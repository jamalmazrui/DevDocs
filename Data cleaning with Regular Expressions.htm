<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Data cleaning with Regular Expressions</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<p>Data cleaning with Regular Expressions</p>
<p>By Christian McDonald. Updated Fall 2018.</p>
<p>NOTE: To work with Regular Expressions, it is very helpful to have a
<a
href="https://docs.google.com/document/d/1vxqW2B0JkRov-V2sRtBSuOHIOdP71WH-5qBFDQvuUY8/edit">​code
editor​</a> that supports</p>
<p>them. While this lesson/session mostly uses <a
href="https://regex101.com/">​regex101.com​,</a> that site can handle only
so much data. In practice, I tend to use regex101 to test my formulas,
then execute them in a code editor.</p>
<p>I use ​<a href="https://code.visualstudio.com/download">VS Code​</a>
for this lesson.</p>
<p>Regular expressions (or regex) is a programming language used to
match patterns in text, so it is VERY useful in cleaning data. This
lesson is just an introduction to a very powerful programming skill.</p>
<p>Key concept: patterns</p>
<p>Let's say you have a list of phone numbers in 10-digit format --
​512-555-1212​ -- but you want the area code to be in parenthesis: ​(512)
555-1212​. You could do a simple search of the 512 area code followed by
a dash ​512-​ and replace it with an area code in parenthesis and a space:
​(512) ​.</p>
<p>But what if there are different area codes in the list?</p>
<p>512-555-1211</p>
<p>301-333-1212</p>
<p>404-123-1213</p>
<p>With regular expressions, you can search for a pattern of characters
and save it as a group. Instead of searching just for ​512-​, you can look
for "three numbers together at the beginning of a line that are then
followed by a dash".</p>
<p>If you save that matching pattern as a group, you can then replace
that group with parenthesis outside it, no matter what the contents of
the group. If that saved group is called ​\1​ then you can replace it with
​(\1) ​ and it doesn't matter if ​\1​ is equal to ​512-​ or ​301-​.</p>
<p>Special characters, commands and escape</p>
<p>Let's touch quickly on the syntax of regular expressions. Don't get
hung up if these sound like</p>
<p>gibberish, because it will make sense more when we start using it.
Your ​<a
href="https://drive.google.com/file/d/0B8ConnGcXrv8MzE3SWtwU2NxQk0/view?usp=sharing">Regex
Cheat Sheet</a>​ (or</p>
<p><a
href="https://drive.google.com/open?id=0B8ConnGcXrv8bnJwdEtWVGx4N0E">this
alternative</a>​) comes in handy here.</p>
<p>Regular expressions use special characters to do special things, like
match the beginning of a line. These commands are called tokens:</p>
<p>● ^​ will find the beginning of a line.</p>
<p>● *​ will find "zero or more" of whatever precedes it.</p>
<p>Regular expressions use the backslash (the one above return on the
keyboard: ​\​) with other characters to create more tokens to do special
things:</p>
<p>● \d​ will find any number character (or digit).</p>
<p>● \D​ will match anything other than a number.</p>
<p>● \t​ is a tab character, because hitting the tab on the keyboard will
perform the action</p>
<p>instead of giving you the character.</p>
<p>But then sometimes, you actually need to find the character ​^​, and
not use it as a command. Regular expressions use the ​\​ to give the
literal expression of a character that would otherwise be a token:</p>
<p>● \*​ will find the asterisk character instead of modifying the query
to find "zero or more".</p>
<p>Enough of that. Let's do this, with the help of ...</p>
<p>Regex101.com</p>
<p><a href="https://regex101.com/">Regex101</a>​ is a great way to not
only build regex patterns, but to also learn how they work. Go ahead and
launch that site in a browser so we can work with it here in a
minute.</p>
<p>We're going to use this site to split some address data into their
parts. Let's talk about the data first.</p>
<p>Splitting Socrata addresses</p>
<p>Many government agencies use ​<a
href="https://opendata.socrata.com/">Socrata</a>​ as their open data
portal: From ​<a href="https://data.austintexas.gov/">Austin​</a> to ​<a
href="https://data.cityofboston.gov/">Boston​;</a> from</p>
<p><a href="https://data.lacity.org/browse">Los Angeles​</a> to ​<a
href="https://nycopendata.socrata.com/">New York​.</a></p>
<p>Some of the data sets in Austin have all the address parts crammed
into a single field. Regex can easily explode that into individual
columns.</p>
<p>Our goal is to turn this:</p>
<p><img src="media/index-2_1.jpeg"
style="width:2.31944in;height:1.59722in" alt="index-2_1.jpg" /></p>
<p>into this:</p>
<p><img src="media/index-3_1.jpeg"
style="width:4.09722in;height:0.76389in" alt="index-3_1.jpg" /></p>
<p>The goal in a nutshell</p>
<p>We are building a pattern in our regular expression field, creating a
group to capture each part of the address that we want to keep. We'll
continue the pattern outside the group until we get to the next part we
want to keep, when we'll create a new group, and so on.</p>
<p>You'll want to reference your <a
href="https://drive.google.com/file/d/0B8ConnGcXrv8MzE3SWtwU2NxQk0/view?usp=sharing">​Regex
Cheat Sheet​</a> (or <a
href="https://drive.google.com/open?id=0B8ConnGcXrv8bnJwdEtWVGx4N0E">​this
alternative​)</a>.</p>
<p>Let's get started:</p>
<p>● View the file <a
href="https://docs.google.com/a/utexas.edu/file/d/0B8ConnGcXrv8UEwybHJEcHJrbTQ/edit">​socrata_addresses.txt</a>​
and copy and paste the contents into the "TEST</p>
<p>STRING" of <a href="https://regex101.com/">​regex101.com​.</a></p>
<p>● Note this is just one column from a larger Socrata data set of ​<a
href="https://data.austintexas.gov/dataset/Restaurant-Inspection-Scores/ecmv-9xxi">restaurant
inspection</a></p>
<p><a
href="https://data.austintexas.gov/dataset/Restaurant-Inspection-Scores/ecmv-9xxi">scores</a>​
in Austin, TX. (When I want to clean a single column of data, I often
download the</p>
<p>data and will just copy out one column into my text editor and work
it before pasting back</p>
<p>the results into Excel, carefully making sure they still line
up.)</p>
<p>● Let's look at our data a little closer:</p>
<p><img src="media/index-3_2.jpeg"
style="width:4.13889in;height:1.13889in" alt="index-3_2.jpg" /></p>
<p>○ Notice the address, city, state, zip, latitude and longitude are
all in the same "cell"</p>
<p>(what is inside the quote marks), but the content of the cell has
returns in it. We want to split these six distinct pieces into their own
columns for each record. Why? Many reasons, but one is to use the
latitude and longitude for data visualizations.</p>
<p>○ We will build a Regular Expression pattern to capture six groups
and then search</p>
<p>and replace to put tabs between each group, so we can put it back
into Excel.</p>
<p>● In regex101, in the right-hand box of the REGULAR EXPRESSION
string, click and add</p>
<p>the modifier "multi line" so it now says " 1 ​ <strong>gm</strong> ​
".</p>
<p>● On the left-hand pane, make sure the 2 ​ <strong>FLAVOR</strong> ​ is
set on "javascript".</p>
<p>1 On the modifier "gm": The "g" is for "global", as in find all
occurrences, not just the first one. ​ The "m" is for "multi-line", which
allows us evaluate each line separately. I almost always use "gm" when
doing search and replace like this.</p>
<p>2 Different programming languages have little differences in how they
handle Regular ​ Expressions. The concepts are the same, but sometimes
the syntax is different. VS Code and Atom use the "javascript" flavor,
so we will use that. TextWrangler and Sublime use this "pcre" flavor.
The main difference I deal with is the replace string, where a "group"
is accessed with "$" in javascript and "/" in php.</p>
<p>Capturing the address</p>
<p>● We know that the first line starts at the beginning of the line, so
we can start with this</p>
<p>token, which signifies that: ​^</p>
<p>● Now, in the end, we don't want to keep the double-quote, so we
won't put it inside a</p>
<p>group. We'll just add it to the pattern: ​^​<strong>"</strong>​.</p>
<p>● Take note for a minute at the number of matches at the top right:
There are 325</p>
<p>matches, and that is how many records we should end up with. You'll
want to keep referring back to that and making sure you have 325
groups.</p>
<p><img src="media/index-4_1.jpeg" style="width:6.5in;height:0.72222in"
alt="index-4_1.jpg" /></p>
<p>● Next, we'll start our first group with parenthesis:
​^"​<strong>()</strong>​. You'll see as you type in the first</p>
<p>parentheses, regex101 ​<em>might</em> ​ also put in the second and then
put your cursor in the middle of them. This is "code completion", and
good code editors do this to help you be more efficient. (If this
doesn't happen for you, please hollar so we can set this up.)</p>
<p>● In this first group, we want the whole address, which is everything
on this line, until the</p>
<p>line ending. The period token ​.​ means "any character", and ​*​ means
"zero or more", so put these together and we get everything:
​^"(​<strong>.*</strong>​)​.</p>
<p>Let's take a minute to explain more about Regex101 and how it helps
you. Each matching group gets a color, and the contents of the match is
shown in MATCH INFORMATION. The EXPLANATION section tells you exactly
how each token is used, and the QUICK REFERENCE section is a list of
tokens you can use, more in depth than the cheat sheet I've started you
with.</p>
<p><img src="media/index-4_2.jpeg" style="width:6.5in;height:3.41667in"
alt="index-4_2.jpg" /></p>
<p>OK .. on with it.</p>
<p>● Before we can start capturing the second group with the city, we
need to add the return</p>
<p>to the pattern so it can start recognizing the next line. But here's
the drive-you-crazy</p>
<p>thing: Windows and Macs treat these differently. On a Mac, ​\n​ is a
"new line". If you are</p>
<p>on a Windows machine, you'll need to use ​\R​. The regex101 editor will
recognize either,</p>
<p>but later when we do the search and replace in your code editor, you
have to use the</p>
<p>character that works with your operating system. This tutorial will
use Macs, so:</p>
<p>^"(.*)​<strong>\n</strong>​.</p>
<p>● (If we end up with PC's in this lab, you'll need to use ​\R​ every
time you see ​\n​ in this</p>
<p>tutorial.)</p>
<p>● Sanity check: This what your screen should look like:</p>
<p><img src="media/index-5_1.jpeg"
style="width:3.97222in;height:3.05556in" alt="index-5_1.jpg" /></p>
<p>Capturing the city</p>
<p>● Now, let's grab the city. As we look through the list, we can see
there is more than</p>
<p>Austin, and some of these names have spaces so we can't find just
letters alone. There</p>
<p>are MANY ways to do this, but we'll do it here by creating a group
first: ​^"(.*)\n​<strong>()</strong>​.</p>
<p>● Then inside the group we'll put a token that looks for word
characters: ​^"(.*)\n(​<strong>\w</strong>​)​.</p>
<p>● Then we'll add the quantifier ​+​ to find "one or more" of what's in
the character set:</p>
<p>^"(.*)\n(\w​<strong>+</strong>​)​.</p>
<p>● Make sure we are capturing all 325 groups. We should be good.</p>
<p>Capturing the state</p>
<p>● These are all the same, all in TX, so we don't really have to save
it at all, but we will.</p>
<p>We'll use this to remind ourselves that you can also just match a
string literally. First we put the comma and space outside the second
group, since we don't want to keep it: ^"(.*)\n(\w+) ​<strong>,</strong>
​.</p>
<p>Catching errors</p>
<p>● Now, take a moment and check how many matching groups we have. Wait
... WHOA ...</p>
<p>we have only 314. What could've gone wrong?</p>
<p>● Scroll down the Test string until you find something amiss. The
colors help you spot</p>
<p>problems easily.</p>
<p><img src="media/index-6_1.jpeg"
style="width:4.40278in;height:3.26389in" alt="index-6_1.jpg" /></p>
<p>● What is the difference between the working lines and the ones that
aren't? Something</p>
<p>about the city.</p>
<p>● BEE CAVE and WEST LAKE HILLS have spaces while AUSTIN and
PFLUGERVILLE</p>
<p>do not. It looks like our city group did not capture a needed space,
which wasn't really revealed until we tried to carry out the pattern
with the ​, ​ that is found after the city. This happens, a lot … we need
to back up and fix the error.</p>
<p>● Right now, our expression is this: ​^"(.*)\n(\w+), ​ and the part
that captures the city</p>
<p>is ​(\w+)​. We need use use something called a "character set" that
allows us to use more than one token within a group. We signify this by
putting what we want inside of square brackets: So we need to put the ​\w​
inside square brackets along with the space so we can catch both:
​^"(.*)\n(​<strong>[\w ]</strong>​+), ​.</p>
<p>Back to the state</p>
<p>● Then we create our third group with TX inside it: ​^"(.*)\n([\w ]+),
​<strong>(TX)</strong>​. We are</p>
<p>looking for the literal text TX because there are no other states in
this data set. We can't skip it because we need the pattern to
continue.</p>
<p>Sanity check. Here is what you should have:</p>
<p><img src="media/index-7_1.jpeg"
style="width:4.63889in;height:4.27778in" alt="index-7_1.jpg" /></p>
<p>Capturing the ZIP</p>
<p>● Again, we don't want to keep the space between the state and ZIP,
so we'll put it outside</p>
<p>the third group, and start our fourth one for ZIP: ​^"(.*)\n([\w ]+),
(TX)​ <strong>()</strong>​.</p>
<p>● All of these zip codes are of the 5-digit variety, so this can be
less complicated than it</p>
<p>would with the 9-digit version. Again, there are many ways to do
this, but we'll use ​\d​ for</p>
<p>the numbers and ​*​ to to capture zero or more of them: ​^"(.*)\n([\w
]+), (TX)</p>
<p>(​<strong>\d*</strong>​)​.</p>
<p>● Complete the pattern for this line with the new line token:
​^"(.*)\n([\w ]+), (TX)</p>
<p>(\d*) ​<strong>\n</strong>​.</p>
<p>● Sanity check: This is where we are …</p>
<p><img src="media/index-8_1.jpeg"
style="width:4.56944in;height:3.02778in" alt="index-8_1.jpg" /></p>
<p>Capturing latitude</p>
<p>● We don't want to keep the parenthesis that starts this last line,
so we'll put it outside a</p>
<p>group. However, since parenthesis mean something special in regex, we
need to escape it with a backslash so it will find the character and not
start the new group: ^"(.*)\n([\w ]+), (TX) (\d*)\n​<strong>\(</strong>​.
Code completion might make this tricky, but you can do it!</p>
<p>● Now we can start our new group, so go ahead and add the beginning
and end</p>
<p>parentheses: ​^"(.*)\n([\w ]+), (TX) (\d*)\n\(​<strong>()</strong>​.</p>
<p>● Inside our fifth group, we need numbers and the decimal point. We
will create a</p>
<p>character set and put inside it ​\d​ for numbers and ​\.​ for the decimal
point, which we have to escape since . means "any character". We finish
it off by using ​+​ to look for one or more of the characters in the set.
Like this:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\((​<strong>[\d\.]+</strong>​)​.</p>
<p>Capturing longitude</p>
<p>● We don't need the comma and space in our next group, so we put it
outside to keep the</p>
<p>pattern going: ​^"(.*)\n([\w ]+), (TX)
(\d*)\n\(([\d\.]+)​<strong>,</strong> ​.</p>
<p>● We can get the longitude like we did latitude, but we have to add
the hyphen to the</p>
<p>character set. So, create the group:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ​<strong>()</strong>​.</p>
<p>● Add the character set:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), (
​<strong>[]</strong>​)​.</p>
<p>● And inside of it, put ​\d​ for digits, ​\-​ for the hyphen and ​\.​ for
the decimal point:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([
​<strong>\d\-\.</strong>​])​.</p>
<p>● Add our quantifier to get one or more:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([\d\-\.]
​<strong>+</strong>​)​.</p>
<p>● Because the trailing parentheses and quote are at the end of a
line, we could ignore</p>
<p>them, but we won't. We'll add them to the end of the pattern,
escaping the close</p>
<p>parentheses just to be sure:</p>
<p>● ^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+),
([\d\-\.]+)​<strong>\)"</strong>​.</p>
<p><img src="media/index-9_1.jpeg" style="width:6.5in;height:2.86111in"
alt="index-9_1.jpg" /></p>
<p>You have it all! 325 matches into 6 different groups.</p>
<p>The substitution string</p>
<p>Now that we have a pattern with our six groups of data, we can
substitute them in any order want using a search and replace, and we can
build our substitution string right here in Regex101 as well.</p>
<p>Underneath our TEST STRING window, you'll see another header called
SUBSTITUTION with a big plus sign on the right side of the window. Click
the plus to expand the substitution window.</p>
<p><img src="media/index-9_2.jpeg" style="width:6.5in;height:0.73611in"
alt="index-9_2.jpg" /></p>
<p>Now we can build a substitution string, and we can see the cleaned
data in the window below.</p>
<p>Our goal with the substitution string is to pull back our six groups,
but to put tabs in between each of them. If we can build a search and
replace like this, then we can paste the result back into Excel, and
each group will become its own column. A quick refresher from our intro:
Once we've built a group, we can reference it in our substitution string
by its order using a backslash before it's order number. So, if we want
to reference our first group, we use this: ​<strong>$1</strong>​. Put that
in the SUBSTITUTION string box, like this:</p>
<p><img src="media/index-10_1.jpeg" style="width:6.5in;height:3.20833in"
alt="index-10_1.jpg" /></p>
<p>● You can see that Regex101 is now pulling back our address.</p>
<p>● We can't just type a tab key after our group because they keyboard
command will move</p>
<p>us to another box, so we use the token for tab, which is ​\t​. So, add
that to the end of our substitution string to get this:
​$1​<strong>\t</strong>​. You'll see space get added into our substitution
example.</p>
<p>● Now we can add our next ordered group to our substitution string
and see our city get</p>
<p>added on: ​$1\t​<strong>$2</strong>​. Here is a sanity check:</p>
<p><img src="media/index-10_2.jpeg" style="width:6.5in;height:3.58333in"
alt="index-10_2.jpg" /></p>
<p>● Now that you see how it works, let's go ahead and add the rest of
the groups, all with</p>
<p>tabs in between them: ​$1\t$2​<strong>\t$3\t$4\t$5\t$6</strong>​. Your
screen might look a little</p>
<p>different than below if the lines start wrapping.</p>
<p><img src="media/index-11_1.jpeg" style="width:6.5in;height:1.31944in"
alt="index-11_1.jpg" /></p>
<p>Now, you might try copy 'n' pasting this result into Excel and see if
it works, and this can work fine for a small data set. But often, I use
regex101 to figure out my patterns, but then use them in my text editor
on a much larger data source. We'll do this so you have the
practice.</p>
<p>You can actually save this in regex101 under SAVE &amp; SHARE in the
far left panel.</p>
<p>My example is saved here: <a
href="https://regex101.com/r/dVFG6T/1/">​https://regex101.com/r/dVFG6T/1/</a></p>
<p>Search and replace in the text editor</p>
<p>We are almost done. Go ahead and launch your text editor if you
haven't already. We'll show this first in VS Code.</p>
<p>● Take your TEST STRING data (not the expression, but the data) and
paste it into a new</p>
<p>next file in your text editor. (Or grab it from the file you
downloaded.)</p>
<p>● Go under the Find menu to "Replace" (or do control-H for PC,
command-option-F for</p>
<p>Mac) to bring up the search window at the bottom of your text
box.</p>
<p>● Copy the Regular Expression pattern you built in Regex101 and
insert into the "Find</p>
<p>what" in Sublime.</p>
<p>● Copy the Substitution pattern and insert it into the Replace field
in "Replace with".</p>
<p>● Click on the button on the far-left of the Find what line, the one
that has ​.*​ in it.</p>
<p>● Check the fourth box with a circle symbol, which is "Wrap around",
which is the same as</p>
<p>"multi line" that we choose when we started in regex101.</p>
<p>Here is what the search and replace screen looks like:</p>
<p><img src="media/index-12_1.jpeg" style="width:6.5in;height:2.20833in"
alt="index-12_1.jpg" /></p>
<p>● Now, hit the "Replace All" button and watch the magic happen.</p>
<p>● Once you run the search and replace, you can copy and paste the
results into a</p>
<p>spreadsheet and it will be six distinct columns. (If it doesn't,
hollar.)</p>
<p><img src="media/index-12_2.jpeg"
style="width:4.68056in;height:1.55556in" alt="index-12_2.jpg" /></p>
<p>Other text editors</p>
<p>The search and replace functions are a little different in other text
editors:</p>
<p>Atom text editor</p>
<p>Atom uses JavaScript notation instead of PCRE, so you have to use ​$1​
instead of ​\1​ on the replace strings:</p>
<p><img src="media/index-12_3.jpeg" style="width:6.5in;height:1.375in"
alt="index-12_3.jpg" /></p>
<p>Sublime Text</p>
<p>Sublime Text and Text Wrangler below use the "pcre (php)" flavor of
regex, with means the replace groups use ​/1​ to signify group
replacement.</p>
<p><img src="media/index-13_1.jpeg" style="width:6.5in;height:1.77778in"
alt="index-13_1.jpg" /></p>
<p>Text Wrangler</p>
<p><img src="media/index-13_2.jpeg" style="width:6.5in;height:2.125in"
alt="index-13_2.jpg" /></p>
<p>NotePad++</p>
<p>Windows PCs sometimes handle the token for returns a little
differently, using ​\R​ for a return instead of ​\n​. Regex101 understands
both, but sometimes Notepad++ wants that ​\R​. So here is the search
window for NotePad++:</p>
<p><img src="media/index-14_1.jpeg"
style="width:6.45833in;height:4.15278in" alt="index-14_1.jpg" /></p>
<p>More Regex</p>
<p>There are lots of sites and tutorials on regular expressions, but</p>
<p><a
href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a>​
is one of my favorites.</p>
<p>And remember, if you are stumped by something, chances are you are
not the first. Google and Stack Overflow are your friends.</p>
</body>
</html>
