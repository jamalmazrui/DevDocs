HTML


Living Standard — Last Updated 15 December 2020

One-Page Version Multipage Version

html.spec.whatwg.org /multipage

Developer Version PDF Version

/dev /print.pdf

Translations FAQ

日本語 • 简体中文 on GitHub

Join us on IRC Contribute on GitHub

#whatwg on Freenode whatwg/html repository

Commits Snapshot

on GitHub as of this commit

Twitter Updates Open Issues

@htmlstandard filed on GitHub

Open an Issue Tests

whatwg.org/newbug web-platform-tests html/

Issues for Tests

ongoing work





Table of contents


1 Introduction ............................................................................................................................................................................ 1

2 Common infrastructure........................................................................................................................................................... 2

3 Semantics, structure, and APIs of HTML documents............................................................................................................... 3

4 The elements of HTML ............................................................................................................................................................ 4

5 Microdata.............................................................................................................................................................................. 12

6 User interaction .................................................................................................................................................................... 12

7 Loading web pages............................................................................................................................................................... 13

8 Web application APIs ............................................................................................................................................................ 15

9 Communication .................................................................................................................................................................... 16

10 Web workers ....................................................................................................................................................................... 17

11 Worklets.............................................................................................................................................................................. 17

12 Web storage ....................................................................................................................................................................... 18

13 The HTML syntax ................................................................................................................................................................ 18

14 The XML syntax .................................................................................................................................................................. 21

15 Rendering ........................................................................................................................................................................... 21

16 Obsolete features ............................................................................................................................................................... 22

17 IANA considerations............................................................................................................................................................ 22

Index........................................................................................................................................................................................ 23

References............................................................................................................................................................................... 23

Acknowledgments ................................................................................................................................................................... 23

Intellectual property rights ...................................................................................................................................................... 23



Full table of contents

1 Introduction .......................................................................................................................................................................... 24

1.1 Where does this specification fit?.................................................................................................................. 24

1.2 Is this HTML5? ............................................................................................................................................... 24

1.3 Background ................................................................................................................................................... 25

1.4 Audience ....................................................................................................................................................... 25

1





1.5 Scope ............................................................................................................................................................ 25


1.6 History........................................................................................................................................................... 25

1.7 Design notes ................................................................................................................................................. 26

1.7.1 Serializability of script execution ........................................................................................... 27

1.7.2 Compliance with other specifications .................................................................................... 27

1.7.3 Extensibility ........................................................................................................................... 27

1.8 HTML vs XML syntax ..................................................................................................................................... 28

1.9 Structure of this specification........................................................................................................................ 28

1.9.1 How to read this specification................................................................................................ 29

1.9.2 Typographic conventions ....................................................................................................... 29

1.10 A quick introduction to HTML ...................................................................................................................... 30

1.10.1 Writing secure applications with HTML ................................................................................ 33

1.10.2 Common pitfalls to avoid when using the scripting APIs ..................................................... 34

1.10.3 How to catch mistakes when writing HTML: validators and conformance checkers............. 35

1.11 Conformance requirements for authors ...................................................................................................... 35

1.11.1 Presentational markup......................................................................................................... 35

1.11.2 Syntax errors ....................................................................................................................... 36

1.11.3 Restrictions on content models and on attribute values...................................................... 38

1.12 Suggested reading ...................................................................................................................................... 41



2 Common infrastructure......................................................................................................................................................... 42

2.1 Terminology................................................................................................................................................... 42

2.1.1 Parallelism ............................................................................................................................. 42

2.1.2 Resources .............................................................................................................................. 43

2.1.3 XML compatibility .................................................................................................................. 44

2.1.4 DOM trees.............................................................................................................................. 44

2.1.5 Scripting ................................................................................................................................ 45

2.1.6 Plugins ................................................................................................................................... 45

2.1.7 Character encodings.............................................................................................................. 46

2.1.8 Conformance classes ............................................................................................................. 46

2.1.9 Dependencies ........................................................................................................................ 49

2.1.10 Extensibility ......................................................................................................................... 65

2.1.11 Interactions with XPath and XSLT......................................................................................... 66

2.2 String comparison ......................................................................................................................................... 67

2.3 Policy-controlled features .............................................................................................................................. 67

2.4 Common microsyntaxes................................................................................................................................ 67

2.4.1 Common parser idioms.......................................................................................................... 67

2.4.2 Boolean attributes ................................................................................................................. 67

2.4.3 Keywords and enumerated attributes.................................................................................... 68

2.4.4 Numbers ................................................................................................................................ 68

2.4.4.1 Signed integers .............................................................................................. 68

2.4.4.2 Non-negative integers.................................................................................... 69

2.4.4.3 Floating-point numbers .................................................................................. 69

2.4.4.4 Percentages and lengths ................................................................................ 71

2.4.4.5 Non-zero percentages and lengths................................................................. 72

2.4.4.6 Lists of floating-point numbers....................................................................... 72

2.4.4.7 Lists of dimensions......................................................................................... 73

2.4.5 Dates and times..................................................................................................................... 73

2.4.5.1 Months ........................................................................................................... 74

2.4.5.2 Dates.............................................................................................................. 75

2





2.4.5.3 Yearless dates ................................................................................................ 75


2.4.5.4 Times.............................................................................................................. 76

2.4.5.5 Local dates and times .................................................................................... 77

2.4.5.6 Time zones ..................................................................................................... 78

2.4.5.7 Global dates and times .................................................................................. 79

2.4.5.8 Weeks............................................................................................................. 81

2.4.5.9 Durations........................................................................................................ 82

2.4.5.10 Vaguer moments in time .............................................................................. 85

2.4.6 Colors .................................................................................................................................... 85

2.4.7 Space-separated tokens ........................................................................................................ 87

2.4.8 Comma-separated tokens...................................................................................................... 87

2.4.9 References............................................................................................................................. 88

2.4.10 Media queries ...................................................................................................................... 88

2.5 URLs .............................................................................................................................................................. 88

2.5.1 Terminology ........................................................................................................................... 88

2.5.2 Parsing URLs .......................................................................................................................... 89

2.5.3 Dynamic changes to base URLs............................................................................................. 89

2.6 Fetching resources ........................................................................................................................................ 90

2.6.1 Terminology ........................................................................................................................... 90

2.6.2 Determining the type of a resource ....................................................................................... 90

2.6.3 Extracting character encodings from meta elements............................................................. 90

2.6.4 CORS settings attributes........................................................................................................ 91

2.6.5 Referrer policy attributes ....................................................................................................... 92

2.6.6 Nonce attributes .................................................................................................................... 92

2.6.7 Lazy loading attributes .......................................................................................................... 93

2.7 Common DOM interfaces .............................................................................................................................. 95

2.7.1 Reflecting content attributes in IDL attributes ....................................................................... 95

2.7.2 Collections ............................................................................................................................. 96

2.7.2.1 The HTMLAllCollection interface................................................................. 96

2.7.2.1.1 [[Call]] ( thisArgument, argumentsList ) ................................. 98

2.7.2.2 The HTMLFormControlsCollection interface................................................ 99

2.7.2.3 The HTMLOptionsCollection interface ....................................................... 100

2.7.3 The DOMStringList interface.............................................................................................. 102

2.8 Safe passing of structured data .................................................................................................................. 103

2.8.1 Serializable objects .............................................................................................................. 103

2.8.2 Transferable objects............................................................................................................. 104

2.8.3 StructuredSerializeInternal ( value, forStorage [ , memory ] ) ............................................. 105

2.8.4 StructuredSerialize ( value ) ................................................................................................ 108

2.8.5 StructuredSerializeForStorage ( value ) ............................................................................... 108

2.8.6 StructuredDeserialize ( serialized, targetRealm [ , memory ] )............................................ 108

2.8.7 StructuredSerializeWithTransfer ( value, transferList )......................................................... 111

2.8.8 StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm )................. 112

2.8.9 Performing serialization and transferring from other specifications .................................... 113



3 Semantics, structure, and APIs of HTML documents........................................................................................................... 115

3.1 Documents.................................................................................................................................................. 115

3.1.1 The Document object............................................................................................................ 115

3.1.2 The DocumentOrShadowRoot interface................................................................................. 116

3.1.3 Resource metadata management........................................................................................ 116

3.1.4 DOM tree accessors ............................................................................................................. 118

3.2 Elements ..................................................................................................................................................... 122

3





3.2.1 Semantics ............................................................................................................................ 122


3.2.2 Elements in the DOM ........................................................................................................... 124

3.2.3 HTML element constructors ................................................................................................. 126

3.2.4 Element definitions .............................................................................................................. 129

3.2.4.1 Attributes ..................................................................................................... 130

3.2.5 Content models ................................................................................................................... 130

3.2.5.1 The "nothing" content model ....................................................................... 131

3.2.5.2 Kinds of content ........................................................................................... 131

3.2.5.2.1 Metadata content ................................................................. 132

3.2.5.2.2 Flow content ......................................................................... 132

3.2.5.2.3 Sectioning content ................................................................ 132

3.2.5.2.4 Heading content ................................................................... 133

3.2.5.2.5 Phrasing content................................................................... 133

3.2.5.2.6 Embedded content ............................................................... 133

3.2.5.2.7 Interactive content ............................................................... 133

3.2.5.2.8 Palpable content ................................................................... 134

3.2.5.2.9 Script-supporting elements................................................... 134

3.2.5.3 Transparent content models......................................................................... 134

3.2.5.4 Paragraphs ................................................................................................... 135

3.2.6 Global attributes .................................................................................................................. 137

3.2.6.1 The title attribute...................................................................................... 140

3.2.6.2 The lang and xml:lang attributes ............................................................... 141

3.2.6.3 The translate attribute .............................................................................. 142

3.2.6.4 The dir attribute.......................................................................................... 143

3.2.6.5 The style attribute...................................................................................... 145

3.2.6.6 Embedding custom non-visible data with the data-* attributes.................. 146

3.2.7 The innerText getter and setter......................................................................................... 149

3.2.8 Requirements relating to the bidirectional algorithm .......................................................... 151

3.2.8.1 Authoring conformance criteria for bidirectional-algorithm formatting

characters ................................................................................................................ 151

3.2.8.2 User agent conformance criteria .................................................................. 151

3.2.9 Requirements related to ARIA and to platform accessibility APIs......................................... 152



4 The elements of HTML ........................................................................................................................................................ 153

4.1 The document element ............................................................................................................................... 153

4.1.1 The html element ................................................................................................................ 153

4.2 Document metadata ................................................................................................................................... 154

4.2.1 The head element ................................................................................................................ 154

4.2.2 The title element .............................................................................................................. 155

4.2.3 The base element ................................................................................................................ 156

4.2.4 The link element ................................................................................................................ 158

4.2.4.1 Processing the media attribute..................................................................... 162

4.2.4.2 Processing the type attribute....................................................................... 163

4.2.4.3 Fetching and processing a resource from a link element ........................... 163

4.2.4.4 Processing `Link` headers........................................................................... 164

4.2.4.5 Providing users with a means to follow hyperlinks created using the link

element .................................................................................................................... 165

4.2.5 The meta element ................................................................................................................ 165

4.2.5.1 Standard metadata names........................................................................... 166

4.2.5.2 Other metadata names ................................................................................ 170

4.2.5.3 Pragma directives......................................................................................... 171

4.2.5.4 Specifying the document's character encoding............................................ 174

4.2.6 The style element .............................................................................................................. 175

4.2.7 Interactions of styling and scripting..................................................................................... 178

4

4.3 Sections ...................................................................................................................................................... 179

4.3.1 The body element ................................................................................................................ 179

4.3.2 The article element .......................................................................................................... 181

4.3.3 The section element .......................................................................................................... 183

4.3.4 The nav element.................................................................................................................. 186

4.3.5 The aside element .............................................................................................................. 189

4.3.6 The h1, h2, h3, h4, h5, and h6 elements .............................................................................. 191

4.3.7 The hgroup element ............................................................................................................ 193

4.3.8 The header element ............................................................................................................ 195

4.3.9 The footer element ............................................................................................................ 196

4.3.10 The address element ........................................................................................................ 199

4.3.11 Headings and sections....................................................................................................... 200

4.3.11.1 Creating an outline..................................................................................... 202

4.3.11.2 Sample outlines.......................................................................................... 206

4.3.11.3 Exposing outlines to users ......................................................................... 211

4.3.12 Usage summary................................................................................................................. 211

4.3.12.1 Article or section?....................................................................................... 213

4.4 Grouping content ........................................................................................................................................ 213

4.4.1 The p element...................................................................................................................... 213

4.4.2 The hr element.................................................................................................................... 215

4.4.3 The pre element.................................................................................................................. 217

4.4.4 The blockquote element..................................................................................................... 219

4.4.5 The ol element.................................................................................................................... 222

4.4.6 The ul element.................................................................................................................... 223

4.4.7 The menu element ................................................................................................................ 224

4.4.8 The li element.................................................................................................................... 225

4.4.9 The dl element.................................................................................................................... 228

4.4.10 The dt element.................................................................................................................. 231

4.4.11 The dd element.................................................................................................................. 232

4.4.12 The figure element .......................................................................................................... 233

4.4.13 The figcaption element................................................................................................... 236

4.4.14 The main element .............................................................................................................. 237

4.4.15 The div element................................................................................................................ 238

4.5 Text-level semantics.................................................................................................................................... 239

4.5.1 The a element...................................................................................................................... 239

4.5.2 The em element.................................................................................................................... 242

4.5.3 The strong element ............................................................................................................ 243

4.5.4 The small element .............................................................................................................. 245

4.5.5 The s element...................................................................................................................... 246

4.5.6 The cite element ................................................................................................................ 247

4.5.7 The q element...................................................................................................................... 248

4.5.8 The dfn element.................................................................................................................. 250

4.5.9 The abbr element ................................................................................................................ 251

4.5.10 The ruby element .............................................................................................................. 253

4.5.11 The rt element.................................................................................................................. 259

4.5.12 The rp element.................................................................................................................. 259

4.5.13 The data element .............................................................................................................. 260

4.5.14 The time element .............................................................................................................. 261

4.5.15 The code element .............................................................................................................. 268

4.5.16 The var element................................................................................................................ 269

5

4.5.17 The samp element .............................................................................................................. 270

4.5.18 The kbd element................................................................................................................ 271

4.5.19 The sub and sup elements................................................................................................. 272

4.5.20 The i element.................................................................................................................... 273

4.5.21 The b element.................................................................................................................... 274

4.5.22 The u element.................................................................................................................... 276

4.5.23 The mark element .............................................................................................................. 276

4.5.24 The bdi element................................................................................................................ 279

4.5.25 The bdo element................................................................................................................ 280

4.5.26 The span element .............................................................................................................. 280

4.5.27 The br element.................................................................................................................. 281

4.5.28 The wbr element................................................................................................................ 282

4.5.29 Usage summary................................................................................................................. 283

4.6 Links............................................................................................................................................................ 284

4.6.1 Introduction ......................................................................................................................... 284

4.6.2 Links created by a and area elements ................................................................................ 285

4.6.3 API for a and area elements ................................................................................................ 285

4.6.4 Following hyperlinks ............................................................................................................ 290

4.6.5 Downloading resources........................................................................................................ 291

4.6.5.1 Hyperlink auditing ........................................................................................ 294

4.6.6 Link types ............................................................................................................................ 295

4.6.6.1 Link type "alternate" ................................................................................. 296

4.6.6.2 Link type "author" ....................................................................................... 298

4.6.6.3 Link type "bookmark" ................................................................................... 298

4.6.6.4 Link type "canonical" ................................................................................. 298

4.6.6.5 Link type "dns-prefetch"............................................................................ 299

4.6.6.6 Link type "external" ................................................................................... 299

4.6.6.7 Link type "help" ........................................................................................... 299

4.6.6.8 Link type "icon" ........................................................................................... 299

4.6.6.9 Link type "license" ..................................................................................... 301

4.6.6.10 Link type "manifest" ................................................................................. 302

4.6.6.11 Link type "modulepreload" ........................................................................ 302

4.6.6.12 Link type "nofollow" ................................................................................. 304

4.6.6.13 Link type "noopener" ................................................................................. 304

4.6.6.14 Link type "noreferrer".............................................................................. 305

4.6.6.15 Link type "opener" ..................................................................................... 305

4.6.6.16 Link type "pingback" ................................................................................. 305

4.6.6.17 Link type "preconnect".............................................................................. 305

4.6.6.18 Link type "prefetch" ................................................................................. 306

4.6.6.19 Link type "preload" ................................................................................... 306

4.6.6.20 Link type "prerender" ............................................................................... 306

4.6.6.21 Link type "search" ..................................................................................... 306

4.6.6.22 Link type "stylesheet".............................................................................. 307

4.6.6.23 Link type "tag"........................................................................................... 309

4.6.6.24 Sequential link types .................................................................................. 310

4.6.6.24.1 Link type "next" ................................................................. 310

4.6.6.24.2 Link type "prev" ................................................................. 310

4.6.6.25 Other link types.......................................................................................... 310

4.7 Edits ............................................................................................................................................................ 312

4.7.1 The ins element.................................................................................................................. 312

4.7.2 The del element.................................................................................................................. 313

4.7.3 Attributes common to ins and del elements ...................................................................... 314

4.7.4 Edits and paragraphs........................................................................................................... 315

6

4.7.5 Edits and lists ...................................................................................................................... 316

4.7.6 Edits and tables ................................................................................................................... 316

4.8 Embedded content...................................................................................................................................... 317

4.8.1 The picture element .......................................................................................................... 317

4.8.2 The source element ............................................................................................................ 318

4.8.3 The img element.................................................................................................................. 321

4.8.4 Images................................................................................................................................. 329

4.8.4.1 Introduction.................................................................................................. 329

4.8.4.1.1 Adaptive images ................................................................... 334

4.8.4.2 Attributes common to source, img, and link elements .............................. 336

4.8.4.2.1 Srcset attributes ................................................................... 336

4.8.4.2.2 Sizes attributes ..................................................................... 336

4.8.4.3 Processing model ......................................................................................... 337

4.8.4.3.1 When to obtain images ......................................................... 338

4.8.4.3.2 Reacting to DOM mutations .................................................. 338

4.8.4.3.3 The list of available images .................................................. 339

4.8.4.3.4 Decoding images .................................................................. 339

4.8.4.3.5 Updating the image data ...................................................... 340

4.8.4.3.6 Selecting an image source.................................................... 343

4.8.4.3.7 Updating the source set........................................................ 344

4.8.4.3.8 Parsing a srcset attribute ...................................................... 345

4.8.4.3.9 Parsing a sizes attribute........................................................ 347

4.8.4.3.10 Normalizing the source densities ........................................ 347

4.8.4.3.11 Reacting to environment changes ...................................... 348

4.8.4.4 Requirements for providing text to act as an alternative for images ........... 349

4.8.4.4.1 General guidelines ................................................................ 349

4.8.4.4.2 A link or button containing nothing but the image ............... 349

4.8.4.4.3 A phrase or paragraph with an alternative graphical

representation: charts, diagrams, graphs, maps, illustrations ............. 350

4.8.4.4.4 A short phrase or label with an alternative graphical

representation: icons, logos................................................................. 351

4.8.4.4.5 Text that has been rendered to a graphic for typographical

effect ................................................................................................... 353

4.8.4.4.6 A graphical representation of some of the surrounding text. 353

4.8.4.4.7 Ancillary images ................................................................... 355

4.8.4.4.8 A purely decorative image that doesn't add any

information .......................................................................................... 356

4.8.4.4.9 A group of images that form a single larger picture with no

links ..................................................................................................... 356

4.8.4.4.10 A group of images that form a single larger picture with

links ..................................................................................................... 356

4.8.4.4.11 A key part of the content .................................................... 357

4.8.4.4.12 An image not intended for the user .................................... 360

4.8.4.4.13 An image in an email or private document intended for a

specific person who is known to be able to view images ..................... 360

4.8.4.4.14 Guidance for markup generators ........................................ 361

4.8.4.4.15 Guidance for conformance checkers................................... 361

4.8.5 The iframe element ............................................................................................................ 362

4.8.6 The embed element .............................................................................................................. 369

4.8.7 The object element ............................................................................................................ 373

4.8.8 The param element .............................................................................................................. 379

4.8.9 The video element .............................................................................................................. 380

4.8.10 The audio element ............................................................................................................ 384

4.8.11 The track element ............................................................................................................ 385

4.8.12 Media elements ................................................................................................................. 388

4.8.12.1 Error codes ................................................................................................. 389

4.8.12.2 Location of the media resource .................................................................. 390

4.8.12.3 MIME types ................................................................................................. 391

7

4.8.12.4 Network states ........................................................................................... 392

4.8.12.5 Loading the media resource ....................................................................... 393

4.8.12.6 Offsets into the media resource ................................................................. 403

4.8.12.7 Ready states............................................................................................... 406

4.8.12.8 Playing the media resource ........................................................................ 408

4.8.12.9 Seeking ...................................................................................................... 415

4.8.12.10 Media resources with multiple media tracks ............................................ 417

4.8.12.10.1 AudioTrackList and VideoTrackList objects ................ 418

4.8.12.10.2 Selecting specific audio and video tracks declaratively .... 422

4.8.12.11 Timed text tracks ..................................................................................... 422

4.8.12.11.1 Text track model ............................................................... 422

4.8.12.11.2 Sourcing in-band text tracks ............................................. 425

4.8.12.11.3 Sourcing out-of-band text tracks....................................... 426

4.8.12.11.4 Guidelines for exposing cues in various formats as text track

cues ..................................................................................................... 429

4.8.12.11.5 Text track API .................................................................... 429

4.8.12.11.6 Event handlers for objects of the text track APIs .............. 435

4.8.12.11.7 Best practices for metadata text tracks............................ 435

4.8.12.12 Identifying a track kind through a URL ..................................................... 437

4.8.12.13 User interface........................................................................................... 437

4.8.12.14 Time ranges ............................................................................................. 438

4.8.12.15 The TrackEvent interface ........................................................................ 439

4.8.12.16 Events summary ...................................................................................... 440

4.8.12.17 Security and privacy considerations......................................................... 442

4.8.12.18 Best practices for authors using media elements .................................... 442

4.8.12.19 Best practices for implementers of media elements ................................ 442

4.8.13 The map element................................................................................................................ 443

4.8.14 The area element .............................................................................................................. 444

4.8.15 Image maps ....................................................................................................................... 446

4.8.15.1 Authoring ................................................................................................... 446

4.8.15.2 Processing model ....................................................................................... 447

4.8.16 MathML .............................................................................................................................. 449

4.8.17 SVG.................................................................................................................................... 450

4.8.18 Dimension attributes ......................................................................................................... 450

4.9 Tabular data ................................................................................................................................................ 451

4.9.1 The table element .............................................................................................................. 451

4.9.1.1 Techniques for describing tables .................................................................. 456

4.9.1.2 Techniques for table design.......................................................................... 459

4.9.2 The caption element .......................................................................................................... 459

4.9.3 The colgroup element ........................................................................................................ 460

4.9.4 The col element.................................................................................................................. 461

4.9.5 The tbody element .............................................................................................................. 462

4.9.6 The thead element .............................................................................................................. 463

4.9.7 The tfoot element .............................................................................................................. 464

4.9.8 The tr element.................................................................................................................... 465

4.9.9 The td element.................................................................................................................... 466

4.9.10 The th element.................................................................................................................. 468

4.9.11 Attributes common to td and th elements........................................................................ 470

4.9.12 Processing model............................................................................................................... 471

4.9.12.1 Forming a table .......................................................................................... 471

4.9.12.2 Forming relationships between data cells and header cells ....................... 474

4.9.13 Examples ........................................................................................................................... 476

4.10 Forms ........................................................................................................................................................ 479

4.10.1 Introduction ....................................................................................................................... 479

8

4.10.1.1 Writing a form's user interface ................................................................... 479

4.10.1.2 Implementing the server-side processing for a form .................................. 481

4.10.1.3 Configuring a form to communicate with a server ..................................... 482

4.10.1.4 Client-side form validation ......................................................................... 483

4.10.1.5 Enabling client-side automatic filling of form controls................................ 484

4.10.1.6 Improving the user experience on mobile devices ..................................... 484

4.10.1.7 The difference between the field type, the autofill field name, and the input

modality ................................................................................................................... 485

4.10.1.8 Date, time, and number formats ................................................................ 486

4.10.2 Categories ......................................................................................................................... 487

4.10.3 The form element .............................................................................................................. 487

4.10.4 The label element ............................................................................................................ 491

4.10.5 The input element ............................................................................................................ 494

4.10.5.1 States of the type attribute ....................................................................... 500

4.10.5.1.1 Hidden state (type=hidden) ............................................... 500

4.10.5.1.2 Text (type=text) state and Search state (type=search).... 500

4.10.5.1.3 Telephone state (type=tel) ................................................ 501

4.10.5.1.4 URL state (type=url).......................................................... 502

4.10.5.1.5 Email state (type=email) ................................................... 503

4.10.5.1.6 Password state (type=password)........................................ 504

4.10.5.1.7 Date state (type=date) ...................................................... 505

4.10.5.1.8 Month state (type=month) .................................................. 506

4.10.5.1.9 Week state (type=week) ..................................................... 507

4.10.5.1.10 Time state (type=time) .................................................... 508

4.10.5.1.11 Local Date and Time state (type=datetime-local)......... 509

4.10.5.1.12 Number state (type=number)............................................ 510

4.10.5.1.13 Range state (type=range) ................................................ 511

4.10.5.1.14 Color state (type=color).................................................. 514

4.10.5.1.15 Checkbox state (type=checkbox) ..................................... 514

4.10.5.1.16 Radio Button state (type=radio)...................................... 515

4.10.5.1.17 File Upload state (type=file)........................................... 516

4.10.5.1.18 Submit Button state (type=submit) ................................. 519

4.10.5.1.19 Image Button state (type=image)..................................... 519

4.10.5.1.20 Reset Button state (type=reset)...................................... 521

4.10.5.1.21 Button state (type=button).............................................. 522

4.10.5.2 Implementation notes regarding localization of form controls ................... 522

4.10.5.3 Common input element attributes ............................................................ 522

4.10.5.3.1 The maxlength and minlength attributes .......................... 523

4.10.5.3.2 The size attribute .............................................................. 523

4.10.5.3.3 The readonly attribute....................................................... 523

4.10.5.3.4 The required attribute....................................................... 524

4.10.5.3.5 The multiple attribute....................................................... 525

4.10.5.3.6 The pattern attribute......................................................... 526

4.10.5.3.7 The min and max attributes ................................................. 527

4.10.5.3.8 The step attribute .............................................................. 528

4.10.5.3.9 The list attribute .............................................................. 529

4.10.5.3.10 The placeholder attribute ............................................... 531

4.10.5.4 Common input element APIs..................................................................... 532

4.10.5.5 Common event behaviors .......................................................................... 535

4.10.6 The button element .......................................................................................................... 536

4.10.7 The select element .......................................................................................................... 538

4.10.8 The datalist element ...................................................................................................... 544

4.10.9 The optgroup element ...................................................................................................... 545

4.10.10 The option element ........................................................................................................ 546

4.10.11 The textarea element .................................................................................................... 549

4.10.12 The output element ........................................................................................................ 554

4.10.13 The progress element .................................................................................................... 556

4.10.14 The meter element .......................................................................................................... 558

9

4.10.15 The fieldset element .................................................................................................... 563

4.10.16 The legend element ........................................................................................................ 566

4.10.17 Form control infrastructure .............................................................................................. 567

4.10.17.1 A form control's value .............................................................................. 567

4.10.17.2 Mutability ................................................................................................. 567

4.10.17.3 Association of controls and forms ............................................................ 567

4.10.18 Attributes common to form controls ................................................................................ 569

4.10.18.1 Naming form controls: the name attribute ................................................ 569

4.10.18.2 Submitting element directionality: the dirname attribute ........................ 570

4.10.18.3 Limiting user input length: the maxlength attribute ................................ 570

4.10.18.4 Setting minimum input length requirements: the minlength attribute.... 570

4.10.18.5 Enabling and disabling form controls: the disabled attribute ................. 571

4.10.18.6 Form submission attributes ...................................................................... 571

4.10.18.7 Autofill...................................................................................................... 574

4.10.18.7.1 Autofilling form controls: the autocomplete attribute ...... 574

4.10.18.7.2 Processing model.............................................................. 580

4.10.19 APIs for the text control selections .................................................................................. 586

4.10.20 Constraints ...................................................................................................................... 591

4.10.20.1 Definitions ................................................................................................ 591

4.10.20.2 Constraint validation ................................................................................ 592

4.10.20.3 The constraint validation API.................................................................... 593

4.10.20.4 Security .................................................................................................... 596

4.10.21 Form submission.............................................................................................................. 596

4.10.21.1 Introduction.............................................................................................. 596

4.10.21.2 Implicit submission................................................................................... 597

4.10.21.3 Form submission algorithm ...................................................................... 597

4.10.21.4 Constructing the entry list........................................................................ 600

4.10.21.5 Selecting a form submission encoding ..................................................... 602

4.10.21.6 URL-encoded form data............................................................................ 603

4.10.21.7 Multipart form data .................................................................................. 603

4.10.21.8 Plain text form data.................................................................................. 603

4.10.21.9 The SubmitEvent interface ...................................................................... 604

4.10.21.10 The FormDataEvent interface ................................................................ 604

4.10.22 Resetting a form .............................................................................................................. 604

4.11 Interactive elements ................................................................................................................................. 605

4.11.1 The details element ........................................................................................................ 605

4.11.2 The summary element ........................................................................................................ 608

4.11.3 Commands......................................................................................................................... 608

4.11.3.1 Facets ......................................................................................................... 608

4.11.3.2 Using the a element to define a command ................................................ 609

4.11.3.3 Using the button element to define a command ....................................... 609

4.11.3.4 Using the input element to define a command ......................................... 609

4.11.3.5 Using the option element to define a command ....................................... 610

4.11.3.6 Using the accesskey attribute on a legend element to define a

command ................................................................................................................. 610

4.11.3.7 Using the accesskey attribute to define a command on other elements... 611

4.11.4 The dialog element .......................................................................................................... 611

4.12 Scripting.................................................................................................................................................... 614

4.12.1 The script element .......................................................................................................... 614

4.12.1.1 Processing model ....................................................................................... 620

4.12.1.2 Scripting languages.................................................................................... 625

4.12.1.3 Restrictions for contents of script elements ............................................ 625

4.12.1.4 Inline documentation for external scripts................................................... 627

4.12.1.5 Interaction of script elements and XSLT .................................................. 628

10

4.12.2 The noscript element ...................................................................................................... 628

4.12.3 The template element ...................................................................................................... 630

4.12.3.1 Interaction of template elements with XSLT and XPath ............................. 633

4.12.4 The slot element .............................................................................................................. 633

4.12.5 The canvas element .......................................................................................................... 635

4.12.5.1 The 2D rendering context........................................................................... 639

4.12.5.1.1 Implementation notes......................................................... 646

4.12.5.1.2 The canvas state................................................................. 646

4.12.5.1.3 Line styles........................................................................... 647

4.12.5.1.4 Text styles ........................................................................... 651

4.12.5.1.5 Building paths ..................................................................... 655

4.12.5.1.6 Path2D objects.................................................................... 660

4.12.5.1.7 Transformations .................................................................. 660

4.12.5.1.8 Image sources for 2D rendering contexts ........................... 662

4.12.5.1.9 Fill and stroke styles ........................................................... 664

4.12.5.1.10 Drawing rectangles to the bitmap .................................... 667

4.12.5.1.11 Drawing text to the bitmap............................................... 668

4.12.5.1.12 Drawing paths to the canvas ............................................ 670

4.12.5.1.13 Drawing focus rings and scrolling paths into view ............ 673

4.12.5.1.14 Drawing images ................................................................ 674

4.12.5.1.15 Pixel manipulation ............................................................ 676

4.12.5.1.16 Compositing...................................................................... 680

4.12.5.1.17 Image smoothing .............................................................. 680

4.12.5.1.18 Shadows ........................................................................... 681

4.12.5.1.19 Filters ................................................................................ 682

4.12.5.1.20 Working with externally-defined SVG filters...................... 683

4.12.5.1.21 Drawing model.................................................................. 683

4.12.5.1.22 Best practices ................................................................... 683

4.12.5.1.23 Examples .......................................................................... 684

4.12.5.2 The ImageBitmap rendering context .......................................................... 688

4.12.5.2.1 Introduction ........................................................................ 688

4.12.5.2.2 The ImageBitmapRenderingContext interface .................. 688

4.12.5.3 The OffscreenCanvas interface................................................................. 690

4.12.5.3.1 The offscreen 2D rendering context.................................... 694

4.12.5.4 Color spaces and color correction .............................................................. 695

4.12.5.5 Serializing bitmaps to a file ........................................................................ 696

4.12.5.6 Security with canvas elements .................................................................. 696

4.13 Custom elements ...................................................................................................................................... 697

4.13.1 Introduction ....................................................................................................................... 697

4.13.1.1 Creating an autonomous custom element ................................................. 697

4.13.1.2 Creating a form-associated custom element.............................................. 698

4.13.1.3 Creating a custom element with default accessible roles, states, and

properties................................................................................................................. 699

4.13.1.4 Creating a customized built-in element...................................................... 700

4.13.1.5 Drawbacks of autonomous custom elements............................................. 701

4.13.1.6 Upgrading elements after their creation .................................................... 703

4.13.2 Requirements for custom element constructors and reactions.......................................... 704

4.13.3 Core concepts .................................................................................................................... 705

4.13.4 The CustomElementRegistry interface............................................................................. 708

4.13.5 Upgrades ........................................................................................................................... 711

4.13.6 Custom element reactions................................................................................................. 713

4.13.7 Element internals............................................................................................................... 716

4.13.7.1 The ElementInternals interface............................................................... 717

4.13.7.2 Shadow root access.................................................................................... 718

4.13.7.3 Form-associated custom elements............................................................. 718

4.13.7.4 Accessibility semantics .............................................................................. 720

4.14 Common idioms without dedicated elements ........................................................................................... 720

11





4.14.1 Bread crumb navigation .................................................................................................... 720


4.14.2 Tag clouds .......................................................................................................................... 721

4.14.3 Conversations .................................................................................................................... 722

4.14.4 Footnotes........................................................................................................................... 724

4.15 Disabled elements..................................................................................................................................... 726

4.16 Matching HTML elements using selectors and CSS ................................................................................... 726

4.16.1 Case-sensitivity of the CSS 'attr()' function ....................................................................... 726

4.16.2 Case-sensitivity of selectors .............................................................................................. 726

4.16.3 Pseudo-classes .................................................................................................................. 728



5 Microdata............................................................................................................................................................................ 732

5.1 Introduction................................................................................................................................................. 732

5.1.1 Overview.............................................................................................................................. 732

5.1.2 The basic syntax.................................................................................................................. 732

5.1.3 Typed items ......................................................................................................................... 735

5.1.4 Global identifiers for items .................................................................................................. 736

5.1.5 Selecting names when defining vocabularies ...................................................................... 736

5.2 Encoding microdata .................................................................................................................................... 737

5.2.1 The microdata model........................................................................................................... 737

5.2.2 Items.................................................................................................................................... 737

5.2.3 Names: the itemprop attribute ........................................................................................... 739

5.2.4 Values .................................................................................................................................. 741

5.2.5 Associating names with items ............................................................................................. 742

5.2.6 Microdata and other namespaces........................................................................................ 743

5.3 Sample microdata vocabularies .................................................................................................................. 743

5.3.1 vCard ................................................................................................................................... 744

5.3.1.1 Conversion to vCard..................................................................................... 752

5.3.1.2 Examples...................................................................................................... 756

5.3.2 vEvent ................................................................................................................................. 757

5.3.2.1 Conversion to iCalendar ............................................................................... 762

5.3.2.2 Examples...................................................................................................... 763

5.3.3 Licensing works ................................................................................................................... 764

5.3.3.1 Examples...................................................................................................... 765

5.4 Converting HTML to other formats .............................................................................................................. 765

5.4.1 JSON..................................................................................................................................... 765



6 User interaction .................................................................................................................................................................. 768

6.1 The hidden attribute................................................................................................................................... 768

6.2 Inert subtrees.............................................................................................................................................. 769

6.3 Tracking user activation .............................................................................................................................. 769

6.3.1 Data model .......................................................................................................................... 769

6.3.2 Processing model................................................................................................................. 770

6.3.3 APIs gated by user activation .............................................................................................. 771

6.4 Activation behavior of elements.................................................................................................................. 771

6.5 Focus........................................................................................................................................................... 772

6.5.1 Introduction ......................................................................................................................... 772

6.5.2 Data model .......................................................................................................................... 773

6.5.3 The tabindex attribute........................................................................................................ 776

6.5.4 Processing model................................................................................................................. 778

6.5.5 Sequential focus navigation................................................................................................. 782

12





6.5.6 Focus management APIs...................................................................................................... 783


6.5.7 The autofocus attribute...................................................................................................... 785

6.6 Assigning keyboard shortcuts ..................................................................................................................... 787

6.6.1 Introduction ......................................................................................................................... 787

6.6.2 The accesskey attribute...................................................................................................... 788

6.6.3 Processing model................................................................................................................. 789

6.7 Editing......................................................................................................................................................... 790

6.7.1 Making document regions editable: The contenteditable content attribute..................... 790

6.7.2 Making entire documents editable: the designMode getter and setter................................ 791

6.7.3 Best practices for in-page editors ........................................................................................ 791

6.7.4 Editing APIs.......................................................................................................................... 792

6.7.5 Spelling and grammar checking .......................................................................................... 792

6.7.6 Autocapitalization ................................................................................................................ 794

6.7.7 Input modalities: the inputmode attribute........................................................................... 796

6.7.8 Input modalities: the enterkeyhint attribute ..................................................................... 796

6.8 Find-in-page ................................................................................................................................................ 796

6.8.1 Introduction ......................................................................................................................... 796

6.8.2 Interaction with selection .................................................................................................... 797

6.9 Drag and drop ............................................................................................................................................. 797

6.9.1 Introduction ......................................................................................................................... 797

6.9.2 The drag data store ............................................................................................................. 799

6.9.3 The DataTransfer interface................................................................................................ 800

6.9.3.1 The DataTransferItemList interface ......................................................... 803

6.9.3.2 The DataTransferItem interface................................................................. 804

6.9.4 The DragEvent interface ..................................................................................................... 805

6.9.5 Processing model................................................................................................................. 807

6.9.6 Events summary.................................................................................................................. 812

6.9.7 The draggable attribute...................................................................................................... 812

6.9.8 Security risks in the drag-and-drop model........................................................................... 813



7 Loading web pages............................................................................................................................................................. 814

7.1 Browsing contexts ....................................................................................................................................... 814

7.1.1 Creating browsing contexts ................................................................................................. 815

7.1.2 Related browsing contexts................................................................................................... 817

7.1.2.1 Navigating related browsing contexts in the DOM ....................................... 819

7.1.3 Security ............................................................................................................................... 821

7.1.4 Groupings of browsing contexts .......................................................................................... 821

7.1.5 Browsing context names...................................................................................................... 822

7.2 Security infrastructure for Window, WindowProxy, and Location objects ................................................... 824

7.2.1 Integration with IDL ............................................................................................................. 824

7.2.2 Shared internal slot: [[CrossOriginPropertyDescriptorMap]] ................................................ 825

7.2.3 Shared abstract operations.................................................................................................. 825

7.2.3.1 CrossOriginProperties ( O ) ........................................................................... 825

7.2.3.2 CrossOriginPropertyFallback ( P ) ................................................................. 826

7.2.3.3 IsPlatformObjectSameOrigin ( O ) ................................................................ 826

7.2.3.4 CrossOriginGetOwnPropertyHelper ( O, P )................................................... 826

7.2.3.5 CrossOriginGet ( O, P, Receiver ).................................................................. 827

7.2.3.6 CrossOriginSet ( O, P, V, Receiver ).............................................................. 827

7.2.3.7 CrossOriginOwnPropertyKeys ( O ) ............................................................... 827

7.3 The Window object ....................................................................................................................................... 828

7.3.1 APIs for creating and navigating browsing contexts by name ............................................. 829

13

7.3.2 Accessing other browsing contexts...................................................................................... 833

7.3.3 Named access on the Window object ................................................................................... 833

7.3.4 Discarding browsing contexts .............................................................................................. 834

7.3.5 Closing browsing contexts ................................................................................................... 835

7.3.6 Browser interface elements ................................................................................................. 835

7.3.7 Script settings for Window objects........................................................................................ 836

7.4 The WindowProxy exotic object ................................................................................................................... 837

7.4.1 [[GetPrototypeOf]] ( )........................................................................................................... 838

7.4.2 [[SetPrototypeOf]] ( V ) ........................................................................................................ 838

7.4.3 [[IsExtensible]] ( ) ................................................................................................................ 838

7.4.4 [[PreventExtensions]] ( ) ...................................................................................................... 838

7.4.5 [[GetOwnProperty]] ( P ) ...................................................................................................... 838

7.4.6 [[DefineOwnProperty]] ( P, Desc )........................................................................................ 839

7.4.7 [[Get]] ( P, Receiver )........................................................................................................... 839

7.4.8 [[Set]] ( P, V, Receiver ) ....................................................................................................... 839

7.4.9 [[Delete]] ( P )...................................................................................................................... 840

7.4.10 [[OwnPropertyKeys]] ( ) ..................................................................................................... 840

7.5 Origin .......................................................................................................................................................... 840

7.5.1 Sites..................................................................................................................................... 842

7.5.2 Relaxing the same-origin restriction .................................................................................... 843

7.5.3 Origin-keyed agent clusters................................................................................................. 844

7.6 Sandboxing ................................................................................................................................................. 845

7.7 Cross-origin opener policies ........................................................................................................................ 848

7.7.1 The headers......................................................................................................................... 849

7.7.2 Browsing context group switches due to cross-origin opener policy.................................... 850

7.7.3 Reporting ............................................................................................................................. 852

7.8 Cross-origin embedder policies ................................................................................................................... 856

7.8.1 The headers......................................................................................................................... 856

7.8.2 Embedder policy checks ...................................................................................................... 857

7.9 Session history and navigation ................................................................................................................... 858

7.9.1 Browsing sessions................................................................................................................ 858

7.9.2 The session history of browsing contexts ............................................................................ 858

7.9.3 The History interface ......................................................................................................... 860

7.9.4 Implementation notes for session history ............................................................................ 866

7.9.5 The Location interface ....................................................................................................... 867

7.9.5.1 [[GetPrototypeOf]] ( ) ................................................................................... 873

7.9.5.2 [[SetPrototypeOf]] ( V ) ................................................................................ 874

7.9.5.3 [[IsExtensible]] ( )......................................................................................... 874

7.9.5.4 [[PreventExtensions]] ( ) .............................................................................. 874

7.9.5.5 [[GetOwnProperty]] ( P )............................................................................... 874

7.9.5.6 [[DefineOwnProperty]] ( P, Desc ) ................................................................ 874

7.9.5.7 [[Get]] ( P, Receiver ) ................................................................................... 874

7.9.5.8 [[Set]] ( P, V, Receiver )................................................................................ 874

7.9.5.9 [[Delete]] ( P ) .............................................................................................. 875

7.9.5.10 [[OwnPropertyKeys]] ( ).............................................................................. 875

7.10 Browsing the web...................................................................................................................................... 875

7.10.1 Navigating across documents............................................................................................ 875

7.10.2 Page load processing model for HTML files........................................................................ 886

7.10.3 Page load processing model for XML files .......................................................................... 886

7.10.4 Page load processing model for text files .......................................................................... 886

14





7.10.5 Page load processing model for multipart/x-mixed-replace resources ........................ 887


7.10.6 Page load processing model for media .............................................................................. 887

7.10.7 Page load processing model for content that uses plugins ................................................ 888

7.10.8 Page load processing model for inline content that doesn't have a DOM .......................... 888

7.10.9 Navigating to a fragment................................................................................................... 889

7.10.10 History traversal .............................................................................................................. 890

7.10.10.1 Persisted history entry state .................................................................... 892

7.10.10.2 The PopStateEvent interface .................................................................. 893

7.10.10.3 The HashChangeEvent interface............................................................... 893

7.10.10.4 The PageTransitionEvent interface ....................................................... 894

7.10.11 Loading documents ......................................................................................................... 894

7.10.12 Unloading documents ...................................................................................................... 894

7.10.12.1 The BeforeUnloadEvent interface........................................................... 896

7.10.13 Aborting a document load ............................................................................................... 896

7.10.14 The `X-Frame-Options` header...................................................................................... 897



8 Web application APIs .......................................................................................................................................................... 900

8.1 Scripting...................................................................................................................................................... 900

8.1.1 Introduction ......................................................................................................................... 900

8.1.2 Agents and agent clusters ................................................................................................... 900

8.1.2.1 Integration with the JavaScript agent formalism .......................................... 900

8.1.2.2 Integration with the JavaScript agent cluster formalism .............................. 901

8.1.3 Realms and their counterparts ............................................................................................ 903

8.1.3.1 Environments ............................................................................................... 903

8.1.3.2 Environment settings objects ....................................................................... 904

8.1.3.3 Realms, settings objects, and global objects................................................ 905

8.1.3.3.1 Entry ..................................................................................... 908

8.1.3.3.2 Incumbent............................................................................. 908

8.1.3.3.3 Current.................................................................................. 911

8.1.3.3.4 Relevant................................................................................ 911

8.1.3.4 Enabling and disabling scripting................................................................... 911

8.1.3.5 Secure contexts............................................................................................ 911

8.1.4 Script processing model ...................................................................................................... 912

8.1.4.1 Scripts .......................................................................................................... 912

8.1.4.2 Fetching scripts ............................................................................................ 913

8.1.4.3 Creating scripts ............................................................................................ 920

8.1.4.4 Calling scripts............................................................................................... 921

8.1.4.5 Killing scripts ................................................................................................ 923

8.1.4.6 Runtime script errors.................................................................................... 924

8.1.4.7 Unhandled promise rejections...................................................................... 925

8.1.5 JavaScript specification host hooks...................................................................................... 926

8.1.5.1 HostEnqueuePromiseJob(job, realm) ............................................................ 926

8.1.5.2 HostEnsureCanCompileStrings(callerRealm, calleeRealm)........................... 927

8.1.5.3 HostPromiseRejectionTracker(promise, operation) ....................................... 928

8.1.5.4 Module-related host hooks ........................................................................... 928

8.1.5.4.1 HostGetImportMetaProperties(moduleRecord) ..................... 930

8.1.5.4.2 HostImportModuleDynamically(referencingScriptOrModule,

specifier, promiseCapability) ............................................................... 930

8.1.5.4.3 HostResolveImportedModule(referencingScriptOrModule,

specifier).............................................................................................. 930

8.1.6 Event loops .......................................................................................................................... 931

8.1.6.1 Definitions .................................................................................................... 931

8.1.6.2 Queuing tasks .............................................................................................. 933

8.1.6.3 Processing model ......................................................................................... 934

8.1.6.4 Generic task sources .................................................................................... 939

15





8.1.6.5 Dealing with the event loop from other specifications ................................. 939


8.1.7 Events.................................................................................................................................. 941

8.1.7.1 Event handlers ............................................................................................. 941

8.1.7.2 Event handlers on elements, Document objects, and Window objects........... 948

8.1.7.2.1 IDL definitions ....................................................................... 951

8.1.7.3 Event firing................................................................................................... 952

8.2 The WindowOrWorkerGlobalScope mixin .................................................................................................... 953

8.3 Base64 utility methods ............................................................................................................................... 954

8.4 Dynamic markup insertion .......................................................................................................................... 955

8.4.1 Opening the input stream.................................................................................................... 955

8.4.2 Closing the input stream...................................................................................................... 956

8.4.3 document.write() .............................................................................................................. 957

8.4.4 document.writeln() .......................................................................................................... 958

8.5 DOM parsing ............................................................................................................................................... 958

8.6 Timers ......................................................................................................................................................... 959

8.7 Microtask queuing ....................................................................................................................................... 963

8.8 User prompts............................................................................................................................................... 964

8.8.1 Simple dialogs ..................................................................................................................... 964

8.8.2 Printing ................................................................................................................................ 966

8.9 System state and capabilities ..................................................................................................................... 967

8.9.1 The Navigator object.......................................................................................................... 967

8.9.1.1 Client identification ...................................................................................... 967

8.9.1.2 Language preferences.................................................................................. 969

8.9.1.3 Browser state ............................................................................................... 970

8.9.1.4 Custom scheme handlers: the registerProtocolHandler() method ........ 970

8.9.1.4.1 Security and privacy ............................................................. 973

8.9.1.5 Cookies......................................................................................................... 973

8.9.1.6 Plugins.......................................................................................................... 973

8.10 Images ...................................................................................................................................................... 978

8.11 Animation frames...................................................................................................................................... 984



9 Communication .................................................................................................................................................................. 986

9.1 The MessageEvent interface ....................................................................................................................... 986

9.2 Server-sent events ...................................................................................................................................... 987

9.2.1 Introduction ......................................................................................................................... 987

9.2.2 The EventSource interface.................................................................................................. 988

9.2.3 Processing model................................................................................................................. 990

9.2.4 Parsing an event stream ...................................................................................................... 991

9.2.5 Interpreting an event stream............................................................................................... 991

9.2.6 Authoring notes ................................................................................................................... 994

9.2.7 Connectionless push and other features.............................................................................. 994

9.2.8 Garbage collection............................................................................................................... 995

9.2.9 Implementation advice ........................................................................................................ 995

9.3 Web sockets ................................................................................................................................................ 996

9.3.1 Introduction ......................................................................................................................... 996

9.3.2 The WebSocket interface ..................................................................................................... 996

9.3.3 Feedback from the protocol ............................................................................................... 1000

9.3.4 Ping and Pong frames ........................................................................................................ 1002

9.3.5 The CloseEvent interface.................................................................................................. 1002

9.3.6 Garbage collection............................................................................................................. 1003

16





9.4 Cross-document messaging ...................................................................................................................... 1004


9.4.1 Introduction ....................................................................................................................... 1004

9.4.2 Security ............................................................................................................................. 1004

9.4.2.1 Authors....................................................................................................... 1004

9.4.2.2 User agents ................................................................................................ 1005

9.4.3 Posting messages .............................................................................................................. 1005

9.5 Channel messaging................................................................................................................................... 1006

9.5.1 Introduction ....................................................................................................................... 1006

9.5.1.1 Examples.................................................................................................... 1007

9.5.1.2 Ports as the basis of an object-capability model on the web...................... 1008

9.5.1.3 Ports as the basis of abstracting out service implementations .................. 1009

9.5.2 Message channels ............................................................................................................. 1009

9.5.3 Message ports ................................................................................................................... 1009

9.5.4 Broadcasting to many ports............................................................................................... 1012

9.5.5 Ports and garbage collection ............................................................................................. 1013

9.6 Broadcasting to other browsing contexts .................................................................................................. 1013



10 Web workers ................................................................................................................................................................... 1016

10.1 Introduction............................................................................................................................................. 1016

10.1.1 Scope............................................................................................................................... 1016

10.1.2 Examples ......................................................................................................................... 1016

10.1.2.1 A background number-crunching worker.................................................. 1016

10.1.2.2 Using a JavaScript module as a worker .................................................... 1017

10.1.2.3 Shared workers introduction .................................................................... 1019

10.1.2.4 Shared state using a shared worker ......................................................... 1021

10.1.2.5 Delegation................................................................................................ 1025

10.1.2.6 Providing libraries..................................................................................... 1027

10.1.3 Tutorials ........................................................................................................................... 1030

10.1.3.1 Creating a dedicated worker .................................................................... 1030

10.1.3.2 Communicating with a dedicated worker ................................................. 1031

10.1.3.3 Shared workers ........................................................................................ 1031

10.2 Infrastructure .......................................................................................................................................... 1032

10.2.1 The global scope.............................................................................................................. 1032

10.2.1.1 The WorkerGlobalScope common interface ............................................ 1032

10.2.1.2 Dedicated workers and the DedicatedWorkerGlobalScope interface ..... 1034

10.2.1.3 Shared workers and the SharedWorkerGlobalScope interface................ 1035

10.2.2 The event loop................................................................................................................. 1035

10.2.3 The worker's lifetime ....................................................................................................... 1036

10.2.4 Processing model............................................................................................................. 1036

10.2.5 Runtime script errors ....................................................................................................... 1039

10.2.6 Creating workers.............................................................................................................. 1039

10.2.6.1 The AbstractWorker mixin...................................................................... 1039

10.2.6.2 Script settings for workers........................................................................ 1040

10.2.6.3 Dedicated workers and the Worker interface ........................................... 1041

10.2.6.4 Shared workers and the SharedWorker interface..................................... 1042

10.2.7 Concurrent hardware capabilities .................................................................................... 1044

10.3 APIs available to workers ........................................................................................................................ 1044

10.3.1 Importing scripts and libraries ......................................................................................... 1044

10.3.2 The WorkerNavigator interface ...................................................................................... 1045

10.3.3 The WorkerLocation interface ........................................................................................ 1045



11 Worklets.......................................................................................................................................................................... 1047

17





11.1 Introduction............................................................................................................................................. 1047


11.1.1 Motivations ...................................................................................................................... 1047

11.1.2 Code idempotence........................................................................................................... 1047

11.1.3 Speculative evaluation .................................................................................................... 1048

11.2 Examples ................................................................................................................................................ 1048

11.2.1 Loading scripts................................................................................................................. 1049

11.2.2 Registering a class and invoking its methods .................................................................. 1050

11.3 Infrastructure .......................................................................................................................................... 1050

11.3.1 The global scope.............................................................................................................. 1050

11.3.1.1 Agents and event loops............................................................................ 1051

11.3.1.2 Creation and termination ......................................................................... 1051

11.3.1.3 Script settings for worklets....................................................................... 1052

11.3.2 The Worklet class ........................................................................................................... 1053

11.3.3 The worklet's lifetime ...................................................................................................... 1055



12 Web storage ................................................................................................................................................................... 1056

12.1 Introduction............................................................................................................................................. 1056

12.2 The API .................................................................................................................................................... 1057

12.2.1 The Storage interface ..................................................................................................... 1057

12.2.2 The sessionStorage getter ............................................................................................ 1059

12.2.3 The localStorage getter ................................................................................................ 1060

12.2.4 The StorageEvent interface............................................................................................ 1060

12.3 Privacy .................................................................................................................................................... 1061

12.3.1 User tracking ................................................................................................................... 1061

12.3.2 Sensitivity of data ............................................................................................................ 1062

12.4 Security ................................................................................................................................................... 1062

12.4.1 DNS spoofing attacks....................................................................................................... 1062

12.4.2 Cross-directory attacks .................................................................................................... 1062

12.4.3 Implementation risks ....................................................................................................... 1062



13 The HTML syntax ............................................................................................................................................................ 1064

13.1 Writing HTML documents ........................................................................................................................ 1064

13.1.1 The DOCTYPE................................................................................................................... 1064

13.1.2 Elements.......................................................................................................................... 1065

13.1.2.1 Start tags ................................................................................................. 1066

13.1.2.2 End tags ................................................................................................... 1067

13.1.2.3 Attributes ................................................................................................. 1067

13.1.2.4 Optional tags............................................................................................ 1068

13.1.2.5 Restrictions on content models ................................................................ 1074

13.1.2.6 Restrictions on the contents of raw text and escapable raw text

elements ................................................................................................................ 1074

13.1.3 Text .................................................................................................................................. 1074

13.1.3.1 Newlines................................................................................................... 1074

13.1.4 Character references ....................................................................................................... 1074

13.1.5 CDATA sections ................................................................................................................ 1075

13.1.6 Comments ....................................................................................................................... 1075

13.2 Parsing HTML documents ........................................................................................................................ 1076

13.2.1 Overview of the parsing model........................................................................................ 1077

13.2.2 Parse errors...................................................................................................................... 1078

13.2.3 The input byte stream ..................................................................................................... 1082

13.2.3.1 Parsing with a known character encoding ................................................ 1083

18

13.2.3.2 Determining the character encoding........................................................ 1083

13.2.3.3 Character encodings ................................................................................ 1088

13.2.3.4 Changing the encoding while parsing ...................................................... 1088

13.2.3.5 Preprocessing the input stream................................................................ 1088

13.2.4 Parse state....................................................................................................................... 1089

13.2.4.1 The insertion mode .................................................................................. 1089

13.2.4.2 The stack of open elements ..................................................................... 1090

13.2.4.3 The list of active formatting elements...................................................... 1092

13.2.4.4 The element pointers ............................................................................... 1093

13.2.4.5 Other parsing state flags.......................................................................... 1093

13.2.5 Tokenization ..................................................................................................................... 1094

13.2.5.1 Data state ................................................................................................ 1095

13.2.5.2 RCDATA state............................................................................................ 1095

13.2.5.3 RAWTEXT state......................................................................................... 1095

13.2.5.4 Script data state....................................................................................... 1095

13.2.5.5 PLAINTEXT state....................................................................................... 1096

13.2.5.6 Tag open state.......................................................................................... 1096

13.2.5.7 End tag open state ................................................................................... 1096

13.2.5.8 Tag name state......................................................................................... 1097

13.2.5.9 RCDATA less-than sign state..................................................................... 1097

13.2.5.10 RCDATA end tag open state.................................................................... 1097

13.2.5.11 RCDATA end tag name state................................................................... 1098

13.2.5.12 RAWTEXT less-than sign state ................................................................ 1098

13.2.5.13 RAWTEXT end tag open state ................................................................. 1098

13.2.5.14 RAWTEXT end tag name state................................................................ 1098

13.2.5.15 Script data less-than sign state .............................................................. 1099

13.2.5.16 Script data end tag open state............................................................... 1099

13.2.5.17 Script data end tag name state.............................................................. 1099

13.2.5.18 Script data escape start state ................................................................ 1100

13.2.5.19 Script data escape start dash state........................................................ 1100

13.2.5.20 Script data escaped state....................................................................... 1100

13.2.5.21 Script data escaped dash state .............................................................. 1101

13.2.5.22 Script data escaped dash dash state ..................................................... 1101

13.2.5.23 Script data escaped less-than sign state................................................ 1101

13.2.5.24 Script data escaped end tag open state................................................. 1102

13.2.5.25 Script data escaped end tag name state................................................ 1102

13.2.5.26 Script data double escape start state .................................................... 1102

13.2.5.27 Script data double escaped state ........................................................... 1103

13.2.5.28 Script data double escaped dash state .................................................. 1103

13.2.5.29 Script data double escaped dash dash state.......................................... 1104

13.2.5.30 Script data double escaped less-than sign state .................................... 1104

13.2.5.31 Script data double escape end state ...................................................... 1104

13.2.5.32 Before attribute name state ................................................................... 1105

13.2.5.33 Attribute name state .............................................................................. 1105

13.2.5.34 After attribute name state...................................................................... 1106

13.2.5.35 Before attribute value state ................................................................... 1106

13.2.5.36 Attribute value (double-quoted) state .................................................... 1106

13.2.5.37 Attribute value (single-quoted) state ..................................................... 1107

13.2.5.38 Attribute value (unquoted) state ............................................................ 1107

13.2.5.39 After attribute value (quoted) state........................................................ 1108

13.2.5.40 Self-closing start tag state...................................................................... 1108

13.2.5.41 Bogus comment state ............................................................................ 1108

13.2.5.42 Markup declaration open state............................................................... 1109

13.2.5.43 Comment start state .............................................................................. 1109

13.2.5.44 Comment start dash state...................................................................... 1109

19

13.2.5.45 Comment state ...................................................................................... 1110

13.2.5.46 Comment less-than sign state................................................................ 1110

13.2.5.47 Comment less-than sign bang state....................................................... 1110

13.2.5.48 Comment less-than sign bang dash state .............................................. 1110

13.2.5.49 Comment less-than sign bang dash dash state...................................... 1110

13.2.5.50 Comment end dash state ....................................................................... 1111

13.2.5.51 Comment end state................................................................................ 1111

13.2.5.52 Comment end bang state....................................................................... 1111

13.2.5.53 DOCTYPE state ....................................................................................... 1112

13.2.5.54 Before DOCTYPE name state .................................................................. 1112

13.2.5.55 DOCTYPE name state ............................................................................. 1112

13.2.5.56 After DOCTYPE name state..................................................................... 1113

13.2.5.57 After DOCTYPE public keyword state...................................................... 1113

13.2.5.58 Before DOCTYPE public identifier state .................................................. 1114

13.2.5.59 DOCTYPE public identifier (double-quoted) state ................................... 1114

13.2.5.60 DOCTYPE public identifier (single-quoted) state..................................... 1115

13.2.5.61 After DOCTYPE public identifier state ..................................................... 1115

13.2.5.62 Between DOCTYPE public and system identifiers state .......................... 1115

13.2.5.63 After DOCTYPE system keyword state .................................................... 1116

13.2.5.64 Before DOCTYPE system identifier state ................................................ 1116

13.2.5.65 DOCTYPE system identifier (double-quoted) state ................................. 1117

13.2.5.66 DOCTYPE system identifier (single-quoted) state................................... 1117

13.2.5.67 After DOCTYPE system identifier state ................................................... 1118

13.2.5.68 Bogus DOCTYPE state ............................................................................ 1118

13.2.5.69 CDATA section state ............................................................................... 1118

13.2.5.70 CDATA section bracket state .................................................................. 1119

13.2.5.71 CDATA section end state ........................................................................ 1119

13.2.5.72 Character reference state ...................................................................... 1119

13.2.5.73 Named character reference state........................................................... 1119

13.2.5.74 Ambiguous ampersand state ................................................................. 1120

13.2.5.75 Numeric character reference state......................................................... 1120

13.2.5.76 Hexadecimal character reference start state ......................................... 1120

13.2.5.77 Decimal character reference start state................................................. 1121

13.2.5.78 Hexadecimal character reference state ................................................. 1121

13.2.5.79 Decimal character reference state ......................................................... 1121

13.2.5.80 Numeric character reference end state.................................................. 1121

13.2.6 Tree construction ............................................................................................................. 1122

13.2.6.1 Creating and inserting nodes ................................................................... 1123

13.2.6.2 Parsing elements that contain only text................................................... 1128

13.2.6.3 Closing elements that have implied end tags .......................................... 1129

13.2.6.4 The rules for parsing tokens in HTML content .......................................... 1129

13.2.6.4.1 The "initial" insertion mode .............................................. 1129

13.2.6.4.2 The "before html" insertion mode..................................... 1130

13.2.6.4.3 The "before head" insertion mode .................................... 1131

13.2.6.4.4 The "in head" insertion mode ........................................... 1132

13.2.6.4.5 The "in head noscript" insertion mode.............................. 1134

13.2.6.4.6 The "after head" insertion mode....................................... 1134

13.2.6.4.7 The "in body" insertion mode ........................................... 1135

13.2.6.4.8 The "text" insertion mode................................................. 1145

13.2.6.4.9 The "in table" insertion mode ........................................... 1147

13.2.6.4.10 The "in table text" insertion mode .................................. 1149

13.2.6.4.11 The "in caption" insertion mode ..................................... 1149

13.2.6.4.12 The "in column group" insertion mode ........................... 1150

13.2.6.4.13 The "in table body" insertion mode ................................ 1150

13.2.6.4.14 The "in row" insertion mode ........................................... 1151

13.2.6.4.15 The "in cell" insertion mode............................................ 1152

13.2.6.4.16 The "in select" insertion mode........................................ 1153

20





13.2.6.4.17 The "in select in table" insertion mode ........................... 1155


13.2.6.4.18 The "in template" insertion mode ................................... 1155

13.2.6.4.19 The "after body" insertion mode..................................... 1156

13.2.6.4.20 The "in frameset" insertion mode ................................... 1157

13.2.6.4.21 The "after frameset" insertion mode .............................. 1158

13.2.6.4.22 The "after after body" insertion mode ............................ 1158

13.2.6.4.23 The "after after frameset" insertion mode ...................... 1158

13.2.6.5 The rules for parsing tokens in foreign content........................................ 1159

13.2.7 The end............................................................................................................................ 1161

13.2.8 Coercing an HTML DOM into an infoset............................................................................ 1162

13.2.9 An introduction to error handling and strange cases in the parser .................................. 1163

13.2.9.1 Misnested tags: <b><i></b></i> .......................................................... 1163

13.2.9.2 Misnested tags: <b><p></b></p> ........................................................ 1164

13.2.9.3 Unexpected markup in tables................................................................... 1165

13.2.9.4 Scripts that modify the page as it is being parsed ................................... 1167

13.2.9.5 The execution of scripts that are moving across multiple documents...... 1168

13.2.9.6 Unclosed formatting elements ................................................................. 1168

13.3 Serializing HTML fragments..................................................................................................................... 1169

13.4 Parsing HTML fragments ......................................................................................................................... 1173

13.5 Named character references................................................................................................................... 1175



14 The XML syntax .............................................................................................................................................................. 1184

14.1 Writing documents in the XML syntax ..................................................................................................... 1184

14.2 Parsing XML documents .......................................................................................................................... 1184

14.3 Serializing XML fragments....................................................................................................................... 1186

14.4 Parsing XML fragments ........................................................................................................................... 1187



15 Rendering ....................................................................................................................................................................... 1188

15.1 Introduction............................................................................................................................................. 1188

15.2 The CSS user agent style sheet and presentational hints ....................................................................... 1188

15.3 Non-replaced elements ........................................................................................................................... 1189

15.3.1 Hidden elements.............................................................................................................. 1189

15.3.2 The page.......................................................................................................................... 1189

15.3.3 Flow content .................................................................................................................... 1191

15.3.4 Phrasing content.............................................................................................................. 1192

15.3.5 Bidirectional text ............................................................................................................. 1194

15.3.6 Sections and headings..................................................................................................... 1195

15.3.7 Lists ................................................................................................................................. 1195

15.3.8 Tables............................................................................................................................... 1196

15.3.9 Margin collapsing quirks .................................................................................................. 1201

15.3.10 Form controls ................................................................................................................. 1201

15.3.11 The hr element.............................................................................................................. 1202

15.3.12 The fieldset and legend elements ............................................................................. 1203

15.4 Replaced elements.................................................................................................................................. 1205

15.4.1 Embedded content .......................................................................................................... 1206

15.4.2 Images............................................................................................................................. 1206

15.4.3 Attributes for embedded content and images ................................................................. 1207

15.4.4 Image maps ..................................................................................................................... 1209

15.5 Widgets ................................................................................................................................................... 1209

15.5.1 Introduction ..................................................................................................................... 1209

15.5.2 Button layout ................................................................................................................... 1209

21





15.5.3 The button element ........................................................................................................ 1210


15.5.4 The details and summary elements ............................................................................... 1210

15.5.5 The input element as a text entry widget ...................................................................... 1210

15.5.6 The input element as domain-specific widgets .............................................................. 1211

15.5.7 The input element as a range control ............................................................................ 1211

15.5.8 The input element as a color well................................................................................... 1211

15.5.9 The input element as a checkbox and radio button widgets .......................................... 1211

15.5.10 The input element as a file upload control ................................................................... 1212

15.5.11 The input element as a button ..................................................................................... 1212

15.5.12 The marquee element .................................................................................................... 1212

15.5.13 The meter element ........................................................................................................ 1213

15.5.14 The progress element .................................................................................................. 1213

15.5.15 The select element ...................................................................................................... 1214

15.5.16 The textarea element .................................................................................................. 1215

15.6 Frames and framesets............................................................................................................................. 1215

15.7 Interactive media .................................................................................................................................... 1217

15.7.1 Links, forms, and navigation............................................................................................ 1217

15.7.2 The title attribute ......................................................................................................... 1217

15.7.3 Editing hosts .................................................................................................................... 1218

15.7.4 Text rendered in native user interfaces ........................................................................... 1218

15.8 Print media.............................................................................................................................................. 1220

15.9 Unstyled XML documents........................................................................................................................ 1220



16 Obsolete features ........................................................................................................................................................... 1222

16.1 Obsolete but conforming features........................................................................................................... 1222

16.1.1 Warnings for obsolete but conforming features ............................................................... 1222

16.2 Non-conforming features......................................................................................................................... 1223

16.3 Requirements for implementations ......................................................................................................... 1228

16.3.1 The marquee element ...................................................................................................... 1228

16.3.2 Frames ............................................................................................................................. 1230

16.3.3 Other elements, attributes and APIs ................................................................................ 1232



17 IANA considerations........................................................................................................................................................ 1241

17.1 text/html............................................................................................................................................... 1241

17.2 multipart/x-mixed-replace ................................................................................................................ 1242

17.3 application/xhtml+xml........................................................................................................................ 1243

17.4 text/ping............................................................................................................................................... 1244

17.5 application/microdata+json............................................................................................................... 1245

17.6 text/event-stream................................................................................................................................ 1246

17.7 `Cross-Origin-Embedder-Policy`........................................................................................................ 1247

17.8 `Cross-Origin-Embedder-Policy-Report-Only` ................................................................................. 1247

17.9 `Cross-Origin-Opener-Policy` ........................................................................................................... 1247

17.10 `Cross-Origin-Opener-Policy-Report-Only`................................................................................... 1248

17.11 `Origin-Agent-Cluster`..................................................................................................................... 1248

17.12 `Ping-From`.......................................................................................................................................... 1249

17.13 `Ping-To` ............................................................................................................................................. 1249

17.14 `Refresh` ............................................................................................................................................. 1249

17.15 `Last-Event-ID` .................................................................................................................................. 1250

22





17.16 `X-Frame-Options` .............................................................................................................................. 1250


17.17 web+ scheme prefix ............................................................................................................................... 1250



Index.................................................................................................................................................................................... 1252

Elements ......................................................................................................................................................... 1252

Element content categories ............................................................................................................................ 1258

Attributes ........................................................................................................................................................ 1259

Element Interfaces .......................................................................................................................................... 1266

All Interfaces ................................................................................................................................................... 1269

Events ............................................................................................................................................................. 1271

MIME Types...................................................................................................................................................... 1272



References........................................................................................................................................................................... 1275



Acknowledgments ............................................................................................................................................................... 1284



Intellectual property rights .................................................................................................................................................. 1287



23





1 Introduction p24 §


1.1 Where does this specification fit? p24 §

This specification defines a big part of the web platform, in lots of detail. Its place in the web platform specification stack relative to other specifications can be best summed up as follows:



CSS SVG MathML Service Workers





CSP PNG



Fetch Opus



IDB V1A THIS SPECIFICATION



HTTP TLS DOM Unicode Web IDL



MIME URL XML JavaScript Encoding



1.2 Is this HTML5? p24 §

This section is non-normative.

In short: Yes.



24





In more length: the term "HTML5" is widely used as a buzzword to refer to modern web technologies, many of which (though by no means all) are developed at the WHATWG. This document is one such; others are available from the WHATWG Standards overview.




1.3 Background p25 §

This section is non-normative.

HTML is the World Wide Web's core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents. Its general design, however, has enabled it to be adapted, over the subsequent years, to describe a number of other types of documents and even applications.



1.4 Audience p25 §

This section is non-normative.

This specification is intended for authors of documents and scripts that use the features defined in this specification, implementers of tools that operate on pages that use the features defined in this specification, and individuals wishing to establish the correctness of documents or implementations with respect to the requirements of this specification.

This document is probably not suited to readers who do not already have at least a passing familiarity with web technologies, as in places it sacrifices clarity for precision, and brevity for completeness. More approachable tutorials and authoring guides can provide a gentler introduction to the topic.

In particular, familiarity with the basics of DOM is necessary for a complete understanding of some of the more technical parts of this specification. An understanding of Web IDL, HTTP, XML, Unicode, character encodings, JavaScript, and CSS will also be helpful in places but is not essential.



1.5 Scope p25 §

This section is non-normative.

This specification is limited to providing a semantic-level markup language and associated semantic-level scripting APIs for authoring accessible pages on the web ranging from static documents to dynamic applications.

The scope of this specification does not include providing mechanisms for media-specific customization of presentation (although default rendering rules for web browsers are included at the end of this specification, and several mechanisms for hooking into CSS are provided as part of the language).

The scope of this specification is not to describe an entire operating system. In particular, hardware configuration software, image manipulation tools, and applications that users would be expected to use with high-end workstations on a daily basis are out of scope. In terms of applications, this specification is targeted specifically at applications that would be expected to be used by users on an occasional basis, or regularly but from disparate locations, with low CPU requirements. Examples of such applications include online purchasing systems, searching systems, games (especially multiplayer online games), public telephone books or address books, communications software (email clients, instant messaging clients, discussion software), document editing software, etc.



1.6 History p25 §

This section is non-normative.

For its first five years (1990-1995), HTML went through a number of revisions and experienced a number of extensions, primarily hosted first at CERN, and then at the IETF.

With the creation of the W3C, HTML's development changed venue again. A first abortive attempt at extending HTML in 1995 known as

25





HTML 3.0 then made way to a more pragmatic approach known as HTML 3.2, which was completed in 1997. HTML4 quickly followed later that same year.


The following year, the W3C membership decided to stop evolving HTML and instead begin work on an XML-based equivalent, called XHTML. This effort started with a reformulation of HTML4 in XML, known as XHTML 1.0, which added no new features except the new serialization, and which was completed in 2000. After XHTML 1.0, the W3C's focus turned to making it easier for other working groups to extend XHTML, under the banner of XHTML Modularization. In parallel with this, the W3C also worked on a new language that was not compatible with the earlier HTML and XHTML languages, calling it XHTML2.

Around the time that HTML's evolution was stopped in 1998, parts of the API for HTML developed by browser vendors were specified and published under the name DOM Level 1 (in 1998) and DOM Level 2 Core and DOM Level 2 HTML (starting in 2000 and culminating in 2003). These efforts then petered out, with some DOM Level 3 specifications published in 2004 but the working group being closed before all the Level 3 drafts were completed.

In 2003, the publication of XForms, a technology which was positioned as the next generation of web forms, sparked a renewed interest in evolving HTML itself, rather than finding replacements for it. This interest was borne from the realization that XML's deployment as a web technology was limited to entirely new technologies (like RSS and later Atom), rather than as a replacement for existing deployed technologies (like HTML).

A proof of concept to show that it was possible to extend HTML4's forms to provide many of the features that XForms 1.0 introduced, without requiring browsers to implement rendering engines that were incompatible with existing HTML web pages, was the first result of this renewed interest. At this early stage, while the draft was already publicly available, and input was already being solicited from all sources, the specification was only under Opera Software's copyright.

The idea that HTML's evolution should be reopened was tested at a W3C workshop in 2004, where some of the principles that underlie the HTML5 work (described below), as well as the aforementioned early draft proposal covering just forms-related features, were presented to the W3C jointly by Mozilla and Opera. The proposal was rejected on the grounds that the proposal conflicted with the previously chosen direction for the web's evolution; the W3C staff and membership voted to continue developing XML-based replacements instead.

Shortly thereafter, Apple, Mozilla, and Opera jointly announced their intent to continue working on the effort under the umbrella of a new venue called the WHATWG. A public mailing list was created, and the draft was moved to the WHATWG site. The copyright was subsequently amended to be jointly owned by all three vendors, and to allow reuse of the specification.

The WHATWG was based on several core principles, in particular that technologies need to be backwards compatible, that specifications and implementations need to match even if this means changing the specification rather than the implementations, and that specifications need to be detailed enough that implementations can achieve complete interoperability without reverse-engineering each other.

The latter requirement in particular required that the scope of the HTML5 specification include what had previously been specified in three separate documents: HTML4, XHTML1, and DOM2 HTML. It also meant including significantly more detail than had previously been considered the norm.

In 2006, the W3C indicated an interest to participate in the development of HTML5 after all, and in 2007 formed a working group chartered to work with the WHATWG on the development of the HTML5 specification. Apple, Mozilla, and Opera allowed the W3C to publish the specification under the W3C copyright, while keeping a version with the less restrictive license on the WHATWG site.

For a number of years, both groups then worked together. In 2011, however, the groups came to the conclusion that they had different goals: the W3C wanted to publish a "finished" version of "HTML5", while the WHATWG wanted to continue working on a Living Standard for HTML, continuously maintaining the specification rather than freezing it in a state with known problems, and adding new features as needed to evolve the platform.

In 2019, the WHATWG and W3C signed an agreement to collaborate on a single version of HTML going forward: this document.



1.7 Design notes p26 §

This section is non-normative.

It must be admitted that many aspects of HTML appear at first glance to be nonsensical and inconsistent.

HTML, its supporting DOM APIs, as well as many of its supporting technologies, have been developed over a period of several decades by a wide array of people with different priorities who, in many cases, did not know of each other's existence.

26





Features have thus arisen from many sources, and have not always been designed in especially consistent ways. Furthermore, because of the unique characteristics of the web, implementation bugs have often become de-facto, and now de-jure, standards, as content is often unintentionally written in ways that rely on them before they can be fixed.


Despite all this, efforts have been made to adhere to certain design goals. These are described in the next few subsections.



1.7.1 Serializability of script execution p27 §

This section is non-normative.

To avoid exposing web authors to the complexities of multithreading, the HTML and DOM APIs are designed such that no script can ever detect the simultaneous execution of other scripts. Even with p1041 workers, the intent is that the behavior of implementations can be thought of as completely serializing the execution of all scripts in all p814 browsing contexts .

The exception to this general design principle is the JavaScript SharedArrayBuffer class. Using SharedArrayBuffer objects, it can in fact be observed that scripts in other agents are executing simultaneously. Furthermore, due to the JavaScript memory model, there are situations which not only are un-representable via serialized script execution, but also un-representable via serialized statement execution among those scripts.



1.7.2 Compliance with other specifications p27 §

This section is non-normative.

This specification interacts with and relies on a wide variety of other specifications. In certain circumstances, unfortunately, conflicting needs have led to this specification violating the requirements of these other specifications. Whenever this has occurred, the transgressions have each been noted as a "willful violation", and the reason for the violation has been noted.



1.7.3 Extensibility p27 §

This section is non-normative.

HTML has a wide array of extensibility mechanisms that can be used for adding semantics in a safe manner:

• Authors can use the p138 class attribute to extend elements, effectively creating their own elements, while using the most

applicable existing "real" HTML element, so that browsers and other tools that don't know of the extension can still support it somewhat well. This is the tack used by microformats, for example.

• Authors can include data for inline client-side scripts or server-side site-wide scripts to process using the p146 data-*=""

attributes. These are guaranteed to never be touched by browsers, and allow scripts to include data on HTML elements that scripts can then look for and process.

• Authors can use the p165 <meta name="" content=""> mechanism to include page-wide metadata.

• Authors can use the p285 rel="" mechanism to annotate links with specific meanings by registering extensions to the

predefined set of link types p310 . This is also used by microformats.

• Authors can embed raw data using the p614 <script type=""> mechanism with a custom type, for further handling by inline

or server-side scripts.

• Authors can create p45 p369 plugins and invoke them using the embed element. This is how Flash works.

• Authors can extend APIs using the JavaScript prototyping mechanism. This is widely used by script libraries, for instance.

• Authors can use the microdata feature (the p737 p739 itemscope="" and itemprop="" attributes) to embed nested name-value

pairs of data to be shared with other applications and sites.



27





1.8 HTML vs XML syntax p28 §


This section is non-normative.

This specification defines an abstract language for describing documents and applications, and some APIs for interacting with in-memory representations of resources that use this language.

The in-memory representation is known as "DOM HTML", or "the DOM" for short.

There are various concrete syntaxes that can be used to transmit resources that use this abstract language, two of which are defined in this specification.

The first such concrete syntax is the HTML syntax. This is the format suggested for most authors. It is compatible with most legacy web browsers. If a document is transmitted with the p1241 text/html MIME type, then it will be processed as an HTML document by web browsers. This specification defines the latest HTML syntax, known simply as "HTML".

The second concrete syntax is XML. When a document is transmitted with an p1243 XML MIME type , such as application/xhtml+xml, then it is treated as an XML document by web browsers, to be parsed by an XML processor. Authors are reminded that the processing for XML and HTML differs; in particular, even minor syntax errors will prevent a document labeled as XML from being rendered fully, whereas they would be ignored in the HTML syntax.

Note

The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons,

because no such term is used for the HTML syntaxes of MathML and SVG).

The DOM, the HTML syntax, and the XML syntax cannot all represent the same content. For example, namespaces cannot be represented using the HTML syntax, but they are supported in the DOM and in the XML syntax. Similarly, documents that use the

noscript p628 feature can be represented using the HTML syntax, but cannot be represented with the DOM or in the XML syntax. Comments that contain the string "-->" can only be represented in the DOM, not in the HTML and XML syntaxes.



1.9 Structure of this specification p28 §

This section is non-normative.

This specification is divided into the following major sections:

Introduction p24

Non-normative materials providing a context for the HTML standard.

Common infrastructure p42

The conformance classes, algorithms, definitions, and the common underpinnings of the rest of the specification.

Semantics, structure, and APIs of HTML documents p115

Documents are built from elements. These elements form a tree using the DOM. This section defines the features of this DOM, as well as introducing the features common to all elements, and the concepts used in defining elements.

The elements of HTML p153

Each element has a predefined meaning, which is explained in this section. Rules for authors on how to use the element, along with user agent requirements for how to handle each element, are also given. This includes large signature features of HTML such as video playback and subtitles, form controls and form submission, and a 2D graphics API known as the HTML canvas.

Microdata p732

This specification introduces a mechanism for adding machine-readable annotations to documents, so that tools can extract trees of name-value pairs from the document. This section describes this mechanism and some algorithms that can be used to convert HTML documents into other formats. This section also defines some sample Microdata vocabularies for contact information, calendar events, and licensing works.

User interaction p768

HTML documents can provide a number of mechanisms for users to interact with and modify content, which are described in this section, such as how focus works, and drag-and-drop.



28





Loading web pages p814


HTML documents do not exist in a vacuum — this section defines many of the features that affect environments that deal with multiple pages, such as web browsers and offline caching of web applications.

Web application APIs p900

This section introduces basic features for scripting of applications in HTML.

Web workers p1016

This section defines an API for background threads in JavaScript.

The communication APIs p986

This section describes some mechanisms that applications written in HTML can use to communicate with other applications from different domains running on the same client. It also introduces a server-push event stream mechanism known as Server Sent

Events or p988 EventSource , and a two-way full-duplex socket protocol for scripts known as Web Sockets.

Web storage p1056

This section defines a client-side storage mechanism based on name-value pairs.

The HTML syntax p1064

The XML syntax p1184

All of these features would be for naught if they couldn't be represented in a serialized form and sent to other people, and so these sections define the syntaxes of HTML and XML, along with rules for how to parse content using those syntaxes.

Rendering p1188

This section defines the default rendering rules for web browsers.

There are also some appendices, listing p1222 p1241 obsolete features and IANA considerations, and several indices.



1.9.1 How to read this specification p29 §

This specification should be read like all other specifications. First, it should be read cover-to-cover, multiple times. Then, it should be read backwards at least once. Then it should be read by picking random sections from the contents list and following all the cross-references.

As described in the conformance requirements section below, this specification describes conformance criteria for a variety of conformance classes. In particular, there are conformance requirements that apply to producers, for example authors and the documents they create, and there are conformance requirements that apply to consumers, for example web browsers. They can be distinguished by what they are requiring: a requirement on a producer states what is allowed, while a requirement on a consumer states how software is to act.

Example

For example, "the p68 foo attribute's value must be a valid integer" is a requirement on producers, as it lays out the allowed values;

in contrast, the requirement "the p68 foo attribute's value must be parsed using the rules for parsing integers" is a requirement on

consumers, as it describes how to process the content.

Requirements on producers have no bearing whatsoever on consumers.

Example

Continuing the above example, a requirement stating that a particular attribute's value is constrained to being a p68 valid integer

emphatically does not imply anything about the requirements on consumers. It might be that the consumers are in fact required to

treat the attribute as an opaque string, completely unaffected by whether the value conforms to the requirements or not. It might

be (as in the previous example) that the consumers are required to parse the value using specific rules that define how invalid

(non-numeric in this case) values are to be processed.



1.9.2 Typographic conventions p29 §

This is a definition, requirement, or explanation.



29





Note


This is a note.



Example

This is an example.



This is an open issue.



⚠Warning!

This is a warning.



IDL [Exposed=Window]

interface Example {

// this is an IDL definition

};



For web developers (non-normative)

variable p30 = object . method( [ optionalArgument ] )

This is a note to authors describing the usage of an interface.



CSS /* this is a CSS fragment */

The defining instance of a term is marked up like p30 p30 this . Uses of that term are marked up like this or like this.

The defining instance of an element, attribute, or API is marked up like this. References to that element, attribute, or API are marked up like p30 this .

Other code fragments are marked up like this.

Variables are marked up like this.

In an algorithm, steps in p937 synchronous sections are marked with ⌛.

In some cases, requirements are given in the form of lists with conditions and corresponding requirements. In such cases, the requirements that apply to a condition are always the first set of requirements that follow the condition, even in the case of there being multiple sets of conditions for those requirements. Such cases are presented as follows:

↪ This is a condition

↪ This is another condition

This is the requirement that applies to the conditions above.

↪ This is a third condition

This is the requirement that applies to the third condition.



1.10 A quick introduction to HTML p30 §

This section is non-normative.

A basic HTML document looks like this:





Sample page





30





Sample page





This is a simple sample.





HTML documents consist of a tree of elements and text. Each element is denoted in the source by a p1066 start tag, such as "", and an p1067 p1068 end tag , such as " ". (Certain start tags and end tags can in certain cases be omitted and are implied by other tags.) Tags have to be nested such that elements are all completely within each other, without overlapping:



This is very wrong!





This is correct.



This specification defines a set of elements that can be used in HTML, along with rules about the ways in which the elements can be nested.

Elements can have attributes, which control how the elements work. In the example below, there is a p284 hyperlink , formed using the

a p239 p285 element and its href attribute:

simple

Attributes p1067 p1067 p1067 are placed inside the start tag, and consist of a name and a value, separated by an "=" character. The attribute value can remain p1067 unquoted if it doesn't contain ASCII whitespace or any of " ' ` = < or >. Otherwise, it has to be quoted using either single or double quotes. The value, along with the "=" character, can be omitted altogether if the value is the empty string.





HTML user agents (e.g., web browsers) then parse this markup, turning it into a DOM (Document Object Model) tree. A DOM tree is an in-memory representation of a document.

DOM trees contain several kinds of nodes, in particular a DocumentType node, Element nodes, Text nodes, Comment nodes, and in some cases ProcessingInstruction nodes.

The p30 markup snippet at the top of this section would be turned into the following DOM tree:

DOCTYPE: html

html p153 p141 lang ="en"

head p154

#text: ⏎␣␣

title p155

#text: Sample page

#text: ⏎␣

#text: ⏎␣

body p179

#text: ⏎␣␣

h1 p191

#text: Sample page

#text: ⏎␣␣

p p213

#text: This is a

31

a p239 p285 href="demo.html"

#text: simple

#text: sample.

#text: ⏎␣␣

#comment: this is a comment

#text: ⏎␣⏎

The p153 document element of this tree is the html element, which is the element always found in that position in HTML documents. It contains two elements, p154 p179 head and body , as well as a Text node between them.

There are many more Text nodes in the DOM tree than one would initially expect, because the source contains a number of spaces (represented here by "␣") and line breaks ("⏎") that all end up as Text nodes in the DOM. However, for historical reasons not all of the spaces and line breaks in the original markup appear in the DOM. In particular, all the whitespace before p154 head start tag ends up being dropped silently, and all the whitespace after the p179 p179 body end tag ends up placed at the end of the body .

The p154 p155 head element contains a title element, which itself contains a Text node with the text "Sample page". Similarly, the

body p179 p191 p213 element contains an h1 element, a p element, and a comment.



This DOM tree can be manipulated from scripts in the page. Scripts (typically in JavaScript) are small programs that can be embedded using the p614 p943 script element or using event handler content attributes. For example, here is a form with a script that sets the value of the form's p554 output element to say "Hello World":

<form name="main">

Result: <output name="result">

<script>

document.forms.main.elements.result.value = 'Hello World';





Each element in the DOM tree is represented by an object, and these objects have APIs so that they can be manipulated. For instance, a link (e.g. the p239 p285 a element in the tree above) can have its " href " attribute changed in several ways:

var a = document.links[0]; // obtain the first link in the document

a.href = 'sample.html'; // change the destination URL of the link

a.protocol = 'https'; // change just the scheme part of the URL a.setAttribute('href', 'https://example.com/'); // change the content attribute directly Since DOM trees are used as the way to represent HTML documents when they are processed and presented by implementations (especially interactive implementations like web browsers), this specification is mostly phrased in terms of DOM trees, instead of the markup described above.



HTML documents represent a media-independent description of interactive content. HTML documents might be rendered to a screen, or through a speech synthesizer, or on a braille display. To influence exactly how such rendering takes place, authors can use a styling language such as CSS.

In the following example, the page has been made yellow-on-blue using CSS.





Sample styled page





Sample styled page





This page is just a demo.





32





For more details on how to use HTML, authors are encouraged to consult tutorials and guides. Some of the examples included in this specification might also be of use, but the novice author is cautioned that this specification, by necessity, defines the language with a level of detail that might be difficult to understand at first.



1.10.1 Writing secure applications with HTML p33 §

This section is non-normative.

When HTML is used to create interactive sites, care needs to be taken to avoid introducing vulnerabilities through which attackers can compromise the integrity of the site itself or of the site's users.

A comprehensive study of this matter is beyond the scope of this document, and authors are strongly encouraged to study the matter in more detail. However, this section attempts to provide a quick introduction to some common pitfalls in HTML application development.

The security model of the web is based on the concept of "origins", and correspondingly many of the potential attacks on the web involve cross-origin actions. p1279 [ORIGIN]

Not validating user input

Cross-site scripting (XSS)

SQL injection

When accepting untrusted input, e.g. user-generated content such as text comments, values in URL parameters, messages from third-party sites, etc, it is imperative that the data be validated before use, and properly escaped when displayed. Failing to do this can allow a hostile user to perform a variety of attacks, ranging from the potentially benign, such as providing bogus user information like a negative age, to the serious, such as running scripts every time a user looks at a page that includes the information, potentially propagating the attack in the process, to the catastrophic, such as deleting all data in the server.

When writing filters to validate user input, it is imperative that filters always be safelist-based, allowing known-safe constructs and disallowing all other input. Blocklist-based filters that disallow known-bad inputs and allow everything else are not secure, as not everything that is bad is yet known (for example, because it might be invented in the future).

Example

For example, suppose a page looked at its URL's query string to determine what to display, and the site then redirected the user to that page to display a message, as in:





Say Hello





Say Welcome





Say Kittens





If the message was just displayed to the user without escaping, a hostile attacker could then craft a URL that contained a script element:

https://example.com/message.cgi?say=%3Cscript%3Ealert%28%27Oh%20no%21%27%29%3C/script%3E

If the attacker then convinced a victim user to visit this page, a script of the attacker's choosing would run on the page. Such a script could do any number of hostile actions, limited only by what the site offers: if the site is an e-commerce shop, for instance, such a script could cause the user to unknowingly make arbitrarily many unwanted purchases.

This is called a cross-site scripting attack.

There are many constructs that can be used to try to trick a site into executing code. Here are some that authors are encouraged to consider when writing safelist filters:

• When allowing harmless-seeming elements like p321 img, it is important to safelist any provided attributes as well. If one

allowed all attributes then an attacker could, for instance, use the p950 onload attribute to run arbitrary script.

• When allowing URLs to be provided (e.g. for links), the scheme of each URL also needs to be explicitly safelisted, as there

33





are many schemes that can be abused. The most prominent example is " p882 javascript: ", but user agents can implement (and indeed, have historically implemented) others.


• Allowing a p156 p614 base element to be inserted means any script elements in the page with relative links can be hijacked,

and similarly that any form submissions can get redirected to a hostile site.

Cross-site request forgery (CSRF)

If a site allows a user to make form submissions with user-specific side-effects, for example posting messages on a forum under the user's name, making purchases, or applying for a passport, it is important to verify that the request was made by the user intentionally, rather than by another site tricking the user into making the request unknowingly.

This problem exists because HTML forms can be submitted to other origins.

Sites can prevent such attacks by populating forms with user-specific hidden tokens, or by checking `Origin` headers on all requests.

Clickjacking

A page that provides users with an interface to perform actions that the user might not wish to perform needs to be designed so as to avoid the possibility that users can be tricked into activating the interface.

One way that a user could be so tricked is if a hostile site places the victim site in a small p362 iframe and then convinces the user to click, for instance by having the user play a reaction game. Once the user is playing the game, the hostile site can quickly position the iframe under the mouse cursor just as the user is about to click, thus tricking the user into clicking the victim site's interface.

To avoid this, sites that do not expect to be used in frames are encouraged to only enable their interface if they detect that they are

not in a frame (e.g. by comparing the p829 p819 window object to the value of the top attribute).



1.10.2 Common pitfalls to avoid when using the scripting APIs p34 §

This section is non-normative.

Scripts in HTML have "run-to-completion" semantics, meaning that the browser will generally run the script uninterrupted before doing anything else, such as firing further events or continuing to parse the document.

On the other hand, parsing of HTML files happens incrementally, meaning that the parser can pause at any point to let scripts run. This is generally a good thing, but it does mean that authors need to be careful to avoid hooking event handlers after the events could have possibly fired.

There are two techniques for doing this reliably: use p943 event handler content attributes, or create the element and add the event handlers in the same script. The latter is safe because, as mentioned earlier, scripts are run to completion before further events can fire.

Example

One way this could manifest itself is with p321 p1271 img elements and the load event. The event could fire as soon as the element has

been parsed, especially if the image has already been cached (which is common).

Here, the author uses the p950 p321 p1271 onload handler on an img element to catch the load event:



If the element is being added by script, then so long as the event handlers are added in the same script, the event will still not be

missed:



34





However, if the author first created the p321 img element and then in a separate script added the event listeners, there's a chance


that the p1271 load event would be fired in between, leading it to be missed:





1.10.3 How to catch mistakes when writing HTML: validators and conformance checkers p35 §

This section is non-normative.

Authors are encouraged to make use of conformance checkers (also known as validators) to catch common mistakes. The WHATWG

maintains a list of such tools at: https://whatwg.org/validator/



1.11 Conformance requirements for authors p35 §

This section is non-normative.

Unlike previous versions of the HTML specification, this specification defines in some detail the required processing for invalid documents as well as valid documents.

However, even though the processing of invalid content is in most cases well-defined, conformance requirements for documents are still important: in practice, interoperability (the situation in which all implementations process particular content in a reliable and identical or equivalent way) is not the only goal of document conformance requirements. This section details some of the more common reasons for still distinguishing between a conforming document and one with errors.



1.11.1 Presentational markup p35 §

This section is non-normative.

The majority of presentational features from previous versions of HTML are no longer allowed. Presentational markup in general has been found to have a number of problems: The use of presentational elements leads to poorer accessibility

While it is possible to use presentational markup in a way that provides users of assistive technologies (ATs) with an acceptable experience (e.g. using ARIA), doing so is significantly more difficult than doing so when using semantically-appropriate markup. Furthermore, even using such techniques doesn't help make pages accessible for non-AT non-graphical users, such as users of text-mode browsers.

Using media-independent markup, on the other hand, provides an easy way for documents to be authored in such a way that they work for more users (e.g. users of text browsers).

Higher cost of maintenance

It is significantly easier to maintain a site written in such a way that the markup is style-independent. For example, changing the color of a site that uses throughout requires changes across the entire site, whereas a similar change to a site based on CSS can be done by changing a single file.



35





Larger document sizes


Presentational markup tends to be much more redundant, and thus results in larger document sizes.

For those reasons, presentational markup has been removed from HTML in this version. This change should not come as a surprise; HTML4 deprecated presentational markup many years ago and provided a mode (HTML4 Transitional) to help authors move away from presentational markup; later, XHTML 1.1 went further and obsoleted those features altogether.

The only remaining presentational markup features in HTML are the p145 p175 p145 style attribute and the style element. Use of the style

attribute is somewhat discouraged in production environments, but it can be useful for rapid prototyping (where its rules can be directly moved into a separate style sheet later) and for providing specific styles in unusual cases where a separate style sheet would be inconvenient. Similarly, the p175 style element can be useful in syndication or for page-specific styles, but in general an external style sheet is likely to be more convenient when the styles apply to multiple pages.

It is also worth noting that some elements that were previously presentational have been redefined in this specification to be media-

independent: p274 p273 p215 p246 p245 p276 b , i , hr , s , small , and u .



1.11.2 Syntax errors p36 §

This section is non-normative.

The syntax of HTML is constrained to avoid a wide variety of problems.

Unintuitive error-handling behavior

Certain invalid syntax constructs, when parsed, result in DOM trees that are highly unintuitive.

Example

For example, the following markup fragment results in a DOM with an p215 hr element that is an earlier sibling of the

corresponding p451 table element:



* * *



...



Errors with optional error recovery

To allow user agents to be used in controlled environments without having to implement the more bizarre and convoluted error

handling rules, user agents are permitted to fail whenever encountering a p1078 parse error.

Errors where the error-handling behavior is not compatible with streaming user agents

Some error-handling behavior, such as the behavior for the



* * *



... example mentioned above, are incompatible with streaming user agents (user agents that process HTML files in one pass, without storing state). To avoid interoperability problems with such user agents, any syntax resulting in such behavior is considered invalid.

Errors that can result in infoset coercion

When a user agent based on XML is connected to an HTML parser, it is possible that certain invariants that XML enforces, such as element or attribute names never contain multiple colons, will be violated by an HTML file. Handling this can require that the parser coerce the HTML DOM into an XML-compatible infoset. Most syntax constructs that require such handling are considered invalid. (Comments containing two consecutive hyphens, or ending with a hyphen, are exceptions that are allowed in the HTML syntax.) Errors that result in disproportionately poor performance

Certain syntax constructs can result in disproportionately poor performance. To discourage the use of such constructs, they are typically made non-conforming.

Example

For example, the following markup results in poor performance, since all the unclosed p273 i elements have to be reconstructed in each paragraph, resulting in progressively more elements in each paragraph:



She dreamt.



She dreamt that she ate breakfast.



Then lunch.



And finally dinner.

36

The resulting DOM for this fragment would be:

p p213

i p273

#text: She dreamt.

p p213

i p273

i p273

#text: She dreamt that she ate breakfast.

p p213

i p273

i p273

i p273

#text: Then lunch.

p p213

i p273

i p273

i p273

i p273

#text: And finally dinner.

Errors involving fragile syntax constructs

There are syntax constructs that, for historical reasons, are relatively fragile. To help reduce the number of users who accidentally run into such problems, they are made non-conforming.

Example

For example, the parsing of certain named character references in attributes happens even with the closing semicolon being omitted. It is safe to include an ampersand followed by letters that do not form a named character reference, but if the letters are changed to a string that does form a named character reference, they will be interpreted as that character instead.

In this fragment, the attribute's value is "?bill&ted":

Bill and Ted

In the following fragment, however, the attribute's value is actually "?art©", not the intended "?art©", because even without the final semicolon, "©" is handled the same as "©" and thus gets interpreted as "©":

Art and Copy

To avoid this problem, all named character references are required to end with a semicolon, and uses of named character references without a semicolon are flagged as errors.

Thus, the correct way to express the above cases is as follows:

Bill and Ted

Art and Copy



Errors involving known interoperability problems in legacy user agents

Certain syntax constructs are known to cause especially subtle or serious problems in legacy user agents, and are therefore marked as non-conforming to help authors avoid them.

Example

For example, this is why the U+0060 GRAVE ACCENT character (`) is not allowed in unquoted attributes. In certain legacy user agents, it is sometimes treated as a quote character.



37





Example


Another example of this is the DOCTYPE, which is required to trigger no-quirks mode, because the behavior of legacy user

agents in quirks mode is often largely undocumented.

Errors that risk exposing authors to security attacks

Certain restrictions exist purely to avoid known security problems.

Example

For example, the restriction on using UTF-7 exists purely to avoid authors falling prey to a known cross-site-scripting attack

using UTF-7. p1282 [UTF7]

Cases where the author's intent is unclear

Markup where the author's intent is very unclear is often made non-conforming. Correcting these errors early makes later maintenance easier.

Example

For example, it is unclear whether the author intended the following to be an p191 p191 h1 heading or an h2 heading:





Contact details





Cases that are likely to be typos

When a user makes a simple typo, it is helpful if the error can be caught early, as this can save the author a lot of debugging time. This specification therefore usually considers it an error to use element names, attribute names, and so forth, that do not match the names defined in this specification.

Example

For example, if the author typed instead of



This provides the user with more context:



Table 1.

This table shows the total score obtained from rolling two

six-sided dice. The first row represents the value of the first

die, the first column the value of the second die. The total

is given in the cell that corresponds to the values of the

two dice.

1 2 3 4 5 6

1 2 3 4 5 6 7

2 3 4 5 6 7 8

3 4 5 6 7 8 9

4 5 6 7 8 9 10

5 6 7 8 9 1011

6 7 8 9 101112



✔ MDN

4.9.3 The colgroup element p46 §

0

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As a child of a p451 p459 p463 p462 p464 p465 table element, after any caption elements and before any thead , tbody , tfoot , and tr elements.

Content model p129:

If the p461 p131 span attribute is present: Nothing.

If the p461 p461 p630 span attribute is absent: Zero or more col and template elements.

Tag omission in text/html p129 :

A p460 p1066 p460 p461 colgroup element's start tag can be omitted if the first thing inside the colgroup element is a col element, and

if the element is not immediately preceded by another p460 p1067 colgroup element whose end tag has been omitted. (It can't be omitted if the element is empty.)

A p460 p1067 p460 colgroup element's end tag can be omitted if the colgroup element is not immediately followed by ASCII

460

whitespace p1075 or a comment.

Content attributes p129:

Global attributes p137

span p461 — Number of columns spanned by the element

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableColElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute unsigned long span;

// also has obsolete members

};



The p460 p124 p471 p471 p451 colgroup element represents a group of one or more columns in the table that is its parent, if it has a parent and that is a p451 table element.

If the p460 p461 colgroup element contains no col elements, then the element may have a span content attribute specified, whose value must be a p69 valid non-negative integer greater than zero and less than or equal to 1000.

The p460 p461 p471 colgroup element and its span attribute take part in the table model.

The p95 p96 span IDL attribute must reflect the content attribute of the same name. It is clamped to the range [1, 1000], and its default value is 1.



✔ MDN

4.9.4 The col element p46 §

1

Categories p129:

None.

Contexts in which this element can be used p129 :

As a child of a p460 p461 colgroup element that doesn't have a span attribute.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

span p461 — Number of columns spanned by the element

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p461 p460 HTMLTableColElement , as defined for colgroup elements.

If a p461 p460 p451 col element has a parent and that is a colgroup element that itself has a parent that is a table element, then the

col p461 p124 p471 p471 p460 element represents one or more columns in the column group represented by that colgroup.

The element may have a p69 span content attribute specified, whose value must be a valid non-negative integer greater than zero and less than or equal to 1000.

461

The p461 p461 p471 col element and its span attribute take part in the table model .

The p95 p96 span IDL attribute must reflect the content attribute of the same name. It is clamped to the range [1, 1000], and its default value is 1.



✔ MDN

4.9.5 The tbody element p46 §

2

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As a child of a p451 p459 p460 p463 p465 table element, after any caption , colgroup , and thead elements, but only if there are no tr

elements that are children of the p451 table element.

Content model p129:

Zero or more p465 p134 tr and script-supporting elements.

Tag omission in text/html p129 :

A p462 p1066 p462 p465 tbody element's start tag can be omitted if the first thing inside the tbody element is a tr element, and if the

element is not immediately preceded by a p462 p463 p464 p1067 tbody , thead , or tfoot element whose end tag has been omitted. (It can't be omitted if the element is empty.)

A p462 p1067 p462 p462 p464 tbody element's end tag can be omitted if the tbody element is immediately followed by a tbody or tfoot

element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableSectionElement : HTMLElement {

[HTMLConstructor] constructor();

[SameObject] readonly attribute HTMLCollection rows;

HTMLTableRowElement insertRow(optional long index = -1);

[CEReactions] undefined deleteRow(long index);

// also has obsolete members

};

The p462 p463 p464 HTMLTableSectionElement interface is also used for thead and tfoot elements.



The p462 p124 p471 p471 p451 tbody element represents a block of rows that consist of a body of data for the parent table element, if the

tbody p462 p451 element has a parent and it is a table .

The p462 p471 tbody element takes part in the table model .

For web developers (non-normative)

tbody p463 . rows

Returns an p465 HTMLCollection of the tr elements of the table section.

tr p463 = tbody . insertRow ( [ index ] )

Creates a p465 p465 tr element, inserts it into the table section at the position given by the argument, and returns the tr. The position is relative to the rows in the table section. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the table section.

If the given position is less than −1 or greater than the number of rows, throws an "IndexSizeError" DOMException.

462

tbody p463 . deleteRow(index)

Removes the p465 tr element with the given position in the table section. The position is relative to the rows in the table section. The index −1 is equivalent to deleting the last row of the table section. If the given position is less than −1 or greater than the index of the last row, or if there are no rows, throws an

"IndexSizeError" DOMException.

The p465 rows attribute must return an HTMLCollection rooted at this element, whose filter matches only tr elements that are children of this element.

The insertRow(index) method must act as follows:

1. If p463 index is less than −1 or greater than the number of elements in the rows collection, throw an "IndexSizeError"

DOMException.

2. Let p465 table row be the result of creating an element given this element's node document , tr, and the HTML namespace.

3. If p463 index is −1 or equal to the number of items in the rows collection, then append table row to this element.

4. Otherwise, p465 p463 insert table row as a child of this element, immediately before the index th tr element in the rows

collection.

5. Return table row.

The deleteRow(index) method must, when invoked, act as follows:

1. If p463 index is less than −1 or greater than or equal to the number of elements in the rows collection, then throw an

"IndexSizeError" DOMException.

2. If p463 p463 index is −1, then remove the last element in the rows collection from this element, or do nothing if the rows

collection is empty.

3. Otherwise, p463 remove the index th element in the rows collection from this element.



✔ MDN

4.9.6 The thead element p46 §

3

Categories p129:

None.

Contexts in which this element can be used p129 :

As a child of a p451 p459 p460 p462 p464 table element, after any caption , and colgroup elements and before any tbody , tfoot, and

tr p465 p463 p451 elements, but only if there are no other thead elements that are children of the table element.

Content model p129:

Zero or more p465 p134 tr and script-supporting elements.

Tag omission in text/html p129 :

A p463 p1067 p463 p462 p464 thead element's end tag can be omitted if the thead element is immediately followed by a tbody or tfoot

element.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p462 p462 HTMLTableSectionElement , as defined for tbody elements.

The p463 p124 p471 p471 p451 thead element represents the block of rows that consist of the column labels (headers) for the parent table

element, if the p463 p451 thead element has a parent and it is a table .

463

The p463 p471 thead element takes part in the table model .

Example

This example shows a p463 p468 p466 p463 thead element being used. Notice the use of both th and td elements in the thead element:

the first row is the headers, and the second row is an explanation of how to fill in the table.



, this would be flagged as an error and the author could correct the typo immediately.

Errors that could interfere with new syntax in the future

In order to allow the language syntax to be extended in the future, certain otherwise harmless features are disallowed.

Example

For example, "attributes" in end tags are ignored currently, but they are invalid, in case a future change to the language makes use of that syntax feature without conflicting with already-deployed (and valid!) content.

Some authors find it helpful to be in the practice of always quoting all attributes and always including all optional tags, preferring the consistency derived from such custom over the minor benefits of terseness afforded by making use of the flexibility of the HTML syntax. To aid such authors, conformance checkers can provide modes of operation wherein such conventions are enforced.



1.11.3 Restrictions on content models and on attribute values p38 §

This section is non-normative.

Beyond the syntax of the language, this specification also places restrictions on how elements and attributes can be specified. These restrictions are present for similar reasons: Errors involving content with dubious semantics

To avoid misuse of elements with defined meanings, content models are defined that restrict how elements can be nested when such nestings would be of dubious value.

Example

For example, this specification disallows nesting a p183 p271 section element inside a kbd element, since it is highly unlikely for an author to indicate that an entire section should be keyed in.



38

Errors that involve a conflict in expressed semantics

Similarly, to draw the author's attention to mistakes in the use of elements, clear contradictions in the semantics expressed are also considered conformance errors.

Example

In the fragments below, for example, the semantics are nonsensical: a separator cannot simultaneously be a cell, nor can a radio button be a progress bar.





* * *





Example

Another example is the restrictions on the content models of the p223 p225 ul element, which only allows li element children. Lists

by definition consist just of zero or more list items, so if a p223 p225 ul element contains something other than an li element, it's not clear what was meant.

Cases where the default styles are likely to lead to confusion

Certain elements have default styles or behaviors that make certain combinations likely to lead to confusion. Where these have equivalent alternatives without this problem, the confusing combinations are disallowed.

Example

For example, p238 p280 div elements are rendered as block boxes , and span elements as inline boxes. Putting a block box in an

inline box p238 p280 is unnecessarily confusing; since either nesting just div elements, or nesting just span elements, or nesting

span p280 p238 p238 p280 elements inside div elements all serve the same purpose as nesting a div element in a span element, but

only the latter involves a block box in an inline box, the latter combination is disallowed.



Example

Another example would be the way p133 p536 interactive content cannot be nested. For example, a button element cannot contain

a p549 textarea element. This is because the default behavior of such nesting interactive elements would be highly confusing to users. Instead of nesting these elements, they can be placed side by side.

Errors that indicate a likely misunderstanding of the specification

Sometimes, something is disallowed because allowing it would likely cause author confusion.

Example

For example, setting the p571 disabled attribute to the value "false" is disallowed, because despite the appearance of meaning that the element is enabled, it in fact means that the element is disabled (what matters for implementations is the presence of the attribute, not its value).

Errors involving limits that have been imposed merely to simplify the language

Some conformance errors simplify the language that authors need to learn.

Example

For example, the p444 p445 p445 p445 area element's shape attribute, despite accepting both circ and circle values in practice as

synonyms, disallows the use of the p445 circ value, so as to simplify tutorials and other learning aids. There would be no benefit to allowing both, but it would cause extra confusion when teaching the language.

Errors that involve peculiarities of the parser

Certain elements are parsed in somewhat eccentric ways (typically for historical reasons), and their content model restrictions are intended to avoid exposing the author to these issues.

Example

For example, a p487 p133 p487 form element isn't allowed inside phrasing content , because when parsed as HTML, a form element's

start tag will imply a p213 p135 p element's end tag. Thus, the following markup results in two paragraphs, not one:

39



Welcome.

Name:



It is parsed exactly like the following:



Welcome.

Name:





Errors that would likely result in scripts failing in hard-to-debug ways

Some errors are intended to help prevent script problems that would be hard to debug.

Example

This is why, for instance, it is non-conforming to have two p138 id attributes with the same value. Duplicate IDs lead to the wrong element being selected, with sometimes disastrous effects whose cause is hard to determine.

Errors that waste authoring time

Some constructs are disallowed because historically they have been the cause of a lot of wasted authoring time, and by encouraging authors to avoid making them, authors can save time in future efforts.

Example

For example, a p614 p616 script element's src attribute causes the element's contents to be ignored. However, this isn't obvious, especially if the element's contents appear to be executable script — which can lead to authors spending a lot of time trying to debug the inline script without realizing that it is not executing. To reduce this problem, this specification makes it non-

conforming to have executable script in a p614 p616 script element when the src attribute is present. This means that authors who are validating their documents are less likely to waste time with this kind of mistake.

Errors that involve areas that affect authors migrating between the HTML and XML syntaxes

Some authors like to write files that can be interpreted as both XML and HTML with similar results. Though this practice is discouraged in general due to the myriad of subtle complications involved (especially when involving scripting, styling, or any kind of automated serialization), this specification has a few restrictions intended to at least somewhat mitigate the difficulties. This makes it easier for authors to use this as a transitionary step when migrating between the HTML and XML syntaxes.

Example

For example, there are somewhat complicated rules surrounding the p141 lang and xml:lang attributes intended to keep the two synchronized.



Example

Another example would be the restrictions on the values of xmlns attributes in the HTML serialization, which are intended to ensure that elements in conforming documents end up in the same namespaces whether processed as HTML or XML.

Errors that involve areas reserved for future expansion

As with the restrictions on the syntax intended to allow for new syntax in future revisions of the language, some restrictions on the content models of elements and values of attributes are intended to allow for future expansion of the HTML vocabulary.

Example

For example, limiting the values of the p285 target attribute that start with an U+005F LOW LINE character (_) to only specific predefined values allows new predefined values to be introduced at a future time without conflicting with author-defined values.

Errors that indicate a mis-use of other specifications

Certain restrictions are intended to support the restrictions made by other specifications.

Example

For example, requiring that attributes that take media query lists use only valid media query lists reinforces the importance of following the conformance rules of that specification.



40





1.12 Suggested reading p41 §


This section is non-normative.

The following documents might be of interest to readers of this specification.

Character Model for the World Wide Web 1.0: Fundamentals p1275 [CHARMOD]

This Architectural Specification provides authors of specifications, software developers, and content developers with a common reference for interoperable text manipulation on the World Wide Web, building on the Universal Character Set, defined jointly by the Unicode Standard and ISO/IEC 10646. Topics addressed include use of the terms 'character', 'encoding' and 'string', a reference processing model, choice and identification of character encodings, character escaping, and string indexing.

Unicode Security Considerations p1282 [UTR36]

Because Unicode contains such a large number of characters and incorporates the varied writing systems of the world, incorrect usage can expose programs or systems to possible security attacks. This is especially important as more and more products are internationalized. This document describes some of the security considerations that programmers, system analysts, standards developers, and users should take into account, and provides specific recommendations to reduce the risk of problems.

Web Content Accessibility Guidelines (WCAG) p1282 [WCAG]

Web Content Accessibility Guidelines (WCAG) covers a wide range of recommendations for making web content more accessible. Following these guidelines will make content accessible to a wider range of people with disabilities, including blindness and low vision, deafness and hearing loss, learning disabilities, cognitive limitations, limited movement, speech disabilities, photosensitivity and combinations of these. Following these guidelines will also often make your web content more usable to users in general.

Authoring Tool Accessibility Guidelines (ATAG) 2.0 p1275 [ATAG]

This specification provides guidelines for designing web content authoring tools that are more accessible for people with disabilities. An authoring tool that conforms to these guidelines will promote accessibility by providing an accessible user interface to authors with disabilities as well as by enabling, supporting, and promoting the production of accessible web content by all authors.

User Agent Accessibility Guidelines (UAAG) 2.0 p1282 [UAAG]

This document provides guidelines for designing user agents that lower barriers to web accessibility for people with disabilities. User agents include browsers and other types of software that retrieve and render web content. A user agent that conforms to these guidelines will promote accessibility through its own user interface and through other internal facilities, including its ability to communicate with other technologies (especially assistive technologies). Furthermore, all users, not just users with disabilities, should find conforming user agents to be more usable.



41





2 Common infrastructure p42 §


This specification depends on p1278 Infra . [INFRA]



2.1 Terminology p42 §

This specification refers to both HTML and XML attributes and IDL attributes, often in the same context. When it is not clear which is being referred to, they are referred to as content attributes for HTML and XML attributes, and IDL attributes for those defined on IDL interfaces. Similarly, the term "properties" is used for both JavaScript object properties and CSS properties. When these are ambiguous they are qualified as object properties and CSS properties respectively.

Generally, when the specification states that a feature applies to p1064 p1184 the HTML syntax or the XML syntax, it also includes the other. When a feature specifically only applies to one of the two languages, it is called out by explicitly stating that it does not apply to the other format, as in "for HTML, ... (this does not apply to XML)".

This specification uses the term document to refer to any use of HTML, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications. The term is used to refer both to p115 Document objects and their descendant DOM trees, and to serialized byte streams using the p1064 p1184 HTML syntax or the XML syntax, depending on context.

In the context of the DOM structures, the terms HTML document and XML document are used as defined in DOM, and refer specifically to two different modes that p115 p1277 Document objects can find themselves in. [DOM] (Such uses are always hyperlinked to their definition.) In the context of byte streams, the term HTML document refers to resources labeled as p1241 text/html, and the term XML document refers to resources labeled with an XML MIME type.



For simplicity, terms such as shown, displayed, and visible might sometimes be used when referring to the way a document is rendered to the user. These terms are not meant to imply a visual medium; they must be considered to apply to other media in equivalent ways.



2.1.1 Parallelism p42 §

To run steps in parallel means those steps are to be run, one after another, at the same time as other logic in the standard (e.g., at the same time as the p931 event loop). This standard does not define the precise mechanism by which this is achieved, be it time-sharing cooperative multitasking, fibers, threads, processes, using different hyperthreads, cores, CPUs, machines, etc. By contrast, an operation that is to run immediately must interrupt the currently running task, run itself, and then resume the previously running task.

Note

For guidance on writing specifications that leverage parallelism, see p939 Dealing with the event loop from other specifications.

To avoid race conditions between different p42 p42 in parallel algorithms that operate on the same data, a parallel queue can be used.

A parallel queue represents a queue of algorithm steps that must be run in series.

A p42 parallel queue has an algorithm queue (a queue), initially empty.

To p42 p42 p42 enqueue steps to a parallel queue , enqueue the algorithm steps to the parallel queue 's algorithm queue.

To start a new parallel queue, run the following steps:

1. Let p42 parallelQueue be a new parallel queue.

2. Run the following steps p42 in parallel:

42





1. While true:


1. Let p42 steps be the result of dequeueing from parallelQueue 's algorithm queue.

2. If steps is not nothing, then run steps.

3. Assert: running p42 steps did not throw an exception, as steps running in parallel are not allowed to throw.

Note

Implementations are not expected to implement this as a continuously running loop. Algorithms in standards are to be easy to understand and are not necessarily great for battery life or performance.

3. Return parallelQueue.

Note

Steps running p42 p42 p42 in parallel can themselves run other steps in in parallel . E.g., inside a parallel queue it can be useful to run a

series of steps in parallel with the queue.



Example

Imagine a standard defined nameList (a list), along with a method to add a name to nameList, unless nameList already contains

name, in which case it rejects.

The following solution suffers from race conditions:

1. Let p be a new promise.

2. Run the following steps p42 in parallel:

1. If nameList contains name, reject p with a TypeError and abort these steps.

2. Do some potentially lengthy work.

3. Append name to nameList.

4. Resolve p with undefined.

3. Return p.

Two invocations of the above could run simultaneously, meaning name isn't in nameList during step 2.1, but it might be added

before step 2.3 runs, meaning name ends up in nameList twice.

Parallel queues solve this. The standard would let p42 nameListQueue be the result of starting a new parallel queue, then:

1. Let p be a new promise.

2. p42 Enqueue the following steps to nameListQueue:

1. If nameList contains name, reject p with a TypeError and abort these steps.

2. Do some potentially lengthy work.

3. Append name to nameList.

4. Resolve p with undefined.

3. Return p.

The steps would now queue and the race is avoided.



2.1.2 Resources p43 §

The specification uses the term supported when referring to whether a user agent has an implementation capable of decoding the semantics of an external resource. A format or type is said to be supported if the implementation can process an external resource of that format or type without critical aspects of the resource being ignored. Whether a specific resource is supported can depend on

43





what features of the resource's format are in use.


Example

For example, a PNG image would be considered to be in a supported format if its pixel data could be decoded and rendered, even

if, unbeknownst to the implementation, the image also contained animation data.



Example

An MPEG-4 video file would not be considered to be in a supported format if the compression format used was not supported, even

if the implementation could determine the dimensions of the movie from the file's metadata.

What some specifications, in particular the HTTP specifications, refer to as a representation is referred to in this specification as a resource p1278 . [HTTP]

A resource's critical subresources are those that the resource needs to have available to be correctly processed. Which resources are considered critical or not is defined by the specification that defines the resource's format.

For CSS style sheets, we tentatively define here that their critical subresources are other style sheets imported via @import rules, including those indirectly imported by other imported style sheets.



This definition is not fully interoperable; furthermore, some user agents seem to count resources like background images or web

fonts as critical subresources. Ideally, the CSS Working Group would define this; see w3c/csswg-drafts issue #1088 to track progress on that front.



2.1.3 XML compatibility p44 §

To ease migration from HTML to XML, UAs conforming to this specification will place elements in HTML in the http://www.w3.org/

1999/xhtml namespace, at least for the purposes of the DOM and CSS. The term "HTML elements" refers to any element in that namespace, even in XML documents.

Except where otherwise stated, all elements defined or mentioned in this specification are in the HTML namespace ("http://www.w3.org/1999/xhtml"), and all attributes defined or mentioned in this specification have no namespace.

The term p536 element type is used to refer to the set of elements that have a given local name and namespace. For example, button

elements are elements with the element type p536 button , meaning they have the local name "button" and (implicitly as defined above) the HTML namespace.

Attribute names are said to be XML-compatible if they match the Name production defined in XML and they contain no U+003A COLON characters (:). p1283 [XML]



2.1.4 DOM trees p44 §

When it is stated that some element or attribute is ignored, or treated as some other value, or handled as if it was something else, this refers only to the processing of the node after it is in the DOM. A user agent must not mutate the DOM in such situations.

A content attribute is said to change value only if its new value is different than its previous value; setting an attribute to a value it already has does not change it.

The term empty, when used for an attribute value, Text node, or string, means that the length of the text is zero (i.e., not even containing controls or U+0020 SPACE).

A node A is inserted into a node B when the insertion steps are invoked with A as the argument and A's new parent is B. Similarly, a node A is removed from a node B when the removing steps are invoked with A as the removedNode argument and B as the oldParent argument.

A node is inserted into a document when the insertion steps are invoked with it as the argument and it is now in a document tree.

Analogously, a node is removed from a document when the removing steps are invoked with it as the argument and it is now no longer in a document tree.

44





A node becomes connected when the insertion steps are invoked with it as the argument and it is now connected. Analogously, a node becomes disconnected when the removing steps are invoked with it as the argument and it is now no longer connected.


A node is p814 browsing-context connected when it is connected and its shadow-including root 's browsing context is non-null. A node becomes browsing-context connected when the insertion steps are invoked with it as the argument and it is now browsing-context

connected p45. A node becomes browsing-context disconnected either when the removing steps are invoked with it as the argument and it is now no longer p45 p814 browsing-context connected , or when its shadow-including root 's browsing context becomes null.



2.1.5 Scripting p45 §

The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo".

An IDL attribute is said to be getting when its value is being retrieved (e.g. by author script), and is said to be setting when a new value is assigned to it.

If a DOM object is said to be live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.



2.1.6 Plugins p45 §

The term plugin refers to an implementation-defined set of content handlers used by the user agent that can take part in the user agent's rendering of a p115 p817 p115 Document object, but that neither act as child browsing contexts of the Document nor introduce any

Node p115 objects to the Document's DOM.

Typically such content handlers are provided by third parties, though a user agent can also designate built-in content handlers as plugins.

A user agent must not consider the types p45 text/plain and application/octet-stream as having a registered plugin.

Example

One example of a plugin would be a PDF viewer that is instantiated in a p814 browsing context when the user navigates to a PDF file.

This would count as a plugin regardless of whether the party that implemented the PDF viewer component was the same as that

which implemented the user agent itself. However, a PDF viewer application that launches separate from the user agent (as

opposed to using the same interface) is not a plugin by this definition.



Note

This specification does not define a mechanism for interacting with plugins, as it is expected to be user-agent- and platform-

specific. Some UAs might opt to support a plugin mechanism such as the Netscape Plugin API; others might use remote content

converters or have built-in support for certain types. Indeed, this specification doesn't require user agents to support plugins at all.

[NPAPI] p1279

A plugin can be p366 secured if it honors the semantics of the sandbox attribute.

Example

For example, a secured plugin would prevent its contents from creating popups when the plugin is instantiated inside a sandboxed

iframe p362 .



⚠Warning!

Browsers should take extreme care when interacting with external content intended for p45 plugins. When third-

party software is run with the same privileges as the user agent itself, vulnerabilities in the third-party software

become as dangerous as those in the user agent.



45





Since different users having different sets of p45 plugins provides a tracking vector that increases the chances of users being uniquely identified, user agents are encouraged to support the exact same set of p45 plugins for each user.




2.1.7 Character encodings p46 §

A character encoding, or just encoding where that is not ambiguous, is a defined way to convert between byte streams and Unicode strings, as defined in Encoding. An encoding has an encoding name and one or more encoding labels, referred to as the encoding's name p1277 and labels in the Encoding standard. [ENCODING]



2.1.8 Conformance classes p46 §

This specification describes the conformance criteria for user agents (relevant to implementers) and documents (relevant to authors and authoring tool implementers).

Conforming documents are those that comply with all the conformance criteria for documents. For readability, some of these conformance requirements are phrased as conformance requirements on authors; such requirements are implicitly requirements on documents: by definition, all documents are assumed to have had an author. (In some cases, that author may itself be a user agent — such user agents are subject to additional rules, as explained below.) Example

For example, if a requirement states that "authors must not use the foobar element", it would imply that documents are not

allowed to contain elements named foobar.



Note

There is no implied relationship between document conformance requirements and implementation conformance requirements.

User agents are not free to handle non-conformant documents as they please; the processing model described in this specification

applies to implementations regardless of the conformity of the input documents.

User agents fall into several (overlapping) categories with different conformance requirements.

Web browsers and other interactive user agents

Web browsers that support p1184 the XML syntax must process elements and attributes from the HTML namespace found in XML documents as described in this specification, so that users can interact with them, unless the semantics of those elements have been overridden by other specifications.

Example

A conforming web browser would, upon finding a p614 script element in an XML document, execute the script contained in that element. However, if the element is found within a transformation expressed in XSLT (assuming the user agent also supports

XSLT), then the processor would instead treat the p614 script element as an opaque element that forms part of the transform.

Web browsers that support p1064 the HTML syntax must process documents labeled with an HTML MIME type as described in this specification, so that users can interact with them.

User agents that support scripting must also be conforming implementations of the IDL fragments in this specification, as described

in p1282 Web IDL . [WEBIDL]

Note

Unless explicitly stated, specifications that override the semantics of HTML elements do not override the requirements on DOM

objects representing those elements. For example, the p614 script element in the example above would still implement the

HTMLScriptElement p615 interface.

Non-interactive presentation user agents

User agents that process HTML and XML documents purely to render non-interactive versions of them must comply to the same conformance criteria as web browsers, except that they are exempt from requirements regarding user interaction.

46

Note

Typical examples of non-interactive presentation user agents are printers (static UAs) and overhead displays (dynamic UAs). It

is expected that most static non-interactive presentation user agents will also opt to p47 lack scripting support.



Example

A non-interactive but dynamic presentation UA would still execute scripts, allowing forms to be dynamically submitted, and so forth. However, since the concept of "focus" is irrelevant when the user cannot interact with the document, the UA would not need to support any of the focus-related DOM APIs.

Visual user agents that support the suggested default rendering

User agents, whether interactive or not, may be designated (possibly as a user option) as supporting the suggested default rendering defined by this specification.

This is not required. In particular, even user agents that do implement the suggested default rendering are encouraged to offer settings that override this default to improve the experience for the user, e.g. changing the color contrast, using different focus styles, or otherwise making the experience more accessible and usable to the user.

User agents that are designated as supporting the suggested default rendering must, while so designated, implement the rules the

rendering section p1188 defines as the behavior that user agents are expected to implement.

User agents with no scripting support

Implementations that do not support scripting (or which have their scripting features disabled entirely) are exempt from supporting the events and DOM interfaces mentioned in this specification. For the parts of this specification that are defined in terms of an events model or in terms of the DOM, such user agents must still act as if events and the DOM were supported.

Note

Scripting can form an integral part of an application. Web browsers that do not support scripting, or that have scripting disabled, might be unable to fully convey the author's intent.

Conformance checkers

Conformance checkers must verify that a document conforms to the applicable conformance criteria described in this specification. Automated conformance checkers are exempt from detecting errors that require interpretation of the author's intent (for example,

while a document is non-conforming if the content of a p219 blockquote element is not a quote, conformance checkers running

without the input of human judgement do not have to check that p219 blockquote elements only contain quoted material).

Conformance checkers must check that the input document conforms when parsed without a p814 browsing context (meaning that no

scripts are run, and that the parser's p1093 scripting flag is disabled), and should also check that the input document conforms when

parsed with a p814 browsing context in which scripts execute, and that the scripts never cause non-conforming states to occur other than transiently during script execution itself. (This is only a "SHOULD" and not a "MUST" requirement because it has been proven to

be impossible. p1275 [COMPUTABLE])

The term "HTML validator" can be used to refer to a conformance checker that itself conforms to the applicable requirements of this specification.

Note

XML DTDs cannot express all the conformance requirements of this specification. Therefore, a validating XML processor and a DTD cannot constitute a conformance checker. Also, since neither of the two authoring formats defined in this specification are applications of SGML, a validating SGML system cannot constitute a conformance checker either.

To put it another way, there are three types of conformance criteria:

1. Criteria that can be expressed in a DTD.

2. Criteria that cannot be expressed by a DTD, but can still be checked by a machine.

3. Criteria that can only be checked by a human.

A conformance checker must check for the first two. A simple DTD-based validator only checks for the first class of errors and is therefore not a conforming conformance checker according to this specification.



47

Data mining tools

Applications and tools that process HTML and XML documents for reasons other than to either render the documents or check them for conformance should act in accordance with the semantics of the documents that they process.

Example

A tool that generates p202 document outlines but increases the nesting level for each paragraph and does not increase the nesting level for each section would not be conforming.

Authoring tools and markup generators

Authoring tools and markup generators must generate p46 conforming documents. Conformance criteria that apply to authors also apply to authoring tools, where appropriate.

Authoring tools are exempt from the strict requirements of using elements only for their specified purpose, but only to the extent that authoring tools are not yet able to determine author intent. However, authoring tools must not automatically misuse elements or encourage their users to do so.

Example

For example, it is not conforming to use an p199 address element for arbitrary contact information; that element can only be used

for marking up contact information for its nearest p181 p179 article or body element ancestor. However, since an authoring tool is likely unable to determine the difference, an authoring tool is exempt from that requirement. This does not mean, though, that

authoring tools can use p199 address elements for any block of italics text (for instance); it just means that the authoring tool

doesn't have to verify that when the user uses a tool for inserting contact information for an p181 article element, that the user really is doing that and not inserting something else instead.



Note

In terms of conformance checking, an editor has to output documents that conform to the same extent that a conformance checker will verify.

When an authoring tool is used to edit a non-conforming document, it may preserve the conformance errors in sections of the document that were not edited during the editing session (i.e. an editing tool is allowed to round-trip erroneous content). However, an authoring tool must not claim that the output is conformant if errors have been so preserved.

Authoring tools are expected to come in two broad varieties: tools that work from structure or semantic data, and tools that work on a What-You-See-Is-What-You-Get media-specific editing basis (WYSIWYG).

The former is the preferred mechanism for tools that author HTML, since the structure in the source information can be used to make informed choices regarding which HTML elements and attributes are most appropriate.

However, WYSIWYG tools are legitimate. WYSIWYG tools should use elements they know are appropriate, and should not use elements that they do not know to be appropriate. This might in certain extreme cases mean limiting the use of flow elements to

just a few elements, like p238 p274 p273 p280 p145 div , b , i , and span and making liberal use of the style attribute.

All authoring tools, whether WYSIWYG or not, should make a best effort attempt at enabling users to create well-structured, semantically rich, media-independent content.

User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g., to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.

For compatibility with existing content and prior specifications, this specification describes two authoring formats: one based on p1184 p1064 p1064 XML , and one using a custom format inspired by SGML (referred to as the HTML syntax). Implementations must support at least one of these two formats, although supporting both is encouraged.

Some conformance requirements are phrased as requirements on elements, attributes, methods or objects. Such requirements fall into two categories: those describing content model restrictions, and those describing implementation behavior. Those in the former category are requirements on documents and authoring tools. Those in the second category are requirements on user agents. Similarly, some conformance requirements are phrased as requirements on authors; such requirements are to be interpreted as conformance requirements on the documents that authors produce. (In other words, this specification does not distinguish between conformance criteria on authors and conformance criteria on documents.)



48





2.1.9 Dependencies p49 §


This specification relies on several other underlying specifications. ✔ MDN

Infra

The following terms are defined in p1278 Infra : [INFRA]

• The general iteration terms while, continue, and break.

• implementation-defined

• tracking vector

• code point and its synonym character

• surrogate

• scalar value

• tuple

• noncharacter

• string, code unit, length, and code point length

• The string equality operations is and identical to

• scalar value string

• ASCII whitespace

• control

• ASCII digit

• ASCII upper hex digit

• ASCII lower hex digit

• ASCII hex digit

• ASCII upper alpha

• ASCII lower alpha

• ASCII alpha

• ASCII alphanumeric

• isomorphic decode

• ASCII lowercase

• ASCII uppercase

• ASCII case-insensitive

• strip newlines

• normalize newlines

• strip leading and trailing ASCII whitespace

• strip and collapse ASCII whitespace

• split a string on ASCII whitespace

• split a string on commas

• collect a sequence of code points and its associated position variable

• skip ASCII whitespace

• The ordered map data structure and the associated definitions for value, entry, exists, getting the value of an

entry, setting the value of an entry, removing an entry, clear, getting the keys, size, and iterate

• The list data structure and the associated definitions for append, extend, replace, remove, empty, contains, size, is

empty, iterate, and clone

• The stack data structure and the associated definitions for push and pop

• The queue data structure and the associated definitions for enqueue and dequeue

• The ordered set data structure and the associated definition for append and union

• The struct specification type and the associated definition for item

• The forgiving-base64 encode and forgiving-base64 decode algorithms

• HTML namespace

• MathML namespace

• SVG namespace

• XLink namespace

• XML namespace

• XMLNS namespace

Unicode and Encoding

The Unicode character set is used to represent textual data, and Encoding defines requirements around character encodings.

[UNICODE] p1282

Note

This specification p46 introduces terminology based on the terms defined in those specifications, as described earlier.

The following terms are used as defined in p1277 Encoding : [ENCODING]

• Getting an encoding

• Get an output encoding

• The generic decode algorithm which takes a byte stream and an encoding and returns a character stream

• The UTF-8 decode algorithm which takes a byte stream and returns a character stream, additionally stripping one

leading UTF-8 Byte Order Mark (BOM), if any

• The UTF-8 decode without BOM algorithm which is identical to UTF-8 decode except that it does not strip one leading

UTF-8 Byte Order Mark (BOM)

• The encode algorithm which takes a character stream and an encoding and returns a byte stream

• The UTF-8 encode algorithm which takes a character stream and returns a byte stream

• The BOM sniff algorithm which takes a byte stream and returns an encoding or null.



49

XML and related specifications

Implementations that support p1184 the XML syntax for HTML must support some version of XML, as well as its corresponding

namespaces specification, because that syntax uses an XML serialization with namespaces. p1283 p1283 [XML] [XMLNS]

Data mining tools and other user agents that perform operations on content without running scripts, evaluating CSS or XPath expressions, or otherwise exposing the resulting DOM to arbitrary content, may "support namespaces" by just asserting that their DOM node analogues are in certain namespaces, without actually exposing the namespace strings.

Note

In p1064 the HTML syntax, namespace prefixes and namespace declarations do not have the same effect as in XML. For instance, the colon has no special meaning in HTML element names.



The attribute with the name p1283 space in the XML namespace is defined by Extensible Markup Language ( XML ). [XML]

The p1283 Name production is defined in XML . [XML]

This specification also references the <?xml-stylesheet?> processing instruction, defined in Associating Style Sheets with XML

documents p1283 . [XMLSSPI]

This specification also non-normatively mentions the XSLTProcessor interface and its transformToFragment() and

transformToDocument() p1283 methods. [XSLTP]

URLs

The following terms are defined in p1282 URL : [URL]

• host

• public suffix

• domain

• IPv4 address

• IPv6 address

• URL

• Origin of URLs

• Absolute URL

• Relative URL

• registrable domain

• The URL parser and basic URL parser as well as these parser states:

◦ scheme start state

◦ host state

◦ hostname state

◦ port state

◦ path start state

◦ query state

◦ fragment state

• URL record, as well as its individual components:

◦ scheme

◦ username

◦ password

◦ host

◦ port

◦ path

◦ query

◦ fragment

◦ cannot-be-a-base-URL flag

◦ object

• valid URL string

• The cannot have a username/password/port concept

• The URL serializer

• The host parser

• The host serializer

• Host equals

• URL equals

• serialize an integer

• Default encode set

• component percent-encode set

• UTF-8 percent-encode

• percent-decode

• set the username

• set the password

• The application/x-www-form-urlencoded format

• The application/x-www-form-urlencoded serializer

A number of schemes and protocols are referenced by this specification also:

50

• The p1275 about: scheme [ABOUT]

• The p1277 blob: scheme [FILEAPI]

• The p1280 data: scheme [RFC2397]

• The p1278 http: scheme [HTTP]

• The p1278 https: scheme [HTTP]

• The p1279 mailto: scheme [MAILTO]

• The p1281 sms: scheme [SMS]

• The p1282 urn: scheme [URN]

Media fragment syntax p1279 is defined in Media Fragments URI . [MEDIAFRAG]

HTTP and related specifications

The following terms are defined in the HTTP specifications: p1278 [HTTP]

• `Accept` header

• `Accept-Language` header

• `Cache-Control` header

• `Content-Disposition` header

• `Content-Language` header

• `Last-Modified` header

• `Referer` header

The following terms are defined in p1275 HTTP State Management Mechanism : [COOKIES]

• cookie-string

• receives a set-cookie-string

• `Cookie` header

The following term is defined in p1282 Web Linking : [WEBLINK]

• `Link` header

The following terms are defined in p1281 Structured Field Values for HTTP : [STRUCTURED-FIELDS]

• structured header

• boolean

• token

• parameters

The following terms are defined in p1279 MIME Sniffing : [MIMESNIFF]

• MIME type

• valid MIME type string

• valid MIME type string with no parameters

• HTML MIME type

• JavaScript MIME type and JavaScript MIME type essence match

• JSON MIME type

• XML MIME type

Fetch

The following terms are defined in p1277 Fetch : [FETCH]

• ABNF

• about:blank

• An HTTP(S) scheme

• A local scheme

• A network scheme

• A fetch scheme

• CORS protocol

• default `User-Agent` value

• extract a MIME type

• fetch

• HTTP-redirect fetch

• ok status

• navigation request

• network error

• `Origin` header

• `Cross-Origin-Resource-Policy` header

• process response

• getting a structured field value

• set

• get, decode, and split

• terminate

• cross-origin resource policy check

• the RequestCredentials enumeration

• the RequestDestination enumeration

• the fetch() method

• serialize a response URL for reporting

51

• response and its associated:

◦ type

◦ url

◦ url list

◦ status

◦ header list

◦ body

◦ internal response

◦ CSP list

◦ location URL

• request and its associated:

◦ url

◦ method

◦ header list

◦ body

◦ client

◦ URL list

◦ current URL

◦ reserved client

◦ replaces client id

◦ initiator

◦ destination

◦ potential destination

◦ translating a potential destination

◦ script-like destinations

◦ priority

◦ origin

◦ referrer

◦ synchronous flag

◦ mode

◦ credentials mode

◦ use-URL-credentials flag

◦ unsafe-request flag

◦ cache mode

◦ redirect mode

◦ referrer policy

◦ cryptographic nonce metadata

◦ integrity metadata

◦ parser metadata

◦ reload-navigation flag

◦ history-navigation flag

The following terms are defined in p1280 Referrer Policy : [REFERRERPOLICY]

• referrer policy

• The `Referrer-Policy` HTTP header

• The parse a referrer policy from a `Referrer-Policy` header algorithm

• The "no-referrer", "no-referrer-when-downgrade", "origin-when-cross-origin", and "unsafe-url" referrer policies

• The default referrer policy

The following terms are defined in p1279 Mixed Content : [MIX]

• a priori authenticated URL

Paint Timing

The following terms are defined in p1279 Paint Timing : [PAINTTIMING]

• mark paint timing

Long Tasks

The following terms are defined in p1278 Long Tasks : [LONGTASKS]

• report long tasks

Web IDL

The IDL fragments in this specification must be interpreted as required for conforming IDL fragments, as described in Web IDL.

[WEBIDL] p1282

The following terms are defined in Web IDL:

• this

• extended attribute

• named constructor

• constructor operation

• overridden constructor steps

• internally create a new object implementing the interface

• array index property name

• supported property indices

• determine the value of an indexed property

52

• set the value of an existing indexed property

• set the value of a new indexed property

• support named properties

• supported property names

• determine the value of a named property

• set the value of an existing named property

• set the value of a new named property

• delete an existing named property

• perform a security check

• platform object

• legacy platform object

• primary interface

• interface object

• include

• inherit

• interface prototype object

• [[Realm]] field of a platform object

• callback context

• frozen array and creating a frozen array

• create a new object implementing the interface

• callback this value

• converting between Web IDL types and JS types

• invoking and constructing callback functions

• converting to a sequence of Unicode scalar values

• overload resolution algorithm

• exposed

• a promise rejected with

• upon rejection

• [LegacyFactoryFunction]

• [LegacyLenientThis]

• [LegacyNullToEmptyString]

• [LegacyOverrideBuiltIns]

• [LegacyTreatNonObjectAsNull]

• [LegacyUnenumerableNamedProperties]

• [LegacyUnforgeable]

The Web IDL also defines the following types that are used in Web IDL fragments in this specification:

• ArrayBuffer

• ArrayBufferView

• boolean

• DOMString

• double

• enumeration

• Error

• Function

• long

• object

• Uint8ClampedArray

• unrestricted double

• unsigned long

• USVString

• VoidFunction

The term throw in this specification is used as defined in Web IDL. The DOMException type and the following exception names are defined by Web IDL and used by this specification:

• "IndexSizeError"

• "HierarchyRequestError"

• "InvalidCharacterError"

• "NotFoundError"

• "NotSupportedError"

• "InvalidStateError"

• "SyntaxError"

• "InvalidAccessError"

• "SecurityError"

• "NetworkError"

• "AbortError"

• "QuotaExceededError"

• "DataCloneError"

• "EncodingError"

• "NotAllowedError"

When this specification requires a user agent to create a Date object representing a particular time (which could be the special value Not-a-Number), the milliseconds component of that time, if any, must be truncated to an integer, and the time value of the

newly created Date object must represent the resulting truncated time.

Example

For instance, given the time 23045 millionths of a second after 01:00 UTC on January 1st 2000, i.e. the time

53

2000-01-01T00:00:00.023045Z, then the Date object created representing that time would represent the same time as that created representing the time 2000-01-01T00:00:00.023Z, 45 millionths earlier. If the given time is NaN, then the result is a

Date object that represents a time value NaN (indicating that the object does not represent a specific instant of time).

JavaScript

Some parts of the language described by this specification only support JavaScript as the underlying scripting language.

[JAVASCRIPT] p1278

Note

The term "JavaScript" is used to refer to ECMA-262, rather than the official term ECMAScript, since the term JavaScript is more

widely known. Similarly, the MIME type used to refer to JavaScript in this specification is text/javascript, since that is the

most commonly used type, p27 p1280 despite it being an officially obsoleted type according to RFC 4329. [RFC4329]

The following terms are defined in the JavaScript specification and used in this specification:

• active function object

• agent and agent cluster

• automatic semicolon insertion

• candidate execution

• The current Realm Record

• early error

• forward progress

• invariants of the essential internal methods

• JavaScript execution context

• JavaScript execution context stack

• JavaScript realm

• EnvironmentRecord

• NewTarget

• running JavaScript execution context

• surrounding agent

• abstract closure

• immutable prototype exotic object

• Well-Known Symbols, including @@hasInstance, @@isConcatSpreadable, @@toPrimitive, and @@toStringTag

• Well-Known Intrinsic Objects, including %Array.prototype%, %Error.prototype%, %EvalError.prototype%,

%Function.prototype%, %JSON.parse%, %Object.prototype%, %Object.prototype.valueOf%, %RangeError.prototype%, %ReferenceError.prototype%, %SyntaxError.prototype%, %TypeError.prototype%, and %URIError.prototype%

• The FunctionBody production

• The Module production

• The Pattern production

• The Script production

• The Type notation

• The Completion Record specification type

• The List and Record specification types

• The Property Descriptor specification type

• The Script Record specification type

• The Cyclic Module Record specification type

• The Source Text Module Record specification type and its Evaluate and Link methods

• The ArrayCreate abstract operation

• The Call abstract operation

• The Construct abstract operation

• The CopyDataBlockBytes abstract operation

• The CreateByteDataBlock abstract operation

• The CreateDataProperty abstract operation

• The DetachArrayBuffer abstract operation

• The EnumerableOwnPropertyNames abstract operation

• The FinishDynamicImport abstract operation

• The OrdinaryFunctionCreate abstract operation

• The Get abstract operation

• The GetActiveScriptOrModule abstract operation

• The GetFunctionRealm abstract operation

• The HasOwnProperty abstract operation

• The HostEnqueuePromiseJob abstract operation

• The HostEnsureCanCompileStrings abstract operation

• The HostImportModuleDynamically abstract operation

• The HostPromiseRejectionTracker abstract operation

• The HostResolveImportedModule abstract operation

• The InitializeHostDefinedRealm abstract operation

• The IsAccessorDescriptor abstract operation

• The IsCallable abstract operation

• The IsConstructor abstract operation

• The IsDataDescriptor abstract operation

• The IsDetachedBuffer abstract operation

• The IsSharedArrayBuffer abstract operation

• The NewObjectEnvironment abstract operation

54

• The NormalCompletion abstract operation

• The OrdinaryGetPrototypeOf abstract operation

• The OrdinarySetPrototypeOf abstract operation

• The OrdinaryIsExtensible abstract operation

• The OrdinaryPreventExtensions abstract operation

• The OrdinaryGetOwnProperty abstract operation

• The OrdinaryDefineOwnProperty abstract operation

• The OrdinaryGet abstract operation

• The OrdinarySet abstract operation

• The OrdinaryDelete abstract operation

• The OrdinaryOwnPropertyKeys abstract operation

• The ObjectCreate abstract operation

• The ParseModule abstract operation

• The ParseScript abstract operation

• The NewPromiseReactionJob abstract operation

• The NewPromiseResolveThenableJob abstract operation

• The RegExpBuiltinExec abstract operation

• The RegExpCreate abstract operation

• The RunJobs abstract operation

• The SameValue abstract operation

• The ScriptEvaluation abstract operation

• The SetImmutablePrototype abstract operation

• The ToBoolean abstract operation

• The ToString abstract operation

• The ToUint32 abstract operation

• The TypedArrayCreate abstract operation

• The Abstract Equality Comparison algorithm

• The Strict Equality Comparison algorithm

• The Atomics object

• The Date class

• The RegExp class

• The SharedArrayBuffer class

• The TypeError class

• The RangeError class

• The eval() function

• The [[IsHTMLDDA]] internal slot

• import()

• import.meta

• The HostGetImportMetaProperties abstract operation

• The typeof operator

• The delete operator

• The TypedArray Constructors table

Users agents that support JavaScript must also implement p1278 ECMAScript Internationalization API . [JSINTL]

User agents that support JavaScript must also implement the p1278 Top-Level Await proposal. [JSTLA]

WebAssembly

The following term is defined in p1282 WebAssembly JavaScript Interface : [WASMJS]

• WebAssembly.Module

DOM

The Document Object Model (DOM) is a representation — a model — of a document and its content. The DOM is not just an API; the

conformance criteria of HTML implementations are defined, in this specification, in terms of operations on the DOM. p1277 [DOM]

Implementations must support DOM and the events defined in UI Events, because this specification is defined in terms of the DOM,

and some of the features are defined as extensions to the DOM interfaces. p1277 p1282 [DOM] [UIEVENTS]

In particular, the following features are defined in p1277 DOM : [DOM]

• Attr interface

• Comment interface

• DOMImplementation interface

• Document interface

• DocumentOrShadowRoot interface

• DocumentFragment interface

• DocumentType interface

• ChildNode interface

• Element interface

• attachShadow() method.

• An element's shadow root

• The retargeting algorithm

• Node interface

• NodeList interface

• ProcessingInstruction interface

• ShadowRoot interface

• Text interface

• node document concept

55

• document type concept

• host concept

• The shadow root concept, and its delegates focus and available to element internals.

• The shadow host concept

• HTMLCollection interface, its length attribute, and its item() and namedItem() methods

• The terms collection and represented by the collection

• DOMTokenList interface, and its value attribute

• createDocument() method

• createHTMLDocument() method

• createElement() method

• createElementNS() method

• getElementById() method

• getElementsByClassName() method

• appendChild() method

• cloneNode() method

• importNode() method

• preventDefault() method

• id attribute

• setAttribute() method

• textContent attribute

• The tree, shadow tree, and node tree concepts

• The tree order and shadow-including tree order concepts

• The child concept

• The root and shadow-including root concepts

• The inclusive ancestor, shadow-including descendant, shadow-including inclusive descendant, and shadow-

including inclusive ancestor concepts

• The first child and next sibling concepts

• The document element concept

• The in a document tree, in a document (legacy), and connected concepts

• The slot concept, and its name and assigned nodes

• The assigned slot concept.

• The find flattened slottables algorithm

• The assign a slot algorithm

• The pre-insert, insert, append, replace, replace all, string replace all, remove, and adopt algorithms for nodes

• The insertion steps, removing steps, adopting steps, and children changed steps hooks for elements

• The change, append, remove, replace, and set value algorithms for attributes

• The attribute change steps hook for attributes

• The attribute list concept

• The data of a text node

• The child text content of a node

• The descendant text content of a node

• Event interface

• Event and derived interfaces constructor behavior

• EventTarget interface

• The activation behavior hook

• The legacy-pre-activation behavior hook

• The legacy-canceled-activation behavior hook

• The create an event algorithm

• The fire an event algorithm

• The canceled flag

• The dispatch algorithm

• EventInit dictionary type

• type attribute

• target attribute

• currentTarget attribute

• bubbles attribute

• cancelable attribute

• composed attribute

• composed flag

• isTrusted attribute

• initEvent() method

• add an event listener

• addEventListener() method

• The remove an event listener and remove all event listeners algorithms

• EventListener callback interface

• The type of an event

• An event listener and its type and callback

• The p115 encoding (herein the character encoding ), mode , and content type of a Document

• The distinction between XML documents and HTML documents

• The terms quirks mode, limited-quirks mode, and no-quirks mode

• The algorithm to clone a Node, and the concept of cloning steps used by that algorithm • The concept of base URL change steps and the definition of what happens when an element is affected by a base

URL change

• The concept of an element's unique identifier (ID)

• The concept of an element's classes

• The term supported tokens

• The concept of a DOM range, and the terms start, end, and boundary point as applied to ranges.

• The create an element algorithm

• The element interface concept

• The concepts of custom element state, and of defined and custom elements

• An element's namespace, namespace prefix, local name, custom element definition, and is value

• MutationObserver interface and mutation observers in general

56

The following features are defined in p1282 UI Events : [UIEVENTS]

• The MouseEvent interface

• The MouseEvent interface's relatedTarget attribute

• MouseEventInit dictionary type

• The FocusEvent interface

• The FocusEvent interface's relatedTarget attribute

• The UIEvent interface

• The UIEvent interface's view attribute

• auxclick event

• click event

• dblclick event

• mousedown event

• mouseenter event

• mouseleave event

• mousemove event

• mouseout event

• mouseover event

• mouseup event

• wheel event

• keydown event

• keypress event

• keyup event

The following features are defined in p1281 Touch Events : [TOUCH]

• Touch interface

• Touch point concept

• touchend event

The following features are defined in p1280 Pointer Events : [POINTEREVENTS]

• PointerEvent interface

• pointerup event

This specification sometimes uses the term name to refer to the event's type; as in, "an event named click" or "if the event name is keypress". The terms "name" and "type" for events are synonymous.

The following features are defined in p1277 DOM Parsing and Serialization : [DOMPARSING]

• innerHTML

• outerHTML

The following features are defined in p1281 Selection API : [SELECTION]

• selection

• Selection

Note

User agents are encouraged to implement the features described in p1277 execCommand . [EXECCOMMAND]

The following parts of p611 Fullscreen API are referenced from this specification, in part to define the rendering of dialog elements,

and also to define how the Fullscreen API interacts with HTML: p1277 [FULLSCREEN]

• top layer (an ordered set) and its add operation

• requestFullscreen()

• run the fullscreen steps

High Resolution Time p1278 provides the current high resolution time and the DOMHighResTimeStamp typedef. [HRT]

File API

This specification uses the following features defined in p1277 File API : [FILEAPI]

• The Blob interface and its type attribute

• The File interface and its name and lastModified attributes

• The FileList interface

• The concept of a Blob's snapshot state

• The concept of read errors

• Blob URL Store

Indexed Database API

This specification uses p1278 cleanup Indexed Database transactions defined by Indexed Database API . [INDEXEDDB]



57

Media Source Extensions

The following terms are defined in p1279 Media Source Extensions : [MEDIASOURCE]

• MediaSource interface

• detaching from a media element

Media Capture and Streams

The following terms are defined in p1279 Media Capture and Streams : [MEDIASTREAM]

• MediaStream interface Reporting

The following terms are defined in p1279 Reporting : [REPORTING]

• Queue a report

• report type

• visible to ReportingObservers

XMLHttpRequest

The following features and terms are defined in p1283 XMLHttpRequest : [XHR]

• The XMLHttpRequest interface, and its responseXML attribute

• The ProgressEvent interface, and its lengthComputable, loaded, and total attributes

• The FormData interface

• The FormDataEntryValue type

• entry

• create an entry

Battery Status

The following features are defined in p1275 Battery Status API : [BATTERY]

• getBattery() method Media Queries

Implementations must support p1279 Media Queries . The <media-condition> feature is defined therein. [MQ]

CSS modules

While support for CSS as a whole is not required of implementations of this specification (though it is encouraged, at least for web browsers), some features are defined in terms of specific CSS requirements.

When this specification requires that something be parsed according to a particular CSS grammar, the relevant algorithm in

CSS Syntax p1277 must be followed, including error handling rules. [CSSSYNTAX]

Example

For example, user agents are required to close all open constructs upon finding the end of a style sheet unexpectedly. Thus, when parsing the string "rgb(0,0,0" (with a missing close-parenthesis) for a color value, the close parenthesis is implied by this error handling rule, and a value is obtained (the color 'black'). However, the similar construct "rgb(0,0," (with both a missing parenthesis and a missing "blue" value) cannot be parsed, as closing the open construct does not result in a viable value.

To parse a CSS <color> value, given a string input with an optional element element, run these steps:

1. Let p1276 color be the result of parsing input as a CSS <color> . [CSSCOLOR]

2. If color is failure, then return failure.

3. If color is 'currentcolor', then:

1. If element is not given, then set color to opaque black.

2. Otherwise, set color to the computed value of the 'color' property of element.

4. Return color.

The following terms and features are defined in p1275 Cascading Style Sheets ( CSS ): [CSS]

• viewport

• line box

• out-of-flow

• in-flow

• content area

58

• content box

• border box

• margin box

• border edge

• margin edge

• collapsing margins

• containing block

• inline box

• block box

• The 'margin-top', 'margin-bottom', 'margin-left', and 'margin-right' properties

• The 'padding-top', 'padding-bottom', 'padding-left', and 'padding-right' properties

• The 'top', 'bottom', 'left', and 'right' properties

• The 'float' property

• The 'clear' property

• The 'width' property

• The 'height' property

• The 'max-width' property

• The 'max-height' property

• The 'line-height' property

• The 'vertical-align' property

• The 'content' property

• The 'inline-block' value of the 'display' property

• The 'visibility' property

CSS p1275 also defines the following border properties: [CSS]

Border properties

Top Bottom Left Right

Width 'border-top-width' 'border-bottom-width' 'border-left-width' 'border-right-width'

Style 'border-top-style' 'border-bottom-style' 'border-left-style' 'border-right-style'

Color 'border-top-color' 'border-bottom-color' 'border-left-color' 'border-right-color'

The basic version of the p1275 'display' property is defined in CSS , and the property is extended by other CSS modules. [CSS]

[CSSRUBY] p1277 p1277 [CSSTABLE]

The following terms and features are defined in p1276 CSS Logical Properties : [CSSLOGICAL]

• The 'margin-block-start', 'margin-block-end', 'margin-inline-start', and 'margin-inline-end' properties

• The 'padding-block-start', 'padding-block-end', 'padding-inline-start', and 'padding-inline-end' properties

• The 'border-block-start-width' property

• The 'block-size' property

• The 'inline-size' property

• The 'inset-block-start' property

• The 'inset-block-end' property

The following terms and features are defined in p1276 CSS Color : [CSSCOLOR]

• named color

• <color>

• The 'color' property

• The 'currentcolor' value

• opaque black

• transparent black

The following terms are defined in p1276 CSS Images : [CSSIMAGES]

• default object size

• intrinsic dimensions

• intrinsic aspect ratio

• intrinsic height

• intrinsic width

• The 'image-orientation' property

• The 'object-fit' property

The term paint source is used as defined in CSS Images Level 4 to define the interaction of certain HTML elements with the CSS

'element()' function. p1276 [CSSIMAGES4]

The following features are defined in p1276 CSS Backgrounds and Borders : [CSSBG]

• The 'background-color' property

• The 'background-image' property

• The 'border-radius' property

The following features are defined in p1275 CSS Box Alignment : [CSSALIGN]

• The 'align-content' property

• The 'align-items' property

59

• The 'align-self' property

• The 'justify-self' property

• The 'justify-content' property

• The 'justify-items' property

The following terms and features are defined in p1276 CSS Display : [CSSDISPLAY]

• outer display type

• block-level

• block container

• formatting context

• block formatting context

• inline formatting context

• absolutely positioned

• replaced element

• CSS box

The following features are defined in p1276 CSS Flexible Box Layout : [CSSFLEXBOX]

• The 'flex-direction' property

• The 'flex-wrap' property

The following terms and features are defined in p1276 CSS Fonts : [CSSFONTS]

• first available font

• The 'font-family' property

• The 'font-weight' property

• The 'font-size' property

• The 'font' property

The following features are defined in p1276 CSS Grid Layout : [CSSGRID]

• The 'grid-auto-columns' property

• The 'grid-auto-flow' property

• The 'grid-auto-rows' property

• The 'grid-column-gap' property

• The 'grid-row-gap' property

• The 'grid-template-areas' property

• The 'grid-template-columns' property

• The 'grid-template-rows' property

The following terms are defined in p1276 CSS Inline Layout : [CSSINLINE]

• alphabetic baseline

• ascent metric

• descent metric

• hanging baseline

• ideographic-under baseline

The following terms and features are defined in p1277 CSS Intrinsic & Extrinsic Sizing : [CSSSIZING]

• fit-content inline size

The p1276 'list-style-type' property is defined in CSS Lists and Counters . [CSSLISTS]

The following features are defined in p1276 CSS Overflow . [CSSOVERFLOW]

• The 'overflow' property and its 'hidden' value

• The 'text-overflow' property

The following features are defined in p1276 CSS Positioned Layout : [CSSPOSITION]

• The 'position' property and its 'static' value

The following features are defined in p1276 CSS Multi-column Layout . [CSSMULTICOL]

• The 'column-count' property

• The 'column-fill' property

• The 'column-gap' property

• The 'column-rule' property

• The 'column-width' property

The p1277 'ruby-base' value of the 'display' property is defined in CSS Ruby Layout . [CSSRUBY]

The following features are defined in p1277 CSS Table : [CSSTABLE]

• The 'border-spacing' property

• The 'border-collapse' property

60

• The 'table-cell', 'table-row', 'table-caption', and 'table' values of the 'display' property

The following features are defined in p1277 CSS Text : [CSSTEXT]

• The 'text-transform' property

• The 'white-space' property

• The 'text-align' property

• The 'letter-spacing' property

The following features are defined in p1277 CSS Writing Modes : [CSSWM]

• The 'direction' property

• The 'unicode-bidi' property

• The block flow direction, block size, inline size, block-start, block-end, inline-start, inline-end, line-left, and

line-right concepts

The following features are defined in p1277 CSS Basic User Interface : [CSSUI]

• The 'outline' property

• The 'cursor' property

• The 'appearance' property

The algorithm to p1282 update animations and send events is defined in Web Animations . [WEBANIMATIONS].

Implementations that support scripting must support the CSS Object Model. The following features and terms are defined in the

CSSOM specifications: p1276 p1276 [CSSOM] [CSSOMVIEW]

• Screen interface

• LinkStyle interface

• CSSStyleDeclaration interface

• style IDL attribute

• cssText attribute of CSSStyleDeclaration

• StyleSheet interface

• create a CSS style sheet

• remove a CSS style sheet

• associated CSS style sheet

• CSS style sheets and their properties:

◦ type

◦ location

◦ parent CSS style sheet

◦ owner node

◦ owner CSS rule

◦ media

◦ title

◦ alternate flag

◦ disabled flag

◦ CSS rules

◦ origin-clean flag

• CSS style sheet set

• CSS style sheet set name

• preferred CSS style sheet set name

• change the preferred CSS style sheet set name

• Serializing a CSS value

• run the resize steps

• run the scroll steps

• evaluate media queries and report changes

• Scroll an element into view

• Scroll to the beginning of the document

• The resize event

• The scroll event

• set up browsing context features

The following features and terms are defined in p1277 CSS Syntax : [CSSSYNTAX]

• conformant style sheet

• parse a list of component values

• parse a comma-separated list of component values

• component value

• environment encoding

• <whitespace-token>

The following terms are defined in p1281 Selectors : [SELECTORS]

• type selector

• attribute selector

• pseudo-class

The following features are defined in p1277 CSS Values and Units : [CSSVALUES]

61

• <length>

• The 'em' unit

• The 'ex' unit

• The 'vw' unit

• The 'in' unit

• The 'px' unit

• The 'attr()' function

• The math functions

The term p1276 style attribute is defined in CSS Style Attributes . [CSSATTR]

The following terms are defined in the p1276 CSS Cascading and Inheritance : [CSSCASCADE]

• specified value

• computed value

• used value

The p639 CanvasRenderingContext2D object's use of fonts depends on the features described in the CSS Fonts and Font Loading

specifications, including in particular p1276 p1276 FontFace objects and the font source concept. [CSSFONTS] [CSSFONTLOAD]

The following interfaces and terms are defined in p1277 Geometry Interfaces : [GEOMETRY]

• DOMMatrix interface, and associated m11 element, m12 element, m21 element, m22 element, m41 element, and

m42 element

• DOMMatrix2DInit and DOMMatrixInit dictionaries

• The create a DOMMatrix from a dictionary and create a DOMMatrix from a 2D dictionary algorithms for

DOMMatrix2DInit or DOMMatrixInit

The following terms are defined in the p1277 CSS Scoping : [CSSSCOPING]

• flat tree

The following terms and features are defined in p1276 CSS Color Adjustment : [CSSCOLORADJUST]

• 'color-scheme'

Intersection Observer

The following term is defined in p1278 Intersection Observer : [INTERSECTIONOBSERVER]

• run the update intersection observations steps

• IntersectionObserver

• IntersectionObserverInit

• observe

• unobserve

• isIntersecting

• target

WebGL

The following interfaces are defined in the WebGL specifications: p1282 [WEBGL]

• WebGLRenderingContext interface

• WebGL2RenderingContext interface

• WebGLContextAttributes dictionary WebVTT

Implementations may support WebVTT as a text track format for subtitles, captions, metadata, etc., for media resources.

[WEBVTT] p1282

The following terms, used in this specification, are defined in WebVTT:

• WebVTT file

• WebVTT file using cue text

• WebVTT file using only nested cues

• WebVTT parser

• The rules for updating the display of WebVTT text tracks

• The WebVTT text track cue writing direction

• VTTCue interface The WebSocket protocol

The following terms are defined in p1277 Fetch : [FETCH]

• establish a WebSocket connection

The following terms are defined in p1282 The WebSocket protocol : [WSP]

62

• the WebSocket connection is established

• extensions in use

• subprotocol in use

• a WebSocket message has been received

• send a WebSocket Message

• fail the WebSocket connection

• close the WebSocket connection

• start the WebSocket closing handshake

• the WebSocket closing handshake is started

• the WebSocket connection is closed (possibly cleanly)

• the WebSocket connection close code

• the WebSocket connection close reason

• Sec-WebSocket-Protocol field

ARIA

The p1275 role attribute is defined in Accessible Rich Internet Applications ( ARIA ), as are the following roles: [ARIA]

• button

• presentation

In addition, the following p1275 aria-* content attributes are defined in ARIA : [ARIA]

• aria-checked

• aria-describedby

• aria-disabled

• aria-label

Finally, the following terms are defined p1275 ARIA : [ARIA]

• role

• accessible name

• The ARIAMixin interface, with its associated ARIAMixin getter steps and ARIAMixin setter steps hooks Content Security Policy

The following terms are defined in p1275 Content Security Policy : [CSP]

• Content Security Policy

• disposition

• directive set

• Content Security Policy directive

• CSP list

• The Content Security Policy syntax

• enforce the policy

• The parse a serialized Content Security Policy algorithm

• The Initialize a global object's CSP list algorithm

• The Initialize a Document's CSP list algorithm

• The Should element's inline behavior be blocked by Content Security Policy? algorithm

• The Should navigation request of type be blocked by Content Security Policy? algorithm

• The Should navigation response to navigation request of type in target be blocked by Content Security

Policy? algorithm

• The report-uri directive

• The EnsureCSPDoesNotBlockStringCompilation abstract operation

• The Is base allowed for Document? algorithm

• The frame-ancestors directive

• The sandbox directive

• The Should plugin element be blocked a priori by Content Security Policy? algorithm

• The contains a header-delivered Content Security Policy property.

Service Workers

The following terms are defined in p1281 Service Workers : [SW]

• active worker

• client message queue

• control

• handle fetch

• match service worker registration

• service worker

• service worker client

• ServiceWorker interface

• ServiceWorkerContainer interface

• ServiceWorkerGlobalScope interface Secure Contexts

The following algorithms are defined in p1281 Secure Contexts : [SECURE-CONTEXTS]

• Is url potentially trustworthy?



63

Permissions Policy

The following terms are defined in p1280 Permissions Policy : [PERMISSIONSPOLICY]

• permissions policy

• policy-controlled feature

• container policy

• serialized permissions policy

• default allowlist

• The creating a permissions policy algorithm

• The creating a permissions policy from a response algorithm

• The is feature enabled by policy for origin algorithm

• The process permissions policy attributes algorithm Payment Request API

The following feature is defined in p1279 Payment Request API : [PAYMENTREQUEST]

• PaymentRequest interface MathML

While support for MathML as a whole is not required by this specification (though it is encouraged, at least for web browsers),

certain features depend upon small parts of MathML being implemented. p1279 [MATHML]

The following features are defined in Mathematical Markup Language (MathML):

• MathML annotation-xml element

• MathML math element

• MathML merror element

• MathML mi element

• MathML mn element

• MathML mo element

• MathML ms element

• MathML mtext element SVG

While support for SVG as a whole is not required by this specification (though it is encouraged, at least for web browsers), certain features depend upon parts of SVG being implemented.

User agents that implement SVG must implement the SVG 2 specification, and not any earlier revisions.

The following features are defined in the p1281 SVG 2 specification: [SVG]

• SVGElement interface

• SVGImageElement interface

• SVGScriptElement interface

• SVGSVGElement interface

• SVG a element

• SVG desc element

• SVG foreignObject element

• SVG image element

• SVG script element

• SVG svg element

• SVG title element

• SVG use element Filter Effects

The following feature is defined in p1277 Filter Effects : [FILTERS]

• <filter-function-list>

Cooperative Scheduling of Background Tasks

The following features are defined in p1280 Cooperative Scheduling of Background Tasks : [REQUESTIDLECALLBACK]

• requestIdleCallback()

• start an idle period algorithm

Storage

The following terms are defined in p1281 Storage : [STORAGE]

• obtain a local storage bottle map

• obtain a session storage bottle map

• storage proxy map

• legacy-clone a browsing session storage shed



64





Web App Manifest


The following features are defined in p1279 Web App Manifest : [MANIFEST]

• application manifest

• installed web application

• process the manifest



This specification does not require support of any particular network protocol, style sheet language, scripting language, or any of the DOM specifications beyond those required in the list above. However, the language described by this specification is biased towards CSS as the styling language, JavaScript as the scripting language, and HTTP as the network protocol, and several features assume that those languages and protocols are in use.

A user agent that implements the HTTP protocol must implement p1278 HTTP State Management Mechanism (Cookies) as well. [HTTP]

[COOKIES] p1275

Note

This specification might have certain additional requirements on character encodings, image formats, audio formats, and video

formats in the respective sections.



2.1.10 Extensibility p65 §

Vendor-specific proprietary user agent extensions to this specification are strongly discouraged. Documents must not use such extensions, as doing so reduces interoperability and fragments the user base, allowing only users of specific user agents to access the content in question.

All extensions must be defined so that the use of extensions neither contradicts nor causes the non-conformance of functionality defined in the specification.

Example

For example, while strongly discouraged from doing so, an implementation could add a new IDL attribute "typeTime" to a control

that returned the time it took the user to select the current value of a control (say). On the other hand, defining a new control that

appears in a form's p489 elements array would be in violation of the above requirement, as it would violate the definition of

elements p489 given in this specification.



When vendor-neutral extensions to this specification are needed, either this specification can be updated accordingly, or an extension specification can be written that overrides the requirements in this specification. When someone applying this specification to their activities decides that they will recognize the requirements of such an extension specification, it becomes an applicable specification for the purposes of conformance requirements in this specification.

Note

Someone could write a specification that defines any arbitrary byte stream as conforming, and then claim that their random junk is

conforming. However, that does not mean that their random junk actually is conforming for everyone's purposes: if someone else

decides that that specification does not apply to their work, then they can quite legitimately say that the aforementioned random

junk is just that, junk, and not conforming at all. As far as conformance goes, what matters in a particular community is what that

community agrees is applicable.



User agents must treat elements and attributes that they do not understand as semantically neutral; leaving them in the DOM (for DOM processors), and styling them according to CSS (for CSS processors), but not inferring any meaning from them.

When support for a feature is disabled (e.g. as an emergency measure to mitigate a security problem, or to aid in development, or for performance reasons), user agents must act as if they had no support for the feature whatsoever, and as if the feature was not mentioned in this specification. For example, if a particular feature is accessed via an attribute in a Web IDL interface, the attribute itself would be omitted from the objects that implement that interface — leaving the attribute on the object but making it return null or throw an exception is insufficient.



65





2.1.11 Interactions with XPath and XSLT p66 §


Implementations of XPath 1.0 that operate on HTML documents parsed or created in the manners described in this specification (e.g. as part of the document.evaluate() API) must act as if the following edit was applied to the XPath 1.0 specification.

First, remove this paragraph:

A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. This is the same way expansion is done for element type names in start and end-tags except that the default namespace declared

with xmlns is not used: if the QName does not have a prefix, then the namespace URI is null (this is the same way attribute names

are expanded). It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.

Then, insert in its place the following:

A QName in the node test is expanded into an expanded-name using the namespace declarations from the expression context. If the QName has a prefix, then there must be a namespace declaration for this prefix in the expression context, and the corresponding namespace URI is the one that is associated with this prefix. It is an error if the QName has a prefix for which there is no namespace declaration in the expression context.

If the QName has no prefix and the principal node type of the axis is element, then the default element namespace is used. Otherwise if the QName has no prefix, the namespace URI is null. The default element namespace is a member of the context for the XPath expression. The value of the default element namespace when executing an XPath expression through the DOM3 XPath API is determined in the following way:

1. If the context node is from an HTML DOM, the default element namespace is "http://www.w3.org/1999/xhtml".

2. Otherwise, the default element namespace URI is null.

Note

This is equivalent to adding the default element namespace feature of XPath 2.0 to XPath 1.0, and using the HTML namespace as the default element namespace for HTML documents. It is motivated by the desire to have implementations be compatible with legacy HTML content while still supporting the changes that this specification introduces to HTML regarding the namespace used for HTML elements, and by the desire to use XPath 1.0 rather than XPath 2.0.



Note

This change is a p27 willful violation of the XPath 1.0 specification, motivated by desire to have implementations be compatible with

legacy content while still supporting the changes that this specification introduces to HTML regarding which namespace is used for

HTML elements. p1283 [XPATH10]



XSLT 1.0 processors outputting to a DOM when the output method is "html" (either explicitly or via the defaulting rule in XSLT 1.0) are affected as follows: If the transformation program outputs an element in no namespace, the processor must, prior to constructing the corresponding DOM

element node, change the namespace of the element to the HTML namespace, ASCII-lowercase the element's local name, and ASCII-

lowercase the names of any non-namespaced attributes on the element.

Note

This requirement is a p27 willful violation of the XSLT 1.0 specification, required because this specification changes the namespaces

and case-sensitivity rules of HTML in a manner that would otherwise be incompatible with DOM-based XSLT transformations.

(Processors that serialize the output are unaffected.) p1283 [XSLT10]



This specification does not specify precisely how XSLT processing interacts with the p1076 HTML parser infrastructure (for example, whether an XSLT processor acts as if it puts any elements into a p1090 stack of open elements). However, XSLT processors must stop

parsing p1161 p118 if they successfully complete, and must set the current document readiness first to "interactive" and then to "complete" if they are aborted.



This specification does not specify how XSLT interacts with the p876 p931 navigation algorithm, how it fits in with the event loop, nor how error pages are to be handled (e.g. whether XSLT errors are to replace an incremental XSLT output, or are rendered inline, etc).

66





Note


There are also additional non-normative comments regarding the interaction of XSLT and HTML p628 in the script element section,

and of XSLT, XPath, and HTML p633 in the template element section.



2.2 String comparison p67 §

A string pattern is a prefix match for a string s when pattern is not longer than s and truncating s to pattern's length leaves the two strings as matches of each other.



2.3 Policy-controlled features p67 §

MDN

This document defines the following policy-controlled features:

• "autoplay", which has a default allowlist of 'self'.

• "cross-origin-isolated", which has a default allowlist of 'self'.

• "document-domain", which has a default allowlist of *.



2.4 Common microsyntaxes p67 §

There are various places in HTML that accept particular data types, such as dates or numbers. This section describes what the conformance criteria for content in those formats is, and how to parse them.

Note

Implementors are strongly urged to carefully examine any third-party libraries they might consider using to implement the parsing

of syntaxes described below. For example, date libraries are likely to implement error handling behavior that differs from what is

required in this specification, since error-handling behavior is often not defined in specifications that describe date syntaxes similar

to those used in this specification, and thus implementations tend to vary greatly in how they handle errors.



2.4.1 Common parser idioms p67 §

Some of the micro-parsers described below follow the pattern of having an input variable that holds the string being parsed, and having a position variable pointing at the next character to parse in input.



2.4.2 Boolean attributes p67 §

A number of attributes are boolean attributes. The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.

If the attribute is present, its value must either be the empty string or a value that is an ASCII case-insensitive match for the attribute's canonical name, with no leading or trailing whitespace.

Note

The values "true" and "false" are not allowed on boolean attributes. To represent a false value, the attribute has to be omitted

altogether.



Example

Here is an example of a checkbox that is checked and disabled. The p498 p571 checked and disabled attributes are the boolean

67





attributes.


Cheese

This could be equivalently written as this:

Cheese

You can also mix styles; the following is still equivalent:

Cheese



2.4.3 Keywords and enumerated attributes p68 §

Some attributes are defined as taking one of a finite set of keywords. Such attributes are called enumerated attributes. The keywords are each defined to map to a particular state (several keywords might map to the same state, in which case some of the keywords are synonyms of each other; additionally, some of the keywords can be said to be non-conforming, and are only in the specification for historical reasons). In addition, two default states can be given. The first is the invalid value default, the second is the missing value default.

If an enumerated attribute is specified, the attribute's value must be an ASCII case-insensitive match for one of the given keywords that are not said to be non-conforming, with no leading or trailing whitespace.

When the attribute is specified, if its value is an ASCII case-insensitive match for one of the given keywords then that keyword's state is the state that the attribute represents. If the attribute value matches none of the given keywords, but the attribute has an invalid value

default p68, then the attribute represents that state. Otherwise, there is no default, and invalid values mean that there is no state represented.

When the attribute is p68 not specified, if there is a missing value default state defined, then that is the state represented by the (missing) attribute. Otherwise, the absence of the attribute means that there is no state represented.

Note

The empty string can be a valid keyword.



2.4.4 Numbers p68 §

2.4.4.1 Signed integers §p68

A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a U+002D HYPHEN-MINUS character (-).

A p68 valid integer without a U+002D HYPHEN-MINUS (-) prefix represents the number that is represented in base ten by that string of digits. A p68 valid integer with a U+002D HYPHEN-MINUS (-) prefix represents the number represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS, subtracted from zero.

The rules for parsing integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let sign have the value "positive".

4. Skip ASCII whitespace within input given position.

5. If position is past the end of input, return an error.

6. If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-):

68





1. Let sign be "negative".


2. Advance position to the next character.

3. If position is past the end of input, return an error.

Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):

1. Advance position to the next character. (The "+" is ignored, but it is not conforming.)

2. If position is past the end of input, return an error.

7. If the character indicated by position is not an ASCII digit, then return an error.

8. Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a

base-ten integer. Let value be that integer.

9. If sign is "positive", return value, otherwise return the result of subtracting value from zero.



2.4.4.2 Non-negative integers p69 §

A string is a valid non-negative integer if it consists of one or more ASCII digits.

A p69 valid non-negative integer represents the number that is represented in base ten by that string of digits.

The rules for parsing non-negative integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.

1. Let input be the string being parsed.

2. Let p68 value be the result of parsing input using the rules for parsing integers.

3. If value is an error, return an error.

4. If value is less than zero, return an error.

5. Return value.



2.4.4.3 Floating-point numbers p69 §

A string is a valid floating-point number if it consists of:

1. Optionally, a U+002D HYPHEN-MINUS character (-).

2. One or both of the following, in the given order:

1. A series of one or more ASCII digits.

2. Both of the following, in the given order:

1. A single U+002E FULL STOP character (.).

2. A series of one or more ASCII digits.

3. Optionally:

1. Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E). 2. Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character (+).

3. A series of one or more ASCII digits.

A p69 valid floating-point number represents the number obtained by multiplying the significand by ten raised to the power of the exponent, where the significand is the first number, interpreted as base ten (including the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative number if the whole string starts with a U+002D HYPHEN-MINUS character (-) and the number is not zero), and where the exponent is the number after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS character (-) between the E and the number and the number is not zero, or else ignoring a U+002B PLUS SIGN character (+) between the E and the number if there is one). If there is no E, then the exponent is treated as zero.

Note

The Infinity and Not-a-Number (NaN) values are not p69 valid floating-point numbers.



69

Note

The p69 valid floating-point number concept is typically only used to restrict what is allowed for authors, while the user agent

requirements use the p70 p557 p556 rules for parsing floating-point number values below (e.g., the max attribute of the progress

element). However, in some cases the user agent requirements include checking if a string is a p69 valid floating-point number (e.g.,

the p498 p510 p494 p345 value sanitization algorithm for the Number state of the input element, or the parse a srcset attribute algorithm).

The best representation of the number n as a floating-point number is the string obtained from running ToString(n). The abstract operation ToString is not uniquely determined. When there are multiple possible strings that could be obtained from ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).

The rules for parsing floating-point number values are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let value have the value 1.

4. Let divisor have the value 1.

5. Let exponent have the value 1.

6. Skip ASCII whitespace within input given position.

7. If position is past the end of input, return an error.

8. If the character indicated by position is a U+002D HYPHEN-MINUS character (-):

1. Change value and divisor to −1.

2. Advance position to the next character.

3. If position is past the end of input, return an error.

Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):

1. Advance position to the next character. (The "+" is ignored, but it is not conforming.)

2. If position is past the end of input, return an error.

9. If the character indicated by position is a U+002E FULL STOP (.), and that is not the last character in input, and the character

after the character indicated by position is an ASCII digit, then set value to zero and jump to the step labeled fraction.

10. If the character indicated by position is not an ASCII digit, then return an error.

11. Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a

base-ten integer. Multiply value by that integer.

12. If position is past the end of input, jump to the step labeled conversion.

13. Fraction: If the character indicated by position is a U+002E FULL STOP (.), run these substeps:

1. Advance position to the next character.

2. If position is past the end of input, or if the character indicated by position is not an ASCII digit, U+0065 LATIN

SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER E (E), then jump to the step labeled conversion.

3. If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL

LETTER E character (E), skip the remainder of these substeps.

4. Fraction loop: Multiply divisor by ten.

5. Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to

value.

6. Advance position to the next character.

7. If position is past the end of input, then jump to the step labeled conversion.

70





8. If the character indicated by position is an ASCII digit, jump back to the step labeled fraction loop in these


substeps.

14. If the character indicated by position is U+0065 (e) or a U+0045 (E), then:

1. Advance position to the next character.

2. If position is past the end of input, then jump to the step labeled conversion.

3. If the character indicated by position is a U+002D HYPHEN-MINUS character (-):

1. Change exponent to −1.

2. Advance position to the next character.

3. If position is past the end of input, then jump to the step labeled conversion.

Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+):

1. Advance position to the next character.

2. If position is past the end of input, then jump to the step labeled conversion.

4. If the character indicated by position is not an ASCII digit, then jump to the step labeled conversion.

5. Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting

sequence as a base-ten integer. Multiply exponent by that integer.

6. Multiply value by ten raised to the exponentth power.

15. Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values

added: 21024 1024 and −2.

16. Let rounded-value be the number in S that is closest to value, selecting the number with an even significand if there are two

equally close values. (The two special values 2 1024 1024 and −2 are considered to have even significands for this purpose.)

17. If 1024 1024 rounded-value is 2 or −2, return an error.

18. Return rounded-value.



2.4.4.4 Percentages and lengths p71 §

The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 0.0, or failure; if a number is returned, then it is further categorized as either a percentage or a length.

1. Let input be the string being parsed.

2. Let position be a position variable for input, initially pointing at the start of input.

3. Skip ASCII whitespace within input given position.

4. If position is past the end of input or the code point at position within input is not an ASCII digit, then return failure.

5. Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a

base-ten integer. Let value be that number.

6. If position is past the end of input, then return value as a length.

7. If the code point at position within input is U+002E (.), then:

1. Advance position by 1.

2. If position is past the end of input or the code point at position within input is not an ASCII digit, then return the

current dimension value p72 with value, input, and position.

3. Let divisor have the value 1.

4. While true:

71





1. Multiply divisor by ten.


2. Add the value of the code point at position within input, interpreted as a base-ten digit (0..9) and divided

by divisor, to value.

3. Advance position by 1.

4. If position is past the end of input, then return value as a length.

5. If the code point at position within input is not an ASCII digit, then break.

8. Return the p72 current dimension value with value, input, and position.

The current dimension value, given value, input, and position, is determined as follows:

1. If position is past the end of input, then return value as a length.

2. If the code point at position within input is U+0025 (%), then return value as a percentage.

3. Return value as a length.



2.4.4.5 Non-zero percentages and lengths p72 §

The rules for parsing nonzero dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.

1. Let input be the string being parsed.

2. Let p71 value be the result of parsing input using the rules for parsing dimension values.

3. If value is an error, return an error.

4. If value is zero, return an error.

5. If value is a percentage, return value as a percentage.

6. Return value as a length.



2.4.4.6 Lists of floating-point numbers p72 §

A p69 valid list of floating-point numbers is a number of valid floating-point numbers separated by U+002C COMMA characters, with no other characters (e.g. no ASCII whitespace). In addition, there might be restrictions on the number of floating-point numbers that can be given, or on the range of values allowed.

The rules for parsing a list of floating-point numbers are as follows:

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let numbers be an initially empty list of floating-point numbers. This list will be the result of this algorithm.

4. Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input

given position. This skips past any leading delimiters.

5. While position is not past the end of input:

1. Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, U+003B SEMICOLON, ASCII

digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters from input given position. This skips past leading garbage.

2. Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON

characters from input given position, and let unparsed number be the result.

3. Let p70 number be the result of parsing unparsed number using the rules for parsing floating-point number values.

72





4. If number is an error, set number to zero.


5. Append number to numbers.

6. Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters

from input given position. This skips past the delimiter.

6. Return numbers.



2.4.4.7 Lists of dimensions p73 §

The rules for parsing a list of dimensions are as follows. These rules return a list of zero or more pairs consisting of a number and a unit, the unit being one of percentage, relative, and absolute.

1. Let raw input be the string being parsed.

2. If the last character in raw input is a U+002C COMMA character (,), then remove that character from raw input.

3. Split the string raw input on commas. Let raw tokens be the resulting list of tokens.

4. Let result be an empty list of number/unit pairs.

5. For each token in raw tokens, run the following substeps:

1. Let input be the token.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let value be the number 0.

4. Let unit be absolute.

5. If position is past the end of input, set unit to relative and jump to the last substep.

6. If the character at position is an ASCII digit, collect a sequence of code points that are ASCII digits from input given

position, interpret the resulting sequence as an integer in base ten, and increment value by that integer.

7. If the character at position is U+002E (.), then:

1. Collect a sequence of code points consisting of ASCII whitespace and ASCII digits from input given

position. Let s be the resulting sequence.

2. Remove all ASCII whitespace in s.

3. If s is not the empty string, then:

1. Let length be the number of characters in s (after the spaces were removed).

2. Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number

by 10length.

3. Increment value by fraction.

8. Skip ASCII whitespace within input given position.

9. If the character at position is a U+0025 PERCENT SIGN character (%), then set unit to percentage.

Otherwise, if the character at position is a U+002A ASTERISK character (*), then set unit to relative.

10. Add an entry to result consisting of the number given by value and the unit given by unit.

6. Return the list result.



2.4.5 Dates and times p73 §

In the algorithms below, the number of days in month month of year year is: 31 if month is 1, 3, 5, 7, 8, 10, or 12; 30 if month is 4, 6, 9, or 11; 29 if month is 2 and year is a number divisible by 400, or if year is a number divisible by 4 but not by 100; and 28

73





otherwise. This takes into account leap years in the Gregorian calendar. p1278 [GREGORIAN]


When ASCII digits are used in the date and time syntaxes defined in this section, they express numbers in base ten.

Note

While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines

parsing rules in much more detail than ISO8601. Implementors are therefore encouraged to carefully examine any date parsing

libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in

exactly the same manner. p1278 [ISO8601]

Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian calendar, extrapolated backwards to year 1. A date in the p74 proleptic Gregorian calendar, sometimes explicitly referred to as a proleptic-Gregorian date, is one that is described using that calendar even if that calendar was not in use at the time (or place) in question. p1278 [GREGORIAN]

Note

The use of the Gregorian calendar as the wire format in this specification is an arbitrary choice resulting from the cultural biases of

those involved in the decision. See also the section discussing p486 date, time, and number formats in forms (for authors),

implementation notes regarding localization of form controls p522 p261 , and the time element.



2.4.5.1 Months p74 §

A p74 month consists of a specific proleptic-Gregorian date with no time-zone information and no date information beyond a year and a month. p1278 [GREGORIAN]

A string is a valid month string representing a year year and month month if it consists of the following components in the given order:

1. Four or more ASCII digits, representing year, where year > 0

2. A U+002D HYPHEN-MINUS character (-)

3. Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12

The rules to parse a month string are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p74 Parse a month component to obtain year and month. If this returns nothing, then fail.

4. If position is not beyond the end of input, then fail.

5. Return year and month.

The rules to parse a month component, given an input string and a position, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not at least four

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.

2. If year is not a number greater than zero, then fail.

3. If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.

Otherwise, move position forwards one character.

4. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.

5. If month is not a number in the range 1 ≤ month ≤ 12, then fail.

6. Return year and month.

74





2.4.5.2 Dates p75 §


A p74 date consists of a specific proleptic-Gregorian date with no time-zone information, consisting of a year, a month, and a day.

[GREGORIAN] p1278

A string is a valid date string representing a year year, month month, and day day if it consists of the following components in the given order:

1. A p74 valid month string, representing year and month

2. A U+002D HYPHEN-MINUS character (-)

3. Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month

and year p73 year

The rules to parse a date string are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p75 Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

4. If position is not beyond the end of input, then fail.

5. Let date be the date with year year, month month, and day day.

6. Return date.

The rules to parse a date component, given an input string and a position, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. p74 Parse a month component to obtain year and month. If this returns nothing, then fail.

2. Let p73 maxday be the number of days in month month of year year.

3. If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.

Otherwise, move position forwards one character.

4. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.

5. If day is not a number in the range 1 ≤ day ≤ maxday, then fail.

6. Return year, month, and day.



2.4.5.3 Yearless dates p75 §

A p1278 yearless date consists of a Gregorian month and a day within that month, but with no associated year. [GREGORIAN]

A string is a valid yearless date string representing a month month and a day day if it consists of the following components in the given order:

1. Optionally, two U+002D HYPHEN-MINUS characters (-)

2. Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12

3. A U+002D HYPHEN-MINUS character (-)

4. Two p73 ASCII digits , representing day , in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month

month and any arbitrary leap year (e.g. 4 or 2000) Note

In other words, if the month is "02", meaning February, then the day can be 29, as if the year was a leap year.



75





The rules to parse a yearless date string are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.


1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p76 Parse a yearless date component to obtain month and day. If this returns nothing, then fail.

4. If position is not beyond the end of input, then fail.

5. Return month and day.

The rules to parse a yearless date component, given an input string and a position, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Collect a sequence of code points that are U+002D HYPHEN-MINUS characters (-) from input given position. If the collected

sequence is not exactly zero or two characters long, then fail.

2. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.

3. If month is not a number in the range 1 ≤ month ≤ 12, then fail.

4. Let p73 maxday be the number of days in month month of any arbitrary leap year (e.g. 4 or 2000).

5. If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.

Otherwise, move position forwards one character.

6. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.

7. If day is not a number in the range 1 ≤ day ≤ maxday, then fail.

8. Return month and day.



2.4.5.4 Times p76 §

A time consists of a specific time with no time-zone information, consisting of an hour, a minute, a second, and a fraction of a second.

A string is a valid time string representing an hour hour, a minute minute, and a second second if it consists of the following components in the given order:

1. Two ASCII digits, representing hour, in the range 0 ≤ hour ≤ 23

2. A U+003A COLON character (:)

3. Two ASCII digits, representing minute, in the range 0 ≤ minute ≤ 59

4. If second is nonzero, or optionally if second is zero:

1. A U+003A COLON character (:)

2. Two ASCII digits, representing the integer part of second, in the range 0 ≤ s ≤ 59 3. If second is not an integer, or optionally if second is an integer:

1. A U+002E FULL STOP character (.)

2. One, two, or three ASCII digits, representing the fractional part of second Note

The second component cannot be 60 or 61; leap seconds cannot be represented.

The rules to parse a time string are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

76





3. p77 Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.


4. If position is not beyond the end of input, then fail.

5. Let time be the time with hour hour, minute minute, and second second.

6. Return time.

The rules to parse a time component, given an input string and a position, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the hour.

2. If hour is not a number in the range 0 ≤ hour ≤ 23, then fail.

3. If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise,

move position forwards one character.

4. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the minute.

5. If minute is not a number in the range 0 ≤ minute ≤ 59, then fail.

6. Let second be 0.

7. If position is not beyond the end of input and the character at position is U+003A (:), then:

1. Advance position to the next character in input.

2. If position is beyond the end of input, or at the last character in input, or if the next two characters in input starting

at position are not both ASCII digits, then fail.

3. Collect a sequence of code points that are either ASCII digits or U+002E FULL STOP characters from input given

position. If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, interpret the resulting sequence as a base-ten number (possibly with a fractional part). Set second to that number.

4. If second is not a number in the range 0 ≤ second < 60, then fail.

8. Return hour, minute, and second.



2.4.5.5 Local dates and times p77 §

A p74 local date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, but expressed without a time zone. p1278 [GREGORIAN]

A string is a valid local date and time string representing a date and time if it consists of the following components in the given order:

1. A p75 valid date string representing the date

2. A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character

3. A p76 valid time string representing the time A string is a valid normalized local date and time string representing a date and time if it consists of the following components in the given order:

1. A p75 valid date string representing the date

2. A U+0054 LATIN CAPITAL LETTER T character (T)

3. A p76 valid time string representing the time, expressed as the shortest possible string for the given time (e.g. omitting the

seconds component entirely if the given time is zero seconds past the minute)

77





The rules to parse a local date and time string are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.


1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p75 Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

4. If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T)

nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.

5. p77 Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

6. If position is not beyond the end of input, then fail.

7. Let date be the date with year year, month month, and day day.

8. Let time be the time with hour hour, minute minute, and second second.

9. Return date and time.



2.4.5.6 Time zones p78 §

A time-zone offset consists of a signed number of hours and minutes.

A string is a valid time-zone offset string representing a time-zone offset if it consists of either:

• A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC

• Or, the following components, in the given order:

1. Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero, a U+002D HYPHEN-MINUS

character (-), representing the sign of the time-zone offset

2. Two ASCII digits, representing the hours component hour of the time-zone offset, in the range 0 ≤ hour ≤ 23

3. Optionally, a U+003A COLON character (:)

4. Two ASCII digits, representing the minutes component minute of the time-zone offset, in the range 0 ≤ minute ≤ 59

Note

This format allows for time-zone offsets from -23:59 to +23:59. Right now, in practice, the range of offsets of actual time zones is

-12:00 to +14:00, and the minutes component of offsets of actual time zones is always either 00, 30, or 45. There is no guarantee

that this will remain so forever, however, since time zones are used as political footballs and are thus subject to very whimsical

policy decisions.



Note

See also the usage notes and examples in the p79 global date and time section below for details on using time-zone offsets with

historical times that predate the formation of formal time zones.

The rules to parse a time-zone offset string are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p78 Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.

4. If position is not beyond the end of input, then fail.

5. Return the time-zone offset that is timezonehours hours and timezoneminutes minutes from UTC.

The rules to parse a time-zone offset component, given an input string and a position, are as follows. This will return either time-

78





zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.


1. If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:

1. Let timezonehours be 0.

2. Let timezoneminutes be 0.

3. Advance position to the next character in input.

Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D HYPHEN-MINUS (-), then:

1. If the character at position is a U+002B PLUS SIGN (+), let sign be "positive". Otherwise, it's a U+002D HYPHEN-

MINUS (-); let sign be "negative".

2. Advance position to the next character in input.

3. Collect a sequence of code points that are ASCII digits from input given position. Let s be the collected sequence.

4. If s is exactly two characters long, then:

1. Interpret s as a base-ten integer. Let that number be the timezonehours.

2. If position is beyond the end of input or if the character at position is not a U+003A COLON character,

then fail. Otherwise, move position forwards one character.

3. Collect a sequence of code points that are ASCII digits from input given position. If the collected

sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the timezoneminutes.

If s is exactly four characters long, then:

1. Interpret the first two characters of s as a base-ten integer. Let that number be the timezonehours.

2. Interpret the last two characters of s as a base-ten integer. Let that number be the timezoneminutes.

Otherwise, fail.

5. If timezone hours is not a number in the range 0 ≤ timezonehours ≤ 23, then fail.

6. If sign is "negative", then negate timezone hours.

7. If timezoneminutes is not a number in the range 0 ≤ timezoneminutes ≤ 59, then fail.

8. If sign is "negative", then negate timezone minutes.

Otherwise, fail.

2. Return timezone hours and timezoneminutes.



2.4.5.7 Global dates and times p79 §

A p74 global date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, expressed with a time-zone offset, consisting of a signed number of hours and minutes. p1278 [GREGORIAN]

A string is a valid global date and time string representing a date, time, and a time-zone offset if it consists of the following components in the given order:

1. A p75 valid date string representing the date

2. A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character

3. A p76 valid time string representing the time

4. A p78 valid time-zone offset string representing the time-zone offset Times in dates before the formation of UTC in the mid twentieth century must be expressed and interpreted in terms of UT1

79

(contemporary Earth solar time at the 0° longitude), not UTC (the approximation of UT1 that ticks in SI seconds). Time before the formation of time zones must be expressed and interpreted as UT1 times with explicit time zones that approximate the contemporary difference between the appropriate local time and the time observed at the location of Greenwich, London.

Example

The following are some examples of dates written as p79 valid global date and time strings.

"0037-12-13 00:00Z"

Midnight in areas using London time on the birthday of Nero (the Roman Emperor). See below for further discussion on which date this actually corresponds to.

"1979-10-14T12:00:00.001-04:00"

One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the USA during daylight saving time.

"8592-01-01T02:09+02:09"

Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.

Several things are notable about these dates:

• Years with fewer than four digits have to be zero-padded. The date "37-12-13" would not be a valid date.

• If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21 12:00Z" (with two spaces

between the components) would not be parsed successfully.

• To unambiguously identify a moment in time prior to the introduction of the Gregorian calendar (insofar as moments in

time before the formation of UTC can be unambiguously identified), the date has to be first converted to the Gregorian calendar from the calendar in use at the time (e.g. from the Julian calendar). The date of Nero's birth is the 15th of

December 37, in the Julian Calendar, which is the 13th of December 37 in the p74 proleptic Gregorian calendar.

• The time and time-zone offset components are not optional.

• Dates before the year one can't be represented as a datetime in this version of HTML.

• Times of specific events in ancient times are, at best, approximations, since time was not well coordinated or measured

until relatively recent decades.

• Time-zone offsets differ based on daylight saving time.



The rules to parse a global date and time string are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. p75 Parse a date component to obtain year, month, and day. If this returns nothing, then fail.

4. If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T)

nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.

5. p77 Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.

6. If position is beyond the end of input, then fail.

7. p78 Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.

8. If position is not beyond the end of input, then fail.

9. Let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting

timezonehours hours and timezoneminutes minutes. That moment in time is a moment in the UTC time zone.

10. Let timezone be timezonehours hours and timezoneminutes minutes from UTC.

11. Return time and timezone.

80





2.4.5.8 Weeks p81 §


A week consists of a week-year number and a week number representing a seven-day period starting on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods, as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969 (1969-12-29) is defined as week number 1 in week-year 1970. Consecutive weeks are numbered sequentially. The week before the number 1 week in a week-year is the last week in the previous week-year, and vice versa.

[GREGORIAN] p1278

A week-year with a number p74 year has 53 weeks if it corresponds to either a year year in the proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year p74 year in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st) and where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other week-years have 52 weeks.

The week number of the last day of a week-year with 53 weeks is 53; the week number of the last day of a week-year with 52 weeks is 52.

Note

The week-year number of a particular day can be different than the number of the year that contains that day in the proleptic

Gregorian calendar p74. The first week in a week-year y is the week that contains the first Thursday of the Gregorian year y.



Note

For modern purposes, a p81 p1278 week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]

A string is a valid week string representing a week-year year and week week if it consists of the following components in the given order:

1. Four or more ASCII digits, representing year, where year > 0

2. A U+002D HYPHEN-MINUS character (-)

3. A U+0057 LATIN CAPITAL LETTER W character (W)

4. Two ASCII digits, representing the week week, in the range 1 ≤ week ≤ maxweek, where maxweek is the week number of the

last day p81 of week-year year The rules to parse a week string are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not at least four

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.

4. If year is not a number greater than zero, then fail.

5. If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.

Otherwise, move position forwards one character.

6. If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL LETTER W character (W),

then fail. Otherwise, move position forwards one character.

7. Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two

characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the week.

8. Let p81 maxweek be the week number of the last day of year year.

9. If week is not a number in the range 1 ≤ week ≤ maxweek, then fail.

10. If position is not beyond the end of input, then fail.

11. Return the week-year number year and the week number week.



81





2.4.5.9 Durations p82 §


A duration consists of a number of seconds.

Note

Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a period whose exact

length depends on the precise day from which it is measured) a p82 duration as defined in this specification cannot include months

(or years, which are equivalent to twelve months). Only durations that describe a specific number of seconds can be described.

A string is a p82 valid duration string representing a duration t if it consists of either of the following:

• A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents, in the order

given, where the number of days, hours, minutes, and seconds corresponds to the same number of seconds as in t:

1. One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a number of days.

2. A U+0054 LATIN CAPITAL LETTER T character followed by one or more of the following subcomponents, in the order

given:

1. One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing a

number of hours.

2. One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing a

number of minutes.

3. The following components:

1. One or more ASCII digits, representing a number of seconds.

2. Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits,

representing a fraction of a second.

3. A U+0053 LATIN CAPITAL LETTER S character.

Note

This, as with a number of other date- and time-related microsyntaxes defined in this specification, is based on one of the

formats defined in ISO 8601. p1278 [ISO8601]

• One or more p82 p82 duration time components , each with a different duration time component scale, in any order; the sum of

the represented seconds being equal to the number of seconds in t.

A duration time component is a string consisting of the following components:

1. Zero or more ASCII whitespace.

2. One or more p82 ASCII digits , representing a number of time units, scaled by the duration time component scale

specified (see below) to represent a number of seconds.

3. If the p82 duration time component scale specified is 1 (i.e. the units are seconds), then, optionally, a U+002E FULL

STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.

4. Zero or more ASCII whitespace.

5. One of the following characters, representing the duration time component scale of the time unit used in the

numeric part of the p82 duration time component:

U+0057 LATIN CAPITAL LETTER W character

U+0077 LATIN SMALL LETTER W character

Weeks. The scale is 604800.

U+0044 LATIN CAPITAL LETTER D character

U+0064 LATIN SMALL LETTER D character

Days. The scale is 86400.

U+0048 LATIN CAPITAL LETTER H character

U+0068 LATIN SMALL LETTER H character

Hours. The scale is 3600.

82

U+004D LATIN CAPITAL LETTER M character

U+006D LATIN SMALL LETTER M character

Minutes. The scale is 60.

U+0053 LATIN CAPITAL LETTER S character

U+0073 LATIN SMALL LETTER S character

Seconds. The scale is 1.

6. Zero or more ASCII whitespace.

Note

This is not based on any of the formats in ISO 8601. It is intended to be a more human-readable alternative to the ISO 8601 duration format.

The rules to p82 parse a duration string are as follows. This will return either a duration or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let months, seconds, and component count all be zero.

4. Let M-disambiguator be minutes.

Note

This flag's other value is months. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.

5. Skip ASCII whitespace within input given position.

6. If position is past the end of input, then fail.

7. If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character, then advance position to the

next character, set M-disambiguator to months, and skip ASCII whitespace within input given position.

8. While true:

1. Let units be undefined. It will be assigned one of the following values: years, months, weeks, days, hours, minutes,

and seconds.

2. Let next character be undefined. It is used to process characters from the input.

3. If position is past the end of input, then break.

4. If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then advance

position to the next character, set M-disambiguator to minutes, skip ASCII whitespace within input given position, and continue.

5. Set next character to the character in input pointed to by position.

6. If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position. That is

taken care of below.)

Otherwise, if next character is an ASCII digit, then collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as a base-ten integer, and let N be that number.

Otherwise next character is not part of a number; fail.

7. If position is past the end of input, then fail.

8. Set next character to the character in input pointed to by position, and this time advance position to the next

character. (If next character was a U+002E FULL STOP character (.) before, it will still be that character this time.)

9. If next character is U+002E (.), then:

1. Collect a sequence of code points that are ASCII digits from input given position. Let s be the resulting

83

sequence.

2. If s is the empty string, then fail.

3. Let length be the number of characters in s.

4. Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by

10length.

5. Increment N by fraction.

6. Skip ASCII whitespace within input given position.

7. If position is past the end of input, then fail.

8. Set next character to the character in input pointed to by position, and advance position to the next

character.

9. If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL

LETTER S character, then fail.

10. Set units to seconds.

Otherwise:

1. If next character is ASCII whitespace, then skip ASCII whitespace within input given position, set next

character to the character in input pointed to by position, and advance position to the next character.

2. If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y

character, set units to years and set M-disambiguator to months.

If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is months, then set units to months.

If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set units to weeks and set M-disambiguator to minutes.

If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set units to days and set M-disambiguator to minutes.

If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set units to hours and set M-disambiguator to minutes.

If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is minutes, then set units to minutes.

If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set units to seconds and set M-disambiguator to minutes.

Otherwise if next character is none of the above characters, then fail.

10. Increment component count.

11. Let multiplier be 1.

12. If units is years, multiply multiplier by 12 and set units to months.

13. If units is months, add the product of N and multiplier to months.

Otherwise:

1. If units is weeks, multiply multiplier by 7 and set units to days.

2. If units is days, multiply multiplier by 24 and set units to hours.

3. If units is hours, multiply multiplier by 60 and set units to minutes.

4. If units is minutes, multiply multiplier by 60 and set units to seconds.

5. Forcibly, units is now seconds. Add the product of N and multiplier to seconds.

14. Skip ASCII whitespace within input given position.

84





9. If component count is zero, fail.


10. If months is not zero, fail.

11. Return the p82 duration consisting of seconds seconds.



2.4.5.10 Vaguer moments in time p85 §

A string is a valid date string with optional time if it is also one of the following:

• A p75 valid date string

• A p79 valid global date and time string



The rules to p75 p76 parse a date or time string are as follows. The algorithm will return either a date , a time, a global date and

time p79, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.

1. Let input be the string being parsed.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Set start position to the same position as position.

4. Set the date present and time present flags to true.

5. p75 Parse a date component to obtain year, month, and day. If this fails, then set the date present flag to false.

6. If date present is true, and position is not beyond the end of input, and the character at position is either a U+0054 LATIN

CAPITAL LETTER T character (T) or a U+0020 SPACE character, then advance position to the next character in input.

Otherwise, if date present is true, and either position is beyond the end of input or the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then set time present to false.

Otherwise, if date present is false, set position back to the same position as start position.

7. If the p77 time present flag is true, then parse a time component to obtain hour, minute, and second. If this returns nothing,

then fail.

8. If the date present and time present flags are both true, but position is beyond the end of input, then fail.

9. If the p78 date present and time present flags are both true, parse a time-zone offset component to obtain timezonehours and

timezoneminutes. If this returns nothing, then fail.

10. If position is not beyond the end of input, then fail.

11. If the date present flag is true and the time present flag is false, then let date be the date with year year, month month, and

day day, and return date.

Otherwise, if the time present flag is true and the date present flag is false, then let time be the time with hour hour, minute minute, and second second, and return time.

Otherwise, let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes, that moment in time being a moment in the UTC time zone; let timezone be timezone hours hours and timezoneminutes minutes from UTC; and return time and timezone.



2.4.6 Colors p85 §

A simple color consists of three 8-bit numbers in the range 0..255, representing the red, green, and blue components of the color respectively, in the sRGB color space. p1281 [SRGB]

A string is a valid simple color if it is exactly seven characters long, and the first character is a U+0023 NUMBER SIGN character (#), and the remaining six characters are all ASCII hex digits, with the first two digits representing the red component, the middle two digits representing the green component, and the last two digits representing the blue component, in hexadecimal.

85

A string is a p85 valid lowercase simple color if it is a valid simple color and doesn't use any characters in the range U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL LETTER F.

The rules for parsing simple color values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a p85 simple color or an error.

1. Let input be the string being parsed.

2. If input is not exactly seven characters long, then return an error.

3. If the first character in input is not a U+0023 NUMBER SIGN character (#), then return an error.

4. If the last six characters of input are not all ASCII hex digits, then return an error.

5. Let p85 result be a simple color.

6. Interpret the second and third characters as a hexadecimal number and let the result be the red component of result.

7. Interpret the fourth and fifth characters as a hexadecimal number and let the result be the green component of result.

8. Interpret the sixth and seventh characters as a hexadecimal number and let the result be the blue component of result.

9. Return result.

The p85 rules for serializing simple color values given a simple color are as given in the following algorithm:

1. Let result be a string consisting of a single U+0023 NUMBER SIGN character (#).

2. Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using ASCII lower hex digits, zero-

padding if necessary, and append these numbers to result, in the order red, green, blue.

3. Return p86 result , which will be a valid lowercase simple color.



Some obsolete legacy attributes parse colors in a more complicated manner, using the rules for parsing a legacy color value, which are given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a p85 simple color or an error.

1. Let input be the string being parsed.

2. If input is the empty string, then return an error.

3. Strip leading and trailing ASCII whitespace from input.

4. If input is an ASCII case-insensitive match for the string "transparent", then return an error.

5. If p85 input is an ASCII case-insensitive match for one of the named colors , then return the simple color corresponding to that

keyword. p1276 [CSSCOLOR]

Note

CSS2 System Colors are not recognized.

6. If input's code point length is four, and the first character in input is U+0023 (#), and the last three characters of input are all

ASCII hex digits, then:

1. Let p85 result be a simple color.

2. Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting

number multiplied by 17.

3. Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting

number multiplied by 17.

4. Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting

number multiplied by 17.

5. Return result.

7. Replace any code points greater than U+FFFF in input (i.e., any characters that are not in the basic multilingual plane) with

86





the two-character string "00".


8. If input's code point length is greater than 128, truncate input, leaving only the first 128 characters.

9. If the first character in input is a U+0023 NUMBER SIGN character (#), remove it.

10. Replace any character in input that is not an ASCII hex digit with the character U+0030 DIGIT ZERO (0).

11. While input's code point length is zero or not a multiple of three, append a U+0030 DIGIT ZERO (0) character to input.

12. Split input into three strings of equal code point length, to obtain three components. Let length be the code point length that

all of those components have (one third the code point length of input).

13. If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.

14. While length is greater than two and the first character in each component is a U+0030 DIGIT ZERO (0) character, remove

that character and reduce length by one.

15. If length is still greater than two, truncate each component, leaving only the first two characters in each.

16. Let p85 result be a simple color.

17. Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.

18. Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.

19. Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.

20. Return result.



Note

The p637 2D graphics context has a separate color syntax that also handles opacity.



2.4.7 Space-separated tokens p87 §

A set of space-separated tokens is a string containing zero or more words (known as tokens) separated by one or more ASCII

whitespace, where words consist of any string of one or more characters, none of which are ASCII whitespace.

A string containing a p87 set of space-separated tokens may have leading or trailing ASCII whitespace.

An p87 unordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated.

An p87 ordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated but where the order of the tokens is meaningful.

Sets of space-separated tokens p87 sometimes have a defined set of allowed values. When a set of allowed values is defined, the tokens must all be from that list of allowed values; other values are non-conforming. If no such set of allowed values is provided, then all values are conforming.

Note

How tokens in a p87 set of space-separated tokens are to be compared (e.g. case-sensitively or not) is defined on a per-set basis.



2.4.8 Comma-separated tokens p87 §

A set of comma-separated tokens is a string containing zero or more tokens each separated from the next by a single U+002C

COMMA character (,), where tokens consist of any string of zero or more characters, neither beginning nor ending with ASCII

whitespace, nor containing any U+002C COMMA characters (,), and optionally surrounded by ASCII whitespace.



87

Example

For instance, the string " a ,b,,d d " consists of four tokens: "a", "b", the empty string, and "d d". Leading and trailing

whitespace around each token doesn't count as part of the token, and the empty string can be a token.

Sets of comma-separated tokens p87 sometimes have further restrictions on what consists a valid token. When such restrictions are defined, the tokens must all fit within those restrictions; other values are non-conforming. If no such restrictions are specified, then all values are conforming.



2.4.9 References p88 §

A valid hash-name reference to an element of type type is a string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches the value of the name attribute of an element with type type in the same tree.

The rules for parsing a hash-name reference to an element of type type, given a context node scope, are as follows:

1. If the string being parsed does not contain a U+0023 NUMBER SIGN character, or if the first such character in the string is

the last character in the string, then return null.

2. Let s be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed

up to the end of that string.

3. Return the first element of type p138 type in scope 's tree , in tree order , that has an id or name attribute whose value is s, or

null if there is no such element.

Note

Although p138 id attributes are accounted for when parsing, they are not used in determining whether a value is a valid

hash-name reference p88 p138 . That is, a hash-name reference that refers to an element based on id is a conformance error (unless that element also has a name attribute with the same value).



2.4.10 Media queries p88 §

A string is a p1279 valid media query list if it matches the production of Media Queries . [MQ]

A string matches the environment of the user if it is the empty string, a string consisting of only ASCII whitespace, or is a media query list that matches the user's environment according to the definitions given in p1279 Media Queries . [MQ]



2.5 URLs p88 §

2.5.1 Terminology p88 §

A string is a valid non-empty URL if it is a valid URL string but it is not the empty string.

A string is a valid URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid

URL string.

A string is a valid non-empty URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a p88 valid non-empty URL.

This specification defines the URL p1064 about:legacy-compat as a reserved, though unresolvable, about: URL, for use in DOCTYPEs in

HTML documents p1275 when needed for compatibility with XML tools. [ABOUT]

This specification defines the URL about:html-kind as a reserved, though unresolvable, about: URL, that is used as an identifier for kinds of media tracks. p1275 [ABOUT]

This specification defines the URL about:srcdoc as a reserved, though unresolvable, about: URL, that is used as the URL of iframe

srcdoc p363 p1275 documents . [ABOUT]

88

The p115 fallback base URL of a Document object document is the URL record obtained by running these steps:

1. If p363 p89 p814 document is an iframe srcdoc document , then return the document base URL of document 's browsing context 's

container document p817 .

2. If p51 p814 p815 document 's URL is about:blank , and document 's browsing context 's creator base URL is non-null, then return

that p815 creator base URL .

3. Return document's URL.

The p115 document base URL of a Document object is the absolute URL obtained by running these steps:

1. If there is no p156 p157 p115 p115 base element that has an href attribute in the Document , then return the Document 's fallback base

URL p89.

2. Otherwise, return the p157 p156 p115 p157 frozen base URL of the first base element in the Document that has an href attribute, in

tree order.



2.5.2 Parsing URLs p89 §

Parsing a URL is the process of taking a string and obtaining the URL record that it represents. While this process is defined in URL, the HTML standard defines a wrapper for convenience. p1282 [URL]

Note

This wrapper is only useful when the character encoding for the URL parser has to match that of the document or environment

settings object for legacy reasons. When that is not the case the URL parser can be used directly.

To parse a URL url, relative to either a document or environment settings object, the user agent must use the following steps. Parsing a URL either results in failure or a p89 p89 resulting URL string and resulting URL record.

1. Let encoding be document's character encoding, if document was given, and environment settings object's API URL

character encoding p904 otherwise.

2. Let p89 p904 baseURL be document 's base URL , if document was given, and environment settings object 's API base URL

otherwise.

3. Let urlRecord be the result of applying the URL parser to url, with baseURL and encoding.

4. If urlRecord is failure, then return failure.

5. Let urlString be the result of applying the URL serializer to urlRecord.

6. Return urlString as the resulting URL string and urlRecord as the resulting URL record.



2.5.3 Dynamic changes to base URLs p89 §

When a document's p89 p56 document base URL changes, all elements in that document are affected by a base URL change.

The following are p56 p56 base URL change steps , which run when an element is affected by a base URL change (as defined by DOM):

↪ p284 If the element creates a hyperlink

If the URL identified by the hyperlink is being shown to the user, or if any data derived from that URL is affecting the display,

then the p285 p89 href attribute should be reparsed relative to the element's node document and the UI updated appropriately.

Example

For example, the CSS p728 p728 :link / :visited pseudo-classes might have been affected.

If the hyperlink has a p285 p285 ping attribute and its URL(s) are being shown to the user, then the ping attribute's tokens should

be p89 reparsed relative to the element's node document and the UI updated appropriately.

89

↪ p248 p219 p312 p313 If the element is a q , blockquote , ins , or del element with a cite attribute

If the URL identified by the cite attribute is being shown to the user, or if any data derived from that URL is affecting the

display, then the p89 URL should be reparsed relative to the element's node document and the UI updated appropriately.

↪ Otherwise

The element is not directly affected.

Example

For instance, changing the base URL doesn't affect the image displayed by p321 img elements, although subsequent accesses

of the p324 src IDL attribute from script will return a new absolute URL that might no longer correspond to the image being shown.



2.6 Fetching resources p90 §

2.6.1 Terminology p90 §

A p1277 response whose type is " basic ", " cors ", or " default " is CORS-same-origin . [FETCH]

A response whose type is "opaque" or "opaqueredirect" is CORS-cross-origin.

A response's unsafe response is its internal response if it has one, and the response itself otherwise.

To create a potential-CORS request, given a url, destination, corsAttributeState, and an optional same-origin fallback flag, run these steps:

1. Let p91 mode be " no-cors " if corsAttributeState is No CORS, and "cors" otherwise.

2. If same-origin fallback flag is set and mode is "no-cors", set mode to "same-origin".

3. Let credentialsMode be "include".

4. If p91 corsAttributeState is Anonymous, set credentialsMode to "same-origin".

5. Let request be a new request whose url is url, destination is destination, mode is mode, credentials mode is credentialsMode,

and whose use-URL-credentials flag is set.



2.6.2 Determining the type of a resource p90 §

The Content-Type metadata of a resource must be obtained and interpreted in a manner consistent with the requirements of MIME

Sniffing p1279 . [MIMESNIFF]

The computed MIME type of a resource must be found in a manner consistent with the requirements given in MIME Sniffing.

[MIMESNIFF] p1279

The rules for sniffing images specifically, the rules for distinguishing if a resource is text or binary, and the rules for

sniffing audio and video specifically are also defined in MIME Sniffing. These rules return a MIME type as their result.

[MIMESNIFF] p1279

⚠Warning!

It is imperative that the rules in MIME Sniffing be followed exactly. When a user agent uses different heuristics for

content type detection than the server expects, security problems can occur. For more details, see MIME Sniffing.

[MIMESNIFF] p1279



2.6.3 Extracting character encodings from p165 p90 meta elements §

The algorithm for extracting a character encoding from a meta element, given a string s, is as follows. It either returns a

90

character encoding or nothing.

1. Let position be a pointer into s, initially pointing at the start of the string.

2. Loop: Find the first seven characters in s after position that are an ASCII case-insensitive match for the word "charset". If no

such match is found, return nothing.

3. Skip any ASCII whitespace that immediately follow the word "charset" (there might not be any).

4. If the next character is not a U+003D EQUALS SIGN (=), then move position to point just before that next character, and

jump back to the step labeled loop.

5. Skip any ASCII whitespace that immediately follow the equals sign (there might not be any).

6. Process the next character as follows:

↪ If it is a U+0022 QUOTATION MARK character (") and there is a later U+0022 QUOTATION MARK character

(") in s

↪ If it is a U+0027 APOSTROPHE character (') and there is a later U+0027 APOSTROPHE character (') in s

Return the result of getting an encoding from the substring that is between this character and the next earliest occurrence of this character.

↪ If it is an unmatched U+0022 QUOTATION MARK character (") ↪ If it is an unmatched U+0027 APOSTROPHE character (')

↪ If there is no next character

Return nothing.

↪ Otherwise

Return the result of getting an encoding from the substring that consists of this character up to but not including the

first ASCII whitespace or U+003B SEMICOLON character (;), or the end of s, whichever comes first.

Note

This algorithm is distinct from those in the HTTP specifications (for example, HTTP doesn't allow the use of single quotes and

requires supporting a backslash-escape mechanism that is not supported by this algorithm). While the algorithm is used in

contexts that, historically, were related to HTTP, the syntax as supported by implementations diverged some time ago. p1278 [HTTP]



2.6.4 CORS settings attributes §

p91 ✔ MDN



A p68 CORS settings attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the states given in the first cell of the rows with keywords give the states to which those keywords map.

State Keywords Brief description

Anonymous anonymous Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".

(the empty string)

Use Credentials use-credentials Requests for the element will have their mode set to "cors" and their credentials mode set to "include".

The attribute's p68 p91 p68 invalid value default is the Anonymous state, and its missing value default is the No CORS state. For the purposes of p95 p95 p91 p91 reflection , the canonical keyword for the Anonymous state is the anonymous keyword.

The majority of fetches governed by p91 p90 CORS settings attributes will be done via the create a potential-CORS request algorithm.

For more modern features, where the request's p91 mode is always " cors ", certain CORS settings attributes have been repurposed to have a slightly different meaning, wherein they only impact the request's credentials mode. To perform this translation, we define the CORS settings attribute credentials mode p91 for a given CORS settings attribute to be determined by switching on the attribute's state:

↪ p91 No CORS

↪ p91 Anonymous

"same-origin"

↪ p91 Use Credentials

"include"

91

2.6.5 Referrer policy attributes p92 §

A p68 referrer policy attribute is an enumerated attribute. Each referrer policy, including the empty string, is a keyword for this attribute, mapping to a state of the same name.

The attribute's p68 p68 invalid value default and missing value default are both the empty string state.

The impact of these states on the processing model of various fetches is defined in more detail throughout this specification, in Fetch, and in p1277 p1280 Referrer Policy . [FETCH] [REFERRERPOLICY]

Note

Several signals can contribute to which processing model is used for a given p92 fetch ; a referrer policy attribute is only one of

them. In general, the order in which these signals are processed are:

1. First, the presence of a p305 noreferrer link type;

2. Then, the value of a p92 referrer policy attribute;

3. Then, the presence of any p165 p166 p168 meta element with name attribute set to referrer .

4. Finally, the `Referrer-Policy` HTTP header.



2.6.6 Nonce attributes p92 §

A nonce content attribute represents a cryptographic nonce ("number used once") which can be used by Content Security Policy ✔ to MDN

determine whether or not a given fetch will be allowed to proceed. The value is text. p1275 [CSP]

Elements that have a p92 nonce content attribute ensure that the crytographic nonce is only exposed to script (and not to side-channels like CSS attribute selectors) by taking the value from the content attribute, moving it into an internal slot named

[[CryptographicNonce]] p126 , exposing it to script via the HTMLOrSVGElement interface mixin, and setting the content attribute to the empty string. Unless otherwise specified, the slot's value is the empty string.

For web developers (non-normative)

element . nonce

Returns the value of the element's p92 [[CryptographicNonce]] internal slot. Can be set, to update that slot's value.

The p92 nonce IDL attribute must, on getting, return the value of this element's [[CryptographicNonce]]; and on setting, set this

element's p92 [[CryptographicNonce]] to the given value.

Note

Note how the setter for the p92 nonce IDL attribute does not update the corresponding content attribute. This, as well as the below

setting of the p92 p45 nonce content attribute to the empty string when an element becomes browsing-context connected, is meant

to prevent exfiltration of the nonce value through mechanisms that can easily read content attributes, such as selectors. Learn

more in issue #2369, where this behavior was introduced.

The following p92 attribute change steps are used for the nonce content attribute:

1. If p126 element does not include HTMLOrSVGElement, then return.

2. If p92 localName is not nonce or namespace is not null, then return.

3. If p92 value is null, then set element 's [[CryptographicNonce]] to the empty string.

4. Otherwise, set p92 element 's [[CryptographicNonce]] to value.

Whenever an element p126 p45 including HTMLOrSVGElement becomes browsing-context connected, the user agent must execute the following steps on the element:

1. Let p116 CSP list be element 's shadow-including root 's CSP list.

92

2. If p92 CSP list contains a header-delivered Content Security Policy , and element has a nonce content attribute attr whose value

is not the empty string, then:

1. Let p92 nonce be element 's [[CryptographicNonce]].

2. p92 Set an attribute value for element using " nonce" and the empty string.

3. Set p92 element 's [[CryptographicNonce]] to nonce.

Note

If p92 element 's [[CryptographicNonce]] were not restored it would be the empty string at this point.



Note

As each p115 p116 Document 's CSP list is append-only, user agents can optimize away the contains a header-delivered Content Security

Policy p115 p882 check by, for example, holding a flag on the Document , set during Document creation and initialization.

The p126 p92 cloning steps for elements that include HTMLOrSVGElement must set the [[CryptographicNonce]] slot on the copy to the value of the slot on the element being cloned.



MDN

2.6.7 Lazy loading attributes p93 §

A p68 lazy loading attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

The attribute directs the user agent to fetch a resource immediately or to defer fetching until some conditions associated with the element are met, according to the attribute's current state.

Keyword State Description

lazy Lazy Used to defer fetching a resource until some conditions are met.

eager Eager Used to fetch a resource immediately; the default state.

The attribute's p68 p68 p93 missing value default and invalid value default are both the Eager state.



The will lazy load element steps, given an element element, are as follows:

1. If p911 scripting is disabled for element, then return false.

Note

This is an anti-tracking measure, because if a user agent supported lazy loading when scripting is disabled, it would still be possible for a site to track a user's approximate scroll position throughout a session, by strategically placing images in a page's markup such that a server can track how many images are requested and when.

2. If p93 p93 element 's lazy loading attribute is in the Lazy state, then return true.

3. Return false.

Each p321 p362 img and iframe element has associated lazy load resumption steps, initially null.

Note

For p321 p362 p93 p93 img and iframe elements that will lazy load , these steps are run from the lazy load intersection observer's callback

or when their p93 p93 lazy loading attribute is set to the Eager state. This causes the element to continue loading.

Each p115 Document has a lazy load intersection observer, initially set to null but can be set to an IntersectionObserver instance.

To start intersection-observing a lazy loading element element, run these steps:

1. Let doc be element's node document.

2. If p93 doc 's lazy load intersection observer is null, set it to a new IntersectionObserver instance, initialized as follows:

93

The intention is to use the original value of the IntersectionObserver constructor. However, we're forced to use the JavaScript-exposed constructor in this specification, until Intersection Observer exposes low-level hooks for use in

specifications. See bug p1278 w3c/IntersectionObserver#427 which tracks this. [INTERSECTIONOBSERVER]

◦ The callback is these steps, with arguments entries and observer:

1. For each entry in entries using a method of iteration which does not trigger developer-modifiable array

accessors or iteration hooks :

1. Let resumptionSteps be null.

2. If entry.isIntersecting is true, then set resumptionSteps to entry.target's lazy load

resumption steps p93.

3. If resumptionSteps is null, then return.

4. p94 Stop intersection-observing a lazy loading element for entry.target.

5. Set p93 entry . target 's lazy load resumption steps to null.

6. Invoke resumptionSteps.

The intention is to use the original value of the isIntersecting and target getters. See w3c/

IntersectionObserver#427 p1278 . [INTERSECTIONOBSERVER]

◦ The options is an IntersectionObserverInit dictionary with the following dictionary members: «[ "rootMargin"

→ p94 lazy load root margin ]»

Note

This allows for fetching the image during scrolling, when it does not yet — but is about to — intersect the viewport.



The p94 lazy load root margin suggestions imply dynamic changes to the value, but the IntersectionObserver

API does not support changing the root margin. See issue w3c/IntersectionObserver#428.

3. Call p93 doc 's lazy load intersection observer's observe method with element as the argument.

The intention is to use the original value of the observe method. See w3c/IntersectionObserver#427.

[INTERSECTIONOBSERVER] p1278

To stop intersection-observing a lazy loading element element, run these steps:

1. Let doc be element's node document.

2. Assert: p93 doc 's lazy load intersection observer is not null.

3. Call p93 doc 's lazy load intersection observer unobserve method with element as the argument.

The intention is to use the original value of the unobserve method. See w3c/IntersectionObserver#427.

[INTERSECTIONOBSERVER] p1278

The lazy load root margin is an implementation-defined value, but with the following suggestions to consider:

• Set a minimum value that most often results in the resources being loaded before they intersect the viewport under

normal usage patterns for the given device.

• The typical scrolling speed: increase the value for devices with faster typical scrolling speeds.

• The current scrolling speed or momentum: the UA can attempt to predict where the scrolling will likely stop, and adjust the

value accordingly.

• The network quality: increase the value for slow or high-latency connections.

• User preferences can influence the value.

94

Note

It is important p94 for privacy that the lazy load root margin not leak additional information. For example, the typical scrolling speed

on the current device could be imprecise so as to not introduce a new fingerprinting vector.



2.7 Common DOM interfaces p95 §

2.7.1 Reflecting content attributes in IDL attributes p95 §

Some IDL attributes are defined to reflect a particular content attribute. This means that on getting, the IDL attribute returns the current value of the content attribute, and on setting, the IDL attribute changes the value of the content attribute to the given value.

In general, on getting, if the content attribute is not present, the IDL attribute must act as if the content attribute's value is the empty string; and on setting, if the content attribute is not present, it must first be added.

If a reflecting IDL attribute is a USVString attribute whose content attribute is defined to contain a URL, then on getting, if the content attribute is absent, the IDL attribute must return the empty string. Otherwise, the IDL attribute must p89 parse the value of the content attribute relative to the element's p89 node document and if that is successful, return the resulting URL string. If parsing fails, then the

value of the content attribute must be returned instead, converted to a USVString. On setting, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a p68 DOMString attribute whose content attribute is an enumerated attribute, and the IDL attribute is limited to only known values, then, on getting, the IDL attribute must return the keyword value associated with the state the attribute is in, if any, or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is not in a defined state (e.g. the attribute is missing and there is no p68 missing value default). If there are multiple keyword values for the state, then return the conforming one. If there are multiple conforming keyword values, then one will be designated the canonical keyword; choose that one. On setting, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a nullable p68 DOMString attribute whose content attribute is an enumerated attribute, then, on getting, if the corresponding content attribute is in its missing value default state then the IDL attribute must return null, otherwise, the IDL attribute must return the keyword value associated with the state the attribute is in. If there are multiple keyword values for the state, then return the conforming one. If there are multiple conforming keyword values, then one will be designated the canonical

keyword p95; choose that one. On setting, if the new value is null, the content attribute must be removed, and otherwise, the content attribute must be set to the specified new value.

If a reflecting IDL attribute is a DOMString or USVString attribute but doesn't fall into any of the above categories, then the getting and setting must be done in a transparent, case-preserving manner.

If a reflecting IDL attribute is a boolean attribute, then on getting the IDL attribute must return true if the content attribute is set, and false if it is absent. On setting, the content attribute must be removed if the IDL attribute is set to false, and must be set to the empty string if the IDL attribute is set to true. (This corresponds to the rules for p67 boolean content attributes.)

If a reflecting IDL attribute has a signed integer type (long) then, on getting, the content attribute must be parsed according to the

rules for parsing signed integers p68, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, then the default value must be returned instead, or 0 if there is no default value. On setting, the given value must be converted to the shortest possible string representing the number as a p68 valid integer and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has a signed integer type (long) that is limited to only non-negative numbers then, on getting, the content attribute must be parsed according to the p69 rules for parsing non-negative integers, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or −1 if there is no default value. On setting, if the value is negative, the user agent must throw an "IndexSizeError" DOMException. Otherwise, the given value must be converted to the

shortest possible string representing the number as a p69 valid non-negative integer and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) then, on getting, the content attribute must be parsed

according to the p69 rules for parsing non-negative integers, and if that is successful, and the value is in the range 0 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0 if there is no default value. On setting, first, if the new value is in the range 0 to 2147483647, then let n be the new value, otherwise let n be the default value, or 0 if there is no default value; then, n must be converted to the shortest possible string representing the number as a p69 valid non-negative integer and that string must be used as

95

the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero, then the behavior is similar to the previous case, but zero is not allowed. On getting, the content attribute must first be parsed according to the p69 rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 1 if there is no default value. On setting, if the value is zero, the user agent must throw an "IndexSizeError" DOMException. Otherwise, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value, or 1 if there is no default value; then, n must be converted to the shortest possible string representing the number as a p69 valid non-negative integer and that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero with fallback, then the behavior is similar to the previous case, but disallowed values are converted to the default value.

On getting, the content attribute must first be parsed according to the p69 rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead. On setting, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value; then, n must be converted to the shortest possible string representing the number as a p69 valid non-negative integer and that string must be used as the new content attribute value.

If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is clamped to the range [min, max], then on getting, the content attribute must first be parsed according to the p69 rules for parsing non-negative integers, and if that is successful, and the value is between min and max inclusive, the resulting value must be returned. If it fails, the default value must be returned. If it succeeds but the value is less than min, min must be returned. If it succeeds but the value is greater than max, max must be returned. On setting, it behaves the same as setting a regular reflected unsigned integer.

If a reflecting IDL attribute has a floating-point number type (double or unrestricted double), then, on getting, the content attribute

must be parsed according to the p70 rules for parsing floating-point number values, and if that is successful, the resulting value must be returned. If, on the other hand, it fails, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, the given value must be converted to the p70 best representation of the number as a floating-point number and then that string must be used as the new content attribute value.

If a reflecting IDL attribute has a floating-point number type (double or unrestricted double) that is limited to numbers greater than zero, then the behavior is similar to the previous case, but zero and negative values are not allowed. On getting, the content attribute must be parsed according to the p70 rules for parsing floating-point number values, and if that is successful and the value is greater than 0.0, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, if the value is less than or equal to zero, then the value must be ignored. Otherwise, the given value must be converted to the best representation of the number as a

floating-point number p70 and then that string must be used as the new content attribute value.

Note

The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in p1282 Web IDL . [WEBIDL]

If a reflecting IDL attribute has the type DOMTokenList, then on getting it must return a DOMTokenList object whose associated element is the element in question and whose associated attribute's local name is the name of the attribute in question.



2.7.2 Collections p96 §

The p99 p100 HTMLFormControlsCollection and HTMLOptionsCollection interfaces are collections derived from the HTMLCollection

interface. The p97 HTMLAllCollection interface is a collection, but is not so derived.



2.7.2.1 The p97 p96 HTMLAllCollection interface §

The p97 p1240 HTMLAllCollection interface is used for the legacy document.all attribute. It operates similarly to HTMLCollection; the main differences are that it allows a staggering variety of different (ab)uses of its methods to all end up returning something, and that it can be called as a function as an alternative to property access.



96

Note

All p97 p115 HTMLAllCollection objects are rooted at a Document and have a filter that matches all elements, so the elements

represented by the collection p97 p115 of an HTMLAllCollection object consist of all the descendant elements of the root Document .

Objects that implement the p97 HTMLAllCollection interface are legacy platform objects with an additonal [[Call]] internal method described in the p98 section below. They also have an [[IsHTMLDDA]] internal slot.

Note

Objects that implement the p97 HTMLAllCollection interface have several unusual behaviors, due of the fact that they have an

[[IsHTMLDDA]] internal slot:

• The p97 ToBoolean abstract operation in JavaScript returns false when given objects implementing the HTMLAllCollection

interface.

• The p97 Abstract Equality Comparison algorithm, when given objects implementing the HTMLAllCollection interface,

returns true when compared to the undefined and null values. (Comparisons using the Strict Equality Comparison algorithm, and Abstract Equality comparisons to other values such as strings or objects, are unaffected.)

• The typeof operator in JavaScript returns the string "undefined" when applied to objects implementing the

HTMLAllCollection p97 interface.

These special behaviors are motivated by a desire for compatibility with two classes of legacy content: one that uses the presence

of p1240 document.all as a way to detect legacy user agents, and one that only supports those legacy user agents and uses the

document.all p1240 p1278 object without testing for its presence first. [JAVASCRIPT]



IDL [Exposed=Window,

LegacyUnenumerableNamedProperties]

interface HTMLAllCollection {

readonly attribute unsigned long length;

getter Element (unsigned long index);

getter (HTMLCollection or Element)? namedItem(DOMString name);

(HTMLCollection or Element)? item(optional DOMString nameOrIndex);

// Note: HTMLAllCollection objects have a custom [[Call]] internal method and an [[IsHTMLDDA]]

internal slot.

};



For web developers (non-normative)

collection p98 . length

Returns the number of elements in the collection.

element p98 = collection . item(index)

element = collection(index)

element = collection[index]

Returns the item with index index from the collection (determined by tree order).

element p98 = collection . item(name)

collection p98 = collection . item(name)

element p98 = collection . namedItem(name)

collection p98 = collection . namedItem(name)

element = collection(name)

collection = collection(name)

element = collection[name]

collection = collection[name]

Returns the item with ID or name name from the collection.

If there are multiple matching items, then an HTMLCollection object containing all those elements is returned.

Only p536 p487 p362 p494 p443 p165 p373 p538 p549 button , form , iframe , input , map , meta , object , select , and textarea elements can have a name for the purpose of this method; their name is given by the value of their name attribute.

97

The object's supported property indices are as defined for HTMLCollection objects.

The p138 supported property names consist of the non-empty values of all the id attributes of all the elements represented by the

collection p98 , and the non-empty values of all the name attributes of all the "all"-named elements represented by the collection, in tree

order p138 , ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

On getting, the length attribute must return the number of nodes represented by the collection.

The indexed property getter must return the result of p98 p97 getting the "all"-indexed element from this HTMLAllCollection given the passed index.

The p98 p97 namedItem( name ) method must return the result of getting the "all"-named element(s) from this HTMLAllCollection given name.

The item(nameOrIndex) method must perform the following steps:

1. If nameOrIndex was not provided, return null.

2. Return the result of p98 p97 getting the "all"-indexed or named element(s) from this HTMLAllCollection, given nameOrIndex.



The following elements are p239 p536 p369 p487 p1231 p1230 p362 p321 "all"-named elements : a , button , embed , form , frame , frameset , iframe , img,

input p494 p443 p165 p373 p538 p549 , map , meta , object , select , and textarea

To p97 th get the "all"-indexed element from an HTMLAllCollection collection given an index index , return the index element in collection th , or null if there is no such index element.

To p97 get the "all"-named element(s) from an HTMLAllCollection collection given a name name, perform the following steps:

1. If name is the empty string, return null.

2. Let p115 subCollection be an HTMLCollection object rooted at the same Document as collection, whose filter matches only

elements that are either:

◦ p98 "all"-named elements with a name attribute equal to name, or,

◦ elements with an ID equal to name.

3. If there is exactly one element in subCollection, then return that element.

4. Otherwise, if subCollection is empty, return null.

5. Otherwise, return subCollection.

To p97 get the "all"-indexed or named element(s) from an HTMLAllCollection collection given nameOrIndex:

1. If nameOrIndex, converted to a JavaScript String value, is an array index property name, return the result of getting the "all"-

indexed element p98 p97 from this HTMLAllCollection given the number represented by nameOrIndex.

2. Return the result of p98 p97 getting the "all"-named element(s) from this HTMLAllCollection given nameOrIndex.



2.7.2.1.1 [[Call]] ( thisArgument, argumentsList ) p98 §

1. If argumentsList's size is zero, or if argumentsList[0] is undefined, return null.

2. Let nameOrIndex be the result of converting argumentsList[0] to a DOMString.

3. Let p98 p97 result be the result of getting the "all"-indexed or named element(s) from this HTMLAllCollection given

nameOrIndex.

4. Return the result of converting result to an ECMAScript value.



98

Note

The thisArgument is ignored, and thus code such as Function.prototype.call.call(document.all, null, "x") will still search

for elements. (document.all.call does not exist, since document.all does not inherit from Function.prototype.)



2.7.2.2 The p99 p99 HTMLFormControlsCollection interface §

✔ MDN

The p99 p487 p487 HTMLFormControlsCollection interface is used for collections of listed elements in form elements.

IDL [Exposed=Window]

interface HTMLFormControlsCollection : HTMLCollection {

// inherits length and item()

getter (RadioNodeList or Element)? namedItem(DOMString name); // shadows inherited namedItem()

};

[Exposed=Window]

interface RadioNodeList : NodeList {

attribute DOMString value;

};



For web developers (non-normative)

collection . length

Returns the number of elements in the collection.

element = collection . item(index)

element = collection[index]

Returns the item with index index from the collection. The items are sorted in tree order.

element p99 = collection . namedItem(name)

radioNodeList p99 = collection . namedItem(name)

element = collection[name]

radioNodeList = collection[name]

Returns the item with p569 ID or name name from the collection.

If there are multiple matching items, then a p99 RadioNodeList object containing all those elements is returned.

radioNodeList . value [ = value ]

Returns the value of the first checked radio button represented by the object. Can be set, to check the first radio button with the given value represented by the object.

The object's supported property indices are as defined for HTMLCollection objects.

The p138 p569 supported property names consist of the non-empty values of all the id and name attributes of all the elements represented

by the collection p138 p569 , in tree order , ignoring later duplicates, with the id of an element preceding its name if it contributes both, they ✔ MDN differ from each other, and neither is the duplicate of an earlier entry.

The namedItem(name) method must act according to the following algorithm:

1. If name is the empty string, return null and stop the algorithm.

2. If, at the time the method is called, there is exactly one node in the collection that has either an p138 p569 id attribute or a name

attribute equal to name, then return that node and stop the algorithm.

3. Otherwise, if there are no nodes in the collection that have either an p138 p569 id attribute or a name attribute equal to name,

then return null and stop the algorithm.

4. Otherwise, create a new p99 p45 p99 RadioNodeList object representing a live view of the HTMLFormControlsCollection object,

further filtered so that the only nodes in the p99 p138 RadioNodeList object are those that have either an id attribute or a

name p569 p99 attribute equal to name . The nodes in the RadioNodeList object must be sorted in tree order.

5. Return that p99 RadioNodeList object.

99

✔ MDN

Members of the p99 RadioNodeList interface inherited from the NodeList interface must behave as they would on a NodeList object.

The p99 value IDL attribute on the RadioNodeList object, on getting, must return the value returned by running the following steps:

1. Let p99 p494 element be the first element in tree order represented by the RadioNodeList object that is an input element

whose p496 p515 p567 type attribute is in the Radio Button state and whose checkedness is true. Otherwise, let it be null.

2. If element is null, return the empty string.

3. If p498 element is an element with no value attribute, return the string "on".

4. Otherwise, return the value of p498 element 's value attribute.

On setting, the p100 value IDL attribute must run the following steps:

1. If the new value is the string " p99 on ": let element be the first element in tree order represented by the RadioNodeList object

that is an p494 p496 p515 p498 input element whose type attribute is in the Radio Button state and whose value content attribute is either absent, or present and equal to the new value, if any. If no such element exists, then instead let element be null.

Otherwise: let p99 p494 element be the first element in tree order represented by the RadioNodeList object that is an input

element whose p496 p515 p498 type attribute is in the Radio Button state and whose value content attribute is present and equal to the new value, if any. If no such element exists, then instead let element be null.

2. If p567 element is not null, then set its checkedness to true.



2.7.2.3 The p100 ✔ MDN p10 HTMLOptionsCollection interface §

0

The p100 p546 p538 HTMLOptionsCollection interface is used for collections of option elements. It is always rooted on a select element and has attributes and methods that manipulate that element's descendants.

IDL [Exposed=Window]

interface HTMLOptionsCollection : HTMLCollection {

// inherits item(), namedItem()

[CEReactions] attribute unsigned long length; // shadows inherited length

[CEReactions] setter undefined (unsigned long index, HTMLOptionElement? option);

[CEReactions] undefined add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement

or long)? before = null);

[CEReactions] undefined remove(long index);

attribute long selectedIndex;

};



For web developers (non-normative)

collection p101 . length [ = value ]

Returns the number of elements in the collection.

When set to a smaller number, truncates the number of p546 option elements in the corresponding container.

When set to a greater number, adds new blank p546 option elements to that container.

element = collection . item(index)

element = collection[index]

Returns the item with index index from the collection. The items are sorted in tree order.

collection[index] = element

When p546 index is a greater number than the number of items in the collection, adds new blank option elements in the corresponding container.

When set to null, removes the item at index index from the collection.

When set to an p546 option element, adds or replaces it at index index from the collection.

element = collection . namedItem(name)

element = collection[name]

Returns the item with p1224 ID or name name from the collection.

100

If there are multiple matching items, then the first is returned.

collection p101 . add (element [, before ] )

Inserts element before the node given by before.

The before argument can be a number, in which case element is inserted before the item with that number, or an element from the collection, in which case element is inserted before that element.

If before is omitted, null, or a number out of range, then element will be added at the end of the list.

This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.

collection p102 . remove(index)

Removes the item with index index from the collection.

collection p102 . selectedIndex [ = value ]

Returns the index of the first selected item, if any, or −1 if there is no selected item. Can be set, to change the selection.

The object's supported property indices are as defined for HTMLCollection objects.

On getting, the length attribute must return the number of nodes represented by the collection.

On setting, the behavior depends on whether the new value is equal to, greater than, or less than the number of nodes represented by

the collection at that time. If the number is the same, then setting the attribute must do nothing. If the new value is greater, then n new p546 p538 option elements with no attributes and no child nodes must be appended to the select element on which the

HTMLOptionsCollection p100 is rooted, where n is the difference between the two numbers (new value minus old value). Mutation events must be fired as if a p546 DocumentFragment containing the new option elements had been inserted. If the new value is lower, then the last n nodes in the collection must be removed from their parent nodes, where n is the difference between the two numbers (old value minus new value).

Note

Setting p101 p545 p545 length never removes or adds any optgroup elements, and never adds new children to existing optgroup

elements (though it can remove children from them).

The p138 p1224 supported property names consist of the non-empty values of all the id and name attributes of all the elements represented

by the collection p138 p1224 , in tree order , ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.

When the user agent is to set the value of a new indexed property or set the value of an existing indexed property for a given property index index to a new value value, it must run the following algorithm:

1. If p102 value is null, invoke the steps for the remove method with index as the argument, and return.

2. Let length be the number of nodes represented by the collection.

3. Let n be index minus length.

4. If p546 n is greater than zero, then append a DocumentFragment consisting of n-1 new option elements with no attributes and

no child nodes to the p538 p100 select element on which the HTMLOptionsCollection is rooted.

5. If p538 n is greater than or equal to zero, append value to the select element. Otherwise, replace the indexth element in the

collection by value.

The add(element, before) method must act according to the following algorithm:

1. If p538 p100 element is an ancestor of the select element on which the HTMLOptionsCollection is rooted, then throw a

"HierarchyRequestError" DOMException.

2. If p538 before is an element, but that element isn't a descendant of the select element on which the

HTMLOptionsCollection p100 is rooted, then throw a "NotFoundError" DOMException.

3. If element and before are the same element, then return.

101

4. If before is a node, then let reference be that node. Otherwise, if before is an integer, and there is a beforeth node in the

collection, let reference be that node. Otherwise, let reference be null.

5. If p538 reference is not null, let parent be the parent node of reference . Otherwise, let parent be the select element on which

the p100 HTMLOptionsCollection is rooted.

6. Pre-insert element into parent node before reference.

The remove(index) method must act according to the following algorithm:

1. If the number of nodes represented by the collection is zero, return.

2. If index is not a number greater than or equal to 0 and less than the number of nodes represented by the collection, return.

3. Let element be the indexth element in the collection.

4. Remove element from its parent node.

The p538 selectedIndex IDL attribute must act like the identically named attribute on the select element on which the

HTMLOptionsCollection p100 is rooted



2.7.3 The p102 ✔ MDN p10 DOMStringList interface §

2

The p102 DOMStringList interface is a non-fashionable retro way of representing a list of strings.

IDL [Exposed=(Window,Worker)]

interface DOMStringList {

readonly attribute unsigned long length;

getter DOMString? item(unsigned long index);

boolean contains(DOMString string);

};



⚠Warning!

New APIs must use p102 sequence<DOMString> or equivalent rather than DOMStringList.



For web developers (non-normative)

strings p102 . length

Returns the number of strings in strings.

strings[index]

strings p102 . item (index)

Returns the string with index index from strings.

strings p102 . contains(string)

Returns true if strings contains string, and false otherwise.

Each p102 DOMStringList object has an associated list.

The p102 supported property indices for a DOMStringList object are the numbers zero to the associated list's size minus one. If its associated list is empty, it has no supported property indices.

The p102 length attribute's getter must return this DOMStringList object's associated list's size.

The p102 item( index ) method, when invoked, must return the index th item in this DOMStringList object's associated list, or null if index p102 plus one is greater than this DOMStringList object's associated list's size.

The p102 contains( string ) method, when invoked, must return true if this DOMStringList object's associated list contains string, and false otherwise.



102

2.8 Safe passing of structured data p10 §

3

This section uses the terminology and typographic conventions from the JavaScript specification. p1278 [JAVASCRIPT]



2.8.1 Serializable objects p10 §

3

Serializable objects p103 support being serialized, and later deserialized, in a way that is independent of any given JavaScript Realm. This allows them to be stored on disk and later restored, or cloned across agent and even agent cluster boundaries.

Not all objects are p103 p103 serializable objects , and not all aspects of objects that are serializable objects are necessarily preserved when they are serialized.

Platform objects p103 can be serializable objects if their primary interface is decorated with the [Serializable] IDL extended attribute. Such interfaces must also define the following algorithms:

serialization steps, taking a platform object value, a Record serialized, and a boolean forStorage

A set of steps that serializes the data in value into fields of serialized. The resulting data serialized into serialized must be

independent of any JavaScript Realm.

These steps may throw an exception if serialization is not possible.

These steps may perform a p107 p108 sub-serialization to serialize nested data structures. They should not call StructuredSerialize directly, as doing so will omit the important memory argument.

The introduction of these steps should omit mention of the forStorage argument if it is not relevant to the algorithm.

deserialization steps, taking a Record serialized and a platform object value

A set of steps that deserializes the data in serialized, using it to set up value as appropriate. value will be a newly-created instance

of the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.

These steps may throw an exception if deserialization is not possible.

These steps may perform a p111 sub-deserialization to deserialize nested data structures. They should not call

StructuredDeserialize p108 directly, as doing so will omit the important targetRealm and memory arguments.

It is up to the definition of individual platform objects to determine what data is serialized and deserialized by these steps. Typically the steps are very symmetric.

The p103 [Serializable] extended attribute must take no arguments, and must only appear on an interface. It must not appear more than once on an interface.

For a given platform object, only the object's primary interface is considered during the (de)serialization process. Thus, if inheritance is involved in defining the interface, each p103 [Serializable]-annotated interface in the inheritance chain needs to define standalone

serialization steps p103 p103 and deserialization steps, including taking into account any important data that might come from inherited interfaces.

Example

Let's say we were defining a platform object Person, which had associated with it two pieces of associated data:

• a name value, which is a string;

• and a best friend value, which is either another Person instance or null

We could then define p103 Person instances to be serializable objects by annotating the Person interface with the

[Serializable] p103 extended attribute, and defining the following accompanying algorithms:

serialization steps p103

1. Set serialized.[[Name]] to value's associated name value.

2. Let p107 serializedBestFriend be the sub-serialization of value's associated best friend value.

3. Set serialized.[[BestFriend]] to serializedBestFriend.

103

deserialization steps p103

1. Set value's associated name value to serialized.[[Name]].

2. Let p111 deserializedBestFriend be the sub-deserialization of serialized.[[BestFriend]].

3. Set value's associated best friend value to deserializedBestFriend.



Objects defined in the JavaScript specification are handled by the p108 StructuredSerialize abstract operation directly.

Note

Originally, this specification defined the concept of "cloneable objects", which could be cloned from one JavaScript Realm to

another. However, to better specify the behavior of certain more complex situations, the model was updated to make the

serialization and deserialization explicit.



✔ MDN

2.8.2 Transferable objects p10 §

4

Transferable objects p104 support being transferred across agents. Transferring is effectively recreating the object while sharing a reference to the underlying data and then detaching the object being transferred. This is useful to transfer ownership of expensive resources. Not all objects are p104 p104 transferable objects and not all aspects of objects that are transferable objects are necessarily preserved when transferred.

Note

Transferring is an irreversible and non-idempotent operation. Once an object has been transferred, it cannot be transferred, or

indeed used, again.

Platform objects p104 can be transferable objects if their primary interface is decorated with the [Transferable] IDL extended attribute. Such interfaces must also define the following algorithms:

transfer steps, taking a platform object value and a Record dataHolder

A set of steps that transfers the data in value into fields of dataHolder. The resulting data held in dataHolder must be independent

of any JavaScript Realm.

These steps may throw an exception if transferral is not possible.

transfer-receiving steps, taking a Record dataHolder and a platform object value

A set of steps that receives the data in dataHolder, using it to set up value as appropriate. value will be a newly-created instance of

the platform object type in question, with none of its internal data set up; setting that up is the job of these steps.

These steps may throw an exception if it is not possible to receive the transfer.

It is up to the definition of individual platform objects to determine what data is transferred by these steps. Typically the steps are very symmetric.

The p104 [Transferable] extended attribute must take no arguments, and must only appear on an interface. It must not appear more than once on an interface.

For a given platform object, only the object's primary interface is considered during the transferring process. Thus, if inheritance is involved in defining the interface, each p104 [Transferable]-annotated interface in the inheritance chain needs to define standalone

transfer steps p104 p104 and transfer-receiving steps , including taking into account any important data that might come from inherited interfaces.

Platform objects p104 that are transferable objects have a [[Detached]] internal slot. This is used to ensure that once a platform object has been transferred, it cannot be transferred again.

Objects defined in the JavaScript specification are handled by the p111 StructuredSerializeWithTransfer abstract operation directly.



104

2.8.3 StructuredSerializeInternal ( value, forStorage [ , memory ] ) p10 §

5

The p105 StructuredSerializeInternal abstract operation takes as input a JavaScript value value and serializes it to a Realm-independent

form, represented here as a Record. This serialized form has all the information necessary to later deserialize into a new JavaScript value in a different Realm.

This process can throw an exception, for example when trying to serialize un-serializable objects.

1. If memory was not supplied, let memory be an empty map.

Note

The purpose of the memory map is to avoid serializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.

2. If memory[value] exists, then return memory[value].

3. Let deep be false.

4. If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String, then return { [[Type]]: "primitive", [[Value]]: value }.

5. If Type(value) is Symbol, then throw a "DataCloneError" DOMException.

6. Let serialized be an uninitialized value.

7. If value has a [[BooleanData]] internal slot, then set serialized to { [[Type]]: "Boolean", [[BooleanData]]:

value.[[BooleanData]] }.

8. Otherwise, if value has a [[NumberData]] internal slot, then set serialized to { [[Type]]: "Number", [[NumberData]]:

value.[[NumberData]] }.

9. Otherwise, if value has a [[BigIntData]] internal slot, then set serialized to { [[Type]]: "BigInt", [[BigIntData]]:

value.[[BigIntData]] }.

10. Otherwise, if value has a [[StringData]] internal slot, then set serialized to { [[Type]]: "String", [[StringData]]:

value.[[StringData]] }.

11. Otherwise, if value has a [[DateValue]] internal slot, then set serialized to { [[Type]]: "Date", [[DateValue]]:

value.[[DateValue]] }.

12. Otherwise, if value has a [[RegExpMatcher]] internal slot, then set serialized to { [[Type]]: "RegExp", [[RegExpMatcher]]:

value.[[RegExpMatcher]], [[OriginalSource]]: value.[[OriginalSource]], [[OriginalFlags]]: value.[[OriginalFlags]] }.

13. Otherwise, if value has an [[ArrayBufferData]] internal slot, then:

1. Let size be value.[[ArrayBufferByteLength]].

2. If ! IsSharedArrayBuffer(value) is true, then:

1. Let agentCluster be the surrounding agent's agent cluster.

2. If p901 agentCluster 's cross-origin isolated is false, then throw a "DataCloneError" DOMException.

Note

This check is only needed when serializing (and not when deserializing) as p901 cross-origin isolated

cannot change over time and a SharedArrayBuffer cannot leave an agent cluster.

3. If forStorage is true, then throw a "DataCloneError" DOMException.

4. Set serialized to { [[Type]]: "SharedArrayBuffer", [[ArrayBufferData]]: value.[[ArrayBufferData]],

[[ArrayBufferByteLength]]: size, [[AgentCluster]]: agentCluster }.

3. Otherwise:

1. If ! IsDetachedBuffer(value) is true, then throw a "DataCloneError" DOMException.

2. Let dataCopy be ? CreateByteDataBlock(size).

Note

This can throw a RangeError exception upon allocation failure.

105

3. Perform ! CopyDataBlockBytes(dataCopy, 0, value.[[ArrayBufferData]], 0, size).

4. Set serialized to { [[Type]]: "ArrayBuffer", [[ArrayBufferData]]: dataCopy, [[ArrayBufferByteLength]]: size

}.

14. Otherwise, if value has a [[ViewedArrayBuffer]] internal slot, then:

1. Let buffer be the value of value's [[ViewedArrayBuffer]] internal slot.

2. Let p105 bufferSerialized be ? StructuredSerializeInternal(buffer, forStorage, memory).

3. Assert: bufferSerialized.[[Type]] is "ArrayBuffer".

4. If value has a [[DataView]] internal slot, then set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]:

"DataView", [[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]] }.

5. Otherwise:

1. Assert: value has a [[TypedArrayName]] internal slot.

2. Set serialized to { [[Type]]: "ArrayBufferView", [[Constructor]]: value.[[TypedArrayName]],

[[ArrayBufferSerialized]]: bufferSerialized, [[ByteLength]]: value.[[ByteLength]], [[ByteOffset]]: value.[[ByteOffset]], [[ArrayLength]]: value.[[ArrayLength]] }.

15. Otherwise, if value has [[MapData]] internal slot, then:

1. Set serialized to { [[Type]]: "Map", [[MapData]]: a new empty List }.

2. Set deep to true.

16. Otherwise, if value has [[SetData]] internal slot, then:

1. Set serialized to { [[Type]]: "Set", [[SetData]]: a new empty List }.

2. Set deep to true.

17. Otherwise, if value has an [[ErrorData]] internal slot and value is not a platform object, then:

1. Let name be ? Get(value, "name").

2. If name is not one of "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", or "URIError",

then set name to "Error".

3. Let valueMessageDesc be ? value.[[GetOwnProperty]]("message").

4. Let message be undefined if IsDataDescriptor(valueMessageDesc) is false, and ?

ToString(valueMessageDesc.[[Value]]) otherwise.

5. Set serialized to { [[Type]]: "Error", [[Name]]: name, [[Message]]: message }.

6. User agents should attach a serialized representation of any interesting accompanying data which are not yet

specified, notably the stack property, to serialized.

Note

See the p1278 Error Stacks proposal for in-progress work on specifying this data. [JSERRORSTACKS]

18. Otherwise, if value is an Array exotic object, then:

1. Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, "length").

2. Let valueLen be valueLenDescriptor.[[Value]].

3. Set serialized to { [[Type]]: "Array", [[Length]]: valueLen, [[Properties]]: a new empty List }.

4. Set deep to true.

19. Otherwise, if p103 value is a platform object that is a serializable object :

1. If p104 value has a [[Detached]] internal slot whose value is true, then throw a "DataCloneError" DOMException.

2. Let typeString be the identifier of the primary interface of value.

106

3. Set serialized to { [[Type]]: typeString }.

4. Set deep to true.

20. Otherwise, if value is a platform object, then throw a "DataCloneError" DOMException.

21. Otherwise, if IsCallable(value) is true, then throw a "DataCloneError" DOMException.

22. Otherwise, if value has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError"

DOMException.

Example

For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.

23. Otherwise, if value is an exotic object and value is not the %Object.prototype% intrinsic object associated with any JavaScript

realm, then throw a "DataCloneError" DOMException.

Example

For instance, a proxy object.

24. Otherwise:

1. Set serialized to { [[Type]]: "Object", [[Properties]]: a new empty List }.

2. Set deep to true.

Note

%Object.prototype% will end up being handled via this step and subsequent steps. The end result is that its exoticness is

ignored, and after deserialization the result will be an empty object (not an immutable prototype exotic object).

25. Set memory[value] to serialized.

26. If deep is true, then:

1. If value has a [[MapData]] internal slot, then:

1. Let copiedList be a new empty List.

2. For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]:

1. Let copiedEntry be a new Record { [[Key]]: entry.[[Key]], [[Value]]: entry.[[Value]] }.

2. If copiedEntry.[[Key]] is not the special value empty, append copiedEntry to copiedList.

3. For each Record { [[Key]], [[Value]] } entry of copiedList:

1. Let p105 serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

2. Let p105 serializedValue be ? StructuredSerializeInternal (entry.[[Value]], forStorage, memory).

3. Append { [[Key]]: serializedKey, [[Value]]: serializedValue } to serialized.[[MapData]].

2. Otherwise, if value has a [[SetData]] internal slot, then:

1. Let copiedList be a new empty List.

2. For each entry of value.[[SetData]]:

1. If entry is not the special value empty, append entry to copiedList.

3. For each entry of copiedList:

1. Let p105 serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).

2. Append serializedEntry to serialized.[[SetData]].

3. Otherwise, if p103 p103 value is a platform object that is a serializable object , then perform the serialization steps for

value's primary interface, given value, serialized, and forStorage.

The p103 serialization steps may need to perform a sub-serialization. This is an operation which takes as input a

107

value p105 subValue , and returns StructuredSerializeInternal(subValue, forStorage, memory). (In other words, a sub-

serialization p107 p105 is a specialization of StructuredSerializeInternal to be consistent within this invocation.)

4. Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key):

1. If ! HasOwnProperty(value, key) is true, then:

1. Let inputValue be ? value.[[Get]](key, value).

2. Let p105 outputValue be ? StructuredSerializeInternal(inputValue, forStorage, memory).

3. Append { [[Key]]: key, [[Value]]: outputValue } to serialized.[[Properties]].

27. Return serialized.

Example

It's important to realize that the p105 Records produced by StructuredSerializeInternal might contain "pointers" to other records that

create circular references. For example, when we pass the following JavaScript object into p105 StructuredSerializeInternal :

const o = {};

o.myself = o;

it produces the following result:

{

[[Type]]: "Object",

[[Properties]]: «

{

[[Key]]: "myself",

[[Value]]: <a pointer to this whole structure>

}

»

}



2.8.4 StructuredSerialize ( value ) p10 §

8

1. Return ? p105 StructuredSerializeInternal(value, false).



2.8.5 StructuredSerializeForStorage ( value ) p10 §

8

1. Return ? p105 StructuredSerializeInternal(value, true).



2.8.6 StructuredDeserialize ( serialized, targetRealm [ , memory ] ) p10 §

8

The p108 StructuredDeserialize abstract operation takes as input a Record serialized, which was previously produced by

StructuredSerialize p108 p108 or StructuredSerializeForStorage, and deserializes it into a new JavaScript value, created in targetRealm.

This process can throw an exception, for example when trying to allocate memory for the new objects (especially ArrayBuffer objects).

1. If memory was not supplied, let memory be an empty map.

Note

The purpose of the memory map is to avoid deserializing objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.

2. If memory[serialized] exists, then return memory[serialized].

108

3. Let deep be false.

4. Let value be an uninitialized value.

5. If serialized.[[Type]] is "primitive", then set value to serialized.[[Value]].

6. Otherwise, if serialized.[[Type]] is "Boolean", then set value to a new Boolean object in targetRealm whose [[BooleanData]]

internal slot value is serialized.[[BooleanData]].

7. Otherwise, if serialized.[[Type]] is "Number", then set value to a new Number object in targetRealm whose [[NumberData]]

internal slot value is serialized.[[NumberData]].

8. Otherwise, if serialized.[[Type]] is "BigInt", then set value to a new BigInt object in targetRealm whose [[BigIntData]] internal

slot value is serialized.[[BigIntData]].

9. Otherwise, if serialized.[[Type]] is "String", then set value to a new String object in targetRealm whose [[StringData]] internal

slot value is serialized.[[StringData]].

10. Otherwise, if serialized.[[Type]] is "Date", then set value to a new Date object in targetRealm whose [[DateValue]] internal

slot value is serialized.[[DateValue]].

11. Otherwise, if serialized.[[Type]] is "RegExp", then set value to a new RegExp object in targetRealm whose [[RegExpMatcher]]

internal slot value is serialized.[[RegExpMatcher]], whose [[OriginalSource]] internal slot value is serialized.[[OriginalSource]], and whose [[OriginalFlags]] internal slot value is serialized.[[OriginalFlags]].

12. Otherwise, if serialized.[[Type]] is "SharedArrayBuffer", then:

1. If targetRealm's corresponding agent cluster is not serialized.[[AgentCluster]], then then throw a

"DataCloneError" DOMException.

2. Otherwise, set value to a new SharedArrayBuffer object in targetRealm whose [[ArrayBufferData]] internal slot

value is serialized.[[ArrayBufferData]] and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].

13. Otherwise, if serialized.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose

[[ArrayBufferData]] internal slot value is serialized.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is serialized.[[ArrayBufferByteLength]].

If this throws an exception, catch it, and then throw a "DataCloneError" DOMException.

Note

This step might throw an exception if there is not enough memory available to create such an ArrayBuffer object.

14. Otherwise, if serialized.[[Type]] is "ArrayBufferView", then:

1. Let p108 deserializedArrayBuffer be ? StructuredDeserialize(serialized.[[ArrayBufferSerialized]], targetRealm,

memory).

2. If serialized.[[Constructor]] is "DataView", then set value to a new DataView object in targetRealm whose

[[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], and whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]].

3. Otherwise, set value to a new typed array object in targetRealm, using the constructor given by

serialized.[[Constructor]], whose [[ViewedArrayBuffer]] internal slot value is deserializedArrayBuffer, whose [[TypedArrayName]] internal slot value is serialized.[[Constructor]], whose [[ByteLength]] internal slot value is serialized.[[ByteLength]], whose [[ByteOffset]] internal slot value is serialized.[[ByteOffset]], and whose [[ArrayLength]] internal slot value is serialized.[[ArrayLength]].

15. Otherwise, if serialized.[[Type]] is "Map", then:

1. Set value to a new Map object in targetRealm whose [[MapData]] internal slot value is a new empty List.

2. Set deep to true.

16. Otherwise, if serialized.[[Type]] is "Set", then:

1. Set value to a new Set object in targetRealm whose [[SetData]] internal slot value is a new empty List.

2. Set deep to true.

109

17. Otherwise, if serialized.[[Type]] is "Array", then:

1. Let outputProto be targetRealm.[[Intrinsics]].[[%Array.prototype%]].

2. Set value to ! ArrayCreate(serialized.[[Length]], outputProto).

3. Set deep to true.

18. Otherwise, if serialized.[[Type]] is "Object", then:

1. Set value to a new Object in targetRealm.

2. Set deep to true.

19. Otherwise, if serialized.[[Type]] is "Error", then:

1. Let prototype be %Error.prototype%.

2. If p54 serialized .[[Name]] is "EvalError", then set prototype to %EvalError.prototype%.

3. If p54 serialized .[[Name]] is "RangeError", then set prototype to %RangeError.prototype%.

4. If p54 serialized .[[Name]] is "ReferenceError", then set prototype to %ReferenceError.prototype%.

5. If p54 serialized .[[Name]] is "SyntaxError", then set prototype to %SyntaxError.prototype%.

6. If p54 serialized .[[Name]] is "TypeError", then set prototype to %TypeError.prototype%.

7. If p54 serialized .[[Name]] is "URIError", then set prototype to %URIError.prototype%.

8. Let message be serialized.[[Message]].

9. Set value to ! ObjectCreate(prototype, « [[ErrorData]] »).

10. Let messageDesc be PropertyDescriptor{ [[Value]]: message, [[Writable]]: true, [[Enumerable]]: false,

[[Configurable]]: true }.

11. If message is not undefined, then perform ! OrdinaryDefineOwnProperty(value, "message", messageDesc).

12. Any interesting accompanying data attached to serialized should be deserialized and attached to value.

20. Otherwise:

1. Let interfaceName be serialized.[[Type]].

2. If the interface identified by interfaceName is not exposed in targetRealm, then throw a "DataCloneError"

DOMException.

3. Set value to a new instance of the interface identified by interfaceName, created in targetRealm.

4. Set deep to true.

21. Set memory[serialized] to value.

22. If deep is true, then:

1. If serialized.[[Type]] is "Map", then:

1. For each Record { [[Key]], [[Value]] } entry of serialized.[[MapData]]:

1. Let p108 deserializedKey be ? StructuredDeserialize(entry.[[Key]], targetRealm, memory).

2. Let p108 deserializedValue be ? StructuredDeserialize (entry.[[Value]], targetRealm, memory).

3. Append { [[Key]]: deserializedKey, [[Value]]: deserializedValue } to value.[[MapData]].

2. Otherwise, if serialized.[[Type]] is "Set", then:

1. For each entry of serialized.[[SetData]]:

1. Let p108 deserializedEntry be ? StructuredDeserialize (entry, targetRealm, memory).

2. Append deserializedEntry to value.[[SetData]].

110

3. Otherwise, if serialized.[[Type]] is "Array" or "Object", then:

1. For each Record { [[Key]], [[Value]] } entry of serialized.[[Properties]]:

1. Let p108 deserializedValue be ? StructuredDeserialize (entry.[[Value]], targetRealm, memory).

2. Let result be ! CreateDataProperty(value, entry.[[Key]], deserializedValue).

3. Assert: result is true.

4. Otherwise:

1. Perform the appropriate p103 deserialization steps for the interface identified by serialized.[[Type]], given

serialized and value.

The p103 deserialization steps may need to perform a sub-deserialization. This is an operation which

takes as input a previously-serialized Record subSerialized, and returns

StructuredDeserialize p108 p111 ( subSerialized , targetRealm , memory ). (In other words, a sub-deserialization

is a specialization of p108 StructuredDeserialize to be consistent within this invocation.)

23. Return value.



2.8.7 StructuredSerializeWithTransfer ( value, transferList ) p11 §

1

1. Let memory be an empty map.

Note

In addition to how it is used normally by p105 StructuredSerializeInternal , in this algorithm memory is also used to ensure

that p105 StructuredSerializeInternal ignores items in transferList, and let us do our own handling instead.

2. For each transferable of transferList:

1. If p104 transferable has neither an [[ArrayBufferData]] internal slot nor a [[Detached]] internal slot, then throw a

"DataCloneError" DOMException.

2. If transferable has an [[ArrayBufferData]] internal slot and ! IsSharedArrayBuffer(transferable) is true, then throw a

"DataCloneError" DOMException.

3. If memory[transferable] exists, then throw a "DataCloneError" DOMException.

4. Set memory[transferable] to { [[Type]]: an uninitialized value }.

Note

transferable p105 is not transferred yet as transferring has side effects and StructuredSerializeInternal needs to be able to throw first.

3. Let p105 serialized be ? StructuredSerializeInternal (value, false, memory).

4. Let transferDataHolders be a new empty List.

5. For each transferable of transferList:

1. If transferable has an [[ArrayBufferData]] internal slot and ! IsDetachedBuffer(transferable) is true, then throw a

"DataCloneError" DOMException.

2. If p104 p104 transferable has a [[Detached]] internal slot and transferable . [[Detached]] is true, then throw a

"DataCloneError" DOMException.

3. Let dataHolder be memory[transferable].

4. If transferable has an [[ArrayBufferData]] internal slot, then:

1. Set dataHolder.[[Type]] to "ArrayBuffer".

2. Set dataHolder.[[ArrayBufferData]] to transferable.[[ArrayBufferData]].

111

3. Set dataHolder.[[ArrayBufferByteLength]] to transferable.[[ArrayBufferByteLength]].

4. Perform ? DetachArrayBuffer(transferable).

Note

Specifications can use the [[ArrayBufferDetachKey]] internal slot to prevent ArrayBuffers from

being detached. This is used in p1282 WebAssembly JavaScript Interface , for example. [WASMJS]

5. Otherwise:

1. Assert: p104 transferable is a platform object that is a transferable object .

2. Let interfaceName be the identifier of the primary interface of transferable.

3. Set dataHolder.[[Type]] to interfaceName.

4. Perform the appropriate p104 transfer steps for the interface identified by interfaceName, given

transferable and dataHolder.

5. Set p104 transferable . [[Detached]] to true.

6. Append dataHolder to transferDataHolders.

6. Return { [[Serialized]]: serialized, [[TransferDataHolders]]: transferDataHolders }.



2.8.8 StructuredDeserializeWithTransfer ( serializeWithTransferResult, targetRealm ) p11 §

2

1. Let memory be an empty map.

Note

Analogous to p111 p108 StructuredSerializeWithTransfer , in addition to how it is used normally by StructuredDeserialize, in

this algorithm p108 memory is also used to ensure that StructuredDeserialize ignores items in serializeWithTransferResult.[[TransferDataHolders]], and let us do our own handling instead.

2. Let transferredValues be a new empty List.

3. For each transferDataHolder of serializeWithTransferResult.[[TransferDataHolders]]:

1. Let value be an uninitialized value.

2. If transferDataHolder.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in targetRealm whose

[[ArrayBufferData]] internal slot value is transferDataHolder.[[ArrayBufferData]], and whose [[ArrayBufferByteLength]] internal slot value is transferDataHolder.[[ArrayBufferByteLength]].

Note

In cases where the original memory occupied by [[ArrayBufferData]] is accessible during the deserialization, this step is unlikely to throw an exception, as no new memory needs to be allocated: the memory occupied by [[ArrayBufferData]] is instead just getting transferred into the new ArrayBuffer. This could be true, for example, when both the source and target Realms are in the same process.

3. Otherwise:

1. Let interfaceName be transferDataHolder.[[Type]].

2. If the interface identified by interfaceName is not exposed in targetRealm, then throw a

"DataCloneError" DOMException.

3. Set value to a new instance of the interface identified by interfaceName, created in targetRealm.

4. Perform the appropriate p104 transfer-receiving steps for the interface identified by interfaceName given

transferDataHolder and value.

4. Set memory[transferDataHolder] to value.

5. Append value to transferredValues.

112

4. Let p108 deserialized be ? StructuredDeserialize (serializeWithTransferResult.[[Serialized]], targetRealm, memory).

5. Return { [[Deserialized]]: deserialized, [[TransferredValues]]: transferredValues }.



2.8.9 Performing serialization and transferring from other specifications p11 §

3

Other specifications may use the abstract operations defined here. The following provides some guidance on when each abstract operation is typically useful, with examples.

StructuredSerializeWithTransfer p111

StructuredDeserializeWithTransfer p112

Cloning a value to another JavaScript Realm, with a transfer list, but where the target Realm is not known ahead of time. In this case the serialization step can be performed immediately, with the deserialization step delayed until the target Realm becomes known.

Example

messagePort.postMessage() p1012 uses this pair of abstract operations, as the destination Realm is not known until the

MessagePort p1010 p1010 has been shipped.

StructuredSerialize p108

StructuredSerializeForStorage p108

StructuredDeserialize p108

Creating a JavaScript Realm-independent snapshot of a given value which can be saved for an indefinite amount of time, and then reified back into a JavaScript value later, possibly multiple times.

StructuredSerializeForStorage p108 can be used for situations where the serialization is anticipated to be stored in a persistent

manner, instead of passed between Realms. It throws when attempting to serialize SharedArrayBuffer objects, since storing

shared memory does not make sense. Similarly, it can throw or possibly have different behavior when given a platform object with

custom p103 serialization steps when the forStorage argument is true.

Example

history.pushState() p864 p864 p108 and history.replaceState() use StructuredSerializeForStorage on author-supplied state

objects, storing them as p859 p859 p108 serialized state in the appropriate session history entry . Then, StructuredDeserialize is used

so that the p862 history.state property can return a clone of the originally-supplied state object.



Example

broadcastChannel.postMessage() p1014 p108 p108 uses StructuredSerialize on its input, then uses StructuredDeserialize multiple times on the result to produce a fresh clone for each destination being broadcast to. Note that transferring does not make sense in multi-destination situations.



Example

Any API for persisting JavaScript values to the filesystem would also use p108 StructuredSerializeForStorage on its input and

StructuredDeserialize p108 on its output.

In general, call sites may pass in Web IDL values instead of JavaScript values; this is to be understood to perform an implicit conversion to the JavaScript value before invoking these algorithms.

Note

This specification used to define a "structured clone" algorithm, and more recently a StructuredClone abstract operation. However,

in practice all known uses of it were better served by separate serialization and deserialization steps, so it was removed.



Call sites that are not invoked as a result of author code synchronously calling into a user agent method must take care to properly

prepare to run script p923 p908 p108 p108 and prepare to run a callback before invoking StructuredSerialize , StructuredSerializeForStorage , or

StructuredSerializeWithTransfer p111 abstract operations, if they are being performed on arbitrary objects. This is necessary because the serialization process can invoke author-defined accessors as part of its final deep-serialization steps, and these accessors could call into operations that rely on the p906 p906 entry and incumbent concepts being properly set up.

113

Example

window.postMessage() p1006 p111 performs StructuredSerializeWithTransfer on its arguments, but is careful to do so immediately,

inside the synchronous portion of its algorithm. Thus it is able to use the algorithms without needing to p923 prepare to run script

and p908 prepare to run a callback .



Example

In contrast, a hypothetical API that used p108 StructuredSerialize to serialize some author-supplied object periodically, directly from a

task p932 p931 on the event loop, would need to ensure it performs the appropriate preparations beforehand. As of this time, we know

of no such APIs on the platform; usually it is simpler to perform the serialization ahead of time, as a synchronous consequence of

author code.



114

3 Semantics, structure, and APIs of HTML documents p11 §

5

3.1 Documents p11 §

5

Every XML and HTML document in an HTML UA is represented by a p115 p1277 Document object. [DOM]

The p115 p115 Document object's URL is defined in DOM . It is initially set when the Document object is created, but can change during the lifetime of the p115 p876 p889 Document object; for example, it changes when the user navigates to a fragment on the page and when the

pushState() p864 p1277 method is called with a new URL . [DOM]

⚠Warning!

Interactive user agents typically expose the p115 Document object's URL in their user interface. This is the primary

mechanism by which a user can tell if a site is attempting to impersonate another.

When a p115 p912 p115 Document is created by a script using the createDocument() or createHTMLDocument() the Document is ready for

post-load tasks p1162 immediately.

The document's referrer p115 is a string (representing a URL ) that can be set when the Document is created. If it is not explicitly set, then its value is the empty string.



3.1.1 The p115 ✔ MDN p11 Document object §

5

DOM defines a Document interface, which this specification extends significantly.

IDL enum DocumentReadyState { "loading", "interactive", "complete" };

typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;

[LegacyOverrideBuiltIns]

partial interface Document {

// resource metadata management

[PutForwards=href, LegacyUnforgeable] readonly attribute Location? location;

attribute USVString domain;

readonly attribute USVString referrer;

attribute USVString cookie;

readonly attribute DOMString lastModified;

readonly attribute DocumentReadyState readyState;

// DOM tree accessors

getter object (DOMString name);

[CEReactions] attribute DOMString title;

[CEReactions] attribute DOMString dir;

[CEReactions] attribute HTMLElement? body;

readonly attribute HTMLHeadElement? head;

[SameObject] readonly attribute HTMLCollection images;

[SameObject] readonly attribute HTMLCollection embeds;

[SameObject] readonly attribute HTMLCollection plugins;

[SameObject] readonly attribute HTMLCollection links;

[SameObject] readonly attribute HTMLCollection forms;

[SameObject] readonly attribute HTMLCollection scripts;

NodeList getElementsByName(DOMString elementName);

readonly attribute HTMLOrSVGScriptElement? currentScript; // classic scripts in a document tree only

// dynamic markup insertion

[CEReactions] Document open(optional DOMString unused1, optional DOMString unused2); // both

arguments are ignored

115

WindowProxy? open(USVString url, DOMString name, DOMString features);

[CEReactions] undefined close();

[CEReactions] undefined write(DOMString... text);

[CEReactions] undefined writeln(DOMString... text);

// user interaction

readonly attribute WindowProxy? defaultView;

boolean hasFocus();

[CEReactions] attribute DOMString designMode;

[CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional

DOMString value = "");

boolean queryCommandEnabled(DOMString commandId);

boolean queryCommandIndeterm(DOMString commandId);

boolean queryCommandState(DOMString commandId);

boolean queryCommandSupported(DOMString commandId);

DOMString queryCommandValue(DOMString commandId);

// special event handler IDL attributes that only apply to Document objects

[LegacyLenientThis] attribute EventHandler onreadystatechange;

// also has obsolete members

};

Document includes GlobalEventHandlers;

Document includes DocumentAndElementEventHandlers;

The p115 Document has a referrer policy (a referrer policy), initially the empty string, which represents the default referrer policy used by p115 fetches initiated by the Document.

The p115 p856 Document has an embedder policy (an embedder policy).

The p115 Document has a CSP list, which is a CSP list containing all of the Content Security Policy objects active for the document. The list is empty unless otherwise specified.

The p115 Document has a permissions policy, which is a permissions policy, which is initially empty.

The p115 p928 Document has a module map , which is a module map , initially empty.

The p115 p848 Document has a cross-origin opener policy , which is a cross-origin opener policy .



3.1.2 The p116 p11 DocumentOrShadowRoot interface §

6

DOM defines the DocumentOrShadowRoot mixin, which this specification extends.

IDL partial interface mixin DocumentOrShadowRoot {

readonly attribute Element? activeElement;

};



3.1.3 Resource metadata management p11 §

6

For web developers (non-normative)

document p116 . referrer

Returns the p115 URL of the Document from which the user navigated to this one, unless it was blocked or there was no such document, in which case it returns the empty string.

The p305 noreferrer link type can be used to block the referrer.

The p115 referrer attribute must return the document's referrer .

116

For web developers (non-normative)

document p117 . cookie [ = value ]

Returns the HTTP cookies that apply to the p115 Document . If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.

Can be set, to add a new cookie to the element's set of HTTP cookies.

If the contents are p846 p362 p366 sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError"

DOMException will be thrown on getting and setting.

The cookie attribute represents the cookies of the resource identified by the document's URL.

A p115 Document object that falls into one of the following conditions is a cookie-averse Document object:

• A p115 p814 Document object whose browsing context is null.

• A p115 Document whose URL's scheme is not a network scheme.

On getting, if the document is a p117 cookie-averse Document object , then the user agent must return the empty string.

Otherwise, if the p115 p841 p841 Document 's origin is an opaque origin, the user agent must throw a "SecurityError"

DOMException p51 . Otherwise, the user agent must return the cookie-string for the document's URL for a "non-HTTP" API, decoded using p1275 UTF-8 decode without BOM . [COOKIES]

On setting, if the document is a p117 cookie-averse Document object, then the user agent must do nothing. Otherwise, if the

Document p115 p841 p841 's origin is an opaque origin , the user agent must throw a "SecurityError" DOMException. Otherwise, the user

agent must act as it would when p51 receiving a set-cookie-string for the document's URL via a "non-HTTP" API, consisting of the new value p1275 p1277 encoded as UTF-8 . [COOKIES] [ENCODING]

Note

Since the p117 cookie attribute is accessible across frames, the path restrictions on cookies are only a tool to help manage which

cookies are sent to which parts of the site, and are not in any way a security feature.



⚠Warning!

The p117 cookie attribute's getter and setter synchronously access shared state. Since there is no locking mechanism,

other browsing contexts in a multiprocess user agent can modify cookies while scripts are running. A site could, for

instance, try to read a cookie, increment its value, then write it back out, using the new value of the cookie as a

unique identifier for the session; if the site does this twice in two different browser windows at the same time, it

might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.



For web developers (non-normative)

document p117 . lastModified

Returns the date of the last modification to the document, as reported by the server, in the form "MM/DD/YYYY hh:mm:ss", in the user's local time zone.

If the last modification date is not known, the current time is returned instead.



The p115 lastModified attribute, on getting, must return the date and time of the Document's source file's last modification, in the ✔ MDN user's local time zone, in the following format:

1. The month component of the date.

2. A U+002F SOLIDUS character (/).

3. The day component of the date.

4. A U+002F SOLIDUS character (/).

5. The year component of the date.

6. A U+0020 SPACE character.

7. The hours component of the time.

8. A U+003A COLON character (:).

117

9. The minutes component of the time.

10. A U+003A COLON character (:).

11. The seconds component of the time.

All the numeric components above, other than the year, must be given as two ASCII digits representing the number in base ten, zero-

padded if necessary. The year must be given as the shortest possible string of four or more ASCII digits representing the number in base ten, zero-padded if necessary.

The p115 Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.



For web developers (non-normative)

document p118 . readyState

Returns " p115 loading " while the Document is loading, "interactive" once it is finished parsing but still loading subresources, and "complete" once it has loaded.

The p1272 p115 readystatechange event fires on the Document object when this value changes.

The p1271 DOMContentLoaded event fires after the transition to "interactive" but before the transition to "complete", at the

point where all subresources apart from p616 p614 async script elements have loaded.



Each document has a p115 current document readiness . When a Document object is created, it must have its current document ✔ MDN

readiness p118 p1076 p1184 set to the string " loading " if the document is associated with an HTML parser , an XML parser, or an XSLT processor, and to the string "complete" otherwise. Various algorithms during page loading affect this value. When the value is set, the user agent must p1272 p115 fire an event named readystatechange at the Document object.

A p115 p1076 p1184 Document is said to have an active parser if it is associated with an HTML parser or an XML parser that has not yet been

stopped p1161 p1162 or aborted.

The p118 readyState IDL attribute must, on getting, return the current document readiness .



3.1.4 DOM tree accessors p11 §

8

The p153 html element of a document is its document element , if it's an html element, and null otherwise.



For web developers (non-normative)

document p118 . head

Returns p118 the head element.

✔ MDN

The p154 p118 head element of a document is the first head element that is a child of the html element, if there is one, or null otherwise.

The p118 p154 head attribute, on getting, must return the head element of the document (a head element or null).



For web developers (non-normative)

document p118 . title [ = value ]

Returns the document's title, as given by p118 the title element for HTML and as given by the SVG title element for SVG. Can be set, to update the document's title. If there is no appropriate element to update, the new value is ignored.

✔ MDN

The p155 title element of a document is the first title element in the document (in tree order), if there is one, or null otherwise.

The title attribute must, on getting, run the following algorithm:

1. If the document element is an SVG svg element, then let value be the child text content of the first SVG title element that

is a child of the document element.

118

2. Otherwise, let p118 p118 value be the child text content of the title element , or the empty string if the title element is null.

3. Strip and collapse ASCII whitespace in value.

4. Return value.

On setting, the steps corresponding to the first matching condition in the following list must be run:

↪ If the document element is an SVG svg element

1. If there is an SVG title element that is a child of the document element, let element be the first such element.

2. Otherwise:

1. Let element be the result of creating an element given the document element's node document, title, and

the SVG namespace.

2. Insert element as the first child of the document element.

3. String replace all with the given value within element.

↪ If the document element is in the HTML namespace

1. If p118 p118 the title element is null and the head element is null, then return.

2. If p118 p118 the title element is non-null, let element be the title element.

3. Otherwise:

1. Let p155 element be the result of creating an element given the document element 's node document , title,

and the HTML namespace.

2. p118 Append element to the head element.

4. String replace all with the given value within element.

↪ Otherwise

Do nothing.



For web developers (non-normative)

document p119 . body [ = value ]

Returns p119 the body element .

Can be set, to replace p119 the body element.

If the new value is not a p179 p1230 body or frameset element, this will throw a "HierarchyRequestError" DOMException.



The body element p118 p179 p1230 of a document is the first of the html element 's children that is either a body element or a frameset ✔ MDN

element, or null if there is no such element.

The p119 p179 p1230 body attribute, on getting, must return the body element of the document (either a body element, a frameset element, or null). On setting, the following algorithm must be run:

1. If the new value is not a p179 p1230 body or frameset element, then throw a "HierarchyRequestError" DOMException.

2. Otherwise, if the new value is the same as p119 the body element, return.

3. Otherwise, if p119 p119 the body element is not null, then replace the body element with the new value within the body

element p119's parent and return.

4. Otherwise, if there is no document element, throw a "HierarchyRequestError" DOMException.

5. Otherwise, p119 the body element is null, but there's a document element. Append the new value to the document element.

Note

The value returned by the p119 body getter is not always the one passed to the setter.



119

Example

In this example, the setter successfully inserts a p179 body element (though this is non-conforming since SVG does not allow a

body p179 p153 as child of SVG svg ). However the getter will return null because the document element is not html.





For web developers (non-normative)

document p120 . images

Returns an p321 p115 HTMLCollection of the img elements in the Document .

document p120 . embeds

document p120 . plugins

Return an p369 p115 HTMLCollection of the embed elements in the Document .

document p120 . links

Returns an p239 p444 p115 p285 HTMLCollection of the a and area elements in the Document that have href attributes.

document p120 . forms

Return an p487 p115 HTMLCollection of the form elements in the Document .

document p120 . scripts

Return an p614 p115 HTMLCollection of the script elements in the Document.

✔ MDN

The p115 p321 images attribute must return an HTMLCollection rooted at the Document node, whose filter matches only img elements. ✔ MDN

✔ MDN

The p115 p369 embeds attribute must return an HTMLCollection rooted at the Document node, whose filter matches only embed elements.

p120 ✔ MDN

The plugins attribute must return the same object as that returned by the embeds attribute.

The p115 p239 links attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with ✔ MDN

href p285 p444 p285 attributes and area elements with href attributes.

✔ MDN

The p115 p487 forms attribute must return an HTMLCollection rooted at the Document node, whose filter matches only form elements.

The p115 p614 scripts attribute must return an HTMLCollection rooted at the Document node, whose filter matches only script elements.



For web developers (non-normative)

collection p120 = document . getElementsByName (name)

Returns a p115 NodeList of elements in the Document that have a name attribute with the value name.



The p45 p44 getElementsByName( name ) method steps are to return a live NodeList containing all the HTML elements in that document ✔ MDN

that have a p115 name attribute whose value is identical to the name argument, in tree order . When the method is invoked on a Document

object again with the same argument, the user agent may return the same as the object returned by the earlier call. In other cases, a new NodeList object must be returned.



For web developers (non-normative)

document p121 . currentScript

Returns the p614 script element, or the SVG script element, that is currently executing, as long as the element represents a

classic script p912. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.

Returns null if the p115 p614 Document is not currently executing a script or SVG script element (e.g., because the running script

is an event handler, or a timeout), or if the currently executing p614 script or SVG script element represents a module

120

script p912.



The p115 currentScript attribute, on getting, must return the value to which it was most recently set. When the Document is created, ✔ MDN

the p121 currentScript must be initialized to null.

Note

This API has fallen out of favor in the implementer and standards community, as it globally exposes p614 script or SVG script

elements. As such, it is not available in newer contexts, such as when running p912 module scripts or when running scripts in a

shadow tree. We are looking into creating a new solution for identifying the running script in such contexts, which does not make it

globally available: see issue #1013.



The p115 p115 Document interface supports named properties . The supported property names of a Document object document at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates, and with values from p138 id attributes coming before values from name attributes when the same element contributes both:

• the value of the p121 p369 p487 p362 p321 p121 p373 name content attribute for all exposed embed , form , iframe , img , and exposed object

elements that have a non-empty name content attribute and are in a document tree with document as their root;

• the value of the p138 p121 p373 p138 id content attribute for all exposed object elements that have a non-empty id content

attribute and are in a document tree with document as their root; and

• the value of the p138 p321 p138 id content attribute for all img elements that have both a non-empty id content attribute and a

non-empty name content attribute, and are in a document tree with document as their root.

To p115 determine the value of a named property name for a Document, the user agent must return the value obtained using the following steps:

1. Let p121 p115 elements be the list of named elements with the name name that are in a document tree with the Document as

their root.

Note

There will be at least one such element, by definition.

2. If p362 p362 elements has only one element, and that element is an iframe element, and that iframe element's nested browsing

context p817 p837 p817 is not null, then return the WindowProxy object of the element's nested browsing context .

3. Otherwise, if elements has only one element, return that element.

4. Otherwise return an p115 p121 HTMLCollection rooted at the Document node, whose filter matches only named elements with

the name name.

Named elements with the name name, for the purposes of the above algorithm, are those that are either:

• p121 p369 p487 p362 p321 p121 p373 Exposed embed , form , iframe , img , or exposed object elements that have a name content attribute

whose value is name, or

• p121 p373 p138 Exposed object elements that have an id content attribute whose value is name, or

• p321 p138 img elements that have an id content attribute whose value is name, and that have a non-empty name content

attribute present also.

An p369 p373 p121 p373 p373 embed or object element is said to be exposed if it has no exposed object ancestor, and, for object elements, is additionally either not showing its p133 p373 p369 fallback content or has no object or embed descendants.



Note

The p145 p115 p143 dir attribute on the Document interface is defined along with the dir content attribute.



121

3.2 Elements p12 §

2

3.2.1 Semantics p12 §

2

Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics). For example, the p222 p141 ol element represents an ordered list, and the lang attribute represents the language of the content.

These definitions allow HTML processors, such as web browsers or search engines, to present and use documents and applications in a wide variety of contexts that the author might not have considered.

Example

As a simple example, consider a web page written by an author who only considered desktop computer web browsers:





My Page





Welcome to my page





I like cars and lorries and have a big Jeep!





Where I live





I live in a small hut on a mountain!





Because HTML conveys meaning, rather than presentation, the same page can also be used by a small browser on a mobile phone,

without any change to the page. Instead of headings being in large letters as on the desktop, for example, the browser on the

mobile phone might use the same size text for the whole page, but with the headings in bold.

But it goes further than just differences in screen size: the same page could equally be used by a blind user using a browser based

around speech synthesis, which instead of displaying the page on a screen, reads the page to the user, e.g. using headphones.

Instead of large text for the headings, the speech browser might use a different volume or a slower voice.

That's not all, either. Since the browsers know which parts of the page are the headings, they can create a document outline that

the user can use to quickly navigate around the document, using keys for "jump to next heading" or "jump to previous heading".

Such features are especially common with speech browsers, where users would otherwise find quickly navigating a page quite

difficult.

Even beyond browsers, software can make use of this information. Search engines can use the headings to more effectively index

a page, or to provide quick links to subsections of the page from their results. Tools can use the headings to create a table of

contents (that is in fact how this very specification's table of contents is generated).

This example has focused on headings, but the same principle applies to all of the semantics in HTML.

Authors must not use elements, attributes, or attribute values for purposes other than their appropriate intended semantic purpose, as doing so prevents software from correctly processing the page.

Example

For example, the following snippet, intended to represent the heading of a corporate site, is non-conforming because the second

line is not intended to be a heading of a subsection, but merely a subheading or subtitle (a subordinate heading for the same

section).





ACME Corporation





The leaders in arbitrary fast delivery since 1920


...

The p193 hgroup element is intended for these kinds of situations:



122





ACME Corporation





The leaders in arbitrary fast delivery since 1920





...



Example

The document in this next example is similarly non-conforming, despite being syntactically correct, because the data placed in the

cells is clearly not tabular data, and the p247 cite element mis-used:





Demonstration





My favourite animal is the cat.



—Ernest, in an essay from 1992





This would make software that relies on these semantics fail: for example, a speech browser that allowed a blind user to navigate

tables in the document would report the quote above as a table, confusing the user; similarly, a tool that extracted titles of works

from pages would extract "Ernest" as the title of a work, even though it's actually a person's name, not a title.

A corrected version of this document might be:





Demonstration





My favourite animal is the cat.





—Ernest,

in an essay from 1992





Authors must not use elements, attributes, or attribute values that are not permitted by this specification or other applicable

specifications p65, as doing so makes it significantly harder for the language to be extended in the future.

Example

In the next example, there is a non-conforming attribute value ("carpet") and a non-conforming attribute ("texture"), which is not

permitted by this specification:

Carpet:

Here would be an alternative and correct way to mark this up:



123

Carpet:



DOM nodes whose p814 node document 's browsing context is null are exempt from all document conformance requirements other than the p1064 p1184 HTML syntax requirements and XML syntax requirements.

Example

In particular, the p630 p631 p814 template element's template contents 's node document 's browsing context is null. For example, the

content model p129 p630 requirements and attribute value microsyntax requirements do not apply to a template element's template

contents p631 p321 . In this example an img element has attribute values that are placeholders that would be invalid outside a

template p630 element.





However, if the above markup were to omit the p1064 end tag, that would be a violation of the HTML syntax, and would thus

be flagged as an error by conformance checkers.

Through scripting and using other mechanisms, the values of attributes, text, and indeed the entire structure of the document may change dynamically while a user agent is processing it. The semantics of a document at an instant in time are those represented by the state of the document at that instant in time, and the semantics of a document can therefore change over time. User agents must update their presentation of the document as this occurs.

Example

HTML has a p556 progress element that describes a progress bar. If its "value" attribute is dynamically updated by a script, the UA

would update the rendering to show the progress changing.



3.2.2 Elements in the DOM p12 §

4

The nodes representing p44 HTML elements in the DOM must implement, and expose to scripts, the interfaces listed for them in the relevant sections of this specification. This includes p44 HTML elements in XML documents, even when those documents are in another context (e.g. inside an XSLT transform).

Elements in the DOM represent things; that is, they have intrinsic meaning, also known as semantics.

Example

For example, an p222 ol element represents an ordered list.

Elements can be referenced (referred to) in some way, either explicitly or implicitly. One way that an element in the DOM can be explicitly referenced is by giving an p138 p284 p138 id attribute to the element, and then creating a hyperlink with that id attribute's value as the p889 p284 p285 fragment for the hyperlink 's href attribute value. Hyperlinks are not necessary for a reference, however; any manner of referring to the element in question will suffice.

Example

Consider the following p233 p138 figure element, which is given an id attribute:





alt="Module A depends on module B, which depends

on modules C and D.">



Figure 27: a simple module graph

124





A p284 p124 p239 hyperlink-based reference could be created using the a element, like so:

As we can see in figure 27, ...

However, there are many other ways of p124 p233 referencing the figure element, such as:

• "As depicted in the figure of modules A, B, C, and D..."

• "In Figure 27..." (without a hyperlink)

• "From the contents of the 'simple module graph' figure..."

• "In the figure below..." (but p233 this is discouraged)



The basic interface, from which all the p44 HTML elements' interfaces inherit, and which must be used by elements that have no ✔ MDN

additional requirements, is the p125 HTMLElement interface.

IDL [Exposed=Window]

interface HTMLElement : Element {

[HTMLConstructor] constructor();

// metadata attributes

[CEReactions] attribute DOMString title;

[CEReactions] attribute DOMString lang;

[CEReactions] attribute boolean translate;

[CEReactions] attribute DOMString dir;

// user interaction

[CEReactions] attribute boolean hidden;

undefined click();

[CEReactions] attribute DOMString accessKey;

readonly attribute DOMString accessKeyLabel;

[CEReactions] attribute boolean draggable;

[CEReactions] attribute boolean spellcheck;

[CEReactions] attribute DOMString autocapitalize;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString innerText;

ElementInternals attachInternals();

};

HTMLElement includes GlobalEventHandlers;

HTMLElement includes DocumentAndElementEventHandlers;

HTMLElement includes ElementContentEditable;

HTMLElement includes HTMLOrSVGElement;

[Exposed=Window]

interface HTMLUnknownElement : HTMLElement {

// Note: intentionally no [HTMLConstructor]

};

The p125 HTMLElement interface holds methods and attributes related to a number of disparate features, and the members of this interface are therefore described in various different sections of this specification.



The element interface for an element with name name in the HTML namespace is determined as follows:



125

1. If p1223 p1223 p1224 p1223 p1223 p1224 p1223 p1224 name is applet , bgsound , blink , isindex , keygen , multicol , nextid , or spacer, then

return p125 HTMLUnknownElement.

2. If p1223 p1224 p1224 p1224 p1224 p1223 p1223 p1223 p1223 name is acronym , basefont , big , center , nobr , noembed , noframes , plaintext , rb,

rtc p1223 p1224 p1224 p125 , strike , or tt , then return HTMLElement .

3. If p1223 p1224 p217 name is listing or xmp , then return HTMLPreElement .

4. Otherwise, if this specification defines an interface appropriate for the p44 element type corresponding to the local name

name, then return that interface.

5. If p65 other applicable specifications define an appropriate interface for name, then return the interface they define.

6. If p706 p125 name is a valid custom element name , then return HTMLElement .

7. Return p125 HTMLUnknownElement.

Note

The use of p125 p125 p706 HTMLElement instead of HTMLUnknownElement in the case of valid custom element names is done to ensure

that any potential future p711 p125 upgrades only cause a linear transition of the element's prototype chain, from HTMLElement to a

subclass, instead of a lateral one, from p125 HTMLUnknownElement to an unrelated subclass.

Features shared between HTML and SVG elements use the p126 p1281 HTMLOrSVGElement interface mixin: [SVG]

IDL interface mixin HTMLOrSVGElement {

[SameObject] readonly attribute DOMStringMap dataset;

attribute DOMString nonce; // intentionally no [CEReactions]

[CEReactions] attribute boolean autofocus;

[CEReactions] attribute long tabIndex;

undefined focus(optional FocusOptions options = {});

undefined blur();

};



Example

An example of an element that is neither an HTML nor SVG element is one created as follows:

const el = document.createElementNS("some namespace", "example"); console.assert(el.constructor === Element);



3.2.3 HTML element constructors p12 §

6

To support the p697 custom elements feature, all HTML elements have special constructor behavior. This is indicated via the

[HTMLConstructor] IDL extended attribute. It indicates that the interface object for the given interface will have a specific behavior when called, as defined in detail below.

The p126 [HTMLConstructor] extended attribute must take no arguments, and must only appear on constructor operations. It must appear only once on a constructor operation, and the interface must contain only the single, annotated constructor operation, and no others. The annotated constructor operation must be declared to take no arguments.

Interfaces declared with constructor operations that are annotated with the p126 [HTMLConstructor] extended attribute have the following overridden constructor steps:

1. Let p911 p708 registry be the current global object 's CustomElementRegistry object.

2. If NewTarget is equal to the active function object, then throw a TypeError.

Example

This can occur when a custom element is defined using an element interface as its constructor:

126

customElements.define("bad-1", HTMLButtonElement);

new HTMLButtonElement(); // (1)

document.createElement("bad-1"); // (2)

In this case, during the execution of p537 HTMLButtonElement (either explicitly, as in (1), or implicitly, as in (2)), both the

active function object p537 and NewTarget are HTMLButtonElement. If this check was not present, it would be possible to

create an instance of p537 HTMLButtonElement whose local name was bad-1.

3. Let p707 definition be the entry in registry with constructor equal to NewTarget. If there is no such definition, then throw a

TypeError.

Note

Since there can be no entry in p707 registry with a constructor of undefined, this step also prevents HTML element

constructors from being called as functions (since in that case NewTarget will be undefined).

4. Let is value be null.

5. If p707 p707 p705 definition 's local name is equal to definition 's name (i.e., definition is for an autonomous custom element ), then:

1. If the p125 active function object is not HTMLElement , then throw a TypeError.

Example

This can occur when a custom element is defined to not extend any local names, but inherits from a

non- p125 HTMLElement class:

customElements.define("bad-2", class Bad2 extends HTMLParagraphElement {});

In this case, during the (implicit) super() call that occurs when constructing an instance of Bad2, the active

function object p213 p125 is HTMLParagraphElement , not HTMLElement.

6. Otherwise (i.e., if p705 definition is for a customized built-in element):

1. Let valid local names be the list of local names for elements defined in this specification or in other applicable

specifications p65 that use the active function object as their element interface.

2. If p707 valid local names does not contain definition 's local name , then throw a TypeError.

Example

This can occur when a custom element is defined to extend a given local name but inherits from the wrong class:

customElements.define("bad-3", class Bad3 extends HTMLQuoteElement {}, { extends: "p" });

In this case, during the (implicit) super() call that occurs when constructing an instance of Bad3, valid local

names p248 p219 p707 p213 is the list containing q and blockquote , but definition 's local name is p , which is not in that list.

3. Set p707 is value to definition 's name.

7. If p707 definition 's construction stack is empty, then:

1. Let element be the result of internally creating a new object implementing the interface to which the active

function object corresponds, given the current Realm Record and NewTarget.

2. Set p911 p829 element 's node document to the current global object 's associated Document.

3. Set element's namespace to the HTML namespace.

4. Set element's namespace prefix to null.

5. Set p707 element 's local name to definition 's local name.

127

6. Set element's custom element state to "custom".

7. Set element's custom element definition to definition.

8. Set element's is value to is value.

9. Return element.

Note

This occurs when author script constructs a new custom element directly, e.g. via new MyCustomElement().

8. Let prototype be Get(NewTarget, "prototype"). Rethrow any exceptions.

9. If Type(prototype) is not Object, then:

1. Let realm be GetFunctionRealm(NewTarget).

2. Set prototype to the interface prototype object of realm whose interface is the same as the interface of the active

function object.

Note

The realm of the active function object might not be realm, so we are using the more general concept of "the same

interface" across realms; we are not looking for equality of interface objects. This fallback behavior, including using the

realm of NewTarget and looking up the appropriate prototype there, is designed to match analogous behavior for the

JavaScript built-ins and Web IDL's internally create a new object implementing the interface algorithm.

10. Let p707 element be the last entry in definition 's construction stack .

11. If p707 element is an already constructed marker, then throw an "InvalidStateError" DOMException.

Example

This can occur when the author code inside the p705 p704 custom element constructor non-conformantly creates another instance of the class being constructed, before calling super():

let doSillyThing = false;

class DontDoThis extends HTMLElement {

constructor() {

if (doSillyThing) {

doSillyThing = false;

new DontDoThis();

// Now the construction stack will contain an already constructed marker.

}

// This will then fail with an "InvalidStateError" DOMException: super();

}

}



Example

This can also occur when author code inside the p705 p704 custom element constructor non-conformantly calls super() twice, since per the JavaScript specification, this actually executes the superclass constructor (i.e. this algorithm) twice, before throwing an error:

class DontDoThisEither extends HTMLElement {

constructor() {

super();

// This will throw, but not until it has already called into the HTMLElement

constructor

super();

}

}

128

12. Perform element.[[SetPrototypeOf]](prototype). Rethrow any exceptions.

13. Replace the last entry in p707 p707 definition 's construction stack with an already constructed marker .

14. Return element.

Note

This step is normally reached when p711 upgrading a custom element; the existing element is returned, so that the

super() p705 call inside the custom element constructor assigns that existing element to this.



In addition to the constructor behavior implied by p126 [HTMLConstructor], some elements also have named constructors (which are really factory functions with a modified prototype property).

Example

Named constructors for HTML elements can also be used in an p705 extends clause when defining a custom element constructor:

class AutoEmbiggenedImage extends Image {

constructor(width, height) {

super(width * 10, height * 10);

}

}

customElements.define("auto-embiggened", AutoEmbiggenedImage, { extends: "img" });

const image = new AutoEmbiggenedImage(15, 20);

console.assert(image.width === 150);

console.assert(image.height === 200);



3.2.4 Element definitions p12 §

9

Each element in this specification has a definition that includes the following information:

Categories

A list of p131 p130 categories to which the element belongs. These are used when defining the content models for each element.

Contexts in which this element can be used

A non-normative description of where the element can be used. This information is redundant with the content models of elements that allow this one as a child, and is provided only as a convenience.

Note

For simplicity, only the most specific expectations are listed.

For example, all p133 p132 p133 phrasing content is flow content . Thus, elements that are phrasing content will only be listed as

"where p133 p132 phrasing content is expected", since this is the more-specific expectation. Anywhere that expects flow content

also expects p133 phrasing content , and thus also meets this expectation.

Content model

A normative description of what content must be included as children and descendants of the element.

Tag omission in text/html

A p1241 p1066 p1067 non-normative description of whether, in the text/html syntax, the start and end tags can be omitted. This

information is redundant with the normative requirements given in the p1068 optional tags section, and is provided in the element definitions only as a convenience.

Content attributes

A normative list of attributes that may be specified on the element (except where otherwise disallowed), along with non-normative descriptions of those attributes. (The content to the left of the dash is normative, the content to the right of the dash is not.)

129

Accessibility considerations

For authors: Conformance requirements for use of p63 p63 p1275 ARIA role and aria-* attributes are defined in ARIA in HTML . [ARIA]

[ARIAHTML] p1275

For implementers: User agent requirements for implementing accessibility API semantics are defined in HTML Accessibility API

Mappings p1278 . [HTMLAAM]

DOM interface

A normative definition of a DOM interface that such elements must implement.

This is then followed by a description of what the element p124 represents, along with any additional normative conformance criteria that may apply to authors and implementations. Examples are sometimes also included.



3.2.4.1 Attributes p13 §

0

An attribute value is a string. Except where otherwise specified, attribute values on p44 HTML elements may be any string value, including the empty string, and there is no restriction on what text can be specified in such attribute values.



3.2.5 Content models p13 §

0

Each element defined in this specification has a content model: a description of the element's expected p130 contents . An HTML

element p44 must have contents that match the requirements described in the element's content model. The contents of an element are its children in the DOM.

ASCII whitespace is always allowed between elements. User agents represent these characters between elements in the source markup as Text nodes in the DOM. Empty Text nodes and Text nodes consisting of just sequences of those characters are considered inter-element whitespace.

Inter-element whitespace p130 , comment nodes, and processing instruction nodes must be ignored when establishing whether an element's contents match the element's content model or not, and must be ignored when following algorithms that define document and element semantics.

Note

Thus, an element A is said to be preceded or followed by a second element B if A and B have the same parent node and there are

no other element nodes or p130 Text nodes (other than inter-element whitespace ) between them. Similarly, a node is the only child

of an element if that element contains no other nodes other than p130 inter-element whitespace , comment nodes, and processing

instruction nodes.

Authors must not use p44 HTML elements anywhere except where they are explicitly allowed, as defined for each element, or as explicitly required by other specifications. For XML compound documents, these contexts could be inside elements from other namespaces, if those elements are defined as providing the relevant contexts.

Example

The Atom Syndication Format defines a content element. When its type attribute has the value xhtml, The Atom Syndication

Format p238 p238 requires that it contain a single HTML div element. Thus, a div element is allowed in that context, even though this

is not explicitly normatively stated by this specification. p1275 [ATOM]

In addition, p44 HTML elements may be orphan nodes (i.e. without a parent node).

Example

For example, creating a p466 p466 td element and storing it in a global variable in a script is conforming, even though td elements are

otherwise only supposed to be used inside p465 tr elements.

var data = {

name: "Banana",

cell: document.createElement('td'),

130

};



3.2.5.1 The "nothing" content model p13 §

1

When an element's content model is p130 nothing , the element must contain no Text nodes (other than inter-element whitespace ) and no element nodes.

Note

Most HTML elements whose content model is "nothing" are also, for convenience, p1065 void elements (elements that have no end

tag p1067 p1064 in the HTML syntax). However, these are entirely separate concepts.



3.2.5.2 Kinds of content p13 §

1

Each element in HTML falls into zero or more categories that group elements with similar characteristics together. The following broad categories are used in this specification:

• p132 Metadata content

• p132 Flow content

• p132 Sectioning content

• p133 Heading content

• p133 Phrasing content

• p133 Embedded content

• p133 Interactive content

Note

Some elements also fall into other categories, which are defined in other parts of this specification.

These categories are related as follows:



Flow



Phrasing Heading

Interactive

Embedded



Sectioning



Metadata



Sectioning content, heading content, phrasing content, embedded content, and interactive content are all types of flow content. Metadata is sometimes flow content. Metadata and interactive content are sometimes phrasing content. Embedded content is also a type of phrasing content, and sometimes is interactive content.

Other categories are also used for specific purposes, e.g. form controls are specified using a number of categories to define common requirements. Some elements have unique requirements and do not fit into any particular category.



131

3.2.5.2.1 Metadata content p13 §

2

Metadata content is content that sets up the presentation or behavior of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other "out of band" information.

⇒ p156 p158 p165 p628 p614 p175 p630 p155 base , link , meta , noscript , script , style , template , title

Elements from other namespaces whose semantics are primarily metadata-related (e.g. RDF) are also p132 metadata content.

Example

Thus, in the XML serialization, one can use RDF, like this:



xmlns:r="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xml:lang="en">



Hedral's Home Page





r:about="https://hedral.example.com/#">

Cat Hedral



Sir





My home page





I like playing with string, I guess. Sister says squirrels are fun too so sometimes I follow her to play with them.





This isn't possible in the HTML serialization, however.



3.2.5.2.2 Flow content p13 §

2

Most elements that are used in the body of documents and applications are categorized as flow content.

⇒ p239 p251 p199 p444 p443 p181 p189 p384 p274 a , abbr , address , area (if it is a descendant of a map element), article , aside , audio , b,

bdi p279 p280 p219 p281 p536 p635 p247 p268 p260 p544 p313 , bdo , blockquote , br , button , canvas , cite , code , data , datalist , del ,

details p605 p250 p611 p238 p228 p242 p369 p563 p233 p196 p487 p191 p191 , dfn , dialog , div , dl , em , embed , fieldset , figure , footer , form , h1 , h2 ,

h3 p191 p191 p191 p191 p195 p193 p215 p273 p362 p321 p494 p312 p271 p491 , h4 , h5 , h6 , header , hgroup , hr , i , iframe , img , input , ins , kbd , label,

link p158 p159 p237 p237 p443 p276 (if it is allowed in the body ), main (if it is a hierarchically correct main element ), map , mark, MathML

math p224 p165 p739 p558 p186 p628 p373 p222 , menu , meta (if the itemprop attribute is present), meter , nav , noscript , object , ol,

output p554 p213 p317 p217 p556 p248 p253 p246 p270 p614 p183 p538 , p , picture , pre , progress , q , ruby , s , samp , script , section , select,

slot p633 p245 p280 p243 p272 p272 p451 p630 p549 p261 p276 , small , span , strong , sub , sup , SVG svg , table , template , textarea , time , u,

ul p223 p269 p380 p282 p705 p133 , var , video , wbr , autonomous custom elements , text



3.2.5.2.3 Sectioning content p13 §

2

Sectioning content p133 p196 is content that defines the scope of headings and footers .

⇒ p181 p189 p186 p183 article , aside , nav , section

Each p132 p202 p200 sectioning content element potentially has a heading and an outline . See the section on headings and sections for further details.

Note

There are also certain elements that are p200 p132 sectioning roots . These are distinct from sectioning content, but they can also have 132

an p202 outline .



3.2.5.2.4 Heading content p13 §

3

Heading content p132 defines the header of a section (whether explicitly marked up using sectioning content elements, or implied by the heading content itself).

⇒ p191 p191 p191 p191 p191 p191 p193 h1 , h2 , h3 , h4 , h5 , h6 , hgroup



3.2.5.2.5 Phrasing content p13 §

3

Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of

phrasing content p133 p135 form paragraphs.

⇒ p239 p251 p444 p443 p384 p274 p279 p280 p281 p536 a , abbr , area (if it is a descendant of a map element), audio , b , bdi , bdo , br , button,

canvas p635 p247 p268 p260 p544 p313 p250 p242 p369 p273 p362 p321 p494 , cite , code , data , datalist , del , dfn , em , embed , i , iframe , img , input,

ins p312 p271 p491 p158 p159 p443 p276 p165 , kbd , label , link (if it is allowed in the body ), map , mark , MathML math , meta (if the

itemprop p739 p558 p628 p373 p554 p317 p556 p248 p253 attribute is present), meter , noscript , object , output , picture , progress , q , ruby,

s p246 p270 p614 p538 p633 p245 p280 p243 p272 p272 p630 , samp , script , select , slot , small , span , strong , sub , sup , SVG svg , template,

textarea p549 p261 p276 p269 p380 p282 p705 p133 , time , u , var , video , wbr , autonomous custom elements , text

Note

Most elements that are categorized as phrasing content can only contain elements that are themselves categorized as phrasing

content, not any flow content.

Text p133 , in the context of content models, means either nothing, or Text nodes. Text is sometimes used as a content model on its own, but is also p133 p130 phrasing content , and can be inter-element whitespace (if the Text nodes are empty or contain just ASCII

whitespace).

Text nodes and attribute values must consist of scalar values, excluding noncharacters, and controls other than ASCII whitespace. This specification includes extra constraints on the exact value of Text nodes and attribute values depending on their precise context.



3.2.5.2.6 Embedded content p13 §

3

Embedded content is content that imports another resource into the document, or content from another vocabulary that is inserted into the document.

⇒ p384 p635 p369 p362 p321 p373 p317 p380 audio , canvas , embed , iframe , img , MathML math , object , picture , SVG svg , video

Elements that are from namespaces other than the HTML namespace and that convey content but not metadata, are embedded

content p133 for the purposes of the content models defined in this specification. (For example, MathML, or SVG.) Some embedded content elements can have fallback content: content that is to be used when the external resource cannot be used (e.g. because it is of an unsupported format). The element definitions state what the fallback is, if any.



3.2.5.2.7 Interactive content p13 §

3

Interactive content is content that is specifically intended for user interaction.

⇒ p239 p285 p384 p437 p536 p605 a (if the href attribute is present), audio (if the controls attribute is present), button , details,

embed p369 p362 p321 p446 p494 p496 , iframe , img (if the usemap attribute is present), input (if the type attribute is not in the

Hidden p500 p491 p373 p446 p538 p549 p380 state), label , object (if the usemap attribute is present), select , textarea , video (if the

controls p437 attribute is present)



133

3.2.5.2.8 Palpable content p13 §

4

As a general rule, elements whose content model allows any p132 p133 flow content or phrasing content should have at least one node in its p130 p768 contents that is palpable content and that does not have the hidden attribute specified.

Note

Palpable content p134 p133 makes an element non-empty by providing either some descendant non-empty text, or else something

users can hear ( p384 p380 p321 p635 audio elements) or view ( video or img or canvas elements) or otherwise interact with (for example,

interactive form controls).

This requirement is not a hard requirement, however, as there are many cases where an element can be empty legitimately, for example when it is used as a placeholder which will later be filled in by a script, or when the element is part of a template and would on most pages be filled in but on some pages is not relevant.

Conformance checkers are encouraged to provide a mechanism for authors to find elements that fail to fulfill this requirement, as an authoring aid.

The following elements are palpable content:

⇒ p239 p251 p199 p181 p189 p384 p437 p274 p279 a , abbr , address , article , aside , audio (if the controls attribute is present), b , bdi,

bdo p280 p219 p536 p635 p247 p268 p260 p605 p250 p238 p228 , blockquote , button , canvas , cite , code , data , details , dfn , div , dl (if the

element's children include at least one name-value group), p242 p369 p563 p233 p196 p487 em , embed , fieldset , figure , footer , form,

h1 p191 p191 p191 p191 p191 p191 p195 p193 p273 p362 p321 p494 p496 , h2 , h3 , h4 , h5 , h6 , header , hgroup , i , iframe , img , input (if the type attribute

is p500 p312 p271 p491 p237 p443 p276 p224 not in the Hidden state), ins , kbd , label , main , map , mark , MathML math , menu (if the element's

children include at least one p225 p558 p186 p373 p222 li element), meter , nav , object , ol (if the element's children include at least

one p225 p554 p213 p217 p556 p248 p253 p246 p270 p183 p538 p245 li element), output , p , pre , progress , q , ruby , s , samp , section , select , small ,

span p280 p243 p272 p272 p451 p549 p261 p276 p223 , strong , sub , sup , SVG svg , table , textarea , time , u , ul (if the element's children include

at least one p225 p269 p380 p705 p133 li element), var , video , autonomous custom elements , text that is not inter-element

whitespace p130



3.2.5.2.9 Script-supporting elements p13 §

4

Script-supporting elements p124 are those that do not represent anything themselves (i.e. they are not rendered), but are used to support scripts, e.g. to provide functionality for the user.

The following elements are script-supporting elements:

⇒ p614 p630 script , template



3.2.5.3 Transparent content models p13 §

4

Some elements are described as transparent; they have "transparent" in the description of their content model. The content model of a p134 transparent element is derived from the content model of its parent element: the elements required in the part of the content model that is "transparent" are the same elements as required in the part of the content model of the parent of the transparent element in which the transparent element finds itself.

Example

For instance, an p312 p253 p259 p253 ins element inside a ruby element cannot contain an rt element, because the part of the ruby

element's content model that allows p312 p133 p259 ins elements is the part that allows phrasing content , and the rt element is not

phrasing content p133 .



Note

In some cases, where transparent elements are nested in each other, the process has to be applied iteratively.



Example

Consider the following markup fragment:



134



Apples





To check whether "Apples" is allowed inside the p239 p239 a element, the content models are examined. The a element's content

model is transparent, as is the p443 p312 p373 map element's, as is the ins element's, as is the part of the object element's in which the

ins p312 p373 p213 p133 element is found. The object element is found in the p element, whose content model is phrasing content. Thus,

"Apples" is allowed, as text is phrasing content.

When a transparent element has no parent, then the part of its content model that is "transparent" must instead be treated as accepting any p132 flow content.



3.2.5.4 Paragraphs §p13

5

Note

The term p135 p213 p135 paragraph as defined in this section is used for more than just the definition of the p element. The paragraph

concept defined here is used to describe how to interpret documents. The p213 p element is merely one of several ways of marking

up a p135 paragraph.

A p133 paragraph is typically a run of phrasing content that forms a block of text with one or more sentences that discuss a particular topic, as in typography, but can also be used for more general thematic grouping. For instance, an address is also a paragraph, as is a part of a form, a byline, or a stanza in a poem.

Example

In the following example, there are two paragraphs in a section. There is also a heading, which contains phrasing content that is

not a paragraph. Note how the comments and p130 inter-element whitespace do not form paragraphs.





Example of paragraphs




This is the first paragraph in this example.



This is the second.





Paragraphs in p132 p239 p312 p313 p443 flow content are defined relative to what the document looks like without the a , ins , del , and map elements complicating matters, since those elements, with their hybrid content models, can straddle paragraph boundaries, as shown in the first two examples below.

Note

Generally, having elements straddle paragraph boundaries is best avoided. Maintaining such markup can be difficult.



Example

The following example takes the markup from the earlier example and puts p312 p313 ins and del elements around some of the

markup to show that the text was changed (though in this case, the changes admittedly don't make much sense). Notice how this

example has exactly the same paragraphs as the previous one, despite the p312 p313 p312 ins and del elements — the ins element

straddles the heading and the first paragraph, and the p313 del element straddles the boundary between the two paragraphs.





Example of paragraphs




This is the first paragraph in this example.

This is the second.





Let p239 p312 p313 p443 p130 view be a view of the DOM that replaces all a , ins , del , and map elements in the document with their contents .

Then, in p133 view , for each run of sibling phrasing content nodes uninterrupted by other types of content, in an element that accepts

135

content other than p133 p133 phrasing content as well as phrasing content, let first be the first node of the run, and let last be the last node of the run. For each such run that consists of at least one node that is neither p133 embedded content nor inter-element

whitespace p130 , a paragraph exists in the original DOM from immediately before first to immediately after last. (Paragraphs can thus span across p239 p312 p313 p443 a , ins , del , and map elements.) Conformance checkers may warn authors of cases where they have paragraphs that overlap each other (this can happen with

object p373 p380 p384 p635 , video , audio , and canvas elements, and indirectly through elements in other namespaces that allow HTML to be further embedded therein, like SVG svg or MathML math).

A p135 p213 paragraph is also formed explicitly by p elements.

Note

The p213 p element can be used to wrap individual paragraphs when there would otherwise not be any content other than phrasing

content to separate the paragraphs from each other.



Example

In the following example, the link spans half of the first paragraph, all of the heading separating the two paragraphs, and half of

the second paragraph. It straddles the paragraphs and the heading.



Welcome!



This is home of...





The Falcons!




The Lockheed Martin multirole jet fighter aircraft!



This page discusses the F-16 Fighting Falcon's innermost secrets.



Here is another way of marking this up, this time showing the paragraphs explicitly, and splitting the one link element into three:





Welcome! This is home of...





The Falcons!





The Lockheed Martin multirole jet

fighter aircraft! This page discusses the F-16 Fighting Falcon's innermost secrets.





Example

It is possible for paragraphs to overlap when using certain elements that define fallback content. For example, in the following

section:





My Cats




You can play with my cat simulator.



To see the cat simulator, use one of the following links:





Download simulator file





Use online simulator





Alternatively, upgrade to the Mellblom Browser.





I'm quite proud of it.





There are five paragraphs:





1. The paragraph that says "You can play with my cat simulator. object I'm quite proud of it.", where object is the object

element.

2. The paragraph that says "To see the cat simulator, use one of the following links:". 3. The paragraph that says "Download simulator file".

4. The paragraph that says "Use online simulator".

5. The paragraph that says "Alternatively, upgrade to the Mellblom Browser.".

The first paragraph is overlapped by the other four. A user agent that supports the "cats.sim" resource will only show the first one,

but a user agent that shows the fallback will confusingly show the first sentence of the first paragraph as if it was in the same

paragraph as the second one, and will show the last paragraph as if it was at the start of the second sentence of the first

paragraph.

To avoid this confusion, explicit p elements can be used. For example:





My Cats





You can play with my cat simulator.





To see the cat simulator, use one of the following links:





Download simulator file





Use online simulator





Alternatively, upgrade to the Mellblom Browser.





I'm quite proud of it.





MDN





The following attributes are common to and may be specified on all HTML elements (even those not defined in this specification):

• accesskey

• autocapitalize

• autofocus

• contenteditable

• dir

• draggable

• enterkeyhint

• hidden

• inputmode

• is

• itemid

• itemprop

• itemref

• itemscope

• itemtype

• lang

• nonce

• spellcheck

• style

• tabindex

• title

• translate

These attributes are only defined by this specification as attributes for HTML elements. When this specification refers to elements having these attributes, elements from namespaces that are not defined as having these attributes must not be considered as being elements with these attributes.

Example

For example, in the following XML fragment, the " bogus " element does not have a dir attribute as defined in this specification,

despite having an attribute with the literal name " dir ". Thus, the directionality of the inner-most span element is ' rtl',



inherited from the div element indirectly through the "bogus" element.





DOM defines the user agent requirements for the class , id , and slot attributes for any element in any namespace. [DOM] ✔ MDN

The class , id , and slot attributes may be specified on all HTML elements.

When specified on HTML elements , the class attribute must have a value that is a set of space-separated tokens representing the various classes that the element belongs to.

Note

Assigning classes to an element affects class matching in selectors in CSS, the getElementsByClassName() method in the DOM,

and other such features.

There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use

values that describe the nature of the content, rather than values that describe the desired presentation of the content.

When specified on HTML elements , the id attribute value must be unique amongst all the IDs in the element's tree and must contain at least one character. The value must not contain any ASCII whitespace.

Note

The id attribute specifies its element's unique identifier (ID).

There are no other restrictions on what form an ID can take; in particular, IDs can consist of just digits, start with a digit, start with

an underscore, consist of just punctuation, etc.

An element's unique identifier can be used for a variety of purposes, most notably as a way to link to specific parts of a document

using fragments, as a way to target an element when scripting, and as a way to style a specific element from CSS.

Identifiers are opaque strings. Particular meanings should not be derived from the value of the id attribute.

There are no conformance requirements for the slot attribute specific to HTML elements.

Note

The slot attribute is used to assign a slot to an element: an element with a slot attribute is assigned to the slot created by

the slot element whose name attribute's value matches that slot attribute's value — but only if that slot element

finds itself in the shadow tree whose root 's host has the corresponding slot attribute value.



To enable assistive technology products to expose a more fine-grained interface than is otherwise possible with HTML elements and attributes, a set of annotations for assistive technology products can be specified (the ARIA role and aria-* attributes).

[ARIA]



The following event handler content attributes may be specified on any HTML element:

• onabort

• onauxclick

• onblur *

• oncancel

• oncanplay

• oncanplaythrough

• onchange



• onclick

• onclose

• oncontextmenu

• oncopy

• oncuechange

• oncut

• ondblclick

• ondrag

• ondragend

• ondragenter

• ondragleave

• ondragover

• ondragstart

• ondrop

• ondurationchange

• onemptied

• onended

• onerror*

• onfocus*

• onformdata

• oninput

• oninvalid

• onkeydown

• onkeypress

• onkeyup

• onload *

• onloadeddata

• onloadedmetadata

• onloadstart

• onmousedown

• onmouseenter

• onmouseleave

• onmousemove

• onmouseout

• onmouseover

• onmouseup

• onpaste

• onpause

• onplay

• onplaying

• onprogress

• onratechange

• onreset

• onresize*

• onscroll*

• onsecuritypolicyviolation

• onseeked

• onseeking

• onselect

• onslotchange

• onstalled

• onsubmit

• onsuspend

• ontimeupdate

• ontoggle

• onvolumechange

• onwaiting

• onwheel

Note

The attributes marked with an asterisk have a different meaning when specified on body elements as those elements expose

event handlers of the Window object with the same names.



Note

While these attributes apply to all elements, they are not useful on all elements. For example, only media elements will ever

receive a volumechange event fired by the user agent.



Custom data attributes (e.g. data-foldername or data-msgid ) can be specified on any HTML element, to store custom data, state, annotations, and similar, specific to the page.



In HTML documents, elements in the HTML namespace may have an xmlns attribute specified, if, and only if, it has the exact value

"http://www.w3.org/1999/xhtml". This does not apply to XML documents.

Note

In HTML, the xmlns attribute has absolutely no effect. It is basically a talisman. It is allowed merely to make migration to and from

XML mildly easier. When parsed by an HTML parser, the attribute ends up in no namespace, not the "http://www.w3.org/

2000/xmlns/" namespace like namespace declaration attributes in XML do.



Note

In XML, an xmlns attribute is part of the namespace declaration mechanism, and an element cannot actually have an xmlns

attribute in no namespace specified.



XML also allows the use of the xml:space attribute in the XML namespace on any element in an XML document. This attribute has no effect on HTML elements , as the default behavior in HTML is to preserve whitespace. [XML]

Note

There is no way to serialize the xml:space attribute on HTML elements in the text/html syntax.



3.2.6.1 The title attribute



The title attribute represents advisory information for the element, such as would be appropriate for a tooltip. On a link, this could be the title or a description of the target resource; on an image, it could be the image credit or a description of the image; on a paragraph, it could be a footnote or commentary on the text; on a citation, it could be further information about the source; on

interactive content , it could be a label for, or instructions for, use of the element; and so forth. The value is text.

Note

Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible

manner as required by this specification (e.g., requiring a pointing device such as a mouse to cause a tooltip to appear, which

excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).

If this attribute is omitted from an element, then it implies that the title attribute of the nearest ancestor HTML element with a

title attribute set is also relevant to this element. Setting the attribute overrides this, explicitly stating that the advisory information of any ancestors is not relevant to this element. Setting the attribute to the empty string indicates that the element has no advisory information.

If the title attribute's value contains U+000A LINE FEED (LF) characters, the content is split into multiple lines. Each U+000A LINE FEED (LF) character represents a line break.

Example

Caution is advised with respect to the use of newlines in title attributes.

For instance, the following snippet actually defines an abbreviation's expansion with a line break in it:



My logs show that there was some interest in HTTP today.





Some elements, such as link , abbr , and input , define additional semantics for the title attribute beyond the semantics described above.

The advisory information of an element is the value that the following algorithm returns, with the algorithm being aborted once a value is returned. When the algorithm returns the empty string, then there is no advisory information.

1. If the element has a title attribute, then return its value.

2. If the element has a parent element, then return the parent element's advisory information .



3. Return the empty string.

User agents should inform the user when elements have advisory information, otherwise the information would not be discoverable.



The title IDL attribute must reflect the title content attribute. ✔ MDN



3.2.6.2 The lang and xml:lang attributes



The lang attribute (in no namespace) specifies the primary language for the element's contents and for any of the element's attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47]

The lang attribute in the XML namespace is defined in XML. [XML]

If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.

The lang attribute in no namespace may be used on any HTML element.

The lang attribute in the XML namespace may be used on HTML elements in XML documents, as well as elements in other

namespaces if the relevant specifications allow it (in particular, MathML and SVG allow lang attributes in the XML namespace to be specified on their elements). If both the lang attribute in no namespace and the lang attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.

Authors must not use the lang attribute in the XML namespace on HTML elements in HTML documents. To ease migration to and from XML, authors may specify an attribute in no namespace with no prefix and with the literal localname "xml:lang" on HTML

elements in HTML documents , but such attributes must only be specified if a lang attribute in no namespace is also specified, and both attributes must have the same value when compared in an ASCII case-insensitive manner.

Note

The attribute in no namespace with no prefix and with the literal localname "xml:lang" has no effect on language processing.



To determine the language of a node, user agents must look at the nearest ancestor element (including the element itself if the node is an element) that has a lang attribute in the XML namespace set or is an HTML element and has a lang in no namespace attribute set. That attribute specifies the language of the node (regardless of its value).

If both the lang attribute in no namespace and the lang attribute in the XML namespace are set on an element, user agents must use the lang attribute in the XML namespace , and the lang attribute in no namespace must be ignored for the purposes of determining the element's language.

If node's inclusive ancestors do not have either attribute set, but there is a pragma-set default language set, then that is the language of the node. If there is no pragma-set default language set, then language information from a higher-level protocol (such as HTTP), if any, must be used as the final fallback language instead. In the absence of any such language information, and in cases where the higher-level protocol reports multiple languages, the language of the node is unknown, and the corresponding language tag is the empty string.

If the resulting value is not a recognized language tag, then it must be treated as an unknown language having the given language tag, distinct from all other languages. For the purposes of round-tripping or communicating with other services that expect language tags, user agents should pass unknown language tags through unmodified, and tagged as being BCP 47 language tags, so that subsequent services do not interpret the data as another type of language description. [BCP47]

Example

Thus, for instance, an element with lang="xyzzy" would be matched by the selector :lang(xyzzy) (e.g. in CSS), but it would not

be matched by :lang(abcde), even though both are equally invalid. Similarly, if a web browser and screen reader working in

unison communicated about the language of the element, the browser would tell the screen reader that the language was "xyzzy",

even if it knew it was invalid, just in case the screen reader actually supported a language with that tag after all. Even if the screen

reader supported both BCP 47 and another syntax for encoding language names, and in that other syntax the string "xyzzy" was a

way to denote the Belarusian language, it would be incorrect for the screen reader to then start treating text as Belarusian,



because "xyzzy" is not how Belarusian is described in BCP 47 codes (BCP 47 uses the code "be" for Belarusian).

If the resulting value is the empty string, then it must be interpreted as meaning that the language of the node is explicitly unknown.



User agents may use the element's language to determine proper processing or rendering (e.g. in the selection of appropriate fonts or pronunciations, for dictionary selection, or for the user interfaces of form controls such as date pickers).



The lang IDL attribute must reflect the lang content attribute in no namespace.



3.2.6.3 The translate attribute



The translate attribute is an enumerated attribute that is used to specify whether an element's attribute values and the values of MDN

its Text node children are to be translated when the page is localized, or whether to leave them unchanged.

The attribute's keywords are the empty string, yes, and no. The empty string and the yes keyword map to the yes state. The no keyword maps to the no state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid

value default .

Each element (even non-HTML elements) has a translation mode , which is in either the translate-enabled state or the no-

translate state. If an HTML element 's translate attribute is in the yes state, then the element's translation mode is in the

translate-enabled state; otherwise, if the element's translate attribute is in the no state, then the element's translation

mode is in the no-translate state. Otherwise, either the element's translate attribute is in the inherit state, or the element is not an HTML element and thus does not have a translate attribute; in either case, the element's translation mode is in the same state as its parent element's, if any, or in the translate-enabled state, if the element is a document element.

When an element is in the translate-enabled state, the element's translatable attributes and the values of its Text node children are to be translated when the page is localized.

When an element is in the no-translate state, the element's attribute values and the values of its Text node children are to be left as-is when the page is localized, e.g. because the element contains a person's name or a name of a computer program.

The following attributes are translatable attributes:

• abbr on th elements

• alt on area , img , and input elements

• content on meta elements, if the name attribute specifies a metadata name whose value is known to be

translatable

• download on a and area elements

• label on optgroup , option , and track elements

• lang on HTML elements; must be "translated" to match the language used in the translation

• placeholder on input and textarea elements

• srcdoc on iframe elements; must be parsed and recursively processed

• style on HTML elements; must be parsed and recursively processed (e.g. for the values of 'content' properties)

• title on all HTML elements

• value on input elements with a type attribute in the Button state or the Reset Button state Other specifications may define other attributes that are also translatable attributes. For example, ARIA would define the aria-

label attribute as translatable.



The translate IDL attribute must, on getting, return true if the element's translation mode is translate-enabled, and false otherwise. On setting, it must set the content attribute's value to "yes" if the new value is true, and set the content attribute's value to "no" otherwise.

Example

In this example, everything in the document is to be translated when the page is localized, except the sample keyboard input and

sample program output:





The Bee Game





The Bee Game is a text adventure game in English.





When the game launches, the first thing you should do is type eat honey. The game will respond with:

Yum yum! That was some good honey!





3.2.6.4 The p143 ✔ MDN p14 dir attribute §

3

The p68 dir attribute specifies the element's text directionality. The attribute is an enumerated attribute with the following keywords and states: The ltr keyword, which maps to the ltr state

Indicates that the contents of the element are explicitly directionally isolated left-to-right text.

The rtl keyword, which maps to the rtl state

Indicates that the contents of the element are explicitly directionally isolated right-to-left text.

The auto keyword, which maps to the auto state

Indicates that the contents of the element are explicitly directionally isolated text, but that the direction is to be determined programmatically using the contents of the element (as described below).

Note

The heuristic used by this state is very crude (it just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm). Authors are urged to only use this value as a

last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied. p1275 [BIDI]



Note

For p549 p217 textarea and pre elements, the heuristic is applied on a per-paragraph level.

The attribute has no p68 p68 invalid value default and no missing value default.



The directionality p44 of an element (any element, not just an HTML element) is either 'ltr' or 'rtl', and is determined as per the first appropriate set of steps from the following list:

↪ p143 p143 If the element's dir attribute is in the ltr state

↪ p143 If the element is a document element and the dir attribute is not in a defined state (i.e. it is not present or has

an invalid value)

↪ p494 p496 p501 p143 If the element is an input element whose type attribute is in the Telephone state, and the dir attribute

is not in a defined state (i.e. it is not present or has an invalid value)

The directionality p143 p143 of the element is ' ltr'.

↪ p143 p143 If the element's dir attribute is in the rtl state

The directionality p143 p143 of the element is ' rtl'.

↪ p494 p496 p500 p500 p501 p502 If the element is an input element whose type attribute is in the Text , Search , Telephone , URL, or

Email p503 p143 p143 state, and the dir attribute is in the auto state

↪ p549 p143 p143 If the element is a textarea element and the dir attribute is in the auto state

If the element's p567 value contains a character of bidirectional character type AL or R, and there is no character of bidirectional

character type L anywhere before it in the element's p567 p143 p143 p1275 value , then the directionality of the element is ' rtl '. [BIDI]

143

Otherwise, if the element's p567 p143 value is not the empty string, or if the element is a document element , the directionality of

the element is ' p143 ltr'.

Otherwise, p143 p143 the directionality of the element is the same as the element's parent element's directionality.

↪ p143 p143 If the element's dir attribute is in the auto state

↪ p279 p143 If the element is a bdi element and the dir attribute is not in a defined state (i.e. it is not present or has an

invalid value)

Find the first character in tree order that matches the following criteria:

• The character is from a p143 Text node that is a descendant of the element whose directionality is being determined.

• The character is of bidirectional character type L, AL, or R. p1275 [BIDI]

• The character is not in a Text node that has an ancestor element that is a descendant of the element whose

directionality p143 is being determined and that is either:

◦ A p279 bdi element.

◦ A p614 script element.

◦ A p175 style element.

◦ A p549 textarea element.

◦ An element with a p143 dir attribute in a defined state.

If such a character is found and it is of bidirectional character type AL or R, p143 p143 the directionality of the element is ' rtl '.

If such a character is found and it is of bidirectional character type L, p143 p143 the directionality of the element is ' ltr'.

Otherwise, if the element is a p143 p143 document element , the directionality of the element is ' ltr'.

Otherwise, p143 p143 the directionality of the element is the same as the element's parent element's directionality.

↪ p143 If the element has a parent element and the dir attribute is not in a defined state (i.e. it is not present or has an

invalid value)

The directionality p143 p143 of the element is the same as the element's parent element's directionality.

Note

Since the p143 p44 dir attribute is only defined for HTML elements, it cannot be present on elements from other namespaces. Thus,

elements from other namespaces always just inherit their p143 directionality from their parent element, or, if they don't have one,

default to ' p143 ltr '.



Note

This attribute p151 has rendering requirements involving the bidirectional algorithm .



The p44 directionality of an attribute of an HTML element, which is used when the text of that attribute is to be included in the rendering in some manner, is determined as per the first appropriate set of steps from the following list:

↪ p144 p143 p143 If the attribute is a directionality-capable attribute and the element's dir attribute is in the auto state

Find the first character (in logical order) of the attribute's value that is of bidirectional character type L, AL, or R. p1275 [BIDI]

If such a character is found and it is of bidirectional character type AL or R, the p144 p143 directionality of the attribute is ' rtl '.

Otherwise, the p144 p143 directionality of the attribute is ' ltr'.

↪ Otherwise

The p144 p143 directionality of the attribute is the same as the element's directionality.

The following attributes are directionality-capable attributes:

• p469 p468 abbr on th elements

• p445 p322 p520 alt on area , img , and input elements

• p166 p165 p166 content on meta elements, if the name attribute specifies a metadata name whose value is primarily intended to be

human-readable rather than machine-readable

• p546 p547 p387 label on optgroup , option , and track elements

• p531 p552 placeholder on input and textarea elements

144

• p140 p44 title on all HTML elements



For web developers (non-normative)

document p145 . dir [ = value ]

Returns p118 p143 the html element 's dir attribute's value, if any.

Can be set, to either " p118 p143 ltr ", " rtl ", or " auto " to replace the html element 's dir attribute's value.

If there is no p118 html element, returns the empty string and ignores new values.



The p95 ✔ MDN p143 p95 dir IDL attribute on an element must reflect the dir content attribute of that element, limited to only known values . ✔ MDN

The p115 p95 p143 p118 dir IDL attribute on Document objects must reflect the dir content attribute of the html element, if any, limited to

only known values p95. If there is no such element, then the attribute must return the empty string and do nothing on setting.

Note

Authors are strongly encouraged to use the p143 dir attribute to indicate text direction rather than using CSS, since that way their

documents will continue to render correctly even in the absence of CSS (e.g. as interpreted by search engines).



Example

This markup fragment is of an IM conversation.



Student: How do you write "What's your name?" in Arabic?





Teacher: ؟كمسا ام

Student: Thanks.

Teacher: That's written "ار ًكش".

Teacher: Do you know how to write "Please"?

Student: "كلضف نم", right?



Given a suitable style sheet and the default alignment styles for the p213 p element, namely to align the text to the start edge of the

paragraph, the resulting rendering could be as follows:





As noted earlier, the p143 auto value is not a panacea. The final paragraph in this example is misinterpreted as being right-to-left

text, since it begins with an Arabic character, which causes the "right?" to be to the left of the Arabic text.



3.2.6.5 The p145 ✔ MDN p14 style attribute §

5

All p44 HTML elements may have the style content attribute set. This is a style attribute as defined by CSS Style Attributes.

[CSSATTR] p1276

In user agents that support CSS, the attribute's value must be parsed when the attribute is added or has its value changed, according to the rules given for p1276 style attributes . [CSSATTR]

However, if the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "style attribute", and the attribute's value, then the style rules defined in the attribute's value must not be applied to the p1275 element . [CSP]

145

Documents that use p145 style attributes on any of their elements must still be comprehensible and usable if those attributes were removed.

Note

In particular, using the p145 style attribute to hide and show content, or to convey meaning that is otherwise not included in the

document, is non-conforming. (To hide and show content, use the p768 hidden attribute.)



For web developers (non-normative)

element . style

Returns a p145 CSSStyleDeclaration object for the element's style attribute.

The p1276 style IDL attribute is defined in CSS Object Model . [CSSOM]

Example

In the following example, the words that refer to colors are marked up using the p280 p145 span element and the style attribute to

make those words show up in the relevant colors in visual media.



My sweat suit is transparent">green and my eyes are blue.





3.2.6.6 Embedding custom non-visible data with the p146 ✔ MDN p14 data-* attributes §

6

A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is p44 XML-compatible, and contains no ASCII upper alphas.

Note

All attribute names on p44 HTML elements in HTML documents get ASCII-lowercased automatically, so the restriction on ASCII

uppercase letters doesn't affect such documents.

Custom data attributes p146 are intended to store custom data, state, annotations, and similar, private to the page or application, for which there are no more appropriate attributes or elements.

These attributes are not intended for use by software that is not known to the administrators of the site that uses the attributes. For generic extensions that are to be used by multiple independent tools, either this specification should be extended to provide the feature explicitly, or a technology like p732 microdata should be used (with a standardized vocabulary).

Example

For instance, a site about music could annotate list items representing tracks in an album with custom data attributes containing

the length of each track. This information could then be used by the site itself to allow the user to sort the list by track length, or to

filter the list for tracks of certain lengths.





Beyond The Sea



...





It would be inappropriate, however, for the user to use generic software not associated with that music site to search for tracks of a

certain length by looking at this data.

This is because these attributes are intended for use by the site's own scripts, and are not a generic extension mechanism for

publicly-usable metadata.



Example

146

Similarly, a page author could write markup that provides information for a translation tool that they are intending to use:



The third claim covers the case of HTML markup.



In this example, the "data-mytrans-de" attribute gives specific text for the MyTrans product to use when translating the phrase

"claim" to German. However, the standard p142 translate attribute is used to tell it that in all languages, "HTML" is to remain

unchanged. When a standard attribute is available, there is no need for a p146 custom data attribute to be used.



Example

In this example, custom data attributes are used to store the result of a feature detection for PaymentRequest, which could be

used in CSS to style a checkout page differently.



Here, the p67 data-has-payment-request attribute is effectively being used as a boolean attribute; it is enough to check the

presence of the attribute. However, if the author so wishes, it could later be populated with some value, maybe to indicate limited

functionality of the feature.

Every p44 p146 HTML element may have any number of custom data attributes specified, with any value.

Authors should carefully design such extensions so that when the attributes are ignored and any associated CSS dropped, the page is still usable.

User agents must not derive any implementation behavior from these attributes or values. Specifications intended for user agents must not define these attributes to have any meaningful values.

JavaScript libraries may use the p146 custom data attributes , as they are considered to be part of the page on which they are used. Authors of libraries that are reused by many authors are encouraged to include their name in the attribute names, to reduce the risk of clashes. Where it makes sense, library authors are also encouraged to make the exact name used in the attribute names customizable, so that libraries whose authors unknowingly picked the same name can be used on the same page, and so that multiple versions of a particular library can be used on the same page even when those versions are not mutually compatible.

Example

For example, a library called "DoQuery" could use attribute names like data-doquery-range, and a library called "jJo" could use

attributes names like data-jjo-range. The jJo library could also provide an API to set which prefix to use (e.g.

J.setDataPrefix('j2'), making the attributes have names like data-j2-range).



For web developers (non-normative)

element p147 . dataset

Returns a p147 p146 DOMStringMap object for the element's data-* attributes. Hyphenated names become camel-cased. For example, data-foo-bar="" becomes element.dataset.fooBar.



The p146 p147 dataset IDL attribute provides convenient accessors for all the data-* attributes on an element. On getting, the dataset ✔ MDN

IDL attribute must return a p147 DOMStringMap whose associated element is this element.

✔ MDN

The p147 p147 p147 DOMStringMap interface is used for the dataset attribute. Each DOMStringMap has an associated element.

IDL [Exposed=Window,

LegacyOverrideBuiltIns]

interface DOMStringMap {

getter DOMString (DOMString name);

[CEReactions] setter undefined (DOMString name, DOMString value);

147

[CEReactions] deleter undefined (DOMString name);

};

To get a DOMStringMap's name-value pairs, run the following algorithm:

1. Let list be an empty list of name-value pairs.

2. For each content attribute on the p147 p147 DOMStringMap 's associated element whose first five characters are the string

"data-" and whose remaining characters (if any) do not include any ASCII upper alphas, in the order that those attributes are

listed in the element's attribute list, add a name-value pair to list whose name is the attribute's name with the first five characters removed and whose value is the attribute's value.

3. For each name in list, for each U+002D HYPHEN-MINUS character (-) in the name that is followed by an ASCII lower alpha,

remove the U+002D HYPHEN-MINUS character (-) and replace the character that followed it by the same character converted

to ASCII uppercase.

4. Return list.

The p147 supported property names on a DOMStringMap object at any instant are the names of each pair returned from getting the

DOMStringMap p148 's name-value pairs at that instant, in the order returned.

To p147 determine the value of a named property name for a DOMStringMap, return the value component of the name-value pair whose name component is p148 name in the list returned from getting the DOMStringMap 's name-value pairs.

To p147 set the value of a new named property or set the value of an existing named property for a DOMStringMap, given a property name name and a new value value, run the following steps:

1. If name contains a U+002D HYPHEN-MINUS character (-) followed by an ASCII lower alpha, then throw a "SyntaxError"

DOMException.

2. For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the

character with the same character converted to ASCII lowercase.

3. Insert the string data-at the front of name.

4. If name does not match the XML Name production, throw an "InvalidCharacterError" DOMException.

5. p147 p147 Set an attribute value for the DOMStringMap 's associated element using name and value.

To p147 delete an existing named property name for a DOMStringMap, run the following steps:

1. For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the

character with the same character converted to ASCII lowercase.

2. Insert the string data-at the front of name.

3. p147 p147 Remove an attribute by name given name and the DOMStringMap 's associated element.

Note

This algorithm will only get invoked by Web IDL for names that are given by the earlier algorithm for getting the DOMStringMap's

name-value pairs p148 p1282 . [WEBIDL]



Example

If a web page wanted an element to represent a space ship, e.g. as part of a game, it would have to use the p138 class attribute

along with p146 data-* attributes:



data-weapons="laser 2" data-shields="50%"

data-x="30" data-y="10" data-z="90">

onclick="spaceships[this.parentNode.dataset.shipId].fire()">

Fire





148





Notice how the hyphenated attribute name becomes camel-cased in the API.



Example

Given the following fragment and elements with similar constructions:



data-ai="robotarget" data-hp="46" data-ability="flames"

src="towers/rocket.png" alt="Rocket Tower">

...one could imagine a function splashDamage() that takes some arguments, the first of which is the element to process:

function splashDamage(node, x, y, damage) {

if (node.classList.contains('tower') && // checking the 'class' attribute

node.dataset.x == x && // reading the 'data-x' attribute

node.dataset.y == y) { // reading the 'data-y' attribute

var hp = parseInt(node.dataset.hp); // reading the 'data-hp' attribute hp = hp-damage;

if (hp < 0) {

hp = 0;

node.dataset.ai = 'dead'; // setting the 'data-ai' attribute

delete node.dataset.ability; // removing the 'data-ability' attribute

}

node.dataset.hp = hp; // setting the 'data-hp' attribute

}

}



3.2.7 The p149 ✔ MDN p14 innerText getter and setter §

9

For web developers (non-normative)

element p149 . innerText [ = value ]

Returns the element's text content "as rendered".

Can be set, to replace the element's children with the given value, but with line breaks converted to p281 br elements.

The innerText getter steps are:

1. If p1188 this is not being rendered or if the user agent is a non-CSS user agent, then return this's descendant text content.

Note

This step can produce surprising results, as when the p149 innerText getter is invoked on an element not being

rendered p1188 p1188 , its text contents are returned, but when accessed on an element that is being rendered, all of its

children that are not p1188 being rendered have their text contents ignored.

2. Let results be a new empty list.

3. For each child node node of this:

1. Let p150 current be the list resulting in running the inner text collection steps with node. Each item in results will

either be a string or a positive integer (a required line break count).

Note

Intuitively, a required line break count item means that a certain number of line breaks appear at that point, but they can be collapsed with the line breaks induced by adjacent required line break count items, reminiscent to CSS margin-collapsing.

149

2. For each item item in current, append item to results.

4. Remove any items from results that are the empty string.

5. Remove any runs of consecutive required line break count items at the start or end of results.

6. Replace each remaining run of consecutive required line break count items with a string consisting of as many U+000A LINE

FEED (LF) characters as the maximum of the values in the required line break count items.

7. Return the concatenation of the string items in results.

The inner text collection steps, given a node node, are as follows:

1. Let p150 items be the result of running the inner text collection steps with each child node of node in tree order, and then

concatenating the results to a single list.

2. If node's computed value of 'visibility' is not 'visible', then return items.

3. If p1188 node is not being rendered, then return items. For the purpose of this step, the following elements must act as

described if the computed value of the 'display' property is not 'none':

◦ p538 select elements have an associated non-replaced inline CSS box whose child boxes include only those of

optgroup p545 p546 and option element child nodes;

◦ p545 optgroup elements have an associated non-replaced block-level CSS box whose child boxes include only those

of p546 option element child nodes; and

◦ p546 option element have an associated non-replaced block-level CSS box whose child boxes are as normal for non-

replaced block-level CSS boxes.

Note

items can be non-empty due to 'display:contents'.

4. If node is a Text node, then for each CSS text box produced by node, in content order, compute the text of the box after

application of the CSS 'white-space' processing rules and 'text-transform' rules, set items to the list of the resulting strings,

and return items. The CSS 'white-space' processing rules are slightly modified: collapsible spaces at the end of lines are

always collapsed, but they are only removed if the line is the last line of the block, or it ends with a p281 br element. Soft

hyphens should be preserved. p1277 [CSSTEXT]

5. If p281 node is a br element, then append a string containing a single U+000A LINE FEED (LF) character to items.

6. If node's computed value of 'display' is 'table-cell', and node's CSS box is not the last 'table-cell' box of its enclosing 'table-

row' box, then append a string containing a single U+0009 CHARACTER TABULATION (tab) character to items.

7. If node's computed value of 'display' is 'table-row', and node's CSS box is not the last 'table-row' box of the nearest ancestor

'table' box, then append a string containing a single U+000A LINE FEED (LF) character to items.

8. If p213 node is a p element, then append 2 (a required line break count) at the beginning and end of items.

9. If node's used value of 'display' is block-level or 'table-caption', then append 1 (a required line break count) at the beginning

and end of p1276 items . [CSSDISPLAY]

Note

Floats and absolutely-positioned elements fall into this category.

10. Return items.

Note

Note that descendant nodes of most replaced elements (e.g., p549 p494 p380 p536 textarea , input , and video — but not button) are not

rendered by CSS, strictly speaking, and therefore have no CSS boxes for the purposes of this algorithm.



This algorithm is amenable to being generalized to work on ranges. Then we can use it as the basis for Selection's stringifier and

maybe expose it directly on ranges. See Bugzilla bug 10583.



The p149 innerText setter steps are:

1. Let document be this's node document.

150

2. Let fragment be a new DocumentFragment object whose node document is document.

3. Let input be the given value.

4. Let position be a pointer into input, initially pointing at the start of the string.

5. Let text be the empty string.

6. While position is not past the end of input:

1. Collect a sequence of code points that are not U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)

characters from input given position. Set text to the collected characters.

2. If text is not the empty string, then append a new Text node whose data is text and node document is document

to fragment.

3. While position is not past the end of input, and the character at position is either a U+000A LINE FEED (LF) or

U+000D CARRIAGE RETURN (CR) character:

1. If the character at position is a U+000D CARRIAGE RETURN (CR) character and the next character is a

U+000A LINE FEED (LF) character, then advance position to the next character in input.

2. Advance position to the next character in input.

3. p281 Append the result of creating an element given document , br , and the HTML namespace to fragment.

7. Replace all with fragment within this.



3.2.8 Requirements relating to the bidirectional algorithm p15 §

1

3.2.8.1 Authoring conformance criteria for bidirectional-algorithm formatting characters p15 §

1

Text content p133 p44 p130 p44 in HTML elements with Text nodes in their contents , and text in attributes of HTML elements that allow free-form text, may contain characters in the ranges U+202A to U+202E and U+2066 to U+2069 (the bidirectional-algorithm formatting characters). p1275 [BIDI]

Note

Authors are encouraged to use the p143 p280 p279 dir attribute, the bdo element, and the bdi element, rather than maintaining the

bidirectional-algorithm formatting characters manually. The bidirectional-algorithm formatting characters interact poorly with CSS.



3.2.8.2 User agent conformance criteria p15 §

1

User agents must implement the Unicode bidirectional algorithm to determine the proper ordering of characters when rendering documents and parts of documents. p1275 [BIDI]

The mapping of HTML to the Unicode bidirectional algorithm must be done in one of three ways. Either the user agent must implement CSS, including in particular the CSS 'unicode-bidi', 'direction', and 'content' properties, and must have, in its user agent style sheet, the rules using those properties given in this specification's p1188 rendering section, or, alternatively, the user agent must act as if it implemented just the aforementioned properties and had a user agent style sheet that included all the aforementioned rules, but without letting style sheets specified in documents override them, or, alternatively, the user agent must implement another styling language with equivalent semantics. p1276 [CSSGC]

The following elements and attributes have requirements defined by the p1188 rendering section that, due to the requirements in this section, are requirements on all user agents (not just those that p47 support the suggested default rendering):

• p143 dir attribute

• p279 bdi element

• p280 bdo element

• p281 br element

• p217 pre element

• p549 textarea element

• p282 wbr element

151

3.2.9 Requirements related to ARIA and to platform accessibility APIs p15 §

2

User agent requirements for implementing Accessibility API semantics on p44 HTML elements are defined in HTML Accessibility API Mappings p705 . In addition to the rules there, for a custom element element, the default ARIA role semantics are determined as follows:

[HTMLAAM] p1278

1. Let p720 map be element 's native accessibility semantics map.

2. If map["role"] exists, then return it.

3. Return no role.

Similarly, for a p705 custom element element, the default ARIA state and property semantics, for a state or property named stateOrProperty, are determined as follows:

1. Let p720 map be element 's native accessibility semantics map.

2. If map[stateOrProperty] exists, then return it.

3. Return the default value for stateOrProperty.

Note

The "default semantics" referred to here are sometimes also called "native", "implicit", or "host language" semantics in ARIA.

[ARIA] p1275



Note

One implication of these definitions is that the default semantics can change over time. This allows custom elements the same

expressivity as built-in elements; e.g., compare to how the default ARIA role semantics of an p239 p285 a element change as the href

attribute is added or removed.

For an example of this in action, see p699 the custom elements section .



Conformance checker requirements for checking use of ARIA p63 p63 p44 role and aria-* attributes on HTML elements are defined in ARIA in HTML p1275 . [ARIAHTML]



152

4 The elements of HTML p15 §

3

4.1 The document element p15 §

3 ✔ MDN

4.1.1 The html element p15 §

3

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As document's document element.

Wherever a subdocument fragment is allowed in a compound document.

Content model p129:

A p154 p179 head element followed by a body element.

Tag omission in text/html p129 :

An p153 p1066 p153 p1075 html element's start tag can be omitted if the first thing inside the html element is not a comment.

An p153 p1067 p153 p1075 html element's end tag can be omitted if the html element is not immediately followed by a comment.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLHtmlElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The p153 p124 html element represents the root of an HTML document.

Authors are encouraged to specify a p141 p153 lang attribute on the root html element, giving the document's language. This aids speech synthesis tools to determine what pronunciations to use, translation tools to determine what rules to use, and so forth.

Example

The p153 html element in the following example declares that the document's language is English.





Swapping Songs





Swapping Songs





Tonight I swapped some of the songs I wrote with some friends, who gave me some of the songs they wrote. I love sharing my music.





153

4.2 Document metadata p15 §

4 ✔ MDN

4.2.1 The head element p15 §

4

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As the first element in an p153 html element.

Content model p129:

If the document is p363 an iframe srcdoc document or if title information is available from a higher-level protocol: Zero or more

elements of p132 p155 p156 metadata content , of which no more than one is a title element and no more than one is a base element.

Otherwise: One or more elements of p132 p155 metadata content , of which exactly one is a title element and no more than one is

a p156 base element.

Tag omission in text/html p129 :

A p154 p1066 p154 head element's start tag can be omitted if the element is empty, or if the first thing inside the head element is an element.

A p154 p1067 p154 head element's end tag can be omitted if the head element is not immediately followed by ASCII whitespace or a

comment p1075.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLHeadElement : HTMLElement {

[HTMLConstructor] constructor();

};



The p154 p124 p115 head element represents a collection of metadata for the Document .

Example

The collection of metadata in a p154 head element can be large or small. Here is an example of a very short one:





A document with a short head





...

Here is an example of a longer one:





An application with a long head





...



Note

The p155 title element is a required child in most situations, but when a higher-level protocol provides title information, e.g. in the

Subject line of an email when HTML is used as an email authoring format, the p155 title element can be omitted.



4.2.2 The title element §

p15 ✔ MDN

5

Categories p129: ✔ MDN

Metadata content p132.

Contexts in which this element can be used p129 :

In a p154 p155 head element containing no other title elements.

Content model p129:

Text p133 p130 that is not inter-element whitespace.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTitleElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString text;

};



The p155 p124 title element represents the document's title or name. Authors should use titles that identify their documents even when they are used out of context, for example in a user's history or bookmarks, or in search results. The document's title is often different from its first heading, since the first heading does not have to stand alone when taken out of context.

There must be no more than one p155 title element per document.

Note

If it's reasonable for the p115 p155 p154 Document to have no title, then the title element is probably not required. See the head

element's content model for a description of when the element is required.



For web developers (non-normative)

title p155 . text [ = value ]

Returns the child text content of the element.

Can be set, to replace the element's children with the given value.

The p155 text attribute's getter must return this title element's child text content.

The p155 p155 text attribute's setter must string replace all with the given value within this title element.

155

Example

Here are some examples of appropriate titles, contrasted with the top-level headings that might be used on those same pages.

Introduction to The Mating Rituals of Bees



...





Introduction





This companion guide to the highly successful

Introduction to Medieval Bee-Keeping book is...

The next page might be a part of the same site. Note how the title describes the subject matter unambiguously, while the first

heading assumes the reader knows what the context is and therefore won't wonder if the dances are Salsa or Waltz:

Dances used during bee mating rituals



...





The Dances





The string to use as the document's title is given by the p118 document.title IDL attribute.

User agents should use the document's title when referring to the document in their user interface. When the contents of a p155 title

element are used in this way, p143 p155 the directionality of that title element should be used to set the directionality of the document's title in the user interface.



✔ MDN

4.2.3 The base element p15 §

6

Categories p129: ✔ MDN

Metadata content p132.

Contexts in which this element can be used p129 :

In a p154 p156 head element containing no other base elements.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

href p157 p89 — Document base URL

target p157 p814 p284 p876 p596 — Default browsing context for hyperlink navigation and form submission

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLBaseElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString href;

[CEReactions] attribute DOMString target;

};



The p156 p89 p89 base element allows authors to specify the document base URL for the purposes of parsing URLs, and the name of the

default p814 p291 p124 browsing context for the purposes of following hyperlinks . The element does not represent any content beyond this information.

There must be no more than one p156 base element per document.

156

A p156 p157 p157 base element must have either an href attribute, a target attribute, or both.

The p88 href content attribute, if specified, must contain a valid URL potentially surrounded by spaces.

A p156 p157 base element, if it has an href attribute, must come before any other elements in the tree that have attributes defined as taking p153 p1225 p156 URLs , except the html element (its manifest attribute isn't affected by base elements).

Note

If there are multiple p156 p157 base elements with href attributes, all but the first are ignored.

The p822 target attribute, if specified, must contain a valid browsing context name or keyword, which specifies which browsing

context p814 p284 p487 p115 p876 is to be used as the default when hyperlinks and forms in the Document cause navigation.

A p156 p157 p284 base element, if it has a target attribute, must come before any elements in the tree that represent hyperlinks .

Note

If there are multiple p156 p157 base elements with target attributes, all but the first are ignored.

To p239 p444 p487 get an element's target , given an a , area , or form element element, run these steps:

1. If element has a target attribute, then return that attribute's value.

2. If p156 p157 p157 element 's node document contains a base element with a target attribute, then return the value of the target

attribute of the first such p156 base element.

3. Return the empty string.



A p156 p156 p157 base element that is the first base element with an href content attribute in a document tree has a frozen base URL. The

frozen base URL p157 p42 p157 must be immediately set for an element whenever any of the following situations occur:

• The p156 p156 p157 p115 base element becomes the first base element in tree order with an href content attribute in its Document .

• The p156 p156 p157 p115 base element is the first base element in tree order with an href content attribute in its Document, and its

href p157 content attribute is changed.

To set the frozen base URL for an element element:

1. Let document be element's node document.

2. Let p157 p89 urlRecord be the result of parsing the value of element 's href content attribute with document 's fallback base URL,

and p156 document 's character encoding . (Thus, the base element isn't affected by itself.)

3. Set p157 p89 element 's frozen base URL to document 's fallback base URL, if urlRecord is failure or running Is base allowed for

Document? p89 on the resulting URL record and document returns "Blocked", and to urlRecord otherwise.

The href IDL attribute, on getting, must return the result of running the following algorithm:

1. Let document be element's node document.

2. Let p157 url be the value of the href attribute of this element, if it has one, and the empty string otherwise.

3. Let p89 urlRecord be the result of parsing url with document 's fallback base URL, and document's character encoding. (Thus,

the p156 p156 base element isn't affected by other base elements or itself.)

4. If urlRecord is failure, return url.

5. Return the serialization of urlRecord.

The p157 p157 href IDL attribute, on setting, must set the href content attribute to the given new value.

The p95 target IDL attribute must reflect the content attribute of the same name.

Example

In this example, a p156 p89 base element is used to set the document base URL:

157





This is an example for the <base> element





Visit the archives.





The link in the above example would be a link to "https://www.example.com/news/archives.html".



✔ MDN

4.2.4 The link element p15 §

8

Categories p129: ✔ MDN

Metadata content p132.

If the element is p159 p132 allowed in the body : flow content.

If the element is p159 p133 allowed in the body : phrasing content .

Contexts in which this element can be used p129 :

Where p132 metadata content is expected.

In a p628 p154 noscript element that is a child of a head element.

If the element is p159 p133 allowed in the body : where phrasing content is expected.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

href p159 p284 — Address of the hyperlink

crossorigin p159 — How the element handles crossorigin requests

rel p159 p284 — Relationship between the document containing the hyperlink and the destination resource

media p160 — Applicable media

integrity p160 p1281 — Integrity metadata used in Subresource Integrity checks [SRI]

hreflang p160 — Language of the linked resource

type p160 — Hint for the type of the referenced resource

referrerpolicy p160 — Referrer policy for fetches initiated by the element

sizes p161 p159 p299 — Sizes of the icons (for rel =" icon")

imagesrcset p160 — Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for

rel p159 p306 =" preload")

imagesizes p160 p159 p306 — Image sizes for different page layouts (for rel =" preload ")

as p161 p159 p306 p159 p302 — Potential destination for a preload request (for rel =" preload " and rel =" modulepreload")

color p162 p159 — Color to use when customizing a site's icon (for rel="mask-icon")

disabled p162 — Whether the link is disabled

Also, the p160 p160 title attribute has special semantics on this element: Title of the link; CSS style sheet set name.

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLLinkElement : HTMLElement {

[HTMLConstructor] constructor();

158

[CEReactions] attribute USVString href;

[CEReactions] attribute DOMString? crossOrigin;

[CEReactions] attribute DOMString rel;

[CEReactions] attribute DOMString as; // (default "")

[SameObject, PutForwards=value] readonly attribute DOMTokenList relList;

[CEReactions] attribute DOMString media;

[CEReactions] attribute DOMString integrity;

[CEReactions] attribute DOMString hreflang;

[CEReactions] attribute DOMString type;

[SameObject, PutForwards=value] readonly attribute DOMTokenList sizes;

[CEReactions] attribute USVString imageSrcset;

[CEReactions] attribute DOMString imageSizes;

[CEReactions] attribute DOMString referrerPolicy;

[CEReactions] attribute boolean disabled;

// also has obsolete members

};

HTMLLinkElement includes LinkStyle;



The p158 link element allows authors to link their document to other resources.

The address of the link(s) is given by the p159 href attribute. If the href attribute is present, then its value must be a valid non-empty

URL potentially surrounded by spaces p88 p159 p160 . One or both of the href or imagesrcset attributes must be present.

If both the p159 p160 href and imagesrcset attributes are absent, then the element does not define a link.

✔ MDN

The p91 p284 crossorigin attribute is a CORS settings attribute . It is intended for use with external resource links.

The types of link indicated (the relationships) are given by the value of the rel attribute, which, if present, must have a value that is a

unordered set of unique space-separated tokens p87 p295 . The allowed keywords and their meanings are defined in a later section. If the

rel p159 attribute is absent, has no keywords, or if none of the keywords used are allowed according to the definitions in this specification, then the element does not create any links.

rel p159 p295 p158 's supported tokens are the keywords defined in HTML link types which are allowed on link elements, impact the processing model, and are supported by the user agent. The possible p296 p299 p299 supported tokens are alternate , dns-prefetch , icon,

manifest p302 p302 p310 p305 p305 p306 p306 p306 p306 , modulepreload , next , pingback , preconnect , prefetch , preload , prerender , search, and

stylesheet p307 p159 . rel 's supported tokens must only include the tokens from this list that the user agent implements the processing model for.

Note

Theoretically a user agent could support the processing model for the p298 canonical keyword — if it were a search engine that

executed JavaScript. But in practice that's quite unlikely. So in most cases, p298 p159 canonical ought not be included in rel's

supported tokens.

A p158 p159 p739 link element must have either a rel attribute or an itemprop attribute, but not both.

If a p158 p739 p159 p295 link element has an itemprop attribute, or has a rel attribute that contains only keywords that are body-ok, then the element is said to be p133 allowed in the body . This means that the element can be used where phrasing content is expected.

Note

If the p159 p179 rel attribute is used, the element can only sometimes be used in the body of the page. When used with the

itemprop p739 p154 p179 attribute, the element can be used both in the head element and in the body of the page, subject to the

constraints of the microdata model.

Two categories of links can be created using the p158 p284 p284 link element: links to external resources and hyperlinks. The link types

section p295 p158 defines whether a particular link type is an external resource or a hyperlink. One link element can create multiple links (of which some might be p284 p284 external resource links and some might be hyperlinks ); exactly which and how many links are created depends on the keywords given in the p159 rel attribute. User agents must process the links on a per-link basis, not a per-element basis.

159

Note

Each link created for a p158 p158 link element is handled separately. For instance, if there are two link elements with

rel="stylesheet", they each count as a separate external resource, and each is affected by its own attributes independently.

Similarly, if a single p158 p159 p284 link element has a rel attribute with the value next stylesheet , it creates both a hyperlink (for

the p310 p284 p307 next keyword) and an external resource link (for the stylesheet keyword), and they are affected by other attributes

(such as p160 p160 media or title) differently.



Example

For example, the following p158 p284 link element creates two hyperlinks (to the same page):



The two links created by this element are one whose semantic is that the target page has information about the current page's

author, and one whose semantic is that the target page has information regarding the license under which the current page is

provided.



Note

Hyperlinks p284 p158 p159 created with the link element and its rel attribute apply to the whole document. This contrasts with the

rel p285 p239 p444 attribute of a and area elements, which indicates the type of a link whose context is given by the link's location

within the document.

The exact behavior for p284 p295 links to external resources depends on the exact relationship, as defined for the relevant link type .

The p88 media attribute says which media the resource applies to. The value must be a valid media query list.

The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The attribute must only be specified on p158 p159 p307 p306 link elements that have a rel attribute that contains the stylesheet , preload , or

modulepreload p302 p1281 keyword. [SRI]

The p158 p285 hreflang attribute on the link element has the same semantics as the hreflang attribute on the a element .

The type attribute gives the MIME type of the linked resource. It is purely advisory. The value must be a valid MIME type string.

For p284 p160 external resource links , the type attribute is used as a hint to user agents so that they can avoid fetching resources they do not support.

The p92 p284 referrerpolicy attribute is a referrer policy attribute . It is intended for use with external resource links, where it helps set the p163 p1280 referrer policy used when fetching and processing the linked resource . [REFERRERPOLICY].

The title attribute gives the title of the link. With one exception, it is purely advisory. The value is text. The exception is for style sheet links that are p160 in a document tree , for which the title attribute defines CSS style sheet sets.

Note

The p160 p158 p140 title attribute on link elements differs from the global title attribute of most other elements in that a link

without a title does not inherit the title of the parent element: it merely has no title.



The p336 imagesrcset attribute may be present, and is a srcset attribute.

The p160 p159 p336 p338 imagesrcset and href attributes (if width descriptors are not used) together contribute the image sources to the

source set p338.

If the p160 p336 p336 imagesrcset attribute is present and has any image candidate strings using a width descriptor, the imagesizes attribute must also be present, and is a p336 p160 p338 sizes attribute . The imagesizes attribute contributes the source size to the source

set p338 .

The p160 p160 p158 p159 imagesrcset and imagesizes attributes must only be specified on link elements that have both a rel attribute that specifies the p306 p161 preload keyword, as well as an as attribute in the "image" state.

Example

160

These attributes allow preloading the appropriate resource that is later used by an p321 img element that has the corresponding

values for its p322 p322 srcset and sizes attributes:



imagesrcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w" imagesizes="50vw">





srcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w" sizes="50vw">

Note how we omit the p159 p160 href attribute, as it would only be relevant for browsers that do not support imagesrcset, and in

those cases it would likely cause the incorrect image to be preloaded.



Example

The p160 p160 imagesrcset attribute can be combined with the media attribute to preload the appropriate resource selected from a

picture p317 p331 element's sources, for art direction :



imagesrcset="dog-cropped-1x.jpg, dog-cropped-2x.jpg 2x"

media="(max-width: 800px)">



imagesrcset="dog-wide-1x.jpg, dog-wide-2x.jpg 2x"

media="(min-width: 801px)">





media="(max-width: 800px)">



alt="An awesome dog">





The sizes attribute gives the sizes of icons for visual media. Its value, if present, is merely advisory. User agents may use the value to decide which icon(s) to use if multiple icons are available. If specified, the attribute must have a value that is an unordered set of

unique space-separated tokens p87 which are ASCII case-insensitive. Each value must be either an ASCII case-insensitive match for the string " p300 p69 any ", or a value that consists of two valid non-negative integers that do not have a leading U+0030 DIGIT ZERO (0) character and that are separated by a single U+0078 LATIN SMALL LETTER X or U+0058 LATIN CAPITAL LETTER X character. The attribute must only be specified on p158 p159 p299 link elements that have a rel attribute that specifies the icon keyword or the apple-touch-icon keyword.

Note

The p310 apple-touch-icon keyword is a registered extension to the predefined set of link types , but user agents are not required

to support it in any way.



The p159 as attribute specifies the potential destination for a preload request for the resource given by the href attribute. It is an

enumerated attribute p68. Each potential destination is a keyword for this attribute, mapping to a state of the same name. The attribute must be specified on p158 p159 p306 link elements that have a rel attribute that contains the preload keyword. It may be specified on

link p158 p159 p302 elements that have a rel attribute that contains the modulepreload keyword; in such cases it must have a value which is a p158 script-like destination . For other link elements, it must not be specified.

The processing model for how the p161 p163 as attribute is used is given in an individual link type's fetch and process the linked resource

algorithm.



161

Note

The attribute does not have a p68 p68 missing value default or invalid value default, meaning that invalid or missing values for the

attribute map to no state. This is accounted for in the processing model. For p306 preload links, both conditions are an error; for

modulepreload p302 links, a missing value will be treated as "script".



The p158 p159 color attribute is used with the mask-icon link type. The attribute must only be specified on link elements that have a rel

attribute that contains the mask-icon keyword. The value must be a string that matches the CSS <color> production, defining a suggested color that user agents can use to customize the display of the icon that the user sees when they pin your site.

Note

This specification does not have any user agent requirements for the p162 color attribute.



Note

The p310 mask-icon keyword is a registered extension to the predefined set of link types, but user agents are not required to

support it in any way.



link p158 elements have an associated explicitly enabled boolean. It is initially false.

The p67 p307 disabled attribute is a boolean attribute that is used with the stylesheet link type. The attribute must only be specified on

link p158 p159 p307 elements that have a rel attribute that contains the stylesheet keyword.

Whenever the p162 p158 p162 disabled attribute is removed, set the link element's explicitly enabled attribute to true.

Example

Removing the p162 disabled attribute dynamically, e.g., using document.querySelector("link").removeAttribute("disabled"),

will fetch and apply the style sheet:





The IDL attributes p95 href , hreflang , integrity , media , rel , sizes , type , and disabled each must reflect the respective content attributes of the same name.

Note

There is no reflecting IDL attribute for the p162 color attribute, but this might be added later.

The p95 p161 p95 as IDL attribute must reflect the as content attribute, limited to only known values.

The p95 p159 p95 crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

The p95 p160 p95 referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The p95 p160 imageSrcset IDL attribute must reflect the imagesrcset content attribute.

✔ MDN

The p95 p160 imageSizes IDL attribute must reflect the imagesizes content attribute.

The p95 p159 relList IDL attribute must reflect the rel content attribute.



4.2.4.1 Processing the p160 p16 media attribute §

2

If the link is a p284 p160 hyperlink then the media attribute is purely advisory, and describes for which media the document in question was designed.

However, if the link is an p284 p160 external resource link , then the media attribute is prescriptive. The user agent must apply the external resource when the p160 p88 media attribute's value matches the environment and the other relevant conditions apply, and must not apply

162

it otherwise.

The default, if the p160 media attribute is omitted, is "all", meaning that by default links apply to all media.

Note

The external resource might have further restrictions defined within that limit its applicability. For example, a CSS style sheet

might have some @media blocks. This specification does not override such further restrictions or requirements.



4.2.4.2 Processing the p160 p16 type attribute §

3

If the p160 type attribute is present, then the user agent must assume that the resource is of the given type (even if that is not a valid

MIME type string p284 , e.g. the empty string). If the attribute is omitted, but the external resource link type has a default type defined, then the user agent must assume that the resource is of that type. If the UA does not support the given MIME type for the given link relationship, then the UA should not p163 fetch and process the linked resource ; if the UA does support the given MIME type for the given link relationship, then the UA should p163 fetch and process the linked resource at the appropriate time as specified for the external

resource link p284 p284 's particular type. If the attribute is omitted, and the external resource link type does not have a default type defined, but the user agent would p163 fetch and process the linked resource if the type was known and supported, then the user agent should p163 fetch and process the linked resource under the assumption that it will be supported.

User agents must not consider the p160 p160 type attribute authoritative — upon fetching the resource, user agents must not use the type

attribute to determine its actual type. Only the actual type (as defined in the next paragraph) is used to determine whether to apply the resource, not the aforementioned assumed type.

If the p284 p90 external resource link type defines rules for processing the resource's Content-Type metadata, then those rules apply.

Otherwise, if the resource is expected to be an image, user agents may apply the image sniffing rules, with the official type being the type determined from the resource's p90 Content-Type metadata, and use the resulting computed type of the resource as if it was the actual type. Otherwise, if neither of these conditions apply or if the user agent opts not to apply the image sniffing rules, then the user agent must use the resource's p90 Content-Type metadata to determine the type of the resource. If there is no type metadata, but the

external resource link p284 type has a default type defined, then the user agent must assume that the resource is of that type.

Note

The p307 p90 stylesheet link type defines rules for processing the resource's Content-Type metadata.

Once the user agent has established the type of the resource, the user agent must apply the resource if it is of a supported type and the other relevant conditions apply, and must ignore the resource otherwise.

Example

If a document contains style sheet links labeled as follows:





...then a compliant UA that supported only CSS style sheets would fetch the B and C files, and skip the A file (since text/plain is

not the MIME type for CSS style sheets).

For files B and C, it would then check the actual types returned by the server. For those that are sent as p1273 text/css, it would

apply the styles, but for those labeled as text/plain, or any other type, it would not.

If one of the two files was returned without a p90 Content-Type metadata, or with a syntactically incorrect type like Content-

Type: "null" p307 p1273 , then the default type for stylesheet links would kick in. Since that default type is text/css, the style sheet

would nonetheless be applied.



4.2.4.3 Fetching and processing a resource from a p158 p16 link element §

3

All p284 p158 external resource links have a fetch and process the linked resource algorithm, which takes a link element el. They also have p158 linked resource fetch setup steps which take a link element el and request request. Individual link types may provide

163

their own p163 fetch and process the linked resource algorithm, but unless explicitly stated, they use the default fetch and process the

linked resource p164 p163 algorithm. Similarly, individual link types may provide their own linked resource fetch setup steps , but unless explicitly stated, these steps just return true.

The p158 default fetch and process the linked resource , given a link element el, is as follows:

1. If p159 el 's href attribute's value is the empty string, then return.

2. p89 p159 Parse the URL given by el 's href attribute, relative to el's node document. If that fails, then return. Otherwise, let url be

the p89 resulting URL record.

3. Let p159 corsAttributeState be the current state of the el 's crossorigin content attribute.

4. Let p90 request be the result of creating a potential-CORS request given url, the empty string, and corsAttributeState.

5. Set request's synchronous flag.

6. Set p911 request 's client to el 's node document 's relevant settings object .

7. Set p92 request 's cryptographic nonce metadata to the current value of el 's [[CryptographicNonce]] internal slot.

8. Set p160 request 's integrity metadata to the current value of el 's integrity content attribute.

9. Set p160 request 's referrer policy to the current state of the el 's referrerpolicy attribute.

10. Run the p163 linked resource fetch setup steps, given el and request. If the result is false, then return.

11. Run the following steps p42 in parallel:

1. Let response be the result of fetching request.

2. Let success be true.

3. If response is a network error or its status is not an ok status, set success to false.

Note

Note that content-specific errors, e.g., CSS parse errors or PNG decoding errors, do not affect success.

4. If p284 p44 success is true, wait for the link resource 's critical subresources to finish loading.

The specification that defines a link type's p44 critical subresources (e.g., CSS) is expected to describe how these subresources are fetched and processed. However, since this is not currently explicit, this specification

describes waiting for a p284 p44 link resource 's critical subresources to be fetched and processed, with the expectation that this will be done correctly.

5. p933 p939 p164 Queue an element task on the networking task source given el to process the linked resource given el,

success, and response.

User agents may opt to only try to p163 fetch and process such resources when they are needed, instead of pro-actively fetching all the

external resources p284 that are not applied.

Similar to the p163 p284 fetch and process the linked resource algorithm, all external resource links have a process the linked resource algorithm which takes a p158 link element el, boolean success, and response response. Individual link types may provide their own

process the linked resource p164 algorithm, but unless explicitly stated, that algorithm does nothing.

Unless otherwise specified for a given p159 p1162 rel keyword, the element must delay the load event of the element's node document

until all the attempts to p163 p44 fetch and process the linked resource and its critical subresources are complete. (Resources that the user agent has not yet attempted to fetch and process, e.g., because it is waiting for the resource to be needed, do not delay the load

event p1162.)



4.2.4.4 Processing `Link` headers p16 §

4

HTTP `Link` headers, if supported, must be assumed to come before any links in the document, in the order that they were given in the HTTP message. These headers are to be processed according to the rules given in the relevant specifications. p1278 [HTTP]

[WEBLINK] p1282

164

Note

Registration of relation types in HTTP ` p295 Link ` headers is distinct from HTML link types, and thus their semantics can be different

from same-named HTML types.



The processing of ` p115 p179 Link ` headers, in particular their influence on a Document 's script-blocking style sheet counter, is not

defined. See issue #4224 for discussion on integrating this into the spec.



4.2.4.5 Providing users with a means to follow hyperlinks created using the p158 p16 link element §

5

Interactive user agents may provide users with a means to p291 p158 follow the hyperlinks created using the link element, somewhere within their user interface. The exact interface is not defined by this specification, but it could include the following information (obtained from the element's attributes, again as defined below), in some form or another (possibly simplified), for each p284 hyperlink

created with each p158 link element in the document:

• The relationship between this document and the resource (given by the p159 rel attribute)

• The title of the resource (given by the p160 title attribute).

• The address of the resource (given by the p159 href attribute).

• The language of the resource (given by the p160 hreflang attribute).

• The optimum media for the resource (given by the p160 media attribute).

User agents could also include other information, such as the type of the resource (as given by the p160 type attribute).

The p158 p284 p291 p158 activation behavior of link elements that create hyperlinks is to follow the hyperlink created by the link element.



✔ MDN

4.2.5 The meta element p16 §

5

Categories p129: ✔ MDN

Metadata content p132.

If the p739 p132 itemprop attribute is present: flow content.

If the p739 p133 itemprop attribute is present: phrasing content.

Contexts in which this element can be used p129 :

If the p166 p171 p172 charset attribute is present, or if the element's http-equiv attribute is in the Encoding declaration state : in a

head p154 element.

If the p171 p172 p154 http-equiv attribute is present but not in the Encoding declaration state : in a head element.

If the p171 p172 p628 http-equiv attribute is present but not in the Encoding declaration state : in a noscript element that is a child

of a p154 head element.

If the p166 p132 name attribute is present: where metadata content is expected.

If the p739 p132 itemprop attribute is present: where metadata content is expected.

If the p739 p133 itemprop attribute is present: where phrasing content is expected.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

name p166 — Metadata name

http-equiv p171 — Pragma directive

content p166 — Value of the element

charset p166 p174 — Character encoding declaration

Accessibility considerations p130:

For authors.

165

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLMetaElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString httpEquiv;

[CEReactions] attribute DOMString content;

// also has obsolete members

};



The p165 p124 p155 p156 p158 meta element represents various kinds of metadata that cannot be expressed using the title , base , link,

style p175 p614 , and script elements.

The p165 p166 p171 meta element can represent document-level metadata with the name attribute, pragma directives with the http-equiv

attribute, and the file's p174 character encoding declaration when an HTML document is serialized to string form (e.g. for transmission over the network or for disk storage) with the p166 charset attribute.

Exactly one of the p166 p171 p166 p739 name , http-equiv , charset , and itemprop attributes must be specified.

If either p166 p171 p739 p166 name , http-equiv , or itemprop is specified, then the content attribute must also be specified. Otherwise, it must be omitted.

The p174 charset attribute specifies the character encoding used by the document. This is a character encoding declaration . If the

attribute is present, its value must be an ASCII case-insensitive match for the string "utf-8".

Note

The p166 p165 charset attribute on the meta element has no effect in XML documents, but is allowed in XML documents in order to

facilitate migration to and from XML.

There must not be more than one p165 p166 meta element with a charset attribute per document.

The content attribute gives the value of the document metadata or pragma directive when the element is used for those purposes. The allowed values depend on the exact context, as described in subsequent sections of this specification.

If a p165 meta element has a name attribute, it sets document metadata. Document metadata is expressed in terms of name-value pairs, the p166 p165 p166 name attribute on the meta element giving the name, and the content attribute on the same element giving the value. The name specifies what aspect of metadata is being set; valid names and the meaning of their values are described in the following sections. If a p165 p166 meta element has no content attribute, then the value part of the metadata name-value pair is the empty string.

The p95 name and content IDL attributes must reflect the respective content attributes of the same name. The IDL attribute httpEquiv must p95 p171 reflect the content attribute http-equiv.



✔ MDN

4.2.5.1 Standard metadata names p16 §

6

This specification defines a few names for the p166 p165 name attribute of the meta element.

Names are case-insensitive, and must be compared in an ASCII case-insensitive manner.

application-name

The value must be a short free-form string giving the name of the web application that the page represents. If the page is not a web

application, the p166 application-name metadata name must not be used. Translations of the web application's name may be given,

using the p141 lang attribute to specify the language of each name.

There must not be more than one p165 p141 p166 meta element with a given language and where the name attribute value is an ASCII

case-insensitive p166 match for application-name per document.

166

User agents may use the application name in UI in preference to the page's p155 title, since the title might include status messages and the like relevant to the status of the page at a particular moment in time instead of just being the name of the application.

To find the application name to use given an ordered list of languages (e.g. British English, American English, and English), user agents must run the following steps:

1. Let languages be the list of languages.

2. Let p141 p115 default language be the language of the Document 's document element, if any, and if that language is not

unknown.

3. If there is a default language, and if it is not the same language as any of the languages in languages, append it to

languages.

4. Let p165 p115 winning language be the first language in languages for which there is a meta element in the Document where

the p166 p166 p141 name attribute value is an ASCII case-insensitive match for application-name and whose language is the language in question.

If none of the languages have such a p165 meta element, then return; there's no given application name.

5. Return the value of the p166 p165 p115 content attribute of the first meta element in the Document in tree order where the

name p166 p166 p141 attribute value is an ASCII case-insensitive match for application-name and whose language is winning language.

Note

This algorithm would be used by a browser when it needs a name for the page, for instance, to label a bookmark. The languages it would provide to the algorithm would be the user's preferred languages.

author

The value must be a free-form string giving the name of one of the page's authors.

description

The value must be a free-form string that describes the page. The value must be appropriate for use in a directory of pages, e.g. in

a search engine. There must not be more than one p165 p166 meta element where the name attribute value is an ASCII case-insensitive

match for p167 description per document.

generator

The value must be a free-form string that identifies one of the software packages used to generate the document. This value must not be used on pages whose markup is not generated by software, e.g. pages whose markup was written by a user in a text editor.

Example

Here is what a tool called "Frontweaver" could include in its output, in the page's p154 head element, to identify itself as the tool used to generate the page:





keywords

The value must be a p87 set of comma-separated tokens, each of which is a keyword relevant to the page.

Example

This page about typefaces on British motorways uses a p165 meta element to specify some keywords that users might use to look for the page:





Typefaces on UK motorways





...

167

Note

Many search engines do not consider such keywords, because this feature has historically been used unreliably and even misleadingly as a way to spam search engine results in a way that is not helpful for users.

To obtain the list of keywords that the author has specified as applicable to the page, the user agent must run the following steps:

1. Let keywords be an empty list.

2. For each p165 p166 p166 p166 meta element with a name attribute and a content attribute and where the name attribute value is

an p167 ASCII case-insensitive match for keywords:

1. Split the value of the element's content attribute on commas.

2. Add the resulting tokens, if any, to keywords.

3. Remove any duplicates from keywords.

4. Return keywords. This is the list of keywords that the author has specified as applicable to the page.

User agents should not use this information when there is insufficient confidence in the reliability of the value.

Example

For instance, it would be reasonable for a content management system to use the keyword information of pages within the system to populate the index of a site-specific search engine, but a large-scale content aggregator that used this information would likely find that certain users would try to game its ranking mechanism through the use of inappropriate keywords.

referrer

The value must be a p115 p1280 referrer policy , which defines the default referrer policy for the Document . [REFERRERPOLICY]

If any p165 p44 p44 p165 meta elements are inserted into the document or removed from the document , or existing meta elements have

their p166 p166 name or content attributes changed, user agents must run the following algorithm:

1. Let p165 candidate elements be the list of all meta elements that meet the following criteria, in tree order:

◦ The element is in a document tree

◦ The element has a p166 p168 name attribute, whose value is an ASCII case-insensitive match for referrer

◦ The element has a p166 content attribute, whose value is not the empty string

◦ The element is a child of p118 the head element of the document

2. For each element in candidate elements:

1. Let p166 value be the value of element 's content attribute, converted to ASCII lowercase.

2. If value is one of the values given in the first column of the following table, then set value to the value given in

the second column:

Legacy value Referrer policy

never no-referrer

default the default referrer policy

always unsafe-url

origin-when-crossorigin origin-when-cross-origin

3. If p116 value is a referrer policy , then set element 's node document 's referrer policy to policy.

Note

The fact that these steps are applied for each element enables deployment of fallback values for older user agents.

[REFERRERPOLICY] p1280

theme-color ⚠ MDN

The value must be a string that matches the CSS <color> production, defining a suggested color that user agents should use to customize the display of the page or of the surrounding user interface. For example, a browser might color the page's title bar with the specified value, or use it as a color highlight in a tab bar or task switcher.

There must not be more than one p165 p166 meta element with its name attribute value set to an ASCII case-insensitive match for

theme-color p168 per document.

168

Example

This standard itself uses "WHATWG green" as its theme color:



HTML Standard





...



To obtain a page's theme color, user agents must run the following steps:

1. Let p165 candidate elements be the list of all meta elements that meet the following criteria, in tree order:

◦ The element is in a document tree

◦ The element has a p166 p168 name attribute, whose value is an ASCII case-insensitive match for theme-color

◦ The element has a p166 content attribute

2. For each element in candidate elements:

1. Let p166 value be the result of stripping leading and trailing ASCII whitespace from the value of element 's content

attribute.

2. Let p58 color be the result of parsing value.

3. If color is not failure, then return color.

3. Return nothing (the page has no theme color).

If any p165 p44 p44 p165 meta elements are inserted into the document or removed from the document , or existing meta elements have

their p166 p166 name or content attributes changed, user agents must re-run the above algorithm and apply the result to any affected UI.

When using the theme color in UI, user agents may adjust it in implementation-specific ways to make it more suitable for the UI in question. For example, if a user agent intends to use the theme color as a background and display white text over it, it might use a darker variant of the theme color in that part of the UI, to ensure adequate contrast.

color-scheme

To aid user agents in rendering the page background with the desired color scheme immediately (rather than waiting for all CSS in

the page to load), a p165 'color-scheme' value can be provided in a meta element.

The value must be a string that matches the syntax for the CSS 'color-scheme' property value, and will be cascaded with the color-scheme declarations for the document root element as described below.

There must not be more than one p165 p166 meta element with its name attribute value set to an ASCII case-insensitive match for

color-scheme p169 per document.

Example

The following declaration indicates that the page is aware of and can handle a color scheme with dark background colors and light foreground colors:





To obtain a page's color-scheme, user agents must run the following steps:

1. Let p165 candidate elements be the list of all meta elements that meet the following criteria, in tree order:

◦ The element is in a document tree

◦ The element has a p166 p169 name attribute, whose value is an ASCII case-insensitive match for color-scheme

◦ The element has a p166 content attribute

2. For each element in candidate elements:

1. Let p166 parsed be the result of parsing a list of component values given the value of element 's content attribute.

2. If parsed is a valid CSS 'color-scheme' property value, then treat that value as a declaration of the CSS 'color-

scheme' p1188 property on element 's root , cascaded as a presentational hint, and return.

169

If any p165 p44 p44 p165 meta elements are inserted into the document or removed from the document , or existing meta elements have

their p166 p166 name or content attributes changed, user agents must re-run the above algorithm.

Note

Because these rules check successive elements until they find a match, an author can provide multiple such values to handle fallback for legacy user agents. Opposite to how CSS fallback works for properties, the multiple meta elements needs to be arranged with the legacy values after the newer values.



4.2.5.2 Other metadata names p17 §

0

Anyone can create and use their own extensions to the predefined set of metadata names. There is no requirement to register such extensions.

However, a new metadata name should not be created in any of the following cases:

• If either the name is a p166 URL , or the value of its accompanying content attribute is a URL; in those cases, registering it as

an p310 extension to the predefined set of link types is encouraged (rather than creating a new metadata name).

• If the name is for something expected to have processing requirements in user agents; in that case it ought to be

standardized.

Also, before creating and using a new metadata name, consulting the WHATWG Wiki MetaExtensions page is encouraged — to avoid choosing a metadata name that's already in use, and to avoid duplicating the purpose of any metadata names that are already in use, and to avoid new standardized names clashing with your chosen name. p1282 [WHATWGWIKI]

Anyone is free to edit the WHATWG Wiki MetaExtensions page at any time to add a metadata name. New metadata names can be specified with the following information: Keyword

The actual name being defined. The name should not be confusingly similar to any other defined name (e.g. differing only in case).

Brief description

A short non-normative description of what the metadata name's meaning is, including the format the value is required to be in.

Specification

A link to a more detailed description of the metadata name's semantics and requirements. It could be another page on the Wiki, or a link to an external page.

Synonyms

A list of other names that have exactly the same processing requirements. Authors should not use the names defined to be synonyms (they are only intended to allow user agents to support legacy content). Anyone may remove synonyms that are not used in practice; only names that need to be processed as synonyms for compatibility with legacy content are to be registered in this way.

Status

One of the following:

Proposed

The name has not received wide peer review and approval. Someone has proposed it and is, or soon will be, using it.

Ratified

The name has received wide peer review and approval. It has a specification that unambiguously defines how to handle pages that use the name, including when they use it in incorrect ways.

Discontinued

The metadata name has received wide peer review and it has been found wanting. Existing pages are using this metadata name, but new pages should avoid it. The "brief description" and "specification" entries will give details of what authors should use instead, if anything.

If a metadata name is found to be redundant with existing values, it should be removed and listed as a synonym for the existing value.

If a metadata name is added in the "proposed" state for a period of a month or more without being used or specified, then it may be

170

removed from the WHATWG Wiki MetaExtensions page.

If a metadata name is added with the "proposed" status and found to be redundant with existing values, it should be removed and listed as a synonym for the existing value. If a metadata name is added with the "proposed" status and found to be harmful, then it should be changed to "discontinued" status.

Anyone can change the status at any time, but should only do so in accordance with the definitions above.



4.2.5.3 Pragma directives p17 §

1

When the p165 http-equiv attribute is specified on a meta element, the element is a pragma directive.

The p171 p68 http-equiv attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.

State Keyword Notes

Content Language p171 content-language Non-conforming

Encoding declaration p172 content-type

Default style p172 default-style

Refresh p172 refresh

Set-Cookie p174 set-cookie Non-conforming

X-UA-Compatible p174 x-ua-compatible

Content security policy p174 content-security-policy

When a p165 p44 p171 meta element is inserted into the document , if its http-equiv attribute is present and represents one of the above states, then the user agent must run the algorithm appropriate for that state, as described in the following list:

Content language state p171 ( http-equiv=" content-language")

Note

This feature is non-conforming. Authors are encouraged to use the p141 lang attribute instead.

This pragma sets the pragma-set default language. Until such a pragma is successfully processed, there is no pragma-set

default language p171.

1. If the p165 p166 meta element has no content attribute, then return.

2. If the element's p166 content attribute contains a U+002C COMMA character (,) then return.

3. Let p166 input be the value of the element's content attribute.

4. Let position point at the first character of input.

5. Skip ASCII whitespace within input given position.

6. Collect a sequence of code points that are not ASCII whitespace from input given position.

7. Let candidate be the string that resulted from the previous step.

8. If candidate is the empty string, return.

9. Set the p171 pragma-set default language to candidate.

Note

If the value consists of multiple space-separated tokens, tokens after the first are ignored.



Note

This pragma is almost, but not quite, entirely unlike the HTTP ` p1278 Content-Language ` header of the same name. [HTTP]



171

Encoding declaration state p171 ( http-equiv=" content-type")

The p172 p166 Encoding declaration state is just an alternative form of setting the charset attribute: it is a character encoding

declaration p174. This state's user agent requirements are all handled by the parsing section of the specification.

For p165 p171 p172 p166 meta elements with an http-equiv attribute in the Encoding declaration state , the content attribute must have a

value that is an ASCII case-insensitive match for a string that consists of: the literal string "text/html;", optionally followed by any

number of ASCII whitespace, followed by the literal string "charset=utf-8".

A document must not contain both a p165 p171 p172 meta element with an http-equiv attribute in the Encoding declaration state and a

meta p165 p166 element with the charset attribute present.

The p172 p171 Encoding declaration state may be used in HTML documents , but elements with an http-equiv attribute in that state

must not be used in XML documents.

p171 ⚠ MDN

Default style state (http-equiv="default-style ")

This pragma sets the name of the default CSS style sheet set.

1. If the p165 p166 meta element has no content attribute, or if that attribute's value is the empty string, then return.

2. p166 Change the preferred CSS style sheet set name with the name being the value of the element's content attribute.

[CSSOM] p1276

Refresh state p171 ( http-equiv=" refresh")

This pragma acts as timed redirect.

A p115 Document object has an associated will declaratively refresh (a boolean). It is initially false.

1. If the p165 p166 meta element has no content attribute, or if that attribute's value is the empty string, then return.

2. Let p166 input be the value of the element's content attribute.

3. Run the p172 p165 p165 shared declarative refresh steps with the meta element's node document , input , and the meta element.

The p115 p165 shared declarative refresh steps , given a Document object document , string input , and optionally a meta element meta, are as follows:

1. If p172 document 's will declaratively refresh is true, then return.

2. Let position point at the first code point of input.

3. Skip ASCII whitespace within input given position.

4. Let time be 0.

5. Collect a sequence of code points that are ASCII digits from input given position, and let the result be timeString.

6. If timeString is the empty string, then:

1. If the code point in input pointed to by position is not U+002E (.), then return.

7. Otherwise, set p69 time to the result of parsing timeString using the rules for parsing non-negative integers.

8. Collect a sequence of code points that are ASCII digits and U+002E FULL STOP characters (.) from input given position.

Ignore any collected characters.

9. Let urlRecord be document's URL.

10. If position is not past the end of input, then:

1. If the code point in input pointed to by position is not U+003B (;), U+002C (,), or ASCII whitespace, then return.

2. Skip ASCII whitespace within input given position.

3. If the code point in input pointed to by position is U+003B (;) or U+002C (,), then advance position to the next

code point.

4. Skip ASCII whitespace within input given position.

11. If position is not past the end of input, then:

172

1. Let urlString be the substring of input from the code point at position to the end of the string.

2. If the code point in input pointed to by position is U+0055 (U) or U+0075 (u), then advance position to the next

code point. Otherwise, jump to the step labeled skip quotes.

3. If the code point in input pointed to by position is U+0052 (R) or U+0072 (r), then advance position to the next

code point. Otherwise, jump to the step labeled parse.

4. If the code point in input pointed to by position is U+004C (L) or U+006C (l), then advance position to the next

code point. Otherwise, jump to the step labeled parse.

5. Skip ASCII whitespace within input given position.

6. If the code point in input pointed to by position is U+003D (=), then advance position to the next code point.

Otherwise, jump to the step labeled parse.

7. Skip ASCII whitespace within input given position.

8. Skip quotes: If the code point in input pointed to by position is U+0027 (') or U+0022 ("), then let quote be that

code point, and advance position to the next code point. Otherwise, let quote be the empty string.

9. Set urlString to the substring of input from the code point at position to the end of the string.

10. If quote is not the empty string, and there is a code point in urlString equal to quote, then truncate urlString at

that code point, so that it and all subsequent code points are removed.

11. p89 Parse : Parse urlString relative to document. If that fails, return. Otherwise, set urlRecord to the resulting URL

record p89.

12. Set p172 document 's will declaratively refresh to true.

13. Perform one or more of the following steps:

◦ After the refresh has come due (as defined below), if the user has not canceled the redirect and, if meta is

given, p848 document 's active sandboxing flag set does not have the sandboxed automatic features browsing

context flag p846 p876 p814 p876 set, then navigate document 's browsing context to urlRecord , with historyHandling set

to " p876 p876 p814 replace " and the source browsing context set to document 's browsing context .

For the purposes of the previous paragraph, a refresh is said to have come due as soon as the later of the following two conditions occurs:

▪ At least p894 time seconds have elapsed since document 's completely loaded time, adjusted to take

into account user or user agent preferences.

▪ If p44 meta is given, at least time seconds have elapsed since meta was inserted into the document

document, adjusted to take into account user or user agent preferences.

Note

It is important to use document here, and not meta's node document, as that might have changed between the initial set of steps and the refresh coming due and meta is not always given (in case of the HTTP

` p1249 Refresh` header).

◦ Provide the user with an interface that, when selected, p876 p814 navigates a browsing context to urlRecord, with

document p814 p876 's browsing context as the source browsing context .

◦ Do nothing.

In addition, the user agent may, as with anything, inform the user of any and all aspects of its operation, including the state of any timers, the destinations of any timed redirects, and so forth.

For p165 p171 p172 p166 meta elements with an http-equiv attribute in the Refresh state , the content attribute must have a value consisting either of:

• just a p69 valid non-negative integer, or

• a p69 valid non-negative integer, followed by a U+003B SEMICOLON character (;), followed by one or more ASCII

whitespace, followed by a substring that is an ASCII case-insensitive match for the string "URL", followed by a U+003D

EQUALS SIGN character (=), followed by a valid URL string that does not start with a literal U+0027 APOSTROPHE (') or U+0022 QUOTATION MARK (") character.

173

In the former case, the integer represents a number of seconds before the page is to be reloaded; in the latter case the integer

represents a number of seconds before the page is to be replaced by the page at the given URL.

Example

A news organization's front page could include the following markup in the page's p154 head element, to ensure that the page automatically reloads from the server every five minutes:





Example

A sequence of pages could be used as an automated slide show by making each page refresh to the next page in the sequence, using markup such as the following:





Set-Cookie state p171 ( http-equiv=" set-cookie")

This pragma is non-conforming and has no effect.

User agents are required to ignore this pragma.

X-UA-Compatible state p171 ( http-equiv=" x-ua-compatible")

In practice, this pragma encourages Internet Explorer to more closely follow the specifications.

For p165 p171 p174 p166 meta elements with an http-equiv attribute in the X-UA-Compatible state , the content attribute must have a

value that is an ASCII case-insensitive match for the string "IE=edge".

User agents are required to ignore this pragma.

Content security policy state p171 ( http-equiv=" content-security-policy ")

This pragma p115 p1275 enforces a Content Security Policy on a Document . [CSP]

1. If the p165 p154 meta element is not a child of a head element, return.

2. If the p165 p166 meta element has no content attribute, or if that attribute's value is the empty string, then return.

3. Let policy be the result of executing Content Security Policy's parse a serialized Content Security Policy algorithm on the

meta p165 p166 element's content attribute's value, with a source of "meta", and a disposition of "enforce".

4. Remove all occurrences of the report-uri, frame-ancestors, and sandbox directives from policy.

5. Enforce the policy policy.

For p165 p171 p174 p166 meta elements with an http-equiv attribute in the Content security policy state , the content attribute must have

a value consisting of a valid Content Security Policy, but must not contain any report-uri, frame-ancestors, or sandbox

directives p166 p1275 . The Content Security Policy given in the content attribute will be enforced upon the current document. [CSP]

Example

A page might choose to mitigate the risk of cross-site scripting attacks by preventing the execution of inline JavaScript, as well as blocking all plugin content, using a policy such as the following:





There must not be more than one p165 meta element with any particular state in the document at a time.



4.2.5.4 Specifying the document's character encoding §p17

4

A character encoding declaration is a mechanism by which the character encoding used to store or transmit a document is specified.

174

The Encoding standard requires use of the UTF-8 character encoding and requires use of the "utf-8" encoding label to identify it.

Those requirements necessitate that the document's p174 character encoding declaration, if it exists, specifies an encoding label using an p174 ASCII case-insensitive match for " utf-8 ". Regardless of whether a character encoding declaration is present or not, the actual

character encoding p1277 used to encode the document must be UTF-8 . [ENCODING]

To enforce the above rules, authoring tools must default to using UTF-8 for newly-created documents.

The following restrictions also apply:

• The character encoding declaration must be serialized without the use of p1074 character references or character escapes of

any kind.

• The element containing the character encoding declaration must be serialized completely within the first 1024 bytes of the

document.

In addition, due to a number of restrictions on p165 p165 meta elements, there can only be one meta-based character encoding declaration per document.

If an p90 HTML document does not start with a BOM, and its encoding is not explicitly given by Content-Type metadata, and the document is not p363 p165 p166 an iframe srcdoc document , then the encoding must be specified using a meta element with a charset

attribute or a p165 p171 p172 meta element with an http-equiv attribute in the Encoding declaration state.

Note

A character encoding declaration is required (either in the p90 Content-Type metadata or explicitly in the file) even when all

characters are in the ASCII range, because a character encoding is needed to process non-ASCII characters entered by the user in

forms, in URLs generated by scripts, and so forth.

Using non-UTF-8 encodings can have unexpected results on form submission and URL encodings, which use the document's

character encoding by default.

If the document is p363 p174 an iframe srcdoc document , the document must not have a character encoding declaration . (In this case,

the source is already decoded, since it is part of the document that contained the p362 iframe.) In XML, the XML declaration should be used for inline character encoding information, if necessary.

Example

In HTML, to declare that the character encoding is UTF-8, the author could include the following markup near the top of the

document (in the p154 head element):



In XML, the XML declaration would be used instead, at the very top of the markup:





✔ MDN

4.2.6 The style element p17 §

5

Categories p129: ✔ MDN

Metadata content p132.

Contexts in which this element can be used p129 :

Where p132 metadata content is expected.

In a p628 p154 noscript element that is a child of a head element.

Content model p129:

Text p133 that gives a conformant style sheet.

Tag omission in text/html p129 :

Neither tag is omissible.

175

Content attributes p129:

Global attributes p137

media p176 — Applicable media

Also, the p176 p176 title attribute has special semantics on this element: CSS style sheet set name.

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLStyleElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString media;

// also has obsolete members

};

HTMLStyleElement includes LinkStyle;



The p175 p175 style element allows authors to embed CSS style sheets in their documents. The style element is one of several inputs to ✔ MDN

the styling processing model. The element does not p124 represent content for the user.

The p88 media attribute says which media the styles apply to. The value must be a valid media query list. The user agent must apply the styles when the p176 p88 media attribute's value matches the environment and the other relevant conditions apply, and must not apply them otherwise.

Note

The styles might be further limited in scope, e.g. in CSS with the use of @media blocks. This specification does not override such

further restrictions or requirements.

⚠ MDN

The default, if the p176 media attribute is omitted, is "all", meaning that by default styles apply to all media.

The p175 p175 p176 title attribute on style elements defines CSS style sheet sets . If the style element has no title attribute, then it has no title; the p140 p175 p175 title attribute of ancestors does not apply to the style element. If the style element is not in a document

tree p176 p1276 , then the title attribute is ignored. [CSSOM]

Note

The p176 p175 p160 p158 p140 title attribute on style elements, like the title attribute on link elements, differs from the global title

attribute in that a p175 style block without a title does not inherit the title of the parent element: it merely has no title.

The p175 child text content of a style element must be that of a conformant style sheet.



The user agent must run the p176 update a style block algorithm whenever one of the following conditions occur:

• The element is popped off the p1090 p1076 p1184 stack of open elements of an HTML parser or XML parser.

• The element is not on the p1090 p1076 p1184 stack of open elements of an HTML parser or XML parser, and it becomes

connected p45 p45 or disconnected.

• The element's children changed steps run.

The update a style block algorithm is as follows:

1. Let p175 element be the style element.

2. If element has an associated CSS style sheet, remove the CSS style sheet in question.

3. If p115 element 's root is neither a shadow root nor a document, then return.

4. If p1226 element 's type attribute is present and its value is neither the empty string nor an ASCII case-insensitive match for

176

" p1273 text/css", then return.

Note

In particular, a p1226 type value with parameters, such as "text/css; charset=utf-8", will cause this algorithm to return early.

5. If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed

upon the p175 p175 p1275 style element, " style ", and the style element's child text content , then return. [CSP]

6. Create a CSS style sheet with the following properties:

type

text/css p1273

owner node

element

media

The p176 media attribute of element.

Note

This is a reference to the (possibly absent at this time) attribute, rather than a copy of the attribute's current value. CSSOM defines what happens when the attribute is dynamically set, changed, or removed.

title

The p176 title attribute of element, if element is in a document tree, or the empty string otherwise.

Note

Again, this is a reference to the attribute.

alternate flag

Unset.

origin-clean flag

Set.

location

parent CSS style sheet

owner CSS rule

null

disabled flag

Left at its default value.

CSS rules

Left uninitialized.



This doesn't seem right. Presumably we should be using the element's child text content? Tracked as issue #2997.



Once the attempts to obtain the style sheet's p44 critical subresources, if any, are complete, or, if the style sheet has no critical

subresources p44, once the style sheet has been parsed and processed, the user agent must run these steps:

1. Let p175 element be the style element associated with the style sheet in question.

2. Let success be true.

3. If the attempts to obtain any of the style sheet's p44 critical subresources failed for any reason (e.g., DNS error, HTTP 404

response, a connection being prematurely closed, unsupported Content-Type), set success to false.



177

Note

Note that content-specific errors, e.g., CSS parse errors or PNG decoding errors, do not affect success.

4. p933 p939 Queue an element task on the networking task source given element and the following steps:

1. If p1271 success is true, fire an event named load at element.

2. Otherwise, p1271 fire an event named error at element.

3. If p178 element contributes a script-blocking style sheet:

1. Assert: p179 element 's node document 's script-blocking style sheet counter is greater than 0.

2. Decrement p179 element 's node document 's script-blocking style sheet counter by 1.

The element must p1162 delay the load event of the element's node document until all the attempts to obtain the style sheet's critical

subresources p44, if any, are complete.

Note

This specification does not specify a style system, but CSS is expected to be supported by most web browsers. p1275 [CSS]

The p95 media IDL attribute must reflect the content attribute of the same name.

The p1276 LinkStyle interface is also implemented by this element. [CSSOM]

Example

The following document has its stress emphasis styled as bright red text rather than italics text, while leaving titles of works and

Latin words in their default italics. It shows how using appropriate elements enables easier restyling of documents.





My favorite book





My favorite book of all time has got to be A Cat's Life. It is a book by P. Rahmel that talks about the Felis Catus in modern human society.





4.2.7 Interactions of styling and scripting p17 §

8

If the style sheet referenced no other resources (e.g., it was an internal style sheet given by a p175 style element with no @import rules), then the style rules must be p42 immediately made available to script; otherwise, the style rules must only be made available to script once the p931 p934 event loop reaches its update the rendering step.

An element p115 p1076 p1184 el in the context of a Document of an HTML parser or XML parser contributes a script-blocking style sheet if all of the following conditions are true:

• p115 el was created by that Document's parser.

• p175 p158 el is either a style element or a link element that was an external resource link that contributes to the styling

processing model p307 when the el was created by the parser.

• If the p158 p160 p88 el is a link element, it's media attribute's value matches the environment.

178

• el's style sheet was enabled when the element was created by the parser.

• The last time the p931 p934 p115 event loop reached step 1 , el 's root was that Document .

• The user agent hasn't given up on loading that particular style sheet yet. A user agent may give up on loading a style sheet

at any time.

Note

Giving up on a style sheet before the style sheet loads, if the style sheet eventually does still load, means that the script might end up operating with incorrect information. For example, if a style sheet sets the color of an element to green, but a script that inspects the resulting style is executed before the sheet is loaded, the script will find that the element is black (or whatever the default color is), and might thus make poor choices (e.g., deciding to use black as the color elsewhere on the page, instead of green). Implementers have to balance the likelihood of a script using incorrect information with the performance impact of doing nothing while waiting for a slow network request to finish.



It is expected that counterparts to the above rules also apply to <?xml-stylesheet?> PIs and HTTP `Link` headers. However, this has not yet been thoroughly investigated.



A p115 Document has a script-blocking style sheet counter, which is a number, initially 0.

A p115 p179 Document has a style sheet that is blocking scripts if its script-blocking style sheet counter is greater than 0, or if that

Document p115 p814 p817 has a non-null browsing context whose container document is non-null and has a script-blocking style sheet

counter p179 greater than 0.

A p115 p179 Document has no style sheet that is blocking scripts if it does not have a style sheet that is blocking scripts as defined in the previous paragraph.



✔ MDN

4.3 Sections p17 §

9



✔ MDN

4.3.1 The body element p17 §

9

Categories p129: ✔ MDN

Sectioning root p200 .

Contexts in which this element can be used p129 :

As the second element in an p153 html element.

Content model p129:

Flow content p132 .

Tag omission in text/html p129 :

A p179 p1066 p179 body element's start tag can be omitted if the element is empty, or if the first thing inside the body element is not

ASCII whitespace p1075 p179 p165 p158 p614 or a comment , except if the first thing inside the body element is a meta , link , script,

style p175 p630 , or template element.

A p179 p1067 p179 p1075 body element's end tag can be omitted if the body element is not immediately followed by a comment.

Content attributes p129:

Global attributes p137

onafterprint p950

onbeforeprint p950

onbeforeunload p950

onhashchange p950

onlanguagechange p950

onmessage p950

onmessageerror p950

onoffline p950

ononline p950

onpagehide p950

179

onpageshow p950

onpopstate p950

onrejectionhandled p950

onstorage p950

onunhandledrejection p950

onunload p950

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLBodyElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};

HTMLBodyElement includes WindowEventHandlers;



The p179 p124 body element represents the contents of the document.

In conforming documents, there is only one p179 p119 body element. The document.body IDL attribute provides scripts with easy access to a document's p179 body element.

Note

Some DOM operations (for example, parts of the p797 p119 drag and drop model) are defined in terms of " the body element ". This

refers to a particular element in the DOM, as per the definition of the term, and not any arbitrary p179 body element.

The p179 p943 p941 p828 body element exposes as event handler content attributes a number of the event handlers of the Window object. It also mirrors their p942 event handler IDL attributes .

The p941 p828 p950 event handlers of the Window object named by the Window-reflecting body element event handler set, exposed on the

body p179 p941 p44 element, replace the generic event handlers with the same names normally supported by HTML elements.

Example

Thus, for example, a bubbling p1271 p119 p115 error event dispatched on a child of the body element of a Document would first trigger

the p950 p943 p153 onerror event handler content attributes of that element, then that of the root html element, and only then would it

trigger the p950 p943 p179 onerror event handler content attribute on the body element. This is because the event would bubble from

the target, to the p179 p153 p115 p828 p941 p179 body , to the html , to the Document , to the Window , and the event handler on the body is

watching the p828 p179 p179 Window not the body . A regular event listener attached to the body using addEventListener(), however,

would be run when the event bubbled through the p179 p828 body and not when it reaches the Window object.



Example

This page updates an indicator to show whether or not the user is online:





Online or offline?





180

onoffline="update(false)"

onload="update(navigator.onLine)">



You are: (Unknown)





4.3.2 The article element §

p18 ✔ MDN

1

Categories p129:

Flow content p132 .

Sectioning content p132 .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p132 sectioning content is expected.

Content model p129:

Flow content p132 .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p125 HTMLElement .

The p181 p124 article element represents a complete, or self-contained, composition in a document, page, application, or site and that is, in principle, independently distributable or reusable, e.g. in syndication. This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment, an interactive widget or gadget, or any other independent item of content.

When p181 p181 article elements are nested, the inner article elements represent articles that are in principle related to the contents of the outer article. For instance, a blog entry on a site that accepts user-submitted comments could represent the comments as

article p181 p181 elements nested within the article element for the blog entry.

Author information associated with an p181 p199 p181 article element (q.v. the address element) does not apply to nested article elements.

Note

When used specifically with content to be redistributed in syndication, the p181 article element is similar in purpose to the entry

element in Atom. p1275 [ATOM]



Note

The schema.org microdata vocabulary can be used to provide the publication date for an p181 article element, using one of the

CreativeWork subtypes.

When the main content of the page (i.e. excluding footers, headers, navigation blocks, and sidebars) is all one single self-contained composition, that content may be marked with an p181 article, but it is technically redundant in that case (since it's self-evident that the page is a single composition, as it is a single document).

Example

This example shows a blog post using the p181 article element, with some schema.org annotations:

181





The Very First Rule of Life





3 days ago





If there's a microphone anywhere near you, assume it's hot and sending whatever you're saying to the world. Seriously.

...





Show comments...





Here is that same blog post, but showing some of the comments:





The Very First Rule of Life





3 days ago





If there's a microphone anywhere near you, assume it's hot and sending whatever you're saying to the world. Seriously.

...





Comments





Posted by:





15 minutes ago





Yeah! Especially when talking about your lobbyist friends!





Posted by:





5 minutes ago





Hey, you have the same first name as me.





Notice the use of footer to give the information for each comment (such as who wrote it and when): the footer element

can appear at the start of its section when appropriate, such as in this case. (Using header in this case wouldn't be wrong

either; it's mostly a matter of authoring preference.)



Example

In this example, article elements are used to host widgets on a portal page. The widgets are implemented as customized

built-in elements in order to get specific styling and scripted behavior.





eHome Portal





Stocks





Stock Value Delta





News





✔ MDN





Categories :

Flow content .

Sectioning content .

Palpable content .

Contexts in which this element can be used :

Where sectioning content is expected.

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The section element represents a generic section of a document or application. A section, in this context, is a thematic grouping of content, typically with a heading.

Example

Examples of sections would be chapters, the various tabbed pages in a tabbed dialog box, or the numbered sections of a thesis. A

web site's home page could be split into sections for an introduction, news items, and contact information.





Note

Authors are encouraged to use the article element instead of the section element when it would make sense to syndicate

the contents of the element.



Note

The section element is not a generic container element. When an element is needed only for styling purposes or as a

convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section

element is appropriate only if the element's contents would be listed explicitly in the document's outline.



Example

In the following example, we see an article (part of a larger web page) about apples, containing two short sections.





Apples





Tasty, delicious fruit!





The apple is the pomaceous fruit of the apple tree.





Red Delicious





These bright red apples are the most common found in many supermarkets.





Granny Smith





These juicy, green apples make a great filling for

apple pies.





Notice how the use of section means that the author can use h1 elements throughout, without having to worry about

whether a particular section is at the top level, the second level, the third level, and so on.



Example

Here is a graduation programme with two sections, one for the list of people graduating, and one for the description of the

ceremony. (The markup in this example features an uncommon style sometimes used to minimize the amount of inter-element

whitespace .)





>

>

>Graduation Ceremony Summer 2022

>

>

>

>Graduation

>

>

>Ceremony

>

>Opening Procession

>

>Speech by Validactorian

>

>Speech by Class President

>

>Presentation of Diplomas

>



>Closing Speech by Headmaster

>

>

>

>Graduates

>

>

>Molly Carpenter

>

>Anastasia Luccio

>

>Ebenezar McCoy

>

>Karrin Murphy

>

>Thomas Raith

>

>Susan Rodriguez

>

>

>

>



Example

In this example, a book author has marked up some sections as chapters and some as appendices, and uses CSS to style the

headers in these two classes of section differently.





My Book





A sample with not much content





Published by Dummy Publicorp Ltd.





My First Chapter





This is the first of my chapters. It doesn't say much.

But it has two paragraphs!





It Continues: The Second Chapter





Bla dee bla, dee bla dee bla. Boom.





Chapter Three: A Further Example





It's not like a battle between brightness and earthtones would go unnoticed.





But it might ruin my story.





Appendix A: Overview of Examples





These are demonstrations.





Appendix B: Some Closing Remarks





Hopefully this long example shows that you can style sections, so long as they are used to indicate actual sections.





✔ MDN





Categories :

Flow content .

Sectioning content .

Palpable content .

Contexts in which this element can be used :

Where sectioning content is expected.

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The nav element represents a section of a page that links to other pages or to parts within the page: a section with navigation links.

Note

Not all groups of links on a page need to be in a nav element — the element is primarily intended for sections that consist of

major navigation blocks. In particular, it is common for footers to have a short list of links to various pages of a site, such as the

terms of service, the home page, and a copyright page. The footer element alone is sufficient for such cases; while a nav

element can be used in such cases, it is usually unnecessary.



Note

User agents (such as screen readers) that are targeted at users who can benefit from navigation information being omitted in the

initial rendering, or who can benefit from navigation information being immediately available, can use this element as a way to

determine what content on the page to initially skip or provide on request (or both).



Example

In the following example, there are two nav elements, one for primary navigation around the site, and one for secondary

navigation around the page itself.





The Wiki Center Of Exampland





Home





Current Events



...more...





Demos in Exampland





Written by A. N. Other.





Public demonstrations





Demolitions



...more...





Public demonstrations





...more...





Demolitions





...more...





...more...





Edit | Delete | Rename





© copyright 1998 Exampland Emperor





Example

In the following example, the page has several places where links are present, but only one of those places is considered a

navigation section.





Wake up sheeple!





News-

Blog-

Forums





Last Modified:





Navigation





Index of all articles





Things sheeple need to wake up for today





Sheeple we have managed to wake





My Day at the Beach





Today I went to the beach and had a lot of fun.



...more content...





Posted Thursday.





...more blog posts...





Copyright ©





About-

Privacy Policy-

Contact Us





You can also see microdata annotations in the above example that use the schema.org vocabulary to provide the publication date

and other metadata about the blog post.



Example

A nav element doesn't have to contain a list, it can contain other kinds of content as well. In this navigation block, links are

provided in prose:





Navigation





You are on my home page. To the north lies my blog, from whence the sounds of battle can be heard. To the east you can see a large mountain, upon which many

href="/school">school papers are littered. Far up thus mountain you can spy a little figure who appears to be me, desperately

scribbling a thesis.





To the west are several exits. One fun-looking exit is labeled

href="https://games.example.com/">"games". Another more boring-looking exit is labeled

href="https://isp.example.net/">ISP™.





To the south lies a dark and dank contacts page. Cobwebs cover its disused entrance, and at one point you see a rat run quickly out of the page.





Example

In this example, nav is used in an email application, to let the user switch folders:





Folders





Inbox





Sent





Drafts





Trash





Customers





✔ MDN





Categories :

Flow content .

Sectioning content .

Palpable content .

Contexts in which this element can be used :

Where sectioning content is expected.

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The aside element represents a section of a page that consists of content that is tangentially related to the content around the

aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.

The element can be used for typographical effects like pull quotes or sidebars, for advertising, for groups of nav elements, and for other content that is considered separate from the main content of the page.

Note

It's not appropriate to use the aside element just for parentheticals, since those are part of the main flow of the document.



Example

The following example shows how an aside is used to mark up background material on Switzerland in a much longer news story on

Europe.





Switzerland





Switzerland, a land-locked country in the middle of geographic Europe, has not joined the geopolitical European Union, though it is a signatory to a number of European treaties.





Example

The following example shows how an aside is used to mark up a pull quote in a longer article.

...



He later joined a large company, continuing on the same work. I love my job. People ask me what I do for fun when I'm not at work. But I'm paid to do my hobby, so I never know what to answer. Some people wonder what they would do if they didn't have to work... but I know what I would do, because I was unemployed for a year, and I filled that time doing exactly what I do now.





People ask me what I do for fun when I'm not at work. But I'm



paid to do my hobby, so I never know what to answer.





Of course his work — or should that be hobby? —

isn't his only passion. He also enjoys other pleasures.



...



Example

The following extract shows how aside can be used for blogrolls and other side content on a blog:





My wonderful blog





My tagline





My blogroll





Example Blog





Archives





My last post





My first post





Twitter Feed





I'm on vacation, writing my blog.





I'm going to go on vacation soon.





My last post





This is my last post.





Permalink





My first post





This is my first post.





Posting





While I'm thinking about it, I wanted to say something about posting. Posting is fun!





Permalink





Archives-

About me-

Copyright





Categories : ✔ MDN

Flow content .

Heading content .

Palpable content .

Contexts in which this element can be used :

As a child of an hgroup element.

Where heading content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLHeadingElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



These elements represent headings for their sections.

The semantics and meaning of these elements are defined in the section on headings and sections.

These elements have a rank given by the number in their name. The h1 element is said to have the highest rank, the h6 element has the lowest rank, and two elements with the same name have equal rank.

Example



As far as their respective document outlines (their heading and section structures) are concerned, these two snippets are

semantically equivalent:





Let's call it a draw(ing surface)





Diving in





Simple shapes





Canvas coordinates





Canvas coordinates diagram





Paths





Let's call it a draw(ing surface)





Diving in





Simple shapes





Canvas coordinates





Canvas coordinates diagram





Paths





Authors might prefer the former style for its terseness, or the latter style for its convenience in the face of heavy editing; which is

best is purely an issue of preferred authoring style.

The two styles can be combined, for compatibility with legacy tools while still future-proofing for when that compatibility is no

longer needed. This third snippet again has the same outline as the previous two:





Let's call it a draw(ing surface)





Diving in





Simple shapes





Canvas coordinates





Canvas coordinates diagram





Paths





✔ MDN





Categories :

Flow content .

Heading content .

Palpable content .

Contexts in which this element can be used :

Where heading content is expected.

Content model :

One or more h1 , h2 , h3 , h4 , h5 , h6 elements, optionally intermixed with script-supporting elements.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The hgroup element represents the heading of a section, which consists of all the h1 – h6 element children of the

hgroup element. The element is used to group a set of h1 – h6 elements when the heading has multiple levels, such as subheadings, alternative titles, or taglines.

The rank of an hgroup element is the rank of the highest-ranked h1 – h6 element descendant of the hgroup element, if there are any such elements, or otherwise the same as for an h1 element (the highest rank). Other h1 – h6 elements of

heading content in the hgroup element indicate subheadings or subtitles or (secondary) alternative titles.

The section on headings and sections defines how hgroup elements are assigned to individual sections.

Example

Here are some examples of valid headings.





The reality dysfunction





Space is not the only void





Dr. Strangelove





Or: How I Learned to Stop Worrying and Love the Bomb





The point of using hgroup in these examples is to prevent the h2 element (which acts as a secondary title) from creating a

separate section of its own in any outline and to instead cause the contents of the h2 to be shown in rendered output from

the outline algorithm in some way to indicate that it is not the title of a separate section but instead just a secondary title in a

group of titles.

How a user agent exposes such multi-level headings in user interfaces (e.g. in tables of contents or search results) is left open to

implementers, as it is a user interface issue. The first example above could be rendered as:

The reality dysfunction: Space is not the only void

Alternatively, it could look like this:

The reality dysfunction (Space is not the only void)





In interfaces where a title can be rendered on multiple lines, it could be rendered as follows, maybe with the first line in a bigger

font size:

The reality dysfunction

Space is not the only void



Example

The following two examples show ways in which two h1 headings could be used within an hgroup element to group the US

and UK names for the same movie.





The Avengers





Avengers Assemble





Avengers Assemble





The Avengers





The first example above shows how the movie names might be grouped in a publication in the US, with the US name The Avengers

as the (primary) title, and the UK name Avengers Assemble as the (secondary) alternative title. The second example above shows

how the movie names might be grouped in a publication in the UK, with the UK name as the (primary) title, and the US name as

the (secondary) alternative title.

In both cases it is important to note the use of the hgroup element to group the two titles indicates that the titles are not

equivalent; instead the first h1 gives the (primary) title while the second gives the (secondary) alternative title. Even though

both the title and alternative title are marked up with h1 elements, in a rendered view of output from the outline algorithm,

the second h1 in the hgroup will be shown in some way that clearly indicates it is secondary; for example:

In a US publication:

The Avengers (Avengers Assemble)

In a UK publication:

Avengers Assemble (The Avengers)



Example

In the following example, an hgroup element is used to mark up a two-level heading in a wizard-style dialog box:





Wallet Setup





Configure your Wallet funding source





Your Wallet can be used to buy wands at the merchant in town, to buy potions from travelling salesmen you may find in the dungeons, and to pay for mercenaries.

We support two payment sources:





Credit Card

Name on card: Name">



Card number:

placeholder="6331 1019 9999 0016">



Expiry Date:

placeholder="2020-02">



Security Code:



placeholder="246">





Checking Account





Name on account:

Routing number:

Account number:





← Back

Next →





✔ MDN





Categories :

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Flow content , but with no header or footer element descendants.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

If the nearest ancestor sectioning content or sectioning root element is the body element: for authors; for

implementers.

Otherwise: for authors; for implementers.

DOM interface :

Uses HTMLElement .

The header element represents a group of introductory or navigational aids.

Note

A header element is intended to usually contain the section's heading (an h1 – h6 element or an hgroup element), but

this is not required. The header element can also be used to wrap a section's table of contents, a search form, or any relevant

logos.



Example

Here are some sample headers. This first one is for a game:





Welcome to...





Voidwars!





The following snippet shows how the element can be used to mark up a specification's header:





Fullscreen API





Living Standard — Last Updated 19 October 2015





Participate:





GitHub whatwg/fullscreen

Commits:





GitHub whatwg/fullscreen/

commits





Note

The header element is not sectioning content; it doesn't introduce a new section.



Example

In this example, the page has a page heading given by the h1 element, and two subsections whose headings are given by h2

elements. The content after the header element is still part of the last subsection started in the header element, because

the header element doesn't take part in the outline algorithm.





Little Green Guys With Guns





Games





Forum





Download





Important News


To play today's games you will need to update your client.





Games





You have three active games:



...



✔ MDN





Categories :

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Flow content , but with no header or footer element descendants.

Tag omission in text/html :

Neither tag is omissible.





Content attributes :

Global attributes

Accessibility considerations :

If the nearest ancestor sectioning content or sectioning root element is the body element: for authors; for

implementers.

Otherwise: for authors; for implementers.

DOM interface :

Uses HTMLElement .

The footer element represents a footer for its nearest ancestor sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like.

When the footer element contains entire sections, they represent appendices, indexes, long colophons, verbose license agreements, and other such content.

Note

Contact information for the author or editor of a section belongs in an address element, possibly itself inside a footer.

Bylines and other information that could be suitable for both a header or a footer can be placed in either (or neither). The

primary purpose of these elements is merely to help the author write self-explanatory markup that is easy to maintain and style;

they are not intended to impose specific structures on authors.

Footers don't necessarily have to appear at the end of a section, though they usually do.

When the nearest ancestor sectioning content or sectioning root element is the body element, then it applies to the whole page.

Note

The footer element is not sectioning content; it doesn't introduce a new section.



Example

Here is a page with two footers, one at the top and one at the bottom, with the same content:





Back to index...





Lorem ipsum





The ipsum of all lorems





A dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla

pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.





Back to index...





Example

Here is an example which shows the footer element being used both for a site-wide footer and for a section footer.





The Ramblings of a Scientist





The Ramblings of a Scientist





Episode 15





Download video.





Published on 2009/10/21 at 6:26pm





My Favorite Trains





I love my trains. My favorite train of all time is a Köf.

It is fun to see them pull some coal cars because they look so dwarfed in comparison.





Published on 2009/09/15 at 2:54pm





Credits —

Terms of Service —

Blog Index





Copyright © 2009 Gordon Freeman





Example

Some site designs have what is sometimes referred to as "fat footers" — footers that contain a lot of material, including images,

links to other articles, links to pages for sending feedback, special offers... in some ways, a whole "front page" in the footer.

This fragment shows the bottom of a page on a site with a "fat footer":

...





Articles





Go to the gym with our somersaults class! Our teacher Jim takes you through the paces

in this two-part article. Part

1 · Part 2





Tired of walking on the edge of a clif? Our guest writer Lara shows you how to bumble

your way through the bars. Read more...





The chips are down, now all that's left is a potato. What can you do with it?

href="articles/crisps/1">Read more...





About us...





Send feedback!





Sitemap





Copyright © 2015 The Snacker —

Terms of Service





Categories :

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Flow content , but with no heading content descendants, no sectioning content descendants, and no header,

footer , or address element descendants.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The address element represents the contact information for its nearest article or body element ancestor. If that is the

body element , then the contact information applies to the document as a whole.

Example

For example, a page at the W3C web site related to HTML might include the following contact information:





Dave Raggett,

Arnaud Le Hors,

contact persons for the W3C HTML Activity





The address element must not be used to represent arbitrary addresses (e.g. postal addresses), unless those addresses are in fact the relevant contact information. (The p element is the appropriate element for marking up postal addresses in general.) The address element must not contain information other than contact information.

Example

For example, the following is non-conforming use of the address element:



Last Modified: 1999/12/24 23:37:50





Typically, the address element would be included along with other information in a footer element.

The contact information for a node node is a collection of address elements defined by the first applicable entry from the following list:





↪ If node is an article element

↪ If node is a body element

The contact information consists of all the address elements that have node as an ancestor and do not have another

body or article element ancestor that is a descendant of node.

↪ If node has an ancestor element that is an article element

↪ If node has an ancestor element that is a body element

The contact information of node is the same as the contact information of the nearest article or body element ancestor, whichever is nearest.

↪ If node 's node document has a body element

The contact information of node is the same as the contact information of the body element of the Document .

↪ Otherwise

There is no contact information for node.

User agents may expose the contact information of a node to the user, or use it for other purposes, such as indexing sections based on the sections' contact information.

Example

In this example the footer contains contact information and a copyright notice.





For more details, contact

John Smith.





© copyright 2038 Example Corp.





The h1 – h6 elements and the hgroup element are headings.

The first element of heading content in an element of sectioning content represents the heading for that section. Subsequent headings of equal or higher rank start new (implied) sections, headings of lower rank start implied subsections that are part of the previous one. In both cases, the element represents the heading of the implied section.

Certain elements are said to be sectioning roots , including blockquote and td elements. These elements can have their own outlines, but the sections and headings inside these elements do not contribute to the outlines of their ancestors.

blockquote , body , details , dialog , fieldset , figure , td

Sectioning content elements are always considered subsections of their nearest ancestor sectioning root or their nearest ancestor element of sectioning content , whichever is nearest, regardless of what implied sections other headings may have created.

Example

For the following fragment:





Foo





Bar





Bla





Baz





Quux





Thud





Grunt





...the structure would be:

1. Foo (heading of explicit body section, containing the "Grunt" paragraph)

1. Bar (heading starting implied section, containing a block quote and the "Baz" paragraph) 2. Quux (heading starting implied section with no content other than the heading itself)

3. Thud (heading of explicit section section)

Notice how the section ends the earlier implicit section so that a later paragraph ("Grunt") is back at the top level.

Sections may contain headings of any rank , but authors are strongly encouraged to either use only h1 elements, or to use elements of the appropriate rank for the section's nesting level.

Authors are also encouraged to explicitly wrap sections in elements of sectioning content , instead of relying on the implicit sections generated by having multiple headings in one element of sectioning content .

Example

For example, the following is correct:





Apples





Apples are fruit.





Taste





They taste lovely.





Sweet





Red apples are sweeter than green ones.





Color





Apples come in various colors.





However, the same document would be more clearly expressed as:





Apples





Apples are fruit.





Taste





They taste lovely.





Sweet





Red apples are sweeter than green ones.





Color





Apples come in various colors.





Both of the documents above are semantically identical and would produce the same outline in compliant user agents.

This third example is also semantically identical, and might be easier to maintain (e.g. if sections are often moved around in



editing):





Apples





Apples are fruit.





Taste





They taste lovely.





Sweet





Red apples are sweeter than green ones.





Color





Apples come in various colors.





This final example would need explicit style rules to be rendered well in legacy browsers. Legacy browsers without CSS support

would render all the headings as top-level headings.



4.3.11.1 Creating an outline



This section defines an algorithm for creating an outline for a sectioning content element or a sectioning root element. It is defined in terms of a walk over the nodes of a DOM tree, in tree order, with each node being visited when it is entered and when it is exited during the walk.

The outline for a sectioning content element or a sectioning root element consists of a list of one or more potentially nested

sections . The element for which an outline is created is said to be the outline's owner.

A section is a container that corresponds to some nodes in the original DOM tree. Each section can have one heading associated with it, and can contain any number of further nested sections. The algorithm for the outline also associates each node in the DOM tree with a particular section and potentially a heading. (The sections in the outline aren't section elements, though some may correspond to such elements — they are merely conceptual sections.) Example

The following markup fragment:





HTML





Living Standard — Last Updated 12 August 2016





Some intro to the document.





Table of contents





...





First section





Some intro to the first section.





...results in the following outline being created for the body node (and thus the entire document):

1. Section created for body node.

Associated with heading

... consisting of primary heading





HTML


and secondary heading Living Standard — Last Updated 12 August 2016


. Also associated with the paragraph Some intro to the document.

(though it likely would not be shown in a rendered view of the outline).



Nested sections:

1. Section implied for first h2 element.

Associated with heading





Table of contents


.

Also associated with the ordered list

...

(though it likely would not be shown in a rendered view of the outline).

No nested sections.

2. Section implied for second h2 element.

Associated with heading





First section


.

Also associated with the paragraph

Some intro to the first section.

(though it likely would not be shown in a rendered view of the outline).

No nested sections.

The following image shows what a rendered view of the outline might look like.





The algorithm that must be followed during a walk of a DOM subtree rooted at a sectioning content element or a sectioning root

element to determine that element's outline is as follows:

1. Let current outline target be null. (It holds the element whose outline is being created.)

2. Let current section be null. (It holds a pointer to a section , so that elements in the DOM can all be associated with a

section.)

3. Create a stack to hold elements, which is used to handle nesting. Initialize this stack to empty.

4. Walk over the DOM in tree order , starting with the sectioning content element or sectioning root element at the root of

the subtree for which an outline is to be created, and trigger the first relevant step below for each element as the walk enters and exits it.

↪ When exiting an element, if that element is the element at the top of the stack

Note

The element being exited is a heading content element or an element with a hidden attribute.

Pop that element from the stack.

↪ If the top of the stack is a heading content element or an element with a hidden attribute

Do nothing.

↪ When entering an element with a hidden attribute

Push the element being entered onto the stack. (This causes the algorithm to skip that element and any descendants of the element.)

↪ When entering a sectioning content element

Run these steps:

1. If current outline target is not null, then:

1. If the current section has no heading, create an implied heading and let that be the heading for

the current section.

2. Push current outline target onto the stack.

2. Let current outline target be the element that is being entered.

3. Let current section be a newly created section for the current outline target element.



4. Associate current outline target with current section.

5. Let there be a new outline for the new current outline target, initialized with just the new current section

as the only section in the outline.

↪ When exiting a sectioning content element, if the stack is not empty

Run these steps:

1. If the current section has no heading, create an implied heading and let that be the heading for the current

section.

2. Pop the top element from the stack, and let the current outline target be that element.

3. Let current section be the last section in the outline of the current outline target element.

4. Append the outline of the sectioning content element being exited to the current section. (This does

not change which section is the last section in the outline .)

↪ When entering a sectioning root element

Run these steps:

1. If current outline target is not null, push current outline target onto the stack.

2. Let current outline target be the element that is being entered.

3. Let current outline target's parent section be current section.

4. Let current section be a newly created section for the current outline target element.

5. Let there be a new outline for the new current outline target, initialized with just the new current section

as the only section in the outline.

↪ When exiting a sectioning root element, if the stack is not empty

Run these steps:

1. If the current section has no heading, create an implied heading and let that be the heading for the current

section.

2. Let current section be current outline target's parent section.

3. Pop the top element from the stack, and let the current outline target be that element.

↪ When exiting a sectioning content element or a sectioning root element (when the stack is empty)

Note

The current outline target is the element being exited, and it is the sectioning content element or a sectioning

root element at the root of the subtree for which an outline is being generated.

If the current section has no heading, create an implied heading and let that be the heading for the current section.

Skip to the next step in the overall set of steps. (The walk is over.)

↪ When entering a heading content element

If the current section has no heading, let the element being entered be the heading for the current section.

Note

If the element being entered is an hgroup element, that hgroup as a whole is a multi-level heading for the

current section , with the highest-ranked h1 – h6 descendant of the hgroup providing the primary

heading for the current section , and with other h1 – h6 descendants of the hgroup providing secondary headings for the current section.

Otherwise, if the element being entered has a rank equal to or higher than the heading of the last section of the

outline of the current outline target , or if the heading of the last section of the outline of the current outline

target is an implied heading, then create a new section and append it to the outline of the current outline target element, so that this new section is the new last section of that outline. Let current section be that new section.



Let the element being entered be the new heading for the current section.

Otherwise, run these substeps:

1. Let candidate section be current section.

2. Heading loop : If the element being entered has a rank lower than the rank of the heading of the

candidate section , then create a new section , and append it to candidate section. (This does not change which section is the last section in the outline.) Let current section be this new section. Let the element being entered be the new heading for the current section. Abort these substeps.

3. Let new candidate section be the section that contains candidate section in the outline of current

outline target.

4. Let candidate section be new candidate section.

5. Return to the step labeled heading loop.

Push the element being entered onto the stack. (This causes the algorithm to skip any descendants of the element.)

Note

Recall that h1 has the highest rank, and h6 has the lowest rank.

↪ Otherwise

Do nothing.

In addition, whenever the walk exits a node, after doing the steps above, if the node is not associated with a section yet,

associate the node with the section current section.

5. Associate all non-element nodes that are in the subtree for which an outline is being created with the section with which

their parent element is associated.

6. Associate all nodes in the subtree with the heading of the section with which they are associated, if any.

The tree of sections created by the algorithm above, or a proper subset thereof, must be used when generating document outlines, for example when generating tables of contents.

The outline created for the body element of a Document is the outline of the entire document.

When creating an interactive table of contents, entries should jump the user to the relevant sectioning content element, if the

section was created for a real element in the original document, or to the relevant heading content element, if the section in the tree was generated for a heading in the above process.

Note

Selecting the first section of the document therefore always takes the user to the top of the document, regardless of where the

first heading in the body is to be found.

The outline depth of a heading content element associated with a section section is the number of sections that are ancestors of section in the outermost outline that section finds itself in when the outlines of its Document's elements are created, plus 1. The outline depth of a heading content element not associated with a section is 1.

User agents should provide default headings for sections that do not have explicit section headings.

Example

Consider the following snippet:





Home





Hello world.





My cat is cute.





Although it contains no headings, this snippet has three sections: a document (the body ) with two subsections (a nav and an

aside ). A user agent could present the outline as follows:

1. Untitled document

1. Navigation

2. Sidebar

These default headings ("Untitled document", "Navigation", "Sidebar") are not specified by this specification, and might vary with

the user's language, the page's language, the user's preferences, the user agent implementer's preferences, etc.



Note

The following JavaScript function shows how the tree walk could be implemented. The root argument is the root of the tree to walk

(either a sectioning content element or a sectioning root element), and the enter and exit arguments are callbacks that are

called with the nodes as they are entered and exited. [JAVASCRIPT]

function (root, enter, exit) {

var node = root;

start: while (node) {

enter(node);

if (node.firstChild) {

node = node.firstChild;

continue start;

}

while (node) {

exit(node);

if (node == root) {

node = null;

} else if (node.nextSibling) {

node = node.nextSibling;

continue start;

} else {

node = node.parentNode;

}

}

}

}



4.3.11.2 Sample outlines



This section is non-normative.

Example

The following document shows a straight-forward application of the outline algorithm. First, here is the document, which is a

book with very short chapters and subsections:





The Tax Book (all in one page)





The Tax Book





Earning money





Earning money is good.





Getting a job





To earn money you typically need a job.





Spending money





Spending is what money is mainly used for.





Cheap things





Buying cheap things often not cost-effective.





Expensive things





The most expensive thing is often not the most cost-effective either.





Investing money





You can lend your money to other people.





Losing money





If you spend money or invest money, sooner or later you will lose money.





Poor judgement





Usually if you lose money it's because you made a mistake.



This book would form the following outline:

1. The Tax Book

1. Earning money

1. Getting a job

2. Spending money

1. Cheap things

2. Expensive things

3. Investing money

4. Losing money

1. Poor judgement

Notice that the title element does not participate in the outline.



Example

Here is a similar document, but this time using section elements to get the same effect:





The Tax Book (all in one page)





The Tax Book





Earning money





Earning money is good.





Getting a job





To earn money you typically need a job.





Spending money





Spending is what money is mainly used for.





Cheap things





Buying cheap things often not cost-effective.





Expensive things





The most expensive thing is often not the most cost-effective either.





Investing money





You can lend your money to other people.





Losing money





If you spend money or invest money, sooner or later you will lose money.





Poor judgement





Usually if you lose money it's because you made a mistake.





This book would form the same outline:

1. The Tax Book

1. Earning money

1. Getting a job

2. Spending money

1. Cheap things

2. Expensive things

3. Investing money

4. Losing money

1. Poor judgement



Example

A document can contain multiple top-level headings:





Alphabetic Fruit





Apples





Pomaceous.





Bananas





Edible.





Carambola





Star.



This would form the following simple outline consisting of three top-level sections:

1. Apples

2. Bananas

3. Carambola

Effectively, the body element is split into three.



Example

Mixing both the h1 – h6 model and the section / h1 model can lead to some unintuitive results.

Consider for example the following, which is just the previous example but with the contents of the (implied) body wrapped in a

section :





Alphabetic Fruit





Apples





Pomaceous.





Bananas





Edible.





Carambola





Star.





The resulting outline would be:

1. (untitled page)

1. Apples

2. Bananas



3. Carambola

This result is described as unintuitive because it results in three subsections even though there's only one section element.

Effectively, the section is split into three, just like the implied body element in the previous example.

(In this example, " (untitled page) " is the implied heading for the body element, since it has no explicit heading.)



Example

Headings never rise above other sections. Thus, in the following example, the first h1 does not actually describe the page

header; it describes the header for the second half of the page:





Feathers on The Site of Encyclopedic Knowledge





A plea from our caretakers





Please, we beg of you, send help! We're stuck in the server room!





Feathers





Epidermal growths.



The resulting outline would be:

1. (untitled page)

1. A plea from our caretakers

2. Feathers



Example

Thus, when an article element starts with a nav block and only later has its heading, the result is that the nav block is

not part of the same section as the rest of the article in the outline. For instance, take this document:





We're adopting a child! — Ray's blog





Ray's blog





Yesterday;

Last week;

Last month





We're adopting a child!





As of today, Janine and I have signed the papers to become the proud parents of baby Diane! We've been looking forward to this day for weeks.





The resulting outline would be:

1. Ray's blog

1. Untitled article

1. Untitled navigation section

2. We're adopting a child!

Also worthy of note in this example is that the header element has no effect whatsoever on the document outline.



Example



The hgroup element can be used for subheadings. For example:





Chronotype: CS Student





The morning





06:00 to 12:00





We sleep.





The afternoon





12:00 to 18:00





We study.





Additional Commentary





Because not all this is necessarily true





Ok it's almost certainly not true





Yeah we probably play, rather than study.





The evening





18:00 to 00:00





We play.





The night





00:00 to 06:00





We play some more.





The resulting outline would be:

1. The morning

2. The afternoon

1. Additional Commentary

3. The evening

4. The night

Exactly how this is represented by user agents, as most interface issues, is left as a matter of implementation preference, but the

key part is that the hgroup 's descendant h1 – h6 elements are what form the element's heading. Thus, the following would

be equally valid:

1. The morning — 06:00 to 12:00

2. The afternoon — 12:00 to 18:00

1. Additional Commentary — Because not all this is necessarily true — Ok it's almost certainly not true

3. The evening — 18:00 to 00:00

4. The night — 00:00 to 06:00

But so would the following:

1. The morning

2. The afternoon

1. Additional Commentary

3. The evening

4. The night

The following would also be valid, though maybe less practical in most contexts:

1. The morning

06:00 to 12:00

2. The afternoon

12:00 to 18:00

1. Additional Commentary

Because not all this is necessarily true



Ok it's almost certainly not true

3. The evening

18:00 to 00:00

4. The night

00:00 to 06:00



4.3.11.3 Exposing outlines to users



User agents are encouraged to expose page outlines to users to aid in navigation. This is especially true for non-visual media, e.g. screen readers.

However, to mitigate the difficulties that arise from authors misusing sectioning content , user agents are also encouraged to offer a mode that navigates the page using heading content alone.

Example

For instance, a user agent could map the arrow keys as follows:

Shift+← Left

Go to previous section, including subsections of previous sections

Shift+→ Right

Go to next section, including subsections of the current section

Shift+↑ Up

Go to parent section of the current section

Shift+↓ Down

Go to next section, skipping subsections of the current section

Plus in addition, the user agent could map the j and k keys to navigating to the previous or next element of heading content,

regardless of the section's outline depth and ignoring sections with no headings.





This section is non-normative.





4.3.12.1 Article or section?



This section is non-normative.

A section forms part of something else. An article is its own thing. But how does one know which is which? Mostly the real answer is "it depends on author intent".

For example, one could imagine a book with a "Granny Smith" chapter that just said "These juicy, green apples make a great filling for apple pies."; that would be a section because there'd be lots of other chapters on (maybe) other kinds of apples.

On the other hand, one could imagine a tweet or reddit comment or tumblr post or newspaper classified ad that just said "Granny Smith. These juicy, green apples make a great filling for apple pies."; it would then be articles because that was the whole thing.

A comment on an article is not part of the article on which it is commenting, therefore it is its own article.



§

✔ MDN





Categories : ✔ MDN

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

A p element's end tag can be omitted if the p element is immediately followed by an address , article ,

aside , blockquote , details , div , dl , fieldset , figcaption , figure , footer , form , h1,

h2 , h3 , h4 , h5 , h6 , header , hgroup , hr , main , menu , nav , ol , p , pre , section,

table , or ul element, or if there is no more content in the parent element and the parent element is an HTML element

that is not an a , audio , del , ins , map , noscript , or video element, or an autonomous custom

element .

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLParagraphElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The p element represents a paragraph.

Note

While paragraphs are usually represented in visual media by blocks of text that are physically separated from adjacent blocks

through blank lines, a style sheet or user agent would be equally justified in presenting paragraph breaks in a different manner, for

instance using inline pilcrows (¶).



Example



The following examples are conforming HTML fragments:



The little kitten gently seated herself on a piece of

carpet. Later in her life, this would be referred to as the time the cat sat on the mat.





Personal information





Name:

Hide from other users





Address:





There was once an example from Femley,



Whose markup was of dubious quality.



The validator complained,



So the author was pained,



To move the error from the markup to the rhyming.





The p element should not be used when a more specific element is more appropriate.

Example

The following example is technically correct:





Last modified: 2001-04-23





Author: fred@example.com





However, it would be better marked-up as:





Last modified: 2001-04-23



Author: fred@example.com





Or:





Last modified: 2001-04-23





Author: fred@example.com





Note

List elements (in particular, ol and ul elements) cannot be children of p elements. When a sentence contains a bulleted

list, therefore, one might wonder how it should be marked up.

Example





For instance, this fantastic sentence has bullets relating to

• wizards,

• faster-than-light travel, and

• telepathy,

and is further discussed below.

The solution is to realize that a paragraph , in HTML terms, is not a logical concept, but a structural one. In the fantastic

example above, there are actually five paragraphs as defined by this specification: one before the list, one for each bullet, and

one after the list.

Example

The markup for the above example could therefore be:



For instance, this fantastic sentence has bullets relating to





wizards,





faster-than-light travel, and





telepathy,





and is further discussed below.





Authors wishing to conveniently style such "logical" paragraphs consisting of multiple "structural" paragraphs can use the div

element instead of the p element.

Example

Thus for instance the above example could become the following:



For instance, this fantastic sentence has bullets relating to



wizards,





faster-than-light travel, and





telepathy,





and is further discussed below.





This example still has five structural paragraphs, but now the author can style just the div instead of having to consider each part of the example separately.



✔ MDN





Categories : ✔ MDN

Flow content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Nothing .

Tag omission in text/html :

No end tag.



Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLHRElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The hr element represents a paragraph-level thematic break, e.g. a scene change in a story, or a transition to another topic within a section of a reference book.

Example

The following fictional extract from a project manual shows two sections that use the hr element to separate topics within the

section.





Communication





There are various methods of communication. This section covers a few of the important ones used by the project.



* * *





Communication stones seem to come in pairs and have mysterious properties:





They can transfer thoughts in two directions once activated if used alone.





If used with another device, they can transfer one's

consciousness to another body.





If both stones are used with another device, the

consciousnesses switch bodies.





* * *





Radios use the electromagnetic spectrum in the meter range and longer.





* * *





Signal flares use the electromagnetic spectrum in the

nanometer range.





Food





All food at the project is rationed:





Potatoes





Two per day





Soup





One bowl per day





* * *





Cooking is done by the chefs on a set rotation.





There is no need for an hr element between the sections themselves, since the section elements and the h1 elements

imply thematic changes themselves.





Example

The following extract from Pandora's Star by Peter F. Hamilton shows two paragraphs that precede a scene change and the

paragraph that follows it. The scene change, represented in the printed book by a gap containing a solitary centered star between

the second and third paragraphs, is here represented using the hr element.



Dudley was ninety-two, in his second life, and fast approaching time for another rejuvenation. Despite his body having the physical age of a standard fifty-year-old, the prospect of a long degrading campaign within academia was one he regarded with dread. For a supposedly advanced civilization, the Intersolar Commonwealth could be appallingly backward at times, not to mention cruel.





Maybe it won't be that bad, he told himself. The lie was comforting enough to get him through the rest of the night's shift.





* * *





The Carlton AllLander drove Dudley home just after dawn. Like the astronomer, the vehicle was old and worn, but perfectly capable of doing its job. It had a cheap diesel engine, common enough on a semi-frontier world like Gralmond, although its drive array was a thoroughly modern photoneural processor. With its high suspension and deep-tread tyres it could plough along the dirt track to the observatory in all weather and seasons, including the metre-deep snow of Gralmond's winters.





Note

The hr element does not affect the document's outline .



✔ MDN





Categories : ✔ MDN

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLPreElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The pre element represents a block of preformatted text, in which structure is represented by typographic conventions rather than by elements.



Note

In the HTML syntax , a leading newline character immediately following the pre element start tag is stripped.

Some examples of cases where the pre element could be used:

• Including an email, with paragraphs indicated by blank lines, lists indicated by lines prefixed with a bullet, and so on.

• Including fragments of computer code, with structure indicated according to the conventions of that language.

• Displaying ASCII art.

Note

Authors are encouraged to consider how preformatted text will be experienced when the formatting is lost, as will be the case for

users of speech synthesizers, braille displays, and the like. For cases like ASCII art, it is likely that an alternative presentation, such

as a textual description, would be more universally accessible to the readers of the document.

To represent a block of computer code, the pre element can be used with a code element; to represent a block of computer output the pre element can be used with a samp element. Similarly, the kbd element can be used within a pre element to indicate text that the user is to enter.

Note

This element has rendering requirements involving the bidirectional algorithm.



Example

In the following snippet, a sample of computer code is presented.



This is the Panel constructor:





function Panel(element, canClose, closeHandler) {

this.element = element;

this.canClose = canClose;

this.closeHandler = function () { if (closeHandler) closeHandler() };

}





Example

In the following snippet, samp and kbd elements are mixed in the contents of a pre element to show a session of Zork I.



You are in an open field west of a big white house with a boarded front door.

There is a small mailbox here.

> open mailbox

Opening the mailbox reveals:

A leaflet.

>





Example

The following shows a contemporary poem that uses the pre element to preserve its unusual formatting, which forms an

intrinsic part of the poem itself.



maxling

it is with a heart

heavy

that i admit loss of a feline

so loved



a friend lost to the

unknown

(night)

~cdr 11dec07





✔ MDN





Categories : ✔ MDN

Flow content .

Sectioning root .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

cite — Link to the source of the quotation or more information about the edit

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLQuoteElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString cite;

};



Note

The HTMLQuoteElement interface is also used by the q element.



The blockquote element represents a section that is quoted from another source.

Content inside a blockquote must be quoted from another source, whose address, if it has one, may be cited in the cite attribute.

If the cite attribute is present, it must be a valid URL potentially surrounded by spaces. To obtain the corresponding citation link, the value of the attribute must be parsed relative to the element's node document. User agents may allow users to follow such citation links, but they are primarily intended for private use (e.g., by server-side scripts collecting statistics about a site's use of quotations), not for readers.

The content of a blockquote may be abbreviated or may have context added in the conventional manner for the text's language.

Example

For example, in English this is traditionally done using square brackets. Consider a page with the sentence "Jane ate the cracker.

She then said she liked apples and fish."; it could be quoted as follows:





[Jane] then said she liked [...] fish.





Attribution for the quotation, if any, must be placed outside the blockquote element.

Example

For example, here the attribution is given in a paragraph after the quote:





I contend that we are both atheists. I just believe in one fewer god than you do. When you understand why you dismiss all the other possible gods, you will understand why I dismiss yours.





— Stephen Roberts



The other examples below show other ways of showing attribution.

The cite IDL attribute must reflect the element's cite content attribute.

Example

Here a blockquote element is used in conjunction with a figure element and its figcaption to clearly relate a quote to

its attribution (which is not part of the quote and therefore doesn't belong inside the blockquote itself):





The truth may be puzzling. It may take some work to grapple with. It may be counterintuitive. It may contradict deeply held

prejudices. It may not be consonant with what we desperately want to be true. But our preferences do not determine what's true. We have a method, and that method helps us to reach not absolute truth, only asymptotic approaches to the truth — never there, just closer and closer, always finding vast new oceans of undiscovered possibilities. Cleverly designed experiments are the key.





Carl Sagan, in "Wonder and Skepticism", from the Skeptical Inquirer Volume 19, Issue 1 (January-February 1995)





Example

This next example shows the use of cite alongside blockquote :



His next piece was the aptly named Sonnet 130:





My mistress' eyes are nothing like the sun,



Coral is far more red, than her lips red,



...



Example

This example shows how a forum post could use blockquote to show what post a user is replying to. The article element

is used for each post, to mark up the threading.





Bacon on a crowbar





t3yw 12 points 1 hour ago I bet a narwhal would love that.





permalink





greg 8 points 1 hour ago



I bet a narwhal would love that.



Dude narwhals don't eat bacon.





permalink





t3yw 15 points 1 hour ago



I bet a narwhal would love that.



Dude narwhals don't eat bacon.





Next thing you'll be saying they don't get capes and wizard hats either!





permalink





boing-5 points 1 hour ago narwhals are worse than ceiling cat





permalink





fred 1 points 23 minutes ago I bet a narwhal would love that.



I bet they'd love to peel a banana too.





permalink





Example

This example shows the use of a blockquote for short snippets, demonstrating that one does not have to use p elements

inside blockquote elements:



He began his list of "lessons" with the following:





One should never assume that his side of

the issue will be recognized, let alone that it will

be conceded to have merits.





He continued with a number of similar points, ending with:

Finally, one should be prepared for the threat of breakdown in negotiations at any given moment and not

be cowed by the possibility.





We shall now discuss these points...



Note

Examples of how to represent a conversation are shown in a later section; it is not appropriate to use the cite and

blockquote elements for this purpose.





✔ MDN





Categories :

Flow content .

If the element's children include at least one li element: Palpable content.

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Zero or more li and script-supporting elements.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

reversed — Number the list backwards

start — Starting value of the list

type — Kind of list marker

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLOListElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean reversed;

[CEReactions] attribute long start;

[CEReactions] attribute DOMString type;

// also has obsolete members

};



The ol element represents a list of items, where the items have been intentionally ordered, such that changing the order would change the meaning of the document.

The items of the list are the li element child nodes of the ol element, in tree order .

The reversed attribute is a boolean attribute. If present, it indicates that the list is a descending list (..., 3, 2, 1). If the attribute is omitted, the list is an ascending list (1, 2, 3, ...).

The start attribute, if present, must be a valid integer . It is used to determine the starting value of the list.

An ol element has a starting value, which is an integer determined as follows:

1. If the ol element has a start attribute, then:

1. Let parsed be the result of parsing the value of the attribute as an integer.

2. If parsed is not an error, then return parsed.

2. If the ol element has a reversed attribute, then return the number of owned li elements .

3. Return 1.

The type attribute can be used to specify the kind of marker to use in the list, in the cases where that matters (e.g. because items are to be referenced by their number/letter). The attribute, if specified, must have a value that is identical to one of the characters given in the first cell of one of the rows of the following table. The type attribute represents the state given in the cell in the second column of the row whose first cell matches the attribute's value; if none of the cells match, or if the attribute is omitted, then the attribute represents the decimal state.





User agents should render the items of the list in a manner consistent with the state of the type attribute of the ol element.

Numbers less than or equal to zero should always use the decimal system regardless of the type attribute.

Note

For CSS user agents, a mapping for this attribute to the 'list-style-type' CSS property is given in the rendering section (the

mapping is straightforward: the states above have the same names as their corresponding CSS values).



Note

It is possible to redefine the default CSS list styles used to implement this attribute in CSS user agents; doing so will affect how list

items are rendered.

The reversed and type IDL attributes must reflect the respective content attributes of the same name.

The start IDL attribute must reflect the content attribute of the same name, with a default value of 1.

Note

This means that the start IDL attribute does not necessarily match the list's starting value , in cases where the start

content attribute is omitted and the reversed content attribute is specified.



Example

The following markup shows a list where the order matters, and where the ol element is therefore appropriate. Compare this

list to the equivalent list in the ul section to see an example of the same items using the ul element.



I have lived in the following countries (given in the order of when I first lived there):





Switzerland





United Kingdom





United States





Norway





Note how changing the order of the list changes the meaning of the document. In the following example, changing the relative

order of the first two items has changed the birthplace of the author:



I have lived in the following countries (given in the order of when I first lived there):





United Kingdom





Switzerland





United States





Norway





✔ MDN





Categories : ✔ MDN

Flow content .

If the element's children include at least one li element: Palpable content.



Contexts in which this element can be used :

Where flow content is expected.

Content model :

Zero or more li and script-supporting elements.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLUListElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The ul element represents a list of items, where the order of the items is not important — that is, where changing the order would not materially change the meaning of the document.

The items of the list are the li element child nodes of the ul element.

Example

The following markup shows a list where the order does not matter, and where the ul element is therefore appropriate.

Compare this list to the equivalent list in the ol section to see an example of the same items using the ol element.



I have lived in the following countries:





Norway





Switzerland





United Kingdom





United States





Note that changing the order of the list does not change the meaning of the document. The items in the snippet above are given in

alphabetical order, but in the snippet below they are given in order of the size of their current account balance in 2007, without

changing the meaning of the document whatsoever:



I have lived in the following countries:





Switzerland





Norway





United Kingdom





United States





⚠ MDN





Categories :

Flow content .

If the element's children include at least one li element: Palpable content.



Contexts in which this element can be used :

Where flow content is expected.

Content model :

Zero or more li and script-supporting elements.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLMenuElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The menu element represents a toolbar consisting of its contents, in the form of an unordered list of items (represented by li elements), each of which represents a command that the user can perform or activate.

Note

The menu element is simply a semantic alternative to ul to express an unordered list of commands (a "toolbar").



Example

In this example, a text-editing application uses a menu element to provide a series of editing commands:





Note that the styling to make this look like a conventional toolbar menu is up to the application.



✔ MDN





Categories : ✔ MDN

None.

Contexts in which this element can be used :

Inside ol elements.

Inside ul elements.

Inside menu elements.

Content model :

Flow content .

Tag omission in text/html :

An li element's end tag can be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.





Content attributes :

Global attributes

If the element is not a child of an ul or menu element: value — Ordinal value of the list item

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLLIElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute long value;

// also has obsolete members

};



The li element represents a list item. If its parent element is an ol , ul , or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other

li element.

The value attribute, if present, must be a valid integer . It is used to determine the ordinal value of the list item, when the li 's

list owner is an ol element.



Any element whose computed value of 'display' is 'list-item' has a list owner, which is determined as follows:

1. If the element is not being rendered , return null; the element has no list owner.

2. Let ancestor be the element's parent.

3. If the element has an ol , ul , or menu ancestor, set ancestor to the closest such ancestor element.

4. Return the closest inclusive ancestor of ancestor that produces a CSS box.

Note

Such an element will always exist, as at the very least the document element will always produce a CSS box.

To determine the ordinal value of each element owned by a given list owner owner, perform the following steps:

1. Let i be 1.

2. If owner is an ol element, let numbering be owner 's starting value . Otherwise, let numbering be 1.

3. Loop: If i is greater than the number of list items that owner owns , then return; all of owner 's owned list items have

been assigned ordinal values .

4. Let item be the i th of owner 's owned list items , in tree order.

5. If item is an li element that has a value attribute, then:

1. Let parsed be the result of parsing the value of the attribute as an integer.

2. If parsed is not an error, then set numbering to parsed.

6. The ordinal value of item is numbering.

7. If owner is an ol element, and owner has a reversed attribute, decrement numbering by 1; otherwise, increment

numbering by 1.

8. Increment i by 1.

9. Go to the step labeled loop.





The value IDL attribute must reflect the value of the value content attribute.

Example

The element's value IDL attribute does not directly correspond to its ordinal value ; it simply reflects the content attribute.

For example, given this list:





Item 1





Item 3





Item 4





The ordinal values are 1, 3, and 4, whereas the value IDL attributes return 0, 3, 0 on getting.



Example

The following example, the top ten movies are listed (in reverse order). Note the way the list is given a title by using a figure

element and its figcaption element.





The top 10 movies of all time





Josie and the Pussycats, 2001

Црна мачка, бели мачор, 1998

A Bug's Life, 1998





Toy Story, 1995





Monsters, Inc, 2001





Cars, 2006





Toy Story 2, 1999





Finding Nemo, 2003





The Incredibles, 2004





Ratatouille, 2007





The markup could also be written as follows, using the reversed attribute on the ol element:





The top 10 movies of all time





Josie and the Pussycats, 2001





Црна мачка, бели мачор, 1998

A Bug's Life, 1998





Toy Story, 1995





Monsters, Inc, 2001





Cars, 2006





Toy Story 2, 1999





Finding Nemo, 2003





The Incredibles, 2004





Ratatouille, 2007





Note

While it is conforming to include heading elements (e.g. h1 ) inside li elements, it likely does not convey the semantics that

the author intended. A heading starts a new section, so a heading in a list implicitly splits the list into spanning multiple sections.





✔ MDN





Categories :

Flow content .

If the element's children include at least one name-value group: Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally

intermixed with script-supporting elements.

Or: One or more div elements, optionally intermixed with script-supporting elements .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLDListElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The dl element represents an association list consisting of zero or more name-value groups (a description list). A name-value group consists of one or more names ( dt elements, possibly as children of a div element child) followed by one or more values ( dd elements, possibly as children of a div element child), ignoring any nodes other than dt and dd element children, and

dt and dd elements that are children of div element children. Within a single dl element, there should not be more than one dt element for each name.

Name-value groups may be terms and definitions, metadata topics and values, questions and answers, or any other groups of name-value data.

The values within a group are alternatives; multiple paragraphs forming part of the same value must all be given within the same

dd element.

The order of the list of groups, and of the names and values within each group, may be significant.

In order to annotate groups with microdata attributes, or other global attributes that apply to whole groups, or just for styling purposes, each group in a dl element can be wrapped in a div element. This does not change the semantics of the dl

element.

The name-value groups of a dl element dl are determined using the following algorithm. A name-value group has a name (a list of

dt elements, initially empty) and a value (a list of dd elements, initially empty).

1. Let groups be an empty list of name-value groups.

2. Let current be a new name-value group.

3. Let seenDd be false.

4. Let child be dl's first child.

5. Let grandchild be null.

6. While child is not null:

1. If child is a div element, then:



1. Let grandchild be child's first child.

2. While grandchild is not null:

1. Process dt or dd for grandchild.

2. Set grandchild to grandchild's next sibling.

2. Otherwise, process dt or dd for child.

3. Set child to child's next sibling.

7. If current is not empty, then append current to groups.

8. Return groups.

To process dt or dd for a node node means to follow these steps:

1. Let groups, current, and seenDd be the same variables as those of the same name in the algorithm that invoked these steps.

2. If node is a dt element, then:

1. If seenDd is true, then append current to groups, set current to a new name-value group, and set seenDd to false.

2. Append node to current's name.

3. Otherwise, if node is a dd element, then append node to current's value and set seenDd to true.

Note

When a name-value group has an empty list as name or value, it is often due to accidentally using dd elements in the place of

dt elements and vice versa. Conformance checkers can spot such mistakes and might be able to advise authors how to

correctly use the markup.



Example

In the following example, one entry ("Authors") is linked to two values ("John" and "Luke").





Authors





John





Luke





Editor





Frank





Example

In the following example, one definition is linked to two terms.





color





colour





A sensation which (in humans) derives from the ability of the fine structure of the eye to distinguish three differently filtered analyses of a view.





Example

The following example illustrates the use of the dl element to mark up metadata of sorts. At the end of the example, one group

has two metadata labels ("Authors" and "Editors") and two values ("Robert Rothman" and "Daniel Jackson"). This example also

uses the div element around the groups of dt and dd element, to aid with styling.





Last modified time





2004-12-23T23:33Z





Recommended update interval





60s





Authors





Editors





Robert Rothman





Daniel Jackson





Example

The following example shows the dl element used to give a set of instructions. The order of the instructions here is important

(in the other examples, the order of the blocks was not important).



Determine the victory points as follows (use the

first matching case):





If you have exactly five gold coins





You get five victory points





If you have one or more gold coins, and you have one or more silver coins

You get two victory points





If you have one or more silver coins





You get one victory point





Otherwise





You get no victory points





Example

The following snippet shows a dl element being used as a glossary. Note the use of dfn to indicate the word being defined.





Apartment, n.





An execution context grouping one or more threads with one or more COM objects.





Flat, n.





A deflated tire.





Home, n.





The user's login directory.





Example

This example uses microdata attributes in a dl element, together with the div element, to annotate the ice cream

desserts at a French restaurant.





Café ou Chocolat Liégeois





€





2 boules Café ou Chocolat, 1 boule Vanille, sause café ou chocolat, chantilly





Américaine





€





1 boule Crème brûlée, 1 boule Vanille, 1 boule Caramel, chantilly





Without the div element the markup would need to use the itemref attribute to link the data in the dd elements with the

item, as follows.





€





2 boules Café ou Chocolat, 1 boule Vanille, sause café ou chocolat, chantilly





€





1 boule Crème brûlée, 1 boule Vanille, 1 boule Caramel, chantilly





Note

The dl element is inappropriate for marking up dialogue. See some examples of how to mark up dialogue .



✔ MDN





Categories :

None.

Contexts in which this element can be used :

Before dd or dt elements inside dl elements.

Before dd or dt elements inside div elements that are children of a dl element.

Content model :

Flow content , but with no header , footer , sectioning content , or heading content descendants.

Tag omission in text/html :

A dt element's end tag can be omitted if the dt element is immediately followed by another dt element or a dd

element.

Content attributes :

Global attributes

Accessibility considerations :

For authors.



For implementers.

DOM interface :

Uses HTMLElement .

The dt element represents the term, or name, part of a term-description group in a description list ( dl element).

Note

The dt element itself, when used in a dl element, does not indicate that its contents are a term being defined, but this can

be indicated using the dfn element.



Example

This example shows a list of frequently asked questions (a FAQ) marked up using the dt element for questions and the dd

element for answers.





FAQ





What do we want?





Our data.





When do we want it?





Now.





Where is it?





We are not sure.





✔ MDN





Categories :

None.

Contexts in which this element can be used :

After dt or dd elements inside dl elements.

After dt or dd elements inside div elements that are children of a dl element.

Content model :

Flow content .

Tag omission in text/html :

A dd element's end tag can be omitted if the dd element is immediately followed by another dd element or a dt

element, or if there is no more content in the parent element.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The dd element represents the description, definition, or value, part of a term-description group in a description list ( dl element).

Example

A dl can be used to define a vocabulary list, like in a dictionary. In the following example, each entry, given by a dt with a

dfn , has several dds, showing the various parts of the definition.





happiness





/'hæ p. nes/





n.





The state of being happy.





Good fortune; success. Oh happiness! It worked!

rejoice





/ri jois'/





v.intr. To be delighted oneself.

v.tr. To cause one to be delighted.





✔ MDN





Categories :

Flow content .

Sectioning root .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

Content model :

Either: one figcaption element followed by flow content.

Or: flow content followed by one figcaption element.

Or: flow content.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The figure element represents some flow content , optionally with a caption, that is self-contained (like a complete sentence) and is typically referenced as a single unit from the main flow of the document.

Note

"Self-contained" in this context does not necessarily mean independent. For example, each sentence in a paragraph is self-

contained; an image that is part of a sentence would be inappropriate for figure, but an entire sentence made of images would

be fitting.

The element can thus be used to annotate illustrations, diagrams, photos, code listings, etc.

Note

When a figure is referred to from the main content of the document by identifying it by its caption (e.g., by figure number), it

enables such content to be easily moved away from that primary content, e.g., to the side of the page, to dedicated pages, or to

an appendix, without affecting the flow of the document.

If a figure element is referenced by its relative position, e.g., "in the photograph above" or "as the next figure shows", then

moving the figure would disrupt the page's meaning. Authors are encouraged to consider using labels to refer to figures, rather

than using such relative references, so that the page can easily be restyled without affecting the page's meaning.



The first figcaption element child of the element, if any, represents the caption of the figure element's contents. If there is no child figcaption element, then there is no caption.

A figure element's contents are part of the surrounding flow. If the purpose of the page is to display the figure, for example a photograph on an image sharing site, the figure and figcaption elements can be used to explicitly provide a caption for that figure. For content that is only tangentially related, or that serves a separate purpose than the surrounding flow, the aside element should be used (and can itself wrap a figure ). For example, a pull quote that repeats content from an article would be more appropriate in an aside than in a figure , because it isn't part of the content, it's a repetition of the content for the purposes of enticing readers or highlighting key topics.

Example

This example shows the figure element to mark up a code listing.



In listing 4 we see the primary core interface API declaration.





Listing 4. The primary core interface API declaration. interface PrimaryCore {

boolean verifyDataLine();

undefined sendData(sequence<byte> data);

undefined initSelfDestruct();

}





The API is designed to use UTF-8.





Example

Here we see a figure element to mark up a photo that is the main content of the page (as in a gallery).





Bubbles at work — My Gallery™





alt="Bubbles, sitting in his office chair, works on his

latest project intently.">



Bubbles at work





Prev — Next



Example

In this example, we see an image that is not a figure, as well as an image and a video that are. The first image is literally part of

the example's second sentence, so it's not a self-contained unit, and thus figure would be inappropriate.





Malinko's comics





This case centered on some sort of "intellectual property" infringement related to a comic (see Exhibit A). The suit started after a trailer ending with these words:





...was aired. A lawyer, armed with a Bigger Notebook, launched a preemptive strike using snowballs. A complete copy of the trailer is included with Exhibit B.





Exhibit A. The alleged rough copy comic.





Exhibit B. The Rough Copy trailer.





The case was resolved out of court.



Example

Here, a part of a poem is marked up using figure.





'Twas brillig, and the slithy toves



Did gyre and gimble in the wabe;



All mimsy were the borogoves,



And the mome raths outgrabe.





Jabberwocky (first verse). Lewis Carroll, 1832-98





Example

In this example, which could be part of a much larger work discussing a castle, nested figure elements are used to provide

both a group caption and individual captions for each figure in the group:





The castle through the ages: 1423, 1858, and 1999 respectively.



Etching. Anonymous, ca. 1423.





Oil-based paint on canvas. Maria Towle, 1858.





Film photograph. Peter Jankle, 1999. one piece.">





Example

The previous example could also be more succinctly written as follows (using title attributes in place of the nested

figure / figcaption pairs):





alt="The castle has one tower, and a tall wall around it.">



alt="The castle now has two towers and two walls.">



alt="The castle lies in ruins, the original tower all that remains in one piece.">



The castle through the ages: 1423, 1858, and 1999 respectively.





Example

The figure is sometimes referenced only implicitly from the content:





Fiscal negotiations stumble in Congress as deadline nears





Barack Obama and Harry Reid. White House press photograph.





Negotiations in Congress to end the fiscal impasse sputtered on Tuesday, leaving both chambers grasping for a way to reopen the government and raise the country's borrowing authority with a Thursday deadline drawing near.



...





✔ MDN





Categories :

None.

Contexts in which this element can be used :

As the first or last child of a figure element.

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The figcaption element represents a caption or legend for the rest of the contents of the figcaption element's parent

figure element, if any.

Example

The element can contain additional information about the source:





A duck.





Photograph courtesy of 🌟 News.





Average rent for 3-room apartments, excluding non-profit apartments Zürich’s Statistics Office — 14 November 2017





✔ MDN





Categories :

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected, but only if it is a hierarchically correct main element .

Content model :

Flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The main element represents the dominant contents of the document.

A document must not have more than one main element that does not have the hidden attribute specified.

A hierarchically correct main element is one whose ancestor elements are limited to html , body , div , form without an

accessible name , and autonomous custom elements . Each main element must be a hierarchically correct main element .

Example

In this example, the author has used a presentation where each component of the page is rendered in a box. To wrap the main

content of the page (as opposed to the header, the footer, the navigation bar, and a sidebar), the main element is used.





RPG System 17





System Eighteen





← System 17

RPXIX →





This system has no HP mechanic, so there's no healing.





Character creation





Attributes (magic, strength, agility) are purchased at the cost of one point per level.





Rolls





Each encounter, roll the dice for all your skills. If you roll more than the opponent, you

win.





Copyright © 2013





In the following example, multiple main elements are used and script is used to make navigation work without a server

roundtrip and to set the hidden attribute on those that are not current:





…





Home

About

Contact





Home




…





About




…





Contact




…





Made with ❤️ by Example 👻.



✔ MDN





Categories :

Flow content .

Palpable content .

Contexts in which this element can be used :

Where flow content is expected.

As a child of a dl element.

Content model :

If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally

intermixed with script-supporting elements.

If the element is not a child of a dl element: flow content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.



For implementers.

DOM interface :

[Exposed=Window]

interface HTMLDivElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The div element has no special meaning at all. It represents its children. It can be used with the class , lang, and

title attributes to mark up semantics common to a group of consecutive elements. It can also be used in a dl element, wrapping groups of dt and dd elements.

Note

Authors are strongly encouraged to view the div element as an element of last resort, for when no other element is suitable.

Use of more appropriate elements instead of the div element leads to better accessibility for readers and easier maintainability

for authors.



Example

For example, a blog post would be marked up using article , a chapter using section , a page's navigation aids using

nav , and a group of form controls using fieldset.

On the other hand, div elements can be useful for stylistic purposes or to wrap multiple paragraphs within a section that are all

to be annotated in a similar way. In the following example, we see div elements used as a way to set the language of two

paragraphs at once, instead of setting the language on the two paragraph elements separately:





My use of language and my cats





My cat's behavior hasn't changed much since her absence, except that she plays her new physique to the neighbors regularly, in an attempt to get pets.





My other cat, coloured black and white, is a sweetie. He followed us to the pool today, walking down the pavement with us. Yesterday he apparently visited our neighbours. I wonder if he recognises that their flat is a mirror image of ours.





Hm, I just noticed that in the last paragraph I used British English. But I'm supposed to write in American English. So I shouldn't say "pavement" or "flat" or "colour"...





I should say "sidewalk" and "apartment" and "color"!





§

✔ MDN





Categories : ✔ MDN

Flow content .

Phrasing content .

If the element has an href attribute: Interactive content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.



Content model :

Transparent , but there must be no interactive content descendant, a element descendant, or descendant with the

tabindex attribute specified.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

href — Address of the hyperlink

target — Browsing context for hyperlink navigation

download — Whether to download the resource instead of navigating to it, and its file name if so

ping — URLs to ping

rel — Relationship between the location in the document containing the hyperlink and the destination resource

hreflang — Language of the linked resource

type — Hint for the type of the referenced resource

referrerpolicy — Referrer policy for fetches initiated by the element

Accessibility considerations :

If the element has an href attribute: for authors; for implementers.

Otherwise: for authors; for implementers.

DOM interface :

[Exposed=Window]

interface HTMLAnchorElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString target;

[CEReactions] attribute DOMString download;

[CEReactions] attribute USVString ping;

[CEReactions] attribute DOMString rel;

[SameObject, PutForwards=value] readonly attribute DOMTokenList relList;

[CEReactions] attribute DOMString hreflang;

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString text;

[CEReactions] attribute DOMString referrerPolicy;

// also has obsolete members

};

HTMLAnchorElement includes HTMLHyperlinkElementUtils;



If the a element has an href attribute, then it represents a hyperlink (a hypertext anchor) labeled by its contents.

If the a element has no href attribute, then the element represents a placeholder for where a link might otherwise have been placed, if it had been relevant, consisting of just the element's contents.

The target , download , ping , rel , hreflang , type , and referrerpolicy attributes must be omitted if the

href attribute is not present.

If the itemprop attribute is specified on an a element, then the href attribute must also be specified.

Example

If a site uses a consistent navigation toolbar on every page, then the link that would normally link to the page itself could be

marked up using an a element:





Home





News





Examples





Legal





The href , target , download , ping , and referrerpolicy attributes affect what happens when users follow

hyperlinks or download hyperlinks created using the a element. The rel , hreflang , and type attributes may be used to indicate to the user the likely nature of the target resource before the user follows the link.

The activation behavior of a elements that create hyperlinks is to run the following steps:

1. If the target of the click event is an img element with an ismap attribute specified, then server-side image map

processing must be performed, as follows:

1. Let x and y be zero.

2. If the click event was a real pointing-device-triggered click event on the img element, then set x to the

distance in CSS pixels from the left edge of the image to the location of the click, and set y to the distance in CSS

pixels from the top edge of the image to the location of the click.

3. If x is negative, set x to zero.

4. If y is negative, set y to zero.

5. Let hyperlink suffix be a U+003F QUESTION MARK character, the value of x expressed as a base-ten integer using

ASCII digits, a U+002C COMMA character (,), and the value of y expressed as a base-ten integer using ASCII digits.

2. Follow the hyperlink or download the hyperlink created by the a element, as determined by the download

attribute and any expressed user preference, passing hyperlink suffix, if the steps above defined it.

For web developers (non-normative)

a . text

Same as textContent.



The IDL attributes download , ping , target , rel , hreflang , and type , must reflect the respective content attributes of the same ✔ ✔MDN MDN name.

The IDL attribute relList must reflect the rel content attribute.

The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.

The text attribute's getter must return this element's descendant text content.

The text attribute's setter must string replace all with the given value within this element.

Example

The a element can be wrapped around entire paragraphs, lists, tables, and so forth, even entire sections, so long as there is no

interactive content within (e.g., buttons or other links). This example shows how this can be used to make an entire advertising

block into a link:





Advertising





Mellblomatic 9000!





Turn all your widgets into mellbloms!





Only $9.99 plus shipping and handling.





The Mellblom Browser





Web browsing at the speed of light.





No other browser goes faster!





Example

The following example shows how a bit of script can be used to effectively make an entire row in a job listing table a hyperlink:





Position



Team



Location





Manager



Remotees



Remote





Director



Remotees



Remote





Astronaut



Architecture



Remote





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes



Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The em element represents stress emphasis of its contents.

The level of stress that a particular piece of content has is given by its number of ancestor em elements.

The placement of stress emphasis changes the meaning of the sentence. The element thus forms an integral part of the content. The precise way in which stress is used in this way depends on the language.

Example

These examples show how changing the stress emphasis changes the meaning. First, a general statement of fact, with no stress:



Cats are cute animals.



By emphasizing the first word, the statement implies that the kind of animal under discussion is in question (maybe someone is

asserting that dogs are cute):



Cats are cute animals.



Moving the stress to the verb, one highlights that the truth of the entire sentence is in question (maybe someone is saying cats are

not cute):



Cats are cute animals.



By moving it to the adjective, the exact nature of the cats is reasserted (maybe someone suggested cats were mean animals):



Cats are cute animals.



Similarly, if someone asserted that cats were vegetables, someone correcting this might emphasize the last word:



Cats are cute animals.



By emphasizing the entire sentence, it becomes clear that the speaker is fighting hard to get the point across. This kind of stress

emphasis also typically affects the punctuation, hence the exclamation mark here.



Cats are cute animals!



Anger mixed with emphasizing the cuteness could lead to markup such as:



Cats are cute animals!





Note

The em element isn't a generic "italics" element. Sometimes, text is intended to stand out from the rest of the paragraph, as if it

was in a different mood or voice. For this, the i element is more appropriate.

The em element also isn't intended to convey importance; for that purpose, the strong element is more appropriate.





Categories :

Flow content .



Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The strong element represents strong importance, seriousness, or urgency for its contents.

Importance : the strong element can be used in a heading, caption, or paragraph to distinguish the part that really matters from other parts that might be more detailed, more jovial, or merely boilerplate. (This is distinct from marking up subheadings, for which the

hgroup element is appropriate.) Example

For example, the first word of the previous paragraph is marked up with strong to distinguish it from the more detailed text in

the rest of the paragraph.

Seriousness : the strong element can be used to mark up a warning or caution notice.

Urgency : the strong element can be used to denote contents that the user needs to see sooner than other parts of the document.

The relative level of importance of a piece of content is given by its number of ancestor strong elements; each strong element increases the importance of its contents.

Changing the importance of a piece of text with the strong element does not change the meaning of the sentence.

Example

Here, the word "chapter" and the actual chapter number are mere boilerplate, and the actual name of the chapter is marked up

with strong:





Chapter 1: The Praxis




In the following example, the name of the diagram in the caption is marked up with strong, to distinguish it from boilerplate

text (before) and the description (after):



Figure 1. Ant colony dynamics. The ants in this colony are affected by the heat source (upper left) and the food source (lower right).

In this example, the heading is really "Flowers, Bees, and Honey", but the author has added a light-hearted addition to the

heading. The strong element is thus used to mark up the first part to distinguish it from the latter part.





Flowers, Bees, and Honey and other things I don't understand





Example

Here is an example of a warning notice in a game, with the various parts marked up according to how important they are:





Warning. This dungeon is dangerous.

Avoid the ducks. Take any gold you find.

Do not take any of the diamonds,

they are explosive and will destroy anything within ten meters. You have been warned.





Example

In this example, the strong element is used to denote the part of the text that the user is intended to read first.



Welcome to Remy, the reminder system.





Your tasks for today:





Turn off the oven.





Put out the trash.





Do the laundry.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The small element represents side comments such as small print.

Note

Small print typically features disclaimers, caveats, legal restrictions, or copyrights. Small print is also sometimes used for

attribution, or for satisfying licensing requirements.



Note

The small element does not "de-emphasize" or lower the importance of text emphasized by the em element or marked as

important with the strong element. To mark text as not emphasized or important, simply do not mark it up with the em or

strong elements respectively.

The small element should not be used for extended spans of text, such as multiple paragraphs, lists, or sections of text. It is only intended for short runs of text. The text of a page listing terms of use, for instance, would not be a suitable candidate for the small element: in such a case, the text is not a side comment, it is the main content of the page.



The small element must not be used for subheadings; for that purpose, use the hgroup element.

Example

In this example, the small element is used to indicate that value-added tax is not included in a price of a hotel room:

Example





Single room





199 € breakfast included, VAT not included

Double room





239 € breakfast included, VAT not included





Example

In this second example, the small element is used for a side comment in an article.



Example Corp today announced record profits for the

second quarter (Full Disclosure: Foo News is a subsidiary of Example Corp), leading to speculation about a third quarter merger with Demo Group.



This is distinct from a sidebar, which might be multiple paragraphs long and is removed from the main flow of text. In the following

example, we see a sidebar from the same article. This sidebar also has small print, indicating the source of the information in the

sidebar.





Example Corp





This company mostly creates small software and Web

sites.





The Example Corp company mission is "To provide entertainment and news on a sample basis".





Information obtained from

href="https://example.com/about.html">example.com home

page.





Example

In this last example, the small element is marked as being important small print.



Continued use of this service will result in a kiss.





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.



Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The s element represents contents that are no longer accurate or no longer relevant.

Note

The s element is not appropriate when indicating document edits; to mark a span of text as having been removed from a

document, use the del element.



Example

In this example a recommended retail price has been marked as no longer relevant as the product in question has a new sale

price.



Buy our Iced Tea and Lemonade!





Recommended retail price: $3.99 per bottle





Now selling for just $2.99 a bottle!





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The cite element represents the title of a work (e.g. a book, a paper, an essay, a poem, a score, a song, a script, a film, a TV show, a game, a sculpture, a painting, a theatre production, a play, an opera, a musical, an exhibition, a legal case report, a computer program, etc). This can be a work that is being quoted or referenced in detail (i.e. a citation), or it can just be a work that is mentioned in passing.

A person's name is not the title of a work — even if people call that person a piece of work — and the element must therefore not be used to mark up people's names. (In some cases, the b element might be appropriate for names; e.g. in a gossip article where the names of famous people are keywords rendered with a different style to draw attention to them. In other cases, if an element is really needed, the span element can be used.)





Example

This next example shows a typical use of the cite element:



My favorite book is The Reality Dysfunction by Peter F. Hamilton. My favorite comic is Pearls Before Swine by Stephan Pastis. My favorite track is Jive Samba by the Cannonball Adderley Sextet.





Example

This is correct usage:



According to the Wikipedia article HTML, as it stood in mid-February 2008, leaving attribute values unquoted is unsafe. This is obviously an over-simplification.



The following, however, is incorrect usage, as the cite element here is containing far more than the title of the work:



According to the Wikipedia article on HTML, as it stood in mid-February 2008, leaving attribute values unquoted is unsafe. This is obviously an over-simplification.





Example

The cite element is obviously a key part of any citation in a bibliography, but it is only used to mark the title:



Universal Declaration of Human Rights, United Nations, December 1948. Adopted by General Assembly resolution 217 A (III).





Note

A citation is not a quote (for which the q element is appropriate).



Example

This is incorrect usage, because cite is not for quotes:



This is wrong!, said Ian.



This is also incorrect usage, because a person is not a work:



This is still wrong!, said Ian.



The correct usage does not use a cite element:



This is correct, said Ian.



As mentioned above, the b element might be relevant for marking names as being keywords in certain kinds of documents:



And then Ian said this might be right, in a

gossip column, maybe!.





Categories :

Flow content .



Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

cite — Link to the source of the quotation or more information about the edit

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLQuoteElement .

The q element represents some phrasing content quoted from another source.

Quotation punctuation (such as quotation marks) that is quoting the contents of the element must not appear immediately before, after, or inside q elements; they will be inserted into the rendering by the user agent.

Content inside a q element must be quoted from another source, whose address, if it has one, may be cited in the cite attribute. The source may be fictional, as when quoting characters in a novel or screenplay.

If the cite attribute is present, it must be a valid URL potentially surrounded by spaces. To obtain the corresponding citation link, the value of the attribute must be parsed relative to the element's node document. User agents may allow users to follow such citation links, but they are primarily intended for private use (e.g., by server-side scripts collecting statistics about a site's use of quotations), not for readers.

The q element must not be used in place of quotation marks that do not represent quotes; for example, it is inappropriate to use the q element for marking up sarcastic statements.

The use of q elements to mark up quotations is entirely optional; using explicit quotation punctuation without q elements is just as correct.

Example

Here is a simple example of the use of the q element:



The man said Things that are impossible just take

longer. I disagreed with him.





Example

Here is an example with both an explicit citation link in the q element, and an explicit citation outside:



The W3C page About W3C says the W3C's

mission is To lead the World Wide Web to its full potential by developing protocols and guidelines that ensure long-term growth for the Web. I disagree with this mission.





Example

In the following example, the quotation itself contains a quotation:



In Example One, he writes The man



said Things that are impossible just take longer. I

disagreed with him. Well, I disagree even more!





Example

In the following example, quotation marks are used instead of the q element:



His best argument was ❝I disagree❞, which

I thought was laughable.





Example

In the following example, there is no quote — the quotation marks are used to name a word. Use of the q element in this case

would be inappropriate.



The word "ineffable" could have been used to describe the disaster resulting from the campaign's mismanagement.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content , but there must be no dfn element descendants.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Also, the title attribute has special semantics on this element: Full term or expansion of abbreviation.

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The dfn element represents the defining instance of a term. The paragraph , description list group , or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element.

Defining term : if the dfn element has a title attribute, then the exact value of that attribute is the term being defined.

Otherwise, if it contains exactly one element child node and no child Text nodes, and that child element is an abbr element with a

title attribute, then the exact value of that attribute is the term being defined. Otherwise, it is the descendant text content of the

dfn element that gives the term being defined.

If the title attribute of the dfn element is present, then it must contain only the term being defined.

Note

The title attribute of ancestor elements does not affect dfn elements.





An a element that links to a dfn element represents an instance of the term defined by the dfn element.

Example

In the following fragment, the term "Garage Door Opener" is first defined in the first paragraph, then used in the second. In both

cases, its abbreviation is what is actually displayed.



The GDO is a device that allows off-world teams to open the iris.





Teal'c activated his GDO and so Hammond ordered the iris to be opened.



With the addition of an a element, the reference can be made explicit:



The GDO is a device that allows off-world teams to open the iris.





Teal'c activated his GDO and so Hammond ordered the iris to be opened.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Also, the title attribute has special semantics on this element: Full term or expansion of abbreviation.

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else.

Example

The paragraph below contains an abbreviation marked up with the abbr element. This paragraph defines the term "Web

Hypertext Application Technology Working Group".



The

title="Web Hypertext Application Technology Working Group">WHATWG is a loose unofficial collaboration of web browser manufacturers and interested parties who wish to develop new technologies designed to allow authors to write and deploy Applications over the World Wide



Web.



An alternative way to write this would be:



The Web Hypertext Application Technology

Working Group (

title="Web Hypertext Application Technology Working Group">WHATWG) is a loose unofficial collaboration of web browser manufacturers and interested parties who wish to develop new technologies designed to allow authors to write and deploy Applications over the World Wide Web.





Example

This paragraph has two abbreviations. Notice how only one is defined; the other, with no expansion associated with it, does not use

the abbr element.



The

WHATWG started working on HTML5 in 2004.





Example

This paragraph links an abbreviation to its definition.



The

title="Web Hypertext Application Technology Working Group">WHATWG community does not have much representation from Asia.





Example

This paragraph marks up an abbreviation without giving an expansion, possibly as a hook to apply styles for abbreviations (e.g.

smallcaps).



Philip` and Dashiva both denied that they were going to get the issue counts from past revisions of the specification to backfill the WHATWG issue graph.





If an abbreviation is pluralized, the expansion's grammatical number (plural vs singular) must match the grammatical number of the contents of the element.

Example

Here the plural is outside the element, so the expansion is in the singular:



Two WGs worked on

this specification: the WHATWG and the

HTMLWG.



Here the plural is inside the element, so the expansion is in the plural:



Two WGs worked on

this specification: the WHATWG and the

HTMLWG.





Abbreviations do not have to be marked up using this element. It is expected to be useful in the following cases:

• Abbreviations for which the author wants to give expansions, where using the abbr element with a title attribute is



an alternative to including the expansion inline (e.g. in parentheses).

• Abbreviations that are likely to be unfamiliar to the document's readers, for which authors are encouraged to either mark up

the abbreviation using an abbr element with a title attribute or include the expansion inline in the text the first time the abbreviation is used.

• Abbreviations whose presence needs to be semantically annotated, e.g. so that they can be identified from a style sheet and

given specific styles, for which the abbr element can be used without a title attribute.

Providing an expansion in a title attribute once will not necessarily cause other abbr elements in the same document with the same contents but without a title attribute to behave as if they had the same expansion. Every abbr element is independent.





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

See prose.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.

The content model of ruby elements consists of one or more of the following sequences:

1. One or the other of the following:

◦ Phrasing content , but with no ruby elements and with no ruby element descendants

◦ A single ruby element that itself has no ruby element descendants

2. One or the other of the following:

◦ One or more rt elements

◦ An rp element followed by one or more rt elements, each of which is itself followed by an rp element The ruby and rt elements can be used for a variety of kinds of annotations, including in particular (though by no means limited to) those described below. For more details on Japanese Ruby in particular, and how to render Ruby for Japanese, see Requirements for Japanese Text Layout . [JLREQ]

Note

At the time of writing, CSS does not yet provide a way to fully control the rendering of the HTML ruby element. It is hoped that

CSS will be extended to support the styles described below in due course.

Mono-ruby for individual base characters in Japanese

One or more hiragana or katakana characters (the ruby annotation) are placed with each ideographic character (the base text). This is used to provide readings of kanji characters.





Example

Bannotation



Example

In this example, notice how each annotation corresponds to a single base character.

君くん子しは和わして同どうぜず。

君くん子しは和わして同どうぜず。

This example can also be written as follows, using one ruby element with two segments of base text and two annotations

(one for each) rather than two back-to-back ruby elements each with one base text segment and annotation (as in the markup above):

君くん子しは和わして同どうぜず。



Mono-ruby for compound words (jukugo)

This is similar to the previous case: each ideographic character in the compound word (the base text) has its reading given in hiragana or katakana characters (the ruby annotation). The difference is that the base text segments form a compound word rather than being separate from each other.

Example

BannotationBannotation



Example

In this example, notice again how each annotation corresponds to a single base character. In this example, each compound

word (jukugo) corresponds to a single ruby element.

The rendering here is expected to be that each annotation be placed over (or next to, in vertical text) the corresponding base character, with the annotations not overhanging any of the adjacent characters.

鬼き門もんの方ほう角がくを凝ぎ ょう視しする

鬼き門もんの方ほう角がくを凝ぎょう視しする

Jukugo-ruby

This is semantically identical to the previous case (each individual ideographic character in the base compound word has its reading given in an annotation in hiragana or katakana characters), but the rendering is the more complicated Jukugo Ruby rendering.

Example

This is the same example as above for mono-ruby for compound words. The different rendering is expected to be achieved using different styling (e.g. in CSS), and is not shown here.

鬼き門もんの方ほう角がくを凝ぎ ょう視しする



Note

For more details on Jukugo Ruby rendering , see Appendix F in the Requirements for Japanese Text Layout . [JLREQ]

Group ruby for describing meanings

The annotation describes the meaning of the base text, rather than (or in addition to) the pronunciation. As such, both the base text and the annotation can be multiple characters long.

Example



BASEannotation



Example

Here a compound ideographic word has its corresponding katakana given as an annotation.

境界面インターフェース

境界面インターフェース



Example

Here a compound ideographic word has its translation in English provided as an annotation.

編集者editor

編集者editor

Group ruby for Jukuji readings

A phonetic reading that corresponds to multiple base characters, because a one-to-one mapping would be difficult. (In English, the words "Colonel" and "Lieutenant" are examples of words where a direct mapping of pronunciation to individual letters is, in some dialects, rather unclear.)

Example

In this example, the name of a species of flowers has a phonetic reading provided using group ruby:

紫陽花あじさい

紫陽花あじさい

Text with both phonetic and semantic annotations (double-sided ruby)

Sometimes, ruby styles described above are combined.

If this results in two annotations covering the same single base segment, then the annotations can just be placed back to back.

Example

BASEannotation 1annotation 2



Example

BaaAaaSaaEaa



Example

In this contrived example, some symbols are given names in English and French.



♥ Heart Cœur

☘ Shamrock Trèfle

✶ Star Étoile





In more complication situations such as following examples, a nested ruby element is used to give the inner annotations, and

then that whole ruby is then given an annotation at the "outer" level.

Example

BaAnStEnannotation



Example

Here both a phonetic reading and the meaning are given in ruby annotations. The annotation on the nested ruby element

gives a mono-ruby phonetic annotation for each base character, while the annotation in the rt element that is a child of the

outer ruby element gives the meaning using hiragana.

東とう南なんたつみの方角

東とう南なんたつみの方角



Example

This is the same example, but the meaning is given in English instead of Japanese:

東とう南なんSoutheastの方角

東とう南なんSoutheastの方角



Within a ruby element that does not have a ruby element ancestor, content is segmented and segments are placed into three categories: base text segments, annotation segments, and ignored segments. Ignored segments do not form part of the document's semantics (they consist of some inter-element whitespace and rp elements, the latter of which are used for legacy user agents that do not support ruby at all). Base text segments can overlap (with a limit of two segments overlapping any one position in the DOM, and with any segment having an earlier start point than an overlapping segment also having an equal or later end point, and any segment have a later end point than an overlapping segment also having an equal or earlier start point). Annotation segments correspond to rt elements. Each annotation segment can be associated with a base text segment, and each base text segment can have annotation segments associated with it. (In a conforming document, each base text segment is associated with at least one annotation segment, and each annotation segment is associated with one base text segment.) A ruby element represents the

union of the segments of base text it contains, along with the mapping from those base text segments to annotation segments.

Segments are described in terms of DOM ranges; annotation segment ranges always consist of exactly one element. [DOM]

At any particular time, the segmentation and categorization of content of a ruby element is the result that would be obtained from running the following algorithm:

1. Let base text segments be an empty list of base text segments, each potentially with a list of base text subsegments.

2. Let annotation segments be an empty list of annotation segments, each potentially being associated with a base text

segment or subsegment.

3. Let root be the ruby element for which the algorithm is being run.

4. If root has a ruby element ancestor, then jump to the step labeled end.

5. Let current parent be root.

6. Let index be 0.

7. Let start index be null.

8. Let parent start index be null.

9. Let current base text be null.

10. Start mode: If index is equal to or greater than the number of child nodes in current parent, then jump to the step labeled

end mode.

11. If the index th node in current parent is an rt or rp element, jump to the step labeled annotation mode.

12. Set start index to the value of index.

13. Base mode : If the index th node in current parent is a ruby element, and if current parent is the same element as root,

then push a ruby level and then jump to the step labeled start mode.

14. If the index th node in current parent is an rt or rp element, then set the current base text and then jump to the

step labeled annotation mode.

15. Increment index by one.



16. Base mode post-increment: If index is equal to or greater than the number of child nodes in current parent, then jump to the

step labeled end mode.

17. Jump back to the step labeled base mode.

18. Annotation mode : If the index th node in current parent is an rt element, then push a ruby annotation and jump to the

step labeled annotation mode increment.

19. If the index th node in current parent is an rp element, jump to the step labeled annotation mode increment.

20. If the index th node in current parent is not a Text node, or is a Text node that is not inter-element whitespace , then jump

to the step labeled base mode.

21. Annotation mode increment: Let lookahead index be index plus one.

22. Annotation mode white-space skipper: If lookahead index is equal to the number of child nodes in current parent then jump

to the step labeled end mode.

23. If the lookahead index th node in current parent is an rt element or an rp element, then set index to lookahead index

and jump to the step labeled annotation mode.

24. If the lookahead index th node in current parent is not a Text node, or is a Text node that is not inter-element whitespace ,

then jump to the step labeled base mode (without further incrementing index , so the inter-element whitespace seen so far becomes part of the next base text segment).

25. Increment lookahead index by one.

26. Jump to the step labeled annotation mode white-space skipper.

27. End mode : If current parent is not the same element as root , then pop a ruby level and jump to the step labeled base

mode post-increment.

28. End : Return base text segments and annotation segments . Any content of the ruby element not described by segments in

either of those lists is implicitly in an ignored segment.

When the steps above say to set the current base text, it means to run the following steps at that point in the algorithm:

1. Let text range be a DOM range whose start is the boundary point (current parent, start index) and whose end is the

boundary point (current parent, index).

2. Let new text segment be a base text segment described by the range annotation range.

3. Add new text segment to base text segments.

4. Let current base text be new text segment.

5. Let start index be null.

When the steps above say to push a ruby level, it means to run the following steps at that point in the algorithm:

1. Let current parent be the indexth node in current parent.

2. Let index be 0.

3. Set saved start index to the value of start index.

4. Let start index be null.

When the steps above say to pop a ruby level, it means to run the following steps at that point in the algorithm:

1. Let index be the position of current parent in root.

2. Let current parent be root.

3. Increment index by one.

4. Set start index to the value of saved start index.

5. Let saved start index be null.

When the steps above say to push a ruby annotation, it means to run the following steps at that point in the algorithm:



1. Let rt be the rt element that is the indexth node of current parent.

2. Let annotation range be a DOM range whose start is the boundary point (current parent, index) and whose end is the

boundary point (current parent, index plus one) (i.e. that contains only rt).

3. Let new annotation segment be an annotation segment described by the range annotation range.

4. If current base text is not null, associate new annotation segment with current base text.

5. Add new annotation segment to annotation segments.

Example

In this example, each ideograph in the Japanese text 漢字 is annotated with its reading in hiragana.

...

漢かん字じ

...

This might be rendered as:





Example

In this example, each ideograph in the traditional Chinese text 漢字 is annotated with its bopomofo reading.

漢ㄏㄢˋ字ㄗˋ

This might be rendered as:





Example

In this example, each ideograph in the simplified Chinese text 汉字 is annotated with its pinyin reading.

...汉hàn字zì...

This might be rendered as:





Example

In this more contrived example, the acronym "HTML" has four annotations: one for the whole acronym, briefly describing what it is,

one for the letters "HT" expanding them to "Hypertext", one for the letter "M" expanding it to "Markup", and one for the letter "L"

expanding it to "Language".





HTHypertextMMarkupLLanguage An abstract language for describing documents and applications





✔ MDN





Categories :

None.

Contexts in which this element can be used :

As a child of a ruby element.

Content model :

Phrasing content .

Tag omission in text/html :

An rt element's end tag can be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The rt element marks the ruby text component of a ruby annotation. When it is the child of a ruby element, it doesn't

represent anything itself, but the ruby element uses it as part of determining what it represents.

An rt element that is not a child of a ruby element represents the same thing as its children.



✔ MDN





Categories :

None.

Contexts in which this element can be used :

As a child of a ruby element, either immediately before or immediately after an rt element.

Content model :

Text .

Tag omission in text/html :

An rp element's end tag can be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .



The rp element can be used to provide parentheses or other content around a ruby text component of a ruby annotation, to be shown by user agents that don't support ruby annotations.

An rp element that is a child of a ruby element represents nothing. An rp element whose parent element is not a ruby

element represents its children.

Example

The example above, in which each ideograph in the text 漢字 is annotated with its phonetic reading, could be expanded to use

rp so that in legacy user agents the readings are in parentheses:

...

漢（かん）字（じ） ...

In conforming user agents the rendering would be as above, but in user agents that do not support ruby, the rendering would be:

... 漢（かん）字（じ）...



Example

When there are multiple annotations for a segment, rp elements can also be placed between the annotations. Here is another

copy of an earlier contrived example showing some symbols with names given in English and French, but this time with rp

elements as well:



♥: Heart, Cœur. ☘: Shamrock, Trèfle. ✶: Star, Étoile.

This would make the example render as follows in non-ruby-capable user agents:

♥: Heart, Cœur. ☘: Shamrock, Trèfle. ✶: Star, Étoile.



✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

value — Machine-readable value

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]



interface HTMLDataElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString value;

};



The data element represents its contents, along with a machine-readable form of those contents in the value attribute.

The value attribute must be present. Its value must be a representation of the element's contents in a machine-readable format.

Note

When the value is date- or time-related, the more specific time element can be used instead.

The element can be used for several purposes.

When combined with microformats or the microdata attributes defined in this specification, the element serves to provide both a machine-readable value for the purposes of data processors, and a human-readable value for the purposes of rendering in a web browser. In this case, the format to be used in the value attribute is determined by the microformats or microdata vocabulary in use.

The element can also, however, be used in conjunction with scripts in the page, for when a script has a literal value to store alongside a human-readable value. In such cases, the format to be used depends only on the needs of the script. (The data-* attributes can ✔ MDN also be useful in such situations.) The value IDL attribute must reflect the content attribute of the same name.

Example

Here, a short table has its numeric values encoded using the data element so that the table sorting JavaScript library can

provide a sorting mechanism on each column despite the numbers being presented in textual form in one column and in a

decomposed form in another.





Game Corporations Map Size





1830 Eight 19+74 hexes (93

total)





1856 Eleven 12+87 hexes (99

total)





1870 Ten 4+145 hexes (149

total)





✔ MDN





Categories : ✔ MDN

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

If the element has a datetime attribute: Phrasing content.

Otherwise: Text , but must match requirements described in prose below.





Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

datetime — Machine-readable value

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLTimeElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString dateTime;

};



The time element represents its contents, along with a machine-readable form of those contents in the datetime attribute. The kind of content is limited to various kinds of dates, times, time-zone offsets, and durations, as described below.

The datetime attribute may be present. If present, its value must be a representation of the element's contents in a machine-readable format.

A time element that does not have a datetime content attribute must not have any element descendants.

The datetime value of a time element is the value of the element's datetime content attribute, if it has one, otherwise the

child text content of the time element.

The datetime value of a time element must match one of the following syntaxes.

A valid month string

Example

2011-11



A valid date string

Example

2011-11-18



A valid yearless date string

Example

11-18



A valid time string

Example

14:54



Example

14:54:39





Example

14:54:39.929



A valid local date and time string

Example

2011-11-18T14:54



Example

2011-11-18T14:54:39



Example

2011-11-18T14:54:39.929



Example

2011-11-18 14:54



Example

2011-11-18 14:54:39



Example

2011-11-18 14:54:39.929



Note

Times with dates but without a time zone offset are useful for specifying events that are observed at the same specific time in each time zone, throughout a day. For example, the 2020 new year is celebrated at 2020-01-01 00:00 in each time zone, not at the same precise moment across all time zones. For events that occur at the same time across all time zones, for example a

videoconference meeting, a valid global date and time string is likely more useful.

A valid time-zone offset string

Example

Z



Example

+0000



Example

+00:00



Example

-0800



Example

-08:00



Note

For times without dates (or times referring to events that recur on multiple dates), specifying the geographic location that controls the time is usually more useful than specifying a time zone offset, because geographic locations change time zone offsets with daylight saving time. In some cases, geographic locations even change time zone, e.g. when the boundaries of those time zones are redrawn, as happened with Samoa at the end of 2011. There exists a time zone database that describes

the boundaries of time zones and what rules apply within each such zone, known as the time zone database . [TZDATABASE]

A valid global date and time string

Example

2011-11-18T14:54Z



Example

2011-11-18T14:54:39Z



Example

2011-11-18T14:54:39.929Z



Example

2011-11-18T14:54+0000



Example

2011-11-18T14:54:39+0000



Example

2011-11-18T14:54:39.929+0000



Example

2011-11-18T14:54+00:00



Example

2011-11-18T14:54:39+00:00



Example

2011-11-18T14:54:39.929+00:00



Example

2011-11-18T06:54-0800



Example

2011-11-18T06:54:39-0800



Example

2011-11-18T06:54:39.929-0800





Example

2011-11-18T06:54-08:00



Example

2011-11-18T06:54:39-08:00



Example

2011-11-18T06:54:39.929-08:00



Example

2011-11-18 14:54Z



Example

2011-11-18 14:54:39Z



Example

2011-11-18 14:54:39.929Z



Example

2011-11-18 14:54+0000



Example

2011-11-18 14:54:39+0000



Example

2011-11-18 14:54:39.929+0000



Example

2011-11-18 14:54+00:00



Example

2011-11-18 14:54:39+00:00



Example

2011-11-18 14:54:39.929+00:00



Example

2011-11-18 06:54-0800



Example

2011-11-18 06:54:39-0800





Example

2011-11-18 06:54:39.929-0800



Example

2011-11-18 06:54-08:00



Example

2011-11-18 06:54:39-08:00



Example

2011-11-18 06:54:39.929-08:00



Note

Times with dates and a time zone offset are useful for specifying specific events, or recurring virtual events where the time is not anchored to a specific geographic location. For example, the precise time of an asteroid impact, or a particular meeting in a series of meetings held at 1400 UTC every day, regardless of whether any particular part of the world is observing daylight saving time or not. For events where the precise time varies by the local time zone offset of a specific geographic location, a

valid local date and time string combined with that geographic location is likely more useful.

A valid week string

Example

2011-W47



Four or more ASCII digits, at least one of which is not U+0030 DIGIT ZERO (0)

Example

2011



Example

0001



A valid duration string

Example

PT4H18M3S



Example

4h 18m 3s



The machine-readable equivalent of the element's contents must be obtained from the element's datetime value by using the following algorithm:

1. If parsing a month string from the element's datetime value returns a month, that is the machine-readable

equivalent; return.

2. If parsing a date string from the element's datetime value returns a date, that is the machine-readable equivalent;

return.

3. If parsing a yearless date string from the element's datetime value returns a yearless date, that is the machine-



readable equivalent; return.

4. If parsing a time string from the element's datetime value returns a time, that is the machine-readable equivalent;

return.

5. If parsing a local date and time string from the element's datetime value returns a local date and time, that is the

machine-readable equivalent; return.

6. If parsing a time-zone offset string from the element's datetime value returns a time-zone offset, that is the

machine-readable equivalent; return.

7. If parsing a global date and time string from the element's datetime value returns a global date and time, that is the

machine-readable equivalent; return.

8. If parsing a week string from the element's datetime value returns a week, that is the machine-readable equivalent;

return.

9. If the element's datetime value consists of only ASCII digits, at least one of which is not U+0030 DIGIT ZERO (0), then the

machine-readable equivalent is the base-ten interpretation of those digits, representing a year; return.

10. If parsing a duration string from the element's datetime value returns a duration, that is the machine-readable

equivalent; return.

11. There is no machine-readable equivalent.

Note

The algorithms referenced above are intended to be designed such that for any arbitrary string s, only one of the algorithms

returns a value. A more efficient approach might be to create a single algorithm that parses all these data types in one pass;

developing such an algorithm is left as an exercise to the reader.



The dateTime IDL attribute must reflect the element's datetime content attribute.

Example

The time element can be used to encode dates, for example in microformats. The following shows a hypothetical way of

encoding an event using a variant on hCalendar that uses the time element:





http://www.web2con.com/ :

October 5-7,

at the





Example

Here, a fictional microdata vocabulary based on the Atom vocabulary is used with the time element to mark up a blog post's

publication date.





Big tasks





Published two days ago. Today, I went out and bought a bike for my kid.





Example

In this example, another article's publication date is marked up using time, this time using the schema.org microdata

vocabulary:





Small tasks





Published yesterday. I put a bike bell on her bike.





Example

In the following snippet, the time element is used to encode a date in the ISO8601 format, for later processing by a script:



Our first date was a Saturday.



In this second snippet, the value includes a time:



We stopped talking at 5am the next morning.



A script loaded by the page (and thus privy to the page's internal convention of marking up dates and times using the time

element) could scan through the page and look at all the time elements therein to create an index of dates and times.



Example

For example, this element conveys the string "Friday" with the additional semantic that the 18th of November 2011 is the meaning

that corresponds to "Friday":

Today is Friday.



Example

In this example, a specific time in the Pacific Standard Time timezone is specified:

Your next meeting is at 3pm.





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The code element represents a fragment of computer code. This could be an XML element name, a file name, a computer program, or any other string that a computer would recognize.



There is no formal way to indicate the language of computer code being marked up. Authors who wish to mark code elements with the language used, e.g. so that syntax highlighting scripts can use the right rules, can use the class attribute, e.g. by adding a class prefixed with "language-" to the element.

Example

The following example shows how the element can be used in a paragraph to mark up element names and computer code,

including punctuation.



The code element represents a fragment of computer code.





When you call the activate() method on the

robotSnowman object, the eyes glow.





The example below uses the begin keyword to indicate the start of a statement block. It is paired with an end keyword, which is followed by the . punctuation character (full stop) to indicate the end of the program.





Example

The following example shows how a block of code could be marked up using the pre and code elements.



var i: Integer;

begin

i := 1;

end.





A class is used in that example to indicate the language used.



Note

See the pre element for more details.



✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The var element represents a variable. This could be an actual variable in a mathematical expression or programming context,



an identifier representing a constant, a symbol identifying a physical quantity, a function parameter, or just be a term used as a placeholder in prose.

Example

In the paragraph below, the letter "n" is being used as a variable in prose:



If there are n pipes leading to the ice

cream factory then I expect at least n

flavors of ice cream to be available for purchase!





For mathematics, in particular for anything beyond the simplest of expressions, MathML is more appropriate. However, the var element can still be used to refer to specific variables that are then mentioned in MathML expressions.

Example

In this example, an equation is shown, with a legend that references the variables in the equation. The expression itself is marked

up with MathML, but the variables are mentioned in the figure's legend using var.





a

=



b2

+

c2





Using Pythagoras' theorem to solve for the hypotenuse a of a triangle with sides b and c





Example

Here, the equation describing mass-energy equivalence is used in a sentence, and the var element is used to mark the

variables and constants in that equation:



Then she turned to the blackboard and picked up the chalk. After a few moment's thought, she wrote E = m c2. The teacher looked pleased.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.





Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The samp element represents sample or quoted output from another program or computing system.

Note

See the pre and kbd elements for more details.



Note

This element can be contrasted with the output element, which can be used to provide immediate output in a web application.



Example

This example shows the samp element being used inline:



The computer said Too much cheese in tray

two but I didn't know what that meant.





Example

This second example shows a block of sample output from a console program. Nested samp and kbd elements allow for the

styling of specific elements of the sample output using a style sheet. There's also a few parts of the samp that are annotated

with even more detailed markup, to enable very precise styling. To achieve this, span elements are used.



ssh demo.example.com Last login: Tue Apr 12 09:10:17 2005 from mowmow.example.com on pts/1 Linux demo 2.6.10-grsec+gg3+e+fhs6b+nfs+gr0501+++p3+c4a+gr2b-reslog-v6.189 #1 SMP Tue Feb 1 11:22:36 PST 2005 i686 unknown





Example

This third example shows a block of input and its respective output. The example uses both code and samp elements.





console.log(2.3 + 2.4) 4.699999999999999





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .



Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The kbd element represents user input (typically keyboard input, although it may also be used to represent other input, such as voice commands).

When the kbd element is nested inside a samp element, it represents the input as it was echoed by the system.

When the kbd element contains a samp element, it represents input based on system output, for example invoking a menu item.

When the kbd element is nested inside another kbd element, it represents an actual key or other single unit of input as appropriate for the input mechanism.

Example

Here the kbd element is used to indicate keys to press:



To make George eat an apple, press Shift+F3



In this second example, the user is told to pick a particular menu item. The outer kbd element marks up a block of input, with

the inner kbd elements representing each individual step of the input, and the samp elements inside them indicating that the

steps are input based on something being displayed by the system, in this case menu labels:



To make George eat an apple, select

File|Eat Apple...





Such precision isn't necessary; the following is equally fine:



To make George eat an apple, select File | Eat Apple...





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes





Accessibility considerations :

The sub element: for authors; for implementers.

The sup element: for authors; for implementers.

DOM interface :

Use HTMLElement.

The sup element represents a superscript and the sub element represents a subscript.

These elements must be used only to mark up typographical conventions with specific meanings, not for typographical presentation for presentation's sake. For example, it would be inappropriate for the sub and sup elements to be used in the name of the LaTeX document preparation system. In general, authors should use these elements only if the absence of those elements would change the meaning of the content.

In certain languages, superscripts are part of the typographical conventions for some abbreviations.

Example



Their names are

and .





The sub element can be used inside a var element, for variables that have subscripts.

Example

Here, the sub element is used to represent the subscript that identifies the variable in a family of variables:



The coordinate of the ith point is

(xi, yi). For example, the 10th point has coordinate

(x10, y10).





Mathematical expressions often use subscripts and superscripts. Authors are encouraged to use MathML for marking up mathematics, but authors may opt to use sub and sup if detailed mathematical markup is not desired. [MATHML]

Example

E=mc2

f(x, n) = log4xn





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes



Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The i element represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose in a manner indicating a different quality of text, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, transliteration, a thought, or a ship name in Western texts.

Terms in languages different from the main text should be annotated with lang attributes (or, in XML, lang attributes in the XML

namespace).

Example

The examples below show uses of the i element:



The Felis silvestris catus is cute.

The term prose content is defined above.





There is a certain je ne sais quoi in the air.



In the following example, a dream sequence is marked up using i elements.



Raymond tried to sleep.





The ship sailed away on Thursday, he

dreamt. The ship had many people aboard, including a beautiful princess called Carey. He watched her, day-in, day-out, hoping she would notice him, but she never did.





Finally one night he picked up the courage to speak with her—





Raymond woke with a start as the fire alarm rang out.





Authors can use the class attribute on the i element to identify why the element is being used, so that if the style of a particular use (e.g. dream sequences as opposed to taxonomic terms) is to be changed at a later date, the author doesn't have to go through the entire document (or series of related documents) annotating each use.

Authors are encouraged to consider whether other elements might be more applicable than the i element, for instance the em

element for marking up stress emphasis, or the dfn element to mark up the defining instance of a term.

Note

Style sheets can be used to format i elements, just like any other element can be restyled. Thus, it is not the case that content

in i elements will necessarily be italicized.



✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.



Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.

Example

The following example shows a use of the b element to highlight key words without marking them up as important:



The frobonitor and barbinator components are fried.





Example

In the following example, objects in a text adventure are highlighted as being special by use of the b element.



You enter a small room. Your sword glows

brighter. A rat scurries past the corner wall.





Example

Another case where the b element is appropriate is in marking up the lede (or lead) sentence or paragraph. The following

example shows how a BBC article about kittens adopting a rabbit as their own could be marked up:





Kittens 'adopted' by pet rabbit





Six abandoned kittens have found an

unexpected new mother figure — a pet rabbit.





Veterinary nurse Melanie Humble took the three-week-old kittens to her Aberdeen home.



[...]



As with the i element, authors can use the class attribute on the b element to identify why the element is being used, so that if the style of a particular use is to be changed at a later date, the author doesn't have to go through annotating each use.

The b element should be used as a last resort when no other element is more appropriate. In particular, headings should use the

h1 to h6 elements, stress emphasis should use the em element, importance should be denoted with the strong element, and text marked or highlighted should use the mark element.

Example

The following would be incorrect usage:



WARNING! Do not frob the barbinator!



In the previous example, the correct element to use would have been strong , not b .



Note

Style sheets can be used to format b elements, just like any other element can be restyled. Thus, it is not the case that content

in b elements will necessarily be boldened.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The u element represents a span of text with an unarticulated, though explicitly rendered, non-textual annotation, such as labeling the text as being a proper name in Chinese text (a Chinese proper name mark), or labeling the text as being misspelt.

In most cases, another element is likely to be more appropriate: for marking stress emphasis, the em element should be used; for marking key words or phrases either the b element or the mark element should be used, depending on the context; for marking book titles, the cite element should be used; for labeling text with explicit textual annotations, the ruby element should be used; for technical terms, taxonomic designation, transliteration, a thought, or for labeling ship names in Western texts, the i element should be used.

Note

The default rendering of the u element in visual presentations clashes with the conventional rendering of hyperlinks

(underlining). Authors are encouraged to avoid using the u element where it could be confused for a hyperlink.



Example

In this example, a u element is used to mark a word as misspelt:



The see is full of fish.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.





Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity.

Example

This example shows how the mark element can be used to bring attention to a particular part of a quotation:



Consider the following quote:





Look around and you will find, no-one's really

colour blind.





As we can tell from the spelling of the word, the person writing this quote is clearly not American.



(If the goal was to mark the element as misspelt, however, the u element, possibly with a class, would be more appropriate.)



Example

Another example of the mark element is highlighting parts of a document that are matching some search string. If someone

looked at a document, and the server knew that the user was searching for the word "kitten", then the server might return the

document with one paragraph modified as follows:



I also have some kittens who are visiting me these days. They're really cute. I think they like my garden! Maybe I should adopt a kitten.





Example

In the following snippet, a paragraph of text refers to a specific part of a code fragment.



The highlighted part below is where the error lies:

var i: Integer;

begin

i := 1.1;

end.





This is separate from syntax highlighting , for which span is more appropriate. Combining both, one would get:



The highlighted part below is where the error lies:

: ;



:= ;

.





Example



This is another example showing the use of mark to highlight a part of quoted text that was originally not emphasized. In this

example, common typographic conventions have led the author to explicitly style mark elements in quotes to render in italics.





She knew





Did you notice the subtle joke in the joke on panel 4?





I didn't want to believe. Of course on some level I realized it was a known-plaintext attack. But I couldn't admit it until I saw for myself.





(Emphasis mine.) I thought that was great. It's so pedantic, yet it explains everything neatly.





Note, incidentally, the distinction between the em element in this example, which is part of the original text being quoted, and

the mark element, which is highlighting a part for comment.



Example

The following example shows the difference between denoting the importance of a span of text ( strong) as opposed to

denoting the relevance of a span of text ( mark ). It is an extract from a textbook, where the extract has had the parts relevant to

the exam highlighted. The safety warnings, important though they may be, are apparently not relevant to the exam.





Wormhole Physics Introduction





A wormhole in normal conditions can be held open for a maximum of just under 39 minutes. Conditions that can increase the time include a powerful energy source coupled to one or both of the gates connecting the wormhole, and a large gravity well (such as a black hole).





Momentum is preserved across the wormhole. Electromagnetic radiation can travel in both directions through a wormhole, but matter cannot.





When a wormhole is created, a vortex normally forms.

Warning: The vortex caused by the wormhole opening will annihilate anything in its path. Vortexes can be avoided when using sufficiently advanced dialing technology.





An obstruction in a gate will prevent it from accepting a wormhole connection.





✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Also, the dir global attribute has special semantics on this element.

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The bdi element represents a span of text that is to be isolated from its surroundings for the purposes of bidirectional text formatting. [BIDI]

Note

The dir global attribute defaults to auto on this element (it never inherits from the parent element like with other

elements).



Note

This element has rendering requirements involving the bidirectional algorithm.



Example

This element is especially useful when embedding user-generated content with an unknown directionality.

In this example, usernames are shown along with the number of posts that the user has submitted. If the bdi element were not

used, the username of the Arabic user would end up confusing the text (the bidirectional algorithm would put the colon and the

number "3" next to the word "User" rather than next to the word "posts").





User jcranmer: 12 posts.





User hober: 5 posts.





User نايإ: 3 posts.





When using the bdi element, the username acts as expected.





If the bdi element were to be replaced by a b element, the username would confuse the bidirectional algorithm and the third



bullet would end up saying "User 3 :", followed by the Arabic name (right-to-left), followed by "posts" and a period.



✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Also, the dir global attribute has special semantics on this element.

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The bdo element represents explicit text directionality formatting control for its children. It allows authors to override the Unicode bidirectional algorithm by explicitly specifying a direction override. [BIDI]

Authors must specify the dir attribute on this element, with the value ltr to specify a left-to-right override and with the value

rtl to specify a right-to-left override. The auto value must not be specified.

Note

This element has rendering requirements involving the bidirectional algorithm.



✔ MDN





Categories :

Flow content .

Phrasing content .

Palpable content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Phrasing content .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

Accessibility considerations :

For authors.



For implementers.

DOM interface :

[Exposed=Window]

interface HTMLSpanElement : HTMLElement {

[HTMLConstructor] constructor();

};



The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g.

class , lang , or dir . It represents its children.

Example

In this example, a code fragment is marked up using span elements and class attributes so that its keywords and identifiers

can be color-coded from CSS:



( = 0; < 256; ++) {

= ( & 0x1ffff) | ( << 17);

= ((((((( >> 3) ^ ) >> 1) ^ ) >> 8) ^ ) >> 5) & 0xff;

( == )

;

}





✔ MDN





Categories : ✔ MDN

Flow content .

Phrasing content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Nothing .

Tag omission in text/html :

No end tag.

Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLBRElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The br element represents a line break.



Note

While line breaks are usually represented in visual media by physically moving subsequent text to a new line, a style sheet or user

agent would be equally justified in causing line breaks to be rendered in a different manner, for instance as green dots, or as extra

spacing.

br elements must be used only for line breaks that are actually part of the content, as in poems or addresses.

Example

The following example is correct usage of the br element:



P. Sherman



42 Wallaby Way



Sydney





br elements must not be used for separating thematic groups in a paragraph.

Example

The following examples are non-conforming, as they abuse the br element:



34 comments.



Add a comment.





Name:



Address:



Here are alternatives to the above, which are correct:



34 comments.





Add a comment.





Name:





Address:





If a paragraph consists of nothing but a single br element, it represents a placeholder blank line (e.g. as in a template). Such blank lines must not be used for presentation purposes.

Any content inside br elements must not be considered part of the surrounding text.

Note

This element has rendering requirements involving the bidirectional algorithm.



✔ MDN





Categories :

Flow content .

Phrasing content .

Contexts in which this element can be used :

Where phrasing content is expected.

Content model :

Nothing .

Tag omission in text/html :

No end tag.





Content attributes :

Global attributes

Accessibility considerations :

For authors.

For implementers.

DOM interface :

Uses HTMLElement .

The wbr element represents a line break opportunity.

Example

In the following example, someone is quoted as saying something which, for effect, is written as one long word. However, to

ensure that the text can be wrapped in a readable fashion, the individual words in the quote are separated using a wbr element.



So then she pointed at the tiger and screamed

"thereisnowayyouareevergoingtocatchme"!





Any content inside wbr elements must not be considered part of the surrounding text.

Example

var wbr = document.createElement("wbr");

wbr.textContent = "This is wrong";

document.body.appendChild(wbr);



Note

This element has rendering requirements involving the bidirectional algorithm.





This section is non-normative.





§





Links are a conceptual construct, created by a , area , form , and link elements, that represent a connection between two resources, one of which is the current Document. There are two kinds of links in HTML:

Links to external resources

These are links to resources that are to be used to augment the current document, generally automatically processed by the user

agent. All external resource links have a fetch and process the linked resource algorithm which describes how the resource is obtained.

Hyperlinks

These are links to other resources that are generally exposed to the user by the user agent so that the user can cause the user

agent to navigate to those resources, e.g. to visit them in a browser or download them.

For link elements with an href attribute and a rel attribute, links must be created for the keywords of the rel attribute, as defined for those keywords in the link types section.

Similarly, for a and area elements with an href attribute and a rel attribute, links must be created for the keywords of the rel attribute as defined for those keywords in the link types section. Unlike link elements, however, a and area

elements with an href attribute that either do not have a rel attribute, or whose rel attribute has no keywords that are defined as specifying hyperlinks , must also create a hyperlink . This implied hyperlink has no special meaning (it has no link

type ) beyond linking the element's node document to the resource given by the element's href attribute.

Similarly, for form elements with a rel attribute, links must be created for the keywords of the rel attribute as defined for those keywords in the link types section. form elements that do not have a rel attribute, or whose rel attribute has no keywords that are defined as specifying hyperlinks , must also create a hyperlink .

A hyperlink can have one or more hyperlink annotations that modify the processing semantics of that hyperlink.





The href attribute on a and area elements must have a value that is a valid URL potentially surrounded by spaces.

Note

The href attribute on a and area elements is not required; when those elements do not have href attributes they do

not create hyperlinks.

The target attribute, if present, must be a valid browsing context name or keyword . It gives the name of the browsing context

that will be used. User agents use this name when following hyperlinks.

When an a or area element's activation behavior is invoked, the user agent may allow the user to indicate a preference regarding whether the hyperlink is to be used for navigation or whether the resource it specifies is to be downloaded.

In the absence of a user preference, the default should be navigation if the element has no download attribute, and should be to download the specified resource if it does.

Whether determined by the user's preferences or via the presence or absence of the attribute, if the decision is to use the hyperlink for

navigation then the user agent must follow the hyperlink , and if the decision is to use the hyperlink to download a resource, the ✔ MDN

user agent must download the hyperlink. These terms are defined in subsequent sections below.

The download attribute, if present, indicates that the author intends the hyperlink to be used for downloading a resource . The attribute may have a value; the value, if any, specifies the default file name that the author recommends for use in labeling the resource in a local file system. There are no restrictions on allowed values, but authors are cautioned that most file systems have MDN limitations with regard to what punctuation is supported in file names, and user agents are likely to adjust file names accordingly.

The ping attribute, if present, gives the URLs of the resources that are interested in being notified if the user follows the hyperlink. The value must be a set of space-separated tokens , each of which must be a valid non-empty URL whose scheme is an HTTP(S)

scheme . The value is used by the user agent for hyperlink auditing .

The rel attribute on a and area elements controls what kinds of links the elements create. The attribute's value must be a

unordered set of unique space-separated tokens . The allowed keywords and their meanings are defined below.

rel 's supported tokens are the keywords defined in HTML link types which are allowed on a and area elements, impact the processing model, and are supported by the user agent. The possible supported tokens are noreferrer , noopener, and

opener . rel 's supported tokens must only include the tokens from this list that the user agent implements the processing model for.

The rel attribute has no default value. If the attribute is omitted or if none of the values in the attribute are recognized by the user agent, then the document has no particular relationship with the destination resource other than there being a hyperlink between the two.

The hreflang attribute on a elements that create hyperlinks, if present, gives the language of the linked resource. It is purely advisory. The value must be a valid BCP 47 language tag. [BCP47] User agents must not consider this attribute authoritative — upon fetching the resource, user agents must use only language information associated with the resource to determine its language, not metadata included in the link to the resource.

The type attribute, if present, gives the MIME type of the linked resource. It is purely advisory. The value must be a valid MIME type

string . User agents must not consider the type attribute authoritative — upon fetching the resource, user agents must not use metadata included in the link to the resource to determine its type.

The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when following

hyperlinks . [REFERRERPOLICY]





✔ interface mixin HTMLHyperlinkElementUtils { MDN

[CEReactions] stringifier attribute USVString href;

readonly attribute USVString origin;

[CEReactions] attribute USVString protocol;



[CEReactions] attribute USVString username;

[CEReactions] attribute USVString password;

[CEReactions] attribute USVString host;

[CEReactions] attribute USVString hostname;

[CEReactions] attribute USVString port;

[CEReactions] attribute USVString pathname;

[CEReactions] attribute USVString search;

[CEReactions] attribute USVString hash;

};



For web developers (non-normative)

hyperlink . toString()

hyperlink . href

Returns the hyperlink's URL.

Can be set, to change the URL.

hyperlink . origin

Returns the hyperlink's URL's origin.

hyperlink . protocol

Returns the hyperlink's URL's scheme.

Can be set, to change the URL's scheme.

hyperlink . username

Returns the hyperlink's URL's username.

Can be set, to change the URL's username.

hyperlink . password

Returns the hyperlink's URL's password.

Can be set, to change the URL's password.

hyperlink . host

Returns the hyperlink's URL's host and port (if different from the default port for the scheme). Can be set, to change the URL's host and port.

hyperlink . hostname

Returns the hyperlink's URL's host.

Can be set, to change the URL's host.

hyperlink . port

Returns the hyperlink's URL's port.

Can be set, to change the URL's port.

hyperlink . pathname

Returns the hyperlink's URL's path.

Can be set, to change the URL's path.

hyperlink . search

Returns the hyperlink's URL's query (includes leading "?" if non-empty). Can be set, to change the URL's query (ignores leading "?").

hyperlink . hash

Returns the hyperlink's URL's fragment (includes leading "#" if non-empty). Can be set, to change the URL's fragment (ignores leading "#").

An element implementing the HTMLHyperlinkElementUtils mixin has an associated url (null or a URL). It is initially null.

An element implementing the HTMLHyperlinkElementUtils mixin has an associated set the url algorithm, which runs these steps:





1. If this element's href content attribute is absent, set this element's url to null.

2. Otherwise, parse this element's href content attribute value relative to this element's node document . If parsing is

successful, set this element's url to the result; otherwise, set this element's url to null.

When elements implementing the HTMLHyperlinkElementUtils mixin are created, and whenever those elements have their

href content attribute set, changed, or removed, the user agent must set the url.

Note

This is only observable for blob: URLs as parsing them involves a Blob URL Store lookup.

An element implementing the HTMLHyperlinkElementUtils mixin has an associated reinitialize url algorithm, which runs these steps:

1. If element's url is non-null, its scheme is "blob", and its cannot-be-a-base-URL flag is set, terminate these steps.

2. Set the url.

To update href , set the element's href content attribute's value to the element's url, serialized.



The href attribute's getter must run these steps: ✔ MDN

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null and this element has no href content attribute, return the empty string.

4. Otherwise, if url is null, return this element's href content attribute's value.

5. Return url, serialized.

✔ MDN

The href attribute's setter must set this element's href content attribute's value to the given value.

The origin attribute's getter must run these steps:

1. Reinitialize url.

2. If this element's url is null, return the empty string.

3. Return the serialization of this element's url's origin.

The protocol attribute's getter must run these steps: ✔ MDN

1. Reinitialize url.

2. If this element's url is null, return ":".

3. Return this element's url 's scheme, followed by ":".

The protocol attribute's setter must run these steps:

1. Reinitialize url.

2. If this element's url is null, terminate these steps.

3. Basic URL parse the given value, followed by " : ", with this element's url as url and scheme start state as state override.

Note

Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".

4. Update href .

The username attribute's getter must run these steps: ✔ MDN



1. Reinitialize url.

2. If this element's url is null, return the empty string.

3. Return this element's url 's username.

The username attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url cannot have a username/password/port, then return.

4. Set the username, given url and the given value.

5. Update href .

The password attribute's getter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null, then return the empty string.

4. Return url's password.

The password attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url cannot have a username/password/port, then return.

4. Set the password, given url and the given value.

5. Update href .

The host attribute's getter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url or url's host is null, return the empty string.

4. If url's port is null, return url's host, serialized.

5. Return url's host, serialized, followed by ":" and url's port, serialized.

The host attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

4. Basic URL parse the given value, with url as url and host state as state override.

5. Update href .

The hostname attribute's getter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url or url's host is null, return the empty string.



4. Return url's host, serialized.

The hostname attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

4. Basic URL parse the given value, with url as url and hostname state as state override.

5. Update href .

The port attribute's getter must run these steps: ✔ MDN

1. Reinitialize url.

2. Let url be this element's url .

3. If url or url's port is null, return the empty string.

4. Return url's port, serialized.

The port attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url cannot have a username/password/port, then return.

4. If the given value is the empty string, then set url's port to null.

5. Otherwise, basic URL parse the given value, with url as url and port state as state override.

6. Update href .

The pathname attribute's getter must run these steps: ✔ MDN

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null, return the empty string.

4. If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

5. If url's path is empty, then return the empty string.

6. Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The pathname attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null or url's cannot-be-a-base-URL flag is set, terminate these steps.

4. Set url's path to the empty list.

5. Basic URL parse the given value, with url as url and path start state as state override.

6. Update href .

The search attribute's getter must run these steps: ✔ MDN

1. Reinitialize url.

2. Let url be this element's url .



3. If url is null, or url's query is either null or the empty string, return the empty string.

4. Return "?", followed by url's query.

The search attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null, terminate these steps.

4. If the given value is the empty string, set url's query to null.

5. Otherwise:

1. Let input be the given value with a single leading "?" removed, if any.

2. Set url's query to the empty string.

3. Basic URL parse input, with url as url and query state as state override, and this element's node document's

document's character encoding as encoding override.

6. Update href .

The hash attribute's getter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null, or url's fragment is either null or the empty string, return the empty string.

4. Return "#", followed by url's fragment.

The hash attribute's setter must run these steps:

1. Reinitialize url.

2. Let url be this element's url .

3. If url is null, then return.

4. If the given value is the empty string, set url's fragment to null.

5. Otherwise:

1. Let input be the given value with a single leading "#" removed, if any.

2. Set url's fragment to the empty string.

3. Basic URL parse input, with url as url and fragment state as state override.

6. Update href .





An element element cannot navigate if one of the following is true:

• element 's node document is not fully active

• element is not an a element and is not connected.

Note

This is also used by form submission for the form element. The exception for a elements is for compatibility with web

content.

To get an element's noopener , given an a , area , or form element element and a string target, run these steps:



1. If element 's link types include the noopener or noreferrer keyword, then return true.

2. If element 's link types do not include the opener keyword and target is an ASCII case-insensitive match for "_blank",

then return true.

3. Return false.

When a user follows a hyperlink created by an element subject, optionally with a hyperlink suffix, the user agent must run the following steps:

1. If subject cannot navigate , then return.

2. Let replace be false.

3. Let source be subject 's node document 's browsing context.

4. Let targetAttributeValue be the empty string.

5. If subject is an a or area element, then set targetAttributeValue to the result of getting an element's target given

subject.

6. Let noopener be the result of getting an element's noopener with subject and targetAttributeValue.

7. Let target and windowType be the result of applying the rules for choosing a browsing context given targetAttributeValue,

source, and noopener.

8. If target is null, then return.

9. Parse the URL given by subject 's href attribute, relative to subject's node document.

10. If that is successful, let URL be the resulting URL string.

Otherwise, if parsing the URL failed, the user agent may report the error to the user in a user-agent-specific manner, may

queue an element task on the DOM manipulation task source given subject to navigate the target browsing

context to an error page to report the error, or may ignore the error and do nothing. In any case, the user agent must then return.

11. If there is a hyperlink suffix, append it to URL.

12. Let request be a new request whose url is URL and whose referrer policy is the current state of subject's referrerpolicy

content attribute.

13. If subject 's link types includes the noreferrer keyword, then set request's referrer to "no-referrer".

14. Let historyHandling be " replace " if windowType is not " existing or none "; otherwise, " default".

15. Queue an element task on the DOM manipulation task source given subject to navigate target to request with

historyHandling set to historyHandling and the source browsing context set to source.



✔ MDN





In some cases, resources are intended for later use rather than immediate viewing. To indicate that a resource is intended to be downloaded for use later, rather than immediately used, the download attribute can be specified on the a or area element that creates the hyperlink to that resource.

The attribute can furthermore be given a value, to specify the file name that user agents are to use when storing the resource in a file system. This value can be overridden by the ` Content-Disposition ` HTTP header's filename parameters. [RFC6266]

In cross-origin situations, the download attribute has to be combined with the `Content-Disposition` HTTP header, specifically with the attachment disposition type, to avoid the user being warned of possibly nefarious activity. (This is to protect users from being made to download sensitive personal or confidential information without their full understanding.)



The following allowed to download algorithm takes an initiator browsing context and an instantiator browsing context, and returns a boolean indicating whether or not downloading is allowed:



1. If the initiator browsing context 's sandboxing flags has the sandboxed downloads browsing context flag set, then

return false.

2. If the instantiator browsing context is non-null, and its sandboxing flags has the sandboxed downloads browsing context

flag set, then return false.

3. Optionally, the user agent may return false, if it believes doing so would safeguard the user from a potentially hostile

download.

4. Return true.

When a user downloads a hyperlink created by an element subject, optionally with a hyperlink suffix, the user agent must run the following steps:

1. If subject cannot navigate , then return.

2. Run the allowed to download algorithm with the subject 's node document 's browsing context and null. If the algorithm

returns false, then return.

3. Parse the URL given by subject 's href attribute, relative to subject's node document.

4. If parsing the URL fails, the user agent may report the error to the user in a user-agent-specific manner, may navigate

to an error page to report the error, or may ignore the error and do nothing. In either case, the user agent must return.

5. Otherwise, let URL be the resulting URL string.

6. If there is a hyperlink suffix, append it to URL.

7. Run these steps in parallel:

1. Let request be a new request whose url is URL , client is entry settings object , initiator is "download", destination

is the empty string, and whose synchronous flag and use-URL-credentials flag are set.

2. Handle the result of fetching request as a download.

When a user agent is to handle a resource obtained from a fetch as a download, it should provide the user with a way to save the resource for later use, if a resource is successfully obtained. Otherwise, it should report any problems downloading the file to the user.

If the user agent needs a file name for a resource being handled as a download , it should select one using the following algorithm.

⚠Warning!

This algorithm is intended to mitigate security dangers involved in downloading files from untrusted sites, and user

agents are strongly urged to follow it.

1. Let filename be the undefined value.

2. If the resource has a `Content-Disposition` header, that header specifies the attachment disposition type, and the header

includes file name information, then let filename have the value specified by the header, and jump to the step labeled

sanitize below. [RFC6266]

3. Let interface origin be the origin of the Document in which the download or navigate action resulting in the

download was initiated, if any.

4. Let resource origin be the origin of the URL of the resource being downloaded, unless that URL's scheme component is

data, in which case let resource origin be the same as the interface origin, if any.

5. If there is no interface origin, then let trusted operation be true. Otherwise, let trusted operation be true if resource origin is

the same origin as interface origin, and false otherwise.

6. If trusted operation is true and the resource has a `Content-Disposition` header and that header includes file name

information, then let filename have the value specified by the header, and jump to the step labeled sanitize below.

[RFC6266]

7. If the download was not initiated from a hyperlink created by an a or area element, or if the element of the

hyperlink from which it was initiated did not have a download attribute when the download was initiated, or if there was such an attribute but its value when the download was initiated was the empty string, then jump to the step labeled no proposed file name.



8. Let proposed filename have the value of the download attribute of the element of the hyperlink that initiated the

download at the time the download was initiated.

9. If trusted operation is true, let filename have the value of proposed filename, and jump to the step labeled sanitize below.

10. If the resource has a `Content-Disposition` header and that header specifies the attachment disposition type, let filename

have the value of proposed filename , and jump to the step labeled sanitize below. [RFC6266]

11. No proposed file name: If trusted operation is true, or if the user indicated a preference for having the resource in question

downloaded, let filename have a value derived from the URL of the resource in an implementation-defined manner, and jump to the step labeled sanitize below.

12. Let filename be set to the user's preferred file name or to a file name selected by the user agent, and jump to the step

labeled sanitize below.

⚠Warning!

If the algorithm reaches this step, then a download was begun from a different origin than the resource being downloaded, and the origin did not mark the file as suitable for downloading, and the download was

not initiated by the user. This could be because a download attribute was used to trigger the download, or because the resource in question is not of a type that the user agent supports.

This could be dangerous, because, for instance, a hostile server could be trying to get a user to unknowingly download private information and then re-upload it to the hostile server, by tricking the user into thinking the data is from the hostile server.

Thus, it is in the user's interests that the user be somehow notified that the resource in question comes from quite a different source, and to prevent confusion, any suggested file name from the potentially hostile interface origin should be ignored.

13. Sanitize: Optionally, allow the user to influence filename. For example, a user agent could prompt the user for a file name,

potentially providing the value of filename as determined above as a default value.

14. Adjust filename to be suitable for the local file system.

Example

For example, this could involve removing characters that are not legal in file names, or trimming leading and trailing whitespace.

15. If the platform conventions do not in any way use extensions to determine the types of file on the file system, then return

filename as the file name.

16. Let claimed type be the type given by the resource's Content-Type metadata, if any is known. Let named type be the type

given by filename 's extension, if any is known. For the purposes of this step, a type is a mapping of a MIME type to an

extension .

17. If named type is consistent with the user's preferences (e.g. because the value of filename was determined by prompting the

user), then return filename as the file name.

18. If claimed type and named type are the same type (i.e. the type given by the resource's Content-Type metadata is

consistent with the type given by filename 's extension), then return filename as the file name.

19. If the claimed type is known, then alter filename to add an extension corresponding to claimed type.

Otherwise, if named type is known to be potentially dangerous (e.g. it will be treated by the platform conventions as a native executable, shell script, HTML application, or executable-macro-capable document) then optionally alter filename to add a

known-safe extension (e.g. ".txt").

Note

This last step would make it impossible to download executables, which might not be desirable. As always, implementers are forced to balance security and usability in this matter.

20. Return filename as the file name.

For the purposes of this algorithm, a file extension consists of any part of the file name that platform conventions dictate will be used for identifying the type of the file. For example, many operating systems use the part of the file name following the last dot (".") in the file name to determine the type of the file, and from that the manner in which the file is to be opened or executed.



Note User agents should ignore any directory or path information provided by the resource itself, its URL , and any download attribute, in deciding where to store the resulting file in the user's file system.



4.6.5.1 Hyperlink auditing



If a hyperlink created by an a or area element has a ping attribute, and the user follows the hyperlink, and the value of the element's href attribute can be parsed, relative to the element's node document, without failure, then the user agent must take the ping attribute's value, split that string on ASCII whitespace , parse each resulting token relative to the element's node

document , and then run these steps for each resulting URL record ping URL, ignoring tokens that fail to parse:

1. If ping URL's scheme is not an HTTP(S) scheme, then return.

2. Optionally, return. (For example, the user agent might wish to ignore any or all ping URLs in accordance with the user's

expressed preferences.)

3. Let request be a new request whose url is ping URL, method is `POST`, body is `PING`, client is the environment settings

object of the Document containing the hyperlink, destination is the empty string, credentials mode is "include",

referrer is "no-referrer", and whose use-URL-credentials flag is set.

4. Let target URL be the resulting URL string obtained from parsing the value of the element's href attribute and then:

↪ If the URL of the Document object containing the hyperlink being audited and ping URL have the same

origin

↪ If the origins are different, but the scheme of the URL of the Document containing the hyperlink being

audited is not "https"

request must include a ` Ping-From` header with, as its value, the URL of the document containing the hyperlink,

and a ` Ping-To` HTTP header with, as its value, the target URL.

↪ Otherwise

request must include a ` Ping-To` HTTP header with, as its value, target URL. request does not include a

` Ping-From` header.

5. Fetch request.

This may be done in parallel with the primary fetch, and is independent of the result of that fetch.

User agents should allow the user to adjust this behavior, for example in conjunction with a setting that disables the sending of HTTP

` Referer ` (sic) headers. Based on the user's preferences, UAs may either ignore the ping attribute altogether, or selectively ignore URLs in the list (e.g. ignoring any third-party URLs); this is explicitly accounted for in the steps above.

User agents must ignore any entity bodies returned in the responses. User agents may close the connection prematurely once they start receiving a response body.

When the ping attribute is present, user agents should clearly indicate to the user that following the hyperlink will also cause secondary requests to be sent in the background, possibly including listing the actual target URLs.

Example

For example, a visual user agent could include the hostnames of the target ping URLs along with the hyperlink's actual URL in a

status bar or tooltip.



Note

The ping attribute is redundant with pre-existing technologies like HTTP redirects and JavaScript in allowing web pages to track

which off-site links are most popular or allowing advertisers to track click-through rates.

However, the ping attribute provides these advantages to the user over those alternatives:

• It allows the user to see the final target URL unobscured.

• It allows the UA to inform the user about the out-of-band notifications.

• It allows the user to disable the notifications without losing the underlying link functionality.





• It allows the UA to optimize the use of available network bandwidth so that the target page loads faster.

Thus, while it is possible to track users without this feature, authors are encouraged to use the ping attribute so that the user

agent can make the user experience more transparent.



MDN





The following table summarizes the link types that are defined by this specification, by their corresponding keywords. This table is non-normative; the actual definitions for the link types are given in the next few sections.

In this section, the term referenced document refers to the resource identified by the element representing the link, and the term current document refers to the resource within which the element representing the link finds itself.

To determine which link types apply to a link , a , area , or form element, the element's rel attribute must be split on

ASCII whitespace. The resulting tokens are the keywords for the link types that apply to that element.

Except where otherwise specified, a keyword must not be specified more than once per rel attribute.

Some of the sections that follow the table below list synonyms for certain keywords. The indicated synonyms are to be handled as specified by user agents, but must not be used in documents (for example, the keyword "copyright").

Keywords are always ASCII case-insensitive, and must be compared as such.

Example

Thus, rel="next" is the same as rel="NEXT".

Keywords that are body-ok affect whether link elements are allowed in the body . The body-ok keywords are dns-

prefetch , modulepreload , pingback , preconnect , prefetch , preload , prerender , and stylesheet.

New link types that are to be implemented by web browsers are to be added to this standard. The remainder can be registered as

extensions .





⚠ MDN

4.6.6.1 Link type "alternate"



The alternate keyword may be used with link , a , and area elements.

The meaning of this keyword depends on the values of the other attributes.

↪ If the element is a link element and the rel attribute also contains the keyword stylesheet

The alternate keyword modifies the meaning of the stylesheet keyword in the way described for that keyword. The

alternate keyword does not create a link of its own.

Example

Here, a set of link elements provide some style sheets:





↪ If the alternate keyword is used with the type attribute set to the value application/rss+xml or the value

application/atom+xml

The keyword creates a hyperlink referencing a syndication feed (though not necessarily syndicating exactly the same content as the current page).

For the purposes of feed autodiscovery, user agents should consider all link elements in the document with the



alternate keyword used and with their type attribute set to the value application/rss+xml or the value application/

atom+xml. If the user agent has the concept of a default syndication feed, the first such element (in tree order) should be used as the default.

Example

The following link elements give syndication feeds for a blog:





Such link elements would be used by user agents engaged in feed autodiscovery, with the first being the default (where applicable).

The following example offers various different syndication feeds to the user, using a elements:



You can access the planets database using Atom feeds:





atom+xml">Recently Visited Planets





Known Bad

Planets





Unexplored

Planets





These links would not be used in feed autodiscovery.



↪ Otherwise

The keyword creates a hyperlink referencing an alternate representation of the current document.

The nature of the referenced document is given by the hreflang , and type attributes.

If the alternate keyword is used with the hreflang attribute, and that attribute's value differs from the document

element 's language, it indicates that the referenced document is a translation.

If the alternate keyword is used with the type attribute, it indicates that the referenced document is a reformulation of the current document in the specified format.

The hreflang and type attributes can be combined when specified with the alternate keyword.

Example

The following example shows how you can specify versions of the page that use alternative formats, are aimed at other languages, and that are intended for other media:





This relationship is transitive — that is, if a document links to two other documents with the link type " alternate", then, in addition to implying that those documents are alternative representations of the first document, it is also implying that those two documents are alternative representations of each other.





4.6.6.2 Link type "author"



The author keyword may be used with link , a , and area elements. This keyword creates a hyperlink .

For a and area elements, the author keyword indicates that the referenced document provides further information about the author of the nearest article element ancestor of the element defining the hyperlink, if there is one, or of the page as a whole, otherwise.

For link elements, the author keyword indicates that the referenced document provides further information about the author for the page as a whole.

Note

The "referenced document" can be, and often is, a mailto: URL giving the email address of the author. [MAILTO]

Synonyms : For historical reasons, user agents must also treat link , a , and area elements that have a rev attribute with the value " made " as having the author keyword specified as a link relationship.



4.6.6.3 Link type "bookmark"



The bookmark keyword may be used with a and area elements. This keyword creates a hyperlink.

The bookmark keyword gives a permalink for the nearest ancestor article element of the linking element in question, or of the

section the linking element is most closely associated with , if there are no ancestor article elements.

Example

The following snippet has three permalinks. A user agent could determine which permalink applies to which part of the spec by

looking at where the permalinks are given.

...





Example of permalinks





First example





This permalink applies to only the content from the first H2 to the second H2. The DIV isn't exactly that section, but it roughly corresponds to it.





Second example





This permalink applies to the outer ARTICLE element (which could be, e.g., a blog post).





This permalink applies to the inner ARTICLE element (which could be, e.g., a blog comment).





...



4.6.6.4 Link type "canonical"



The canonical keyword may be used with link element. This keyword creates a hyperlink.

The canonical keyword indicates that URL given by the href attribute is the preferred URL for the current document. That helps search engines reduce duplicate content, as described in more detail in The Canonical Link Relation . [RFC6596]





MDN


4.6.6.5 Link type "dns-prefetch"



The dns-prefetch keyword may be used with link elements. This keyword creates an external resource link. This keyword is

body-ok .

The dns-prefetch keyword indicates that preemptively performing DNS resolution for the origin of the specified resource is likely to be beneficial, as it is highly likely that the user will require resources located at that origin , and the user experience would be improved by preempting the latency costs associated with DNS resolution. User agents must implement the processing model of the dns-prefetch keyword described in Resource Hints . [RESOURCEHINTS]

There is no default type for resources given by the dns-prefetch keyword.



4.6.6.6 Link type "external"



The external keyword may be used with a , area , and form elements. This keyword does not create a hyperlink , but

annotates any other hyperlinks created by the element (the implied hyperlink, if no other keywords create one).

The external keyword indicates that the link is leading to a document that is not part of the site that the current document forms a part of.



4.6.6.7 Link type "help"



The help keyword may be used with link , a , area , and form elements. This keyword creates a hyperlink.

For a , area , and form elements, the help keyword indicates that the referenced document provides further help information for the parent of the element defining the hyperlink, and its children.

Example

In the following example, the form control has associated context-sensitive help. The user agent could use this information, for

example, displaying the referenced document if the user presses the "Help" or "F1" key.



Topic: (Help)





For link elements, the help keyword indicates that the referenced document provides help for the page as a whole.

For a and area elements, on some browsers, the help keyword causes the link to use a different cursor.



✔ MDN

4.6.6.8 Link type "icon"



The icon keyword may be used with link elements. This keyword creates an external resource link.

The specified resource is an icon representing the page or site, and should be used by the user agent when representing the page in the user interface.

Icons could be auditory icons, visual icons, or other kinds of icons. If multiple icons are provided, the user agent must select the most appropriate icon according to the type , media , and sizes attributes. If there are multiple equally appropriate icons, user agents must use the last one declared in tree order at the time that the user agent collected the list of icons. If the user agent tries to use an icon but that icon is determined, upon closer examination, to in fact be inappropriate (e.g. because it uses an unsupported format), then the user agent must try the next-most-appropriate icon as determined by the attributes.

Note

User agents are not required to update icons when the list of icons changes, but are encouraged to do so.

There is no default type for resources given by the icon keyword. However, for the purposes of determining the type of the

resource , user agents must expect the resource to be an image.



The sizes keywords represent icon sizes in raw pixels (as opposed to CSS pixels).

Note

An icon that is 50 CSS pixels wide intended for displays with a device pixel density of two device pixels per CSS pixel (2x, 192dpi)

would have a width of 100 raw pixels. This feature does not support indicating that a different resource is to be used for small

high-resolution icons vs large low-resolution icons (e.g. 50×50 2x vs 100×100 1x).

To parse and process the attribute's value, the user agent must first split the attribute's value on ASCII whitespace, and must then parse each resulting keyword to determine what it represents.

The any keyword represents that the resource contains a scalable icon, e.g. as provided by an SVG image.

Other keywords must be further parsed as follows to determine what they represent:

• If the keyword doesn't contain exactly one U+0078 LATIN SMALL LETTER X or U+0058 LATIN CAPITAL LETTER X character,

then this keyword doesn't represent anything. Return for that keyword.

• Let width string be the string before the "x" or "X".

• Let height string be the string after the "x" or "X".

• If either width string or height string start with a U+0030 DIGIT ZERO (0) character or contain any characters other than

ASCII digits, then this keyword doesn't represent anything. Return for that keyword.

• Apply the rules for parsing non-negative integers to width string to obtain width.

• Apply the rules for parsing non-negative integers to height string to obtain height.

• The keyword represents that the resource contains a bitmap icon with a width of width device pixels and a height of height

device pixels.

The keywords specified on the sizes attribute must not represent icon sizes that are not actually available in the linked resource.

The linked resource fetch setup steps for this type of linked resource, given a link element el and request request, are:

1. Set request's destination to "image".

2. Return true.

In the absence of a link with the icon keyword, for Document objects whose URL's scheme is an HTTP(S) scheme, user

agents may instead run these steps in parallel:

1. Let request be a new request whose url is the URL record obtained by resolving the URL "/favicon.ico" against the

Document object's URL , client is the Document object's relevant settings object , destination is "image", synchronous

flag is set, credentials mode is "include", and whose use-URL-credentials flag is set.

2. Let response be the result of fetching request.

3. Use response 's unsafe response as an icon as if it had been declared using the icon keyword.

Example

The following snippet shows the top part of an application with several icons.





lsForums — Inbox





...



For historical reasons, the p299 icon keyword may be preceded by the keyword "shortcut". If the "shortcut" keyword is present, the

rel p285 attribute's entire value must be an ASCII case-insensitive match for the string "shortcut icon" (with a single U+0020 SPACE

character between the tokens and no other ASCII whitespace).



4.6.6.9 Link type "license" p30 §

1

The p301 p158 p239 p444 p487 p284 license keyword may be used with link , a , area , and form elements. This keyword creates a hyperlink .

The p301 license keyword indicates that the referenced document provides the copyright license terms under which the main content of the current document is provided.

This specification does not specify how to distinguish between the main content of a document and content that is not deemed to be part of that main content. The distinction should be made clear to the user.

Example

Consider a photo sharing site. A page on that site might describe and show a photograph, and the page might be marked up as

follows:





Exampl Pictures: Kissat





Kissat





Return to photo index





Kissat





One of them has six toes!





MIT

Licensed





Home | Photo index



© copyright 2009 Exampl Pictures. All Rights Reserved.





In this case the p301 license applies to just the photo (the main content of the document), not the whole document. In particular not

the design of the page itself, which is covered by the copyright given at the bottom of the document. This could be made clearer in

the styling (e.g. making the license link prominently positioned near the photograph, while having the page copyright in light small

text at the foot of the page).

Synonyms p301 : For historical reasons, user agents must also treat the keyword " copyright " like the license keyword.



301

4.6.6.10 Link type "manifest" p30 §

2

The p302 p158 p284 manifest keyword may be used with link elements. This keyword creates an external resource link.

The p302 manifest keyword indicates the manifest file that provides metadata associated with the current document.

There is no default type for resources given by the p302 manifest keyword.

The appropriate time to p163 fetch and process the linked resource for this link type is when the user agent deems it necessary. For example, when the user chooses to p158 p159 install the web application . In that case, only the first link element in tree order whose rel

attribute contains the token p302 manifest may be used.

A user agent must not p1162 delay the load event for this link type.

The p163 p158 linked resource fetch setup steps for this type of linked resource, given a link element el and request request, are:

1. Let p814 context be el 's node document 's browsing context.

2. If context is null, then return false.

3. If p817 context is not a top-level browsing context, then return false.

4. Set request's initiator to "manifest".

5. Set request's destination to "manifest".

6. Set request's mode to "cors".

7. Set p91 p159 request 's credentials mode to the CORS settings attribute credentials mode for el 's crossorigin content attribute.

8. Return true.

To p164 p158 process this type of linked resource given a link element el, boolean success, and response response:

1. If p90 response 's Content-Type metadata is not a JSON MIME type, then set success to false.

2. If p1279 success is true, then process the manifest given el and response . [MANIFEST]



⚠ MDN

4.6.6.11 Link type "modulepreload" p30 §

2

The p302 p158 p284 modulepreload keyword may be used with link elements. This keyword creates an external resource link. This keyword is p295 body-ok.

The p302 p306 modulepreload keyword is a specialized alternative to the preload keyword, with a processing model geared toward preloading p912 module scripts . In particular, it uses the specific fetch behavior for module scripts (including, e.g., a different interpretation of the p159 p116 crossorigin attribute), and places the result into the appropriate module map for later evaluation. In contrast, a similar p284 p306 external resource link using the preload keyword would place the result in the preload cache, without affecting the document's p116 module map.

Additionally, implementations can take advantage of the fact that p912 module scripts declare their dependencies in order to fetch the specified module's dependency as well. This is intended as an optimization opportunity, since the user agent knows that, in all likelihood, those dependencies will also be needed later. It will not generally be observable without using technology such as service workers, or monitoring on the server side. Notably, the appropriate p1271 p1271 load or error events will occur after the specified module is fetched, and will not wait for any dependencies.

The appropriate times to p163 fetch and process the linked resource for such a link are:

• When the p284 p158 p45 external resource link is created on a link element that is already browsing-context connected.

• When the p284 p158 p45 external resource link 's link element becomes browsing-context connected.

• When the p159 p158 p284 href attribute of the link element of an external resource link that is already browsing-context

connected p45 is changed.



302

Note

Unlike some other link relations, changing the relevant attributes (such as p161 p159 p160 as , crossorigin , and referrerpolicy) of

such a p158 p116 link does not trigger a new fetch. This is because the document's module map has already been populated by a

previous fetch, and so re-fetching would be pointless.

The p163 p302 p158 fetch and process the linked resource algorithm for modulepreload links, given a link element el, is as follows:

1. If the p159 href attribute's value is the empty string, then return.

2. Let p161 destination be the current state of the as attribute (a destination), or "script" if it is in no state.

3. If p933 p939 p158 destination is not script-like , then queue an element task on the networking task source given the link element

to p1271 p158 fire an event named error at the link element, and return.

4. p89 p159 Parse the URL given by the href attribute, relative to the element's node document. If that fails, then return.

Otherwise, let p89 url be the resulting URL record.

5. Let p158 p911 settings object be the link element's node document 's relevant settings object.

6. Let p91 p159 credentials mode be the CORS settings attribute credentials mode for the crossorigin attribute.

7. Let p92 cryptographic nonce be the current value of the element's [[CryptographicNonce]] internal slot.

8. Let p160 integrity metadata be the value of the integrity attribute, if it is specified, or the empty string otherwise.

9. Let p160 referrer policy be the current state of the element's referrerpolicy attribute.

10. Let p913 p913 p913 options be a script fetch options whose cryptographic nonce is cryptographic nonce , integrity metadata is

integrity metadata p913 p913 , parser metadata is " not-parser-inserted ", credentials mode is credentials mode, and referrer

policy p913 is referrer policy.

11. p916 Fetch a modulepreload module script graph given url, destination, settings object, and options. Wait until the algorithm

asynchronously completes with result.

12. If p1271 p158 result is null, then fire an event named error at the link element, and return.

13. p1271 p158 Fire an event named load at the link element.

Example

The following snippet shows the top part of an application with several modules preloaded:





IRCFog





onerror="fallback(parentNode)">

...





320

✔ MDN

4.8.3 The img element p32 §

1

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Embedded content p133.

Form-associated element p487 .

If the element has a p446 p133 usemap attribute: Interactive content .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 embedded content is expected.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

alt p322 — Replacement text for use when images are not available

src p322 — Address of the resource

srcset p322 — Images to use in different situations, e.g., high-resolution displays, small monitors, etc.

sizes p322 — Image sizes for different page layouts

crossorigin p322 — How the element handles crossorigin requests

usemap p446 p446 — Name of image map to use

ismap p324 — Whether the image is a server-side image map

width p450 — Horizontal dimension

height p450 — Vertical dimension

referrerpolicy p322 — Referrer policy for fetches initiated by the element

decoding p322 — Decoding hint to use when processing this image for presentation

loading p322 — Used when determining loading deferral

Accessibility considerations p130:

If the element has a non-empty p322 alt attribute: for authors; for implementers.

Otherwise: for authors; for implementers.

DOM interface p130:

IDL [Exposed=Window,

LegacyFactoryFunction=Image(optional unsigned long width, optional unsigned long height)]

interface HTMLImageElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString alt;

[CEReactions] attribute USVString src;

[CEReactions] attribute USVString srcset;

[CEReactions] attribute DOMString sizes;

[CEReactions] attribute DOMString? crossOrigin;

[CEReactions] attribute DOMString useMap;

[CEReactions] attribute boolean isMap;

[CEReactions] attribute unsigned long width;

[CEReactions] attribute unsigned long height;

readonly attribute unsigned long naturalWidth;

readonly attribute unsigned long naturalHeight;

readonly attribute boolean complete;

readonly attribute USVString currentSrc;

[CEReactions] attribute DOMString referrerPolicy;

[CEReactions] attribute DOMString decoding;

[CEReactions] attribute DOMString loading;

Promise decode();

321

// also has obsolete members

};

✔ MDN

An p321 img element represents an image.

The image given by the p318 p318 src and srcset attributes, and any previous sibling source elements' srcset attributes if the parent is a p317 picture element, is the embedded content; the value of the alt attribute provides equivalent content for those who cannot process images or who have image loading disabled (i.e. it is the p321 p133 img element's fallback content).

The requirements on the p322 p349 alt attribute's value are described in a separate section.

The p322 p88 src attribute must be present, and must contain a valid non-empty URL potentially surrounded by spaces referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.

Note

The requirements above imply that images can be static bitmaps (e.g. PNGs, GIFs, JPEGs), single-page vector documents (single-

page PDFs, XML files with an SVG document element), animated bitmaps (APNGs, animated GIFs), animated vector graphics (XML

files with an SVG document element that use declarative SMIL animation), and so forth. However, these definitions preclude SVG

files with script, multipage PDF files, interactive MNG files, HTML documents, plain text documents, and so forth. p1280 [PNG]

[GIF] p1278 p1278 p1280 p1283 p1275 p1281 p1279 [JPEG] [PDF] [XML] [APNG] [SVG] [MNG]

The p322 p336 srcset attribute may also be present, and is a srcset attribute .

The p322 p322 p336 p338 srcset attribute and the src attribute (if width descriptors are not used) contribute the image sources to the source

set p338 p318 (if no source element was selected).

If the p322 p336 p336 srcset attribute is present and has any image candidate strings using a width descriptor, the sizes attribute must also be present, and is a p336 p322 p338 p338 p318 sizes attribute . The sizes attribute contributes the source size to the source set (if no source ✔ MDN element was selected).

The p91 crossorigin attribute is a CORS settings attribute. Its purpose is to allow images from third-party sites that allow cross-origin access to be used with p635 canvas .

The p92 referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the image.

[REFERRERPOLICY] p1280

The p339 decoding attribute indicates the preferred method to decode this image. The attribute, if present, must be an image decoding

hint p339 p68 p68 p339 . This attribute's missing value default and invalid value default are both the auto state.

The p93 loading attribute is a lazy loading attribute. Its purpose is to indicate the policy for loading images that are outside the viewport.

When the p322 p93 loading attribute's state is changed to the Eager state, the user agent must run these steps:

1. Let p321 p93 resumptionSteps be the img element's lazy load resumption steps.

2. If resumptionSteps is null, then return.

3. Set the p321 p93 img 's lazy load resumption steps to null.

4. Invoke resumptionSteps.

Example





322

In the example above, the images load as follows:

↪ 1.jpeg, 2.jpeg, 4.jpeg

The images load eagerly and delay the window's load event.

↪ 3.jpeg

The image loads when layout is known, due to being in the viewport, however it does not delay the window's load event.

↪ 5.jpeg

The image loads only once scrolled into the viewport, and does not delay the window's load event.

Note

Developers are encouraged to specify an intrinsic aspect ratio via p450 p450 width and height attributes on lazy loaded images, even if CSS sets the image's width and height properties, to prevent the page layout from shifting around after the image loads.



The p321 p321 img element must not be used as a layout tool. In particular, img elements should not be used to display transparent images, as such images rarely convey meaning and rarely add anything useful to the document.



What an p321 p322 p322 img element represents depends on the src attribute and the alt attribute.

↪ p322 p322 If the src attribute is set and the alt attribute is set to the empty string

The image is either decorative or supplemental to the rest of the content, redundant with some other information in the document.

If the image is p337 p124 available and the user agent is configured to display that image, then the element represents the element's image data.

Otherwise, the element p124 represents nothing, and may be omitted completely from the rendering. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.

↪ p322 p322 If the src attribute is set and the alt attribute is set to a value that isn't empty

The image is a key part of the content; the p322 alt attribute gives a textual equivalent or replacement for the image.

If the image is p337 p124 available and the user agent is configured to display that image, then the element represents the element's image data.

Otherwise, the element p124 p322 represents the text given by the alt attribute. User agents may provide the user with a notification that an image is present but has been omitted from the rendering.

↪ p322 p322 If the src attribute is set and the alt attribute is not

The image might be a key part of the content, and there is no textual equivalent of the image available.

Note

In a conforming document, the absence of the p322 alt attribute indicates that the image is a key part of the content but that a textual replacement for the image was not available when the image was generated.

If the image is p337 p124 available and the user agent is configured to display that image, then the element represents the element's image data.

If the image has a p322 p124 src attribute whose value is the empty string, then the element represents nothing.

Otherwise, the user agent should display some sort of indicator that there is an image that is not being rendered, and may, if requested by the user, or if so configured, or when required to provide contextual information in response to navigation, provide caption information for the image, derived as follows:

1. If the image has a p140 title attribute whose value is not the empty string, then return the value of that attribute.

323

2. If the image is a descendant of a p233 p236 figure element that has a child figcaption element, and, ignoring the

figcaption p236 p233 p132 element and its descendants, the figure element has no flow content descendants other than

inter-element whitespace p130 p321 p236 and the img element, then return the contents of the first such figcaption element.

3. Return nothing. (There is no caption information.)

↪ p322 p322 p322 If the src attribute is not set and either the alt attribute is set to the empty string or the alt attribute is

not set at all

The element p124 represents nothing.

↪ Otherwise

The element p124 p322 represents the text given by the alt attribute.

The p322 p322 alt attribute does not represent advisory information. User agents must not present the contents of the alt attribute in the same way as content of the p140 title attribute.

User agents may always provide the user with the option to display any image, or to prevent any image from being displayed. User agents may also apply heuristics to help the user make use of the image when the user is unable to see it, e.g. due to a visual disability or because they are using a text terminal with no graphics capabilities. Such heuristics could include, for instance, optical character recognition (OCR) of text found within the image.

⚠Warning!

While user agents are encouraged to repair cases of missing p322 alt attributes, authors must not rely on such

behavior. p349 Requirements for providing text to act as an alternative for images are described in detail below.

The p321 contents of img elements, if any, are ignored for the purposes of rendering.



The p446 p446 usemap attribute, if present, can indicate that the image has an associated image map .

The p239 p285 ismap attribute, when used on an element that is a descendant of an a element with an href attribute, indicates by its presence that the element provides access to a server-side image map. This affects how events are handled on the corresponding p239 a element.

The p324 p67 ismap attribute is a boolean attribute. The attribute must not be specified on an element that does not have an ancestor

a p239 p285 element with an href attribute.

Note

The p446 p324 p318 usemap and ismap attributes can result in confusing behavior when used together with source elements with the

media p319 p317 attribute specified in a picture element.

✔ MDN

The p321 p450 img element supports dimension attributes .

✔ MDN

The p95 alt , src , srcset and sizes IDL attributes must reflect the respective content attributes of the same name.

✔ MDN

The p95 p322 p95 crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

✔ MDN

The p95 p446 useMap IDL attribute must reflect the usemap content attribute.

The p95 p324 isMap IDL attribute must reflect the ismap content attribute.

✔ MDN

The p95 p322 p95 referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The p95 p322 p95 decoding IDL attribute must reflect the decoding content attribute, limited to only known values.

The p95 p322 p95 loading IDL attribute must reflect the loading content attribute, limited to only known values.

For web developers (non-normative)



324

image p325 . width [ = value ]

image p325 . height [ = value ]

These attributes return the actual rendered dimensions of the image, or zero if the dimensions are not known. They can be set, to change the corresponding content attributes.

image p325 . naturalWidth

image p325 . naturalHeight

These attributes return the intrinsic dimensions of the image, or zero if the dimensions are not known.

image p325 . complete

Returns true if the image has been completely downloaded or if no image is specified; otherwise, returns false.

image p325 . currentSrc

Returns the image's absolute URL.

image p325 . decode()

This method causes the user agent to p339 p42 decode the image in parallel, returning a promise that fulfills when decoding is complete.

The promise will be rejected with an "EncodingError" DOMException if the image cannot be decoded.

image p327 = new Image( [ width [, height ] ] )

Returns a new p321 p450 p450 img element, with the width and height attributes set to the values passed in the relevant arguments, if applicable.



The IDL attributes width and height must return the rendered width and height of the image, in CSS pixels, if the image is being ✔ MDN p1188 p337 rendered , and is being rendered to a visual medium; or else the density-corrected intrinsic width and height of the image, in

CSS pixels p337 , if the image has intrinsic dimensions and is available but not being rendered to a visual medium; or else 0, if the image is not p337 p1275 available or does not have intrinsic dimensions . [CSS]

✔ MDN

On setting, they must act as if they p95 reflected the respective content attributes of the same name.

The IDL attributes p337 naturalWidth and naturalHeight must return the density-corrected intrinsic width and height of the image, in

CSS pixels p337 p1275 , if the image has intrinsic dimensions and is available , or else 0. [CSS]

Note

Since the p325 intrinsic dimensions of an image take into account any orientation specified in its metadata, naturalWidth and

naturalHeight p325 reflect the dimensions after applying any rotation needed to correctly orient the image, regardless of the value

of the ✔ MDN 'image-orientation' property.

The IDL attribute complete must return true if any of the following conditions is true:

• Both the p322 p322 src attribute and the srcset attribute are omitted.

• The p322 p322 srcset attribute is omitted and the src attribute's value is the empty string.

• The p321 p337 p337 p337 p337 img element's current request 's state is completely available and its pending request is null.

• The p321 p337 p337 p337 p337 img element's current request 's state is broken and its pending request is null.

✔ MDN

Otherwise, the attribute must return false.

✔ MDN

The p321 p337 p337 currentSrc IDL attribute must return the img element's current request 's current URL .

The decode() method, when invoked, must perform the following steps:

1. Let promise be a new promise.

2. p933 Queue a microtask to perform the following steps:

Note

This is done because p340 updating the image data takes place in a microtask as well. Thus, to make code such as

img.src = "stars.jpg";

img.decode();

325

properly decode stars.jpg, we need to delay any processing by one microtask.

1. If any of the following conditions are true about this p321 img element:

▪ its p814 node document is not an active document;

▪ its p337 p337 p337 current request 's state is broken,

then reject promise with an "EncodingError" DOMException.

2. Otherwise, p42 in parallel, wait for one of the following cases to occur, and perform the corresponding actions:

↪ p321 p814 This img element's node document stops being an active document

↪ p321 p337 This img element's current request changes or is mutated

↪ p321 p337 p337 p337 This img element's current request 's state becomes broken

Reject promise with an "EncodingError" DOMException.

↪ p321 p337 p337 p337 This img element's current request 's state becomes completely available

Decode p339 the image.

If decoding does not need to be performed for this image (for example because it is a vector graphic), resolve promise with undefined.

If decoding fails (for example due to invalid image data), reject promise with an "EncodingError"

DOMException.

If the decoding process completes successfully, resolve promise with undefined.

User agents should ensure that the decoded media data stays readily available until at least the end of the

next successful p934 p931 update the rendering step in the event loop . This is an important part of the API contract, and should not be broken if at all possible. (Typically, this would only be violated in low-memory situations that require evicting decoded image data, or when the image is too large to keep in decoded form for this period of time.)

Note

Animated images will become p337 completely available only after all their frames are loaded. Thus, even though an implementation could decode the first frame before that point, the above steps will not do so, instead waiting until all frames are available.

3. Return promise.

Example

Without the p325 p321 decode() method, the process of loading an img element and then displaying it might look like the following:

const img = new Image();

img.src = "nebula.jpg";

img.onload = () => {

document.body.appendChild(img);

};

img.onerror = () => {

document.body.appendChild(new Text("Could not load the nebula :("));

};

However, this can cause notable dropped frames, as the paint that occurs after inserting the image into the DOM causes a

synchronous decode on the main thread.

This can instead be rewritten using the p325 decode() method:

const img = new Image();

img.src = "nebula.jpg";



326

img.decode().then(() => {

document.body.appendChild(img);

}).catch(() => {

document.body.appendChild(new Text("Could not load the nebula :("));

});

This latter form avoids the dropped frames of the original, by allowing the user agent to decode the image p42 in parallel, and only

inserting it into the DOM (and thus causing it to be painted) once the decoding process is complete.



Example

Because the p325 decode() method attempts to ensure that the decoded image data is available for at least one frame, it can be

combined with the p984 requestAnimationFrame() API. This means it can be used with coding styles or frameworks that ensure that

all DOM modifications are batched together as p984 animation frame callbacks:

const container = document.querySelector("#container");

const { containerWidth, containerHeight } = computeDesiredSize(); requestAnimationFrame(() => {

container.style.width = containerWidth;

container.style.height = containerHeight;

});

// ...

const img = new Image();

img.src = "supernova.jpg";

img.decode().then(() => {

requestAnimationFrame(() => container.appendChild(img));

});



A legacy factory function is provided for creating p321 HTMLImageElement objects (in addition to the factory methods from DOM such as ✔ MDN

createElement()): Image(width, height). When invoked, the legacy factory function must perform the following steps:

1. Let p911 p829 document be the current global object 's associated Document .

2. Let p321 img be the result of creating an element given document , img , and the HTML namespace.

3. If p450 width is given, then set an attribute value for img using " width" and width.

4. If p450 height is given, then set an attribute value for img using " height " and height.

5. Return img.

Example

A single image can have different appropriate alternative text depending on the context.

In each of the following cases, the same image is used, yet the p322 alt text is different each time. The image is the coat of arms of

the Carouge municipality in the canton Geneva in Switzerland.

Here it is used as a supplementary icon:



I lived in Carouge.



Here it is used as an icon representing the town:



Home town:



Here it is used as part of a text on the town:



327



Carouge has a coat of arms.





It is used as decoration all over the town.



Here it is used as a way to support a similar text where the description is given as well as, instead of as an alternative to, the

image:



Carouge has a coat of arms.





The coat of arms depicts a lion, sitting in front of a tree. It is used as decoration all over the town.



Here it is used as part of a story:



She picked up the folder and a piece of paper fell out.





She stared at the folder. S! The answer she had been looking for all this time was simply the letter S! How had she not seen that before? It all came together now. The phone call where Hector had referred to a lion's tail, the time Maria had stuck her tongue out...



Here it is not known at the time of publication what the image will be, only that it will be a coat of arms of some kind, and thus no

replacement text can be provided, and instead only a brief caption for the image is provided, in the p140 title attribute:



The last user to have uploaded a coat of arms uploaded this one:





Ideally, the author would find a way to provide real replacement text even in this case, e.g. by asking the previous user. Not

providing replacement text makes the document more difficult to use for people who are unable to view images, e.g. blind users,

or users or very low-bandwidth connections or who pay by the byte, or users who are forced to use a text-only web browser.



Example

Here are some more examples showing the same picture used in different contexts, with different appropriate alternate texts each

time.





My cats





Fluffy





Fluffy is my favorite.





She's just too cute.





Miles





My other cat, Miles just eats and sleeps.





Photography





Shooting moving targets indoors





The trick here is to know how to anticipate; to know at what speed and what distance the subject will pass by.





Nature by night





To achieve this, you'll need either an extremely sensitive film, or immense flash lights.





328





About me





My pets





I've got a cat named Fluffy and a dog named Miles.





My dog Miles and I like go on long walks together.





music





After our walks, having emptied my mind, I like listening to Bach.





Fluffy and the Yarn





Fluffy was a cat who liked to play with yarn. She also liked to jump.





She would play in the morning, she would play in the evening.





4.8.4 Images p32 §

9

4.8.4.1 Introduction p32 §

9

This section is non-normative.

To embed an image in HTML, when there is only a single image resource, use the p321 p322 img element and its src attribute.

Example





From today's featured article





Marie Lloyd (1870–1922)

was an English music hall singer, ...



However, there are a number of situations for which the author might wish to use multiple image resources that the user agent can choose from:

• Different users might have different environmental characteristics:

◦ The users' physical screen size might be different from one another.

Example

A mobile phone's screen might be 4 inches diagonally, while a laptop's screen might be 14 inches diagonally.



14″



4″



Note

This is only relevant when an image's rendered size depends on the viewport size.

329

◦ The users' screen pixel density might be different from one another.

Example

A mobile phone's screen might have three times as many physical pixels per inch compared to another mobile phone's screen, regardless of their physical screen size.



1x 3x



◦ The users' zoom level might be different from one another, or might change for a single user over time.

Example

A user might zoom in to a particular image to be able to get a more detailed look.

The zoom level and the screen pixel density (the previous point) can both affect the number of physical screen

pixels per CSS pixel. This ratio is usually referred to as device-pixel-ratio.

◦ The users' screen orientation might be different from one another, or might change for a single user over time.

Example

A tablet can be held upright or rotated 90 degrees, so that the screen is either "portrait" or "landscape".



Portrait

Landscape



◦ The users' network speed, network latency and bandwidth cost might be different from one another, or might

change for a single user over time.

Example

A user might be on a fast, low-latency and constant-cost connection while at work, on a slow, low-latency and constant-cost connection while at home, and on a variable-speed, high-latency and variable-cost connection anywhere else.

• Authors might want to show the same image content but with different rendered size depending on, usually, the width of the

viewport. This is usually referred to as viewport-based selection.

Example

A web page might have a banner at the top that always spans the entire viewport width. In this case, the rendered size of the image depends on the physical size of the screen (assuming a maximised browser window).



330



Example



Another web page might have images in columns, with a single column for screens with a small physical size, two columns for screens with medium physical size, and three columns for screens with big physical size, with the images

varying in rendered size in each case to fill up the viewport. In this case, the rendered size of an image might be bigger in the one-column layout compared to the two-column layout, despite the screen being smaller.



Medium, 2 columns



Narrow, 1 column

Wide, 3 columns





• Authors might want to show different image content depending on the rendered size of the image. This is usually referred to



as art direction.



Example

When a web page is viewed on a screen with a large physical size (assuming a maximised browser window), the author might wish to include some less relevant parts surrounding the critical part of the image. When the same web page is viewed on a screen with a small physical size, the author might wish to show only the critical part of the image.





• Authors might want to show the same image content but using different image formats, depending on which image formats



the user agent supports. This is usually referred to as image format-based selection.

Example

A web page might have some images in the JPEG, WebP and JPEG XR image formats, with the latter two having better compression abilities compared to JPEG. Since different user agents can support different image formats, with some formats offering better compression ratios, the author would like to serve the better formats to user agents that support them, while providing JPEG fallback for user agents that don't.

The above situations are not mutually exclusive. For example, it is reasonable to combine different resources for different device-pixel-

331

ratio p330 p331 with different resources for art direction.

While it is possible to solve these problems using scripting, doing so introduces some other problems:

• Some user agents aggressively download images specified in the HTML markup, before scripts have had a chance to run, so

that web pages complete loading sooner. If a script changes which image to download, the user agent will potentially start two separate downloads, which can instead cause worse page loading performance.

• If the author avoids specifying any image in the HTML markup and instead instantiates a single download from script, that

avoids the double download problem above but then no image will be downloaded at all for users with scripting disabled and the aggressive image downloading optimization will also be disabled.

With this in mind, this specification introduces a number of features to address the above problems in a declarative manner.

Device-pixel-ratio p330-based selection when the rendered size of the image is fixed

The p322 p322 p321 src and srcset attributes on the img element can be used, using the x descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).

Note

The x descriptor is not appropriate when the rendered size of the image depends on the viewport width (viewport-based

selection p330 p331 ), but can be used together with art direction.



Example





From today's featured article





srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x" alt="" width="100" height="150">



Marie Lloyd (1870–1922)

was an English music hall singer, ...

The user agent can choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.

For backwards compatibility with older user agents that don't yet understand the p322 srcset attribute, one of the URLs is

specified in the p321 p322 img element's src attribute. This will result in something useful (though perhaps lower-resolution than the

user would like) being displayed even in older user agents. For new user agents, the p322 src attribute participates in the

resource selection, as if it was specified in p322 srcset with a 1x descriptor.

The image's rendered size is given in the p450 p450 width and height attributes, which allows the user agent to allocate space for the image before it is downloaded.

Viewport-based selection p330

The p322 p322 srcset and sizes attributes can be used, using the w descriptor, to provide multiple images that only vary in their size (the smaller image is a scaled-down version of the bigger image).

Example

In this example, a banner image takes up the entire viewport width (using appropriate CSS).





src="wolf-400.jpg" alt="The rad wolf">





The user agent will calculate the effective pixel density of each image from the specified w descriptors and the specified

rendered size in the p322 sizes attribute. It can then choose any of the given resources depending on the user's screen's pixel density, zoom level, and possibly other factors such as the user's network conditions.

If the user's screen is 320 CSS pixels wide, this is equivalent to specifying wolf-400.jpg 1.25x, wolf-800.jpg 2.5x,

wolf-1600.jpg 5x. On the other hand, if the user's screen is 1200 CSS pixels wide, this is equivalent to specifying

wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x p322 . By using the w descriptors and the sizes attribute, the user agent can choose the correct image source to download regardless of how large the user's device is.

For backwards compatibility, one of the URLs is specified in the p321 p322 img element's src attribute. In new user agents, the

332

src p322 p322 attribute is ignored when the srcset attribute uses w descriptors.



Example

In this example, the web page has three layouts depending on the width of the viewport. The narrow layout has one column of images (the width of each image is about 100%), the middle layout has two columns of images (the width of each image is about 50%), and the widest layout has three columns of images, and some page margin (the width of each image is about

33%). It breaks between these layouts when the viewport is 30em wide and 50em wide, respectively.



srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w" src="swing-400.jpg" alt="Kettlebell Swing">

The p322 sizes attribute sets up the layout breakpoints at 30em and 50em, and declares the image sizes between these breakpoints to be 100vw, 50vw, or calc(33vw - 100px). These sizes do not necessarily have to match up exactly with the actual image width as specified in the CSS.

The user agent will pick a width from the p322 sizes attribute, using the first item with a <media-condition> (the part in parentheses) that evaluates to true, or using the last item (calc(33vw - 100px)) if they all evaluate to false.

For example, if the viewport width is 29em, then (max-width: 30em) evaluates to true and 100vw is used, so the image size, for

the purpose of resource selection, is 29em. If the viewport width is instead 32em, then (max-width: 30em) evaluates to false, but (max-width: 50em) evaluates to true and 50vw is used, so the image size, for the purpose of resource selection, is 16em

(half the viewport width). Notice that the slightly wider viewport results in a smaller image because of the different layout.

The user agent can then calculate the effective pixel density and choose an appropriate resource similarly to the previous example.

Art direction p331-based selection

The p317 p318 p319 picture element and the source element, together with the media attribute, can be used, to provide multiple images that vary the image content (for instance the smaller image might be a cropped version of the bigger image).

Example





The user agent will choose the first p318 p319 source element for which the media query in the media attribute matches, and then

choose an appropriate URL from its p318 srcset attribute.

The rendered size of the image varies depending on which resource is chosen. To specify dimensions that the user agent can use before having downloaded the image, CSS can be used.

CSS img { width: 300px; height: 300px }

@media (min-width: 32em) { img { width: 500px; height:300px } } @media (min-width: 45em) { img { width: 700px; height:400px } }



Example

This example combines p331 p330 art direction- and device-pixel-ratio-based selection. A banner that takes half the viewport is provided in two versions, one for wide screens and one for narrow screens.





333

Image format-based selection p331

The p318 p318 type attribute on the source element can be used, to provide multiple images in different formats.

Example





From today's featured article





Marie Lloyd (1870–1922)

was an English music hall singer, ...

In this example, the user agent will choose the first source that has a p318 type attribute with a supported MIME type. If the user

agent supports WebP images, the first p318 source element will be chosen. If not, but the user agent does support JPEG XR

images, the second p318 p321 source element will be chosen. If neither of those formats are supported, the img element will be chosen.



4.8.4.1.1 Adaptive images p33 §

4

This section is non-normative.

CSS and media queries can be used to construct graphical page layouts that adapt dynamically to the user's environment, in particular to different p321 viewport dimensions and pixel densities. For content, however, CSS does not help; instead, we have the img element's

srcset p322 p317 attribute and the picture element. This section walks through a sample case showing how to use these features.

Consider a situation where on wide screens (wider than 600 CSS pixels) a 300×150 image named a-rectangle.png is to be used, but on smaller screens (600 CSS pixels and less), a smaller 100×100 image called a-square.png is to be used. The markup for this would look like this:





Barney Frank, 2011





Note

For details on what to put in the p322 p349 alt attribute, see the Requirements for providing text to act as an alternative for images

section.

The problem with this is that the user agent does not necessarily know what dimensions to use for the image when the image is loading. To avoid the layout having to be reflowed multiple times as the page is loading, CSS and CSS media queries can be used to provide the dimensions:





Barney Frank, 2011





334

Alternatively, the p450 p450 width and height attributes can be used to provide the width and height for legacy user agents, using CSS

just for the user agents that support p317 picture:





alt="Barney Frank wears a suit and glasses." id="a">





Barney Frank, 2011





The p321 p322 img element is used with the src attribute, which gives the URL of the image to use for legacy user agents that do not support the p317 p322 picture element. This leads to a question of which image to provide in the src attribute.

If the author wants the biggest image in legacy user agents, the markup could be as follows:





However, if legacy mobile user agents are more important, one can list all three images in the p318 source elements, overriding the

src p322 attribute entirely.





Since at this point the p322 p317 p322 src attribute is actually being ignored entirely by picture-supporting user agents, the src attribute can default to any image, including one that is neither the smallest nor biggest:





Above the max-width media feature is used, giving the maximum (viewport) dimensions that an image is intended for. It is also possible to use min-width instead.





335

4.8.4.2 Attributes common to p318 p321 p158 p33 source , img , and link elements §

6

4.8.4.2.1 Srcset attributes p33 §

6

A srcset attribute is an attribute with requirements defined in this section.

If present, its value must consist of one or more p336 image candidate strings , each separated from the next by a U+002C COMMA character (,). If an p336 image candidate string contains no descriptors and no ASCII whitespace after the URL, the following image

candidate string p336, if there is one, must begin with one or more ASCII whitespace.

An image candidate string consists of the following components, in order, with the further restrictions described below this list:

1. Zero or more ASCII whitespace.

2. A p88 valid non-empty URL that does not start or end with a U+002C COMMA character (,), referencing a non-interactive,

optionally animated, image resource that is neither paged nor scripted.

3. Zero or more ASCII whitespace.

4. Zero or one of the following:

◦ A p69 width descriptor , consisting of: ASCII whitespace , a valid non-negative integer giving a number greater than

zero representing the width descriptor value, and a U+0077 LATIN SMALL LETTER W character.

◦ A p69 pixel density descriptor , consisting of: ASCII whitespace , a valid floating-point number giving a number

greater than zero representing the pixel density descriptor value, and a U+0078 LATIN SMALL LETTER X character.

5. Zero or more ASCII whitespace.

There must not be an p336 p336 image candidate string for an element that has the same width descriptor value as another image

candidate string p336 p336 's width descriptor value for the same element.

There must not be an p336 p336 image candidate string for an element that has the same pixel density descriptor value as another image

candidate string p336 p336 's pixel density descriptor value for the same element. For the purpose of this requirement, an image candidate

string p336 p336 with no descriptors is equivalent to an image candidate string with a 1x descriptor.

If an p336 p336 p336 image candidate string for an element has the width descriptor specified, all other image candidate strings for that element must also have the p336 width descriptor specified.

The specified width in an p336 p336 image candidate string 's width descriptor must match the intrinsic width in the resource given by the

image candidate string p336 's URL, if it has an intrinsic width.

If an element has a p336 p336 p336 sizes attribute present, all image candidate strings for that element must have the width descriptor

specified.



4.8.4.2.2 Sizes attributes p33 §

6

A sizes attribute is an attribute with requirements defined in this section.

If present, the value must be a p336 valid source size list.

A p1277 p1279 valid source size list is a string that matches the following grammar: [CSSVALUES] [MQ]

<source-size-list> = [ <source-size># , ]? <source-size-value>

<source-size> = <media-condition> <source-size-value>

<source-size-value> = <length>

A p336 <source-size-value> must not be negative, and must not use CSS functions other than the math functions.

The p336 <source-size-value> gives the intended layout width of the image. The author can specify different widths for different environments with <media-condition>s.



336

Note

Percentages are not allowed in a p336 <source-size-value> , to avoid confusion about what it would be relative to. The 'vw' unit can

be used for sizes relative to the viewport width.



4.8.4.3 Processing model p33 §

7



An p321 p337 p337 img element has a current request and a pending request . The current request is initially set to a new image request .

The p337 pending request is initially set to null.

An image request has a state, current URL, and image data.

An p337 p337 image request 's state is one of the following:

Unavailable

The user agent hasn't obtained any image data, or has obtained some or all of the image data but hasn't yet decoded enough of the image to get the image dimensions.

Partially available

The user agent has obtained some of the image data and at least the image dimensions are available.

Completely available

The user agent has obtained all of the image data and at least the image dimensions are available.

Broken

The user agent has obtained all of the image data that it can, but it cannot even decode the image enough to get the image dimensions (e.g. the image is corrupted, or the format is not supported, or no data could be obtained).

An p337 p337 image request 's current URL is initially the empty string.

An p337 p337 image request 's image data is the decoded image data.

When an p337 p337 p337 p337 p337 image request 's state is either partially available or completely available , the image request is said to be available.

When an p321 p337 p337 p337 img element's current request 's state is completely available and the user agent can decode the media data without errors, then the p321 img element is said to be fully decodable.

An p337 p337 p337 image request 's state is initially unavailable.

When an p321 p337 p337 p321 img element's current request is available , the img element provides a paint source whose width is the image's

density-corrected intrinsic width p337 p337 (if any), whose height is the image's density-corrected intrinsic height (if any), and whose appearance is the intrinsic appearance of the image.



An p321 p322 p317 img element is said to use srcset or picture if it has a srcset attribute specified or if it has a parent that is a picture element.



Each p321 img element has a last selected source, which must initially be null.

Each p337 image request has a current pixel density, which must initially be undefined.

When an p321 p337 img element has a current pixel density that is not 1.0, the element's image data must be treated as if its resolution, in device pixels per p337 CSS pixels , was the current pixel density . The image's density-corrected intrinsic width and height are the

intrinsic width and height p337 after taking into account the current pixel density.

Example

For example, if the p337 current pixel density is 3.125, that means that there are 300 device pixels per CSS inch, and thus if the

image data is 300x600, it has intrinsic dimensions of 96 CSS pixels by 192 CSS pixels.



337

All p321 p158 p338 img and link elements are associated with a source set.

A p338 p338 source set is an ordered set of zero or more image sources and a source size.

An p336 p336 image source is a URL , and optionally either a pixel density descriptor , or a width descriptor.

A p336 p338 source size is a <source-size-value> . When a source size has a unit relative to the viewport, it must be interpreted relative to the p321 p1279 img element's node document 's viewport . Other units must be interpreted the same as in Media Queries. [MQ]



A parse error for algorithms in this section indicates a non-fatal mismatch between input and requirements. User agents are encouraged to expose p338 parse error s somehow.



Whether the image is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the image's type and whether it is a valid image.

Note

This allows servers to return images with error responses, and have them displayed.

The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type

headers p90 giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's

associated Content-Type headers p90.

User agents must not support non-image resources with the p321 img element (e.g. XML files whose document element is an HTML element). User agents must not run executable code (e.g. scripts) embedded in the image resource. User agents must only display the first page of a multipage resource (e.g. a PDF file). User agents must not allow the resource to act in an interactive fashion, but should honour any animation in the resource.

This specification does not specify which image types are to be supported.



4.8.4.3.1 When to obtain images p33 §

8

By default, images are obtained immediately. User agents may provide users with the option to instead obtain them on-demand. (The on-demand option might be used by bandwidth-constrained users, for example.) When obtaining images immediately, the user agent must synchronously p340 p321 update the image data of the img element, with the restart animation p338 flag set if so stated, whenever that element is created or has experienced relevant mutations.

When obtaining images on demand, the user agent must p340 p321 update the image data of an img element whenever it needs the image data (i.e., on demand), but only if the p321 p337 p337 p337 p321 img element's current request 's state is unavailable . When an img

element has experienced p338 p321 relevant mutations , if the user agent only obtains images on demand, the img element's current

request p337 p337 p337 's state must return to unavailable.



4.8.4.3.2 Reacting to DOM mutations p33 §

8

The p321 relevant mutations for an img element are as follows:

• The element's p322 p322 p450 p322 src , srcset , width , or sizes attributes are set, changed, or removed.

• The element's p322 src attribute is set to the same value as the previous value. This must set the restart animation flag for the

update the image data p340 algorithm.

• The element's p322 crossorigin attribute's state is changed.

• The element's p322 referrerpolicy attribute's state is changed.

• The p44 p44 p317 element is inserted into or removed from a picture parent element.

• The element's parent is a p317 p318 p44 picture element and a source element is inserted as a previous sibling.

338

• The element's parent is a p317 p318 p44 picture element and a source element that was a previous sibling is removed.

• The element's parent is a p317 p318 p318 picture element and a source element that is a previous sibling has its srcset,

sizes p319 p319 p318 , media , or type attributes set, changed, or removed.

• The element's adopting steps are run.



4.8.4.3.3 The list of available images p33 §

9

Each p115 Document object must have a list of available images. Each image in this list is identified by a tuple consisting of an

absolute URL p91 p91 p841 , a CORS settings attribute mode, and, if the mode is not No CORS , an origin . Each image furthermore has an ignore higher-layer caching p115 p339 flag. User agents may copy entries from one Document object's list of available images to another at any time (e.g. when the p115 Document is created, user agents can add to it all the images that are loaded in other

Document p115s), but must not change the keys of entries copied in this way when doing so, and must unset the ignore higher-layer

caching p339 flag for the copied entry. User agents may also remove images from such lists at any time (e.g. to save memory). User agents must remove entries in the p339 list of available images as appropriate given higher-layer caching semantics for the resource (e.g. the HTTP ` p339 Cache-Control ` response header) when the ignore higher-layer caching flag is unset.

Note

The p339 p322 list of available images is intended to enable synchronous switching when changing the src attribute to a URL that has

previously been loaded, and to avoid re-downloading images in the same document even when they don't allow caching per HTTP.

It is not used to avoid re-downloading the same image while the previous image is still loading.



Note

The user agent can also store the image data separately from the p339 list of available images .



Example

For example, if a resource has the HTTP response header `Cache-Control: must-revalidate`, and its ignore higher-layer

caching p339 p339 flag is unset, the user agent would remove it from the list of available images but could keep the image data

separately, and use that if the server responds with a 304 Not Modified status.



4.8.4.3.4 Decoding images p33 §

9

Image data is usually encoded in order to reduce file size. This means that in order for the user agent to present the image to the screen, the data needs to be decoded. Decoding is the process which converts an image's media data into a bitmap form, suitable for presentation to the screen. Note that this process can be slow relative to other processes involved in presenting content. Thus, the user agent can choose when to perform decoding, in order to create the best user experience.

Image decoding is said to be synchronous if it prevents presentation of other content until it is finished. Typically, this has an effect of atomically presenting the image and any other content at the same time. However, this presentation is delayed by the amount of time it takes to perform the decode.

Image decoding is said to be asynchronous if it does not prevent presentation of other content. This has an effect of presenting non-image content faster. However, the image content is missing on screen until the decode finishes. Once the decode is finished, the screen is updated with the image.

In both synchronous and asynchronous decoding modes, the final content is presented to screen after the same amount of time has MDN elapsed. The main difference is whether the user agent presents non-image content ahead of presenting the final content.

In order to aid the user agent in deciding whether to perform synchronous or asynchronous decode, the p322 decoding attribute can be set on p321 p322 img elements. The possible values of the decoding attribute are the following image decoding hint keywords:

Keyword State Description

sync p339 Sync Indicates a preference to decode this image synchronously for atomic presentation with other content.

async p339 Async Indicates a preference to decode this image asynchronously to avoid delaying presentation of other content. auto Auto Indicates no preference in decoding mode (the default).



339

When p339 p322 decoding an image, the user agent should respect the preference indicated by the decoding attribute's state. If the state indicated is p339 auto, then the user agent is free to choose any decoding behavior.

Note

It is also possible to control the decoding behavior using the p325 p325 decode() method. Since the decode() method performs

decoding p339 p322 independently from the process responsible for presenting content to screen, it is unaffected by the decoding

attribute.



4.8.4.3.5 Updating the image data p34 §

0

Note

This algorithm cannot be called from steps running p42 in parallel. If a user agent needs to call this algorithm from steps running in

parallel p42 p933 , it needs to queue a task to do so.

When the user agent is to p321 update the image data of an img element, optionally with the restart animations flag set, it must run the following steps:

1. If the element's p814 node document is not the active document , then:

1. Continue running this algorithm p42 in parallel.

2. Wait until the element's p814 node document is the active document.

3. If another instance of this algorithm for this p321 img element was started after this instance (even if it aborted and

is no longer running), then return.

4. p933 Queue a microtask to continue this algorithm.

2. If the user agent cannot support images, or its support for images has been disabled, then p343 abort the image request for

the p337 p337 p337 p337 p337 current request and the pending request , set current request 's state to unavailable , set pending

request p337 to null, and return.

3. Let selected source be null and selected pixel density be undefined.

4. If the element does not p337 p322 use srcset or picture and it has a src attribute specified whose value is not the empty

string, then set p322 selected source to the value of the element's src attribute and set selected pixel density to 1.0.

5. Set the element's p337 last selected source to selected source.

6. If selected source is not null, then:

1. p89 Parse selected source, relative to the element's node document. If that is not successful, then abort this inner

set of steps. Otherwise, let p89 urlString be the resulting URL string.

2. Let p321 p322 key be a tuple consisting of urlString , the img element's crossorigin attribute's mode, and, if that mode

is not p91 p841 No CORS , the node document 's origin.

3. If the p339 list of available images contains an entry for key, then:

1. Set the p339 ignore higher-layer caching flag for that entry.

2. p343 p337 p337 Abort the image request for the current request and the pending request .

3. Set p337 pending request to null.

4. Let p337 p337 p337 current request be a new image request whose image data is that of the entry and whose

state p337 p337 is completely available.

5. Update the presentation of the image appropriately.

6. Set p337 p337 current request 's current pixel density to selected pixel density.

7. p933 p939 p321 Queue an element task on the DOM manipulation task source given the img element and

following steps:

340

1. If p1207 restart animation is set, then restart the animation.

2. Set p337 p337 current request 's current URL to urlString.

3. p1271 p321 Fire an event named load at the img element.

8. Abort the p340 update the image data algorithm.

7. p933 p932 Queue a microtask to perform the rest of this algorithm, allowing the task that invoked this algorithm to continue.

8. If another instance of this algorithm for this p321 img element was started after this instance (even if it aborted and is no

longer running), then return.

Note

Only the last instance takes effect, to avoid multiple requests when, for example, the p322 p322 src , srcset, and

crossorigin p322 attributes are all set in succession.

9. Let p343 selected source and selected pixel density be the URL and pixel density that results from selecting an image source ,

respectively.

10. If selected source is null, then:

1. Set the p337 p337 p337 p343 p337 current request 's state to broken , abort the image request for the current request and the

pending request p337 p337 , and set pending request to null.

2. p933 p939 p321 Queue an element task on the DOM manipulation task source given the img element and the following

steps:

1. Change the p337 p337 current request 's current URL to the empty string.

2. If the element has a p322 p337 p1271 src attribute or it uses srcset or picture , fire an event named error at

the p321 img element.

3. Return.

11. p89 p89 Parse selected source , relative to the element's node document , and let urlString be the resulting URL string. If that is

not successful, then:

1. p343 p337 p337 Abort the image request for the current request and the pending request .

2. Set the p337 p337 p337 current request 's state to broken .

3. Set p337 pending request to null.

4. p933 p939 p321 Queue an element task on the DOM manipulation task source given the img element and the following

steps:

1. Change the p337 p337 current request 's current URL to selected source.

2. p1271 p321 Fire an event named error at the img element.

5. Return.

12. If the p337 p337 p337 pending request is not null and urlString is the same as the pending request 's current URL , then return.

13. If p337 p337 p337 p337 p337 urlString is the same as the current request 's current URL and current request 's state is partially available ,

then p343 p337 p933 abort the image request for the pending request , queue an element task on the DOM manipulation task

source p939 p321 p1207 given the img element to restart the animation if restart animation is set, and return.

14. If the p337 p343 p337 pending request is not null, then abort the image request for the pending request.

15. Set p337 p337 image request to a new image request whose current URL is urlString.

16. If p337 p337 p337 p337 p337 current request 's state is unavailable or broken , then set the current request to image request. Otherwise,

set the p337 pending request to image request.

17. Let p90 request be the result of creating a potential-CORS request given urlString, "image", and the current state of the

element's p322 crossorigin content attribute.

18. Set p911 request 's client to the element's node document 's relevant settings object.

341

19. If the element p337 uses srcset or picture, set request's initiator to "imageset".

20. Set p322 request 's referrer policy to the current state of the element's referrerpolicy attribute.

21. Let p321 p93 p93 p911 delay load event be true if the img 's lazy loading attribute is in the Eager state, or if scripting is disabled for

the p321 img , and false otherwise.

22. If the p93 p321 will lazy load element steps given the img return true, then:

1. Set the p321 p93 img 's lazy load resumption steps to the rest of this algorithm starting with the step labeled fetch the

image.

2. p93 p321 Start intersection-observing a lazy loading element for the img element.

3. Return.

23. Fetch the image: Fetch request. Let this instance of the fetching algorithm be associated with image request.

The resource obtained in this fashion, if any, is p337 p90 image request 's image data . It can be either CORS-same-origin or

CORS-cross-origin p90 p841 p635 ; this affects the origin of the image itself (e.g. when used on a canvas).

When p1162 delay load event is true, fetching the image must delay the load event of the element's node document until the

task p932 p933 p939 p343 that is queued by the networking task source once the resource has been fetched ( defined below ) has been run.

⚠Warning!

This, unfortunately, can be used to perform a rudimentary port scan of the user's local network (especially in conjunction with scripting, though scripting isn't actually necessary to carry out such an attack). User

agents may implement p841 cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing web content.

24. Continue the remaining steps p42 in parallel, but without missing any data from fetching.

25. As soon as possible, jump to the first applicable entry from the following list:

↪ p1242 If the resource type is multipart/x-mixed-replace

The next p932 p933 p939 task that is queued by the networking task source while the image is being fetched must run the following steps:

1. If p337 image request is the pending request and at least one body part has been completely decoded, abort

the image request p343 p337 p343 for the current request , upgrade the pending request to the current request.

2. Otherwise, if p337 image request is the pending request and the user agent is able to determine that image

request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, abort

the image request p343 p337 p343 for the current request , upgrade the pending request to the current request,

and set the p337 p337 p337 current request 's state to broken .

3. Otherwise, if p337 p337 p337 image request is the current request , its state is unavailable , and the user agent is

able to determine p337 p337 image request 's image's width and height, set the current request 's state to

partially available p337 .

4. Otherwise, if p337 p337 p337 image request is the current request , its state is unavailable , and the user agent is

able to determine that image request's image is corrupted in some fatal way such that the image

dimensions cannot be obtained, set the p337 p337 p337 current request 's state to broken.

Each p932 p933 p939 task that is queued by the networking task source while the image is being fetched must update the presentation of the image, but as each new body part comes in, it must replace the previous image. Once one body

part has been completely decoded, the user agent must set the p321 p337 p337 img element's current request 's state to

completely available p337 p933 p939 p321 and queue an element task on the DOM manipulation task source given the img

element to p1271 p321 fire an event named load at the img element.

↪ p338 If the resource type and data corresponds to a supported image format, as described below

The next p932 p933 p939 task that is queued by the networking task source while the image is being fetched must run the following steps:

1. If the user agent is able to determine image request's image's width and height, and image request is

342

pending request p337 p337 p337 , set image request 's state to partially available.

2. Otherwise, if the user agent is able to determine image request's image's width and height, and image

request p337 p321 is current request , update the img element's presentation appropriately and set image

request p337 p337 's state to partially available.

3. Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way

such that the image dimensions cannot be obtained, and p337 image request is pending request , abort the

image request p343 p337 p337 for the current request and the pending request , upgrade the pending request to

the current request p343 p337 p337 p337 p1271 , set current request 's state to broken , and fire an event named error

at the p321 img element.

4. Otherwise, if the user agent is able to determine that image request's image is corrupted in some fatal way

such that the image dimensions cannot be obtained, and p337 image request is current request, abort the

image request p343 p1271 p321 for image request and fire an event named error at the img element.

That p932 p932 p933 p939 task , and each subsequent task , that is queued by the networking task source while the image is

being fetched, if p337 image request is the current request, must update the presentation of the image appropriately (e.g., if the image is a progressive JPEG, each packet can improve the resolution of the image).

Furthermore, the last p932 p933 p939 task that is queued by the networking task source once the resource has been fetched must additionally run these steps:

1. If p337 p343 p337 image request is the pending request , abort the image request for the current request, upgrade

the pending request to the current request p343 p321 and update the img element's presentation appropriately.

2. Set p337 image request to the completely available state.

3. Add the image to the p339 p339 list of available images using the key key , with the ignore higher-layer caching

flag set.

4. p1271 p321 Fire an event named load at the img element.

↪ Otherwise

The image data is not in a supported file format; the user agent must set p337 p337 image request 's state to broken ,

abort the image request p343 p337 p337 for the current request and the pending request , upgrade the pending request to

the current request p343 p337 p933 if image request is the pending request , and then queue an element task on the DOM

manipulation task source p939 p321 p1271 p321 given the img element to fire an event named error at the img element.

While a user agent is running the above algorithm for an element x, there must be a strong reference from the element's node

document to the element x, even if that element is not connected.

To p337 abort the image request for an image request image request means to run the following steps:

1. Forget p337 image request 's image data, if any.

2. Abort any instance of the fetching algorithm for image request, discarding any pending tasks generated by that algorithm.

To p321 upgrade the pending request to the current request for an img element means to run the following steps:

1. Let the p321 p337 p337 img element's current request be the pending request .

2. Let the p321 p337 img element's pending request be null.



4.8.4.3.6 Selecting an image source §p34

3

When asked to p321 p158 select an image source for a given img or link element el, user agents must do the following:

1. p344 Update the source set for el.

2. If p338 el 's source set is empty, return null as the URL and undefined as the pixel density.

3. Otherwise, take p338 el 's source set and let it be source set.

4. If an entry p336 b in source set has the same associated pixel density descriptor as an earlier entry a in source set, then

343

remove entry p336 b . Repeat this step until none of the entries in source set have the same associated pixel density descriptor

as an earlier entry.

5. In a user agent-specific manner, choose one p338 image source from source set. Let this be selected source.

6. Return selected source and its associated pixel density.



4.8.4.3.7 Updating the source set p34 §

4

When asked to p321 p158 update the source set for a given img or link element el, user agents must do the following:

1. Set p338 p338 el 's source set to an empty source set.

2. Let elements be « el ».

3. If p321 p317 el is an img element whose parent node is a picture element, then replace the contents of elements with el's parent

node's child elements, retaining relative order.

4. For each child in elements:

1. If child is el:

1. Let p338 source set be an empty source set .

2. If p322 p160 p345 child has a srcset or imagesrcset attribute, parse child 's srcset attribute and set source set

to the returned p338 source set.

3. p347 p338 Parse child 's sizes attribute , and let source set 's source size be the returned value.

4. If p322 p159 child has a src or href attribute whose value is not the empty string and source set does not

contain an p338 p336 p338 image source with a pixel density descriptor value of 1, and no image source with a

width descriptor p336 p322 p159 , append child 's src or href attribute value to source set.

5. p347 Normalize the source densities of source set.

6. Let p338 el 's source set be source set.

7. Return.

Note

If p158 el is a link element, then elements contains only el, so this step will be reached immediately and the rest of the algorithm will not run.

2. Assert: p158 child is not a link element.

3. If p318 p318 child is not a source element, continue to the next child. Otherwise, child is a source element.

4. If p318 child does not have a srcset attribute, continue to the next child.

5. p345 p338 Parse child 's srcset attribute and let the returned source set be source set.

6. If p338 source set has zero image sources, continue to the next child.

7. If p319 p88 child has a media attribute, and its value does not match the environment, continue to the next child.

8. p347 p338 Parse child 's sizes attribute with the fallback width width , and let source set 's source size be the returned

value.

9. If p318 child has a type attribute, and its value is an unknown or unsupported MIME type, continue to the next child.

10. p347 Normalize the source densities of source set.

11. Let p338 el 's source set be source set.

12. Return.



344

Note

Each p321 p318 p321 img element independently considers its previous sibling source elements plus the img element itself for selecting

an p338 p321 p317 image source , ignoring any other (invalid) elements, including other img elements in the same picture element, or

source p318 p321 elements that are following siblings of the relevant img element.



4.8.4.3.8 Parsing a srcset attribute §p34

5

When asked to p336 parse a srcset attribute from an element, parse the value of the element's srcset attribute as follows:

1. Let input be the value passed to this algorithm.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Let p338 candidates be an initially empty source set .

4. Splitting loop: Collect a sequence of code points that are ASCII whitespace or U+002C COMMA characters from input given

position p338 . If any U+002C COMMA characters were collected, that is a parse error.

5. If position is past the end of input, return candidates.

6. Collect a sequence of code points that are not ASCII whitespace from input given position, and let that be url.

7. Let descriptors be a new empty list.

8. If url ends with U+002C (,), then:

1. Remove all trailing U+002C COMMA characters from url. If this removed more than one character, that is a parse

error p338 .

Otherwise:

1. Descriptor tokenizer: Skip ASCII whitespace within input given position.

2. Let current descriptor be the empty string.

3. Let state be in descriptor.

4. Let c be the character at position. Do the following depending on the value of state. For the purpose of this step,

"EOF" is a special character representing that position is past the end of input.

↪ In descriptor

Do the following, depending on the value of c:

↪ ASCII whitespace

If current descriptor is not empty, append current descriptor to descriptors and let current descriptor be the empty string. Set state to after descriptor.

↪ U+002C COMMA (,)

Advance position to the next character in input. If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

↪ U+0028 LEFT PARENTHESIS (()

Append c to current descriptor. Set state to in parens.

↪ EOF

If current descriptor is not empty, append current descriptor to descriptors. Jump to the step labeled descriptor parser.

↪ Anything else

Append c to current descriptor.

↪ In parens

Do the following, depending on the value of c:

↪ U+0029 RIGHT PARENTHESIS ())

Append c to current descriptor. Set state to in descriptor.

345

↪ EOF

Append current descriptor to descriptors. Jump to the step labeled descriptor parser.

↪ Anything else

Append c to current descriptor.

↪ After descriptor

Do the following, depending on the value of c:

↪ ASCII whitespace

Stay in this state.

↪ EOF

Jump to the step labeled descriptor parser.

↪ Anything else

Set state to in descriptor. Set position to the previous character in input.

Advance position to the next character in input. Repeat this step.

Note

In order to be compatible with future additions, this algorithm supports multiple descriptors and descriptors with parens.

9. Descriptor parser: Let error be no.

10. Let width be absent.

11. Let density be absent.

12. Let future-compat-h be absent.

13. For each descriptor in descriptors, run the appropriate set of steps from the following list:

↪ p69 If the descriptor consists of a valid non-negative integer followed by a U+0077 LATIN SMALL LETTER W

character

1. If the user agent does not support the p322 sizes attribute, let error be yes.

Note

A conforming user agent will support the p322 sizes attribute. However, user agents typically implement and ship features in an incremental manner in practice.

2. If width and density are not both absent, then let error be yes.

3. Apply the p69 rules for parsing non-negative integers to the descriptor. If the result is zero, let error be yes.

Otherwise, let width be the result.

↪ p69 If the descriptor consists of a valid floating-point number followed by a U+0078 LATIN SMALL LETTER X

character

1. If width, density and future-compat-h are not all absent, then let error be yes.

2. Apply the p70 rules for parsing floating-point number values to the descriptor. If the result is less than zero,

let error be yes. Otherwise, let density be the result.

Note

If density is zero, the intrinsic dimensions will be infinite. User agents are expected to have limits in how

big images can be rendered, which is allowed by the p48 hardware limitations clause.

↪ p69 If the descriptor consists of a valid non-negative integer followed by a U+0068 LATIN SMALL LETTER H

character

This is a p338 parse error .

1. If future-compat-h and density are not both absent, then let error be yes.

346

2. Apply the p69 rules for parsing non-negative integers to the descriptor. If the result is zero, let error be yes.

Otherwise, let future-compat-h be the result.

↪ Anything else

Let error be yes.

14. If future-compat-h is not absent and width is absent, let error be yes.

15. If p338 error is still no , then append a new image source to candidates whose URL is url, associated with a width width if not

absent p338 and a pixel density density if not absent . Otherwise, there is a parse error.

16. Return to the step labeled splitting loop.



4.8.4.3.9 Parsing a sizes attribute §p34

7

When asked to parse a sizes attribute from an element, parse a comma-separated list of component values from the value of the element's p336 p1277 sizes attribute (or the empty string, if the attribute is absent), and let unparsed sizes list be the result. [CSSSYNTAX]

For each unparsed size in unparsed sizes list:

1. Remove all consecutive <whitespace-token>s from the end of unparsed size. If unparsed size is now empty, that is a parse

error p338 ; continue to the next iteration of this algorithm.

2. If the last p336 component value in unparsed size is a valid non-negative <source-size-value>, let size be its value and remove

the component value from unparsed size. Any CSS function other than the math functions is invalid. Otherwise, there is a

parse error p338; continue to the next iteration of this algorithm.

3. Remove all consecutive <whitespace-token>s from the end of unparsed size. If unparsed size is now empty, return size and

exit this algorithm. If this was not the last item in p338 unparsed sizes list , that is a parse error.

4. Parse the remaining component values in unparsed size as a <media-condition>. If it does not parse correctly, or it does

parse correctly but the p1279 <media-condition> evaluates to false, continue to the next iteration of this algorithm. [MQ]

5. Return size and exit this algorithm.

If the above algorithm exhausts unparsed sizes list without returning a size value, then return 100vw.

Note

While a p336 p336 valid source size list only contains a bare <source-size-value> (without an accompanying <media-condition>) as

the last entry in the p336 <source-size-list>, the parsing algorithm technically allows such at any point in the list, and will accept it

immediately as the size if the preceding entries in the list weren't used. This is to enable future extensions, and protect against

simple author errors such as a final trailing comma.



4.8.4.3.10 Normalizing the source densities §p34

7

An p338 p336 p336 image source can have a pixel density descriptor , a width descriptor , or no descriptor at all accompanying its URL.

Normalizing a p338 p338 p336 source set gives every image source a pixel density descriptor .

When asked to p338 normalize the source densities of a source set source set, the user agent must do the following:

1. Let p338 source size be source set 's source size.

2. For each p338 image source in source set:

1. If the p338 p336 p338 image source has a pixel density descriptor , continue to the next image source .

2. Otherwise, if the p338 p336 p336 image source has a width descriptor , replace the width descriptor with a pixel density

descriptor p336 p336 p336 p338 with a value of the width descriptor value divided by the source size and a unit of x.

Note

If the p338 source size is zero, the density would be infinity, which results in the intrinsic dimensions being zero

347

by zero.

3. Otherwise, give the p338 p336 image source a pixel density descriptor of 1x.



4.8.4.3.11 Reacting to environment changes p34 §

8

The user agent may at any time run the following algorithm to update an p321 img element's image in order to react to changes in the environment. (User agents are not required to ever run this algorithm; for example, if the user is not looking at the page any more, the user agent might want to wait until the user has returned to the page before determining which image to use, in case the environment changes again in the meantime.) Note

User agents are encouraged to run this algorithm in particular when the user changes the viewport's size (e.g. by resizing the

window or changing the page zoom), and when an p321 p44 img element is inserted into a document, so that the density-corrected

intrinsic width and height p337 p331 match the new viewport , and so that the correct image is chosen when art direction is involved.

1. p936 p937 Await a stable state . The synchronous section consists of all the remaining steps of this algorithm until the algorithm

says the p937 p937 synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

2. p321 p337 p814 ⌛ If the img element does not use srcset or picture , its node document is not the active document, has image

data whose resource type is p1242 p337 multipart/x-mixed-replace , or the pending request is not null, then return.

3. p343 ⌛ Let selected source and selected pixel density be the URL and pixel density that results from selecting an image source,

respectively.

4. ⌛ If selected source is null, then return.

5. p337 ⌛ If selected source and selected pixel density are the same as the element's last selected source and current pixel

density p337, then return.

6. p89 p89 ⌛ Parse selected source , relative to the element's node document , and let urlString be the resulting URL string. If that is

not successful, then return.

7. p322 ⌛ Let corsAttributeState be the state of the element's crossorigin content attribute.

8. p841 p321 ⌛ Let origin be the origin of the img element's node document.

9. p321 p911 ⌛ Let client be the img element's node document 's relevant settings object.

10. p91 ⌛ Let key be a tuple consisting of urlString , corsAttributeState , and, if corsAttributeState is not No CORS, origin.

11. p337 p337 ⌛ Let image request be a new image request whose current URL is urlString

12. p337 ⌛ Let the element's pending request be image request.

13. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

14. If the p339 p337 list of available images contains an entry for key , then set image request 's image data to that of the entry.

Continue to the next step.

Otherwise:

1. Let p90 request be the result of creating a potential-CORS request given urlString, "image", and corsAttributeState.

2. Set request's client to client, initiator to "imageset", and set request's synchronous flag.

3. Set p322 request 's referrer policy to the current state of the element's referrerpolicy attribute.

4. Let response be the result of fetching request.

5. If p90 response 's unsafe response is a network error or if the image format is unsupported (as determined by

applying the image sniffing rules, again as mentioned earlier), or if the user agent is able to determine that image request's image is corrupted in some fatal way such that the image dimensions cannot be obtained, or if the

resource type is p1242 p337 multipart/x-mixed-replace , then let pending request be null and abort these steps.

348

6. Otherwise, p90 p337 p90 response 's unsafe response is image request 's image data . It can be either CORS-same-origin

or p90 p841 p635 CORS-cross-origin ; this affects the origin of the image itself (e.g., when used on a canvas).

15. p933 p939 p321 Queue an element task on the DOM manipulation task source given the img element and the following steps:

1. If the p321 p338 img element has experienced relevant mutations since this algorithm started, then let pending

request p337 be null and abort these steps.

2. Let the p321 p337 p321 img element's last selected source be selected source and the img element's current pixel

density p337 be selected pixel density.

3. Set the p337 p337 image request 's state to completely available.

4. Add the image to the p339 p339 list of available images using the key key , with the ignore higher-layer caching flag set.

5. p343 Upgrade the pending request to the current request.

6. Update the p321 img element's presentation appropriately.

7. p1271 p321 Fire an event named load at the img element.



4.8.4.4 Requirements for providing text to act as an alternative for images p34 §

9

4.8.4.4.1 General guidelines p34 §

9

Except where otherwise specified, the p322 alt attribute must be specified and its value must not be empty; the value must be an appropriate replacement for the image. The specific requirements for the p322 alt attribute depend on what the image is intended to represent, as described in the following sections.

The most general rule to consider when writing alternative text is the following: the intent is that replacing every image with the text of its p322 alt attribute does not change the meaning of the page.

So, in general, alternative text can be written by considering what one would have written had one not been able to include the image.

A corollary to this is that the p322 alt attribute's value should never contain text that could be considered the image's caption, title, or legend. It is supposed to contain replacement text that could be used by users instead of the image; it is not meant to supplement the image. The p140 title attribute can be used for supplemental information.

Another corollary is that the p322 alt attribute's value should not repeat information that is already provided in the prose next to the image.

Note

One way to think of alternative text is to think about how you would read the page containing the image to someone over the

phone, without mentioning that there is an image present. Whatever you say instead of the image is typically a good start for

writing the alternative text.



4.8.4.4.2 A link or button containing nothing but the image p34 §

9

When an p239 p284 p536 a element that creates a hyperlink , or a button element, has no textual content but contains one or more images, the p322 alt attributes must contain text that together convey the purpose of the link or button.

Example

In this example, a user is asked to pick their preferred color from a list of three. Each color is given by an image, but for users who

have configured their user agent not to display images, the color names are used instead:





Pick your color





349





Example

In this example, each button has a set of images to indicate the kind of color output desired by the user. The first image is used in

each case to give the alternative text.





Since each image represents one part of the text, it could also be written like this:





However, with other alternative text, this might not work, and putting all the alternative text into one image in each case might

make more sense:





4.8.4.4.3 A phrase or paragraph with an alternative graphical representation: charts, diagrams, graphs, maps, p35 §

illustrations 0

Sometimes something can be more clearly stated in graphical form, for example as a flowchart, a diagram, a graph, or a simple map showing directions. In such cases, an image can be given using the p321 img element, but the lesser textual version must still be given, so that users who are unable to view the image (e.g. because they have a very slow connection, or because they are using a text-only browser, or because they are listening to the page being read out by a hands-free automobile voice web browser, or simply because they are blind) are still able to understand the message being conveyed.

The text must be given in the p322 p322 alt attribute, and must convey the same message as the image specified in the src attribute.

It is important to realize that the alternative text is a replacement for the image, not a description of the image.

Example

In the following example we have p322 a flowchart in image form, with text in the alt attribute rephrasing the flowchart in prose

form:



In the common case, the data handled by the tokenization stage comes from the network, but it can also come from script.





Example

Here's another example, showing a good solution and a bad solution to the problem of including an image in a description.

350

First, here's the good solution. This sample shows how the alternative text should just be what you would have put in the prose if

the image had never existed.





You are standing in an open field west of a house.

There is a small mailbox here.





Second, here's the bad solution. In this incorrect way of doing things, the alternative text is simply a description of the image,

instead of a textual replacement for the image. It's bad because when the image isn't shown, the text doesn't flow as well as in the

first example.





You are standing in an open field west of a house.

There is a small mailbox here.





Text such as "Photo of white house with boarded door" would be equally bad alternative text (though it could be suitable for the

title p140 p236 p233 attribute or in the figcaption element of a figure with this image).



4.8.4.4.4 A short phrase or label with an alternative graphical representation: icons, logos p35 §

1

A document can contain information in iconic form. The icon is intended to help users of visual browsers to recognize features at a glance.

In some cases, the icon is supplemental to a text label conveying the same meaning. In those cases, the p322 alt attribute must be present but must be empty.

Example

Here the icons are next to text that conveys the same meaning, so they have an empty p322 alt attribute:





Help





Configuration Tools





In other cases, the icon has no text next to it describing what it means; the icon is supposed to be self-explanatory. In those cases, an equivalent textual label must be given in the p322 alt attribute.

Example

Here, posts on a news site are labeled with an icon indicating their topic.





Ratatouille wins Best Movie of the Year award





Pixar has won yet another Best Movie of the Year award, making this its 8th win in the last 12 years.





Latest TWiT episode is online





The latest TWiT episode has been posted, in which we hear several tech news stories as well as learning much more about the iPhone. This week, the panelists compare how reflective their iPhones' Apple logos are.





Many pages include logos, insignia, flags, or emblems, which stand for a particular entity such as a company, organization, project, band, software package, country, or some such.

If the logo is being used to represent the entity, e.g. as a page heading, the alt attribute must contain the name of the entity being represented by the logo. The alt attribute must not contain text like the word "logo", as it is not the fact that it is a logo that is being conveyed, it's the entity itself.

If the logo is being used next to the name of the entity that it represents, then the logo is supplemental, and its alt attribute must instead be empty.

If the logo is merely used as decorative material (as branding, or, for example, as a side image in an article that mentions the entity to which the logo belongs), then the entry below on purely decorative images applies. If the logo is actually being discussed, then it is being used as a phrase or paragraph (the description of the logo) with an alternative graphical representation (the logo itself), and the first entry above applies.

Example

In the following snippets, all four of the above cases are present. First, we see a logo used to represent a company:





Next, we see a paragraph which uses a logo right next to the company name, and so doesn't have any alternative text:





News





We have recently been looking at buying the ΑΒΓ company, a small Greek company

specializing in our type of product.



In this third snippet, we have a logo being used in an aside, as part of the larger article discussing the acquisition:





The ΑΒΓ company has had a good quarter, and our

pie chart studies of their accounts suggest a much bigger blue slice than its green and orange slices, which is always a good sign.





Finally, we have an opinion piece talking about a logo, and the logo is therefore described in detail in the alternative text.



Consider for a moment their logo:





How unoriginal can you get? I mean, oooooh, a question mark, how revolutionary, how utterly ground-breaking, I'm



sure everyone will rush to adopt those specifications now! They could at least have tried for some sort of, I don't know, sequence of rounded squares with varying shades of green and bold white outlines, at least that would look good on the cover of a blue book.



This example shows how the alternative text should be written such that if the image isn't available , and the text is used

instead, the text flows seamlessly into the surrounding text, as if the image had never been there in the first place.



4.8.4.4.5 Text that has been rendered to a graphic for typographical effect



Sometimes, an image just consists of text, and the purpose of the image is not to highlight the actual typographic effects used to render the text, but just to convey the text itself.

In such cases, the alt attribute must be present but must consist of the same text as written in the image itself.

Example

Consider a graphic containing the text "Earth Day", but with the letters all decorated with flowers and plants. If the text is merely

being used as a heading, to spice up the page for graphical users, then the correct alternative text is just the same text "Earth

Day", and no mention need be made of the decorations:





Example

An illuminated manuscript might use graphics for some of its images. The alternative text in such a situation is just the character

that the image represents.



nce upon a time and a long long time ago, late at night, when it was dark, over the hills, through the woods, across a great ocean, in a land far away, in a small house, on a hill, under a full moon...



When an image is used to represent a character that cannot otherwise be represented in Unicode, for example gaiji, itaiji, or new characters such as novel currency symbols, the alternative text should be a more conventional way of writing the same thing, e.g. using the phonetic hiragana or katakana to give the character's pronunciation.

Example

In this example from 1997, a new-fangled currency symbol that looks like a curly E with two bars in the middle instead of one is

represented using an image. The alternative text gives the character's pronunciation.



Only 5.99!



An image should not be used if characters would serve an identical purpose. Only when the text cannot be directly represented using text, e.g., because of decorations or because there is no appropriate character (as in the case of gaiji), would an image be appropriate.

Note

If an author is tempted to use an image because their default system font does not support a given character, then web Fonts are

a better solution than images.



4.8.4.4.6 A graphical representation of some of the surrounding text



In many cases, the image is actually just supplementary, and its presence merely reinforces the surrounding text. In these cases, the

alt attribute must be present but its value must be the empty string.





In general, an image falls into this category if removing the image doesn't make the page any less useful, but including the image makes it a lot easier for users of visual browsers to understand the concept.

Example

A flowchart that repeats the previous paragraph in graphical form:



The Network passes data to the Input Stream Preprocessor, which passes it to the Tokenizer, which passes it to the Tree Construction stage. From there, data goes to both the DOM and to Script Execution. Script Execution is linked to the DOM, and, using document.write(), passes data to the Tokenizer.





In these cases, it would be wrong to include alternative text that consists of just a caption. If a caption is to be included, then either

the title attribute can be used, or the figure and figcaption elements can be used. In the latter case, the image

would in fact be a phrase or paragraph with an alternative graphical representation, and would thus require alternative text.





The Network passes data to the Input Stream Preprocessor, which passes it to the Tokenizer, which passes it to the Tree Construction stage. From there, data goes to both the DOM and to Script Execution. Script Execution is linked to the DOM, and, using document.write(), passes data to the Tokenizer.





title="Flowchart representation of the parsing model.">





The Network passes data to the Input Stream Preprocessor, which passes it to the Tokenizer, which passes it to the Tree Construction stage. From there, data goes to both the DOM and to Script Execution. Script Execution is linked to the DOM, and, using document.write(), passes data to the Tokenizer.





Flowchart representation of the parsing model.





The Network passes data to the Input Stream Preprocessor, which passes it to the Tokenizer, which passes it to the Tree Construction stage. From there, data goes to both the DOM and to Script Execution. Script Execution is linked to the DOM, and, using document.write(), passes data to the Tokenizer.





alt="Flowchart representation of the parsing model.">





Example

A graph that repeats the previous paragraph in graphical form:



According to a study covering several billion pages,

about 62% of documents on the web in 2007 triggered the Quirks rendering mode of web browsers, about 30% triggered the Almost Standards mode, and about 9% triggered the Standards mode.





4.8.4.4.7 Ancillary images



Sometimes, an image is not critical to the content, but is nonetheless neither purely decorative nor entirely redundant with the text. In these cases, the alt attribute must be present, and its value should either be the empty string, or a textual representation of the information that the image conveys. If the image has a caption giving the image's title, then the alt attribute's value must not be empty (as that would be quite confusing for non-visual readers).

Example

Consider a news article about a political figure, in which the individual's face was shown in an image that, through a style sheet, is

floated to the right. The image is not purely decorative, as it is relevant to the story. The image is not entirely redundant with the

story either, as it shows what the politician looks like. Whether any alternative text need be provided is an authoring decision, in

part influenced by whether the image colors the interpretation of the prose.

In this first variant, the image is shown without context, and no alternative text is provided:



Ahead of today's referendum, the First Minister of Scotland, Alex Salmond, wrote an open letter to all registered voters. In it, he admitted that all countries make mistakes.



If the picture is just a face, there might be no value in describing it. It's of no interest to the reader whether the individual has red

hair or blond hair, whether the individual has white skin or black skin, whether the individual has one eye or two eyes.

However, if the picture is more dynamic, for instance showing the politician as angry, or particularly happy, or devastated, some

alternative text would be useful in setting the tone of the article, a tone that might otherwise be missed:





Ahead of today's referendum, the First Minister of Scotland, Alex Salmond, wrote an open letter to all registered voters. In it, he admitted that all countries make mistakes.





Ahead of today's referendum, the First Minister of Scotland, Alex Salmond, wrote an open letter to all registered voters. In it, he admitted that all countries make mistakes.



Whether the individual was "sad" or "ecstatic" makes a difference to how the rest of the paragraph is to be interpreted: is he likely

saying that he is resigned to the populace making a bad choice in the upcoming referendum, or is he saying that the election was

a mistake but the likely turnout will make it irrelevant? The interpretation varies based on the image.



Example

If the image has a caption, then including alternative text avoids leaving the non-visual user confused as to what the caption refers

to.



Ahead of today's referendum, the First Minister of Scotland, Alex Salmond, wrote an open letter to all registered voters. In it, he admitted that all countries make mistakes.





alt="A high forehead, cheerful disposition, and dark hair round out Alex Salmond's face.">



Alex Salmond, SNP. Photo © 2014 PolitiPhoto.





4.8.4.4.8 A purely decorative image that doesn't add any information



If an image is decorative but isn't especially page-specific — for example an image that forms part of a site-wide design scheme — the image should be specified in the site's CSS, not in the markup of the document.

However, a decorative image that isn't discussed by the surrounding text but still has some relevance can be included in a page using the img element. Such images are decorative, but still form part of the content. In these cases, the alt attribute must be present but its value must be the empty string.

Example

Examples where the image is purely decorative despite being relevant would include things like a photo of the Black Rock City

landscape in a blog post about an event at Burning Man, or an image of a painting inspired by a poem, on a page reciting that

poem. The following snippet shows an example of the latter case (only the first verse is included in this snippet):





The Lady of Shalott





On either side the river lie



Long fields of barley and of rye,



That clothe the wold and meet the sky;



And through the field the road run by



To many-tower'd Camelot;



And up and down the people go,



Gazing where the lilies blow



Round an island there below,



The island of Shalott.





4.8.4.4.9 A group of images that form a single larger picture with no links



When a picture has been sliced into smaller image files that are then displayed together to form the complete picture again, one of the images must have its alt attribute set as per the relevant rules that would be appropriate for the picture as a whole, and then all the remaining images must have their alt attribute set to the empty string.

Example

In the following example, a picture representing a company logo for XYZ Corp has been split into two pieces, the first containing

the letters "XYZ" and the second with the word "Corp". The alternative text ("XYZ Corp") is all in the first image.





Example

In the following example, a rating is shown as three filled stars and two empty stars. While the alternative text could have been

"★★★☆☆", the author has instead decided to more helpfully give the rating in the form "3 out of 5". That is the alternative text of

the first image, and the rest have blank alternative text.



Rating:

>

>





4.8.4.4.10 A group of images that form a single larger picture with links



Generally, image maps should be used instead of slicing an image for links.

However, if an image is indeed sliced and any of the components of the sliced picture are the sole contents of links, then one image per link must have alternative text in its alt attribute representing the purpose of the link.

Example



In the following example, a picture representing the flying spaghetti monster emblem, with each of the left noodly appendages and

the right noodly appendages in different images, so that the user can pick the left side or the right side in an adventure.





The Church





You come across a flying spaghetti monster. Which side of His Noodliness do you wish to reach out for?





>

>





4.8.4.4.11 A key part of the content



In some cases, the image is a critical part of the content. This could be the case, for instance, on a page that is part of a photo gallery. The image is the whole point of the page containing it.

How to provide alternative text for an image that is a key part of the content depends on the image's provenance.

The general case

When it is possible for detailed alternative text to be provided, for example if the image is part of a series of screenshots in a magazine review, or part of a comic strip, or is a photograph in a blog entry about that photograph, text that can serve as a

substitute for the image must be given as the contents of the alt attribute.

Example

A screenshot in a gallery of screenshots for a new OS, with some alternative text:





alt="The desktop is blue, with icons along the left hand side in

two columns, reading System, Home, K-Mail, etc. A window is open showing that menus wrap to a second line if they

cannot fit in the window. The window has a list of icons

along the top, with an address bar below it, a list of

icons for tabs along the left edge, a status bar on the

bottom, and two panes in the middle. The desktop has a bar at the bottom of the screen with a few buttons, a pager, a list of open applications, and a clock.">



Screenshot of a KDE desktop.





Example

A graph in a financial report:



title="Sales graph"

alt="From 1998 to 2005, sales increased by the following percentages with each year: 624%, 75%, 138%, 40%, 35%, 9%, 21%">

Note that "sales graph" would be inadequate alternative text for a sales graph. Text that would be a good caption is not generally suitable as replacement text.

Images that defy a complete description

In certain cases, the nature of the image might be such that providing thorough alternative text is impractical. For example, the image could be indistinct, or could be a complex fractal, or could be a detailed topographical map.

In these cases, the alt attribute must contain some suitable alternative text, but it may be somewhat brief.





Example

Sometimes there simply is no text that can do justice to an image. For example, there is little that can be said to usefully describe a Rorschach inkblot test. However, a description, even if brief, is still better than nothing:





A black outline of the first of the ten cards

in the Rorschach inkblot test.





Note that the following would be a very bad use of alternative text:





A black outline of the first of the ten cards

in the Rorschach inkblot test.





Including the caption in the alternative text like this isn't useful because it effectively duplicates the caption for users who don't have images, taunting them twice yet not helping them any more than if they had only read or heard the caption once.



Example

Another example of an image that defies full description is a fractal, which, by definition, is infinite in detail.

The following example shows one possible way of providing alternative text for the full view of an image of the Mandelbrot set.





Example

Similarly, a photograph of a person's face, for example in a biography, can be considered quite relevant and key to the content, but it can be hard to fully substitute text for:





A Biography of Isaac Asimov





Born Isaak Yudovich Ozimov in 1920, Isaac was a prolific author.

glasses.

Later in life, he wore long white sideburns.">



Asimov was born in Russia, and moved to the US when he was three years old.

...





In such cases it is unnecessary (and indeed discouraged) to include a reference to the presence of the image itself in the alternative text, since such text would be redundant with the browser itself reporting the presence of the image. For example, if the alternative text was "A photo of Isaac Asimov", then a conforming user agent might read that out as "(Image) A photo of Isaac Asimov" rather than the more useful "(Image) Isaac Asimov had dark hair, a tall forehead, and wore glasses...".

Images whose contents are not known

In some unfortunate cases, there might be no alternative text available at all, either because the image is obtained in some automated fashion without any associated alternative text (e.g. a Webcam), or because the page is being generated by a script



using user-provided images where the user did not provide suitable or usable alternative text (e.g. photograph sharing sites), or because the author does not themself know what the images represent (e.g. a blind photographer sharing an image on their blog).

In such cases, the alt attribute may be omitted, but one of the following conditions must be met as well:

• The img element is in a figure element that contains a figcaption element that contains content other than

inter-element whitespace , and, ignoring the figcaption element and its descendants, the figure element has

no flow content descendants other than inter-element whitespace and the img element.

• The title attribute is present and has a non-empty value.

Note

Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g. requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).



Note

Such cases are to be kept to an absolute minimum. If there is even the slightest possibility of the author having the ability to

provide real alternative text, then it would not be acceptable to omit the alt attribute.



Example

A photo on a photo-sharing site, if the site received the image with no metadata other than the caption, could be marked up as follows:





Bubbles traveled everywhere with us.





It would be better, however, if a detailed description of the important parts of the image obtained from the user and included on the page.



Example

A blind user's blog in which a photo taken by the user is shown. Initially, the user might not have any idea what the photo they took shows:





I took a photo





I went out today and took a photo!





A photograph taken blindly from my front porch.





Eventually though, the user might obtain a description of the image from their friends and could then include alternative text:





I took a photo





I went out today and took a photo!





A photograph taken blindly from my front porch.





Example

Sometimes the entire point of the image is that a textual description is not available, and the user is to provide the description. For instance, the point of a CAPTCHA image is to see if the user can literally read the graphic. Here is one way to mark up a

CAPTCHA (note the title attribute):



What does this image say?





(If you cannot see the image, you can use an

href="?audio">audio test instead.)



Another example would be software that displays images and asks for alternative text precisely for the purpose of then writing a page with correct alternative text. Such a page could have a table of images, like this:





Image Description





Notice that even in this example, as much useful information as possible is still included in the title attribute.



Note

Since some users cannot use images at all (e.g. because they have a very slow connection, or because they are using a text-only browser, or because they are listening to the page being read out by a hands-free automobile voice web browser, or simply

because they are blind), the alt attribute is only allowed to be omitted rather than being provided with replacement text when no alternative text is available and none can be made available, as in the above examples. Lack of effort from the part of

the author is not an acceptable reason for omitting the alt attribute.



4.8.4.4.12 An image not intended for the user



Generally authors should avoid using img elements for purposes other than showing images.

If an img element is being used for purposes other than showing an image, e.g. as part of a service to count page views, then the

alt attribute must be the empty string.

In such cases, the width and height attributes should both be set to zero.



4.8.4.4.13 An image in an email or private document intended for a specific person who is known to be able to view

images

This section does not apply to documents that are publicly accessible, or whose target audience is not necessarily personally known to the author, such as documents on a web site, emails sent to public mailing lists, or software documentation.

When an image is included in a private communication (such as an HTML email) aimed at a specific person who is known to be able to view images, the alt attribute may be omitted. However, even in such cases authors are strongly urged to include alternative text (as appropriate according to the kind of image involved, as described in the above entries), so that the email is still usable should the user use a mail client that does not support images, or should the document be forwarded on to other users whose abilities might not



include easily seeing images.



4.8.4.4.14 Guidance for markup generators



Markup generators (such as WYSIWYG authoring tools) should, wherever possible, obtain alternative text from their users. However, it is recognized that in many cases, this will not be possible.

For images that are the sole contents of links, markup generators should examine the link target to determine the title of the target, or the URL of the target, and use information obtained in this manner as the alternative text.

For images that have captions, markup generators should use the figure and figcaption elements, or the title attribute, to provide the image's caption.

As a last resort, implementers should either set the alt attribute to the empty string, under the assumption that the image is a purely decorative image that doesn't add any information but is still specific to the surrounding content, or omit the alt attribute altogether, under the assumption that the image is a key part of the content.

Markup generators may specify a generator-unable-to-provide-required-alt attribute on img elements for which they have been unable to obtain alternative text and for which they have therefore omitted the alt attribute. The value of this attribute must be the empty string. Documents containing such attributes are not conforming, but conformance checkers will silently ignore this error.

Note

This is intended to avoid markup generators from being pressured into replacing the error of omitting the alt attribute with the

even more egregious error of providing phony alternative text, because state-of-the-art automated conformance checkers cannot

distinguish phony alternative text from correct alternative text.

Markup generators should generally avoid using the image's own file name as the alternative text. Similarly, markup generators should avoid generating alternative text from any content that will be equally available to presentation user agents (e.g., web browsers).

Note

This is because once a page is generated, it will typically not be updated, whereas the browsers that later read the page can be

updated by the user, therefore the browser is likely to have more up-to-date and finely-tuned heuristics than the markup generator

did when generating the page.



4.8.4.4.15 Guidance for conformance checkers



A conformance checker must report the lack of an alt attribute as an error unless one of the conditions listed below applies:

• The img element is in a figure element that satisfies the conditions described above .

• The img element has a title attribute with a value that is not the empty string (also as described above).

• The conformance checker has been configured to assume that the document is an email or document intended for a specific

person who is known to be able to view images.

• The img element has a (non-conforming) generator-unable-to-provide-required-alt attribute whose value is the

empty string. A conformance checker that is not reporting the lack of an alt attribute as an error must also not report the

presence of the empty generator-unable-to-provide-required-alt attribute as an error. (This case does not represent a case where the document is conforming, only that the generator could not determine appropriate alternative text — validators are not required to show an error in this case, because such an error might encourage markup generators to include bogus alternative text purely in an attempt to silence validators. Naturally, conformance checkers may report the

lack of an alt attribute as an error even in the presence of the generator-unable-to-provide-required-alt attribute; for example, there could be a user option to report all conformance errors even those that might be the more or less inevitable result of using a markup generator.)





✔ MDN





Categories :

Flow content .

Phrasing content .

Embedded content .

Interactive content .

Palpable content .

Contexts in which this element can be used :

Where embedded content is expected.

Content model :

Nothing .

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

src — Address of the resource

srcdoc — A document to render in the iframe

name — Name of nested browsing context

sandbox — Security rules for nested content

allow — Permissions policy to be applied to the iframe's contents

allowfullscreen — Whether to allow the iframe's contents to use requestFullscreen()

width — Horizontal dimension

height — Vertical dimension

referrerpolicy — Referrer policy for fetches initiated by the element

loading — Used when determining loading deferral

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLIFrameElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString srcdoc;

[CEReactions] attribute DOMString name;

[SameObject, PutForwards=value] readonly attribute DOMTokenList sandbox;

[CEReactions] attribute DOMString allow;

[CEReactions] attribute boolean allowFullscreen;

[CEReactions] attribute DOMString width;

[CEReactions] attribute DOMString height;

[CEReactions] attribute DOMString referrerPolicy;

[CEReactions] attribute DOMString loading;

readonly attribute Document? contentDocument;

readonly attribute WindowProxy? contentWindow;

Document? getSVGDocument();

// also has obsolete members

};



The iframe element represents its nested browsing context.

The src attribute gives the URL of a page that the element's nested browsing context is to contain. The attribute, if present, must be a valid non-empty URL potentially surrounded by spaces . If the itemprop attribute is specified on an iframe element, then ✔ MDN

the src attribute must also be specified.



The srcdoc attribute gives the content of the page that the element's nested browsing context is to contain. The value of the attribute is the source of an iframe srcdoc document.

The srcdoc attribute, if present, must have a value using the HTML syntax that consists of the following syntactic components, in the given order:

1. Any number of comments and ASCII whitespace.

2. Optionally, a DOCTYPE.

3. Any number of comments and ASCII whitespace.

4. The document element , in the form of an html element.

5. Any number of comments and ASCII whitespace.

Note

The above requirements apply in XML documents as well.



Example

Here a blog uses the srcdoc attribute in conjunction with the sandbox attribute described below to provide users of user

agents that support this feature with an extra layer of protection from script injection in the blog post comments:





I got my own magazine!





After much effort, I've finally found a publisher, and so now I have my own magazine! Isn't that awesome?! The first issue will come out in September, and we have articles about getting food, and about getting in boxes, it's going to be great!





Written by cap, 1 hour ago.





Thirteen minutes ago, ch wrote:





Nine minutes ago, cap wrote: href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>in my gallery</a>.">





Five minutes ago, ch wrote: <p>you should get earl&amp;amp;me on the next cover.">





Notice the way that quotes have to be escaped (otherwise the srcdoc attribute would end prematurely), and the way raw

ampersands (e.g. in URLs or in prose) mentioned in the sandboxed content have to be doubly escaped — once so that the

ampersand is preserved when originally parsing the srcdoc attribute, and once more to prevent the ampersand from being

misinterpreted when parsing the sandboxed content.

Furthermore, notice that since the DOCTYPE is optional in iframe srcdoc documents , and the html , head, and

body elements have optional start and end tags , and the title element is also optional in iframe srcdoc

documents , the markup in a srcdoc attribute can be relatively succinct despite representing an entire document, since only

the contents of the body element need appear literally in the syntax. The other elements are still present, but only by

implication.



Note

In the HTML syntax, authors need only remember to use U+0022 QUOTATION MARK characters (") to wrap the attribute

contents and then to escape all U+0026 AMPERSAND (&) and U+0022 QUOTATION MARK (") characters, and to specify the



sandbox attribute, to ensure safe embedding of content. (And remember to escape ampersands before quotation marks, to

ensure quotation marks become &quot; and not &amp;quot;.)



Note

In XML the U+003C LESS-THAN SIGN character (<) needs to be escaped as well. In order to prevent attribute-value normalization,

some of XML's whitespace characters — specifically U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), and U+000D

CARRIAGE RETURN (CR) — also need to be escaped. [XML]



Note

If the src attribute and the srcdoc attribute are both specified together, the srcdoc attribute takes priority. This allows

authors to provide a fallback URL for legacy user agents that do not support the srcdoc attribute.



When an iframe element element is inserted into a document whose browsing context is non-null, the user agent must run these steps:

1. Create a new nested browsing context for element.

2. Process the iframe attributes for element , with initialInsertion set to true.

When an iframe element is removed from a document , the user agent must discard the element's nested browsing

context , if it is not null, and then set the element's nested browsing context to null.

Note

This happens without any unload events firing (the element's nested browsing context and its Document are

discarded , not unloaded).

Whenever an iframe element with a non-null nested browsing context has its srcdoc attribute set, changed, or removed, the user agent must process the iframe attributes.

Similarly, whenever an iframe element with a non-null nested browsing context but with no srcdoc attribute specified has its src attribute set, changed, or removed, the user agent must process the iframe attributes.

To process the iframe attributes for an element element, with an optional boolean initialInsertion (default false):

1. If element 's srcdoc attribute is specified, then:

1. Set element 's current navigation was lazy loaded boolean to false.

2. If the will lazy load element steps given element return true, then:

1. Set element 's lazy load resumption steps to the rest of this algorithm starting with the step labeled

navigate to the srcdoc resource.

2. Set element 's current navigation was lazy loaded boolean to true.

3. Start intersection-observing a lazy loading element for element.

4. Return.

3. Navigate to the srcdoc resource : navigate an iframe or frame given element and a new response whose url list

consists of about:srcdoc , header list consists of ` Content-Type `/` text/html`, body is the value of

element 's srcdoc attribute, and CSP list is a clone of element 's node document 's CSP list.

The resulting Document must be considered an iframe srcdoc document.

2. Otherwise, if element has a src attribute specified, or initialInsertion is false, then run the shared attribute processing

steps for iframe and frame elements given element.

The shared attribute processing steps for iframe and frame elements, given an element element, are:

1. If element has no src attribute specified, or its value is the empty string, let url be the URL " about:blank".



Otherwise, parse the value of element 's src attribute, relative to element's node document.

If that is not successful, then let url be the URL " about:blank ". Otherwise, let url be the resulting URL record.

2. If there exists an ancestor browsing context of element 's nested browsing context whose active document's URL,

ignoring fragments, is equal to url, then return.

3. Let resource be a new request whose url is url and whose referrer policy is the current state of element 's referrerpolicy

content attribute.

4. If element is an iframe element, then set element 's current navigation was lazy loaded boolean to false.

5. If element is an iframe element, and the will lazy load element steps given element return true, then:

1. Set element 's lazy load resumption steps to the rest of this algorithm starting with the step labeled navigate to

the resource.

2. Set element 's current navigation was lazy loaded boolean to true.

3. Start intersection-observing a lazy loading element for element.

4. Return.

6. Navigate to the resource : navigate an iframe or frame given element and resource.

To navigate an iframe or frame given an element element and a resource resource:

1. Let historyHandling be " default".

2. If element 's nested browsing context 's session history contains only one Document, and that was the

about:blank Document created when element 's nested browsing context was created, then set historyHandling to

" replace ".

3. If element 's nested browsing context 's active document is not completely loaded , then set historyHandling to

" replace ".

4. Navigate element 's nested browsing context to resource , with historyHandling set to historyHandling and the

source browsing context set to element 's node document 's browsing context .

Note

A load event is also fired at the iframe element when it is created if no other data is loaded in it.

Each Document has an iframe load in progress flag and a mute iframe load flag. When a Document is created, these flags must be unset for that Document.

To run the iframe load event steps , given an iframe element element:

1. Assert: element 's nested browsing context is not null.

2. Let childDocument be the active document of element 's nested browsing context.

3. If childDocument has its mute iframe load flag set, then return.

4. Set childDocument 's iframe load in progress flag.

5. Fire an event named load at element.

6. Unset childDocument 's iframe load in progress flag.

⚠Warning!

This, in conjunction with scripting, can be used to probe the URL space of the local network's HTTP servers. User

agents may implement cross-origin access control policies that are stricter than those described above to

mitigate this attack, but unfortunately such policies are typically not compatible with existing web content.

If an element type potentially delays the load event, then for each element element of that type, the user agent must delay the

load event of element 's node document if element 's nested browsing context is non-null and any of the following are true:



• element 's nested browsing context 's active document is not ready for post-load tasks.

• Anything is delaying the load event of element 's nested browsing context 's active document .

• element 's nested browsing context is in the delaying load events mode.

Note

If, during the handling of the load event, element 's nested browsing context is again navigated, that will further delay

the load event .

Each iframe element has an associated current navigation was lazy loaded boolean, initially false. It is set and unset in the

process the iframe attributes algorithm.

An iframe element whose current navigation was lazy loaded boolean is false potentially delays the load event .

Note

If, when the element is created, the srcdoc attribute is not set, and the src attribute is either also not set or set but its

value cannot be parsed , the browsing context will remain at the initial about:blank page.



Note

If the user navigates away from this page, the iframe 's nested browsing context 's WindowProxy object will proxy new

Window objects for new Document objects, but the src attribute will not change.



The name attribute, if present, must be a valid browsing context name . The given value is used to name the element's nested

browsing context if present when that is created.



The sandbox attribute, when specified, enables a set of extra restrictions on any content hosted by the iframe . Its value must be an ✔ MDN

unordered set of unique space-separated tokens that are ASCII case-insensitive . The allowed values are allow-forms, allow-

modals , allow-orientation-lock , allow-pointer-lock , allow-popups , allow-popups-to-escape-sandbox , allow-

presentation , allow-same-origin , allow-scripts , allow-top-navigation , allow-top-navigation-by-user-

activation , and allow-downloads .

When the attribute is set, the content is treated as being from a unique origin, forms, scripts, and various potentially annoying APIs are disabled, links are prevented from targeting other browsing contexts , and plugins are secured. The allow-same-origin

keyword causes the content to be treated as being from its real origin instead of forcing it into a unique origin; the allow-top-

navigation keyword allows the content to navigate its top-level browsing context; the allow-top-navigation-by-user-

activation keyword behaves similarly but allows such navigation only when the browsing context's active window has

transient activation ; and the allow-forms , allow-modals , allow-orientation-lock , allow-pointer-lock, allow-

popups , allow-presentation , allow-scripts , and allow-popups-to-escape-sandbox keywords re-enable forms, modal dialogs, screen orientation lock, the pointer lock API, popups, the presentation API, scripts, and the creation of unsandboxed auxiliary

browsing contexts respectively. [POINTERLOCK] [SCREENORIENTATION] [PRESENTATION]

The allow-top-navigation and allow-top-navigation-by-user-activation keywords must not both be specified, as doing so is redundant; only allow-top-navigation will have an effect in such non-conformant markup.

⚠Warning!

Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the

same origin as the page containing the iframe allows the embedded page to simply remove the sandbox

attribute and then reload itself, effectively breaking out of the sandbox altogether.



⚠Warning!

These flags only take effect when the nested browsing context of the iframe element is navigated .

Removing them, or removing the entire sandbox attribute, has no effect on an already-loaded page.



⚠Warning!

Potentially hostile files should not be served from the same server as the file containing the iframe element.



Sandboxing hostile content is of minimal help if an attacker can convince the user to just visit the hostile content

directly, rather than in the iframe. To limit the damage that can be caused by hostile HTML content, it should be

served from a separate dedicated domain. Using a different domain ensures that scripts in the files are unable to

attack the site, even if the user is tricked into visiting those pages directly, without the protection of the sandbox

attribute.

When an iframe element with a sandbox attribute has its nested browsing context created (before the initial about:blank

Document is created), and when an iframe element's sandbox attribute is set or changed while it has a nested browsing

context , the user agent must parse the sandboxing directive using the attribute's value as the input and the iframe

element's iframe sandboxing flag set as the output.

When an iframe element's sandbox attribute is removed while it has a non-null nested browsing context, the user agent must empty the iframe element's iframe sandboxing flag set .

Example

In this example, some completely-unknown, potentially hostile, user-provided HTML content is embedded in a page. Because it is

served from a separate domain, it is affected by all the normal cross-site restrictions. In addition, the embedded page has scripting

disabled, plugins disabled, forms disabled, and it cannot navigate any frames or windows other than itself (or any frames or

windows it itself embeds).



We're not scared of you! Here is your content, unedited:





⚠Warning!

It is important to use a separate domain so that if the attacker convinces the user to visit that page directly, the page doesn't run in the context of the site's origin, which would make the user vulnerable to any attack found in the page.



Example

In this example, a gadget from another site is embedded. The gadget has scripting and forms enabled, and the origin sandbox

restrictions are lifted, allowing the gadget to communicate with its originating server. The sandbox is still useful, however, as it

disables plugins and popups, thus reducing the risk of the user being exposed to malware and other annoyances.

<p style="margin-left:7em">src="https://maps.example.com/embedded.html">



Example

Suppose a file A contained the following fragment:



Suppose that file B contained an iframe also:



Further, suppose that file C contained a link:

Link

For this example, suppose all the files were served as text/html.

Page C in this scenario has all the sandboxing flags set. Scripts are disabled, because the iframe in A has scripts disabled, and

this overrides the allow-scripts keyword set on the iframe in B. Forms are also disabled, because the inner iframe (in

B) does not have the allow-forms keyword set.





Suppose now that a script in A removes all the sandbox attributes in A and B. This would change nothing immediately. If the

user clicked the link in C, loading page D into the iframe in B, page D would now act as if the iframe in B had the allow-

same-origin and allow-forms keywords set, because that was the state of the nested browsing context in the

iframe in A when page B was loaded.

Generally speaking, dynamically removing or changing the sandbox attribute is ill-advised, because it can make it quite hard to

reason about what will be allowed and what will not.



The allow attribute, when specified, determines the container policy that will be used when the permissions policy for a

Document in the iframe 's nested browsing context is initialized. Its value must be a serialized permissions policy.

[PERMISSIONSPOLICY]

Example

In this example, an iframe is used to embed a map from an online navigation service. The allow attribute is used to enable

the Geolocation API within the nested context.





The allowfullscreen attribute is a boolean attribute . When specified, it indicates that Document objects in the iframe

element's nested browsing context will be initialized with a permissions policy which allows the "fullscreen" feature to be used from any origin . This is enforced by the process permissions policy attributes algorithm. [PERMISSIONSPOLICY]

Example

Here, an iframe is used to embed a player from a video site. The allowfullscreen attribute is needed to enable the player

to show its video fullscreen.





Fred Flintstone





12:44 — Private

Post





Check out my new ride!





Note

Neither allow nor allowfullscreen can grant access to a feature in an iframe element's nested browsing context if

the element's node document is not already allowed to use that feature.

To determine whether a Document object document is allowed to use the policy-controlled-feature feature, run these steps:

1. If document 's browsing context is null, then return false.

2. If document 's browsing context 's active document is not document, then return false.

3. If the result of running is feature enabled in document for origin on feature , document , and document 's origin is

"Enabled", then return true.

4. Return false.

⚠Warning!

Because they only influence the permissions policy of the nested browsing context 's active document, the

allow and allowfullscreen attributes only take effect when the nested browsing context of the iframe is

navigated . Adding or removing them has no effect on an already-loaded document.





The iframe element supports dimension attributes for cases where the embedded content has specific dimensions (e.g. ad units have well-defined dimensions).

An iframe element never has fallback content , as it will always create a new nested browsing context , regardless of whether the specified initial contents are successfully used.



The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when processing the iframe

attributes . [REFERRERPOLICY]

The loading attribute is a lazy loading attribute . Its purpose is to indicate the policy for loading iframe elements that are outside the viewport.

When the loading attribute's state is changed to the Eager state, the user agent must run these steps:

1. Let resumptionSteps be the iframe element's lazy load resumption steps.

2. If resumptionSteps is null, then return.

3. Set the iframe 's lazy load resumption steps to null.

4. Invoke resumptionSteps.



Descendants of iframe elements represent nothing. (In legacy user agents that do not support iframe elements, the contents would be parsed as markup that could act as fallback content.) Note

The HTML parser treats markup inside iframe elements as text.



The IDL attributes src , srcdoc , name , sandbox , and allow must reflect the respective content attributes of the same name. ✔ MDN

The supported tokens for sandbox 's DOMTokenList are the allowed values defined in the sandbox attribute and supported by the user agent.

The allowFullscreen IDL attribute must reflect the allowfullscreen content attribute.

The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

✔ MDN

The loading IDL attribute must reflect the loading content attribute, limited to only known values.

✔ MDN

The contentDocument IDL attribute, on getting, must return the iframe element's content document.

The contentWindow IDL attribute must return the WindowProxy object of the iframe element's nested browsing context, if its

nested browsing context is non-null, or null otherwise.

Example

Here is an example of a page using an iframe to include advertising from an advertising broker:

<p style="margin-left:7em">width="468" height="60">



✔ MDN





Categories : ✔ MDN

Flow content .

Phrasing content .

Embedded content .

Interactive content .



Palpable content .

Contexts in which this element can be used :

Where embedded content is expected.

Content model :

Nothing .

Tag omission in text/html :

No end tag.

Content attributes :

Global attributes

src — Address of the resource

type — Type of embedded resource

width — Horizontal dimension

height — Vertical dimension

Any other attribute that has no namespace (see prose).

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLEmbedElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString width;

[CEReactions] attribute DOMString height;

Document? getSVGDocument();

// also has obsolete members

};

Depending on the type of content instantiated by the embed element, the node may also support other interfaces.



The embed element provides an integration point for an external (typically non-HTML) application or interactive content.

The src attribute gives the URL of the resource being embedded. The attribute, if present, must contain a valid non-empty URL

potentially surrounded by spaces .

⚠Warning!

Authors should avoid referencing untrusted resources, as such a resource can be used to instantiate plugins or run

scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.

If the itemprop attribute is specified on an embed element, then the src attribute must also be specified.

The type attribute, if present, gives the MIME type by which the plugin to instantiate is selected. The value must be a valid MIME type

string . If both the type attribute and the src attribute are present, then the type attribute must specify the same type as the

explicit Content-Type metadata of the resource given by the src attribute.

While any of the following conditions are occurring, any plugin instantiated for the element must be removed, and the embed

element represents nothing:

• The element has neither a src attribute nor a type attribute.

• The element has a media element ancestor.

• The element has an ancestor object element that is not showing its fallback content .

An embed element is said to be potentially active when the following conditions are all met simultaneously:



• The element is in a document or was in a document the last time the event loop reached step 1.

• The element's node document is fully active .

• The element has either a src attribute set or a type attribute set (or both).

• The element's src attribute is either absent or its value is not the empty string.

• The element is not a descendant of a media element.

• The element is not a descendant of an object element that is not showing its fallback content.

• The element is being rendered , or was being rendered the last time the event loop reached step 1 .

Whenever an embed element that was not potentially active becomes potentially active , and whenever a potentially

active embed element that is remaining potentially active and has its src attribute set, changed, or removed or its

type attribute set, changed, or removed, the user agent must queue an element task on the embed task source given the element to run the embed element setup steps for that element.

The embed element setup steps for a given embed element element are as follows:

1. If another task has since been queued to run the embed element setup steps for element, then return.

2. If the Should plugin element be blocked a priori by Content Security Policy? algorithm returns "Blocked" when executed on

element , then return. [CSP]

3. If element has a src attribute set, then:

1. Let url be the result of parsing the value of element 's src attribute, relative to element's node document.

2. If url is failure, then return.

3. Let request be a new request whose url is url , client is element 's node document 's relevant settings object,

destination is "embed", credentials mode is "include", mode is "navigate", and whose use-URL-credentials flag is set.

4. Fetch request.

Fetching the resource must delay the load event of element's node document.

To process response for the response response:

1. If another task has since been queued to run the embed element setup steps for element, then

return.

2. If response is a network error , then fire an event named load at element, and return.

3. Let type be the result of determining the type of content given element and response.

4. Switch on type:

↪ null

1. Display no plugin for element.

↪ image/svg+xml

1. If element 's nested browsing context is null, then create a new nested browsing

context for element.

2. Navigate element 's nested browsing context to response, with

historyHandling set to " replace " and the source browsing context set to

element 's node document 's browsing context.

Note

element 's src attribute does not get updated if the browsing context gets further navigated to other locations.

3. element now represents its nested browsing context .

↪ Otherwise

1. Display a plugin for element, given type and response.

4. Otherwise:



1. Let type be the value of element 's type attribute.

2. If type is a type that a plugin supports, then display a plugin for element given type.

3. Otherwise, display no plugin for element.

To determine the type of the content given an embed element element and a response response, run the following steps:

1. If element has a type attribute, and that attribute's value is a type that a plugin supports, then return the value of the

type attribute.

2. If the path component of response 's url matches a pattern that a plugin supports, then return the type that that plugin can

handle.

Example

For example, a plugin might say that it can handle URLs with path components that end with the four character string ".swf".

3. If response has explicit Content-Type metadata , and that value is a type that a plugin supports, then return that value.

4. Return null.

Note

It is intentional that the above algorithm allows response to have a non-ok status. This allows servers to return data for plugins

even with error responses (e.g., HTTP 500 Internal Server Error codes can still contain plugin data).

To display a plugin for an embed element element, given a string type and optionally a response response:

1. If element 's nested browsing context is not null, then:

1. Discard element 's nested browsing context .

2. Set element 's nested browsing context to null.

2. Find and instantiate an appropriate plugin based on type, replacing any previously-instantiated plugin for element. If

response was given, forward it to the plugin.

3. element now represents this plugin instance.

4. Once the plugin, and response if given, are completely loaded, queue an element task on the DOM manipulation task

source give element to fire an event named load at element.

To display no plugin for an embed element element:

1. If element 's nested browsing context is not null, then:

1. Discard element 's nested browsing context .

2. Set element 's nested browsing context to null.

2. Display an indication that no plugin could be found for element, replacing any previously-instantiated plugin for element.

3. element now represents nothing.

Note

The embed element has no fallback content ; its descendants are ignored.

Whenever an embed element that was potentially active stops being potentially active , any plugin that had been instantiated for that element must be unloaded.

When a plugin is to be instantiated but it cannot be secured and the sandboxed plugins browsing context flag is set on the

embed element's node document 's active sandboxing flag set , then the user agent must not instantiate the plugin, and must instead render the embed element in a manner that conveys that the plugin was disabled. The user agent may offer the user the option to override the sandbox and instantiate the plugin anyway; if the user invokes such an option, the user agent must act as if the conditions above did not apply for the purposes of this element.



⚠Warning!

Plugins that cannot be secured are disabled in sandboxed browsing contexts because they might not honor the

restrictions imposed by the sandbox (e.g. they might allow scripting even when scripting in the sandbox is

disabled). User agents should convey the danger of overriding the sandbox to the user if an option to do so is

provided.

The embed element potentially delays the load event.

Any namespace-less attribute other than name , align , hspace , and vspace may be specified on the embed element, so long as its name is XML-compatible and contains no ASCII upper alphas. These attributes are then passed as parameters to the

plugin .

Note

All attributes in HTML documents get lowercased automatically, so the restriction on uppercase letters doesn't affect such

documents.



Note

The four exceptions are to exclude legacy attributes that have side-effects beyond just sending parameters to the plugin.

The user agent should pass the names and values of all the attributes of the embed element that have no namespace to the

plugin used, when one is instantiated.

The HTMLEmbedElement object representing the element must expose the scriptable interface of the plugin instantiated for the

embed element, if any.

The embed element supports dimension attributes.

The IDL attributes src and type each must reflect the respective content attributes of the same name.

Example

Here's a way to embed a resource that requires a proprietary plugin, like Flash:



If the user does not have the plugin (for example if the plugin vendor doesn't support the user's platform), then the user will be

unable to use the resource.

To pass the plugin a parameter "quality" with the value "high", an attribute can be specified:



This would be equivalent to the following, when using an object element instead:





✔ MDN





Categories : ✔ MDN

Flow content .

Phrasing content .

Embedded content .

If the element has a usemap attribute: Interactive content .

Listed and submittable form-associated element.

Palpable content .



Contexts in which this element can be used :

Where embedded content is expected.

Content model :

Zero or more param elements, then, transparent.

Tag omission in text/html :

Neither tag is omissible.

Content attributes :

Global attributes

data — Address of the resource

type — Type of embedded resource

name — Name of nested browsing context

usemap — Name of image map to use

form — Associates the element with a form element

width — Horizontal dimension

height — Vertical dimension

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLObjectElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString data;

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString useMap;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute DOMString width;

[CEReactions] attribute DOMString height;

readonly attribute Document? contentDocument;

readonly attribute WindowProxy? contentWindow;

Document? getSVGDocument();

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

// also has obsolete members

};

Depending on the type of content instantiated by the object element, the node also supports other interfaces.



The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image, as a child browsing context , or as an external resource to be processed by a plugin.

The data attribute, if present, specifies the URL of the resource. If present, the attribute must be a valid non-empty URL potentially

surrounded by spaces .

⚠Warning!

Authors should avoid referencing untrusted resources, as such a resource can be used to instantiate plugins or run

scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.





The type attribute, if present, specifies the type of the resource. If present, the attribute must be a valid MIME type string.

At least one of either the data attribute or the type attribute must be present.

If the itemprop attribute is specified on an object element, then the data attribute must also be specified.

The name attribute, if present, must be a valid browsing context name . The given value is used to name the element's nested

browsing context , if applicable, and if present when the element's nested browsing context is created.

Whenever one of the following conditions occur:

• the element is created,

• the element is popped off the stack of open elements of an HTML parser or XML parser,

• the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into

a document or removed from a document,

• the element's node document changes whether it is fully active ,

• one of the element's ancestor object elements changes to or from showing its fallback content ,

• the element's classid attribute is set, changed, or removed,

• the element's classid attribute is not present, and its data attribute is set, changed, or removed,

• neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed,

or removed,

• the element changes from being rendered to not being rendered, or vice versa,

...the user agent must queue an element task on the DOM manipulation task source given the object element to run the following steps to (re)determine what the object element represents. This task being queued or actively running must delay

the load event of the element's node document.

1. If the user has indicated a preference that this object element's fallback content be shown instead of the element's

usual behavior, then jump to the step below labeled fallback.

Note

For example, a user could ask for the element's fallback content to be shown because that content uses a format that the user finds more accessible.

2. If the element has an ancestor media element , or has an ancestor object element that is not showing its fallback

content , or if the element is not in a document whose browsing context is non-null, or if the element's node document

is not fully active , or if the element is still in the stack of open elements of an HTML parser or XML parser, or

if the element is not being rendered, or if the Should plugin element be blocked a priori by Content Security Policy?

algorithm returns " Blocked " when executed on the element, then jump to the step below labeled fallback . [CSP]

3. If the classid attribute is present, and has a value that isn't the empty string, then: if the user agent can find a plugin

suitable according to the value of the classid attribute, and either plugins aren't being sandboxed or that plugin

can be secured , then that plugin should be used , and the value of the data attribute, if any, should be passed to

the plugin . If no suitable plugin can be found, or if the plugin reports an error, jump to the step below labeled fallback.

4. If the data attribute is present and its value is not the empty string, then:

1. If the type attribute is present and its value is not a type that the user agent supports, and is not a type that

the user agent can find a plugin for, then the user agent may jump to the step below labeled fallback without fetching the content to examine its real type.

2. Parse the URL specified by the data attribute, relative to the element's node document.

3. If that failed, fire an event named error at the element, then jump to the step below labeled fallback.

4. Let request be a new request whose url is the resulting URL record, client is the element's node document's

relevant settings object , destination is "object", credentials mode is "include", mode is "navigate", and

whose use-URL-credentials flag is set.



5. Fetch request.

Fetching the resource must delay the load event of the element's node document until the task that is

queued by the networking task source once the resource has been fetched (defined next) has been run.

6. If the resource is not yet available (e.g. because the resource was not available in the cache, so that loading the

resource required making a request over the network), then jump to the step below labeled fallback . The task

that is queued by the networking task source once the resource is available must restart this algorithm from this step. Resources can load incrementally; user agents may opt to consider a resource "available" whenever enough data has been obtained to begin processing the resource.

7. If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), fire an event named error at the

element, then jump to the step below labeled fallback.

8. Determine the resource type, as follows:

1. Let the resource type be unknown.

2. If the user agent is configured to strictly obey Content-Type headers for this resource, and the resource

has associated Content-Type metadata, then let the resource type be the type specified in the

resource's Content-Type metadata , and jump to the step below labeled handler.

⚠Warning!

This can introduce a vulnerability, wherein a site is trying to embed a resource that uses a particular plugin, but the remote site overrides that and instead furnishes the user agent with a resource that triggers a different plugin with different security characteristics.

3. If there is a type attribute present on the object element, and that attribute's value is not a type

that the user agent supports, but it is a type that a plugin supports, then let the resource type be the

type specified in that type attribute, and jump to the step below labeled handler.

4. Run the appropriate set of steps from the following list:

↪ If the resource has associated Content-Type metadata

1. Let binary be false.

2. If the type specified in the resource's Content-Type metadata is "text/plain", and

the result of applying the rules for distinguishing if a resource is text or binary to the

resource is that the resource is not text/plain, then set binary to true.

3. If the type specified in the resource's Content-Type metadata is "application/

octet-stream", then set binary to true.

4. If binary is false, then let the resource type be the type specified in the resource's

Content-Type metadata , and jump to the step below labeled handler.

5. If there is a type attribute present on the object element, and its value is not

application/octet-stream, then run the following steps:

1. If the attribute's value is a type that a plugin supports, or the attribute's

value is a type that starts with "image/" that is not also an XML MIME type,

then let the resource type be the type specified in that type attribute.

2. Jump to the step below labeled handler.

↪ Otherwise, if the resource does not have associated Content-Type metadata

1. If there is a type attribute present on the object element, then let the tentative

type be the type specified in that type attribute.

Otherwise, let tentative type be the computed type of the resource.

2. If tentative type is not application/octet-stream, then let resource type be tentative

type and jump to the step below labeled handler.

5. If applying the URL parser algorithm to the URL of the specified resource (after any redirects) results in a



URL record whose path component matches a pattern that a plugin supports, then let resource type be the type that that plugin can handle.

Example

For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".

Note

It is possible for this step to finish, or for one of the substeps above to jump straight to the next step, with resource type still being unknown. In both cases, the next step will trigger fallback.

9. Handler: Handle the content as given by the first of the following cases that matches:

↪ If the resource type is not a type that the user agent supports, but it is a type that a plugin

supports

If the object element's nested browsing context is non-null, then it must be discarded and then set to null.

If plugins are being sandboxed and the plugin that supports resource type cannot be secured, jump to the step below labeled fallback.

Otherwise, the user agent should use the plugin that supports resource type and pass the content of the

resource to that plugin . If the plugin reports an error, then jump to the step below labeled fallback.

↪ If the resource type is an XML MIME type, or if the resource type does not start with "image/"

If the object element's nested browsing context is null, then create a new nested browsing

context for the element.

If the URL of the given resource is not about:blank , then navigate the element's nested browsing

context to that resource, with historyHandling set to " replace" and the source browsing

context set to the object element's node document 's browsing context . (The data attribute of

the object element doesn't get updated if the browsing context gets further navigated to other locations.)

The object element represents its nested browsing context.

↪ If the resource type starts with "image/", and support for images has not been disabled

If the object element's nested browsing context is non-null, then it must be discarded and then set to null.

Apply the image sniffing rules to determine the type of the image.

The object element represents the specified image.

If the image cannot be rendered, e.g. because it is malformed or in an unsupported format, jump to the step below labeled fallback.

↪ Otherwise

The given resource type is not supported. Jump to the step below labeled fallback.

Note

If the previous step ended with the resource type being unknown, this is the case that is triggered.

10. The element's contents are not part of what the object element represents.

11. If the object element does not represent its nested browsing context, then once the resource is completely

loaded, queue an element task on the DOM manipulation task source given the object element to fire an

event named load at the element.

Note

If the element does represent its nested browsing context, then an analogous task will be queued when the

created Document is completely finished loading .



12. Return.

5. If the data attribute is absent but the type attribute is present, and the user agent can find a plugin suitable

according to the value of the type attribute, and either plugins aren't being sandboxed or the plugin can be

secured , then that plugin should be used . If these conditions cannot be met, or if the plugin reports an error, jump

to the step below labeled fallback . Otherwise return; once the plugin is completely loaded, queue an element task on the

DOM manipulation task source given the object element to fire an event named load at the element.

6. Fallback : The object element represents the element's children, ignoring any leading param element children. This

is the element's fallback content . If the element has an instantiated plugin, then unload it. If the element's nested

browsing context is non-null, then it must be discarded and then set to null.

When the algorithm above instantiates a plugin , the user agent should pass to the plugin used the names and values of all the attributes on the element, in the order they were added to the element, with the attributes added by the parser being ordered in source order, followed by a parameter named "PARAM" whose value is null, followed by all the names and values of parameters

given by param elements that are children of the object element, in tree order . If the plugin supports a scriptable interface, the HTMLObjectElement object representing the element should expose that interface. The object element represents the

plugin . The plugin is not a nested browsing context.

Plugins are considered sandboxed for the purpose of an object element if the sandboxed plugins browsing context flag is set on the object element's node document 's active sandboxing flag set.

Due to the algorithm above, the contents of object elements act as fallback content , used only when referenced resources can't be shown (e.g. because it returned a 404 error). This allows multiple object elements to be nested inside each other, targeting multiple user agents with different capabilities, with the user agent picking the first one it supports.

The object element potentially delays the load event.

The usemap attribute, if present while the object element represents an image, can indicate that the object has an associated

image map . The attribute must be ignored if the object element doesn't represent an image.

The form attribute is used to explicitly associate the object element with its form owner.

Constraint validation : object elements are always barred from constraint validation .

✔ MDN

The object element supports dimension attributes.

The IDL attributes data , type and name each must reflect the respective content attributes of the same name. The useMap IDL

attribute must reflect the usemap content attribute.

The contentDocument IDL attribute, on getting, must return the object element's content document .

The contentWindow IDL attribute must return the WindowProxy object of the object element's nested browsing context, if its

nested browsing context is non-null; otherwise, it must return null.

The willValidate , validity , and validationMessage attributes, and the checkValidity() , reportValidity(), and

setCustomValidity() methods, are part of the constraint validation API . The form IDL attribute is part of the element's forms API.

Example

In this example, an HTML page is embedded in another using the object element.





My HTML Clock





Example

The following example shows how a plugin can be used in HTML (in this case the Flash plugin, to show a video file). Fallback is

provided for users who do not have Flash enabled, in this case using the video element to show the video for those using user

agents that support video , and finally providing a link to the video for those who have neither Flash nor a video-capable





browser.



Look at my video:





View video.





✔ MDN





Categories : ✔ MDN

None.

Contexts in which this element can be used :

As a child of an object element, before any flow content.

Content model :

Nothing .

Tag omission in text/html :

No end tag.

Content attributes :

Global attributes

name — Name of parameter

value — Value of parameter

Accessibility considerations :

For authors.

For implementers.

DOM interface :

[Exposed=Window]

interface HTMLParamElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString value;

// also has obsolete members

};



The param element defines parameters for plugins invoked by object elements. It does not represent anything on its own.

The name attribute gives the name of the parameter.

The value attribute gives the value of the parameter.

Both attributes must be present. They may have any value.

If both attributes are present, and if the parent element of the param is an object element, then the element defines a parameter with the given name-value pair.

If either the name or value of a parameter defined by a param element that is the child of an object element that



represents an instantiated plugin changes, and if that plugin is communicating with the user agent using an API that features the ability to update the plugin when the name or value of a parameter so changes, then the user agent must appropriately exercise that ability to notify the plugin of the change.

The IDL attributes name and value must both reflect the respective content attributes of the same name.

Example

The following example shows how the param element can be used to pass a parameter to a plugin, in this case the O3D plugin.





O3D Utah Teapot





title="3D Utah Teapot illustration rendered using O3D."

alt="When O3D renders the Utah Teapot, it appears as a squat teapot with a shiny metallic finish on which the

surroundings are reflected, with a faint shadow caused by

the lighting.">



To see the teapot actually rendered by O3D on your

computer, please download and install the

href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D plugin.





✔ MDN

4.8.9 The video element p38 §

0

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Embedded content p133.

If the element has a p437 p133 controls attribute: Interactive content.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 embedded content is expected.

Content model p129:

If the element has a p390 p385 p134 p388 src attribute: zero or more track elements, then transparent , but with no media element descendants.

If the element does not have a p390 p318 p385 src attribute: zero or more source elements, then zero or more track elements, then

transparent p134 p388 , but with no media element descendants.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

src p390 — Address of the resource

crossorigin p391 — How the element handles crossorigin requests

poster p381 — Poster frame to show prior to video playback

preload p402 p389 — Hints how much buffering the media resource will likely need

380

autoplay p408 p389 — Hint that the media resource can be started automatically when the page is loaded

playsinline p382 — Encourage the user agent to display video content within the element's playback area

loop p406 p389 — Whether to loop the media resource

muted p438 p389 — Whether to mute the media resource by default

controls p437 — Show user agent controls

width p450 — Horizontal dimension

height p450 — Vertical dimension

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLVideoElement : HTMLMediaElement {

[HTMLConstructor] constructor();

[CEReactions] attribute unsigned long width;

[CEReactions] attribute unsigned long height;

readonly attribute unsigned long videoWidth;

readonly attribute unsigned long videoHeight;

[CEReactions] attribute USVString poster;

[CEReactions] attribute boolean playsInline;

};



A p380 video element is used for playing videos or movies, and audio files with captions.

Content may be provided inside the p380 video element. User agents should not show this content to the user; it is intended for older web browsers which do not support p380 video, so that legacy video plugins can be tried, or to show text to the users of these older browsers informing them of how to access the video contents.

Note

In particular, this content is not intended to address accessibility concerns. To make video content accessible to the partially

sighted, the blind, the hard-of-hearing, the deaf, and those with other physical or cognitive disabilities, a variety of features are

available. Captions can be provided, either embedded in the video stream or as external files using the p385 track element. Sign-

language tracks can be embedded in the video stream. Audio descriptions can be embedded in the video stream or in text form

using a p385 WebVTT file referenced using the track element and synthesized into speech by the user agent. WebVTT can also be

used to provide chapter titles. For users who would rather not use a media element at all, transcripts or other textual alternatives

can be provided by simply linking to them in the prose near the p380 p1282 video element. [WEBVTT]

The p380 p388 p389 video element is a media element whose media data is ostensibly video data, possibly with associated audio data.

The p390 p391 p402 p408 p406 p438 p437 src , crossorigin , preload , autoplay , loop , muted , and controls attributes are the attributes common to

all media elements p389.

The poster attribute gives the URL of an image file that the user agent can show while no video data is available. The attribute, if present, must contain a p88 valid non-empty URL potentially surrounded by spaces.

If the specified resource is to be used, then, when the element is created or when the p381 poster attribute is set, changed, or removed, the user agent must run the following steps to determine the element's poster frame (regardless of the value of the element's show

poster flag p405):

1. If there is an existing instance of this algorithm running for this p380 video element, abort that instance of this algorithm

without changing the p381 poster frame .

2. If the p381 p381 poster attribute's value is the empty string or if the attribute is absent, then there is no poster frame ; return.

3. p89 p381 Parse the poster attribute's value relative to the element's node document. If this fails, then there is no poster

frame p381; return.

4. Let p89 request be a new request whose url is the resulting URL record, client is the element's node document's relevant

settings object p911, destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.

381

5. p1162 Fetch request . This must delay the load event of the element's node document.

6. If an image is thus obtained, the p381 p381 poster frame is that image. Otherwise, there is no poster frame .

Note

The image given by the p381 p381 poster attribute, the poster frame, is intended to be a representative frame of the video (typically

one of the first non-blank frames) that gives the user an idea of what the video is like.

The p67 playsinline attribute is a boolean attribute. If present, it serves as a hint to the user agent that the video ought to be displayed "inline" in the document by default, constrained to the element's playback area, instead of being displayed fullscreen or in an independent resizable window.

Note

The absence of the p382 playsinline attributes does not imply that the video will display fullscreen by default. Indeed, most user

agents have chosen to play all videos inline by default, and in such user agents the p382 playsinline attribute has no effect.



A p380 video element represents what is given for the first matching condition in the list below:

↪ p408 p406 p406 When no video data is available (the element's readyState attribute is either HAVE_NOTHING , or HAVE_METADATA

but no video data has yet been obtained at all, or the element's p408 readyState attribute is any subsequent value but

the p389 media resource does not have a video channel)

The p380 p124 p381 video element represents its poster frame, if any, or else transparent black with no intrinsic dimensions.

↪ p380 p409 p404 When the video element is paused , the current playback position is the first frame of video, and the

element's p405 show poster flag is set

The p380 p124 p381 video element represents its poster frame, if any, or else the first frame of the video.

↪ p380 p409 p404 When the video element is paused , and the frame of video corresponding to the current playback position

is not available (e.g. because the video is seeking or buffering)

↪ p380 p409 p409 When the video element is neither potentially playing nor paused (e.g. when seeking or stalled)

The p380 p124 video element represents the last frame of the video to have been rendered.

↪ p380 p409 When the video element is paused

The p380 p124 p404 video element represents the frame of video corresponding to the current playback position .

↪ p380 p409 Otherwise (the video element has a video channel and is potentially playing)

The p380 p124 p404 video element represents the frame of video at the continuously increasing "current" position. When the current

playback position p404 changes such that the last frame rendered is no longer the frame corresponding to the current playback

position p404 in the video, the new frame must be rendered.

Frames of video must be obtained from the video track that was p421 p931 p934 selected when the event loop last reached step 1.

Note

Which frame in a video stream corresponds to a particular playback position is defined by the video stream's format.

The p380 p124 p424 p425 p422 video element also represents any text track cues whose text track cue active flag is set and whose text track is in the p423 p389 p404 showing mode, and any audio from the media resource , at the current playback position .

Any audio associated with the p389 p404 media resource must, if played, be played synchronized with the current playback position, at the element's p438 p421 effective media volume . The user agent must play the audio from audio tracks that were enabled when the event

loop p931 last reached step 1.

In addition to the above, the user agent may provide messages to the user (such as "buffering", "no video loaded", "error", or more detailed information) by overlaying text or icons on the video or other areas of the element's playback area, or in another appropriate manner.

User agents that cannot render the video may instead make the element p124 represent a link to an external video playback utility or to the video data itself.

When a p380 p389 video element's media resource has a video channel, the element provides a paint source whose width is the media

resource p389 p383 p389 p383 's intrinsic width , whose height is the media resource 's intrinsic height , and whose appearance is the frame of

382

video corresponding to the p404 current playback position, if that is available, or else (e.g. when the video is seeking or buffering) its previous appearance, if any, or else (e.g. because the video is still loading the first frame) blackness.



For web developers (non-normative)

video p383 . videoWidth

video p383 . videoHeight

These attributes return the intrinsic dimensions of the video, or zero if the dimensions are not known.

The p389 intrinsic width and intrinsic height of the media resource are the dimensions of the resource in CSS pixels after taking into account the resource's dimensions, aspect ratio, clean aperture, resolution, and so forth, as defined for the format used by the resource. If an anamorphic format does not define how to apply the aspect ratio to the video data's dimensions to obtain the "correct" ✔ MDN dimensions, then the user agent must apply the ratio by increasing one dimension and leaving the other unchanged.

The p383 videoWidth IDL attribute must return the intrinsic width of the video in CSS pixels. The videoHeight IDL attribute must return the p383 p408 p406 intrinsic height of the video in CSS pixels . If the element's readyState attribute is HAVE_NOTHING , then the attributes must return 0.

Whenever the p383 p383 intrinsic width or intrinsic height of the video changes (including, for example, because the selected video

track p421 p408 p406 was changed), if the element's readyState attribute is not HAVE_NOTHING , the user agent must queue a media element

task p389 p388 p441 p388 given the media element to fire an event named resize at the media element .

The p380 p450 video element supports dimension attributes.

In the absence of style rules to the contrary, video content should be rendered inside the element's playback area such that the video content is shown centered in the playback area at the largest possible size that fits completely within it, with the video content's aspect ratio being preserved. Thus, if the aspect ratio of the playback area does not match the aspect ratio of the video, the video will be shown letterboxed or pillarboxed. Areas of the element's playback area that do not contain the video represent nothing.

Note

In user agents that implement CSS, the above requirement can be implemented by using the style rule suggested in the rendering

section p1206.

The p380 p381 intrinsic width of a video element's playback area is the intrinsic width of the poster frame, if that is available and the element currently p124 p383 represents its poster frame; otherwise, it is the intrinsic width of the video resource, if that is available; otherwise the intrinsic width is missing.

The p380 p381 intrinsic height of a video element's playback area is the intrinsic height of the poster frame, if that is available and the element currently p124 p383 represents its poster frame; otherwise it is the intrinsic height of the video resource, if that is available; otherwise the intrinsic height is missing.

The p1276 default object size is a width of 300 CSS pixels and a height of 150 CSS pixels . [CSSIMAGES]



User agents should provide controls to enable or disable the display of closed captions, audio description tracks, and other additional data associated with the video stream, though such features should, again, not interfere with the page's normal rendering.

User agents may allow users to view the video content in manners more suitable to the user, such as fullscreen or in an independent resizable window. User agents may even trigger such a viewing mode by default upon playing a video, although they should not do so when the p382 playsinline attribute is specified. As with the other user interface features, controls to enable this should not interfere with the page's normal rendering unless the user agent is p437 exposing a user interface . In such an independent viewing mode,

however, user agents may make full user interfaces visible, even if the p437 controls attribute is absent.

User agents may allow video playback to affect system features that could interfere with the user's experience; for example, user agents could disable screensavers while video playback is in progress.



The p95 p381 poster IDL attribute must reflect the poster content attribute.

The p95 p382 playsInline IDL attribute must reflect the playsinline content attribute.



383

Example

This example shows how to detect when a video has failed to play correctly:





Download the video file.





4.8.10 The audio element §

p38 ✔ MDN

4

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Embedded content p133.

If the element has a p437 p133 controls attribute: Interactive content.

If the element has a p437 p134 controls attribute: Palpable content.

Contexts in which this element can be used p129 :

Where p133 embedded content is expected.

Content model p129:

If the element has a p390 p385 p134 p388 src attribute: zero or more track elements, then transparent , but with no media element descendants.

If the element does not have a p390 p318 p385 src attribute: zero or more source elements, then zero or more track elements, then

transparent p134 p388 , but with no media element descendants.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

src p390 — Address of the resource

crossorigin p391 — How the element handles crossorigin requests

preload p402 p389 — Hints how much buffering the media resource will likely need

autoplay p408 p389 — Hint that the media resource can be started automatically when the page is loaded

loop p406 p389 — Whether to loop the media resource

muted p438 p389 — Whether to mute the media resource by default

controls p437 — Show user agent controls

384

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window,

LegacyFactoryFunction=Audio(optional DOMString src)]

interface HTMLAudioElement : HTMLMediaElement {

[HTMLConstructor] constructor();

};



An p384 p124 audio element represents a sound or audio stream.

Content may be provided inside the p384 audio element. User agents should not show this content to the user; it is intended for older web browsers which do not support p384 audio, so that legacy audio plugins can be tried, or to show text to the users of these older browsers informing them of how to access the audio contents.

Note

In particular, this content is not intended to address accessibility concerns. To make audio content accessible to the deaf or to

those with other physical or cognitive disabilities, a variety of features are available. If captions or a sign language video are

available, the p380 p384 video element can be used instead of the audio element to play the audio, allowing users to enable the visual

alternatives. Chapter titles can be provided to aid navigation, using the p385 track element and a WebVTT file. And, naturally,

transcripts or other textual alternatives can be provided by simply linking to them in the prose near the p384 audio element.

[WEBVTT] p1282

The p384 p388 p389 audio element is a media element whose media data is ostensibly audio data.

The p390 p391 p402 p408 p406 p438 p437 src , crossorigin , preload , autoplay , loop , muted , and controls attributes are the attributes common to

all media elements p389.

For web developers (non-normative)

audio p385 = new Audio ( [ url ] )

Returns a new p384 p390 audio element, with the src attribute set to the value passed in the argument, if applicable.



A legacy factory function is provided for creating p385 HTMLAudioElement objects (in addition to the factory methods from DOM such as ✔ MDN

createElement()): Audio(src). When invoked, the legacy factory function must perform the following steps:

1. Let p911 p829 document be the current global object 's associated Document .

2. Let p384 audio be the result of creating an element given document , audio , and the HTML namespace.

3. p402 p402 Set an attribute value for audio using " preload " and " auto ".

4. If p390 p391 src is given, then set an attribute value for audio using " src " and src . (This will cause the user agent to invoke the

object's p394 resource selection algorithm before returning.)

5. Return audio.



✔ MDN

4.8.11 The track element p38 §

5

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As a child of a p388 p132 media element , before any flow content .

Content model p129:

Nothing p131 .



385

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

kind p386 — The type of text track

src p386 — Address of the resource

srclang p387 — Language of the text track

label p387 — User-visible label

default p387 p422 — Enable the track if no other text track is more suitable

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTrackElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString kind;

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString srclang;

[CEReactions] attribute DOMString label;

[CEReactions] attribute boolean default;

const unsigned short NONE = 0;

const unsigned short LOADING = 1;

const unsigned short LOADED = 2;

const unsigned short ERROR = 3;

readonly attribute unsigned short readyState;

readonly attribute TextTrack track;

};



The p385 p422 p388 p124 track element allows authors to specify explicit external timed text tracks for media elements . It does not represent anything on its own.

The p68 kind attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The keyword given in the first cell of each row maps to the state given in the second cell.

Keyword State Brief description

subtitles Subtitles Transcription or translation of the dialogue, suitable for when the sound is available but not understood (e.g. because the user

does not understand the language of the media resourcep389's audio track). Overlaid on the video.

captions Captions Transcription or translation of the dialogue, sound effects, relevant musical cues, and other relevant audio information, suitable for

when sound is unavailable or not clearly audible (e.g. because it is muted, drowned-out by ambient noise, or because the user is deaf). Overlaid on the video; labeled as appropriate for the hard-of-hearing.

descriptions Descriptions p389 Textual descriptions of the video component of the media resource, intended for audio synthesis when the visual component is

obscured, unavailable, or not usable (e.g. because the user is interacting with the application without a screen while driving, or because the user is blind). Synthesized as audio.

chapters Chapters Tracks intended for use from script. Not displayed by the user agent.

metadata

metadata Metadata

The attribute may be omitted. The p68 p386 p68 p386 missing value default is the subtitles state. The invalid value default is the metadata

state.

The p88 src attribute gives the URL of the text track data. The value must be a valid non-empty URL potentially surrounded by spaces. This attribute must be present.

If the element has a p386 src attribute whose value is not the empty string and whose value, when the attribute was set, could be successfully p89 p89 parsed relative to the element's node document , then the element's track URL is the resulting URL string.

386

Otherwise, the element's p386 track URL is the empty string.

If the element's p386 p386 p386 track URL identifies a WebVTT resource, and the element's kind attribute is not in the chapters metadata or

metadata p386 p1282 state, then the WebVTT file must be a WebVTT file using cue text . [WEBVTT]

The srclang attribute gives the language of the text track data. The value must be a valid BCP 47 language tag. This attribute must be present if the element's p386 p386 p1275 kind attribute is in the subtitles state. [BCP47]

If the element has a p387 srclang attribute whose value is not the empty string, then the element's track language is the value of the attribute. Otherwise, the element has no p387 track language .

The p386 p386 label attribute gives a user-readable title for the track. This title is used by user agents when listing subtitle , caption , and

audio description p386 tracks in their user interface.

The value of the p387 label attribute, if the attribute is present, must not be the empty string. Furthermore, there must not be two

track p385 p388 p386 p387 element children of the same media element whose kind attributes are in the same state, whose srclang

attributes are both missing or have values that represent the same language, and whose p387 label attributes are again both missing or both have the same value.

If the element has a p387 label attribute whose value is not the empty string, then the element's track label is the value of the attribute. Otherwise, the element's p387 track label is an empty string.

The p67 default attribute is a boolean attribute, which, if specified, indicates that the track is to be enabled if the user's preferences do not indicate that another track would be more appropriate.

Each p388 p385 p386 p386 media element must have no more than one track element child whose kind attribute is in the subtitles or

captions p386 p387 state and whose default attribute is specified.

Each p388 p385 p386 p386 media element must have no more than one track element child whose kind attribute is in the description state and whose p387 default attribute is specified.

Each p388 p385 p386 p386 media element must have no more than one track element child whose kind attribute is in the chapters metadata

state and whose p387 default attribute is specified.

Note

There is no limit on the number of p385 p386 p386 p387 track elements whose kind attribute is in the metadata state and whose default

attribute is specified.



For web developers (non-normative)

track p387 . readyState

Returns the p423 text track readiness state , represented by a number from the following list:

track p387 . NONE (0)

The p423 text track not loaded state.

track p387 . LOADING (1)

The p423 text track loading state.

track p388 . LOADED (2)

The p423 text track loaded state.

track p388 . ERROR (3)

The p423 text track failed to load state.

track p388 . track

Returns the p430 p422 p385 TextTrack object corresponding to the text track of the track element.

The p423 p385 readyState attribute must return the numeric value corresponding to the text track readiness state of the track element's

text track p422 , as defined by the following list:

NONE (numeric value 0)

The p423 text track not loaded state.

LOADING (numeric value 1)

The p423 text track loading state.

387

LOADED (numeric value 2)

The p423 text track loaded state.

ERROR (numeric value 3)

The p423 text track failed to load state.

✔ MDN

The p385 p422 p430 track IDL attribute must, on getting, return the track element's text track 's corresponding TextTrack object.

The p95 src , srclang , label , and default IDL attributes must reflect the respective content attributes of the same name. The kind IDL

attribute must p95 p95 reflect the content attribute of the same name, limited to only known values.

Example

This video has subtitles in several languages:





(The p141 p387 lang attributes on the last two describe the language of the label attribute, not the language of the subtitles

themselves. The language of the subtitles is given by the p387 srclang attribute.)



✔ MDN

4.8.12 Media elements p38 §

8 ✔ MDN

HTMLMediaElement p388 p384 p380 objects ( audio and video , in this specification) are simply known as media elements.

IDL enum CanPlayTypeResult { "" /* empty string */, "maybe", "probably" };

typedef (MediaStream or MediaSource or Blob) MediaProvider;

[Exposed=Window]

interface HTMLMediaElement : HTMLElement {

// error state

readonly attribute MediaError? error;

// network state

[CEReactions] attribute USVString src;

attribute MediaProvider? srcObject;

readonly attribute USVString currentSrc;

[CEReactions] attribute DOMString? crossOrigin;

const unsigned short NETWORK_EMPTY = 0;

const unsigned short NETWORK_IDLE = 1;

const unsigned short NETWORK_LOADING = 2;

const unsigned short NETWORK_NO_SOURCE = 3;

readonly attribute unsigned short networkState;

[CEReactions] attribute DOMString preload;

readonly attribute TimeRanges buffered;

undefined load();

CanPlayTypeResult canPlayType(DOMString type);

// ready state

const unsigned short HAVE_NOTHING = 0;

const unsigned short HAVE_METADATA = 1;

const unsigned short HAVE_CURRENT_DATA = 2;

const unsigned short HAVE_FUTURE_DATA = 3;

const unsigned short HAVE_ENOUGH_DATA = 4;

readonly attribute unsigned short readyState;

388

readonly attribute boolean seeking;

// playback state

attribute double currentTime;

undefined fastSeek(double time);

readonly attribute unrestricted double duration;

object getStartDate();

readonly attribute boolean paused;

attribute double defaultPlaybackRate;

attribute double playbackRate;

attribute boolean preservesPitch;

readonly attribute TimeRanges played;

readonly attribute TimeRanges seekable;

readonly attribute boolean ended;

[CEReactions] attribute boolean autoplay;

[CEReactions] attribute boolean loop;

Promise play();

undefined pause();

// controls

[CEReactions] attribute boolean controls;

attribute double volume;

attribute boolean muted;

[CEReactions] attribute boolean defaultMuted;

// tracks

[SameObject] readonly attribute AudioTrackList audioTracks;

[SameObject] readonly attribute VideoTrackList videoTracks;

[SameObject] readonly attribute TextTrackList textTracks;

TextTrack addTextTrack(TextTrackKind kind, optional DOMString label = "", optional DOMString language

= "");

};

The p390 p391 p402 p408 p406 p438 p437 media element attributes , src , crossorigin , preload , autoplay , loop , muted , and controls , apply to

all p388 media elements. They are defined in this section.

Media elements p388 are used to present audio data, or video and audio data, to the user. This is referred to as media data in this section, since this section applies equally to p388 media elements for audio or for video. The term media resource is used to refer to the complete set of media data, e.g. the complete video file, or complete audio file.

A p389 p388 media resource can have multiple audio and video tracks. For the purposes of a media element, the video data of the media

resource p389 p418 is only that of the currently selected track (if any) as given by the element's videoTracks attribute when the event

loop p931 p934 p389 last reached step 1 , and the audio data of the media resource is the result of mixing all the currently enabled tracks (if any) given by the element's p418 p931 p934 audioTracks attribute when the event loop last reached step 1 .

Note

Both p384 p380 audio and video elements can be used for both audio and video. The main difference between the two is simply that

the p384 p380 audio element has no playback area for visual content (such as video or captions), whereas the video element does.

Each p388 media element has a unique media element event task source.

To p388 p933 queue a media element task with a media element element and a series of steps steps , queue an element task on the

media element p388 p389 's media element event task source given element and steps.



4.8.12.1 Error codes p38 §

9

For web developers (non-normative)



389

media p390 . error

Returns a p390 MediaError object representing the current error state of the element. Returns null if there is no error.



All p388 media elements have an associated error status, which records the last error the element encountered since its resource ✔ MDN

selection algorithm p394 p390 was last invoked. The error attribute, on getting, must return the MediaError object created for this last ✔ MDN error, or null if there has not been an error.

IDL [Exposed=Window]

interface MediaError {

const unsigned short MEDIA_ERR_ABORTED = 1;

const unsigned short MEDIA_ERR_NETWORK = 2;

const unsigned short MEDIA_ERR_DECODE = 3;

const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

readonly attribute unsigned short code;

readonly attribute DOMString message;

};



For web developers (non-normative)

media p390 p390 . error . code

Returns the current error's error code, from the list below.

media p390 p390 . error . message

Returns a specific informative diagnostic message about the error condition encountered. The message and message format are not generally uniform across different user agents. If no such message is available, then the empty string is returned.

Every p390 MediaError object has a message, which is a string, and a code, which is one of the following: MEDIA_ERR_ABORTED (numeric value 1)

The fetching process for the p389 media resource was aborted by the user agent at the user's request.

MEDIA_ERR_NETWORK (numeric value 2)

A network error of some description caused the user agent to stop fetching the p389 media resource, after the resource was established to be usable.

MEDIA_ERR_DECODE (numeric value 3)

An error of some description occurred while decoding the p389 media resource , after the resource was established to be usable.

MEDIA_ERR_SRC_NOT_SUPPORTED (numeric value 4)

The p389 p390 p391 media resource indicated by the src attribute or assigned media provider object was not suitable.

To p390 p390 create a MediaError , given an error code which is one of the above values, return a new MediaError object whose code is

the given error code and whose p390 message is a string containing any details the user agent is able to supply about the cause of the error condition, or the empty string if the user agent is unable to supply such details. This message string must not contain only the information already available via the supplied error code; for example, it must not simply be a translation of the code into a string format. If no additional information is available beyond that provided by the error code, the p390 message must be set to the empty ✔ MDN string.

The p390 MDN p390 p390 code attribute of a MediaError object must return this MediaError object's code .

The p390 p390 p390 message attribute of a MediaError object must return this MediaError object's message.



4.8.12.2 Location of the media resource §p39

0

The p388 src content attribute on media elements gives the URL of the media resource (video, audio) to show. The attribute, if present, must contain a p88 valid non-empty URL potentially surrounded by spaces.

✔ MDN

If the p739 p388 p390 itemprop attribute is specified on the media element , then the src attribute must also be specified.

390

The p388 p91 crossorigin content attribute on media elements is a CORS settings attribute.

If a p388 p390 p42 p388 media element is created with a src attribute, the user agent must immediately invoke the media element's resource

selection algorithm p394.

If a p390 p388 p388 src attribute of a media element is set or changed, the user agent must invoke the media element's media element load ✔ MDN

algorithm p393 p390 p318 . ( Removing the src attribute does not do this, even if there are source elements present.) The p388 p95 src IDL attribute on media elements must reflect the content attribute of the same name.

The p95 p391 p95 crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

A p389 media provider object is an object that can represent a media resource , separate from a URL. MediaStream objects,

MediaSource p391 objects, and Blob objects are all media provider objects.

Each p388 p391 media element can have an assigned media provider object , which is a media provider object. When a media

element p388 p391 is created, it has no assigned media provider object .

For web developers (non-normative)

media p391 . srcObject [ = source ]

Allows the p388 p391 media element to be assigned a media provider object.

media p391 . currentSrc

Returns the p389 URL of the current media resource , if any.

Returns the empty string when there is no p389 media resource, or it doesn't have a URL.



The p394 currentSrc IDL attribute must initially be set to the empty string. Its value is changed by the resource selection algorithm ✔ ⚠ MDN MDN defined below.

The p391 srcObject IDL attribute, on getting, must return the element's assigned media provider object, if any, or null otherwise. On setting, it must set the element's p391 assigned media provider object to the new value, and then invoke the element's media element

load algorithm p393 .

Note

There are three ways to specify a p389 p391 p390 p318 media resource : the srcObject IDL attribute, the src content attribute, and source

elements. The IDL attribute takes priority, followed by the content attribute, followed by the elements.



4.8.12.3 MIME types p39 §

1

A p389 media resource can be described in terms of its type, specifically a MIME type, in some cases with a codecs parameter. (Whether the p1281 codecs parameter is allowed or not depends on the MIME type.) [RFC6381]

Types are usually somewhat incomplete descriptions; for example "video/mpeg" doesn't say anything except what the container type is, and even a type like "video/mp4; codecs="avc1.42E01E, mp4a.40.2"" doesn't include information like the actual bitrate (only the maximum bitrate). Thus, given a type, a user agent can often only know whether it might be able to play media of that type (with varying levels of confidence), or whether it definitely cannot play media of that type.

A type that the user agent knows it cannot render is one that describes a resource that the user agent definitely does not support, for example because it doesn't recognize the container type, or it doesn't support the listed codecs.

The p391 MIME type " application/octet-stream " with no parameters is never a type that the user agent knows it cannot render. User agents must treat that type as equivalent to the lack of any explicit p90 Content-Type metadata when it is used to label a potential

media resource p389 .

Note

Only the MIME type "application/octet-stream" with no parameters is special-cased here; if any parameter appears with it, it

will be treated just like any other MIME type. This is a deviation from the rule that unknown MIME type parameters should be

ignored.



391

For web developers (non-normative)

media p392 . canPlayType(type)

Returns the empty string (a negative response), "maybe", or "probably" based on how confident the user agent is that it can play media resources of the given type.



The p391 canPlayType( type ) method must return the empty string if type is a type that the user agent knows it cannot render or is ✔ MDN

the type "application/octet-stream"; it must return "probably" if the user agent is confident that the type represents a media

resource p389 p384 p380 that it can render if used in with this audio or video element; and it must return "maybe" otherwise. Implementors are encouraged to return " p392 maybe" unless the type can be confidently established as being supported or not. Generally, a user agent should never return " p392 probably" for a type that allows the codecs parameter if that parameter is not present.

Example

This script tests to see if the user agent supports a (fictional) new format to dynamically decide whether to use a p380 video element

or a plugin:





Download video





Note

The p318 p318 type attribute of the source element allows the user agent to avoid downloading resources that use formats it cannot

render.



4.8.12.4 Network states p39 §

2

For web developers (non-normative)

media p392 . networkState

Returns the current state of network activity for the element, from the codes in the list below.



As p388 media elements interact with the network, their current network activity is represented by the networkState attribute. On ✔ MDN getting, it must return the current network state of the element, which must be one of the following values: NETWORK_EMPTY (numeric value 0)

The element has not yet been initialized. All attributes are in their initial states.



392

NETWORK_IDLE (numeric value 1)

The element's p394 p389 resource selection algorithm is active and has selected a resource , but it is not actually using the network at this time.

NETWORK_LOADING (numeric value 2)

The user agent is actively trying to download data.

NETWORK_NO_SOURCE (numeric value 3)

The element's p394 p389 resource selection algorithm is active, but it has not yet found a resource to use.

The p394 p392 resource selection algorithm defined below describes exactly when the networkState attribute changes value and what events fire to indicate changes in this state.



4.8.12.5 Loading the media resource p39 §

3

For web developers (non-normative)

media p393 . load ()

Causes the element to reset and start selecting and loading a new p389 media resource from scratch.

All p388 media elements have a can autoplay flag, which must begin in the true state, and a delaying-the-load-event flag, which must begin in the false state. While the p393 p1162 delaying-the-load-event flag is true, the element must delay the load event of its ✔ MDN document.

When the p388 p393 load() method on a media element is invoked, the user agent must run the media element load algorithm .

The media element load algorithm consists of the following steps.

1. Abort any already-running instance of the p394 resource selection algorithm for this element.

2. Let p932 p388 p389 pending tasks be a list of all tasks from the media element 's media element event task source in one of the

task queues p931.

3. For each task in p411 p411 pending tasks that would resolve pending play promises or reject pending play promises , immediately

resolve or reject those promises in the order the corresponding tasks were queued.

4. Remove each p932 p931 task in pending tasks from its task queue

Note

Basically, pending events and callbacks are discarded and promises in-flight to be resolved/rejected are resolved/ rejected immediately when the media element starts loading a new resource.

5. If the p388 p392 p393 p393 media element 's networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue a media element

task p389 p388 p440 p388 given the media element to fire an event named abort at the media element.

6. If the p388 p392 p392 media element 's networkState is not set to NETWORK_EMPTY, then:

1. p389 p388 p440 Queue a media element task given the media element to fire an event named emptied at the media

element p388.

2. If a fetching process is in progress for the p388 media element, the user agent should stop it.

3. If the p388 p391 media element 's assigned media provider object is a MediaSource object, then detach it.

4. p402 Forget the media element's media-resource-specific tracks.

5. If p408 p406 readyState is not set to HAVE_NOTHING, then set it to that state.

6. If the p409 paused attribute is false, then:

1. Set the p409 paused attribute to true.

2. p411 p411 Take pending play promises and reject pending play promises with the result and an "AbortError"

DOMException.

393

7. If p416 seeking is true, set it to false.

8. Set the p404 current playback position to 0.

Set the p404 official playback position to 0.

If this changed the p404 p389 p388 official playback position , then queue a media element task given the media element

to p441 p388 fire an event named timeupdate at the media element .

9. Set the p405 timeline offset to Not-a-Number (NaN).

10. Update the p405 duration attribute to Not-a-Number (NaN).

Note

The user agent p405 p441 will not fire a durationchange event for this particular change of the duration.

7. Set the p410 p410 playbackRate attribute to the value of the defaultPlaybackRate attribute.

8. Set the p390 p393 error attribute to null and the can autoplay flag to true.

9. Invoke the p388 p394 media element 's resource selection algorithm.

Note

10. p389 Playback of any previously playing media resource for this element stops.

The p388 p932 resource selection algorithm for a media element is as follows. This algorithm is always invoked as part of a task, but one of the first steps in the algorithm is to return and continue running the remaining steps p42 in parallel. In addition, this algorithm

interacts closely with the p931 p937 event loop mechanism; in particular, it has synchronous sections (which are triggered as part of the

event loop p931 algorithm). Steps in such sections are marked with ⌛.

1. Set the element's p392 p393 networkState attribute to the NETWORK_NO_SOURCE value.

2. Set the element's p405 show poster flag to true.

3. Set the p388 p393 p1162 media element 's delaying-the-load-event flag to true (this delays the load event).

4. p936 p932 p937 Await a stable state , allowing the task that invoked this algorithm to continue. The synchronous section consists of

all the remaining steps of this algorithm until the algorithm says the p937 synchronous section has ended. (Steps in

synchronous sections p937 are marked with ⌛.)

5. p388 p423 p423 ⌛ If the media element 's blocked-on-parser flag is false, then populate the list of pending text tracks .

6. p388 p391 ⌛ If the media element has an assigned media provider object, then let mode be object.

⌛ p388 p391 p390 Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.

⌛ p388 p391 p390 Otherwise, if the media element does not have an assigned media provider object and does not have a src

attribute, but does have a p318 p318 source element child, then let mode be children and let candidate be the first such source

element child in tree order.

⌛ p388 p391 p390 Otherwise the media element has no assigned media provider object and has neither a src attribute nor a

source p318 element child:

1. p392 p392 ⌛ Set the networkState to NETWORK_EMPTY.

2. p393 p1162 ⌛ Set the element's delaying-the-load-event flag to false. This stops delaying the load event.

3. End the p937 synchronous section and return.

7. p388 p392 p393 ⌛ Set the media element 's networkState to NETWORK_LOADING.

8. p389 p388 p440 ⌛ Queue a media element task given the media element to fire an event named loadstart at the media

element p388.

9. Run the appropriate steps from the following list:



394

↪ If mode is object

1. p391 ⌛ Set the currentSrc attribute to the empty string.

2. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

3. Run the p397 p391 resource fetch algorithm with the assigned media provider object. If that algorithm returns

without aborting this one, then the load failed.

4. Failed with media provider: Reaching this step indicates that the media resource failed to load. Take pending

play promises p411 p389 p388 and queue a media element task given the media element to run the dedicated

media source failure steps p396 with the result.

5. Wait for the p932 task queued by the previous step to have executed.

6. Return. The element won't attempt to load another resource until this algorithm is triggered again.

↪ If mode is attribute

1. p390 p937 ⌛ If the src attribute's value is the empty string, then end the synchronous section, and jump down

to the failed with attribute step below.

2. p89 p89 ⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively,

that would have resulted from p89 p390 parsing the URL specified by the src attribute's value relative to the

media element p388 p390 's node document when the src attribute was last changed.

3. p391 ⌛ If urlString was obtained successfully, set the currentSrc attribute to urlString.

4. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

5. If p397 urlRecord was obtained successfully, run the resource fetch algorithm with urlRecord. If that algorithm

returns without aborting this one, then the load failed.

6. Failed with attribute: Reaching this step indicates that the media resource failed to load or that the given

URL p89 p411 p389 could not be parsed . Take pending play promises and queue a media element task given the

media element p388 p396 to run the dedicated media source failure steps with the result.

7. Wait for the p932 task queued by the previous step to have executed.

8. Return. The element won't attempt to load another resource until this algorithm is triggered again.

↪ Otherwise (mode is children)

1. p388 ⌛ Let pointer be a position defined by two adjacent nodes in the media element 's child list, treating the

start of the list (before the first child in the list, if any) and end of the list (after the last child in the list, if any) as nodes in their own right. One node is the node before pointer, and the other node is the node after pointer. Initially, let pointer be the position between the candidate node and the next node, if there are any, or the end of the list, if it is the last node.

As p44 p44 p388 nodes are inserted and removed into the media element, pointer must be updated as follows:

If a new p44 node is inserted between the two nodes that define pointer

Let pointer be the point between the node before pointer and the new node. In other words, insertions at pointer go after pointer.

If the node before pointer is removed

Let pointer be the point between the node after pointer and the node before the node after pointer. In other words, pointer doesn't move relative to the remaining nodes.

If the node after pointer is removed

Let pointer be the point between the node before pointer and the node after the node before pointer. Just as with the previous case, pointer doesn't move relative to the remaining nodes.

Other changes don't affect pointer.

2. p319 p319 ⌛ Process candidate : If candidate does not have a src attribute, or if its src attribute's value is the

empty string, then end the p937 synchronous section, and jump down to the failed with elements step below.

3. p89 p89 ⌛ Let urlString and urlRecord be the resulting URL string and the resulting URL record, respectively,

that would have resulted from p89 p319 parsing the URL specified by candidate 's src attribute's value relative

to the p319 candidate 's node document when the src attribute was last changed.

395

4. p937 ⌛ If urlString was not obtained successfully, then end the synchronous section, and jump down to the

failed with elements step below.

5. p318 ⌛ If candidate has a type attribute whose value, when parsed as a MIME type (including any codecs

described by the codecs parameter, for types that define that parameter), represents a type that the user

agent knows it cannot render p391 p937 , then end the synchronous section, and jump down to the failed with elements step below.

6. p391 ⌛ Set the currentSrc attribute to urlString.

7. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

8. Run the p397 resource fetch algorithm with urlRecord. If that algorithm returns without aborting this one, then

the load failed.

9. p389 p388 Failed with elements : Queue a media element task given the media element to fire an event named

error p441 at candidate.

10. p936 p937 Await a stable state . The synchronous section consists of all the remaining steps of this algorithm

until the algorithm says the p937 p937 synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

11. p402 ⌛ Forget the media element's media-resource-specific tracks .

12. ⌛ Find next candidate: Let candidate be null.

13. ⌛ Search loop: If the node after pointer is the end of the list, then jump to the waiting step below.

14. p318 ⌛ If the node after pointer is a source element, let candidate be that element.

15. ⌛ Advance pointer so that the node before pointer is now the node that was after pointer, and the node after

pointer is the node after the node that used to be after pointer, if any.

16. ⌛ If candidate is null, jump back to the search loop step. Otherwise, jump back to the process candidate

step.

17. p392 p393 ⌛ Waiting : Set the element's networkState attribute to the NETWORK_NO_SOURCE value.

18. p405 ⌛ Set the element's show poster flag to true.

19. p389 p388 ⌛ Queue a media element task given the media element to set the element's delaying-the-load-event

flag p393 p1162 to false. This stops delaying the load event.

20. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)

22. p936 p937 Await a stable state . The synchronous section consists of all the remaining steps of this algorithm

until the algorithm says the p937 p937 synchronous section has ended. (Steps in synchronous sections are marked with ⌛.)

23. p393 p1162 ⌛ Set the element's delaying-the-load-event flag back to true (this delays the load event again, in

case it hasn't been fired yet).

24. p392 p393 ⌛ Set the networkState back to NETWORK_LOADING .

25. ⌛ Jump back to the find next candidate step above.

The dedicated media source failure steps with a list of promises promises are the following steps:

1. Set the p390 p390 p390 error attribute to the result of creating a MediaError with MEDIA_ERR_SRC_NOT_SUPPORTED .

2. p402 Forget the media element's media-resource-specific tracks.

3. Set the element's p392 p393 networkState attribute to the NETWORK_NO_SOURCE value.

4. Set the element's p405 show poster flag to true.

5. p440 p388 Fire an event named error at the media element.

396

6. p411 Reject pending play promises with promises and a "NotSupportedError" DOMException.

7. Set the element's p393 p1162 delaying-the-load-event flag to false. This stops delaying the load event.

The p388 p391 resource fetch algorithm for a media element and a given URL record or media provider object is as follows:

1. If the algorithm was invoked with p391 p391 media provider object or a URL record whose object is a media provider object, then

let mode be local. Otherwise let mode be remote.

2. If mode is remote, then let the current media resource be the resource given by the URL record passed to this algorithm;

otherwise, let the p391 current media resource be the resource given by the media provider object . Either way, the current

media resource p389 is now the element's media resource.

3. Remove all p425 p388 p423 media-resource-specific text tracks from the media element 's list of pending text tracks, if any.

4. Run the appropriate steps from the following list:

↪ If mode is remote

1. Optionally, run the following substeps. This is the expected behavior if the user agent intends to not attempt

to fetch the resource until the user requests it explicitly (e.g. as a way to implement the p402 preload

attribute's p402 none keyword).

1. Set the p392 p393 networkState to NETWORK_IDLE.

2. p389 p388 p440 Queue a media element task given the media element to fire an event named suspend

at the element.

3. p389 p388 Queue a media element task given the media element to set the element's delaying-the-

load-event flag p393 p1162 to false. This stops delaying the load event.

4. Wait for the task to be run.

5. Wait for an implementation-defined event (e.g., the user requesting that the media element begin

playback).

6. Set the element's p393 p1162 delaying-the-load-event flag back to true (this delays the load event

again, in case it hasn't been fired yet).

7. Set the p392 p393 networkState to NETWORK_LOADING .

2. Let p388 p384 destination be " audio " if the media element is an audio element and to "video" otherwise.

Let p90 request be the result of creating a potential-CORS request given current media resource's URL record,

destination p388 p391 , and the media element 's crossorigin content attribute value.

Set p388 p911 request 's client to the media element 's node document 's relevant settings object .

Fetch request.

The p90 p389 response 's unsafe response obtained in this fashion, if any, contains the media data. It can be

CORS-same-origin p90 p90 p389 or CORS-cross-origin ; this affects whether subtitles referenced in the media data

are exposed in the API and, for p380 p635 video elements, whether a canvas gets tainted when the video is drawn on it.

The stall timeout is an implementation-defined length of time, which should be about three seconds. When

a p388 p389 media element that is actively attempting to obtain media data has failed to receive any data for a

duration equal to the p397 p389 stall timeout , the user agent must queue a media element task given the media

element p388 p440 to fire an event named stalled at the element.

User agents may allow users to selectively block or slow p389 media data downloads. When a media

element p388's download has been blocked altogether, the user agent must act as if it was stalled (as opposed to acting as if the connection was closed). The rate of the download may also be throttled automatically by the user agent, e.g. to balance the download with other connections sharing the same bandwidth.

User agents may decide to not download more content at any time, e.g. after buffering five minutes of a one hour media resource, while waiting for the user to decide whether to play the resource or not, while waiting

for user input in an interactive resource, or when the user navigates away from the page. When a media

397

element p388 p389 's download has been suspended, the user agent must queue a media element task given

the p388 p392 p393 media element to set the networkState to NETWORK_IDLE and fire an event named

suspend p440 at the element. If and when downloading of the resource resumes, the user agent must queue a

media element task p389 p388 p392 p393 given the media element to set the networkState to NETWORK_LOADING .

Between the queuing of these tasks, the load is suspended (so p440 progress events don't fire, as described above).

Note

The p402 preload attribute provides a hint regarding how much buffering the author thinks is advisable,

even in the absence of the p408 autoplay attribute.

When a user agent decides to completely suspend a download, e.g., if it is waiting until the user starts

playback before downloading any further content, the user agent must p389 queue a media element task

given the p388 p393 media element to set the element's delaying-the-load-event flag to false. This stops

delaying the load event p1162.

The user agent may use whatever means necessary to fetch the resource (within the constraints put forward by this and other specifications); for example, reconnecting to the server in the face of network errors, using HTTP range retrieval requests, or switching to a streaming protocol. The user agent must consider a resource erroneous only if it has given up trying to fetch it.

To determine the format of the p389 media resource, the user agent must use the rules for sniffing audio and

video specifically.

While the load is not suspended (see below), every 350ms (±200ms) or for every byte received, whichever

is p389 p388 least frequent, queue a media element task given the media element to fire an event named

progress p440 at the element.

The p939 p932 p42 networking task source tasks to process the data as it is being fetched must each immediately

queue a media element task p389 p388 given the media element to run the first appropriate steps from the

media data processing steps list p399 below. (A new task is used for this so that the work described below

occurs relative to the appropriate p389 media element event task source rather than using the networking

task source p939.)

When the p939 p933 p932 networking task source has queued the last task as part of fetching the media

resource p389 (i.e. once the download has completed), if the fetching process completes without errors, including decoding the media data, and if all of the data is available to the user agent without network access, then, the user agent must move on to the final step below. This might never happen, e.g. when streaming an infinite resource such as web radio, or if the resource is longer than the user agent's ability to cache data.

While the user agent might still need network access to obtain parts of the p389 media resource, the user agent must remain on this step.

Example

For example, if the user agent has discarded the first half of a video, the user agent will remain at this

step even once the p409 playback has ended, because there is always the chance the user will seek back

to the start. In fact, in this situation, once p409 playback has ended, the user agent will end up firing a

suspend p440 event, as described earlier.

↪ Otherwise (mode is local)

The resource described by the p389 p90 current media resource , if any, contains the media data . It is CORS-same-origin.

If the current media resource is a raw data stream (e.g. from a File object), then to determine the format of the

media resource p389 , the user agent must use the rules for sniffing audio and video specifically. Otherwise, if the data stream is pre-decoded, then the format is the format given by the relevant specification.

Whenever new data for the p389 current media resource becomes available, queue a media element task given the

media element p388 p399 to run the first appropriate steps from the media data processing steps list below.

When the current media resource is permanently exhausted (e.g. all the bytes of a Blob have been processed), if there were no decoding errors, then the user agent must move on to the final step below. This might never happen,

e.g. if the current media resource is a MediaStream.

398

The media data processing steps list is as follows:

↪ p389 If the media data cannot be fetched at all, due to network errors, causing the user agent to give up

trying to fetch the resource

↪ p389 If the media data can be fetched but is found by inspection to be in an unsupported format, or can

otherwise not be rendered at all

DNS errors, HTTP 4xx and 5xx errors (and equivalents in other protocols), and other fatal network errors that occur before the user agent has established whether the current media resource is usable, as well as the file using an unsupported container format, or using unsupported codecs for all the data, must cause the user agent to execute the following steps:

1. The user agent should cancel the fetching process.

2. Abort this subalgorithm, returning to the p394 resource selection algorithm .

↪ p389 If the media resource is found to have an audio track

1. Create an p418 AudioTrack object to represent the audio track.

2. Update the p388 p418 p418 media element 's audioTracks attribute's AudioTrackList object with the new

AudioTrack p418 object.

3. Let enable be unknown.

4. If either the p389 media resource or the URL of the current media resource indicate a particular set of audio

tracks to enable, or if the user agent has information that would facilitate the selection of specific audio tracks to improve the user's experience, then: if this audio track is one of the ones to enable, then set enable to true, otherwise, set enable to false.

Example

This could be triggered by media fragment syntax, but it could also be triggered e.g. by the user agent selecting a 5.1 surround sound audio track over a stereo audio track.

5. If p388 p421 enable is still unknown , then, if the media element does not yet have an enabled audio track, then

set enable to true, otherwise, set enable to false.

6. If enable is true, then enable this audio track, otherwise, do not enable this audio track.

7. p441 p418 p439 Fire an event named addtrack at this AudioTrackList object, using TrackEvent, with the

track p440 p418 attribute initialized to the new AudioTrack object.

↪ p389 If the media resource is found to have a video track

1. Create a p418 VideoTrack object to represent the video track.

2. Update the p388 p418 p418 media element 's videoTracks attribute's VideoTrackList object with the new

VideoTrack p418 object.

3. Let enable be unknown.

4. If either the p389 media resource or the URL of the current media resource indicate a particular set of video

tracks to enable, or if the user agent has information that would facilitate the selection of specific video tracks to improve the user's experience, then: if this video track is the first such video track, then set enable to true, otherwise, set enable to false.

Example

This could again be triggered by media fragment syntax.

5. If p388 p421 enable is still unknown , then, if the media element does not yet have a selected video track, then

set enable to true, otherwise, set enable to false.

6. If enable is true, then select this track and unselect any previously selected video tracks, otherwise, do not

select this video track. If other tracks are unselected, then p421 a change event will be fired.

7. p441 p418 p439 Fire an event named addtrack at this VideoTrackList object, using TrackEvent, with the

track p440 p418 attribute initialized to the new VideoTrack object.

399

↪ p389 p389 Once enough of the media data has been fetched to determine the duration of the media resource,

its dimensions, and other metadata

This indicates that the resource is usable. The user agent must follow these substeps:

1. p403 p404 Establish the media timeline for the purposes of the current playback position and the earliest

possible position p405 p389 , based on the media data .

2. Update the p405 timeline offset to the date and time that corresponds to the zero time in the media

timeline p403 established in the previous step, if any. If no explicit time and date is given by the media

resource p389 p405 , the timeline offset must be set to Not-a-Number (NaN).

3. Set the p404 p404 current playback position and the official playback position to the earliest possible

position p405.

4. Update the p405 duration attribute with the time of the last frame of the resource, if known, on the media

timeline p403 established above. If it is not known (e.g. a stream that is in principle infinite), update the

duration p405 attribute to the value positive Infinity.

Note

The user agent p405 p389 p388 will queue a media element task given the media element to fire an event

named p441 durationchange at the element at this point.

5. For p380 p383 p383 video elements, set the videoWidth and videoHeight attributes, and queue a media element

task p389 p388 p441 p388 given the media element to fire an event named resize at the media element .

Note

Further p441 resize events will be fired if the dimensions subsequently change.

6. Set the p408 p406 readyState attribute to HAVE_METADATA.

Note

A p440 p407 p408 loadedmetadata DOM event will be fired as part of setting the readyState attribute to a new value.

7. Let jumped be false.

8. If the p388 p404 p416 media element 's default playback start position is greater than zero, then seek to that time,

and let jumped be true.

9. Let the p388 p404 media element 's default playback start position be zero.

10. Let the initial playback position be zero.

11. If either the p389 media resource or the URL of the current media resource indicate a particular start time,

then set the p416 initial playback position to that time and, if jumped is still false, seek to that time.

Example

For example, with media formats that support media fragment syntax, the fragment can be used to indicate a start position.

12. If there is no p421 enabled audio track, then enable an audio track. This will cause a change event to be

fired p421 .

13. If there is no p421 selected video track, then select a video track. This will cause a change event to be

fired p421 .

Once the p408 p406 p407 readyState attribute reaches HAVE_CURRENT_DATA , after the loadeddata event has been fired, set

the element's p393 p1162 delaying-the-load-event flag to false. This stops delaying the load event.

Note

A user agent that is attempting to reduce network usage while still fetching the metadata for each media

resource p389 p397 would also stop buffering at this point, following the rules described previously, which involve the

networkState p392 p393 p440 attribute switching to the NETWORK_IDLE value and a suspend event firing.

400

Note

The user agent is p389 required to determine the duration of the media resource and go through this step before playing.



↪ p389 Once the entire media resource has been fetched (but potentially before any of it has been decoded)

Fire an event p440 p388 named progress at the media element.

Set the p392 p393 p440 p388 networkState to NETWORK_IDLE and fire an event named suspend at the media element.

If the user agent ever discards any p389 media data and then needs to resume the network activity to obtain it again,

then it must p389 p388 p392 queue a media element task given the media element to set the networkState to

NETWORK_LOADING p393 .

Note

If the user agent can keep the p389 media resource loaded, then the algorithm will continue to its final step below, which aborts the algorithm.



↪ p389 If the connection is interrupted after some media data has been received, causing the user agent to

give up trying to fetch the resource

Fatal network errors that occur after the user agent has established whether the current media resource is usable (i.e.

once the p388 p408 p406 media element 's readyState attribute is no longer HAVE_NOTHING ) must cause the user agent to execute the following steps:

1. The user agent should cancel the fetching process.

2. Set the p390 p390 p390 error attribute to the result of creating a MediaError with MEDIA_ERR_NETWORK .

3. Set the element's p392 p393 networkState attribute to the NETWORK_IDLE value.

4. Set the element's p393 p1162 delaying-the-load-event flag to false. This stops delaying the load event.

5. p440 p388 Fire an event named error at the media element.

6. Abort the overall p394 resource selection algorithm .

↪ p389 If the media data is corrupted

Fatal errors in decoding the p389 media data that occur after the user agent has established whether the current media

resource p388 p408 p406 is usable (i.e. once the media element 's readyState attribute is no longer HAVE_NOTHING ) must cause the user agent to execute the following steps:

1. The user agent should cancel the fetching process.

2. Set the p390 p390 p390 error attribute to the result of creating a MediaError with MEDIA_ERR_DECODE.

3. Set the element's p392 p393 networkState attribute to the NETWORK_IDLE value.

4. Set the element's p393 p1162 delaying-the-load-event flag to false. This stops delaying the load event.

5. p440 p388 Fire an event named error at the media element.

6. Abort the overall p394 resource selection algorithm .

↪ p389 If the media data fetching process is aborted by the user

The fetching process is aborted by the user, e.g. because the user pressed a "stop" button, the user agent must

execute the following steps. These steps are not followed if the p393 load() method itself is invoked while these steps are running, as the steps above handle that particular kind of abort.

1. The user agent should cancel the fetching process.

2. Set the p390 p390 p390 error attribute to the result of creating a MediaError with MEDIA_ERR_ABORTED .

3. p440 p388 Fire an event named abort at the media element.

4. If the p388 p408 p406 media element 's readyState attribute has a value equal to HAVE_NOTHING, set the element's

networkState p392 p392 p405 attribute to the NETWORK_EMPTY value, set the element's show poster flag to true,

and p440 fire an event named emptied at the element.

401

Otherwise, set the element's p392 p393 networkState attribute to the NETWORK_IDLE value.

5. Set the element's p393 p1162 delaying-the-load-event flag to false. This stops delaying the load event.

6. Abort the overall p394 resource selection algorithm .

↪ p389 If the media data can be fetched but has non-fatal errors or uses, in part, codecs that are unsupported,

preventing the user agent from rendering the content completely correctly but not preventing playback altogether

The server returning data that is partially usable but cannot be optimally rendered must cause the user agent to render just the bits it can handle, and ignore the rest.

↪ p389 p425 If the media resource is found to declare a media-resource-specific text track that the user agent

supports

If the p389 p90 p425 media data is CORS-same-origin , run the steps to expose a media-resource-specific text track with the relevant data.

Note

Cross-origin videos do not expose their subtitles, since that would allow attacks such as hostile sites reading subtitles from confidential videos on a user's intranet.

5. Final step: If the user agent ever reaches this step (which can only happen if the entire resource gets loaded and kept

available): abort the overall p394 resource selection algorithm.

When a p388 media element is to forget the media element's media-resource-specific tracks, the user agent must remove from the p388 p422 p425 p388 media element 's list of text tracks all the media-resource-specific text tracks , then empty the media element's

audioTracks p418 p418 p388 p418 attribute's AudioTrackList object, then empty the media element 's videoTracks attribute's

VideoTrackList p418 p441 p440 p440 object. No events (in particular, no removetrack events) are fired as part of this; the error and emptied events, fired by the algorithms that invoke this one, can be used instead.



The p68 preload attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword. The attribute can be changed even once the p389 media resource is being buffered or played; the descriptions in the table below are to be interpreted with that in mind.

Keyword State Brief description

none None Hints to the user agent that either the author does not expect the user to need the media resource, or that the server wants to minimize

unnecessary traffic. This state does not provide a hint regarding how aggressively to actually download the media resource if buffering starts anyway (e.g. once the user hits "play").

metadata Metadata Hints to the user agent that the author does not expect the user to need the media resource, but that fetching the resource metadata

(dimensions, track list, duration, etc), and maybe even the first few frames, is reasonable. If the user agent precisely fetches no more

than the metadata, then the p388 p408 p406 media element will end up with its readyState attribute set to HAVE_METADATA; typically though,

some frames will be obtained as well and it will probably be p406 p406 HAVE_CURRENT_DATA or HAVE_FUTURE_DATA . When the media resource is playing, hints to the user agent that bandwidth is to be considered scarce, e.g. suggesting throttling the download so that the media data is obtained at the slowest possible rate that still maintains consistent playback.

auto Automatic Hints to the user agent that the user agent can put the user's needs first without risk to the server, up to and including optimistically

downloading the entire resource.

The empty string is also a valid keyword, and maps to the p402 p68 Automatic state. The attribute's missing value default and invalid

value default p68 p402 are implementation-defined , though the Metadata state is suggested as a compromise between reducing server load and providing an optimal user experience.

Note

Authors might switch the attribute from " p402 p402 p402 none " or " metadata " to " auto" dynamically once the user begins playback. For

example, on a page with many videos this might be used to indicate that the many videos are not to be downloaded unless

requested, but that once one is requested it is to be downloaded aggressively.

The p402 preload attribute is intended to provide a hint to the user agent about what the author thinks will lead to the best user experience. The attribute may be ignored altogether, for example based on explicit user preferences or based on the available connectivity.

The p95 p95 preload IDL attribute must reflect the content attribute of the same name, limited to only known values.

402

Note

The p408 p402 autoplay attribute can override the preload attribute (since if the media plays, it naturally has to buffer first,

regardless of the hint given by the p402 preload attribute). Including both is not an error, however.



For web developers (non-normative)

media p403 . buffered

Returns a p439 p389 TimeRanges object that represents the ranges of the media resource that the user agent has buffered.

The p439 buffered attribute must return a new static normalized TimeRanges object that represents the ranges of the media

resource p389, if any, that the user agent has buffered, at the time the attribute is evaluated. Users agents must accurately determine the ranges available, even for media streams where this can only be determined by tedious inspection.

Note

Typically this will be a single range anchored at the zero point, but if, e.g. the user agent uses HTTP range requests in response to

seeking, then there could be multiple ranges.

User agents may discard previously buffered data.

Note

Thus, a time position included within a range of the objects return by the p403 buffered attribute at one time can end up being not

included in the range(s) of objects returned by the same attribute at later times.



⚠Warning!

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be

costly to change it. It is not to be copied to new APIs.



4.8.12.6 Offsets into the media resource p40 §

3

For web developers (non-normative)

media p405 . duration

Returns the length of the p389 p389 media resource , in seconds, assuming that the start of the media resource is at time zero. Returns NaN if the duration isn't available.

Returns Infinity for unbounded streams.

media p405 . currentTime [ = value ]

Returns the p404 official playback position , in seconds.

Can be set, to seek to the given time.

A p389 p389 media resource has a media timeline that maps times (in seconds) to positions in the media resource . The origin of a timeline is its earliest defined position. The duration of a timeline is its last defined position.

Establishing the media timeline p389 : if the media resource somehow specifies an explicit timeline whose origin is not negative (i.e.

gives each frame a specific time offset and gives the first frame a zero or positive offset), then the p403 media timeline should be that timeline. (Whether the p389 p389 media resource can specify a timeline or not depends on the media resource's format.) If the media

resource p389 specifies an explicit start time and date, then that time and date should be considered the zero point in the media

timeline p403 p405 p406 ; the timeline offset will be the time and date, exposed using the getStartDate() method.

If the p389 media resource has a discontinuous timeline, the user agent must extend the timeline used at the start of the resource across the entire resource, so that the p403 p389 media timeline of the media resource increases linearly starting from the earliest possible

position p405 p389 (as defined below), even if the underlying media data has out-of-order or even overlapping time codes.

Example

For example, if two clips have been concatenated into one video file, but the video format exposes the original times for the two

clips, the video data might expose a timeline that goes, say, 00:15..00:29 and then 00:05..00:38. However, the user agent would

403

not expose those times; it would instead expose the times as 00:15..00:29 and 00:29..01:02, as a single video.

In the rare case of a p389 p403 media resource that does not have an explicit timeline, the zero time on the media timeline should correspond to the first frame of the p389 p389 media resource . In the even rarer case of a media resource with no explicit timings of any kind, not even frame durations, the user agent must itself determine the time for each frame in an implementation-

defined manner.

Note

An example of a file format with no explicit timeline but with explicit frame durations is the Animated GIF format. An example of a

file format with no explicit timings at all is the JPEG-push format ( p1242 multipart/x-mixed-replace with JPEG frames, often used

as the format for MJPEG streams).

If, in the case of a resource with no timing information, the user agent will nonetheless be able to seek to an earlier point than the first frame originally provided by the server, then the zero time should correspond to the earliest seekable time of the p389 media resource ;

otherwise, it should correspond to the first frame received from the server (the point in the p389 media resource at which the user agent began receiving the stream).

Note

At the time of writing, there is no known format that lacks explicit frame time offsets yet still supports seeking to a frame before

the first frame sent by the server.



Example

Consider a stream from a TV broadcaster, which begins streaming on a sunny Friday afternoon in October, and always sends

connecting user agents the media data on the same media timeline, with its zero time set to the start of this stream. Months later,

user agents connecting to this stream will find that the first frame they receive has a time with millions of seconds. The

getStartDate() p406 method would always return the date that the broadcast started; this would allow controllers to display real

times in their scrubber (e.g. "2:30pm") rather than a time relative to when the broadcast began ("8 months, 4 hours, 12 minutes,

and 23 seconds").

Consider a stream that carries a video with several concatenated fragments, broadcast by a server that does not allow user agents

to request specific times but instead just streams the video data in a predetermined order, with the first frame delivered always

being identified as the frame with time zero. If a user agent connects to this stream and receives fragments defined as covering

timestamps 2010-03-20 23:15:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, it

would expose this with a p403 media timeline starting at 0s and extending to 3,600s (one hour). Assuming the streaming server

disconnected at the end of the second clip, the p405 p406 duration attribute would then return 3,600. The getStartDate() method

would return a Date object with a time corresponding to 2010-03-20 23:15:00 UTC. However, if a different user agent connected

five minutes later, it would (presumably) receive fragments covering timestamps 2010-03-20 23:20:00 UTC to 2010-03-21

00:05:00 UTC and 2010-02-12 14:25:00 UTC to 2010-02-12 14:35:00 UTC, and would expose this with a p403 media timeline starting

at 0s and extending to 3,300s (fifty five minutes). In this case, the p406 getStartDate() method would return a Date object with a

time corresponding to 2010-03-20 23:20:00 UTC.

In both of these examples, the p417 seekable attribute would give the ranges that the controller would want to actually display in its

UI; typically, if the servers don't support seeking to arbitrary times, this would be the range of time from the moment the user

agent connected to the stream up to the latest frame that the user agent has obtained; however, if the user agent starts

discarding earlier information, the actual range might be shorter.

In any case, the user agent must ensure that the p405 earliest possible position (as defined below) using the established media

timeline p403, is greater than or equal to zero.

The p403 media timeline also has an associated clock. Which clock is used is user-agent defined, and may be media

resource p389-dependent, but it should approximate the user's wall clock.

Media elements p388 p389 have a current playback position , which must initially (i.e. in the absence of media data) be zero seconds.

The p404 p403 current playback position is a time on the media timeline.

Media elements p388 also have an official playback position, which must initially be set to zero seconds. The official playback

position p404 p404 is an approximation of the current playback position that is kept stable while scripts are running.

Media elements p388 also have a default playback start position, which must initially be set to zero seconds. This time is used to

404

allow the element to be seeked even before the media is loaded.

Each p388 p388 media element has a show poster flag . When a media element is created, this flag must be set to true. This flag is used ✔ MDN

to control when the user agent is to show a poster frame for a p380 video element instead of showing the video contents.

The p388 p404 currentTime attribute must, on getting, return the media element 's default playback start position, unless that is zero, in which case it must return the element's p404 official playback position. The returned value must be expressed in seconds. On setting, if the p388 p408 p406 p388 media element 's readyState is HAVE_NOTHING , then it must set the media element 's default playback start

position p404 p404 p416 to the new value; otherwise, it must set the official playback position to the new value and then seek to the new value. The new value must be interpreted as being in seconds.

If the p389 media resource is a streaming resource, then the user agent might be unable to obtain certain parts of the resource after it has expired from its buffer. Similarly, some p389 p403 media resources might have a media timeline that doesn't start at zero. The earliest possible position is the earliest position in the stream or resource that the user agent can ever obtain again. It is also a time on the

media timeline p403.

Note

The p405 earliest possible position is not explicitly exposed in the API; it corresponds to the start time of the first range in the

seekable p417 p439 p404 attribute's TimeRanges object, if any, or the current playback position otherwise.

When the p405 p404 p405 earliest possible position changes, then: if the current playback position is before the earliest possible position , the

user agent must p416 p405 p441 seek to the earliest possible position ; otherwise, if the user agent has not fired a timeupdate event at the element in the past 15 to 250ms and is not still running event handlers for such an event, then the user agent must queue a media

element task p389 p388 p441 given the media element to fire an event named timeupdate at the element.

Note

Because of the above requirement and the requirement in the p397 resource fetch algorithm that kicks in when the metadata of the

clip becomes known p400 p404 p405 , the current playback position can never be less than the earliest possible position.

If at any time the user agent learns that an audio or video track has ended and all p389 media data relating to that track corresponds to parts of the p403 p405 p389 media timeline that are before the earliest possible position , the user agent may queue a media element task

given the p388 media element to run these steps:

1. Remove the track from the p418 p418 p418 audioTracks attribute's AudioTrackList object or the videoTracks attribute's

VideoTrackList p418 object as appropriate.

2. p441 p388 p418 p418 Fire an event named removetrack at the media element 's aforementioned AudioTrackList or VideoTrackList

object, using p439 p440 p418 p418 TrackEvent , with the track attribute initialized to the AudioTrack or VideoTrack object representing the track.

The p389 p403 duration attribute must return the time of the end of the media resource , in seconds, on the media timeline. If no media ✔ MDN

data p389 p389 is available, then the attributes must return the Not-a-Number (NaN) value. If the media resource is not known to be bounded (e.g. streaming radio, or a live event with no announced end time), then the attribute must return the positive Infinity value.

The user agent must determine the duration of the p389 p389 media resource before playing any part of the media data and before setting

readyState p408 p406 to a value equal to or greater than HAVE_METADATA , even if doing so requires fetching multiple parts of the resource.

When the length of the p389 media resource changes to a known value (e.g. from being unknown to known, or from a previously established length to a new length) the user agent must p389 p388 queue a media element task given the media element to fire an event

named p441 p388 durationchange at the media element. (The event is not fired when the duration is reset as part of loading a new media resource.) If the duration is changed such that the p404 current playback position ends up being greater than the time of the end of the

media resource p389 p416 p389 , then the user agent must also seek to the time of the end of the media resource .

Example

If an "infinite" stream ends for some reason, then the duration would change from positive Infinity to the time of the last frame or

sample in the stream, and the p441 durationchange event would be fired. Similarly, if the user agent initially estimated the media

resource p389's duration instead of determining it precisely, and later revises the estimate based on new information, then the

duration would change and the p441 durationchange event would be fired.

Some video files also have an explicit date and time corresponding to the zero time in the p403 media timeline, known as the timeline offset p405 . Initially, the timeline offset must be set to Not-a-Number (NaN).

405

The p53 p405 getStartDate() method must return a new Date object representing the current timeline offset .



The p67 p388 loop attribute is a boolean attribute that, if specified, indicates that the media element is to seek back to the start of the ✔ MDN

media resource p389 upon reaching the end.

The p95 loop IDL attribute must reflect the content attribute of the same name.



4.8.12.7 Ready states p40 §

6

For web developers (non-normative)

media p408 . readyState

Returns a value that expresses the current state of the element with respect to rendering the p404 current playback position , from the codes in the list below.

Media elements p388 have a ready state, which describes to what degree they are ready to be rendered at the current playback

position p404. The possible values are as follows; the ready state of a media element at any particular time is the greatest value describing the state of the element: HAVE_NOTHING (numeric value 0)

No information regarding the p389 p404 media resource is available. No data for the current playback position is available. Media

elements p388 p392 p392 p406 whose networkState attribute are set to NETWORK_EMPTY are always in the HAVE_NOTHING state.

HAVE_METADATA (numeric value 1)

Enough of the resource has been obtained that the duration of the resource is available. In the case of a p380 video element, the

dimensions of the video are also available. No p389 p404 media data is available for the immediate current playback position .

HAVE_CURRENT_DATA (numeric value 2)

Data for the immediate p404 current playback position is available, but either not enough data is available that the user agent could

successfully advance the p404 p413 current playback position in the direction of playback at all without immediately reverting to the

HAVE_METADATA p406 p413 state, or there is no more data to obtain in the direction of playback. For example, in video this corresponds

to the user agent having data from the current frame, but not the next frame, when the p404 current playback position is at the end

of the current frame; and to when p409 playback has ended .

HAVE_FUTURE_DATA (numeric value 3)

Data for the immediate p404 current playback position is available, as well as enough data for the user agent to advance the current

playback position p404 p413 p406 in the direction of playback at least a little without immediately reverting to the HAVE_METADATA state,

and p424 the text tracks are ready . For example, in video this corresponds to the user agent having data for at least the current frame

and the next frame when the p404 current playback position is at the instant in time between the two frames, or to the user agent

having the video data for the current frame and audio data to keep playing at least a little when the p404 current playback position is

in the middle of a frame. The user agent cannot be in this state if p409 p404 playback has ended , as the current playback position can

never advance in this case.

HAVE_ENOUGH_DATA (numeric value 4)

All the conditions described for the p406 HAVE_FUTURE_DATA state are met, and, in addition, either of the following conditions is also true:

• The user agent estimates that data is being fetched at a rate where the p404 current playback position , if it were to advance

at the element's p410 playbackRate, would not overtake the available data before playback reaches the end of the media

resource p389.

• The user agent has entered a state where waiting longer will not result in further data being obtained, and therefore

nothing would be gained by delaying playback any further. (For example, the buffer might be full.) Note

In practice, the difference between p406 p406 HAVE_METADATA and HAVE_CURRENT_DATA is negligible. Really the only time the difference

is relevant is when painting a p380 p635 video element onto a canvas, where it distinguishes the case where something will be drawn

( p406 p406 HAVE_CURRENT_DATA or greater) from the case where nothing is drawn ( HAVE_METADATA or less). Similarly, the difference

between p406 p406 HAVE_CURRENT_DATA (only the current frame) and HAVE_FUTURE_DATA (at least this frame and the next) can be 406

negligible (in the extreme, only one frame). The only time that distinction really matters is when a page provides an interface for

"frame-by-frame" navigation.

When the ready state of a p388 p392 p392 media element whose networkState is not NETWORK_EMPTY changes, the user agent must follow the steps given below:

1. Apply the first applicable set of substeps from the following list:

↪ p406 p406 If the previous ready state was HAVE_NOTHING , and the new ready state is HAVE_METADATA

Queue a media element task p389 p388 p440 given the media element to fire an event named loadedmetadata at the element.

Note

Before this task is run, as part of the p931 event loop mechanism, the rendering will have been updated to resize

the p380 video element if appropriate.



↪ p406 p406 If the previous ready state was HAVE_METADATA and the new ready state is HAVE_CURRENT_DATA or greater

If this is the first time this occurs for this p388 p393 media element since the load() algorithm was last invoked, the user

agent must p389 p388 p440 queue a media element task given the media element to fire an event named loadeddata at the element.

If the new ready state is p406 p406 HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then the relevant steps below must then be run also.

↪ p406 If the previous ready state was HAVE_FUTURE_DATA or more, and the new ready state is

HAVE_CURRENT_DATA p406 or less

If the p388 p409 p408 media element was potentially playing before its readyState attribute changed to a value lower than

HAVE_FUTURE_DATA p406 p409 p409 , and the element has not ended playback , and playback has not stopped due to errors,

paused for user interaction p410 p410 , or paused for in-band content , the user agent must queue a media element

task p389 p388 p441 given the media element to fire an event named timeupdate at the element, and queue a media

element task p389 p388 p441 given the media element to fire an event named waiting at the element.

↪ p406 If the previous ready state was HAVE_CURRENT_DATA or less, and the new ready state is

HAVE_FUTURE_DATA p406

The user agent must p389 p388 p440 queue a media element task given the media element to fire an event named canplay at the element.

If the element's p409 p411 paused attribute is false, the user agent must notify about playing for the element.

↪ p406 If the new ready state is HAVE_ENOUGH_DATA

If the previous ready state was p406 p389 HAVE_CURRENT_DATA or less, the user agent must queue a media element task

given the p388 p440 p409 media element to fire an event named canplay at the element, and, if the element's paused

attribute is false, p411 notify about playing for the element.

The user agent must p389 p388 queue a media element task given the media element to fire an event named

canplaythrough p440 at the element.

If the element is not p409 eligible for autoplay , then the user agent must abort these substeps.

The user agent may run the following substeps:

1. Set the p409 paused attribute to false.

2. If the element's p405 p414 show poster flag is true, set it to false and run the time marches on steps.

3. p389 p441 Queue a media element task given the element to fire an event named play at the element.

4. p411 Notify about playing for the element.

Alternatively, if the element is a p380 video element, the user agent may start observing whether the element

intersects the viewport p1188 p1188 . When the element starts intersecting the viewport, if the element is still eligible for

autoplay p409 p1188 , run the substeps above. Optionally, when the element stops intersecting the viewport, if the can

407

autoplay flag p393 p408 is still true and the autoplay attribute is still specified, run the following substeps:

1. Run the p412 p393 internal pause steps and set the can autoplay flag to true.

2. p389 p441 Queue a media element task given the element to fire an event named pause at the element.

Note

The substeps for playing and pausing can run multiple times as the element starts or stops intersecting the

viewport p1188 p393 , as long as the can autoplay flag is true.



Note

User agents do not need to support autoplay, and it is suggested that user agents honor user preferences on the

matter. Authors are urged to use the p408 autoplay attribute rather than using script to force the video to play, so as to allow the user to override the behavior if so desired.



Note

It is possible for the ready state of a media element to jump between these states discontinuously. For example, the state of a

media element can jump straight from p406 p406 HAVE_METADATA to HAVE_ENOUGH_DATA without passing through the

HAVE_CURRENT_DATA p406 p406 ✔ MDN and HAVE_FUTURE_DATA states.

The readyState IDL attribute must, on getting, return the value described above that describes the current ready state of the media

element p388.

The p67 autoplay attribute is a boolean attribute. When present, the user agent (as described in the algorithm described herein) will automatically begin playback of the p389 media resource as soon as it can do so without stopping.

Note

Authors are urged to use the p408 autoplay attribute rather than using script to trigger automatic playback, as this allows the user

to override the automatic playback when it is not desired, e.g. when using a screen reader. Authors are also encouraged to

consider not using the automatic playback behavior at all, and instead to let the user agent wait for the user to start playback

explicitly. ✔ MDN



The p95 autoplay IDL attribute must reflect the content attribute of the same name.



4.8.12.8 Playing the media resource p40 §

8

For web developers (non-normative)

media p409 . paused

Returns true if playback is paused; false otherwise.

media p409 . ended

Returns true if playback has reached the end of the p389 media resource.

media p410 . defaultPlaybackRate [ = value ]

Returns the default rate of playback, for when the user is not fast-forwarding or reversing through the p389 media resource. Can be set, to change the default rate of playback.

The default rate has no direct effect on playback, but if the user switches to a fast-forward mode, when they return to the normal playback mode, it is expected that the rate of playback will be returned to the default rate of playback.

media p410 . playbackRate [ = value ]

Returns the current rate playback, where 1.0 is normal speed.

Can be set, to change the rate of playback.

media p411 . preservesPitch

Returns true if pitch-preserving algorithms are used when the p410 playbackRate is not 1.0. The default value is true.

Can be set to false to have the p389 p410 media resource 's audio pitch change up or down depending on the playbackRate. This is useful for aesthetic and performance reasons.

408

media p411 . played

Returns a p439 p389 TimeRanges object that represents the ranges of the media resource that the user agent has played.

media p411 . play ()

Sets the p409 p389 paused attribute to false, loading the media resource and beginning playback if necessary. If the playback had ended, will restart it from the start.

media p412 . pause()

Sets the p409 p389 paused attribute to true, loading the media resource if necessary.



The p388 paused attribute represents whether the media element is paused or not. The attribute must initially be true. ✔ MDN

A p388 p408 p406 media element is a blocked media element if its readyState attribute is in the HAVE_NOTHING state, the

HAVE_METADATA p406 p406 p410 state, or the HAVE_CURRENT_DATA state, or if the element has paused for user interaction or paused for in-

band content p410.

A p388 p409 p409 media element is said to be potentially playing when its paused attribute is false, the element has not ended playback, playback has not p409 p409 stopped due to errors , and the element is not a blocked media element .

Note

A p441 p407 p409 waiting DOM event can be fired as a result of an element that is potentially playing stopping playback due to its

readyState p408 p406 attribute changing to a value lower than HAVE_FUTURE_DATA.

A p388 media element is said to be eligible for autoplay when all of the following conditions are met:

• Its p393 can autoplay flag is true.

• Its p409 paused attribute is true.

• It has an p408 autoplay attribute specified.

• Its p848 p846 node document 's active sandboxing flag set does not have the sandboxed automatic features browsing context flag

set.

• Its p368 p67 node document is allowed to use the " autoplay" feature.

A p388 media element is said to be allowed to play if the user agent and the system allow media playback in the current context.

Example

For example, a user agent could allow playback only when the p388 p828 p770 media element 's Window object has transient activation,

but an exception could be made to allow playback while p438 muted.

A p388 media element is said to have ended playback when:

• The element's p408 p406 readyState attribute is HAVE_METADATA or greater, and

• Either:

◦ The p404 p389 current playback position is the end of the media resource , and

◦ The p413 direction of playback is forwards, and

◦ The p388 p406 media element does not have a loop attribute specified.

Or:

◦ The p404 p405 current playback position is the earliest possible position, and

◦ The p413 direction of playback is backwards.

The p931 p934 p388 ended attribute must return true if, the last time the event loop reached step 1 , the media element had ended ✔ MDN

playback p409 p413 and the direction of playback was forwards, and false otherwise.

A p388 p408 p406 media element is said to have stopped due to errors when the element's readyState attribute is HAVE_METADATA or greater, and the user agent p402 p389 encounters a non-fatal error during the processing of the media data , and due to that error, is not able to play the content at the p404 current playback position.



409

A p388 p409 p408 media element is said to have paused for user interaction when its paused attribute is false, the readyState attribute is either p406 p406 p389 HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has reached a point in the media resource where the user has to make a selection for the resource to continue.

It is possible for a p388 p409 p410 media element to have both ended playback and paused for user interaction at the same time.

When a p388 p409 p410 media element that is potentially playing stops playing because it has paused for user interaction , the user agent

must p389 p388 p441 queue a media element task given the media element to fire an event named timeupdate at the element.

A p388 p409 p408 media element is said to have paused for in-band content when its paused attribute is false, the readyState attribute is either p406 p406 p389 HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA and the user agent has suspended playback of the media resource in order to play content that is temporally anchored to the p389 media resource and has a nonzero length, or to play content that is temporally anchored to a segment of the p389 media resource but has a length longer than that segment.

Example

One example of when a p388 p410 media element would be paused for in-band content is when the user agent is playing audio

descriptions p386 from an external WebVTT file, and the synthesized speech generated for a cue is longer than the time between the

text track cue start time p424 p424 and the text track cue end time .



When the p404 p389 p413 current playback position reaches the end of the media resource when the direction of playback is forwards, then the user agent must follow these steps:

1. If the p388 p406 p416 p405 media element has a loop attribute specified, then seek to the earliest possible position of the media

resource p389 and return.

2. As defined above, the p409 p931 p934 ended IDL attribute starts returning true once the event loop returns to step 1.

3. p389 p388 Queue a media element task given the media element and the following steps:

1. p441 p388 Fire an event named timeupdate at the media element .

2. If the p388 p409 p413 p409 media element has ended playback , the direction of playback is forwards, and paused is false,

then:

1. Set the p409 paused attribute to true.

2. p441 p388 Fire an event named pause at the media element.

3. p411 p411 Take pending play promises and reject pending play promises with the result and an "AbortError"

DOMException.

3. p441 p388 Fire an event named ended at the media element.

When the p404 p405 p389 current playback position reaches the earliest possible position of the media resource when the direction of

playback p413 p389 p388 is backwards, then the user agent must only queue a media element task given the media element to fire an event

named p441 timeupdate at the element.

Note

The word "reaches" here does not imply that the p404 current playback position needs to have changed during normal playback; it

could be via p416 seeking , for instance.



The p389 defaultPlaybackRate attribute gives the desired speed at which the media resource is to play, as a multiple of its intrinsic ✔ MDN speed. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting the attribute must be set to the new value.

Note

The p410 p437 ✔ MDN defaultPlaybackRate is used by the user agent when it exposes a user interface to the user .

The p389 playbackRate attribute gives the effective playback rate, which is the speed at which the media resource plays, as a multiple of its intrinsic speed. If it is not equal to the p410 defaultPlaybackRate, then the implication is that the user is using a feature such as fast forward or slow motion playback. The attribute is mutable: on getting it must return the last value it was set to, or 1.0 if it hasn't

410

yet been set; on setting, the user agent must follow these steps:

1. If the given value is not supported by the user agent, then throw a "NotSupportedError" DOMException.

2. Set p410 p409 playbackRate to the new value, and if the element is potentially playing, change the playback speed.

When the p410 p410 defaultPlaybackRate or playbackRate attributes change value (either by being set by script or by being changed directly by the user agent, e.g. in response to user control) the user agent must p389 queue a media element task given the media

element p388 p441 p388 to fire an event named ratechange at the media element. The user agent must process attribute changes smoothly and must not introduce any perceivable gaps or muting of playback in response.

The preservesPitch getter steps are to return true if a pitch-preserving algorithm is in effect during playback. The setter steps are to correspondingly switch the pitch-preserving algorithm on or off, without any perceivable gaps or muting of playback. By default, such a pitch-preserving algorithm must be in effect (i.e., the getter will initially return true).



The p439 played attribute must return a new static normalized TimeRanges object that represents the ranges of points on the media

timeline p403 p389 p404 of the media resource reached through the usual monotonic increase of the current playback position during normal playback, if any, at the time the attribute is evaluated.

⚠Warning!

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be

costly to change it. It is not to be copied to new APIs.



Each p388 media element has a list of pending play promises, which must initially be empty.

To p388 take pending play promises for a media element, the user agent must run the following steps:

1. Let promises be an empty list of promises.

2. Copy the p388 p411 media element 's list of pending play promises to promises.

3. Clear the p388 p411 media element 's list of pending play promises .

4. Return promises.

To p388 resolve pending play promises for a media element with a list of promises promises, the user agent must resolve each promise in promises with undefined.

To p388 reject pending play promises for a media element with a list of promise promises and an exception name error, the user agent must reject each promise in promises with error.

To p388 notify about playing for a media element , the user agent must run the following steps:

1. p411 Take pending play promises and let promises be the result.

2. p389 Queue a media element task given the element and the following steps:

1. p440 Fire an event named playing at the element.

2. p411 Resolve pending play promises with promises.

When the p388 play() method on a media element is invoked, the user agent must run the following steps. ✔ MDN

1. If the p388 p409 media element is not allowed to play , return a promise rejected with a "NotAllowedError" DOMException.

2. If the p388 p390 p390 p390 media element 's error attribute is not null and its code is MEDIA_ERR_SRC_NOT_SUPPORTED, return a

promise rejected with a "NotSupportedError" DOMException.

Note

This means that the p396 dedicated media source failure steps have run. Playback is not possible until the media element

load algorithm p393 p390 clears the error attribute.

3. Let p411 promise be a new promise and append promise to the list of pending play promises.

411

4. Run the p412 p388 internal play steps for the media element.

5. Return promise.

The p388 internal play steps for a media element are as follows:

1. If the p388 p392 p392 p388 media element 's networkState attribute has the value NETWORK_EMPTY , invoke the media element 's

resource selection algorithm p394 .

2. If the p409 p413 p416 p405 playback has ended and the direction of playback is forwards, seek to the earliest possible position of the

media resource p389 .

Note

This p417 p389 p388 will cause the user agent to queue a media element task given the media element to fire an event named

timeupdate p441 p388 at the media element.

3. If the p388 p409 media element 's paused attribute is true, then:

1. Change the value of p409 paused to false.

2. If the p405 p405 p414 show poster flag is true, set the element's show poster flag to false and run the time marches on

steps.

3. p389 p388 p441 Queue a media element task given the media element to fire an event named play at the element.

4. If the p388 p408 p406 p406 media element 's readyState attribute has the value HAVE_NOTHING , HAVE_METADATA , or

HAVE_CURRENT_DATA p406 p389 p388 , queue a media element task given the media element to fire an event named

waiting p441 at the element.

Otherwise, the p388 p408 p406 media element 's readyState attribute has the value HAVE_FUTURE_DATA or

HAVE_ENOUGH_DATA p406 p411 : notify about playing for the element.

4. Otherwise, if the p388 p408 p406 media element 's readyState attribute has the value HAVE_FUTURE_DATA or

HAVE_ENOUGH_DATA p406 p411 p389 p388 , take pending play promises and queue a media element task given the media element to

resolve pending play promises p411 with the result.

Note

The media element is already playing. However, it's possible that p411 promise will be rejected before the queued task is run.

5. Set the p388 p393 media element 's can autoplay flag to false.



When the p388 pause() method is invoked, and when the user agent is required to pause the media element, the user agent must run ✔ MDN the following steps:

1. If the p388 p392 p392 p388 media element 's networkState attribute has the value NETWORK_EMPTY , invoke the media element 's

resource selection algorithm p394 .

2. Run the p412 p388 internal pause steps for the media element .

The p388 internal pause steps for a media element are as follows:

1. Set the p388 p393 media element 's can autoplay flag to false.

2. If the p388 p409 media element 's paused attribute is false, run the following steps:

1. Change the value of p409 paused to true.

2. p411 Take pending play promises and let promises be the result.

3. p389 p388 Queue a media element task given the media element and the following steps:

1. p441 Fire an event named timeupdate at the element.

2. p441 Fire an event named pause at the element.

412

3. p411 Reject pending play promises with promises and an "AbortError" DOMException.

4. Set the p404 p404 official playback position to the current playback position.



If the element's p410 playbackRate is positive or zero, then the direction of playback is forwards. Otherwise, it is backwards.

When a p388 p409 p115 p818 p115 media element is potentially playing and its Document is a fully active Document, its current playback

position p404 p410 must increase monotonically at the element's playbackRate units of media time per unit time of the media

timeline p403's clock. (This specification always refers to this as an increase, but that increase could actually be a decrease if the element's p410 playbackRate is negative.) Note

The element's p410 p404 playbackRate can be 0.0, in which case the current playback position doesn't move, despite playback not

being paused ( p409 p441 paused doesn't become true, and the pause event doesn't fire).



Note

This specification doesn't define how the user agent achieves the appropriate playback rate — depending on the protocol and

media available, it is plausible that the user agent could negotiate with the server to have the server provide the media data at the

appropriate rate, so that (except for the period between when the rate is changed and when the server updates the stream's

playback rate) the client doesn't actually have to drop or interpolate any frames.

Any time the user agent p936 p404 p404 provides a stable state , the official playback position must be set to the current playback position .

While the p413 p438 p410 direction of playback is backwards, any corresponding audio must be muted . While the element's playbackRate is so low or so high that the user agent cannot play audio usefully, the corresponding audio must also be p438 muted . If the element's

playbackRate p410 p411 is not 1.0 and preservesPitch is true, the user agent must apply pitch adjustment to preserve the original pitch of the audio. Otherwise, the user agent must speed up or slow down the audio without any pitch adjustment.

When a p388 p409 p404 media element is potentially playing , its audio data played must be synchronized with the current playback position, at the element's p438 effective media volume. The user agent must play the audio from audio tracks that were enabled when the event

loop p931 p934 last reached step 1 .

When a p388 p409 media element is not potentially playing, audio must not play for the element.

Media elements p388 p409 that are potentially playing while not in a document must not play any video, but should play any audio component. Media elements must not stop playing just because all references to them have been removed; only once a media element is in a state where no further audio could ever be played by that element may the element be garbage collected.

Note

It is possible for an element to which no explicit references exist to play audio, even if such an element is not still actively playing:

for instance, it could be unpaused but stalled waiting for content to buffer, or it could be still buffering, but with a p440 suspend

event listener that begins playback. Even a media element whose p389 media resource has no audio tracks could eventually play

audio again if it had an event listener that changes the p389 media resource.



Each p388 p424 media element has a list of newly introduced cues , which must be initially empty. Whenever a text track cue is added to the p423 p422 p422 p388 p424 list of cues of a text track that is in the list of text tracks for a media element , that cue must be added to the

media element p388 p413 p422 p422 's list of newly introduced cues . Whenever a text track is added to the list of text tracks for a media

element p388 p424 p422 p423 p388 , all of the cues in that text track 's list of cues must be added to the media element's list of newly introduced

cues p413 p388 p413 p388 . When a media element 's list of newly introduced cues has new cues added while the media element 's show poster

flag p405 p414 is not set, then the user agent must run the time marches on steps.

When a p424 p423 p422 p422 text track cue is removed from the list of cues of a text track that is in the list of text tracks for a media

element p388 p422 p422 p388 p388 , and whenever a text track is removed from the list of text tracks of a media element , if the media element's

show poster flag p405 p414 is not set, then the user agent must run the time marches on steps.

When the p404 p388 current playback position of a media element changes (e.g. due to playback or seeking), the user agent must run the

time marches on p414 steps. To support use cases that depend on the timing accuracy of cue event firing, such as synchronizing captions with shot changes in a video, user agents should fire cue events as close as possible to their position on the media timeline, and ideally within 20 milliseconds. If the p404 current playback position changes while the steps are running, then the user agent must

413

wait for the steps to complete, and then must immediately rerun the steps. These steps are thus run as often as possible or needed.

Note

If one iteration takes a long time, this can cause short duration p424 cues to be skipped over as the user agent rushes ahead to

"catch up", so these cues will not appear in the p432 activeCues list.

The time marches on steps are as follows:

1. Let p424 p424 p423 p423 p422 current cues be a list of cues , initialized to contain all the cues of all the hidden or showing text tracks of

the p388 p423 p424 media element (not the disabled ones) whose start times are less than or equal to the current playback

position p404 p424 p404 and whose end times are greater than the current playback position.

2. Let p424 p424 p423 p423 p422 other cues be a list of cues , initialized to contain all the cues of hidden and showing text tracks of the

media element p388 that are not present in current cues.

3. Let p404 p388 last time be the current playback position at the time this algorithm was last run for this media element, if this is

not the first time it has run.

4. If the p404 current playback position has, since the last time this algorithm was run, only changed through its usual monotonic

increase during normal playback, then let p424 p424 missed cues be the list of cues in other cues whose start times are greater

than or equal to p424 p404 last time and whose end times are less than or equal to the current playback position. Otherwise, let missed cues be an empty list.

5. Remove all the p424 p388 p413 cues in missed cues that are also in the media element 's list of newly introduced cues, and then

empty the element's p413 list of newly introduced cues.

6. If the time was reached through the usual monotonic increase of the p404 current playback position during normal playback,

and if the user agent has not fired a p441 timeupdate event at the element in the past 15 to 250ms and is not still running

event handlers for such an event, then the user agent must p389 p388 queue a media element task given the media element to

fire an event p441 named timeupdate at the element. (In the other cases, such as explicit seeks, relevant events get fired as

part of the overall process of changing the p404 current playback position .)

Note

The event thus is not to be fired faster than about 66Hz or slower than 4Hz (assuming the event handlers don't take longer than 250ms to run). User agents are encouraged to vary the frequency of the event based on the system load and the average cost of processing the event each time, so that the UI updates are not any more frequent than the user agent can comfortably handle while decoding the video.

7. If all of the p424 p425 p424 cues in current cues have their text track cue active flag set, none of the cues in other cues have their

text track cue active flag p425 set, and missed cues is empty, then return.

8. If the time was reached through the usual monotonic increase of the p404 current playback position during normal playback,

and there are p424 p424 cues in other cues that have their text track cue pause-on-exit flag set and that either have their text

track cue active flag p425 p42 p412 p388 set or are also in missed cues , then immediately pause the media element.

Note

In the other cases, such as explicit seeks, playback is not paused by going past the end time of a p424 cue, even if that

cue p424 p424 has its text track cue pause-on-exit flag set.

9. Let p932 p932 p422 events be a list of tasks , initially empty. Each task in this list will be associated with a text track , a text track

cue p424 p932 , and a time, which are used to sort the list before the tasks are queued.

Let p422 affected tracks be a list of text tracks, initially empty.

When the steps below say to p424 prepare an event named event for a text track cue target with a time time, the user agent must run these steps:

1. Let p422 p424 track be the text track with which the text track cue target is associated.

2. Create a p932 task to fire an event named event at target.

3. Add the newly created p932 p422 task to events , associated with the time time , the text track track, and the text track

cue p424 target.

4. Add track to affected tracks.

414

10. For each p424 p414 p442 p434 text track cue in missed cues , prepare an event named enter for the TextTrackCue object with the

text track cue start time p424 .

11. For each p424 p425 text track cue in other cues that either has its text track cue active flag set or is in missed cues, prepare an

event p414 p442 p434 p424 named exit for the TextTrackCue object with the later of the text track cue end time and the text track

cue start time p424 .

12. For each p424 p425 p414 text track cue in current cues that does not have its text track cue active flag set, prepare an event

named p442 p434 p424 enter for the TextTrackCue object with the text track cue start time.

13. Sort the p932 p932 tasks in events in ascending time order ( tasks with earlier times first).

Further sort p932 p425 p424 tasks in events that have the same time by the relative text track cue order of the text track cues

associated with these p932 tasks.

Finally, sort p932 p425 p932 tasks in events that have the same time and same text track cue order by placing tasks that fire

enter p442 p442 events before those that fire exit events.

14. p389 p388 p932 Queue a media element task given the media element for each task in events, in list order.

15. Sort p422 p388 p422 affected tracks in the same order as the text tracks appear in the media element 's list of text tracks, and

remove duplicates.

16. For each p422 p389 p388 text track in affected tracks , in the list order, queue a media element task given the media element to fire

an event p441 p430 p422 p385 named cuechange at the TextTrack object, and, if the text track has a corresponding track element,

to then p441 p385 fire an event named cuechange at the track element as well.

17. Set the p425 p424 p425 text track cue active flag of all the cues in the current cues , and unset the text track cue active flag of all

the p424 cues in the other cues.

18. Run the p423 p422 p423 rules for updating the text track rendering of each of the text tracks in affected tracks that are showing,

providing the p422 p423 text track 's text track language as the fallback language if it is not the empty string. For example, for

text tracks p422 p1282 based on WebVTT, the rules for updating the display of WebVTT text tracks . [WEBVTT]

For the purposes of the algorithm above, a p424 p422 text track cue is considered to be part of a text track only if it is listed in the text

track list of cues p423 p422 , not merely if it is associated with the text track.

Note

If the p388 p818 p413 media element 's node document stops being a fully active document, then the playback will stop until the

document is active again.

When a p388 p44 media element is removed from a Document, the user agent must run the following steps:

1. p936 p932 p388 p115 Await a stable state , allowing the task that removed the media element from the Document to continue. The

synchronous section p937 p937 consists of all the remaining steps of this algorithm. (Steps in the synchronous section are marked with ⌛.)

2. p388 ⌛ If the media element is in a document, return.

3. p412 p388 ⌛ Run the internal pause steps for the media element.



4.8.12.9 Seeking p41 §

5

For web developers (non-normative)

media p416 . seeking

Returns true if the user agent is currently seeking.

media p417 . seekable

Returns a p439 p389 TimeRanges object that represents the ranges of the media resource to which it is possible for the user agent to seek.

media p416 . fastSeek ( time )

Seeks to near the given p405 time as fast as possible, trading precision for speed. (To seek to a precise time, use the currentTime

415

attribute.)

This does nothing if the media resource has not been loaded.

MDN

The seeking attribute must initially have the value false.

The p416 fastSeek() method must seek to the time given by the method's argument, with the approximate-for-speed flag set.

When the user agent is required to p389 seek to a particular new playback position in the media resource, optionally with the approximate-for-speed flag set, it means that the user agent must run the following steps. This algorithm interacts closely with the

event loop p931 p937 p931 mechanism; in particular, it has a synchronous section (which is triggered as part of the event loop algorithm). Steps in that section are marked with ⌛.

1. Set the p388 p405 media element 's show poster flag to false.

2. If the p388 p408 p406 media element 's readyState is HAVE_NOTHING , return.

3. If the element's p416 seeking IDL attribute is true, then another instance of this algorithm is already running. Abort that other

instance of the algorithm without waiting for the step that it is running to complete.

4. Set the p416 seeking IDL attribute to true.

5. If the seek was in response to a DOM method call or setting of an IDL attribute, then continue the script. The remainder of

these steps must be run p42 in parallel. With the exception of the steps marked with ⌛, they could be aborted at any time by another instance of this algorithm being invoked.

6. If the p389 p389 new playback position is later than the end of the media resource , then let it be the end of the media resource

instead.

7. If the p405 new playback position is less than the earliest possible position, let it be that position instead.

8. If the (possibly now changed) p417 new playback position is not in one of the ranges given in the seekable attribute, then let it

be the position in one of the ranges given in the p417 seekable attribute that is the nearest to the new playback position. If two positions both satisfy that constraint (i.e. the new playback position is exactly in the middle between two ranges in the

seekable p417 p404 attribute) then use the position that is closest to the current playback position. If there are no ranges given

in the p417 p416 seekable attribute then set the seeking IDL attribute to false and return.

9. If the approximate-for-speed flag is set, adjust the new playback position to a value that will allow for playback to resume

promptly. If p404 new playback position before this step is before current playback position , then the adjusted new playback

position p404 must also be before the current playback position. Similarly, if the new playback position before this step is after

current playback position p404 p404 , then the adjusted new playback position must also be after the current playback position.

Example

For example, the user agent could snap to a nearby key frame, so that it doesn't have to spend time decoding then discarding intermediate frames before resuming playback.

10. p389 p388 p441 Queue a media element task given the media element to fire an event named seeking at the element.

11. Set the p404 current playback position to the new playback position.

Note

If the p388 p409 media element was potentially playing immediately before it started seeking, but seeking caused its

readyState p408 p406 p441 attribute to change to a value lower than HAVE_FUTURE_DATA , then a waiting event will be

fired p407 at the element.

Note

This step sets the p404 current playback position, and thus can immediately trigger other conditions, such as the rules

regarding when playback " p410 reaches the end of the media resource" (part of the logic that handles looping), even before the user agent is actually able to render the media data for that position (as determined in the next step).

Note

The p405 p404 p404 currentTime attribute returns the official playback position , not the current playback position, and therefore gets updated before script execution, separate from this algorithm.

416

12. Wait until the user agent has established whether or not the p389 media data for the new playback position is available, and, if

it is, until it has decoded enough data to play back that position.

13. p936 p937 Await a stable state . The synchronous section consists of all the remaining steps of this algorithm. (Steps in the

synchronous section p937 are marked with ⌛.)

14. p416 ⌛ Set the seeking IDL attribute to false.

15. p414 ⌛ Run the time marches on steps.

16. p389 p388 p441 ⌛ Queue a media element task given the media element to fire an event named timeupdate at the element.

17. p389 p388 p441 ⌛ Queue a media element task given the media element to fire an event named seeked at the element.



The p439 seekable attribute must return a new static normalized TimeRanges object that represents the ranges of the media ✔ MDN

resource p389, if any, that the user agent is able to seek to, at the time the attribute is evaluated.

Note

If the user agent can seek to anywhere in the p389 media resource, e.g. because it is a simple movie file and the user agent and the

server support HTTP Range requests, then the attribute would return an object with one range, whose start is the time of the first

frame (the p405 earliest possible position, typically zero), and whose end is the same as the time of the first frame plus the

duration p405 attribute's value (which would equal the time of the last frame, and might be positive Infinity).



Note

The range might be continuously changing, e.g. if the user agent is buffering a sliding window on an infinite stream. This is the

behavior seen with DVRs viewing live TV, for instance.



⚠Warning!

Returning a new object each time is a bad pattern for attribute getters and is only enshrined here as it would be

costly to change it. It is not to be copied to new APIs.

User agents should adopt a very liberal and optimistic view of what is seekable. User agents should also buffer recent content where possible to enable seeking to be fast.

Example

For instance, consider a large video file served on an HTTP server without support for HTTP Range requests. A browser could

implement this by only buffering the current frame and data obtained for subsequent frames, never allow seeking, except for

seeking to the very start by restarting the playback. However, this would be a poor implementation. A high quality implementation

would buffer the last few minutes of content (or more, if sufficient storage space is available), allowing the user to jump back and

rewatch something surprising without any latency, and would in addition allow arbitrary seeking by reloading the file from the start

if necessary, which would be slower but still more convenient than having to literally restart the video and watch it all the way

through just to get to an earlier unbuffered spot.

Media resources p389 p388 might be internally scripted or interactive. Thus, a media element could play in a non-linear fashion. If this happens, the user agent must act as if the algorithm for p416 p404 seeking was used whenever the current playback position changes in a discontinuous fashion (so that the relevant events fire).



4.8.12.10 Media resources with multiple media tracks p41 §

7

A p389 media resource can have multiple embedded audio and video tracks. For example, in addition to the primary video and audio tracks, a p389 media resource could have foreign-language dubbed dialogues, director's commentaries, audio descriptions, alternative angles, or sign-language overlays.

For web developers (non-normative)

media p418 . audioTracks

Returns an p418 p389 AudioTrackList object representing the audio tracks available in the media resource.



417

media p418 . videoTracks

Returns a p418 p389 VideoTrackList object representing the video tracks available in the media resource .



The p388 p45 p418 audioTracks attribute of a media element must return a live AudioTrackList object representing the audio tracks ✔ ✔ MDN MDN

available in the p388 p389 media element 's media resource.

The p388 p45 p418 videoTracks attribute of a media element must return a live VideoTrackList object representing the video tracks available in the p388 p389 media element 's media resource.

Note

There are only ever one p418 p418 p388 AudioTrackList object and one VideoTrackList object per media element , even if another

media resource p389 p418 p418 is loaded into the element: the objects are reused. (The AudioTrack and VideoTrack objects are not,

though.)



4.8.12.10.1 p418 ✔ MDN p418 p41 AudioTrackList and VideoTrackList objects §

8 ✔ MDN

The p418 p418 AudioTrackList and VideoTrackList interfaces are used by attributes defined in the previous section.

IDL [Exposed=Window]

interface AudioTrackList : EventTarget {

readonly attribute unsigned long length;

getter AudioTrack (unsigned long index);

AudioTrack? getTrackById(DOMString id);

attribute EventHandler onchange;

attribute EventHandler onaddtrack;

attribute EventHandler onremovetrack;

};

[Exposed=Window]

interface AudioTrack {

readonly attribute DOMString id;

readonly attribute DOMString kind;

readonly attribute DOMString label;

readonly attribute DOMString language;

attribute boolean enabled;

};

[Exposed=Window]

interface VideoTrackList : EventTarget {

readonly attribute unsigned long length;

getter VideoTrack (unsigned long index);

VideoTrack? getTrackById(DOMString id);

readonly attribute long selectedIndex;

attribute EventHandler onchange;

attribute EventHandler onaddtrack;

attribute EventHandler onremovetrack;

};

[Exposed=Window]

interface VideoTrack {

readonly attribute DOMString id;

readonly attribute DOMString kind;

readonly attribute DOMString label;

readonly attribute DOMString language;

attribute boolean selected;

418

};



For web developers (non-normative)

media p418 p419 . audioTracks . length

media p418 p419 . videoTracks . length

Returns the number of tracks in the list.

audioTrack p418 = media . audioTracks[index]

videoTrack p418 = media . videoTracks [index]

Returns the specified p418 p418 AudioTrack or VideoTrack object.

audioTrack p418 p420 = media . audioTracks . getTrackById( id )

videoTrack p418 p420 = media . videoTracks . getTrackById ( id )

Returns the p418 p418 AudioTrack or VideoTrack object with the given identifier, or null if no track has that identifier.

audioTrack p420 . id

videoTrack p420 . id

Returns the ID of the given track. This is the ID that can be used with a fragment if the format supports media fragment syntax, and that can be used with the getTrackById() method.

audioTrack p420 . kind

videoTrack p420 . kind

Returns the category the given track falls into. The p420 possible track categories are given below.

audioTrack p421 . label

videoTrack p421 . label

Returns the label of the given track, if known, or the empty string otherwise.

audioTrack p421 . language

videoTrack p421 . language

Returns the language of the given track, if known, or the empty string otherwise.

audioTrack p421 . enabled [ = value ]

Returns true if the given track is active, and false otherwise.

Can be set, to change whether the track is enabled or not. If multiple audio tracks are enabled simultaneously, they are mixed.

media p418 p421 . videoTracks . selectedIndex

Returns the index of the currently selected track, if any, or −1 otherwise.

videoTrack p421 . selected [ = value ]

Returns true if the given track is active, and false otherwise.

Can be set, to change whether the track is selected or not. Either zero or one video track is selected; selecting a new track while a previous one is selected will unselect the previous one.

An p418 AudioTrackList object represents a dynamic list of zero or more audio tracks, of which zero or more can be enabled at a time.

Each audio track is represented by an p418 AudioTrack object.

A p418 VideoTrackList object represents a dynamic list of zero or more video tracks, of which zero or one can be selected at a time.

Each video track is represented by a p418 VideoTrack object.

Tracks in p418 p418 p389 AudioTrackList and VideoTrackList objects must be consistently ordered. If the media resource is in a format that defines an order, then that order must be used; otherwise, the order must be the relative order in which the tracks are declared in the p389 media resource. The order used is called the natural order of the list.

Note

Each track in one of these objects thus has an index; the first has the index 0, and each subsequent track is numbered one higher

than the previous one. If a p389 media resource dynamically adds or removes audio or video tracks, then the indices of the tracks

will change dynamically. If the p389 media resource changes entirely, then all the previous tracks will be removed and replaced with

new tracks. ✔ MDN



The p418 p418 AudioTrackList length and VideoTrackList length attribute getters must return the number of tracks represented by

419

their objects at the time of getting.

The p418 p418 supported property indices of AudioTrackList and VideoTrackList objects at any instant are the numbers from zero to the number of tracks represented by the respective object minus one, if any tracks are represented. If an p418 AudioTrackList or

VideoTrackList p418 object represents no tracks, it has no supported property indices.

To p418 p418 determine the value of an indexed property for a given index index in an AudioTrackList or VideoTrackList object list, the ✔ MDN

user agent must return the p418 p418 AudioTrack or VideoTrack object that represents the indexth track in list.

The p418 p418 p418 AudioTrackList getTrackById( id ) and VideoTrackList getTrackById( id ) methods must return the first AudioTrack

or p418 p418 p418 VideoTrack object (respectively) in the AudioTrackList or VideoTrackList object (respectively) whose identifier is equal to the value of the id argument (in the natural order of the list, as defined above). When no tracks match the given argument, the methods must return null.

The p418 p418 p389 AudioTrack and VideoTrack objects represent specific tracks of a media resource. Each track can have an identifier, category, label, and language. These aspects of a track are permanent for the lifetime of the track; even if a track is removed from a

media resource p389 p418 p418 's AudioTrackList or VideoTrackList objects, those aspects do not change.

In addition, p418 p418 AudioTrack objects can each be enabled or disabled; this is the audio track's enabled state . When an AudioTrack is

created, its p397 enabled state must be set to false (disabled). The resource fetch algorithm can override this.

Similarly, a single p418 p418 VideoTrack object per VideoTrackList object can be selected, this is the video track's selection state. When ✔ MDN

a p418 p397 VideoTrack is created, its selection state must be set to false (not selected). The resource fetch algorithm can override this.

The p418 p418 AudioTrack id and VideoTrack id attributes must return the identifier of the track, if it has one, or the empty string otherwise. If the p389 media resource is in a format that supports media fragment syntax, the identifier returned for a particular track must be the same identifier that would enable the track if used as the name of a track in the track dimension of such a fragment.

[INBAND] p1278

Example

For example, in Ogg files, this would be the Name header field of the track. p1279 ✔ MDN [OGGSKELETONHEADERS]

The p418 p418 AudioTrack kind and VideoTrack kind attributes must return the category of the track, if it has one, or the empty string otherwise.

The category of a track is the string given in the first column of the table below that is the most appropriate for the track based on the definitions in the table's second and third columns, as determined by the metadata included in the track in the p389 media resource. The cell in the third column of a row says what the category given in the cell in the first column of that row applies to; a category is only appropriate for an audio track if it applies to audio tracks, and a category is only appropriate for video tracks if it applies to video tracks. Categories must only be returned for p418 AudioTrack objects if they are appropriate for audio, and must only be returned for

VideoTrack p418 objects if they are appropriate for video.

For Ogg files, the Role header field of the track gives the relevant metadata. For DASH media resources, the Role element conveys the information. For WebM, only the FlagDefault element currently maps to a value. Sourcing In-band Media Resource Tracks from Media Containers into HTML p1279 p1277 p1282 p1278 has further details. [OGGSKELETONHEADERS] [DASH] [WEBMCG] [INBAND]

Return values for p418 p420 p418 p420 AudioTrack 's kind and VideoTrack 's kind

Category Definition Applies Examples

to...

"alternative" A possible alternative to the main track, e.g. a Audio Ogg: "audio/alternate" or "video/alternate"; DASH: "alternate" without "main"

different take of a song (audio), or a different angle and and "commentary" roles, and, for audio, without the "dub" role (other roles (video). video. ignored).

"captions" A version of the main video track with captions burnt Video DASH: "caption" and "main" roles together (other roles ignored).

in. (For legacy content; new content would use text only.

tracks.)

"descriptions" An audio description of a video track. Audio Ogg: "audio/audiodesc".

only.

"main" The primary audio or video track. Audio Ogg: "audio/main" or "video/main"; WebM: the "FlagDefault" element is set;

and DASH: "main" role without "caption", "subtitle", and "dub" roles (other roles

video. ignored).

"main-desc" The primary audio track, mixed with audio Audio AC3 audio in MPEG-2 TS: bsmod=2 and full_svc=1.

descriptions. only.

"sign" A sign-language interpretation of an audio track. Video Ogg: "video/sign".

only.

420

Category Definition Applies Examples

to...

"subtitles" A version of the main video track with subtitles burnt Video DASH: "subtitle" and "main" roles together (other roles ignored).

in. (For legacy content; new content would use text only.

tracks.)

"translation" A translated version of the main audio track. Audio Ogg: "audio/dub". DASH: "dub" and "main" roles together (other roles

only. ignored).

"commentary" Commentary on the primary audio or video track, e.g. Audio DASH: "commentary" role without "main" role (other roles ignored).

a director's commentary. and

video.

"" (empty No explicit kind, or the kind given by the track's Audio

string) metadata is not recognized by the user agent. and

video.

The AudioTrack label and VideoTrack label attributes must return the label of the track, if it has one, or the empty string ✔ MDN p418 p418 ✔ MDN

otherwise. p1278 [INBAND]

The p418 p418 AudioTrack language and VideoTrack language attributes must return the BCP 47 language tag of the language of the track, if it has one, or the empty string otherwise. If the user agent is not able to express that language as a BCP 47 language tag (for example because the language information in the p389 media resource 's format is a free-form string without a defined interpretation), ✔ MDN

then the method must return the empty string, as if the track had no language. p1278 [INBAND]

The p418 AudioTrack enabled attribute, on getting, must return true if the track is currently enabled, and false otherwise. On setting, it must enable the track if the new value is true, and disable it otherwise. (If the track is no longer in an p418 AudioTrackList object, then the track being enabled or disabled has no effect beyond changing the value of the attribute on the p418 AudioTrack object.) Whenever an audio track in an p418 AudioTrackList that was disabled is enabled, and whenever one that was enabled is disabled, the user agent must p389 p388 p441 queue a media element task given the media element to fire an event named change at the

AudioTrackList p418 object.

An audio track that has no data for a particular position on the p403 media timeline, or that does not exist at that position, must be ✔ MDN interpreted as being silent at that point on the timeline.

The p418 VideoTrackList selectedIndex attribute must return the index of the currently selected track, if any. If the ✔ MDN

VideoTrackList p418 object does not currently represent any tracks, or if none of the tracks are selected, it must instead return −1.

The p418 VideoTrack selected attribute, on getting, must return true if the track is currently selected, and false otherwise. On setting, it must select the track if the new value is true, and unselect it otherwise. If the track is in a p418 VideoTrackList , then all the other

VideoTrack p418 p418 objects in that list must be unselected. (If the track is no longer in a VideoTrackList object, then the track being selected or unselected has no effect beyond changing the value of the attribute on the p418 VideoTrack object.) Whenever a track in a p418 VideoTrackList that was previously not selected is selected, and whenever the selected track in a

VideoTrackList p418 p389 is unselected without a new track being selected in its stead, the user agent must queue a media element task

given the p388 p441 p418 p932 p933 media element to fire an event named change at the VideoTrackList object. This task must be queued

before the p932 p441 task that fires the resize event, if any.

A video track that has no data for a particular position on the p403 media timeline must be interpreted as being transparent black at that point on the timeline, with the same dimensions as the last frame before that position, or, if the position is before all the data for that track, the same dimensions as the first frame for that track. A track that does not exist at all at the current position must be treated as if it existed but had no data.

Example

For instance, if a video has a track that is only introduced after one hour of playback, and the user selects that track then goes

back to the start, then the user agent will act as if that track started at the start of the p389 media resource but was simply

transparent until one hour in.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p418 p418 , by all objects implementing the AudioTrackList and VideoTrackList interfaces:

Event handler p941 p944 Event handler event type

p441 ✔ MDN

onchange change

p441 ✔ MDN

onaddtrack addtrack

421

Event handler p941 p944 Event handler event type

onremovetrack removetrack

p441 ✔ MDN



4.8.12.10.2 Selecting specific audio and video tracks declaratively p42 §

2

The p418 p418 audioTracks and videoTracks attributes allow scripts to select which track should play, but it is also possible to select specific tracks declaratively, by specifying particular tracks in the p389 fragment of the URL of the media resource . The format of the

fragment p389 p1280 p1282 depends on the MIME type of the media resource . [RFC2046] [URL]

Example

In this example, a video that uses a format that supports media fragment syntax is embedded in such a way that the alternative

angles labeled "Alternative" are enabled instead of the default video track.





4.8.12.11 Timed text tracks p42 §

2

4.8.12.11.1 Text track model p42 §

2

A p388 p388 media element can have a group of associated text tracks , known as the media element's list of text tracks. The text

tracks p422 are sorted as follows:

1. The p422 p385 p388 text tracks corresponding to track element children of the media element , in tree order.

2. Any p422 p431 text tracks added using the addTextTrack() method, in the order they were added, oldest first.

3. Any p425 p422 p389 media-resource-specific text tracks ( text tracks corresponding to data in the media resource ), in the order

defined by the p389 media resource 's format specification.

A p422 text track consists of:

The kind of text track

This decides how the track is handled by the user agent. The kind is represented by a string. The possible strings are:

• subtitles

• captions

• descriptions

• chapters

• metadata

The p422 p422 p385 kind of track can change dynamically, in the case of a text track corresponding to a track element.

A label

This is a human-readable string intended to identify the track for the user.

The p422 p422 p385 label of a track can change dynamically, in the case of a text track corresponding to a track element.

When a p422 text track label is the empty string, the user agent should automatically generate an appropriate label from the text track's other properties (e.g. the kind of text track and the text track's language) for use in its user interface. This automatically-generated label is not exposed in the API.

An in-band metadata track dispatch type

This is a string extracted from the p389 media resource specifically for in-band metadata tracks to enable such tracks to be dispatched to different scripts in the document.

Example

For example, a traditional TV station broadcast streamed on the web and augmented with web-specific interactive features could include text tracks with metadata for ad targeting, trivia game data during game shows, player states during sports games, recipe information during food programs, and so forth. As each program starts and ends, new tracks might be added or removed from the stream, and as each one is added, the user agent could bind them to dedicated script modules using the value of this attribute.

422

Other than for in-band metadata text tracks, the p422 in-band metadata track dispatch type is the empty string. How this value is

populated for different media formats is described in p425 steps to expose a media-resource-specific text track .

A language

This is a string (a BCP 47 language tag) representing the language of the text track's cues. p1275 [BCP47]

The p423 p422 p385 language of a text track can change dynamically, in the case of a text track corresponding to a track element.

A readiness state

One of the following:

Not loaded

Indicates that the text track's cues have not been obtained.

Loading

Indicates that the text track is loading and there have been no fatal errors encountered so far. Further cues might still be added to the track by the parser.

Loaded

Indicates that the text track has been loaded with no fatal errors.

Failed to load

Indicates that the text track was enabled, but when the user agent attempted to obtain it, this failed in some way (e.g. URL could

not be p89 parsed, network error, unknown text track format). Some or all of the cues are likely missing and will not be obtained.

The p423 p422 readiness state of a text track changes dynamically as the track is obtained.

A mode

One of the following:

Disabled

Indicates that the text track is not active. Other than for the purposes of exposing the track in the DOM, the user agent is ignoring the text track. No cues are active, no events are fired, and the user agent will not attempt to obtain the track's cues.

Hidden

Indicates that the text track is active, but that the user agent is not actively displaying the cues. If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily. The user agent is maintaining a list of which cues are active, and events are being fired accordingly.

Showing

Indicates that the text track is active. If no attempt has yet been made to obtain the track's cues, the user agent will perform such an attempt momentarily. The user agent is maintaining a list of which cues are active, and events are being fired

accordingly. In addition, for text tracks whose p422 p422 p422 kind is subtitles or captions, the cues are being overlaid on the video

as appropriate; for text tracks whose p422 p422 kind is descriptions, the user agent is making the cues available to the user in a

non-visual fashion; and for text tracks whose p422 p422 kind is chapters , the user agent is making available to the user a

mechanism by which the user can navigate to any point in the p389 media resource by selecting a cue.

A list of zero or more cues

A list of p424 text track cues, along with rules for updating the text track rendering. For example, for WebVTT, the rules for

updating the display of WebVTT text tracks p1282 . [WEBVTT]

The p423 p422 p423 list of cues of a text track can change dynamically, either because the text track has not yet been loaded or is still

loading p423 , or due to DOM manipulation.

Each p422 p430 text track has a corresponding TextTrack object.



Each p388 media element has a list of pending text tracks, which must initially be empty, a blocked-on-parser flag, which must initially be false, and a did-perform-automatic-track-selection flag, which must also initially be false.

When the user agent is required to p388 populate the list of pending text tracks of a media element , the user agent must add to the

element's p423 p422 p422 p423 list of pending text tracks each text track in the element's list of text tracks whose text track mode is not

disabled p423 p423 p423 and whose text track readiness state is loading .

423

Whenever a p385 p422 track element's parent node changes, the user agent must remove the corresponding text track from any list of

pending text tracks p423 that it is in.

Whenever a p422 p423 p423 p423 text track 's text track readiness state changes to either loaded or failed to load , the user agent must remove it from any p423 list of pending text tracks that it is in.

When a p388 p1076 p1184 media element is created by an HTML parser or XML parser, the user agent must set the element's blocked-on-

parser p423 p388 p1090 p1076 flag to true. When a media element is popped off the stack of open elements of an HTML parser or XML

parser p1184 p427 , the user agent must honor user preferences for automatic text track selection, populate the list of pending text

tracks p423 p423 , and set the element's blocked-on-parser flag to false.

The p422 p388 p423 text tracks of a media element are ready when both the element's list of pending text tracks is empty and the element's p423 blocked-on-parser flag is false.

Each p388 media element has a pending text track change notification flag, which must initially be unset.

Whenever a p422 p388 p422 p423 text track that is in a media element 's list of text tracks has its text track mode change value, the user agent must run the following steps for the p388 media element:

1. If the p388 p424 media element 's pending text track change notification flag is set, return.

2. Set the p388 p424 media element 's pending text track change notification flag.

3. p389 p388 Queue a media element task given the media element to run these steps:

1. Unset the p388 p424 media element 's pending text track change notification flag.

2. p441 p388 p430 p429 Fire an event named change at the media element 's textTracks attribute's TextTrackList object.

4. If the p388 p405 p414 media element 's show poster flag is not set, run the time marches on steps.

The p932 p932 p939 task source for the tasks listed in this section is the DOM manipulation task source .



A p422 text track cue is the unit of time-sensitive data in a text track, corresponding for instance for subtitles and captions to the text that appears at a particular time and disappears at another time.

Each p424 text track cue consists of:

An identifier

An arbitrary string.

A start time

The time, in seconds and fractions of a second, that describes the beginning of the range of the p389 media data to which the cue applies.

An end time

The time, in seconds and fractions of a second, that describes the end of the range of the p389 media data to which the cue applies.

A pause-on-exit flag

A boolean indicating whether playback of the p389 media resource is to pause when the end of the range to which the cue applies is reached.

Some additional format-specific data

Additional fields, as needed for the format, including the actual data of the cue. For example, WebVTT has a text track cue writing

direction p1282 and so forth. [WEBVTT]

Note

The p424 p424 p404 text track cue start time and text track cue end time can be negative. (The current playback position can never be

negative, though, so cues entirely before time zero cannot be active.) Each p424 p434 text track cue has a corresponding TextTrackCue object (or more specifically, an object that inherits from

TextTrackCue p434 p424 — for example, WebVTT cues use the VTTCue interface). A text track cue's in-memory representation can be dynamically changed through this p434 p1282 TextTrackCue API. [WEBVTT]

424

A p424 p423 text track cue is associated with rules for updating the text track rendering, as defined by the specification for the specific kind of p424 p430 text track cue . These rules are used specifically when the object representing the cue is added to a TextTrack object using the p432 addCue() method.

In addition, each p424 text track cue has two pieces of dynamic information: The active flag

This flag must be initially unset. The flag is used to ensure events are fired appropriately when the cue becomes active or inactive, and to make sure the right cues are rendered.

The user agent must synchronously unset this flag whenever the p424 p422 text track cue is removed from its text track's text track list

of cues p423 p422 p388 p422 ; whenever the text track itself is removed from its media element 's list of text tracks or has its text track

mode p423 p423 p388 p408 p406 changed to disabled ; and whenever the media element 's readyState is changed back to HAVE_NOTHING.

When the flag is unset in this way for one or more cues in p422 p423 text tracks that were showing prior to the relevant incident, the

user agent must, after having unset the flag for all the affected cues, apply the p423 rules for updating the text track rendering of

those p422 p422 text tracks . For example, for text tracks based on WebVTT, the rules for updating the display of WebVTT text tracks.

[WEBVTT] p1282

The display state

This is used as part of the rendering model, to keep cues in a consistent position. It must initially be empty. Whenever the text track

cue active flag p425 p425 is unset, the user agent must empty the text track cue display state .

The p424 p388 p422 text track cues of a media element 's text tracks are ordered relative to each other in the text track cue order, which is determined as follows: first group the p424 p422 cues by their text track , with the groups being sorted in the same order as their text

tracks p422 p388 p422 p424 appear in the media element 's list of text tracks ; then, within each group, cues must be sorted by their start

time p424 p424 p424 p424 , earliest first; then, any cues with the same start time must be sorted by their end time , latest first; and finally, any

cues p424 p424 p423 with identical end times must be sorted in the order they were last added to their respective text track list of cues,

oldest first (so e.g. for cues from a WebVTT file, that would initially be the order in which the cues were listed in the file). p1282 [WEBVTT]



4.8.12.11.2 Sourcing in-band text tracks p42 §

5

A p422 p389 media-resource-specific text track is a text track that corresponds to data found in the media resource.

Rules for processing and rendering such data are defined by the relevant specifications, e.g. the specification of the video format if the

media resource p389 is a video. Details for some legacy formats can be found in Sourcing In-band Media Resource Tracks from Media Containers into HTML p1278 . [INBAND]

When a p389 p422 media resource contains data that the user agent recognizes and supports as being equivalent to a text track , the user

agent p402 runs the steps to expose a media-resource-specific text track with the relevant data, as follows.

1. Associate the relevant data with a new p422 p430 p422 text track and its corresponding new TextTrack object. The text track is a

media-resource-specific text track p425 .

2. Set the new p422 p422 p422 p423 text track 's kind , label , and language based on the semantics of the relevant data, as defined by

the relevant specification. If there is no label in that data, then the p422 label must be set to the empty string.

3. Associate the p423 p423 text track list of cues with the rules for updating the text track rendering appropriate for the format in

question.

4. If the new p422 p422 p422 p422 text track 's kind is chapters or metadata, then set the text track in-band metadata track dispatch

type p422 p389 as follows, based on the type of the media resource:

↪ p389 If the media resource is an Ogg file

The p422 text track in-band metadata track dispatch type must be set to the value of the Name header field.

[OGGSKELETONHEADERS] p1279

↪ p389 If the media resource is a WebM file

The p422 text track in-band metadata track dispatch type must be set to the value of the CodecID element.

[WEBMCG] p1282

↪ p389 If the media resource is an MPEG-2 file

Let stream type be the value of the "stream_type" field describing the text track's type in the file's program map section, interpreted as an 8-bit unsigned integer. Let length be the value of the "ES_info_length" field for the track in

425

the same part of the program map section, interpreted as an integer as defined by Generic coding of moving pictures and associated audio information. Let descriptor bytes be the length bytes following the "ES_info_length" field. The

text track in-band metadata track dispatch type p422 must be set to the concatenation of the stream type byte and the

zero or more p1279 descriptor bytes bytes, expressed in hexadecimal using ASCII upper hex digits . [MPEG2]

↪ p389 If the media resource is an MPEG-4 file

Let the first p422 stsd box of the first stbl box of the first minf box of the first mdia box of the text track's trak box in the first moov box of the file be the stsd box, if any. If the file has no stsd box, or if the stsd box has neither a mett box

nor a p422 metx box, then the text track in-band metadata track dispatch type must be set to the empty string.

Otherwise, if the p422 stsd box has a mett box then the text track in-band metadata track dispatch type must be set to the concatenation of the string "mett", a U+0020 SPACE character, and the value of the first mime_format field of the first mett box of the stsd box, or the empty string if that field is absent in that box. Otherwise, if the stsd box has no

mett p422 box but has a metx box then the text track in-band metadata track dispatch type must be set to the concatenation of the string "metx", a U+0020 SPACE character, and the value of the first namespace field of the first

metx p1279 box of the stsd box , or the empty string if that field is absent in that box. [MPEG4]

5. Populate the new p422 p423 p429 text track 's list of cues with the cues parsed so far, following the guidelines for exposing cues,

and begin updating it dynamically as necessary.

6. Set the new p422 p423 p423 text track 's readiness state to loaded .

7. Set the new p422 p423 text track 's mode to the mode consistent with the user's preferences and the requirements of the

relevant specification for the data.

Note

For instance, if there are no other active subtitles, and this is a forced subtitle track (a subtitle track giving subtitles in the audio track's primary language, but only for audio that is actually in another language), then those subtitles might be activated here.

8. Add the new p422 p388 p422 text track to the media element 's list of text tracks.

9. p441 p388 p430 p429 Fire an event named addtrack at the media element 's textTracks attribute's TextTrackList object, using

TrackEvent p439 p440 p422 p430 , with the track attribute initialized to the text track 's TextTrack object.



4.8.12.11.3 Sourcing out-of-band text tracks p42 §

6

When a p385 p422 track element is created, it must be associated with a new text track (with its value set as defined below) and its corresponding new p430 TextTrack object.

The p422 p386 text track kind is determined from the state of the element's kind attribute according to the following table; for a state given in a cell of the first column, the p422 kind is the string given in the second column:

State String

Subtitles p386 p422 subtitles

Captions p386 p422 captions

Descriptionsp386 descriptions p422

Chapters metadata p386 p422 chapters

Metadata p386 p422 metadata

The p422 p387 text track label is the element's track label.

The p423 p387 text track language is the element's track language , if any, or the empty string otherwise.

As the p386 p387 p387 p422 kind , label , and srclang attributes are set, changed, or removed, the text track must update accordingly, as per the definitions above.

Note

Changes to the p386 track URL are handled in the algorithm below.

The p423 p423 p423 p423 text track readiness state is initially not loaded , and the text track mode is initially disabled.

426

The p423 text track list of cues is initially empty. It is dynamically modified when the referenced file is parsed. Associated with the list are the p423 rules for updating the text track rendering appropriate for the format in question; for WebVTT, this is the rules for updating the

display of WebVTT text tracks p1282 . [WEBVTT]

When a p385 p388 track element's parent element changes and the new parent is a media element , then the user agent must add the

track p385 p422 p388 p422 element's corresponding text track to the media element 's list of text tracks , and then queue a media element

task p389 p388 p441 p388 p430 given the media element to fire an event named addtrack at the media element 's textTracks attribute's

TextTrackList p429 p439 p440 p422 p430 object, using TrackEvent , with the track attribute initialized to the text track 's TextTrack object.

When a p385 p388 track element's parent element changes and the old parent was a media element, then the user agent must remove the p385 p422 p388 p422 track element's corresponding text track from the media element 's list of text tracks, and then queue a media

element task p389 p388 p441 p388 p430 given the media element to fire an event named removetrack at the media element 's textTracks

attribute's p429 p439 p440 p422 p430 TextTrackList object, using TrackEvent , with the track attribute initialized to the text track 's TextTrack object.



When a p422 p385 p388 p422 text track corresponding to a track element is added to a media element 's list of text tracks, the user agent

must p389 p388 p388 queue a media element task given the media element to run the following steps for the media element:

1. If the element's p423 blocked-on-parser flag is true, then return.

2. If the element's p423 did-perform-automatic-track-selection flag is true, then return.

3. p427 Honor user preferences for automatic text track selection for this element.

When the user agent is required to p388 honor user preferences for automatic text track selection for a media element , the user agent must run the following steps:

1. p427 p422 p422 Perform automatic text track selection for subtitles and captions .

2. p427 p422 Perform automatic text track selection for descriptions.

3. If there are any p422 p388 p422 p422 p422 text tracks in the media element 's list of text tracks whose text track kind is chapters or

metadata p422 p385 p387 p423 that correspond to track elements with a default attribute set whose text track mode is set to

disabled p423 p423 p423 , then set the text track mode of all such tracks to hidden

4. Set the element's p423 did-perform-automatic-track-selection flag to true.

When the steps above say to p422 perform automatic text track selection for one or more text track kinds, it means to run the following steps:

1. Let p422 p388 p422 candidates be a list consisting of the text tracks in the media element 's list of text tracks whose text track

kind p422 p422 is one of the kinds that were passed to the algorithm, if any, in the order given in the list of text tracks.

2. If candidates is empty, then return.

3. If any of the p422 p423 p423 text tracks in candidates have a text track mode set to showing, return.

4. If the user has expressed an interest in having a track from p422 candidates enabled based on its text track kind, text track

language p423 p422 p423 p423 , and text track label , then set its text track mode to showing .

Note

For example, the user could have set a browser preference to the effect of "I want French captions whenever possible", or "If there is a subtitle track with 'Commentary' in the title, enable it", or "If there are audio description tracks available, enable one, ideally in Swiss German, but failing that in Standard Swiss German or Standard German".

Otherwise, if there are any p422 p385 p387 text tracks in candidates that correspond to track elements with a default attribute

set whose p423 p423 p423 p423 text track mode is set to disabled , then set the text track mode of the first such track to showing .

When a p422 p385 text track corresponding to a track element experiences any of the following circumstances, the user agent must start

the p428 p422 p385 track processing model for that text track and its track element:

• The p385 track element is created.

• The p422 p423 text track has its text track mode changed.

427

• The p385 p388 track element's parent element changes and the new parent is a media element.

When a user agent is to p422 p385 start the track processing model for a text track and its track element, it must run the following algorithm. This algorithm interacts closely with the p931 p937 event loop mechanism; in particular, it has a synchronous section (which is triggered as part of the p931 event loop algorithm). The steps in that section are marked with ⌛.

1. If another occurrence of this algorithm is already running for this p422 p385 text track and its track element, return, letting that

other algorithm take care of this element.

2. If the p422 p423 p423 p423 text track 's text track mode is not set to one of hidden or showing, then return.

3. If the p422 p385 p388 text track 's track element does not have a media element as a parent, return.

4. Run the remainder of these steps p42 in parallel, allowing whatever caused these steps to run to continue.

5. p936 p937 Top : Await a stable state . The synchronous section consists of the following steps. (The steps in the synchronous

section p937 are marked with ⌛.)

6. p423 p423 ⌛ Set the text track readiness state to loading .

7. p386 p385 ⌛ Let URL be the track URL of the track element.

8. p385 p388 ⌛ If the track element's parent is a media element then let corsAttributeState be the state of the parent media

element p388 p391 p91 's crossorigin content attribute. Otherwise, let corsAttributeState be No CORS.

9. End the p937 p42 synchronous section , continuing the remaining steps in parallel.

10. If URL is not the empty string, then:

1. Let p90 request be the result of creating a potential-CORS request given URL, "track", and corsAttributeState, and

with the same-origin fallback flag set.

2. Set p385 p911 request 's client to the track element's node document 's relevant settings object.

3. Fetch request.

The p932 p933 p939 tasks queued by the fetching algorithm on the networking task source to process the data as it is being fetched must determine the type of the resource. If the type of the resource is not a supported text track format, the load will

fail, as described below. Otherwise, the resource's data must be passed to the appropriate parser (e.g., the WebVTT parser)

as it is received, with the p423 p1282 text track list of cues being used for that parser's output. [WEBVTT]

Note

The appropriate parser will incrementally update the p423 p939 text track list of cues during these networking task source

tasks p932, as each such task is run with whatever data has been received from the network).



This specification does not currently say whether or how to check the MIME types of text tracks, or whether or how to perform file type sniffing using the actual file data. Implementors differ in their intentions on this matter and it is therefore unclear what the right solution is. In the absence of any requirement here, the HTTP specifications' strict requirement to follow the Content-Type header prevails ("Content-Type specifies the media type of the underlying data." ... "If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource.").

If fetching fails for any reason (network error, the server returns an error code, CORS fails, etc), or if URL is the empty string,

then p933 p939 p388 queue an element task on the DOM manipulation task source given the media element to first change the

text track readiness state p423 p423 p441 p385 to failed to load and then fire an event named error at the track element.

If fetching does not fail, but the type of the resource is not a supported text track format, or the file was not successfully processed (e.g., the format in question is an XML format and the file contained a well-formedness error that XML requires be

detected and reported to the application), then the p932 p933 p939 task that is queued on the networking task source in which the

aforementioned problem is found must change the p423 p423 text track readiness state to failed to load and fire an event named

error p441 p385 at the track element.

If fetching does not fail, and the file was successfully processed, then the final p932 p933 task that is queued by the networking

task source p939 p423 p423 , after it has finished parsing the data, must change the text track readiness state to loaded , and fire an

event p441 p385 named load at the track element.

428

If, while fetching is ongoing, either:

◦ the p386 p423 p423 track URL changes so that it is no longer equal to URL , while the text track mode is set to hidden or

showing p423; or

◦ the p423 p423 p423 p386 text track mode changes to hidden or showing , while the track URL is not equal to URL

...then the user agent must abort p932 fetching , discarding any pending tasks generated by that algorithm (and in particular,

not adding any cues to the p423 text track list of cues after the moment the URL changed), and then queue an element

task p933 p939 p385 on the DOM manipulation task source given the track element that first changes the text track readiness

state p423 p423 p441 p385 to failed to load and then fires an event named error at the track element.

11. Wait until the p423 p423 text track readiness state is no longer set to loading.

12. Wait until the p386 p423 p423 track URL is no longer equal to URL , at the same time as the text track mode is set to hidden or

showing p423.

13. Jump to the step labeled top.

Whenever a p385 p386 p42 track element has its src attribute set, changed, or removed, the user agent must immediately empty the element's p422 p423 text track 's text track list of cues . (This also causes the algorithm above to stop adding cues from the resource being obtained using the previously given URL, if any.)



4.8.12.11.4 Guidelines for exposing cues in various formats as p424 p42 text track cues §

9

How a specific format's text track cues are to be interpreted for the purposes of processing by an HTML user agent is defined by that format. In the absence of such a specification, this section provides some constraints within which implementations can attempt to consistently expose such formats.

To support the p422 p424 text track model of HTML, each unit of timed data is converted to a text track cue. Where the mapping of the format's features to the aspects of a p424 text track cue as defined in this specification are not defined, implementations must ensure that the mapping is consistent with the definitions of the aspects of a p424 text track cue as defined above, as well as with the following constraints: The p424 text track cue identifier

Should be set to the empty string if the format has no obvious analogue to a per-cue identifier.

The p424 text track cue pause-on-exit flag

Should be set to false.



4.8.12.11.5 Text track API p42 §

9

IDL [Exposed=Window] ✔ MDN

interface TextTrackList : EventTarget {

readonly attribute unsigned long length;

getter TextTrack (unsigned long index);

TextTrack? getTrackById(DOMString id);

attribute EventHandler onchange;

attribute EventHandler onaddtrack;

attribute EventHandler onremovetrack;

};



For web developers (non-normative)

media p430 . textTracks . length

Returns the number of p422 p388 p385 text tracks associated with the media element (e.g. from track elements). This is the number

of p422 p388 p422 text tracks in the media element 's list of text tracks.



429

media p430 . textTracks[ n ]

Returns the p430 p422 p388 p422 TextTrack object representing the n th text track in the media element 's list of text tracks.

textTrack p430 p430 = media . textTracks . getTrackById( id )

Returns the p430 TextTrack object with the given identifier, or null if no track has that identifier.

✔ MDN

A p429 p422 TextTrackList object represents a dynamically updating list of text tracks in a given order.

The p388 p429 p430 textTracks attribute of media elements must return a TextTrackList object representing the TextTrack objects of the ✔ MDN

text tracks p422 p388 p422 p422 in the media element 's list of text tracks , in the same order as in the list of text tracks.

The p429 p422 length attribute of a TextTrackList object must return the number of text tracks in the list represented by the

TextTrackList p429 object.

The p429 supported property indices of a TextTrackList object at any instant are the numbers from zero to the number of text

tracks p422 p429 p422 in the list represented by the TextTrackList object minus one, if any. If there are no text tracks in the list, there are no supported property indices.

To p429 determine the value of an indexed property of a TextTrackList object for a given index index, the user agent must return the ✔ MDN

index p422 p429 th text track in the list represented by the TextTrackList object.

The p430 p429 p431 getTrackById( id ) method must return the first TextTrack in the TextTrackList object whose id IDL attribute would return a value equal to the value of the id argument. When no tracks match the given argument, the method must return null.



IDL ✔ enum TextTrackMode { "disabled" , "hidden" , "showing" }; MDN

enum TextTrackKind { "subtitles", "captions", "descriptions", "chapters", "metadata" };

[Exposed=Window]

interface TextTrack : EventTarget {

readonly attribute TextTrackKind kind;

readonly attribute DOMString label;

readonly attribute DOMString language;

readonly attribute DOMString id;

readonly attribute DOMString inBandMetadataTrackDispatchType;

attribute TextTrackMode mode;

readonly attribute TextTrackCueList? cues;

readonly attribute TextTrackCueList? activeCues;

undefined addCue(TextTrackCue cue);

undefined removeCue(TextTrackCue cue);

attribute EventHandler oncuechange;

};



For web developers (non-normative)

textTrack p431 = media . addTextTrack( kind [, label [, language ] ] )

Creates and returns a new p430 p388 p422 TextTrack object, which is also added to the media element 's list of text tracks.

textTrack p431 . kind

Returns the p422 text track kind string.

textTrack p431 . label

Returns the p422 text track label , if there is one, or the empty string otherwise (indicating that a custom label probably needs to be generated from the other attributes of the object if the object is exposed to the user).



430

textTrack p431 . language

Returns the p423 text track language string.

textTrack p431 . id

Returns the ID of the given track.

For in-band tracks, this is the ID that can be used with a fragment if the format supports media fragment syntax, and that can

be used with the p430 getTrackById() method.

For p430 p385 p385 TextTrack objects corresponding to track elements, this is the ID of the track element.

textTrack p432 . inBandMetadataTrackDispatchType

Returns the p422 text track in-band metadata track dispatch type string.

textTrack p432 . mode [ = value ]

Returns the p423 text track mode , represented by a string from the following list:

" p432 disabled "

The p423 text track disabled mode.

" p432 hidden"

The p423 text track hidden mode.

" p432 showing"

The p423 text track showing mode.

Can be set, to change the mode.

textTrack p432 . cues

Returns the p423 p433 text track list of cues , as a TextTrackCueList object.

textTrack p432 . activeCues

Returns the p424 p423 text track cues from the text track list of cues that are currently active (i.e. that start before the current

playback position p404 p433 and end after it), as a TextTrackCueList object.

textTrack p432 . addCue( cue )

Adds the given cue to p423 textTrack 's text track list of cues.

textTrack p432 . removeCue ( cue )

Removes the given cue from p423 textTrack 's text track list of cues .

The p388 addTextTrack( kind , label , language ) method of media elements , when invoked, must run the following steps:

1. Create a new p430 TextTrack object.

2. Create a new p422 p422 p422 text track corresponding to the new object, and set its text track kind to kind , its text track label to

label p423 p423 p423 , its text track language to language , its text track readiness state to the text track loaded state, its text track

mode p423 p423 p423 to the text track hidden mode, and its text track list of cues to an empty list.

Initially, the p423 p423 text track list of cues is not associated with any rules for updating the text track rendering . When a text

track cue p424 p423 is added to it, the text track list of cues has its rules permanently set accordingly.

3. Add the new p422 p388 p422 text track to the media element 's list of text tracks.

4. p389 p388 p441 p388 Queue a media element task given the media element to fire an event named addtrack at the media element's

textTracks p430 p429 p439 p440 attribute's TextTrackList object, using TrackEvent , with the track attribute initialized to the new

text track p422 p430 's TextTrack object.

5. Return the new p430 TextTrack object.



The p422 p422 p430 kind attribute must return the text track kind of the text track that the TextTrack object represents.

The p422 p422 p430 label attribute must return the text track label of the text track that the TextTrack object represents.

The p423 p422 p430 language attribute must return the text track language of the text track that the TextTrack object represents.

The p385 id attribute returns the track's identifier, if it has one, or the empty string otherwise. For tracks that correspond to track

431

elements, the track's identifier is the value of the element's p138 id attribute, if any. For in-band tracks, the track's identifier is specified by the p389 p389 media resource . If the media resource is in a format that supports media fragment syntax, the identifier returned for a particular track must be the same identifier that would enable the track if used as the name of a track in the track dimension of such a

fragment.

The p422 inBandMetadataTrackDispatchType attribute must return the text track in-band metadata track dispatch type of the text ✔ MDN

track p422 p430 that the TextTrack object represents.

The p423 p422 mode attribute, on getting, must return the string corresponding to the text track mode of the text track that the

TextTrack p430 object represents, as defined by the following list:

"disabled"

The p423 text track disabled mode.

"hidden"

The p423 text track hidden mode.

"showing"

The p423 text track showing mode.

On setting, if the new value isn't equal to what the attribute would currently return, the new value must be processed as follows:

↪ p432 If the new value is " disabled"

Set the p423 p422 p430 p423 text track mode of the text track that the TextTrack object represents to the text track disabled mode.

↪ p432 If the new value is " hidden "

Set the p423 p422 p430 p423 text track mode of the text track that the TextTrack object represents to the text track hidden mode.

↪ p432 If the new value is " showing"

Set the p423 p422 p430 p423 text track mode of the text track that the TextTrack object represents to the text track showing mode.

If the p423 p422 p430 p423 text track mode of the text track that the TextTrack object represents is not the text track disabled mode, then the cues p45 p433 p423 attribute must return a live TextTrackCueList object that represents the subset of the text track list of cues of the text

track p422 p430 p424 that the TextTrack object represents whose end times occur at or after the earliest possible position when the script

started p432 p425 p430 , in text track cue order . Otherwise, it must return null. For each TextTrack object, when an object is returned, the same p433 TextTrackCueList object must be returned each time.

The p405 earliest possible position when the script started is whatever the earliest possible position was the last time the event

loop p931 reached step 1.

If the p423 p422 p430 p423 text track mode of the text track that the TextTrack object represents is not the text track disabled mode, then the activeCues p45 p433 p423 attribute must return a live TextTrackCueList object that represents the subset of the text track list of cues of

the p422 p430 p432 text track that the TextTrack object represents whose active flag was set when the script started, in text track cue

order p425 p430 p433 . Otherwise, it must return null. For each TextTrack object, when an object is returned, the same TextTrackCueList object must be returned each time.

A p424 p425 text track cue 's active flag was set when the script started if its text track cue active flag was set the last time the event

loop p931 p934 reached step 1.



The p430 addCue( cue ) method of TextTrack objects, when invoked, must run the following steps:

1. If the p423 p423 text track list of cues does not yet have any associated rules for updating the text track rendering , then

associate the p423 p423 text track list of cues with the rules for updating the text track rendering appropriate to cue.

2. If p423 p423 text track list of cues ' associated rules for updating the text track rendering are not the same rules for updating the

text track rendering p423 as appropriate for cue, then throw an "InvalidStateError" DOMException.

3. If the given p423 p423 cue is in a text track list of cues , then remove cue from that text track list of cues.

4. Add p430 p422 p423 cue to the TextTrack object's text track 's text track list of cues.

The p430 removeCue( cue ) method of TextTrack objects, when invoked, must run the following steps:

1. If the given p430 p422 p423 cue is not in the TextTrack object's text track 's text track list of cues, then throw a "NotFoundError"

432

DOMException.

2. Remove p430 p422 p423 cue from the TextTrack object's text track 's text track list of cues .

Example

In this example, an p384 audio element is used to play a specific sound-effect from a sound file containing many sound effects. A cue

is used to pause the audio, so that it ends exactly at the end of the clip, even if the browser is busy running some script. If the

page had relied on script to pause the audio, then the start of the next clip might be heard if the browser was not able to run the

script at the exact time specified.

var sfx = new Audio('sfx.wav');

var sounds = sfx.addTextTrack('metadata');

// add sounds we care about

function addFX(start, end, name) {

var cue = new VTTCue(start, end, '');

cue.id = name;

cue.pauseOnExit = true;

sounds.addCue(cue);

}

addFX(12.783, 13.612, 'dog bark');

addFX(13.612, 15.091, 'kitten mew'))

function playSound(id) {

sfx.currentTime = sounds.getCueById(id).startTime;

sfx.play();

}

// play a bark as soon as we can

sfx.oncanplaythrough = function () {

playSound('dog bark');

}

// meow when the user tries to leave,

// and have the browser ask them to stay

window.onbeforeunload = function (e) {

playSound('kitten mew');

e.preventDefault();

}



IDL [Exposed=Window]

interface TextTrackCueList {

readonly attribute unsigned long length;

getter TextTrackCue (unsigned long index);

TextTrackCue? getCueById(DOMString id);

};



For web developers (non-normative)

cuelist p434 . length

Returns the number of p424 cues in the list.

cuelist[index]

Returns the p424 p425 text track cue with index index in the list. The cues are sorted in text track cue order.

cuelist p434 . getCueById ( id )

Returns the first p424 p425 p424 text track cue (in text track cue order ) with text track cue identifier id. Returns null if none of the cues have the given identifier or if the argument is the empty string.

A p433 p424 TextTrackCueList object represents a dynamically updating list of text track cues in a given order.

433

The p424 p433 length attribute must return the number of cues in the list represented by the TextTrackCueList object.

The p433 p424 supported property indices of a TextTrackCueList object at any instant are the numbers from zero to the number of cues

in the list represented by the p433 p424 TextTrackCueList object minus one, if any. If there are no cues in the list, there are no supported

property indices.

To p424 determine the value of an indexed property for a given index index , the user agent must return the index th text track cue in the list represented by the p433 TextTrackCueList object.

The p424 getCueById( id ) method, when called with an argument other than the empty string, must return the first text track cue in the

list represented by the p433 p424 TextTrackCueList object whose text track cue identifier is id, if any, or null otherwise. If the argument is the empty string, then the method must return null.



IDL MDN [ Exposed = Window ]

interface TextTrackCue : EventTarget {

readonly attribute TextTrack? track;

attribute DOMString id;

attribute double startTime;

attribute double endTime;

attribute boolean pauseOnExit;

attribute EventHandler onenter;

attribute EventHandler onexit;

};



For web developers (non-normative)

cue p434 . track

Returns the p430 p424 TextTrack object to which this text track cue belongs, if any, or null otherwise.

cue p434 . id [ = value ]

Returns the p424 text track cue identifier.

Can be set.

cue p434 . startTime [ = value ]

Returns the p424 text track cue start time, in seconds.

Can be set.

cue p434 . endTime [ = value ]

Returns the p424 text track cue end time , in seconds.

Can be set.

cue p435 . pauseOnExit [ = value ]

Returns true if the p424 text track cue pause-on-exit flag is set, false otherwise. Can be set.

The p430 p422 p423 p424 track attribute, on getting, must return the TextTrack object of the text track in whose list of cues the text track cue

that the p434 TextTrackCue object represents finds itself, if any; or null otherwise.

The p424 p424 p434 id attribute, on getting, must return the text track cue identifier of the text track cue that the TextTrackCue object represents. On setting, the p424 text track cue identifier must be set to the new value.

The p424 p424 p434 startTime attribute, on getting, must return the text track cue start time of the text track cue that the TextTrackCue

object represents, in seconds. On setting, the p424 text track cue start time must be set to the new value, interpreted in seconds; then, if the p434 p424 p422 p423 p422 p388 TextTrackCue object's text track cue is in a text track 's list of cues , and that text track is in a media element's

list of text tracks p422 p388 p405 p414 , and the media element 's show poster flag is not set, then run the time marches on steps for that media

element p388.

The p424 p424 p434 endTime attribute, on getting, must return the text track cue end time of the text track cue that the TextTrackCue

object represents, in seconds. On setting, the p424 text track cue end time must be set to the new value, interpreted in seconds; then, if

434

the p434 p424 p422 p423 p422 p388 TextTrackCue object's text track cue is in a text track 's list of cues , and that text track is in a media element's

list of text tracks p422 p388 p405 p414 , and the media element 's show poster flag is not set, then run the time marches on steps for that media

element p388.

The p424 p424 pauseOnExit attribute, on getting, must return true if the text track cue pause-on-exit flag of the text track cue that the

TextTrackCue p434 p424 object represents is set; or false otherwise. On setting, the text track cue pause-on-exit flag must be set if the new value is true, and must be unset otherwise.



4.8.12.11.6 Event handlers for objects of the text track APIs §p43

5

The following are the p941 p944 event handlers that (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p429 , by all objects implementing the TextTrackList interface:

Event handler p941 p944 Event handler event type

onchange p441 change

onaddtrack p441 addtrack

onremovetrack p441 removetrack

The following are the p941 p944 event handlers that (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p430 , by all objects implementing the TextTrack interface:

Event handler p941 p944 Event handler event type

oncuechange p441 cuechange

The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p434 , by all objects implementing the TextTrackCue interface:

Event handler p941 p944 Event handler event type

onenter p442 enter

onexit p442 exit



4.8.12.11.7 Best practices for metadata text tracks p43 §

5

This section is non-normative.

Text tracks can be used for storing data relating to the media data, for interactive or augmented views.

For example, a page showing a sports broadcast could include information about the current score. Suppose a robotics competition was being streamed live. The image could be overlayed with the scores, as follows:



435





RED ALLIANCE BLUE ALLIANCE




78 66



QUAL MATCH 37 FRIDAY 14:21



In order to make the score display render correctly whenever the user seeks to an arbitrary point in the video, the metadata text track cues need to be as long as is appropriate for the score. For example, in the frame above, there would be maybe one cue that lasts the length of the match that gives the match number, one cue that lasts until the blue alliance's score changes, and one cue that lasts until the red alliance's score changes. If the video is just a stream of the live event, the time in the bottom right would presumably be automatically derived from the current video time, rather than based on a cue. However, if the video was just the highlights, then that might be given in cues also.

The following shows what fragments of this could look like in a WebVTT file:

WEBVTT

...

05:10:00.000 --> 05:12:15.000

matchtype:qual

matchnumber:37

...

05:11:02.251 --> 05:11:17.198

red:78

05:11:03.672 --> 05:11:54.198

blue:66

05:11:17.198 --> 05:11:25.912

red:80

05:11:25.912 --> 05:11:26.522

red:83

05:11:26.522 --> 05:11:26.982

red:86

05:11:26.982 --> 05:11:27.499

red:89

436

...

The key here is to notice that the information is given in cues that span the length of time to which the relevant event applies. If, instead, the scores were given as zero-length (or very brief, nearly zero-length) cues when the score changes, for example saying "red+2" at 05:11:17.198, "red+3" at 05:11:25.912, etc, problems arise: primarily, seeking is much harder to implement, as the script has to walk the entire list of cues to make sure that no notifications have been missed; but also, if the cues are short it's possible the script will never see that they are active unless it listens to them specifically.

When using cues in this manner, authors are encouraged to use the p441 cuechange event to update the current annotations. (In particular, using the p441 timeupdate event would be less appropriate as it would require doing work even when the cues haven't changed, and, more importantly, would introduce a higher latency between when the metadata cues become active and when the display is updated, since p441 timeupdate events are rate-limited.)



4.8.12.12 Identifying a track kind through a URL p43 §

7

Other specifications or formats that need a p418 p420 p418 p420 URL to identify the return values of the AudioTrack kind or VideoTrack kind

IDL attributes, or identify the p422 p88 kind of text track , must use the about:html-kind URL.



4.8.12.13 User interface p43 §

7

The p67 controls attribute is a boolean attribute. If present, it indicates that the author has not provided a scripted controller and would like the user agent to provide its own set of controls.

If the attribute is present, or if p911 p388 scripting is disabled for the media element, then the user agent should expose a user interface to the user. This user interface should include features to begin playback, pause playback, seek to an arbitrary position in the content (if the content supports arbitrary seeking), change the volume, change the display of closed captions or embedded sign-language tracks, select different audio tracks or turn on audio descriptions, and show the media content in manners more suitable to the user (e.g. fullscreen video or in an independent resizable window). Other controls may also be made available.

Even when the attribute is absent, however, user agents may provide controls to affect playback of the media resource (e.g. play, pause, seeking, track selection, and volume controls), but such features should not interfere with the page's normal rendering. For example, such features could be exposed in the p388 media element's context menu, platform media keys, or a remote control. The user agent may implement this simply by p437 p437 exposing a user interface to the user as described above (as if the controls attribute was present).

If the user agent p437 p388 exposes a user interface to the user by displaying controls over the media element, then the user agent should suppress any user interaction events while the user agent is interacting with this interface. (For example, if the user clicks on a video's playback control, mousedown events and so forth would not simultaneously be fired at elements on the page.) Where possible (specifically, for starting, stopping, pausing, and unpausing playback, for seeking, for changing the rate of playback, for fast-forwarding or rewinding, for listing, enabling, and disabling text tracks, and for muting or changing the volume of the audio), user interface features exposed by the user agent must be implemented in terms of the DOM API described above, so that, e.g., all the same events fire.

Features such as fast-forward or rewind must be implemented by only changing the playbackRate attribute (and not the defaultPlaybackRate attribute).

Seeking must be implemented in terms of p416 p388 p403 seeking to the requested position in the media element 's media timeline. For media resources where seeking to an arbitrary position would be slow, user agents are encouraged to use the approximate-for-speed ✔ MDN flag when seeking in response to the user manipulating an approximate position interface such as a seek bar.

The p95 controls IDL attribute must reflect the content attribute of the same name.



For web developers (non-normative)

media p438 . volume [ = value ]

Returns the current playback volume, as a number in the range 0.0 to 1.0, where 0.0 is the quietest and 1.0 the loudest. Can be set, to change the volume.

437

Throws an "IndexSizeError" DOMException if the new value is not in the range 0.0 .. 1.0.

media p438 . muted [ = value ]

Returns true if audio is muted, overriding the p438 p438 volume attribute, and false if the volume attribute is being honored. Can be set, to change whether the audio is muted or not.

A p388 media element has a playback volume, which is a fraction in the range 0.0 (silent) to 1.0 (loudest). Initially, the volume should be 1.0, but user agents may remember the last set value across sessions, on a per-site basis or otherwise, so the volume may start at ✔ MDN other values.

The p438 p388 volume IDL attribute must return the playback volume of any audio portions of the media element . On setting, if the new

value is in the range 0.0 to 1.0 inclusive, the p388 p438 media element 's playback volume must be set to the new value. If the new value is outside the range 0.0 to 1.0 inclusive, then, on setting, an "IndexSizeError" DOMException must be thrown instead.

A p388 media element can also be muted. If anything is muting the element, then it is muted. (For example, when the direction of ✔ MDN

playback p413 is backwards, the element is muted.) The p388 muted IDL attribute must return the value to which it was last set. When a media element is created, if the element has a

muted p438 p438 content attribute specified, then the muted IDL attribute should be set to true; otherwise, the user agents may set the value to the user's preferred value (e.g. remembering the last set value across sessions, on a per-site basis or otherwise). While the

muted p438 p388 p438 IDL attribute is set to true, the media element must be muted.

Whenever either of the values that would be returned by the p438 p438 volume and muted IDL attributes change, the user agent must

queue a media element task p389 p388 p441 p388 given the media element to fire an event named volumechange at the media element. Then, if the p388 p409 p412 p388 media element is not allowed to play , the user agent must run the internal pause steps for the media element.

An element's effective media volume is determined as follows:

1. If the user has indicated that the user agent is to override the volume of the element, then return the volume desired by the

user.

2. If the element's audio output is p438 muted, then return zero.

3. Let p438 p388 volume be the playback volume of the audio portions of the media element, in range 0.0 (silent) to 1.0 (loudest).

4. Return volume, interpreted relative to the range 0.0 to 1.0, with 0.0 being silent, and 1.0 being the loudest setting, values in

between increasing in loudness. The range need not be linear. The loudest setting may be lower than the system's loudest possible setting; for example the user could have set a maximum volume.

The p388 p67 muted content attribute on media elements is a boolean attribute that controls the default state of the audio output of the ✔ MDN

media resource p389 , potentially overriding user preferences.

The p95 p438 defaultMuted IDL attribute must reflect the muted content attribute.

Note

This attribute has no dynamic effect (it only controls the default state of the element).



Example

This video (an advertisement) autoplays, but to avoid annoying users, it does so without sound, and allows the user to turn the

sound on. The user agent can pause the video if it's unmuted without a user interaction.





✔ MDN

4.8.12.14 Time ranges p43 §

8

Objects implementing the p439 TimeRanges interface represent a list of ranges (periods) of time.

IDL [Exposed=Window]

438

interface TimeRanges {

readonly attribute unsigned long length;

double start(unsigned long index);

double end(unsigned long index);

};



For web developers (non-normative)

media p439 . length

Returns the number of ranges in the object.

time p439 = media . start (index)

Returns the time for the start of the range with the given index.

Throws an "IndexSizeError" DOMException if the index is out of range.

time p439 = media . end(index)

Returns the time for the end of the range with the given index.

Throws an "IndexSizeError" DOMException if the index is out of range.

✔ MDN

The length IDL attribute must return the number of ranges represented by the object. ✔ MDN

The start(index) method must return the position of the start of the indexth range represented by the object, in seconds measured ✔ MDN from the start of the timeline that the object covers.

The end(index) method must return the position of the end of the indexth range represented by the object, in seconds measured from the start of the timeline that the object covers.

These methods must throw "IndexSizeError" DOMExceptions if called with an index argument greater than or equal to the number of ranges represented by the object.

When a p439 TimeRanges object is said to be a normalized TimeRanges object, the ranges it represents must obey the following criteria:

• The start of a range must be greater than the end of all earlier ranges.

• The start of a range must be less than or equal to the end of that same range.

In other words, the ranges in such an object are ordered, don't overlap, and don't touch (adjacent ranges are folded into one bigger range). A range can be empty (referencing just a single moment in time), e.g. to indicate that only one frame is currently buffered in the case that the user agent has discarded the entire p389 p388 media resource except for the current frame, when a media element is paused.

Ranges in a p439 TimeRanges object must be inclusive.

Example

Thus, the end of a range would be equal to the start of a following adjacent (touching but not overlapping) range. Similarly, a

range covering a whole timeline anchored at zero would have a start equal to zero and an end equal to the duration of the

timeline.

The timelines used by the objects returned by the p403 p417 p411 p388 buffered , seekable and played IDL attributes of media elements must be that element's p403 media timeline.



4.8.12.15 The p439 ⚠ MDN p43 TrackEvent interface §

9

IDL [Exposed=Window]

interface TrackEvent : Event {

constructor(DOMString type, optional TrackEventInit eventInitDict = {});

readonly attribute (VideoTrack or AudioTrack or TextTrack)? track;

};

439

dictionary TrackEventInit : EventInit {

(VideoTrack or AudioTrack or TextTrack)? track = null;

};



For web developers (non-normative)

event p440 . track

Returns the track object ( p430 p418 p418 TextTrack , AudioTrack , or VideoTrack ) to which the event relates.



The track attribute must return the value it was initialized to. It represents the context information for the event. ⚠ MDN



4.8.12.16 Events summary p44 §

0

This section is non-normative.

The following events fire on p388 media elements as part of the processing model described above:

Event name Interface Fired when... Preconditions

MDN

loadstart Event The user agent begins looking for media p392 p393 networkState equals NETWORK_LOADING

datap389, as part of the resource selection

algorithm p394.

MDN

suspend p392 ✔ MDN p393 Event progress Event p389 p392 p393 The user agent is fetching media data . networkState equals NETWORK_LOADING

The user agent is intentionally not currently networkState equals NETWORK_IDLE

fetching p389 media data.

MDN

abort Event The user agent stops fetching the media p390 p390 p392 error is an object with the code MEDIA_ERR_ABORTED . networkState

datap389 p392 p393 before it is completely downloaded, equals either NETWORK_EMPTY or NETWORK_IDLE , depending on when the but not due to an error. download was aborted.

MDN

error Event An error occurs while fetching the media p390 p390 error is an object with the code MEDIA_ERR_NETWORK or higher.

datap389 p392 p392 p393 or the type of the resource is not networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending supported media format. on when the download was aborted.

emptied Event p392 p392 p392 A media element whose networkState networkState is NETWORK_EMPTY ; all the IDL attributes are in their initial

p388 ✔ MDN

was previously not in the NETWORK_EMPTYp392 states.

state has just switched to that state (either

because of a fatal error during load that's

about to be reported, or because the

load() p393 method was invoked while the

resource selection algorithmp394 was already

stalled p392 ✔ MDN p393 Event running).

The user agent is trying to fetch media networkState is NETWORK_LOADING .

datap389, but data is unexpectedly not

forthcoming.

loadedmetadata p408 ✔ MDN p406 Event The user agent has just determined the readyState is newly equal to HAVE_METADATA or greater for the first time.

duration and dimensions of the media

loadeddata p389 ✔ MDN p408 p406 Event resource p389 p424 and the text tracks are ready.

The user agent can render the media data readyState newly increased to HAVE_CURRENT_DATA or greater for the first

at the p404 current playback position for the time.

canplay p408 ✔ MDN p406 Event first time.

The user agent can resume playback of the readyState newly increased to HAVE_FUTURE_DATA or greater.

media datap389, but estimates that if playback

were to be started now, the media

resource p389 could not be rendered at the

current playback rate up to its end without

having to stop for further buffering of

canplaythrough p408 ✔ MDN p406 Event content.

The user agent estimates that if playback readyState is newly equal to HAVE_ENOUGH_DATA .

were to be started now, the media

resource p389 could be rendered at the current

playback rate all the way to its end without

having to stop for further buffering.

playing Event Playback is ready to start after having been p406 readyState is newly equal to or greater than HAVE_FUTURE_DATA and

p408 ✔ MDN

paused or delayed due to lack of media p409 p409 p408 paused is false, or paused is newly false and readyState is equal to or

datap389 p406 . greater than HAVE_FUTURE_DATA . Even if this event fires, the element might still

not be p409 p410 potentially playing , e.g. if the element is paused for user interaction or

440

Event name Interface Fired when... Preconditions

waiting p408 ✔ MDN p406 p409 Event paused for in-band contentp410.

Playback has stopped because the next frame readyState is equal to or less than HAVE_CURRENT_DATA , and paused is

is not available, but the user agent expects p416 p404 false. Either seeking is true, or the current playback position is not contained

that frame to become available in due course. p403 in any of the ranges in buffered . It is possible for playback to stop for other

reasons without p409 paused being false, but those reasons do not fire this event (and

when those situations resolve, a separate p440 playing event is not fired either): e.g.,

playback has endedp409 , or playback stopped due to errorsp409, or the element has

paused for user interaction p410 p410 or paused for in-band content.

seeking Event The seeking IDL attribute changed to

p416 ✔ MDN

true, and the user agent has started seeking

to a new position.

p416 ✔ MDN

seeked Event The seeking IDL attribute changed to

false after the p404 current playback position

was changed.

✔ MDN

ended Event Playback has stopped because the end of the currentTimep405 equals the end of the media resourcep389; endedp409 is true.

media resourcep389 was reached.

p405 ✔ MDN

durationchange Event The duration attribute has just been

updated.

✔ MDN

timeupdate Event p404 The current playback position changed as

part of normal playback or in an especially

interesting way, for example discontinuously.

p409 ✔ MDN

play Event The element is no longer paused. Fired after paused is newly false.

the p411 play() method has returned, or when

the p408 autoplay attribute has caused

playback to begin.

pause Event The element has been paused. Fired after the paused is newly true.

p409 ✔ MDN

pause() p412 method has returned.

p410 ✔ MDN

ratechange Event Either the defaultPlaybackRate or the

playbackRate p410 attribute has just been

updated.

resize Event p383 p388 p380 p408 p406 One or both of the videoWidth and Media element is a video element; readyState is not HAVE_NOTHING

videoHeight p383 attributes have just been

updated.

volumechange Event Either the volume attribute or the

p438 ✔ MDN

muted p438 attribute has changed. Fired after

the relevant attribute's setter has returned.

The following event fires on p318 source element:

Event name Interface Fired when...

error p389 Event An error occurs while fetching the media data or the type of the resource is not supported media format.

The following events fire on p418 p418 p429 AudioTrackList , VideoTrackList , and TextTrackList objects:

Event name Interface Fired when...

✔ MDN

change Event One or more tracks in the track list have been enabled or disabled.

p439 ✔ MDN

addtrack TrackEvent A track has been added to the track list.

removetrack TrackEvent A track has been removed from the track list.

p439 ✔ MDN



The following event fires on p430 p385 TextTrack objects and track elements:

Event name Interface Fired when...

✔ MDN

cuechange Event One or more cues in the track have become active or stopped being active.

The following events fire on p385 track elements:

Event name Interface Fired when...

error Event An error occurs while fetching the track data or the type of the resource is not supported text track format.

load Event A track data has been fetched and successfully processed.

The following events fire on p434 TextTrackCue objects:



441

Event name Interface Fired when...

enter Event The cue has become active.

exit Event The cue has stopped being active.



4.8.12.17 Security and privacy considerations p44 §

2

The main security and privacy implications of the p380 p384 video and audio elements come from the ability to embed media cross-origin. There are two directions that threats can flow: from hostile content to a victim page, and from a hostile page to victim content.



If a victim page embeds hostile content, the threat is that the content might contain scripted code that attempts to interact with the

Document p115 that embeds the content. To avoid this, user agents must ensure that there is no access from the content to the embedding page. In the case of media content that uses DOM concepts, the embedded content must be treated as if it was in its own unrelated p817 top-level browsing context .

Example

For instance, if an SVG animation was embedded in a p380 video element, the user agent would not give it access to the DOM of the

outer page. From the perspective of scripts in the SVG resource, the SVG file would appear to be in a lone top-level browsing

context with no parent.



If a hostile page embeds victim content, the threat is that the embedding page could obtain information from the content that it would not otherwise have access to. The API does expose some information: the existence of the media, its type, its duration, its size, and the performance characteristics of its host. Such information is already potentially problematic, but in practice the same information can more or less be obtained using the p321 img element, and so it has been deemed acceptable.

However, significantly more sensitive information could be obtained if the user agent further exposes metadata within the content, such as subtitles. That information is therefore only exposed if the video resource uses CORS. The p391 crossorigin attribute allows authors to enable CORS. p1277 [FETCH]

Example

Without this restriction, an attacker could trick a user running within a corporate network into visiting a site that attempts to load a

video from a previously leaked location on the corporation's intranet. If such a video included confidential plans for a new product,

then being able to read the subtitles would present a serious confidentiality breach.



4.8.12.18 Best practices for authors using media elements p44 §

2

This section is non-normative.

Playing audio and video resources on small devices such as set-top boxes or mobile phones is often constrained by limited hardware resources in the device. For example, a device might only support three simultaneous videos. For this reason, it is a good practice to release resources held by p388 media elements when they are done playing, either by being very careful about removing all references to the element and allowing it to be garbage collected, or, even better, by removing the element's p390 p318 src attribute and any source

element descendants, and invoking the element's p393 load() method.

Similarly, when the playback rate is not exactly 1.0, hardware, software, or format limitations can cause video frames to be dropped and audio to be choppy or muted.



4.8.12.19 Best practices for implementers of media elements p44 §

2

This section is non-normative.

How accurately various aspects of the p388 media element API are implemented is considered a quality-of-implementation issue.

For example, when implementing the p403 buffered attribute, how precise an implementation reports the ranges that have been buffered depends on how carefully the user agent inspects the data. Since the API reports ranges as times, but the data is obtained in

442

byte streams, a user agent receiving a variable-bitrate stream might only be able to determine precise times by actually decoding all of the data. User agents aren't required to do this, however; they can instead return estimates (e.g. based on the average bitrate seen so far) which get revised as more information becomes available.

As a general rule, user agents are urged to be conservative rather than optimistic. For example, it would be bad to report that everything had been buffered when it had not.

Another quality-of-implementation issue would be playing a video backwards when the codec is designed only for forward playback (e.g. there aren't many key frames, and they are far apart, and the intervening frames only have deltas from the previous frame). User agents could do a poor job, e.g. only showing key frames; however, better implementations would do more work and thus do a better job, e.g. actually decoding parts of the video forwards, storing the complete frames, and then playing the frames backwards.

Similarly, while implementations are allowed to drop buffered data at any time (there is no requirement that a user agent keep all the media data obtained for the lifetime of the media element), it is again a quality of implementation issue: user agents with sufficient resources to keep all the data around are encouraged to do so, as this allows for a better user experience. For example, if the user is watching a live stream, a user agent could allow the user only to view the live video; however, a better user agent would buffer everything and allow the user to seek through the earlier material, pause it, play it forwards and backwards, etc.



When a p388 p44 p931 media element that is paused is removed from a document and not reinserted before the next time the event loop

reaches p934 step 1, implementations that are resource constrained are encouraged to take that opportunity to release all hardware resources (like video planes, networking resources, and data buffers) used by the p388 media element. (User agents still have to keep track of the playback position and so forth, though, in case playback is later restarted.)



✔ MDN

4.8.13 The map element p44 §

3

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Transparent p134 .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

name p443 p446 p124 p446 — Name of image map to reference from the usemap attribute

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLMapElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString name;

[SameObject] readonly attribute HTMLCollection areas;

};



The p443 p321 p444 p446 map element, in conjunction with an img element and any area element descendants, defines an image map. The element p124 represents its children.

The p124 name attribute gives the map a name so that it can be referenced . The attribute must be present and must have a non-empty

443

value with no p443 p443 ASCII whitespace . The value of the name attribute must not be equal to the value of the name attribute of another

map p443 p138 element in the same tree . If the id attribute is also specified, both attributes must have the same value.

For web developers (non-normative)

map p444 . areas

Returns an p444 p443 HTMLCollection of the area elements in the map .

The p443 p444 areas attribute must return an HTMLCollection rooted at the map element, whose filter matches only area elements.

The IDL attribute p95 name must reflect the content attribute of the same name.

Example

Image maps can be defined in conjunction with other content on the page, to ease maintenance. This example is of a page with an

image map at the top of the page and a corresponding set of text links at the bottom.





Babies™: Toys





Toys





ALT="Babies™ navigation menu. Select a department to go to its page." USEMAP="#NAV">



...





Clothes

|

Toys

|

Food

|

Books





✔ MDN





Categories :

Flow content .

Phrasing content .

Contexts in which this element can be used :

Where phrasing content is expected, but only if there is a map element ancestor.

Content model :

Nothing .

Tag omission in text/html :

No end tag.

Content attributes :

Global attributes

alt — Replacement text for use when images are not available

coords — Coordinates for the shape to be created in an image map



shape — The kind of shape to be created in an image map

href — Address of the hyperlink

target — Browsing context for hyperlink navigation

download — Whether to download the resource instead of navigating to it, and its file name if so

ping — URLs to ping

rel — Relationship between the location in the document containing the hyperlink and the destination resource

referrerpolicy — Referrer policy for fetches initiated by the element

Accessibility considerations :

If the element has an href attribute: for authors; for implementers.

Otherwise: for authors; for implementers.

DOM interface :

[Exposed=Window]

interface HTMLAreaElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString alt;

[CEReactions] attribute DOMString coords;

[CEReactions] attribute DOMString shape;

[CEReactions] attribute DOMString target;

[CEReactions] attribute DOMString download;

[CEReactions] attribute USVString ping;

[CEReactions] attribute DOMString rel;

[SameObject, PutForwards=value] readonly attribute DOMTokenList relList;

[CEReactions] attribute DOMString referrerPolicy;

// also has obsolete members

};

HTMLAreaElement includes HTMLHyperlinkElementUtils;



The area element represents either a hyperlink with some text and a corresponding area on an image map , or a dead area on an image map.

An area element with a parent node must have a map element ancestor.

If the area element has an href attribute, then the area element represents a hyperlink. In this case, the alt attribute must be present. It specifies the text of the hyperlink. Its value must be text that, when presented with the texts specified for the other hyperlinks of the image map, and with the alternative text of the image, but without the image itself, provides the user with the same kind of choice as the hyperlink would when used without its text but with its shape applied to the image. The alt attribute may be left blank if there is another area element in the same image map that points to the same resource and has a non-blank

alt attribute.

If the area element has no href attribute, then the area represented by the element cannot be selected, and the alt attribute must be omitted.

In both cases, the shape and coords attributes specify the area.

The shape attribute is an enumerated attribute. The following table lists the keywords defined for this attribute. The states given in the first cell of the rows with keywords give the states to which those keywords map. Some of the keywords are non-conforming, as noted in the last column.





The attribute may be omitted. The missing value default and invalid value default are the rectangle state.

The coords attribute must, if specified, contain a valid list of floating-point numbers. This attribute gives the coordinates for the shape described by the shape attribute. The processing for this attribute is described as part of the image map processing model.

In the circle state , area elements must have a coords attribute present, with three integers, the last of which must be non-

negative. The first integer must be the distance in CSS pixels from the left edge of the image to the center of the circle, the second integer must be the distance in CSS pixels from the top edge of the image to the center of the circle, and the third integer must be the radius of the circle, again in CSS pixels.

In the default state state, area elements must not have a coords attribute. (The area is the whole image.) In the polygon state , area elements must have a coords attribute with at least six integers, and the number of integers must be even. Each pair of integers must represent a coordinate given as the distances from the left and the top of the image in CSS pixels respectively, and all the coordinates together must represent the points of the polygon, in order.

In the rectangle state , area elements must have a coords attribute with exactly four integers, the first of which must be less than the third, and the second of which must be less than the fourth. The four points must represent, respectively, the distance from the left edge of the image to the left side of the rectangle, the distance from the top edge to the top side, the distance from the left edge to the right side, and the distance from the top edge to the bottom side, all in CSS pixels.

When user agents allow users to follow hyperlinks or download hyperlinks created using the area element, as described in the next section, the href , target , download , and ping attributes decide how the link is followed. The rel attribute may be used to indicate to the user the likely nature of the target resource before the user follows the link.

The target , download , ping , rel , and referrerpolicy attributes must be omitted if the href attribute is not present.

If the itemprop attribute is specified on an area element, then the href attribute must also be specified.

The activation behavior of area elements is to follow the hyperlink or download the hyperlink created by the area ✔ MDN

element, if any, and as determined by the download attribute and any expressed user preference.

The IDL attributes alt , coords , target , download , ping , and rel , each must reflect the respective content attributes of the same name.

✔ MDN

The IDL attribute shape must reflect the shape content attribute.

The IDL attribute relList must reflect the rel content attribute.

The IDL attribute referrerPolicy must reflect the referrerpolicy content attribute, limited to only known values.





4.8.15.1 Authoring



An image map allows geometric areas on an image to be associated with hyperlinks.

An image, in the form of an img element or an object element representing an image, may be associated with an image map (in the form of a map element) by specifying a usemap attribute on the img or object element. The usemap attribute, if specified, must be a valid hash-name reference to a map element.

Example

Consider an image that looks as follows:





If we wanted just the colored areas to be clickable, we could do it as follows:





Please select a shape:



alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a

yellow four-pointed star.">





href="yellow.html" alt="Yellow star.">





4.8.15.2 Processing model



If an img element or an object element representing an image has a usemap attribute specified, user agents must process it as follows:

1. Parse the attribute's value using the rules for parsing a hash-name reference to a map element, with the element as the

context node. This will return either an element (the map) or null.

2. If that returned null, then return. The image is not associated with an image map after all.

3. Otherwise, the user agent must collect all the area elements that are descendants of the map. Let those be the areas.

Having obtained the list of area elements that form the image map (the areas), interactive user agents must process the list in one of two ways.

If the user agent intends to show the text that the img element represents, then it must use the following steps.

Note

In user agents that do not support images, or that have images disabled, object elements cannot represent images, and thus

this section never applies (the fallback content is shown instead). The following steps therefore only apply to img elements.

1. Remove all the area elements in areas that have no href attribute.

2. Remove all the area elements in areas that have no alt attribute, or whose alt attribute's value is the empty

string, if there is another area element in areas with the same value in the href attribute and with a non-empty

alt attribute.

3. Each remaining area element in areas represents a hyperlink. Those hyperlinks should all be made available to the

user in a manner associated with the text of the img .

In this context, user agents may represent area and img elements with no specified alt attributes, or whose alt



attributes are the empty string or some other non-visible text, in an implementation-defined fashion intended to indicate the lack of suitable author-provided text.

If the user agent intends to show the image and allow interaction with the image to select hyperlinks, then the image must be associated with a set of layered shapes, taken from the area elements in areas , in reverse tree order (so the last specified area

element in the map is the bottom-most shape, and the first element in the map, in tree order, is the top-most shape).

Each area element in areas must be processed as follows to obtain a shape to layer onto the image:

1. Find the state that the element's shape attribute represents.

2. Use the rules for parsing a list of floating-point numbers to parse the element's coords attribute, if it is present, and let

the result be the coords list. If the attribute is absent, let the coords list be the empty list.

3. If the number of items in the coords list is less than the minimum number given for the area element's current state, as

per the following table, then the shape is empty; return.





4. Check for excess items in the coords list as per the entry in the following list corresponding to the shape attribute's state:

↪ Circle state

Drop any items in the list beyond the third.

↪ Default state

Drop all items in the list.

↪ Polygon state

Drop the last item if there's an odd number of items.

↪ Rectangle state

Drop any items in the list beyond the fourth.

5. If the shape attribute represents the rectangle state, and the first number in the list is numerically greater than the

third number in the list, then swap those two numbers around.

6. If the shape attribute represents the rectangle state, and the second number in the list is numerically greater than the

fourth number in the list, then swap those two numbers around.

7. If the shape attribute represents the circle state , and the third number in the list is less than or equal to zero, then the

shape is empty; return.

8. Now, the shape represented by the element is the one described for the entry in the list below corresponding to the state of

the shape attribute:

↪ Circle state

Let x be the first number in coords, y be the second number, and r be the third number.

The shape is a circle whose center is x CSS pixels from the left edge of the image and y CSS pixels from the top edge

of the image, and whose radius is r CSS pixels.

↪ Default state

The shape is a rectangle that exactly covers the entire image.

↪ Polygon state

Let x be the (2i)th entry in coords, and y be the (2i+1)th entry in coords (the first entry in coords being the one with index 0).

Let the coordinates be (x, y), interpreted in CSS pixels measured from the top left of the image, for all integer values of i from 0 to (N/2)-1, where N is the number of items in coords.

The shape is a polygon whose vertices are given by the coordinates, and whose interior is established using the even-



odd rule. [GRAPHICS]

↪ Rectangle state

Let x be the first number in coords, y be the second number, x be the third number, and y be the fourth number.

The shape is a rectangle whose top-left corner is given by the coordinate (x, y) and whose bottom right corner is

given by the coordinate (x, y), those coordinates being interpreted as CSS pixels from the top left corner of the image.

For historical reasons, the coordinates must be interpreted relative to the displayed image after any stretching caused by the

CSS 'width' and 'height' properties (or, for non-CSS browsers, the image element's width and height attributes — CSS browsers map those attributes to the aforementioned CSS properties).

Note

Browser zoom features and transforms applied using CSS or SVG do not affect the coordinates.

Pointing device interaction with an image associated with a set of layered shapes per the above algorithm must result in the relevant user interaction events being first fired to the top-most shape covering the point that the pointing device indicated, if any, or to the image element itself, if there is no shape covering that point. User agents may also allow individual area elements representing

hyperlinks to be selected and activated (e.g. using a keyboard).

Note

Because a map element (and its area elements) can be associated with multiple img and object elements, it is

possible for an area element to correspond to multiple focusable areas of the document.

Image maps are live; if the DOM is mutated, then the user agent must act as if it had rerun the algorithms for image maps.





The MathML math element falls into the embedded content , phrasing content , flow content , and palpable content categories for the purposes of the content models in this specification.

When the MathML annotation-xml element contains elements from the HTML namespace , such elements must all be flow content.

When the MathML token elements (mi, mo, mn, ms, and mtext) are descendants of HTML elements, they may contain phrasing

content elements from the HTML namespace.

User agents must handle text other than inter-element whitespace found in MathML elements whose content models do not allow straight text by pretending for the purposes of MathML content models, layout, and rendering that the text is actually wrapped in a

MathML mtext element. (Such text is not, however, conforming.) User agents must act as if any MathML element whose contents does not match the element's content model was replaced, for the purposes of MathML layout and rendering, by a MathML merror element containing some appropriate error message.

The semantics of MathML elements are defined by MathML and other applicable specifications . [MATHML]

Example

Here is an example of the use of MathML in an HTML document:





The quadratic formula





The quadratic formula





x

449

=





− b

±



b 2

−

4 a c





2 a





✔ MDN

4.8.17 SVG p45 §

0

The p133 p133 p132 p134 SVG svg element falls into the embedded content , phrasing content , flow content , and palpable content categories for the purposes of the content models in this specification.

When the p132 SVG foreignObject element contains elements from the HTML namespace , such elements must all be flow content.

The content model for the p133 SVG title element inside HTML documents is phrasing content. (This further constrains the requirements given in SVG 2.) The semantics of SVG elements are defined by p65 p1281 SVG 2 and other applicable specifications . [SVG]



For web developers (non-normative)

doc p450 = iframe . getSVGDocument()

doc p450 = embed . getSVGDocument ()

doc p450 = object . getSVGDocument ()

Returns the p115 p362 p369 p373 Document object, in the case of iframe , embed , or object elements being used to embed SVG.

The getSVGDocument() method must run the following steps:

1. Let p819 document be this element's content document.

2. If p886 document is non-null and was created by the page load processing model for XML files section because the computed

type of the resource p876 p1273 in the navigate algorithm was image/svg+xml, then return document.

3. Return null.



4.8.18 Dimension attributes p45 §

0

Author requirements p321 p362 p369 p373 p380 : The width and height attributes on img , iframe , embed , object , video, and, when their

type p496 p519 p494 attribute is in the Image Button state, input elements may be specified to give the dimensions of the visual content of the element (the width and height respectively, relative to the nominal direction of the output medium), in CSS pixels. The attributes, if

specified, must have values that are p69 valid non-negative integers.

The specified dimensions given may differ from the dimensions specified in the resource itself, since the resource may have a

450

resolution that differs from the CSS pixel resolution. (On screens, CSS pixels have a resolution of 96ppi, but in general the CSS pixel resolution depends on the reading distance.) If both attributes are specified, then one of the following statements must be true:

• specified width- 0.5 ≤ specified height * target ratio ≤ specified width + 0.5

• specified height- 0.5 ≤ specified width / target ratio ≤ specified height + 0.5

• specified height = specified width = 0

The target ratio is the ratio of the intrinsic width to the intrinsic height in the resource. The specified width and specified height are the values of the p450 p450 width and height attributes respectively.

The two attributes must be omitted if the resource in question does not have both an intrinsic width and an intrinsic height.

If the two attributes are both zero, it indicates that the element is not intended for the user (e.g. it might be a part of a service to count page views).

Note

The dimension attributes are not intended to be used to stretch the image.

p1208 ✔ MDN

User agent requirements: User agents are expected to use these attributes as hints for the rendering .

The p362 p369 p373 p380 p95 width and height IDL attributes on the iframe , embed , object , and video elements must reflect the respective content attributes of the same name.

Note

For p362 p369 p373 p380 iframe , embed , and object the IDL attributes are DOMString ; for video the IDL attributes are unsigned long.



Note

The corresponding IDL attributes for p325 p500 img and input elements are defined in those respective elements' sections, as they are

slightly more specific to those elements' other behaviors.



4.9 Tabular data p45 §

1 ✔ MDN

4.9.1 The table element p45 §

1

Categories p129: ✔ MDN

Flow content p132 .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p132 flow content is expected.

Content model p129:

In this order: optionally a p459 p460 caption element, followed by zero or more colgroup elements, followed optionally by a

thead p463 p462 p465 element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a

tfoot p464 p134 element, optionally intermixed with one or more script-supporting elements .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.



451

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute HTMLTableCaptionElement? caption;

HTMLTableCaptionElement createCaption();

[CEReactions] undefined deleteCaption();

[CEReactions] attribute HTMLTableSectionElement? tHead;

HTMLTableSectionElement createTHead();

[CEReactions] undefined deleteTHead();

[CEReactions] attribute HTMLTableSectionElement? tFoot;

HTMLTableSectionElement createTFoot();

[CEReactions] undefined deleteTFoot();

[SameObject] readonly attribute HTMLCollection tBodies;

HTMLTableSectionElement createTBody();

[SameObject] readonly attribute HTMLCollection rows;

HTMLTableRowElement insertRow(optional long index = -1);

[CEReactions] undefined deleteRow(long index);

// also has obsolete members

};



The p451 p124 p471 table element represents data with more than one dimension, in the form of a table .

The p451 p471 table element takes part in the table model . Tables have rows, columns, and cells given by their descendants. The rows and columns form a grid; a table's cells must completely cover that grid without overlap.

Note

Precise rules for determining whether this conformance requirement is met are described in the description of the p471 table model.

Authors are encouraged to provide information describing how to interpret complex tables. Guidance on how to provide such

information p456 is given below.

Tables must not be used as layout aids. Historically, some web authors have misused tables in HTML as a way to control their page layout. This usage is non-conforming, because tools attempting to extract tabular data from such documents would obtain very confusing results. In particular, users of accessibility tools like screen readers are likely to find it very difficult to navigate pages with tables used for layout.

Note

There are a variety of alternatives to using HTML tables for layout, primarily using CSS positioning and the CSS table model.

[CSS] p1275



Tables can be complicated to understand and navigate. To help users with this, user agents should clearly delineate cells in a table from each other, unless the user agent has classified the table as a (non-conforming) layout table.

Note

Authors and implementers are encouraged to consider using some of the p459 table design techniques described below to make

tables easier to navigate for users.

User agents, especially those that do table analysis on arbitrary content, are encouraged to find heuristics to determine which tables actually contain data and which are merely being used for layout. This specification does not define a precise heuristic, but the following are suggested as possible indicators:

452





Feature Indication


The use of the p63 role attribute with the value presentation Probably a layout table

The use of the non-conforming p1228 border attribute with the non-conforming Probably a layout table value 0

The use of the non-conforming p1228 p1228 cellspacing and cellpadding Probably a layout table attributes with the value 0

The use of p459 p463 p468 caption , thead , or th elements Probably a non-layout table

The use of the p470 p468 headers and scope attributes Probably a non-layout table

The use of the non-conforming p1228 border attribute with a value other than 0 Probably a non-layout table Explicit visible borders set using CSS Probably a non-layout table

The use of the p1226 summary attribute Not a good indicator (both layout and non-layout tables have historically been

given this attribute)



Note

It is quite possible that the above suggestions are wrong. Implementors are urged to provide feedback elaborating on their

experiences with trying to create a layout table detection heuristic.

If a p451 p1226 table element has a (non-conforming) summary attribute, and the user agent has not classified the table as a layout table, the user agent may report the contents of that attribute to the user.



For web developers (non-normative)

table p454 . caption [ = value ]

Returns the table's p459 caption element.

Can be set, to replace the p459 caption element.

caption p454 = table . createCaption ()

Ensures the table has a p459 caption element, and returns it.

table p454 . deleteCaption()

Ensures the table does not have a p459 caption element.

table p454 . tHead [ = value ]

Returns the table's p463 thead element.

Can be set, to replace the p463 p463 thead element. If the new value is not a thead element, throws a "HierarchyRequestError"

DOMException.

thead p454 = table . createTHead()

Ensures the table has a p463 thead element, and returns it.

table p454 . deleteTHead ()

Ensures the table does not have a p463 thead element.

table p454 . tFoot [ = value ]

Returns the table's p464 tfoot element.

Can be set, to replace the p464 p464 tfoot element. If the new value is not a tfoot element, throws a "HierarchyRequestError"

DOMException.

tfoot p454 = table . createTFoot()

Ensures the table has a p464 tfoot element, and returns it.

table p454 . deleteTFoot ()

Ensures the table does not have a p464 tfoot element.

table p454 . tBodies

Returns an p462 HTMLCollection of the tbody elements of the table.

tbody p454 = table . createTBody()

Creates a p462 tbody element, inserts it into the table, and returns it.

table p454 . rows

Returns an p465 HTMLCollection of the tr elements of the table.

453

tr p455 = table . insertRow( [ index ] )

Creates a p465 p462 tr element, along with a tbody if required, inserts them into the table at the position given by the argument,

and returns the p465 tr .

The position is relative to the rows in the table. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the table.

If the given position is less than −1 or greater than the number of rows, throws an "IndexSizeError" DOMException.

table p455 . deleteRow(index)

Removes the p465 tr element with the given position in the table.

The position is relative to the rows in the table. The index −1 is equivalent to deleting the last row of the table. If the given position is less than −1 or greater than the index of the last row, or if there are no rows, throws an

"IndexSizeError" DOMException.



In all of the following attribute and method definitions, when an element is to be table-created, that means to create an element ✔ MDN p451 given the table element's node document , the given local name, and the HTML namespace .

The p459 p451 caption IDL attribute must return, on getting, the first caption element child of the table element, if any, or null otherwise. On setting, the first p459 p451 caption element child of the table element, if any, must be removed, and the new value, if not ✔ MDN

null, must be inserted as the first node of the p451 table element.

The p459 p451 createCaption() method must return the first caption element child of the table element, if any; otherwise a new ✔ MDN

caption p459 p454 p451 element must be table-created , inserted as the first node of the table element, and then returned.

The p459 ✔ MDN p451 deleteCaption() method must remove the first caption element child of the table element, if any.

The p463 p451 tHead IDL attribute must return, on getting, the first thead element child of the table element, if any, or null otherwise. On setting, if the new value is null or a p463 p463 p451 thead element, the first thead element child of the table element, if any, must be removed, and the new value, if not null, must be inserted immediately before the first element in the p451 table element that is neither a p459 p460 caption element nor a colgroup element, if any, or at the end of the table if there are no such elements. If the new value is ✔ MDN

neither null nor a p463 thead element, then a "HierarchyRequestError" DOMException must be thrown instead.

The p463 p451 p463 createTHead() method must return the first thead element child of the table element, if any; otherwise a new thead

element must be p454 p451 table-created and inserted immediately before the first element in the table element that is neither a

caption p459 p460 element nor a colgroup element, if any, or at the end of the table if there are no such elements, and then that new ✔ MDN element must be returned.

The p463 ✔ MDN p451 deleteTHead() method must remove the first thead element child of the table element, if any.

The p464 p451 tFoot IDL attribute must return, on getting, the first tfoot element child of the table element, if any, or null otherwise. On setting, if the new value is null or a p464 p464 p451 tfoot element, the first tfoot element child of the table element, if any, must be removed, and the new value, if not null, must be inserted at the end of the table. If the new value is neither null nor a p464 tfoot ✔ MDN

element, then a "HierarchyRequestError" DOMException must be thrown instead.

The p464 p451 p464 createTFoot() method must return the first tfoot element child of the table element, if any; otherwise a new tfoot ✔ MDN

element must be p454 table-created and inserted at the end of the table, and then that new element must be returned.

✔ MDN

The p464 p451 deleteTFoot() method must remove the first tfoot element child of the table element, if any.

The p451 p462 tBodies attribute must return an HTMLCollection rooted at the table node, whose filter matches only tbody elements that are children of the p451 table element.

The p454 p462 p462 createTBody() method must table-create a new tbody element, insert it immediately after the last tbody element child in the p451 p451 p451 p462 table element, if any, or at the end of the table element if the table element has no tbody element children, and ✔ MDN

then must return the new p462 tbody element.

The p451 p465 rows attribute must return an HTMLCollection rooted at the table node, whose filter matches only tr elements that are either children of the p451 p463 p462 p464 table element, or children of thead , tbody , or tfoot elements that are themselves children of the

table p451 p463 element. The elements in the collection must be ordered such that those elements whose parent is a thead are included first, in p451 p462 tree order , followed by those elements whose parent is either a table or tbody element, again in tree order, followed ✔ MDN

finally by those elements whose parent is a p464 tfoot element, still in tree order.

454

The behavior of the insertRow(index) method depends on the state of the table. When it is called, the method must act as required by the first item in the following list of conditions that describes the state of the table and the index argument:

↪ p454 If index is less than −1 or greater than the number of elements in rows collection:

The method must throw an "IndexSizeError" DOMException.

↪ p454 p451 p462 If the rows collection has zero elements in it, and the table has no tbody elements in it:

The method must p454 p462 p454 p465 p465 table-create a tbody element, then table-create a tr element, then append the tr element

to the p462 p462 p451 p465 tbody element, then append the tbody element to the table element, and finally return the tr element.

↪ p454 If the rows collection has zero elements in it:

The method must p454 p465 p462 p465 table-create a tr element, append it to the last tbody element in the table, and return the tr element.

↪ p454 If index is −1 or equal to the number of items in rows collection:

The method must p454 p465 p465 p454 table-create a tr element, and append it to the parent of the last tr element in the rows

collection. Then, the newly created p465 tr element must be returned.

↪ Otherwise:

The method must p454 p465 p465 p454 table-create a tr element, insert it immediately before the index th tr element in the rows

collection, in the same parent, and finally must return the newly created p465 tr element.

When the ✔ MDN deleteRow( index ) method is called, the user agent must run the following steps:

1. If p454 index is less than −1 or greater than or equal to the number of elements in the rows collection, then throw an

"IndexSizeError" DOMException.

2. If p454 p454 index is −1, then remove the last element in the rows collection from its parent, or do nothing if the rows collection

is empty.

3. Otherwise, p454 remove the index th element in the rows collection from its parent.

Example

Here is an example of a table being used to mark up a Sudoku puzzle. Observe the lack of headers, which are not necessary in

such a table.





Today's Sudoku





1 3 6 4 7 9





2 9 1





7 6





2 4 3 9 8





5 9 7 1





6 5 2





7





9 8 2 5





455

4.9.1.1 Techniques for describing tables p45 §

6

For tables that consist of more than just a grid of cells with headers in the first row and headers in the first column, and for any table in general where the reader might have difficulty understanding the content, authors should include explanatory information introducing the table. This information is useful for all users, but is especially useful for users who cannot see the table, e.g. users of screen readers.

Such explanatory information should introduce the purpose of the table, outline its basic cell structure, highlight any trends or patterns, and generally teach the user how to use the table.

For instance, the following table:

Characteristics with positive and

negative sides

Negative Characteristic Positive

Sad Mood Happy

Failing Grade Passing

...might benefit from a description explaining the way the table is laid out, something like "Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column".

There are a variety of ways to include this information, such as: In prose, surrounding the table

Example



In the following table, characteristics are given in the second column, with the negative side in the left column and the positive side in the right column.





Characteristics with positive and negative sides Negative



Characteristic



Positive





Sad



Mood



Happy





Failing



Grade



Passing





In the table's p459 caption

Example





Characteristics with positive and negative sides.

Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column.





Negative



Characteristic

456



Positive





Sad



Mood



Happy





Failing



Grade



Passing





In the table's p459 p605 caption , in a details element

Example





Characteristics with positive and negative sides.





Help



Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column.





Negative



Characteristic



Positive





Sad



Mood



Happy





Failing



Grade



Passing





Next to the table, in the same p233 figure

Example





Characteristics with positive and negative sides Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column.





Negative



Characteristic



Positive





Sad

457



Mood



Happy





Failing



Grade



Passing





Next to the table, in a p233 p236 figure 's figcaption

Example





Characteristics with positive and negative sides

Characteristics are given in the second column, with the negative side in the left column and the positive side in the right column.





Negative



Characteristic



Positive





Sad



Mood



Happy





Failing



Grade



Passing





Authors may also use other techniques, or combinations of the above techniques, as appropriate.

The best option, of course, rather than writing a description explaining the way the table is laid out, is to adjust the table such that no explanation is needed.

Example

In the case of the table used in the examples above, a simple rearrangement of the table so that the headers are on the top and

left sides removes the need for an explanation as well as removing the need for the use of p470 headers attributes:





Characteristics with positive and negative sides Characteristic



Negative



Positive





Mood



Sad



Happy

458





Grade



Failing



Passing





4.9.1.2 Techniques for table design p45 §

9

Good table design is key to making tables more readable and usable.

In visual media, providing column and row borders and alternating row backgrounds can be very effective to make complicated tables more readable.

For tables with large volumes of numeric content, using monospaced fonts can help users see patterns, especially in situations where a user agent does not render the borders. (Unfortunately, for historical reasons, not rendering borders on tables is a common default.) In speech media, table cells can be distinguished by reporting the corresponding headers before reading the cell's contents, and by allowing users to navigate the table in a grid fashion, rather than serializing the entire contents of the table in source order.

Authors are encouraged to use CSS to achieve these effects.

User agents are encouraged to render tables using these techniques whenever the page does not use CSS and the table is not classified as a layout table.



✔ MDN

4.9.2 The caption element p45 §

9

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As the first element child of a p451 table element.

Content model p129:

Flow content p132 p451 , but with no descendant table elements.

Tag omission in text/html p129 :

A p459 p1067 p459 caption element's end tag can be omitted if the caption element is not immediately followed by ASCII whitespace

or a p1075 comment.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableCaptionElement : HTMLElement {

[HTMLConstructor] constructor();

// also has obsolete members

};



The p459 p124 p451 p451 caption element represents the title of the table that is its parent, if it has a parent and that is a table element.

The p459 p471 caption element takes part in the table model.

459

When a p451 p233 p236 p459 table element is the only content in a figure element other than the figcaption , the caption element should be omitted in favor of the p236 figcaption .

A caption can introduce context for a table, making it significantly easier to understand.

Example

Consider, for instance, the following table:

1 2 3 4 5 6

1 2 3 4 5 6 7

2 3 4 5 6 7 8

3 4 5 6 7 8 9

4 5 6 7 8 9 10

5 6 7 8 9 1011

6 7 8 9 101112

In the abstract, this table is not clear. However, with a caption giving the table's number (for p124 reference in the main prose) and

explaining its use, it makes more sense:





Table 1.



This table shows the total score obtained from rolling two six-sided dice. The first row represents the value of the first die, the first column the value of the second die. The total is given in the cell that corresponds to the values of the two dice.





School auction sign-up sheet Name



Product



Picture



Price





Your name here



What are you selling?



Link to a picture



Your reserve price





Ms Danus



Doughnuts



$45





✔ MDN

4.9.7 The tfoot element p46 §

4

Categories p129:

None.

Contexts in which this element can be used p129 :

As a child of a p451 p459 p460 p463 p462 p465 table element, after any caption , colgroup , thead , tbody , and tr elements, but only if there

are no other p464 p451 tfoot elements that are children of the table element.

Content model p129:

Zero or more p465 p134 tr and script-supporting elements.

Tag omission in text/html p129 :

A p464 p1067 tfoot element's end tag can be omitted if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p462 p462 HTMLTableSectionElement , as defined for tbody elements.

The p464 p124 p471 p471 p451 tfoot element represents the block of rows that consist of the column summaries (footers) for the parent table

464

element, if the p464 p451 tfoot element has a parent and it is a table .

The p464 p471 tfoot element takes part in the table model .



✔ MDN

4.9.8 The tr element p46 §

5

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As a child of a p463 thead element.

As a child of a p462 tbody element.

As a child of a p464 tfoot element.

As a child of a p451 p459 p460 p463 p462 table element, after any caption , colgroup , and thead elements, but only if there are no tbody

elements that are children of the p451 table element.

Content model p129:

Zero or more p466 p468 p134 td , th , and script-supporting elements.

Tag omission in text/html p129 :

A p465 p1067 p465 p465 tr element's end tag can be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableRowElement : HTMLElement {

[HTMLConstructor] constructor();

readonly attribute long rowIndex;

readonly attribute long sectionRowIndex;

[SameObject] readonly attribute HTMLCollection cells;

HTMLTableCellElement insertCell(optional long index = -1);

[CEReactions] undefined deleteCell(long index);

// also has obsolete members

};



The p465 p124 p471 p471 p471 tr element represents a row of cells in a table.

The p465 p471 tr element takes part in the table model.

For web developers (non-normative)

tr p466 . rowIndex

Returns the position of the row in the table's p454 rows list.

Returns −1 if the element isn't in a table.

tr p466 . sectionRowIndex

Returns the position of the row in the table section's p463 rows list.

Returns −1 if the element isn't in a table section.

tr p466 . cells

Returns an p466 p468 HTMLCollection of the td and th elements of the row.

465

cell p466 = tr . insertCell( [ index ] )

Creates a p466 p466 td element, inserts it into the table row at the position given by the argument, and returns the td . The position is relative to the cells in the row. The index −1, which is the default if the argument is omitted, is equivalent to inserting at the end of the row.

If the given position is less than −1 or greater than the number of cells, throws an "IndexSizeError" DOMException.

tr p466 . deleteCell(index)

Removes the p466 p468 td or th element with the given position in the row.

The position is relative to the cells in the row. The index −1 is equivalent to deleting the last cell of the row. If the given position is less than −1 or greater than the index of the last cell, or if there are no cells, throws an

"IndexSizeError" DOMException.

The p451 p462 p463 p464 rowIndex attribute must, if this element has a parent table element, or a parent tbody , thead , or tfoot element and a p451 p465 p451 p454 grandparent table element, return the index of this tr element in that table element's rows collection. If there is no such p451 table element, then the attribute must return −1.

The p451 p462 p463 p464 sectionRowIndex attribute must, if this element has a parent table , tbody , thead , or tfoot element, return the index of the p465 p452 p454 tr element in the parent element's rows collection (for tables, that's HTMLTableElement 's rows collection; for table sections, that's p462 p463 HTMLTableSectionElement 's rows collection). If there is no such parent element, then the attribute must return −1.

The p465 p466 p468 cells attribute must return an HTMLCollection rooted at this tr element, whose filter matches only td and th elements ✔ MDN

that are children of the p465 tr element.

The insertCell(index) method must act as follows:

1. If p466 index is less than −1 or greater than the number of elements in the cells collection, then throw an "IndexSizeError"

DOMException.

2. Let p465 p466 table cell be the result of creating an element given this tr element's node document , td , and the HTML

namespace.

3. If p466 p465 index is equal to −1 or equal to the number of items in cells collection, then append table cell to this tr element.

4. Otherwise, p465 p466 p468 insert table cell as a child of this tr element, immediately before the index th td or th element in the

cells p466 collection.

5. Return table cell.

The deleteCell(index) method must act as follows:

1. If p466 index is less than −1 or greater than or equal to the number of elements in the cells collection, then throw an

"IndexSizeError" DOMException.

2. If p466 p466 index is −1, then remove the last element in the cells collection from its parent, or do nothing if the cells

collection is empty.

3. Otherwise, p466 remove the index th element in the cells collection from its parent.



✔ MDN

4.9.9 The td element p46 §

6

Categories p129: ✔ MDN

Sectioning root p200 .

Contexts in which this element can be used p129 :

As a child of a p465 tr element.

Content model p129:

Flow content p132 .

466

Tag omission in text/html p129 :

A p466 p1067 p466 p466 p468 td element's end tag can be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

colspan p470 — Number of columns that the cell is to span

rowspan p470 — Number of rows that the cell is to span

headers p470 — The header cells for this cell

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTableCellElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute unsigned long colSpan;

[CEReactions] attribute unsigned long rowSpan;

[CEReactions] attribute DOMString headers;

readonly attribute long cellIndex;

[CEReactions] attribute DOMString scope; // only conforming for th elements

[CEReactions] attribute DOMString abbr; // only conforming for th elements

// also has obsolete members

};

The p467 p468 HTMLTableCellElement interface is also used for th elements.



The p466 p124 p471 td element represents a data cell in a table.

The p466 p470 p470 p470 p471 td element and its colspan , rowspan , and headers attributes take part in the table model.

User agents, especially in non-visual environments or where displaying the table as a 2D grid is impractical, may give the user context for the cell when rendering the contents of a cell; for instance, giving its position in the p471 table model, or listing the cell's header cells (as determined by the p474 algorithm for assigning header cells ). When a cell's header cells are being listed, user agents may use the value of p469 abbr attributes on those header cells, if any, instead of the contents of the header cells themselves.

Example

In this example, we see a snippet of a web application consisting of a grid of editable cells (essentially a simple spreadsheet). One

of the cells has been configured to show the sum of the cells above it. Three have been marked as headings, which use p468 th

elements instead of p466 td elements. A script would attach event handlers to these elements to maintain the total.





467





✔ MDN

4.9.10 The th element p46 §

8

Categories p129:

None.

Contexts in which this element can be used p129 :

As a child of a p465 tr element.

Content model p129:

Flow content p132 p195 p196 p132 p133 , but with no header , footer , sectioning content , or heading content descendants.

Tag omission in text/html p129 :

A p468 p1067 p468 p466 p468 th element's end tag can be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

colspan p470 — Number of columns that the cell is to span

rowspan p470 — Number of rows that the cell is to span

headers p470 — The header cells for this cell

scope p468 — Specifies which cells the header cell applies to

abbr p469 — Alternative label to use for the header cell when referencing the cell in other contexts

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p467 p466 HTMLTableCellElement , as defined for td elements.

The p468 p124 p471 th element represents a header cell in a table.

The p468 p468 p68 th element may have a scope content attribute specified. The scope attribute is an enumerated attribute with five states, four of which have explicit keywords: The row keyword, which maps to the row state

The row state means the header cell applies to some of the subsequent cells in the same row(s).

The col keyword, which maps to the column state

The column state means the header cell applies to some of the subsequent cells in the same column(s).

The rowgroup keyword, which maps to the row group state

The p468 p468 row group state means the header cell applies to all the remaining cells in the row group. A th element's scope attribute

must not be in the p468 p471 row group state if the element is not anchored in a row group .



468

The colgroup keyword, which maps to the column group state

The p468 p468 column group state means the header cell applies to all the remaining cells in the column group. A th element's scope

attribute must not be in the p469 p471 column group state if the element is not anchored in a column group.

The auto state

The auto state makes the header cell apply to a set of cells selected based on context.

The p468 p68 p68 scope attribute's missing value default and invalid value default are the auto state.

The p468 th element may have an abbr content attribute specified. Its value must be an alternative label for the header cell, to be used when referencing the cell in other contexts (e.g. when describing the header cells that apply to a data cell). It is typically an abbreviated form of the full header cell, but can also be an expansion, or merely a different phrasing.

The p468 p470 p470 p470 p468 p471 th element and its colspan , rowspan , headers , and scope attributes take part in the table model .

Example

The following example shows how the p468 p468 scope attribute's rowgroup value affects which data cells a header cell applies to.

Here is a markup fragment showing a table:





ID Measurement Average Maximum





Cats





93 Legs 3.5 4





10 Tails 1 1





English speakers





32 Legs 2.67 4





35 Tails 0.33 1





This would result in the following table:

ID Measurement Average Maximum

Cats

93 Legs 3.5 4

10 Tails 1 1

English speakers

32 Legs 2.67 4

35 Tails 0.33 1

The headers in the first row all apply directly down to the rows in their column.

The headers with the explicit p468 scope attributes apply to all the cells in their row group other than the cells in the first column.

The remaining headers apply just to the cells to the right of them.



469



4.9.11 Attributes common to p466 p468 p47 td and th elements §

0

The p466 p468 p69 td and th elements may have a colspan content attribute specified, whose value must be a valid non-negative integer greater than zero and less than or equal to 1000.

The p466 p468 td and th elements may also have a rowspan content attribute specified, whose value must be a valid non-negative

integer p69 less than or equal to 65534. For this attribute, the value zero means that the cell is to span all the remaining rows in the row group.

These attributes give the number of columns and rows respectively that the cell is to span. These attributes must not be used to overlap cells, as described in the description of the p471 table model.



The p466 p468 p470 td and th element may have a headers content attribute specified. The headers attribute, if specified, must contain a string consisting of an p87 unordered set of unique space-separated tokens, none of which are identical to another token and each of which must have the value of an p468 p471 p466 p468 ID of a th element taking part in the same table as the td or th element (as defined by the p471 table model ).

A p468 p466 p468 p471 p470 th element with ID id is said to be directly targeted by all td and th elements in the same table that have headers

attributes whose values include as one of their tokens the p468 p468 p466 ID id . A th element A is said to be targeted by a th or td element B if either A is directly targeted by B or if there exists an element C that is itself targeted by the element B and A is directly targeted by C.

A p468 th element must not be targeted by itself.

The p470 p470 p470 p471 colspan , rowspan , and headers attributes take part in the table model .



For web developers (non-normative)

cell p471 . cellIndex

Returns the position of the cell in the row's p466 cells list. This does not necessarily correspond to the x-position of the cell in the table, since earlier cells might cover multiple rows or columns.

Returns −1 if the element isn't in a row.

The p95 p470 p96 colSpan IDL attribute must reflect the colspan content attribute. It is clamped to the range [1, 1000], and its default value is 1.

The p95 p470 p96 rowSpan IDL attribute must reflect the rowspan content attribute. It is clamped to the range [0, 65534], and its default value is 1.

The p95 headers IDL attribute must reflect the content attribute of the same name.

470

The p465 cellIndex IDL attribute must, if the element has a parent tr element, return the index of the cell's element in the parent element's p466 cells collection. If there is no such parent element, then the attribute must return −1.

The p95 p95 scope IDL attribute must reflect the content attribute of the same name, limited to only known values.

The p95 abbr IDL attribute must reflect the content attribute of the same name.



4.9.12 Processing model p47 §

1

The various table elements and their content attributes together define the table model.

A table consists of cells aligned on a two-dimensional grid of slots with coordinates (x, y). The grid is finite, and is either empty or has one or more slots. If the grid has one or more slots, then the x coordinates are always in the range 0 ≤ x < xwidth, and the y coordinates are always in the range 0 ≤ y < y height. If one or both of xwidth and yheight are zero, then the table is empty (has no slots).

Tables correspond to p451 table elements.

A cell is a set of slots anchored at a slot (cellx, celly), and with a particular width and height such that the cell covers all the slots with coordinates (x, y) where cellx ≤ x < cellx+width and celly ≤ y < celly+height. Cells can either be data cells or header cells. Data cells correspond to p466 p468 td elements, and header cells correspond to th elements. Cells of both types can have zero or more associated header cells.

It is possible, in certain error cases, for two cells to occupy the same slot.

A p465 row is a complete set of slots from x =0 to x = x width-1, for a particular value of y . Rows usually correspond to tr elements, though a p471 p471 p471 row group can have some implied rows at the end in some cases involving cells spanning multiple rows.

A p461 column is a complete set of slots from y =0 to y = y height-1, for a particular value of x . Columns can correspond to col elements.

In the absence of p461 col elements, columns are implied.

A p471 row group is a set of rows anchored at a slot (0, groupy) with a particular height such that the row group covers all the slots with coordinates ( p462 p463 p464 x , y ) where 0 ≤ x < x width and group y ≤ y < group y + height . Row groups correspond to tbody , thead , and tfoot

elements. Not every row is necessarily in a row group.

A p471 column group is a set of columns anchored at a slot (groupx, 0) with a particular width such that the column group covers all the slots with coordinates ( p460 x , y ) where group x ≤ x < group x + width and 0 ≤ y < y height . Column groups correspond to colgroup elements. Not every column is necessarily in a column group.

Row groups p471 p471 cannot overlap each other. Similarly, column groups cannot overlap each other.

A p471 p471 cell cannot cover slots that are from two or more row groups. It is, however, possible for a cell to be in multiple column

groups p471 p471 p471 . All the slots that form part of one cell are part of zero or one row groups and zero or more column groups .

In addition to p471 p471 p471 p471 p471 p471 p459 cells , columns , rows , row groups , and column groups , tables can have a caption element associated with them. This gives the table a heading, or legend.

A p451 table model error is an error with the data represented by table elements and their descendants. Documents must not have table model errors.



4.9.12.1 Forming a table p47 §

1

To determine which elements correspond to which slots in a p471 p451 table associated with a table element, to determine the dimensions of the table ( p471 x width and y height ), and to determine if there are any table model errors, user agents must use the following algorithm:

1. Let xwidth be zero.

2. Let yheight be zero.

3. Let p464 p464 pending tfoot elements be a list of tfoot elements, initially empty.

4. Let p471 p451 the table be the table represented by the table element. The xwidth and yheight variables give the table's

dimensions. The table is initially empty.

471

5. If the p451 table element has no children elements, then return the table (which will be empty).

6. Associate the first p459 p451 caption element child of the table element with the table. If there are no such children, then it has

no associated p459 caption element.

7. Let the p451 current element be the first element child of the table element.

If a step in this algorithm ever requires the current element to be advanced to the next child of the table when there is no such next child, then the user agent must jump to the step labeled end, near the end of this algorithm.

8. While the p472 current element is not one of the following elements, advance the current element to the next child of the

table p451 :

◦ p460 colgroup

◦ p463 thead

◦ p462 tbody

◦ p464 tfoot

◦ p465 tr

9. If the p460 current element is a colgroup , follow these substeps:

1. Column groups: Process the current element according to the appropriate case below:

↪ p461 If the current element has any col element children

Follow these steps:

1. Let xstart have the value of xwidth.

2. Let the p461 p460 current column be the first col element child of the colgroup element.

3. p461 p461 Columns : If the current column col element has a span attribute, then parse its value using

the p69 rules for parsing non-negative integers.

If the result of parsing the value is not an error or zero, then let span be that value.

Otherwise, if the p461 p461 col element has no span attribute, or if trying to parse the attribute's value resulted in an error or zero, then let span be 1.

If span is greater than 1000, let it be 1000 instead.

4. Increase xwidth by span.

5. Let the last p471 p461 span columns in the table correspond to the current column col element.

6. If p461 p460 current column is not the last col element child of the colgroup element, then let the

current column p461 p460 be the next col element child of the colgroup element, and return to the step labeled columns.

7. Let all the last p471 p471 columns in the table from x= x start to x= x width -1 form a new column group ,

anchored at the slot ( p460 x start , 0), with width x width-x start , corresponding to the colgroup element.

↪ p461 If the current element has no col element children

1. If the p460 p461 colgroup element has a span attribute, then parse its value using the rules for

parsing non-negative integers p69.

If the result of parsing the value is not an error or zero, then let span be that value.

Otherwise, if the p460 p461 colgroup element has no span attribute, or if trying to parse the attribute's value resulted in an error or zero, then let span be 1.

If span is greater than 1000, let it be 1000 instead.

2. Increase xwidth by span.

3. Let the last p471 p471 span columns in the table form a new column group, anchored at the slot

( p460 x width-span , 0), with width span , corresponding to the colgroup element.

2. p472 p451 Advance the current element to the next child of the table.

3. While the p472 current element is not one of the following elements, advance the current element to the next child

472

of the p451 table :

▪ p460 colgroup

▪ p463 thead

▪ p462 tbody

▪ p464 tfoot

▪ p465 tr

4. If the p460 current element is a colgroup element, jump to the step labeled column groups above.

10. Let ycurrent be zero.

11. Let the list of downward-growing cells be an empty list.

12. p472 Rows : While the current element is not one of the following elements, advance the current element to the next child of

the p451 table:

◦ p463 thead

◦ p462 tbody

◦ p464 tfoot

◦ p465 tr

13. If the p465 p473 p472 current element is a tr , then run the algorithm for processing rows , advance the current element to the next

child of the p451 table , and return to the step labeled rows.

14. Run the p473 algorithm for ending a row group .

15. If the p464 p464 p472 current element is a tfoot , then add that element to the list of pending tfoot elements , advance the current

element p451 to the next child of the table , and return to the step labeled rows.

16. The p463 p462 current element is either a thead or a tbody.

Run the p473 algorithm for processing row groups.

17. p472 p451 Advance the current element to the next child of the table.

18. Return to the step labeled rows.

19. p464 p464 End : For each tfoot element in the list of pending tfoot elements, in tree order, run the algorithm for processing row

groups p473 .

20. If there exists a p471 p471 p471 p471 row or column in the table containing only slots that do not have a cell anchored to them, then

this is a p471 table model error.

21. Return the table.

The p463 p462 algorithm for processing row groups , which is invoked by the set of steps above for processing thead , tbody, and

tfoot p464 elements, is:

1. Let ystart have the value of yheight.

2. For each p465 tr element that is a child of the element being processed, in tree order, run the algorithm for processing

rows p473 .

3. If p471 p471 y height > y start , then let all the last rows in the table from y= y start to y= y height-1 form a new row group , anchored at

the slot with coordinate (0, ystart), with height yheight-ystart, corresponding to the element being processed.

4. Run the p473 algorithm for ending a row group .

The algorithm for ending a row group, which is invoked by the set of steps above when starting and ending a block of rows, is:

1. While ycurrent is less than yheight, follow these steps:

1. Run the p474 algorithm for growing downward-growing cells .

2. Increase ycurrent by 1.

2. Empty the list of downward-growing cells.

The p465 algorithm for processing rows , which is invoked by the set of steps above for processing tr elements, is:



473

1. If yheight is equal to ycurrent, then increase yheight by 1. (ycurrent is never greater than yheight.)

2. Let xcurrent be 0.

3. Run the p474 algorithm for growing downward-growing cells .

4. If the p465 p466 p468 tr element being processed has no td or th element children, then increase y current by 1, abort this set of

steps, and return to the algorithm above.

5. Let p466 p468 p465 current cell be the first td or th element child in the tr element being processed.

6. Cells: While xcurrent is less than xwidth and the slot with coordinate (xcurrent, ycurrent) already has a cell assigned to it,

increase x current by 1.

7. If xcurrent is equal to xwidth, increase xwidth by 1. (xcurrent is never greater than xwidth.)

8. If the p470 p69 current cell has a colspan attribute, then parse that attribute's value, and let colspan be the result.

If parsing that value failed, or returned zero, or if the attribute is absent, then let colspan be 1, instead.

If colspan is greater than 1000, let it be 1000 instead.

9. If the p470 p69 current cell has a rowspan attribute, then parse that attribute's value, and let rowspan be the result.

If parsing that value failed or if the attribute is absent, then let rowspan be 1, instead.

If rowspan is greater than 65534, let it be 65534 instead.

10. If p451 rowspan is zero and the table element's node document is not set to quirks mode, then let cell grows downward be

true, and set rowspan to 1. Otherwise, let cell grows downward be false.

11. If xwidth < xcurrent+colspan, then let xwidth be xcurrent+colspan.

12. If yheight < ycurrent+rowspan, then let yheight be ycurrent+rowspan.

13. Let the slots with coordinates (x, y) such that xcurrent ≤ x < xcurrent+colspan and ycurrent ≤ y < ycurrent+rowspan be covered

by a new p471 cell c, anchored at (xcurrent, ycurrent), which has width colspan and height rowspan, corresponding to the current cell element.

If the p468 current cell element is a th element, let this new cell c be a header cell; otherwise, let it be a data cell.

To establish which header cells apply to the p474 current cell element, use the algorithm for assigning header cells described in the next section.

If any of the slots involved already had a p471 p471 cell covering them, then this is a table model error . Those slots now have two cells overlapping.

14. If cell grows downward is true, then add the tuple {c, xcurrent, colspan} to the list of downward-growing cells.

15. Increase xcurrent by colspan.

16. If p466 p468 p465 current cell is the last td or th element child in the tr element being processed, then increase ycurrent by 1, abort

this set of steps, and return to the algorithm above.

17. Let p466 p468 p465 current cell be the next td or th element child in the tr element being processed.

18. Return to the step labeled cells.

When the algorithms above require the user agent to run the algorithm for growing downward-growing cells, the user agent must, for each { p471 cell , cell x , width } tuple in the list of downward-growing cells , if any, extend the cell cell so that it also covers the slots with coordinates (x, ycurrent), where cellx ≤ x < cellx+width.



4.9.12.2 Forming relationships between data cells and header cells p47 §

4

Each cell can be assigned zero or more header cells. The algorithm for assigning header cells to a cell principal cell is as follows.

1. Let header list be an empty list of cells.

2. Let (principalx, principaly) be the coordinate of the slot to which the principal cell is anchored.

474

3.↪ p470 If the principal cell has a headers attribute specified

1. Take the value of the p470 principal cell 's headers attribute and split it on ASCII whitespace, letting id list be

the list of tokens obtained.

2. For each token in the p115 id list , if the first element in the Document with an ID equal to the token is a cell in

the same p471 table , and that cell is not the principal cell, then add that cell to header list.

↪ p470 If principal cell does not have a headers attribute specified

1. Let principalwidth be the width of the principal cell.

2. Let principalheight be the height of the principal cell.

3. For each value of y from principaly to principaly+principalheight-1, run the internal algorithm for scanning

and assigning header cells p475 , with the principal cell, the header list, the initial coordinate (principal x,y), and the increments Δx=−1 and Δy=0.

4. For each value of x from principalx to principalx+principalwidth-1, run the internal algorithm for scanning and

assigning header cells p475, with the principal cell, the header list, the initial coordinate (x,principaly), and the increments Δx=0 and Δy=−1.

5. If the p471 p476 principal cell is anchored in a row group , then add all header cells that are row group headers

and are anchored in the same row group with an x-coordinate less than or equal to principalx+principalwidth-1 and a y-coordinate less than or equal to principaly+principalheight-1 to header list.

6. If the p471 principal cell is anchored in a column group , then add all header cells that are column group

headers p476 and are anchored in the same column group with an x-coordinate less than or equal to principalx+principalwidth-1 and a y-coordinate less than or equal to principaly+principalheight-1 to header list.

4. Remove all the p476 empty cells from the header list.

5. Remove any duplicates from the header list.

6. Remove principal cell from the header list if it is there.

7. Assign the headers in the header list to the principal cell.

The internal algorithm for scanning and assigning header cells, given a principal cell, a header list, an initial coordinate (initialx, initialy), and Δx and Δy increments, is as follows:

1. Let x equal initialx.

2. Let y equal initialy.

3. Let opaque headers be an empty list of cells.

4.↪ If principal cell is a header cell

Let in header block be true, and let headers from current header block be a list of cells containing just the principal cell.

↪ Otherwise

Let in header block be false and let headers from current header block be an empty list of cells.

5. Loop: Increment x by Δx; increment y by Δy.

Note

For each invocation of this algorithm, one of Δx and Δy will be −1, and the other will be 0.

6. If either x or y are less than 0, then abort this internal algorithm.

7. If there is no cell covering slot (x, y), or if there is more than one cell covering slot (x, y), return to the substep labeled loop.

8. Let current cell be the cell covering slot (x, y).



475

9.↪ If current cell is a header cell

1. Set in header block to true.

2. Add current cell to headers from current header block.

3. Let blocked be false.

4.↪ If Δx is 0

If there are any cells in the opaque headers list anchored with the same x-coordinate as the current cell, and with the same width as current cell, then let blocked be true.

If the p476 current cell is not a column header, then let blocked be true.

↪ If Δy is 0

If there are any cells in the opaque headers list anchored with the same y-coordinate as the current cell, and with the same height as current cell, then let blocked be true.

If the p476 current cell is not a row header , then let blocked be true.

5. If blocked is false, then add the current cell to the headers list.

↪ If current cell is a data cell and in header block is true

Set in header block to false. Add all the cells in headers from current header block to the opaque headers list, and empty the headers from current header block list.

10. Return to the step labeled loop.

A header cell anchored at the slot with coordinate (x, y) with width width and height height is said to be a column header if any of the following conditions are true:

• The cell's p468 p468 scope attribute is in the column state, or

• The cell's p468 p469 scope attribute is in the auto state, and there are no data cells in any of the cells covering slots with

y-coordinates y .. y+height-1.

A header cell anchored at the slot with coordinate (x, y) with width width and height height is said to be a row header if any of the following conditions are true:

• The cell's p468 p468 scope attribute is in the row state, or

• The cell's p468 p469 p476 scope attribute is in the auto state, the cell is not a column header, and there are no data cells in any of

the cells covering slots with x-coordinates x .. x+width-1.

A header cell is said to be a p468 p469 column group header if its scope attribute is in the column group state.

A header cell is said to be a p468 p468 row group header if its scope attribute is in the row group state.

A cell is said to be an empty cell if it contains no elements and its child text content, if any, consists only of ASCII whitespace.



4.9.13 Examples p47 §

6

This section is non-normative.

The following shows how might one mark up the bottom part of table 45 of the Smithsonian physical tables, Volume 71:





476





Specification values: Steel, Castings, Ann. A.S.T.M. A27-16, Class B;* P max. 0.06; S max. 0.05. Grade. Yield Point. Ultimate tensile strength Per cent elong. 50.8mm or 2 in. Per cent reduct. area.

kg/mm2 lb/in2

Hard 0.45 ultimate 56.2 80,000 15 20

Medium 0.45 ultimate 49.2 70,000 18 25

Soft 0.45 ultimate 42.2 60,000 22 30



This table could look like this:

Specification values: Steel, Castings, Ann. A.S.T.M. A27-16, Class B;* P max. 0.06; S max. 0.05.



Grade. Ultimate tensile strength Per cent Per cent elong. Yield Point. reduct. 2 2 50.8 mm area. kg/mm lb/in or 2 in.

Hard. . . . . 0.45 ultimate 56.2 80,000 15 20

Medium . . . 0.45 ultimate 49.2 70,000 18 25

Soft . . . . . 0.45 ultimate 42.2 60,000 22 30



The following shows how one might mark up the gross margin table on page 46 of Apple, Inc's 10-K filing for fiscal year 2008:





2008



2007



2006





Net sales



$ 32,479



$ 24,006



$ 19,315

477





Cost of sales



21,334



15,852



13,717





Gross margin



$ 11,145



$ 8,154



$ 5,598





Gross margin percentage



34.3%



34.0%



29.0%





This table could look like this:

2008 2008 2007 2007 2006 2006

Net sales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . $ 32,479 $ 24,006 $ 19,315

Cost of sales . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21,334 15,852 13,717

Gross margin . . . . . . . . . . . . . . . . . . . . . . . . . . . $ 11,145 $ 8,154 $ 5,598

Gross margin percentage . . . . . . . . . . . . . . . . . 34.3% 34.0% 29.0%



The following shows how one might mark up the operating expenses table from lower on the same page of that document:





2008 2007 2006





Research and development



$ 1,109 $ 782 $ 712





Percentage of net sales



3.4% 3.3% 3.7%





Selling, general, and administrative



$ 3,761 $ 2,963 $ 2,433





Percentage of net sales



11.6% 12.3% 12.6%





This table could look like this:

2008 2008 2007 2007 2006 2006

Research and development . . . . . . . . . . . . . . . . . . $ 1,109 $ 782 $ 712

Percentage of net sales . . . . . . . . . . . . . . . . . . . . . 3.4% 3.3% 3.7%

Selling, general, and administrative . . . . . . . . . . . $ 3,761 $ 2,963 $ 2,433

Percentage of net sales . . . . . . . . . . . . . . . . . . . . . 11.6% 12.3% 12.6%



478

✔ MDN

4.10 Forms p47 §

9



4.10.1 Introduction p47 §

9

This section is non-normative.

A form is a component of a web page that has form controls, such as text, buttons, checkboxes, range, or color picker controls. A user can interact with such a form, providing data that can then be sent to the server for further processing (e.g. returning the results of a search or calculation). No client-side scripting is needed in many cases, though an API is available so that scripts can augment the user experience or use forms for purposes other than submitting data to a server.

Writing a form consists of several steps, which can be performed in any order: writing the user interface, implementing the server-side processing, and configuring the user interface to communicate with the server.



4.10.1.1 Writing a form's user interface p47 §

9

This section is non-normative.

For the purposes of this brief introduction, we will create a pizza ordering form.

Any form starts with a p487 p494 form element, inside which are placed the controls. Most controls are represented by the input element, which by default provides a text control. To label a control, the p491 label element is used; the label text and the control itself go inside the p491 p135 p213 label element. Each part of a form is considered a paragraph , and is typically separated from other parts using p elements. Putting this together, here is how one might ask for the customer's name:





Customer name:





To let the user select the size of the pizza, we can use a set of radio buttons. Radio buttons also use the p494 input element, this time with a p496 p515 type attribute with the value radio . To make the radio buttons work as a group, they are given a common name using the

name p569 p563 attribute. To group a batch of controls together, such as, in this case, the radio buttons, one can use the fieldset element.

The title of such a group of controls is given by the first element in the p563 p566 fieldset , which has to be a legend element.





Customer name:





Pizza Size



Small





Medium





Large





Note

Changes from the previous step are highlighted.

To pick toppings, we can use checkboxes. These use the p494 p496 p514 input element with a type attribute with the value checkbox:





Customer name:





Pizza Size



Small





Medium





Large





479





Pizza Toppings



Bacon





Extra Cheese





Onion





Mushroom





The pizzeria for which this form is being written is always making mistakes, so it needs a way to contact the customer. For this purpose, we can use form controls specifically for telephone numbers ( p494 p496 p501 input elements with their type attribute set to tel) and email addresses ( p494 p496 p503 input elements with their type attribute set to email ):





Customer name:





Telephone:





Email address:





Pizza Size



Small





Medium





Large





Pizza Toppings



Bacon





Extra Cheese





Onion





Mushroom





We can use an p494 p496 p508 input element with its type attribute set to time to ask for a delivery time. Many of these form controls have attributes to control exactly what values can be specified; in this case, three attributes of particular interest are p527 p527 min , max, and

step p528. These set the minimum time, the maximum time, and the interval between allowed values (in seconds). This pizzeria only delivers between 11am and 9pm, and doesn't promise anything better than 15 minute increments, which we can mark up as follows:





Customer name:





Telephone:





Email address:





Pizza Size



Small





Medium





Large





Pizza Toppings



Bacon





Extra Cheese





Onion





Mushroom





Preferred delivery time:





The p549 textarea element can be used to provide a multiline text control. In this instance, we are going to use it to provide a space for the customer to give delivery instructions:





480



Customer name:





Telephone:





Email address:





Pizza Size



Small





Medium





Large





Pizza Toppings



Bacon





Extra Cheese





Onion





Mushroom





Preferred delivery time:

Delivery instructions:





Finally, to make the form submittable we use the p536 button element:





Customer name:





Telephone:





Email address:





Pizza Size



Small





Medium





Large





Pizza Toppings



Bacon





Extra Cheese





Onion





Mushroom





Preferred delivery time:

Delivery instructions:

Submit order





4.10.1.2 Implementing the server-side processing for a form p48 §

1

This section is non-normative.

The exact details for writing a server-side processor are out of scope for this specification. For the purposes of this introduction, we will assume that the script at https://pizza.example.com/order.cgi is configured to accept submissions using the application/x-

www-form-urlencoded p573 format, expecting the following parameters sent in an HTTP POST body: custname

Customer's name

custtel

Customer's telephone number

custemail

Customer's email address

481

size

The pizza size, either small, medium, or large topping

A topping, specified once for each selected topping, with the allowed values being bacon, cheese, onion, and mushroom delivery

The requested delivery time

comments

The delivery instructions



4.10.1.3 Configuring a form to communicate with a server p48 §

2

This section is non-normative.

Form submissions are exposed to servers in a variety of ways, most commonly as HTTP GET or POST requests. To specify the exact method used, the p572 p487 method attribute is specified on the form element. This doesn't specify how the form data is encoded, though; to specify that, you use the p573 enctype attribute. You also have to specify the URL of the service that will handle the submitted data, using the p572 action attribute.

For each form control you want submitted, you then have to give a name that will be used to refer to the data in the submission. We already specified the name for the group of radio buttons; the same attribute ( p569 name ) also specifies the submission name. Radio buttons can be distinguished from each other in the submission by giving them different values, using the p498 value attribute.

Multiple controls can have the same name; for example, here we give all the checkboxes the same name, and the server distinguishes which checkbox was checked by seeing which values are submitted with that name — like the radio buttons, they are also given unique values with the p498 value attribute.

Given the settings in the previous section, this all becomes:



enctype="application/x-www-form-urlencoded"

action="https://pizza.example.com/order.cgi">



Customer name:

Telephone:

Email address:



Pizza Size



Small

Medium

Large





Pizza Toppings



Bacon

Extra Cheese

Onion

Mushroom





Preferred delivery time:

name="delivery">





Delivery instructions:

Submit order





Note

There is no particular significance to the way some of the attributes have their values quoted and others don't. The HTML syntax

allows a variety of equally valid ways to specify attributes, as discussed p1067 in the syntax section.

For example, if the customer entered "Denise Lawrence" as their name, "555-321-8642" as their telephone number, did not specify an

482

email address, asked for a medium-sized pizza, selected the Extra Cheese and Mushroom toppings, entered a delivery time of 7pm, and left the delivery instructions text control blank, the user agent would submit the following to the online web service:

custname=Denise+Lawrence&custtel=555-321-8642&custemail=&size=medium&topping=cheese&topping=mushroom&de livery=19%3A00&comments=



✔ MDN

4.10.1.4 Client-side form validation p48 §

3

This section is non-normative.

Forms can be annotated in such a way that the user agent will check the user's input before the form is submitted. The server still has to verify the input is valid (since hostile users can easily bypass the form validation), but it allows the user to avoid the wait incurred by having the server be the sole checker of the user's input.

The simplest annotation is the p524 p494 required attribute, which can be specified on input elements to indicate that the form is not to be submitted until a value is given. By adding this attribute to the customer name, pizza size, and delivery time fields, we allow the user agent to notify the user when the user submits the form without filling in those fields:



enctype="application/x-www-form-urlencoded"

action="https://pizza.example.com/order.cgi">



Customer name:

Telephone:

Email address:



Pizza Size



Small

Medium

Large





Pizza Toppings



Bacon

Extra Cheese

Onion

Mushroom





Preferred delivery time:

name="delivery" required>





Delivery instructions:

Submit order





It is also possible to limit the length of the input, using the p570 p549 maxlength attribute. By adding this to the textarea element, we can limit users to 1000 characters, preventing them from writing huge essays to the busy delivery drivers instead of staying focused and to the point:



enctype="application/x-www-form-urlencoded"

action="https://pizza.example.com/order.cgi">



Customer name:

Telephone:

Email address:



Pizza Size



Small

Medium

Large





483

Pizza Toppings



Bacon

Extra Cheese

Onion

Mushroom





Preferred delivery time:

name="delivery" required>





Delivery instructions:

Submit order





Note

When a form is submitted, p1271 invalid events are fired at each form control that is invalid. This can be useful for displaying a

summary of the problems with the form, since typically the browser itself will only report one problem at a time.



4.10.1.5 Enabling client-side automatic filling of form controls p48 §

4

This section is non-normative.

Some browsers attempt to aid the user by automatically filling form controls rather than having the user reenter their information each time. For example, a field asking for the user's telephone number can be automatically filled with the user's phone number.

To help the user agent with this, the p574 autocomplete attribute can be used to describe the field's purpose. In the case of this form, we have three fields that can be usefully annotated in this way: the information about who the pizza is to be delivered to. Adding this information looks like this:



enctype="application/x-www-form-urlencoded"

action="https://pizza.example.com/order.cgi">



Customer name:

Telephone:

Email address:



Pizza Size



Small

Medium

Large





Pizza Toppings



Bacon

Extra Cheese

Onion

Mushroom





Preferred delivery time:

name="delivery" required>





Delivery instructions:

Submit order





4.10.1.6 Improving the user experience on mobile devices p48 §

4

This section is non-normative.

Some devices, in particular those with virtual keyboards can provide the user with multiple input modalities. For example, when typing in a credit card number the user may wish to only see keys for digits 0-9, while when typing in their name they may wish to see a form

484

field that by default capitalizes each word.

Using the p796 inputmode attribute we can select appropriate input modalities:



enctype="application/x-www-form-urlencoded"

action="https://pizza.example.com/order.cgi">



Customer name:

Telephone:

Buzzer code:

Email address:



Pizza Size



Small

Medium

Large





Pizza Toppings



Bacon

Extra Cheese

Onion

Mushroom





Preferred delivery time:

name="delivery" required>





Delivery instructions:

Submit order





4.10.1.7 The difference between the field type, the autofill field name, and the input modality p48 §

5

This section is non-normative.

The p496 p574 p796 type , autocomplete , and inputmode attributes can seem confusingly similar. For instance, in all three cases, the string "email" is a valid value. This section attempts to illustrate the difference between the three attributes and provides advice suggesting how to use them.

The p496 p494 type attribute on input elements decides what kind of control the user agent will use to expose the field. Choosing between different values of this attribute is the same choice as choosing whether to use an p494 p549 input element, a textarea element, a

select p538 element, etc.

The p574 autocomplete attribute, in contrast, describes what the value that the user will enter actually represents. Choosing between different values of this attribute is the same choice as choosing what the label for the element will be.

First, consider telephone numbers. If a page is asking for a telephone number from the user, the right form control to use is <input

type=tel> p501 p574 . However, which autocomplete value to use depends on which phone number the page is asking for, whether they expect a telephone number in the international format or just the local format, and so forth.

For example, a page that forms part of a checkout process on an e-commerce site for a customer buying a gift to be shipped to a friend might need both the buyer's telephone number (in case of payment issues) and the friend's telephone number (in case of delivery issues). If the site expects international phone numbers (with the country code prefix), this could thus look like this:



Your phone number:

Recipient's phone number:

Please enter complete phone numbers including the country code prefix, as in "+1 555 123 4567".

But if the site only supports British customers and recipients, it might instead look like this (notice the use of p578 tel-national rather than p578 tel):



485



Your phone number:

Recipient's phone number:



Please enter complete UK phone numbers, as in "(01632) 960 123".

Now, consider a person's preferred languages. The right p574 p578 autocomplete value is language. However, there could be a number of different form controls used for the purpose: a text control ( p500 p538 <input type=text> ), a drop-down list ( <select>), radio buttons ( p515 <input type=radio>), etc. It only depends on what kind of interface is desired.

Finally, consider names. If a page just wants one name from the user, then the relevant control is p500 <input type=text>. If the page is asking for the user's full name, then the relevant p574 p576 autocomplete value is name.



Japanese name: Romanized name:

In this example, the " p574 p574 section-* " keywords in the autocomplete attributes' values tell the user agent that the two fields expect different names. Without them, the user agent could automatically fill the second field with the value given in the first field when the user gave a value to the first field.

Note

The "-jp" and "-en" parts of the keywords are opaque to the user agent; the user agent cannot guess, from those, that the two

names are expected to be in Japanese and English respectively.

Separate from the choices regarding p496 p574 p796 type and autocomplete , the inputmode attribute decides what kind of input modality (e.g., virtual keyboard) to use, when the control is a text control.

Consider credit card numbers. The appropriate input type is p510 p511 not <input type=number> , as explained below ; it is instead <input

type=text> p500 . To encourage the user agent to use a numeric input modality anyway (e.g., a virtual keyboard displaying only digits), the page would use



Credit card number:



autocomplete="cc-number">





4.10.1.8 Date, time, and number formats p48 §

6

This section is non-normative.

In this pizza delivery example, the times are specified in the format "HH:MM": two digits for the hour, in 24-hour format, and two digits for the time. (Seconds could also be specified, though they are not necessary in this example.) In some locales, however, times are often expressed differently when presented to users. For example, in the United States, it is still common to use the 12-hour clock with an am/pm indicator, as in "2pm". In France, it is common to separate the hours from the minutes using an "h" character, as in "14h00".

Similar issues exist with dates, with the added complication that even the order of the components is not always consistent — for example, in Cyprus the first of February 2003 would typically be written "1/2/03", while that same date in Japan would typically be written as "2003年02月01日" — and even with numbers, where locales differ, for example, in what punctuation is used as the decimal separator and the thousands separator.

It is therefore important to distinguish the time, date, and number formats used in HTML and in form submissions, which are always the formats defined in this specification (and based on the well-established ISO 8601 standard for computer-readable date and time formats), from the time, date, and number formats presented to the user by the browser and accepted as input from the user by the browser.

The format used "on the wire", i.e., in HTML markup and in form submissions, is intended to be computer-readable and consistent irrespective of the user's locale. Dates, for instance, are always written in the format "YYYY-MM-DD", as in "2003-02-01". While some users might see this format, others might see it as "01.02.2003" or "February 1, 2003".

486

The time, date, or number given by the page in the wire format is then translated to the user's preferred presentation (based on user preferences or on the locale of the page itself), before being displayed to the user. Similarly, after the user inputs a time, date, or number using their preferred format, the user agent converts it back to the wire format before putting it in the DOM or submitting it.

This allows scripts in pages and on servers to process times, dates, and numbers in a consistent manner without needing to support dozens of different formats, while still supporting the users' needs.

Note

See also the p522 implementation notes regarding localization of form controls.



4.10.2 Categories p48 §

7

Mostly for historical reasons, elements in this section fall into several overlapping (but subtly different) categories in addition to the usual ones like p132 p133 p133 flow content , phrasing content , and interactive content .

A number of the elements are p567 form-associated elements , which means they can have a form owner .

⇒ p536 p563 p494 p373 p554 p538 p549 p321 button , fieldset , input , object , output , select , textarea , img, form-associated custom

elements p706

The p487 form-associated elements fall into several subcategories:

Listed elements

Denotes elements that are listed in the p489 p564 p567 form .elements and fieldset .elements APIs. These elements also have a form

content attribute, and a matching p569 p567 form IDL attribute, that allow authors to specify an explicit form owner.

⇒ p536 p563 p494 p373 p554 p538 p549 button , fieldset , input , object , output , select , textarea, form-associated custom

elements p706

Submittable elements

Denotes elements that can be used for p600 p487 p597 constructing the entry list when a form element is submitted.

⇒ p536 p494 p373 p538 p549 p706 button , input , object , select , textarea , form-associated custom elements

Some p487 submittable elements can be, depending on their attributes, buttons. The prose below defines when an element is a button. Some buttons are specifically submit buttons.

Resettable elements

Denotes elements that can be affected when a p487 p604 form element is reset.

⇒ p494 p554 p538 p549 p706 input , output , select , textarea , form-associated custom elements

Autocapitalize-inheriting elements

Denotes elements that inherit the p794 p567 autocapitalize attribute from their form owner.

⇒ p536 p563 p494 p554 p538 p549 button , fieldset , input , output , select , textarea

Some elements, not all of them p487 form-associated, are categorized as labelable elements. These are elements that can be associated with a p491 label element.

⇒ p536 p494 p496 p500 p558 p554 p556 button , input (if the type attribute is not in the Hidden state), meter , output , progress ,

select p538 p549 p706 , textarea , form-associated custom elements



4.10.3 The form element §

p48 ✔ MDN

7

Categories p129: ✔ MDN

Flow content p132 .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p132 flow content is expected.

487

Content model p129:

Flow content p132 p487 , but with no form element descendants.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

accept-charset p488 p596 — Character encodings to use for form submission

action p572 p596 — URL to use for form submission

autocomplete p489 — Default setting for autofill feature for controls in the form

enctype p573 p596 — Entry list encoding type to use for form submission

method p572 p596 — Variant to use for form submission

name p488 p120 — Name of form to use in the document.forms API

novalidate p573 p596 — Bypass form control validation for form submission

target p573 p814 p596 — Browsing context for form submission

rel p489

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window,

LegacyOverrideBuiltIns,

LegacyUnenumerableNamedProperties]

interface HTMLFormElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString acceptCharset;

[CEReactions] attribute USVString action;

[CEReactions] attribute DOMString autocomplete;

[CEReactions] attribute DOMString enctype;

[CEReactions] attribute DOMString encoding;

[CEReactions] attribute DOMString method;

[CEReactions] attribute DOMString name;

[CEReactions] attribute boolean noValidate;

[CEReactions] attribute DOMString target;

[CEReactions] attribute DOMString rel;

[SameObject, PutForwards=value] readonly attribute DOMTokenList relList;

[SameObject] readonly attribute HTMLFormControlsCollection elements;

readonly attribute unsigned long length;

getter Element (unsigned long index);

getter (RadioNodeList or Element) (DOMString name);

undefined submit();

undefined requestSubmit(optional HTMLElement? submitter = null);

[CEReactions] undefined reset();

boolean checkValidity();

boolean reportValidity();

};



The p487 p124 p284 p487 form element represents a hyperlink that can be manipulated through a collection of form-associated elements, some of which can represent editable values that can be submitted to a server for processing.

The accept-charset attribute gives the character encodings that are to be used for the submission. If specified, the value must be an

ASCII case-insensitive p1277 match for " UTF-8 ". [ENCODING]

The p487 p120 name attribute represents the form 's name within the forms collection. The value must not be the empty string, and the value must be unique amongst the p487 p120 form elements in the forms collection that it is in, if any.

488

The p68 autocomplete attribute is an enumerated attribute. The attribute has two states. The on keyword maps to the on state, and the off p68 p68 keyword maps to the off state. The attribute may also be omitted. The missing value default and the invalid value default are

the p489 p489 p580 on state. The off state indicates that by default, form controls in the form will have their autofill field name set to

" p575 p489 p580 p576 off "; the on state indicates that by default, form controls in the form will have their autofill field name set to " on".

The p572 p573 p572 p573 p573 p571 action , enctype , method , novalidate , and target attributes are attributes for form submission.

The p487 rel attribute on form elements controls what kinds of links the elements create. The attribute's value must be a unordered set

of unique space-separated tokens p87 p295 . The allowed keywords and their meanings are defined in an earlier section.

rel p489 p295 p487 's supported tokens are the keywords defined in HTML link types which are allowed on form elements, impact the processing model, and are supported by the user agent. The possible p305 p304 supported tokens are noreferrer , noopener , and

opener p305 p489 . rel 's supported tokens must only include the tokens from this list that the user agent implements the processing model for.

For web developers (non-normative)

form p489 . elements

Returns an p99 HTMLFormControlsCollection of the form controls in the form (excluding image buttons for historical reasons).

form p490 . length

Returns the number of form controls in the form (excluding image buttons for historical reasons).

form[index]

Returns the indexth element in the form (excluding image buttons for historical reasons).

form[name]

Returns the form control (or, if there are several, a p99 RadioNodeList of the form controls) in the form with the given ID or

name p569 p321 (excluding image buttons for historical reasons); or, if there are none, returns the img element with the given ID. Once an element has been referenced using a particular name, that name will continue being available as a way to reference

that element in this method, even if the element's actual p569 ID or name changes, for as long as the element remains in the tree.

If there are multiple matching items, then a p99 RadioNodeList object containing all those elements is returned.

form p491 . submit ()

Submits the form, bypassing p592 p1272 interactive constraint validation and without firing a submit event.

form p491 . requestSubmit( [ submitter ] )

Requests to submit the form. Unlike p491 p592 submit() , this method includes interactive constraint validation and firing a

submit p1272 event, either of which can cancel submission.

The p487 p572 p573 submitter argument can be used to point to a specific submit button , whose formaction , formenctype,

formmethod p572 p573 p573 , formnovalidate , and formtarget attributes can impact submission. Additionally, the submitter will be

included when p600 constructing the entry list for submission; normally, buttons are excluded.

form p491 . reset()

Resets the form.

form p491 . checkValidity()

Returns true if the form's controls are all valid; otherwise, returns false.

form p491 . reportValidity()

Returns true if the form's controls are all valid; otherwise, returns false and informs the user.

The p95 ✔ MDN p95 autocomplete IDL attribute must reflect the content attribute of the same name, limited to only known values .

✔ MDN

The p95 name and rel IDL attributes must reflect the content attribute of the same name.

The p95 p488 acceptCharset IDL attribute must reflect the accept-charset content attribute.

The p95 p489 relList IDL attribute must reflect the rel content attribute.



The p99 p487 elements IDL attribute must return an HTMLFormControlsCollection rooted at the form element's root, whose filter ✔ MDN

matches p487 p567 p487 p494 p496 listed elements whose form owner is the form element, with the exception of input elements whose type ✔ MDN

attribute is in the p519 Image Button state, which must, for historical reasons, be excluded from this particular collection.

489

The p489 length IDL attribute must return the number of nodes represented by the elements collection.

The p489 supported property indices at any instant are the indices supported by the object returned by the elements attribute at that instant.

To p487 determine the value of an indexed property for a form element, the user agent must return the value returned by the item

method on the p489 elements collection, when invoked with the given index as its argument.



Each p487 form element has a mapping of names to elements called the past names map. It is used to persist names of controls even when they change names.

The supported property names consist of the names obtained from the following algorithm, in the order obtained from this algorithm:

1. Let sourced names be an initially empty ordered list of tuples consisting of a string, an element, a source, where the source

is either id, name, or past, and, if the source is past, an age.

2. For each p487 p567 p487 p494 listed element candidate whose form owner is the form element, with the exception of any input

elements whose p496 p519 type attribute is in the Image Button state:

1. If p138 p138 candidate has an id attribute, add an entry to sourced names with that id attribute's value as the string,

candidate as the element, and id as the source.

2. If p569 p569 candidate has a name attribute, add an entry to sourced names with that name attribute's value as the

string, candidate as the element, and name as the source.

3. For each p321 p567 p487 img element candidate whose form owner is the form element:

1. If p138 p138 candidate has an id attribute, add an entry to sourced names with that id attribute's value as the string,

candidate as the element, and id as the source.

2. If p1224 p1224 candidate has a name attribute, add an entry to sourced names with that name attribute's value as the

string, candidate as the element, and name as the source.

4. For each entry p490 past entry in the past names map add an entry to sourced names with the past entry's name as the string,

past entry's element as the element, past as the source, and the length of time past entry has been in the past names

map p490 as the age.

5. Sort sourced names by tree order of the element entry of each tuple, sorting entries with the same element by putting

entries whose source is id first, then entries whose source is name, and finally entries whose source is past, and sorting entries with the same element and source by their age, oldest first.

6. Remove any entries in sourced names that have the empty string as their name.

7. Remove any entries in sourced names that have the same name as an earlier entry in the map.

8. Return the list of names from sourced names, maintaining their relative order.

To p487 determine the value of a named property name for a form element, the user agent must run the following steps:

1. Let p45 p99 p487 p567 candidates be a live RadioNodeList object containing all the listed elements , whose form owner is the

form p487 p138 p569 p494 element, that have either an id attribute or a name attribute equal to name , with the exception of input

elements whose p496 p519 type attribute is in the Image Button state, in tree order.

2. If p45 p99 p321 candidates is empty, let candidates be a live RadioNodeList object containing all the img elements, whose form

owner p567 p487 p138 p1224 is the form element, that have either an id attribute or a name attribute equal to name, in tree order.

3. If p487 p490 candidates is empty, name is the name of one of the entries in the form element's past names map: return the

object associated with name in that map.

4. If candidates contains more than one node, return candidates.

5. Otherwise, p487 candidates contains exactly one node. Add a mapping from name to the node in candidates in the form

element's p490 past names map , replacing the previous entry with the same name, if any.

6. Return the node in candidates.

If an element listed in a p487 p490 p567 form element's past names map changes form owner, then its entries must be removed from that

490

map.



The p597 p487 p487 submit() method, when invoked, must submit the form element from the form element itself, with the submitted from ✔ MDN MDN

submit() p491 method flag set.

The requestSubmit(submitter) method, when invoked, must run the following steps:

1. If submitter is not null, then:

1. If p487 submitter is not a submit button , then throw a TypeError.

2. If p567 p487 submitter 's form owner is not this form element, then throw a "NotFoundError" DOMException.

2. Otherwise, set p487 submitter to this form element.

3. p597 p487 Submit this form element, from submitter.

The reset() method, when invoked, must run the following steps: ✔ MDN

1. If the p487 p491 form element is marked as locked for reset, then return.

2. Mark the p487 form element as locked for reset.

3. p604 p487 Reset the form element.

4. Unmark the p487 p491 form element as locked for reset.

If the p592 p487 checkValidity() method is invoked, the user agent must statically validate the constraints of the form element, and return true if the constraint validation return a positive result, and false if it returned a negative result.

If the p592 p487 reportValidity() method is invoked, the user agent must interactively validate the constraints of the form element, and return true if the constraint validation return a positive result, and false if it returned a negative result.

Example

This example shows two search forms:





Google:





Bing:





✔ MDN

4.10.4 The label element p49 §

1

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Interactive content p133.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Phrasing content p133 p487 p492 , but with no descendant labelable elements unless it is the element's labeled control, and no

descendant p491 label elements.

Tag omission in text/html p129 :

Neither tag is omissible.



491

Content attributes p129:

Global attributes p137

for p492 — Associate the label with form control

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLLabelElement : HTMLElement {

[HTMLConstructor] constructor();

readonly attribute HTMLFormElement? form;

[CEReactions] attribute DOMString htmlFor;

readonly attribute HTMLElement? control;

};



The p491 p124 label element represents a caption in a user interface. The caption can be associated with a specific form control, known as the p491 p492 p491 label element's labeled control , either using the for attribute, or by putting the form control inside the label element itself.

Except where otherwise specified by the following rules, a p491 p492 label element has no labeled control.

The for attribute may be specified to indicate a form control with which the caption is to be associated. If the attribute is specified, the attribute's value must be the p487 p491 ID of a labelable element in the same tree as the label element. If the attribute is specified and there is an element in the p492 tree whose ID is equal to the value of the for attribute, and the first such element in tree order is a

labelable element p487 p491 p492 , then that element is the label element's labeled control .

If the p492 p491 p487 for attribute is not specified, but the label element has a labelable element descendant, then the first such descendant in p491 p492 tree order is the label element's labeled control .

The p491 label element's exact default presentation and behavior, in particular what its activation behavior might be, if anything, should match the platform's label behavior. The p491 activation behavior of a label element for events targeted at interactive

content p133 p491 p133 descendants of a label element, and any descendants of those interactive content descendants, must be to do nothing.

Note

Form-associated custom elements p706 p487 p491 are labelable elements , so for user agents where the label element's activation

behavior p492 impacts the labeled control , both built-in and custom elements will be impacted.



Example

For example, on platforms where clicking a label activates the form control, clicking the p491 label in the following snippet could

trigger the user agent to p953 p494 fire a click event at the input element, as if the element itself had been triggered by the user:

Lost

Similarly, assuming p706 p698 my-checkbox was declared as as a form-associated custom element (like in this example), then the code

Lost

would have the same behavior, p953 firing a click event at the my-checkbox element.

On other platforms, the behavior in both cases might be just to focus the control, or to do nothing.



Example

The following example shows three form controls each with a label, two of which have small text showing the right format for users

to use.



492



Full name: Format: First Last

Age:





Post code: Format: AB12 3CD





For web developers (non-normative)

label p493 . control

Returns the form control that is associated with this element.

label p493 . form

Returns the p567 form owner of the form control that is associated with this element. Returns null if there isn't one.

✔ MDN

The p95 p492 htmlFor IDL attribute must reflect the for content attribute. ✔ MDN

✔ MDN

The p491 p492 control IDL attribute must return the label element's labeled control, if any, or null if there isn't one.

The form IDL attribute must run the following steps:

1. If the p491 p492 label element has no labeled control , then return null.

2. If the p491 p492 p487 label element's labeled control is not a form-associated element, then return null.

3. Return the p491 p492 p567 label element's labeled control 's form owner (which can still be null).

Note

The p493 p491 p567 p487 form IDL attribute on the label element is different from the form IDL attribute on listed form-associated

elements p487 p491 p567 , and the label element does not have a form content attribute.



For web developers (non-normative)

control p493 . labels

Returns a p491 NodeList of all the label elements that the form control is associated with.



Labelable elements p487 p494 p45 and all input elements have a live NodeList object associated with them that represents the list of ✔ MDN

label p491 p492 elements, in tree order , whose labeled control is the element in question. The labels IDL attribute of labelable

elements p487 p706 p493 p494 that are not form-associated custom elements , and the labels IDL attribute of input elements, on getting, must return that p494 NodeList object, and that same value must always be returned, unless this element is an input element whose

type p496 p500 attribute is in the Hidden state, in which case it must instead return null.

Form-associated custom elements p706 p493 p717 don't have a labels IDL attribute. Instead, their ElementInternals object has a labels IDL attribute. On getting, it must throw a p717 " NotSupportedError " DOMException if the target element is not a form-associated

custom element p706. Otherwise, it must return that NodeList object, and that same value must always be returned.

Example

This (non-conforming) example shows what happens to the p493 p494 NodeList and what labels returns when an input element has

its p496 type attribute changed.





✔ MDN

4.10.5 The input element p49 §

4

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

If the p496 p500 p133 type attribute is not in the Hidden state: Interactive content .

If the p496 p500 p487 p487 p487 p487 type attribute is not in the Hidden state: Listed , labelable , submittable , resettable , and autocapitalize-

inheriting p487 p487 form-associated element.

If the p496 p500 p487 p487 p487 p487 type attribute is in the Hidden state: Listed , submittable , resettable , and autocapitalize-inheriting

form-associated element p487.

If the p496 p500 p134 type attribute is not in the Hidden state: Palpable content .

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Nothing p131 .

Tag omission in text/html p129 :

No p1067 end tag.

Content attributes p129:

Global attributes p137

accept p517 p516 — Hint for expected file type in file upload controls

alt p520 — Replacement text for use when images are not available

autocomplete p574 — Hint for form autofill feature

checked p498 — Whether the control is checked

dirname p570 p143 p596 — Name of form control to use for sending the element's directionality in form submission

disabled p571 — Whether the form control is disabled

form p567 p487 — Associates the element with a form element

formaction p572 p596 — URL to use for form submission

formenctype p573 p596 — Entry list encoding type to use for form submission

formmethod p572 p596 — Variant to use for form submission

formnovalidate p573 p596 — Bypass form control validation for form submission

formtarget p573 p814 p596 — Browsing context for form submission

height p450 — Vertical dimension

list p529 — List of autocomplete options

max p527 — Maximum value

maxlength p523 — Maximum length of value

min p527 — Minimum value

minlength p523 — Minimum length of value

multiple p525 — Whether to allow multiple values

name p569 p596 p489 — Name of the element to use for form submission and in the form.elements API

pattern p526 — Pattern to be matched by the form control's value

placeholder p531 — User-visible label to be placed within the form control

readonly p523 — Whether to allow the value to be edited by the user

required p524 p596 — Whether the control is required for form submission

size p523 — Size of the control

src p519 — Address of the resource

step p528 — Granularity to be matched by the form control's value

type p496 — Type of form control

value p498 — Value of the form control

494

width p450 — Horizontal dimension

Also, the p527 p527 p526 title attribute has special semantics on this element: Description of pattern (when used with pattern attribute).

Accessibility considerations p130:

type p496 p500 attribute in the Hidden state: for authors; for implementers.

type p496 p500 attribute in the Text state: for authors; for implementers.

type p496 p500 attribute in the Search state: for authors; for implementers.

type p496 p501 attribute in the Telephone state: for authors; for implementers.

type p496 p502 attribute in the URL state: for authors; for implementers.

type p496 p503 attribute in the Email state: for authors; for implementers.

type p496 p504 attribute in the Password state: for authors; for implementers.

type p496 p505 attribute in the Date state: for authors; for implementers.

type p496 p506 attribute in the Month state: for authors; for implementers.

type p496 p507 attribute in the Week state: for authors; for implementers.

type p496 p508 attribute in the Time state: for authors; for implementers.

type p496 p509 attribute in the Local Date and Time state: for authors; for implementers.

type p496 p510 attribute in the Number state: for authors; for implementers.

type p496 p511 attribute in the Range state: for authors; for implementers.

type p496 p514 attribute in the Color state: for authors; for implementers.

type p496 p514 attribute in the Checkbox state: for authors; for implementers.

type p496 p515 attribute in the Radio Button state: for authors; for implementers.

type p496 p516 attribute in the File Upload state: for authors; for implementers.

type p496 p519 attribute in the Submit Button state: for authors; for implementers.

type p496 p519 attribute in the Image Button state: for authors; for implementers.

type p496 p521 attribute in the Reset Button state: for authors; for implementers.

type p496 p522 attribute in the Button state: for authors; for implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLInputElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString accept;

[CEReactions] attribute DOMString alt;

[CEReactions] attribute DOMString autocomplete;

[CEReactions] attribute boolean defaultChecked;

attribute boolean checked;

[CEReactions] attribute DOMString dirName;

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

attribute FileList? files;

[CEReactions] attribute USVString formAction;

[CEReactions] attribute DOMString formEnctype;

[CEReactions] attribute DOMString formMethod;

[CEReactions] attribute boolean formNoValidate;

[CEReactions] attribute DOMString formTarget;

[CEReactions] attribute unsigned long height;

attribute boolean indeterminate;

readonly attribute HTMLElement? list;

[CEReactions] attribute DOMString max;

[CEReactions] attribute long maxLength;

[CEReactions] attribute DOMString min;

[CEReactions] attribute long minLength;

[CEReactions] attribute boolean multiple;

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString pattern;

[CEReactions] attribute DOMString placeholder;

[CEReactions] attribute boolean readOnly;

[CEReactions] attribute boolean required;

[CEReactions] attribute unsigned long size;

495

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString step;

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString defaultValue;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString value;

attribute object? valueAsDate;

attribute unrestricted double valueAsNumber;

[CEReactions] attribute unsigned long width;

undefined stepUp(optional long n = 1);

undefined stepDown(optional long n = 1);

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

readonly attribute NodeList? labels;

undefined select();

attribute unsigned long? selectionStart;

attribute unsigned long? selectionEnd;

attribute DOMString? selectionDirection;

undefined setRangeText(DOMString replacement);

undefined setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional

SelectionMode selectionMode = "preserve");

undefined setSelectionRange(unsigned long start, unsigned long end, optional DOMString

direction);

// also has obsolete members

};



The p494 p124 input element represents a typed data field, usually with a form control to allow the user to edit the data.

The p68 type attribute controls the data type (and associated control) of the element. It is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

Keyword State Data type Control type

hidden p500 Hidden An arbitrary string n/a

text p500 Text Text with no line breaks A text control

search p500 Search Text with no line breaks Search control

tel p501 Telephone Text with no line breaks A text control

url p502 URL An absolute URL A text control

email p503 Email An email address or list of email addresses A text control

password p504 Password Text with no line breaks (sensitive information) A text control that

obscures data entry

date p505 Date A date (year, month, day) with no time zone A date control

month p506 Month A date consisting of a year and a month with no time zone A month control

week p507 Week A date consisting of a week-year number and a week number with no time zone A week control

time p508 Time A time (hour, minute, seconds, fractional seconds) with no time zone A time control

datetime-Local Date and A date and time (year, month, day, hour, minute, second, fraction of a second) with no time zone A date and time control

local p509 Time

number p510 Number A numerical value A text control or spinner

control

range p511 Range A numerical value, with the extra semantic that the exact value is not important A slider control or similar

color p514 Color An sRGB color with 8-bit red, green, and blue components A color picker

496

Keyword State Data type Control type

checkbox Checkboxp514 A set of zero or more values from a predefined list A checkbox

radio p515 Radio Button An enumerated value A radio button

file p516 File Upload Zero or more files each with a MIME type and optionally a file name A label and a button

submit Submit An enumerated value, with the extra semantic that it must be the last value selected and initiates A button

Button p519 form submission

image Image A coordinate, relative to a particular image's size, with the extra semantic that it must be the last Either a clickable image, or

Button p519 value selected and initiates form submission a button

reset p521 Reset Button n/a A button

button p522 Button n/a A button

The p68 p68 p500 missing value default and the invalid value default are the Text state.

Which of the p517 p520 p574 p498 p570 p572 p573 p572 accept , alt , autocomplete , checked , dirname , formaction , formenctype , formmethod,

formnovalidate p573 p573 p450 p529 p527 p523 p527 p523 p525 p526 , formtarget , height , list , max , maxlength , min , minlength , multiple , pattern,

placeholder p531 p523 p524 p523 p519 p528 p450 p533 p534 , readonly , required , size , src , step , and width content attributes, the checked , files,

valueAsDate p534 p534 p535 p588 p588 p588 , valueAsNumber , and list IDL attributes, the select() method, the selectionStart , selectionEnd, and p589 p589 p589 p534 selectionDirection , IDL attributes, the setRangeText() and setSelectionRange() methods, the stepUp() and

stepDown() p534 p1271 p1271 p494 p496 methods, and the input and change events apply to an input element depends on the state of its type attribute. The subsections that define each type also clearly define in normative "bookkeeping" sections which of these feature apply, and which do not apply, to each type. The behavior of these features depends on whether they apply or not, as defined in their various sections (q.v. for p522 p532 p535 content attributes , for APIs , for events ).

The following table is non-normative and summarizes which of those content attributes, IDL attributes, methods, and events p497 apply to each state:

Hidden p500 p500 p502 p503 p504 p505 p510 p511 p514 p514 Text , URL , Email Password Date , Local Number Range Color Checkbox,

Search p500 p501 p506 Telephone Month, Date Radio

Weekp507, and p515 Button

Time p508 p509 Time

Content attributes

accept p517 · · · · · · · · · · ·

alt p520 · · · · · · · · · · ·

autocompletep574 Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes ·

checked p498 · · · · · · · · · · Yes

dirname p570 · Yes · · · · · · · · ·

formaction p572 · · · · · · · · · · ·

formenctype p573 · · · · · · · · · · ·

formmethod p572 · · · · · · · · · · ·

formnovalidate p573 · · · · · · · · · · ·

formtarget p573 · · · · · · · · · · ·

height p450 · · · · · · · · · · ·

list p529 · Yes Yes Yes · Yes Yes Yes Yes Yes ·

maxp527 · · · · · Yes Yes Yes Yes · ·

maxlength p523 · Yes Yes Yes Yes · · · · · ·

min p527 · · · · · Yes Yes Yes Yes · ·

minlength p523 · Yes Yes Yes Yes · · · · · ·

multiple p525 · · · Yes · · · · · · ·

pattern p526 · Yes Yes Yes Yes · · · · · ·

placeholder p531 · Yes Yes Yes Yes · · Yes · · ·

readonly p523 · Yes Yes Yes Yes Yes Yes Yes · · ·

required p524 · Yes Yes Yes Yes Yes Yes Yes · · Yes

size p523 · Yes Yes Yes Yes · · · · · ·

srcp519 · · · · · · · · · · ·

step p528 · · · · · Yes Yes Yes Yes · ·

width p450 · · · · · · · · · · ·

IDL attributes and methods

checked p533 · · · · · · · · · · Yes

files p534 · · · · · · · · · · ·

497

Hidden p500 p500 p502 p503 p504 p505 p510 p511 p514 p514 Text , URL , Email Password Date , Local Number Range Color Checkbox,

Search p500 p501 p506 Telephone Month, Date Radio

Week p507 p515 , and Button

Time p508 p509 Time

value p533 p533 p533 p533 p533 p533 p533 p533 p533 p533 p533 p533 default value value value value value value value value value default/on

valueAsDate p534 · · · · · Yes · · · · ·

valueAsNumber p534 · · · · · Yes Yes Yes Yes · ·

list p535 · Yes Yes Yes · Yes Yes Yes Yes Yes ·

select() p588 · Yes Yes Yes† Yes Yes† Yes† Yes† · Yes† ·

selectionStart p588 · Yes Yes · Yes · · · · · ·

selectionEnd p588 · Yes Yes · Yes · · · · · ·

selectionDirection p589 · Yes Yes · Yes · · · · · ·

setRangeText() p589 · Yes Yes · Yes · · · · · ·

setSelectionRange() p589 · Yes Yes · Yes · · · · · ·

stepDown() p534 · · · · · Yes Yes Yes Yes · ·

stepUp() p534 · · · · · Yes Yes Yes Yes · ·

Events

input p1271 event · Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes

change p1271 event · Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes

† If the control has no selectable text, the p588 select() method results in a no-op, with no "InvalidStateError" DOMException.

Some states of the p496 type attribute define a value sanitization algorithm.

Each p494 p567 p533 input element has a value , which is exposed by the value IDL attribute. Some states define an algorithm to convert a string to a number, an algorithm to convert a number to a string, an algorithm to convert a string to a Date object, and an p527 p527 p528 p534 algorithm to convert a Date object to a string , which are used by max , min , step , valueAsDate,

valueAsNumber p534 p534 , and stepUp() .

An p494 p567 input element's dirty value flag must be set to true whenever the user interacts with the control in a way that changes the

value p567 p533 . (It is also set to true when the value is programmatically changed, as described in the definition of the value IDL attribute.) The p567 p494 p498 value content attribute gives the default value of the input element. When the value content attribute is added, set, or removed, if the control's p567 p567 p498 dirty value flag is false, the user agent must set the value of the element to the value of the value

content attribute, if there is one, or the empty string otherwise, and then run the current p498 value sanitization algorithm , if one is defined.

Each p494 p567 p533 input element has a checkedness , which is exposed by the checked IDL attribute.

Each p494 input element has a boolean dirty checkedness flag. When it is true, the element is said to have a dirty checkedness.

The p498 dirty checkedness flag must be initially set to false when the element is created, and must be set to true whenever the user interacts with the control in a way that changes the p567 checkedness.

The p67 p567 p494 checked content attribute is a boolean attribute that gives the default checkedness of the input element. When the

checked p498 p498 p567 content attribute is added, if the control does not have dirty checkedness , the user agent must set the checkedness

of the element to true; when the p498 p498 checked content attribute is removed, if the control does not have dirty checkedness, the user agent must set the p567 checkedness of the element to false.

The p605 p494 p567 p498 reset algorithm for input elements is to set the dirty value flag and dirty checkedness flag back to false, set the

value p567 p498 of the element to the value of the value content attribute, if there is one, or the empty string otherwise, set the

checkedness p567 p498 of the element to true if the element has a checked content attribute and false if it does not, empty the list of

selected files p516 p498 p496 , and then invoke the value sanitization algorithm , if the type attribute's current state defines one.

Each p494 p567 p494 p567 input element can be mutable . Except where otherwise specified, an input element is always mutable. Similarly,

except where otherwise specified, the user agent should not allow the user to modify the element's p567 p567 value or checkedness.

When an p494 p571 p567 input element is disabled , it is not mutable .

Note

The p523 p505 p514 p494 readonly attribute can also in some cases (e.g. for the Date state, but not the Checkbox state) stop an input

element from being p567 mutable .

498

The p494 p567 p567 p567 cloning steps for input elements must propagate the value , dirty value flag , checkedness, and dirty checkedness

flag p498 from the node being cloned to the copy.

The p494 activation behavior for input elements are these steps:

1. If this element is not p567 p514 p515 mutable and is not in the Checkbox state and is not in the Radio state, then return.

2. Run this element's input activation behavior, if any, and do nothing otherwise.

The p494 legacy-pre-activation behavior for input elements are these steps:

1. If this element's p496 p514 p567 type attribute is in the Checkbox state , then set this element's checkedness to its opposite value

(i.e. true if it is false, false if it is true) and set this element's p500 indeterminate IDL attribute to false.

2. If this element's p496 p515 type attribute is in the Radio Button state , then get a reference to the element in this element's radio

button group p515 p567 p567 that has its checkedness set to true, if any, and then set this element's checkedness to true.

The p494 legacy-canceled-activation behavior for input elements are these steps:

1. If the element's p496 p514 p567 type attribute is in the Checkbox state , then set the element's checkedness and the element's

indeterminate p500 IDL attribute back to the values they had before the legacy-pre-activation behavior was run.

2. If this element's p496 p515 type attribute is in the Radio Button state , then if the element to which a reference was obtained in

the p515 legacy-pre-activation behavior , if any, is still in what is now this element's radio button group , if it still has one, and if

so, setting that element's p567 checkedness to true; or else, if there was no such element, or that element is no longer in this

element's p515 p515 radio button group , or if this element no longer has a radio button group, setting this element's

checkedness p567 to false.



When an p494 input element is first created, the element's rendering and behavior must be set to the rendering and behavior defined for the p496 p498 p496 type attribute's state, and the value sanitization algorithm , if one is defined for the type attribute's state, must be invoked.

When an p494 p496 input element's type attribute changes state, the user agent must run the following steps:

1. If the previous state of the element's p496 p533 p533 type attribute put the value IDL attribute in the value mode, and the

element's p567 p496 p533 value is not the empty string, and the new state of the element's type attribute puts the value IDL

attribute in either the p533 p533 p498 default mode or the default/on mode, then set the element's value content attribute to the

element's p567 value.

2. Otherwise, if the previous state of the element's p496 p533 type attribute put the value IDL attribute in any mode other than the

value p533 p496 p533 p533 mode, and the new state of the element's type attribute puts the value IDL attribute in the value mode,

then set the p567 p498 value of the element to the value of the value content attribute, if there is one, or the empty string

otherwise, and then set the control's p567 dirty value flag to false.

3. Otherwise, if the previous state of the element's p496 p533 type attribute put the value IDL attribute in any mode other than the

filename p533 p496 p533 p533 mode, and the new state of the element's type attribute puts the value IDL attribute in the filename

mode, then set the p567 value of the element to the empty string.

4. Update the element's rendering and behavior to the new state's.

5. p515 Signal a type change for the element. (The Radio Button state uses this, in particular.)

6. Invoke the p498 p496 value sanitization algorithm , if one is defined for the type attribute's new state.

7. Let p589 p497 previouslySelectable be true if setRangeText() previously applied to the element, and false otherwise.

8. Let p589 p497 nowSelectable be true if setRangeText() now applies to the element, and false otherwise.

9. If p587 previouslySelectable is false and nowSelectable is true, set the element's text entry cursor position to the beginning of

the text control, and p588 set its selection direction to "none".



The p569 p570 p143 name attribute represents the element's name. The dirname attribute controls how the element's directionality is submitted. The p571 disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The

form p567 p494 p567 p574 attribute is used to explicitly associate the input element with its form owner . The autocomplete attribute controls

499

✔ MDN

how the user agent provides autofill behavior.

The indeterminate IDL attribute must initially be set to false. On getting, it must return the last value it was set to. On setting, it must be set to the new value. It has no effect except for changing the appearance of p514 checkbox controls.

The p95 accept , alt , max , min , multiple , pattern , placeholder , required , size , src , and step IDL attributes must reflect the respective content attributes of the same name. The p95 p570 dirName IDL attribute must reflect the dirname content attribute. The readOnly p95 p523 p95 IDL attribute must reflect the readonly content attribute. The defaultChecked IDL attribute must reflect the

checked p498 p95 p498 content attribute. The defaultValue IDL attribute must reflect the value content attribute.

The p95 p95 type IDL attribute must reflect the respective content attribute of the same name, limited to only known values. The maxLength p95 p523 p95 IDL attribute must reflect the maxlength content attribute, limited to only non-negative numbers. The minLength IDL attribute must p95 p523 p95 reflect the minlength content attribute, limited to only non-negative numbers.

The IDL attributes width and height must return the rendered width and height of the image, in CSS pixels, if an image is being

rendered p1188, and is being rendered to a visual medium; or else the intrinsic width and height of the image, in CSS pixels, if an image

is p520 p520 p494 p496 available but not being rendered to a visual medium; or else 0, if no image is available . When the input element's type

attribute is not in the p519 p520 p1275 Image Button state, then no image is available . [CSS]

On setting, they must act as if they p95 reflected the respective content attributes of the same name.

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage IDL attributes, and the checkValidity() , reportValidity(), and p594 p593 p493 setCustomValidity() methods, are part of the constraint validation API . The labels IDL attribute provides a list of the element's p491 p588 p588 p588 p589 p589 label s. The select() , selectionStart , selectionEnd , selectionDirection , setRangeText(), and

setSelectionRange() p589 p571 p569 p569 methods and IDL attributes expose the element's text selection. The disabled , form , and name IDL attributes are part of the element's forms API.



4.10.5.1 States of the p496 p50 type attribute §

0 ✔ MDN

4.10.5.1.1 Hidden state (type=hidden) p50 §

0

When an p494 p496 p500 input element's type attribute is in the Hidden state, the rules in this section apply.

The p494 p124 input element represents a value that is not intended to be examined or manipulated by the user.

Constraint validation p494 p496 p500 p591 : If an input element's type attribute is in the Hidden state, it is barred from constraint validation.

If the p569 p569 name attribute is present and has a value that is an ASCII case-insensitive match for " _charset_", then the element's

value p498 attribute must be omitted.

Bookkeeping details

▪The p574 p497 autocomplete content attribute applies to this element.

▪The p533 p497 p533 value IDL attribute applies to this element and is in mode default.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 p525 , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength , multiple,

pattern p526 p531 p523 p524 p523 p519 p528 p450 , placeholder , readonly , required , size , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p535 p588 p588 do not apply to the element: checked , files , list , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p588 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown(),

and p534 stepUp() methods.

▪The p1271 p1271 p497 input and change events do not apply.



✔ MDN

4.10.5.1.2 Text (type=text) state and Search state (type=search) p50 §

0

When an p494 p496 p500 p500 input element's type attribute is in the Text state or the Search state, the rules in this section apply.

The p494 p124 p567 input element represents a one line plain text edit control for the element's value .

Note

The difference between the p500 p500 Text state and the Search state is primarily stylistic: on platforms where search controls are

distinguished from regular text controls, the p500 Search state might result in an appearance consistent with the platform's search

500

controls rather than appearing like a regular text control.

If the element is p567 p567 mutable , its value should be editable by the user. User agents must not allow users to insert U+000A LINE

FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the element's p567 value.

If the element is p567 mutable, the user agent should allow the user to change the writing direction of the element, setting it either to a left-to-right writing direction or a right-to-left writing direction. If the user does so, the user agent must then run the following steps:

1. Set the element's p143 p143 p143 dir attribute to " ltr " if the user selected a left-to-right writing direction, and " rtl" if the user

selected a right-to-left writing direction.

2. p933 p939 p1271 Queue an element task on the user interaction task source given the element to fire an event named input at the

element, with the bubbles and composed attributes initialized to true.

The p498 value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The p498 p567 value sanitization algorithm is as follows : Strip newlines from the value.

Bookkeeping details

▪The following common p494 p497 p574 p570 p529 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , dirname , list,

maxlength p523 p523 p526 p531 p523 p524 p523 p535 p588 , minlength , pattern , placeholder , readonly , required , and size content attributes; list , selectionStart,

selectionEndp588, selectionDirectionp589, and valuep533 IDL attributes; select() p588, setRangeText()p589, and setSelectionRange()p589 methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p572 p573 do not apply to the element: accept , alt , checked , formaction , formenctype,

formmethod p572 p573 p573 p450 p527 p527 p525 p519 p528 p450 , formnovalidate , formtarget , height , max , min , multiple , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p534 p534 do not apply to the element: checked , files , valueAsDate , and valueAsNumber IDL attributes;

stepDown() p534 p534 and stepUp() methods.



✔ MDN

4.10.5.1.3 Telephone state (type=tel) p50 §

1

When an p494 p496 p501 input element's type attribute is in the Telephone state, the rules in this section apply.

The p494 p124 p567 input element represents a control for editing a telephone number given in the element's value .

If the element is p567 p567 mutable , its value should be editable by the user. User agents may change the spacing and, with care, the punctuation of p567 values that the user enters. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D

CARRIAGE RETURN (CR) characters into the element's p567 value .

The p498 value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The p498 p567 value sanitization algorithm is as follows : Strip newlines from the value.

Note

Unlike the p502 p503 p501 URL and Email types, the Telephone type does not enforce a particular syntax. This is intentional; in practice,

telephone number fields tend to be free-form fields, because there are a wide variety of valid phone numbers. Systems that need

to enforce a particular format are encouraged to use the p526 p594 pattern attribute or the setCustomValidity() method to hook

into the client-side validation mechanism.

Bookkeeping details

▪The following common inputp494 element content attributes, IDL attributes, and methods applyp497 to the element: autocompletep574, listp529, maxlengthp523,

minlength p523 p526 p531 p523 p524 p523 p535 p588 p588 , pattern , placeholder , readonly , required , and size content attributes; list , selectionStart , selectionEnd,

selectionDirection p589 p533 p588 p589 p589 , and value IDL attributes; select() , setRangeText() , and setSelectionRange() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctypep573, formmethodp572, formnovalidatep573, formtargetp573, heightp450, max p527, minp527, multiplep525, srcp519, stepp528, and widthp450.

▪The following IDL attributes and methods p497 p533 p534 p534 p534 do not apply to the element: checked , files , valueAsDate , and valueAsNumber IDL attributes;

stepDown() p534 p534 and stepUp() methods.

501

✔ MDN

4.10.5.1.4 URL state (type=url) p50 §

2

When an p494 p496 p502 input element's type attribute is in the URL state, the rules in this section apply.

The p494 p124 p567 input element represents a control for editing a single absolute URL given in the element's value.

If the element is p567 p567 mutable , the user agent should allow the user to change the URL represented by its value. User agents may

allow the user to set the p567 value to a string that is not a valid absolute URL, but may also or instead automatically escape characters entered by the user so that the p567 value is always a valid absolute URL (even if that isn't the actual value seen and edited by the user in the interface). User agents should allow the user to set the p567 value to the empty string. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the p567 value .

The p498 p88 value attribute, if specified and not empty, must have a value that is a valid URL potentially surrounded by spaces that is also an absolute URL.

The p498 p567 value sanitization algorithm is as follows : Strip newlines from the value, then strip leading and trailing ASCII

whitespace p567 from the value.

Constraint validation p567 : While the value of the element is neither the empty string nor a valid absolute URL, the element is

suffering from a type mismatch p591.

Bookkeeping details

▪The following common p494 p497 p574 p529 p523 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , maxlength,

minlength p523 p526 p531 p523 p524 p523 p535 p588 p588 , pattern , placeholder , readonly , required , and size content attributes; list , selectionStart , selectionEnd,

selectionDirectionp589, and valuep533 IDL attributes; select() p588, setRangeText()p589, and setSelectionRange()p589 methods.

▪The valuep533 IDL attribute is in mode valuep533.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p527 p527 p525 p519 p528 p450 , formmethod , formnovalidate , formtarget , height , max , min , multiple , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p534 p534 do not apply to the element: checked , files , valueAsDate , and valueAsNumber IDL attributes;

stepDown() p534 p534 and stepUp() methods.

Example

If a document contained the following markup:





rfc2045">





...and the user had typed "spec.w", and the user agent had also found that the user had visited

https://url.spec.whatwg.org/#url-parsing and https://streams.spec.whatwg.org/ in the recent past, then the rendering

might look like this:

spec.w| ▼

https://html.spec.whatwg.org/ HTML

https://mediasession.spec.whatwg.org/ Media Session

https://fullscreen.spec.whatwg.org/ Fullscreen

https://dom.spec.whatwg.org/ DOM

https://url.spec.whatwg.org/#url-parsing

https://streams.spec.whatwg.org/



The first four URLs in this sample consist of the four URLs in the author-specified list that match the text the user has entered,



502

sorted in some implementation-defined manner (maybe by how frequently the user refers to those URLs). Note how the UA is using

the knowledge that the values are URLs to allow the user to omit the scheme part and perform intelligent matching on the domain

name.

The last two URLs (and probably many more, given the scrollbar's indications of more values being available) are the matches from

the user agent's session history data. This data is not made available to the page DOM. In this particular case, the UA has no titles

to provide for those values.



✔ MDN

4.10.5.1.5 Email state (type=email) p50 §

3

When an p494 p496 p503 input element's type attribute is in the Email state, the rules in this section apply.

How the p503 p525 Email state operates depends on whether the multiple attribute is specified or not.

↪ p525 When the multiple attribute is not specified on the element

The p494 p124 p567 input element represents a control for editing an email address given in the element's value.

If the element is p567 p567 mutable , the user agent should allow the user to change the email address represented by its value.

User agents may allow the user to set the p567 p504 value to a string that is not a valid email address . The user agent should act in a manner consistent with expecting the user to provide a single email address. User agents should allow the user to set the

value p567 to the empty string. User agents must not allow users to insert U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN

(CR) characters into the p567 p567 value . User agents may transform the value for display and editing; in particular, user agents

should convert punycode in the domain labels of the p567 value to IDN in the display and vice versa.

Constraint validation: While the user interface is representing input that the user agent cannot convert to punycode, the

control is p592 suffering from bad input.

The p498 p504 value attribute, if specified and not empty, must have a value that is a single valid email address .

The p498 p567 value sanitization algorithm is as follows : Strip newlines from the value, then strip leading and trailing ASCII

whitespace p567 from the value.

Constraint validation p567 p504 : While the value of the element is neither the empty string nor a single valid email address, the

element is p591 suffering from a type mismatch .

↪ p525 When the multiple attribute is specified on the element

The p494 p124 input element represents a control for adding, removing, and editing the email addresses given in the element's

value p567 s .

If the element is p567 mutable, the user agent should allow the user to add, remove, and edit the email addresses represented by

its p567 p567 values . User agents may allow the user to set any individual value in the list of value s to a string that is not a valid

email address p504 , but must not allow users to set any individual value to a string containing U+002C COMMA (,), U+000A LINE FEED (LF), or U+000D CARRIAGE RETURN (CR) characters. User agents should allow the user to remove all the addresses in the

element's p567 p567 values . User agents may transform the values for display and editing; in particular, user agents should convert

punycode in the domain labels of the p567 value to IDN in the display and vice versa.

Constraint validation: While the user interface describes a situation where an individual value contains a U+002C COMMA (,)

or is representing input that the user agent cannot convert to punycode, the control is p592 suffering from bad input .

Whenever the user changes the element's p567 value s , the user agent must run the following steps:

1. Let p567 latest values be a copy of the element's value s.

2. Strip leading and trailing ASCII whitespace from each value in latest values.

3. Let the element's p567 value be the result of concatenating all the values in latest values, separating each value from

the next by a single U+002C COMMA character (,), maintaining the list's order.

The p498 p504 value attribute, if specified, must have a value that is a valid email address list .

The p498 value sanitization algorithm is as follows:

503

1. p567 Split on commas the element's value , strip leading and trailing ASCII whitespace from each resulting token, if any,

and let the element's p567 values be the (possibly empty) resulting list of (possibly empty) tokens, maintaining the original order.

2. Let the element's p567 p567 value be the result of concatenating the element's values , separating each value from the

next by a single U+002C COMMA character (,), maintaining the list's order.

Constraint validation p567 p504 : While the value of the element is not a valid email address list, the element is suffering from a

type mismatch p591.

When the p525 p498 multiple attribute is set or removed, the user agent must run the value sanitization algorithm.

A valid email address is a string that matches the email production of the following ABNF, the character set for which is Unicode.

This ABNF implements the extensions described in RFC 1123. p1275 p1281 p1280 p1280 [ABNF] [RFC5322] [RFC1034] [RFC1123]

email = 1*( atext / "." ) "@" label *( "." label )

label = let-dig [ [ ldh-str ] let-dig ] ; limited to a length of 63 characters by RFC 1034

section 3.5

atext = < as defined in RFC 5322 section 3.2.3 >

let-dig = < as defined in RFC 1034 section 3.5 >

ldh-str = < as defined in RFC 1034 section 3.5 >



Note

This requirement is a p27 willful violation of RFC 5322, which defines a syntax for email addresses that is simultaneously too strict

(before the "@" character), too vague (after the "@" character), and too lax (allowing comments, whitespace characters, and

quoted strings in manners unfamiliar to most users) to be of practical use here.



Note

The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.

/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/

A p87 p504 valid email address list is a set of comma-separated tokens , where each token is itself a valid email address. To obtain the list of tokens from a p504 valid email address list , an implementation must split the string on commas.

Bookkeeping details

▪The following common p494 p497 p574 p529 p523 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , maxlength,

minlength p523 p525 p526 p531 p523 p524 p523 p535 p533 , multiple , pattern , placeholder , readonly , required , and size content attributes; list and value IDL attributes;

select() p588 method.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p527 p527 p519 p528 p450 , formmethod , formnovalidate , formtarget , height , max , min , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; setRangeText() , setSelectionRange() , stepDown() and

stepUp() p534 methods.



✔ MDN

4.10.5.1.6 Password state (type=password) p50 §

4

When an p494 p496 p504 input element's type attribute is in the Password state, the rules in this section apply.

The p494 p124 p567 input element represents a one line plain text edit control for the element's value . The user agent should obscure the value so that people other than the user cannot see it.

If the element is p567 p567 mutable , its value should be editable by the user. User agents must not allow users to insert U+000A LINE

FEED (LF) or U+000D CARRIAGE RETURN (CR) characters into the p567 value.

The p498 value attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

504

The p498 p567 value sanitization algorithm is as follows : Strip newlines from the value.

Bookkeeping details

▪The following common p494 p497 p574 p523 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , maxlength,

minlength p523 p526 p531 p523 p524 p523 p588 p588 , pattern , placeholder , readonly , required , and size content attributes; selectionStart , selectionEnd,

selectionDirection p589 p533 p588 p589 p589 , and value IDL attributes; select() , setRangeText() , and setSelectionRange() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p529 p527 p527 p525 p519 p528 p450 , formmethod , formnovalidate , formtarget , height , list , max , min , multiple , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p535 p534 p534 do not apply to the element: checked , files , list , valueAsDate , and valueAsNumber IDL

attributes; p534 p534 stepDown() and stepUp() methods.



✔ MDN

4.10.5.1.7 Date state (type=date) p50 §

5

When an p494 p496 p505 input element's type attribute is in the Date state, the rules in this section apply.

The p494 p124 p567 p75 input element represents a control for setting the element's value to a string representing a specific date.

If the element is p567 p75 p567 mutable , the user agent should allow the user to change the date represented by its value, as obtained by

parsing a date p75 p567 from it. User agents must not allow the user to set the value to a non-empty string that is not a valid date

string p75 p75 p567 p75 . If the user agent provides a user interface for selecting a date , then the value must be set to a valid date string

representing the user's selection. User agents should allow the user to set the p567 value to the empty string.

Constraint validation p75 : While the user interface describes input that the user agent cannot convert to a valid date string, the

control is p592 suffering from bad input.

Note

See the p486 introduction section for a discussion of the difference between the input format and submission format for date, time,

and number form controls, and the p522 implementation notes regarding localization of form controls.

The p498 p75 value attribute, if specified and not empty, must have a value that is a valid date string.

The p498 p567 p75 value sanitization algorithm is as follows : If the value of the element is not a valid date string, then set it to the empty string instead.

The p527 p75 p527 min attribute, if specified, must have a value that is a valid date string . The max attribute, if specified, must have a value that is a p75 valid date string.

The p528 p528 step attribute is expressed in days. The step scale factor is 86,400,000 (which converts the days to milliseconds, as used in the other algorithms). The p528 default step is 1 day.

When the element is p592 p567 p75 suffering from a step mismatch , the user agent may round the element's value to the nearest date for which the element would not p592 suffer from a step mismatch.

The p498 p75 algorithm to convert a string to a number , given a string input , is as follows : If parsing a date from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight UTC on the morning of 1970-01-01

(the time represented by the value " p75 1970-01-01T00:00:00.0Z ") to midnight UTC on the morning of the parsed date, ignoring leap seconds.

The p498 p75 algorithm to convert a number to a string , given a number input , is as follows : Return a valid date string that represents the p75 date that, in UTC, is current input milliseconds after midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z").

The p498 p75 algorithm to convert a string to a Date object , given a string input , is as follows : If parsing a date from input results in an error, then return an error; otherwise, return p53 a new Date object representing midnight UTC on the morning of the parsed p75 date.

The p498 p75 algorithm to convert a Date object to a string , given a Date object input , is as follows : Return a valid date string

that represents the p75 date current at the time represented by input in the UTC time zone.



505

Note

The p505 Date state (and other date- and time-related states described in subsequent sections) is not intended for the entry of

values for which a precise date and time relative to the contemporary calendar cannot be established. For example, it would be

inappropriate for the entry of times like "one millisecond after the big bang", "the early part of the Jurassic period", or "a winter

around 250 BCE".

For the input of dates before the introduction of the Gregorian calendar, authors are encouraged to not use the p505 Date state (and

the other date- and time-related states described in subsequent sections), as user agents are not required to support converting

dates and times from earlier periods to the Gregorian calendar, and asking users to do so manually puts an undue burden on users.

(This is complicated by the manner in which the Gregorian calendar was phased in, which occurred at different times in different

countries, ranging from partway through the 16th century all the way to early in the 20th.) Instead, authors are encouraged to

provide fine-grained input controls using the p538 p494 p510 select element and input elements with the Number state.

Bookkeeping details

▪The following common inputp494 element content attributes, IDL attributes, and methods applyp497 to the element: autocompletep574, listp529, maxp527, minp527,

readonly p523 p524 p528 p535 p533 p534 p534 p588 , required , and step content attributes; list , value , valueAsDate , and valueAsNumber IDL attributes; select(),

stepDown() p534 p534 , and stepUp() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctypep573, formmethodp572, formnovalidatep573, formtargetp573, heightp450, maxlengthp523, minlengthp523, multiplep525, patternp526, placeholderp531,

size p523 p519 p450 , src , and width.

▪The following IDL attributes and methods p497 p533 p588 p588 p589 do not apply to the element: checked , selectionStart , selectionEnd , and selectionDirection IDL

attributes; p589 p589 setRangeText() , and setSelectionRange() methods.



MDN

4.10.5.1.8 Month state (type=month) p50 §

6

When an p494 p496 p506 input element's type attribute is in the Month state, the rules in this section apply.

The p494 p124 p567 p74 input element represents a control for setting the element's value to a string representing a specific month.

If the element is p567 p74 p567 mutable , the user agent should allow the user to change the month represented by its value, as obtained by

parsing a month p74 p567 from it. User agents must not allow the user to set the value to a non-empty string that is not a valid month

string p74 p74 p567 p74 . If the user agent provides a user interface for selecting a month , then the value must be set to a valid month string

representing the user's selection. User agents should allow the user to set the p567 value to the empty string.

Constraint validation p74 : While the user interface describes input that the user agent cannot convert to a valid month string, the

control is p592 suffering from bad input.

Note

See the p486 introduction section for a discussion of the difference between the input format and submission format for date, time,

and number form controls, and the p522 implementation notes regarding localization of form controls.

The p498 p74 value attribute, if specified and not empty, must have a value that is a valid month string.

The p498 p567 p74 value sanitization algorithm is as follows : If the value of the element is not a valid month string, then set it to the empty string instead.

The p527 p74 p527 min attribute, if specified, must have a value that is a valid month string . The max attribute, if specified, must have a value that is a p74 valid month string.

The p528 p528 step attribute is expressed in months. The step scale factor is 1 (there is no conversion needed as the algorithms use months). The p528 default step is 1 month.

When the element is p592 p567 p74 suffering from a step mismatch , the user agent may round the element's value to the nearest month for which the element would not p592 suffer from a step mismatch.

The p498 p74 algorithm to convert a string to a number , given a string input , is as follows : If parsing a month from input results in an error, then return an error; otherwise, return the number of months between January 1970 and the parsed p74 month.

The p498 p74 algorithm to convert a number to a string , given a number input , is as follows : Return a valid month string that

506

represents the p74 month that has input months between it and January 1970.

The p498 p74 algorithm to convert a string to a Date object , given a string input , is as follows : If parsing a month from input results in an error, then return an error; otherwise, return p53 a new Date object representing midnight UTC on the morning of the first day of the parsed p74 month.

The p498 p74 algorithm to convert a Date object to a string , given a Date object input , is as follows : Return a valid month string

that represents the p74 month current at the time represented by input in the UTC time zone.

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

readonly p523 p524 p528 p535 p533 p534 p534 p588 , required , and step content attributes; list , value , valueAsDate , and valueAsNumber IDL attributes; select(),

stepDown() p534 p534 , and stepUp() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p531 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , placeholder,

size p523 p519 p450 , src , and width.

▪The following IDL attributes and methods do not applyp497 to the element: checkedp533, filesp534, selectionStartp588, selectionEndp588, and

selectionDirection p589 p589 p589 IDL attributes; setRangeText() , and setSelectionRange() methods.



✔ MDN

4.10.5.1.9 Week state (type=week) p50 §

7

When an p494 p496 p507 input element's type attribute is in the Week state, the rules in this section apply.

The p494 p124 p567 p81 input element represents a control for setting the element's value to a string representing a specific week.

If the element is p567 p81 p567 mutable , the user agent should allow the user to change the week represented by its value , as obtained by

parsing a week p81 p567 from it. User agents must not allow the user to set the value to a non-empty string that is not a valid week

string p81 p81 p567 p81 . If the user agent provides a user interface for selecting a week , then the value must be set to a valid week string

representing the user's selection. User agents should allow the user to set the p567 value to the empty string.

Constraint validation p81 : While the user interface describes input that the user agent cannot convert to a valid week string, the control is p592 suffering from bad input.

Note

See the p486 introduction section for a discussion of the difference between the input format and submission format for date, time,

and number form controls, and the p522 implementation notes regarding localization of form controls.

The p498 p81 value attribute, if specified and not empty, must have a value that is a valid week string.

The p498 p567 p81 value sanitization algorithm is as follows : If the value of the element is not a valid week string, then set it to the empty string instead.

The p527 p81 p527 min attribute, if specified, must have a value that is a valid week string . The max attribute, if specified, must have a value that is a p81 valid week string.

The p528 p528 step attribute is expressed in weeks. The step scale factor is 604,800,000 (which converts the weeks to milliseconds, as used in the other algorithms). The p528 p528 default step is 1 week. The default step base is −259,200,000 (the start of week 1970-W01).

When the element is p592 p567 p81 suffering from a step mismatch , the user agent may round the element's value to the nearest week for which the element would not p592 suffer from a step mismatch.

The p498 p81 algorithm to convert a string to a number , given a string input , is as follows : If parsing a week string from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z") to midnight UTC on the morning of the Monday of the parsed p81 week, ignoring leap seconds.

The p498 p81 algorithm to convert a number to a string , given a number input , is as follows : Return a valid week string that represents the p81 week that, in UTC, is current input milliseconds after midnight UTC on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0Z").

507

The p498 p81 algorithm to convert a string to a Date object , given a string input , is as follows : If parsing a week from input results in an error, then return an error; otherwise, return p53 a new Date object representing midnight UTC on the morning of the Monday of the parsed p81 week.

The p498 p81 algorithm to convert a Date object to a string , given a Date object input , is as follows : Return a valid week string

that represents the p81 week current at the time represented by input in the UTC time zone.

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

readonly p523 p524 p528 p535 p533 p534 p534 p588 , required , and step content attributes; list , value , valueAsDate , and valueAsNumber IDL attributes; select(),

stepDown() p534 p534 , and stepUp() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p531 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , placeholder,

size p523 p519 p450 , src , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd, and

selectionDirection p589 p589 p589 IDL attributes; setRangeText() , and setSelectionRange() methods.



✔ MDN

4.10.5.1.10 Time state (type=time) p50 §

8

When an p494 p496 p508 input element's type attribute is in the Time state, the rules in this section apply.

The p494 p124 p567 p76 input element represents a control for setting the element's value to a string representing a specific time.

If the element is p567 p76 p567 mutable , the user agent should allow the user to change the time represented by its value, as obtained by

parsing a time p76 p567 from it. User agents must not allow the user to set the value to a non-empty string that is not a valid time

string p76 p76 p567 p76 . If the user agent provides a user interface for selecting a time , then the value must be set to a valid time string

representing the user's selection. User agents should allow the user to set the p567 value to the empty string.

Constraint validation p76 : While the user interface describes input that the user agent cannot convert to a valid time string, the

control is p592 suffering from bad input.

Note

See the p486 introduction section for a discussion of the difference between the input format and submission format for date, time,

and number form controls, and the p522 implementation notes regarding localization of form controls.

The p498 p76 value attribute, if specified and not empty, must have a value that is a valid time string.

The p498 p567 p76 value sanitization algorithm is as follows : If the value of the element is not a valid time string, then set it to the empty string instead.

The form control p527 has a periodic domain.

The p527 p76 p527 min attribute, if specified, must have a value that is a valid time string . The max attribute, if specified, must have a value that is a p76 valid time string.

The p528 p528 step attribute is expressed in seconds. The step scale factor is 1000 (which converts the seconds to milliseconds, as used in the other algorithms). The p528 default step is 60 seconds.

When the element is p592 p567 p76 suffering from a step mismatch , the user agent may round the element's value to the nearest time for which the element would not p592 suffer from a step mismatch.

The p498 p76 algorithm to convert a string to a number , given a string input , is as follows : If parsing a time from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight to the parsed p76 time on a day with no time changes.

The p498 p76 algorithm to convert a number to a string , given a number input , is as follows : Return a valid time string that represents the p76 time that is input milliseconds after midnight on a day with no time changes.

The p498 p76 algorithm to convert a string to a Date object , given a string input , is as follows : If parsing a time from input results in an error, then return an error; otherwise, return p53 p76 a new Date object representing the parsed time in UTC on 1970-01-01.

508

The p498 p76 algorithm to convert a Date object to a string , given a Date object input , is as follows : Return a valid time string

that represents the UTC p76 time component that is represented by input.

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

readonly p523 p524 p528 p535 p533 p534 p534 p588 , required , and step content attributes; list , value , valueAsDate , and valueAsNumber IDL attributes; select(),

stepDown() p534 p534 , and stepUp() methods.

▪The valuep533 IDL attribute is in mode valuep533.

▪The inputp1271 and changep1271 events apply p497.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p531 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , placeholder,

size p523 p519 p450 , src , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd, and

selectionDirection p589 p589 p589 IDL attributes; setRangeText() , and setSelectionRange() methods.



✔ MDN

4.10.5.1.11 Local Date and Time state (type=datetime-local) p50 §

9

When an p494 p496 p509 input element's type attribute is in the Local Date and Time state, the rules in this section apply.

The p494 p124 p567 p77 input element represents a control for setting the element's value to a string representing a local date and time, with no time-zone offset information.

If the element is p567 p77 p567 mutable , the user agent should allow the user to change the date and time represented by its value, as obtained by p78 p567 parsing a date and time from it. User agents must not allow the user to set the value to a non-empty string that is not a p77 p77 valid normalized local date and time string . If the user agent provides a user interface for selecting a local date and time, then the p567 p77 value must be set to a valid normalized local date and time string representing the user's selection. User agents should allow the user to set the p567 value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid normalized local date

and time string p77 p592 , the control is suffering from bad input.

Note

See the p486 introduction section for a discussion of the difference between the input format and submission format for date, time,

and number form controls, and the p522 implementation notes regarding localization of form controls.

The p498 p77 value attribute, if specified and not empty, must have a value that is a valid local date and time string.

The p498 p567 p77 value sanitization algorithm is as follows : If the value of the element is a valid local date and time string, then set it

to a p77 valid normalized local date and time string representing the same date and time; otherwise, set it to the empty string instead.

The p527 p77 p527 min attribute, if specified, must have a value that is a valid local date and time string . The max attribute, if specified, must have a value that is a p77 valid local date and time string.

The p528 p528 step attribute is expressed in seconds. The step scale factor is 1000 (which converts the seconds to milliseconds, as used in the other algorithms). The p528 default step is 60 seconds.

When the element is p592 p567 suffering from a step mismatch , the user agent may round the element's value to the nearest local date

and time p77 p592 for which the element would not suffer from a step mismatch .

The p498 p78 algorithm to convert a string to a number , given a string input , is as follows : If parsing a date and time from input results in an error, then return an error; otherwise, return the number of milliseconds elapsed from midnight on the morning of 1970-01-01 (the time represented by the value " p77 1970-01-01T00:00:00.0 ") to the parsed local date and time, ignoring leap seconds.

The p498 algorithm to convert a number to a string, given a number input, is as follows: Return a valid normalized local date

and time string p77 that represents the date and time that is input milliseconds after midnight on the morning of 1970-01-01 (the time represented by the value "1970-01-01T00:00:00.0").

Note

See p506 p505 the note on historical dates in the Date state section.

509

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

readonly p523 p524 p528 p535 p533 p534 p588 p534 , required , and step content attributes; list , value , and valueAsNumber IDL attributes; select() , stepDown(), and

stepUp()p534 methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p498 p570 p572 do not apply to the element: accept , alt , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p531 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , placeholder,

size p523 p519 p450 , src , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd,

selectionDirection p589 p534 p589 p589 , and valueAsDate IDL attributes; setRangeText() , and setSelectionRange() methods.

Example

The following example shows part of a flight booking application. The application uses an p494 p496 input element with its type

attribute set to p509 datetime-local , and it then interprets the given date and time in the time zone of the selected airport.





Destination



Airport:

Departure time:





✔ MDN

4.10.5.1.12 Number state (type=number) p51 §

0

When an p494 p496 p510 input element's type attribute is in the Number state, the rules in this section apply.

The p494 p124 p567 input element represents a control for setting the element's value to a string representing a number.

If the element is p567 p567 mutable , the user agent should allow the user to change the number represented by its value, as obtained from applying the p70 p567 rules for parsing floating-point number values to it. User agents must not allow the user to set the value to a non-

empty string that is not a p69 valid floating-point number. If the user agent provides a user interface for selecting a number, then the

value p567 p70 must be set to the best representation of the number representing the user's selection as a floating-point number. User agents should allow the user to set the p567 value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid floating-point

number p69 p592 , the control is suffering from bad input.

Note

This specification does not define what user interface user agents are to use; user agent vendors are encouraged to consider what

would best serve their users' needs. For example, a user agent in Persian or Arabic markets might support Persian and Arabic

numeric input (converting it to the format required for submission as described above). Similarly, a user agent designed for

Romans might display the value in Roman numerals rather than in decimal; or (more realistically) a user agent designed for the

French market might display the value with apostrophes between thousands and commas before the decimals, and allow the user

to enter a value in that manner, internally converting it to the submission format described above.

The p498 p69 value attribute, if specified and not empty, must have a value that is a valid floating-point number.

The p498 p567 p69 value sanitization algorithm is as follows : If the value of the element is not a valid floating-point number, then set it to the empty string instead.

The p527 p69 p527 min attribute, if specified, must have a value that is a valid floating-point number . The max attribute, if specified, must have a value that is a p69 valid floating-point number.

510

The p528 p528 p528 step scale factor is 1. The default step is 1 (allowing only integers to be selected by the user, unless the step base has a non-integer value).

When the element is p592 p567 suffering from a step mismatch , the user agent may round the element's value to the nearest number for which the element would not p592 suffer from a step mismatch. If there are two such numbers, user agents are encouraged to pick the one nearest positive infinity.

The p498 algorithm to convert a string to a number, given a string input, is as follows: If applying the rules for parsing

floating-point number values p70 to input results in an error, then return an error; otherwise, return the resulting number.

The p498 algorithm to convert a number to a string, given a number input, is as follows: Return a valid floating-point

number p69 that represents input.

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

placeholder p531 p523 p524 p528 p535 p533 p534 p588 , readonly , required , and step content attributes; list , value , and valueAsNumber IDL attributes; select(),

stepDown() p534 p534 , and stepUp() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The inputp1271 and changep1271 events apply p497.

▪The following content attributes must not be specified and do not applyp497 to the element: acceptp517, altp520, checkedp498, dirnamep570, formactionp572,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p523 p519 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , size , src,

and p450 width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd,

selectionDirection p589 p534 p589 p589 , and valueAsDate IDL attributes; setRangeText() , and setSelectionRange() methods.

Example

Here is an example of using a numeric input control:

How much do you want to charge? $

As described above, a user agent might support numeric input in the user's local format, converting it to the format required for

submission as described above. This might include handling grouping separators (as in "872,000,000,000") and various decimal

separators (such as "3,99" vs "3.99") or using local digits (such as those in Arabic, Devanagari, Persian, and Thai).



Note

The type=number state is not appropriate for input that happens to only consist of numbers but isn't strictly speaking a number.

For example, it would be inappropriate for credit card numbers or US postal codes. A simple way of determining whether to use

type=number is to consider whether it would make sense for the input control to have a spinbox interface (e.g. with "up" and

"down" arrows). Getting a credit card number wrong by 1 in the last digit isn't a minor mistake, it's as wrong as getting every digit

incorrect. So it would not make sense for the user to select a credit card number using "up" and "down" buttons. When a spinbox

interface is not appropriate, p796 p526 type=text is probably the right choice (possibly with an inputmode or pattern attribute).



✔ MDN

4.10.5.1.13 Range state (type=range) p51 §

1

When an p494 p496 p511 input element's type attribute is in the Range state, the rules in this section apply.

The p494 p124 p567 input element represents a control for setting the element's value to a string representing a number, but with the caveat that the exact value is not important, letting UAs provide a simpler interface than they do for the p510 Number state.

If the element is p567 p567 mutable , the user agent should allow the user to change the number represented by its value, as obtained from applying the p70 p567 rules for parsing floating-point number values to it. User agents must not allow the user to set the value to a string that is not a p69 p567 valid floating-point number . If the user agent provides a user interface for selecting a number, then the value must be set to a p70 best representation of the number representing the user's selection as a floating-point number. User agents must not

allow the user to set the p567 value to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid floating-point

number p69 p592 , the control is suffering from bad input.

The p498 p69 value attribute, if specified, must have a value that is a valid floating-point number.

511

The p498 p567 p69 value sanitization algorithm is as follows : If the value of the element is not a valid floating-point number, then set it

to the p70 p512 best representation, as a floating-point number , of the default value.

The p527 p527 p527 default value is the minimum plus half the difference between the minimum and the maximum, unless the

maximum p527 p527 p512 p527 is less than the minimum , in which case the default value is the minimum .

When the element is p591 p567 suffering from an underflow , the user agent must set the element's value to the best representation, as a

floating-point number p70 p527 , of the minimum.

When the element is p592 p527 p527 suffering from an overflow , if the maximum is not less than the minimum, the user agent must set the

element's p567 p69 p527 value to a valid floating-point number that represents the maximum .

When the element is p592 p567 suffering from a step mismatch , the user agent must round the element's value to the nearest number for which the element would not p592 p527 suffer from a step mismatch , and which is greater than or equal to the minimum, and, if the

maximum p527 p527 p527 is not less than the minimum , which is less than or equal to the maximum, if there is a number that matches these constraints. If two numbers match these constraints, then user agents must use the one nearest to positive infinity.

Example

For example, the markup results in a range control whose initial value

is 60.



Example

Here is an example of a range control using an autocomplete list with the p529 list attribute. This could be useful if there are values

along the full range of the control that are especially important, such as preconfigured light levels or typical speed limits in a range

control used as a speed control. The following markup fragment:





...with the following style sheet applied:

CSS input { height: 75px; width: 49px; background: #D5CCBB; color: black; }

...might render as:





Note how the UA determined the orientation of the control from the ratio of the style-sheet-specified height and width properties.

The colors were similarly derived from the style sheet. The tick marks, however, were derived from the markup. In particular, the

step p528 attribute has not affected the placement of tick marks, the UA deciding to only use the author-specified completion values

and then adding longer tick marks at the extremes.

Note also how the invalid value ++50 was completely ignored.



Example

For another example, consider the following markup fragment:



A user agent could display in a variety of ways, for instance:

512



Or, alternatively, for instance:





The user agent could pick which one to display based on the dimensions given in the style sheet. This would allow it to maintain

the same resolution for the tick marks, despite the differences in width.



Example

Finally, here is an example of a range control with two labeled values:





With styles that make the control draw vertically, it might look as follows:





Note

In this state, the range and step constraints are enforced even during user input, and there is no way to set the value to the empty

string.

The p527 p69 p527 p527 min attribute, if specified, must have a value that is a valid floating-point number . The default minimum is 0. The max

attribute, if specified, must have a value that is a p69 p527 valid floating-point number . The default maximum is 100.

The p528 p528 p527 step scale factor is 1. The default step is 1 (allowing only integers, unless the min attribute has a non-integer value).

The p498 algorithm to convert a string to a number, given a string input, is as follows: If applying the rules for parsing

floating-point number values p70 to input results in an error, then return an error; otherwise, return the resulting number.

The p498 algorithm to convert a number to a string, given a number input, is as follows: Return the best representation, as a

floating-point number p70, of input.

Bookkeeping details

▪The following common p494 p497 p574 p529 p527 p527 input element content attributes, IDL attributes, and methods apply to the element: autocomplete , list , max , min,

and p528 p535 p533 p534 p534 p534 step content attributes; list , value , and valueAsNumber IDL attributes; stepDown() and stepUp() methods.

▪The p533 p533 value IDL attribute is in mode value.

▪The inputp1271 and changep1271 events apply p497.

▪The following content attributes must not be specified and do not applyp497 to the element: acceptp517, altp520, checkedp498, dirnamep570, formactionp572,

formenctype p573 p572 p573 p573 p450 p523 p523 p525 p526 p531 , formmethod , formnovalidate , formtarget , height , maxlength , minlength , multiple , pattern , placeholder,

513

readonly p523 p524 p523 p519 p450 , required , size , src , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd,

selectionDirection p589 p534 p588 p589 p589 , and valueAsDate IDL attributes; select() , setRangeText() , and setSelectionRange() methods.



✔ MDN

4.10.5.1.14 Color state (type=color) p51 §

4

When an p494 p496 p514 input element's type attribute is in the Color state, the rules in this section apply.

The p494 p124 p567 p85 input element represents a color well control, for setting the element's value to a string representing a simple color.

Note

In this state, there is always a color picked, and there is no way to set the value to the empty string.

If the element is p567 p567 mutable , the user agent should allow the user to change the color represented by its value , as obtained from applying the p86 p567 rules for parsing simple color values to it. User agents must not allow the user to set the value to a string that is not a p86 p567 valid lowercase simple color . If the user agent provides a user interface for selecting a color, then the value must be set to the result of using the p86 rules for serializing simple color values to the user's selection. User agents must not allow the user to set the

value p567 to the empty string.

Constraint validation: While the user interface describes input that the user agent cannot convert to a valid lowercase simple

color p86 p592 , the control is suffering from bad input .

The p498 p85 value attribute, if specified and not empty, must have a value that is a valid simple color.

The p498 p567 p85 value sanitization algorithm is as follows : If the value of the element is a valid simple color, then set it to the

value p567 of the element converted to ASCII lowercase; otherwise, set it to the string "#000000".

Bookkeeping details

▪The following common p494 p497 p574 p529 input element content attributes and IDL attributes apply to the element: autocomplete and list content attributes;

list p535 p533 p588 and value IDL attributes; select() method.

▪The p533 p533 value IDL attribute is in mode value.

▪The inputp1271 and changep1271 events apply p497.

▪The following content attributes must not be specified and do not applyp497 to the element: acceptp517, altp520, checkedp498, dirnamep570, formactionp572,

formenctype p573 p572 p573 p573 p450 p527 p523 p527 p523 p525 p526 , formmethod , formnovalidate , formtarget , height , max , maxlength , min , minlength , multiple , pattern,

placeholder p531 p523 p524 p523 p519 p528 p450 , readonly , required , size , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p588 p588 do not apply to the element: checked , files , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p589 p589 p534 , valueAsDate and, valueAsNumber IDL attributes; setRangeText() , setSelectionRange() , stepDown(), and

stepUp() p534 methods.



✔ MDN

4.10.5.1.15 Checkbox state (type=checkbox) p51 §

4

When an p494 p496 p514 input element's type attribute is in the Checkbox state, the rules in this section apply.

The p494 p124 p567 input element represents a two-state control that represents the element's checkedness state. If the element's

checkedness p567 state is true, the control represents a positive selection, and if it is false, a negative selection. If the element's

indeterminate p500 IDL attribute is set to true, then the control's selection should be obscured as if the control was in a third, indeterminate, state.

Note

The control is never a true tri-state control, even if the element's p500 indeterminate IDL attribute is set to true. The

indeterminate p500 IDL attribute only gives the appearance of a third state.

The p499 input activation behavior is to run the following steps:

1. If the element is not connected, then return.

2. p1271 Fire an event named input at the element with the bubbles and composed attributes initialized to true.

3. p1271 Fire an event named change at the element with the bubbles attribute initialized to true.

514

Constraint validation p524 p567 : If the element is required and its checkedness is false, then the element is suffering from being

missing p591 .

For web developers (non-normative)

input p500 . indeterminate [ = value ]

When set, overrides the rendering of p514 checkbox controls so that the current value is not visible.

Bookkeeping details

▪The following common inputp494 element content attributes and IDL attributes applyp497 to the element: checkedp498, and requiredp524 content attributes;

checked p533 p533 and value IDL attributes.

▪The p533 p533 value IDL attribute is in mode default/on.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p574 p570 p572 do not apply to the element: accept , alt , autocomplete , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 p525 , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength , multiple,

pattern p526, placeholderp531, readonlyp523, sizep523, src p519, stepp528, and widthp450.

▪The following IDL attributes and methods p497 p534 p535 p588 p588 p589 do not apply to the element: files , list , selectionStart , selectionEnd , selectionDirection,

valueAsDate p534 p534 p588 p589 p589 p534 p534 , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown() , and stepUp() methods.



✔ MDN

4.10.5.1.16 Radio Button state (type=radio) p51 §

5

When an p494 p496 p515 input element's type attribute is in the Radio Button state, the rules in this section apply.

The p494 p124 p494 input element represents a control that, when used in conjunction with other input elements, forms a radio button

group p515 p567 p567 in which only one control can have its checkedness state set to true. If the element's checkedness state is true, the control represents the selected control in the group, and if it is false, it indicates a control in the group that is not selected.

The p494 p494 radio button group that contains an input element a also contains all the other input elements b that fulfill all of the following conditions:

• The p494 p496 p515 input element b 's type attribute is in the Radio Button state.

• Either p567 p567 a and b have the same form owner , or they both have no form owner .

• Both a and b are in the same tree.

• They both have a p569 p569 p569 name attribute, their name attributes are not empty, and the value of a 's name attribute equals the

value of p569 b 's name attribute.

A p494 p515 tree must not contain an input element whose radio button group contains only that element.

When any of the following phenomena occur, if the element's p567 p567 checkedness state is true after the occurrence, the checkedness

state of all the other elements in the same p515 radio button group must be set to false:

• The element's p567 checkedness state is set to true (for whatever reason).

• The element's p569 name attribute is set, changed, or removed.

• The element's p567 form owner changes.

• p499 A type change is signalled for the element.

The p499 input activation behavior is to run the following steps:

1. If the element is not connected, then return.

2. p1271 Fire an event named input at the element with the bubbles and composed attributes initialized to true.

3. p1271 Fire an event named change at the element with the bubbles attribute initialized to true.

Constraint validation p515 p524 p494 : If an element in the radio button group is required , and all of the input elements in the radio button

group p515 p567 p591 have a checkedness that is false, then the element is suffering from being missing .



515

Example

The following example, for some reason, has specified that puppers are both p524 p571 required and disabled:





Pupper

Doggo

Make your choice





If the user tries to submit this form without first selecting "Doggo", then p494 both input elements will be suffering from being

missing p591 p515 p524 , since an element in the radio button group is required (viz. the first element), and both of the elements in the

radio button group have a false p567 checkedness.

On the other hand, if the user selects "Doggo" and then submits the form, then neither p494 input element will be suffering from

being missing p591 p524 p567 , since while one of them is required , not all of them have a false checkedness .



Note

If none of the radio buttons in a p515 radio button group are checked, then they will all be initially unchecked in the interface, until

such time as one of them is checked (either by the user or by script).

Bookkeeping details

▪The following common p494 p497 p498 p524 input element content attributes and IDL attributes apply to the element: checked and required content attributes;

checked p533 p533 and value IDL attributes.

▪The p533 p533 value IDL attribute is in mode default/on.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p517 p520 p574 p570 p572 do not apply to the element: accept , alt , autocomplete , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 p525 , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength , multiple,

pattern p526 p531 p523 p523 p519 p528 p450 , placeholder , readonly , size , src , step , and width.

▪The following IDL attributes and methods p497 p534 p535 p588 p588 p589 do not apply to the element: files , list , selectionStart , selectionEnd , selectionDirection,

valueAsDate p534 p534 p588 p589 p589 p534 p534 , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown() , and stepUp() methods.



✔ MDN

4.10.5.1.17 File Upload state (type=file) p51 §

6 ✔ MDN

When an p494 p496 p516 input element's type attribute is in the File Upload state, the rules in this section apply.

The p494 p124 input element represents a list of selected files, each file consisting of a file name, a file type, and a file body (the contents of the file).

File names must not contain p516 path components , even in the case that a user has selected an entire directory hierarchy or multiple files with the same name from different directories. p516 Path components , for the purposes of the File Upload state, are those parts of file names that are separated by U+005C REVERSE SOLIDUS character (\) characters.

Unless the p525 p516 multiple attribute is set, there must be no more than one file in the list of selected files .

The element's p499 input activation behavior is to run the following steps:

1. If the algorithm is invoked when the element's p828 p770 Window object does not have transient activation , then return without

doing anything else.

2. Run these steps p42 in parallel:

1. Optionally, wait until any prior execution of this algorithm has terminated.

2. Display a prompt to the user requesting that the user specify some files. If the p525 multiple attribute is not set,

there must be no more than one file selected; otherwise, any number may be selected. Files can be from the filesystem or created on the fly, e.g., a picture taken from a camera connected to the user's device.

3. Wait for the user to have made their selection.

4. p517 p494 Update the file selection for the input element.

516

If the element is p567 mutable, the user agent should allow the user to change the files on the list in other ways also, e.g., adding or

removing files by drag-and-drop. When the user does so, the user agent must p517 update the file selection for the element.

If the element is not p567 mutable, the user agent must not allow the user to change the element's selection.

To update the file selection for an element element:

1. p933 p939 Queue an element task on the user interaction task source given element and the following steps:

1. Update p516 element 's selected files so that it represents the user's selection.

2. p1271 p494 Fire an event named input at the input element, with the bubbles and composed attributes initialized to

true.

3. p1271 p494 Fire an event named change at the input element, with the bubbles attribute initialized to true.

Constraint validation p524 p516 : If the element is required and the list of selected files is empty, then the element is suffering from

being missing p591.



The accept attribute may be specified to provide user agents with a hint of what file types will be accepted. ✔ MDN

If specified, the attribute must consist of a p87 set of comma-separated tokens, each of which must be an ASCII case-insensitive match for one of the following: The string "audio/*"

Indicates that sound files are accepted.

The string "video/*"

Indicates that video files are accepted.

The string "image/*"

Indicates that image files are accepted.

A valid MIME type string with no parameters

Indicates that files of the specified type are accepted.

A string whose first character is a U+002E FULL STOP character (.)

Indicates that files with the specified file extension are accepted.

The tokens must not be ASCII case-insensitive matches for any of the other tokens (i.e. duplicates are not allowed). To obtain the list of tokens from the attribute, the user agent must split the attribute value on commas.

User agents may use the value of this attribute to display a more appropriate user interface than a generic file picker. For instance, given the value image/*, a user agent could offer the user the option of using a local camera or selecting a photograph from their photo collection; given the value audio/*, a user agent could offer the user the option of recording a clip using a headset microphone.

User agents should prevent the user from selecting files that are not accepted by one (or more) of these tokens.

Note

Authors are encouraged to specify both any MIME types and any corresponding extensions when looking for data in a specific

format.



Example

For example, consider an application that converts Microsoft Word documents to Open Document Format files. Since Microsoft

Word documents are described with a wide variety of MIME types and extensions, the site can list several, as follows:



On platforms that only use file extensions to describe file types, the extensions listed here can be used to filter the allowed

documents, while the MIME types can be used with the system's type registration table (mapping MIME types to extensions used

by the system), if any, to determine any other extensions to allow. Similarly, on a system that does not have file names or

extensions but labels documents with MIME types internally, the MIME types can be used to pick the allowed files, while the

517

extensions can be used if the system has an extension registration table that maps known extensions to MIME types used by the

system.



⚠Warning!

Extensions tend to be ambiguous (e.g. there are an untold number of formats that use the ".dat" extension, and

users can typically quite easily rename their files to have a ".doc" extension even if they are not Microsoft Word

documents), and MIME types tend to be unreliable (e.g. many formats have no formally registered types, and many

formats are in practice labeled using a number of different MIME types). Authors are reminded that, as usual, data

received from a client should be treated with caution, as it may not be in an expected format even if the user is not

hostile and the user agent fully obeyed the p517 MDN accept attribute's requirements.



Example

For historical reasons, the p533 value IDL attribute prefixes the file name with the string "C:\fakepath\". Some legacy user agents

actually included the full path (which was a security vulnerability). As a result of this, obtaining the file name from the p533 value IDL

attribute in a backwards-compatible way is non-trivial. The following function extracts the file name in a suitably compatible

manner:

function extractFilename(path) {

if (path.substr(0, 12) == "C:\\fakepath\\")

return path.substr(12); // modern browser

var x;

x = path.lastIndexOf('/');

if (x >= 0) // Unix-based path

return path.substr(x+1);

x = path.lastIndexOf('\\');

if (x >= 0) // Windows-based path

return path.substr(x+1);

return path; // just the file name

}

This can be used as follows:





The name of the file you picked is: (none)





Bookkeeping details

▪The following common inputp494 element content attributes and IDL attributes applyp497 to the element: acceptp517, multiplep525, and required p524 content

attributes; p534 p533 p588 files and value IDL attributes; select() method.

▪The p533 p533 value IDL attribute is in mode filename.

▪The p1271 p1271 p497 input and change events apply.

▪The following content attributes must not be specified and p497 p520 p574 p498 p570 p572 do not apply to the element: alt , autocomplete , checked , dirname , formaction,

formenctype p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 p526 , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength , pattern,

placeholderp531, readonly p523, sizep523, srcp519, stepp528, and widthp450.

▪The element's valuep498 attribute must be omitted.

▪The following IDL attributes and methods p497 p533 p535 p588 p588 do not apply to the element: checked , list , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; setRangeText() , setSelectionRange() , stepDown(), and

stepUp() p534 methods.



518

✔ MDN

4.10.5.1.18 Submit Button state (type=submit) p51 §

9

When an p494 p496 p519 input element's type attribute is in the Submit Button state, the rules in this section apply.

The p494 p124 p498 input element represents a button that, when activated, submits the form. If the element has a value attribute, the button's label must be the value of that attribute; otherwise, it must be an implementation-defined string that means

"Submit" or some such. The element is a p487 p487 button , specifically a submit button.

Note

Since the default label is implementation-defined, and the width of the button typically depends on the button's label, the button's

width can leak a few bits of fingerprintable information. These bits are likely to be strongly correlated to the identity of the user

agent and the user's locale.

The element's p499 p567 input activation behavior is as follows: if the element has a form owner, and the element's node document is fully

active p818 p597 p567 p494 , submit the form owner from the input element; otherwise, do nothing.

The p572 p573 p572 p573 p573 formaction , formenctype , formmethod , formnovalidate , and formtarget attributes are attributes for form

submission p571 .

Note

The p573 formnovalidate attribute can be used to make submit buttons that do not trigger the constraint validation.

Bookkeeping details

▪The following common p494 p497 p572 p573 p572 input element content attributes and IDL attributes apply to the element: formaction , formenctype , formmethod,

formnovalidate p573 p573 p533 , and formtarget content attributes; value IDL attribute.

▪The p533 p533 value IDL attribute is in mode default.

▪The following content attributes must not be specified and p497 p517 p520 p574 p498 p570 do not apply to the element: accept , alt , autocomplete , checked , dirname,

heightp450, listp529, max p527, maxlengthp523, minp527, minlengthp523, multiplep525, patternp526, placeholderp531, readonlyp523, requiredp524, sizep523, srcp519,

step p528 p450 , and width.

▪The following IDL attributes and methods p497 p533 p534 p535 p588 p588 do not apply to the element: checked , files , list , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p588 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown(),

and p534 stepUp() methods.

▪The p1271 p1271 p497 input and change events do not apply.



✔ MDN

4.10.5.1.19 Image Button state (type=image) p51 §

9

When an p494 p496 p519 input element's type attribute is in the Image Button state, the rules in this section apply.

The p494 p124 input element represents either an image from which a user can select a coordinate and submit the form, or alternatively a button from which the user can submit the form. The element is a p487 p487 button , specifically a submit button.

Note

The coordinate is sent to the server p600 during form submission by sending two entries for the element, derived from the name of

the control but with ".x" and ".y" appended to the name with the x and y components of the coordinate respectively.



The image is given by the p519 src attribute. The src attribute must be present, and must contain a valid non-empty URL potentially

surrounded by spaces p88 referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted.

When any of the these events occur

• the p494 p496 p519 input element's type attribute is first set to the Image Button state (possibly when the element is first

created), and the p519 src attribute is present

• the p494 p496 p519 p519 input element's type attribute is changed back to the Image Button state, and the src attribute is present,

and its value has changed since the last time the p496 p519 type attribute was in the Image Button state

• the p494 p496 p519 p519 input element's type attribute is in the Image Button state, and the src attribute is set or changed then unless the user agent cannot support images, or its support for images has been disabled, or the user agent only fetches images on demand, or the p519 p89 p519 src attribute's value is the empty string, the user agent must parse the value of the src attribute value,

519

relative to the element's node document, and if that is successful, then:

1. Let p89 request be a new request whose url is the resulting URL record, client is the element's node document's relevant

settings object p911, destination is "image", credentials mode is "include", and whose use-URL-credentials flag is set.

2. Fetch request.

Fetching the image must p1162 p932 p933 delay the load event of the element's node document until the task that is queued by the

networking task source p939 once the resource has been fetched (defined below) has been run.

If the image was successfully obtained, with no network errors, and the image's type is a supported image type, and the image is a valid image of that type, then the image is said to be available. If this is true before the image is completely downloaded, each

task p932 p933 p939 that is queued by the networking task source while the image is being fetched must update the presentation of the image appropriately.

The user agent should apply the image sniffing rules to determine the type of the image, with the image's associated Content-Type

headers p90 giving the official type. If these rules are not applied, then the type of the image must be the type given by the image's

associated Content-Type headers p90.

User agents must not support non-image resources with the p494 input element. User agents must not run executable code embedded in the image resource. User agents must only display the first page of a multipage resource. User agents must not allow the resource to act in an interactive fashion, but should honor any animation in the resource.

The p932 p933 p939 task that is queued by the networking task source once the resource has been fetched, must, if the download was successful and the image is p520 p933 p939 p494 available , queue an element task on the user interaction task source given the input

element to p1271 p494 fire an event named load at the input element; and otherwise, if the fetching process fails without a response from the remote server, or completes but the image is not a valid or supported image, p933 queue an element task on the user interaction

task source p939 p494 p1271 p494 given the input element to fire an event named error on the input element.



The p520 alt attribute provides the textual label for the button for users and user agents who cannot use the image. The alt attribute must be present, and must contain a non-empty string giving the label that would be appropriate for an equivalent button if the image was unavailable.

The p494 p450 input element supports dimension attributes.



If the p519 p520 src attribute is set, and the image is available and the user agent is configured to display that image, then: The element

represents p124 p520 p519 p567 a control for selecting a coordinate from the image specified by the src attribute; if the element is mutable ,

the user agent should allow the user to select this p520 p499 coordinate , and the element's input activation behavior is as follows: if the element has a p567 p818 p520 form owner , and the element's node document is fully active , take the user's selected coordinate , and

submit p597 p494 p567 p494 the input element's form owner from the input element. If the user activates the control without explicitly selecting a coordinate, then the coordinate (0,0) must be assumed.

Otherwise, the element p124 p520 represents a submit button whose label is given by the value of the alt attribute; the element's input

activation behavior p499 p567 p818 is as follows: if the element has a form owner , and the element's node document is fully active , set the

selected coordinate p520 p597 p494 p567 p494 to (0,0), and submit the input element's form owner from the input element.

In either case, if the element has no p567 p818 form owner or the element's node document is not fully active, then its input activation

behavior p499 must be to do nothing..

The selected coordinate must consist of an x-component and a y-component. The coordinates represent the position relative to the edge of the image, with the coordinate space having the positive x direction to the right, and the positive y direction downwards.

The p68 x-component must be a valid integer representing a number x in the range −(borderleft+paddingleft) ≤ x ≤ width+borderright+paddingright, where width is the rendered width of the image, borderleft is the width of the border on the left of the image, paddingleft is the width of the padding on the left of the image, borderright is the width of the border on the right of the image, and paddingright is the width of the padding on the right of the image, with all dimensions given in CSS pixels.

The p68 y-component must be a valid integer representing a number y in the range −(bordertop+paddingtop) ≤ y ≤ height+borderbottom+paddingbottom, where height is the rendered height of the image, bordertop is the width of the border above the image, paddingtop is the width of the padding above the image, borderbottom is the width of the border below the image, and paddingbottom is the width of the padding below the image, with all dimensions given in CSS pixels.

520

Where a border or padding is missing, its width is zero CSS pixels.



The p572 p573 p572 p573 p573 formaction , formenctype , formmethod , formnovalidate , and formtarget attributes are attributes for form

submission p571 .

For web developers (non-normative)

image p500 . width [ = value ]

image p500 . height [ = value ]

These attributes return the actual rendered dimensions of the image, or zero if the dimensions are not known. They can be set, to change the corresponding content attributes.

Bookkeeping details

▪The following common p494 p497 p520 p572 p573 input element content attributes and IDL attributes apply to the element: alt , formaction , formenctype,

formmethod p572 p573 p573 p450 p519 p450 p533 , formnovalidate , formtarget , height , src , and width content attributes; value IDL attribute.

▪The p533 p533 value IDL attribute is in mode default.

▪The following content attributes must not be specified and p497 p517 p574 p498 p570 p529 do not apply to the element: accept , autocomplete , checked , dirname , list,

max p527 p523 p527 p523 p525 p526 p531 p523 p524 p523 p528 , maxlength , min , minlength , multiple , pattern , placeholder , readonly , required , size , and step.

▪The element's p498 value attribute must be omitted.

▪The following IDL attributes and methods do not applyp497 to the element: checkedp533, filesp534, listp535, selectionStartp588, selectionEnd p588,

selectionDirection p589 p534 p534 p588 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown(),

and p534 stepUp() methods.

▪The p1271 p1271 p497 input and change events do not apply.

Note

Many aspects of this state's behavior are similar to the behavior of the p321 img element. Readers are encouraged to read that

section, where many of the same requirements are described in more detail.



Example

Take the following form:





If the user clicked on the image at coordinate (127,40) then the URL used to submit the form would be

"process.cgi?where.x=127&where.y=40".

(In this example, it's assumed that for users who don't see the map, and who instead just see a button labeled "Show location list",

clicking the button will cause the server to show a list of locations to pick from instead of the map.)



✔ MDN

4.10.5.1.20 Reset Button state (type=reset) p52 §

1

When an p494 p496 p521 input element's type attribute is in the Reset Button state, the rules in this section apply.

The p494 p124 p498 input element represents a button that, when activated, resets the form. If the element has a value attribute, the button's label must be the value of that attribute; otherwise, it must be an implementation-defined string that means

"Reset" or some such. The element is a p487 button .

Note

Since the default label is implementation-defined, and the width of the button typically depends on the button's label, the button's

width can leak a few bits of fingerprintable information. These bits are likely to be strongly correlated to the identity of the user

agent and the user's locale.

The element's p499 p567 p818 input activation behavior , if the element has a form owner and the element's node document is fully active , is

to p604 p567 reset the form owner; otherwise, it is to do nothing.

521

Constraint validation p591 : The element is barred from constraint validation.

Bookkeeping details

▪The p533 p497 p533 value IDL attribute applies to this element and is in mode default.

▪The following content attributes must not be specified and p497 p517 p520 p574 p498 p570 do not apply to the element: accept , alt , autocomplete , checked , dirname,

formaction p572 p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 , formenctype , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength,

multiple p525 p526 p531 p523 p524 p523 p519 p528 p450 , pattern , placeholder , readonly , required , size , src , step , and width.

▪The following IDL attributes and methods p497 p533 p534 p535 p588 p588 do not apply to the element: checked , files , list , selectionStart , selectionEnd,

selectionDirection p589 p534 p534 p588 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown(),

and p534 stepUp() methods.

▪The p1271 p1271 p497 input and change events do not apply.



✔ MDN

4.10.5.1.21 Button state (type=button) p52 §

2

When an p494 p496 p522 input element's type attribute is in the Button state, the rules in this section apply.

The p494 p124 p498 input element represents a button with no default behavior. A label for the button must be provided in the value

attribute, though it may be the empty string. If the element has a p498 value attribute, the button's label must be the value of that attribute; otherwise, it must be the empty string. The element is a p487 button.

The element has no p499 input activation behavior.

Constraint validation p591 : The element is barred from constraint validation.

Bookkeeping details

▪The p533 p497 p533 value IDL attribute applies to this element and is in mode default.

▪The following content attributes must not be specified and p497 p517 p520 p574 p498 p570 do not apply to the element: accept , alt , autocomplete , checked , dirname,

formaction p572 p573 p572 p573 p573 p450 p529 p527 p523 p527 p523 , formenctype , formmethod , formnovalidate , formtarget , height , list , max , maxlength , min , minlength,

multiple p525 p526 p531 p523 p524 p523 p519 p528 p450 , pattern , placeholder , readonly , required , size , src , step , and width.

▪The following IDL attributes and methods do not applyp497 to the element: checkedp533, filesp534, listp535, selectionStartp588, selectionEnd p588,

selectionDirection p589 p534 p534 p588 p589 p589 p534 , valueAsDate , and valueAsNumber IDL attributes; select() , setRangeText() , setSelectionRange() , stepDown(),

and p534 stepUp() methods.

▪The p1271 p1271 p497 input and change events do not apply.



4.10.5.2 Implementation notes regarding localization of form controls p52 §

2

This section is non-normative.

The formats shown to the user in date, time, and number controls is independent of the format used for form submission.

Browsers are encouraged to use user interfaces that present dates, times, and numbers according to the conventions of either the locale implied by the p494 p141 input element's language or the user's preferred locale. Using the page's locale will ensure consistency with page-provided data.

Example

For example, it would be confusing to users if an American English page claimed that a Cirque De Soleil show was going to be

showing on 02/03, but their browser, configured to use the British English locale, only showed the date 03/02 in the ticket purchase

date picker. Using the page's locale would at least ensure that the date was presented in the same format everywhere. (There's

still a risk that the user would end up arriving a month late, of course, but there's only so much that can be done about such

cultural differences...)



4.10.5.3 Common p494 p52 input element attributes §

2

These attributes only p497 p494 p496 apply to an input element if its type attribute is in a state whose definition declares that the attribute

applies p497 p497 p494 p44 . When an attribute doesn't apply to an input element, user agents must ignore the attribute, regardless of the requirements and definitions below.



522

4.10.5.3.1 The p523 p523 p52 maxlength and minlength attributes §

3 ✔ MDN

The p497 p570 maxlength attribute, when it applies , is a form control maxlength attribute. ✔ MDN

The p497 p570 minlength attribute, when it applies , is a form control minlength attribute.

If the p494 p570 p498 input element has a maximum allowed value length , then the length of the value of the element's value attribute must be equal to or less than the element's p570 maximum allowed value length.

Example

The following extract shows how a messaging client's text entry could be arbitrarily restricted to a fixed number of characters, thus

forcing any conversation through this medium to be terse and discouraging intelligent discourse.

What are you doing?



Example

Here, a password is given a minimum length:



Username:



Password:



4.10.5.3.2 The p523 p52 size attribute §

3

The size attribute gives the number of characters that, in a visual rendering, the user agent is to allow the user to see while editing the element's p567 value .

The p523 p69 size attribute, if specified, must have a value that is a valid non-negative integer greater than zero.

If the attribute is present, then its value must be parsed using the p69 rules for parsing non-negative integers, and if the result is a number greater than zero, then the user agent should ensure that at least that many characters are visible.

The p500 p96 size IDL attribute is limited to only non-negative numbers greater than zero and has a default value of 20.



4.10.5.3.3 The p523 ✔ MDN p52 readonly attribute §

3

The p67 readonly attribute is a boolean attribute that controls whether or not the user can edit the form control. When specified, the element is not p567 mutable.

Constraint validation p523 p494 : If the readonly attribute is specified on an input element, the element is barred from constraint

validation p591 .

Note

The difference between p571 p523 disabled and readonly is that read-only controls can still function, whereas disabled controls

generally do not function as controls until they are enabled. This is spelled out in more detail elsewhere in this specification with

normative requirements that refer to the p571 disabled concept (for example, the element's activation behavior, whether or not it is

a p773 p600 focusable area , or when constructing the entry list). Any other behavior related to user interaction with disabled controls,

such as whether text can be selected or copied, is not defined in this standard.

Only text controls can be made read-only, since for other controls (such as checkboxes and buttons) there is no useful distinction

between being read-only and being disabled, so the p523 p497 readonly attribute does not apply.



Example

In the following example, the existing product identifiers cannot be modified, but they are still displayed as part of the form, for

consistency with the row representing a new product (where the identifier is not yet filled in).



523





Product ID Product name Price Action





$ value="49.99">



Delete





$ value="24.99">



Delete





$ Delete





Add

Save





4.10.5.3.4 The p524 p52 required attribute §

4

The p67 required attribute is a boolean attribute. When specified, the element is required.

Constraint validation p524 p533 p497 p533 : If the element is required , and its value IDL attribute applies and is in the mode value , and the

element is p567 p567 p591 mutable , and the element's value is the empty string, then the element is suffering from being missing.

Example

The following form has two required fields, one for an email address and one for a password. It also has a third field that is only

considered valid if the user types the same password in the password field and this third field.





Create new account





oninput="up2.setCustomValidity(up2.value != up.value ? 'Passwords do not match.' : '')">





Email address:





Password:





Confirm password:





Example

For radio buttons, the p524 p515 required attribute is satisfied if any of the radio buttons in the group is selected. Thus, in the

following example, any of the radio buttons can be checked, not just the one marked as required:



524





Did the movie pass the Bechdel test?



No, there are not even two

female characters in the movie.



No, the female characters never

talk to each other.



No, when female characters talk to

each other it's always about a male character.



Yes.

I don't know.





To avoid confusion as to whether a p515 radio button group is required or not, authors are encouraged to specify the attribute on all

the radio buttons in a group. Indeed, in general, authors are encouraged to avoid having radio button groups that do not have any

initially checked controls in the first place, as this is a state that the user cannot return to, and is therefore generally considered a

poor user interface.



4.10.5.3.5 The p525 p52 multiple attribute §

5

The p67 multiple attribute is a boolean attribute that indicates whether the user is to be allowed to specify more than one value. ✔ MDN

Example

The following extract shows how an email client's "To" field could accept multiple email addresses.

To:

If the user had, amongst many friends in their user contacts database, two friends "Spider-Man" (with address

"spider@parker.example.net") and "Scarlet Witch" (with address "scarlet@avengers.example.net"), then, after the user has typed

"s", the user agent might suggest these two email addresses to the user.

Send Save Now Discard

To: s| ▼

spider@parker.example.net Spider-Man

scarlet@avengers.example.net Scarlet Witch



The page could also link in the user's contacts database from the site:

To: ...





Suppose the user had entered "bob@example.net" into this text control, and then started typing a second email address starting

with "s". The user agent might show both the two friends mentioned earlier, as well as the "astrophy" and "astronomy" values

given in the p544 datalist element.



525

Send Save Now Discard

To: bob@example.net, s| ▼

spider@parker.example.net Spider-Man

scarlet@avengers.example.net Scarlet Witch

astronomy@science.example.org

astrophy@cute.example



Example

The following extract shows how an email client's "Attachments" field could accept multiple files for upload.

Attachments:



4.10.5.3.6 The p526 ✔ MDN p52 pattern attribute §

6

The p567 p525 pattern attribute specifies a regular expression against which the control's value , or, when the multiple attribute

applies p497 p567 and is set, the control's values, are to be checked.

If specified, the attribute's value must match the JavaScript Pattern[+U, +N] production.

The p494 compiled pattern regular expression of an input element, if it exists, is a JavaScript RegExp object. It is determined as follows:

1. If the element does not have a p526 pattern attribute specified, then return nothing. The element has no compiled pattern

regular expression p526.

2. Let p526 pattern be the value of the pattern attribute of the element.

3. Let p1278 regexpCompletion be RegExpCreate ( pattern , " u "). [JAVASCRIPT]

4. If regexpCompletion is an abrupt completion, then return nothing. The element has no compiled pattern regular

expression p526.

Note

User agents are encouraged to log this error in a developer console, to aid debugging.

5. Let anchoredPattern be the string "^(?:", followed by pattern, followed by ")$".

6. Return ! RegExpCreate(anchoredPattern, "u").

Note

The reasoning behind these steps, instead of just using the value of the p526 pattern attribute directly, is twofold. First, we want to

ensure that when matched against a string, the regular expression's start is anchored to the start of the string and its end to the

end of the string. Second, we want to ensure that the regular expression is valid in standalone form, instead of only becoming valid

after being surrounded by the "^(?:" and ")$" anchors.

A RegExp object regexp matches a string input, if ! RegExpBuiltinExec(regexp, input) is not null.

Constraint validation p567 p525 : If the element's value is not the empty string, and either the element's multiple attribute is not specified or it p497 p494 p496 does not apply to the input element given its type attribute's current state, and the element has a compiled

pattern regular expression p526 p526 p567 but that regular expression does not match the element's value , then the element is suffering

from a pattern mismatch p591 .

Constraint validation p567 p525 : If the element's value is not the empty string, and the element's multiple attribute is specified and

applies p497 p494 p526 to the input element, and the element has a compiled pattern regular expression but that regular expression does not p526 p567 p591 match each of the element's values , then the element is suffering from a pattern mismatch.

526

When an p494 p526 input element has a pattern attribute specified, authors should include a title attribute to give a description of the pattern. User agents may use the contents of this attribute, if it is present, when informing the user that the pattern is not matched, or at any other suitable time, such as in a tooltip or read out by assistive technology when the control p774 gains focus .

Example

For example, the following snippet:

Part number:



title="A part number is a digit followed by three uppercase letters."/>



...could cause the UA to display an alert such as:

A part number is a digit followed by three uppercase letters. You cannot submit this form when the field is incorrect.

When a control has a p526 p527 pattern attribute, the title attribute, if used, must describe the pattern. Additional information could also be included, so long as it assists the user in filling in the control. Otherwise, assistive technology would be impaired.

Example

For instance, if the title attribute contained the caption of the control, assistive technology could end up saying something like The

text you have entered does not match the required pattern. Birthday, which is not useful.

UAs may still show the p140 title in non-error situations (for example, as a tooltip when hovering over the control), so authors should be careful not to word p527 titles as if an error has necessarily occurred.



4.10.5.3.7 The p527 p527 p52 min and max attributes §

7

Some form controls can have explicit constraints applied limiting the allowed range of values that the user can provide. Normally, such a range would be linear and continuous. A form control can have a periodic domain, however, in which case the form control's broadest possible range is finite, and authors can specify explicit ranges within it that span the boundaries.

Example

Specifically, the broadest range of a p508 type=time control is midnight to midnight (24 hours), and authors can set both continuous

linear ranges (such as 9pm to 11pm) and discontinuous ranges spanning midnight (such as 11pm to 1am).

The min and max attributes indicate the allowed range of values for the element.

Their syntax is defined by the section that defines the p496 type attribute's current state.

If the element has a p527 p498 min attribute, and the result of applying the algorithm to convert a string to a number to the value of the

min p527 p496 attribute is a number, then that number is the element's minimum ; otherwise, if the type attribute's current state defines a default minimum p527 p527 , then that is the minimum ; otherwise, the element has no minimum.

The p527 p528 min attribute also defines the step base.

If the element has a p527 p498 max attribute, and the result of applying the algorithm to convert a string to a number to the value of the

max p527 p496 attribute is a number, then that number is the element's maximum ; otherwise, if the type attribute's current state defines a p527 p527 default maximum , then that is the maximum ; otherwise, the element has no maximum.

If the element does not p527 p527 p527 p527 have a periodic domain , the max attribute's value (the maximum ) must not be less than the min

attribute's value (its p527 minimum ).

Note

If an element that does not p527 p527 p527 have a periodic domain has a maximum that is less than its minimum , then so long as the

element has a p567 p591 p592 value , it will either be suffering from an underflow or suffering from an overflow.

527

An element p527 p527 p527 has a reversed range if it has a periodic domain and its maximum is less than its minimum.

An element p527 p527 has range limitations if it has a defined minimum or a defined maximum.

Constraint validation p527 p528 : When the element has a minimum and does not have a reversed range , and the result of applying the

algorithm to convert a string to a number p498 p567 to the string given by the element's value is a number, and the number obtained from that algorithm is less than the p527 p591 minimum , the element is suffering from an underflow .

Constraint validation p527 p528 : When the element has a maximum and does not have a reversed range, and the result of applying the

algorithm to convert a string to a number p498 p567 to the string given by the element's value is a number, and the number obtained from that algorithm is more than the p527 p592 maximum , the element is suffering from an overflow .

Constraint validation p528 : When an element has a reversed range , and the result of applying the algorithm to convert a string to a

number p498 p567 to the string given by the element's value is a number, and the number obtained from that algorithm is more than the

maximum p527 p527 p591 and less than the minimum , the element is simultaneously suffering from an underflow and suffering from an

overflow p592.

Example

The following date control limits input to dates that are before the 1980s:





Example

The following number control limits input to whole numbers greater than zero:





Example

The following time control limits input to those minutes that occur between 9pm and 6am, defaulting to midnight:





4.10.5.3.8 The p528 p52 step attribute §

8

The p567 p567 step attribute indicates the granularity that is expected (and required) of the value or values , by limiting the allowed

values. The section that defines the p496 type attribute's current state also defines the default step, the step scale factor, and in some cases the default step base, which are used in processing the attribute as described below.

The p528 p69 p70 step attribute, if specified, must either have a value that is a valid floating-point number that parses to a number that is greater than zero, or must have a value that is an ASCII case-insensitive match for the string "any".

The attribute provides the allowed value step for the element, as follows:

1. If the attribute does not p497 p528 apply , then there is no allowed value step.

2. Otherwise, if the attribute is absent, then the p528 p528 allowed value step is the default step multiplied by the step scale

factor p528 .

3. Otherwise, if the attribute's value is an ASCII case-insensitive match for the string "any", then there is no allowed value

step p528.

4. Otherwise, if the p70 rules for parsing floating-point number values, when they are applied to the attribute's value, return an

error, zero, or a number less than zero, then the p528 p528 allowed value step is the default step multiplied by the step scale

factor p528 .

5. Otherwise, the p528 p70 allowed value step is the number returned by the rules for parsing floating-point number values when

they are applied to the attribute's value, multiplied by the p528 step scale factor.

The step base is the value returned by the following algorithm:

528

1. If the element has a p527 p498 min content attribute, and the result of applying the algorithm to convert a string to a number to

the value of the p527 min content attribute is not an error, then return that result.

2. If the element has a p498 p498 value content attribute, and the result of applying the algorithm to convert a string to a number

to the value of the p498 value content attribute is not an error, then return that result.

3. If a p528 p496 default step base is defined for this element given its type attribute's state, then return it.

4. Return zero.

Constraint validation p528 : When the element has an allowed value step, and the result of applying the algorithm to convert a string

to a number p498 p567 p528 to the string given by the element's value is a number, and that number subtracted from the step base is not an integral multiple of the p528 p592 allowed value step , the element is suffering from a step mismatch .

Example

The following range control only accepts values in the range 0..1, and allows 256 steps in that range:





Example

The following control allows any time in the day to be selected, with any accuracy (e.g. thousandth-of-a-second accuracy or more):



Normally, time controls are limited to an accuracy of one minute.



4.10.5.3.9 The p529 p52 list attribute §

9

The list attribute is used to identify an element that lists predefined options suggested to the user.

If present, its value must be the p544 ID of a datalist element in the same tree.

The p529 suggestions source element is the first element in the tree in tree order to have an ID equal to the value of the list

attribute, if that element is a p544 p529 datalist element. If there is no list attribute, or if there is no element with that ID, or if the first

element with that p544 p529 ID is not a datalist element, then there is no suggestions source element .

If there is a p529 p494 p567 suggestions source element , then, when the user agent is allowing the user to edit the input element's value, the user agent should offer the suggestions represented by the p529 suggestions source element to the user in a manner suitable for the type of control used. If appropriate, the user agent should use the suggestion's p547 p547 label and value to identify the suggestion to the user.

User agents are encouraged to filter the suggestions represented by the p529 suggestions source element when the number of suggestions is large, including only the most relevant ones (e.g. based on the user's input so far). No precise threshold is defined, but capping the list at four to seven values is reasonable. If filtering based on the user's input, user agents should use substring matching against both the suggestions' p547 p547 label and value .

Example

This text field allows you to choose a type of JavaScript function.





function

async function

generator function

arrow function

async arrow function

async generator function



529

For user agents that follow the above suggestions, both the p547 p547 label and value would be shown:

▼

function function

async function async function

function* generator function

=> arrow function

async => async arrow function

async function* async generator function



Then, typing "arrow" or "=>" would filter the list to the entries with labels "arrow function" and "async arrow function". Typing

"generator" or "*" would filter the list to the entries with labels "generator function" and "async generator function".



Note

As always, user agents are free to make user interface decisions which are appropriate for their particular requirements and for the

user's particular circumstances. However, this has historically been an area of confusion for implementers, web developers, and

users alike, so we've given some "should" suggestions above.

How user selections of suggestions are handled depends on whether the element is a control accepting a single value only, or whether it accepts multiple values:

↪ p525 p525 p497 If the element does not have a multiple attribute specified or if the multiple attribute does not apply

When the user selects a suggestion, the p494 p567 p547 input element's value must be set to the selected suggestion's value, as if the user had written that value themself.

↪ p496 p503 p525 If the element's type attribute is in the Email state and the element has a multiple attribute specified

When the user selects a suggestion, the user agent must either add a new entry to the p494 p567 input element's values, whose

value is the selected suggestion's p547 p494 p567 value , or change an existing entry in the input element's values to have the value

given by the selected suggestion's p547 value , as if the user had themself added an entry with that value, or edited an existing

entry to be that value. Which behavior is to be applied depends on the user interface in an implementation-defined manner.



If the p529 p497 p529 list attribute does not apply , there is no suggestions source element .

Example

This URL field offers some suggestions.

Homepage:





Other URLs from the user's history might show also; this is up to the user agent.



Example

This example demonstrates how to design a form that uses the autocompletion list feature while still degrading usefully in legacy

user agents.

If the autocompletion list is merely an aid, and is not important to the content, then simply using a p544 datalist element with

children p546 option elements is enough. To prevent the values from being rendered in legacy user agents, they need to be placed

inside the p547 value attribute instead of inline.





530



Enter a breed:





However, if the values need to be shown in legacy UAs, then fallback content can be placed inside the p544 datalist element, as

follows:





Enter a breed:





or select one from the list:

(none selected) Abyssinian Alpaca





The fallback content will only be shown in UAs that don't support p544 datalist. The options, on the other hand, will be detected by

all UAs, even though they are not children of the p544 datalist element.

Note that if an p546 p544 p548 option element used in a datalist is selected, it will be selected by default by legacy UAs (because it

affects the p538 p494 p544 select ), but it will not have any effect on the input element in UAs that support datalist.



4.10.5.3.10 The p531 p53 placeholder attribute §

1

The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control ✔ MDN has no value. A hint could be a sample value or a brief description of the expected format. The attribute, if specified, must have a value that contains no U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) characters.

The p531 p491 placeholder attribute should not be used as an alternative to a label. For a longer hint or other advisory text, the

title p140 attribute is more appropriate.

Note

These mechanisms are very similar but subtly different: the hint given by the control's p491 label is shown at all times; the short

hint given in the p531 p140 placeholder attribute is shown before the user enters a value; and the hint in the title attribute is shown

when the user requests further help.

User agents should present this hint to the user, after having p567 stripped newlines from it, when the element's value is the empty string, especially if the control is not p774 focused.

If a user agent normally doesn't show this hint to the user when the control is p774 focused , then the user agent should nonetheless

show the hint for the control if it was focused as a result of the p785 autofocus attribute, since in that case the user will not have had an opportunity to examine the control before focusing it.

531

Example

Here is an example of a mail configuration user interface that uses the p531 placeholder attribute:





Mail Account



Name:

Address:

Password:

Description:





Example

In situations where the control's content has one directionality but the placeholder needs to have a different directionality,

Unicode's bidirectional-algorithm formatting characters can be used in the attribute value:



For slightly more clarity, here's the same example using numeric character references instead of inline Arabic:



placeholder="‫رقم الهاتف 1‮">

placeholder="‫رقم الهاتف 2‮">



4.10.5.4 Common p494 p53 input element APIs §

2

For web developers (non-normative)

input p533 . value [ = value ]

Returns the current p567 value of the form control.

Can be set, to change the value.

Throws an "InvalidStateError" DOMException if it is set to any value other than the empty string when the control is a file upload control.

input p533 . checked [ = value ]

Returns the current p567 checkedness of the form control.

Can be set, to change the p567 checkedness.

input p534 . files [ = files ]

Returns a p516 FileList object listing the selected files of the form control. Returns null if the control isn't a file control.

Can be set to a p516 FileList object to change the selected files of the form control. For instance, as the result of a drag-and-drop operation.

input p534 . valueAsDate [ = value ]

Returns a p567 Date object representing the form control's value, if applicable; otherwise, returns null. Can be set, to change the value.

Throws an "InvalidStateError" DOMException if the control isn't date- or time-based.

input p534 . valueAsNumber [ = value ]

Returns a number representing the form control's p567 value, if applicable; otherwise, returns NaN. Can be set, to change the value. Setting this to NaN will set the underlying value to the empty string.

Throws an "InvalidStateError" DOMException if the control is neither date- or time-based nor numeric.



532

input p534 . stepUp( [ n ] )

input p534 . stepDown ( [ n ] )

Changes the form control's p567 p528 value by the value given in the step attribute, multiplied by n. The default value for n is 1.

Throws p528 " InvalidStateError " DOMException if the control is neither date- or time-based nor numeric, or if the step attribute's value is "any".

input p535 . list

Returns the p544 p529 datalist element indicated by the list attribute.

The p567 p494 value IDL attribute allows scripts to manipulate the value of an input element. The attribute is in one of the following modes, which define its behavior:

value

On getting, return the current p567 value of the element.

On setting:

1. Let p567 oldValue be the element's value.

2. Set the element's p567 value to the new value.

3. Set the element's p567 dirty value flag to true.

4. Invoke the p498 p496 value sanitization algorithm , if the element's type attribute's current state defines one.

5. If the element's p567 p498 value (after applying the value sanitization algorithm ) is different from oldValue, and the element

has a p587 p587 text entry cursor position , move the text entry cursor position to the end of the text control, unselecting any

selected text and p588 resetting the selection direction to "none".

default

On getting, if the element has a p498 value content attribute, return that attribute's value; otherwise, return the empty string.

On setting, set the value of the element's p498 value content attribute to the new value.

default/on

On getting, if the element has a p498 value content attribute, return that attribute's value; otherwise, return the string "on".

On setting, set the value of the element's p498 value content attribute to the new value.

filename

On getting, return the string " p516 C:\fakepath\ " followed by the name of the first file in the list of selected files, if any, or the empty string if the list is empty.

On setting, if the new value is the empty string, empty the list of p516 selected files ; otherwise, throw an "InvalidStateError"

DOMException.

Note

This "fakepath" requirement is a sad accident of history. See p518 the example in the File Upload state section for more information.



Note

Since p516 p516 path components are not permitted in file names in the list of selected files, the "\fakepath\" cannot be mistaken for a path component.



The p567 p494 checked IDL attribute allows scripts to manipulate the checkedness of an input element. On getting, it must return the current p567 p567 checkedness of the element; and on setting, it must set the element's checkedness to the new value and set the element's p498 dirty checkedness flag to true.



533

The p516 files IDL attribute allows scripts to access the element's selected files.

On getting, if the IDL attribute p497 p516 applies , it must return a FileList object that represents the current selected files . The same

object must be returned until the list of p516 p497 selected files changes. If the IDL attribute does not apply, then it must instead return null. p1277 [FILEAPI]

On setting, it must run these steps:

1. If the IDL attribute p497 does not apply or the given value is null, then return.

2. Replace the element's p516 selected files with the given value.



The p567 valueAsDate IDL attribute represents the value of the element, interpreted as a date.

On getting, if the p534 p497 p494 p496 valueAsDate attribute does not apply , as defined for the input element's type attribute's current state, then return null. Otherwise, run the p498 p567 algorithm to convert a string to a Date object defined for that state to the element's value ; if

the algorithm returned a Date object, then return it, otherwise, return null.

On setting, if the p534 p497 p494 p496 valueAsDate attribute does not apply , as defined for the input element's type attribute's current state, then throw an "InvalidStateError" DOMException; otherwise, if the new value is not null and not a Date object throw a TypeError

exception; otherwise if the new value is null or a p567 Date object representing the NaN time value, then set the value of the element to the empty string; otherwise, run the p498 algorithm to convert a Date object to a string , as defined for that state, on the new value, and

set the p567 value of the element to the resulting string.



The p567 valueAsNumber IDL attribute represents the value of the element, interpreted as a number.

On getting, if the p534 p497 p494 p496 valueAsNumber attribute does not apply , as defined for the input element's type attribute's current state, then return a Not-a-Number (NaN) value. Otherwise, run the p498 algorithm to convert a string to a number defined for that state to the element's p567 value; if the algorithm returned a number, then return it, otherwise, return a Not-a-Number (NaN) value.

On setting, if the new value is infinite, then throw a p534 TypeError exception. Otherwise, if the valueAsNumber attribute does not

apply p497 p494 p496 , as defined for the input element's type attribute's current state, then throw an "InvalidStateError" DOMException.

Otherwise, if the new value is a Not-a-Number (NaN) value, then set the p567 value of the element to the empty string. Otherwise, run the p498 p567 algorithm to convert a number to a string , as defined for that state, on the new value, and set the value of the element to the resulting string.



The stepDown(n) and stepUp(n) methods, when invoked, must run the following algorithm: MDN

1. If the p534 p534 p497 p494 p496 stepDown() and stepUp() methods do not apply , as defined for the input element's type attribute's

current state, then throw an "InvalidStateError" DOMException.

2. If the element has no p528 allowed value step, then throw an "InvalidStateError" DOMException.

3. If the element has a p527 p527 p527 p527 minimum and a maximum and the minimum is greater than the maximum, then return.

4. If the element has a p527 p527 minimum and a maximum and there is no value greater than or equal to the element's

minimum p527 p527 p528 and less than or equal to the element's maximum that, when subtracted from the step base , is an

integral multiple of the p528 allowed value step , then return.

5. If applying the p498 p567 algorithm to convert a string to a number to the string given by the element's value does not result in

an error, then let value be the result of that algorithm. Otherwise, let value be zero.

6. Let valueBeforeStepping be value.

7. If p528 p528 value subtracted from the step base is not an integral multiple of the allowed value step, then set value to the

nearest value that, when subtracted from the p528 p528 step base , is an integral multiple of the allowed value step, and that is

less than p534 value if the method invoked was the stepDown() method, and more than value otherwise.

Otherwise ( p528 p528 value subtracted from the step base is an integral multiple of the allowed value step):

1. Let n be the argument.

2. Let p528 delta be the allowed value step multiplied by n.

534

3. If the method invoked was the p534 stepDown() method, negate delta.

4. Let value be the result of adding delta to value.

8. If the element has a p527 p527 minimum , and value is less than that minimum , then set value to the smallest value that, when

subtracted from the p528 p528 step base , is an integral multiple of the allowed value step, and that is more than or equal to minimum.

9. If the element has a p527 p527 maximum , and value is greater than that maximum , then set value to the largest value that,

when subtracted from the p528 p528 step base , is an integral multiple of the allowed value step , and that is less than or equal to maximum.

10. If either the method invoked was the p534 stepDown() method and value is greater than valueBeforeStepping, or the method

invoked was the p534 stepUp() method and value is less than valueBeforeStepping, then return.

Example

This ensures that invoking the p534 p494 stepUp() method on the input element in the following example does not change

the p567 value of that element:



11. Let p498 p494 value as string be the result of running the algorithm to convert a number to a string , as defined for the input

element's p496 type attribute's current state, on value.

12. Set the p567 value of the element to value as string.



The p529 list IDL attribute must return the current suggestions source element , if any, or null otherwise.



4.10.5.5 Common event behaviors p53 §

5

When the p1271 p1271 p497 p494 p487 input and change events apply (which is the case for all input controls other than buttons and those with the p496 p500 type attribute in the Hidden state), the events are fired to indicate that the user has interacted with the control. The

input p1271 p1271 event fires whenever the user has modified the data of the control. The change event fires when the value is committed, if that makes sense for the control, or else when the control p780 p1271 loses focus . In all cases, the input event comes before the corresponding p1271 change event (if any).

When an p494 p499 p497 input element has a defined input activation behavior , the rules for dispatching these events, if they apply, are given in the section above that defines the p496 p494 p496 type attribute's state. (This is the case for all input controls with the type

attribute in the p514 p515 p516 Checkbox state, the Radio Button state, or the File Upload state.) For p494 p499 p497 input elements without a defined input activation behavior , but to which these events apply , and for which the user

interface involves both interactive manipulation and an explicit commit action, then when the user changes the element's p567 value, the user agent must p933 p939 p494 queue an element task on the user interaction task source given the input element to fire an event

named p1271 p494 input at the input element, with the bubbles and composed attributes initialized to true, and any time the user commits the change, the user agent must p933 p939 p494 queue an element task on the user interaction task source given the input

element to p1271 p494 fire an event named change at the input element, with the bubbles attribute initialized to true.

Example

An example of a user interface involving both interactive manipulation and a commit action would be a p511 Range controls that use

a slider, when manipulated using a pointing device. While the user is dragging the control's knob, p1271 input events would fire

whenever the position changed, whereas the p1271 change event would only fire when the user let go of the knob, committing to a

specific value.

For p494 p499 p497 input elements without a defined input activation behavior , but to which these events apply , and for which the user interface involves an explicit commit action but no intermediate manipulation, then any time the user commits a change to the element's p567 p933 p939 p494 value , the user agent must queue an element task on the user interaction task source given the input element to first p1271 p494 fire an event named input at the input element, with the bubbles and composed attributes initialized to true, and then

fire an event p1271 p494 named change at the input element, with the bubbles attribute initialized to true.



535

Example

An example of a user interface with a commit action would be a p514 Color control that consists of a single button that brings up a

color wheel: if the p567 value only changes when the dialog is closed, then that would be the explicit commit action. On the other

hand, if manipulating the control changes the color interactively, then there might be no commit action.



Example

Another example of a user interface with a commit action would be a p505 Date control that allows both text-based user input and

user selection from a drop-down calendar: while text input might not have an explicit commit step, selecting a date from the drop

down calendar and then dismissing the drop down would be a commit action.

For p494 p499 p497 input elements without a defined input activation behavior , but to which these events apply , any time the user causes

the element's p567 p933 value to change without an explicit commit action, the user agent must queue an element task on the user

interaction task source p939 p494 p1271 p494 given the input element to fire an event named input at the input element, with the bubbles

and p1271 p780 composed attributes initialized to true. The corresponding change event, if any, will be fired when the control loses focus.

Example

Examples of a user changing the element's p567 value would include the user typing into a text control, pasting a new value into the

control, or undoing an edit in that control. Some user interactions do not cause changes to the value, e.g., hitting the "delete" key

in an empty text control, or replacing some text in the control with text from the clipboard that happens to be exactly the same

text.



Example

A p511 p774 Range control in the form of a slider that the user has focused and is interacting with using a keyboard would be another

example of the user changing the element's p567 value without a commit step.

In the case of p932 p1271 tasks that just fire an input event, user agents may wait for a suitable break in the user's interaction before

queuing p933 the tasks; for example, a user agent could wait for the user to have not hit a key for 100ms, so as to only fire the event when the user pauses, instead of continuously for each keystroke.

When the user agent is to change an p494 p567 input element's value on behalf of the user (e.g. as part of a form prefilling feature), the user agent must p933 p939 p494 queue an element task on the user interaction task source given the input element to first update the

value p567 p1271 p494 accordingly, then fire an event named input at the input element, with the bubbles and composed attributes initialized to true, then p1271 p494 fire an event named change at the input element, with the bubbles attribute initialized to true.

Note

These events are not fired in response to changes made to the values of form controls by scripts. (This is to make it easier to

update the values of form controls in response to the user manipulating the controls, without having to then filter out the script's

own changes to avoid an infinite loop.)



✔ MDN

4.10.6 The button element p53 §

6

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Interactive content p133.

Listed p487 p487 p487 p487 p487 , labelable , submittable , and autocapitalize-inheriting form-associated element .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Phrasing content p133 p133 p776 , but there must be no interactive content descendant and no descendant with the tabindex attribute specified.

Tag omission in text/html p129 :

Neither tag is omissible.

536

Content attributes p129:

Global attributes p137

disabled p571 — Whether the form control is disabled

form p567 p487 — Associates the element with a form element

formaction p572 p596 — URL to use for form submission

formenctype p573 p596 — Entry list encoding type to use for form submission

formmethod p572 p596 — Variant to use for form submission

formnovalidate p573 p596 — Bypass form control validation for form submission

formtarget p573 p814 p596 — Browsing context for form submission

name p569 p596 p489 — Name of the element to use for form submission and in the form.elements API

type p537 — Type of button

value p538 p596 — Value to be used for form submission

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLButtonElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute USVString formAction;

[CEReactions] attribute DOMString formEnctype;

[CEReactions] attribute DOMString formMethod;

[CEReactions] attribute boolean formNoValidate;

[CEReactions] attribute DOMString formTarget;

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString value;

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

readonly attribute NodeList labels;

};



The p536 p124 button element represents a button labeled by its contents.

The element is a p487 button.

The p68 type attribute controls the behavior of the button when it is activated. It is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.

Keyword State Brief description

submit p538 Submit Button Submits the form.

reset p538 Reset Button Resets the form.

button p538 Button Does nothing.

The p68 p68 p538 missing value default and invalid value default are the Submit Button state.

If the p537 p538 p487 type attribute is in the Submit Button state, the element is specifically a submit button .

Constraint validation p537 p538 p538 : If the type attribute is in the Reset Button state or the Button state, the element is barred from

537

constraint validation p591 .

A p536 p537 button element's activation behavior is to run the steps defined in the following list for the current state of this element's type

attribute, if this element is not p571 disabled, and do nothing otherwise:

Submit Button

If the element has a p567 p818 p597 form owner and the element's node document is fully active , the element must submit the form

owner p567 p536 from the button element.

Reset Button

If the element has a p567 p818 p604 form owner and the element's node document is fully active , the element must reset the form

owner p567 .

Button

Do nothing.

The p567 p536 p567 p569 form attribute is used to explicitly associate the button element with its form owner . The name attribute represents the element's name. The p571 disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The p572 p573 p572 p573 p573 formaction , formenctype , formmethod , formnovalidate , and formtarget attributes are attributes for

form submission p571 .

Note

The p573 formnovalidate attribute can be used to make submit buttons that do not trigger the constraint validation.

The p572 p573 p572 p573 p573 formaction , formenctype , formmethod , formnovalidate , and formtarget must not be specified if the element's

type p537 p538 attribute is not in the Submit Button state.

The p567 value attribute gives the element's value for the purposes of form submission. The element's value is the value of the element's p538 value attribute, if there is one, or the empty string otherwise.

Note

A button (and its value) is only included in the form submission if the button itself was used to initiate the form submission.



The p95 value IDL attribute must reflect the content attribute of the same name.

The p95 p95 type IDL attribute must reflect the content attribute of the same name, limited to only known values.

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage IDL attributes, and the checkValidity() , reportValidity(), and p594 p593 p493 setCustomValidity() methods, are part of the constraint validation API . The labels IDL attribute provides a list of the element's p491 p571 p569 p569 label s. The disabled , form , and name IDL attributes are part of the element's forms API.

Example

The following button is labeled "Show hint" and pops up a dialog box when activated:

onclick="alert('This 15-20 minute piece was composed by George Gershwin.')">

Show hint





✔ MDN

4.10.7 The select element p53 §

8

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Interactive content p133.

Listed p487 p487 p487 p487 p487 p487 , labelable , submittable , resettable , and autocapitalize-inheriting form-associated element .

538

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Zero or more p546 p545 p134 option , optgroup , and script-supporting elements.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

autocomplete p574 — Hint for form autofill feature

disabled p571 — Whether the form control is disabled

form p567 p487 — Associates the element with a form element

multiple p540 — Whether to allow multiple values

name p569 p596 p489 — Name of the element to use for form submission and in the form.elements API

required p540 p596 — Whether the control is required for form submission

size p540 — Size of the control

Accessibility considerations p130:

If the element has a p540 p540 multiple attribute or a size attribute with a value > 1: for authors; for implementers.

Otherwise: for authors; for implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLSelectElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString autocomplete;

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute boolean multiple;

[CEReactions] attribute DOMString name;

[CEReactions] attribute boolean required;

[CEReactions] attribute unsigned long size;

readonly attribute DOMString type;

[SameObject] readonly attribute HTMLOptionsCollection options;

[CEReactions] attribute unsigned long length;

getter Element? item(unsigned long index);

HTMLOptionElement? namedItem(DOMString name);

[CEReactions] undefined add((HTMLOptionElement or HTMLOptGroupElement) element, optional

(HTMLElement or long)? before = null);

[CEReactions] undefined remove(); // ChildNode overload

[CEReactions] undefined remove(long index);

[CEReactions] setter undefined (unsigned long index, HTMLOptionElement? option);

[SameObject] readonly attribute HTMLCollection selectedOptions;

attribute long selectedIndex;

attribute DOMString value;

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

readonly attribute NodeList labels;

539

};



The p538 select element represents a control for selecting amongst a set of options.

The p67 p538 p124 multiple attribute is a boolean attribute . If the attribute is present, then the select element represents a control for selecting zero or more options from the p540 p538 p124 list of options . If the attribute is absent, then the select element represents a control for selecting a single option from the p540 list of options .

The p540 size attribute gives the number of options to show to the user. The size attribute, if specified, must have a value that is a

valid non-negative integer p69 greater than zero.

The p538 p69 display size of a select element is the result of applying the rules for parsing non-negative integers to the value of element's p540 size attribute, if it has one and parsing it is successful. If applying those rules to the attribute's value is not successful, or if the p540 p540 p540 size attribute is absent, then the element's display size is 4 if the element's multiple content attribute is present, and 1 otherwise.

The p538 p546 p538 list of options for a select element consists of all the option element children of the select element, and all the

option p546 p545 p538 element children of all the optgroup element children of the select element, in tree order.

The p67 required attribute is a boolean attribute. When specified, the user will be required to select a value before submitting the form.

If a p538 p540 p540 select element has a required attribute specified, does not have a multiple attribute specified, and has a display

size p540 p547 p546 p538 p540 of 1; and if the value of the first option element in the select element's list of options (if any) is the empty string, and that p546 p538 p545 p546 option element's parent node is the select element (and not an optgroup element), then that option is

the p538 select element's placeholder label option.

If a p538 p540 p540 select element has a required attribute specified, does not have a multiple attribute specified, and has a display

size p540 p538 p540 of 1, then the select element must have a placeholder label option .

Note

In practice, the requirement stated in the paragraph above can only apply when a p538 p540 select element does not have a size

attribute with a value greater than 1.

Constraint validation p540 p546 : If the element has its required attribute specified, and either none of the option elements in the

select p538 p540 p548 p546 p538 element's list of options have their selectedness set to true, or the only option element in the select

element's p540 p548 p540 list of options with its selectedness set to true is the placeholder label option, then the element is suffering from

being missing p591.

If the p540 p571 multiple attribute is absent, and the element is not disabled, then the user agent should allow the user to pick an

option p546 p540 p547 p546 element in its list of options that is itself not disabled . Upon this option element being picked (either through a click, or through unfocusing the element after changing its value, or through a p610 menu command, or through any other mechanism), and before the relevant user interaction event is queued (e.g. before the p548 click event), the user agent must set the selectedness of

the picked p546 p548 p541 option element to true, set its dirtiness to true, and then send select update notifications.

If the p540 p546 p538 p540 multiple attribute is absent, whenever an option element in the select element's list of options has its

selectedness p548 p546 p548 p538 set to true, and whenever an option element with its selectedness set to true is added to the select

element's p540 p548 p546 p540 list of options , the user agent must set the selectedness of all the other option elements in its list of options to

false.

If the p540 p540 multiple attribute is absent and the element's display size is greater than 1, then the user agent should also allow the user to request that the p546 p548 option whose selectedness is true, if any, be unselected. Upon this request being conveyed to the user agent, and before the relevant user interaction event is queued (e.g. before the click event), the user agent must set the

selectedness p548 p546 p548 p541 of that option element to false, set its dirtiness to true, and then send select update notifications .

If p44 p44 p540 p546 nodes are inserted or nodes are removed causing the list of options to gain or lose one or more option elements, or if an

option p546 p540 p538 p540 element in the list of options asks for a reset , then, if the select element's multiple attribute is absent, the user agent must run the first applicable set of steps from the following list:

↪ p538 p540 p546 p538 If the select element's display size is 1, and no option elements in the select element's list of

options p540 p548 have their selectedness set to true

Set the p548 p546 p540 p547 selectedness of the first option element in the list of options in tree order that is not disabled , if any, to

540

true.

↪ p546 p538 p540 p548 If two or more option elements in the select element's list of options have their selectedness set to

true

Set the p548 p546 p548 p540 selectedness of all but the last option element with its selectedness set to true in the list of options in tree

order to false.

If the p540 p571 multiple attribute is present, and the element is not disabled, then the user agent should allow the user to toggle the

selectedness p548 p546 p540 p547 of the option elements in its list of options that are themselves not disabled. Upon such an element being

toggled p541 p610 (either through a click, or through a menu command, or any other mechanism), and before the relevant user interaction event is queued (e.g. before a related p548 p546 click event), the selectedness of the option element must be changed (from true to false or false to true), the p548 dirtiness of the element must be set to true, and the user agent must send select update

notifications p541.

When the user agent is to p933 p939 send select update notifications , queue an element task on the user interaction task source given the p538 select element to run these steps:

1. p1271 p538 Fire an event named input at the select element, with the bubbles and composed attributes initialized to true.

2. p1271 p538 Fire an event named change at the select element, with the bubbles attribute initialized to true.

The p605 p538 p546 p540 reset algorithm for select elements is to go through all the option elements in the element's list of options, set their

selectedness p548 p546 p548 p548 to true if the option element has a selected attribute, and false otherwise, set their dirtiness to false, and then have the p546 p540 option elements ask for a reset .

The p567 p538 p567 p569 form attribute is used to explicitly associate the select element with its form owner . The name attribute represents the element's name. The p571 disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The p574 autocomplete attribute controls how the user agent provides autofill behavior.

A p538 p571 p567 select element that is not disabled is mutable.

For web developers (non-normative)

select p542 . type

Returns " p540 select-multiple " if the element has a multiple attribute, and "select-one" otherwise.

select p542 . options

Returns an p100 p540 HTMLOptionsCollection of the list of options.

select p542 . length [ = value ]

Returns the number of elements in the p540 list of options .

When set to a smaller number, truncates the number of p546 p538 option elements in the select .

When set to a greater number, adds new blank p546 p538 option elements to the select.

element p542 = select . item(index)

select[index]

Returns the item with index p540 index from the list of options . The items are sorted in tree order.

element p542 = select . namedItem (name)

Returns the first item with p1224 p540 ID or name name from the list of options .

Returns null if no element with that ID could be found.

select p542 . add(element [, before ] )

Inserts element before the node given by before.

The before argument can be a number, in which case element is inserted before the item with that number, or an element from

the p540 list of options, in which case element is inserted before that element. If before is omitted, null, or a number out of range, then element will be added at the end of the list.

This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.

select p542 . selectedOptions

Returns an p540 HTMLCollection of the list of options that are selected.

541

select p542 . selectedIndex [ = value ]

Returns the index of the first selected item, if any, or −1 if there is no selected item. Can be set, to change the selection.

select p542 . value [ = value ]

Returns the p547 value of the first selected item, if any, or the empty string if there is no selected item. Can be set, to change the selection.



The p540 type IDL attribute, on getting, must return the string " select-one " if the multiple attribute is absent, and the string "select-✔ ✔ MDN MDN

multiple p540 " if the multiple attribute is present.

The p100 p538 options IDL attribute must return an HTMLOptionsCollection rooted at the select node, whose filter matches the elements in the p540 list of options.

The p542 p539 options collection is also mirrored on the HTMLSelectElement object. The supported property indices at any instant are the indices supported by the object returned by the p542 options attribute at that instant.

The p542 length IDL attribute must return the number of nodes represented by the options collection. On setting, it must act like the ✔ MDN

attribute of the same name on the p542 options collection.

The p542 item( index ) method must return the value returned by the method of the same name on the options collection, when ✔ MDN invoked with the same argument.

The p542 namedItem( name ) method must return the value returned by the method of the same name on the options collection, when invoked with the same argument.

When the user agent is to p538 set the value of a new indexed property or set the value of an existing indexed property for a select ✔ MDN

element, it must instead run p101 p538 p542 the corresponding algorithm on the select element's options collection.

✔ MDN

Similarly, the p542 add() method must act like its namesake method on that same options collection.

The p542 remove() method must act like its namesake method on that same options collection when it has arguments, and like its namesake method on the p539 ChildNode interface implemented by the HTMLSelectElement ancestor interface Element when it has no ✔ MDN arguments.

The p538 selectedOptions IDL attribute must return an HTMLCollection rooted at the select node, whose filter matches the elements ✔ MDN

in the p540 p548 list of options that have their selectedness set to true.

The p548 p546 p540 selectedIndex IDL attribute, on getting, must return the index of the first option element in the list of options in tree

order p548 that has its selectedness set to true, if any. If there isn't one, then it must return −1.

On setting, the p542 p548 p546 p540 selectedIndex attribute must set the selectedness of all the option elements in the list of options to false, and then the p546 p540 p548 option element in the list of options whose index is the given new value, if any, must have its

selectedness p548 p548 set to true and its dirtiness set to true.

Note

This can result in no element having a p548 p538 selectedness set to true even in the case of the select element having no

multiple p540 p540 attribute and a display size of 1.

The p547 p546 p540 value IDL attribute, on getting, must return the value of the first option element in the list of options in tree order that has its p548 selectedness set to true, if any. If there isn't one, then it must return the empty string.

On setting, the p542 p548 p546 p540 value attribute must set the selectedness of all the option elements in the list of options to false, and then the first p546 p540 p547 option element in the list of options , in tree order , whose value is equal to the given new value, if any, must have its p548 p548 selectedness set to true and its dirtiness set to true.

Note

This can result in no element having a p548 p538 selectedness set to true even in the case of the select element having no

multiple p540 p540 attribute and a display size of 1.

542

The p95 p543 multiple , required , and size IDL attributes must reflect the respective content attributes of the same name. The size IDL

attribute has a default value of zero.

Note

For historical reasons, the default value of the p543 size IDL attribute does not return the actual size used, which, in the absence of

the p540 p540 size content attribute, is either 1 or 4 depending on the presence of the multiple attribute.

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage IDL attributes, and the checkValidity() , reportValidity(), and p594 p593 p493 setCustomValidity() methods, are part of the constraint validation API . The labels IDL attribute provides a list of the element's p491 p571 p569 p569 label s. The disabled , form , and name IDL attributes are part of the element's forms API.

Example

The following example shows how a p538 select element can be used to offer the user with a set of options from which the user can

select a single option. The default option is preselected.





Select unit type:

Miner Puffer Snipey Max Firebot





When there is no default option, a placeholder can be used instead:

Select unit type Miner Puffer Snipey Max Firebot



Example

Here, the user is offered a set of options from which they can select any number. By default, all five options are selected.





Select unit types to enable on this map: Miner Puffer Snipey Max Firebot





Example

Sometimes, a user has to select one or more items. This example shows such an interface.



Select the songs from that you would like on your Act II Mix Tape: It Sucks to Be Me (Reprise) 543 There is Life Outside Your Apartment The More You Ruv Someone Schadenfreude I Wish I Could Go Back to College The Money Song School for Monsters The Money Song (Reprise) There's a Fine, Fine Line (Reprise) What Do You Do With a B.A. in English? (Reprise) For Now





4.10.8 The datalist element §

p54 ✔ MDN

4

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Either: p133 phrasing content.

Or: Zero or more p546 p134 option and script-supporting elements.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLDataListElement : HTMLElement {

[HTMLConstructor] constructor();

[SameObject] readonly attribute HTMLCollection options;

};



The p544 p546 datalist element represents a set of option elements that represent predefined options for other controls. In the rendering, the p544 p124 datalist element represents nothing and it, along with its children, should be hidden.

The p544 p544 p546 datalist element can be used in two ways. In the simplest case, the datalist element has just option element children.

Example



Animal:





544





In the more elaborate case, the p544 datalist element can be given contents that are to be displayed for down-level clients that don't support p544 p546 p538 p544 datalist . In this case, the option elements are provided inside a select element inside the datalist element.

Example



Animal:





or select from the list:

Cat Dog





The p544 p494 p529 p494 datalist element is hooked up to an input element using the list attribute on the input element.

Each p546 p544 p547 p547 option element that is a descendant of the datalist element, that is not disabled , and whose value is a string that isn't the empty string, represents a suggestion. Each suggestion has a p547 p547 value and a label.

For web developers (non-normative)

datalist p545 . options

Returns an p546 p544 HTMLCollection of the option elements of the datalist element.

The p544 p546 options IDL attribute must return an HTMLCollection rooted at the datalist node, whose filter matches option elements.

Constraint validation p544 p591 : If an element has a datalist element ancestor, it is barred from constraint validation.



4.10.9 The optgroup element §

p54 ✔ MDN

5

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As a child of a p538 select element.

Content model p129:

Zero or more p546 p134 option and script-supporting elements.

Tag omission in text/html p129 :

An p545 p1067 p545 optgroup element's end tag can be omitted if the optgroup element is immediately followed by another

optgroup p545 element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

disabled p546 — Whether the form control is disabled

label p546 — User-visible label

Accessibility considerations p130:

For authors.

545

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLOptGroupElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean disabled;

[CEReactions] attribute DOMString label;

};



The p545 p124 p546 optgroup element represents a group of option elements with a common label.

The element's group of p546 p546 p545 option elements consists of the option elements that are children of the optgroup element.

When showing p546 p538 p546 option elements in select elements, user agents should show the option elements of such groups as being related to each other and separate from other p546 option elements.

The p67 p547 p546 disabled attribute is a boolean attribute and can be used to disable a group of option elements together.

The label attribute must be specified. Its value gives the name of the group, for the purposes of the user interface. User agents should use this attribute's value when labeling the group of p546 p538 option elements in a select element.

The p95 disabled and label attributes must reflect the respective content attributes of the same name.

Note

There is no way to select an p545 p546 p545 optgroup element. Only option elements can be selected. An optgroup element merely

provides a label for a group of p546 option elements.



Example

The following snippet shows how a set of lessons from three courses could be offered in a p538 select drop-down widget:





Which course would you like to watch today?



Course:

Lecture 01: Powers of Ten Lecture 02: 1D Kinematics Lecture 03: Vectors Lecture 01: What holds our world together? Lecture 02: Electric Field Lecture 03: Electric Flux Lecture 01: Periodic Phenomenon Lecture 02: Beats Lecture 03: Forced Oscillations with Damping





4.10.10 The option element §

p54 ✔ MDN

6

Categories p129: ✔ MDN

None.

546

Contexts in which this element can be used p129 :

As a child of a p538 select element.

As a child of a p544 datalist element.

As a child of an p545 optgroup element.

Content model p129:

If the element has a p547 p547 p131 label attribute and a value attribute: Nothing.

If the element has a p547 p547 p133 label attribute but no value attribute: Text.

If the element has no p547 p544 p133 label attribute and is not a child of a datalist element: Text that is not inter-element

whitespace p130 .

If the element has no p547 p544 p133 label attribute and is a child of a datalist element: Text.

Tag omission in text/html p129 :

An p546 p1067 p546 p546 option element's end tag can be omitted if the option element is immediately followed by another option

element, or if it is immediately followed by an p545 optgroup element, or if there is no more content in the parent element.

Content attributes p129:

Global attributes p137

disabled p547 — Whether the form control is disabled

label p547 — User-visible label

selected p548 — Whether the option is selected by default

value p547 p596 — Value to be used for form submission

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window,

LegacyFactoryFunction=Option(optional DOMString text = "", optional DOMString value, optional

boolean defaultSelected = false, optional boolean selected = false)]

interface HTMLOptionElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute DOMString label;

[CEReactions] attribute boolean defaultSelected;

attribute boolean selected;

[CEReactions] attribute DOMString value;

[CEReactions] attribute DOMString text;

readonly attribute long index;

};



The p546 p124 p538 p544 option element represents an option in a select element or as part of a list of suggestions in a datalist element.

In certain circumstances described in the definition of the p538 p546 p538 select element, an option element can be a select element's

placeholder label option p540 p540 . A placeholder label option does not represent an actual option, but instead represents a label for the

select p538 control.

The p67 p546 p547 disabled attribute is a boolean attribute . An option element is disabled if its disabled attribute is present or if it is a child of an p545 p546 optgroup element whose disabled attribute is present.

An p546 p547 p933 p939 option element that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.

The p546 p547 label attribute provides a label for element. The label of an option element is the value of the label content attribute, if there is one and its value is not the empty string, or, otherwise, the value of the element's p548 text IDL attribute.

The p547 label content attribute, if specified, must not be empty.

The p546 p547 value attribute provides a value for element. The value of an option element is the value of the value content attribute, if

547

there is one, or, if there is not, the value of the element's p548 text IDL attribute.

The p67 p548 selected attribute is a boolean attribute . It represents the default selectedness of the element.

The p546 p548 dirtiness of an option element is a boolean state, initially false. It controls whether adding or removing the selected

content attribute has any effect.

The p546 selectedness of an option element is a boolean state, initially false. Except where otherwise specified, when the element is created, its p548 p548 p546 selectedness must be set to true if the element has a selected attribute. Whenever an option element's

selected p548 p548 p548 p546 attribute is added, if its dirtiness is false, its selectedness must be set to true. Whenever an option element's

selected p548 p548 p548 attribute is removed , if its dirtiness is false, its selectedness must be set to false.

Note

The p549 p548 Option() constructor, when called with three or fewer arguments, overrides the initial state of the selectedness state to

always be false even if the third argument is true (implying that a p548 selected attribute is to be set). The fourth argument can be

used to explicitly set the initial p548 selectedness state when using the constructor.

A p538 p540 p546 select element whose multiple attribute is not specified must not have more than one descendant option element with its p548 selected attribute set.

An p546 p546 p540 option element's index is the number of option elements that are in the same list of options but that come before it in

tree order p546 p540 p546 p548 . If the option element is not in a list of options , then the option element's index is zero.

For web developers (non-normative)

option p548 . selected

Returns true if the element is selected, and false otherwise.

Can be set, to override the current state of the element.

option p548 . index

Returns the index of the element in its p538 p542 select element's options list.

option p549 . form

Returns the element's p487 form element, if any, or null otherwise.

option p548 . text

Same as p614 textContent , except that spaces are collapsed and script elements are skipped.

option p549 = new Option ( [ text [, value [, defaultSelected [, selected ] ] ] ] )

Returns a new p546 option element.

The text argument sets the contents of the element.

The p547 value argument sets the value attribute.

The p548 defaultSelected argument sets the selected attribute.

The selected argument sets whether or not the element is selected. If it is omitted, even if the defaultSelected argument is true, the element is not selected.

The p95 p95 disabled IDL attribute must reflect the content attribute of the same name. The defaultSelected IDL attribute must reflect

the p548 selected content attribute.

The p547 label IDL attribute, on getting, if there is a label content attribute, must return that attribute's value; otherwise, it must return the element's p547 p547 label . On setting, the element's label content attribute must be set to the new value.

The p547 p547 value IDL attribute, on getting, must return the element's value . On setting, the element's value content attribute must be set to the new value.

The p548 selected IDL attribute, on getting, must return true if the element's selectedness is true, and false otherwise. On setting, it must set the element's p548 p548 p540 selectedness to the new value, set its dirtiness to true, and then cause the element to ask for a reset.

The p548 index IDL attribute must return the element's index .

The text IDL attribute, on getting, must return the result of stripping and collapsing ASCII whitespace from the concatenation of data

of all the p546 Text node descendants of the option element, in tree order, excluding any that are descendants of descendants of the

548

option p546 p614 element that are themselves script or SVG script elements.

The p548 text attribute's setter must string replace all with the given value within this element.

The p546 p538 p546 form IDL attribute's behavior depends on whether the option element is in a select element or not. If the option has a

select p538 p545 p545 p538 element as its parent, or has an optgroup element as its parent and that optgroup element has a select element as its parent, then the p549 p569 p538 form IDL attribute must return the same value as the form IDL attribute on that select element. ✔ MDN Otherwise, it must return null.

A legacy factory function is provided for creating p547 HTMLOptionElement objects (in addition to the factory methods from DOM such as

createElement()): Option(text, value, defaultSelected, selected). When invoked, the legacy factory function must perform the following steps:

1. Let p911 p829 document be the current global object 's associated Document .

2. Let p546 option be the result of creating an element given document , option , and the HTML namespace.

3. If text is not the empty string, then append to option a new Text node whose data is text.

4. If p547 value is given, then set an attribute value for option using " value" and value.

5. If p548 defaultSelected is true, then set an attribute value for option using " selected" and the empty string.

6. If p548 p548 selected is true, then set option 's selectedness to true; otherwise set its selectedness to false (even if

defaultSelected is true).

7. Return option.



✔ MDN

4.10.11 The textarea element p54 §

9

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Interactive content p133.

Listed p487 p487 p487 p487 p487 p487 , labelable , submittable , resettable , and autocapitalize-inheriting form-associated element .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Text p133.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

autocomplete p574 — Hint for form autofill feature

cols p551 — Maximum number of characters per line

dirname p570 p143 p596 — Name of form control to use for sending the element's directionality in form submission

disabled p571 — Whether the form control is disabled

form p567 p487 — Associates the element with a form element

maxlength p552 — Maximum length of value

minlength p552 — Minimum length of value

name p569 p596 p489 — Name of the element to use for form submission and in the form.elements API

placeholder p552 — User-visible label to be placed within the form control

readonly p550 — Whether to allow the value to be edited by the user

required p552 p596 — Whether the control is required for form submission

rows p551 — Number of lines to show

wrap p552 p596 — How the value of the form control is to be wrapped for form submission



549

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLTextAreaElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString autocomplete;

[CEReactions] attribute unsigned long cols;

[CEReactions] attribute DOMString dirName;

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute long maxLength;

[CEReactions] attribute long minLength;

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString placeholder;

[CEReactions] attribute boolean readOnly;

[CEReactions] attribute boolean required;

[CEReactions] attribute unsigned long rows;

[CEReactions] attribute DOMString wrap;

readonly attribute DOMString type;

[CEReactions] attribute DOMString defaultValue;

attribute [LegacyNullToEmptyString] DOMString value;

readonly attribute unsigned long textLength;

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

readonly attribute NodeList labels;

undefined select();

attribute unsigned long selectionStart;

attribute unsigned long selectionEnd;

attribute DOMString selectionDirection;

undefined setRangeText(DOMString replacement);

undefined setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional

SelectionMode selectionMode = "preserve");

undefined setSelectionRange(unsigned long start, unsigned long end, optional DOMString

direction);

};



The p549 p124 textarea element represents a multiline plain text edit control for the element's raw value. The contents of the control represent the control's default value.

The p550 p549 raw value of a textarea control must be initially the empty string.

Note

This element p151 has rendering requirements involving the bidirectional algorithm.

The p67 readonly attribute is a boolean attribute used to control whether the text can be edited by the user or not.

Example

550

In this example, a text control is marked read-only because it represents a read-only file:

Filename: /etc/bash.bashrc

</p> <p style="margin-left:4em"># System-wide .bashrc file for interactive bash(1) shells.</p> <p style="margin-left:4em"># To enable the settings / commands in this file for login shells as well, # this file has to be sourced in /etc/profile.</p> <p style="margin-left:4em"># If not running interactively, don't do anything</p> <p style="margin-left:4em">[ -z "$PS1" ] && return</p> <p style="margin-left:4em">...



Constraint validation p550 p549 : If the readonly attribute is specified on a textarea element, the element is barred from constraint

validation p591 .

A p549 p567 p571 p550 textarea element is mutable if it is neither disabled nor has a readonly attribute specified.

When a p549 p567 p550 textarea is mutable , its raw value should be editable by the user: the user agent should allow the user to edit, insert, and remove text, and to insert and remove line breaks in the form of U+000A LINE FEED (LF) characters. Any time the user causes the element's p550 p933 p939 raw value to change, the user agent must queue an element task on the user interaction task source

given the p549 p1271 p549 textarea element to fire an event named input at the textarea element, with the bubbles and composed attributes initialized to true. User agents may wait for a suitable break in the user's interaction before queuing the task; for example, a user agent could wait for the user to have not hit a key for 100ms, so as to only fire the event when the user pauses, instead of continuously for each keystroke.

A p549 p567 textarea element's dirty value flag must be set to true whenever the user interacts with the control in a way that changes the

raw value p550.

The p549 p550 p567 cloning steps for textarea elements must propagate the raw value and dirty value flag from the node being cloned to the copy.

The p549 p567 children changed steps for textarea elements must, if the element's dirty value flag is false, set the element's raw

value p550 to its child text content.

The p605 p549 p567 p550 reset algorithm for textarea elements is to set the dirty value flag back to false, and set the raw value of element to its child text content.

When a p549 p1090 p1076 p1184 textarea element is popped off the stack of open elements of an HTML parser or XML parser, then the user agent must invoke the element's p605 reset algorithm .

If the element is p567 mutable, the user agent should allow the user to change the writing direction of the element, setting it either to a left-to-right writing direction or a right-to-left writing direction. If the user does so, the user agent must then run the following steps:

1. Set the element's p143 p143 p143 dir attribute to " ltr " if the user selected a left-to-right writing direction, and " rtl" if the user

selected a right-to-left writing direction.

2. p933 p939 p549 Queue an element task on the user interaction task source given the textarea element to fire an event named

input p1271 p549 at the textarea element, with the bubbles and composed attributes initialized to true.

The p551 cols attribute specifies the expected maximum number of characters per line. If the cols attribute is specified, its value must be a p69 p69 valid non-negative integer greater than zero. If applying the rules for parsing non-negative integers to the attribute's value results in a number greater than zero, then the element's character width is that value; otherwise, it is 20.

The user agent may use the p549 p551 textarea element's character width as a hint to the user as to how many characters the server prefers per line (e.g. for visual user agents by making the width of the control be that many characters). In visual renderings, the user agent should wrap the user's input in the rendering so that each line is no wider than this number of characters.

The p551 rows attribute specifies the number of lines to show. If the rows attribute is specified, its value must be a valid non-negative

integer p69 p69 greater than zero. If applying the rules for parsing non-negative integers to the attribute's value results in a number greater than zero, then the element's character height is that value; otherwise, it is 2.

551

Visual user agents should set the height of the control to the number of lines given by p551 character height.

The p68 p552 wrap attribute is an enumerated attribute with two keywords and states: the soft keyword which maps to the Soft state, and the p552 p68 p68 p552 hard keyword which maps to the Hard state. The missing value default and invalid value default are the Soft state.

The p549 Soft state indicates that the text in the textarea is not to be wrapped when it is submitted (though it can still be wrapped in the rendering).

The p549 Hard state indicates that the text in the textarea is to have newlines added by the user agent so that the text is wrapped when it is submitted.

If the element's p552 p552 p551 wrap attribute is in the Hard state, the cols attribute must be specified.

For historical reasons, the element's value is normalized in three different ways for three different purposes. The p550 raw value is the value as it was originally set. It is not normalized. The p567 p553 p553 API value is the value used in the value IDL attribute, textLength IDL

attribute, and by the p570 p570 maxlength and minlength content attributes. It is normalized so that line breaks use U+000A LINE FEED

(LF) characters. Finally, there is the p567 value , as used in form submission and other processing models in this specification. It is normalized so that line breaks use U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pairs, and in addition, if necessary given the element's p552 wrap attribute, additional line breaks are inserted to wrap the text at the given width.

The algorithm for obtaining the element's p567 p550 API value is to return the element's raw value, with newlines normalized.

The element's p567 p550 p552 value is defined to be the element's raw value with the textarea wrapping transformation applied. The textarea wrapping transformation is the following algorithm, as applied to a string:

1. Replace every occurrence of a U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF)

character, and every occurrence of a U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, by a two-character string consisting of a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair.

2. If the element's p552 p552 wrap attribute is in the Hard state, insert U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF)

character pairs into the string using an implementation-defined algorithm so that each line has no more than character

width p551 characters. For the purposes of this requirement, lines are delimited by the start of the string, the end of the string, and U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pairs.

The p570 maxlength attribute is a form control maxlength attribute .

If the p549 p570 textarea element has a maximum allowed value length, then the element's children must be such that the length of the value of the element's descendant text content with newlines normalized is equal to or less than the element's maximum allowed

value length p570.

The p570 minlength attribute is a form control minlength attribute .

The p67 required attribute is a boolean attribute. When specified, the user will be required to enter a value before submitting the form.

Constraint validation p552 p567 : If the element has its required attribute specified, and the element is mutable, and the element's

value p567 p591 is the empty string, then the element is suffering from being missing.

The placeholder attribute represents a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format.

The p552 p491 placeholder attribute should not be used as an alternative to a label. For a longer hint or other advisory text, the

title p140 attribute is more appropriate.

Note

These mechanisms are very similar but subtly different: the hint given by the control's p491 label is shown at all times; the short

hint given in the p552 p140 placeholder attribute is shown before the user enters a value; and the hint in the title attribute is shown

when the user requests further help.

User agents should present this hint to the user when the element's p567 p774 value is the empty string and the control is not focused

(e.g. by displaying it inside a blank unfocused control). All U+000D CARRIAGE RETURN U+000A LINE FEED character pairs (CRLF) in the hint, as well as all other U+000D CARRIAGE RETURN (CR) and U+000A LINE FEED (LF) characters in the hint, must be treated as line breaks when rendering the hint.

If a user agent normally doesn't show this hint to the user when the control is p774 focused , then the user agent should nonetheless

552

show the hint for the control if it was focused as a result of the p785 autofocus attribute, since in that case the user will not have had an opportunity to examine the control before focusing it.

The p569 p570 p143 name attribute represents the element's name. The dirname attribute controls how the element's directionality is submitted. The p571 disabled attribute is used to make the control non-interactive and to prevent its value from being submitted. The

form p567 p549 p567 p574 attribute is used to explicitly associate the textarea element with its form owner . The autocomplete attribute controls how the user agent provides autofill behavior.

For web developers (non-normative)

textarea p553 . type

Returns the string "textarea".

textarea p553 . value

Returns the current value of the element.

Can be set, to change the value.

The p95 cols , placeholder , required , rows , and wrap IDL attributes must reflect the respective content attributes of the same name.

The p553 p553 p96 p553 cols and rows attributes are limited to only non-negative numbers greater than zero with fallback . The cols IDL

attribute's default value is 20. The p553 p95 p570 rows IDL attribute's default value is 2. The dirName IDL attribute must reflect the dirname

content attribute. The p95 p552 maxLength IDL attribute must reflect the maxlength content attribute, limited to only non-negative

numbers p95 p95 p552 p95 . The minLength IDL attribute must reflect the minlength content attribute, limited to only non-negative numbers.

The p95 p550 readOnly IDL attribute must reflect the readonly content attribute.

The type IDL attribute must return the value "textarea".

The defaultValue attribute's getter must return the element's child text content.

The p553 defaultValue attribute's setter must string replace all with the given value within this element.

The p567 value IDL attribute must, on getting, return the element's API value . On setting, it must perform the following steps:

1. Let p567 oldAPIValue be this element's API value.

2. Set this element's p550 raw value to the new value.

3. Set this element's p567 dirty value flag to true.

4. If the new p567 p587 API value is different from oldAPIValue , then move the text entry cursor position to the end of the text

control, unselecting any selected text and p588 resetting the selection direction to "none".

The p567 textLength IDL attribute must return the length of the element's API value .

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage IDL attributes, and the checkValidity() , reportValidity(), and p594 p593 p493 setCustomValidity() methods, are part of the constraint validation API . The labels IDL attribute provides a list of the element's p491 p588 p588 p588 p589 p589 label s. The select() , selectionStart , selectionEnd , selectionDirection , setRangeText(), and

setSelectionRange() p589 p571 p569 p569 methods and IDL attributes expose the element's text selection. The disabled , form , and name IDL attributes are part of the element's forms API.

Example

Here is an example of a p549 textarea being used for unrestricted free-form text input in a form:



If you have any comments, please let us know:



To specify a maximum length for the comments, one can use the p552 maxlength attribute:



If you have any short comments, please let us know:



To give a default value, text can be included inside the element:



If you have any comments, please let us know: You</p> <p style="text-align:right"><span style="font-size:0.75em">553</span></p> <p id="page_554" style="margin-left:4em">rock!



You can also give a minimum length. Here, a letter needs to be filled out by the user; a template (which is shorter than the

minimum length) is provided, but is insufficient to submit the form:

Dear Madam Speaker,</p> <p style="margin-left:4em">Regarding your letter dated ...</p> <p style="margin-left:4em">...</p> <p style="margin-left:4em">Yours Sincerely,</p> <p style="margin-left:4em">...

A placeholder can be given as well, to suggest the basic form to the user, without providing an explicit template:

They closed the parks this week, so we won't be able to</p> <p style="margin-left:4em">meet your there. Should we just have dinner?</p> <p style="margin-left:4em">Love,</p> <p style="margin-left:4em">Daddy">

To have the browser submit p143 p570 the directionality of the element along with the value, the dirname attribute can be specified:



If you have any comments, please let us know (you may use either English or Hebrew for your comments):





4.10.12 The output element §

p55 ✔ MDN

4

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Listed p487 p487 p487 p487 p487 , labelable , resettable , and autocapitalize-inheriting form-associated element.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Phrasing content p133.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

for p555 — Specifies controls from which the output was calculated

form p567 p487 — Associates the element with a form element

name p569 p489 — Name of the element to use in the form.elements API.

Accessibility considerations p130:

For authors.

For implementers.

554

DOM interface p130:

IDL [Exposed=Window]

interface HTMLOutputElement : HTMLElement {

[HTMLConstructor] constructor();

[SameObject, PutForwards=value] readonly attribute DOMTokenList htmlFor;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute DOMString name;

readonly attribute DOMString type;

[CEReactions] attribute DOMString defaultValue;

[CEReactions] attribute DOMString value;

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

readonly attribute NodeList labels;

};



The p554 p124 output element represents the result of a calculation performed by the application, or the result of a user action.

Note

This element can be contrasted with the p270 samp element, which is the appropriate element for quoting the output of other

programs run previously.

The for content attribute allows an explicit relationship to be made between the result of a calculation and the elements that represent the values that went into the calculation or that otherwise influenced the calculation. The p555 for attribute, if specified, must contain a string consisting of an p87 unordered set of unique space-separated tokens, none of which are identical to another token and each of which must have the value of an ID of an element in the same tree.

The p567 p554 p567 p569 form attribute is used to explicitly associate the output element with its form owner . The name attribute represents the element's name. The p554 p124 output element is associated with a form so that it can be easily referenced from the event handlers of form controls; the element's value itself is not submitted when the form is submitted.

The element has a default value override (null or a string). Initially it must be null.

The element's default value is determined by the following steps:

1. If this element's p555 default value override is non-null, then return it.

2. Return this element's descendant text content.

The p605 p554 reset algorithm for output elements is to run these steps:

1. p555 String replace all with this element's default value within this element.

2. Set this element's p555 default value override to null.

For web developers (non-normative)

output p556 . value [ = value ]

Returns the element's current value.

Can be set, to change the value.

output p556 . defaultValue [ = value ]

Returns the element's current default value.

Can be set, to change the default value.

555

output p556 . type

Returns the string "output".

The value attribute's getter must return this element's descendant text content.

The p556 value attribute's setter must run these steps:

1. Set this element's p555 p555 default value override to its default value.

2. String replace all with the given value within this element.

The p555 defaultValue attribute's getter must return the result of running this element's default value.

The p556 defaultValue attribute's setter must run these steps:

1. If this element's p555 default value override is null, then string replace all with the given value within this element and return.

2. Set this element's p555 default value override to the given value.

The type attribute's getter must return "output".

The p95 p555 htmlFor IDL attribute must reflect the for content attribute.

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage IDL attributes, and the checkValidity() , reportValidity(), and p594 p593 p493 setCustomValidity() methods, are part of the constraint validation API . The labels IDL attribute provides a list of the element's p491 p569 p569 label s. The form and name IDL attributes are part of the element's forms API.

Example

A simple calculator could use p554 output for its display of calculated results:





+

=





Example

In this example, an p554 output element is used to report the results of a calculation performed by a remote server, as they come in:





✔ MDN

4.10.13 The progress element p55 §

6

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Labelable element p487.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

556

Content model p129:

Phrasing content p133 p556 , but there must be no progress element descendants.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

value p557 — Current value of the element

max p557 — Upper bound of range

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLProgressElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute double value;

[CEReactions] attribute double max;

readonly attribute double position;

readonly attribute NodeList labels;

};



The p556 p124 progress element represents the completion progress of a task. The progress is either indeterminate, indicating that progress is being made but that it is not clear how much more work remains to be done before the task is complete (e.g. because the task is waiting for a remote host to respond), or the progress is a number in the range zero to a maximum, giving the fraction of work that has so far been completed.

There are two attributes that determine the current task completion represented by the element. The value attribute specifies how much of the task has been completed, and the max attribute specifies how much work the task requires in total. The units are arbitrary and not specified.

Note

To make a determinate progress bar, add a p557 value attribute with the current progress (either a number from 0.0 to 1.0, or, if the

max p557 p557 attribute is specified, a number from 0 to the value of the max attribute). To make an indeterminate progress bar,

remove the p557 value attribute.

Authors are encouraged to also include the current value and the maximum value inline as text inside the element, so that the progress is made available to users of legacy user agents.

Example

Here is a snippet of a web application that shows the progress of some automated task:





Task Progress





Progress: 0%





(The updateProgress() method in this example would be called by some other code on the page to update the actual progress

bar as the task progressed.)

557

The p557 p557 p69 p557 value and max attributes, when present, must have values that are valid floating-point numbers . The value attribute, if present, must have a value equal to or greater than zero, and less than or equal to the value of the p557 max attribute, if present, or 1.0, otherwise. The p557 max attribute, if present, must have a value greater than zero.

Note

The p556 progress element is the wrong element to use for something that is just a gauge, as opposed to task progress. For

instance, indicating disk space usage using p556 p558 progress would be inappropriate. Instead, the meter element is available for

such use cases.

User agent requirements p557 : If the value attribute is omitted, then the progress bar is an indeterminate progress bar. Otherwise, it is a determinate progress bar.

If the progress bar is a determinate progress bar and the element has a p557 p557 max attribute, the user agent must parse the max

attribute's value according to the p70 rules for parsing floating-point number values. If this does not result in an error, and if the parsed value is greater than zero, then the p557 maximum value of the progress bar is that value. Otherwise, if the element has no max

attribute, or if it has one but parsing it resulted in an error, or if the parsed value was less than or equal to zero, then the maximum

value p558 of the progress bar is 1.0.

If the progress bar is a determinate progress bar, user agents must parse the p557 value attribute's value according to the rules for

parsing floating-point number values p70. If this does not result in an error and the parsed value is greater than zero, then the value of the progress bar is that parsed value. Otherwise, if parsing the p557 value attribute's value resulted in an error or a number less than or equal to zero, then the p558 value of the progress bar is zero.

If the progress bar is a determinate progress bar, then the p558 p558 current value is the maximum value , if value is greater than the

maximum value p558 p558 , and value otherwise.

UA requirements for showing the progress bar p556 : When representing a progress element to the user, the UA should indicate whether it is a determinate or indeterminate progress bar, and in the former case, should indicate the relative position of the current

value p558 p558 relative to the maximum value.

For web developers (non-normative)

progress p558 . position

For a determinate progress bar (one with known current and maximum values), returns the result of dividing the current value by the maximum value.

For an indeterminate progress bar, returns −1.

If the progress bar is an indeterminate progress bar, then the position IDL attribute must return −1. Otherwise, it must return the result of dividing the p558 p558 current value by the maximum value .

If the progress bar is an indeterminate progress bar, then the value IDL attribute, on getting, must return 0. Otherwise, it must return the p558 current value . On setting, the given value must be converted to the best representation of the number as a floating-point

number p70 p558 and then the value content attribute must be set to that string.

Note

Setting the p558 value IDL attribute to itself when the corresponding content attribute is absent would change the progress bar from

an indeterminate progress bar to a determinate progress bar with no progress.

The p95 p96 max IDL attribute must reflect the content attribute of the same name, limited to numbers greater than zero. The default value for p558 max is 1.0.

The p493 p491 labels IDL attribute provides a list of the element's labels.



✔ MDN

4.10.14 The meter element p55 §

8

Categories p129: ✔ MDN

Flow content p132 .

Phrasing content p133.

Labelable element p487.

558

Palpable content p134.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Phrasing content p133 p558 , but there must be no meter element descendants.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

value p559 — Current value of the element

min p559 — Lower bound of range

max p559 — Upper bound of range

low p559 — High limit of low range

high p559 — Low limit of high range

optimum p559 — Optimum value in gauge

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLMeterElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute double value;

[CEReactions] attribute double min;

[CEReactions] attribute double max;

[CEReactions] attribute double low;

[CEReactions] attribute double high;

[CEReactions] attribute double optimum;

readonly attribute NodeList labels;

};



The p558 p124 meter element represents a scalar measurement within a known range, or a fractional value; for example disk usage, the relevance of a query result, or the fraction of a voting population to have selected a particular candidate.

This is also known as a gauge.

The p558 meter element should not be used to indicate progress (as in a progress bar). For that role, HTML provides a separate

progress p556 element.

Note

The p558 meter element also does not represent a scalar value of arbitrary range — for example, it would be wrong to use this to

report a weight, or height, unless there is a known maximum value.

There are six attributes that determine the semantics of the gauge represented by the element.

The min attribute specifies the lower bound of the range, and the max attribute specifies the upper bound. The value attribute specifies the value to have the gauge indicate as the "measured" value.

The other three attributes can be used to segment the gauge's range into "low", "medium", and "high" parts, and to indicate which part of the gauge is the "optimum" part. The low attribute specifies the range that is considered to be the "low" part, and the high attribute specifies the range that is considered to be the "high" part. The optimum attribute gives the position that is "optimum"; if that is higher than the "high" value then this indicates that the higher the value, the better; if it's lower than the "low" mark then it indicates that lower values are better, and naturally if it is in between then it indicates that neither high nor low values are good.

Authoring requirements p559 p559 p559 p559 p559 p559 p559 : The value attribute must be specified. The value , min , low , high , max , and optimum

attributes, when present, must have values that are p69 valid floating-point numbers.

559

In addition, the attributes' values are further constrained: Let p559 value be the value attribute's number.

If the p559 min attribute is specified, then let minimum be that attribute's value; otherwise, let it be zero.

If the p559 max attribute is specified, then let maximum be that attribute's value; otherwise, let it be 1.0.

The following inequalities must hold, as applicable:

• minimum ≤ value ≤ maximum

• p559 p559 minimum ≤ low ≤ maximum (if low is specified)

• p559 p559 minimum ≤ high ≤ maximum (if high is specified)

• p559 p559 minimum ≤ optimum ≤ maximum (if optimum is specified)

• p559 p559 p559 p559 low ≤ high (if both low and high are specified) Note

If no minimum or maximum is specified, then the range is assumed to be 0..1, and the value thus has to be within that range.

Authors are encouraged to include a textual representation of the gauge's state in the element's contents, for users of user agents that do not support the p558 meter element.

When used with p732 p558 p559 microdata , the meter element's value attribute provides the element's machine-readable value.

Example

The following examples show three gauges that would all be three-quarters full:

Storage space usage: 6 blocks used (out of 8 total) Voter turnout: Tickets sold:

The following example is incorrect use of the element, because it doesn't give a range (and since the default maximum is 1, both

of the gauges would end up looking maxed out):



The grapefruit pie had a radius of 12cm and a height of 2cm.



Instead, one would either not include the meter element, or use the meter element with a defined range to give the dimensions in

context compared to other pies:



The grapefruit pie had a radius of 12cm and a height of 2cm.





Radius:

12cm





Height:

2cm





There is no explicit way to specify units in the p558 p140 meter element, but the units may be specified in the title attribute in free-form text.

Example

The example above could be extended to mention the units:





Radius:

12cm

Height:

2cm





User agent requirements p559 p559 p559 p559 p559 p559 : User agents must parse the min , max , value , low , high , and optimum attributes using the p70 rules for parsing floating-point number values.

560

User agents must then use all these numbers to obtain values for six points on the gauge, as follows. (The order in which these are evaluated is important, as some of the values refer to earlier ones.) The minimum value

If the p559 min attribute is specified and a value could be parsed out of it, then the minimum value is that value. Otherwise, the minimum value is zero.

The maximum value

If the p559 max attribute is specified and a value could be parsed out of it, then the candidate maximum value is that value. Otherwise, the candidate maximum value is 1.0.

If the candidate maximum value is greater than or equal to the minimum value, then the maximum value is the candidate maximum value. Otherwise, the maximum value is the same as the minimum value.

The actual value

If the p559 value attribute is specified and a value could be parsed out of it, then that value is the candidate actual value. Otherwise, the candidate actual value is zero.

If the candidate actual value is less than the minimum value, then the actual value is the minimum value.

Otherwise, if the candidate actual value is greater than the maximum value, then the actual value is the maximum value.

Otherwise, the actual value is the candidate actual value.

The low boundary

If the p559 low attribute is specified and a value could be parsed out of it, then the candidate low boundary is that value. Otherwise, the candidate low boundary is the same as the minimum value.

If the candidate low boundary is less than the minimum value, then the low boundary is the minimum value.

Otherwise, if the candidate low boundary is greater than the maximum value, then the low boundary is the maximum value.

Otherwise, the low boundary is the candidate low boundary.

The high boundary

If the p559 high attribute is specified and a value could be parsed out of it, then the candidate high boundary is that value. Otherwise, the candidate high boundary is the same as the maximum value.

If the candidate high boundary is less than the low boundary, then the high boundary is the low boundary.

Otherwise, if the candidate high boundary is greater than the maximum value, then the high boundary is the maximum value.

Otherwise, the high boundary is the candidate high boundary.

The optimum point

If the p559 optimum attribute is specified and a value could be parsed out of it, then the candidate optimum point is that value. Otherwise, the candidate optimum point is the midpoint between the minimum value and the maximum value.

If the candidate optimum point is less than the minimum value, then the optimum point is the minimum value.

Otherwise, if the candidate optimum point is greater than the maximum value, then the optimum point is the maximum value.

Otherwise, the optimum point is the candidate optimum point.

All of which will result in the following inequalities all being true:

• minimum value ≤ actual value ≤ maximum value

• minimum value ≤ low boundary ≤ high boundary ≤ maximum value • minimum value ≤ optimum point ≤ maximum value UA requirements for regions of the gauge: If the optimum point is equal to the low boundary or the high boundary, or anywhere in between them, then the region between the low and high boundaries of the gauge must be treated as the optimum region, and the low and high parts, if any, must be treated as suboptimal. Otherwise, if the optimum point is less than the low boundary, then the region between the minimum value and the low boundary must be treated as the optimum region, the region from the low boundary up to the high boundary must be treated as a suboptimal region, and the remaining region must be treated as an even less good region. Finally,

561

if the optimum point is higher than the high boundary, then the situation is reversed; the region between the high boundary and the maximum value must be treated as the optimum region, the region from the high boundary down to the low boundary must be treated as a suboptimal region, and the remaining region must be treated as an even less good region.

UA requirements for showing the gauge p558 : When representing a meter element to the user, the UA should indicate the relative position of the actual value to the minimum and maximum values, and the relationship between the actual value and the three regions of the gauge.

Example

The following markup:





Suggested groups





Hide suggested groups





view">comp.infosystems.www.authoring.stylesheets-

join





Group description: Layout/presentation on the WWW.

Moderate activity, Usenet, 618 subscribers





netscape.public.mozilla.xpinstall

-

join





Group description: Mozilla XPInstall discussion.

Low activity, Usenet, 22 subscribers





mozilla.dev.general-

join





Low activity, Usenet, 66 subscribers





Might be rendered as follows:





User agents may combine the value of the p140 title attribute and the other attributes to provide context-sensitive help or inline text detailing the actual values.

Example

For example, the following snippet:



...might cause the user agent to display a gauge with a tooltip saying "Value: 23.2 out of 60." on one line and "seconds" on a

562

second line.

The p561 value IDL attribute, on getting, must return the actual value . On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the value content attribute must be set to that string.

The p561 min IDL attribute, on getting, must return the minimum value. On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the min content attribute must be set to that string.

The p561 max IDL attribute, on getting, must return the maximum value . On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the max content attribute must be set to that string.

The p561 low IDL attribute, on getting, must return the low boundary. On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the low content attribute must be set to that string.

The p561 high IDL attribute, on getting, must return the high boundary. On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the high content attribute must be set to that string.

The p561 optimum IDL attribute, on getting, must return the optimum value. On setting, the given value must be converted to the best

representation of the number as a floating-point number p70 p559 and then the optimum content attribute must be set to that string.

The p493 p491 labels IDL attribute provides a list of the element's labels.

Example

The following example shows how a gauge could fall back to localized or pretty-printed text.



Disk usage: 170 261 928 bytes used out of 233 257 824 bytes available





✔ MDN

4.10.15 The fieldset element p56 §

3

Categories p129: ✔ MDN

Flow content p132 .

Sectioning root p200 .

Listed p487 p487 p487 and autocapitalize-inheriting form-associated element .

Palpable content p134.

Contexts in which this element can be used p129 :

Where p132 flow content is expected.

Content model p129:

Optionally a p566 p132 legend element, followed by flow content .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

disabled p564 p566 — Whether the descendant form controls, except any inside legend, are disabled

form p567 p487 — Associates the element with a form element

name p569 p489 — Name of the element to use in the form.elements API.

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLFieldSetElement : HTMLElement {

563

[HTMLConstructor] constructor();

[CEReactions] attribute boolean disabled;

readonly attribute HTMLFormElement? form;

[CEReactions] attribute DOMString name;

readonly attribute DOMString type;

[SameObject] readonly attribute HTMLCollection elements;

readonly attribute boolean willValidate;

[SameObject] readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

undefined setCustomValidity(DOMString error);

};



The p563 p124 fieldset element represents a set of form controls (or other content) grouped together, optionally with a caption. The caption is given by the first p566 p563 legend element that is a child of the fieldset element, if any. The remainder of the descendants ✔ MDN form the group.

The p563 disabled attribute, when specified, causes all the form control descendants of the fieldset element, excluding those that are descendants of the p563 p566 p571 fieldset element's first legend element child, if any, to be disabled.

A p563 fieldset element is a disabled fieldset if it matches any of the following conditions:

• Its p564 disabled attribute is specified

• It is a descendant of another p563 p564 fieldset element whose disabled attribute is specified, and is not a descendant of that

fieldset p563 p566 element's first legend element child, if any.

The p567 p563 p567 p569 form attribute is used to explicitly associate the fieldset element with its form owner . The name attribute represents the element's name.

For web developers (non-normative)

fieldset p564 . type

Returns the string "fieldset".

fieldset p564 . elements

Returns an HTMLCollection of the form controls in the element.

The p95 disabled IDL attribute must reflect the content attribute of the same name.

The type IDL attribute must return the string "fieldset".

The p563 elements IDL attribute must return an HTMLCollection rooted at the fieldset element, whose filter matches listed

elements p487.

The p594 p594 p596 p595 p596 willValidate , validity , and validationMessage attributes, and the checkValidity() , reportValidity(), and

setCustomValidity() p594 p593 p569 p569 methods, are part of the constraint validation API . The form and name IDL attributes are part of the element's forms API.

Example

This example shows a p563 fieldset element being used to group a set of related controls:





Display



Black on White

White on Black

564



Use grayscale



Enhance contrast

step=1>





Example

The following snippet shows a fieldset with a checkbox in the legend that controls whether or not the fieldset is enabled. The

contents of the fieldset consist of two required text controls and an optional year/month control.





Use Club Card





Name on card:

Card number:

Expiry date:





Example

You can also nest p563 fieldset elements. Here is an example expanding on the previous one that does so:





Use Club Card





Name on card:





My card has numbers on it





Card number:





My card has letters on it





Card code:





In this example, if the outer "Use Club Card" checkbox is not checked, everything inside the outer p563 fieldset , including the two

radio buttons in the legends of the two nested p563 fieldsets, will be disabled. However, if the checkbox is checked, then the radio

buttons will both be enabled and will let you select which of the two inner p563 fieldsets is to be enabled.



Example

This example shows a grouping of controls where the p566 legend element both labels the grouping, and the nested heading

element surfaces the grouping in the document outline:





565





How can we best reach you?





Phone





Text





Email





✔ MDN

4.10.16 The legend element p56 §

6

Categories p129: ✔ MDN

None.

Contexts in which this element can be used p129 :

As the p563 first child of a fieldset element.

Content model p129:

Phrasing content p133 p133 , optionally intermixed with heading content.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLLegendElement : HTMLElement {

[HTMLConstructor] constructor();

readonly attribute HTMLFormElement? form;

// also has obsolete members

};



The p566 p124 p566 p563 legend element represents a caption for the rest of the contents of the legend element's parent fieldset element, if any.

For web developers (non-normative)

legend p566 . form

Returns the element's p487 form element, if any, or null otherwise.

The p566 p563 p566 form IDL attribute's behavior depends on whether the legend element is in a fieldset element or not. If the legend has

a p563 p566 p569 fieldset element as its parent, then the form IDL attribute must return the same value as the form IDL attribute on that

566

fieldset p563 element. Otherwise, it must return null.



4.10.17 Form control infrastructure p56 §

7

4.10.17.1 A form control's value p56 §

7

Most form controls have a p494 value and a checkedness . (The latter is only used by input elements.) These are used to describe how the user interacts with the control.

A control's p567 value is its internal state. As such, it might not match the user's current input.

Example

For instance, if a user enters the word " p510 three " into a numeric field that expects digits, the user's input would be the string

"three" but the control's p567 value would remain unchanged. Or, if a user enters the email address " awesome@example.com" (with

leading whitespace) into p503 an email field, the user's input would be the string " awesome@example.com" but the browser's UI for

email fields might translate that into a p567 value of "awesome@example.com" (without the leading whitespace).

input p494 p549 p567 and textarea elements have a dirty value flag . This is used to track the interaction between the value and default value. If it is false, p567 value mirrors the default value. If it is true, the default value is ignored.

To define the behavior of constraint validation in the face of the p494 p525 p494 input element's multiple attribute, input elements can also have separately defined values.

To define the behavior of the p570 p570 p549 maxlength and minlength attributes, as well as other APIs specific to the textarea element, all form control with a p567 value also have an algorithm for obtaining an API value. By default this algorithm is to simply return the control's p567 value.

The p538 p567 p548 p546 select element does not have a value ; the selectedness of its option elements is what is used instead.



4.10.17.2 Mutability p56 §

7

A form control can be designated as mutable.

Note

This determines (by means of definitions and requirements in this specification that rely on whether an element is so designated)

whether or not the user can modify the p567 p567 value or checkedness of a form control, or whether or not a control can be

automatically prefilled.



4.10.17.3 Association of controls and forms p56 §

7

A p487 p487 form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-

associated element p487 p487 p567 is not associated with a form element, its form owner is said to be null.

✔ MDN

A p487 form-associated element has an associated parser inserted flag.

A p487 p487 form-associated element is, by default, associated with its nearest ancestor form element (as described below), but, if it is

listed p487, may have a form attribute specified to override this.

Note

This feature allows authors to work around the lack of support for nested p487 form elements.

If a p487 p487 p567 p487 listed form-associated element has a form attribute specified, then that attribute's value must be the ID of a form

element in the element's tree.



567

Note

The rules in this section are complicated by the fact that although conforming documents or trees will never contain nested

form p487 elements, it is quite possible (e.g., using a script that performs DOM manipulation) to generate trees that have such

nested elements. They are also complicated by rules in the HTML parser that, for historical reasons, can result in a form-associated

element p487 p487 being associated with a form element that is not its ancestor.

When a p487 p567 form-associated element is created, its form owner must be initialized to null (no owner).

When a p487 p567 form-associated element is to be associated with a form, its form owner must be set to that form.

When a p487 p44 form-associated element or one of its ancestors is inserted, then:

1. If the p487 p567 form-associated element 's parser inserted flag is set, then return.

2. p568 p487 Reset the form owner of the form-associated element.

When a p487 p44 form-associated element or one of its ancestors is removed, then:

1. If the p487 p567 p487 p567 form-associated element has a form owner and the form-associated element and its form owner are no

longer in the same p568 p487 tree , then reset the form owner of the form-associated element .

When a p487 p487 p567 listed form-associated element 's form attribute is set, changed, or removed, then the user agent must reset the form

owner p568 of that element.

When a p487 p487 p567 listed form-associated element has a form attribute and the ID of any of the elements in the tree changes, then the user agent must p568 p487 reset the form owner of that form-associated element.

When a p487 p487 p567 p44 p44 listed form-associated element has a form attribute and an element with an ID is inserted into or removed from

the p115 p568 p487 Document , then the user agent must reset the form owner of that form-associated element.

When the user agent is to p487 reset the form owner of a form-associated element element, it must run the following steps:

1. Unset p567 element 's parser inserted flag .

2. If all of the following conditions are true

◦ p567 element 's form owner is not null

◦ p487 p567 element is not listed or its form content attribute is not present

◦ p567 p487 element 's form owner is its nearest form element ancestor after the change to the ancestor chain

then do nothing, and return.

3. Set p567 element 's form owner to null.

4. If p487 p567 element is listed , has a form content attribute, and is connected, then:

1. If the first element in p567 element 's tree , in tree order , to have an ID that is identical to element 's form content

attribute's value, is a p487 p568 p487 form element, then associate the element with that form element.

5. Otherwise, if p487 p568 p487 element has an ancestor form element, then associate element with the nearest such ancestor form

element.

Example

In the following non-conforming snippet:

...





...

568

The p567 p567 form owner of "d" would be the inner nested form "c", while the form owner of "e" would be the outer form "a".

This happens as follows: First, the "e" node gets associated with "c" in the p1076 HTML parser. Then, the innerHTML algorithm moves

the nodes from the temporary document to the "b" element. At this point, the nodes see their ancestor chain change, and thus all

the "magic" associations done by the parser are reset to normal ancestor associations.

This example is a non-conforming document, though, as it is a violation of the content models to nest p487 form elements, and there

is a p1078 parse error for the tag.



For web developers (non-normative)

element p569 . form

Returns the element's p567 form owner .

Returns null if there isn't one.



Listed p487 p487 p706 form-associated elements except for form-associated custom elements have a form IDL attribute, which, on getting, ✔ MDN

must return the element's p567 form owner, or null if there isn't one.

Form-associated custom elements p706 p569 p717 don't have form IDL attribute. Instead, their ElementInternals object has a form IDL

attribute. On getting, it must throw a p717 " NotSupportedError " DOMException if the target element is not a form-associated custom

element p706 p567 . Otherwise, it must return the element's form owner, or null if there isn't one.



4.10.18 Attributes common to form controls p56 §

9

4.10.18.1 Naming form controls: the p569 p56 name attribute §

9

The p596 p487 name content attribute gives the name of the form control, as used in form submission and in the form element's

elements p489 object. If the attribute is specified, its value must not be the empty string or isindex.

Note

A number of user agents historically implemented special support for first-in-form text controls with the name isindex, and this

specification previously defined related user agent requirements for it. However, some user agents subsequently dropped that

special support, and the related requirements were removed from this specification. So, to avoid problematic reinterpretations in

legacy user agents, the name isindex is no longer allowed.

Other than p488 isindex , any non-empty value for name is allowed. An ASCII case-insensitive match for the name _charset_ is special: if used as the name of a p500 p498 p498 Hidden control with no value attribute, then during submission the value attribute is automatically given a value consisting of the submission character encoding.

The p95 p569 name IDL attribute must reflect the name content attribute.

Note

DOM clobbering is a common cause of security issues. Avoid using the names of built-in form properties with the p569 name content

attribute.

In this example, the p494 p572 input element overrides the built-in method property:

let form = document.createElement("form");

let input = document.createElement("input");

form.appendChild(input);

form.method; // => "get"

input.name = "method"; // DOM clobbering occurs here

form.method === input; // => true

Since the input name takes precedence over built-in form properties, the JavaScript reference form.method will point to the

input p494 p572 element named "method" instead of the built-in method property.

569

4.10.18.2 Submitting element directionality: the p570 p57 dirname attribute §

0

The p143 dirname attribute on a form control element enables the submission of the directionality of the element, and gives the name of the control that contains this value during p596 form submission. If such an attribute is specified, its value must not be the empty string.

Example

In this example, a form contains a text control and a submission button:





Comment:

Post Comment





When the user submits the form, the user agent includes three fields, one called "comment", one called "comment.dir", and one

called "mode"; so if the user types "Hello", the submission body might be something like:

comment=Hello&comment.dir=ltr&mode=add

If the user manually switches to a right-to-left writing direction and enters "ابحرم", the submission body might be something like:

comment=%D9%85%D8%B1%D8%AD%D8%A8%D8%A7&comment.dir=rtl&mode=add



4.10.18.3 Limiting user input length: the p570 p57 maxlength attribute §

0

A p567 form control maxlength attribute , controlled by the dirty value flag , declares a limit on the number of characters a user can input. The "number of characters" is measured using p549 length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).

If an element has its p570 p69 form control maxlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the p69 rules for parsing non-negative integers to its value results in a number, then that number is the element's maximum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no

maximum allowed value length p570 .

Constraint validation p570 p567 p567 : If an element has a maximum allowed value length , its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the p567 length of the element's API value is greater than the element's p570 p591 maximum allowed value length , then the element is suffering from being too long.

User agents may prevent the user from causing the element's p567 API value to be set to a value whose length is greater than the element's p570 maximum allowed value length.

Note

In the case of p549 p567 p567 textarea elements, the API value and value differ. In particular, newline normalization is applied before

the p570 p552 maximum allowed value length is checked (whereas the textarea wrapping transformation is not applied).



4.10.18.4 Setting minimum input length requirements: the p570 p57 minlength attribute §

0

A p567 form control minlength attribute , controlled by the dirty value flag , declares a lower bound on the number of characters a user can input. The "number of characters" is measured using p549 length and, in the case of textarea elements, with all newlines normalized to a single character (as opposed to CRLF pairs).

Note

The p570 minlength attribute does not imply the required attribute. If the form control has no required attribute, then the value

can still be omitted; the p570 minlength attribute only kicks in once the user has entered a value at all. If the empty string is not

allowed, then the required attribute also needs to be set.

If an element has its p570 p69 form control minlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the p69 rules for parsing non-negative integers to its value results in a number, then that number is

570

the element's minimum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no

minimum allowed value length p571.

If an element has both a p570 p571 maximum allowed value length and a minimum allowed value length, the minimum allowed value

length p571 p570 must be smaller than or equal to the maximum allowed value length .

Constraint validation p571 p567 p567 : If an element has a minimum allowed value length , its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), its p567 value is not the empty string, and the length of the element's

API value p567 p571 p591 is less than the element's minimum allowed value length , then the element is suffering from being too short.

Example

In this example, there are four text controls. The first is required, and has to be at least 5 characters long. The other three are

optional, but if the user fills one in, the user has to enter at least 10 characters.





Name of Event:

Describe what you would like for breakfast, if anything:





Describe what you would like for lunch, if anything:





Describe what you would like for dinner, if anything:





4.10.18.5 Enabling and disabling form controls: the p571 p57 disabled attribute §

1

The p67 disabled content attribute is a boolean attribute.

Note

The p547 p546 p546 p545 disabled attribute for option elements and the disabled attribute for optgroup elements are defined

separately.

A form control is disabled if any of the following conditions are met:

1. The element is a p536 p494 p538 p549 p706 button , input , select , textarea , or form-associated custom element , and the

disabled p571 attribute is specified on this element (regardless of its value).

2. The element is a descendant of a p563 p564 fieldset element whose disabled attribute is specified, and is not a descendant of

that p563 p566 fieldset element's first legend element child, if any.

A form control that is p571 p933 p939 disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.

✔ MDN

Constraint validation p571 p591 : If an element is disabled , it is barred from constraint validation.

The p95 p571 disabled IDL attribute must reflect the disabled content attribute.



4.10.18.6 Form submission attributes p57 §

1

Attributes for form submission p487 p487 can be specified both on form elements and on submit buttons (elements that represent ✔ MDN

buttons that submit forms, e.g. an p494 p496 p519 input element whose type attribute is in the Submit Button state).

The p571 p487 p572 p573 p572 attributes for form submission that may be specified on form elements are action , enctype , method ,

novalidate p573 p573 , and target .

The corresponding p571 p487 p572 p573 attributes for form submission that may be specified on submit buttons are formaction , formenctype ,

formmethod p572 p573 p573 , formnovalidate , and formtarget . When omitted, they default to the values given on the corresponding

571

attributes on the p487 form element.



The action and formaction content attributes, if specified, must have a value that is a valid non-empty URL potentially surrounded by

spaces p88.

The p572 p487 action of an element is the value of the element's formaction attribute, if the element is a submit button and has such an attribute, or the value of its p567 p572 form owner 's action attribute, if it has one, or else the empty string.



The p68 method and formmethod content attributes are enumerated attributes with the following keywords and states:

• The keyword get, mapping to the state GET, indicating the HTTP GET method.

• The keyword post, mapping to the state POST, indicating the HTTP POST method.

• The keyword p487 p611 dialog , mapping to the state dialog , indicating that submitting the form is intended to close the dialog

box in which the form finds itself, if any, and otherwise not submit.

The p572 p68 p68 p572 method attribute's invalid value default and missing value default are both the GET state.

The p572 p68 p572 p68 formmethod attribute's invalid value default is the GET state. It has no missing value default.

The p487 p572 method of an element is one of those states. If the element is a submit button and has a formmethod attribute, then the element's p572 p567 p572 method is that attribute's state; otherwise, it is the form owner 's method attribute's state.

Example

Here the p572 p572 method attribute is used to explicitly specify the default value, " get ", so that the search query is submitted in the

URL:





Search terms:





Example

On the other hand, here the p572 p572 method attribute is used to specify the value " post", so that the user's message is submitted in

the HTTP request's body:





Message:





Example

In this example, a p487 p611 p572 p572 form is used with a dialog . The method attribute's " dialog" keyword is used to have the dialog

automatically close when the form is submitted.





A ship has arrived in the harbour.



Board the ship

Call to the captain





The p68 enctype and formenctype content attributes are enumerated attributes with the following keywords and states:

• The "application/x-www-form-urlencoded" keyword and corresponding state.

• The "multipart/form-data" keyword and corresponding state.

• The "text/plain" keyword and corresponding state.

The p573 p68 p68 enctype attribute's invalid value default and missing value default are both the application/x-www-form-

urlencoded p573 state.

The p573 p68 p573 formenctype attribute's invalid value default is the application/x-www-form-urlencoded state. It has no missing value

default p68.

The p487 p573 enctype of an element is one of those three states. If the element is a submit button and has a formenctype attribute, then the element's p573 p567 p573 enctype is that attribute's state; otherwise, it is the form owner 's enctype attribute's state.



The p822 target and formtarget content attributes, if specified, must have values that are valid browsing context names or keywords.



The p67 novalidate and formnovalidate content attributes are boolean attributes. If present, they indicate that the form is not to be validated during submission.

The p487 p573 no-validate state of an element is true if the element is a submit button and the element's formnovalidate attribute is present, or if the element's p567 p573 form owner 's novalidate attribute is present, and false otherwise.

Example

This attribute is useful to include "save" buttons on forms that have validation constraints, to allow users to save their progress

even though they haven't fully entered the data in the form. The following example shows a simple form that has two required

fields. There are three buttons: one to submit the form, which requires both fields to be filled in; one to save the form so that the

user can come back and fill it in later; and one to cancel the form altogether.





Name:





Essay:





The p95 action IDL attribute must reflect the content attribute of the same name, except that on getting, when the content attribute is ✔ MDN

missing or its value is the empty string, the element's node document's URL must be returned instead. The target IDL attribute must

reflect p95 p95 the content attribute of the same name. The method and enctype IDL attributes must reflect the respective content attributes of the same name, p95 p95 p573 limited to only known values . The encoding IDL attribute must reflect the enctype content attribute, p95 p95 p573 limited to only known values . The noValidate IDL attribute must reflect the novalidate content attribute. The formAction p95 p572 IDL attribute must reflect the formaction content attribute, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The formEnctype IDL attribute must p95 p573 p95 p95 reflect the formenctype content attribute, limited to only known values . The formMethod IDL attribute must reflect the

formmethod p572 p95 p95 content attribute, limited to only known values . The formNoValidate IDL attribute must reflect the

formnovalidate p573 p95 p573 content attribute. The formTarget IDL attribute must reflect the formtarget content attribute.

573





MDN


4.10.18.7 Autofill p57 §

4



4.10.18.7.1 Autofilling form controls: the p574 p57 autocomplete attribute §

4

User agents sometimes have features for helping users fill forms in, for example prefilling the user's address based on earlier user input. The autocomplete content attribute can be used to hint to the user agent how to, or indeed whether to, provide such a feature.

There are two ways this attribute is used. When wearing the p574 autofill expectation mantle , the autocomplete attribute describes what input is expected from users. When wearing the p574 autofill anchor mantle , the autocomplete attribute describes the meaning of the given value.

On an p494 p496 p500 p574 input element whose type attribute is in the Hidden state, the autocomplete attribute wears the autofill anchor

mantle p574 p574 . In all other cases, it wears the autofill expectation mantle.

When wearing the p574 p574 autofill expectation mantle , the autocomplete attribute, if specified, must have a value that is an ordered set

of space-separated tokens p87 p575 consisting of either a single token that is an ASCII case-insensitive match for the string " off ", or a

single token that is an p576 p574 ASCII case-insensitive match for the string " on ", or autofill detail tokens .

When wearing the p574 p574 autofill anchor mantle , the autocomplete attribute, if specified, must have a value that is an ordered set of

space-separated tokens p87 p574 p576 p575 consisting of just autofill detail tokens (i.e. the " on " and " off" keywords are not allowed).

Autofill detail tokens are the following, in the order given below:

1. Optionally, a token whose first eight characters are an ASCII case-insensitive match for the string "section-", meaning that

the field belongs to the named group.

Example

For example, if there are two shipping addresses in the form, then they could be marked up as:





Ship the blue gift to...



Address: street-address">



City: address-level2">



Postal Code:





Ship the red gift to...



Address: street-address">



City: address-level2">



Postal Code:





2. Optionally, a token that is an ASCII case-insensitive match for one of the following strings:

◦ "shipping", meaning the field is part of the shipping address or contact information ◦ "billing", meaning the field is part of the billing address or contact information

3. Either of the following two options:

◦ A token that is an p576 ASCII case-insensitive match for one of the following autofill field names, excluding those that

are p576 inappropriate for the control :

▪ " p576 name"

▪ " p576 honorific-prefix "

▪ " p576 given-name"

▪ " p576 additional-name"

▪ " p576 family-name "

▪ " p576 honorific-suffix "

574

▪ " p577 nickname "

▪ " p577 username "

▪ " p577 new-password "

▪ " p577 current-password "

▪ " p577 one-time-code"

▪ " p577 organization-title"

▪ " p577 organization "

▪ " p577 street-address"

▪ " p577 address-line1"

▪ " p577 address-line2"

▪ " p577 address-line3"

▪ " p577 address-level4"

▪ " p577 address-level3"

▪ " p577 address-level2"

▪ " p577 address-level1"

▪ " p577 country "

▪ " p577 country-name "

▪ " p577 postal-code "

▪ " p577 cc-name "

▪ " p577 cc-given-name"

▪ " p577 cc-additional-name"

▪ " p577 cc-family-name"

▪ " p577 cc-number"

▪ " p577 cc-exp"

▪ " p577 cc-exp-month "

▪ " p577 cc-exp-year "

▪ " p577 cc-csc"

▪ " p577 cc-type "

▪ " p577 transaction-currency "

▪ " p578 transaction-amount"

▪ " p578 language "

▪ " p578 bday"

▪ " p578 bday-day "

▪ " p578 bday-month"

▪ " p578 bday-year"

▪ " p578 sex "

▪ " p578 url "

▪ " p578 photo"

(See the table below for descriptions of these values.)

◦ The following, in the given order:

1. Optionally, a token that is an ASCII case-insensitive match for one of the following strings:

▪ "home", meaning the field is for contacting someone at their residence ▪ "work", meaning the field is for contacting someone at their workplace ▪ "mobile", meaning the field is for contacting someone regardless of location ▪ "fax", meaning the field describes a fax machine's contact details ▪ "pager", meaning the field describes a pager's or beeper's contact details

2. A token that is an p576 ASCII case-insensitive match for one of the following autofill field names, excluding

those that are p576 inappropriate for the control:

▪ " p578 tel "

▪ " p578 tel-country-code "

▪ " p578 tel-national "

▪ " p578 tel-area-code"

▪ " p578 tel-local"

▪ " p578 tel-local-prefix "

▪ " p578 tel-local-suffix "

▪ " p578 tel-extension"

▪ " p578 email"

▪ " p578 impp"

(See the table below for descriptions of these values.) As noted earlier, the meaning of the attribute and its keywords depends on the mantle that the attribute is wearing.

↪ p574 When wearing the autofill expectation mantle ...

The "off" keyword indicates either that the control's input data is particularly sensitive (for example the activation code for a nuclear weapon); or that it is a value that will never be reused (for example a one-time-key for a bank login) and the user will therefore have to explicitly enter the data each time, instead of being able to rely on the UA to prefill the value for them; or that the document provides its own autocomplete mechanism and does not want the user agent to provide autocompletion values.

575

The "on" keyword indicates that the user agent is allowed to provide the user with autocompletion values, but does not provide any further information about what kind of data the user might be expected to enter. User agents would have to use heuristics to decide what autocompletion values to suggest.

The p576 autofill field listed above indicate that the user agent is allowed to provide the user with autocompletion values, and specifies what kind of value is expected. The meaning of each such keyword is described in the table below.

If the p574 p567 autocomplete attribute is omitted, the default value corresponding to the state of the element's form owner's

autocomplete p489 p576 p575 p567 p576 attribute is used instead (either " on " or " off "). If there is no form owner , then the value " on " is used.

↪ p574 When wearing the autofill anchor mantle...

The p576 autofill field listed above indicate that the value of the particular kind of value specified is that value provided for this element. The meaning of each such keyword is described in the table below.

Example

In this example the page has explicitly specified the currency and amount of the transaction. The form requests a credit card and other billing details. The user agent could use this information to suggest a credit card that it knows has sufficient balance and that supports the relevant currency.





Credit card number:

autocomplete=cc-number>



Expiry Date:





The autofill field keywords relate to each other as described in the table below. Each field name listed on a row of this table corresponds to the meaning given in the cell for that row in the column labeled "Meaning". Some fields correspond to subparts of other fields; for example, a credit card expiry date can be expressed as one field giving both the month and year of expiry (" p577 cc-exp"), or

as two fields, one giving the month (" p577 p577 cc-exp-month ") and one the year (" cc-exp-year"). In such cases, the names of the broader fields cover multiple rows, in which the narrower fields are defined.

Note

Generally, authors are encouraged to use the broader fields rather than the narrower fields, as the narrower fields tend to expose

Western biases. For example, while it is common in some Western cultures to have a given name and a family name, in that order

(and thus often referred to as a first name and a surname), many cultures put the family name first and the given name second,

and many others simply have one name (a mononym). Having a single field is therefore more flexible.

Some fields are only appropriate for certain form controls. An p576 autofill field name is inappropriate for a control if the control does not belong to the group listed for that p576 p576 autofill field in the fifth column of the first row describing that autofill field in the table below. What controls fall into each group is described below the table.

Field name Meaning Canonical Format Canonical Format Control

Example group

" p578 name " Full name Free-form text, no Sir Timothy John Text

newlines Berners-Lee, OM,

KBE, FRS, FREng,

FRSA

" p578 honorific- lle Free-form text, no Sir Text Prefix or title (e.g. "Mr.", "Ms.", "Dr.", "M ")

prefix" newlines

" p578 given-name " Given name (in some Western cultures, also known as the first name ) Free-form text, no Timothy Text

newlines

"additional- Additional names (in some Western cultures, also known as middle names, Free-form text, no John p578 Text name" forenames other than the first name) newlines

"family-name" Family name (in some Western cultures, also known as the last name or Free-form text, no Berners-Lee p578 Text

surname) newlines

"honorific- Suffix (e.g. "Jr.", "B.Sc.", "MBASW", "II") Free-form text, no OM, KBE, FRS, p578 Text suffix" newlines FREng, FRSA

576





Field name Meaning Canonical Format Canonical Format Control


Example group

" p578 nickname " Nickname, screen name, handle: a typically short name used instead of Free-form text, no Tim Text

the full name newlines

"organization- Job title (e.g. "Software Engineer", "Senior Vice President", "Deputy Free-form text, no Professor p578 Text title" Managing Director") newlines

"username" A username Free-form text, no timbl p579 Username

newlines

"new-password" A new password (e.g. when creating an account or changing a password) Free-form text, no GUMFXbadyrS3 p578 Password

newlines

" p577 p578 current- The current password for the account identified by the username field Free-form text, no qwerty Password

password" (e.g. when logging in) newlines

"one-time-code" One-time code used for verifying user identity Free-form text, no 123456 p578 Password

newlines

" p578 organization " Company name corresponding to the person, address, or contact Free-form text, no World Wide Web Text

information in the other fields associated with this field newlines Consortium

" p578 street-address " Street address (multiple lines, newlines preserved) Free-form text 32 Vassar Street Multiline

MIT Room 32-G524

"address- Street address (one line per field) Free-form text, no 32 Vassar Street p578 Text line1" newlines

"address- Free-form text, no MIT Room 32-G524 p578 Text

line2" newlines

"address- Free-form text, no Textp578

line3" newlines

" p579 p578 address-level4 " The most fine-grained administrative level , in addresses with four Free-form text, no Text

administrative levels newlines

"address-level3" p579 p578 The third administrative level , in addresses with three or more Free-form text, no Text

administrative levels newlines

"address-level2" p579 The second administrative level, in addresses with two or more Free-form text, no Cambridge p578 Text

administrative levels; in the countries with two administrative levels, this newlines

would typically be the city, town, village, or other locality within which the

relevant street address is found

" p579 p578 address-level1 " The broadest administrative level in the address, i.e. the province Free-form text, no MA Text

within which the locality is found; for example, in the US, this would be the newlines state; in Switzerland it would be the canton; in the UK, the post town

"country" Country code Valid ISO 3166-1-alpha-2 US p578 Text

country code

[ISO3166] p1278

" p578 country-name " Country name Free-form text, no US Text

newlines; derived from

country p584 in some cases

" p578 postal-code " Postal code, post code, ZIP code, CEDEX code (if CEDEX, append "CEDEX", Free-form text, no 02139 Text

and the p577 arrondissement , if relevant, to the address-level2 field) newlines

" p578 cc-name " Full name as given on the payment instrument Free-form text, no Tim Berners-Lee Text

newlines

"cc-given- Given name as given on the payment instrument (in some Western Free-form text, no Tim p578 Text name" cultures, also known as the first name) newlines

"cc- Additional names given on the payment instrument (in some Western Free-form text, no p578 Text additional- cultures, also known as middle names, forenames other than the first newlines name" name)

" p578 cc-family- Family name given on the payment instrument (in some Western cultures, Free-form text, no Berners-Lee Text

name" also known as the last name or surname) newlines

"cc-number" Code identifying the payment instrument (e.g. the credit card number) ASCII digits 4114360123456785 p578 Text

"cc-exp" Expiration date of the payment instrument Valid month stringp74 2014-12 Monthp579

" p68 p579 cc-exp- Month component of the expiration date of the payment instrument Valid integer in the 12 Numeric

month" range 1..12

" p68 p579 cc-exp-year " Year component of the expiration date of the payment instrument Valid integer greater 2014 Numeric

than zero

"cc-csc" Security code for the payment instrument (also known as the card ASCII digits 419 p578 Text

security code (CSC), card validation code (CVC), card verification value

(CVV), signature panel code (SPC), credit card ID (CCID), etc)

" p578 cc-type " Type of payment instrument Free-form text, no Visa Text

newlines

"transaction- The currency that the user would prefer the transaction to use ISO 4217 currency code GBP Textp578

currency p1278 " [ISO4217]

577





Field name Meaning Canonical Format Canonical Format Control


Example group

" p579 transaction- The amount that the user would like for the transaction (e.g. when Valid floating-point 401.00 Numeric

amount" entering a bid or sale price) numberp69

" p578 language " Preferred language Valid BCP 47 language tag en Text

[BCP47] p1275

" p75 p579 bday " Birthday Valid date string 1955-06-08 Date

"bday-day" Day component of birthday p68 Valid integer in the 8 p579 Numeric

range 1..31

" p68 p579 bday-month " Month component of birthday Valid integer in the 6 Numeric

range 1..12

" p68 p579 bday-year " Year component of birthday Valid integer greater 1955 Numeric

than zero

" p578 sex " Gender identity (e.g. Female, Fa'afafine) Free-form text, no Male Text

newlines

" p579 url " Home page or other web page corresponding to the company, person, Valid URL string https://www.w3.org/ URL

address, or contact information in the other fields associated with this People/Berners-Lee/ field

"photo" Photograph, icon, or other image corresponding to the company, person, Valid URL string https://www.w3.org/ p579 URL

address, or contact information in the other fields associated with this Press/Stock/Berners-field Lee/

2001-europaeum-

eighth.jpg

"tel" Full telephone number, including country code ASCII digits and U+0020 +1 617 253 5702 p579 Tel

SPACE characters, prefixed

by a U+002B PLUS SIGN

character (+)

"tel-country-Country code component of the telephone number ASCII digits prefixed by a +1 Textp578 code" U+002B PLUS SIGN

character (+)

"tel- Telephone number without the county code component, with a country- ASCII digits and U+0020 617 253 5702 p578 Text national" internal prefix applied if applicable SPACE characters

"tel-area-Area code component of the telephone number, with a country-internal ASCII digits 617 p578 Text code" prefix applied if applicable

"tel- Telephone number without the country code and area code components ASCII digits 2535702 Textp578 local"

" p578 tel- First part of the component of the telephone number that follows the area ASCII digits 253 Text

local-code, when that component is split into two components

prefix"

" p578 tel- Second part of the component of the telephone number that follows the ASCII digits 5702 Text

local-area code, when that component is split into two components

suffix"

"tel-extension" Telephone number internal extension code ASCII digits 1000 p578 Text

" p504 p579 email " Email address Valid email address timbl@w3.org Username

" p579 impp " URL representing an instant messaging protocol endpoint (for example, Valid URL string irc://example.org/ URL

"aim:goim?screenname=example" or "xmpp:fred@example.net") timbl,isuser

The groups correspond to controls as follows:

Text

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

textarea p549 elements

select p538 elements

Multiline

input p494 p496 p500 elements with a type attribute in the Hidden state

textarea p549 elements

select p538 elements

Password

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

578

input p494 p496 p504 elements with a type attribute in the Password state

textarea p549 elements

select p538 elements

URL

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p502 elements with a type attribute in the URL state

textarea p549 elements

select p538 elements

Username

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p503 elements with a type attribute in the Email state

textarea p549 elements

select p538 elements

Tel

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p501 elements with a type attribute in the Telephone state

textarea p549 elements

select p538 elements

Numeric

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p510 elements with a type attribute in the Number state

textarea p549 elements

select p538 elements

Month

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p506 elements with a type attribute in the Month state

textarea p549 elements

select p538 elements

Date

input p494 p496 p500 elements with a type attribute in the Hidden state

input p494 p496 p500 elements with a type attribute in the Text state

input p494 p496 p500 elements with a type attribute in the Search state

input p494 p496 p505 elements with a type attribute in the Date state

textarea p549 elements

select p538 elements Address levels p577 p577 : The " address-level1 " – " address-level4" fields are used to describe the locality of the street address. Different locales have different numbers of levels. For example, the US uses two levels (state and town), the UK uses one or two depending on the address (the post town, and in some cases the locality), and China can use three (province, city, district). The

" p577 address-level1" field represents the widest administrative division. Different locales order the fields in different ways; for example, in the US the town (level 2) precedes the state (level 1); while in Japan the prefecture (level 1) precedes the city (level 2) which precedes the district (level 3). Authors are encouraged to provide forms that are presented in a way that matches the country's conventions (hiding, showing, and rearranging fields accordingly as the user changes the country).



579

4.10.18.7.2 Processing model p58 §

0

Each p494 p574 p497 p538 p549 input element to which the autocomplete attribute applies , each select element, and each textarea element, has an autofill hint set, an autofill scope, an autofill field name, and an IDL-exposed autofill value.

The p580 p577 p577 autofill field name specifies the specific kind of data expected in the field, e.g. " street-address " or " cc-exp".

The p580 p574 p575 autofill hint set identifies what address or contact information type the user agent is to look at, e.g. " shipping fax " or

" p574 billing ".

The p580 p580 autofill scope identifies the group of fields whose information concerns the same subject, and consists of the autofill hint set

with, if applicable, the "section-*" prefix, e.g. "billing", "section-parent shipping", or "section-child shipping home".

These values are defined as the result of running the following algorithm:

1. If the element has no p574 autocomplete attribute, then jump to the step labeled default.

2. Let tokens be the result of splitting the attribute's value on ASCII whitespace.

3. If tokens is empty, then jump to the step labeled default.

4. Let index be the index of the last token in tokens.

5. If the indexth token in tokens is not an ASCII case-insensitive match for one of the tokens given in the first column of the

following table, or if the number of tokens in tokens is greater than the maximum number given in the cell in the second column of that token's row, then jump to the step labeled default. Otherwise, let field be the string given in the cell of the first column of the matching row, and let category be the value of the cell in the third column of that same row.

Token Maximum number of tokens Category

" p575 off" 1 Off

" p576 on" 1 Automatic

" p576 name" 3 Normal

"honorific-prefixp576" 3 Normal

" p576 given-name" 3 Normal

" p576 additional-name" 3 Normal

" p576 family-name" 3 Normal

" p576 honorific-suffix" 3 Normal

" p577 nickname" 3 Normal

" p577 organization-title" 3 Normal

" p577 username" 3 Normal

" p577 new-password" 3 Normal

" p577 current-password" 3 Normal

"one-time-codep577" 3 Normal

" p577 organization" 3 Normal

" p577 street-address" 3 Normal

" p577 address-line1" 3 Normal

" p577 address-line2" 3 Normal

" p577 address-line3" 3 Normal

" p577 address-level4" 3 Normal

" p577 address-level3" 3 Normal

" p577 address-level2" 3 Normal

" p577 address-level1" 3 Normal

"countryp577" 3 Normal

" p577 country-name" 3 Normal

" p577 postal-code" 3 Normal

" p577 cc-name" 3 Normal

" p577 cc-given-name" 3 Normal

" p577 cc-additional-name" 3 Normal

" p577 cc-family-name" 3 Normal

" p577 cc-number" 3 Normal

" p577 cc-exp" 3 Normal

580

Token Maximum number of tokens Category

"cc-exp-monthp577" 3 Normal

" p577 cc-exp-year" 3 Normal

" p577 cc-csc" 3 Normal

" p577 cc-type" 3 Normal

" p577 transaction-currency" 3 Normal

" p578 transaction-amount" 3 Normal

" p578 language" 3 Normal

" p578 bday" 3 Normal

" p578 bday-day" 3 Normal

" p578 bday-month" 3 Normal

"bday-yearp578" 3 Normal

" p578 sex" 3 Normal

" p578 url" 3 Normal

" p578 photo" 3 Normal

" p578 tel" 4 Contact

" p578 tel-country-code" 4 Contact

" p578 tel-national" 4 Contact

" p578 tel-area-code" 4 Contact

" p578 tel-local" 4 Contact

"tel-local-prefixp578" 4 Contact

" p578 tel-local-suffix" 4 Contact

" p578 tel-extension" 4 Contact

" p578 email" 4 Contact

" p578 impp" 4 Contact

6. If p574 p574 category is Off or Automatic but the element's autocomplete attribute is wearing the autofill anchor mantle , then

jump to the step labeled default.

7. If p580 p580 category is Off, let the element's autofill field name be the string " off ", let its autofill hint set be empty, and let its

IDL-exposed autofill value p580 be the string "off". Then, return.

8. If p580 p580 category is Automatic, let the element's autofill field name be the string " on ", let its autofill hint set be empty, and

let its p580 IDL-exposed autofill value be the string "on". Then, return.

9. Let scope tokens be an empty list.

10. Let hint tokens be an empty set.

11. Let IDL value have the same value as field.

12. If the indexth token in tokens is the first entry, then skip to the step labeled done.

13. Decrement index by one.

14. If category is Contact and the indexth token in tokens is an ASCII case-insensitive match for one of the strings in the

following list, then run the substeps that follow:

◦ " p575 home"

◦ " p575 work"

◦ " p575 mobile"

◦ " p575 fax "

◦ " p575 pager"

The substeps are:

1. Let contact be the matching string from the list above.

2. Insert contact at the start of scope tokens.

3. Add contact to hint tokens.

4. Let IDL value be the concatenation of contact, a U+0020 SPACE character, and the previous value of IDL value

(which at this point will always be field).

581

5. If the indexth entry in tokens is the first entry, then skip to the step labeled done.

6. Decrement index by one.

15. If the indexth token in tokens is an ASCII case-insensitive match for one of the strings in the following list, then run the

substeps that follow:

◦ " p574 shipping "

◦ " p574 billing "

The substeps are:

1. Let mode be the matching string from the list above.

2. Insert mode at the start of scope tokens.

3. Add mode to hint tokens.

4. Let IDL value be the concatenation of mode, a U+0020 SPACE character, and the previous value of IDL value

(which at this point will either be field or the concatenation of contact, a space, and field).

5. If the indexth entry in tokens is the first entry, then skip to the step labeled done.

6. Decrement index by one.

16. If the indexth entry in tokens is not the first entry, then jump to the step labeled default.

17. If the first eight characters of the indexth token in tokens are not an ASCII case-insensitive match for the string

" p574 section-", then jump to the step labeled default.

18. Let section be the indexth token in tokens, converted to ASCII lowercase.

19. Insert section at the start of scope tokens.

20. Let IDL value be the concatenation of section, a U+0020 SPACE character, and the previous value of IDL value.

21. p580 Done : Let the element's autofill hint set be hint tokens.

22. Let the element's p580 autofill scope be scope tokens.

23. Let the element's p580 autofill field name be field.

24. Let the element's p580 IDL-exposed autofill value be IDL value.

25. Return.

26. p580 p580 p580 Default : Let the element's IDL-exposed autofill value be the empty string, and its autofill hint set and autofill scope

be empty.

27. If the element's p574 p574 autocomplete attribute is wearing the autofill anchor mantle , then let the element's autofill field

name p580 be the empty string and return.

28. Let p567 form be the element's form owner, if any, or null otherwise.

29. If p489 p489 p580 form is not null and form 's autocomplete attribute is in the off state, then let the element's autofill field name be

" p575 off ".

Otherwise, let the element's p580 p576 autofill field name be " on".



For the purposes of autofill, a control's data depends on the kind of control: An p494 p496 p503 p525 input element with its type attribute in the Email state and with the multiple attribute specified

The element's p567 value s .

Any other p494 input element A p549 textarea element

The element's p567 value.

A p538 p540 select element with its multiple attribute specified

The p546 p538 p540 p548 option elements in the select element's list of options that have their selectedness set to true.

582

Any other p538 select element

The p546 p538 p540 p548 option element in the select element's list of options that has its selectedness set to true.



How to process the p580 p580 p580 p574 autofill hint set , autofill scope , and autofill field name depends on the mantle that the autocomplete

attribute is wearing.

↪ p574 When wearing the autofill expectation mantle ...

When an element's p580 p575 p582 autofill field name is " off ", the user agent should not remember the control's data , and should not offer past values to the user.

Note

In addition, when an element's p580 p575 p891 p890 autofill field name is " off ", values are reset when traversing the history .



Example

Banks frequently do not want UAs to prefill login information:



Account:

PIN:





When an element's p580 p575 p582 autofill field name is not " off ", the user agent may store the control's data , and may offer previously stored values to the user.

Example

For example, suppose a user visits a page with this control:

Afghanistan Albania Algeria Andorra Angola Antigua and Barbuda Argentina Armenia Yemen Zambia Zimbabwe

This might render as follows:





Suppose that on the first visit to this page, the user selects "Zambia". On the second visit, the user agent could duplicate the entry for Zambia at the top of the list, so that the interface instead looks like this:



583



When the p580 p576 autofill field name is " on ", the user agent should attempt to use heuristics to determine the most appropriate

values to offer the user, e.g. based on the element's p569 name value, the position of the element in its tree, what other fields exist in the form, and so forth.

When the p580 p576 autofill field name is one of the names of the autofill fields described above, the user agent should provide

suggestions that match the meaning of the field name as given in the table earlier in this section. The p580 autofill hint set should be used to select amongst multiple possible suggestions.

Example

For example, if a user once entered one address into fields that used the " p574 shipping " keyword, and another address into

fields that used the " p574 billing" keyword, then in subsequent forms only the first address would be suggested for form

controls whose p580 p574 autofill hint set contains the keyword " shipping ". Both addresses might be suggested, however, for

address-related form controls whose p580 autofill hint set does not contain either keyword.



↪ p574 When wearing the autofill anchor mantle...

When the p580 autofill field name is not the empty string, then the user agent must act as if the user had specified the control's

data p582 p580 p580 p580 for the given autofill hint set , autofill scope , and autofill field name combination.

When the user agent p567 p580 autofills form controls , elements with the same form owner and the same autofill scope must use data relating to the same person, address, payment instrument, and contact details. When a user agent autofills " p577 country" and

" p577 p567 p580 p577 country-name " fields with the same form owner and autofill scope , and the user agent has a value for the country"

field(s), then the " p577 country-name" field(s) must be filled using a human-readable name for the same country. When a user agent fills in multiple fields at once, all fields with the same p580 p567 p580 autofill field name , form owner and autofill scope must be filled with the same value.

Example

Suppose a user agent knows of two phone numbers, +1 555 123 1234 and +1 555 666 7777. It would not be conforming for the

user agent to fill a field with autocomplete="shipping tel-local-prefix" with the value "123" and another field in the same

form with autocomplete="shipping tel-local-suffix" with the value "7777". The only valid prefilled values given the

aforementioned information would be "123" and "1234", or "666" and "7777", respectively.



Example

Similarly, if a form for some reason contained both a " p577 p577 cc-exp " field and a " cc-exp-month " field, and the user agent prefilled

the form, then the month component of the former would have to match the latter.



Example

This requirement interacts with the p574 autofill anchor mantle also. Consider the following markup snippet:





The only value that a conforming user agent could suggest in the text control is "TreePlate", the value given by the hidden

input p494 element.

584

The " p580 section-* " tokens in the autofill scope are opaque; user agents must not attempt to derive meaning from the precise values of these tokens.

Example

For example, it would not be conforming if the user agent decided that it should offer the address it knows to be the user's

daughter's address for "section-child" and the addresses it knows to be the user's spouses' addresses for "section-spouse".

The autocompletion mechanism must be implemented by the user agent acting as if the user had modified the p582 control's data, and must be done at a time where the element is p567 mutable (e.g. just after the element has been inserted into the document, or when the user agent p1161 stops parsing). User agents must only prefill controls using values that the user could have entered.

Example

For example, if a p538 p546 select element only has option elements with values "Steve" and "Rebecca", "Jay", and "Bob", and has an

autofill field name p580 p576 " given-name", but the user agent's only idea for what to prefill the field with is "Evan", then the user

agent cannot prefill the field. It would not be conforming to somehow set the p538 select element to the value "Evan", since the

user could not have done so themselves.

A user agent prefilling a form control must not discriminate between form controls that are in a document tree and those that are

connected; that is, it is not conforming to make the decision on whether or not to autofill based on whether the element's root is a

shadow root p115 versus a Document.

A user agent prefilling a form control's p567 p591 value must not cause that control to suffer from a type mismatch, suffer from being too

long p591 p591 p591 p592 p592 , suffer from being too short , suffer from an underflow , suffer from an overflow , or suffer from a step mismatch. A user agent prefilling a form control's p567 p591 value must not cause that control to suffer from a pattern mismatch either. Where possible given the control's constraints, user agents must use the format given as canonical in the aforementioned table. Where it's not possible for the canonical format to be used, user agents should use heuristics to attempt to convert values so that they can be used.

Example

For example, if the user agent knows that the user's middle name is "Ines", and attempts to prefill a form control that looks like

this:



...then the user agent could convert "Ines" to "I" and prefill it that way.



Example

A more elaborate example would be with month values. If the user agent knows that the user's birthday is the 27th of July 2012,

then it might try to prefill all of the following controls with slightly different values, all driven from this information:

2012-07 The day is dropped since the p506 Month state only accepts a month/year combination. (Note that this

<input name=b type=month p580 p578 example is non-conforming, because the autofill field name bday is not allowed with the

autocomplete="bday"> p506

Month state.)

July The user agent picks the month from the listed options, either by noticing there are twelve options and

<select name=c picking the 7th, or by recognizing that one of the strings (three characters "Jul" followed by a newline

autocomplete="bday"> and a space) is a close match for the name of the month (July) in one of the user agent's supported

<option>Jan languages, or through some other similar mechanism.

<option>Feb

...

<option>Jul

<option>Aug

...

select>

7 User agent converts "July" to a month number in the range 1..12, like the field.

<input name=a type=number

min=1 max=12

autocomplete="bday-month">

6 User agent converts "July" to a month number in the range 0..11, like the field.

<input name=a type=number

min=0 max=11

autocomplete="bday-month">



585

User agent doesn't fill in the field, since it can't make a good guess as to what the form expects.

<input name=a type=number

min=1 max=11

autocomplete="bday-month">



A user agent may allow the user to override an element's p580 p575 p576 autofill field name , e.g. to change it from " off " to " on" to allow values to be remembered and prefilled despite the page author's objections, or to always " p575 off", never remembering values.

More specifically, user agents may in particular consider replacing the p580 autofill field name of form controls that match the description given in the first column of the following table, when their p580 p576 p575 autofill field name is either " on " or " off ", with the

value given in the second cell of that row. If this table is used, the replacements must be done in tree order, since all but the first row references the p580 autofill field name of earlier elements. When the descriptions below refer to form controls being preceded or followed by others, they mean in the list of p487 p567 listed elements that share the same form owner.

Form control New autofill field

name p580

an p494 p496 p500 p494 p496 p577 input element whose type attribute is in the Text state that is followed by an input element whose type attribute is " username "

in the p504 Password state

an p494 p496 p504 p494 input element whose type attribute is in the Password state that is preceded by an input element whose autofill field "current-

name p580 p577 p577 is " username " password"

an p494 p496 p504 p494 p577 input element whose type attribute is in the Password state that is preceded by an input element whose autofill field " new-password "

name p580 p577 is " current-password"

an p494 p496 p504 p494 p577 input element whose type attribute is in the Password state that is preceded by an input element whose autofill field " new-password "

name p580 p577 is " new-password"

The p580 p95 autocomplete IDL attribute, on getting, must return the element's IDL-exposed autofill value , and on setting, must reflect

the content attribute of the same name.



4.10.19 APIs for the text control selections p58 §

6

The p494 p549 input and textarea elements define several attributes and methods for handling their selection. Their shared algorithms are defined here.

For web developers (non-normative)

element p588 . select()

Selects everything in the text control.

element p588 . selectionStart [ = value ]

Returns the offset to the start of the selection.

Can be set, to change the start of the selection.

element p588 . selectionEnd [ = value ]

Returns the offset to the end of the selection.

Can be set, to change the end of the selection.

element p589 . selectionDirection [ = value ]

Returns the current direction of the selection.

Can be set, to change the direction of the selection.

The possible values are "forward", "backward", and "none".

element p589 . setSelectionRange (start, end [, direction] )

Changes the selection to cover the given substring in the given direction. If the direction is omitted, it will be reset to be the platform default (none or forward).

element p589 . setRangeText(replacement [, start, end [, selectionMode ] ] )

Replaces a range of text with the new text. If the start and end arguments are not provided, the range is assumed to be the selection.

The final argument determines how the selection will be set after the text has been replaced. The possible values are:

586

" p590 select"

Selects the newly inserted text.

" p590 start "

Moves the selection to just before the inserted text.

" p590 end"

Moves the selection to just after the selected text.

" p590 preserve "

Attempts to preserve the selection. This is the default.

All p494 p497 p549 input elements to which these APIs apply , and all textarea elements, have either a selection or a text entry cursor position p1188 at all times (even for elements that are not being rendered), measured in offsets into the code units of the control's

relevant value p587 p587 . The initial state must consist of a text entry cursor at the beginning of the control.

For p494 p567 p549 input elements, these APIs must operate on the element's value . For textarea elements, these APIs must operate on the element's p567 API value. In the below algorithms, we call the value string being operated on the relevant value.

Example

The use of p567 p550 p549 API value instead of raw value for textarea elements means that U+000D (CR) characters are normalized

away. For example,





If we had operated on the p550 raw value of "A\r\nB", then we would have replaced the characters "A\r", ending up with a result of

" p567 replaced\nB ". But since we used the API value of "A\nB", we replaced the characters "A\n", giving "replacedB".



Note

Characters with no visible rendering, such as U+200D ZERO WIDTH JOINER, still count as characters. Thus, for instance, the

selection can include just an invisible character, and the text insertion cursor can be placed to one side or another of such a

character.

Whenever the p587 relevant value changes for an element to which these APIs apply, run these steps:

1. If the element has a p587 selection:

1. If the start of the selection is now past the end of the p587 p587 relevant value , set it to the end of the relevant value .

2. If the end of the selection is now past the end of the p587 p587 relevant value , set it to the end of the relevant value.

3. If the user agent does not support empty selection, and both the start and end of the selection are now pointing to

the end of the p587 p587 relevant value , then instead set the element's text entry cursor position to the end of the

relevant value p587 , removing any selection.

2. Otherwise, the element must have a p587 p587 text entry cursor position position. If it is now past the end of the relevant value ,

set it to the end of the p587 relevant value.

Note

In some cases where the p587 relevant value changes, other parts of the specification will also modify the text entry cursor

position p587 p553 p549 , beyond just the clamping steps above. For example, see the value setter for textarea .

Where possible, user interface features for changing the p587 p494 p549 text selection in input and textarea elements must be implemented using the p589 set the selection range algorithm so that, e.g., all the same events fire.

The p587 p494 p549 selections of input and textarea elements have a selection direction, which is either "forward", "backward", or "none". The exact meaning of the selection direction depends on the platform. This direction is set when the user manipulates the

587

selection. The initial p587 selection direction must be "none" if the platform supports that direction, or "forward" otherwise.

To p587 set the selection direction of an element to a given direction, update the element's selection direction to the given direction, unless the direction is "none" and the platform does not support that direction; in that case, update the element's selection

direction p587 to "forward".

Note

On Windows, the direction indicates the position of the caret relative to the selection: a "forward" selection has the caret at the

end of the selection and a "backward" selection has the caret at the start of the selection. Windows has no "none" direction.

On Mac, the direction indicates which end of the selection is affected when the user adjusts the size of the selection using the

arrow keys with the Shift modifier: the "forward" direction means the end of the selection is modified, and the "backward"

direction means the start of the selection is modified. The "none" direction is the default on Mac, it indicates that no particular

direction has yet been selected. The user sets the direction implicitly when first adjusting the selection, based on which directional

arrow key was used.



The select() method, when invoked, must run the following steps: MDN

1. If this element is an p494 p588 p497 input element, and either select() does not apply to this element or the corresponding

control has no selectable text, return.

Example

For instance, in a user agent where p514 <input type=color> is rendered as a color well with a picker, as opposed to a text control accepting a hexadecimal color code, there would be no selectable text, and thus calls to the method are ignored.

2. p589 Set the selection range with 0 and infinity.

The selectionStart attribute's getter must run the following steps:

1. If this element is an p494 p588 p497 input element, and selectionStart does not apply to this element, return null.

2. If there is no p587 p587 selection , return the code unit offset within the relevant value to the character that immediately follows

the p587 text entry cursor .

3. Return the p587 code unit offset within the relevant value to the character that immediately follows the start of the

selection p587.

The p588 selectionStart attribute's setter must run the following steps:

1. If this element is an p494 p588 p497 input element, and selectionStart does not apply to this element, throw an

"InvalidStateError" DOMException.

2. Let p588 end be the value of this element's selectionEnd attribute.

3. If end is less than the given value, set end to the given value.

4. p589 p589 Set the selection range with the given value, end , and the value of this element's selectionDirection attribute.

The selectionEnd attribute's getter must run the following steps:

1. If this element is an p494 p588 p497 input element, and selectionEnd does not apply to this element, return null.

2. If there is no p587 p587 selection , return the code unit offset within the relevant value to the character that immediately follows

the p587 text entry cursor .

3. Return the p587 code unit offset within the relevant value to the character that immediately follows the end of the

selection p587.

The p588 selectionEnd attribute's setter must run the following steps:

1. If this element is an p494 p588 p497 input element, and selectionEnd does not apply to this element, throw an

"InvalidStateError" DOMException.

2. p589 p588 Set the selection range with the value of this element's selectionStart attribute, the given value, and the value of

588

this element's p589 selectionDirection attribute.

The selectionDirection attribute's getter must run the following steps:

1. If this element is an p494 p589 p497 input element, and selectionDirection does not apply to this element, return null.

2. Return this element's p587 selection direction.

The p589 selectionDirection attribute's setter must run the following steps:

1. If this element is an p494 p589 p497 input element, and selectionDirection does not apply to this element, throw an

"InvalidStateError" DOMException.

2. p589 p588 Set the selection range with the value of this element's selectionStart attribute, the value of this element's

selectionEnd p588 attribute, and the given value.

The setSelectionRange(start, end, direction) method, when invoked, must run the following steps: ✔ MDN

1. If this element is an p494 p589 p497 input element, and setSelectionRange() does not apply to this element, throw an

"InvalidStateError" DOMException.

2. p589 Set the selection range with start, end, and direction.

To set the selection range with an integer or null start, an integer or null or the special value infinity end, and optionally a string direction, run the following steps:

1. If start is null, let start be zero.

2. If end is null, let end be zero.

3. Set the p587 p587 selection of the text control to the sequence of code units within the relevant value starting with the code unit

at the startth position (in logical order) and ending with the code unit at the (end-1)th position. Arguments greater than the

length p587 of the relevant value of the text control (including the special value infinity) must be treated as pointing at the end of the text control. If end is less than or equal to start then the start of the selection and the end of the selection must both be placed immediately before the character with offset end. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end.

4. If direction is not identical to either "backward" or "forward", or if the direction argument was not given, set direction to

"none".

5. p588 Set the selection direction of the text control to direction.

6. If the previous steps caused the p587 p587 selection of the text control to be modified (in either extent or direction ), then queue

an element task p933 p939 p1272 on the user interaction task source given the element to fire an event named select at the

element, with the bubbles attribute initialized to true.

The setRangeText(replacement, start, end, selectMode) method, when invoked, must run the following steps: ✔ MDN

1. If this element is an p494 p589 p497 input element, and setRangeText() does not apply to this element, throw an

"InvalidStateError" DOMException.

2. Set this element's p567 dirty value flag to true.

3. If the method has only one argument, then let p588 start and end have the values of the selectionStart attribute and the

selectionEnd p588 attribute respectively.

Otherwise, let start, end have the values of the second and third arguments respectively.

4. If start is greater than end, then throw an "IndexSizeError" DOMException.

5. If p587 start is greater than the length of the relevant value of the text control, then set it to the length of the relevant

value p587 of the text control.

6. If p587 p587 end is greater than the length of the relevant value of the text control, then set it to the length of the relevant value

of the text control.

7. Let p588 selection start be the current value of the selectionStart attribute.

8. Let p588 selection end be the current value of the selectionEnd attribute.

589

9. If p587 start is less than end , delete the sequence of code units within the element's relevant value starting with the code unit

at the startth position and ending with the code unit at the (end-1)th position.

10. Insert the value of the first argument into the text of the p587 relevant value of the text control, immediately before the startth

code unit.

11. Let new length be the length of the value of the first argument.

12. Let new end be the sum of start and new length.

13. Run the appropriate set of substeps from the following list:

↪ If the fourth argument's value is "select"

Let selection start be start.

Let selection end be new end.

↪ If the fourth argument's value is "start"

Let selection start and selection end be start.

↪ If the fourth argument's value is "end"

Let selection start and selection end be new end.

↪ If the fourth argument's value is "preserve"

↪ If the method has only one argument

1. Let old length be end minus start.

2. Let delta be new length minus old length.

3. If selection start is greater than end, then increment it by delta. (If delta is negative, i.e. the new text is

shorter than the old text, then this will decrease the value of selection start.)

Otherwise: if selection start is greater than start, then set it to start. (This snaps the start of the selection to the start of the new text if it was in the middle of the text that it replaced.)

4. If selection end is greater than end, then increment it by delta in the same way.

Otherwise: if selection end is greater than start, then set it to new end. (This snaps the end of the selection to the end of the new text if it was in the middle of the text that it replaced.)

14. p589 Set the selection range with selection start and selection end.

The p589 setRangeText() method uses the following enumeration:

IDL enum SelectionMode {

"select",

"start",

"end",

"preserve" // default

};



Example

To obtain the currently selected text, the following JavaScript suffices:

var selectionText = control.value.substring(control.selectionStart, control.selectionEnd);

...where p494 p549 control is the input or textarea element.



Example

To add some text at the start of a text control, while maintaining the text selection, the three attributes must be preserved:



590

var oldStart = control.selectionStart;

var oldEnd = control.selectionEnd;

var oldDirection = control.selectionDirection;

var prefix = "http://";

control.value = prefix + control.value;

control.setSelectionRange(oldStart + prefix.length, oldEnd + prefix.length, oldDirection);

...where p494 p549 control is the input or textarea element.



4.10.20 Constraints p59 §

1

4.10.20.1 Definitions p59 §

1

A p487 submittable element is a candidate for constraint validation except when a condition has barred the element from constraint validation p591 p373 . (For example, an element is barred from constraint validation if it is an object element.) An element can have a p591 custom validity error message defined. Initially, an element must have its custom validity error message

set to the empty string. When its value is not the empty string, the element is p592 suffering from a custom error. It can be set using the

setCustomValidity() p594 p706 p706 method, except for form-associated custom elements . Form-associated custom elements can have a

custom validity error message p591 p717 p719 set via their ElementInternals object's setValidity() method. The user agent should use the p591 custom validity error message when alerting the user to the problem with the control.

An element can be constrained in various ways. The following is the list of validity states that a form control can be in, making the control invalid for the purposes of constraint validation. (The definitions below are non-normative; other parts of this specification define more precisely when each state applies or does not.)

Suffering from being missing

When a control has no p567 p494 p524 p549 p552 value but has a required attribute ( input required , textarea required ); or, more

complicated rules for p538 p515 select elements and controls in radio button groups, as specified in their sections.

When the p719 p706 setValidity() method sets valueMissing flag to true for a form-associated custom element .

Suffering from a type mismatch

When a control that allows arbitrary user input has a p567 p503 p502 value that is not in the correct syntax ( Email , URL ).

When the p719 p706 setValidity() method sets typeMismatch flag to true for a form-associated custom element .

Suffering from a pattern mismatch

When a control has a p567 p526 value that doesn't satisfy the pattern attribute.

When the p719 p706 setValidity() method sets patternMismatch flag to true for a form-associated custom element.

Suffering from being too long

When a control has a p567 p570 p494 p523 p549 value that is too long for the form control maxlength attribute ( input maxlength , textarea

maxlength p552 ).

When the p719 p706 setValidity() method sets tooLong flag to true for a form-associated custom element.

Suffering from being too short

When a control has a p567 p570 p494 p523 p549 value that is too short for the form control minlength attribute ( input minlength , textarea

minlength p552 ).

When the p719 p706 setValidity() method sets tooShort flag to true for a form-associated custom element .

Suffering from an underflow

When a control has a p567 p527 value that is not the empty string and is too low for the min attribute.

When the p719 p706 setValidity() method sets rangeUnderflow flag to true for a form-associated custom element.

591

Suffering from an overflow

When a control has a p567 p527 value that is not the empty string and is too high for the max attribute.

When the p719 p706 setValidity() method sets rangeOverflow flag to true for a form-associated custom element .

Suffering from a step mismatch

When a control has a p567 p528 value that doesn't fit the rules given by the step attribute.

When the p719 p706 setValidity() method sets stepMismatch flag to true for a form-associated custom element .

Suffering from bad input

When a control has incomplete input and the user agent does not think the user ought to be able to submit the form in its current state.

When the p719 p706 setValidity() method sets badInput flag to true for a form-associated custom element .

Suffering from a custom error

When a control's p591 p594 custom validity error message (as set by the element's setCustomValidity() method or

ElementInternals p717 p719 's setValidity() method) is not the empty string.

Note

An element can still suffer from these states even when the element is p571 disabled; thus these states can be represented in the

DOM even if validating the form during submission wouldn't indicate a problem to the user.

An element p591 satisfies its constraints if it is not suffering from any of the above validity states .



4.10.20.2 Constraint validation p59 §

2

When the user agent is required to p487 statically validate the constraints of form element form, it must run the following steps, which return either a positive result (all the controls in the form are valid) or a negative result (there are invalid controls) along with a (possibly empty) list of elements that are invalid and for which no script has claimed responsibility:

1. Let p487 p567 controls be a list of all the submittable elements whose form owner is form, in tree order.

2. Let invalid controls be an initially empty list of elements.

3. For each element field in controls, in tree order:

1. If p591 field is not a candidate for constraint validation, then move on to the next element.

2. Otherwise, if p592 field satisfies its constraints, then move on to the next element.

3. Otherwise, add field to invalid controls.

4. If invalid controls is empty, then return a positive result.

5. Let unhandled invalid controls be an initially empty list of elements.

6. For each element field in invalid controls, if any, in tree order:

1. Let p1271 notCanceled be the result of firing an event named invalid at field, with the cancelable attribute

initialized to true.

2. If notCanceled is true, then add field to unhandled invalid controls.

7. Return a negative result with the list of elements in the unhandled invalid controls list.

If a user agent is to p487 interactively validate the constraints of form element form, then the user agent must run the following steps:

1. p592 Statically validate the constraints of form, and let unhandled invalid controls be the list of elements returned if the result

was negative.

2. If the result was positive, then return that result.

592

3. Report the problems with the constraints of at least one of the elements given in unhandled invalid controls to the user.

◦ User agents may focus one of those elements in the process, by running the p779 focusing steps for that element,

and may change the scrolling position of the document, or perform some other action that brings the element to

the user's attention. For elements that are p706 form-associated custom elements, user agents should use their

validation anchor p719 instead, for the purposes of these actions.

◦ User agents may report more than one constraint violation.

◦ User agents may coalesce related constraint violation reports if appropriate (e.g. if multiple radio buttons in a

group p515 are marked as required, only one error need be reported).

◦ If one of the controls is not p1188 p768 being rendered (e.g. it has the hidden attribute set) then user agents may

report a script error.

4. Return a negative result.



✔ MDN

4.10.20.3 The constraint validation API §p59

3

For web developers (non-normative)

element p594 . willValidate

Returns true if the element will be validated when the form is submitted; false otherwise.

element p594 . setCustomValidity (message)

Sets a custom error, so that the element would fail to validate. The given message is the message to be shown to the user when reporting the problem to the user.

If the argument is the empty string, clears the custom error.

element p594 p595 . validity . valueMissing

Returns true if the element has no value but is a required field; false otherwise.

element p594 p595 . validity . typeMismatch

Returns true if the element's value is not in the correct syntax; false otherwise.

element p594 p595 . validity . patternMismatch

Returns true if the element's value doesn't match the provided pattern; false otherwise.

element p594 p595 . validity . tooLong

Returns true if the element's value is longer than the provided maximum length; false otherwise.

element p594 p595 . validity . tooShort

Returns true if the element's value, if it is not the empty string, is shorter than the provided minimum length; false otherwise.

element p594 p595 . validity . rangeUnderflow

Returns true if the element's value is lower than the provided minimum; false otherwise.

element p594 p595 . validity . rangeOverflow

Returns true if the element's value is higher than the provided maximum; false otherwise.

element p594 p595 . validity . stepMismatch

Returns true if the element's value doesn't fit the rules given by the p528 step attribute; false otherwise.

element p594 p595 . validity . badInput

Returns true if the user has provided input in the user interface that the user agent is unable to convert to a value; false otherwise.

element p594 p595 . validity . customError

Returns true if the element has a custom error; false otherwise.

element p594 p595 . validity . valid

Returns true if the element's value has no validity problems; false otherwise.

valid p595 = element . checkValidity ()

Returns true if the element's value has no validity problems; false otherwise. Fires an p1271 invalid event at the element in the latter case.

593

valid p596 = element . reportValidity()

Returns true if the element's value has no validity problems; otherwise, returns false, fires an p1271 invalid event at the element, and (if the event isn't canceled) reports the problem to the user.

element p596 . validationMessage

Returns the error message that would be shown to the user if the element was to be checked for validity.



The p591 willValidate attribute's getter must return true, if this element is a candidate for constraint validation, and false otherwise ✔ MDN

(i.e., false if any conditions are p591 barring it from constraint validation).

The p717 willValidate attribute of ElementInternals interface, on getting, must throw a "NotSupportedError" DOMException if the

target element p717 p706 p717 is not a form-associated custom element . Otherwise, it must return true if the target element is a candidate ✔ MDN

for constraint validation p591, and false otherwise.

The p591 setCustomValidity( message ) method, when invoked, must set the custom validity error message to message.

Example

In the following example, a script checks the value of a form control each time it is edited, and whenever it is not a valid value,

uses the p594 setCustomValidity() method to set an appropriate message.

Feeling:



The p594 p591 validity attribute's getter must return a ValidityState object that represents the validity states of this element. This ✔ MDN

object is p45 live.

The p717 validity attribute of ElementInternals interface, on getting, must throw a "NotSupportedError" DOMException if the target

element p717 p706 p594 is not a form-associated custom element . Otherwise, it must return a ValidityState object that represents the ✔MDN

validity states p591 p717 p45 of the target element . This object is live.

IDL [Exposed=Window]

interface ValidityState {

readonly attribute boolean valueMissing;

readonly attribute boolean typeMismatch;

readonly attribute boolean patternMismatch;

readonly attribute boolean tooLong;

readonly attribute boolean tooShort;

readonly attribute boolean rangeUnderflow;

readonly attribute boolean rangeOverflow;

readonly attribute boolean stepMismatch;

readonly attribute boolean badInput;

readonly attribute boolean customError;

readonly attribute boolean valid;

};

A p594 ValidityState object has the following attributes. On getting, they must return true if the corresponding condition given in the following list is true, and false otherwise.

594

valueMissing

The control is p591 suffering from being missing.

typeMismatch

The control is p591 suffering from a type mismatch.

patternMismatch

The control is p591 suffering from a pattern mismatch.

tooLong ✔ MDN

The control is p591 suffering from being too long.

tooShort ✔ MDN

The control is p591 suffering from being too short.

rangeUnderflow

The control is p591 suffering from an underflow .

rangeOverflow

The control is p592 suffering from an overflow.

stepMismatch

The control is p592 suffering from a step mismatch.

badInput ✔ MDN

The control is p592 suffering from bad input.

customError

The control is p592 suffering from a custom error.

valid

None of the other conditions are true.

The check validity steps for an element element are:

1. If p591 p592 element is a candidate for constraint validation and does not satisfy its constraints, then:

1. p1271 Fire an event named invalid at element, with the cancelable attribute initialized to true (though canceling

has no effect).

2. Return false.

2. Return true.

The p595 checkValidity() method, when invoked, must run the check validity steps on this element. ✔ MDN

The p717 checkValidity() method of the ElementInternals interface must run these steps:

1. Let p717 p717 element be this ElementInternals 's target element.

2. If p706 element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.

3. Run the p595 check validity steps on element.

The report validity steps for an element element are:

1. If p591 p592 element is a candidate for constraint validation and does not satisfy its constraints, then:

1. Let p1271 report be the result of firing an event named invalid at element, with the cancelable attribute initialized

to true.

2. If report is true, then report the problems with the constraints of this element to the user. When reporting the

problem with the constraints to the user, the user agent may run the p779 focusing steps for element, and may change the scrolling position of the document, or perform some other action that brings element to the user's attention. User agents may report more than one constraint violation, if element suffers from multiple problems at

595

once. If p1188 element is not being rendered, then the user agent may, instead of notifying the user, report the

error p924 p923 for the running script.

3. Return false.

2. Return true.

The p595 reportValidity() method, when invoked, must run the report validity steps on this element. ✔ MDN

The p717 reportValidity() method of the ElementInternals interface must run these steps:

1. Let p717 p717 element be this ElementInternals 's target element.

2. If p706 element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.

3. Run the p595 report validity steps on element.

The validationMessage attribute's getter must run these steps: ✔ MDN

1. If this element is not a p591 p592 candidate for constraint validation or if this element satisfies its constraints , then return the

empty string.

2. Return a suitably localized message that the user agent would show the user if this were the only form control with a validity

constraint problem. If the user agent would not actually show a textual message in such a situation (e.g., it would show a graphical cue instead), then return a suitably localized message that expresses (one or more of) the validity constraint(s)

that the control does not satisfy. If the element is a p591 candidate for constraint validation and is suffering from a custom

error p592 p591 , then the custom validity error message should be present in the return value.



4.10.20.4 Security p59 §

6

Servers should not rely on client-side validation. Client-side validation can be intentionally bypassed by hostile users, and unintentionally bypassed by users of older user agents or automated tools that do not implement these features. The constraint validation features are only intended to improve the user experience, not to provide any kind of security mechanism.



4.10.21 Form submission p59 §

6

4.10.21.1 Introduction p59 §

6

This section is non-normative.

When a form is submitted, the data in the form is converted into the structure specified by the p573 enctype , and then sent to the

destination specified by the p572 p572 action using the given method.

For example, take the following form:





If the user types in "cats" in the first field and "fur" in the second, and then hits the submit button, then the user agent will load /find.cgi?t=cats&q=fur.

On the other hand, consider this form:





596

Given the same user input, the result on submission is quite different: the user agent instead does an HTTP POST to the given URL, with as the entity body something like the following text:

------kYFrd4jNJEgCervE

Content-Disposition: form-data; name="t"

cats

------kYFrd4jNJEgCervE

Content-Disposition: form-data; name="q"

fur

------kYFrd4jNJEgCervE--



4.10.21.2 Implicit submission p59 §

7

A p487 p487 p567 p487 form element's default button is the first submit button in tree order whose form owner is that form element.

If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting the "enter" key while a text control is p774 p597 focused implicitly submits the form), then doing so for a form, whose default button has activation behavior and is not

disabled p571 p953 p597 , must cause the user agent to fire a click event at that default button .

Note

There are pages on the web that are only usable if there is a way to implicitly submit forms, so user agents are strongly

encouraged to support this.

If the form has no p487 submit button , then the implicit submission mechanism must do nothing if the form has more than one field that blocks implicit submission p597 p487 p487 , and must submit the form element from the form element itself otherwise.

For the purpose of the previous paragraph, an element is a p487 field that blocks implicit submission of a form element if it is an

input p494 p567 p487 p496 p500 element whose form owner is that form element and whose type attribute is in one of the following states: Text,

Search p500 p502 p501 p503 p504 p505 p506 p507 p508 p509 p510 , URL , Telephone , Email , Password , Date , Month , Week , Time , Local Date and Time , Number



4.10.21.3 Form submission algorithm p59 §

7

Each p487 form element has a constructing entry list boolean, initially false.

Each p487 form element has a firing submission events boolean, initially false.

When a p487 form element form is submitted from an element submitter (typically a button), optionally with a submitted from

submit() p491 method flag set, the user agent must run the following steps:

1. If p290 form cannot navigate , then return.

2. If p597 form 's constructing entry list is true, then return.

3. Let form document be form's node document.

4. If p848 p846 form document 's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.

5. Let p814 form browsing context be the browsing context of form document.

6. If the p491 submitted from submit() method flag is not set, then:

1. If p597 form 's firing submission events is true, then return.

2. Set p597 form 's firing submission events to true.

3. If the p573 p592 submitter element's no-validate state is false, then interactively validate the constraints of form and

examine the result. If the result is negative (i.e., the constraint validation concluded that there were invalid fields and probably informed the user of this), then:

1. Set p597 form 's firing submission events to false.

597

2. Return.

4. Let submitterButton be null if submitter is form. Otherwise, let submitterButton be submitter.

5. Let p1272 p604 continue be the result of firing an event named submit at form using SubmitEvent, with the

submitter p604 attribute initialized to submitterButton, the bubbles attribute initialized to true, and the cancelable attribute initialized to true.

6. Set p597 form 's firing submission events to false.

7. If continue is false, then return.

8. If p290 form cannot navigate , then return.

Note

Cannot navigate p290 p1272 is run again as dispatching the submit event could have changed the outcome.

7. Let p602 encoding be the result of picking an encoding for the form .

8. Let p600 entry list be the result of constructing the entry list with form, submitter, and encoding.

9. If p290 form cannot navigate , then return.

Note

Cannot navigate p290 p1271 p600 is run again as dispatching the formdata event in constructing the entry list could have changed the outcome.

10. Let p572 action be the submitter element's action .

11. If action is the empty string, let action be the URL of the form document.

12. p89 Parse the URL action, relative to the submitter element's node document. If this fails, return.

13. Let p89 parsed action be the resulting URL record.

14. Let scheme be the scheme of parsed action.

15. Let p573 enctype be the submitter element's enctype .

16. Let p572 method be the submitter element's method .

17. Let p573 p487 target be the submitter element's formtarget attribute value, if the element is a submit button and has such an

attribute. Otherwise, let it be the result of p157 p567 getting an element's target given submitter 's form owner.

18. Let p290 noopener be the result of getting an element's noopener with form and targetAttributeValue.

19. Let p823 target browsing context and windowType be the result of applying the rules for choosing a browsing context using

target, form browsing context, and noopener.

20. Let p876 historyHandling be " replace" if windowType is either "new and unrestricted" or "new with no opener"; otherwise

" p876 default ".

21. If target browsing context is null, then return.

22. If p894 p491 form document has not yet completely loaded and the submitted from submit() method flag is set, then set

historyHandling p876 to " replace".

23. If the value of p572 p600 method is dialog then jump to the submit dialog steps.

Otherwise, select the appropriate row in the table below based on the value of scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on the value of method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.

GET p572 p572 POST

http p599 p599 Mutate action URL Submit as entity body

https p599 p599 Mutate action URL Submit as entity body

ftp p599 p599 Get action URL Get action URL

javascript p599 p599 Get action URL Get action URL

598

GET p572 p572 POST

data p599 p599 Mutate action URL Get action URL

mailto p600 p600 Mail with headers Mail as body

If scheme is not one of those listed in this table, then the behavior is not defined by this specification. User agents should, in the absence of another specification defining this, act in a manner analogous to that defined in this specification for similar schemes.

Each p487 p932 p487 form element has a planned navigation , which is either null or a task ; when the form is first created, its

planned navigation p599 must be set to null. In the behaviors described below, when the user agent is required to plan to navigate to a particular resource destination, it must run the following steps:

1. If destination is not a request, then set destination to a new request whose URL is destination.

2. If the p487 p295 p305 form element's link types include the noreferrer keyword, then set destination's referrer to "no-

referrer".

3. If the p487 p599 p931 form has a non-null planned navigation , remove it from its task queue.

4. p933 p939 p487 Queue an element task on the DOM manipulation task source given the form element and the following

steps:

1. Set the p487 p599 form 's planned navigation to null.

2. p876 p876 Navigate target browsing context to destination , with historyHandling set to historyHandling and

navigationType p876 set to "form-submission".

5. Set the p487 p599 p932 form 's planned navigation to the just-queued task.

The behaviors are as follows:

Mutate action URL

Let query be the result of running the application/x-www-form-urlencoded serializer with entry list and encoding.

Set parsed action's query component to query.

Plan to navigate p599 to parsed action.

Submit as entity body

Switch on enctype:

↪ p573 application/x-www-form-urlencoded

Let body be the result of running the application/x-www-form-urlencoded serializer with entry list and encoding.

Set body to the result of encoding body.

Let MIME type be "application/x-www-form-urlencoded".

↪ p573 multipart/form-data

Let p603 body be the result of running the multipart/form-data encoding algorithm with entry list and encoding.

Let MIME type be the concatenation of the string "multipart/form-data;", a U+0020 SPACE character, the string

" p603 boundary= ", and the multipart/form-data boundary string generated by the multipart/form-data

encoding algorithm p603.

↪ p573 text/plain

Let p603 body be the result of running the text/plain encoding algorithm with entry list.

Set body to the result of encoding body using encoding.

Let MIME type be "text/plain".

Plan to navigate p599 to a new request whose url is parsed action, method is method, header list consists of `Content-

Type`/MIME type, and body is body.

Get action URL

Plan to navigate p599 to parsed action.

599

Note

entry list is discarded.

Mail with headers

Let headers be the result of running the application/x-www-form-urlencoded serializer with entry list and encoding.

Replace occurrences of U+002B PLUS SIGN characters (+) in headers with the string "%20".

Set parsed action's query to headers.

Plan to navigate p599 to parsed action.

Mail as body

Switch on enctype:

↪ p573 text/plain

Let p603 body be the result of running the text/plain encoding algorithm with entry list.

Set p1282 body to the result of running UTF-8 percent-encode on body using the default encode set . [URL]

↪ Otherwise

Let body be the result of running the application/x-www-form-urlencoded serializer with entry list and encoding.

If parsed action's query is null, then set it to the empty string.

If parsed action's query is not the empty string, then append a single U+0026 AMPERSAND character (&) to it.

Append "body=" to parsed action's query.

Append body to parsed action's query.

Plan to navigate p599 to parsed action.

Submit dialog

Let p611 subject be the nearest ancestor dialog element of form, if any.

If there isn't one, or if it does not have an p612 open attribute, do nothing. Otherwise, proceed as follows:

If p494 p496 p519 submitter is an input element whose type attribute is in the Image Button state, then let result be the string

formed by concatenating the p520 selected coordinate's x-component, expressed as a base-ten number using ASCII digits, a

U+002C COMMA character (,), and the p520 selected coordinate's y-component, expressed in the same way as the x-component.

Otherwise, if p567 p567 submitter has a value , then let result be that value .

Otherwise, there is no result.

Then, p613 close the dialog subject. If there is a result, let that be the return value.



4.10.21.4 Constructing the entry list p60 §

0

The algorithm to construct the entry list given a form, an optional submitter, and an optional encoding, is as follows. If not specified otherwise, submitter is null.

1. If p597 form 's constructing entry list is true, then return null.

2. Set p597 form 's constructing entry list to true.

3. Let p487 p567 controls be a list of all the submittable elements whose form owner is form, in tree order.

4. Let entry list be a new empty list of entries.

5. For each element field in controls, in tree order:

600

1. If any of the following is true:

▪ The p544 field element has a datalist element ancestor.

▪ The p571 field element is disabled .

▪ The p487 field element is a button but it is not submitter.

▪ The p494 p496 p514 field element is an input element whose type attribute is in the Checkbox state and

whose p567 checkedness is false.

▪ The p494 p496 p515 field element is an input element whose type attribute is in the Radio Button state and

whose p567 checkedness is false.

▪ The p373 p45 field element is an object element that is not using a plugin.

Then continue.

2. If the p494 p496 p519 field element is an input element whose type attribute is in the Image Button state, then:

1. If the p569 field element has a name attribute specified and its value is not the empty string, let name be

that value followed by a single U+002E FULL STOP character (.). Otherwise, let name be the empty string.

2. Let namex be the string consisting of the concatenation of name and a single U+0078 LATIN SMALL

LETTER X character (x).

3. Let namey be the string consisting of the concatenation of name and a single U+0079 LATIN SMALL

LETTER Y character (y).

4. The p520 field element is submitter , and before this algorithm was invoked the user indicated a coordinate.

Let x be the x-component of the coordinate selected by the user, and let y be the y-component of the coordinate selected by the user.

5. p602 Append an entry to entry list with namex and x.

6. p602 Append an entry to entry list with namey and y.

7. Continue.

3. If the p706 p720 field is a form-associated custom element , then perform the entry construction algorithm given field

and entry list, then continue.

4. If either the p569 p569 field element does not have a name attribute specified, or its name attribute's value is the empty

string, then continue.

5. Let p569 name be the value of the field element's name attribute.

6. If the p538 p546 p538 field element is a select element, then for each option element in the select element's list of

options p540 p548 p547 p602 whose selectedness is true and that is not disabled , append an entry to entry list with name

and the p547 p546 value of the option element.

7. Otherwise, if the p494 p496 p514 field element is an input element whose type attribute is in the Checkbox state or the

Radio Button p515 state, then:

1. If the p498 field element has a value attribute specified, then let value be the value of that attribute;

otherwise, let value be the string "on".

2. p602 Append an entry to entry list with name and value.

8. Otherwise, if the p494 p496 p516 field element is an input element whose type attribute is in the File Upload state, then:

1. If there are no p516 p602 selected files , then append an entry to entry list with name and a new File object

with an empty name, application/octet-stream as type, and an empty body.

2. Otherwise, for each file in p516 p602 selected files , append an entry to entry list with name and a File object

representing the file.

9. Otherwise, if the p373 p45 field element is an object element: try to obtain a form submission value from the plugin,

and if that is successful, p602 append an entry to entry list with name and the returned form submission value.

601

10. Otherwise, if the p494 p496 p500 field element is an input element whose type attribute is in the Hidden state and name

is an p569 ASCII case-insensitive match for " _charset_":

1. Let charset be the name of encoding if encoding is given, and "UTF-8" otherwise.

2. p602 Append an entry to entry list with name and charset.

11. Otherwise, if the p549 p602 field element is a textarea element, append an entry to entry list with name and the

value p567 of the field element, and the prevent line break normalization flag set.

Note

In the case of the p567 p549 value of textarea elements, the line break normalization is already performed during

the conversion of the control's p550 p567 raw value into the control's value (which also performs any necessary line wrapping).

12. Otherwise, p602 p567 append an entry to entry list with name and the value of the field element.

13. If the element has a p570 dirname attribute, and that attribute's value is not the empty string, then:

1. Let p570 dirname be the value of the element's dirname attribute.

2. Let p143 p143 dir be the string " ltr " if the directionality of the element is ' ltr', and "rtl" otherwise (i.e.,

when p143 p143 the directionality of the element is ' rtl ').

3. p602 Append an entry to entry list with dirname and dir.

Note

An element can only have a p570 p549 p494 dirname attribute if it is a textarea element or an input element whose

type p496 p500 p500 attribute is in either the Text state or the Search state.

6. Let form data be a new FormData object associated with entry list.

7. p1271 p604 p604 Fire an event named formdata at form using FormDataEvent , with the formData attribute initialized to form data

and the bubbles attribute initialized to true.

8. Set p597 form 's constructing entry list to false.

9. Return a clone of entry list.

To append an entry to entry list, given name, value, and optional prevent line break normalization flag, run these steps:

1. For name, replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF) not

preceded by U+000D (CR), by a string consisting of a U+000D (CR) and U+000A (LF).

2. Replace name with the result of converting to a sequence of Unicode scalar values.

3. If value is not a File object, then:

1. If the prevent line break normalization flag is unset, then replace every occurrence of U+000D (CR) not followed by

U+000A (LF), and every occurrence of U+000A (LF) not preceded by U+000D (CR) in value, by a string consisting of a U+000D (CR) and U+000A (LF).

2. Replace value with the result of converting to a sequence of Unicode scalar values.

4. Create an entry with name and value, and append it to entry list.



4.10.21.5 Selecting a form submission encoding p60 §

2

If the user agent is to pick an encoding for a form, it must run the following steps:

1. Let encoding be the document's character encoding.

2. If the p487 p488 form element has an accept-charset attribute, set encoding to the return value of running these substeps:

1. Let p487 p488 input be the value of the form element's accept-charset attribute.

602

2. Let candidate encoding labels be the result of splitting input on ASCII whitespace.

3. Let candidate encodings be an empty list of character encodings.

4. For each token in candidate encoding labels in turn (in the order in which they were found in input), get an

encoding for the token and, if this does not result in failure, append the encoding to candidate encodings.

5. If candidate encodings is empty, return UTF-8.

6. Return the first encoding in candidate encodings.

3. Return the result of getting an output encoding from encoding.



4.10.21.6 URL-encoded form data p60 §

3

See p1282 URL for details on application/x-www-form-urlencoded . [URL]



4.10.21.7 Multipart form data p60 §

3

The multipart/form-data encoding algorithm, given an entry list and encoding, is as follows:

1. Return the byte sequence resulting from encoding the entry list using the rules described by RFC 7578, Returning Values

from Forms: p1281 multipart/form-data , given the following conditions: [RFC7578]

◦ Each entry in entry list is a field, the name of the entry is the field name and the value of the entry is the field

value.

◦ The order of parts must be the same as the order of fields in entry list. Multiple entries with the same name must

be treated as distinct fields.

◦ Field names, field values for non-file fields, and file names for file fields, in the generated multipart/form-

data p1273 resource must be set to the result of encoding the corresponding entry's name or value with encoding, converted to a byte sequence. In the case of file names, however, the precise name may be approximated if necessary (e.g., newlines could be removed from file names, quotes could be changed to "%22", and characters not expressible in encoding could be replaced by other characters before encoding).

◦ The parts of the generated p1273 multipart/form-data resource that correspond to non-file fields must not have a

` p90 Content-Type` header specified.

◦ The boundary used by the user agent in generating the return value of this algorithm is the multipart/form-data

boundary string. (This value is used to generate the MIME type of the form submission payload generated by this algorithm.) For details on how to interpret p1273 p1281 multipart/form-data payloads, see RFC 7578. [RFC7578]



4.10.21.8 Plain text form data p60 §

3

The text/plain encoding algorithm, given an entry list, is as follows:

1. Let result be the empty string.

2. For each entry in entry list:

1. If the entry's value is a File object, then set its value to the File object's name.

2. Append the entry's name to result.

3. Append a single U+003D EQUALS SIGN character (=) to result.

4. Append the entry's value to result.

5. Append a U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) character pair to result.

603

3. Return result.

Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value).



4.10.21.9 The p604 MDN p60 SubmitEvent interface §

4

IDL MDN [ Exposed = Window ]

interface SubmitEvent : Event {

constructor(DOMString type, optional SubmitEventInit eventInitDict = {});

readonly attribute HTMLElement? submitter;

};

dictionary SubmitEventInit : EventInit {

HTMLElement? submitter = null;

};



For web developers (non-normative)

event p604 . submitter

Returns the element representing the p487 p596 submit button that triggered the form submission, or null if the submission was not triggered by a button.



The submitter attribute must return the value it was initialized to. MDN



4.10.21.10 The p604 MDN p60 FormDataEvent interface §

4

IDL [Exposed=Window]

interface FormDataEvent : Event {

constructor(DOMString type, FormDataEventInit eventInitDict);

readonly attribute FormData formData;

};

dictionary FormDataEventInit : EventInit {

required FormData formData;

};



For web developers (non-normative)

event p604 . formData

Returns a p487 FormData object representing names and values of elements associated to the target form . Operations on the

FormData object will affect form data to be submitted.



The formData attribute must return the value it was initialized to. It represents a FormData object associated to the entry list that is MDN

constructed p600 p487 when the form is submitted.



4.10.22 Resetting a form p60 §

4

When a p487 form element form is reset, run these steps:

1. Let p1272 reset be the result of firing an event named reset at form, with the bubbles and cancelable attributes initialized to

true.

2. If p605 p487 p567 reset is true, then invoke the reset algorithm of each resettable element whose form owner is form.

604

Each p487 resettable element defines its own reset algorithm. Changes made to form controls as part of these algorithms do not count as changes caused by the user (and thus, e.g., do not cause p1271 input events to fire).



4.11 Interactive elements p60 §

5 ✔ MDN

4.11.1 The details element p60 §

5

Categories p129: ✔ MDN

Flow content p132 .

Sectioning root p200 .

Interactive content p133.

Palpable content p134.

Contexts in which this element can be used p129 :

Where p132 flow content is expected.

Content model p129:

One p608 p132 summary element followed by flow content.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

open p605 — Whether the details are visible

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLDetailsElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean open;

};



The p605 p124 details element represents a disclosure widget from which the user can obtain additional information or controls.

Note

The p605 p724 details element is not appropriate for footnotes. Please see the section on footnotes for details on how to mark up

footnotes.

The first p608 p124 summary element child of the element, if any, represents the summary or legend of the details. If there is no child

summary p608 element, the user agent should provide its own legend (e.g. "Details").

The rest of the element's contents p124 represents the additional information or controls.

The p67 open content attribute is a boolean attribute. If present, it indicates that both the summary and the additional information is to be shown to the user. If the attribute is absent, only the summary is to be shown.

When the element is created, if the attribute is absent, the additional information should be hidden; if the attribute is present, that information should be shown. Subsequently, if the attribute is removed, then the information should be hidden; if the attribute is added, the information should be shown.

The user agent should allow the user to request that the additional information be shown or hidden. To honor a request for the details to be shown, the user agent must p605 set the open attribute on the element to the empty string. To honor a request for the information to be hidden, the user agent must p605 remove the open attribute from the element.

605

Note

This ability to request that additional information be shown or hidden may simply be the activation behavior of the appropriate

summary p608 element, in the case such an element exists. However, if no such element exists, user agents can still provide this

ability through some other user interface affordance.

Whenever the p605 p605 p933 open attribute is added to or removed from a details element, the user agent must queue an element task

on the p939 p605 DOM manipulation task source given then details element that runs the following steps, which are known as the details notification task steps p605 , for this details element:

1. If another p932 p933 p606 p605 task has been queued to run the details notification task steps for this details element, then return.

Note

When the p605 open attribute is toggled several times in succession, these steps essentially get coalesced so that only one event is fired.

2. p1272 p605 Fire an event named toggle at the details element.

The p95 p605 open IDL attribute must reflect the open content attribute.

Example

The following example shows the p605 details element being used to hide technical details in a progress report.





Copying "Really Achieving Your Childhood Dreams"





Copying... 25%



Transfer rate:

452KB/s





Local filename:

/home/rpausch/raycd.m4v





Remote filename:

/var/www/lectures/raycd.m4v

Duration:

01:16:27





Color profile:

SD (6-1-6)





Dimensions:

320×240





Example

The following shows how a p605 details element can be used to hide some controls by default:





Name & Extension:





Hide extension





One could use this in conjunction with other p605 details in a list to allow the user to collapse a set of fields down to a small set of

headings, with the ability to open each one.



606



In these examples, the summary really just summarizes what the controls can change, and not the actual values, which is less than



ideal.



Example

Because the p605 open attribute is added and removed automatically as the user interacts with the control, it can be used in CSS to

style the element differently based on its state. Here, a style sheet is used to animate the color of the summary when the element

is opened or closed:





Automated Status: Operational



Velocity: 12m/s



607



Direction: North





4.11.2 The summary element §

p60 ✔ MDN

8

Categories p129:

None.

Contexts in which this element can be used p129 :

As the p605 first child of a details element.

Content model p129:

Phrasing content p133 p133 , optionally intermixed with heading content.

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

Uses p125 HTMLElement .

The p608 p124 p608 summary element represents a summary, caption, or legend for the rest of the contents of the summary element's parent

details p605 element, if any.

A p608 summary element is a summary for its parent details if the following algorithm returns true:

1. If this p608 summary element has no parent, then return false.

2. Let p608 parent be this summary element's parent.

3. If p605 parent is not a details element, then return false.

4. If p608 p608 parent 's first summary element child is not this summary element, then return false.

5. Return true.

The p608 activation behavior of summary elements is to run the following steps:

1. If this p608 p608 summary element is not the summary for its parent details, then return.

2. Let p608 parent be this summary element's parent.

3. If the p605 p605 open attribute is present on parent , then remove it. Otherwise, set parent 's open attribute to the empty string.

Note

This will then run the p606 details notification task steps .



4.11.3 Commands p60 §

8

4.11.3.1 Facets p60 §

8

A command is the abstraction behind menu items, buttons, and links. Once a command is defined, other parts of the interface can refer to the same command, allowing many access points to a single feature to share facets such as the p609 Disabled State .

608

Commands are defined to have the following facets:

Label

The name of the command as seen by the user.

Access Key

A key combination selected by the user agent that triggers the command. A command might not have an Access Key.

Hidden State

Whether the command is hidden or not (basically, whether it should be shown in menus).

Disabled State

Whether the command is relevant and can be triggered or not.

Action

The actual effect that triggering the command will have. This could be a scripted event handler, a p876 URL to which to navigate , or a form submission.

User agents may expose the p608 commands that match the following criteria:

• The p609 Hidden State facet is false (visible)

• The element is p814 in a document with a non-null browsing context.

• Neither the element nor any of its ancestors has a p768 hidden attribute specified.

User agents are encouraged to do this especially for commands that have p609 Access Keys, as a way to advertise those keys to the user.

Example

For example, such commands could be listed in the user agent's menu bar.



4.11.3.2 Using the a element to define a command p60 §

9

An p239 p285 p608 a element with an href attribute defines a command.

The p609 Label of the command is the element's descendant text content.

The p609 p789 Access Key of the command is the element's assigned access key, if any.

The p609 p768 Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The p609 p769 Disabled State facet of the command is true if the element or one of its ancestors is inert , and false otherwise.

The p609 p953 Action of the command is to fire a click event at the element.



4.11.3.3 Using the button element to define a command p60 §

9

A p536 p608 button element always defines a command.

The p609 p609 p609 p609 p609 Label , Access Key , Hidden State , and Action facets of the command are determined as for a elements (see the previous section).

The p609 p769 p571 Disabled State of the command is true if the element or one of its ancestors is inert , or if the element's disabled state is set, and false otherwise.



4.11.3.4 Using the input element to define a command p60 §

9

An p494 p496 p519 p521 p519 p522 input element whose type attribute is in one of the Submit Button , Reset Button , Image Button , Button , Radio

Button p515 p514 p608 , or Checkbox states defines a command.

The p609 Label of the command is determined as follows:

609

• If the p496 p519 p521 p519 p522 type attribute is in one of the Submit Button , Reset Button , Image Button , or Button states, then the

Label p609 p498 is the string given by the value attribute, if any, and a UA-dependent, locale-dependent value that the UA uses to label the button itself if the attribute is absent.

• Otherwise, if the element is a p492 p609 p491 labeled control , then the Label is the descendant text content of the first label

element in p492 tree order whose labeled control is the element in question. (In JavaScript terms, this is given by element.labels[0].textContent.)

• Otherwise, if the p498 p609 value attribute is present, then the Label is the value of that attribute.

• Otherwise, the p609 Label is the empty string.

Note

Even though the p498 p494 p519 value attribute on input elements in the Image Button state is non-conformant, the attribute can still

contribute to the p609 p520 Label determination, if it is present and the Image Button's alt attribute is missing.

The p609 p789 Access Key of the command is the element's assigned access key, if any.

The p609 p768 Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The p609 p769 p571 Disabled State of the command is true if the element or one of its ancestors is inert , or if the element's disabled state is set, and false otherwise.

The p609 p953 Action of the command is to fire a click event at the element.



4.11.3.5 Using the option element to define a command p61 §

0

An p546 p538 p547 p547 option element with an ancestor select element and either no value attribute or a value attribute that is not the empty string p608 defines a command .

The p609 p546 p547 p546 Label of the command is the value of the option element's label attribute, if there is one, or else the option

element's descendant text content, with ASCII whitespace stripped and collapsed.

The p609 p789 Access Key of the command is the element's assigned access key, if any.

The p609 p768 Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The p609 p547 p538 Disabled State of the command is true if the element is disabled , or if its nearest ancestor select element is

disabled p571 p769 , or if it or one of its ancestors is inert , and false otherwise.

If the p546 p538 p540 p609 p541 option 's nearest ancestor select element has a multiple attribute, the Action of the command is to toggle the

option p546 p609 p540 p546 element. Otherwise, the Action is to pick the option element.



4.11.3.6 Using the accesskey attribute on a legend element to define a command p61 §

0

A p566 p608 legend element defines a command if all of the following are true:

• It has an p789 assigned access key .

• It is a child of a p563 fieldset element.

• Its parent has a descendant that p608 p491 p566 defines a command that is neither a label element nor a legend element. This

element, if it exists, is the legend element's accesskey delegatee.

The p609 Label of the command is the element's descendant text content.

The p609 p789 Access Key of the command is the element's assigned access key.

The p609 p609 p609 Hidden State , Disabled State , and Action facets of the command are the same as the respective facets of the legend

element's p610 accesskey delegatee.

610

Example

In this example, the p566 p788 p494 legend element specifies an accesskey , which, when activated, will delegate to the input element

inside the p566 legend element.





I want

pizza(s) with these toppings



Cheese Ham Pineapple





4.11.3.7 Using the accesskey attribute to define a command on other elements p61 §

1

An element that has an p789 p608 assigned access key defines a command .

If one of the earlier sections that define elements that p608 p608 define commands define that this element defines a command, then that section applies to this element, and this section does not. Otherwise, this section applies to that element.

The p609 p492 Label of the command depends on the element. If the element is a labeled control, the descendant text content of the first

label p491 p492 p609 element in tree order whose labeled control is the element in question is the Label (in JavaScript terms, this is given by element p609 .labels[0].textContent ). Otherwise, the Label is the element's descendant text content.

The p609 p789 Access Key of the command is the element's assigned access key.

The p609 p768 Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.

The p609 p769 Disabled State of the command is true if the element or one of its ancestors is inert , and false otherwise.

The p609 Action of the command is to run the following steps:

1. Run the p779 focusing steps for the element.

2. p953 Fire a click event at the element.



MDN

4.11.4 The dialog element p61 §

1

Categories p129: MDN

Flow content p132 .

Sectioning root p200 .

Contexts in which this element can be used p129 :

Where p132 flow content is expected.

Content model p129:

Flow content p132 .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

open p612 — Whether the dialog box is showing

Accessibility considerations p130:

For authors.

For implementers.

611

DOM interface p130:

IDL [Exposed=Window]

interface HTMLDialogElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean open;

attribute DOMString returnValue;

[CEReactions] undefined show();

[CEReactions] undefined showModal();

[CEReactions] undefined close(optional DOMString returnValue);

};



The p611 dialog element represents a part of an application that a user interacts with to perform a task, for example a dialog box, inspector, or window.

The p67 p611 open attribute is a boolean attribute . When specified, it indicates that the dialog element is active and that the user can interact with it.

A p611 p612 dialog element without an open attribute specified should not be shown to the user. This requirement may be implemented indirectly through the style layer. For example, user agents that p47 support the suggested default rendering implement this requirement using the CSS rules described in the p1188 rendering section.

Note

Removing the p612 open attribute will usually hide the dialog. However, doing so has a number of strange additional consequences:

• The p1271 close event will not be fired.

• The p613 p614 close() method, and any user-agent provided cancelation interface, will no longer be able to close the dialog.

• If the dialog was shown using its p612 p115 p769 showModal() method, the Document will still be blocked.

For these reasons, it is generally better to never remove the p612 p613 open attribute manually. Instead, use the close() method to

close the dialog, or the p768 hidden attribute to hide it.

The p776 p611 tabindex attribute must not be specified on dialog elements.

For web developers (non-normative)

dialog p612 . show()

Displays the p611 dialog element.

dialog p612 . showModal()

Displays the p611 dialog element and makes it the top-most modal dialog.

This method honors the p785 autofocus attribute.

dialog p613 . close( [ result ] )

Closes the p611 dialog element.

The argument, if provided, provides a return value.

dialog p614 . returnValue [ = result ]

Returns the p611 dialog's return value.

Can be set, to update the return value.



When the show() method is invoked, the user agent must run the following steps: MDN

1. If the element already has an p612 open attribute, then return.

2. Add an p612 p611 open attribute to the dialog element, whose value is the empty string.

3. Run the p613 p611 dialog focusing steps for the dialog element.

When the showModal() method is invoked, the user agent must run the following steps: MDN

612

1. Let p611 subject be the dialog element on which the method was invoked.

2. If p612 subject already has an open attribute, then throw an "InvalidStateError" DOMException.

3. If subject is not connected, then throw an "InvalidStateError" DOMException.

4. Add an p612 open attribute to subject, whose value is the empty string.

5. Set the p614 is modal flag of subject to true.

6. Let p769 subject 's node document be blocked by the modal dialog subject.

Note

This will cause the p774 p769 focused area of the document to become inert (unless that currently focused area is a shadow-

including descendant p780 of subject ). In such cases, the focus fixup rule will kick in and reset the focused area of the

document p774 to the viewport for now. In a couple steps we will attempt to find a better candidate to focus.

7. If subject's node document's top layer does not already contain subject, then add subject to subject's node document's top

layer.

8. Run the p613 dialog focusing steps for subject.

The p611 dialog focusing steps for a dialog element subject are as follows:

1. If p769 subject is inert , return.

2. Let p769 p785 control be the first descendant element of subject , in tree order , that is not inert and has the autofocus attribute

specified.

If there isn't one, then let p769 control be the first non-inert descendant element of subject, in tree order.

If there isn't one of those either, then let control be subject.

3. Run the p779 focusing steps for control.

Note

If p775 p613 control is not focusable , this will do nothing. For modal dialogs, this means that any earlier modifications to the

focused area of the document p774 will apply.

4. Let p814 p814 topDocument be the active document of control 's node document 's browsing context 's top-level browsing

context p817 .

5. If p841 p842 p841 control 's node document 's origin is not the same as the origin of topDocument, then return.

6. p785 Empty topDocument 's autofocus candidates .

7. Set p785 topDocument 's autofocus processed flag to true.

If at any time a p611 p44 p611 p115 dialog element is removed from a Document , then if that dialog is in that Document's top layer, it must be MDN

removed from it.

When the p613 close() method is invoked, the user agent must close the dialog that the method was invoked on. If the method was invoked with an argument, that argument must be used as the return value; otherwise, there is no return value.

When a p611 dialog element subject is to be closed, optionally with a return value result, the user agent must run the following steps:

1. If p612 subject does not have an open attribute, then return.

2. Remove p612 subject 's open attribute.

3. Set the p614 is modal flag of subject to false.

4. If the argument p614 result was provided, then set the returnValue attribute to the value of result.

5. If p115 subject is in its Document's top layer, then remove it.

6. p933 p939 Queue an element task on the user interaction task source given the subject element to fire an event named

close p1271 at subject.

MDN 613

The returnValue IDL attribute, on getting, must return the last value to which it was set. On setting, it must be set to the new value. When the element is created, it must be set to the empty string.



Canceling dialogs p115 p769 : When Document is blocked by a modal dialog dialog, user agents may provide a user interface that, upon activation, p933 p939 queues an element task on the user interaction task source given the dialog element to run these steps:

1. Let p1271 close be the result of firing an event named cancel at dialog, with the cancelable attribute initialized to true.

2. If p612 p613 close is true and dialog has an open attribute, then close the dialog with no return value.

Note

An example of such a UI mechanism would be the user pressing the "Escape" key.



Each p611 p611 dialog element has an is modal flag. When a dialog element is created, this flag must be set to false.



The p95 p612 open IDL attribute must reflect the open content attribute. MDN

Example

This dialog box has some small print. The p243 strong element is used to draw the user's attention to the more important part.





Add to Wallet





How many gold coins do you want to add to your

wallet?





You add coins at your own risk.





Only add perfectly round coins





4.12 Scripting p61 §

4

Scripts allow authors to add interactivity to their documents.

Authors are encouraged to use declarative alternatives to scripting where possible, as declarative mechanisms are often more maintainable, and many users disable scripting.

Example

For example, instead of using script to show or hide a section to show more details, the p605 details element could be used.

Authors are also encouraged to make their applications degrade gracefully in the absence of scripting support.

Example

For example, if an author provides a link in a table header to dynamically resort the table, the link could also be made to function

without scripts by requesting the sorted table from the server.



✔ MDN

4.12.1 The script element p61 §

4

Categories p129: ✔ MDN

Metadata content p132.

Flow content p132 .

614

Phrasing content p133.

Script-supporting element p134 .

Contexts in which this element can be used p129 :

Where p132 metadata content is expected.

Where p133 phrasing content is expected.

Where p134 script-supporting elements are expected.

Content model p129:

If there is no p616 p615 p625 src attribute, depends on the value of the type attribute, but must match script content restrictions .

If there p616 p627 is a src attribute, the element must be either empty or contain only script documentation that also matches

script content restrictions p625 .

Tag omission in text/html p129 :

Neither tag is omissible.

Content attributes p129:

Global attributes p137

src p616 — Address of the resource

type p615 — Type of script

nomodule p616 p912 — Prevents execution in user agents that support module scripts

async p616 — Execute script when available, without blocking while fetching

defer p616 — Defer script execution

crossorigin p617 — How the element handles crossorigin requests

integrity p617 p1281 — Integrity metadata used in Subresource Integrity checks [SRI]

referrerpolicy p617 — Referrer policy for fetches initiated by the element

Accessibility considerations p130:

For authors.

For implementers.

DOM interface p130:

IDL [Exposed=Window]

interface HTMLScriptElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString type;

[CEReactions] attribute boolean noModule;

[CEReactions] attribute boolean async;

[CEReactions] attribute boolean defer;

[CEReactions] attribute DOMString? crossOrigin;

[CEReactions] attribute DOMString text;

[CEReactions] attribute DOMString integrity;

[CEReactions] attribute DOMString referrerPolicy;

// also has obsolete members

};



The p614 script element allows authors to include dynamic script and data blocks in their documents. The element does not ✔ MDN

represent p124 content for the user.

The type attribute allows customization of the type of script represented:

• Omitting the attribute, setting it to the empty string, or setting it to a JavaScript MIME type essence match, means that the

script is a p912 classic script, to be interpreted according to the JavaScript Script top-level production. Classic scripts are

affected by the p616 p616 p616 p615 async and defer attributes, but only when the src attribute is set. Authors should omit the type

attribute instead of redundantly setting it.

• Setting the attribute to an p912 ASCII case-insensitive match for the string " module " means that the script is a module script ,

to be interpreted according to the JavaScript p616 Module top-level production. Module scripts are not affected by the defer

attribute, but are affected by the p616 p616 async attribute (regardless of the state of the src attribute).

615

• Setting the attribute to any other value means that the script is a p614 data block , which is not processed. None of the script

attributes (except p615 type itself) have any effect on data blocks. Authors must use a valid MIME type string that is not a

JavaScript MIME type essence match to denote data blocks.

Note

The requirement that p616 data blocks must be denoted using a valid MIME type string is in place to avoid potential future collisions.

If this specification ever adds additional types of p912 p615 script , they will be triggered by setting the type attribute to something

which is not a MIME type, like how the " p912 module " value denotes module scripts . By using a valid MIME type string now, you

ensure that your data block will not ever be reinterpreted as a different script type, even in future user agents.

Classic scripts p912 p912 and module scripts can be embedded inline, or be imported from an external file using the src attribute, which if specified gives the p616 URL of the external script resource to use. If src is specified, it must be a valid non-empty URL potentially

surrounded by spaces p88 p614 . The contents of inline script elements, or the external script resource, must conform with the requirements of the JavaScript specification's p912 p912 Script or Module productions, for classic scripts and module scripts respectively.

[JAVASCRIPT] p1278

When used to include p616 p615 data blocks , the data must be embedded inline, the format of the data must be given using the type

attribute, and the contents of the p614 p616 script element must conform to the requirements defined for the format used. The src,

async p616 p616 p616 p617 p617 p617 , nomodule , defer , crossorigin , integrity , and referrerpolicy attributes must not be specified.

The p67 nomodule attribute is a boolean attribute that prevents a script from being executed in user agents that support module

scripts p912 p912 p912 . This allows selective execution of module scripts in modern user agents and classic scripts in older user agents, as ✔ MDN

shown below p619 p616 p912 . The nomodule attribute must not be specified on module scripts (and will be ignored if it is).

The p67 p912 async and defer attributes are boolean attributes that indicate how the script should be evaluated. Classic scripts may specify p616 p616 p616 p912 defer or async , but must not specify either unless the src attribute is present. Module scripts may specify the

async p616 p616 attribute, but must not specify the defer attribute.

There are several possible modes that can be selected using these attributes, and depending on the script's type.

For p912 p616 p42 classic scripts , if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes). If the p616 p616 async attribute is not present but the defer attribute is present, then the classic script will be fetched p42 in parallel and evaluated when the page has finished parsing. If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.

For p912 p616 p42 module scripts , if the async attribute is present, then the module script and all its dependencies will be fetched in parallel to parsing, and the module script will be evaluated as soon as it is available (potentially before parsing completes). Otherwise, the module script and its dependencies will be fetched p42 in parallel to parsing and evaluated when the page has finished parsing. (The

defer p616 attribute has no effect on module scripts.) This is all summarized in the following schematic diagram:



<script> Scripting:

HTML Parser:

<script defer> Scripting:

HTML Parser:

<script async> Scripting:

HTML Parser:

<script type="module"> Scripting:

HTML Parser:

<script type="module" async> Scripting:

HTML Parser:

parser fetch execution runtime →



Note

The exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of

aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The

algorithms below (in this section) describe the core of this processing, but these algorithms reference and are referenced by the

parsing rules for p614 p1132 p1145 p1160 p1185 script start and end tags in HTML, in foreign content , and in XML, the rules for the

document.write() p958 p900 method, the handling of scripting, etc.

616

The p616 p616 defer attribute may be specified even if the async attribute is specified, to cause legacy web browsers that only support

defer p616 p616 p616 (and not async ) to fall back to the defer behavior instead of the blocking behavior that is the default.

The p91 p912 crossorigin attribute is a CORS settings attribute . For classic scripts , it controls whether error information will be exposed, when the script is obtained from other p841 p912 origins . For module scripts , it controls the credentials mode used for cross-origin requests.

Note

Unlike p912 p912 classic scripts , module scripts require the use of the CORS protocol for cross-origin fetching.

The integrity attribute represents the integrity metadata for requests which this element is responsible for. The value is text. The

integrity p617 p616 p1281 attribute must not be specified when the src attribute is not specified. [SRI]

The p92 referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when fetching the script, as well as any scripts imported from it. p1280 [REFERRERPOLICY]

Example

An example of a p614 script element's referrer policy being used when fetching imported scripts but not other subresources:





Changing the p616 p615 p616 p616 p616 p617 p617 p617 src , type , nomodule , async , defer , crossorigin , integrity , and referrerpolicy attributes dynamically has no direct effect; these attributes are only used at specific times described below.

✔ MDN

The IDL attributes p95 src , type , defer , and integrity , must each reflect the respective content attributes of the same name.

The p95 p617 p95 referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.

The p95 p617 p95 crossOrigin IDL attribute must reflect the crossorigin content attribute, limited to only known values.

The p95 p616 noModule IDL attribute must reflect the nomodule content attribute.

The p620 async IDL attribute controls whether the element will execute asynchronously or not. If the element's "non-blocking" flag is set, then, on getting, the p617 p620 async IDL attribute must return true, and on setting, the "non-blocking" flag must first be unset, and then the content attribute must be removed if the IDL attribute's new value is false, and must be set to the empty string if the IDL

attribute's new value is true. If the element's p620 p95 p616 "non-blocking" flag is not set, the IDL attribute must reflect the async content attribute.

For web developers (non-normative)

script p617 . text [ = value ]

Returns the child text content of the element.

Can be set, to replace the element's children with the given value.

The p614 text attribute's getter must return this script element's child text content.

The p617 p614 text attribute's setter must string replace all with the given value within this script element.

Note

When inserted using the p958 p614 p1133 document.write() method, script elements usually execute (typically blocking further script

execution or HTML parsing). When inserted using the innerHTML and outerHTML attributes, they do not execute at all.



Example

In this example, two p614 p912 script elements are used. One embeds an external classic script, and the other includes some data as

a p616 data block.



617





The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way,

though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the

site's search engine to help users who are looking for particular features in their game maps.



Example

The following sample shows how a p614 script element can be used to define a function that is then used by other parts of the

document, as part of a p912 p614 classic script . It also shows how a script element can be used to invoke script while the document is

being parsed, in this case to initialize the form's output.





Work out the price of your car



Base cost: £52000.





Select additional options:





Ceramic brakes (£1000)

Satellite radio (£2500)

Turbo charger (£5000)

"XZ" sticker (£250)





Total: £





Example

The following sample shows how a p614 p912 script element can be used to include an external module script .



This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once

the entire resulting module graph has been imported, and the document has finished parsing, the contents of app.mjs will be

evaluated.



618

Additionally, if code from another p614 p828 script element in the same Window imports the module from app.mjs (e.g. via import

"./app.mjs"; p912 p614 ), then the same module script created by the former script element will be imported.



Example

This example shows how to include a p912 p912 module script for modern user agents, and a classic script for older user agents:





In modern user agents that support p912 p614 p616 module scripts , the script element with the nomodule attribute will be ignored, and

the p614 p615 p912 script element with a type of " module " will be fetched and evaluated (as a module script ). Conversely, older user

agents will ignore the p614 p615 script element with a type of "module", as that is an unknown script type for them — but they will

have no problem fetching and evaluating the other p614 p912 script element (as a classic script), since they do not implement the

nomodule p616 attribute.



Example

The following sample shows how a p614 p912 script element can be used to write an inline module script that performs a number of

substitutions on the document's text, in order to make for a more interesting reading experience (e.g. on a news site):

[XKCD1288] p1283



Some notable features gained by using a module script include the ability to import functions from other JavaScript modules, strict

mode by default, and how top-level declarations do not introduce new properties onto the p905 global object. Also note that no

matter where this p614 script element appears in the document, it will not be evaluated until both document parsing has complete

and its dependency (dom-utils.mjs) has been fetched and evaluated.



619

4.12.1.1 Processing model p62 §

0

A p614 script element has several associated pieces of state.

A p614 p614 script element has a flag indicating whether or not it has been "already started" . Initially, script elements must have this flag unset (script blocks, when created, are not "already started"). The p614 cloning steps for script elements must set the "already started" flag on the copy if it is set on the element being cloned.

A p614 p115 script element has a parser document , which is either null or a Document . Initially, its value must be null. It is set by the

HTML parser p1076 p1184 p614 p614 and the XML parser on script elements they insert, and affects the processing of those elements. script

elements with non-null p620 parser documents are known as "parser-inserted".

A p614 p614 script element has a flag indicating whether the element will be "non-blocking" . Initially, script elements must have this flag set. It is unset by the p1076 p1184 p614 HTML parser and the XML parser on script elements they insert. In addition, whenever a

script p614 p620 p616 p620 element whose "non-blocking" flag is set has an async content attribute added, the element's "non-blocking" flag must be unset.

A p614 p614 script element has a flag indicating whether or not the script block is "ready to be parser-executed" . Initially, script

elements must have this flag unset (script blocks, when created, are not "ready to be parser-executed"). This flag is used only for elements that are also p620 "parser-inserted" , to let the parser know when to execute the script.

The script's type p614 p620 for a script element is either " classic " or " module ". It is determined when the script is prepared, based on the p615 type attribute of the element at that time.

A p614 p115 script element has a preparation-time document , which is a Document determined near the beginning of the prepare a

script p620 p620 p624 algorithm. It is used to prevent scripts that move between documents during preparation from executing .

A p614 script element has a flag indicating whether or not the script is from an external file. It is determined when the script is

prepared p620 p616 , based on the src attribute of the element at that time.

The script's script p614 p912 p620 for a script element is either null or a script resulting from preparing the element. This is set asynchronously after the classic script or module graph is fetched. Once it is set, either to a p912 script in the case of success or to null in the case of failure, the fetching algorithms will note that the script is ready, which can trigger other actions. The user agent must

delay the load event p1162 p620 of the element's node document until the script is ready .



When a p614 p620 script element that is not "parser-inserted" experiences one of the events listed in the following list, the user agent must p42 p620 p614 immediately prepare the script element:

• The p614 p45 script element becomes connected.

• The p614 p44 p614 script element is connected and a node or document fragment is inserted into the script element, after any

script p614 p44 elements inserted at that time.

• The p614 p616 script element is connected and has a src attribute set where previously the element had no such attribute.

To prepare a script, the user agent must act as follows:

1. If the p614 p620 script element is marked as having "already started" , then return. The script is not executed.

2. Let p620 parser document be the element's parser document .

3. Set the element's p620 parser document to null.

Note

This is done so that if parser-inserted p614 script elements fail to run when the parser tries to run them, e.g. because they are empty or specify an unsupported scripting language, another script can later mutate them and cause them to run again.

4. If p616 parser document is non-null and the element does not have an async attribute, then set the element's "non-

blocking" p620 flag to true.

Note

This is done so that if a parser-inserted p614 script element fails to run when the parser tries to run it, but it is later

executed after a script dynamically updates it, it will execute in a non-blocking fashion even if the p616 async attribute

620

isn't set.

5. Let source text be the element's child text content.

6. If the element has no p616 src attribute, and source text is the empty string, then return. The script is not executed.

7. If the element is not connected, then return. The script is not executed.

8. If either:

◦ the p614 p615 script element has a type attribute and its value is the empty string, or

◦ the p614 p615 p1226 script element has no type attribute but it has a language attribute and that attribute's value is

the empty string, or

◦ the p614 p615 p1226 script element has neither a type attribute nor a language attribute, then

...let p614 the script block's type string for this script element be "text/javascript".

Otherwise, if the p614 p615 p614 script element has a type attribute, let the script block's type string for this script element be

the value of that attribute with leading and trailing ASCII whitespace stripped.

Otherwise, the element has a non-empty p1226 p614 language attribute; let the script block's type string for this script element

be the concatenation of the string " p1226 text/ " followed by the value of the language attribute.

Note

The p1226 p615 language attribute is never conforming, and is always ignored if there is a type attribute present.

Determine p620 the script's type as follows:

◦ If p620 the script block's type string is a JavaScript MIME type essence match , the script's type is "classic".

◦ If p620 the script block's type string is an ASCII case-insensitive match for the string " module ", the script's type is

"module".

◦ If neither of the above conditions are true, then return. No script is executed.

9. If p620 parser document is non-null, then set the element's parser document back to parser document and set the element's

"non-blocking" p620 flag to false.

10. Set the element's p620 "already started" flag.

11. Set the element's p620 preparation-time document to its node document.

12. If p620 parser document is non-null, and parser document is not equal to the element's preparation-time document, then

return.

13. If p911 p614 scripting is disabled for the script element, then return. The script is not executed.

Note

The definition of p911 scripting is disabled means that, amongst others, the following scripts will not execute: scripts in

XMLHttpRequest p958 's responseXML documents, scripts in DOMParser-created documents, scripts in documents created

by p50 p50 p115 XSLTProcessor 's transformToDocument feature, and scripts that are first inserted by a script into a Document

that was created using the p1283 p1277 p1283 p1277 createDocument() API. [XHR] [DOMPARSING] [XSLTP] [DOM]

14. If the p614 p616 p620 script element has a nomodule content attribute and the script's type is "classic", then return. The script is

not executed.

Note

This means specifying p616 p912 nomodule on a module script has no effect; the algorithm continues onward.

15. If the p614 p616 script element does not have a src content attribute, and the Should element's inline behavior be blocked by

Content Security Policy? p614 algorithm returns " Blocked " when executed upon the script element, "script", and source

text p1275 , then return. The script is not executed. [CSP]

16. If the p614 p1226 p1226 p620 script element has an event attribute and a for attribute, and the script's type is "classic", then:

1. Let p1226 for be the value of the for attribute.

621

2. Let p1226 event be the value of the event attribute.

3. Strip leading and trailing ASCII whitespace from event and for.

4. If for is not an ASCII case-insensitive match for the string "window", then return. The script is not executed.

5. If event is not an ASCII case-insensitive match for either the string "onload" or the string "onload()", then return.

The script is not executed.

17. If the p614 p1224 script element has a charset attribute, then let encoding be the result of getting an encoding from the value

of the p1224 charset attribute.

If the p614 p1224 script element does not have a charset attribute, or if getting an encoding failed, let encoding be the same as

the encoding p614 of the script element's node document.

Note

If p620 the script's type is "module", this encoding will be ignored.

18. Let p617 classic script CORS setting be the current state of the element's crossorigin content attribute.

19. Let p91 p617 module script credentials mode be the CORS settings attribute credentials mode for the element's crossorigin

content attribute.

20. Let p92 cryptographic nonce be the element's [[CryptographicNonce]] internal slot's value.

21. If the p614 p617 script element has an integrity attribute, then let integrity metadata be that attribute's value.

Otherwise, let integrity metadata be the empty string.

22. Let p617 referrer policy be the current state of the element's referrerpolicy content attribute.

23. Let p614 p620 parser metadata be " parser-inserted " if the script element is "parser-inserted" , and "not-parser-inserted"

otherwise.

24. Let p913 p913 p913 options be a script fetch options whose cryptographic nonce is cryptographic nonce , integrity metadata is

integrity metadata p913 p913 , parser metadata is parser metadata , credentials mode is module script credentials mode, and

referrer policy p913 is referrer policy.

25. Let p911 settings object be the element's node document 's relevant settings object.

26. If the element has a p616 src content attribute, then:

1. Let p616 src be the value of the element's src attribute.

2. If p933 p1271 src is the empty string, queue a task to fire an event named error at the element, and return.

3. Set the element's p620 from an external file flag.

4. p89 Parse src relative to the element's node document.

5. If the previous step failed, p933 p1271 queue a task to fire an event named error at the element, and return.

Otherwise, let p89 url be the resulting URL record.

6. Switch on p620 the script's type :

↪ "classic"

Fetch a classic script p914 given url, settings object, options, classic script CORS setting, and encoding.

↪ "module"

Fetch an external module script graph p916 given url, settings object, and options.

When the chosen algorithm asynchronously completes, set p620 the script's script to the result. At that time, the

script is ready p620.

For performance reasons, user agents may start fetching the classic script or module graph (as defined above) as

soon as the p616 src attribute is set, instead, in the hope that the element will be inserted into the document (and

that the p617 crossorigin attribute won't change value in the meantime). Either way, once the element is inserted

into the document p44, the load must have started as described in this step. If the UA performs such prefetching, but

the element is never inserted in the document, or the p616 src attribute is dynamically changed, or the

622

crossorigin p617 attribute is dynamically changed, then the user agent will not execute the script so obtained, and the fetching process will have been effectively wasted.

27. If the element does not have a p616 src content attribute, run these substeps:

1. Let p614 p89 base URL be the script element's node document 's document base URL.

2. Switch on p620 the script's type :

↪ "classic"

1. Let p920 script be the result of creating a classic script using source text, settings object, base URL,

and options.

2. Set p620 the script's script to script.

3. p620 The script is ready.

↪ "module"

1. p916 Fetch an inline module script graph, given source text, base URL, settings object, and options.

When this asynchronously completes, set p620 the script's script to the result. At that time, the

script is ready p620.

28. Then, follow the first of the following options that describes the situation:

↪ p620 p616 p616 If the script's type is " classic ", and the element has a src attribute, and the element has a defer

attribute, and the element is p620 p616 "parser-inserted" , and the element does not have an async attribute

↪ p620 p620 If the script's type is " module ", and the element is "parser-inserted", and the element does not have

an p616 async attribute

Add the element to the end of the list of scripts that will execute when the document has finished parsing

associated with the p115 Document of the parser that created the element.

When p620 p620 the script is ready , set the element's "ready to be parser-executed" flag. The parser will handle executing the script.

↪ p620 p616 If the script's type is " classic ", and the element has a src attribute, and the element is "parser-

inserted" p620 p616 , and the element does not have an async attribute

The element is the p624 p115 pending parsing-blocking script of the Document of the parser that created the element.

(There can only be one such script per p115 Document at a time.)

When p620 p620 the script is ready , set the element's "ready to be parser-executed" flag. The parser will handle executing the script.

↪ p620 p616 If the script's type is " classic ", and the element has a src attribute, and the element does not have

an p616 p620 async attribute, and the element does not have the "non-blocking" flag set

↪ p620 p616 If the script's type is " module ", and the element does not have an async attribute, and the element

does not have the p620 "non-blocking" flag set

Add the element to the end of the list of scripts that will execute in order as soon as possible associated with

the element's p620 preparation-time document .

When p620 the script is ready, run the following steps:

1. If the element is not now the first element in the list of scripts that will execute in order as soon as

possible p623 to which it was added above, then mark the element as ready but return without executing the script yet.

2. p624 Execution : Execute the script block corresponding to the first script element in this list of scripts that will

execute in order as soon as possible p623 .

3. Remove the first element from this p623 list of scripts that will execute in order as soon as possible.

4. If this p623 list of scripts that will execute in order as soon as possible is still not empty and the first entry has

already been marked as ready, then jump back to the step labeled execution.



623

↪ p620 p616 If the script's type is " classic ", and the element has a src attribute

↪ p620 If the script's type is "module"

The element must be added to the set of scripts that will execute as soon as possible of the element's

preparation-time document p620.

When p620 p624 the script is ready , execute the script block and then remove the element from the set of scripts that will

execute as soon as possible p624.

↪ p616 p620 If the element does not have a src attribute, and the element is "parser-inserted" , and either the

parser that created the p614 p1184 p1076 script is an XML parser or it's an HTML parser whose script nesting

level p1078 p620 is not greater than one, and the element's parser document has a style sheet that is blocking

scripts p179

The element is the p624 p620 pending parsing-blocking script of its parser document . (There can only be one such script

per p115 Document at a time.)

Set the element's p620 "ready to be parser-executed" flag. The parser will handle executing the script.

↪ Otherwise

Immediately p42 p624 execute the script block, even if other scripts are already executing.

The p115 p115 pending parsing-blocking script of a Document is used by the Document's parser(s).

Note

If a p614 p115 script element that blocks a parser gets moved to another Document before it would normally have stopped blocking

that parser, it nonetheless continues blocking that parser until the condition that causes it to be blocking the parser no longer

applies (e.g., if the script is a p624 p115 pending parsing-blocking script because the original Document has a style sheet that is

blocking scripts p179 p115 when it was parsed, but then the script is moved to another Document before the blocking style sheet(s)

loaded, the script still blocks the parser until the style sheets are all loaded, at which time the script executes and the parser is

unblocked).

To p614 execute a script block given a script element scriptElement:

1. Let document be scriptElement's node document.

2. If p620 scriptElement 's preparation-time document is not equal to document, then return.

3. If p620 p1271 the script's script is null for scriptElement , then fire an event named error at scriptElement, and return.

4. If p620 p620 scriptElement is from an external file , or the script's type for scriptElement is "module", then increment document's

ignore-destructive-writes counter p957.

5. Switch on p620 the script's type for scriptElement:

↪ "classic"

1. Let p121 oldCurrentScript be the value to which document 's currentScript object was most recently set.

2. If p121 scriptElement 's root is not a shadow root , then set document 's currentScript attribute to

scriptElement. Otherwise, set it to null.

Note

This does not use the in a document tree check, as scriptElement could have been removed from the

document prior to execution, and in that scenario p121 currentScript still needs to point to it.

3. p921 p620 Run the classic script given by the script's script for scriptElement.

4. Set p121 document 's currentScript attribute to oldCurrentScript.

↪ "module"

1. Assert: p121 document 's currentScript attribute is null.

2. p922 p620 Run the module script given by the script's script for scriptElement.

6. Decrement the p957 ignore-destructive-writes counter of document, if it was incremented in the earlier step.

624

7. If p620 p1271 scriptElement is from an external file , then fire an event named load at scriptElement.



4.12.1.2 Scripting languages p62 §

5

User agents are not required to support JavaScript. This standard needs to be updated if a language other than JavaScript comes along and gets similar wide adoption by web browsers. Until such a time, implementing other languages is in conflict with this standard, given the processing model defined for the p614 script element.

Servers should use p1273 text/javascript for JavaScript resources. Servers should not use other JavaScript MIME types for JavaScript resources, and must not use non-JavaScript MIME types.

For external JavaScript resources, MIME type parameters in ` p90 Content-Type` headers are generally ignored. (In some cases the

` p614 p615 charset ` parameter has an effect.) However, for the script element's type attribute they are significant; it uses the JavaScript

MIME type essence match concept.

Note

For example, scripts with their p615 type attribute set to "text/javascript; charset=utf-8" will not be evaluated, even though

that is a valid JavaScript MIME type when parsed.

Furthermore, again for external JavaScript resources, special considerations apply around ` p90 Content-Type` header processing as detailed in the p620 p1277 prepare a script algorithm and Fetch . [FETCH]



4.12.1.3 Restrictions for contents of script elements p62 §

5

Note

The easiest and safest way to avoid the rather strange restrictions described in this section is to always escape an ASCII case-

insensitive match for ""

script-open = "<" s c r i p t tag-end

s = %x0053 ; U+0053 LATIN CAPITAL LETTER S

s =/ %x0073 ; U+0073 LATIN SMALL LETTER S

c = %x0043 ; U+0043 LATIN CAPITAL LETTER C

c =/ %x0063 ; U+0063 LATIN SMALL LETTER C

r = %x0052 ; U+0052 LATIN CAPITAL LETTER R

r =/ %x0072 ; U+0072 LATIN SMALL LETTER R

i = %x0049 ; U+0049 LATIN CAPITAL LETTER I

i =/ %x0069 ; U+0069 LATIN SMALL LETTER I

p = %x0050 ; U+0050 LATIN CAPITAL LETTER P

p =/ %x0070 ; U+0070 LATIN SMALL LETTER P

t = %x0054 ; U+0054 LATIN CAPITAL LETTER T

625

t =/ %x0074 ; U+0074 LATIN SMALL LETTER T

tag-end = %x0009 ; U+0009 CHARACTER TABULATION (tab)

tag-end =/ %x000A ; U+000A LINE FEED (LF)

tag-end =/ %x000C ; U+000C FORM FEED (FF)

tag-end =/ %x0020 ; U+0020 SPACE

tag-end =/ %x002F ; U+002F SOLIDUS (/)

tag-end =/ %x003E ; U+003E GREATER-THAN SIGN (>) When a p614 p627 script element contains script documentation , there are further restrictions on the contents of the element, as described in the section below.

Example

The following script illustrates this issue. Suppose you have a script that contains a string, as in:

var example = 'Consider this string:

What is going on here is that for legacy reasons, " p614



It is possible for these sequences to naturally occur in script expressions, as in the following examples:

if (x





4.12.5.1.13 Drawing focus rings and scrolling paths into view



For web developers (non-normative)

context . drawFocusIfNeeded (element)

context . drawFocusIfNeeded (path, element)

If the given element is focused , draws a focus ring around the current default path or the given path, following the platform conventions for focus rings.

context . scrollPathIntoView ()

context . scrollPathIntoView (path)

Scrolls the current default path or the given path into view. This is especially useful on devices with small screens, where the whole canvas might not be visible at once.

Objects that implement the CanvasUserInterface interface provide the following methods to control drawing focus rings and scrolling paths into view.



The drawFocusIfNeeded(element) method, when invoked, must run these steps: ✔ MDN

1. If element is not focused or is not a descendant of the element with whose context the method is associated, then return.

2. Draw a focus ring of the appropriate style along the intended path, following platform conventions.

Note

Some platforms only draw focus rings around elements that have been focused from the keyboard, and not those focused from the mouse. Other platforms simply don't draw focus rings around some elements at all unless relevant accessibility features are enabled. This API is intended to follow these conventions. User agents that implement distinctions based on the manner in which the element was focused are encouraged to classify focus driven by the

focus() method based on the kind of user interaction event from which the call was triggered (if any).

The focus ring should not be subject to the shadow effects , the global alpha , the global composition operators , or

any of the members in the CanvasFillStrokeStyles , CanvasPathDrawingStyles , CanvasTextDrawingStyles

interfaces, but should be subject to the clipping region . (The effect of transformations is described above and varies based on which path is being used.)

3. Inform the user that the focus is at the location given by the intended path. User agents may wait until the next time the

event loop reaches its update the rendering step to optionally inform the user.

User agents should not implicitly close open subpaths in the intended path when drawing the focus ring.

Note

This might be a moot point, however. For example, if the focus ring is drawn as an axis-aligned bounding rectangle around the

points in the intended path, then whether the subpaths are closed or not has no effect. This specification intentionally does not

specify precisely how focus rings are to be drawn: user agents are expected to honor their platform's native conventions.



⚠ MDN

The scrollPathIntoView() method, when invoked, must run these steps:

1. Let specifiedRectangle be the rectangle of the bounding box of the intended path.

2. Let notionalChild be a hypothetical element that is a rendered child of the canvas element whose dimensions are those of

specifiedRectangle.

3. Scroll notionalChild into view with behavior set to "auto", block set to "start", and inline set to "nearest".

4. Optionally, inform the user that the caret or selection (or both) cover specifiedRectangle of the canvas. The user agent

may wait until the next time the event loop reaches its update the rendering step to optionally inform the user.

"Inform the user", as used in this section, does not imply any persistent state change. It could mean, for instance, calling a system accessibility API to notify assistive technologies such as magnification tools so that the user's magnifier moves to the given area of the canvas. However, it does not associate the path with the element, or provide a region for tactile feedback, etc.



4.12.5.1.14 Drawing images



Objects that implement the CanvasDrawImage interface have the drawImage method to draw images. ✔ MDN

This method can be invoked with three different sets of arguments:

• drawImage(image, dx, dy)

• drawImage(image, dx, dy, dw, dh)

• drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) For web developers (non-normative)

context . drawImage (image, dx, dy)

context . drawImage (image, dx, dy, dw, dh)

context . drawImage (image, sx, sy, sw, sh, dx, dy, dw, dh)

Draws the given image onto the canvas. The arguments are interpreted as follows:





If the image isn't yet fully decoded, then nothing is drawn. If the image is a canvas with no data, throws an

"InvalidStateError" DOMException.

When the drawImage() method is invoked, the user agent must run these steps:

1. If any of the arguments are infinite or NaN, then return.



2. Let usability be the result of checking the usability of image.

3. If usability is bad, then return (without drawing anything).

4. Establish the source and destination rectangles as follows:

If not specified, the dw and dh arguments must default to the values of sw and sh, interpreted such that one CSS pixel in the

image is treated as one unit in the output bitmap's coordinate space. If the sx, sy, sw, and sh arguments are omitted,

then they must default to 0, 0, the image's intrinsic width in image pixels, and the image's intrinsic height in image pixels,

respectively. If the image has no intrinsic dimensions, then the concrete object size must be used instead, as determined

using the CSS "Concrete Object Size Resolution" algorithm, with the specified size having neither a definite width nor height,

nor any additional constraints, the object's intrinsic properties being those of the image argument, and the default object

size being the size of the output bitmap . [CSSIMAGES]

The source rectangle is the rectangle whose corners are the four points (sx, sy), (sx+sw, sy), (sx+sw, sy+sh), (sx, sy+sh).

The destination rectangle is the rectangle whose corners are the four points (dx, dy), (dx+dw, dy), (dx+dw, dy+dh), (dx, dy+dh).

When the source rectangle is outside the source image, the source rectangle must be clipped to the source image and the destination rectangle must be clipped in the same proportion.

Note

When the destination rectangle is outside the destination image (the output bitmap), the pixels that land outside the

output bitmap are discarded, as if the destination was an infinite canvas whose rendering was clipped to the

dimensions of the output bitmap.

5. If one of the sw or sh arguments is zero, then return. Nothing is painted.

6. Paint the region of the image argument specified by the source rectangle on the region of the rendering context's output

bitmap specified by the destination rectangle, after applying the current transformation matrix to the destination rectangle.

The image data must be processed in the original direction, even if the dimensions given are negative.

When scaling up, if the imageSmoothingEnabled attribute is set to true, the user agent should attempt to apply a smoothing algorithm to the image data when it is scaled. User agents which support multiple filtering algorithms may use

the value of the imageSmoothingQuality attribute to guide the choice of filtering algorithm when the

imageSmoothingEnabled attribute is set to true. Otherwise, the image must be rendered using nearest-neighbor interpolation.

Note

This specification does not define the precise algorithm to use when scaling an image down, or when scaling an image

up when the imageSmoothingEnabled attribute is set to true.

Note

When a canvas element is drawn onto itself, the drawing model requires the source to be copied before the image

is drawn, so it is possible to copy parts of a canvas element onto overlapping parts of itself.

If the original image data is a bitmap image, then the value painted at a point in the destination rectangle is computed by filtering the original image data. The user agent may use any filtering algorithm (for example bilinear interpolation or nearest-neighbor). When the filtering algorithm requires a pixel value from outside the original image data, it must instead use the value from the nearest edge pixel. (That is, the filter uses 'clamp-to-edge' behavior.) When the filtering algorithm requires a pixel value from outside the source rectangle but inside the original image data, then the value from the original image data must be used.

Note

Thus, scaling an image in parts or in whole will have the same effect. This does mean that when sprites coming from a single sprite sheet are to be scaled, adjacent images in the sprite sheet can interfere. This can be avoided by ensuring

each sprite in the sheet is surrounded by a border of transparent black, or by copying sprites to be scaled into temporary

canvas elements and drawing the scaled sprites from there.

Images are painted without affecting the current path, and are subject to shadow effects , global alpha , the clipping

region , and global composition operators.



7. If image is not origin-clean , then set the CanvasRenderingContext2D 's origin-clean flag to false.



4.12.5.1.15 Pixel manipulation



For web developers (non-normative)

imagedata = new ImageData (sw, sh)

imagedata = context . createImageData(sw, sh)

Returns an ImageData object with the given dimensions. All the pixels in the returned object are transparent black.

Throws an "IndexSizeError" DOMException if either of the width or height arguments are zero.

imagedata = context . createImageData(imagedata)

Returns an ImageData object with the same dimensions as the argument. All the pixels in the returned object are transparent

black.

imagedata = new ImageData (data, sw [, sh ] )

Returns an ImageData object using the data provided in the Uint8ClampedArray argument, interpreted using the given dimensions.

As each pixel in the data is represented by four numbers, the length of the data needs to be a multiple of four times the given width. If the height is provided as well, then the length needs to be exactly the width times the height times 4.

Throws an "IndexSizeError" DOMException if the given data and dimensions can't be interpreted consistently, or if either dimension is zero.

imagedata = context . getImageData (sx, sy, sw, sh)

Returns an ImageData object containing the image data for the given rectangle of the bitmap.

Throws an "IndexSizeError" DOMException if the either of the width or height arguments are zero.

imagedata . width

imagedata . height

Returns the actual dimensions of the data in the ImageData object, in pixels.

imagedata . data

Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255.

context . putImageData(imagedata, dx, dy [, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] )

Paints the data from the given ImageData object onto the bitmap. If a dirty rectangle is provided, only the pixels from that rectangle are painted.

The globalAlpha and globalCompositeOperation attributes, as well as the shadow attributes, are ignored for the purposes of this method call; pixels in the canvas are replaced wholesale, with no composition, alpha blending, no shadows, etc.

Throws an " InvalidStateError " DOMException if the imagedata object's data attribute value's [[ViewedArrayBuffer]] internal slot is detached.



Objects that implement the CanvasImageData interface provide the following methods for reading and writing pixel data to the MDN bitmap.

The ImageData() constructors and the createImageData() methods are used to instantiate new ImageData objects.

When the ImageData() constructor is invoked with two numeric arguments sw and sh, it must run these steps:

1. If one or both of sw and sh are zero, then throw an "IndexSizeError" DOMException.

2. Create an ImageData object with parameter pixelsPerRow set to sw, and rows set to sh.

3. Initialize the image data of the newly created ImageData object to transparent black.

4. Return the newly created ImageData object.

When the ImageData() constructor is invoked with its first argument being an Uint8ClampedArray source and its second and optional third arguments being numeric arguments sw and sh, it must run these steps:

1. Let length be the number of bytes in source.



2. If length is not a nonzero integral multiple of four, then throw an "InvalidStateError" DOMException.

3. Let length be length divided by four.

4. If length is not an integral multiple of sw, then throw an "IndexSizeError" DOMException.

Note

At this step, the length is guaranteed to be greater than zero (otherwise the second step above would have aborted the steps), so if sw is zero, this step will throw the exception and return.

5. Let height be length divided by sw.

6. If the sh argument was not omitted, and its value is not equal to height, then throw an "IndexSizeError" DOMException.

7. Create an ImageData object , with parameter pixelsPerRow set to sw, rows set to sh, and using source. Return the newly

created ImageData object.

Note

The resulting object's data is not a copy of source, it's the actual Uint8ClampedArray object passed as the first argument to the constructor.

When the createImageData() method is invoked with two numeric arguments sw and sh , it must create an ImageData object ,

with parameter pixelsPerRow set to the absolute magnitude of sw, and parameter rows set to the absolute magnitude of sh. Initialize the image data of the new ImageData object to transparent black . If both sw and sh are nonzero, then return the new ImageData

object. If one or both of sw and sh are zero, then throw an "IndexSizeError" DOMException instead.

When the createImageData() method is invoked with a single imagedata argument, it must create an ImageData object, with parameter pixelsPerRow set to the value of the width attribute of the ImageData object passed as the argument, and the rows parameter set to the value of the height attribute. Initialize the image data of the new ImageData object to transparent black. ✔ MDN

Return the newly created ImageData object.

The getImageData(sx, sy, sw, sh) method, when invoked, must, if either the sw or sh arguments are zero, throw an

" IndexSizeError " DOMException ; otherwise, if the CanvasRenderingContext2D 's origin-clean flag is set to false, it must throw a " SecurityError " DOMException ; otherwise, it must create an ImageData object , with parameter pixelsPerRow set to sw, and parameter rows set to sh . Set the pixel values of the image data of the newly created ImageData object to represent the output

bitmap for the area of that bitmap denoted by the rectangle whose corners are the four points (sx, sy), (sx+sw, sy), (sx+sw, sy + sh ), ( sx , sy + sh ), in the bitmap's coordinate space units. Pixels outside the output bitmap must be set to transparent black. Pixel values must not be premultiplied by alpha.

When the user agent is required to create an ImageData object, given a positive integer number of rows rows, a positive integer ✔ MDN

number of pixels per row pixelsPerRow, and an optional Uint8ClampedArray source, it must run these steps:

1. Let imageData be a new uninitialized ImageData object.

2. If source is specified, then assign the data attribute of imageData to source.

3. If source is not specified, then initialize the data attribute of imageData to a new Uint8ClampedArray object. The

Uint8ClampedArray object must use a new Canvas Pixel ArrayBuffer for its storage, and must have a zero start offset

and a length equal to the length of its storage, in bytes. The Canvas Pixel ArrayBuffer must have the correct size to store rows × pixelsPerRow pixels.

If the Canvas Pixel ArrayBuffer cannot be allocated, then rethrow the RangeError thrown by JavaScript, and return.

4. Initialize the width attribute of imageData to pixelsPerRow.

5. Initialize the height attribute of imageData to rows.

6. Return imageData.

ImageData objects are serializable objects . Their serialization steps, given value and serialized, are:

1. Set serialized .[[Data]] to the sub-serialization of the value of value 's data attribute.

2. Set serialized .[[Width]] to the value of value 's width attribute.



3. Set serialized .[[Height]] to the value of value 's height attribute.

Their deserialization steps, given serialized and value, are:

1. Initialize value 's data attribute to the sub-deserialization of serialized.[[Data]].

2. Initialize value 's width attribute to serialized.[[Width]].

3. Initialize value 's height attribute to serialized.[[Height]].

A Canvas Pixel ArrayBuffer is an ArrayBuffer whose data is represented in left-to-right order, row by row top to bottom, starting with the top left, with each pixel's red, green, blue, and alpha components being given in that order for each pixel. Each component of each pixel represented in this array must be in the range 0..255, representing the 8 bit value for that component. The components ✔ MDN must be assigned consecutive indices starting with 0 for the top left pixel's red component.

The putImageData() method writes data from ImageData structures back to the rendering context's output bitmap. Its arguments are: imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, and dirtyHeight.

When the last four arguments to this method are omitted, they must be assumed to have the values 0, 0, the width member of the imagedata structure, and the height member of the imagedata structure, respectively.

The method, when invoked, must act as follows:

1. Let buffer be imagedata 's data attribute value's [[ViewedArrayBuffer]] internal slot.

2. If IsDetachedBuffer(buffer) is true, then throw an "InvalidStateError" DOMException.

3. If dirtyWidth is negative, then let dirtyX be dirtyX+dirtyWidth, and let dirtyWidth be equal to the absolute magnitude of

dirtyWidth.

If dirtyHeight is negative, then let dirtyY be dirtyY+dirtyHeight, and let dirtyHeight be equal to the absolute magnitude of dirtyHeight.

4. If dirtyX is negative, then let dirtyWidth be dirtyWidth+dirtyX, and let dirtyX be zero.

If dirtyY is negative, then let dirtyHeight be dirtyHeight+dirtyY, and let dirtyY be zero.

5. If dirtyX + dirtyWidth is greater than the width attribute of the imagedata argument, then let dirtyWidth be the value of

that width attribute, minus the value of dirtyX.

If dirtyY + dirtyHeight is greater than the height attribute of the imagedata argument, then let dirtyHeight be the value of

that height attribute, minus the value of dirtyY.

6. If, after those changes, either dirtyWidth or dirtyHeight are negative or zero, then return without affecting any bitmaps.

7. For all integer values of x and y where dirtyX ≤ x < dirtyX+dirtyWidth and dirtyY ≤ y < dirtyY+dirtyHeight, copy the four

channels of the pixel with coordinate ( x , y ) in the imagedata data structure's Canvas Pixel ArrayBuffer to the pixel with

coordinate ( dx + x , dy + y ) in the rendering context's output bitmap.

Note

Due to the lossy nature of converting to and from premultiplied alpha color values, pixels that have just been set using

putImageData() might be returned to an equivalent getImageData() as different values.

The current path, transformation matrix , shadow attributes , global alpha , the clipping region, and global composition

operator must not affect the methods described in this section.

Example

In the following example, the script generates an ImageData object so that it can draw onto it.

// canvas is a reference to a element

var context = canvas.getContext('2d');

// create a blank slate

var data = context.createImageData(canvas.width, canvas.height);





// create some plasma

FillPlasma(data, 'green'); // green plasma

// add a cloud to the plasma

AddCloud(data, data.width/2, data.height/2); // put a cloud in the middle

// paint the plasma+cloud on the canvas

context.putImageData(data, 0, 0);

// support methods

function FillPlasma(data, color) { ... }

function AddCloud(data, x, y) { ... }



Example

Here is an example of using getImageData() and putImageData() to implement an edge detection filter.





Edge detection demo





4.12.5.1.16 Compositing p68 §

0

For web developers (non-normative)

context p680 . globalAlpha [ = value ]

Returns the current alpha value applied to rendering operations.

Can be set, to change the alpha value. Values outside of the range 0.0 .. 1.0 are ignored.

context p680 . globalCompositeOperation [ = value ]

Returns the current composition operation, from the values defined in p1275 Compositing and Blending . [COMPOSITE]. Can be set, to change the composition operation. Unknown values are ignored.



All drawing operations on an object which implements the p640 CanvasCompositing interface are affected by the global compositing ✔ MDN

attributes, p680 p680 globalAlpha and globalCompositeOperation.

The globalAlpha attribute gives an alpha value that is applied to shapes and images before they are composited onto the output

bitmap p644 . The value must be in the range from 0.0 (fully transparent) to 1.0 (no additional transparency). If an attempt is made to set the attribute to a value outside this range, including Infinity and Not-a-Number (NaN) values, then the attribute must retain its previous ✔ MDN

value. When the context is created, the p680 globalAlpha attribute must initially have the value 1.0.

The globalCompositeOperation attribute sets the current composition operator, which controls how shapes and images are drawn onto the p644 p680 output bitmap , once they have had globalAlpha and the current transformation matrix applied. The possible values are those defined in p1275 Compositing and Blending , and include the values source-over and copy . [COMPOSITE]

These values are all case-sensitive — they must be used exactly as defined. User agents must not recognize values that are not

identical to p1275 one of the values given in Compositing and Blending . [COMPOSITE]

On setting, if the user agent does not recognize the specified value, it must be ignored, leaving the value of

globalCompositeOperation p680 unaffected. Otherwise, the attribute must be set to the given new value.

When the context is created, the p680 p680 globalCompositeOperation attribute must initially have the value source-over .



4.12.5.1.17 Image smoothing p68 §

0

For web developers (non-normative)

context p681 . imageSmoothingEnabled [ = value ]

Returns whether pattern fills and the p674 drawImage() method will attempt to smooth images if their pixels don't line up exactly with the display, when scaling images up.

Can be set, to change whether images are smoothed (true) or not (false).



680

context p681 . imageSmoothingQuality [ = value ]

Returns the current image-smoothing-quality preference.

Can be set, to change the preferred quality of image smoothing. The possible values are " p646 p646 p646 low ", " medium " and " high".

Unknown values are ignored.

✔ MDN

Objects that implement the p640 CanvasImageSmoothing interface have attributes that control how image smoothing is performed.

The imageSmoothingEnabled attribute, on getting, must return the last value it was set to. On setting, it must be set to the new value.

When the object implementing the p640 CanvasImageSmoothing interface is created, the attribute must be set to true.

The imageSmoothingQuality attribute, on getting, must return the last value it was set to. On setting, it must be set to the new value.

When the object implementing the p640 p646 CanvasImageSmoothing interface is created, the attribute must be set to " low".



4.12.5.1.18 Shadows p68 §

1

All drawing operations on an object which implements the p640 CanvasShadowStyles interface are affected by the four global shadow attributes.

For web developers (non-normative)

context p681 . shadowColor [ = value ]

Returns the current shadow color.

Can be set, to change the shadow color. Values that cannot be parsed as CSS colors are ignored.

context p681 . shadowOffsetX [ = value ]

context p681 . shadowOffsetY [ = value ]

Returns the current shadow offset.

Can be set, to change the shadow offset. Values that are not finite numbers are ignored.

context p681 . shadowBlur [ = value ]

Returns the current level of blur applied to shadows.

Can be set, to change the blur level. Values that are not finite numbers greater than or equal to zero are ignored.



The shadowColor attribute sets the color of the shadow. ✔ MDN

When the context is created, the p681 shadowColor attribute initially must be transparent black.

On getting, the p664 serialization of the color must be returned.

On setting, the new value must be p58 p635 parsed with this canvas element and the color assigned. If parsing the value results in failure ✔ MDN

then it must be ignored, and the attribute must retain its previous value. p1276 [CSSCOLOR]

The shadowOffsetX and shadowOffsetY attributes specify the distance that the shadow will be offset in the positive horizontal and positive vertical distance respectively. Their values are in coordinate space units. They are not affected by the current transformation matrix.

When the context is created, the shadow offset attributes must initially have the value 0.

On getting, they must return their current value. On setting, the attribute being set must be set to the new value, except if the value is ✔ MDN infinite or NaN, in which case the new value must be ignored.

The shadowBlur attribute specifies the level of the blurring effect. (The units do not map to coordinate space units, and are not affected by the current transformation matrix.) When the context is created, the p681 shadowBlur attribute must initially have the value 0.

On getting, the attribute must return its current value. On setting the attribute must be set to the new value, except if the value is negative, infinite or NaN, in which case the new value must be ignored.



681

Shadows are only drawn if p681 the opacity component of the alpha component of the color of shadowColor is nonzero and either the

shadowBlur p681 p681 p681 is nonzero, or the shadowOffsetX is nonzero, or the shadowOffsetY is nonzero.

When shadows are drawn p682, they must be rendered as follows:

1. Let A be an infinite transparent black bitmap on which the source image for which a shadow is being created has been

rendered.

2. Let B be an infinite transparent black bitmap, with a coordinate space and an origin identical to A.

3. Copy the alpha channel of p681 p681 A to B , offset by shadowOffsetX in the positive x direction, and shadowOffsetY in the

positive y direction.

4. If p681 shadowBlur is greater than 0:

1. Let p681 σ be half the value of shadowBlur.

2. Perform a 2D Gaussian Blur on B, using σ as the standard deviation.

User agents may limit values of σ to an implementation-specific maximum value to avoid exceeding hardware limitations during the Gaussian blur operation.

5. Set the red, green, and blue components of every pixel in B to the red, green, and blue components (respectively) of the

color of p681 shadowColor .

6. Multiply the alpha component of every pixel in p681 B by the alpha component of the color of shadowColor.

7. The shadow is in the bitmap p683 B , and is rendered as part of the drawing model described below.

If the current composition operation is p680 copy, then shadows effectively won't render (since the shape will overwrite the shadow).



MDN

4.12.5.1.19 Filters p68 §

2

All drawing operations on an object which implements the p640 CanvasFilters interface are affected by the global filter attribute.

For web developers (non-normative)

context p682 . filter [ = value ]

Returns the current filter.

Can be set, to change the filter. Values that cannot be parsed as a <filter-function-list> value are ignored.

The p682 filter attribute, on getting, must return the last value it was successfully set to. The value must not be re-serialized. On setting, if the new value is 'none' (not the empty string, null, or undefined), filters must be disabled for the context. Otherwise, the value must be parsed as a <filter-function-list> value. If the value cannot be parsed as a <filter-function-list> value, where using property-independent style sheet syntax like 'inherit' or 'initial' is considered an invalid value, then it must be ignored, and the attribute must retain its previous value. When creating the object implementing the p640 CanvasFilters interface, the attribute must be set to 'none'.

A <filter-function-list> value consists of a sequence of one or more filter functions or references to SVG filters. The input to the filter is used as the input to the first item in the list. Subsequent items take the output of the previous item as their input. p1277 [FILTERS]

Coordinates used in the value of the p682 filter attribute are interpreted such that one pixel is equivalent to one SVG user space unit and to one canvas coordinate space unit. Filter coordinates are not affected by the p660 current transformation matrix. The current transformation matrix affects only the input to the filter. Filters are applied in the p644 output bitmap's coordinate space.

When the value of the p682 filter attribute defines lengths using percentages or using 'em' or 'ex' units, these must be interpreted relative to the p651 computed value of the 'font-size' property of the font style source object at the time that the attribute is set, if it is an element. If the p651 computed values are undefined for a particular case (e.g. because the font style source object is not an element or is not p1188 p652 being rendered ), then the relative keywords must be interpreted relative to the default value of the font attribute. The 'larger' and 'smaller' keywords are not supported.

If the value of the p682 filter attribute refers to an SVG filter in the same document, and this SVG filter changes, then the changed filter is used for the next draw operation.

682

If the value of the p682 filter attribute refers to an SVG filter in an external resource document and that document is not loaded when a drawing operation is invoked, then the drawing operation must proceed with no filtering.



4.12.5.1.20 Working with externally-defined SVG filters p68 §

3

This section is non-normative.

Since drawing is performed using filter value 'none' until an externally-defined filter has finished loading, authors might wish to determine whether such a filter has finished loading before proceeding with a drawing operation. One way to accomplish this is to load the externally-defined filter elsewhere within the same page in some element that sends a load event (for example, an SVG use element), and wait for the load event to be dispatched.



4.12.5.1.21 Drawing model p68 §

3

When a shape or image is painted, user agents must follow these steps, in the order given (or act as if they do):

1. Render the shape or image onto an infinite transparent black bitmap, creating image A, as described in the previous

sections. For shapes, the current fill, stroke, and line styles must be honored, and the stroke must itself also be subjected to the current transformation matrix.

2. When the filter attribute is set to a value other than 'none' and all the externally-defined filters it references, if any, are in

documents that are currently loaded, then use image p682 A as the input to the filter, creating image B. Otherwise, let B be an alias for A.

3. p682 When shadows are drawn, render the shadow from image B, using the current shadow styles, creating image C.

4. p682 p680 When shadows are drawn , multiply the alpha component of every pixel in C by globalAlpha .

5. p682 p671 p644 When shadows are drawn , composite C within the clipping region over the current output bitmap using the current

composition operator p680.

6. Multiply the alpha component of every pixel in p680 B by globalAlpha.

7. Composite p671 p644 p680 B within the clipping region over the current output bitmap using the current composition operator .

When compositing onto the p644 p644 output bitmap , pixels that would fall outside of the output bitmap must be discarded.



4.12.5.1.22 Best practices p68 §

3

When a canvas is interactive, authors should include p775 focusable elements in the element's fallback content corresponding to each

focusable p775 p671 part of the canvas, as in the example above .

When rendering focus rings, to ensure that focus rings have the appearance of native focus rings, authors should use the

drawFocusIfNeeded() p673 method, passing it the element for which a ring is being drawn. This method only draws the focus ring if the element is p774 focused, so that it can simply be called whenever drawing the element, without checking whether the element is focused or not first.

In addition to drawing focus rings, authors should use the p674 scrollPathIntoView() method when an element in the canvas is focused, to make sure it is visible on the screen (if applicable).

Authors should avoid implementing text editing controls using the p635 canvas element. Doing so has a large number of disadvantages:

• Mouse placement of the caret has to be reimplemented.

• Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).

• Scrolling of the text control has to be implemented (horizontally for long lines, vertically for multiline input).

• Native features such as copy-and-paste have to be reimplemented.

• Native features such as spell-checking have to be reimplemented.

683

• Native features such as drag-and-drop have to be reimplemented.

• Native features such as page-wide text search have to be reimplemented.

• Native features specific to the user, for example custom text services, have to be reimplemented. This is close to impossible

since each user might have different services installed, and there is an unbounded set of possible such services.

• Bidirectional text editing has to be reimplemented.

• For multiline text editing, line wrapping has to be implemented for all relevant languages.

• Text selection has to be reimplemented.

• Dragging of bidirectional text selections has to be reimplemented.

• Platform-native keyboard shortcuts have to be reimplemented.

• Platform-native input method editors (IMEs) have to be reimplemented.

• Undo and redo functionality has to be reimplemented.

• Accessibility features such as magnification following the caret or selection have to be reimplemented.

This is a huge amount of work, and authors are most strongly encouraged to avoid doing any of it by instead using the p494 input

element, the p549 p790 textarea element, or the contenteditable attribute.



4.12.5.1.23 Examples p68 §

4

This section is non-normative.

Example

Here is an example of a script that uses canvas to draw pretty glowing lines.





Example

The 2D rendering context for p635 canvas is often used for sprite-based games. The following example demonstrates this:



Walk Stop

Blue Robot Player Sprite by JohnColburn. Licensed under the

Here is the source for this example: terms of the Creative Commons Attribution Share-Alike 3.0

Unported license. This work is itself licensed under a Creative

Commons Attribution-ShareAlike 3.0 Unported License <!DOCTYPE HTML>.





Blue Robot Demo





Blue Robot Player Sprite by JohnColburn. Licensed under the terms of the Creative Commons Attribution Share-Alike 3.0 Unported

license.

This work is itself licensed under a licenses/by-sa/3.0/">Creative

Commons Attribution-ShareAlike 3.0 Unported License.





4.12.5.2 The p978 p68 ImageBitmap rendering context §

8

4.12.5.2.1 Introduction p68 §

8

ImageBitmapRenderingContext p688 is a performance-oriented interface that provides a low overhead method for displaying the contents of p978 ImageBitmap objects. It uses transfer semantics to reduce overall memory consumption. It also streamlines performance by avoiding intermediate compositing, unlike the p674 p639 drawImage() method of CanvasRenderingContext2D .

Using an p321 img element as an intermediate for getting an image resource into a canvas, for example, would result in two copies of the decoded image existing in memory at the same time: the p321 img element's copy, and the one in the canvas's backing store. This memory cost can be prohibitive when dealing with extremely large images. This can be avoided by using

ImageBitmapRenderingContext p688 .

Example

Using p688 ImageBitmapRenderingContext, here is how to transcode an image to the JPEG format in a memory- and CPU-efficient

way:

createImageBitmap(inputImageBlob).then(image => {

const canvas = document.createElement('canvas');

const context = canvas.getContext('bitmaprenderer');

context.transferFromImageBitmap(image);

canvas.toBlob(outputJPEGBlob => {

// Do something with outputJPEGBlob.

}, 'image/jpeg');

});



4.12.5.2.2 The p688 MDN p68 ImageBitmapRenderingContext interface §

8

IDL [Exposed=(Window,Worker)]

interface ImageBitmapRenderingContext {

readonly attribute (HTMLCanvasElement or OffscreenCanvas) canvas;

undefined transferFromImageBitmap(ImageBitmap? bitmap);

};

688

dictionary ImageBitmapRenderingContextSettings {

boolean alpha = true;

};



For web developers (non-normative)

context p637 p690 = canvas . getContext ('bitmaprenderer' [, { [ alpha: false ] } ] )

Returns an p688 p635 ImageBitmapRenderingContext object that is permanently bound to a particular canvas element.

If the p690 alpha setting is provided and set to false, then the canvas is forced to always be opaque.

context p689 . canvas

Returns the p635 canvas element that the context is bound to.

context p690 . transferFromImageBitmap (imageBitmap)

Transfers the underlying p979 p635 bitmap data from imageBitmap to context , and the bitmap becomes the contents of the canvas

element to which context is bound.

context p690 . transferFromImageBitmap (null)

Replaces contents of the p635 canvas element to which context is bound with a transparent black bitmap whose size corresponds

to the p636 p636 p635 width and height content attributes of the canvas element.

The canvas attribute must return the value it was initialized to when the object was created.

An p688 p979 ImageBitmapRenderingContext object has an output bitmap , which is a reference to bitmap data.

An p688 p689 ImageBitmapRenderingContext object has a bitmap mode , which can be set to valid or blank . A value of valid indicates that the context's p689 p979 p690 p689 output bitmap refers to bitmap data that was acquired via transferFromImageBitmap() . A value blank

indicates that the context's p689 output bitmap is a default transparent bitmap.

An p688 ImageBitmapRenderingContext object also has an alpha flag, which can be set to true or false. When an

ImageBitmapRenderingContext p688 p689 p635 object has its alpha flag set to false, the contents of the canvas element to which the context is bound are obtained by compositing the context's p689 output bitmap onto an opaque black bitmap of the same size using the source-over composite operation. If the p689 p689 alpha flag is set to true, then the output bitmap is used as the contents of the

canvas p635 p1275 element to which the context is bound. [COMPOSITE]

Note

The step of compositing over an opaque black bitmap ought to be elided whenever equivalent results can be obtained more

efficiently by other means.



When a user agent is required to set an ImageBitmapRenderingContext's output bitmap, with a context argument that is an

ImageBitmapRenderingContext p688 p979 object and an optional argument bitmap that refers to bitmap data , it must run these steps:

1. If a bitmap argument was not provided, then:

1. Set p689 p689 context 's bitmap mode to blank.

2. Let p635 canvas be the canvas element to which context is bound.

3. Set p689 p636 context 's output bitmap to be transparent black with an intrinsic width equal to the numeric value of

canvas p636 p636 p636 's width attribute and an intrinsic height equal to the numeric value of canvas 's height attribute,

those values being interpreted in CSS pixels.

4. Set the p689 p636 output bitmap 's origin-clean flag to true.

2. If a bitmap argument was provided, then:

1. Set p689 p689 context 's bitmap mode to valid .

2. Set p689 context 's output bitmap to refer to the same underlying bitmap data as bitmap, without making a copy.

Note

The p636 origin-clean flag of bitmap is included in the bitmap data to be referenced by context's output

689

bitmap p689 .



The ImageBitmapRenderingContext creation algorithm, which is passed a target and options, consists of running these steps:

1. Let p689 settings be the result of converting options to the dictionary type ImageBitmapRenderingContextSettings . (This can

throw an exception.)

2. Let p688 context be a new ImageBitmapRenderingContext object.

3. Initialize p645 context 's canvas attribute to point to target.

4. Set p689 context 's output bitmap to the same bitmap as target's bitmap (so that they are shared).

5. Run the steps to p689 set an ImageBitmapRenderingContext 's output bitmap with context.

6. Initialize p689 context 's alpha flag to true.

7. Process each of the members of settings as follows:

alpha

If false, then set p689 context 's alpha flag to false.

8. Return context.



The transferFromImageBitmap(imageBitmap) method, when invoked, must run these steps: MDN

1. Let p688 p690 bitmapContext be the ImageBitmapRenderingContext object on which the transferFromImageBitmap() method

was called.

2. If p689 imageBitmap is null, then run the steps to set an ImageBitmapRenderingContext's output bitmap, with bitmapContext

as the context argument and no bitmap argument, then return.

3. If the value of p104 imageBitmap 's [[Detached]] internal slot is set to true, then throw an "InvalidStateError" DOMException.

4. Run the steps to p689 set an ImageBitmapRenderingContext 's output bitmap , with the context argument equal to

bitmapContext p979 , and the bitmap argument referring to imageBitmap 's underlying bitmap data .

5. Set the value of p104 imageBitmap 's [[Detached]] internal slot to true.

6. Unset p979 imageBitmap's bitmap data .



4.12.5.3 The p690 ⚠ MDN p69 OffscreenCanvas interface §

0

IDL typedef (OffscreenCanvasRenderingContext2D or ImageBitmapRenderingContext or WebGLRenderingContext or

WebGL2RenderingContext) OffscreenRenderingContext;

dictionary ImageEncodeOptions {

DOMString type = "image/png";

unrestricted double quality;

};

enum OffscreenRenderingContextId { "2d", "bitmaprenderer", "webgl", "webgl2" };

[Exposed=(Window,Worker), Transferable]

interface OffscreenCanvas : EventTarget {

constructor([EnforceRange] unsigned long long width, [EnforceRange] unsigned long long height);

attribute [EnforceRange] unsigned long long width;

attribute [EnforceRange] unsigned long long height;



690

OffscreenRenderingContext? getContext(OffscreenRenderingContextId contextId, optional any options =

null);

ImageBitmap transferToImageBitmap();

Promise<Blob> convertToBlob(optional ImageEncodeOptions options = {});

};



Note

OffscreenCanvas p690 is an EventTarget so that WebGL can fire webglcontextlost and webglcontextrestored events at it.

[WEBGL] p1282



OffscreenCanvas p690 p635 objects are used to create rendering contexts, much like an HTMLCanvasElement, but with no connection to ⚠ MDN

the DOM. This makes it possible to use canvas rendering contexts in p1016 workers.

An p690 OffscreenCanvas object may hold a weak reference to a placeholder canvas element, which is typically in the DOM, whose embedded content is provided by the p690 p690 OffscreenCanvas object. The bitmap of the OffscreenCanvas object is pushed to the

placeholder p691 p690 canvas element by calling the commit() method of the OffscreenCanvas object's rendering context. All rendering context types that can be created by an p690 p691 OffscreenCanvas object must implement a commit() method. The exact behavior of the commit method (e.g. whether it copies or transfers bitmaps) may vary, as defined by the rendering contexts' respective specifications. Only the p694 2D context for offscreen canvases is defined in this specification.

For web developers (non-normative)

offscreenCanvas p691 = new OffscreenCanvas(width, height)

Returns a new p690 p691 OffscreenCanvas object that is not linked to a placeholder canvas element, and whose bitmap's size is determined by the width and height arguments.

context p692 = offscreenCanvas . getContext(contextId [, options ] )

Returns an object that exposes an API for drawing on the p690 OffscreenCanvas object. contextId specifies the desired API:

" p692 p692 p692 p692 2d ", " bitmaprenderer ", " webgl ", or " webgl2 ". options is handled by that API.

This specification defines the " p637 p692 2d " context below, which is similar but distinct from the " 2d " context that is created from a

canvas p635 p692 p692 p1282 element. The WebGL specifications define the " webgl " and " webgl2 " contexts. [WEBGL]

Returns null if the canvas has already been initialized with another context type (e.g., trying to get a " p692 2d" context after

getting a " p692 webgl" context).

An p690 OffscreenCanvas object has an internal bitmap that is initialized when the object is created. The width and height of the

bitmap p691 p692 p692 p690 are equal to the values of the width and height attributes of the OffscreenCanvas object. Initially, all the bitmap's pixels are transparent black.

An p690 OffscreenCanvas object can have a rendering context bound to it. Initially, it does not have a bound rendering context. To keep track of whether it has a rendering context or not, and what kind of rendering context it is, an p690 OffscreenCanvas object also has a context mode, which is initially none but can be changed to either 2d, bitmaprenderer, webgl, webgl2, or detached by ⚠ MDN

algorithms defined in this specification.

The constructor p690 p691 OffscreenCanvas( width , height ) , when invoked, must create a new OffscreenCanvas object with its bitmap

initialized to a rectangular array of p692 transparent black pixels of the dimensions specified by width and height ; and its width and

height p692 attributes initialized to width and height respectively.



OffscreenCanvas p690 p104 p104 objects are transferable . Their transfer steps, given value and dataHolder, are as follows:

1. If p691 p691 value 's context mode is not equal to none, then throw an "InvalidStateError" DOMException.

2. Set p691 p691 value 's context mode to detached .

3. Let p691 width and height be the dimensions of value 's bitmap .

4. Unset p691 value 's bitmap.

5. Set dataHolder.[[Width]] to width and dataHolder.[[Height]] to height.

6. Set p691 dataHolder .[[PlaceholderCanvas]] to be a weak reference to value 's placeholder canvas element, if value has one, or

null if it does not.

691

Their p104 transfer-receiving steps, given dataHolder and value, are:

1. Initialize p691 value 's bitmap to a rectangular array of transparent black pixels with width given by dataHolder.[[Width]] and

height given by dataHolder.[[Height]].

2. If p691 dataHolder .[[PlaceholderCanvas]] is not null, set value 's placeholder canvas element to

dataHolder.[[PlaceholderCanvas]] (while maintaining the weak reference semantics).



The p690 getContext( contextId , options ) method of an OffscreenCanvas object, when invoked, must run these steps: ⚠ MDN

1. If options is not an object, then set options to null.

2. Set options to the result of converting options to a JavaScript value.

3. Run the steps in the cell of the following table whose column header matches this p690 OffscreenCanvas object's context

mode p691 and whose row header matches contextId:

none p691 p691 p691 p691 p691 2d bitmaprenderer webgl or detached

webgl2 p691

"2d" Follow the offscreen 2D context creation Return the Return null. Return null. Throw an

algorithm p694 defined in the section below, passing it same object "InvalidStateError"

this OffscreenCanvasp690 object and options, to as was DOMException.

obtain an p694 OffscreenCanvasRenderingContext2D returned the

object; if this does not throw an exception, then set last time the

this p690 p691 OffscreenCanvas object's context mode method was

to p691 2d, and return the new invoked with

OffscreenCanvasRenderingContext2D p694 object. this same

first

argument.

"bitmaprenderer" Follow the ImageBitmapRenderingContext creation Return null. Return the same Return null. Throw an

algorithmp690 defined in the section above, passing it object as was "InvalidStateError"

this p690 OffscreenCanvas object and options, to returned the last DOMException.

obtain an p688 ImageBitmapRenderingcontext object; time the method was

if this does not throw an exception, then set this invoked with this

OffscreenCanvas p690 p691 object's context mode to same first argument.

bitmaprenderer p691 , and return the new

ImageBitmapRenderingcontext p688 object.

"webgl" or Follow the instructions given in the WebGL Return null. Return null. Return the Throw an

"webgl2" specifications' Context Creation sections to obtain same value "InvalidStateError"

either a WebGLRenderingContext, as was DOMException.

WebGL2RenderingContext, or null; if the returned returned the

value is null, then return null; otherwise, set this last time the

OffscreenCanvasp690 object's context modep691 to method was

webgl p691 p691 or webgl2, and return the invoked with

WebGLRenderingContext or this same

WebGL2RenderingContext p1282 object. [WEBGL] first

argument.



For web developers (non-normative)

offscreenCanvas p692 . width [ = value ]

offscreenCanvas p692 . height [ = value ]

These attributes return the dimensions of the p690 p691 OffscreenCanvas object's bitmap.

They can be set, to replace the p691 bitmap with a new, transparent black bitmap of the specified dimensions (effectively resizing it).



If either the p690 width or height attributes of an OffscreenCanvas object are set (to a new value or to the same value as before) and ⚠ MDN

the p690 p691 p691 p690 p691 OffscreenCanvas object's context mode is 2d , then replace the OffscreenCanvas object's bitmap with a new

transparent black p647 bitmap and reset the rendering context to its default state . The new bitmap's dimensions are equal to the new values of the p692 p692 width and height attributes.

The resizing behavior for " p692 p692 p1282 webgl " and " webgl2 " contexts is defined in the WebGL specifications. [WEBGL]

Note

If an p690 p691 OffscreenCanvas object whose dimensions were changed has a placeholder canvas element , then the placeholder 692

canvas p691 p691 p690 element 's intrinsic size will only be updated via the commit() method of the OffscreenCanvas object's rendering

context.



For web developers (non-normative)

promise p693 = offscreenCanvas . convertToBlob( [options] )

Returns a promise that will fulfill with a new p690 Blob object representing a file containing the image in the OffscreenCanvas object.

The argument, if provided, is a dictionary that controls the encoding options of the image file to be created. The p693 type field

specifies the file format and has a default value of " p1273 image/png"; that type is also used if the requested type isn't supported.

If the image format supports variable quality (such as " p1273 p693 image/jpeg "), then the quality field is a number in the range 0.0 to 1.0 inclusive indicating the desired quality level for the resulting image.

canvas p693 . transferToImageBitmap()

Returns a newly created p978 p690 ImageBitmap object with the image in the OffscreenCanvas object. The image in the

OffscreenCanvas p690 object is replaced with a new blank image.



The convertToBlob(options) method, when invoked, must run the following steps: ⚠ MDN

1. If the value of this p690 p104 OffscreenCanvas object's [[Detached]] internal slot is set to true, then return a promise rejected

with an "InvalidStateError" DOMException.

2. If this p690 p691 p691 p694 p694 OffscreenCanvas object's context mode is 2d and the rendering context's bitmap 's origin-clean flag is

set to false, then return a promise rejected with a "SecurityError" DOMException.

3. If this p690 p691 OffscreenCanvas object's bitmap has no pixels (i.e., either its horizontal dimension or its vertical dimension is

zero) then return a promise rejected with an "IndexSizeError" DOMException.

4. Let p690 p691 bitmap be a copy of this OffscreenCanvas object's bitmap .

5. Let result be a new promise object.

6. Run these steps p42 in parallel:

1. Let p696 file be a serialization of bitmap as a file , with options's type and quality if present.

2. p933 p639 p635 Queue an element task on the canvas blob serialization task source given the canvas element to run

these steps:

1. If file is null, then reject result with an "EncodingError" DOMException.

2. Otherwise, resolve p911 result with a new Blob object, created in the relevant Realm of this

OffscreenCanvas p690 p1277 object, representing file . [FILEAPI]

7. Return result.

The transferToImageBitmap() method, when invoked, must run the following steps: ⚠ MDN

1. If the value of this p690 p104 OffscreenCanvas object's [[Detached]] internal slot is set to true, then throw an

"InvalidStateError" DOMException.

2. If this p690 p691 p691 OffscreenCanvas object's context mode is set to none , then throw an "InvalidStateError" DOMException.

3. Let p978 image be a newly created ImageBitmap object that references the same underlying bitmap data as this

OffscreenCanvas p690 p691 object's bitmap .

4. Set this p690 p691 OffscreenCanvas object's bitmap to reference a newly created bitmap of the same dimensions as the

previous bitmap, and with its pixels initialized to p694 transparent black , or opaque black if the rendering context's alpha flag is set to false.

Note

This means that if the rendering context of this p690 OffscreenCanvas is a WebGLRenderingContext, the value of

preserveDrawingBuffer p1282 will have no effect. [WEBGL]

5. Return image.

693

4.12.5.3.1 The offscreen 2D rendering context p69 §

4

IDL [Exposed=(Window,Worker)]

interface OffscreenCanvasRenderingContext2D {

undefined commit();

readonly attribute OffscreenCanvas canvas;

};

OffscreenCanvasRenderingContext2D includes CanvasState;

OffscreenCanvasRenderingContext2D includes CanvasTransform;

OffscreenCanvasRenderingContext2D includes CanvasCompositing;

OffscreenCanvasRenderingContext2D includes CanvasImageSmoothing;

OffscreenCanvasRenderingContext2D includes CanvasFillStrokeStyles;

OffscreenCanvasRenderingContext2D includes CanvasShadowStyles;

OffscreenCanvasRenderingContext2D includes CanvasFilters;

OffscreenCanvasRenderingContext2D includes CanvasRect;

OffscreenCanvasRenderingContext2D includes CanvasDrawPath;

OffscreenCanvasRenderingContext2D includes CanvasText;

OffscreenCanvasRenderingContext2D includes CanvasDrawImage;

OffscreenCanvasRenderingContext2D includes CanvasImageData;

OffscreenCanvasRenderingContext2D includes CanvasPathDrawingStyles;

OffscreenCanvasRenderingContext2D includes CanvasTextDrawingStyles;

OffscreenCanvasRenderingContext2D includes CanvasPath;

The p694 p691 p690 OffscreenCanvasRenderingContext2D object is a rendering context for drawing to the bitmap of an OffscreenCanvas

object. It is similar to the p639 CanvasRenderingContext2D object, with the following differences:

• there is no support for p641 user interface features;

• its p695 p690 p635 canvas attribute refers to an OffscreenCanvas object rather than a canvas element;

• it has a p695 p690 commit() method for pushing the rendered image to the context's OffscreenCanvas object's placeholder

canvas p691 element.

An p694 OffscreenCanvasRenderingContext2D object has a bitmap that is initialized when the object is created.

The p694 bitmap has an origin-clean flag, which can be set to true or false. Initially, when one of these bitmaps is created, its origin-

clean p694 flag must be set to true.

An p694 OffscreenCanvasRenderingContext2D object also has an alpha flag, which can be set to true or false. Initially, when the context is created, its alpha flag must be set to true. When an p694 p694 OffscreenCanvasRenderingContext2D object has its alpha flag

set to false, then its alpha channel must be fixed to 1.0 (fully opaque) for all pixels, and attempts to change the alpha component of any pixel must be silently ignored.

An p694 p690 OffscreenCanvasRenderingContext2D object has an associated OffscreenCanvas object , which is the OffscreenCanvas

object from which the p694 OffscreenCanvasRenderingContext2D object was created.

For web developers (non-normative)

offscreenCanvasRenderingContext2D p695 . commit()

Copies the rendering context's p694 p691 bitmap to the bitmap of the placeholder canvas element of the associated

OffscreenCanvas p694 object . The copy operation is synchronous. Calling this method is not needed for the transfer, since it

happens automatically during the p931 event loop execution.

offscreenCanvas p695 = offscreenCanvasRenderingContext2D . canvas

Returns the p694 associated OffscreenCanvas object.

The p690 offscreen 2D context creation algorithm , which is passed a target (an OffscreenCanvas object) and optionally some arguments, consists of running the following steps:

1. If the algorithm was passed some arguments, let arg be the first such argument. Otherwise, let arg be undefined.

2. Let p639 settings be the result of converting options to the dictionary type CanvasRenderingContext2DSettings. (This can

throw an exception.).

694

3. Let p694 context be a new OffscreenCanvasRenderingContext2D object.

4. Set p694 context 's associated OffscreenCanvas object to target.

5. Process each of the members of settings as follows:

alpha p645

If false, set p694 context 's alpha flag to false.

6. Set p694 p692 p692 context 's bitmap to a newly created bitmap with the dimensions specified by the width and height attributes

of target, and set target's bitmap to the same bitmap (so that they are shared).

7. If p694 p694 context 's alpha flag is set to true, initialize all the pixels of context 's bitmap to transparent black. Otherwise,

initialize the pixels to opaque black.

8. Return context.

The commit() method, when invoked, must run the following steps:

1. If this p694 p694 OffscreenCanvasRenderingContext2D 's associated OffscreenCanvas object does not have a placeholder

canvas p691 element, then return.

2. Let p694 p694 p694 image be a copy of this OffscreenCanvasRenderingContext2D 's bitmap , including the value of its origin-clean

flag.

3. p933 p939 p691 Queue an element task on the DOM manipulation task source given the placeholder canvas element to set the

placeholder p691 p644 canvas element 's output bitmap to be a reference to image.

Note

If p691 image has different dimensions than the bitmap previously referenced as the placeholder canvas element 's output

bitmap p644 p691 , then this task will result in a change in the placeholder canvas element 's intrinsic size, which can affect document layout.



Note

Implementations are encouraged to short-circuit the graphics update steps of the p931 window event loop for the purposes of

updating the contents of a p691 p695 placeholder canvas element to the display. This could mean, for example, that the commit()

method can copy the bitmap contents directly to a graphics buffer that is mapped to the physical display location of the

placeholder p691 canvas element. This or similar short-circuiting approaches can significantly reduce display latency, especially in

cases where the p695 p931 p931 commit() method is invoked from a worker event loop and the window event loop of the placeholder

canvas p691 element is busy. However, such shortcuts can not have any script-observable side-effects. This means that the

committed bitmap still needs to be sent to the p691 placeholder canvas element, in case the element is used as a

CanvasImageSource p639 p978 p638 p638 , as an ImageBitmapSource , or in case toDataURL() or toBlob() are called on it.

The p694 p694 canvas attribute, on getting, must return this OffscreenCanvasRenderingContext2D 's associated OffscreenCanvas object .



4.12.5.4 Color spaces and color correction p69 §

5

The p635 canvas APIs must perform color correction at only two points: when rendering images with their own gamma correction and color space information onto a bitmap, to convert the image to the color space used by the bitmaps (e.g. using the 2D Context's

drawImage() p674 p639 method with an HTMLOrSVGImageElement object), and when rendering the actual canvas bitmap to the output device.

Note

Thus, in the 2D context, colors used to draw shapes onto the canvas will exactly match colors obtained through the

getImageData() p677 method.

The p638 toDataURL() method, when invoked, must not include color space information in the resources they return. Where the output format allows it, the color of pixels in resources created by p638 p677 toDataURL() must match those returned by the getImageData()

method.

In user agents that support CSS, the color space used by a p635 canvas element must match the color space used for processing any

695

colors for that element in CSS.

The gamma correction and color space information of images must be handled in such a way that an image rendered directly using an

img p321 p635 element would use the same colors as one painted on a canvas element that is then itself rendered. Furthermore, the rendering of images that have no color correction information (such as those returned by the p638 toDataURL() method) must be rendered with no color correction.

Note

Thus, in the 2D context, calling the p674 p638 drawImage() method to render the output of the toDataURL() method to the canvas,

given the appropriate dimensions, has no visible effect.



4.12.5.5 Serializing bitmaps to a file p69 §

6

When a user agent is to create a serialization of the bitmap as a file, given a type and an optional quality, it must create an image file in the format given by type. If an error occurs during the creation of the image file (e.g. an internal encoder error), then the result of the serialization is null. p1280 [PNG]

The image file's pixel data must be the bitmap's pixel data scaled to one image pixel per coordinate space unit, and if the file format used supports encoding resolution metadata, the resolution must be given as 96dpi (one image pixel per CSS pixel).

If type is supplied, then it must be interpreted as a MIME type giving the format to use. If the type has any parameters, then it must be treated as not supported.

Example

For example, the value " p1273 p1273 image/png " would mean to generate a PNG image, the value " image/jpeg" would mean to

generate a JPEG image, and the value " p1273 image/svg+xml" would mean to generate an SVG image (which would require that the

user agent track how the bitmap was generated, an unlikely, though potentially awesome, feature).

User agents must support PNG (" p1273 image/png"). User agents may support other types. If the user agent does not support the requested type, then it must create the file using the PNG format. p1280 [PNG]

User agents must convert the provided type to ASCII lowercase before establishing if they support that type.

For image types that do not support an alpha channel, the serialized image must be the bitmap image composited onto an opaque

black background using the source-over operator.

If p1273 p1273 type is an image format that supports variable quality (such as " image/jpeg "), quality is given, and type is not " image/png", then, if Type(quality) is Number, and quality is in the range 0.0 to 1.0 inclusive, the user agent must treat quality as the desired quality level. Otherwise, the user agent must use its default quality value, as if the quality argument had not been given.

Note

The use of type-testing here, instead of simply declaring quality as a Web IDL double, is a historical artifact.



Note

Different implementations can have slightly different interpretations of "quality". When the quality is not specified, an

implementation-specific default is used that represents a reasonable compromise between compression ratio, image quality, and

encoding time.



4.12.5.6 Security with p635 p69 canvas elements §

6

This section is non-normative.

Information leakage p841 can occur if scripts from one origin can access information (e.g. read pixels) from images from another origin (one that isn't the p842 same ).

To mitigate this, bitmaps used with p635 p978 canvas elements and ImageBitmap objects are defined to have a flag indicating whether they are p636 p636 origin-clean . All bitmaps start with their origin-clean set to true. The flag is set to false when cross-origin images are

696

used.

The p638 p638 p677 toDataURL() , toBlob() , and getImageData() methods check the flag and will throw a "SecurityError" DOMException rather than leak cross-origin data.

The value of the p636 p635 p978 origin-clean flag is propagated from a source canvas element's bitmap to a new ImageBitmap object by

createImageBitmap() p980 p635 p636 . Conversely, a destination canvas element's bitmap will have its origin-clean flags set to false by

drawImage p674 p978 p636 if the source image is an ImageBitmap object whose bitmap has its origin-clean flag set to false.

The flag can be reset in certain situations; for example, when changing the value of the p636 p636 width or the height content attribute of the p635 p639 p636 canvas element to which a CanvasRenderingContext2D is bound, the bitmap is cleared and its origin-clean flag is reset.

When using an p688 p636 p978 ImageBitmapRenderingContext , the value of the origin-clean flag is propagated from ImageBitmap objects when they are transferred to the p635 p690 canvas via transferFromImageBitmap() .



✔ MDN

4.13 Custom elements p69 §

7



4.13.1 Introduction p69 §

7

This section is non-normative.

Custom elements p705 provide a way for authors to build their own fully-featured DOM elements. Although authors could always use non-standard elements in their documents, with application-specific behavior added after the fact by scripting or similar, such elements have historically been non-conforming and not very functional. By p708 defining a custom element, authors can inform the parser how to properly construct an element and how elements of that class should react to changes.

Custom elements are part of a larger effort to "rationalise the platform", by explaining existing platform features (like the elements of HTML) in terms of lower-level author-exposed extensibility points (like custom element definition). Although today there are many limitations on the capabilities of custom elements—both functionally and semantically—that prevent them from fully explaining the behaviors of HTML's existing elements, we hope to shrink this gap over time.



4.13.1.1 Creating an autonomous custom element p69 §

7

This section is non-normative.

For the purposes of illustrating how to create an p705 autonomous custom element, let's define a custom element that encapsulates rendering a small icon for a country flag. Our goal is to be able to use it like so:



To do this, we first declare a class for the custom element, extending p125 HTMLElement :

class FlagIcon extends HTMLElement {

constructor() {

super();

this._countryCode = null;

}

static get observedAttributes() { return ["country"]; }

attributeChangedCallback(name, oldValue, newValue) {

// name will always be "country" due to observedAttributes this._countryCode = newValue;

this._updateRendering();

}

connectedCallback() {

697

this._updateRendering();

}

get country() {

return this._countryCode;

}

set country(v) {

this.setAttribute("country", v);

}

_updateRendering() {

// Left as an exercise for the reader. But, you'll probably want to // check this.ownerDocument.defaultView to see if we've been // inserted into a document with a browsing context, and avoid // doing any work if not.

}

}

We then need to use this class to define the element:

customElements.define("flag-icon", FlagIcon); At this point, our above code will work! The parser, whenever it sees the flag-icon tag, will construct a new instance of our FlagIcon class, and tell our code about its new country attribute, which we then use to set the element's internal state and update its rendering (when appropriate).

You can also create flag-icon elements using the DOM API:

const flagIcon = document.createElement("flag-icon")

flagIcon.country = "jp"

document.body.appendChild(flagIcon)

Finally, we can also use the p705 custom element constructor itself. That is, the above code is equivalent to:

const flagIcon = new FlagIcon()

flagIcon.country = "jp"

document.body.appendChild(flagIcon)



4.13.1.2 Creating a form-associated custom element p69 §

8

This section is non-normative.

Adding a static p705 formAssociated property, with a true value, makes an autonomous custom element a form-associated custom

element p706 p717 . The ElementInternals interface helps you to implement functions and properties common to form control elements.

class MyCheckbox extends HTMLElement {

static get formAssociated() { return true; }

static get observedAttributes() { return ['checked']; }

constructor() {

super();

this._internals = this.attachInternals();

this.addEventListener('click', this._onClick.bind(this));

}

get form() { return this._internals.form; }

get name() { return this.getAttribute('name'); }

get type() { return this.localName; }

698

get checked() { return this.getAttribute('checked'); }

set checked(flag) { this.toggleAttribute('checked', Boolean(flag)); }

attributeChangedCallback(name, oldValue, newValue) {

// name will always be "checked" due to observedAttributes this._internals.setFormValue(this.checked ? 'on' : null);

}

_onClick(event) {

this.checked = !this.checked;

}

}

customElements.define('my-checkbox', MyCheckbox); You can use the custom element p487 p491 my-checkbox like a built-in form-associated element. For example, putting it in form or label

associates the p487 my-checkbox element with them, and submitting the form will send data provided by my-checkbox implementation.





I read the agreement.





4.13.1.3 Creating a custom element with default accessible roles, states, and properties p69 §

9

This section is non-normative.

By using the appropriate properties of p717 ElementInternals, your custom element can have default accessibility semantics. The following code expands our form-associated checkbox from the previous section to properly set its default role and checkedness, as viewed by accessibility technology:

class MyCheckbox extends HTMLElement {

static get formAssociated() { return true; }

static get observedAttributes() { return ['checked']; }

constructor() {

super();

this._internals = this.attachInternals();

this.addEventListener('click', this._onClick.bind(this));

this._internals.role = 'checkbox';

this._internals.ariaChecked = false;

}

get form() { return this._internals.form; }

get name() { return this.getAttribute('name'); }

get type() { return this.localName; }

get checked() { return this.getAttribute('checked'); }

set checked(flag) { this.toggleAttribute('checked', Boolean(flag)); }

attributeChangedCallback(name, oldValue, newValue) {

// name will always be "checked" due to observedAttributes this._internals.setFormValue(this.checked ? 'on' : null);

this._internals.ariaChecked = this.checked;

}

_onClick(event) {

this.checked = !this.checked;

}

}

699

customElements.define('my-checkbox', MyCheckbox); Note that, like for built-in elements, these are only defaults, and can be overridden by the page author using the p63 p63 role and aria-*

attributes:





Custom element authors are encouraged to state what aspects of their accessibility semantics are strong native semantics, i.e., should not be overriden by users of the custom element. In our example, the author of the my-checkbox element would state that its role and

aria-checked values are strong native semantics, thus discouraging code such as the above.



4.13.1.4 Creating a customized built-in element p70 §

0

This section is non-normative.

Customized built-in elements p705 p705 are a distinct kind of custom element, which are defined slightly differently and used very differently compared to p705 autonomous custom elements. They exist to allow reuse of behaviors from the existing elements of HTML, by extending those elements with new custom functionality. This is important since many of the existing behaviors of HTML elements can unfortunately not be duplicated by using purely p705 p705 autonomous custom elements . Instead, customized built-in elements allow the installation of custom construction behavior, lifecycle hooks, and prototype chain onto existing elements, essentially "mixing in" these capabilities on top of the already-existing element.

Customized built-in elements p705 p705 require a distinct syntax from autonomous custom elements because user agents and other software key off an element's local name in order to identify the element's semantics and behavior. That is, the concept of customized

built-in elements p705 building on top of existing behavior depends crucially on the extended elements retaining their original local name.

In this example, we'll be creating a p705 customized built-in element named plastic-button, which behaves like a normal button but gets fancy animation effects added whenever you click on it. We start by defining a class, just like before, although this time we extend

HTMLButtonElement p537 p125 instead of HTMLElement :

class PlasticButton extends HTMLButtonElement {

constructor() {

super();

this.addEventListener("click", () => {

// Draw some fancy animation effects!

});

}

}

When defining our custom element, we have to also specify the extends option:

customElements.define("plastic-button", PlasticButton, { extends: "button" }); In general, the name of the element being extended cannot be determined simply by looking at what element interface it extends, as many elements share the same interface (such as p248 p219 p219 q and blockquote both sharing HTMLQuoteElement ).

To construct our p705 p705 p536 customized built-in element from parsed HTML source text, we use the is attribute on a button element:

Click Me!

Trying to use a p705 p705 customized built-in element as an autonomous custom element will not work; that is, Click me? p125 will simply create an HTMLElement with no special behavior.

700

If you need to create a customized built-in element programmatically, you can use the following form of createElement():

const plasticButton = document.createElement("button", { is: "plastic-button" }); plasticButton.textContent = "Click me!"; And as before, the constructor will also work:

const plasticButton2 = new PlasticButton();

console.log(plasticButton2.localName); // will output "button" console.assert(plasticButton2 instanceof PlasticButton);

console.assert(plasticButton2 instanceof HTMLButtonElement); Note that when creating a customized built-in element programmatically, the p705 is attribute will not be present in the DOM, since it was not explicitly set. However, p1172 it will be added to the output when serializing:

console.assert(!plasticButton.hasAttribute("is"));

console.log(plasticButton.outerHTML); // will output ''

Regardless of how it is created, all of the ways in which p536 button is special apply to such "plastic buttons" as well: their focus behavior, ability to participate in p597 p571 form submission , the disabled attribute, and so on.

Customized built-in elements p705 are designed to allow extension of existing HTML elements that have useful user-agent supplied behavior or APIs. As such, they can only extend existing HTML elements defined in this specification, and cannot extend legacy elements such as p1223 p1224 p1223 p1223 p1224 p1223 p1224 bgsound , blink , isindex , keygen , multicol , nextid , or spacer that have been defined to use p125 HTMLUnknownElement as their element interface.

One reason for this requirement is future-compatibility: if a p705 customized built-in element was defined that extended a currently-unknown element, for example combobox, this would prevent this specification from defining a combobox element in the future, as consumers of the derived p705 customized built-in element would have come to depend on their base element having no interesting user-agent-supplied behavior.



4.13.1.5 Drawbacks of autonomous custom elements p70 §

1

This section is non-normative.

As specified below, and alluded to above, simply defining and using an element called taco-button does not mean that such elements

represent p124 buttons. That is, tools such as web browsers, search engines, or accessibility technology will not automatically treat the resulting element as a button just based on its defined name.

To convey the desired button semantics to a variety of users, while still using an p705 autonomous custom element, a number of techniques would need to be employed:

• The addition of the p776 p775 tabindex attribute would make the taco-button focusable. Note that if the taco-button were to

become logically disabled, the p776 tabindex attribute would need to be removed.

• The addition of an ARIA role and various ARIA states and properties helps convey semantics to accessibility technology. For

example, setting the role to "button" will convey the semantics that this is a button, enabling users to successfully interact

with the control using usual button-like interactions in their accessibility technology. Setting the aria-label property is

necessary to give the button an accessible name, instead of having accessibility technology traverse its child text nodes and

announce them. And setting the aria-disabled state to "true" when the button is logically disabled conveys to accessibility technology the button's disabled state.

• The addition of event handlers to handle commonly-expected button behaviors helps convey the semantics of the button to

web browser users. In this case, the most relevant event handler would be one that proxies appropriate keydown events to

become click events, so that you can activate the button both with keyboard and by clicking.

• In addition to any default visual styling provided for taco-button elements, the visual styling will also need to be updated to

reflect changes in logical state, such as becoming disabled; that is, whatever style sheet has rules for taco-button will also need to have rules for taco-button[disabled].

With these points in mind, a full-featured taco-button that took on the responsibility of conveying button semantics (including the

701

ability to be disabled) might look something like this:

class TacoButton extends HTMLElement {

static get observedAttributes() { return ["disabled"]; }

constructor() {

super();

this._internals = this.attachInternals();

this._internals.role = "button";

this.addEventListener("keydown", e => {

if (e.code === "Enter" || e.code === "Space") {

this.dispatchEvent(new PointerEvent("click", {

bubbles: true,

cancelable: true

}));

}

});

this.addEventListener("click", e => {

if (this.disabled) {

e.preventDefault();

e.stopImmediatePropagation();

}

});

this._observer = new MutationObserver(() => {

this._internals.ariaLabel = this.textContent;

});

}

connectedCallback() {

this.setAttribute("tabindex", "0");

this._observer.observe(this, {

childList: true,

characterData: true,

subtree: true

});

}

disconnectedCallback() {

this._observer.disconnect();

}

get disabled() {

return this.hasAttribute("disabled");

}

set disabled(flag) {

this.toggleAttribute("disabled", Boolean(flag));

}

attributeChangedCallback(name, oldValue, newValue) {

// name will always be "disabled" due to observedAttributes if (this.disabled) {

this.removeAttribute("tabindex");

this._internals.ariaDisabled = "true";

} else {

this.setAttribute("tabindex", "0");

this._internals.ariaDisabled = "false";

}

}

702

}

Even with this rather-complicated element definition, the element is not a pleasure to use for consumers: it will be continually

"sprouting" p776 tabindex attributes of its own volition, and its choice of tabindex="0" focusability behavior may not match the

button p536 behavior on the current platform. This is because as of now there is no way to specify default focus behavior for custom elements, forcing the use of the p776 tabindex attribute to do so (even though it is usually reserved for allowing the consumer to override default behavior).

In contrast, a simple p705 customized built-in element, as shown in the previous section, would automatically inherit the semantics and behavior of the p536 button element, with no need to implement these behaviors manually. In general, for any elements with nontrivial behavior and semantics that build on top of existing elements of HTML, p705 customized built-in elements will be easier to develop, maintain, and consume.



4.13.1.6 Upgrading elements after their creation p70 §

3

This section is non-normative.

Because p708 element definition can occur at any time, a non-custom element could be created, and then later become a custom

element p705 p707 after an appropriate definition is registered. We call this process "upgrading" the element, from a normal element into a custom element.

Upgrades p711 p707 enable scenarios where it may be preferable for custom element definitions to be registered after relevant elements have been initially created, such as by the parser. They allow progressive enhancement of the content in the custom element. For example, in the following HTML document the element definition for img-viewer is loaded asynchronously:





Image viewer example





The definition for the p614 p616 img-viewer element here is loaded using a script element marked with the async attribute, placed after the tag in the markup. While the script is loading, the img-viewer element will be treated as an undefined element, similar to a p280 span. Once the script loads, it will define the img-viewer element, and the existing img-viewer element on the page will be upgraded, applying the custom element's definition (which presumably includes applying an image filter identified by the string "Kelvin", enhancing the image's visual appearance).



Note that p711 upgrades only apply to elements in the document tree. (Formally, elements that are connected.) An element that is not inserted into a document will stay un-upgraded. An example illustrates this point:





Upgrade edge-cases example





4.13.2 Requirements for custom element constructors and reactions p70 §

4

When authoring p705 custom element constructors , authors are bound by the following conformance requirements:

• A parameter-less call to super() must be the first statement in the constructor body, to establish the correct prototype chain

and this value before any further code is run.

• A return statement must not appear anywhere inside the constructor body, unless it is a simple early-return (return or

return this).

• The constructor must not use the p958 p956 document.write() or document.open() methods.

• The element's attributes and children must not be inspected, as in the non- p711 upgrade case none will be present, and relying

on upgrades makes the element less usable.

• The element must not gain any attributes or children, as this violates the expectations of consumers who use the

createElement or createElementNS methods.

• In general, work should be deferred to connectedCallback as much as possible—especially work involving fetching

resources or rendering. However, note that connectedCallback can be called more than once, so any initialization work that is truly one-time will need a guard to prevent it from running twice.

• In general, the constructor should be used to set up initial state and default values, and to set up event listeners and

possibly a shadow root.

Several of these requirements are checked during element creation, either directly or indirectly, and failing to follow them will result in a custom element that cannot be instantiated by the parser or DOM APIs. This is true even if the work is done inside a constructor-

initiated p932 p936 microtask , as a microtask checkpoint can occur immediately after construction.

When authoring p714 custom element reactions, authors should avoid manipulating the node tree as this can lead to unexpected results.

Example

An element's connectedCallback can be queued before the element is disconnected, but as the callback queue is still processed,

it results in a connectedCallback for an element that is no longer connected:

class CParent extends HTMLElement {

connectedCallback() {

this.firstChild.remove();

}

}

customElements.define("c-parent", CParent);

class CChild extends HTMLElement {

connectedCallback() {

console.log("CChild connectedCallback: isConnected =", this.isConnected);

}

}

704

customElements.define("c-child", CChild);

const parent = new CParent(),

child = new CChild();

parent.append(child);

document.body.append(parent);

// Logs:

// CChild connectedCallback: isConnected = false



4.13.3 Core concepts p70 §

5

A custom element is an element that is custom. Informally, this means that its constructor and prototype are defined by the author, instead of by the user agent. This author-supplied constructor function is called the custom element constructor.

MDN

Two distinct types of p705 custom elements can be defined:

1. An autonomous custom element, which is defined with no extends option. These types of custom elements have a local

name equal to their p707 defined name.

2. A customized built-in element, which is defined with an extends option. These types of custom elements have a local

name equal to the value passed in their p707 extends option, and their defined name is used as the value of the is attribute,

which therefore must be a p706 valid custom element name.

After a p705 p705 custom element is created , changing the value of the is attribute does not change the element's behavior, as it is saved on the element as its is value.

Autonomous custom elements p705 have the following element definition:

Categories p129:

Flow content p132 .

Phrasing content p133.

Palpable content p134.

For p706 p487 p487 p487 p487 form-associated custom elements : Listed , labelable , submittable , and resettable form-associated

element p487.

Contexts in which this element can be used p129 :

Where p133 phrasing content is expected.

Content model p129:

Transparent p134 .

Content attributes p129:

Global attributes p137 p705 , except the is attribute

form p567 p706 p487 , for form-associated custom elements — Associates the element with a form element

disabled p571 p706 , for form-associated custom elements — Whether the form control is disabled

readonly p706 p706 p594 , for form-associated custom elements — Affects willValidate, plus any behavior added by the custom element author

name p569 p706 p596 , for form-associated custom elements — Name of the element to use for form submission and in the

form.elements p489 API

Any other attribute that has no namespace (see prose).

Accessibility considerations p130:

For p706 form-associated custom elements: for authors; for implementers.

Otherwise: for authors; for implementers.

DOM interface p130:

Supplied by the element's author (inherits from p125 HTMLElement )

An p705 p124 p705 autonomous custom element does not have any special meaning: it represents its children. A customized built-in element

705

inherits the semantics of the element that it extends.

Any namespace-less attribute that is relevant to the element's functioning, as determined by the element's author, may be specified on an p705 p44 autonomous custom element , so long as the attribute name is XML-compatible and contains no ASCII upper alphas. The

exception is the p705 p705 is attribute, which must not be specified on an autonomous custom element (and which will have no effect if it is).

Customized built-in elements p705 follow the normal requirements for attributes, based on the elements they extend. To add custom attribute-based behavior, use p146 data-* attributes.



An p705 autonomous custom element is called a form-associated custom element if the element is associated with a custom element

definition p707 p707 whose form-associated field is set to true.

The p569 p706 p571 name attribute represents the form-associated custom element 's name. The disabled attribute is used to make the form-

associated custom element p706 p718 p567 non-interactive and to prevent its submission value from being submitted. The form attribute is used to explicitly associate the p706 p567 form-associated custom element with its form owner .

The p706 p591 readonly attribute of form-associated custom elements specifies that the element is barred from constraint validation. User

agents don't provide any other behavior for the attribute, but custom element authors should, where possible, use its presence to make their control non-editable in some appropriate fashion, similar to the behavior for the p523 readonly attribute on built-in form controls.

Constraint validation p706 p706 : If the readonly attribute is specified on a form-associated custom element, the element is barred from

constraint validation p591 .

The p605 p706 p715 reset algorithm for form-associated custom elements is to enqueue a custom element callback reaction with the element, callback name "formResetCallback", and an empty argument list.



A valid custom element name is a sequence of characters name that meets all of the following requirements:

• p706 name must match the PotentialCustomElementName production:

PotentialCustomElementName ::=

[a-z] ( p706 p706 PCENChar )* '-' ( PCENChar)*

PCENChar ::=

"-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

This uses the p1283 EBNF notation from the XML specification. [XML]

• name must not be any of the following:

◦ annotation-xml

◦ color-profile

◦ font-face

◦ font-face-src

◦ font-face-uri

◦ font-face-format

◦ font-face-name

◦ missing-glyph

Note

The list of names above is the summary of all hyphen-containing element names from the p65 applicable specifications,

namely p1281 p1279 SVG 2 and MathML . [SVG] [MATHML]



Note

These requirements ensure a number of goals for p706 valid custom element names:

• They start with an ASCII lower alpha, ensuring that the HTML parser will treat them as tags instead of as text.

• They do not contain any ASCII upper alphas, ensuring that the user agent can always treat HTML elements ASCII-case-

706

insensitively.

• They contain a hyphen, used for namespacing and to ensure forward compatibility (since no elements will be added to

HTML, SVG, or MathML with hyphen-containing local names in the future).

• They can always be created with createElement() and createElementNS(), which have restrictions that go beyond the

parser's.

Apart from these restrictions, a large variety of names is allowed, to give maximum flexibility for use cases like or

.

A p705 custom element definition describes a custom element and consists of: A name

A p706 valid custom element name

A local name

A local name

A constructor

A Web IDL p708 p705 CustomElementConstructor callback function type value wrapping the custom element constructor

A list of observed attributes

A sequence

A collection of lifecycle callbacks

A map, whose keys are the strings "connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback", "formAssociatedCallback", "formDisabledCallback", "formResetCallback", and

"formStateRestoreCallback". The corresponding values are either a Web IDL Function callback function type value, or null. By default the value of each entry is null.

A construction stack

A list, initially empty, that is manipulated by the p711 p126 upgrade an element algorithm and the HTML element constructors . Each entry in the list will be either an element or an already constructed marker.

A form-associated boolean

If this is true, user agent treats elements associated to this p707 p706 custom element definition as form-associated custom elements.

A disable internals boolean

Controls p716 attachInternals() .

A disable shadow boolean

Controls attachShadow().

To look up a custom element definition, given a document, namespace, localName, and is, perform the following steps. They will return either a p707 custom element definition or null:

1. If namespace is not the HTML namespace, return null.

2. If p814 document 's browsing context is null, return null.

3. Let p911 p708 registry be document 's relevant global object 's CustomElementRegistry object.

4. If there is p707 p707 p707 custom element definition in registry with name and local name both equal to localName, return that

custom element definition p707.

5. If there is a p707 p707 p707 custom element definition in registry with name equal to is and local name equal to localName, return

that p707 custom element definition.

6. Return null.



707

4.13.4 The p708 p70 CustomElementRegistry interface §

8

Each p828 p708 p828 Window object is associated with a unique instance of a CustomElementRegistry object, allocated when the Window

object is created.

Note

Custom element registries are associated with p828 p115 Window objects, instead of Document objects, since each custom element

constructor p705 p125 p125 p828 inherits from the HTMLElement interface, and there is exactly one HTMLElement interface per Window

object. ✔ MDN



The p828 p708 p828 customElements attribute of the Window interface must return the CustomElementRegistry object for that Window ✔ MDN

object.

IDL [Exposed=Window]

interface CustomElementRegistry {

[CEReactions] undefined define(DOMString name, CustomElementConstructor constructor, optional

ElementDefinitionOptions options = {});

(CustomElementConstructor or undefined) get(DOMString name);

Promise<CustomElementConstructor> whenDefined(DOMString name);

[CEReactions] undefined upgrade(Node root);

};

callback CustomElementConstructor = HTMLElement ();

dictionary ElementDefinitionOptions {

DOMString extends;

};

Every p708 p707 CustomElementRegistry has a set of custom element definitions, initially empty. In general, algorithms in this specification look up elements in the registry by any of p707 p707 p707 name , local name , or constructor.

Every p708 CustomElementRegistry also has an element definition is running flag which is used to prevent reentrant invocations of

element definition p708. It is initially unset.

Every p708 p706 CustomElementRegistry also has a when-defined promise map , mapping valid custom element names to promises. It is used to implement the p710 whenDefined() method.

For web developers (non-normative)

window p708 p708 . customElements . define(name, constructor)

Defines a new p705 p705 custom element , mapping the given name to the given constructor as an autonomous custom element.

window p708 p708 . customElements . define(name, constructor, { extends: baseLocalName })

Defines a new p705 p705 custom element , mapping the given name to the given constructor as a customized built-in element for

the p44 element type identified by the supplied baseLocalName. A "NotSupportedError" DOMException will be thrown upon

trying to extend a p705 custom element or an unknown element.

window p708 p710 . customElements . get(name)

Retrieves the p705 p707 custom element constructor defined for the given name. Returns undefined if there is no custom element

definition p707 p707 with the given name.

window p708 p710 . customElements . whenDefined(name)

Returns a promise that will be fulfilled with the p705 p705 custom element 's constructor when a custom element becomes defined

with the given name. (If such a p705 custom element is already defined, the returned promise will be immediately fulfilled.)

Returns a promise rejected with a p706 " SyntaxError " DOMException if not given a valid custom element name .

window p708 p711 . customElements . upgrade(root)

Tries to upgrade p713 all shadow-including inclusive descendant elements of root, even if they are not connected.



Element definition p707 p708 is a process of adding a custom element definition to the CustomElementRegistry. This is accomplished by ✔ MDN

the p708 define() method. When invoked, the define(name, constructor, options) method must run these steps:

1. If IsConstructor(constructor) is false, then throw a TypeError.

708

2. If p706 name is not a valid custom element name , then throw a "SyntaxError" DOMException.

3. If this p708 p707 CustomElementRegistry contains an entry with name name, then throw a "NotSupportedError"

DOMException.

4. If this p708 p707 CustomElementRegistry contains an entry with constructor constructor, then throw a "NotSupportedError"

DOMException.

5. Let localName be name.

6. Let extends be the value of the extends member of options, or null if no such member exists.

7. If extends is not null, then:

1. If p706 extends is a valid custom element name, then throw a "NotSupportedError" DOMException.

2. If the p125 element interface for extends and the HTML namespace is HTMLUnknownElement (e.g., if extends does not

indicate an element definition in this specification), then throw a "NotSupportedError" DOMException.

3. Set localName to extends.

8. If this p708 p708 CustomElementRegistry 's element definition is running flag is set, then throw a "NotSupportedError"

DOMException.

9. Set this p708 p708 CustomElementRegistry 's element definition is running flag.

10. Let formAssociated be false.

11. Let disableInternals be false.

12. Let disableShadow be false.

13. Let observedAttributes be an empty sequence.

14. Run the following substeps while catching any exceptions:

1. Let prototype be Get(constructor, "prototype"). Rethrow any exceptions.

2. If Type(prototype) is not Object, then throw a TypeError exception.

3. Let lifecycleCallbacks be a map with the keys "connectedCallback", "disconnectedCallback",

"adoptedCallback", and "attributeChangedCallback", each of which belongs to an entry whose value is null.

4. For each of the keys callbackName in lifecycleCallbacks, in the order listed in the previous step:

1. Let callbackValue be Get(prototype, callbackName). Rethrow any exceptions.

2. If callbackValue is not undefined, then set the value of the entry in lifecycleCallbacks with key

callbackName to the result of converting callbackValue to the Web IDL Function callback type. Rethrow any exceptions from the conversion.

5. If the value of the entry in lifecycleCallbacks with key "attributeChangedCallback" is not null, then:

1. Let observedAttributesIterable be Get(constructor, "observedAttributes"). Rethrow any exceptions.

2. If observedAttributesIterable is not undefined, then set observedAttributes to the result of converting

observedAttributesIterable to a sequence. Rethrow any exceptions from the conversion.

6. Let disabledFeatures be an empty sequence.

7. Let disabledFeaturesIterable be Get(constructor, "disabledFeatures"). Rethrow any exceptions.

8. If disabledFeaturesIterable is not undefined, then set disabledFeatures to the result of converting

disabledFeaturesIterable to a sequence. Rethrow any exceptions from the conversion.

9. Set disableInternals to true if disabledFeatures contains "internals".

10. Set disableShadow to true if disabledFeatures contains "shadow".

11. Let formAssociatedValue be Get( constructor, "formAssociated"). Rethrow any exceptions.

12. Set formAssociated to the result of converting formAssociatedValue to a boolean. Rethrow any exceptions from the

709

conversion.

13. If formAssociated is true, for each of "formAssociatedCallback", "formResetCallback",

"formDisabledCallback", and "formStateRestoreCallback" callbackName:

1. Let callbackValue be Get(prototype, callbackName). Rethrow any exceptions.

2. If callbackValue is not undefined, then set the value of the entry in lifecycleCallbacks with key

callbackName to the result of converting callbackValue to the Web IDL Function callback type. Rethrow any exceptions from the conversion.

Then, perform the following substep, regardless of whether the above steps threw an exception or not:

1. Unset this p708 p708 CustomElementRegistry 's element definition is running flag.

Finally, if the first set of substeps threw an exception, then rethrow that exception (thus terminating this algorithm). Otherwise, continue onward.

15. Let p707 p707 p707 p707 definition be a new custom element definition with name name , local name localName , constructor

constructor p707 p707 p707 , observed attributes observedAttributes , lifecycle callbacks lifecycleCallbacks , form-associated

formAssociated p707 p707 , disable internals disableInternals , and disable shadow disableShadow.

16. Add p708 definition to this CustomElementRegistry.

17. Let p708 p911 p829 document be this CustomElementRegistry 's relevant global object 's associated Document .

18. Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML

namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only

include elements whose is value is equal to name.

19. For each element p715 element in upgrade candidates , enqueue a custom element upgrade reaction given element and

definition.

20. If this p708 p708 CustomElementRegistry 's when-defined promise map contains an entry with key name:

1. Let promise be the value of that entry.

2. Resolve promise with constructor.

3. Delete the entry with key p708 p708 name from this CustomElementRegistry 's when-defined promise map.

When invoked, the get(name) method must run these steps: ✔ MDN

1. If this p708 p707 p707 CustomElementRegistry contains an entry with name name , then return that entry's constructor .

2. Otherwise, return undefined.

When invoked, the whenDefined(name) method must run these steps: ✔ MDN

1. If p706 name is not a valid custom element name , then return a new promise rejected with a "SyntaxError" DOMException.

2. If this p708 p707 CustomElementRegistry contains an entry with name name, then return a new promise resolved with that

entry's p707 constructor.

3. Let p708 p708 map be this CustomElementRegistry 's when-defined promise map.

4. If map does not contain an entry with key name, create an entry in map with key name and whose value is a new promise.

5. Let promise be the value of the entry in map with key name.

6. Return promise.

Example

The p710 p705 whenDefined() method can be used to avoid performing an action until all appropriate custom elements are defined. In

this example, we combine it with the p728 :defined pseudo-class to hide a dynamically-loaded article's contents until we're sure

that all of the p705 autonomous custom elements it uses are defined.

articleContainer.hidden = true;

710

fetch(articleURL)

.then(response => response.text())

.then(text => {

articleContainer.innerHTML = text;

return Promise.all(

[...articleContainer.querySelectorAll(":not(:defined)")]

.map(el => customElements.whenDefined(el.localName))

);

})

.then(() => {

articleContainer.hidden = false;

});



When invoked, the upgrade(root) method must run these steps: MDN

1. Let candidates be a list of all of root's shadow-including inclusive descendant elements, in shadow-including tree order.

2. p713 For each candidate of candidates , try to upgrade candidate.

Example

The p711 upgrade() method allows upgrading of elements at will. Normally elements are automatically upgraded when they become

connected, but this method can be used if you need to upgrade before you're ready to connect the element.

const el = document.createElement("spider-man");

class SpiderMan extends HTMLElement {}

customElements.define("spider-man", SpiderMan);

console.assert(!(el instanceof SpiderMan)); // not yet upgraded

customElements.upgrade(el);

console.assert(el instanceof SpiderMan); // upgraded!



4.13.5 Upgrades p71 §

1

To p707 upgrade an element , given as input a custom element definition definition and an element element, run the following steps:

1. If element's custom element state is not "undefined" or "uncustomized", then return.

Example

One scenario where this can occur due to reentrant invocation of this algorithm, as in the following example:





This step will thus bail out the algorithm early when p711 upgrade an element is invoked with "b" a second time.

2. Set element's custom element definition to definition.

3. Set element's custom element state to "failed".

Note

It will be set to " p713 custom " after the upgrade succeeds . For now, we set it to "failed" so that any reentrant invocations

will hit p711 the above early-exit step.

4. For each p715 attribute in element 's attribute list , in order, enqueue a custom element callback reaction with element, callback

name "attributeChangedCallback", and an argument list containing attribute's local name, null, attribute's value, and attribute's namespace.

5. If p715 element is connected , then enqueue a custom element callback reaction with element, callback name

"connectedCallback", and an empty argument list.

6. Add p707 element to the end of definition 's construction stack.

7. Let p707 C be definition 's constructor .

8. Run the following substeps while catching any exceptions:

1. If p707 definition 's disable shadow is true and element's shadow root is non-null, then throw a "NotSupportedError"

DOMException.

Note

This is needed as p707 attachShadow() does not use look up a custom element definition while

attachInternals() p716 does.

2. Set element's custom element state to "precustomized".

3. Let constructResult be the result of constructing C, with no arguments.

Note

If p704 p715 C non-conformantly uses an API decorated with the [CEReactions] extended attribute, then the reactions enqueued at the beginning of this algorithm will execute during this step, before C finishes and control returns to this algorithm. Otherwise, they will execute after C and the rest of the upgrade process finishes.

4. If SameValue(constructResult, element) is false, then throw a TypeError.

Note

This can occur if C constructs another instance of the same custom element before calling super(), or if C uses

JavaScript's p125 return-override feature to return an arbitrary HTMLElement object from the constructor.

Then, perform the following substep, regardless of whether the above steps threw an exception or not:

1. Remove the last entry from the end of p707 definition 's construction stack.

Note



712

Assuming p704 C calls super() (as it will if it is conformant ), and that the call succeeds, this will be the already

constructed p707 marker that replaced the element we pushed at the beginning of this algorithm. (The HTML

element constructor p126 carries out this replacement.)

If p704 p126 C does not call super() (i.e. it is not conformant ), or if any step in the HTML element constructor throws, then this entry will still be element.

Finally, if the above steps threw an exception, then:

1. Set element's custom element definition to null.

2. Empty p714 element 's custom element reaction queue .

3. Rethrow the exception (thus terminating this algorithm).

Note

If the above steps threw an exception, then element's custom element state will remain "failed" or "precustomized".

9. If p706 element is a form-associated custom element , then:

1. p568 p487 Reset the form owner of element . If element is associated with a form element, then enqueue a custom

element callback reaction p715 with element, callback name "formAssociatedCallback", and « the associated

form p487 ».

2. If p571 p715 element is disabled , then enqueue a custom element callback reaction with element, callback name

"formDisabledCallback" and « true ».

10. Set element's custom element state to "custom".

To try to upgrade an element, given as input an element element, run the following steps:

1. Let p707 definition be the result of looking up a custom element definition given element's node document, element's

namespace, element's local name, and element's is value.

2. If p715 definition is not null, then enqueue a custom element upgrade reaction given element and definition.



4.13.6 Custom element reactions p71 §

3

A p705 custom element possesses the ability to respond to certain occurrences by running author code:

• When p711 p705 upgraded , its constructor is run, with no arguments.

• When it p45 becomes connected, its connectedCallback is called, with no arguments.

• When it p45 becomes disconnected, its disconnectedCallback is called, with no arguments.

• When it is adopted into a new document, its adoptedCallback is called, given the old document and new document as

arguments.

• When any of its attributes are changed, appended, removed, or replaced, its attributeChangedCallback is called, given the

attribute's local name, old value, new value, and namespace as arguments. (An attribute's old or new value is considered to be null when the attribute is added or removed, respectively.)

• When the user agent p568 p706 resets the form owner of a form-associated custom element and doing so changes the form

owner, its formAssociatedCallback is called, given the new form owner (or null if no owner) as an argument.

• When the form owner of a p706 p604 form-associated custom element is reset, its formResetCallback is called.

• When the p571 p706 disabled state of a form-associated custom element is changed, its formDisabledCallback is called, given

the new state as an argument.

• When user agent updates a p706 form-associated custom element 's value on behalf of a user, its formStateRestoreCallback

is called, given the new value and a string indicating a reason, "restore" or "autocomplete", as arguments.



713

We call these reactions collectively custom element reactions.

The way in which p714 custom element reactions are invoked is done with special care, to avoid running author code during the middle of delicate operations. Effectively, they are delayed until "just before returning to user script". This means that for most purposes they appear to execute synchronously, but in the case of complicated composite operations (like cloning, or range manipulation), they will instead be delayed until after all the relevant user agent processing steps have completed, and then run together as a batch.

Additionally, the precise ordering of these reactions is managed via a somewhat-complicated stack-of-queues system, described below.

The intention behind this system is to guarantee that p714 custom element reactions always are invoked in the same order as their triggering actions, at least within the local context of a single p705 p714 custom element . (Because custom element reaction code can perform its own mutations, it is not possible to give a global ordering guarantee across multiple elements.)



Each p900 similar-origin window agent has a custom element reactions stack, which is initially empty. A similar-origin window

agent p900 p714 p714 's current element queue is the element queue at the top of its custom element reactions stack. Each item in the

stack is an p714 element queue , which is initially empty as well. Each item in an element queue is an element. (The elements are not necessarily p711 custom yet, since this queue is used for upgrades as well.) Each p714 p714 custom element reactions stack has an associated backup element queue , which an initially-empty element queue.

Elements are pushed onto the p714 backup element queue during operations that affect the DOM without going through an API decorated with p715 p1124 [CEReactions] , or through the parser's create an element for the token algorithm. An example of this is a user-

initiated editing operation which modifies the descendants or attributes of an editable element. To prevent reentrancy when processing the p714 p714 backup element queue , each custom element reactions stack also has a processing the backup element queue flag, initially unset.

All elements have an associated custom element reaction queue, initially empty. Each item in the custom element reaction

queue p714 is of one of two types:

• An p711 p707 upgrade reaction , which will upgrade the custom element and contains a custom element definition ; or

• A callback reaction, which will call a lifecycle callback, and contains a callback function as well as a list of arguments.

This is all summarized in the following schematic diagram:



custom element

reactions stack element queue



⋯



⋯

custom element reaction queue

Attribute Attribute

Upgrade changed changed Connected



processing backup

backup element queue element queue flag



To enqueue an element on the appropriate element queue, given an element element, run the following steps:

1. Let p901 p714 reactionsStack be element 's relevant agent 's custom element reactions stack.

714

2. If reactionsStack is empty, then:

1. Add p714 element to reactionsStack 's backup element queue .

2. If p714 reactionsStack 's processing the backup element queue flag is set, then return.

3. Set p714 reactionsStack 's processing the backup element queue flag.

4. p933 Queue a microtask to perform the following steps:

1. p715 p714 Invoke custom element reactions in reactionsStack 's backup element queue .

2. Unset p714 reactionsStack 's processing the backup element queue flag.

3. Otherwise, add p901 p714 element to element 's relevant agent 's current element queue.

To p705 enqueue a custom element callback reaction , given a custom element element, a callback name callbackName, and a list of arguments args, run the following steps:

1. Let definition be element's custom element definition.

2. Let p707 callback be the value of the entry in definition 's lifecycle callbacks with key callbackName.

3. If callback is null, then return

4. If callbackName is "attributeChangedCallback", then:

1. Let attributeName be the first element of args.

2. If p707 definition 's observed attributes does not contain attributeName, then return.

5. Add a new p714 p714 callback reaction to element 's custom element reaction queue, with callback function callback and

arguments args.

6. p714 Enqueue an element on the appropriate element queue given element.

To p707 enqueue a custom element upgrade reaction , given an element element and custom element definition definition, run the following steps:

1. Add a new p714 p714 p707 upgrade reaction to element 's custom element reaction queue , with custom element definition

definition.

2. p714 Enqueue an element on the appropriate element queue given element.

To p714 invoke custom element reactions in an element queue queue, run the following steps:

1. For each p705 custom element element in queue:

1. Let p714 reactions be element 's custom element reaction queue .

2. Repeat until reactions is empty:

1. Remove the first element of reactions, and let reaction be that element. Switch on reaction's type:

↪ p714 upgrade reaction

Upgrade p711 p707 element using reaction 's custom element definition.

↪ p714 callback reaction

Invoke reaction's callback function with reaction's arguments, and with element as the callback

this value.

If this throws an exception, catch it, and p924 report the exception.



To ensure p714 custom element reactions are triggered appropriately, we introduce the [CEReactions] IDL extended attribute. It indicates that the relevant algorithm is to be supplemented with additional steps in order to appropriately track and invoke custom

element reactions p714.

The p715 [CEReactions] extended attribute must take no arguments, and must not appear on anything other than an operation, attribute, setter, or deleter. Additionally, it must not appear on readonly attributes.

715

Operations, attributes, setters, or deleters annotated with the p715 [CEReactions] extended attribute must run the following steps in place of the ones specified in their description:

1. p714 p901 p714 Push a new element queue onto this object's relevant agent 's custom element reactions stack .

2. Run the originally-specified steps for this construct, catching any exceptions. If the steps return a value, let value be the

returned value. If they throw an exception, let exception be the thrown exception.

3. Let p901 p714 queue be the result of popping from this object's relevant agent 's custom element reactions stack.

4. p715 Invoke custom element reactions in queue.

5. If an exception exception was thrown by the original steps, rethrow exception.

6. If a value value was returned from the original steps, return value.

Note

The intent behind this extended attribute is somewhat subtle. One way of accomplishing its goals would be to say that every

operation, attribute, setter, and deleter on the platform must have these steps inserted, and to allow implementers to optimize

away unnecessary cases (where no DOM mutation is possible that could cause p714 custom element reactions to occur).

However, in practice this imprecision could lead to non-interoperable implementations of p714 custom element reactions , as some

implementations might forget to invoke these steps in some cases. Instead, we settled on the approach of explicitly annotating all

relevant IDL constructs, as a way of ensuring interoperable behavior and helping implementations easily pinpoint all cases where

these steps are necessary.

Any nonstandard APIs introduced by the user agent that could modify the DOM in such a way as to cause enqueuing a custom element

callback reaction p715 p715 or enqueuing a custom element upgrade reaction , for example by modifying any attributes or child elements, must also be decorated with the p715 [CEReactions] attribute.

Note

As of the time of this writing, the following nonstandard or not-yet-standardized APIs are known to fall into this category:

• p125 HTMLElement's outerText IDL attribute

• p495 HTMLInputElement's webkitdirectory and incremental IDL attributes

• p158 HTMLLinkElement 's scope IDL attribute

• ShadowRoot's innerHTML IDL attribute



4.13.7 Element internals p71 §

6

Certain capabilities are meant to be available to a custom element author, but not to a custom element consumer. These are provided by the p716 p717 element.attachInternals() method, which returns an instance of ElementInternals. The properties and methods of

ElementInternals p717 allow control over internal features which the user agent provides to all elements.

For web developers (non-normative)

element p716 . attachInternals()

Returns an p717 p705 ElementInternals object targeting the custom element element. Throws an exception if element is not a

custom element p705, if the "internals" feature was disabled as part of the element definition, or if it is called twice on the same element.

Each p125 HTMLElement has an attached internals boolean, initially false.

The attachInternals() method steps are:

1. If this's is value is not null, then throw a "NotSupportedError" DOMException.

2. Let p707 definition be the result of looking up a custom element definition given this's node document, its namespace, its local

name, and null as the is value.

716

3. If definition is null, then throw an "NotSupportedError" DOMException.

4. If p707 definition 's disable internals is true, then throw a "NotSupportedError" DOMException.

5. If p716 this 's attached internals is true, then throw an "NotSupportedError" DOMException.

6. If this's custom element state is not "precustomized" or "custom", then throw a "NotSupportedError" DOMException.

7. Set p716 this 's attached internals to true.

8. Return a new p717 p717 ElementInternals instance whose target element is this.



4.13.7.1 The p717 p71 ElementInternals interface §

7

The IDL for the p717 ElementInternals interface is as follows, with the various operations and attributes defined in the following sections:

IDL [Exposed=Window]

interface ElementInternals {

// Shadow root access

readonly attribute ShadowRoot? shadowRoot;

// Form-associated custom elements

undefined setFormValue((File or USVString or FormData)? value,

optional (File or USVString or FormData)? state);

readonly attribute HTMLFormElement? form;

undefined setValidity(optional ValidityStateFlags flags = {},

optional DOMString message,

optional HTMLElement anchor);

readonly attribute boolean willValidate;

readonly attribute ValidityState validity;

readonly attribute DOMString validationMessage;

boolean checkValidity();

boolean reportValidity();

readonly attribute NodeList labels;

};

// Accessibility semantics

ElementInternals includes ARIAMixin;

dictionary ValidityStateFlags {

boolean valueMissing = false;

boolean typeMismatch = false;

boolean patternMismatch = false;

boolean tooLong = false;

boolean tooShort = false;

boolean rangeUnderflow = false;

boolean rangeOverflow = false;

boolean stepMismatch = false;

boolean badInput = false;

boolean customError = false;

};

Each p717 p705 ElementInternals has a target element , which is a custom element .



717

4.13.7.2 Shadow root access p71 §

8

For web developers (non-normative)

internals p718 . shadowRoot

Returns the p717 p717 ShadowRoot for internals 's target element , if the target element is a shadow host, or null otherwise.

The shadowRoot getter steps are:

1. Let p717 target be this 's target element.

2. If target is not a shadow host, then return null.

3. Let shadow be target's shadow root.

4. If shadow's available to element internals is false, then return null.

5. Return shadow.



4.13.7.3 Form-associated custom elements p71 §

8

For web developers (non-normative)

internals p719 . setFormValue(value)

Sets both the p719 p718 p717 state and submission value of internals 's target element to value. If value is null, the element won't participate in form submission.

internals p719 . setFormValue(value, state)

Sets the p718 p717 p719 submission value of internals 's target element to value , and its state to state. If value is null, the element won't participate in form submission.

internals p569 . form

Returns the p567 p717 form owner of internals 's target element.

internals p719 . setValidity(flags, message [, anchor ])

Marks p717 internals 's target element as suffering from the constraints indicated by the flags argument, and sets the element's validation message to message. If anchor is specified, the user agent might use it to indicate problems with the constraints of

internals p717 p567 p596 's target element when the form owner is validated interactively or reportValidity() is called.

internals p719 . setValidity({})

Marks p717 p592 internals 's target element as satisfying its constraints .

internals p594 . willValidate

Returns true if p717 internals 's target element will be validated when the form is submitted; false otherwise.

internals p594 . validity

Returns the p594 p717 ValidityState object for internals 's target element .

internals p720 . validationMessage

Returns the error message that would be shown to the user if p717 internals 's target element was to be checked for validity.

valid p595 = internals . checkValidity()

Returns true if p717 p1271 internals 's target element has no validity problems; false otherwise. Fires an invalid event at the element in the latter case.

valid p596 = internals . reportValidity()

Returns true if p717 p1271 internals 's target element has no validity problems; otherwise, returns false, fires an invalid event at the element, and (if the event isn't canceled) reports the problem to the user.

internals p493 . labels

Returns a p491 p717 NodeList of all the label elements that internals 's target element is associated with.

Each p706 form-associated custom element has submission value. It is used to provide one or more entries on form submission. The initial value of p718 p718 submission value is null, and submission value can be null, a string, a File, or a list of entries.

718

Each p706 form-associated custom element has state. It is information with which the user agent can restore a user's input for the element. The initial value of p719 p719 state is null, and state can be null, a string, a File, or a list of entries.

The p719 p718 p719 setFormValue() method is used by the custom element author to set the element's submission value and state, thus communicating these to the user agent.

When the user agent believes it is a good idea to restore a p706 p719 form-associated custom element 's state, for example after navigation or restarting the user agent, they may p715 enqueue a custom element callback reaction with that element, callback name "formStateRestoreCallback", and an argument list containing the state to be restored, and "restore".

If the user agent has a form-filling assist feature, then when the feature is invoked, it may enqueue a custom element callback

reaction p715 p706 with a form-associated custom element, callback name "formStateRestoreCallback", and an argument list containing the state value determined by history of state value and some heuristics, and "autocomplete".

In general, the p719 p718 state is information specified by a user, and the submission value is a value after canonicalization or sanitization, suitable for submission to the server. The following examples makes this concrete: Example

Suppose that we have a p706 form-associated custom element which asks a user to specify a date. The user specifies "3/15/2019",

but the control wishes to submit p719 "2019-03-15" to the server. "3/15/2019" would be a state of the element, and "2019-03-15"

would be a p718 submission value .



Example

Suppose you develop a custom element emulating a the behavior of the existing p514 p494 checkbox input type. Its submission

value p718 p719 would be the value of its value content attribute, or the string "on" . Its state would be one of "checked",

"unchecked", "checked/indeterminate", or "unchecked/indeterminate".

The setFormValue(value, state) method steps are:

1. Let p717 element be this 's target element.

2. If p706 element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.

3. Set p717 p718 target element 's submission value to value if value is not a FormData object, or to a clone of the entry list

associated with value otherwise.

4. If the p719 p718 state argument of the function is omitted, set element 's state to its submission value.

5. Otherwise, if p719 state is a FormData object, set element 's state to clone of the entry list associated with state.

6. Otherwise, set p719 element 's state to state.



Each p706 form-associated custom element has validity flags named valueMissing, typeMismatch, patternMismatch, tooLong, tooShort, rangeUnderflow, rangeOverflow, stepMismatch, and customError. They are false initially.

Each p706 form-associated custom element has a validation message string. It is the empty string initially.

Each p706 form-associated custom element has a validation anchor element. It is null initially.

The setValidity(flags, message, anchor) method steps are:

1. Let p717 element be this 's target element.

2. If p706 element is not a form-associated custom element, then throw a "NotSupportedError" DOMException.

3. If flags contains one or more true values and message is not given or is the empty string, then throw a TypeError.

4. For each entry flag → value of flags, set element's validity flag with the name flag to value.

5. Set p719 element 's validation message to the empty string if message is not given or all of element's validity flags are false, or

to message otherwise.

6. If p591 element 's customError validity flag is true, then set element 's custom validity error message to element's validation

message p719 p591 . Otherwise, set element 's custom validity error message to the empty string.

719

7. Set p719 element 's validation anchor to null if anchor is not given. Otherwise, if anchor is not a shadow-including descendant

of p719 element , then throw a " NotFoundError " DOMException . Otherwise, set element 's validation anchor to anchor.

The p719 p717 validationMessage getter steps are to return the validation message of this 's target element.

The p706 entry construction algorithm for a form-associated custom element, given an element element and a list entry list, consists of the following steps:

1. If p718 p718 element 's submission value is a list of entries , then append each item of element 's submission value to entry list,

and return.

Note

In this case, user agent does not refer to the p569 name content attribute value. An implementation of form-associated

custom element p706 p569 is responsible to decide names of entries . They can be the name content attribute value, they can

be strings based on the p569 p569 name content attribute value, or they can be unrelated to the name content attribute.

2. If the element does not have a p569 p569 name attribute specified, or its name attribute's value is the empty string, then return.

3. If the element's p718 p602 p569 submission value is not null, append an entry to entry list with the name attribute value and the

submission value p718.



4.13.7.4 Accessibility semantics p72 §

0

For web developers (non-normative)

internals p0 . role [ = value ]

Sets or retrieves the default ARIA role for p717 internals 's target element, which will be used unless the page author overrides it

using the p63 role attribute.

internals p0 . aria* [ = value ]

Sets or retrieves various default ARIA states or property values for p717 internals 's target element , which will be used unless the

page author overrides them using the p63 aria-* attributes.

Each p705 p443 custom element has a native accessibility semantics map , which is a map, initially empty. See the Requirements

related to ARIA and to platform accessibility APIs p152 section for information on how this impacts platform accessibility APIs.

ElementInternals p717 includes the ARIAMixin mixin. The accessors provided by this mixin are used to manipulate the target

element p717 p720 's native accessibility semantics map , as follows:

The p717 ARIAMixin getter steps for ElementInternals, given internals, idlAttribute, and contentAttribute, are:

1. Let p717 p720 map be internals 's target element 's native accessibility semantics map .

2. If map[contentAttribute] exists, then return it.

3. Return null.

The p717 ARIAMixin setter steps for ElementInternals , given internals, idlAttribute, contentAttribute, and value, are:

1. Let p717 p720 map be internals 's target element 's native accessibility semantics map .

2. If value is null, then remove map[contentAttribute].

3. Otherwise, set map[contentAttribute] to value.



4.14 Common idioms without dedicated elements p72 §

0

4.14.1 Bread crumb navigation p72 §

0

This specification does not provide a machine-readable way of describing bread-crumb navigation menus. Authors are encouraged to just use a series of links in a paragraph. The p186 nav element can be used to mark the section containing these paragraphs as being

720

navigation blocks.

Example

In the following example, the current page can be reached via two paths.





Main ▸

Products ▸

Dishwashers ▸

Second hand





Main ▸

Second hand ▸

Dishwashers





4.14.2 Tag clouds p72 §

1

This specification does not define any markup specifically for marking up lists of keywords that apply to a group of pages (also known as p223 tag clouds ). In general, authors are encouraged to either mark up such lists using ul elements with explicit inline counts that are then hidden and turned into a presentational effect using a style sheet, or to use SVG.

Example

Here, three tags are included in a short tag cloud:



...





apple (popular)





kiwi (rare)





pear (very

popular)





The actual frequency of each tag is given using the p140 title attribute. A CSS style sheet is provided to convert the markup into a

cloud of differently-sized words, but for user agents that do not support CSS or are not visual, the markup contains annotations like

"(popular)" or "(rare)" to categorize the various tags by frequency, thus enabling all users to benefit from the information.

The p223 p222 ul element is used (rather than ol ) because the order is not particularly important: while the list is in fact ordered

alphabetically, it would convey the same information if ordered by, say, the length of the tag.

The p309 p285 p239 tag rel-keyword is not used on these a elements because they do not represent tags that apply to the page itself;

they are just part of an index listing the tags themselves.

721

4.14.3 Conversations p72 §

2

This specification does not define a specific element for marking up conversations, meeting minutes, chat transcripts, dialogues in screenplays, instant message logs, and other situations where different players take turns in discourse.

Instead, authors are encouraged to mark up conversations using p213 p elements and punctuation. Authors who need to mark the speaker for styling purposes are encouraged to use p280 p274 p273 span or b . Paragraphs with their text wrapped in the i element can be used for marking up stage directions.

Example

This example demonstrates this using an extract from Abbot and Costello's famous sketch, Who's on first:



Costello: Look, you gotta first baseman?



Abbott: Certainly.



Costello: Who's playing first?



Abbott: That's right.



Costello becomes exasperated.



Costello: When you pay off the first baseman every month, who gets the money?

Abbott: Every dollar of it.



Example

The following extract shows how an IM conversation log could be marked up, using the p260 data element to provide Unix

timestamps for each line. Note that the timestamps are provided in a format that the p261 time element does not support, so the

data p260 element is used instead (namely, Unix time_t timestamps). Had the author wished to mark up the data using one of the

date and time formats supported by the p261 p260 time element, that element could have been used instead of data. This could be

advantageous as it would allow data analysis tools to detect the timestamps unambiguously, without coordination with the page

author.



14:22 egof I'm not that nerdy, I've only seen 30% of the star trek episodes



14:23 kaj if you know what percentage of the star trek episodes you have seen, you are inarguably nerdy



14:23 egof it's unarguably

14:23 * kaj blinks

14:24 kaj you are not helping your case



Example

HTML does not have a good way to mark up graphs, so descriptions of interactive conversations from games are more difficult to

mark up. This example shows one possible convention using p228 dl elements to list the possible responses at each point in the

conversation. Another option to consider is describing the conversation in the form of a DOT file, and outputting the result as an

SVG image to place in the document. p1277 [DOT]



Next, you meet a fisher. You can say one of several greetings:





"Hello there!"





She responds with "Hello, how may I help you?"; you can respond with:





"I would like to buy a fish."





She sells you a fish and the conversation finishes.



"Can I borrow your boat?"





She is surprised and asks "What are you offering in return?".





"Five gold." (if you have enough)





"Ten gold." (if you have enough)





"Fifteen gold." (if you have enough)





She lends you her boat. The conversation ends.





"A fish." (if you have one)

722





"A newspaper." (if you have one)





"A pebble." (if you have one)





"No thanks", she replies. Your conversation options at this point are the same as they were after asking to borrow her boat, minus any options you've suggested before.





"Vote for me in the next election!"





She turns away. The conversation finishes.





"Madam, are you aware that your fish are running away?"





She looks at you skeptically and says "Fish cannot run, miss".





"You got me!"





The fisher sighs and the conversation ends.





"Only kidding."





"Good one!" she retorts. Your conversation options at this point are the same as those following "Hello there!" above.



"Oh, then what are they doing?"





She looks at her fish, giving you an opportunity to steal her boat, which you do. The conversation ends.





Example

In some games, conversations are simpler: each character merely has a fixed set of lines that they say. In this example, a game

FAQ/walkthrough lists some of the known possible responses for each character:





Dialogue





Some characters repeat their lines in order each time you interact with them, others randomly pick from amongst their lines. Those who respond in order have numbered entries in the lists below.





The Shopkeeper





How may I help you?





Fresh apples!





A loaf of bread for madam?





The pilot





Before the accident:





I'm about to fly out, sorry!





Sorry, I'm just waiting for flight clearance and then I'll be off!





After the accident:





I'm about to fly out, sorry!





Ok, I'm not leaving right now, my plane is being cleaned.

Ok, it's not being cleaned, it needs a minor repair first.

Ok, ok, stop bothering me! Truth is, I had a crash.





Clan Leader





During the first clan meeting:





Hey, have you seen my daughter? I bet she's up to something nefarious again...

723





Nice weather we're having today, eh?





The name is Bailey, Jeff Bailey. How can I help you today?

A glass of water? Fresh from the well!





After the earthquake:





Everyone is safe in the shelter, we just have to put out the fire!

I'll go and tell the fire brigade, you keep hosing it down!





4.14.4 Footnotes p72 §

4

HTML does not have a dedicated mechanism for marking up footnotes. Here are the suggested alternatives.



For short inline annotations, the p140 title attribute could be used.

Example

In this example, two parts of a dialogue are annotated with footnote-like content using the p140 title attribute.



Customer: Hello! I wish to register a complaint. Hello. Miss?

Shopkeeper: Watcha mean, miss?



Customer: Uh, I'm sorry, I have a cold. I wish to make a complaint.

Shopkeeper: Sorry, we're closing for lunch.



Note

Unfortunately, relying on the p140 title attribute is currently discouraged as many user agents do not expose the attribute in an

accessible manner as required by this specification (e.g. requiring a pointing device such as a mouse to cause a tooltip to appear,

which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).



Note

If the p140 title attribute is used, CSS can be used to draw the reader's attention to the elements with the attribute.



Example

For example, the following CSS places a dashed line below elements that have a p140 title attribute.

CSS [title] { border-bottom: thin dashed; }



For longer annotations, the p239 a element should be used, pointing to an element later in the document. The convention is that the contents of the link be a number in square brackets.

Example

In this example, a footnote in the dialogue links to a paragraph below the dialogue. The paragraph then reciprocally links back to

the dialogue, allowing the user to return to the location of the footnote.



Announcer: Number 16: The hand.



Interviewer: Good evening. I have with me in the studio tonight Mr Norman St John Polevaulter, who for the past few years has been

724

contradicting people. Mr Polevaulter, why do you

contradict people?



Norman: I don't. [1]

Interviewer: You told me you did!

...





[1] This is, naturally, a lie,

but paradoxically if it were true he could not say so without contradicting the interviewer and thus making it false.





For side notes, longer annotations that apply to entire sections of the text rather than just specific words or sentences, the p189 aside element should be used.

Example

In this example, a sidebar is given after a dialogue, giving it some context.



Customer: I will not buy this record, it is scratched.

Shopkeeper: I'm sorry?



Customer: I will not buy this record, it is scratched.

Shopkeeper: No no no, this's'a tobacconist's.





In 1970, the British Empire lay in ruins, and foreign

nationalists frequented the streets — many of them Hungarians (not the streets — the foreign nationals). Sadly, Alexander Yalt has been publishing incompetently-written phrase books.





For figures or tables, footnotes can be included in the relevant p236 p459 figcaption or caption element, or in surrounding prose.

Example

In this example, a table has cells with footnotes that are given in prose. A p233 figure element is used to give a single legend to the

combination of the table and its footnotes.





Table 1. Alternative activities for knights.





Activity



Location



Cost





Dance



Wherever possible



£01





Routines, chorus scenes2



Undisclosed



Undisclosed





Dining3



Camelot



Cost of ham, jam, and spam4





1. Assumed.





2. Footwork impeccable.



725



3. Quality described as "well".





4. A lot.





4.15 Disabled elements p72 §

6

An element is said to be actually disabled if it is one of the following:

• a p536 p571 button element that is disabled

• an p494 p571 input element that is disabled

• a p538 p571 select element that is disabled

• a p549 p571 textarea element that is disabled

• an p545 p546 optgroup element that has a disabled attribute

• an p546 p547 option element that is disabled

• a p563 p564 fieldset element that is a disabled fieldset

• a p706 p571 form-associated custom element that is disabled

Note

This definition is used to determine what elements are p775 p729 focusable and which elements match the :enabled and

:disabled p729 pseudo classes.



4.16 Matching HTML elements using selectors and CSS p72 §

6

4.16.1 Case-sensitivity of the CSS 'attr()' function p72 §

6

CSS Values and Units leaves the case-sensitivity of attribute names for the purpose of the 'attr()' function to be defined by the host language. p1277 [CSSVALUES]

When comparing the attribute name part of a CSS p44 'attr()' function to the names of namespace-less attributes on HTML elements in

HTML documents, the name part of the CSS 'attr()' function must first be converted to ASCII lowercase. The same function when

compared to other attributes must be compared according to its original case. In both cases, to match the values must be identical to each other (and therefore the comparison is case sensitive).

Note

This is the same as comparing the name part of a CSS attribute selector, specified in the next section.



4.16.2 Case-sensitivity of selectors p72 §

6

Selectors leaves the case-sensitivity of element names, attribute names, and attribute values to be defined by the host language.

[SELECTORS] p1281

When comparing a CSS element p44 type selector to the names of HTML elements in HTML documents, the CSS element type selector

must first be converted to ASCII lowercase. The same selector when compared to other elements must be compared according to its original case. In both cases, to match the values must be identical to each other (and therefore the comparison is case sensitive).

When comparing the name part of a CSS p44 attribute selector to the names of attributes on HTML elements in HTML documents, the name part of the CSS attribute selector must first be converted to ASCII lowercase. The same selector when compared to other

726

attributes must be compared according to its original case. In both cases, the comparison is case-sensitive.

Attribute selectors p44 on an HTML element in an HTML document must treat the values of attributes with the following names as ASCII

case-insensitive:

• accept

• accept-charset

• align

• alink

• axis

• bgcolor

• charset

• checked

• clear

• codetype

• color

• compact

• declare

• defer

• dir

• direction

• disabled

• enctype

• face

• frame

• hreflang

• http-equiv

• lang

• language

• link

• media

• method

• multiple

• nohref

• noresize

• noshade

• nowrap

• readonly

• rel

• rev

• rules

• scope

• scrolling

• selected

• shape

• target

• text

• type

• valign

• valuetype

• vlink

Example

For example, the selector [bgcolor="#ffffff"] will match any HTML element with a bgcolor attribute with values including

#ffffff p238 , #FFFFFF and #fffFFF . This happens even if bgcolor has no effect for a given element (e.g., div ).

The selector [type=a s] will match any HTML element with a type attribute whose value is a, but not whose value is A, due to the

s flag.

All other attribute values and everything else must be treated as entirely identical to each other for the purposes of selector matching. This includes:

• IDs and classes in no-quirks mode and limited-quirks mode

• the names of elements not in the HTML namespace

• the names of p44 HTML elements in XML documents

• the names of attributes of elements not in the HTML namespace

• the names of attributes of p44 HTML elements in XML documents

• the names of attributes that themselves have namespaces Note

Selectors defines that ID and class selectors (such as #foo and .bar), when matched against elements in documents that are in

quirks mode, will be matched in an ASCII case-insensitive manner. However, this does not apply for attribute selectors with "id" or

"class" as the name part. The selector [class="foobar"] will treat its value as case-sensitive even in quirks mode.



727





MDN


4.16.3 Pseudo-classes p72 §

8

There are a number of dynamic selectors that can be used with HTML. This section defines when these selectors match HTML

elements. p1281 p1277 [SELECTORS] [CSSUI]

:defined ✔ MDN

The p728 :defined pseudo-class must match any element that is defined.

:link ✔ MDN

:visited ✔ MDN

All p239 p285 p444 p285 p158 a elements that have an href attribute, all area elements that have an href attribute, and all link elements

that have an p159 p728 p728 href attribute, must match one of :link and :visited .

Other specifications might apply more specific rules regarding how these elements are to match these pseudo-classes, to mitigate some privacy concerns that apply with straightforward implementations of this requirement.

:active ✔ MDN

The p728 :active pseudo-class is defined to match an element “while an element is being activated by the user”.

To determine whether a particular element is p728 p728 being activated for the purposes of defining the :active pseudo-class only, an HTML user agent must use the first relevant entry in the following list.

If the element has a descendant that is currently matching the p728 :active pseudo-class

The element is p728 being activated .

If the element is the p492 p491 p728 labeled control of a label element that is currently matching :active

The element is p728 being activated .

If the element is a p536 button element

If the element is an p494 p496 p519 p519 input element whose type attribute is in the Submit Button , Image Button , Reset

Button p521 p522 , or Button state

The element is p728 p728 p571 being activated if it is in a formal activation state and it is not disabled .

Example

For example, if the user is using a keyboard to push a p536 button element by pressing the space bar, the element would

match this pseudo-class in between the time that the element received the keydown event and the time the element

received the keyup event.

If the element is an p239 p285 a element that has an href attribute

If the element is an p444 p285 area element that has an href attribute

If the element is a p158 p159 link element that has an href attribute

If the element is p775 focusable

The element is p728 p728 being activated if it is in a formal activation state .

If the element is p728 being actively pointed at

The element is p728 being activated .

An element is said to be in a formal activation state between the time the user begins to indicate an intent to trigger the

element's activation behavior and either the time the user stops indicating an intent to trigger the element's activation behavior, or

the time the element's activation behavior has finished running, which ever comes first.

An element is said to be being actively pointed at while the user indicates the element using a pointing device while that pointing device is in the "down" state (e.g. for a mouse, between the time the mouse button is pressed and the time it is depressed; for a finger in a multitouch environment, while the finger is touching the display surface).

:hover ✔ MDN

The p728 :hover pseudo-class is defined to match an element “while the user designates an element with a pointing device”. For the

purposes of defining the p728 :hover pseudo-class only, an HTML user agent must consider an element as being one that the user designates if it is:

• An element that the user indicates using a pointing device.

728

• An element that has a descendant that the user indicates using a pointing device.

• An element that is the p492 p491 p728 labeled control of a label element that is currently matching :hover.

Example

Consider in particular a fragment such as:





If the user designates the element with ID " p213 a " with their pointing device, then the p element (and all its ancestors not shown

in the snippet above), the p491 p728 label element, the element with ID " a ", and the element with ID " c " will match the :hover

pseudo-class p491 p213 . The element with ID " a " matches it from condition 1, the label and p elements match it because of

condition 2 (one of their descendants is designated), and the element with ID " p491 c " matches it through condition 3 (its label

element matches p728 p728 :hover ). However, the element with ID " b " does not match :hover : its descendant is not designated,

even though it matches p728 :hover .

:focus ✔ MDN

For the purposes of the CSS p729 :focus pseudo-class, an element has the focus when:

• it is not itself a p817 browsing context container; and

• at least one of the following is true:

◦ it is one of the elements listed in the p774 current focus chain of the top-level browsing context , or

◦ its shadow root shadowRoot is not null and shadowRoot is the root of at least one element that has the

focus p729 .

:target ✔ MDN

For the purposes of the CSS p729 p115 p115 :target pseudo-class , the Document 's target elements are a list containing the Document 's

target element p890 p1281 , if it is not null, or containing no elements, if it is. [SELECTORS]

:enabled ✔ MDN

The p729 p536 p494 p538 p549 p545 p546 :enabled pseudo-class must match any button , input , select , textarea , optgroup , option ,

fieldset p563 p706 p726 element, or form-associated custom element that is not actually disabled .

:disabled ✔ MDN

The p729 p726 :disabled pseudo-class must match any element that is actually disabled.

:checked ✔ MDN

The p729 :checked pseudo-class must match any element falling into one of the following categories:

• p494 p496 p514 p567 input elements whose type attribute is in the Checkbox state and whose checkedness state is true

• p494 p496 p515 p567 input elements whose type attribute is in the Radio Button state and whose checkedness state is true

• p546 p548 option elements whose selectedness is true

:indeterminate ✔ MDN

The p729 :indeterminate pseudo-class must match any element falling into one of the following categories:

• p494 p496 p514 p500 input elements whose type attribute is in the Checkbox state and whose indeterminate IDL attribute is set

to true

• p494 p496 p515 p515 input elements whose type attribute is in the Radio Button state and whose radio button group contains no

input p494 p567 elements whose checkedness state is true.

• p556 p557 progress elements with no value content attribute

:default ✔ MDN

The p729 :default pseudo-class must match any element falling into one of the following categories:

• p487 p597 p567 Submit buttons that are default buttons of their form owner .

• p494 p498 p498 input elements to which the checked attribute applies and that have a checked attribute

729

• p546 p548 option elements that have a selected attribute

:placeholder-shown

The p730 :placeholder-shown pseudo-class must match any element falling into one of the following categories:

• p494 p531 input elements that have a placeholder attribute whose value is currently being presented to the user.

• p549 p552 textarea elements that have a placeholder attribute whose value is currently being presented to the user.

:valid ✔ MDN

The p730 :valid pseudo-class must match any element falling into one of the following categories:

• elements that are p591 p592 candidates for constraint validation and that satisfy their constraints

• p487 p567 form elements that are not the form owner of any elements that themselves are candidates for constraint

validation p591 p592 but do not satisfy their constraints

• p563 p591 fieldset elements that have no descendant elements that themselves are candidates for constraint validation but

do not p592 satisfy their constraints

:invalid ✔ MDN

The p730 :invalid pseudo-class must match any element falling into one of the following categories:

• elements that are p591 p592 candidates for constraint validation but that do not satisfy their constraints

• p487 p567 form elements that are the form owner of one or more elements that themselves are candidates for constraint

validation p591 p592 but do not satisfy their constraints

• p563 fieldset elements that have of one or more descendant elements that themselves are candidates for constraint

validation p591 p592 but do not satisfy their constraints

:in-range ✔ MDN

The p730 p591 :in-range pseudo-class must match all elements that are candidates for constraint validation , have range

limitations p528 p591 p592 , and that are neither suffering from an underflow nor suffering from an overflow.

:out-of-range ✔ MDN

The p730 p591 :out-of-range pseudo-class must match all elements that are candidates for constraint validation , have range

limitations p528 p591 p592 , and that are either suffering from an underflow or suffering from an overflow.

:required ✔ MDN

The p730 :required pseudo-class must match any element falling into one of the following categories:

• p494 p524 input elements that are required

• p538 p540 select elements that have a required attribute

• p549 p552 textarea elements that have a required attribute

:optional ✔ MDN

The p730 :optional pseudo-class must match any element falling into one of the following categories:

• p494 p524 p524 input elements to which the required attribute applies that are not required

• p538 p540 select elements that do not have a required attribute

• p549 p552 textarea elements that do not have a required attribute

:read-only ✔ MDN

:read-write ✔ MDN

The p730 :read-write pseudo-class must match any element falling into one of the following categories, which for the purposes of

Selectors are thus considered p1281 user-alterable : [SELECTORS]

• p494 p523 p567 input elements to which the readonly attribute applies, and that are mutable (i.e. that do not have the

readonly p523 p571 attribute specified and that are not disabled)

• p549 p550 p571 textarea elements that do not have a readonly attribute, and that are not disabled

730

• elements that are p792 p494 p549 editing hosts or editable and are neither input elements nor textarea elements

The p730 p44 :read-only pseudo-class must match all other HTML elements.

:dir(ltr) ⚠ MDN

The p731 p143 p143 :dir(ltr) pseudo-class must match all elements whose directionality is ' ltr '.

:dir(rtl)

The p731 p143 p143 :dir(rtl) pseudo-class must match all elements whose directionality is ' rtl '.

Note

This specification does not define when an element matches the :lang() dynamic pseudo-class, as it is defined in sufficient detail

in a language-agnostic fashion in p1281 Selectors . [SELECTORS]



731

5 Microdata p73 §

2

5.1 Introduction p73 §

2

5.1.1 Overview p73 §

2

This section is non-normative.

Sometimes, it is desirable to annotate content with specific machine-readable labels, e.g. to allow generic scripts to provide services that are customized to the page, or to enable content from a variety of cooperating authors to be processed by a single script in a consistent manner.

For this purpose, authors can use the microdata features described in this section. Microdata allows nested groups of name-value pairs to be added to documents, in parallel with the existing content.



5.1.2 The basic syntax p73 §

2

This section is non-normative.

At a high level, microdata consists of a group of name-value pairs. The groups are called p737 items , and each name-value pair is a property. Items and properties are represented by regular elements.

To create an item, the p737 itemscope attribute is used.

To add a property to an item, the p739 p737 itemprop attribute is used on one of the item's descendants.

Example

Here there are two items, each of which has the property "name":





My name is Elizabeth.





My name is Daniel.





Markup without the microdata-related attributes does not have any effect on the microdata model.

Example

These two examples are exactly equivalent, at a microdata level, as the previous two examples respectively:





My name is Elizabeth.





My name is Daniel.





Properties generally have values that are strings.

732

Example

Here the item has three properties:





My name is Neil.





My band is called Four Parts Water.

I am British.





When a string value is a p239 p285 p321 p322 URL , it is expressed using the a element and its href attribute, the img element and its src attribute, or other elements that link to or embed external resources.

Example

In this example, the item has one property, "image", whose value is a URL:





When a string value is in some machine-readable format unsuitable for human consumption, it is expressed using the p261 value

attribute of the p260 data element, with the human-readable version given in the element's contents.

Example

Here, there is an item with a property whose value is a product ID. The ID is not human-friendly, so the product's name is used the

human-visible text instead of the ID.





The Instigator 2000





For numeric data, the p558 p559 meter element and its value attribute can be used instead.

Example

Here a rating is given using a p558 meter element.





Panasonic White 60L Refrigerator



itemscope itemtype="http://schema.org/AggregateRating">

Rated 3.5/5 (based on 11 customer reviews)





Similarly, for date- and time-related data, the p261 p262 time element and its datetime attribute can be used instead.

Example

In this example, the item has one property, "birthday", whose value is a date:





I was born on May 10th 2009.





Properties can also themselves be groups of name-value pairs, by putting the p737 itemscope attribute on the element that declares the property.

733

Items that are not part of others are called p742 top-level microdata items.

Example

In this example, the outer item represents a person, and the inner one represents a band:





Name: Amanda





Band: Jazz Band (

itemprop="size">12 players)





The outer item here has two properties, "name" and "band". The "name" is "Amanda", and the "band" is an item in its own right,

with two properties, "name" and "size". The "name" of the band is "Jazz Band", and the "size" is "12".

The outer item in this example is a top-level microdata item.

Properties that are not descendants of the element with the p737 p737 itemscope attribute can be associated with the item using the

itemref p738 attribute. This attribute takes a list of IDs of elements to crawl in addition to crawling the children of the element with the

itemscope p737 attribute.

Example

This example is the same as the previous one, but all the properties are separated from their p737 items:





Name: Amanda





Band: Jazz Band





Size: 12 players





This gives the same result as the previous example. The first item has two properties, "name", set to "Amanda", and "band", set to

another item. That second item has two further properties, "name", set to "Jazz Band", and "size", set to "12".

An p737 item can have multiple properties with the same name and different values.

Example

This example describes an ice cream, with two flavors:





Flavors in my favorite ice cream:





Lemon sorbet





Apricot sorbet





This thus results in an item with two properties, both "flavor", having the values "Lemon sorbet" and "Apricot sorbet".

An element introducing a property can also introduce multiple properties at once, to avoid duplication when some of the properties have the same value.

Example

Here we see an item with two properties, "favorite-color" and "favorite-fruit", both set to the value "orange":





orange





734

It's important to note that there is no relationship between the microdata and the content of the document where the microdata is marked up.

Example

There is no semantic difference, for instance, between the following two examples:





The Castle (1986)





The Castle (1986)





Both have a figure with a caption, and both, completely unrelated to the figure, have an item with a name-value pair with the

name "name" and the value "The Castle". The only difference is that if the user drags the caption out of the document, in the

former case, the item will be included in the drag-and-drop data. In neither case is the image in any way associated with the item.



5.1.3 Typed items p73 §

5

This section is non-normative.

The examples in the previous section show how information could be marked up on a page that doesn't expect its microdata to be re-used. Microdata is most useful, though, when it is used in contexts where other authors and readers are able to cooperate to make new uses of the markup.

For this purpose, it is necessary to give each p737 item a type, such as "https://example.com/person", or "https://example.org/cat", or

"https://band.example.net/". Types are identified as URLs.

The type for an p737 p737 p737 item is given as the value of an itemtype attribute on the same element as the itemscope attribute.

Example

Here, the item's type is "https://example.org/animals#cat":





Hedral





Hedral is a male american domestic

shorthair, with a fluffy black fur with white paws and belly.





In this example the "https://example.org/animals#cat" item has three properties, a "name" ("Hedral"), a "desc" ("Hedral is..."), and

an "img" ("hedral.jpeg").

The type gives the context for the properties, thus selecting a vocabulary: a property named "class" given for an item with the type "https://census.example/person" might refer to the economic class of an individual, while a property named "class" given for an item with the type "https://example.com/school/teacher" might refer to the classroom a teacher has been assigned. Several types can share a vocabulary. For example, the types "https://example.org/people/teacher" and "https://example.org/people/engineer" could be defined to use the same vocabulary (though maybe some properties would not be especially useful in both cases, e.g. maybe the "https://example.org/people/engineer" type might not typically be used with the "classroom" property). Multiple types defined to use the same vocabulary can be given for a single item by listing the URLs as a space-separated list in the attribute' value. An item cannot be given two types if they do not use the same vocabulary, however.



735

5.1.4 Global identifiers for items p73 §

6

This section is non-normative.

Sometimes, an p737 item gives information about a topic that has a global identifier. For example, books can be identified by their ISBN number.

Vocabularies (as identified by the p737 p737 itemtype attribute) can be designed such that items get associated with their global identifier in an unambiguous way by expressing the global identifiers as p738 URLs given in an itemid attribute.

The exact meaning of the p738 URLs given in itemid attributes depends on the vocabulary used.

Example

Here, an item is talking about a particular book:



itemtype="https://vocab.example.net/book"

itemid="urn:isbn:0-330-34032-8">



Title





The Reality Dysfunction





Author





Peter F. Hamilton





Publication date





26 January 1996





The " p738 https://vocab.example.net/book " vocabulary in this example would define that the itemid attribute takes a urn: URL

pointing to the ISBN of the book.



5.1.5 Selecting names when defining vocabularies p73 §

6

This section is non-normative.

Using microdata means using a vocabulary. For some purposes, an ad-hoc vocabulary is adequate. For others, a vocabulary will need to be designed. Where possible, authors are encouraged to re-use existing vocabularies, as this makes content re-use easier.

When designing new vocabularies, identifiers can be created either using URLs, or, for properties, as plain words (with no dots or colons). For URLs, conflicts with other vocabularies can be avoided by only using identifiers that correspond to pages that the author has control over.

Example

For instance, if Jon and Adam both write content at example.com, at https://example.com/~jon/... and

https://example.com/~adam/... respectively, then they could select identifiers of the form "https://example.com/~jon/name"

and "https://example.com/~adam/name" respectively.

Properties whose names are just plain words can only be used within the context of the types for which they are intended; properties named using URLs can be reused in items of any type. If an item has no type, and is not part of another item, then if its properties have names that are just plain words, they are not intended to be globally unique, and are instead only intended for limited use. Generally speaking, authors are encouraged to use either properties with globally unique names (URLs) or ensure that their items are typed.

Example

Here, an item is an "https://example.org/animals#cat", and most of the properties have names that are words defined in the

context of that type. There are also a few additional properties whose names come from other vocabularies.





Hedral





Hedral is a male american domestic

736

shorthair, with a fluffy

itemprop="https://example.com/color">black fur with white paws and belly.





This example has one item with the type "https://example.org/animals#cat" and the following properties:

Property Value

name Hedral

https://example.com/fn Hedral

desc Hedral is a male american domestic shorthair, with a fluffy black fur with white paws and belly. https://example.com/color black

https://example.com/color white

img .../hedral.jpeg



5.2 Encoding microdata p73 §

7

5.2.1 The microdata model p73 §

7

The microdata model consists of groups of name-value pairs known as p737 items.

Each group is known as an p737 p737 p737 p738 item . Each item can have item types , a global identifier (if the vocabulary specified by the

item types p737 p738 support global identifiers for items ), and a list of name-value pairs. Each name in the name-value pair is known as a

property p742 p742 p741 p741 , and each property has one or more values . Each value is either a string or itself a group of name-value pairs (an

item p737 ). The names are unordered relative to each other, but if a particular name has multiple values, they do have a relative order.



5.2.2 Items p73 §

7

Every p44 p737 p67 HTML element may have an itemscope attribute specified. The itemscope attribute is a boolean attribute. ✔ MDN

An element with the p737 itemscope attribute specified creates a new item, a group of name-value pairs.



Elements with an p737 p737 p737 itemscope attribute may have an itemtype attribute specified, to give the item types of the item . ✔ MDN

The p737 p87 itemtype attribute, if specified, must have a value that is an unordered set of unique space-separated tokens, none of which are identical to another token and each of which is a valid URL string that is an absolute URL, and all of which are defined to use the same vocabulary. The attribute's value must have at least one token.

The p737 item types of an item are the tokens obtained by splitting the element's itemtype attribute's value on ASCII whitespace. If the

itemtype p737 p737 p737 attribute is missing or parsing it in this way finds no tokens, the item is said to have no item types .

The p737 p65 item types must all be types defined in applicable specifications and must all be defined to use the same vocabulary.

Except if otherwise specified by that specification, the p737 URLs given as the item types should not be automatically dereferenced.

Note

A specification could define that its p737 item type can be dereferenced to provide the user with help information, for example. In

fact, vocabulary authors are encouraged to provide useful information at the given URL.

Item types p737 p737 are opaque identifiers, and user agents must not dereference unknown item types , or otherwise deconstruct them, in

order to determine how to process p737 items that use them.

The p737 p737 itemtype attribute must not be specified on elements that do not have an itemscope attribute specified.

737

An p737 p737 p741 p742 p738 item is said to be a typed item when either it has an item type , or it is the value of a property of a typed item.

The p738 p737 p737 p738 p737 relevant types for a typed item is the item 's item types , if it has any, or else is the relevant types of the item for

which it is a p742 p741 property 's value .



Elements with an p737 p737 itemscope attribute and an itemtype attribute that references a vocabulary that is defined to support global ✔ MDN

identifiers for items p737 may also have an itemid attribute specified, to give a global identifier for the item, so that it can be related to other p737 items on pages elsewhere on the web.

The p738 p88 itemid attribute, if specified, must have a value that is a valid URL potentially surrounded by spaces.

The p737 p738 p89 global identifier of an item is the value of its element's itemid attribute, if it has one, parsed relative to the node

document p738 of the element on which the attribute is specified. If the itemid attribute is missing or if resolving it fails, it is said to have no p738 global identifier .

The p738 p737 p737 itemid attribute must not be specified on elements that do not have both an itemscope attribute and an itemtype

attribute specified, and must not be specified on elements with an p737 p737 itemscope attribute whose itemtype attribute specifies a vocabulary that does not p738 support global identifiers for items , as defined by that vocabulary's specification.

The exact meaning of a p738 global identifier is determined by the vocabulary's specification. It is up to such specifications to define whether multiple items with the same global identifier (whether on the same page or on different pages) are allowed to exist, and what the processing rules for that vocabulary are with respect to handling the case of multiple items with the same ID.



Elements with an p737 itemscope attribute may have an itemref attribute specified, to give a list of additional elements to crawl to find ✔ MDN

the name-value pairs of the p737 item.

The p738 p87 itemref attribute, if specified, must have a value that is an unordered set of unique space-separated tokens none of which are identical to another token and consisting of IDs of elements in the same tree.

The p738 p737 itemref attribute must not be specified on elements that do not have an itemscope attribute specified.

Note

The p738 itemref attribute is not part of the microdata data model. It is merely a syntactic construct to aid authors in adding

annotations to pages where the data to be annotated does not follow a convenient tree structure. For example, it allows authors to

mark up data in a table so that each column defines a separate p737 item, while keeping the properties in the cells.



Example

This example shows a simple vocabulary used to describe the products of a model railway manufacturer. The vocabulary has just

five property names:

product-code

An integer that names the product in the manufacturer's catalog.

name

A brief description of the product.

scale

One of "HO", "1", or "Z" (potentially with leading or trailing whitespace), indicating the scale of the product.

digital

If present, one of "Digital", "Delta", or "Systems" (potentially with leading or trailing whitespace) indicating that the product has a digital decoder of the given type.

track-type

For track-specific products, one of "K", "M", "C" (potentially with leading or trailing whitespace) indicating the type of track for which the product is intended.

This vocabulary has four defined p737 item types :

https://md.example.com/loco

Rolling stock with an engine

738

https://md.example.com/passengers

Passenger rolling stock

https://md.example.com/track

Track pieces

https://md.example.com/lighting

Equipment with lighting

Each p737 item that uses this vocabulary can be given one or more of these types, depending on what the product is.

Thus, a locomotive might be marked up as:



https://md.example.com/lighting">



Name:





Tank Locomotive (DB 80)





Product code:





33041





Scale:





HO





Digital:





Delta





A turnout lantern retrofit kit might be marked up as:



https://md.example.com/lighting">



Name:





Turnout Lantern Kit





Product code:





74470





Purpose:





For retrofitting 2 C Track turnouts.





A passenger car with no lighting might be marked up as:





Name:





Express Train Passenger Car (DB Am 203)

Product code:





8710





Scale:





Z





Great care is necessary when creating new vocabularies. Often, a hierarchical approach to types can be taken that results in a

vocabulary where each item only ever has a single type, which is generally much simpler to manage.



5.2.3 Names: the itemprop attribute §

p73 ✔ MDN

9

Every p44 p739 p742 HTML element may have an itemprop attribute specified, if doing so adds one or more properties to one or more

items p737 (as defined below).

The p739 p87 itemprop attribute, if specified, must have a value that is an unordered set of unique space-separated tokens none of which

739

are identical to another token, representing the names of the name-value pairs that it adds. The attribute's value must have at least one token.

Each token must be either:

• If the item is a p738 typed item: a defined property name allowed in this situation according to the specification that defines

the p738 relevant types for the item, or

• A valid URL string that is an absolute URL defined as an item property name allowed in this situation by a vocabulary

specification, or

• A valid URL string that is an absolute URL, used as a proprietary item property name (i.e. one used by the author for private

purposes, not defined in a public specification), or

• If the item is not a p738 typed item : a string that contains no U+002E FULL STOP characters (.) and no U+003A COLON

characters (:), used as a proprietary item property name (i.e. one used by the author for private purposes, not defined in a public specification).

Specifications that introduce p740 defined property names must ensure all such property names contain no U+002E FULL STOP

characters (.), no U+003A COLON characters (:), and no ASCII whitespace.

Note

The rules above disallow U+003A COLON characters (:) in non-URL values because otherwise they could not be distinguished from

URLs. Values with U+002E FULL STOP characters (.) are reserved for future extensions. ASCII whitespace are disallowed because

otherwise the values would be parsed as multiple tokens.

When an element with an p739 p742 p737 itemprop attribute adds a property to multiple items , the requirement above regarding the tokens applies for each p737 item individually.

The p739 property names of an element are the tokens that the element's itemprop attribute is found to contain when its value is split

on ASCII whitespace, with the order preserved but with duplicates removed (leaving only the first occurrence of each name).

Within an p737 item, the properties are unordered with respect to each other, except for properties with the same name, which are ordered in the order they are given by the algorithm that defines p742 the properties of an item.

Example

In the following example, the "a" property has the values "1" and "2", in that order, but whether the "a" property comes before the

"b" property or not is not important:





1





2





test





Thus, the following is equivalent:





test





1





2





As is the following:





1





test





2





740

And the following:





1





test





2





5.2.4 Values p74 §

1

The p739 property value of a name-value pair added by an element with an itemprop attribute is as given for the first matching case in the following list:

↪ p737 If the element also has an itemscope attribute

The value is the p737 item created by the element.

↪ p165 If the element is a meta element

The value is the value of the element's p166 content attribute, if any, or the empty string if there is no such attribute.

↪ p384 p369 p362 p321 p318 p385 p380 If the element is an audio , embed , iframe , img , source , track , or video element

The value is the p89 p89 resulting URL string that results from parsing the value of the element's src attribute relative to the node

document p89 of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

↪ p239 p444 p158 If the element is an a , area , or link element

The value is the p89 p89 resulting URL string that results from parsing the value of the element's href attribute relative to the node

document p89 of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

↪ p373 If the element is an object element

The value is the p89 p89 resulting URL string that results from parsing the value of the element's data attribute relative to the node

document p89 of the element at the time the attribute is set, or the empty string if there is no such attribute or if parsing it results in an error.

↪ p260 If the element is a data element

The value is the value of the element's p261 value attribute, if it has one, or the empty string otherwise.

↪ p558 If the element is a meter element

The value is the value of the element's p559 value attribute, if it has one, or the empty string otherwise.

↪ p261 If the element is a time element

The value is the element's p262 datetime value .

↪ Otherwise

The value is the element's descendant text content.

The p239 p444 p384 p369 p362 p321 p158 p373 p318 URL property elements are the a , area , audio , embed , iframe , img , link , object , source ,

track p385 p380 , and video elements.

If a property's p741 value , as defined by the property's definition, is an absolute URL, the property must be specified using a URL

property element p741.

Note

These requirements do not apply just because a property value happens to match the syntax for a URL. They only apply if the

property is explicitly defined as taking such a value.

741

Example

For example, a book about the first moon landing could be called "mission:moon". A "title" property from a vocabulary that defines

a title as being a string would not expect the title to be given in an p239 a element, even though it looks like a URL. On the other

hand, if there was a (rather narrowly scoped!) vocabulary for "books whose titles look like URLs" which had a "title" property

defined to take a URL, then the property p239 would expect the title to be given in an a element (or one of the other URL property

elements p741), because of the requirement above.



5.2.5 Associating names with items p74 §

2

To find the properties of an item defined by the element root, the user agent must run the following steps. These steps are also used to flag p742 microdata errors.

1. Let results, memory, and pending be empty lists of elements.

2. Add the element root to memory.

3. Add the child elements of root, if any, to pending.

4. If p738 root has an itemref attribute, split the value of that itemref attribute on ASCII whitespace. For each resulting token ID,

if there is an element in the tree of root with the ID ID, then add the first such element to pending.

5. While pending is not empty:

1. Remove an element from pending and let current be that element.

2. If p742 current is already in memory , there is a microdata error ; continue.

3. Add current to memory.

4. If p737 current does not have an itemscope attribute, then: add all the child elements of current to pending.

5. If p739 p740 current has an itemprop attribute specified and has one or more property names, then add current to

results.

6. Sort results in tree order.

7. Return results.

A document must not contain any p737 p742 items for which the algorithm to find the properties of an item finds any microdata errors.

An p737 p739 item is a top-level microdata item if its element does not have an itemprop attribute.

All p738 p115 p737 itemref attributes in a Document must be such that there are no cycles in the graph formed from representing each item

in the p115 p742 p741 Document as a node in the graph and each property of an item whose value is another item as an edge in the graph connecting those two items.

A document must not contain any elements that have an p739 itemprop attribute that would not be found to be a property of any of the

items p737 p742 in that document were their properties all to be determined.

Example

In this example, a single license statement is applied to two works, using p738 itemref from the items representing the works:





Photo gallery





My photos





The house I found.



742





leaflet inside.">



The mailbox.





All images licensed under the

href="http://www.opensource.org/licenses/mit-license.php">MIT license.





The above results in two items with the type "http://n.whatwg.org/work", one with:

work

images/house.jpeg

title

The house I found.

license

http://www.opensource.org/licenses/mit-license.php

...and one with:

work

images/mailbox.jpeg

title

The mailbox.

license

http://www.opensource.org/licenses/mit-license.php



5.2.6 Microdata and other namespaces p74 §

3

Currently, the p737 p739 p44 itemscope , itemprop , and other microdata attributes are only defined for HTML elements. This means that attributes with the literal names "itemscope", "itemprop", etc, do not cause microdata processing to occur on elements in other namespaces, such as SVG.

Example

Thus, in the following example there is only one item, not two.





5.3 Sample microdata vocabularies p74 §

3

The vocabularies in this section are primarily intended to demonstrate how a vocabulary is specified, though they are also usable in their own right.



743

5.3.1 vCard p74 §

4

An item with the p737 item type http://microformats.org/profile/hcard represents a person's or organization's contact information.

This vocabulary does not p738 support global identifiers for items .

The following are the type's p740 defined property names . They are based on the vocabulary defined in vCard Format Specification ( p1281 vCard ) and its extensions, where more information on how to interpret the values can be found. [RFC6350]

kind

Describes what kind of contact the item represents.

The p741 p751 value must be text that is identical to one of the kind strings .

A single property with the name p744 p737 kind may be present within each item with the type http://microformats.org/profile/

hcard p744 .

fn

Gives the formatted text corresponding to the name of the person or organization.

The p741 value must be text.

Exactly one property with the name p744 p737 fn must be present within each item with the type http://microformats.org/profile/

hcard p744 .

n

Gives the structured name of the person or organization.

The p741 p737 p744 p744 p744 value must be an item with zero or more of each of the family-name , given-name , additional-name ,

honorific-prefix p744 p745 , and honorific-suffix properties.

Exactly one property with the name p744 p737 n must be present within each item with the type http://microformats.org/profile/

hcard p744 .

family-name p744 (inside n )

Gives the family name of the person, or the full name of the organization.

The p741 value must be text.

Any number of properties with the name p744 p737 p741 p744 family-name may be present within the item that forms the value of the n

property of an p737 p744 item with the type http://microformats.org/profile/hcard.

given-name p744 (inside n)

Gives the given-name of the person.

The p741 value must be text.

Any number of properties with the name p744 p737 p741 p744 given-name may be present within the item that forms the value of the n

property of an p737 p744 item with the type http://microformats.org/profile/hcard.

additional-name p744 (inside n )

Gives the any additional names of the person.

The p741 value must be text.

Any number of properties with the name p744 p737 p741 additional-name may be present within the item that forms the value of the

n p744 p737 p744 property of an item with the type http://microformats.org/profile/hcard .

honorific-prefix p744 (inside n )

Gives the honorific prefix of the person.

The p741 value must be text.

Any number of properties with the name p744 p737 p741 honorific-prefix may be present within the item that forms the value of the

744

n p744 p737 p744 property of an item with the type http://microformats.org/profile/hcard .

honorific-suffix p744 (inside n )

Gives the honorific suffix of the person.

The p741 value must be text.

Any number of properties with the name p745 p737 p741 honorific-suffix may be present within the item that forms the value of the

n p744 p737 p744 property of an item with the type http://microformats.org/profile/hcard .

nickname

Gives the nickname of the person or organization.

Note

The nickname is the descriptive name given instead of or in addition to the one belonging to a person, place, or thing. It can

also be used to specify a familiar form of a proper name specified by the p744 p744 fn or n properties.

The p741 value must be text.

Any number of properties with the name p745 p737 nickname may be present within each item with the type

http://microformats.org/profile/hcard p744 .

photo

Gives a photograph of the person or organization.

The p741 value must be an absolute URL.

Any number of properties with the name p745 p737 photo may be present within each item with the type http://microformats.org/

profile/hcard p744.

bday

Gives the birth date of the person or organization.

The p741 p75 value must be a valid date string.

A single property with the name p745 p737 bday may be present within each item with the type http://microformats.org/profile/

hcard p744 .

anniversary

Gives the birth date of the person or organization.

The p741 p75 value must be a valid date string.

A single property with the name p745 p737 anniversary may be present within each item with the type http://microformats.org/

profile/hcard p744.

sex

Gives the biological sex of the person.

The p741 value must be one of F, meaning "female", M, meaning "male", N, meaning "none or not applicable", O, meaning "other", or U, meaning "unknown".

A single property with the name p745 p737 sex may be present within each item with the type http://microformats.org/profile/

hcard p744 .

gender-identity

Gives the gender identity of the person.

The p741 value must be text.

A single property with the name p745 p737 gender-identity may be present within each item with the type

http://microformats.org/profile/hcard p744 .

745

adr

Gives the delivery address of the person or organization.

The p741 p737 p746 p746 p746 p746 value must be an item with zero or more type , post-office-box , extended-address , and street-address

properties, and optionally a p746 p746 p747 locality property, optionally a region property, optionally a postal-code property, and

optionally a p747 country-name property.

If no p746 p737 p741 p746 p737 type properties are present within an item that forms the value of an adr property of an item with the type

http://microformats.org/profile/hcard p744 p751 p751 , then the address type string work is implied.

Any number of properties with the name p746 p737 adr may be present within each item with the type http://microformats.org/

profile/hcard p744.

type p746 (inside adr )

Gives the type of delivery address.

The p741 p751 value must be text that is identical to one of the address type strings.

Any number of properties with the name p746 p737 p741 p746 type may be present within the item that forms the value of an adr property

of an p737 p744 p746 p737 item with the type http://microformats.org/profile/hcard , but within each such adr property item there

must only be one p746 type property per distinct value.

post-office-box p746 (inside adr)

Gives the post office box component of the delivery address of the person or organization.

The p741 value must be text.

Any number of properties with the name p746 p737 p741 post-office-box may be present within the item that forms the value of an

adr p746 p737 p744 property of an item with the type http://microformats.org/profile/hcard.

Note

vCard urges authors not to use this field.

extended-address p746 (inside adr)

Gives an additional component of the delivery address of the person or organization.

The p741 value must be text.

Any number of properties with the name p746 p737 p741 extended-address may be present within the item that forms the value of an

adr p746 p737 p744 property of an item with the type http://microformats.org/profile/hcard.

Note

vCard urges authors not to use this field.

street-address p746 (inside adr )

Gives the street address component of the delivery address of the person or organization.

The p741 value must be text.

Any number of properties with the name p746 p737 p741 street-address may be present within the item that forms the value of an

adr p746 p737 p744 property of an item with the type http://microformats.org/profile/hcard.

locality p746 (inside adr)

Gives the locality component (e.g. city) of the delivery address of the person or organization.

The p741 value must be text.

A single property with the name p746 p737 p741 p746 locality may be present within the item that forms the value of an adr property of

an p737 p744 item with the type http://microformats.org/profile/hcard.

region p746 (inside adr)

Gives the region component (e.g. state or province) of the delivery address of the person or organization.

746

The p741 value must be text.

A single property with the name p746 p737 p741 p746 region may be present within the item that forms the value of an adr property of an

item p737 p744 with the type http://microformats.org/profile/hcard .

postal-code p746 (inside adr)

Gives the postal code component of the delivery address of the person or organization.

The p741 value must be text.

A single property with the name p747 p737 p741 p746 postal-code may be present within the item that forms the value of an adr property

of an p737 p744 item with the type http://microformats.org/profile/hcard .

country-name p746 (inside adr)

Gives the country name component of the delivery address of the person or organization.

The p741 value must be text.

A single property with the name p747 p737 p741 p746 country-name may be present within the item that forms the value of an adr property

of an p737 p744 item with the type http://microformats.org/profile/hcard .

tel

Gives the telephone number of the person or organization.

The p741 value must be either text that can be interpreted as a telephone number as defined in the CCITT specifications E.163 and

X.121, or an p737 p747 p747 p1277 p1282 item with zero or more type properties and exactly one value property. [E163] [X121]

If no p747 p737 p741 p747 p737 type properties are present within an item that forms the value of a tel property of an item with the type

http://microformats.org/profile/hcard p744 p741 p747 , or if the value of such a tel property is text, then the telephone type

string p751 p751 voice is implied.

Any number of properties with the name p747 p737 tel may be present within each item with the type http://microformats.org/

profile/hcard p744.

type p747 (inside tel )

Gives the type of telephone number.

The p741 p751 value must be text that is identical to one of the telephone type strings.

Any number of properties with the name p747 p737 p741 p747 type may be present within the item that forms the value of a tel property of

an p737 p744 p747 p737 item with the type http://microformats.org/profile/hcard , but within each such tel property item there must

only be one p747 type property per distinct value.

value p747 (inside tel )

Gives the actual telephone number of the person or organization.

The p741 value must be text that can be interpreted as a telephone number as defined in the CCITT specifications E.163 and X.121.

[E163] p1277 p1282 [X121]

Exactly one property with the name p747 p737 p741 p747 value must be present within the item that forms the value of a tel property of

an p737 p744 item with the type http://microformats.org/profile/hcard.

email

Gives the email address of the person or organization.

The p741 value must be text.

Any number of properties with the name p747 p737 email may be present within each item with the type http://microformats.org/

profile/hcard p744.

impp

Gives a URL for instant messaging and presence protocol communications with the person or organization.

The p741 value must be an absolute URL.

747

Any number of properties with the name p747 p737 impp may be present within each item with the type http://microformats.org/

profile/hcard p744.

lang

Gives a language understood by the person or organization.

The p741 p1275 value must be a valid BCP 47 language tag. [BCP47].

Any number of properties with the name p748 p737 lang may be present within each item with the type http://microformats.org/

profile/hcard p744.

tz

Gives the time zone of the person or organization.

The p741 value must be text and must match the following syntax:

1. Either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).

2. A p69 valid non-negative integer that is exactly two digits long and that represents a number in the range 00..23.

3. A U+003A COLON character (:).

4. A p69 valid non-negative integer that is exactly two digits long and that represents a number in the range 00..59.

Any number of properties with the name p748 p737 tz may be present within each item with the type http://microformats.org/

profile/hcard p744.

geo

Gives the geographical position of the person or organization.

The p741 value must be text and must match the following syntax:

1. Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).

2. One or more ASCII digits.

3. Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.

4. A U+003B SEMICOLON character (;).

5. Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).

6. One or more ASCII digits.

7. Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.

The optional components marked with an asterisk (*) should be included, and should have six digits each.

Note

The value specifies latitude and longitude, in that order (i.e., "LAT LON" ordering), in decimal degrees. The longitude represents the location east and west of the prime meridian as a positive or negative real number, respectively. The latitude represents the location north and south of the equator as a positive or negative real number, respectively.

Any number of properties with the name p748 p737 geo may be present within each item with the type http://microformats.org/

profile/hcard p744.

title

Gives the job title, functional position or function of the person or organization.

The p741 value must be text.

Any number of properties with the name p748 p737 title may be present within each item with the type http://microformats.org/

profile/hcard p744.

role

Gives the role, occupation, or business category of the person or organization.

748

The p741 value must be text.

Any number of properties with the name p748 p737 role may be present within each item with the type http://microformats.org/

profile/hcard p744.

logo

Gives the logo of the person or organization.

The p741 value must be an absolute URL.

Any number of properties with the name p749 p737 logo may be present within each item with the type http://microformats.org/

profile/hcard p744.

agent

Gives the contact information of another person who will act on behalf of the person or organization.

The p741 p737 p744 value must be either an item with the type http://microformats.org/profile/hcard , or an absolute URL, or text.

Any number of properties with the name p749 p737 agent may be present within each item with the type http://microformats.org/

profile/hcard p744.

org

Gives the name and units of the organization.

The p741 p737 p749 p749 value must be either text or an item with one organization-name property and zero or more organization-unit properties.

Any number of properties with the name p749 p737 org may be present within each item with the type http://microformats.org/

profile/hcard p744.

organization-name p749 (inside org)

Gives the name of the organization.

The p741 value must be text.

Exactly one property with the name p749 p737 p741 organization-name must be present within the item that forms the value of an

org p749 p737 p744 property of an item with the type http://microformats.org/profile/hcard.

organization-unit p749 (inside org)

Gives the name of the organization unit.

The p741 value must be text.

Any number of properties with the name p749 p737 p741 organization-unit may be present within the item that forms the value of the

org p749 p737 p744 property of an item with the type http://microformats.org/profile/hcard.

member

Gives a URL that represents a member of the group.

The p741 value must be an absolute URL.

Any number of properties with the name p749 p737 member may be present within each item with the type http://microformats.org/

profile/hcard p744 p737 p744 p751 if the item also has a property with the name kind whose value is " group".

related

Gives a relationship to another entity.

The p741 p737 p749 p750 value must be an item with one url property and one rel properties.

Any number of properties with the name p749 p737 related may be present within each item with the type

http://microformats.org/profile/hcard p744 .

url p749 (inside related)

Gives the URL for the related entity.

749

The p741 value must be an absolute URL.

Exactly one property with the name p749 p737 p741 p749 url must be present within the item that forms the value of a related property of

an p737 p744 item with the type http://microformats.org/profile/hcard.

rel p749 (inside related)

Gives the relationship between the entity and the related entity.

The p741 p751 value must be text that is identical to one of the relationship strings .

Exactly one property with the name p750 p737 p741 p749 rel must be present within the item that forms the value of a related property of

an p737 p744 item with the type http://microformats.org/profile/hcard.

categories

Gives the name of a category or tag that the person or organization could be classified as.

The p741 value must be text.

Any number of properties with the name p750 p737 categories may be present within each item with the type

http://microformats.org/profile/hcard p744 .

note

Gives supplemental information or a comment about the person or organization.

The p741 value must be text.

Any number of properties with the name p750 p737 note may be present within each item with the type http://microformats.org/

profile/hcard p744.

rev

Gives the revision date and time of the contact information.

The p741 p79 value must be text that is a valid global date and time string.

Note

The value distinguishes the current revision of the information for other renditions of the information.

Any number of properties with the name p750 p737 rev may be present within each item with the type http://microformats.org/

profile/hcard p744.

sound

Gives a sound file relating to the person or organization.

The p741 value must be an absolute URL.

Any number of properties with the name p750 p737 sound may be present within each item with the type http://microformats.org/

profile/hcard p744.

uid

Gives a globally unique identifier corresponding to the person or organization.

The p741 value must be text.

A single property with the name p750 p737 uid may be present within each item with the type http://microformats.org/profile/

hcard p744 .

url

Gives a URL relating to the person or organization.

The p741 value must be an absolute URL.

Any number of properties with the name p750 p737 url may be present within each item with the type http://microformats.org/

profile/hcard p744.

750

The kind strings are:

individual

Indicates a single entity (e.g. a person).

group

Indicates multiple entities (e.g. a mailing list).

org

Indicates a single entity that is not a person (e.g. a company).

location

Indicates a geographical place (e.g. an office building).

The address type strings are:

home

Indicates a delivery address for a residence.

work

Indicates a delivery address for a place of work.

The telephone type strings are:

home

Indicates a residential number.

work

Indicates a telephone number for a place of work.

text

Indicates that the telephone number supports text messages (SMS).

voice

Indicates a voice telephone number.

fax

Indicates a facsimile telephone number.

cell

Indicates a cellular telephone number.

video

Indicates a video conferencing telephone number.

pager

Indicates a paging device telephone number.

textphone

Indicates a telecommunication device for people with hearing or speech difficulties.

The relationship strings are:

emergency

An emergency contact.

agent

Another entity that acts on behalf of this entity.



751

contact

acquaintance

friend

met

worker

colleague

resident

neighbor

child

parent

sibling

spouse

kin

muse

crush

date

sweetheart

me

Has the meaning defined in XFN. p1283 [XFN]



5.3.1.1 Conversion to vCard p75 §

2

Given a list of nodes p115 nodes in a Document , a user agent must run the following algorithm to extract any vCard data represented by those nodes (only the first vCard is returned):

1. If none of the nodes in p737 p737 p744 nodes are items with the item type http://microformats.org/profile/hcard, then there

is no vCard. Abort the algorithm, returning nothing.

2. Let p737 p737 p744 node be the first node in nodes that is an item with the item type http://microformats.org/profile/hcard .

3. Let output be an empty string.

4. p754 Add a vCard line with the type "BEGIN" and the value "VCARD" to output.

5. p754 Add a vCard line with the type "PROFILE" and the value "VCARD" to output.

6. p754 Add a vCard line with the type "VERSION" and the value "4.0" to output.

7. p754 p755 Add a vCard line with the type " SOURCE " and the result of escaping the vCard text string that is the document's URL as

the value to output.

8. If p118 p754 the title element is not null, add a vCard line with the type "NAME" and with the result of escaping the vCard text

string p755 p118 obtained from the the title element's descendant text content as the value to output.

9. Let sex be the empty string.

10. Let gender-identity be the empty string.

11. For each element p742 p740 element that is a property of the item node : for each name name in element 's property names, run

the following substeps:

1. Let parameters be an empty set of name-value pairs.

2. Run the appropriate set of substeps from the following list. The steps will set a variable value, which is used in the

next step.

If the property's p741 p737 p744 value is an item subitem and name is n

1. Let value be the empty string.

2. Append to p755 p744 value the result of collecting the first vCard subproperty named family-name in

subitem.

752

3. Append a U+003B SEMICOLON character (;) to value.

4. Append to p755 p744 value the result of collecting the first vCard subproperty named given-name in

subitem.

5. Append a U+003B SEMICOLON character (;) to value.

6. Append to p755 p744 value the result of collecting the first vCard subproperty named additional-name in

subitem.

7. Append a U+003B SEMICOLON character (;) to value.

8. Append to p755 p744 value the result of collecting the first vCard subproperty named honorific-prefix

in subitem.

9. Append a U+003B SEMICOLON character (;) to value.

10. Append to p755 p745 value the result of collecting the first vCard subproperty named honorific-suffix

in subitem.

If the property's p741 p737 p746 value is an item subitem and name is adr

1. Let value be the empty string.

2. Append to p755 p746 value the result of collecting vCard subproperties named post-office-box in

subitem.

3. Append a U+003B SEMICOLON character (;) to value.

4. Append to p755 p746 value the result of collecting vCard subproperties named extended-address in

subitem.

5. Append a U+003B SEMICOLON character (;) to value.

6. Append to p755 p746 value the result of collecting vCard subproperties named street-address in

subitem.

7. Append a U+003B SEMICOLON character (;) to value.

8. Append to p755 p746 value the result of collecting the first vCard subproperty named locality in

subitem.

9. Append a U+003B SEMICOLON character (;) to value.

10. Append to p755 p746 value the result of collecting the first vCard subproperty named region in subitem.

11. Append a U+003B SEMICOLON character (;) to value.

12. Append to p755 p747 value the result of collecting the first vCard subproperty named postal-code in

subitem.

13. Append a U+003B SEMICOLON character (;) to value.

14. Append to p755 p747 value the result of collecting the first vCard subproperty named country-name in

subitem.

15. If there is a property named p746 p741 type in subitem , and the first such property has a value that is not

an p737 item and whose value consists only of ASCII alphanumerics, then add a parameter named

" p741 TYPE " whose value is the value of that property to parameters.

If the property's p741 p737 p749 value is an item subitem and name is org

1. Let value be the empty string.

2. Append to p755 p749 value the result of collecting the first vCard subproperty named organization-name

in subitem.

3. For each property named p749 organization-unit in subitem, run the following steps:

1. If the p741 p737 value of the property is an item, then skip this property.

753

2. Append a U+003B SEMICOLON character (;) to value.

3. Append the result of p755 p741 escaping the vCard text string given by the value of the property

to value.

If the property's p741 p737 p737 value is an item subitem with the item type http://microformats.org/

profile/hcard p744 p749 and name is related

1. Let value be the empty string.

2. If there is a property named p749 p741 url in subitem , and its element is a URL property element, then

append the result of p755 p741 escaping the vCard text string given by the value of the first such property to value, and add a parameter with the name "VALUE" and the value "URI" to parameters.

3. If there is a property named p750 p741 rel in subitem , and the first such property has a value that is not

an p737 item and whose value consists only of ASCII alphanumerics, then add a parameter named

" p741 RELATION " whose value is the value of that property to parameters.

If the property's p741 p737 value is an item and name is none of the above

1. Let p755 value be the result of collecting the first vCard subproperty named value in subitem.

2. If there is a property named p741 type in subitem , and the first such property has a value that is not an

item p737 and whose value consists only of ASCII alphanumeric, then add a parameter named "TYPE"

whose value is the p741 value of that property to parameters.

If the property's p741 p737 p745 value is not an item and its name is sex

If this is the first such property to be found, set p741 sex to the property's value.

If the property's p741 p737 p745 value is not an item and its name is gender-identity

If this is the first such property to be found, set p741 gender-identity to the property's value .

Otherwise (the property's p741 p737 value is not an item)

1. Let p741 value be the property's value.

2. If p741 element is one of the URL property elements, add a parameter with the name "VALUE" and the

value "URI" to parameters.

3. Otherwise, if p745 p745 p75 name is bday or anniversary and the value is a valid date string, add a

parameter with the name "VALUE" and the value "DATE" to parameters.

4. Otherwise, if p750 p79 name is rev and the value is a valid global date and time string, add a parameter

with the name "VALUE" and the value "DATE-TIME" to parameters.

5. Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE

SOLIDUS character (\).

6. Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

7. Unless p748 name is geo , prefix every U+003B SEMICOLON character (;) in value with a U+005C

REVERSE SOLIDUS character (\).

8. Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a

U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

9. Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in

value with a U+005C REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

3. p754 Add a vCard line with the type name, the parameters parameters, and the value value to output.

12. If either p754 sex or gender-identity has a value that is not the empty string, add a vCard line with the type "GENDER" and the

value consisting of the concatenation of sex, a U+003B SEMICOLON character (;), and gender-identity to output.

13. p754 Add a vCard line with the type "END" and the value "VCARD" to output.

When the above algorithm says that the user agent is to add a vCard line consisting of a type type, optionally some parameters, and a value value to a string output, it must run the following steps:

754

1. Let line be an empty string.

2. Append type, converted to ASCII uppercase, to line.

3. If there are any parameters, then for each parameter, in the order that they were added, run these substeps:

1. Append a U+003B SEMICOLON character (;) to line.

2. Append the parameter's name to line.

3. Append a U+003D EQUALS SIGN character (=) to line.

4. Append the parameter's value to line.

4. Append a U+003A COLON character (:) to line.

5. Append value to line.

6. Let maximum length be 75.

7. While line's code point length is greater than maximum length:

1. Append the first maximum length code points of line to output.

2. Remove the first maximum length code points from line.

3. Append a U+000D CARRIAGE RETURN character (CR) to output.

4. Append a U+000A LINE FEED character (LF) to output.

5. Append a U+0020 SPACE character to output.

6. Let maximum length be 74.

8. Append (what remains of) line to output.

9. Append a U+000D CARRIAGE RETURN character (CR) to output.

10. Append a U+000A LINE FEED character (LF) to output.

When the steps above require the user agent to obtain the result of collecting vCard subproperties named subname in subitem, the user agent must run the following steps:

1. Let value be the empty string.

2. For each property named subname in the item subitem, run the following substeps:

1. If the p741 p737 value of the property is itself an item, then skip this property.

2. If this is not the first property named subname in subitem (ignoring any that were skipped by the previous step),

then append a U+002C COMMA character (,) to value.

3. Append the result of p755 p741 escaping the vCard text string given by the value of the property to value.

3. Return value.

When the steps above require the user agent to obtain the result of collecting the first vCard subproperty named subname in subitem, the user agent must run the following steps:

1. If there are no properties named subname in subitem, then return the empty string.

2. If the p741 p737 value of the first property named subname in subitem is an item, then return the empty string.

3. Return the result of p755 p741 escaping the vCard text string given by the value of the first property named subname in subitem.

When the above algorithms say the user agent is to escape the vCard text string value, the user agent must use the following steps:

1. Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE SOLIDUS character (\).

2. Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

755

3. Prefix every U+003B SEMICOLON character (;) in value with a U+005C REVERSE SOLIDUS character (\).

4. Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a U+005C REVERSE

SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

5. Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in value with a U+005C

REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

6. Return the mutated value.

Note

This algorithm can generate invalid vCard output, if the input does not conform to the rules described for the

http://microformats.org/profile/hcard p744 p737 p740 item type and defined property names.



5.3.1.2 Examples p75 §

6

This section is non-normative.

Example

Here is a long example vCard for a fictional character called "Jack Bauer":





Jack

Bauer





Counter-Terrorist Unit (Los Angeles Division)





10201 W. Pico Blvd.

Los Angeles,

CA

90064



United States





34.052339;-118.410623





Assorted Contact Methods





+1 (310) 597 3781 work





I'm on Wikipedia so you can leave a message on my user talk page.





Jack Bauer Facts

href="mailto:j.bauer@la.ctu.gov.invalid">j.bauer@la.ctu.gov.invalid





+1 (310) 555 3781

mobile phone





756





Update!

My new home phone number is

01632 960 123.





The odd line wrapping is needed because newlines are meaningful in microdata: newlines would be preserved in a conversion to,

for example, the vCard format.



Example

This example shows a site's contact details (using the p199 address element) containing an address with two street components:





Alfred Person



1600 Amphitheatre Parkway

Building 43, Second Floor

Mountain View,

CA 94043





Example

The vCard vocabulary can be used to just mark up people's names:

George Washington

This creates a single item with a two name-value pairs, one with the name "fn" and the value "George Washington", and the other

with the name "n" and a second item as its value, the second item having the two name-value pairs "given-name" and "family-

name" with the values "George" and "Washington" respectively. This is defined to map to the following vCard:

BEGIN:VCARD

PROFILE:VCARD

VERSION:4.0

SOURCE:document's address

FN:George Washington

N:Washington;George;;;

END:VCARD



5.3.2 vEvent p75 §

7

An item with the p737 item type http://microformats.org/profile/hcalendar#vevent represents an event.

This vocabulary does not p738 support global identifiers for items .

The following are the type's p740 defined property names . They are based on the vocabulary defined in Internet Calendaring and Scheduling Core Object Specification p1280 ( iCalendar ), where more information on how to interpret the values can be found. [RFC5545]

Note

Only the parts of the iCalendar vocabulary relating to events are used here; this vocabulary cannot express a complete iCalendar

757

instance.

attach

Gives the address of an associated document for the event.

The p741 value must be an absolute URL.

Any number of properties with the name p758 p737 attach may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

categories

Gives the name of a category or tag that the event could be classified as.

The p741 value must be text.

Any number of properties with the name p758 p737 categories may be present within each item with the type

http://microformats.org/profile/hcalendar#vevent p757.

class

Gives the access classification of the information regarding the event.

The p741 value must be text with one of the following values:

• public

• private

• confidential

⚠Warning!

This is merely advisory and cannot be considered a confidentiality measure.

A single property with the name p758 p737 class may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757.

comment

Gives a comment regarding the event.

The p741 value must be text.

Any number of properties with the name p758 p737 comment may be present within each item with the type

http://microformats.org/profile/hcalendar#vevent p757.

description

Gives a detailed description of the event.

The p741 value must be text.

A single property with the name p758 p737 description may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

geo

Gives the geographical position of the event.

The p741 value must be text and must match the following syntax:

1. Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).

2. One or more ASCII digits.

3. Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.

4. A U+003B SEMICOLON character (;).

5. Optionally, either a U+002B PLUS SIGN character (+) or a U+002D HYPHEN-MINUS character (-).

758

6. One or more ASCII digits.

7. Optionally*, a U+002E FULL STOP character (.) followed by one or more ASCII digits.

The optional components marked with an asterisk (*) should be included, and should have six digits each.

Note

The value specifies latitude and longitude, in that order (i.e., "LAT LON" ordering), in decimal degrees. The longitude represents the location east and west of the prime meridian as a positive or negative real number, respectively. The latitude represents the location north and south of the equator as a positive or negative real number, respectively.

A single property with the name p758 p737 geo may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757.

location

Gives the location of the event.

The p741 value must be text.

A single property with the name p759 p737 location may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

resources

Gives a resource that will be needed for the event.

The p741 value must be text.

Any number of properties with the name p759 p737 resources may be present within each item with the type

http://microformats.org/profile/hcalendar#vevent p757.

status

Gives the confirmation status of the event.

The p741 value must be text with one of the following values:

• tentative

• confirmed

• cancelled

A single property with the name p759 p737 status may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

summary

Gives a short summary of the event.

The p741 value must be text.

User agents should replace U+000A LINE FEED (LF) characters in the p741 value by U+0020 SPACE characters when using the value.

A single property with the name p759 p737 summary may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

dtend

Gives the date and time by which the event ends.

If the property with the name p759 p737 dtend is present within an item with the type http://microformats.org/profile/

hcalendar#vevent p757 p760 p75 p741 that has a property with the name dtstart whose value is a valid date string , then the value of the

property with the name p759 p75 p741 dtend must be text that is a valid date string also. Otherwise, the value of the property must be

text that is a p79 valid global date and time string.

In either case, the p741 p760 p737 value be later in time than the value of the dtstart property of the same item.

Note

The time given by the p759 p759 p741 dtend property is not inclusive. For day-long events, therefore, the dtend property's value will

759

be the day after the end of the event.

A single property with the name p759 p737 dtend may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757 p757 , so long as that http://microformats.org/profile/hcalendar#vevent does not have a property with

the name p760 duration .

dtstart

Gives the date and time at which the event starts.

The p741 p75 p79 value must be text that is either a valid date string or a valid global date and time string.

Exactly one property with the name p760 p737 dtstart must be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

duration

Gives the duration of the event.

The p741 p761 value must be text that is a valid vevent duration string.

The duration represented is the sum of all the durations represented by integers in the value.

A single property with the name p760 p737 duration may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 p757 , so long as that http://microformats.org/profile/hcalendar#vevent does not have a

property with the name p759 dtend.

transp

Gives whether the event is to be considered as consuming time on a calendar, for the purpose of free-busy time searches.

The p741 value must be text with one of the following values:

• opaque

• transparent

A single property with the name p760 p737 transp may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

contact

Gives the contact information for the event.

The p741 value must be text.

Any number of properties with the name p760 p737 contact may be present within each item with the type

http://microformats.org/profile/hcalendar#vevent p757.

url

Gives a URL for the event.

The p741 value must be an absolute URL.

A single property with the name p760 p737 url may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757.

uid

Gives a globally unique identifier corresponding to the event.

The p741 value must be text.

A single property with the name p760 p737 uid may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757.

exdate

Gives a date and time at which the event does not occur despite the recurrence rules.



760

The p741 p75 p79 value must be text that is either a valid date string or a valid global date and time string.

Any number of properties with the name p760 p737 exdate may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

rdate

Gives a date and time at which the event recurs.

The p741 value must be text that is one of the following:

• A p75 valid date string.

• A p79 valid global date and time string.

• A p79 valid global date and time string followed by a U+002F SOLIDUS character (/) followed by a second valid global date

and time string p79 representing a later time.

• A p79 valid global date and time string followed by a U+002F SOLIDUS character (/) followed by a valid vevent duration

string p761.

Any number of properties with the name p761 p737 rdate may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

rrule

Gives a rule for finding dates and times at which the event occurs.

The p741 p1280 value must be text that matches the RECUR value type defined in iCalendar . [RFC5545]

A single property with the name p761 p737 rrule may be present within each item with the type http://microformats.org/profile/

hcalendar#vevent p757.

created

Gives the date and time at which the event information was first created in a calendaring system.

The p741 p79 value must be text that is a valid global date and time string.

A single property with the name p761 p737 created may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

last-modified

Gives the date and time at which the event information was last modified in a calendaring system.

The p741 p79 value must be text that is a valid global date and time string.

A single property with the name p761 p737 last-modified may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

sequence

Gives a revision number for the event information.

The p741 p69 value must be text that is a valid non-negative integer.

A single property with the name p761 p737 sequence may be present within each item with the type http://microformats.org/

profile/hcalendar#vevent p757 .

A string is a valid vevent duration string if it matches the following pattern:

1. A U+0050 LATIN CAPITAL LETTER P character (P).

2. One of the following:

◦ A p69 valid non-negative integer followed by a U+0057 LATIN CAPITAL LETTER W character (W). The integer

represents a duration of that number of weeks.

◦ At least one, and possible both in this order, of the following:

1. A p69 valid non-negative integer followed by a U+0044 LATIN CAPITAL LETTER D character (D). The integer

represents a duration of that number of days.

761

2. A U+0054 LATIN CAPITAL LETTER T character (T) followed by any one of the following, or the first and

second of the following in that order, or the second and third of the following in that order, or all three of the following in this order:

1. A p69 valid non-negative integer followed by a U+0048 LATIN CAPITAL LETTER H character (H).

The integer represents a duration of that number of hours.

2. A p69 valid non-negative integer followed by a U+004D LATIN CAPITAL LETTER M character (M).

The integer represents a duration of that number of minutes.

3. A p69 valid non-negative integer followed by a U+0053 LATIN CAPITAL LETTER S character (S).

The integer represents a duration of that number of seconds.



5.3.2.1 Conversion to iCalendar p76 §

2

Given a list of nodes p115 nodes in a Document , a user agent must run the following algorithm to extract any vEvent data represented by those nodes:

1. If none of the nodes in p737 p757 nodes are items with the type http://microformats.org/profile/hcalendar#vevent , then

there is no vEvent data. Abort the algorithm, returning nothing.

2. Let output be an empty string.

3. p763 Add an iCalendar line with the type "BEGIN" and the value "VCALENDAR" to output.

4. p763 Add an iCalendar line with the type "PRODID" and the value equal to a user-agent-specific string representing the user

agent to output.

5. p763 Add an iCalendar line with the type "VERSION" and the value "2.0" to output.

6. For each node p737 p757 node in nodes that is an item with the type http://microformats.org/profile/hcalendar#vevent,

run the following steps:

1. p763 Add an iCalendar line with the type "BEGIN" and the value "VEVENT" to output.

2. p763 Add an iCalendar line with the type "DTSTAMP" and a value consisting of an iCalendar DATE-TIME string

representing the current date and time, with the annotation " p1280 VALUE=DATE-TIME ", to output . [RFC5545]

3. For each element p742 element that is a property of the item node: for each name name in element's property

names p740 , run the appropriate set of substeps from the following list:

If the property's p741 p737 value is an item

Skip the property.

If the property is p759 dtend

If the property is p760 dtstart

If the property is p760 exdate

If the property is p761 rdate

If the property is p761 created

If the property is p761 last-modified

Let value be the result of stripping all U+002D HYPHEN-MINUS (-) and U+003A COLON (:) characters from the

property's p741 value.

If the property's p741 p75 p763 value is a valid date string then add an iCalendar line with the type name and the value value to output, with the annotation "VALUE=DATE".

Otherwise, if the property's p741 p79 p763 value is a valid global date and time string then add an iCalendar line with the type name and the value value to output, with the annotation "VALUE=DATE-TIME".

Otherwise skip the property.

Otherwise

Add an iCalendar line p763 p741 with the type name and the property's value to output.

4. p763 Add an iCalendar line with the type "END" and the value "VEVENT" to output.

762

7. p763 Add an iCalendar line with the type "END" and the value "VCALENDAR" to output.

When the above algorithm says that the user agent is to add an iCalendar line consisting of a type type, a value value, and optionally an annotation, to a string output, it must run the following steps:

1. Let line be an empty string.

2. Append type, converted to ASCII uppercase, to line.

3. If there is an annotation:

1. Append a U+003B SEMICOLON character (;) to line.

2. Append the annotation to line.

4. Append a U+003A COLON character (:) to line.

5. Prefix every U+005C REVERSE SOLIDUS character (\) in value with another U+005C REVERSE SOLIDUS character (\).

6. Prefix every U+002C COMMA character (,) in value with a U+005C REVERSE SOLIDUS character (\).

7. Prefix every U+003B SEMICOLON character (;) in value with a U+005C REVERSE SOLIDUS character (\).

8. Replace every U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF) in value with a U+005C REVERSE

SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

9. Replace every remaining U+000D CARRIAGE RETURN (CR) or U+000A LINE FEED (LF) character in value with a U+005C

REVERSE SOLIDUS character (\) followed by a U+006E LATIN SMALL LETTER N character (n).

10. Append value to line.

11. Let maximum length be 75.

12. While line's code point length is greater than maximum length:

1. Append the first maximum length code points of line to output.

2. Remove the first maximum length code points from line.

3. Append a U+000D CARRIAGE RETURN character (CR) to output.

4. Append a U+000A LINE FEED character (LF) to output.

5. Append a U+0020 SPACE character to output.

6. Let maximum length be 74.

13. Append (what remains of) line to output.

14. Append a U+000D CARRIAGE RETURN character (CR) to output.

15. Append a U+000A LINE FEED character (LF) to output.

Note

This algorithm can generate invalid iCalendar output, if the input does not conform to the rules described for the

http://microformats.org/profile/hcalendar#vevent p757 p737 p740 item type and defined property names.



5.3.2.2 Examples p76 §

3

This section is non-normative.

Example

Here is an example of a page that uses the vEvent vocabulary to mark up an event:



...

763





Bluesday Tuesday: Money Road




...

May 5th @ 7pm (until 9pm) ...



rel="bookmark" itemprop="url">Link to this page

...



Location: The RoadHouse

...





onclick="location = getCalendar(this)">



...





The getCalendar() function is left as an exercise for the reader.

The same page could offer some markup, such as the following, for copy-and-pasting into blogs:





I'm going to

Bluesday Tuesday: Money Road, May 5th at 7pm to 9pm, at The RoadHouse!





itemprop="url">See this event on livebrum.co.uk.





5.3.3 Licensing works p76 §

4

An item with the p737 item type http://n.whatwg.org/work represents a work (e.g. an article, an image, a video, a song, etc). This type is primarily intended to allow authors to include licensing information for works.

The following are the type's p740 defined property names .

work

Identifies the work being described.

The p741 value must be an absolute URL.

Exactly one property with the name p764 p737 p764 work must be present within each item with the type http://n.whatwg.org/work .

title

Gives the name of the work.

A single property with the name p764 p737 p764 title may be present within each item with the type http://n.whatwg.org/work.

author

Gives the name or contact information of one of the authors or creators of the work.

The p741 p737 p744 value must be either an item with the type http://microformats.org/profile/hcard , or text.

Any number of properties with the name p764 p737 author may be present within each item with the type http://n.whatwg.org/

work p764.



764

license

Identifies one of the licenses under which the work is available.

The p741 value must be an absolute URL.

Any number of properties with the name p765 p737 license may be present within each item with the type http://n.whatwg.org/

work p764.



5.3.3.1 Examples p76 §

5

This section is non-normative.

Example

This example shows an embedded image entitled My Pond, licensed under the Creative Commons Attribution-Share Alike 4.0

International License and the MIT license simultaneously.





My Pond





Licensed under the

href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-Share Alike 4.0 International License and the

href="http://www.opensource.org/licenses/mit-license.php">MIT license.





5.4 Converting HTML to other formats p76 §

5

5.4.1 JSON p76 §

5

Given a list of nodes p115 nodes in a Document , a user agent must run the following algorithm to extract the microdata from those nodes into a JSON form:

1. Let result be an empty object.

2. Let items be an empty array.

3. For each p742 p765 node in nodes , check if the element is a top-level microdata item , and if it is then get the object for that

element and add it to items.

4. Add an entry to result called "items" whose value is the array items.

5. Return the result of serializing result to JSON in the shortest possible way (meaning no whitespace between tokens, no

unnecessary zero digits in numbers, and only using Unicode escapes in strings for characters that do not have a dedicated

escape sequence), and with a lowercase " p1278 e " used, when appropriate, in the representation of any numbers. [JSON]

Note

This algorithm returns an object with a single property that is an array, instead of just returning an array, so that it is possible to

extend the algorithm in the future if necessary.

When the user agent is to get the object for an item item, optionally with a list of elements memory, it must run the following substeps:

1. Let result be an empty object.

765

2. If no memory was passed to the algorithm, let memory be an empty list.

3. Add item to memory.

4. If the p737 p737 item has any item types , add an entry to result called " type " whose value is an array listing the item types of

item p737 , in the order they were specified on the itemtype attribute.

5. If the p738 p738 item has a global identifier , add an entry to result called " id " whose value is the global identifier of item.

6. Let properties be an empty object.

7. For each element p740 p742 element that has one or more property names and is one of the properties of the item item, in the

order those elements are given by the algorithm that returns p742 the properties of an item , run the following substeps:

1. Let p741 value be the property value of element.

2. If p737 value is an item, then: If value is in memory, then let value be the string "ERROR". Otherwise, get the

object p765 for value, passing a copy of memory, and then replace value with the object returned from those steps.

3. For each name p740 name in element 's property names , run the following substeps:

1. If there is no entry named name in properties, then add an entry named name to properties whose value

is an empty array.

2. Append value to the entry named name in properties.

8. Add an entry to result called "properties" whose value is the object properties.

9. Return result.

Example

For example, take this markup:





My Blog





Progress report





today





All in all, he's doing well with his swim lessons. The biggest thing was he had trouble putting his head in, but we got it down.





Comments





Posted by:





15 minutes ago





Ha!





Posted by:





5 minutes ago





When you say "we got it down"...





It would be turned into the following JSON by the algorithm above (supposing that the page's URL was

https://blog.example.com/progress-report):

{

"items": [

{

"type": [ "http://schema.org/BlogPosting" ],

"properties": {

"headline": [ "Progress report" ],

"datePublished": [ "2013-08-29" ],

"url": [ "https://blog.example.com/progress-report?comments=0" ], "comment": [

{

"type": [ "http://schema.org/UserComments" ],

"properties": {

"url": [ "https://blog.example.com/progress-report#c1" ],

"creator": [

{

"type": [ "http://schema.org/Person" ],

"properties": {

"name": [ "Greg" ]

}

}

],

"commentTime": [ "2013-08-29" ]

}

},

{

"type": [ "http://schema.org/UserComments" ],

"properties": {

"url": [ "https://blog.example.com/progress-report#c2" ],

"creator": [

{

"type": [ "http://schema.org/Person" ],

"properties": {

"name": [ "Charlotte" ]

}

}

],

"commentTime": [ "2013-08-29" ]

}

}

]

}

}

]

}





§



All HTML elements may have the hidden content attribute set. The hidden attribute is a boolean attribute. When specified on an element, it indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user. User agents should not render elements that have the hidden attribute specified. This requirement may be implemented indirectly through the style layer.

For example, an HTML+CSS user agent could implement these requirements using the rules suggested in the Rendering section.

Note

Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that

applies 'display: block' to all elements will cancel the effects of the hidden attribute. Authors therefore have to take care when

writing their style sheets to make sure that the attribute is still styled as expected.



Example

In the following skeletal example, the attribute is used to hide the web game's main screen until the user logs in:





The Example Game





Login





...





...





The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.

Elements that are not themselves hidden must not hyperlink to elements that are hidden . The for attributes of label

and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.

Elements and scripts may, however, refer to elements that are hidden in other contexts.

Example

For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the

content is not applicable or relevant, then there is no reason to link to it.

It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden.

While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the

specific context of being referenced from the elements that they describe.



Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer,

and a form control could refer to a hidden form element using its form attribute.



Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and ✔ MDN submit respectively. Only their presentation to the user changes.

The hidden IDL attribute must reflect the content attribute of the same name.



MDN

§



Note

This section does not define or create any content attribute named "inert". This section merely defines an abstract concept of

inertness .

A node (in particular elements and text nodes) can be marked as inert . When a node is inert, then the user agent must act as if the

node was absent for the purposes of targeting user interaction events, may ignore the node for the purposes of find-in-page, and may prevent the user from selecting text in that node. User agents should allow the user to override the restrictions on search and text selection, however.

Example

For example, consider a page that consists of just a single inert paragraph positioned in the middle of a body. If a user

moves their pointing device from the body over to the inert paragraph and clicks on the paragraph, no mouseover event

would be fired, and the mousemove and click events would be fired on the body element rather than the paragraph.



Note

When a node is inert, it generally cannot be focused. Inert nodes that are commands will also get disabled.

While a browsing context container is marked as inert , its nested browsing context 's active document, and all nodes in that Document , must be marked as inert.

An element is expressly inert if it is inert and its node document is not inert.

A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer.

While document is so blocked, every node that is connected to document, with the exception of the subject element and its shadow-

including descendants , must be marked inert . (The elements excepted by this paragraph can additionally be marked inert

through other means; being part of a modal dialog does not "protect" a node from being marked inert.) Note

The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node

document's top layer.



§



To prevent abuse of certain APIs that could be annoying to users (e.g., opening popups or vibrating phones), user agents allow these APIs only when the user is actively interacting with the web page or has interacted with the page at least once. This "active interaction" state is maintained through the mechanisms defined in this section.





For the purpose of tracking user activation, each Window W has a last activation timestamp. This is a number indicating the last



time W got an activation notification. It corresponds to a DOMHighResTimeStamp value except for two cases: positive infinity indicates that W has never been activated, while negative infinity indicates that a user activation-gated API has consumed the

last user activation of W. The initial value is positive infinity.

A user agent also defines a transient activation duration, which is a constant number indicating how long a user activation is available for certain user activation-gated APIs (e.g., for opening popups).

Note

The transient activation duration is expected be at most a few seconds, so that the user can possibly perceive the link between

an interaction with the page and the page calling the activation-gated API.

These two values imply two boolean user activation states for W:

Sticky activation

When the current high resolution time is greater than or equal to the last activation timestamp in W, W is said to have sticky

activation .

This is W's historical activation state, indicating whether the user has ever interacted in W. It starts false, then changes to true (and

never changes back to false) when W gets the very first activation notification .

Transient activation

When the current high resolution time is greater than or equal to the last activation timestamp in W, and less than the last

activation timestamp in W plus the transient activation duration , then W is said to have transient activation .

This is W's current activation state, indicating whether the user has interacted in W recently. This starts with a false value, and

remains true for a limited time after every activation notification W gets.

The transient activation state is considered expired if it becomes false because the transient activation duration time has

elapsed since the last user activation. Note that it can become false even before the expiry time through an activation

consumption .





When a user interaction in a browsing context B causes firing of an activation triggering input event in B 's active document

D, the user agent must perform the following activation notification steps before dispatching the event:

1. Let browsingContexts be a list consisting of:

◦ B,

◦ all ancestor browsing contexts of B, and

◦ all the descendant browsing contexts of D that have active documents from the same origin as that of D.

2. Let windows be the list of Window objects constructed by taking the active window of each item in browsingContexts.

3. For each window in windows , set window 's last activation timestamp to the current high resolution time.

An activation triggering input event is any event whose isTrusted attribute is true and whose type is one of:

• change

• click

• contextmenu

• dblclick

• mouseup

• pointerup

• reset

• submit

• touchend

The event set is inconsistent across major browsers. See issue #3849.



Activation consuming APIs defined in this and other specifications can consume user activation by performing the following



steps, given a Window W:

1. If W 's browsing context is null, then return.

2. Let top be W 's browsing context 's top-level browsing context.

3. Let browsingContexts be the list of the descendant browsing contexts of top 's active document.

4. Append top to browsingContexts.

5. Let windows be the list of Window objects constructed by taking the active window of each item in browsingContexts.

6. For each window in windows , if window 's last activation timestamp is not positive infinity, then set window's last

activation timestamp to negative infinity.



The spec is not clear about how to traverse a tree of documents. See issue #5020.



Note

Note the asymmetry in the sets of browsing contexts in the page that are affected by an activation notification vs an

activation consumption : an activation consumption changes (to false) the transient activation states for all browsing

contexts in the page, but an activation notification changes (to true) the states for a subset of those browsing contexts. The

exhaustive nature of consumption here is deliberate: it prevents malicious sites from making multiple calls to an activation

consuming API from a single user activation (possibly by exploiting a deep hierarchy of iframes).





APIs that are dependent on user activation are classified into three different levels. The levels are as follows, sorted by their "strength of dependence" on user activation (from weakest to strongest):

Sticky activation-gated APIs

These APIs require the sticky activation state to be true, so they are blocked until the very first user activation.

Transient activation-gated APIs

These APIs require the transient activation state to be true, but they don't consume it, so multiple calls are allowed per user

activation until the transient state expires.

Transient activation-consuming APIs

These APIs require the transient activation state to be true, and they consume user activation in each call to prevent multiple calls per user activation.



§



Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.

The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.

For web developers (non-normative)

element . click ()

Acts as if the element was clicked.

✔ MDN

Each element has an associated click in progress flag, which is initially unset.

The click() method must run the following steps:



1. If this element is a form control that is disabled, then return.

2. If this element's click in progress flag is set, then return.

3. Set this element's click in progress flag.

4. Fire a synthetic pointer event named click at this element, with the not trusted flag set.

5. Unset this element's click in progress flag.



§





This section is non-normative.

An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).

When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.

Example

Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page

with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.

The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children,

the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as

well as the dialog. The dialog itself would have as its children the text control and the button.





If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the

graphical system to ① the web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.





Keyboard events are always targeted at this focused element.





A top-level browsing context has system focus when it can receive keyboard input channeled from the operating system.

Note

System focus is lost when a browser window loses focus, but might also be lost to other system widgets in the browser window

such as a URL bar.

The term focusable area is used to refer to regions of the interface that can further become the target of such keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.

Each focusable area has a DOM anchor , which is a Node object that represents the position of the focusable area in the DOM.

(When the focusable area is itself a Node , it is its own DOM anchor .) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.

The following table describes what objects can be focusable areas . The cells in the left column describe objects that can be

focusable areas ; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)





Note

A browsing context container (e.g. an iframe ) is a focusable area , but key events routed to a browsing context

container get immediately routed to its nested browsing context 's active document. Similarly, in sequential focus

navigation a browsing context container essentially acts merely as a placeholder for its nested browsing context 's active

document .



One focusable area in each Document is designated the focused area of the document. Which control is so designated changes over time, based on algorithms in this specification.

The currently focused area of a top-level browsing context topLevelBC at any particular time is the focusable area-or-null returned by this algorithm:

1. If topLevelBC does not have system focus, then return null.

2. Let candidate be topLevelBC 's active document.

3. While candidate 's focused area is a browsing context container with a non-null nested browsing context : set

candidate to the active document of that browsing context container 's nested browsing context .

4. If candidate 's focused area is non-null, set candidate to candidate 's focused area .

5. Return candidate.

The current focus chain of a top-level browsing context topLevelBC at any particular time is the focus chain of the currently

focused area of topLevelBC, if topLevelBC is non-null, or an empty list otherwise.

An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the

currently focused area of a top-level browsing context . When an element is the DOM anchor of a focusable area of the

currently focused area of a top-level browsing context , it is focused.

The focus chain of a focusable area subject is the ordered list constructed as follows:

1. Let output be an empty list.

2. Let currentObject be subject.

3. While true:

1. Append currentObject to output.



2. If currentObject is an area element's shape, then append that area element to output.

Otherwise, if currentObject 's DOM anchor is an element that is not currentObject itself, then append

currentObject 's DOM anchor to output.

3. If currentObject is a focusable area , then set currentObject to currentObject 's DOM anchor's node document.

Otherwise, if currentObject is a Document whose browsing context is a child browsing context , then set

currentObject to currentObject 's browsing context 's container.

Otherwise, break.

4. Return output.

Note

The chain starts with subject and (if subject is or can be the currently focused area of a top-level browsing context )

continues up the focus hierarchy up to the Document of the top-level browsing context.

All elements that are focusable areas are said to be focusable.

There are two special types of focusability for focusable areas:

• A focusable area is said to be sequentially focusable if it is included in its Document's sequential focus navigation

order and the user agent determines that it is sequentially focusable.

• A focusable area is said to be click focusable if the user agent determines that it is click focusable. User agents should

consider focusable areas with non-null tabindex values to be click focusable.

Note

Elements which are not focusable are not focusable areas , and thus not sequentially focusable and not click

focusable .



Note

Being focusable is a statement about whether an element can be focused programmatically, e.g. via the focus() method or

autofocus attribute. In contrast, sequentially focusable and click focusable govern how the user agent responds to user

interaction: respectively, to sequential focus navigation and as activation behavior.

The user agent might determine that an element is not sequentially focusable even if it is focusable and is included in its

Document 's sequential focus navigation order , according to user preferences. For example, macOS users can set the user

agent to skip non-form control elements, or can skip links when doing sequential focus navigation with just the Tab key (as

opposed to using both the Option and Tab keys).

Similarly, the user agent might determine that an element is not click focusable even if it is focusable. For example, in some

user agents, clicking on a non-editable form control does not focus it, i.e. the user agent has determined that such controls are not

click focusable.

Thus, an element can be focusable , but neither sequentially focusable nor click focusable. For example, in some user

agents, a non-editable form-control with a negative-integer tabindex value would not be focusable via user interaction, only via

programmatic APIs.

When a user activates a click focusable focusable area , the user agent must run the focusing steps on the focusable

area with focus trigger set to "click".

Note

Note that focusing is not an activation behavior , i.e. calling the click() method on an element or dispatching a synthetic click

event on it won't cause the element to get focused.



A node is a focus navigation scope owner if it is a document , a shadow host or a slot .

Each focus navigation scope owner has a focus navigation scope, which is a list of elements. Its contents are determined as follows:



Every element element has an associated focus navigation owner , which is either null or a focus navigation scope owner . It is determined by the following algorithm:

1. If element's parent is null, then return null.

2. If element's parent is a shadow host, then return element's assigned slot.

3. If element's parent is a shadow root, then return the parent's host.

4. If element's parent is the document element, then return the parent's node document.

5. Return element 's parent's associated focus navigation owner .

Then, the contents of a given focus navigation scope owner owner 's focus navigation scope are all elements whose associated

focus navigation owner is owner.

Note

The order of elements within a focus navigation scope does not impact any of the algorithms in this specification. Ordering only

becomes important for the tabindex-ordered focus navigation scope and flattened tabindex-ordered focus navigation scope

concepts defined below.

A tabindex-ordered focus navigation scope is a list of focusable areas and focus navigation scope owners. Every focus

navigation scope owner owner has tabindex-ordered focus navigation scope , whose contents are determined as follows:

• It contains all elements in owner 's focus navigation scope that are themselves focus navigation scope owners , except

the elements whose tabindex value is a negative integer.

• It contains all of the focusable areas whose DOM anchor is an element in owner 's focus navigation scope, except

the focusable areas whose tabindex value is a negative integer.

The order within a tabindex-ordered focus navigation scope is determined by each element's tabindex value , as described in the section below.

Note

The rules there do not give a precise ordering, as they are composed mostly of "should" statements and relative orderings.

A flattened tabindex-ordered focus navigation scope is a list of focusable areas . Every focus navigation scope owner

owner owns a distinct flattened tabindex-ordered focus navigation scope, whose contents are determined by the following algorithm:

1. Let result be a clone of owner 's tabindex-ordered focus navigation scope.

2. For each item of result:

1. If item is not a focus navigation scope owner, then continue.

2. If item is not a focusable area, then replace item with all of the items in item's flattened tabindex-ordered focus

navigation scope .

3. Otherwise, insert the contents of item 's flattened tabindex-ordered focus navigation scope after item.





The tabindex content attribute allows authors to make an element and regions that have the element as its DOM anchor be✔ MDN

focusable areas , allow or prevent them from being sequentially focusable, and determine their relative ordering for sequential

focus navigation .

The name "tab index" comes from the common use of the Tab key to navigate through the focusable elements. The term "tabbing"

refers to moving forward through sequentially focusable focusable areas .

The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is not



sequentially focusable .

Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.

Note

The following provides a non-normative summary of the behaviors of the possible tabindex attribute values. The below

processing model gives the more precise rules.

omitted (or non-integer values)

The user agent will decide whether the element is focusable , and if it is, whether it is sequentially focusable or click

focusable (or both).

−1 (or other negative integer values)

Causes the element to be focusable , and indicates that the author would prefer the element to be click focusable but not

sequentially focusable . The user agent might ignore this preference for click and sequential focusability, e.g., for specific element types according to platform conventions, or for keyboard-only users.

0

Causes the element to be focusable , and indicates that the author would prefer the element to be both click focusable

and sequentially focusable. The user agent might ignore this preference for click and sequential focusabiity.

positive integer values

Behaves the same as 0, but in addition creates a relative ordering within a tabindex-ordered focus navigation scope , so that

elements with higher tabindex attribute value come later.

Note that the tabindex attribute cannot be used to make an element non-focusable. The only way a page author can do that is

by disabling the element, or making it inert.



The tabindex value of an element is the value of its tabindex attribute, parsed using the rules for parsing integers. If parsing

fails or the attribute is not specified, then the tabindex value is null.

The tabindex value of a focusable area is the tabindex value of its DOM anchor.

The tabindex value of an element must be interpreted as follows: If the value is null

The user agent should follow platform conventions to determine if the element should be considered as a focusable area and if

so, whether the element and any focusable areas that have the element as their DOM anchor are sequentially focusable ,

and if so, what their relative position in their tabindex-ordered focus navigation scope is to be. If the element is a focus

navigation scope owner , it must be included in its tabindex-ordered focus navigation scope even if it is not a focusable

area .

The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the

same focus navigation scope and whose tabindex value is null should be in shadow-including tree order.

Modulo platform conventions, it is suggested that the following elements should be considered as focusable areas and be

sequentially focusable :

• a elements that have an href attribute

• link elements that have an href attribute

• button elements

• input elements whose type attribute are not in the Hidden state

• select elements

• textarea elements

• summary elements that are the first summary element child of a details element

• Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin drag operations



for those elements without the use of a pointing device

• Editing hosts

• Browsing context containers

If the value is a negative integer

The user agent must consider the element as a focusable area , but should omit the element from any tabindex-ordered focus

navigation scope .

Note

One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would

be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.

If the value is a zero

The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable

areas that have the element as their DOM anchor to be sequentially focusable.

The relative ordering within a tabindex-ordered focus navigation scope for elements and focusable areas that belong to the

same focus navigation scope and whose tabindex value is zero should be in shadow-including tree order.

If the value is greater than zero

The user agent must allow the element to be considered as a focusable area and should allow the element and any focusable

areas that have the element as their DOM anchor to be sequentially focusable, and should place the element —

referenced as candidate below — and the aforementioned focusable areas in the tabindex-ordered focus navigation scope

where the element is a part of so that, relative to other elements and focusable areas that belong to the same focus navigation

scope , they are:

• before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or

whose value, when parsed, returns an error,

• before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or

less than zero,

• after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than

zero but less than the value of the tabindex attribute on candidate,

• after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the

value of the tabindex attribute on candidate but that is located earlier than candidate in shadow-including tree order,

• before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the

value of the tabindex attribute on candidate but that is located later than candidate in shadow-including tree order, and

• before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than

the value of the tabindex attribute on candidate.

The tabIndex IDL attribute must reflect the value of the tabindex content attribute. The default value is 0 if the element is an ✔ MDN

a , area , button , frame , iframe , input , object , select , textarea , or SVG a element, or is a summary

element that is a summary for its parent details . The default value is −1 otherwise.

Note

The varying default value based on element type is a historical artifact.





To get the focusable area for a focus target that is either an element that is not a focusable area , or is a browsing context ,

given an optional string focus trigger, run the first matching set of steps from the following list:



↪ If focus target is an area element with one or more shapes that are focusable areas

Return the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.

↪ If focus target is an element with one or more scrollable regions that are focusable areas

Return the element's first scrollable region, according to a pre-order, depth-first traversal of the flat tree . [CSSSCOPING]

↪ If focus target is the document element of its Document

Return the Document's viewport.

↪ If focus target is a browsing context

Return the browsing context 's active document .

↪ If focus target is a browsing context container with a non-null nested browsing context

Return the browsing context container 's nested browsing context 's active document.

↪ If focus target is a shadow host whose shadow root's delegates focus is true

1. If focus target is a shadow-including inclusive ancestor of the currently focused area of a top-level browsing

context 's DOM anchor , then return null.

2. Otherwise:

1. If focus trigger is " click ", then let possible focus delegates be the list of all click focusable focusable

areas whose DOM anchor is a descendant of focus target in the flat tree.

2. Otherwise, let possible focus delegates be the list of all focusable areas whose DOM anchor is a

descendant of focus target in the flat tree.

3. Return the first focusable area in tree order of their DOM anchors in possible focus delegates, or null

if possible focus delegates is empty.

Note

For sequential focusability , the handling of shadow hosts and delegates focus is done when constructing the sequential

focus navigation order . That is, the focusing steps will never be called on such shadow hosts as part of sequential focus navigation.

↪ Otherwise

Return null.

The focusing steps for an object new focus target that is either a focusable area , or an element that is not a focusable area , or

a browsing context, are as follows. They can optionally be run with a fallback target and a string focus trigger.

1. If new focus target is not a focusable area , then set new focus target to the result of getting the focusable area for

new focus target, given focus trigger if it was passed.

2. If new focus target is null, then:

1. If no fallback target was specified, then return.

2. Otherwise, set new focus target to the fallback target.

3. If new focus target is a browsing context container with non-null nested browsing context , then set new focus target to

the nested browsing context 's active document .

4. If new focus target is a focusable area and its DOM anchor is inert , then return.

5. If new focus target is the currently focused area of a top-level browsing context, then return.

6. Let old chain be the current focus chain of the top-level browsing context in which new focus target finds itself.

7. Let new chain be the focus chain of new focus target.

8. Run the focus update steps with old chain, new chain, and new focus target respectively.

User agents must immediately run the focusing steps for a focusable area or browsing context candidate whenever the



user attempts to move the focus to candidate.

The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area

are as follows:

1. If old focus target is inert , then return.

2. If old focus target is an area element and one of its shapes is the currently focused area of a top-level browsing

context , or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused

area of a top-level browsing context , then let old focus target be that currently focused area of a top-level browsing

context .

3. Let old chain be the current focus chain of the top-level browsing context in which old focus target finds itself.

4. If old focus target is not one of the entries in old chain, then return.

5. If old focus target is not a focusable area , then return.

6. Let topDocument be old chain's last entry.

7. If topDocument 's browsing context has system focus , then run the focusing steps for topDocument's viewport.

Otherwise, apply any relevant platform-specific conventions for removing system focus from topDocument's browsing

context , and run the focus update steps with old chain, an empty list, and null respectively.

When the currently focused area of a top-level browsing context is somehow unfocused without another element being explicitly focused in its stead, the user agent must immediately run the unfocusing steps for that object.

Note

The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level

browsing context . For example, if the currently focused area of a top-level browsing context is a viewport, then it will usually

keep its focus regardless until another focusable area is explicitly focused with the focusing steps .



Focus fixup rule : When the designated focused area of the document is removed from that Document in some way (e.g. it stops being a focusable area , it is removed from the DOM, it becomes expressly inert , etc.), designate the Document's

viewport to be the new focused area of the document.

Example

For example, this might happen because an element is removed from its Document , or has a hidden attribute added. It might

also happen to an input element when the element gets disabled.



Example

In a Document whose focused area is a button element, removing, disabling, or hiding that button would cause the

page's new focused area to be the viewport of the Document. This would, in turn, be reflected through the

activeElement API as the body element.



The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:

1. If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry

from new chain and redo this step.

2. For each entry entry in old chain, in order, run these substeps:

1. If entry is an input element, and the change event applies to the element, and the element does not

have a defined activation behavior , and the user has changed the element's value or its list of selected files

while the control was focused without committing that change (such that it is different to what it was when the

control was first focused), then fire an event named change at the element, with the bubbles attribute initialized to true.

2. If entry is an element, let blur event target be entry.

If entry is a Document object, let blur event target be that Document object's relevant global object.



Otherwise, let blur event target be null.

3. If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element,

then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.

4. If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as

the related target.

Note

In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.

3. Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the

contents of a text control when that control is focused.)

4. For each entry entry in new chain, in reverse order, run these substeps:

1. If entry is a focusable area : designate entry as the focused area of the document.

2. If entry is an element, let focus event target be entry.

If entry is a Document object, let focus event target be that Document object's relevant global object .

Otherwise, let focus event target be null.

3. If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element,

then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.

4. If focus event target is not null, fire a focus event named focus at focus event target, with related focus

target as the related target.

Note

In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.

To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the

relatedTarget attribute initialized to r , the view attribute initialized to t 's node document 's relevant global object, and the

composed flag set.



When a key event is to be routed in a top-level browsing context , the user agent must run the following steps:

1. Let target area be the currently focused area of the top-level browsing context.

2. Assert: target area is not null, since key events are only routed to top-level browsing contexts that have system focus.

3. If target area is a focusable area , let target node be target area 's DOM anchor . Otherwise, target area is a dialog ;

let target node be target area.

4. If target node is a Document that has a body element , then let target node be the body element of that

Document .

Otherwise, if target node is a Document object that has a non-null document element, then let target node be that

document element.

5. If target node is not inert, then:

Note

It is possible for the currently focused area of a top-level browsing context to be inert, for example if a modal

dialog is shown , and then that dialog element is made inert . It is likely to be the result of a logic error in the application, though.

1. Let canHandle be the result of dispatching the key event at target node.

2. If canHandle is true, then let target area handle the key event. This might include firing a click event at target

node.



The has focus steps , given a Document object target, are as follows:



1. If target 's browsing context 's top-level browsing context does not have system focus , then return false.

2. Let candidate be target 's top-level browsing context 's active document.

3. While true:

1. If candidate is target, then return true.

2. If the focused area of candidate is a browsing context container with a non-null nested browsing context,

then set candidate to the active document of that browsing context container 's nested browsing context.

3. Otherwise, return false.





Each Document has a sequential focus navigation order , which orders some or all of the focusable areas in the Document

relative to each other. Its contents and ordering are given by the flattened tabindex-ordered focus navigation scope of the

Document .

Note

Per the rules defining the flattened tabindex-ordered focus navigation scope , the ordering is not necessarily related to the tree

order of the Document.

If a focusable area is omitted from the sequential focus navigation order of its Document, then it is unreachable via sequential

focus navigation .

There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.

Example

For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.



Note

User agents are required to set the sequential focus navigation starting point to the target element when navigating to a

fragment .

When the user requests that focus move from the currently focused area of a top-level browsing context to the next or previous

focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-

level browsing context in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:

1. Let starting point be the currently focused area of a top-level browsing context, if the user requested to move focus

sequentially from there, or else the top-level browsing context itself, if the user instead requested to move focus from

outside the top-level browsing context .

2. If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the

sequential focus navigation starting point instead.

3. Let direction be forward if the user requested the next control, and backward if the user requested the previous control.

Note

Typically, pressing tab requests the next control, and pressing shift+tab requests the previous control.

4. Loop : Let selection mechanism be sequential if the starting point is a browsing context or if starting point is in its

Document 's sequential focus navigation order .

Otherwise, starting point is not in its Document 's sequential focus navigation order; let selection mechanism be DOM.

5. Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and

selection mechanism as the arguments.

6. If candidate is not null, then run the focusing steps for candidate and return.



7. Otherwise, unset the sequential focus navigation starting point.

8. If starting point is the top-level browsing context , or a focusable area in the top-level browsing context, the user

agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.

Example

For example, if direction is backward , then the last sequentially focusable control before the browser's rendering area would be the control to focus.

If the user agent has no sequentially focusable controls — a kiosk-mode browser, for instance — then the user agent may

instead restart these steps with the starting point being the top-level browsing context itself.

9. Otherwise, starting point is a focusable area in a child browsing context. Set starting point to that child browsing

context 's container and return to the step labeled loop.

The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.

1. Pick the appropriate cell from the following table, and follow the instructions in that cell.

The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.





A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and is sequentially

focusable .

The home document is the Document to which starting point belongs.

The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.

Note

The home sequential focus navigation order is the home document 's sequential focus navigation order, but is

only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).

2. If candidate is a browsing context container with a non-null nested browsing context, then let new candidate be the

result of running the sequential navigation search algorithm with candidate 's nested browsing context as the first argument, direction as the second, and sequential as the third.

If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.

3. Return candidate.





dictionary FocusOptions {

boolean preventScroll = false;

};



For web developers (non-normative)



documentOrShadowRoot . activeElement

Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.

For the purposes of this API, when a child browsing context is focused, its container is focused in the parent browsing

context . For example, if the user moves the focus to a text control in an iframe , the iframe is the element returned

by the activeElement API in the iframe's node document.

Similarly, when the focused element is in a different node tree than documentOrShadowRoot, the element returned will be the

host that's located in the same node tree as documentOrShadowRoot if documentOrShadowRoot is a shadow-including inclusive

ancestor of the focused element, and null if not.

document . hasFocus ()

Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.

window . focus()

Moves the focus to the window's browsing context , if any.

element . focus ([ { preventScroll: true } ])

Moves the focus to the element.

If the element is a browsing context container , moves the focus to its nested browsing context instead.

By default, this method also scrolls the element into view. Providing the preventScroll option and setting it to true prevents this behavior.

element . blur ()

Moves the focus to the viewport . Use of this method is discouraged; if you want to focus the viewport , call the focus()

method on the Document 's document element.

Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use a CSS rule to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.

Example

For example, to hide the outline from links and instead use a yellow background to indicate focus, you could use:

:link:focus, :visited:focus { outline: none; background: yellow; color: black; }



The activeElement attribute's getter must run these steps:

1. Let candidate be the DOM anchor of the focused area of this DocumentOrShadowRoot 's node document.

2. Set candidate to the result of retargeting candidate against this DocumentOrShadowRoot.

3. If candidate 's root is not this DocumentOrShadowRoot, then return null.

4. If candidate is not a Document object, then return candidate.

5. If candidate has a body element , then return that body element.

6. If candidate's document element is non-null, then return that document element.

7. Return null.

The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the ✔ ✔ MDN MDN

Document object as the argument.

The focus() method, when invoked, must run these steps:

1. Let current be this Window object's browsing context.

2. If current is null, then return.



3. Run the focusing steps with current.

4. If current is a top-level browsing context , user agents are encouraged to trigger some sort of notification to indicate to

the user that the page is attempting to gain focus.

The blur() method, when invoked, provides a hint to the user agent that the script believes the user probably is not currently ✔ MDN

interested in the contents of this Window object's browsing context, if non-null, but that the contents might become interesting again in the future.

User agents are encouraged to ignore calls to this blur() method entirely.

Note

Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g., tab or

window) that contained the ✔ MDN browsing context , but hostile sites widely abuse this behavior to the user's detriment.

The focus(options) method on elements, when invoked, must run the following steps:

1. If the element is marked as locked for focus, then return.

2. Mark the element as locked for focus.

3. Run the focusing steps for the element.

4. If the value of the preventScroll dictionary member of options is false, then scroll the element into view with scroll

behavior "auto", block flow direction position set to an implementation-defined value, and inline base direction position set

to an implementation-defined value.

5. Unmark the element as locked for focus.

The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called. User agents ✔ MDN may selectively or uniformly ignore calls to this method for usability reasons.

Example

For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would

become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.





The autofocus content attribute allows the author to indicate that an element is to be focused as soon as the page is loaded or as soon as the dialog within which it finds itself is shown, allowing the user to just start typing without having to manually focus the main element.

The autofocus attribute is a boolean attribute.

An element's nearest ancestor autofocus scoping root element is the element itself if the element is a dialog element, or else is the element's nearest ancestor dialog element, if any, or else is the element's last inclusive ancestor element.

There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus

attribute specified.

Each Document has an autofocus candidates list, initially empty.

Each Document has an autofocus processed flag boolean, initially false.

When an element with the autofocus attribute specified is inserted into a document, run the following steps:

1. If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then

optionally return.

2. Let target be the element's node document.

3. If target 's browsing context is null, then return.



4. If target 's active sandboxing flag set has the sandboxed automatic features browsing context flag, then return.

5. Let topDocument be the active document of target 's browsing context 's top-level browsing context.

6. If target 's origin is not the same as the origin of topDocument, then return.

7. If topDocument 's autofocus processed flag is false, then remove the element from topDocument's autofocus

candidates , and append the element to topDocument 's autofocus candidates.

Note

We do not check if an element is a focusable area before storing it in the autofocus candidates list, because even if it is not

a focusable area when it is inserted, it could become one by the time flush autofocus candidates sees it.

To flush autofocus candidates for a document topDocument, run these steps:

1. If topDocument 's autofocus processed flag is true, then return.

2. Let candidates be topDocument 's autofocus candidates.

3. If candidates is empty, then return.

4. If topDocument 's focused area is not topDocument itself, or topDocument's URL's fragment is not empty, then:

1. Empty candidates.

2. Set topDocument 's autofocus processed flag to true.

3. Return.

5. While candidates is not empty:

1. Let element be candidates[0].

2. Let doc be element's node document.

3. If doc is not fully active, then remove element from candidates, and continue.

4. If doc 's browsing context 's top-level browsing context is not same as topDocument 's browsing context,

then remove element from candidates, and continue.

5. If doc 's script-blocking style sheet counter is greater than 0, then return.

Note

In this case, element is the currently-best candidate, but doc is not ready for autofocusing. We'll try again next

time flush autofocus candidates is called.

6. Remove element from candidates.

7. Let inclusiveAncestorDocuments be a list consisting of doc , plus the active documents of each of doc's browsing

context 's ancestor browsing contexts.

8. If URL 's fragment of any Document in inclusiveAncestorDocuments is not empty, then continue.

9. Let target be element.

10. If target is not a focusable area , then set target to the result of getting the focusable area for target.

Note

Autofocus candidates can contain elements which are not focusable areas. In addition to the special

cases handled in the get the focusable area algorithm, this can happen because a non- focusable area

element with an autofocus attribute was inserted into a document and it never became focusable, or

because the element was focusable but its status changed while it was stored in autofocus candidates.

11. If target is not null, then:

1. Empty candidates.

2. Set topDocument 's autofocus processed flag to true.



3. Run the focusing steps for target.

Note

This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements

also processes the autofocus attribute.



Note

Focusing the element does not imply that the user agent has to focus the browser window if it has lost focus.



The autofocus IDL attribute must reflect the content attribute of the same name.

Example

In the following snippet, the text control would be focused when the document was loaded.





Example

The autofocus attribute applies to all elements, not just to form controls. This allows examples such as the following:



Edit me!



§





This section is non-normative.

Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.

The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.

In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.

Each alternative consists of a single character, such as a letter or digit.

User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.

Example

In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author

has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another

possibly key.



accesskey="C 1" id=c>



Example

To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's

label:



function addShortcutKeyLabel(button) {

if (button.accessKeyLabel != '')

button.value += ' (' + button.accessKeyLabel + ')';

}

addShortcutKeyLabel(document.getElementById('c'));

Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent

on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might

display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if

the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser

might use "M-ESC" or "ESC ESC".

In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.





All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.

If specified, the value must be an ordered set of unique space-separated tokens none of which are identical to another token and each of which must be exactly one code point in length.

Example

In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more

quickly navigate to the relevant pages:





Activities |

Technical Reports

|

Site Index |

About Consortium |

Contact





Example

In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device

with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad

might pick just the plain unadorned key 0:





Search:





Example

In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise

the key combination the user agent selected.



...



On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the

user agent doesn't assign a key, it will be just " Compose ". The exact string depends on what the assigned access key is, and on

how the user agent represents that key combination.





An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key .

Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned

access key by running the following steps:

1. If the element has no accesskey attribute, then skip to the fallback step below.

2. Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.

3. For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:

1. If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.

2. If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this

value.

3. If the user agent can find a mix of zero or more modifier keys that, combined with the key that

corresponds to the value given in the attribute, can be used as the access key, then the user agent may

assign that combination of keys as the element's assigned access key and return.

4. Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access

key and then return.

5. If this step is reached, the element has no assigned access key.

Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned

access key unless the accesskey content attribute is changed or the element is moved to another Document .

When the user presses the key combination corresponding to the assigned access key for an element, if the element defines a

command , the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a document that has a non-null browsing context, and neither the element nor any of its ancestors has a

hidden attribute specified, then the user agent must trigger the Action of the command.

Note

User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in

response to a specific key combination.



MDN

The accessKey IDL attribute must reflect the accesskey content attribute.

The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key , if any. If the element does not have one, then the IDL attribute must return the empty string.



§





interface mixin ElementContentEditable {

[CEReactions] attribute DOMString contentEditable;

[CEReactions] attribute DOMString enterKeyHint;

readonly attribute boolean isContentEditable;

[CEReactions] attribute DOMString inputMode;

};

The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true , and false . The

empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid value default.

The true state indicates that the element is editable. The inherit state indicates that the element is editable if its parent is. The false state indicates that the element is not editable.

Example

For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write

the article using HTML:





New article

<p>Hello world.</p>





Publish





When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the

contenteditable attribute:





New article

<p>Hello world.</p>

Hello world.





Publish





Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and

other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]



Example

The contenteditable attribute can also be used to great effect:





Live CSS editing!





For web developers (non-normative)

element . contentEditable [ = value ]

Returns " true ", " false ", or " inherit ", based on the state of the contenteditable attribute. Can be set, to change that state.

Throws a "SyntaxError" DOMException if the new value isn't one of those strings.

element . isContentEditable

Returns true if the element is editable; otherwise, returns false.

The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "false" if the content attribute is set to the false state, and "inherit" otherwise. On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string

"true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string

"false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" ✔ MDN

DOMException.

The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.





For web developers (non-normative)

document . designMode [ = value ]

Returns "on" if the document is editable, and "off" if it isn't.

Can be set, to change the document's current state. This focuses the document and resets the selection in that document.

Document objects have an associated design mode enabled, which is a boolean. It is initially false.

The designMode getter steps are to return " on " if this 's design mode enabled is true; otherwise "off".

The designMode setter steps are:

1. Let value be the given value, converted to ASCII lowercase.

2. If value is " on " and this 's design mode enabled is false, then:

1. Set this 's design mode enabled to true.

2. Reset this's active range's start and end boundary points to be at the start of this.

3. Run the focusing steps for this's document element, if non-null.

3. If value is " off ", then set this 's design mode enabled to false.





Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line



wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.

Example

As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing

"yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value

of 'white-space' ('normal'), the resulting markup will either consist of "yellow ball" or "yellow ball"; i.e., there

will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value

for 'white-space' requires adjacent regular spaces to be collapsed together.

In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though

"yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible

indentation from the non-breaking space.

When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words,

and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.





An editing host is either an HTML element with its contenteditable attribute in the true state, or a child HTML element of a

Document whose design mode enabled is true.

The definition of the terms active range, editing host of, and editable, the user interface requirements of elements that are editing

hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(),

queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand . [EXECCOMMAND]





User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of

textarea elements), or in elements in an editing host (e.g. using contenteditable ).

For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:

true-by-default

The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled

through the spellcheck attribute.

false-by-default

The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.

inherit-by-default

The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.



The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the default state, which is the missing value default and the invalid value default.

Note

The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element

is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The

false state indicates that the element is not to be checked.





For web developers (non-normative)

element . spellcheck [ = value ]

Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.

Can be set, to override the default and set the spellcheck content attribute.

The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behavior is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behavior is inherit-by-default

and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.

Note

The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and

therefore might not reflect the actual spellchecking state.

On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".



User agents must only consider the following pieces of text as checkable for the purposes of this feature:

• The value of input elements whose type attributes are in the Text , Search , URL , or Email states and

that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).

• The value of textarea elements that do not have a readonly attribute and that are not disabled .

• Text in Text nodes that are children of editing hosts or editable elements.

• Text in attributes of editable elements.

For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of

input and textarea elements, it is the element itself.

To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:

1. If the user has disabled the checking for this text, then the checking is disabled.

2. Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.

3. Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in

the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.

4. Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the

nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.

5. Otherwise, if the element's default behavior is true-by-default, then checking is enabled.

6. Otherwise, if the element's default behavior is false-by-default, then checking is disabled.

7. Otherwise, if the element's parent element has its checking enabled, then checking is enabled.

8. Otherwise, checking is disabled.

If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections. User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings. UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.

If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.





Example

The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling

errors. In this example, it would not be.





o!





The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's

value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the

default).





Name:





Note

This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand

checking, could perform continuous checking while the checking is enabled, or could use other interfaces.



✔ MDN





Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.

The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.) The autocapitalize attribute can be used on an editing host to control autocapitalization behavior for the hosted editable region, on an input or textarea element to control the behavior for inputting text into that element, or on a form element to control the default behavior for all autocapitalize-inheriting elements associated with the form element.

The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL , Email , or Password states. (This behavior is included in the used autocapitalization hint algorithm below.) The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:

default

The user agent and input method should use make their own determination of whether or not to enable autocapitalization.

none

No autocapitalization should be applied (all letters should default to lowercase).

sentences

The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.

words

The first letter of each word should default to a capital letter; all other letters should default to lowercase.

characters

All letters should default to uppercase.

The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The

autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization



hint , which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:





The invalid value default is the sentences state. The missing value default is the default state.

For web developers (non-normative)

element . autocapitalize [ = value ]

Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and

textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this

element is, in fact, the editing host).

Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).

To compute the own autocapitalization hint of an element element, run the following steps:

1. If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of

the attribute.

2. If element is an autocapitalize-inheriting element and has a non-null form owner, return the own autocapitalization

hint of element 's form owner.

3. Return default.

The autocapitalize getter steps are to:

1. Let state be the own autocapitalization hint of this.

2. If state is default, then return the empty string.

3. If state is none , then return " none ".

4. If state is sentences , then return " sentences".

5. Return the keyword value corresponding to state.

The autocapitalize setter steps are to set the autocapitalize content attribute to the given value.



User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.

User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.

The used autocapitalization hint for an element element is computed using the following algorithm:

1. If element is an input element whose type attribute is in one of the URL , Email , or Password states, then

return default.

2. If element is an input element or a textarea element, then return element 's own autocapitalization hint.

3. If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of

element.

4. Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.





User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).

The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.





The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.

When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.





User agents can support the enterkeyhint attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).

The enterkeyhint content attribute is an enumerated attribute that specifies what action label (or icon) to present for the enter key on virtual keyboards. This allows authors to customize the presentation of the enter key in order to make it more helpful for users.





The enterKeyHint IDL attribute must reflect the enterkeyhint content attribute, limited to only known values.

When enterkeyhint is unspecified (or is in a state not supported by the user agent), the user agent should determine the default action label (or icon) to present. Contextual information such as the inputmode , type , or pattern attributes should be used to determine which action label (or icon) to present on the virtual keyboard.



§





This section defines find-in-page — a common user-agent mechanism which allows users to search through the contents of the page



for particular information.

Access to find-in-page feature is provided via a find-in-page interface. This is a user-agent provided user interface, which allows the user to specify input and the parameters of the search. This interface can appear as a result of a shortcut or a menu selection.

A combination of text input and settings in the find-in-page interface represents the user query. This typically includes the text that the user wants to search for, as well as optional settings (e.g., the ability to restrict the search to whole words only).

The user-agent processes page contents for a given query, and identifies zero or more matches, which are content ranges that satisfy the user query.

One of the matches is identified to the user as the active match. It is highlighted and scrolled into view. The user can navigate through the matches by advancing the active match using the find-in-page interface .



Issue #3539 tracks standardizing how find-in-page underlies the currently-unspecified window.find() API.





The find-in-page process is invoked in the context of a document, and may have an effect on the selection of that document.

Specifically, the range that defines the active match can dictate the current selection. These selection updates, however, can happen at different times during the find-in-page process (e.g. upon the find-in-page interface dismissal or upon a change in the

active match range).



✔ MDN

§



This section defines an event-based drag-and-drop mechanism.

This specification does not define exactly what a drag-and-drop operation actually is.

On a visual medium with a pointing device, a drag operation could be the default action of a mousedown event that is followed by a series of mousemove events, and the drop could be triggered by the mouse being released.

When using an input modality other than a pointing device, users would probably have to explicitly indicate their intention to perform a drag-and-drop operation, stating what they wish to drag and where they wish to drop it, respectively.

However it is implemented, drag-and-drop operations must have a starting point (e.g. where the mouse was clicked, or the start of the selection or element that was selected for the drag), may have any number of intermediate steps (elements that the mouse moves over during a drag, or elements that the user picks as possible drop points as they cycle through possibilities), and must either have an end point (the element above which the mouse button was released, or the element that was finally selected), or be canceled. The end point must be the last element selected as a possible drop point before the drop occurs (so if the operation is not canceled, there must be at least one element in the middle step).





This section is non-normative.

To make an element draggable, give the element a draggable attribute, and set an event listener for dragstart that stores the data being dragged.

The event handler typically needs to check that it's not a text selection that is being dragged, and then needs to store data into the

DataTransfer object and set the allowed effects (copy, move, link, or some combination).

For example:



What fruits do you like?





Apples





Oranges





Pears





To accept a drop, the drop target has to listen to the following events:

1. The dragenter event handler reports whether or not the drop target is potentially willing to accept the drop, by canceling

the event.

2. The dragover event handler specifies what feedback will be shown to the user, by setting the dropEffect attribute of

the DataTransfer associated with the event. This event also needs to be canceled.

3. The drop event handler has a final chance to accept or reject the drop. If the drop is accepted, the event handler must

perform the drop operation on the target. This event needs to be canceled, so that the dropEffect attribute's value can be used by the source. Otherwise, the drop operation is rejected.

For example:



Drop your favorite fruits below:





ondrop="dropHandler(event)">





To remove the original element (the one that was dragged) from the display, the dragend event can be used.

For our example here, that means updating the original markup to handle that event:



What fruits do you like?





...as before...





The data that underlies a drag-and-drop operation, known as the drag data store, consists of the following information:

• A drag data store item list, which is a list of items representing the dragged data, each consisting of the following

information:

The drag data item kind

The kind of data:

Text

Text.

File

Binary data with a file name.

The drag data item type string

A Unicode string giving the type or format of the data, generally given by a MIME type. Some values that are not MIME

types are special-cased for legacy reasons. The API does not enforce the use of MIME types; other values can be used as

well. In all cases, however, the values are all converted to ASCII lowercase by the API.

There is a limit of one text item per item type string.

The actual data

A Unicode or binary string, in some cases with a file name (itself a Unicode string), as per the drag data item kind .

The drag data store item list is ordered in the order that the items were added to the list; most recently added last.

• The following information, used to generate the UI feedback during the drag:

◦ User-agent-defined default feedback information, known as the drag data store default feedback.

◦ Optionally, a bitmap image and the coordinate of a point within that image, known as the drag data store



bitmap and drag data store hot spot coordinate.

• A drag data store mode, which is one of the following:

Read/write mode

For the dragstart event. New data can be added to the drag data store.

Read-only mode

For the drop event. The list of items representing dragged data can be read, including the data. No new data can be added.

Protected mode

For all other events. The formats and kinds in the drag data store list of items representing dragged data can be enumerated, but the data itself is unavailable and no new data can be added.

• A drag data store allowed effects state, which is a string.

When a drag data store is created , it must be initialized such that its drag data store item list is empty, it has no drag data

store default feedback , it has no drag data store bitmap and drag data store hot spot coordinate, its drag data store

mode is protected mode , and its drag data store allowed effects state is the string " uninitialized ".





DataTransfer objects are used to expose the drag data store that underlies a drag-and-drop operation.

[Exposed=Window]

interface DataTransfer {

constructor();

attribute DOMString dropEffect;

attribute DOMString effectAllowed;

[SameObject] readonly attribute DataTransferItemList items;

undefined setDragImage(Element image, long x, long y);

/* old interface */

readonly attribute FrozenArray types;

DOMString getData(DOMString format);

undefined setData(DOMString format, DOMString data);

undefined clearData(optional DOMString format);

[SameObject] readonly attribute FileList files;

};



For web developers (non-normative)

dataTransfer = new DataTransfer()

Creates a new DataTransfer object with an empty drag data store.

dataTransfer . dropEffect [ = value ]

Returns the kind of operation that is currently selected. If the kind of operation isn't one of those that is allowed by the

effectAllowed attribute, then the operation will fail.

Can be set, to change the selected operation.

The possible values are " none ", " copy ", " link ", and " move ".

dataTransfer . effectAllowed [ = value ]

Returns the kinds of operations that are to be allowed.

Can be set (during the dragstart event), to change the allowed operations.

The possible values are " none ", " copy ", " copyLink ", " copyMove ", " link ", " linkMove ", " move ", " all",



and " uninitialized",

dataTransfer . items

Returns a DataTransferItemList object, with the drag data.

dataTransfer . setDragImage(element, x, y)

Uses the given element to update the drag feedback, replacing any previously specified feedback.

dataTransfer . types

Returns a frozen array listing the formats that were set in the dragstart event. In addition, if any files are being dragged, then one of the types will be the string "Files".

data = dataTransfer . getData(format)

Returns the specified data. If there is no such data, returns the empty string.

dataTransfer . setData(format, data)

Adds the specified data.

dataTransfer . clearData ( [ format ] )

Removes the data of the specified formats. Removes all data if the argument is omitted.

dataTransfer . files

Returns a FileList of the files being dragged, if any.

DataTransfer objects that are created as part of drag-and-drop events are only valid while those events are being fired.

A DataTransfer object is associated with a drag data store while it is valid.

A DataTransfer object has an associated types array, which is a FrozenArray<DOMString>, initially empty. When the contents of the DataTransfer object's drag data store item list change, or when the DataTransfer object becomes no longer associated with a drag data store, run the following steps:

1. Let L be an empty sequence.

2. If the DataTransfer object is still associated with a drag data store , then:

1. For each item in the DataTransfer object's drag data store item list whose kind is text, add an entry to L

consisting of the item's type string.

2. If there are any items in the DataTransfer object's drag data store item list whose kind is File, then add

an entry to L consisting of the string "Files". (This value can be distinguished from the other values because it is not lowercase.)

3. Set the DataTransfer object's types array to the result of creating a frozen array from L.

The DataTransfer() constructor, when invoked, must return a newly created DataTransfer object initialized as follows: ⚠ MDN

1. Set the drag data store 's item list to be an empty list.

2. Set the drag data store 's mode to read/write mode.

3. Set the dropEffect and effectAllowed to "none".

The dropEffect attribute controls the drag-and-drop feedback that the user is given during a drag-and-drop operation. When the ✔ MDN

DataTransfer object is created, the dropEffect attribute is set to a string value. On getting, it must return its current value. On setting, if the new value is one of "none", "copy", "link", or "move", then the attribute's current value must be set to the new value. ✔ MDN Other values must be ignored.

The effectAllowed attribute is used in the drag-and-drop processing model to initialize the dropEffect attribute during the

dragenter and dragover events. When the DataTransfer object is created, the effectAllowed attribute is set to a string value. On getting, it must return its current value. On setting, if drag data store 's mode is the read/write mode and the new value is one of "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", or "uninitialized", then the attribute's MDN current value must be set to the new value. Otherwise it must be left unchanged.

The items attribute must return a DataTransferItemList object associated with the DataTransfer object.



The setDragImage(element, x, y) method must run the following steps:

1. If the DataTransfer object is no longer associated with a drag data store , return. Nothing happens.

2. If the drag data store 's mode is not the read/write mode , return. Nothing happens.

3. If element is an img element, then set the drag data store bitmap to the element's image (at its intrinsic size);

otherwise, set the drag data store bitmap to an image generated from the given element (the exact mechanism for doing so is not currently specified).

4. Set the drag data store hot spot coordinate to the given x, y coordinate.

The types attribute must return this DataTransfer object's types array . ✔ MDN

The getData(format) method must run the following steps:

1. If the DataTransfer object is no longer associated with a drag data store , then return the empty string.

2. If the drag data store 's mode is the protected mode, then return the empty string.

3. Let format be the first argument, converted to ASCII lowercase.

4. Let convert-to-URL be false.

5. If format equals "text", change it to "text/plain".

6. If format equals "url", change it to "text/uri-list" and set convert-to-URL to true.

7. If there is no item in the drag data store item list whose kind is text and whose type string is equal to format,

return the empty string.

8. Let result be the data of the item in the drag data store item list whose kind is Plain Unicode string and whose type

string is equal to format.

9. If convert-to-URL is true, then parse result as appropriate for text/uri-list data, and then set result to the first URL from

the list, if any, or the empty string otherwise. [RFC2483]

10. Return result.

The setData(format, data) method must run the following steps:

1. If the DataTransfer object is no longer associated with a drag data store , return. Nothing happens.

2. If the drag data store 's mode is not the read/write mode , return. Nothing happens.

3. Let format be the first argument, converted to ASCII lowercase.

4. If format equals "text", change it to "text/plain".

If format equals "url", change it to "text/uri-list".

5. Remove the item in the drag data store item list whose kind is text and whose type string is equal to format, if

there is one.

6. Add an item to the drag data store item list whose kind is text , whose type string is equal to format, and whose

data is the string given by the method's second argument.

The clearData() method must run the following steps:

1. If the DataTransfer object is no longer associated with a drag data store , return. Nothing happens.

2. If the drag data store 's mode is not the read/write mode , return. Nothing happens.

3. If the method was called with no arguments, remove each item in the drag data store item list whose kind is Plain

Unicode string, and return.

4. Let format be the first argument, converted to ASCII lowercase.

5. If format equals "text", change it to "text/plain".

If format equals "url", change it to "text/uri-list".



6. Remove the item in the drag data store item list whose kind is text and whose type string is equal to format, if

there is one.

Note

The clearData() method does not affect whether any files were included in the drag, so the types attribute's list might still

not be empty after calling ✔ MDN clearData() (it would still contain the " Files " string if any files were included in the drag).

The files attribute must return a live FileList sequence consisting of File objects representing the files found by the following steps. Furthermore, for a given FileList object and a given underlying file, the same File object must be used each time.

1. Start with an empty list L.

2. If the DataTransfer object is no longer associated with a drag data store , the FileList is empty. Return the empty

list L.

3. If the drag data store 's mode is the protected mode, Return the empty list L.

4. For each item in the drag data store item list whose kind is File , add the item's data (the file, in particular its name

and contents, as well as its type) to the list L.

5. The files found by these steps are those in the list L.

Note

This version of the API does not expose the types of the files during the drag.



6.9.3.1 The DataTransferItemList interface

✔ MDN

Each DataTransfer object is associated with a DataTransferItemList object.

[Exposed=Window]

interface DataTransferItemList {

readonly attribute unsigned long length;

getter DataTransferItem (unsigned long index);

DataTransferItem? add(DOMString data, DOMString type);

DataTransferItem? add(File data);

undefined remove(unsigned long index);

undefined clear();

};



For web developers (non-normative)

items . length

Returns the number of items in the drag data store .

items[index]

Returns the DataTransferItem object representing the index th entry in the drag data store .

items . remove(index)

Removes the index th entry in the drag data store.

items . clear()

Removes all the entries in the drag data store .

items . add (data)

items . add (data, type)

Adds a new entry for the given data to the drag data store . If the data is plain text then a type string has to be provided also.

While the DataTransferItemList object's DataTransfer object is associated with a drag data store , the

DataTransferItemList object's mode is the same as the drag data store mode . When the DataTransferItemList object's

DataTransfer object is not associated with a drag data store , the DataTransferItemList object's mode is the disabled mode . The drag data store referenced in this section (which is used only when the DataTransferItemList object is not in the



✔ MDN

disabled mode ) is the drag data store with which the DataTransferItemList object's DataTransfer object is associated.

The length attribute must return zero if the object is in the disabled mode; otherwise it must return the number of items in the drag

data store item list .

When a DataTransferItemList object is not in the disabled mode, its supported property indices are the numbers in the range 0 ..

n -1, where n is the number of items in the drag data store item list.

To determine the value of an indexed property i of a DataTransferItemList object, the user agent must return a

DataTransferItem object representing the i th item in the drag data store. The same object must be returned each time a particular item is obtained from this DataTransferItemList object. The DataTransferItem object must be associated with the ✔ MDN

same DataTransfer object as the DataTransferItemList object when it is first created.

The add() method must run the following steps:

1. If the DataTransferItemList object is not in the read/write mode , return null.

2. Jump to the appropriate set of steps from the following list:

↪ If the first argument to the method is a string

If there is already an item in the drag data store item list whose kind is text and whose type string is equal

to the value of the method's second argument, converted to ASCII lowercase, then throw a "NotSupportedError"

DOMException.

Otherwise, add an item to the drag data store item list whose kind is text , whose type string is equal to the

value of the method's second argument, converted to ASCII lowercase, and whose data is the string given by the method's first argument.

↪ If the first argument to the method is a File

Add an item to the drag data store item list whose kind is File , whose type string is the type of the File,

converted to ASCII lowercase, and whose data is the same as the File's data.

3. Determine the value of the indexed property corresponding to the newly added item, and return that value (a newly

created DataTransferItem object).

The remove() method, when invoked with the argument i, must run these steps:

1. If the DataTransferItemList object is not in the read/write mode , throw an "InvalidStateError" DOMException.

2. Remove the i th item from the drag data store .

The clear() method, if the DataTransferItemList object is in the read/write mode, must remove all the items from the drag ✔ MDN

data store . Otherwise, it must do nothing.



6.9.3.2 The DataTransferItem interface



Each DataTransferItem object is associated with a DataTransfer object.

[Exposed=Window]

interface DataTransferItem {

readonly attribute DOMString kind;

readonly attribute DOMString type;

undefined getAsString(FunctionStringCallback? _callback);

File? getAsFile();

};

callback FunctionStringCallback = undefined (DOMString data);



For web developers (non-normative)

item . kind

Returns the drag data item kind, one of: "string", "file".



item . type

Returns the drag data item type string.

item . getAsString(callback)

Invokes the callback with the string data as the argument, if the drag data item kind is text.

file = item . getAsFile()

Returns a File object, if the drag data item kind is File.

While the DataTransferItem object's DataTransfer object is associated with a drag data store and that drag data store's

drag data store item list still contains the item that the DataTransferItem object represents, the DataTransferItem object's mode is the same as the drag data store mode . When the DataTransferItem object's DataTransfer object is not associated with a drag data store , or if the item that the DataTransferItem object represents has been removed from the relevant drag

data store item list , the DataTransferItem object's mode is the disabled mode . The drag data store referenced in this section (which is used only when the DataTransferItem object is not in the disabled mode ) is the drag data store with which ✔ MDN

the DataTransferItem object's DataTransfer object is associated.

The kind attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return the string given in the cell from the second column of the following table from the row whose cell in the first column contains the drag

data item kind of the item represented by the DataTransferItem object: The type attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return ✔ MDN ✔ MDN

the drag data item type string of the item represented by the DataTransferItem object.

The getAsString(callback) method must run the following steps:

1. If the callback is null, return.

2. If the DataTransferItem object is not in the read/write mode or the read-only mode, return. The callback is never

invoked.

3. If the drag data item kind is not text, then return. The callback is never invoked.

4. Otherwise, queue a task to invoke callback , passing the actual data of the item represented by the DataTransferItem

object as the argument.

The getAsFile() method must run the following steps: ✔ MDN

1. If the DataTransferItem object is not in the read/write mode or the read-only mode, then return null.

2. If the drag data item kind is not File, then return null.

3. Return a new File object representing the actual data of the item represented by the DataTransferItem object.





✔ MDN

The drag-and-drop processing model involves several events. They all use the DragEvent interface.

[Exposed=Window]

interface DragEvent : MouseEvent {

constructor(DOMString type, optional DragEventInit eventInitDict = {});

readonly attribute DataTransfer? dataTransfer;

};

dictionary DragEventInit : MouseEventInit {



DataTransfer? dataTransfer = null;

};



For web developers (non-normative)

event . dataTransfer

Returns the DataTransfer object for the event.



Note

Although, for consistency with other event interfaces, the DragEvent interface has a constructor, it is not particularly useful. In

particular, there's no way to create a useful DataTransfer object from script, as DataTransfer objects have a processing

and security model that is coordinated by the browser during drag-and-drops.



The dataTransfer attribute of the DragEvent interface must return the value it was initialized to. It represents the context information for the event.

When a user agent is required to fire a DND event named e at an element, using a particular drag data store, and optionally with a specific related target, the user agent must run the following steps:

1. Let dataDragStoreWasChanged be false.

2. If no specific related target was provided, set related target to null.

3. Let window be the relevant global object of the Document object of the specified target element.

4. If e is dragstart , then set the drag data store mode to the read/write mode and set dataDragStoreWasChanged to

true.

If e is drop , set the drag data store mode to the read-only mode.

5. Let dataTransfer be a newly created DataTransfer object associated with the given drag data store.

6. Set the effectAllowed attribute to the drag data store 's drag data store allowed effects state .

7. Set the dropEffect attribute to " none " if e is dragstart , drag , or dragleave ; to the value corresponding to

the current drag operation if e is drop or dragend ; and to a value based on the effectAllowed attribute's value

and the drag-and-drop source, as given by the following table, otherwise (i.e. if e is dragenter or dragover):





Where the table above provides possibly appropriate alternatives, user agents may instead use the listed alternative values if platform conventions dictate that the user has requested those alternate effects.

Example

For example, Windows platform conventions are such that dragging while holding the "alt" key indicates a preference for



linking the data, rather than moving or copying it. Therefore, on a Windows system, if " link" is an option according to

the table above while the "alt" key is depressed, the user agent could select that instead of " copy " or " move".

8. Let event be the result of creating an event using DragEvent.

9. Initialize event's type attribute to e, its bubbles attribute to true, its view attribute to window, its relatedTarget attribute

to related target , and its dataTransfer attribute to dataTransfer.

10. If e is not dragleave or dragend, then initialize event's cancelable attribute to true.

11. Initialize event's mouse and key attributes initialized according to the state of the input devices as they would be for user

interaction events.

If there is no relevant pointing device, then initialize event's screenX, screenY, clientX, clientY, and button attributes to 0.

12. Dispatch event at the specified target element.

13. Set the drag data store allowed effects state to the current value of dataTransfer 's effectAllowed attribute. (It can

only have changed value if e is dragstart.)

14. If dataDragStoreWasChanged is true, then set the drag data store mode back to the protected mode.

15. Break the association between dataTransfer and the drag data store .





When the user attempts to begin a drag operation, the user agent must run the following steps. User agents must act as if these steps were run even if the drag actually started in another document or application and the user agent was not aware that the drag was occurring until it intersected with a document under the user agent's purview.

1. Determine what is being dragged, as follows:

If the drag operation was invoked on a selection, then it is the selection that is being dragged.

Otherwise, if the drag operation was invoked on a Document, it is the first element, going up the ancestor chain, starting

at the node that the user tried to drag, that has the IDL attribute draggable set to true. If there is no such element, then nothing is being dragged; return, the drag-and-drop operation is never started.

Otherwise, the drag operation was invoked outside the user agent's purview. What is being dragged is defined by the document or application where the drag was started.

Note

img elements and a elements with an href attribute have their draggable attribute set to true by default.

2. Create a drag data store . All the DND events fired subsequently by the steps in this section must use this drag data

store .

3. Establish which DOM node is the source node, as follows:

If it is a selection that is being dragged, then the source node is the Text node that the user started the drag on (typically

the Text node that the user originally clicked). If the user did not specify a particular node, for example if the user just told

the user agent to begin a drag of "the selection", then the source node is the first Text node containing a part of the selection.

Otherwise, if it is an element that is being dragged, then the source node is the element that is being dragged.

Otherwise, the source node is part of another document or application. When this specification requires that an event be

dispatched at the source node in this case, the user agent must instead follow the platform-specific conventions relevant to that situation.

Note

Multiple events are fired on the source node during the course of the drag-and-drop operation.



4. Determine the list of dragged nodes, as follows:

If it is a selection that is being dragged, then the list of dragged nodes contains, in tree order, every node that is partially or completely included in the selection (including all their ancestors).

Otherwise, the list of dragged nodes contains only the source node , if any.

5. If it is a selection that is being dragged, then add an item to the drag data store item list, with its properties set as

follows:

The drag data item type string

"text/plain"

The drag data item kind

Text

The actual data

The text of the selection

Otherwise, if any files are being dragged, then add one item per file to the drag data store item list , with their properties set as follows:

The drag data item type string

The MIME type of the file, if known, or "application/octet-stream" otherwise.

The drag data item kind

File

The actual data

The file's contents and name.

Note

Dragging files can currently only happen from outside a browsing context , for example from a file system manager application.

If the drag initiated outside of the application, the user agent must add items to the drag data store item list as appropriate for the data being dragged, honoring platform conventions where appropriate; however, if the platform

conventions do not use MIME types to label dragged data, the user agent must make a best-effort attempt to map the types

to MIME types, and, in any case, all the drag data item type strings must be converted to ASCII lowercase.

User agents may also add one or more items representing the selection or dragged element(s) in other forms, e.g. as HTML.

6. If the list of dragged nodes is not empty, then extract the microdata from those nodes into a JSON form , and add one

item to the drag data store item list , with its properties set as follows:

The drag data item type string

application/microdata+json

The drag data item kind

Text

The actual data

The resulting JSON string.

7. Run the following substeps:

1. Let urls be an empty list of absolute URLs.

2. For each node in the list of dragged nodes :

If the node is an a element with an href attribute

Add to urls the result of parsing the element's href content attribute relative to the element's node

document.

If the node is an img element with a src attribute

Add to urls the result of parsing the element's src content attribute relative to the element's node

document.



3. If urls is still empty, then return.

4. Let url string be the result of concatenating the strings in urls, in the order they were added, separated by a

U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).

5. Add one item to the drag data store item list , with its properties set as follows:

The drag data item type string

text/uri-list

The drag data item kind

Text

The actual data

url string

8. Update the drag data store default feedback as appropriate for the user agent (if the user is dragging the selection, then

the selection would likely be the basis for this feedback; if the user is dragging an element, then that element's rendering would be used; if the drag began outside the user agent, then the platform conventions for determining the drag feedback should be used).

9. Fire a DND event named dragstart at the source node.

If the event is canceled, then the drag-and-drop operation should not occur; return.

Note

Since events with no event listeners registered are, almost by definition, never canceled, drag-and-drop is always available to the user if the author does not specifically prevent it.

10. Initiate the drag-and-drop operation in a manner consistent with platform conventions, and as described below.

The drag-and-drop feedback must be generated from the first of the following sources that is available:

1. The drag data store bitmap , if any. In this case, the drag data store hot spot coordinate should be used as

hints for where to put the cursor relative to the resulting image. The values are expressed as distances in CSS

pixels from the left side and from the top side of the image respectively. [CSS]

2. The drag data store default feedback.

From the moment that the user agent is to initiate the drag-and-drop operation, until the end of the drag-and-drop operation, device input events (e.g. mouse and keyboard events) must be suppressed.

During the drag operation, the element directly indicated by the user as the drop target is called the immediate user selection.

(Only elements can be selected by the user; other nodes must not be made available as drop targets.) However, the immediate user

selection is not necessarily the current target element, which is the element currently selected for the drop part of the drag-and-drop operation.

The immediate user selection changes as the user selects different elements (either by pointing at them with a pointing device, or by selecting them in some other way). The current target element changes when the immediate user selection changes, based on the results of event listeners in the document, as described below.

Both the current target element and the immediate user selection can be null, which means no target element is selected. They can also both be elements in other (DOM-based) documents, or other (non-web) programs altogether. (For example, a user could drag text to a word-processor.) The current target element is initially null.

In addition, there is also a current drag operation, which can take on the values "none", "copy", "link", and "move". Initially, it has the value " none". It is updated by the user agent as described in the steps below.

User agents must, as soon as the drag operation is initiated and every 350ms (±200ms) thereafter for as long as the drag operation is ongoing, queue a task to perform the following steps in sequence:

1. If the user agent is still performing the previous iteration of the sequence (if any) when the next iteration becomes due,

return for this iteration (effectively "skipping missed frames" of the drag-and-drop operation).

2. Fire a DND event named drag at the source node. If this event is canceled, the user agent must set the current

drag operation to " none" (no drag operation).



3. If the drag event was not canceled and the user has not ended the drag-and-drop operation, check the state of the drag-

and-drop operation, as follows:

1. If the user is indicating a different immediate user selection than during the last iteration (or if this is the first

iteration), and if this immediate user selection is not the same as the current target element, then update

the current target element as follows:

↪ If the new immediate user selection is null

Set the current target element to null also.

↪ If the new immediate user selection is in a non-DOM document or application

Set the current target element to the immediate user selection.

↪ Otherwise

Fire a DND event named dragenter at the immediate user selection.

If the event is canceled, then set the current target element to the immediate user selection.

Otherwise, run the appropriate step from the following list:

↪ If the immediate user selection is a text control (e.g., textarea , or an input element

whose type attribute is in the Text state) or an editing host or editable element,

and the drag data store item list has an item with the drag data item type string

" text/plain " and the drag data item kind text

Set the current target element to the immediate user selection anyway.

↪ If the immediate user selection is the body element

Leave the current target element unchanged.

↪ Otherwise

Fire a DND event named dragenter at the body element , if there is one, or at the

Document object, if not. Then, set the current target element to the body element , regardless of whether that event was canceled or not.

2. If the previous step caused the current target element to change, and if the previous target element was not

null or a part of a non-DOM document, then fire a DND event named dragleave at the previous target

element, with the new current target element as the specific related target.

3. If the current target element is a DOM element, then fire a DND event named dragover at this current

target element .

If the dragover event is not canceled, run the appropriate step from the following list:

↪ If the current target element is a text control (e.g., textarea , or an input element whose

type attribute is in the Text state) or an editing host or editable element, and the drag

data store item list has an item with the drag data item type string "text/plain" and the

drag data item kind text

Set the current drag operation to either " copy " or " move ", as appropriate given the platform conventions.

↪ Otherwise

Reset the current drag operation to " none".

Otherwise (if the dragover event is canceled), set the current drag operation based on the values of the

effectAllowed and dropEffect attributes of the DragEvent object's dataTransfer object as they

stood after the event dispatch finished, as per the following table:





4. Otherwise, if the current target element is not a DOM element, use platform-specific mechanisms to determine



what drag operation is being performed (none, copy, link, or move), and set the current drag operation accordingly.

5. Update the drag feedback (e.g. the mouse cursor) to match the current drag operation , as follows:





4. Otherwise, if the user ended the drag-and-drop operation (e.g. by releasing the mouse button in a mouse-driven drag-and-

drop interface), or if the drag event was canceled, then this will be the last iteration. Run the following steps, then stop the drag-and-drop operation:

1. If the current drag operation is " none " (no drag operation), or, if the user ended the drag-and-drop operation

by canceling it (e.g. by hitting the Escape key), or if the current target element is null, then the drag operation failed. Run these substeps:

1. Let dropped be false.

2. If the current target element is a DOM element, fire a DND event named dragleave at it;

otherwise, if it is not null, use platform-specific conventions for drag cancelation.

3. Set the current drag operation to " none".

Otherwise, the drag operation might be a success; run these substeps:

1. Let dropped be true.

2. If the current target element is a DOM element, fire a DND event named drop at it; otherwise,

use platform-specific conventions for indicating a drop.

3. If the event is canceled, set the current drag operation to the value of the dropEffect attribute of

the DragEvent object's dataTransfer object as it stood after the event dispatch finished.

Otherwise, the event is not canceled; perform the event's default action, which depends on the exact target as follows:

↪ If the current target element is a text control (e.g., textarea , or an input

element whose type attribute is in the Text state) or an editing host or editable

element, and the drag data store item list has an item with the drag data item type

string " text/plain " and the drag data item kind text

Insert the actual data of the first item in the drag data store item list to have a drag data item

type string of " text/plain " and a drag data item kind that is text into the text control or

editing host or editable element in a manner consistent with platform-specific conventions (e.g. inserting it at the current mouse cursor position, or inserting it at the end of the field).

↪ Otherwise

Reset the current drag operation to " none".

2. Fire a DND event named dragend at the source node.

3. Run the appropriate steps from the following list as the default action of the dragend event:

↪ If dropped is true, the current target element is a text control (see below), the current drag

operation is " move", and the source of the drag-and-drop operation is a selection in the DOM

that is entirely contained within an editing host

Delete the selection.

↪ If dropped is true, the current target element is a text control (see below), the current drag

operation is " move", and the source of the drag-and-drop operation is a selection in a text control

The user agent should delete the dragged selection from the relevant text control.





↪ If dropped is false or if the current drag operation is " none"

The drag was canceled. If the platform conventions dictate that this be represented to the user (e.g. by animating the dragged selection going back to the source of the drag-and-drop operation), then do so.

↪ Otherwise

The event has no default action.

For the purposes of this step, a text control is a textarea element or an input element whose type

attribute is in one of the Text , Search , Tel , URL , Email , Password , or Number states.

Note

User agents are encouraged to consider how to react to drags near the edge of scrollable regions. For example, if a user drags a

link to the bottom of the viewport on a long page, it might make sense to scroll the page so that the user can drop the link lower

on the page.



Note

This model is independent of which Document object the nodes involved are from; the events are fired as described above and

the rest of the processing model runs as described above, irrespective of how many documents are involved in the operation.



MDN





This section is non-normative.

The following events are involved in the drag-and-drop model.





Not shown in the above table: all these events bubble, are composed, and the effectAllowed attribute always has the value it had after the dragstart event, defaulting to " uninitialized " in the dragstart event.





All HTML elements may have the draggable content attribute set. The draggable attribute is an enumerated attribute. It has three states. The first state is true and it has the keyword true. The second state is false and it has the keyword false. The third state is auto ; it has no keywords but it is the missing value default and the invalid value default.

The true state means the element is draggable; the false state means that it is not. The auto state uses the default behavior of the user agent.

An element with a draggable attribute should also have a title attribute that names the element for the purpose of non-visual interactions.





For web developers (non-normative)

element . draggable [ = value ]

Returns true if the element is draggable; otherwise, returns false.

Can be set, to override the default and set the draggable content attribute.

The draggable IDL attribute, whose value depends on the content attribute's in the way described below, controls whether or not the element is draggable. Generally, only text selections are draggable, but elements whose draggable IDL attribute is true become draggable as well.

If an element's draggable content attribute has the state true , the draggable IDL attribute must return true.

Otherwise, if the element's draggable content attribute has the state false , the draggable IDL attribute must return false.

Otherwise, the element's draggable content attribute has the state auto . If the element is an img element, an object

element that represents an image, or an a element with an href content attribute, the draggable IDL attribute must return true; otherwise, the draggable IDL attribute must return false.

If the draggable IDL attribute is set to the value false, the draggable content attribute must be set to the literal value "false".

If the draggable IDL attribute is set to the value true, the draggable content attribute must be set to the literal value "true".





User agents must not make the data added to the DataTransfer object during the dragstart event available to scripts until the

drop event, because otherwise, if a user were to drag sensitive information from one document to a second document, crossing a hostile third document in the process, the hostile document could intercept the data.

For the same reason, user agents must consider a drop to be successful only if the user specifically ended the drag operation — if any scripts end the drag operation, it must be considered unsuccessful (canceled) and the drop event must not be fired.

User agents should take care to not start drag-and-drop operations in response to script actions. For example, in a mouse-and-window environment, if a script moves a window while the user has their mouse button depressed, the UA would not consider that to start a drag. This is important because otherwise UAs could cause data to be dragged from sensitive sources and dropped into hostile documents without the user's consent.

User agents should filter potentially active (scripted) content (e.g. HTML) when it is dragged and when it is dropped, using a safelist of known-safe features. Similarly, relative URLs should be turned into absolute URLs to avoid references changing in unexpected ways. This specification does not specify how this is performed.

Example

Consider a hostile page providing some content and getting the user to select and drag and drop (or indeed, copy and paste) that

content to a victim page's contenteditable region. If the browser does not ensure that only safe content is dragged,

potentially unsafe content such as scripts and event handlers in the selection, once dropped (or pasted) into the victim site, get

the privileges of the victim site. This would thus enable a cross-site scripting attack.





This section describes features that apply most directly to web browsers. Having said that, except where specified otherwise, the requirements defined in this section do apply to all user agents, whether they are web browsers or not.



§



A browsing context is an environment in which Document objects are presented to the user.

Note

A tab or window in a web browser typically contains a browsing context , as does an iframe or frame s in a frameset.

A browsing context has a corresponding WindowProxy object.

A browsing context has an opener browsing context , which is null or a browsing context. It is initially null.

A browsing context has a disowned boolean. It is initially false.

A browsing context has an is closing boolean. It is initially false.

Example

The following example illustrates the various possibilities of a browsing context . It can be disowned , is closing , neither, or

both.

// Neither disowned nor is closing:

const popup1 = window.open();

// Disowned, but not is closing:

const popup2 = window.open();

popup2.opener = null;

// Not disowned, but is closing:

const popup3 = window.open();

popup3.close();

// Disowned, is closing:

const popup4 = window.open();

popup4.opener = null;

popup4.close();



A browsing context has a session history , which lists the Document objects that the browsing context has presented, is presenting, or will present. A Document 's browsing context is the browsing context whose session history contains the

Document , if any such browsing context exists and has not been discarded, and null otherwise.

Note

A Document does not necessarily have a non-null browsing context . In particular, data mining tools are likely to never

instantiate browsing contexts. A Document created using an API such as createDocument() never has a non-null browsing

context . And the Document originally created for an iframe element, which has since been removed from the

document , has no associated browsing context, since that browsing context was discarded.

A browsing context 's active window is its WindowProxy object's [[Window]] internal slot value. A browsing context's active document is its active window 's associated Document .





Note

In general, there is a 1-to-1 mapping from the Window object to the Document object, as long as the Document object has

a non-null browsing context . There is one exception. A Window can be reused for the presentation of a second Document

in the same browsing context , such that the mapping is then 1-to-2. This occurs when a browsing context is navigated

from the initial about:blank Document to another, with historyHandling set to " replace".

A browsing context has a virtual browsing context group ID integer. It is initially 0. This is used by cross-origin opener policy

reporting , to keep track of the browsing context group switches that would have happened if the report-only policy had been enforced.

A browsing context has an initial URL, which is a URL or null. It is initially null.

A browsing context has an opener origin at creation , which is an origin or null. It is initially null.





To set the active document of a browsing context browsingContext to a Document object document, run these steps:

1. Let window be document 's relevant global object .

2. Set browsingContext 's active window to window.

3. Set window 's associated Document to document.

4. Set window 's relevant settings object 's execution ready flag.



A browsing context has an associated creator origin (null or returns an origin ), creator URL (null or returns a URL), and creator base URL (null or returns a URL). These are all initially null.

To determine the origin , given browsing context browsingContext , URL url , sandboxing flag set sandboxFlags, and two

origins invocationOrigin and activeDocumentNavigationOrigin:

1. If sandboxFlags has its sandboxed origin browsing context flag set, then return a new opaque origin .

2. If url is null, then return a new opaque origin.

3. If activeDocumentNavigationOrigin is not null, and url's scheme is "javascript", then return

activeDocumentNavigationOrigin.

4. If invocationOrigin is non-null and url is about:blank, then return invocationOrigin.

Note

The result here is that two documents end up with the same underlying origin , meaning that document.domain affects both.

5. If url is about:srcdoc , then return the origin of browsingContext 's container document.

6. Return url's origin.

To create a new browsing context , given null or a Document object creator, null or an element embedder, and a browsing

context group group, run these steps:

1. Let browsingContext be a new browsing context.

2. If creator is non-null, then set browsingContext 's creator origin to return creator 's origin , browsingContext's creator

URL to return creator 's URL , browsingContext 's creator base URL to return creator 's base URL, and

browsingContext 's virtual browsing context group ID to creator 's top-level browsing context 's virtual browsing context

group ID .

3. Let sandboxFlags be the result of determining the creation sandboxing flags given browsingContext and embedder.

4. Let origin be the result of determining the origin given browsingContext , about:blank, sandboxFlags,



browsingContext 's creator origin , and null.

5. Let permissionsPolicy be the result of creating a permissions policy given browsingContext and origin.

[PERMISSIONSPOLICY]

This needs to use embedder.

6. Let agent be the result of obtaining a similar-origin window agent given origin, group, and false.

7. Let realm execution context be the result of creating a new JavaScript realm given agent and the following

customizations:

◦ For the global object, create a new Window object.

◦ For the global this binding, use browsingContext 's WindowProxy object.

8. Let topLevelCreationURL be about:blank if embedder is null; otherwise embedder 's relevant settings object 's top-level

creation URL .

9. Let topLevelOrigin be origin if embedder is null; otherwise embedder 's relevant settings object 's top-level origin.

10. Set up a window environment settings object with about:blank, realm execution context, null, topLevelCreationURL,

and topLevelOrigin.

11. Let coop be a new cross-origin opener policy.

12. If creator is non-null and creator 's origin is same origin with creator 's relevant settings object 's top-level origin,

then set coop to creator 's browsing context 's top-level browsing context 's active document's cross-origin opener

policy .

13. Let document be a new Document , marked as an HTML document in quirks mode, whose content type is "text/html",

origin is origin , active sandboxing flag set is sandboxFlags , permissions policy is permissionsPolicy, cross-origin

opener policy is coop , and which is ready for post-load tasks.

14. Assert: document 's URL and document 's relevant settings object 's creation URL are about:blank.

15. Ensure that document has a single child html node, which itself has two empty child nodes: a head element, and a

body element.

16. Set the active document of browsingContext to document.

17. If browsingContext 's creator URL is non-null, then set document 's referrer to the serialization of it.

18. If creator is non-null, then set document 's referrer policy to creator 's referrer policy .

19. If creator is non-null, then set document 's embedder policy to creator 's embedder policy.

20. Add document to browsingContext 's session history.

21. Completely finish loading document.

22. Return browsingContext.

To create a new top-level browsing context:

1. Let group be the result of creating a new browsing context group.

2. Return group 's browsing context set[0].

Note

This creates a top-level browsing context .

To create a new auxiliary browsing context , given a browsing context opener:

1. Let group be opener 's top-level browsing context 's group

2. Assert: group is non-null, as navigating invokes this directly.



3. Let browsingContext be the result of creating a new browsing context with opener 's active document, null, and group.

4. Append browsingContext to group.

5. Set browsingContext 's opener browsing context to opener.

6. Set browsingContext 's virtual browsing context group ID to opener 's top-level browsing context's virtual browsing

context group ID .

7. Set browsingContext 's opener origin at creation to opener 's active document 's origin .

8. Legacy-clone a browsing session storage shed with opener 's browsing session and browsingContext's browsing

session . [STORAGE]

9. Return browsingContext.

Note

This creates a top-level browsing context that is also an auxiliary browsing context.

To create a new nested browsing context, given an element element:

1. Let group be element 's node document 's browsing context 's top-level browsing context 's group .

2. Let browsingContext be the result of creating a new browsing context with element's node document, element, and

group.

3. Set element 's nested browsing context to browsingContext.

4. If element has a name attribute, then set browsingContext 's name to the value of this attribute.





Certain elements (for example, iframe elements) can instantiate further browsing contexts. These elements are called browsing context containers.

Each browsing context container has a nested browsing context , which is either a browsing context or null. It is initially null.

The container of a browsing context bc is the browsing context container whose nested browsing context is bc, or null if there is no such element.

Each browsing context bc has a container document, which is the result of running these steps:

1. If bc 's container is null, then return null.

2. Return bc 's container 's node document.

Note

This is equal to bc 's container 's shadow-including root as bc 's container has to be connected.

A browsing context child is said to be a child browsing context of another browsing context parent, if child's container

document is non-null and child 's container document 's browsing context is parent.

A browsing context child is a document-tree child browsing context of parent if child is a child browsing context and child's

container is in a document tree.

A browsing context child may have a parent browsing context . This is the unique browsing context that has child as a child

browsing context , if any such browsing context exists. Otherwise, the browsing context has no parent browsing context.

A browsing context A is said to be an ancestor of a browsing context B if there exists a browsing context A' that is a child browsing

context of A and that is itself an ancestor of B , or if the browsing context A is the parent browsing context of B.

A browsing context that has no parent browsing context is the top-level browsing context for itself and all of the browsing contexts for which it is an ancestor browsing context.



A top-level browsing context has an associated group (null or a browsing context group ). It is initially null.

It is possible to create new browsing contexts that are related to a top-level browsing context while their container is null. Such browsing contexts are called auxiliary browsing contexts . Auxiliary browsing contexts are always top-level browsing contexts.

The transitive closure of parent browsing contexts for a browsing context that is a child browsing context gives the list of

ancestor browsing contexts .

The list of the descendant browsing contexts of a Document d is the (ordered) list returned by the following algorithm:

1. Let list be an empty list.

2. For each browsing context container container , whose nested browsing context is non-null and whose shadow-

including root is d, in shadow-including tree order:

1. Let nestedBC be container 's nested browsing context.

2. Append nestedBC to list.

3. Extend list with the list of the descendant browsing contexts of nestedBC 's active document .

3. Return list.

A Document d is said to be fully active when d 's browsing context is non-null, d 's browsing context 's active document is d , and either d 's browsing context is a top-level browsing context , or d 's browsing context 's container document is fully

active .

Because they are associated with an element, child browsing contexts are always tied to a specific Document in their parent

browsing context . User agents must not allow the user to interact with child browsing contexts of elements that are in

Document s that are not themselves fully active .

Example

The following example illustrates the differences between active and fully active Document objects. Here a.html is

loaded into a browser window, b-1.html starts out loaded into an iframe as shown, and b-2.html and c.html are omitted

(they can simply be an empty document).





Browsing context A





Click me





Browsing context B





At this point, the documents given by a.html , b-1.html , and c.html are all the active documents of their respective browsing

contexts . They are also all fully active.

After clicking on the button , and thus loading a new Document from b-2.html into browsing context B, we have the

following results:

• The a.html Document remains both the active document of browsing context A, and fully active.

• The b-1.html Document is now not the active document of browsing context B. As such it is also not fully

active .

• The new b-2.html Document is now the active document of browsing context B, and is also fully active .





• The c.html Document is still the active document of browsing context C. However, since C's container

document is the b-1.html Document , which is itself not fully active , this means the c.html Document is now

not fully active (even though it is active).

For more explorations of the complexities involved here, especially as it impacts the session history , see A Model of Navigation

History . [NAVMODEL]

A child browsing context can be put into a delaying load events mode . This is used when it is navigated, to delay the load

event of its container before the new Document is created.

The document family of a browsing context consists of the union of all the Document objects in that browsing context's

session history and the document families of all those Document objects. The document family of a Document object consists of the union of all the document families of the browsing contexts in the list of the descendant browsing contexts of the Document object.

The content document of a browsing context container container is the result of the following algorithm:

1. If container 's nested browsing context is null, then return null.

2. Let context be container 's nested browsing context.

3. Let document be context 's active document .

4. If document 's origin and container 's node document 's origin are not same origin-domain , then return null.

5. Return document.



7.1.2.1 Navigating related browsing contexts in the DOM



For web developers (non-normative)

window . top

Returns the WindowProxy for the top-level browsing context.

window . opener [ = value ]

Returns the WindowProxy for the opener browsing context .

Returns null if there isn't one or if it has been set to null.

Can be set to null.

window . parent

Returns the WindowProxy for the parent browsing context.

window . frameElement

Returns the Element for the browsing context container.

Returns null if there isn't one, and in cross-origin situations.



The top attribute's getter must run these steps: ✔ MDN

1. If this Window object's browsing context is null, then return null.

2. Return this Window object's browsing context 's top-level browsing context 's WindowProxy object.

The opener attribute's getter must run these steps: ✔ MDN

1. Let current be this Window object's browsing context.

2. If current is null, then return null.

3. If current 's disowned is true, then return null.

4. If current 's opener browsing context is null, then return null.



5. Return current 's opener browsing context 's WindowProxy object.

The opener attribute's setter must run these steps:

1. If the given value is null and this Window object's browsing context is non-null, then set this Window object's

browsing context 's disowned to true.

2. If the given value is non-null, then return ? OrdinaryDefineOwnProperty (this Window object, "opener", { [[Value]]: the

given value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }).

Note

If a browsing context 's disowned is true, its window.opener attribute is null. That prevents scripts in the browsing

context from changing any properties of its opener browsing context 's Window object (i.e., the Window object from

which the browsing context was created).

Otherwise, if a browsing context 's disowned is false, then scripts in that browsing context can use window.opener to

change properties of its opener browsing context 's Window object. For example, a script running in the browsing context

can change the value of window.opener.location , causing the opener browsing context to navigate to a completely different

document.



The parent attribute's getter must run these steps:

1. Let current be this Window object's browsing context.

2. If current is null, then return null.

3. If current is a child browsing context of another browsing context parent , then return parent 's WindowProxy object.

4. Assert: current is a top-level browsing context .

5. Return current 's WindowProxy object.

The frameElement attribute's getter must run these steps:

1. Let current be this Window object's browsing context.

2. If current is null, then return null.

3. Let container be current 's container.

4. If container is null, then return null.

5. If container 's node document 's origin is not same origin-domain with the current settings object 's origin, then

return null.

6. Return container.

Example

An example of when these IDL attributes can return null is as follows:





Here the browsing context corresponding to iframeWindow was discarded when element was removed from the document.





A browsing context A is familiar with a second browsing context B if one of the following conditions is true:

• Either the origin of the active document of A is the same as the origin of the active document of B, or

• The browsing context A is a child browsing context and its top-level browsing context is B, or

• The browsing context B is an auxiliary browsing context and A is familiar with B 's opener browsing context , or

• The browsing context B is not a top-level browsing context , but there exists an ancestor browsing context of B whose

active document has the same origin as the active document of A (possibly in fact being A itself).



A browsing context A is allowed to navigate a second browsing context B if the following algorithm returns true:

1. If A is not the same browsing context as B , and A is not one of the ancestor browsing contexts of B, and B is not a top-

level browsing context , and A 's active document 's active sandboxing flag set has its sandboxed navigation

browsing context flag set, then return false.

2. Otherwise, if B is a top-level browsing context , and is one of the ancestor browsing contexts of A, then:

1. If A 's active window has transient activation and A 's active document 's active sandboxing flag set has

its sandboxed top-level navigation with user activation browsing context flag set, then return false.

2. Otherwise, if A 's active window does not have transient activation and A 's active document's active

sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set,

then return false.

3. Otherwise, if B is a top-level browsing context , and is neither A nor one of the ancestor browsing contexts of A, and A's

Document 's active sandboxing flag set has its sandboxed navigation browsing context flag set, and A is not the one

permitted sandboxed navigator of B, then return false.

4. Return true.



An element has a browsing context scope origin if its Document 's browsing context is a top-level browsing context or if all of its Document 's ancestor browsing contexts all have active documents whose origin are the same origin as the element's node document 's origin . If an element has a browsing context scope origin , then its value is the origin of the element's node document.





A user agent holds a browsing context group set (a set of browsing context groups).

A browsing context group holds a browsing context set (a set of top-level browsing contexts).

Note

A top-level browsing context is added to the group when the group is created . All subsequent top-level browsing

contexts added to the group will be auxiliary browsing contexts.

A browsing context group has an associated agent cluster map (a weak map of agent cluster keys to agent clusters). User agents are responsible for collecting agent clusters when it is deemed that nothing can access them anymore.

A browsing context group has a cross-origin isolated boolean. It is initially false.



A browsing context group has an associated historical agent cluster key map , which is a map of origins to agent cluster

keys . This map is used to ensure the consistency of the origin-keyed agent clusters feature by recording what agent cluster keys were previously used for a given origin.

Note

The historical agent cluster key map only ever gains entries over the lifetime of the browsing context group.

To create a new browsing context group, run these steps:

1. Let group be a new browsing context group.

2. Append group to the user agent's browsing context group set .

3. Let browsingContext be the result of creating a new browsing context with null, null, and group.

4. Append browsingContext to group.

5. Return group.

To append a top-level browsing context browsingContext to a browsing context group group, run these steps:

1. Append browsingContext to group 's browsing context set .

2. Set browsingContext 's group to group.

To remove a top-level browsing context browsingContext, run these steps:

1. Assert: browsingContext 's group is non-null, because a browsing context only gets discarded once.

2. Let group be browsingContext 's group .

3. Set browsingContext 's group to null.

4. Remove browsingContext from group 's browsing context set.

5. If group 's browsing context set is empty , then remove group from the user agent's browsing context group set .

Note

Append and remove are primitive operations that help define the lifetime of a browsing context group. They are called

from creating a new browsing context group , creating a new auxiliary browsing context , and discarding a browsing

context .



Note

The HTML Standard used to define "unit of related browsing contexts" and "unit of related similar-origin browsing contexts". These

have been removed as they were not adequate.





Browsing contexts can have a browsing context name. Unless stated otherwise, it is the empty string.

A valid browsing context name is any string with at least one character that does not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for special keywords.) A valid browsing context name or keyword is any string that is either a valid browsing context name or that is an ASCII case-

insensitive match for one of: _blank, _self, _parent, or _top.

These values have different meanings based on whether the page is sandboxed or not, as summarized in the following (non-normative) table. In this table, "current" means the browsing context that the link or script is in, "parent" means the parent browsing

context of the one the link or script is in, "top" means the top-level browsing context of the one the link or script is in, "new"

means a new top-level browsing context or auxiliary browsing context is to be created, subject to various user preferences and user agent policies, "none" means that nothing will happen, and "maybe new" means the same as "new" if the " allow-popups"



keyword is also specified on the sandbox attribute (or if the user overrode the sandboxing), and the same as "none" otherwise.





The rules for choosing a browsing context , given a browsing context name name , a browsing context current, and a boolean noopener are as follows:

1. Let chosen be null.

2. Let windowType be "existing or none".

3. Let sandboxingFlagSet be current 's active document 's active sandboxing flag set .

4. If name is the empty string or an ASCII case-insensitive match for "_self", then set chosen to current.

5. Otherwise, if name is an ASCII case-insensitive match for " _parent ", set chosen to current 's parent browsing context, if

any, and current otherwise.

6. Otherwise, if name is an ASCII case-insensitive match for " _top ", set chosen to current 's top-level browsing context , if

any, and current otherwise.

7. Otherwise, if name is not an ASCII case-insensitive match for " _blank ", there exists a browsing context whose name is

the same as name , current is familiar with that browsing context, and the user agent determines that the two browsing contexts are related enough that it is ok if they reach each other, set chosen to that browsing context. If there are multiple matching browsing contexts, the user agent should set chosen to one in some arbitrary consistent manner, such as the most recently opened, most recently focused, or more closely related.

This will be made more precise in issue #313.

8. Otherwise, a new browsing context is being requested, and what happens depends on the user agent's configuration and

abilities — it is determined by the rules given for the first applicable option from the following list:

↪ If current 's active window does not have transient activation and the user agent has been configured

to not show popups (i.e., the user agent has a "popup blocker" enabled)

The user agent may inform the user that a popup has been blocked.





↪ If sandboxingFlagSet has the sandboxed auxiliary navigation browsing context flag set

The user agent may report to a developer console that a popup has been blocked.

↪ If the user agent has been configured such that in this instance it will create a new browsing context

1. Set windowType to "new and unrestricted".

2. If current 's top-level browsing context 's active document 's cross-origin opener policy 's value is

" same-origin " or " same-origin-plus-COEP ", then:

1. Let currentDocument be current 's active document.

2. If currentDocument 's origin is not same origin with currentDocument's relevant settings

object 's top-level origin , then set noopener to true, name to "_blank", and windowType to "new with no opener".

Note

In the presence of a cross-origin opener policy , nested documents that are cross-origin with their top-level browsing context's active document always set noopener to true.

3. If noopener is true, then set chosen to the result of creating a new top-level browsing context .

4. Otherwise:

1. Set chosen to the result of creating a new auxiliary browsing context with current.

2. If sandboxingFlagSet 's sandboxed navigation browsing context flag is set, then current must

be set as chosen 's one permitted sandboxed navigator.

5. If sandboxingFlagSet 's sandbox propagates to auxiliary browsing contexts flag is set, then all the flags

that are set in sandboxingFlagSet must be set in chosen 's popup sandboxing flag set.

6. If name is not an ASCII case-insensitive match for " _blank ", then set chosen 's name to name.

Note

If the newly created browsing context is immediately navigated , then the navigation will be done with

historyHandling set to " replace ".



↪ If the user agent has been configured such that in this instance it will reuse current

Set chosen to current.

↪ If the user agent has been configured such that in this instance it will not find a browsing context

Do nothing.

Note

User agents are encouraged to provide a way for users to configure the user agent to always reuse current.

9. Return chosen and windowType.



§



Although typically objects cannot be accessed across origins, the web platform would not be true to itself if it did not have some legacy exceptions to that rule that the web depends upon.





When perform a security check is invoked, with a platformObject, identifier, and type, run these steps:

1. If platformObject is not a Window or Location object, then return.



2. For each e of ! CrossOriginProperties (platformObject):

1. If SameValue(e.[[Property]], identifier) is true, then:

1. If type is "method" and e has neither [[NeedsGet]] nor [[NeedsSet]], then return.

2. Otherwise, if type is "getter" and e.[[NeedsGet]] is true, then return.

3. Otherwise, if type is "setter" and e.[[NeedsSet]] is true, then return.

3. If ! IsPlatformObjectSameOrigin(platformObject) is false, then throw a "SecurityError" DOMException.





Window and Location objects both have a [[CrossOriginPropertyDescriptorMap]] internal slot, whose value is initially an empty map.

Note

The [[CrossOriginPropertyDescriptorMap]] internal slot contains a map with entries whose keys are (currentGlobal,

objectGlobal, propertyKey)-tuples and values are property descriptors, as a memoization of what is visible to scripts when

currentGlobal inspects a Window or Location object from objectGlobal. It is filled lazily by

CrossOriginGetOwnPropertyHelper , which consults it on future lookups.

User agents should allow a value held in the map to be garbage collected along with its corresponding key when nothing holds a reference to any part of the value. That is, as long as garbage collection is not observable.

Example

For example, with const href = Object.getOwnPropertyDescriptor(crossOriginLocation, "href").set the value and its

corresponding key in the map cannot be garbage collected as that would be observable.

User agents may have an optimization whereby they remove key-value pairs from the map when document.domain is set. This is not observable as document.domain cannot revisit an earlier value.

Example

For example, setting document.domain to "example.com" on www.example.com means user agents can remove all key-value

pairs from the map where part of the key is www.example.com, as that can never be part of the origin again and therefore the

corresponding value could never be retrieved from the map.





7.2.3.1 CrossOriginProperties ( O )



1. Assert: O is a Location or Window object.

2. If O is a Location object, then return « { [[Property]]: "href", [[NeedsGet]]: false, [[NeedsSet]]: true }, { [[Property]]:

"replace" } ».

3. Return « { [[Property]]: "window", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "self", [[NeedsGet]]: true,

[[NeedsSet]]: false }, { [[Property]]: "location", [[NeedsGet]]: true, [[NeedsSet]]: true }, { [[Property]]: "close" }, { [[Property]]: "closed", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "focus" }, { [[Property]]: "blur" }, { [[Property]]: "frames", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "length", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "top", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "opener", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "parent", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "postMessage" } ».

Note

Indexed properties do not need to be safelisted in this algorithm, as they are handled directly by the WindowProxy object.





A JavaScript property name P is a cross-origin accessible window property name if it is "window", "self", "location", "close",

"closed", "focus", "blur", "frames", "length", "top", "opener", "parent", "postMessage", or an array index property name.



7.2.3.2 CrossOriginPropertyFallback ( P )



1. If P is " then ", @@toStringTag , @@hasInstance , or @@isConcatSpreadable, then return PropertyDescriptor{ [[Value]]:

undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.

2. Throw a "SecurityError" DOMException.



7.2.3.3 IsPlatformObjectSameOrigin ( O )



1. Return true if the current settings object 's origin is same origin-domain with O 's relevant settings object's

origin , and false otherwise.

Note

Here the current settings object roughly corresponds to the "caller", because this check occurs before the execution context for

the getter/setter/method in question makes its way onto the JavaScript execution context stack. For example, in the code

w.document , this step is invoked before the document getter is reached as part of the [[Get]] algorithm for the

WindowProxy w.



7.2.3.4 CrossOriginGetOwnPropertyHelper ( O, P )



Note

If this abstract operation returns undefined and there is no custom behavior, the caller needs to throw a "SecurityError"

DOMException . In practice this is handled by the caller calling CrossOriginPropertyFallback.

1. Let crossOriginKey be a tuple consisting of the current settings object , O 's relevant settings object , and P.

2. For each e of ! CrossOriginProperties (O):

1. If SameValue(e.[[Property]], P) is true, then:

1. If the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O contains an entry whose key

is crossOriginKey, then return that entry's value.

2. Let originalDesc be OrdinaryGetOwnProperty(O, P).

3. Let crossOriginDesc be undefined.

4. If e.[[NeedsGet]] and e.[[NeedsSet]] are absent, then:

1. Let value be originalDesc.[[Value]].

2. If ! IsCallable(value) is true, then set value to an anonymous built-in function, created in the

current Realm Record, that performs the same steps as the IDL operation P on object O.

3. Set crossOriginDesc to PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]:

false, [[Configurable]]: true }.

5. Otherwise:

1. Let crossOriginGet be undefined.

2. If e.[[NeedsGet]] is true, then set crossOriginGet to an anonymous built-in function, created in

the current Realm Record, that performs the same steps as the getter of the IDL attribute P on object O.

3. Let crossOriginSet be undefined.



4. If e.[[NeedsSet]] is true, then set crossOriginSet to an anonymous built-in function, created in

the current Realm Record, that performs the same steps as the setter of the IDL attribute P on object O.

5. Set crossOriginDesc to PropertyDescriptor{ [[Get]]: crossOriginGet, [[Set]]: crossOriginSet,

[[Enumerable]]: false, [[Configurable]]: true }.

6. Create an entry in the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O with key

crossOriginKey and value crossOriginDesc.

7. Return crossOriginDesc.

3. Return undefined.

Note

The reason that the property descriptors produced here are configurable is to preserve the invariants of the essential internal

methods required by the JavaScript specification. In particular, since the value of the property can change as a consequence of

navigation, it is required that the property be configurable. (However, see tc39/ecma262 issue #672 and references to it elsewhere

in this specification for cases where we are not able to preserve these invariants, for compatibility with existing web content.)

[JAVASCRIPT]



Note

The reason the property descriptors are non-enumerable, despite this mismatching the same-origin behavior, is for compatibility

with existing web content. See issue #3183 for details.



7.2.3.5 CrossOriginGet ( O, P, Receiver )



1. Let desc be ? O.[[GetOwnProperty]](P).

2. Assert: desc is not undefined.

3. If ! IsDataDescriptor(desc) is true, then return desc.[[Value]].

4. Assert: IsAccessorDescriptor(desc) is true.

5. Let getter be desc.[[Get]].

6. If getter is undefined, then throw a "SecurityError" DOMException.

7. Return ? Call(getter, Receiver).



7.2.3.6 CrossOriginSet ( O, P, V, Receiver )



1. Let desc be ? O.[[GetOwnProperty]](P).

2. Assert: desc is not undefined.

3. If desc.[[Set]] is present and its value is not undefined, then:

1. Perform ? Call(setter, Receiver, «V»).

2. Return true.

4. Throw a "SecurityError" DOMException.



7.2.3.7 CrossOriginOwnPropertyKeys ( O )



1. Let keys be a new empty List.



2. For each e of ! CrossOriginProperties (O), append e.[[Property]] to keys.

3. Return the concatenation of keys and « " then ", @@toStringTag , @@hasInstance , @@isConcatSpreadable ».



§



[Global=Window,

Exposed=Window,

LegacyUnenumerableNamedProperties]

interface Window : EventTarget {

// the current browsing context

[LegacyUnforgeable] readonly attribute WindowProxy window;

[Replaceable] readonly attribute WindowProxy self;

[LegacyUnforgeable] readonly attribute Document document;

attribute DOMString name;

[PutForwards=href, LegacyUnforgeable] readonly attribute Location location;

readonly attribute History history;

readonly attribute CustomElementRegistry customElements;

[Replaceable] readonly attribute BarProp locationbar;

[Replaceable] readonly attribute BarProp menubar;

[Replaceable] readonly attribute BarProp personalbar;

[Replaceable] readonly attribute BarProp scrollbars;

[Replaceable] readonly attribute BarProp statusbar;

[Replaceable] readonly attribute BarProp toolbar;

attribute DOMString status;

undefined close();

readonly attribute boolean closed;

undefined stop();

undefined focus();

undefined blur();

// other browsing contexts

[Replaceable] readonly attribute WindowProxy frames;

[Replaceable] readonly attribute unsigned long length;

[LegacyUnforgeable] readonly attribute WindowProxy? top;

attribute any opener;

[Replaceable] readonly attribute WindowProxy? parent;

readonly attribute Element? frameElement;

WindowProxy? open(optional USVString url = "", optional DOMString target = "_blank", optional

[LegacyNullToEmptyString] DOMString features = "");

getter object (DOMString name);

// Since this is the global object, the IDL named getter adds a NamedPropertiesObject exotic // object on the prototype chain. Indeed, this does not make the global object an exotic object.

// Indexed access is taken care of by the WindowProxy exotic object.

// the user agent

readonly attribute Navigator navigator;

readonly attribute boolean originAgentCluster;

// user prompts

undefined alert();

undefined alert(DOMString message);

boolean confirm(optional DOMString message = "");

DOMString? prompt(optional DOMString message = "", optional DOMString default = "");

undefined print();

undefined postMessage(any message, USVString targetOrigin, optional sequence<object> transfer = []);

undefined postMessage(any message, optional WindowPostMessageOptions options = {});



Note

// also has obsolete members

};

Window includes GlobalEventHandlers;

Window includes WindowEventHandlers;

dictionary WindowPostMessageOptions : PostMessageOptions {

USVString targetOrigin = "/";

};



For web developers (non-normative)

window . window

window . frames

window . self

These attributes all return window.

window . document

Returns the Document associated with window.

document . defaultView

Returns the Window object of the active document.

The Window object has an associated Document , which is a Document object. It is set when the Window object is created, and only ever changed during navigation from the initial about:blank Document.

The Window object's browsing context is the Window object's associated Document 's browsing context. It is either ✔ MDN

null or a browsing context.

The window , frames , and self attributes' getters must return this Window object's relevant Realm.[[GlobalEnv]]'s ✔ MDN

EnvironmentRecord's [[GlobalThisValue]].

The document IDL attribute, on getting, must return this Window object's associated Document.

Note

The Document object associated with a Window object can change in exactly one case: when the navigate algorithm

creates a new Document object for the first page loaded in a browsing context . In that specific case, the Window object of

the original ✔ MDN about:blank page is reused and gets a new Document object.

The defaultView attribute's getter, when invoked, must run these steps:

1. If this Document object's browsing context is null, then return null.

2. Return this Document object's browsing context 's WindowProxy object.



For historical reasons, Window objects must also have a writable, configurable, non-enumerable property named HTMLDocument ✔ MDN

whose value is the Document interface object.





For web developers (non-normative)

window = window . open( [ url [, target [, features ] ] ] )

Opens a window to show url (defaults to about:blank), and returns it. The target argument gives the name of the new window. If a window exists with that name already, it is reused. The features argument can be used to influence the rendering of the new window.





window . name [ = value ]

Returns the name of the window.

Can be set, to change the name.

window . close()

Closes the window.

window . closed

Returns true if the window has been closed, false otherwise.

window . stop()

Cancels the document load.

The window open steps, given a string url, a string target, and a string features, are as follows:

1. If the event loop 's termination nesting level is nonzero, return null.

2. Let source browsing context be the entry global object 's browsing context .

3. If target is the empty string, then set target to "_blank".

4. Let tokenizedFeatures be the result of tokenizing features.

5. Let noopener and noreferrer be false.

6. If tokenizedFeatures["noopener"] exists, then:

1. Set noopener to the result of parsing tokenizedFeatures [" noopener "] as a boolean feature.

2. Remove tokenizedFeatures["noopener"].

7. If tokenizedFeatures["noreferrer"] exists, then:

1. Set noreferrer to the result of parsing tokenizedFeatures [" noreferrer "] as a boolean feature.

2. Remove tokenizedFeatures["noreferrer"].

8. If noreferrer is true, then set noopener to true.

9. Let target browsing context and windowType be the result of applying the rules for choosing a browsing context given

target, source browsing context, and noopener.

Example

If there is a user agent that supports control-clicking a link to open it in a new tab, and the user control-clicks on an

element whose onclick handler uses the window.open() API to open a page in an iframe element, the user agent could override the selection of the target browsing context to instead target a new tab.

10. Let new be true if windowType is either "new and unrestricted" or "new with no opener", and false otherwise.

11. If target browsing context is null, then return null.

12. If new is true, then set up browsing context features for target browsing context given tokenizedFeatures . [CSSOMVIEW]

13. Let urlRecord be the URL " about:blank".

14. If url is not the empty string or new is true, then:

1. If url is not the empty string, then parse url relative to the entry settings object, and set urlRecord to the

resulting URL record , if any. If the parse a URL algorithm failed, then throw a "SyntaxError" DOMException.

2. Let request be a new request whose URL is urlRecord.

3. If noreferrer is true, then set request's referrer to "noreferrer".

4. Let window be target browsing context 's active window.

5. If urlRecord is " about:blank " and new is true, then queue a global task on the networking task source



given window to fire an event named load at window, with the legacy target override flag set.

6. Otherwise:

1. Let historyHandling be " replace " if new is true; otherwise " default ".

2. Navigate target browsing context to request , with exceptionsEnabled set to true,

historyHandling set to historyHandling , and the source browsing context set to source browsing context.

15. If noopener is true or windowType is "new with no opener", then return null.

16. Otherwise, if new is false, set target browsing context 's opener browsing context to source browsing context.

Note

If new is true this is done as part of creating a new auxiliary browsing context .

17. Return target browsing context 's WindowProxy object.

The open( url , target , features ) method on Window objects provides a mechanism for navigating an existing browsing ✔ MDN

context or opening and navigating an auxiliary browsing context .

When the method is invoked, the user agent must run the window open steps with url, target, and features.



To tokenize the features argument:

1. Let tokenizedFeatures be a new ordered map.

2. Let position point at the first code point of features.

3. While position is not past the end of features:

1. Let name be the empty string.

2. Let value be the empty string.

3. Collect a sequence of code points that are feature separators from features given position. This skips past

leading separators before the name.

4. Collect a sequence of code points that are not feature separators from features given position. Set name to the

collected characters, converted to ASCII lowercase.

5. Set name to the result of normalizing the feature name name.

6. While position is not past the end of features and the code point at position in features is not U+003D (=):

1. If the code point at position in features is U+002C (,), or if it is not a feature separator , then break.

2. Advance position by 1.

Note

This skips to the first U+003D (=) but does not skip past a U+002C (,) or a non-separator.

7. If the code point at position in features is a feature separator:

1. While position is not past the end of features and the code point at position in features is a feature

separator :

1. If the code point at position in features is U+002C (,), then break.

2. Advance position by 1.

Note

This skips to the first non-separator but does not skip past a U+002C (,).

2. Collect a sequence of code points that are not feature separators code points from features given

position. Set value to the collected code points, converted to ASCII lowercase.



8. If name is not the empty string, then set tokenizedFeatures[name] to value.

4. Return tokenizedFeatures.

A code point is a feature separator if it is ASCII whitespace, U+003D (=), or U+002C (,).

For legacy reasons, there are some aliases of some feature names. To normalize a feature name name, switch on name:

↪ "screenx"

Return "left".

↪ "screeny"

Return "top".

↪ "innerwidth"

Return "width".

↪ "innerheight"

Return "height".

↪ Anything else

Return name.

To parse a boolean feature given a string value:

1. If value is the empty string, then return true.

2. If value is "yes", then return true.

3. Let parsed be the result of parsing value as an integer.

4. If parsed is an error, then set it to 0.

5. Return false if parsed is 0, and true otherwise.



The name attribute's getter must run these steps:

1. If this Window object's browsing context is null, then return the empty string.

2. Return this Window object's browsing context 's name.

The name attribute's setter must run these steps:

1. If this Window object's browsing context is null, then return.

2. Set this Window object's browsing context 's name to the given value.

Note

The name gets reset when the browsing context is navigated to another origin.



The close() method must run these steps:

1. Let current be this Window object's browsing context.

2. If current is null or its is closing is true, then return.

3. If all the following are true

◦ current is script-closable

◦ the incumbent global object 's browsing context is familiar with current

◦ the incumbent global object 's browsing context is allowed to navigate current

then:

1. Set current 's is closing to true.

2. Queue a task on the DOM manipulation task source to close current.



A browsing context is script-closable if it is an auxiliary browsing context that was created by a script (as opposed to by an action of the user), or if it is a top-level browsing context whose session history contains only one Document.

The closed attribute's getter must return true if this Window object's browsing context is null or its is closing is true, and false ✔ MDN otherwise.

The stop() method must stop document loading given this Window object's associated Document.





For web developers (non-normative)

window . length

Returns the number of document-tree child browsing contexts .

window[index]

Returns the indicated document-tree child browsing context .

The number of document-tree child browsing contexts of a Window object W is the result of running these steps:

1. If W 's browsing context is null, then return 0.

2. Return the number of document-tree child browsing contexts of W 's browsing context .

The length IDL attribute's getter must return the number of document-tree child browsing contexts of this Window object. ✔ MDN

Note

Indexed access to document-tree child browsing contexts is defined through the [[GetOwnProperty]] internal method of the

WindowProxy object.





For web developers (non-normative)

window[name]

Returns the indicated element or collection of elements.

As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the web platform, for example. Instead of this, use document.getElementById() or document.querySelector().

The document-tree child browsing context name property set of a Window object window is the return value of running these steps:

1. If window 's browsing context is null, then return the empty list.

2. Let childBrowsingContexts be all document-tree child browsing contexts of window 's browsing context whose browsing

context name is not the empty string, in order, and including only the first document-tree child browsing context with

a given name if multiple document-tree child browsing contexts have the same one.

3. Remove each browsing context from childBrowsingContexts whose active document 's origin is not same origin

with window 's relevant settings object 's origin and whose browsing context name does not match the name of its

container 's name content attribute value.

4. Return the browsing context names of childBrowsingContexts, in the same order.

Example

This means that in the following example, hosted on https://example.org/, assuming https://elsewhere.example/ sets





window.name to "spices", evaluating window.spices after everything has loaded will yield undefined:





The Window object supports named properties . The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates:

• window 's document-tree child browsing context name property set;

• the value of the name content attribute for all embed , form , img , and object elements that have a non-empty

name content attribute and are in a document tree with window 's associated Document as their root; and

• the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a

document tree with window 's associated Document as their root.

To determine the value of a named property name in a Window object window, the user agent must return the value obtained using the following steps:

1. Let objects be the list of named objects of window with the name name.

Note

There will be at least one such object, by definition.

2. If objects contains a browsing context , then return the WindowProxy object of the nested browsing context of the

first browsing context container in tree order whose nested browsing context is in objects.

3. Otherwise, if objects has only one element, return that element.

4. Otherwise return an HTMLCollection rooted at window 's associated Document , whose filter matches only named

objects of window with the name name. (By definition, these will all be elements.) Named objects of Window object window with the name name, for the purposes of the above algorithm, consist of the following:

• document-tree child browsing contexts of window 's associated Document whose name is name;

• embed , form , img , or object elements that have a name content attribute whose value is name and are in a

document tree with window 's associated Document as their root; and

• HTML elements that have an id content attribute whose value is name and are in a document tree with window's

associated Document as their root.





To discard a Document document:

1. Set document 's salvageable state to false.

2. Run any unloading document cleanup steps for document that are defined by this specification and other applicable

specifications .

3. Abort document.

4. Remove any tasks associated with document in any task source , without running those tasks.

5. Discard all the child browsing contexts of document.

6. For each session history entry entry whose document is equal to document , set entry 's document to null.

7. Set document 's browsing context to null.

8. Remove document from the owner set of each WorkerGlobalScope object whose set contains document.



9. For each workletGlobalScope in document 's worklet global scopes , terminate workletGlobalScope.

To discard a browsing context browsingContext, run these steps:

1. Discard all Document objects for all the entries in browsingContext 's session history.

2. If browsingContext is a top-level browsing context , then remove browsingContext.

User agents may discard top-level browsing contexts at any time (typically, in response to user requests, e.g., when a user force-closes a window containing one or more top-level browsing contexts ). Other browsing contexts must be discarded once their WindowProxy object is eligible for garbage collection, in addition to the other places where this specification requires them to be discarded.





To close a browsing context browsingContext, run these steps:

1. Prompt to unload browsingContext 's active document . If the user refused to allow the document to be unloaded ,

then return.

2. Unload browsingContext 's active document .

3. Remove browsingContext from the user interface (e.g., close or hide its tab in a tabbed browser).

4. Discard browsingContext.

User agents should offer users the ability to arbitrarily close any top-level browsing context.





To allow web pages to integrate with web browsers, certain web browser interface elements are exposed in a limited way to scripts in web pages.

Each interface element is represented by a BarProp object:

[Exposed=Window]

interface BarProp {

readonly attribute boolean visible;

};



For web developers (non-normative)

window . locationbar . visible

Returns true if the location bar is visible; otherwise, returns false.

window . menubar . visible

Returns true if the menu bar is visible; otherwise, returns false.

window . personalbar . visible

Returns true if the personal bar is visible; otherwise, returns false.

window . scrollbars . visible

Returns true if the scrollbars are visible; otherwise, returns false.

window . statusbar . visible

Returns true if the status bar is visible; otherwise, returns false.

window . toolbar . visible

Returns true if the toolbar is visible; otherwise, returns false.

The visible attribute's getter must run these steps:



1. If this BarProp object's relevant global object 's browsing context is null, then return false.

2. If the user agent does not have a user interface element that the object represents, as described below, then return true.

3. Return true or a value determined by the user agent to most accurately represent the visibility state of the user interface

element that the object represents, as described below.

The following BarProp objects must exist for each Window object:

The location bar BarProp object

Represents the user interface element that contains a control that displays the URL of the active document , or some similar interface concept.

The menu bar BarProp object

Represents the user interface element that contains a list of commands in menu form, or some similar interface concept.

The personal bar BarProp object

Represents the user interface element that contains links to the user's favorite pages, or some similar interface concept.

The scrollbar BarProp object

Represents the user interface element that contains a scrolling mechanism, or some similar interface concept.

The status bar BarProp object

Represents a user interface element found immediately below or after the document, as appropriate for the user's media, which typically provides information about ongoing network activity or information about elements that the user's pointing device is current indicating. If the user agent has no such user interface element, then the object may act as if the corresponding user

interface element was absent (i.e. its visible attribute may return false).

The toolbar BarProp object

Represents the user interface element found immediately above or before the document, as appropriate for the user's media, which

typically provides session history traversal controls (back and forward buttons, reload buttons, etc). If the user agent has no

such user interface element, then the object may act as if the corresponding user interface element was absent (i.e. its visible attribute may return false).

The locationbar attribute must return the location bar BarProp object .

✔ MDN

The menubar attribute must return the menu bar BarProp object.



The personalbar attribute must return the personal bar BarProp object .

✔ MDN

The scrollbars attribute must return the scrollbar BarProp object .

✔ MDN

The statusbar attribute must return the status bar BarProp object.

The toolbar attribute must return the toolbar BarProp object.



For historical reasons, the status attribute on the Window object must, on getting, return the last string it was set to, and on setting, must set itself to the new value. When the Window object is created, the attribute must be set to the empty string. It does not do anything else.





To set up a window environment settings object, given a URL creationURL, a JavaScript execution context execution context, null or an environment reservedEnvironment , a URL topLevelCreationURL , and an origin topLevelOrigin, run these steps:

1. Let realm be the value of execution context's Realm component.

2. Let window be realm 's global object.

3. Let settings object be a new environment settings object whose algorithms are defined as follows:

The realm execution context

Return execution context.



The module map

Return the module map of window 's associated Document.

The responsible document

Return window 's associated Document .

The API URL character encoding

Return the current character encoding of window 's associated Document.

The API base URL

Return the current base URL of window 's associated Document .

The origin

Return the origin of window 's associated Document.

The referrer policy

1. Let document be window 's associated Document .

2. While document is an iframe srcdoc document and document 's referrer policy is the empty string, set

document to document 's browsing context 's container document.

3. Return document 's referrer policy .

The embedder policy

Return window 's associated Document 's embedder policy.

The cross-origin isolated capability

Return the logical conjunction of realm 's agent cluster 's cross-origin isolated and whether window's associated

Document is allowed to use the " cross-origin-isolated" feature.

4. If reservedEnvironment is non-null, then:

1. Set settings object 's id to reservedEnvironment 's id , target browsing context to reservedEnvironment's

target browsing context , and active service worker to reservedEnvironment 's active service worker.

2. Set reservedEnvironment 's id to the empty string.

Note

The identity of the reserved environment is considered to be fully transferred to the created environment

settings object . The reserved environment is not searchable by the environment ’s id from this point on.

5. Otherwise, set settings object 's id to a new unique opaque string, settings object 's target browsing context to null, and

settings object 's active service worker to null.

6. Set settings object 's creation URL to creationURL , settings object 's top-level creation URL to topLevelCreationURL, and

settings object 's top-level origin to topLevelOrigin.

7. Set realm's [[HostDefined]] field to settings object.



§



A WindowProxy is an exotic object that wraps a Window ordinary object, indirecting most operations through to the wrapped object.

Each browsing context has an associated WindowProxy object. When the browsing context is navigated , the Window

object wrapped by the browsing context 's associated WindowProxy object is changed.

The WindowProxy exotic object must use the ordinary internal methods except where it is explicitly specified otherwise below.

There is no WindowProxy interface object.

Every WindowProxy object has a [[Window]] internal slot representing the wrapped Window object.



Note

Although WindowProxy is named as a "proxy", it does not do polymorphic dispatch on its target's internal methods as a real

proxy would, due to a desire to reuse machinery between WindowProxy and Location objects. As long as the Window

object remains an ordinary object this is unobservable and can be implemented either way.





1. Let W be the value of the [[Window]] internal slot of this.

2. If ! IsPlatformObjectSameOrigin(W) is true, then return ! OrdinaryGetPrototypeOf(W).

3. Return null.





1. Return ! SetImmutablePrototype(this, V).





1. Return true.





1. Return false.





1. Let W be the value of the [[Window]] internal slot of this.

2. If P is an array index property name, then:

1. Let index be ! ToUint32(P).

2. Let maxProperties be the number of document-tree child browsing contexts of W.

3. Let value be undefined.

4. If maxProperties is greater than 0 and index is less than maxProperties , then set value to the WindowProxy

object of the index th document-tree child browsing context of W 's browsing context, sorted in the order that

their browsing context container elements were most recently inserted into W 's associated Document, the

WindowProxy object of the most recently inserted browsing context container 's nested browsing context being last.

5. If value is undefined, then:

1. If ! IsPlatformObjectSameOrigin(W) is true, then return undefined.

2. Throw a "SecurityError" DOMException.

6. Return PropertyDescriptor{ [[Value]]: value, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: true }.

3. If ! IsPlatformObjectSameOrigin(W) is true, then return ! OrdinaryGetOwnProperty(W, P).





Note

This is a willful violation of the JavaScript specification's invariants of the essential internal methods to maintain

compatibility with existing web content. See tc39/ecma262 issue #672 for more information. [JAVASCRIPT]

4. Let property be ! CrossOriginGetOwnPropertyHelper (W, P).

5. If property is not undefined, then return property.

6. If property is undefined and P is in W 's document-tree child browsing context name property set , then:

1. Let value be the WindowProxy object of the named object of W with the name P.

2. Return PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]: false, [[Configurable]]: true }.

Note

The reason the property descriptors are non-enumerable, despite this mismatching the same-origin behavior, is

for compatibility with existing web content. See issue #3183 for details.

7. Return ? CrossOriginPropertyFallback (P).





1. Let W be the value of the [[Window]] internal slot of this.

2. If ! IsPlatformObjectSameOrigin(W) is true, then:

1. If P is an array index property name, return false.

2. Return ? OrdinaryDefineOwnProperty(W, P, Desc).

Note

This is a willful violation of the JavaScript specification's invariants of the essential internal methods to

maintain compatibility with existing web content. See tc39/ecma262 issue #672 for more information.

[JAVASCRIPT]

3. Throw a "SecurityError" DOMException.





1. Let W be the value of the [[Window]] internal slot of this.

2. Check if an access between two browsing contexts should be reported , given the current global object's browsing

context , W 's browsing context , P , and the current settings object.

3. If ! IsPlatformObjectSameOrigin(W) is true, then return ? OrdinaryGet(this, P, Receiver).

4. Return ? CrossOriginGet (this, P, Receiver).

Note

this is passed rather than W as OrdinaryGet and CrossOriginGet will invoke the [[GetOwnProperty]] internal method.





1. Let W be the value of the [[Window]] internal slot of this.

2. Check if an access between two browsing contexts should be reported , given the current global object's browsing



context , W 's browsing context , P , and the current settings object.

3. If ! IsPlatformObjectSameOrigin(W) is true, then return ? OrdinarySet(this, P, V, Receiver).

4. Return ? CrossOriginSet(this, P, V, Receiver).

Note

this is passed rather than W as OrdinarySet and CrossOriginSet will invoke the [[GetOwnProperty]] internal method.

OrdinarySet will also invoke the [[DefineOwnProperty]] internal method.





1. Let W be the value of the [[Window]] internal slot of this.

2. If ! IsPlatformObjectSameOrigin(W) is true, then:

1. If P is an array index property name, then:

1. Let desc be ! this.[[GetOwnProperty]](P).

2. If desc is undefined, then return true.

3. Return false.

2. Return ? OrdinaryDelete(W, P).

3. Throw a "SecurityError" DOMException.





1. Let W be the value of the [[Window]] internal slot of this.

2. Let keys be a new empty List.

3. Let maxProperties be the number of document-tree child browsing contexts of W.

4. Let index be 0.

5. Repeat while index < maxProperties,

1. Add ! ToString(index) as the last element of keys.

2. Increment index by 1.

6. If ! IsPlatformObjectSameOrigin(W) is true, then return the concatenation of keys and ! OrdinaryOwnPropertyKeys(W).

7. Return the concatenation of keys and ! CrossOriginOwnPropertyKeys (W).



§



Origins are the fundamental currency of the web's security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.

Example

For example, if Example Bank's web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's web site,

hosted at charity.example.org, a "SecurityError" DOMException will be raised.



An origin is one of the following:

An opaque origin

An internal value, with no serialization it can be recreated from (it is serialized as " null " per serialization of an origin ), for which the only meaningful operation is testing for equality.

A tuple origin

A tuple consists of:

• A scheme (a scheme).

• A host (a host).

• A port (a port).

• A domain (null or a domain). Null unless stated otherwise.

Note

Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the

domain of a tuple origin can be changed, and only through the document.domain API.

The effective domain of an origin origin is computed as follows:

1. If origin is an opaque origin, then return null.

2. If origin 's domain is non-null, then return origin 's domain .

3. Return origin 's host .

Various specification objects are defined to have an origin . These origins are determined as follows: For Document objects

The create a new browsing context and navigation algorithms assign the origin at construction time. Otherwise, the

default default behavior as defined in DOM applies. [DOM]

For images of img elements

↪ If the image data is CORS-cross-origin

A unique opaque origin assigned when the image is created.

↪ If the image data is CORS-same-origin

The img element's node document 's origin.

For audio and video elements

↪ If the media data is CORS-cross-origin

A unique opaque origin assigned when the media data is fetched.

↪ If the media data is CORS-same-origin

The media element 's node document 's origin.

Other specifications can override the above definitions by themselves specifying the origin of a particular Document object, image, or media element.



The serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:

1. If origin is an opaque origin, then return "null".

2. Otherwise, let result be origin 's scheme.

3. Append "://" to result.

4. Append origin 's host , serialized, to result.

5. If origin 's port is non-null, append a U+003A COLON character (:), and origin 's port, serialized, to result.

6. Return result.





Example

The serialization of ("https", "xn--maraa-rta.example", null, null) is "https://xn--maraa-rta.example".



Note

There used to also be a Unicode serialization of an origin. However, it was never widely adopted.



Two origins, A and B, are said to be same origin if the following algorithm returns true:

1. If A and B are the same opaque origin , then return true.

2. If A and B are both tuple origins and their schemes , hosts , and port are identical, then return true.

3. Return false.

Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:

1. If A and B are the same opaque origin , then return true.

2. If A and B are both tuple origins , run these substeps:

1. If A and B 's schemes are identical, and their domains are identical and non-null, then return true.

2. Otherwise, if A and B are same origin and their domains are identical and null, then return true.

3. Return false.

Example





A scheme-and-host is a tuple of a scheme and a host.

A site is an opaque origin or a scheme-and-host.

To obtain a site, given an origin origin, run these steps:

1. If origin is an opaque origin, then return origin.

2. If origin 's host 's registrable domain is null, then return ( origin 's scheme , origin 's host ).

3. Return ( origin 's scheme , origin 's host 's registrable domain).

Two origins, A and B, are said to be schemelessly same site if the following algorithm returns true:

1. If A and B are the same opaque origin , then return true.

2. If A and B are both tuple origins , then:

1. Let hostA be A 's host , and let hostB be B 's host.

2. If hostA equals hostB and hostA's registrable domain is null, then return true.

3. If hostA's registrable domain equals hostB's registrable domain and is non-null, then return true.

3. Return false.



Two origins, A and B, are said to be same site if both of the following statements are true:

• A and B are schemelessly same site

• A and B are either both opaque origins , or both tuple origins with the same scheme

Note

Unlike the same origin and same origin-domain concepts, for schemelessly same site and same site , the port and

domain components are ignored.



⚠Warning!

For the reasons explained in URL , the same site and schemelessly same site concepts should be avoided

when possible, in favor of same origin checks.



Example

Given that wildlife.museum, museum, and com are public suffixes and that example.com is not:





(Here we have omitted the port and domain components since they are not considered.)



✔ MDN





For web developers (non-normative)

document . domain [ = domain ]

Returns the current domain used for security checks.

Can be set to a value that removes subdomains, to change the origin 's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. This enables pages on different hosts of a domain to synchronously access each other's DOMs.

In sandboxed iframe s, Document s with opaque origins , Document s without a browsing context , and when the

" document-domain" feature is disabled, the setter will throw a "SecurityError" exception. In cases where

crossOriginIsolated or originAgentCluster return true, the setter will do nothing.



Avoid using the document.domain setter. It undermines the security protections provided by the same-origin policy. This is especially acute when using shared hosting; for example, if an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will

fail, as the ports are ignored when comparing origins after the document.domain setter has been used.

Because of these security pitfalls, this feature is in the process of being removed from the web platform. (This is a long process that takes many years.)

Instead, use postMessage() or MessageChannel objects to communicate across origins in a safe manner.



The domain getter steps are:

1. Let effectiveDomain be this 's origin 's effective domain .



2. If effectiveDomain is null, then return the empty string.

3. Return effectiveDomain, serialized.

The domain setter steps are:

1. If this 's browsing context is null, then throw a "SecurityError" DOMException.

2. If this 's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a

"SecurityError" DOMException.

3. If this is not allowed to use the " document-domain" feature, then throw a "SecurityError" DOMException.

4. Let effectiveDomain be this 's origin 's effective domain .

5. If effectiveDomain is null, then throw a "SecurityError" DOMException.

6. If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError"

DOMException.

7. If the surrounding agent 's agent cluster 's cross-origin isolated is true, then return.

8. If the surrounding agent 's agent cluster 's is origin-keyed is true, then return.

9. Set this 's origin 's domain to the result of parsing the given value.

To determine if a string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost, run these steps:

1. If hostSuffixString is the empty string, then return false.

2. Let host be the result of parsing hostSuffixString.

3. If host is failure, then return false.

4. If host does not equal originalHost, then:

1. If host or originalHost is not a domain, then return false.

Note

This excludes hosts that are an IPv4 address or an IPv6 address.

2. If host, prefixed by a U+002E FULL STOP (.), does not exactly match the end of originalHost, then return false.

3. If host equals host 's public suffix , then return false. [URL]

5. Return true.





For web developers (non-normative)

window . originAgentCluster

Returns true if this Window belongs to an agent cluster which is origin-keyed, in the manner described in this section.

A Document delivered over a secure context can request that it be placed in an origin-keyed agent cluster, by using the

` Origin-Agent-Cluster` HTTP response header. This header is a structured header whose value must be a boolean.

[STRUCTURED-FIELDS]

Per the processing model in the create and initialize a new Document object, values that are not the structured header boolean true value (i.e., `?1`) will be ignored.

The consequences of using this header are that the resulting Document 's agent cluster key is its origin, instead of the

corresponding site . In terms of observable effects, this means that attempting to relax the same-origin restriction using

document.domain will instead do nothing, and it will not be possible to send WebAssembly.Module objects to cross-origin

Document s (even if they are same site). Behind the scenes, this isolation can allow user agents to allocate implementation-



specific resources corresponding to agent clusters, such as processes or threads, more efficiently.

Note that within a browsing context group , the ` Origin-Agent-Cluster ` header can never cause same-origin Document

objects to end up in different agent clusters, even if one sends the header and the other doesn't. This is prevented by means of the

historical agent cluster key map .

Note

This means that the originAgentCluster getter can return false, even if the header is set, if the header was omitted on a

previously-loaded same-origin page in the same browsing context group. Similarly, it can return true even when the header is

not set.

The originAgentCluster getter steps are to return the surrounding agent 's agent cluster 's is origin-keyed .

Note

Document s with an opaque origin can be considered unconditionally origin-keyed; for them the header has no effect, and the

originAgentCluster getter will always return true.



Note

Similarly, Document s in a cross-origin isolated agent cluster are automatically origin-keyed. The `Origin-Agent-

Cluster ` header might be useful as an additional hint to implementations about resource allocation, since the `Cross-

Origin-Opener-Policy ` and ` Cross-Origin-Embedder-Policy` headers used to achieve cross-origin isolation are more

about ensuring that everything in the same address space opts in to being there. But adding it would have no additional

observable effects on author code.



§



A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have: The sandboxed navigation browsing context flag

This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing

contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation

browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level

navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing

context flag defined below).

If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow

popups (new top-level browsing contexts ) to be opened. These browsing contexts always have one permitted sandboxed

navigator , set when the browsing context is created, which allows the browsing context that created them to actually navigate

them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.) The sandboxed auxiliary navigation browsing context flag

This flag prevents content from creating new auxiliary browsing contexts , e.g. using the target attribute or the

window.open() method.

The sandboxed top-level navigation without user activation browsing context flag

This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level

browsing context . It is consulted only when the sandboxed browsing context's active window does not have transient

activation .

When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-

level browsing context , but other browsing contexts are still protected by the sandboxed navigation browsing context flag

and possibly the sandboxed auxiliary navigation browsing context flag.

The sandboxed top-level navigation with user activation browsing context flag

This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level



browsing context . It is consulted only when the sandboxed browsing context's active window has transient activation.

As with the sandboxed top-level navigation without user activation browsing context flag , this flag only affects the top-level

browsing context ; if it is not set, other browsing contexts might still be protected by other flags.

The sandboxed plugins browsing context flag

This flag prevents content from instantiating plugins , whether using the embed element , the object element, or through

navigation of their nested browsing context , unless those plugins can be secured.

The sandboxed origin browsing context flag

This flag forces content into a unique origin , thus preventing it from accessing other content from the same origin.

This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to

localStorage .

The sandboxed forms browsing context flag

This flag blocks form submission.

The sandboxed pointer lock browsing context flag

This flag disables the Pointer Lock API. [POINTERLOCK]

The sandboxed scripts browsing context flag

This flag blocks script execution .

The sandboxed automatic features browsing context flag

This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form

control .

The sandboxed document.domain browsing context flag

This flag prevents content from using the document.domain setter.

The sandbox propagates to auxiliary browsing contexts flag

This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the

content's active sandboxing flag set .

The sandboxed modals flag

This flag prevents content from using any of the following features to produce modal dialogs:

• window.alert()

• window.confirm()

• window.print()

• window.prompt()

• the beforeunload event The sandboxed orientation lock browsing context flag

This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]

The sandboxed presentation browsing context flag

This flag disables the Presentation API. [PRESENTATION]

The sandboxed downloads browsing context flag

This flag prevents content from initiating or instantiating downloads, whether through downloading hyperlinks or through

navigation that gets handled as a download.

When the user agent is to parse a sandboxing directive , given a string input , a sandboxing flag set output, it must run the following steps:

1. Split input on ASCII whitespace, to obtain tokens.

2. Let output be empty.



3. Add the following flags to output:

◦ The sandboxed navigation browsing context flag.

◦ The sandboxed auxiliary navigation browsing context flag , unless tokens contains the allow-popups keyword.

◦ The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the

allow-top-navigation keyword.

◦ The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either

the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.

Note

This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-

activation keyword will have no effect. For this reason, specifying both is a document conformance error.

◦ The sandboxed plugins browsing context flag.

◦ The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.

Note

The allow-same-origin keyword is intended for two cases.

First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.

Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening popups, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.

◦ The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.

◦ The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.

◦ The sandboxed scripts browsing context flag , unless tokens contains the allow-scripts keyword.

◦ The sandboxed automatic features browsing context flag , unless tokens contains the allow-scripts

keyword (defined above).

Note

This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.

◦ The sandboxed document.domain browsing context flag.

◦ The sandbox propagates to auxiliary browsing contexts flag , unless tokens contains the allow-popups-to-

escape-sandbox keyword.

◦ The sandboxed modals flag , unless tokens contains the allow-modals keyword.

◦ The sandboxed orientation lock browsing context flag , unless tokens contains the allow-orientation-lock

keyword.

◦ The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.

◦ The sandboxed downloads browsing context flag, unless tokens contains the allow-downloads keyword.



Every top-level browsing context has a popup sandboxing flag set , which is a sandboxing flag set. When a browsing

context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a browsing context

and the obtain a browsing context to use for a navigation response algorithm.

Every iframe element has an iframe sandboxing flag set , which is a sandboxing flag set. Which flags in an iframe

sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.





Every Document has an active sandboxing flag set , which is a sandboxing flag set . When the Document is created, its

active sandboxing flag set must be empty. It is populated by the navigation algorithm.

Every resource that is obtained by the navigation algorithm has a forced sandboxing flag set , which is a sandboxing flag set.

A resource by default has no flags set in its forced sandboxing flag set, but other specifications can define that certain flags are set.

Note

In particular, the forced sandboxing flag set is used by Content Security Policy . [CSP]



To determine the creation sandboxing flags for a browsing context browsing context, given null or an element embedder, return the union of the flags that are present in the following sandboxing flag sets:

• If embedder is null, then: the flags set on browsing context 's popup sandboxing flag set.

• If embedder is an element, then: the flags set on embedder 's iframe sandboxing flag set .

• If embedder is an element, then: the flags set on embedder 's node document 's active sandboxing flag set.

After creation, the sandboxing flags for a browsing context browsing context are the result of determining the creation

sandboxing flags given browsing context and browsing context 's container.



§



A cross-origin opener policy value allows a document which is navigated to in a top-level browsing context to force the creation of a new top-level browsing context , and a corresponding group. The possible values are:

"unsafe-none"

This is the (current) default and means that the document will occupy the same top-level browsing context as its predecessor,

unless that document specified a different cross-origin opener policy .

"same-origin-allow-popups"

This forces the creation of a new top-level browsing context for the document, unless its predecessor specified the same cross-

origin opener policy and they are same origin.

"same-origin"

This behaves the same as " same-origin-allow-popups ", with the addition that any auxiliary browsing context created

needs to contain same origin documents that also have the same cross-origin opener policy or it will appear closed to the opener.

"same-origin-plus-COEP"

This behaves the same as " same-origin ", with the addition that it sets the (new) top-level browsing context 's group's

cross-origin isolated to true.

Note

" same-origin-plus-COEP " cannot be directly set via the ` Cross-Origin-Opener-Policy` header, but results from a

combination of setting both ` Cross-Origin-Opener-Policy : same-origin` and `Cross-Origin-Embedder-

Policy : require-corp` together.

A cross-origin opener policy consists of:

• A value , which is a cross-origin opener policy value , initially " unsafe-none".

• A reporting endpoint, which is string or null, initially null.

• A report-only value , which is a cross-origin opener policy value , initially " unsafe-none".

• A report-only reporting endpoint, which is a string or null, initially null.

To match cross-origin opener policy values , given a cross-origin opener policy value A , an origin originA, a cross-origin



opener policy value B , and an origin originB:

1. If A is " unsafe-none " and B is " unsafe-none", then return true.

2. If A is " unsafe-none " or B is " unsafe-none ", then return false.

3. If A is B and originA is same origin with originB, then return true.

4. Return false.





A Document 's cross-origin opener policy is derived from the ` Cross-Origin-Opener-Policy` and the `Cross-Origin-

Opener-Policy-Report-Only ` HTTP response headers. These headers are structured headers whose value must be a token.

[STRUCTURED-FIELDS]

The valid token values are the opener policy values. The token may also have attached parameters; of these, the "report-to"

parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]

Note

Per the processing model described below, user agents will ignore this header if it contains an invalid value. Likewise, user agents

will ignore this header if the value cannot be parsed as a token.



To obtain a cross-origin opener policy given a response response and an environment reservedEnvironment:

1. Let policy be a new cross-origin opener policy.

2. If reservedEnvironment is a non-secure context, then return policy.

3. Let value be the result of getting a structured field value given ` Cross-Origin-Opener-Policy` and "item" from

response's header list.

4. If parsedItem is not null, then:

1. If parsedItem [0] is " same-origin ", then:

1. Let coep be the result of obtaining a cross-origin embedder policy from response.

2. If coep 's value is " require-corp ", then set policy 's value to " same-origin-plus-COEP ".

3. Otherwise, set policy 's value to " same-origin ".

2. If parsedItem [0] is " same-origin-allow-popups ", then set policy 's value to "same-origin-allow-

popups ".

3. If parsedItem [1][" report-to "] exists and it is a string, then set policy 's reporting endpoint to

parsedItem [1][" report-to"].

5. Set parsedItem to the result of getting a structured field value given ` Cross-Origin-Opener-Policy-Report-Only` and

"item" from response's header list.

6. If parsedItem is not null, then:

1. If parsedItem [0] is " same-origin ", then:

1. Let coep be the result of obtaining a cross-origin embedder policy from response.

2. If coep 's value is " require-corp " or coep 's report-only value is " require-corp", then set

policy 's report-only value to " same-origin-plus-COEP ".

Note

Report only COOP also considers report-only COEP to assign the special "same-origin-plus-

COEP " value. This allows developers more freedom in the order of deployment of COOP and COEP.



3. Otherwise, set policy 's report-only value to " same-origin".

2. If parsedItem [0] is " same-origin-allow-popups ", then set policy 's report-only value to "same-origin-

allow-popups ".

3. If parsedItem [1][" report-to "] exists and it is a string, then set policy 's report-only reporting endpoint to

parsedItem [1][" report-to"].

7. Return policy.





To check if COOP values require a browsing context group switch , given a boolean isInitialAboutBlank , two origins

responseOrigin , activeDocumentNavigationOrigin , and two cross-origin opener policy values responseCOOPValue and activeDocumentCOOPValue:

1. If the result of matching activeDocumentCOOPValue, activeDocumentNavigationOrigin, responseCOOPValue, and

responseOrigin is true, return false.

2. If all of the following are true:

◦ isInitialAboutBlank,

◦ activeDocumentCOOPValue 's value is " same-origin-allow-popups ".

◦ responseCOOPValue is " unsafe-none",

then return false.

3. Return true.

To check if enforcing report-only COOP would require a browsing context group switch, given a boolean isInitialAboutBlank, two origins responseOrigin , activeDocumentNavigationOrigin , and two cross-origin opener policies responseCOOP and activeDocumentCOOP:

1. If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, sandboxFlags,

responseOrigin , activeDocumentNavigationOrigin , responseCOOP 's report-only value and

activeDocumentCOOPReportOnly 's report-only value is false, then return false.

Note

Matching report-only policies allows a website to specify the same report-only cross-origin opener policy on all its pages and not receive violation reports for navigations between these pages.

2. If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, sandboxFlags,

responseOrigin , activeDocumentNavigationOrigin , responseCOOP 's value and activeDocumentCOOPReportOnly's report-

only value is true, then return true.

3. If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank, sandboxFlags,

responseOrigin , activeDocumentNavigationOrigin , responseCOOP 's report-only value and

activeDocumentCOOPReportOnly 's value is true, then return true.

4. Return false.

A cross-origin opener policy enforcement result is a struct with the following items:

• A boolean needs a browsing context group switch, initially false.

• A boolean would need a browsing context group switch due to report-only, initially false.

• A URL url.

• An origin current origin.

• A cross-origin opener policy cross-origin opener policy.

• A boolean current context is navigation source.

To enforce a response's cross-origin opener policy , given a browsing context browsingContext, a URL responseURL, an



origin responseOrigin , a cross-origin opener policy responseCOOP , a cross-origin opener policy enforcement result

currentCOOPEnforcementResult, and a referrer referrer:

1. Let newCOOPEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context

group switch is currentCOOPEnforcementResult 's needs a browsing context group switch , would need a browsing

context group switch due to report-only is currentCOOPEnforcementResult's would need a browsing context group switch

due to report-only , url is responseURL , origin is responseOrigin , coop is responseCOOP, and current context is

navigation source is true.

2. Let isInitialAboutBlank be false.

3. If browsingContext 's only entry in its session history is the about:blank Document that was added when

browsingContext was created, then set isInitialAboutBlank to true.

4. If isInitialAboutBlank is true and browsingContext 's initial URL is null, set browsingContext 's initial URL to

responseURL.

5. If the result of checking if COOP values require a browsing context group switch given isInitialAboutBlank,

currentCOOPEnforcementResult 's cross-origin opener policy 's value , currentCOOPEnforcementResult 's origin ,

responseCOOP 's value, and responseOrigin is true, then:

1. Set newCOOPEnforcementResult 's needs a browsing context group switch to true.

2. If browsingContext 's group 's browsing context set's size is greater than 1, then:

1. Queue a violation report for browsing context group switch when navigating to a COOP response with

responseCOOP , " enforce ", responseURL , currentCOOPEnforcementResult 's url,

currentCOOPEnforcementResult 's origin, responseOrigin, and referrer.

2. Queue a violation report for browsing context group switch when navigating away from a COOP

response with activeDocumentCOOP , " enforce ", currentCOOPEnforcementResult 's url ,

responseURL , currentCOOPEnforcementResult 's origin, responseOrigin, and

currentCOOPEnforcementResult 's current context is navigation source.

6. If the result of checking if enforcing report-only COOP would require a browsing context group switch given

isInitialAboutBlank , responseOrigin , currentCOOPEnforcementResult 's origin, responseCOOP, and

currentCOOPEnforcementResult 's cross-origin opener policy , is true, then:

1. Set result 's would need a browsing context group switch due to report-only to true.

2. If browsingContext 's group 's browsing context set's size is greater than 1, then:

1. Queue a violation report for browsing context group switch when navigating to a COOP response with

responseCOOP , " reporting ", responseURL , currentCOOPEnforcementResult 's url,

currentCOOPEnforcementResult 's origin, responseOrigin,and referrer.

2. Queue a violation report for browsing context group switch when navigating away from a COOP

response with activeDocumentCOOP , " reporting ", currentCOOPEnforcementResult 's url,

responseURL , currentCOOPEnforcementResult 's origin, responseOrigin, and

currentCOOPEnforcementResult 's current context is navigation source.

7. Return newCOOPEnforcementResult.

To obtain a browsing context to use for a navigation response , given a browsing contexts browsingContext, a sandboxing

flag set sandboxFlags , a cross-origin opener policy navigationCOOP , and a cross-origin opener policy enforcement result coopEnforcementResult:

1. Assert: browsingContext is a top-level browsing context .

2. If coopEnforcementResult 's needs a browsing context group switch is false, then:

1. If coopEnforcementResult 's would need a browsing context group switch due to report-only is true, set browsing

context 's virtual browsing context group ID to a new unique identifier.

2. Return browsingContext.

3. Let newBrowsingContext be the result of creating a new top-level browsing context .



4. If navigationCOOP 's value is " same-origin-plus-COEP ", then set newBrowsingContext 's group's cross-origin

isolated to true.

5. If sandboxFlags is not empty, then:

1. Assert navigationCOOP 's value is " unsafe-none ".

2. Assert: newBrowsingContext 's popup sandboxing flag set is empty.

3. Set newBrowsingContext 's popup sandboxing flag set to a clone of sandboxFlags.

6. Discard browsingContext.

Note

This has no effect on browsingContext 's group , unless browsingContext was its sole top-level browsing context . In

that case, the user agent might delete the browsing context group which no longer contains any browsing

contexts .

7. Return newBrowsingContext.



The impact of swapping browsing context groups following a navigation is not fully defined. It is currently under discussion in issue

#5350.





An accessor-accessed relationship is an enum that describes the relationship between two browsing contexts between which an access happened. It can take the following values:

accessor is opener

The accessor browsing context or one of its ancestors is the opener browsing context of the accessed browsing

context 's top-level browsing context.

accessor is openee

The accessed browsing context or one of its ancestors is the opener browsing context of the accessor browsing

context 's top-level browsing context.

none

There is no opener relationship between the accessor browsing context , the accessor browsing context , or any of their

ancestors .

To check if an access between two browsing contexts should be reported , given two browsing contexts accessor and accessed , a JavaScript property name P , and an environment settings object environment:

1. If P is not a cross-origin accessible window property name, then return.

2. If accessor 's active document 's origin or any of its ancestors ' active document 's origins are not same

origin with ancestor 's top-level browsing context 's active document 's origin, or if accessed's active

document 's origin or any of its ancestors ' active document 's origins are not same origin with accessed's

top-level browsing context 's active document 's origin , then return.

Note

This avoids leaking information about cross-origin iframes to a top level frame with cross-origin opener policy reporting

3. If accessor 's top-level browsing context 's virtual browsing context group ID is accessed's top-level browsing

context 's virtual browsing context group ID, then return.

4. Let accessorAccessedRelationship be a new accessor-accessed relationship with value none .

5. If accessed 's top-level browsing context 's opener browsing context is accessor or an ancestor of accessor, then set

accessorAccessedRelationship to accessor is opener .

6. If accessor 's top-level browsing context 's opener browsing context is accessed or an ancestor of accessed, then set



accessorAccessedRelationship to accessor is openee.

7. Queue violation reports for accesses , given accessorAccessedRelationship , accessor 's top-level browsing context 's

active document 's cross-origin opener policy , accessed 's top-level browsing context 's active document's cross-

origin opener policy , accessor 's active document 's URL , accessed 's active document 's URL, accessor's top-level

browsing context 's initial URL , accessed 's top-level browsing context 's initial URL, accessor's active

document 's origin , accessed 's active document 's origin , accessor 's top-level browsing context 's opener

origin at creation , accessed 's top-level browsing context 's opener origin at creation , accessor's top-level browsing

context 's active document 's referrer , accessed 's top-level browsing context 's active document 's referrer, P, and environment.

To sanitize a URL to send in a report given a URL url:

1. Let sanitizedURL be a copy of url.

2. Set the username given sanitizedURL and the empty string.

3. Set the password given sanitizedURL and the empty string.

4. Return the serialization of sanitizedURL with the exclude fragment flag set.

To queue a violation report for browsing context group switch when navigating to a COOP response given a cross-origin

opener policy coop , a string disposition , a URL coopURL , a URL previousResponseURL , two origins coopOrigin and previousResponseOrigin, and a referrer referrer:

1. If coop 's reporting endpoint is null, return.

2. Let coopValue be coop 's value .

3. If disposition is " reporting ", then set coopValue to coop 's report-only value .

4. Let serializedReferrer be an empty string

5. If referrer is a URL, set serializedReferrer to the serialization of referrer.

6. Let body be a new object containing the following properties:





7. Queue body as " coop " for coop 's reporting endpoint with coopURL.

To queue a violation report for browsing context group switch when navigating away from a COOP response given a cross-

origin opener policy coop , a string disposition , a URL coopURL , a URL nextResponseURL , two origins coopOrigin and nextResponseOrigin, and a boolean isCOOPResponseNavigationSource:

1. If coop 's reporting endpoint is null, return.

2. Let coopValue be coop 's value .

3. If disposition is " reporting ", then set coopValue to coop 's report-only value .

4. Let body be a new object containing the following properties:





5. Queue body as " coop " for coop 's reporting endpoint with coopURL.



To queue violation reports for accesses , given an accessor-accessed relationship accessorAccessedRelationship, two cross-

origin opener policies accessorCOOP and accessedCOOP, four URLs accessorURL, accessedURL, accessorInitialURL, accessedInitialURL , four origins accessorOrigin , accessedOrigin , accessorCreatorOrigin and accessedCreatorOrigin , two referrers

accessorReferrer and accessedReferrer , a string propertyName , and an environment settings object environment:

1. If coop 's reporting endpoint is null, return.

2. Let coopValue be coop 's value .

3. If disposition is " reporting ", then set coopValue to coop 's report-only value .

4. If accessorAccessedRelationship is accessor is opener :

1. Queue a violation report for access to an opened window, given accessorCOOP, accessorURL, accessedURL,

accessedInitialURL, accessorOrigin, accessedOrigin, accessedCreatorOrigin, propertyName, and environment.

2. Queue a violation report for access from the opener , given accessedCOOP, accessedURL, accessorURL,

accessedOrigin, accessorOrigin, propertyName, and accessedReferrer.

5. Otherwise, if accessorAccessedRelationship is accessor is openee:

1. Queue a violation report for access to the opener , given accessorCOOP, accessorURL, accessedURL,

accessorOrigin, accessedOrigin, propertyName, accessorReferrer, and environment.

2. Queue a violation report for access from an opened window, given accessedCOOP, accessedURL, accessorURL,

accessorInitialURL, accessedOrigin, accessorOrigin, accessorCreatorOrigin, and propertyName.

6. Otherwise:

1. Queue a violation report for access to another window, given accessorCOOP, accessorURL, accessedURL,

accessorOrigin, accessedOrigin, propertyName, and environment

2. Queue a violation report for access from another window, given accessedCOOP, accessedURL, accessorURL,

accessedOrigin, accessorOrigin, and propertyName.

To queue a violation report for access to the opener , given a cross-origin opener policy coop, two URLs coopURL and openerURL , two origins coopOrigin and openerOrigin, a string propertyName, a referrer referrer, and an environment settings

object environment:

1. Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this

report.

2. Let serializedReferrer be an empty string

3. If referrer is a URL, set serializedReferrer to the serialization of referrer.

4. Let body be a new object containing the following properties:





5. Queue body as " coop " for coop 's reporting endpoint with coopURL and environment.

To queue a violation report for access to an opened window , given a cross-origin opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL , three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin,a string propertyName , and an environment settings object environment:

1. Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this

report.



2. Let body be a new object containing the following properties:





3. Queue body as " coop " for coop 's reporting endpoint with coopURL and environment.

To queue a violation report for access to another window , given a cross-origin opener policy coop, two URLs coopURL and otherURL , two origins coopOrigin and otherOrigin , a string propertyName , and an environment settings object environment:

1. Let sourceFile, lineNumber and columnNumber be the relevant script URL and problematic position which triggered this

report.

2. Let body be a new object containing the following properties:





3. Queue body as " coop " for coop 's reporting endpoint with coopURL and environment.

To queue a violation report for access from the opener , given a cross-origin opener policy coop, two URLs coopURL and openerURL , two origins coopOrigin and openerOrigin, a string propertyName, and a referrer referrer:

1. If coop 's reporting endpoint is null, return.

2. Let serializedReferrer be an empty string

3. If referrer is a URL, set serializedReferrer to the serialization of referrer.

4. Let body be a new object containing the following properties:





5. Queue body as " coop " for coop 's reporting endpoint with coopURL.

To queue a violation report for access from an opened window , given a cross-origin opener policy coop, three URLs coopURL, openedWindowURL and initialWindowURL , three origins coopOrigin, openedWindowOrigin, and openerInitialOrigin, and a string propertyName:

1. If coop 's reporting endpoint is null, return.

2. Let body be a new object containing the following properties:





3. Queue body as " coop " for coop 's reporting endpoint with coopURL.

To queue a violation report for access from another window , given a cross-origin opener policy coop, two URLs coopURL and otherURL , two origins coopOrigin and otherOrigin, and a string propertyName:

1. If coop 's reporting endpoint is null, return.

2. Let body be a new object containing the following properties:





3. Queue body as " coop " for coop 's reporting endpoint with coopURL.



§



An embedder policy value controls the fetching of cross-origin resources without explicit permission from resource owners. There are two such values:

"unsafe-none"

This is the default value. When this value is used, cross-origin resources can be fetched without giving explicit permission through

the CORS protocol or the `Cross-Origin-Resource-Policy` header.

"require-corp"

When this value is used, fetching cross-origin resources requires the server's explicit permission through the CORS protocol or the

`Cross-Origin-Resource-Policy` header.

An embedder policy consists of:

• A value , which is an embedder policy value , initially " unsafe-none ".

• A reporting endpoint string, initially the empty string.

• A report only value , which is an embedder policy value , initially " unsafe-none".

• A report only reporting endpoint string, initially the empty string.

The "coep" report type is a report type whose value is "coep". It is visible to ReportingObservers.





The ` Cross-Origin-Embedder-Policy ` and ` Cross-Origin-Embedder-Policy-Report-Only` HTTP response header fields allow a server to declare an embedder policy for an environment settings object. These headers are structured headers whose values must be token . [STRUCTURED-FIELDS]

The valid token values are the embedder policy values . The token may also have attached parameters; of these, the "report-to"

parameter can have a valid URL string identifying an appropriate reporting endpoint. [REPORTING]



Note

The processing model fails open (by defaulting to " unsafe-none ") in the presence of a header that cannot be parsed as a

token. This includes inadvertent lists created by combining multiple instances of the ` Cross-Origin-Embedder-Policy`

header present in a given response:





(The same applies to ` Cross-Origin-Embedder-Policy-Report-Only`.)



To obtain an embedder policy from a response response:

1. Let policy be a new embedder policy.

2. Let parsedItem be the result of getting a structured field value with ` Cross-Origin-Embedder-Policy` and "item" from

response's header list.

3. If parsedItem is non-null and parsedItem[0] is "require-corp":

1. Set policy 's value to " require-corp ".

2. If parsedItem [1][" report-to "] exists , then set policy 's endpoint to parsedItem [1][" report-to "].

4. Set parsedItem to the result of getting a structured field value with ` Cross-Origin-Embedder-Policy-Report-Only`

and "item" from response's header list.

5. If parsedItem is non-null and parsedItem[0] is "require-corp":

1. Set policy 's report-only value to " require-corp".

2. If parsedItem [1][" report-to "] exists , then set policy 's report-only reporting endpoint to

parsedItem [1][" report-to"].

6. Return policy.





To check a navigation response's adherence to its embedder policy given a response response and a browsing context target:

1. If target is not a child browsing context, then return true.

2. Let responsePolicy be the result of obtaining an embedder policy from response.

3. Let parentPolicy be target 's container document 's embedder policy.

4. If parentPolicy 's report-only value is " require-corp " and responsePolicy 's value is " unsafe-none ", then queue

a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's report only reporting

endpoint , " reporting ", and target 's container document 's relevant settings object.

5. If parentPolicy 's value is " unsafe-none " or responsePolicy 's value is " require-corp", then return true.

6. Queue a cross-origin embedder policy inheritance violation with response, "navigation", parentPolicy's reporting

endpoint , " enforce ", and target 's container document 's relevant settings object .

7. Return false.



To check a global object's embedder policy given a WorkerGlobalScope workerGlobalScope, an environment settings

object owner, and a response response:

1. If workerGlobalScope is not a DedicatedWorkerGlobalScope object, then return true.

2. Let policy be workerGlobalScope 's embedder policy.

3. Let ownerPolicy be owner 's embedder policy .

4. If ownerPolicy 's report-only value is " require-corp " and policy 's value is " unsafe-none ", then queue a cross-

origin embedder policy inheritance violation with response, "worker initialization", owner's policy's report only

reporting endpoint , "reporting", and owner.

5. If ownerPolicy 's value is " unsafe-none " or policy 's value is " require-corp", then return true.

6. Queue a cross-origin embedder policy inheritance violation with response, "worker initialization", owner's policy's

reporting endpoint , "enforce", and owner.

7. Return false.

To queue a cross-origin embedder policy inheritance violation given a response response, a string type, a string endpoint, a string disposition , and an environment settings object settings:

1. Let serialized be the result of serializing a response URL for reporting with response.

2. Let body be a new object containing the following properties:





3. Queue body as the " coep " report type for endpoint on settings.



✔ MDN

§





A browsing session is …. See whatwg/html issue #4782 and whatwg/html issue #5350 for defining browsing session. It is

roughly analogous to a top-level browsing context except that it cannot be replaced due to a `Cross-Origin-Opener-

Policy ` header or navigation.

A top-level browsing context has an associated browsing session which is a browsing session.

The browsing session of an environment settings object environment is the result of running these steps:

1. Assert: environment has a responsible document.

2. Return environment 's responsible document 's browsing context 's top-level browsing context's browsing

session .





The sequence of Document s in a browsing context is its session history . Each browsing context, including child browsing

contexts , has a distinct session history. A browsing context 's session history consists of a flat list of session history entries.

Each Document object in a browsing context 's session history is associated with a unique History object which must all



model the same underlying session history.

The history getter steps are to return this 's associated Document 's History instance.



A session history entry is a struct with the following items:

• URL, a URL

• document , a Document or null

Note

Each entry, when first created, has a Document for its document . However, when a Document is not active ,

it's possible for it to be discarded to free resources. The URL and other data in the session history entry is then

used to bring a new Document into being to take the place of the original, in the case where the user agent finds itself having to navigate to the entry.

• serialized state , which is serialized state or null, initially null

• title, a string or null

Note

This need not have any relation with the current title of the document . The session history entry title is intended to explain the state of the document at that point, so that the user can navigate the document's history.

• scroll restoration mode , a scroll restoration mode , initially " auto".

• scroll position data , which is scroll position data for the document 's restorable scrollable regions.

• browsing context name , a browsing context name

• persisted user state, which is implementation-defined, initially null

Example

For example, some user agents might want to persist the values of form controls.

Note

User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the

element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.

Serialized state is a serialization (via StructuredSerializeForStorage ) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.

Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.

Note

Serialized state is intended to be used for two main purposes: first, storing a preparsed description of the state in the URL so

that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed

around by users, so it's only a minor optimization). Second, so that the author can store state that one wouldn't store in the URL

because it only applies to the current Document instance and it would have to be reconstructed if a new Document were

opened.

An example of the latter would be something like keeping track of the precise coordinate from which a popup div was made to

animate, so that if the user goes back, it can be made to animate to the same location. Or alternatively, it could be used to keep a

pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back

and forward, the information doesn't have to be fetched again.



A scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to an ✔ MDN

entry . A scroll restoration mode is one of the following:



"auto"

The user agent is responsible for restoring the scroll position upon navigation.

"manual"

The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically



Several contiguous entries in a session history can share the same document . This can occur when the initial entry is reached via normal navigation , and the following entry is added via history.pushState() . Or it can occur via navigation to a fragment.

Note

All entries that share the same document (and that are therefore merely different states of one particular document) are

contiguous by definition.

User agents may discard the documents of entries with non-null documents, as long as the following conditions are met:

• They must not discard the document of the current entry .

• They must not discard any Document objects which are referenced from script.

Apart from these restrictions, this standard does not specify when user agents should discard an entry's document , versus keeping it cached.

Note

Discarding a Document will set the corresponding document item of any session history entries to null. Subsequent

navigations to those entries will result in the creation of a new Document object, and set the document item to it.



At any point, one of the entries in the session history is the current entry . This is the entry representing the active document of

the browsing context . Which entry is the current entry is changed by the algorithms defined in this specification, e.g., during

session history traversal .

Note

The current entry is usually the initial entry created upon navigation. However, it can also be one of the contiguous entries that

share the same document, as described above.

Each Document in a browsing context can also have a latest entry . This is the entry for that Document to which the browsing

context 's session history was most recently traversed. When a Document is created, it initially has no latest entry .





enum ScrollRestoration { "auto", "manual" };

[Exposed=Window]

interface History {

readonly attribute unsigned long length;

attribute ScrollRestoration scrollRestoration;

readonly attribute any state;

undefined go(optional long delta = 0);

undefined back();

undefined forward();

undefined pushState(any data, DOMString title, optional USVString? url = null);

undefined replaceState(any data, DOMString title, optional USVString? url = null);

};



For web developers (non-normative)





window . history . length

Returns the number of entries in the joint session history.

window . history . scrollRestoration [ = value ]

Returns the scroll restoration mode of the current entry in the session history.

Can be set, to change the scroll restoration mode of the current entry in the session history.

window . history . state

Returns the current serialized state, deserialized into an object.

window . history . go ( [ delta ] )

Goes back or forward the specified number of steps in the joint session history . A zero delta will reload the current page.

If the delta is out of range, does nothing.

window . history . back()

Goes back one step in the joint session history .

If there is no previous page, does nothing.

window . history . forward ()

Goes forward one step in the joint session history.

If there is no next page, does nothing.

window . history . pushState(data, title [, url ] )

Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.

window . history . replaceState (data, title [, url ] )

Updates the current entry in the session history to have the given data, title, and, if provided and not null, URL.

The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of

all the fully active Document objects that share that top-level browsing context , with all the entries that are current entries

in their respective session histories removed except for the current entry of the joint session history.

The current entry of the joint session history is the entry that most recently became a current entry in its session history .

Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories .

Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc).

Note

Since each Document in a browsing context might have a different event loop, the actual state of the joint session

history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique

origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about

each other later, they might disagree about the length of the joint session history .

✔ MDN

Each History object has state, initially null.

The length getter steps are:

1. If this 's associated Document is not fully active, then throw a "SecurityError" DOMException.

2. Return the number of entries in the top-level browsing context 's joint session history.

The actual entries are not accessible from script.

The scrollRestoration getter steps are:

1. If this 's associated Document is not fully active, then throw a "SecurityError" DOMException.

2. Return this 's session history 's current entry 's scroll restoration mode.

The scrollRestoration setter steps are:



1. If this 's associated Document is not fully active, then throw a "SecurityError" DOMException.

2. Set this 's session history 's current entry 's scroll restoration mode to the given value.

The state getter steps are:

1. If this 's associated Document is not fully active, then throw a "SecurityError" DOMException.

2. Return this 's state .

The go(delta) method steps are:

1. Let document be this 's associated Document.

2. If document is not fully active, then throw a "SecurityError" DOMException.

3. If delta is 0, then act as if the location.reload() method was called, and return.

4. Traverse the history by a delta with delta and document 's browsing context.

The back() method steps are:

1. Let document be this 's associated Document.

2. If document is not fully active, then throw a "SecurityError" DOMException.

3. Traverse the history by a delta with −1 and document 's browsing context .

The forward() method steps are:

1. Let document be this 's associated Document.

2. If document is not fully active, then throw a "SecurityError" DOMException.

3. Traverse the history by a delta with +1 and document 's browsing context .



Each top-level browsing context has a session history traversal queue , initially empty, to which tasks can be added.

Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context , in parallel:

1. Wait until this top-level browsing context 's session history traversal queue is not empty.

2. Pull the first task from this top-level browsing context 's session history traversal queue, and execute it.

3. Return to the first step of this algorithm.

The session history event loop helps coordinate cross-browsing-context transitions of the joint session history : since each

browsing context might, at any particular time, have a different event loop (this can happen if the user navigates from example.com to shop.example), transitions would otherwise have to involve cross-event-loop synchronization.



To traverse the history by a delta given delta and browsing context source browsing context, the user agent must append a

task to this top-level browsing context 's session history traversal queue , the task consisting of running the following steps:

1. If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the

number of items in the joint session history , then return.

2. Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current

entry of the joint session history .

3. Let specified browsing context be the browsing context of the specified entry.

4. If source browsing context is not allowed to navigate specified browsing context, then return.

5. If the specified browsing context 's active document 's unload a document algorithm is currently running, return.



6. Queue a global task on the history traversal task source given specified browsing context 's active window to

perform the following steps:

1. If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not

passed the point of making its Document the active document), then cancel that attempt to navigate the

browsing context .

2. If the specified browsing context 's active document is not the same Document as the Document of the

specified entry, then run these substeps:

1. Prompt to unload the active document of the specified browsing context. If the user refused to

allow the document to be unloaded , then return.

2. Unload the active document of the specified browsing context.

3. Traverse the history of the specified browsing context to the specified entry with explicitHistoryNavigation

set to true.

When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must

traverse the history by a delta with a delta equivalent to the action specified by the user and the browsing context being operated on.



The URL and history update steps , given a Document document , a URL newURL , an optional serialized state-or-null serializedData (default null), an optional string-or-null title (default null), and an optional boolean isPush (default false), are:

1. Let browsingContext be document 's browsing context.

2. If isPush is true, then:

1. Remove all the entries in browsingContext 's session history after the current entry . If the current entry is

the last entry in the session history, then no entries are removed.

Note

This doesn't necessarily have to affect the user agent's user interface.

2. Remove any tasks queued by the history traversal task source that are associated with any Document

objects in the top-level browsing context 's document family .

3. Save persisted state to the current entry.

4. Add a session history entry entry to browsingContext 's session history , after the current entry , with

▪ newURL as the URL ;

▪ document as the document;

▪ serializedData as the serialized state ;

▪ title as the title;

▪ the scroll restoration mode of the current entry in the session history as the scroll restoration

mode .

5. Update the current entry to be this newly added entry.

3. Otherwise:

1. Let entry be browsingContext 's session history 's current entry .

2. Set entry 's URL to newURL.

3. If serializedData is not null, then set entry 's serialized state to serializedData.

4. Set entry 's title to title.

5. Update entry so that it represents a GET request, if it currently represents a non-GET request (e.g. it was the result

of a POST submission).



What does this mean? This is not a part of the definition of session history entry.

4. Set document's URL to newURL.

Note

Since this is neither a navigation of the browsing context nor a history traversal , it does not cause a

hashchange event to be fired.



The pushState( data , title , url ) method steps are to run the shared history push/replace state steps given this, data, title ✔, url, ✔ MDN MDN and true.

The replaceState( data , title , url ) method steps are to run the shared history push/replace state steps given this, data, title, url, and false.

The shared history push/replace state steps , given a History history, a value data, a string title, a scalar value string-or-null url, and a boolean isPush, are:

1. Let document be history 's associated Document .

2. If document is not fully active, then throw a "SecurityError" DOMException.

3. Optionally, return. (For example, the user agent might disallow calls to these methods that are invoked on a timer, or from

event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)

4. Let targetRealm be history 's relevant Realm .

5. Let serializedData be StructuredSerializeForStorage(data). Rethrow any exceptions.

6. Let newURL be the session history 's current entry 's URL.

7. If url is not null, then:

1. Parse url , relative to the relevant settings object of history.

2. If that fails, then throw a "SecurityError" DOMException.

3. Set newURL to the resulting URL record.

4. Compare newURL to document's URL. If any component of these two URL records differ other than the path, query,

and fragment components, then throw a "SecurityError" DOMException.

5. If the origin of newURL is not same origin with the origin of document, and either the path or query

components of the two URL records compared in the previous step differ, throw a "SecurityError" DOMException. (This prevents sandboxed content from spoofing other pages on the same origin.)

8. Run the URL and history update steps given document and newURL , with serializedData set to serializedData , title

set to title , and isPush set to isPush.

9. Let state be StructuredDeserialize (serializedData, targetRealm). If this throws an exception, catch it, ignore the exception,

and set state to null.

10. Set history 's state to state.

11. Set the current entry 's document 's latest entry to the current entry.

Note

The title is purely advisory. User agents might use the title in the user interface.

User agents may limit the number of state objects added to the session history per page. If a page hits the implementation-defined

limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.) Example

Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user





can bookmark the page corresponding to a particular coordinate, to return to it later.

A static page implementing the x=5 position in such a game could look like the following:





Line Game - 5





You are at coordinate 5 on the line.





Advance to 6 or

retreat to 4?





The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way

of doing it, using script:





Line Game - 5





You are at coordinate on the line.



Advance to 6 or

retreat to 4?





In systems without script, this still works like the previous example. However, users that do have script support can now navigate

much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would

have with just a naïve script-based approach, bookmarking and navigating the session history still work.

In the example above, the data argument to the pushState() method is the same information as would be sent to the server,

but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.



Example

Applications might not use the same title for a session history entry as the value of the document's title element at that

time. For example, here is a simple page that shows a block in the title element. Clearly, when navigating backwards to a

previous state the user does not go back in time, and therefore it would be inappropriate to put the time in the session history title.





Line





State: 1





Example

Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set

the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element)

to ensure that any entry added to the history session gets the desired scroll restoration mode.





7.9.4 Implementation notes for session history p86 §

6

This section is non-normative.

The p860 History interface is not meant to place restrictions on how implementations represent the session history to the user.

For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the p859 history object are derived from the actual session history as seen from the user's perspective.

Similarly, a page containing two p362 p859 p362 p859 iframe s has a history object distinct from the iframe s' history objects, despite the fact that typical web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.

Security p864 : It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.

For both p864 p864 pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.



866

7.9.5 The p867 ✔ MDN p86 Location interface §

7

Each p828 p867 p828 Window object is associated with a unique instance of a Location object, allocated when the Window object is created.

⚠Warning!

The p867 Location exotic object is defined through a mishmash of IDL, invocation of JavaScript internal methods post-

creation, and overridden JavaScript internal methods. Coupled with its scary security policy, please take extra care

while implementing this excrescence.

To create a p867 Location object, run these steps:

1. Let p867 location be a new Location platform object.

2. Let p911 valueOf be location 's relevant Realm .[[Intrinsics]].[[%Object.prototype.valueOf%]].

3. Perform ! location.[[DefineOwnProperty]]("valueOf", { [[Value]]: valueOf, [[Writable]]: false, [[Enumerable]]: false,

[[Configurable]]: false }).

4. Perform ! p54 location .[[DefineOwnProperty]]( @@toPrimitive, { [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false,

[[Configurable]]: false }).

5. Set the value of the p873 [[DefaultProperties]] internal slot of location to location.[[OwnPropertyKeys]]().

6. Return location.

Note

The addition of p54 p867 valueOf and @@toPrimitive own data properties, as well as the fact that all of Location 's IDL attributes are

marked p867 [ LegacyUnforgeable ] , is required by legacy code that consulted the Location interface, or stringified it, to determine

the p54 document URL , and then used it in a security-sensitive way. In particular, the valueOf , @@toPrimitive, and

[LegacyUnforgeable] stringifier mitigations ensure that code such as foo[location] = bar or location + "" cannot be

misdirected.



For web developers (non-normative)

document p867 . location [ = value ]

window p867 . location [ = value ]

Returns a p867 Location object with the current page's location.

Can be set, to navigate to another page.

The p115 p115 p911 p867 Document object's location attribute's getter must return this Document object's relevant global object 's Location

object, if this p115 p818 Document object is fully active, and null otherwise.

The p828 p828 p867 Window object's location attribute's getter must return this Window object's Location object.

Location p867 p814 p115 p814 objects provide a representation of the URL of the active document of their Document 's browsing context, and allow the p860 p814 p859 current entry of the browsing context 's session history to be changed, by adding or replacing entries in the history object.

IDL [Exposed=Window]

interface Location { // but see also additional creation steps and overridden internal methods

[LegacyUnforgeable] stringifier attribute USVString href;

[LegacyUnforgeable] readonly attribute USVString origin;

[LegacyUnforgeable] attribute USVString protocol;

[LegacyUnforgeable] attribute USVString host;

[LegacyUnforgeable] attribute USVString hostname;

[LegacyUnforgeable] attribute USVString port;

[LegacyUnforgeable] attribute USVString pathname;

[LegacyUnforgeable] attribute USVString search;

[LegacyUnforgeable] attribute USVString hash;

[LegacyUnforgeable] undefined assign(USVString url);

[LegacyUnforgeable] undefined replace(USVString url);

867

[LegacyUnforgeable] undefined reload();

[LegacyUnforgeable, SameObject] readonly attribute DOMStringList ancestorOrigins;

};



For web developers (non-normative)

location . toString()

location p869 . href

Returns the p867 Location object's URL.

Can be set, to navigate to the given URL.

location p869 . origin

Returns the p867 Location object's URL's origin.

location p869 . protocol

Returns the p867 Location object's URL's scheme.

Can be set, to navigate to the same URL with a changed scheme.

location p870 . host

Returns the p867 Location object's URL's host and port (if different from the default port for the scheme). Can be set, to navigate to the same URL with a changed host and port.

location p870 . hostname

Returns the p867 Location object's URL's host.

Can be set, to navigate to the same URL with a changed host.

location p871 . port

Returns the p867 Location object's URL's port.

Can be set, to navigate to the same URL with a changed port.

location p871 . pathname

Returns the p867 Location object's URL's path.

Can be set, to navigate to the same URL with a changed path.

location p871 . search

Returns the p867 Location object's URL's query (includes leading "?" if non-empty). Can be set, to navigate to the same URL with a changed query (ignores leading "?").

location p872 . hash

Returns the p867 Location object's URL's fragment (includes leading "#" if non-empty). Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").

location p872 . assign(url)

Navigates to the given URL.

location p872 . replace(url)

Removes the current page from the session history and navigates to the given URL.

location p873 . reload()

Reloads the current page.

location p873 . ancestorOrigins

Returns a p102 p814 DOMStringList object listing the origins of the ancestor browsing contexts , from the parent browsing

context p817 p817 to the top-level browsing context.

A p867 p867 p911 Location object has an associated relevant Document , which is this Location object's relevant global object's browsing

context p829 p814 p867 p911 p829 's active document , if this Location object's relevant global object 's browsing context is non-null, and null otherwise.

A p867 p867 p868 p867 Location object has an associated url , which is this Location object's relevant Document 's URL , if this Location

object's p868 p51 relevant Document is non-null, and about:blank otherwise.

868

A p867 p867 p869 Location object has an associated ancestor origins list . When a Location object is created, its ancestor origins list must

be set to a p102 DOMStringList object whose associated list is the list of strings that the following steps would produce:

1. Let output be a new list of strings.

2. Let p814 p115 p867 current be the browsing context of the Document with which this Location object is associated.

3. p817 Loop : If current has no parent browsing context , jump to the step labeled end.

4. Let p817 current be current 's parent browsing context .

5. p841 p814 p841 Append the serialization of current 's active document 's origin to output.

6. Return to the step labeled loop.

7. End: Return output.

A p867 Location object has an associated Location-object-setter navigate algorithm, which given a url, runs these steps:

1. Let p876 historyHandling be " replace".

2. If any of the following conditions are met, then set p876 historyHandling to " default ":

◦ This p867 p868 p894 Location object's relevant Document has completely loaded , or

◦ In the p932 task in which the algorithm is running, an activation behavior is currently being processed whose click

event's isTrusted attribute is true, or

◦ In the p932 task in which the algorithm is running, the event listener for a click event, whose isTrusted attribute is

true, is being handled.

3. p869 Location-object navigate, given url and historyHandling.

To Location-object navigate, given a url and historyHandling:

1. Let p911 p829 browsingContext be the current global object 's browsing context.

2. Let p909 p829 sourceBrowsingContext be the incumbent global object 's browsing context.

3. If p858 p115 p51 p115 browsingContext 's session history contains only one Document , and that was the about:blank Document

created when the p814 p876 browsing context was created, then set historyHandling to " replace ".

4. p876 p876 p876 Navigate browsingContext to url , with exceptionsEnabled set to true, historyHandling set to historyHandling, and

the p876 source browsing context set to sourceBrowsingContext.

The href attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. Return this p867 p868 Location object's url, serialized.

The p869 href attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. p89 p908 Parse the given value relative to the entry settings object. If that failed, throw a TypeError exception.

3. p869 p89 Location-object-setter navigate given the resulting URL record.

Note

The p869 ✔ MDN href attribute setter intentionally has no security check.

The origin attribute's getter must run these steps:

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. Return the p841 p867 p868 serialization of this Location object's url's origin.

The protocol attribute's getter must run these steps: ✔ MDN

869

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. Return this p867 p868 Location object's url's scheme, followed by ":".

The p869 protocol attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start

state as state override.

Note

Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".

5. If possibleFailure is failure, then throw a "SyntaxError" DOMException.

6. If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.

7. p869 Location-object-setter navigate to copyURL.

The host attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. Let p867 p868 url be this Location object's url.

3. If url's host is null, return the empty string.

4. If url's port is null, return url's host, serialized.

5. Return url's host, serialized, followed by ":" and url's port, serialized.

The p870 host attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

5. Basic URL parse the given value, with copyURL as url and host state as state override.

6. p869 Location-object-setter navigate to copyURL.

The hostname attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. If this p867 p868 Location object's url's host is null, return the empty string.

3. Return this p867 p868 Location object's url's host, serialized.

The p870 hostname attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

870

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

5. Basic URL parse the given value, with copyURL as url and hostname state as state override.

6. p869 Location-object-setter navigate to copyURL.

The port attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. If this p867 p868 Location object's url's port is null, return the empty string.

3. Return this p867 p868 Location object's url's port, serialized.

The p871 port attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. If copyURL cannot have a username/password/port, then return.

5. If the given value is the empty string, then set copyURL's port to null.

6. Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.

7. p869 Location-object-setter navigate to copyURL.

The pathname attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. Let p867 p868 url be this Location object's url.

3. If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

4. If url's path is empty, then return the empty string.

5. Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The p871 pathname attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.

5. Set copyURL's path to the empty list.

6. Basic URL parse the given value, with copyURL as url and path start state as state override.

7. p869 Location-object-setter navigate to copyURL.

The search attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

871

2. If this p867 p868 Location object's url's query is either null or the empty string, return the empty string.

3. Return " p867 p868 ? ", followed by this Location object's url 's query.

The p871 search attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. If the given value is the empty string, set copyURL's query to null.

5. Otherwise, run these substeps:

1. Let input be the given value with a single leading "?" removed, if any.

2. Set copyURL's query to the empty string.

3. p868 Basic URL parse input , with copyURL as url and query state as state override , and the relevant Document 's

document's character encoding as encoding override.

6. p869 Location-object-setter navigate to copyURL.

The hash attribute's getter must run these steps: ✔ MDN

1. If this p867 p868 p841 p842 Location object's relevant Document is non-null and its origin is not same origin-domain with the entry

settings object p908 p904 's origin, then throw a "SecurityError" DOMException.

2. If this p867 p868 Location object's url's fragment is either null or the empty string, return the empty string.

3. Return " p867 p868 # ", followed by this Location object's url 's fragment.

The p872 hash attribute's setter must run these steps:

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Let p867 p868 copyURL be a copy of this Location object's url.

4. Let input be the given value with a single leading "#" removed, if any.

5. Set copyURL's fragment to the empty string.

6. Basic URL parse input, with copyURL as url and fragment state as state override.

7. p869 Location-object-setter navigate to copyURL.

Note

Unlike the equivalent API for the p239 p444 p872 a and area elements, the hash attribute's setter does not special case the empty string

to remain compatible with deployed scripts.



When the assign(url) method is invoked, the user agent must run the following steps: ✔ MDN

1. If this p867 p868 Location object's relevant Document is null, then return.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. p89 p908 Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.

4. p869 p89 p876 Location-object navigate given the resulting URL record and " default".

When the replace(url) method is invoked, the user agent must run the following steps: ✔ MDN

872

1. If this p867 p868 Location object's relevant Document is null, then return.

2. p89 p908 Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.

3. p869 p89 p876 Location-object navigate given the resulting URL record and " replace".

Note

The p872 ✔ MDN replace() method intentionally has no security check.

When the reload() method is invoked, the user agent must run the appropriate steps from the following list:

↪ p867 p868 If this Location object's relevant Document is null

Return.

↪ p867 p868 p841 p842 If this Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin

Throw a "SecurityError" DOMException.

↪ p932 If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing

context p814

Repaint the p814 browsing context and return.

↪ p814 p814 p363 If the browsing context 's active document is an iframe srcdoc document

Reprocess the p364 p814 p817 iframe attributes of the browsing context 's container.

↪ Otherwise

Navigate p876 p814 p867 p868 p876 the browsing context to this Location object's relevant Document 's URL , with exceptionsEnabled set

to true, p876 p876 p876 p814 historyHandling set to " reload ", and the source browsing context set to the browsing context being navigated.

When a user requests that the p814 p814 active document of a browsing context be reloaded through a user interface element, the user agent should p876 p814 p115 p876 navigate the browsing context to the same resource as that Document , with historyHandling set to

" p876 reload". In the case of non-idempotent methods (e.g., HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g., purchases or database modifications) could be repeated. User agents may allow the user to explicitly override any caches when reloading.



The ancestorOrigins attribute's getter must run these steps: MDN

1. If this p867 p868 Location object's relevant Document is null, then return an empty list.

2. If this p867 p868 p841 p842 Location object's relevant Document 's origin is not same origin-domain with the entry settings

object p908 p904 's origin, then throw a "SecurityError" DOMException.

3. Otherwise, return this p867 p869 Location object's ancestor origins list.

⚠Warning!

The details of how the p873 ancestorOrigins attribute works are still controversial and might change. See issue #1918

for more information.



As explained earlier, the p867 p867 Location exotic object requires additional logic beyond IDL for security purposes. The Location object must use the ordinary internal methods except where it is explicitly specified otherwise below.

Also, every p867 Location object has a [[DefaultProperties]] internal slot representing its own properties at time of its creation.



7.9.5.1 [[GetPrototypeOf]] ( ) p87 §

3

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryGetPrototypeOf(this).



873

2. Return null.



7.9.5.2 [[SetPrototypeOf]] ( V ) p87 §

4

1. Return ! SetImmutablePrototype(this, V).



7.9.5.3 [[IsExtensible]] ( ) p87 §

4

1. Return true.



7.9.5.4 [[PreventExtensions]] ( ) p87 §

4

1. Return false.



7.9.5.5 [[GetOwnProperty]] ( P ) p87 §

4

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then:

1. Let desc be ! OrdinaryGetOwnProperty(this, P).

2. If the value of the p873 [[DefaultProperties]] internal slot of this contains P, then set desc.[[Configurable]] to true.

3. Return desc.

2. Let p826 property be ! CrossOriginGetOwnPropertyHelper (this, P).

3. If property is not undefined, then return property.

4. Return ? p826 CrossOriginPropertyFallback (P).



7.9.5.6 [[DefineOwnProperty]] ( P, Desc ) p87 §

4

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then:

1. If the value of the p873 [[DefaultProperties]] internal slot of this contains P, then return false.

2. Return ? OrdinaryDefineOwnProperty(this, P, Desc).

2. Throw a "SecurityError" DOMException.



7.9.5.7 [[Get]] ( P, Receiver ) p87 §

4

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryGet(this, P, Receiver).

2. Return ? p827 CrossOriginGet (this, P, Receiver).



7.9.5.8 [[Set]] ( P, V, Receiver ) p87 §

4

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then return ? OrdinarySet(this, P, Receiver).

2. Return ? p827 CrossOriginSet(this, P, V, Receiver).

874

7.9.5.9 [[Delete]] ( P ) p87 §

5

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryDelete(this, P).

2. Throw a "SecurityError" DOMException.



7.9.5.10 [[OwnPropertyKeys]] ( ) p87 §

5

1. If ! p826 IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryOwnPropertyKeys(this).

2. Return ! p827 CrossOriginOwnPropertyKeys (this).



7.10 Browsing the web p87 §

5

7.10.1 Navigating across documents p87 §

5

Certain actions cause the p814 p876 browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.

Example

For example, p291 p597 p831 p872 following a hyperlink , form submission , and the window.open() and location.assign() methods can

all cause a browsing context to navigate.



Note

A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses

HTTP POST would also have the HTTP method and payload. Similarly, p363 an iframe srcdoc document needs to know the data it is

to use.

Much of the navigation process is concerned with determining how to create a new p115 Document , which ultimately happens in the

create and initialize a p882 Document object algorithm. The parameters to this algorithm are tracked via a navigation params struct,

which has the following items:

request

null or a request that started the navigation

response

a response that ultimately was navigated to (potentially a network error)

origin

an p841 p115 origin to use for the new Document

final sandboxing flag set

a p845 p115 sandboxing flag set to impose on the new Document

cross-origin opener policy

a p848 p115 cross-origin opener policy to use for the new Document

COOP enforcement result

a p850 cross-origin opener policy enforcement result , used for reporting and potentially for causing a browsing context group

switch p850

reserved environment

null or an p903 p115 environment reserved for the new Document

browsing context

the p814 p850 browsing context to be navigated (or discarded, if a browsing context group switch occurs)

history handling

a p876 history handling behavior

875

Note

Once a p875 navigation params struct is created, this standard does not mutate any of its items. They are only passed onward to

other algorithms.

After p115 p858 Document creation, the session history gets updated. A history handling behavior is used to track the desired type of session history update throughout the navigation process. It is one of the following:

"default"

A regular navigation which adds a new entry to the session history.

"entry update"

A navigation to an existing p859 p859 p834 session history entry to recreate that entry's document , which was previously discarded.

"reload"

A navigation intended to reload the current page and replace the p860 current session history entry .

"replace"

A non-reload navigation that will replace the p860 current session history entry .

Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.



As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.



To navigate a browsing context browsingContext to a resource resource, with an optional boolean exceptionsEnabled (default false), an optional p876 p876 history handling behavior historyHandling (default " default"), and an optional string navigationType (default "other"):

1. If resource is a URL, then set resource to a new request whose url is resource.

2. If p876 resource is a request and historyHandling is " reload ", then set resource's reload-navigation flag.

3. If the p876 p821 source browsing context is not allowed to navigate browsingContext, then:

1. If exceptionsEnabled is given and is true, then throw a "SecurityError" DOMException.

2. Otherwise, the user agent may instead offer to open p817 resource in a new top-level browsing context or in the top-

level browsing context p817 p876 of the source browsing context, at the user's option, in which case the user agent

must p876 p817 navigate that designated top-level browsing context to resource as if the user had requested it independently.

Note

Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.

4. If there is a preexisting attempt to navigate p876 browsingContext , and the source browsing context is the same as

browsingContext p895 , and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.

5. If the p894 p814 prompt to unload algorithm is being run for the active document of browsingContext, then return without

affecting the p894 prompt to unload algorithm.

6. If p876 p814 historyHandling is not " reload ", resource is a request , resource 's url equals browsingContext 's active document 's

URL with exclude fragments flag set, and resource's url's fragment is non-null, then:

1. p889 Navigate to a fragment given browsingContext, resource's url, and historyHandling.

2. Return.

7. Let p841 p814 activeDocumentNavigationOrigin be the origin of the active document of browsingContext.

8. Let p841 p908 p614 incumbentNavigationOrigin be the origin of the incumbent settings object , or if no script was involved, the

origin p841 p876 of the node document of the element that initiated the navigation.

9. Cancel any preexisting but not yet p885 mature attempt to navigate browsingContext, including canceling any instances of the

876

fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document

object p882 p896 p115 p885 , abort that Document also. (Navigation attempts that have matured already have session history entries,

and are therefore handled during the p884 update the session history with the new page algorithm, later.)

10. p894 p814 Prompt to unload the active document of browsingContext. If the user refused to allow the document to be

unloaded p895, then return.

If this instance of the p876 p894 navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.

11. p896 p814 Abort the active document of browsingContext.

12. If p817 p819 browsingContext is a child browsing context , then put it in the delaying load events mode.

The user agent must take this p817 p819 p876 child browsing context out of the delaying load events mode when this navigation

algorithm later p885 matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.

13. Let p848 sandboxFlags be the result of determining the creation sandboxing flags given browsingContext and

browsingContext p817 's container.

14. Return to whatever algorithm invoked the navigation steps and continue running these steps p42 in parallel.

15. This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:

If resource is a response

1. Assert: p817 browsingContext is not a top-level browsing context.

2. Let p848 finalSandboxFlags be the union of browsingContext 's sandboxing flags and resource's forced sandboxing

flag set p848.

3. Let p815 responseOrigin be the result of determining the origin given browsingContext, resource's url,

finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.

4. Let p848 coop be a new cross-origin opener policy.

5. Let p850 coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing

context group switch p850 p850 is false, would need a browsing context group switch due to report-only is false,

url p850 p850 p850 is resource 's url , origin is responseOrigin , cross-origin opener policy is coop, and current context is

navigation source p850 is false.

6. Let p875 p875 p875 navigationParams be a new navigation params whose request is null, response is resource,

origin p875 p875 p875 is responseOrigin , final sandboxing flag set is finalSandboxFlags , cross-origin opener policy is

coop p875 p875 , COOP enforcement result is coopEnforcementResult , reserved environment is null, browsing

context p875 p875 is browsingContext , and history handling is historyHandling.

7. Run p880 p876 process a navigate response with navigationType , the source browsing context , and

navigationParams.

If p882 resource is a request whose url 's scheme is " javascript"

Queue a global task p933 p939 p814 on the DOM manipulation task source given browsingContext 's active window to run these steps:

1. Let p882 response be the result of executing a javascript: URL request given resource, the source browsing

context p876 , and browsingContext.

2. Let p848 finalSandboxFlags be the union of browsingContext 's sandboxing flags and response's forced sandboxing

flag set p848.

3. Let p850 coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing

context group switch p850 p850 is false, would need a browsing context group switch due to report-only is false,

url p850 p850 p850 is resource 's url , origin is activeDocumentNavigationOrigin , cross-origin opener policy is

browsingContext p814 p116 's active document 's cross-origin opener policy, and current context is navigation

source p850 is false.

4. Let p875 p875 p875 navigationParams be a new navigation params whose request is resource , response is response,

origin p875 p875 is activeDocumentNavigationOrigin , final sandboxing flag set is finalSandboxFlags, cross-origin

877

opener policy p875 p814 p116 is browsingContext 's active document 's cross-origin opener policy, COOP enforcement

result p875 p875 p875 is coopEnforcementResult , reserved environment is null, browsing context is browsingContext,

and p875 history handling is historyHandling.

5. Run p880 p876 process a navigate response with navigationType , the source browsing context , and

navigationParams.

Example

So for example a p882 p285 p239 javascript: URL in an href attribute of an a element would only be evaluated when the

link was p291 p362 p362 followed , while such a URL in the src attribute of an iframe element would be evaluated in the

context of the p362 p817 p362 iframe 's nested browsing context when the iframe is being set up. Once evaluated, its return

value (if it was a string) would replace that p814 p814 browsing context 's active document, thus also changing the

corresponding p828 Window object.

If resource is a request whose url's scheme is a fetch scheme

Run p878 p876 process a navigate fetch given resource , the source browsing context , browsingContext, navigationType, sandboxFlags, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling.

Otherwise, p882 resource is a request whose url 's scheme is neither " javascript " nor a fetch scheme

Run p881 process a navigate URL scheme given resource's url and browsingContext.

To p814 process a navigate fetch , given a request request , two browsing contexts sourceBrowsingContext and browsingContext, a string p845 p841 navigationType , a sandboxing flag set sandboxFlags , two origins incumbentNavigationOrigin and activeDocumentNavigationOrigin p876 , and a history handling behavior historyHandling:

1. Let response be null.

2. Set p814 p911 request 's client to sourceBrowsingContext 's active document 's relevant settings object, destination to "document",

mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and replaces client

id p814 p911 p903 to browsingContext 's active document 's relevant settings object 's id .

3. If p817 browsingContext 's container is non-null:

1. If the p817 p821 browsingContext 's container has a browsing context scope origin, then set request's origin to that

browsing context scope origin p821 .

2. Set p817 request 's destination to browsingContext 's container's local name.

4. Let reservedEnvironment be null.

5. Let responseOrigin be null.

6. Let p814 p842 currentContextIsSource be the result of whether browsingContext 's active document is same origin with source's

active document p814.

7. Let p850 coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context

group switch p850 p850 p850 is false, would need a browsing context group switch due to report-only is false, url is

browsingContext p814 p850 p814 p841 's active document 's url , origin is browsingContext 's active document 's origin , cross-origin

opener policy p850 p814 p116 is browsingContext 's active document 's cross-origin opener policy, and current context is navigation

source p850 is currentContextIsSource.

8. Let p845 finalSandboxFlags be an empty sandboxing flag set.

9. While true:

1. Let currentURL be response's location URL, if response is not null, and request's current URL otherwise.

2. If p842 reservedEnvironment is not null and currentURL 's origin is not the same as reservedEnvironment's creation

URL p903's origin, then:

1. Run the p904 environment discarding steps for reservedEnvironment.

2. Set reservedEnvironment to null.

3. If reservedEnvironment is null, then:

1. Let topLevelCreationURL be currentURL.

878

2. Let topLevelOrigin be null.

3. If p817 browsingContext is not a top-level browsing context, then:

1. Let p817 p911 parentEnvironment be browsingContext 's container 's relevant settings object .

2. Set p903 topLevelCreationURL to parentEnvironment 's top-level creation URL and topLevelOrigin

to p903 parentEnvironment 's top-level origin .

4. Set p903 p903 reservedEnvironment to a new environment whose id is a unique opaque string, target

browsing context p904 p903 p903 is browsingContext , creation URL is currentURL , top-level creation URL is

topLevelCreationURL p903 , and top-level origin is topLevelOrigin.

Note

The created environment's p904 active service worker is set in the Handle Fetch algorithm during the

fetch if the request URL matches a service worker registration. p1281 [SW]

4. Set request's reserved client to reservedEnvironment.

5. If the result of Should navigation request of type be blocked by Content Security Policy? given request and

navigationType p1275 is " Blocked ", then set response to a network error and break . [CSP]

6. Otherwise:

1. If response is null, fetch request.

2. Otherwise, perform HTTP-redirect fetch using request and response.

3. Wait for the p932 p939 task on the networking task source to process response and set response to the

result.

4. Set p848 finalSandboxFlags to the union of browsingContext 's sandboxing flags and response's forced

sandboxing flag set p848.

5. Set p815 responseOrigin to the result of determining the origin given browsingContext, request's url,

finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.

6. If p817 browsingContext is a top-level browsing context , then:

1. Set p849 responseCOOP to the result of obtaining a cross-origin opener policy given response and

reservedEnvironment.

2. If p848 p848 sandboxFlags is not empty and responseCOOP 's value is not " unsafe-none", then set

response to an appropriate network error and break.

Note

This results in a network error as one cannot simultaneously provide a clean slate to a response using cross-origin opener policy and sandbox the result of navigating to that response.

3. Set coopEnforcementResult to the result of enforcing the response's cross-origin opener

policy p850 given browsingContext, request's url, responseOrigin, responseCOOP,

coopEnforcementResult and request's referrer.

7. If p817 response is not a network error , browsingContext is a child browsing context , and the result of

performing a p817 cross-origin resource policy check with browsingContext 's container document 's

origin p841 p817 p911 , browsingContext 's container document 's relevant settings object, request's destination,

response, and true is blocked, then set response to a network error and break.

Note

Here we're running the p817 cross-origin resource policy check against the parent browsing context rather than sourceBrowsingContext. This is because we care about the same-originness of the embedded content against the parent context, not the navigation source.

8. If response does not have a location URL or the location URL is not a URL whose scheme is an HTTP(S)

scheme, then break.

879

Note

Navigation handles redirects manually as navigation is the only place in the web platform that cares

for redirects to mailto: URLs and such.

10. If response has a location URL that is failure, then set response to a network error.

11. Otherwise, if response has a location URL that is a URL whose scheme is "blob", "file", "filesystem", or "javascript",

then set response to a network error.

12. Otherwise, if response has a location URL that is a URL whose scheme is a fetch scheme, then run process a navigate

fetch p878 with a new request whose url is response's location URL, sourceBrowsingContext, browsingContext, navigationType, sandboxFlags, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling, and return.

13. Otherwise, if p881 response has a location URL that is a URL , run the process a navigate URL scheme given response's location

URL and browsingContext, and return.

14. Let p875 p875 p875 p875 navigationParams be a new navigation params whose request is request , response is response , origin is

responseOrigin p875 p875 , final sandboxing flag set is finalSandboxFlags , cross-origin opener policy is responseCOOP, COOP

enforcement result p875 p875 p875 is coopEnforcementResult , reserved environment is reservedEnvironment , browsing context is

browsingContext p875 , and history handling is historyHandling.

15. Run p880 p876 process a navigate response with navigationType , the source browsing context , and navigationParams.

To p814 p875 process a navigate response , given a string navigationType , a browsing context source , and a navigation params navigationParams:

1. Let p875 response be navigationParams 's response.

2. Let p875 browsingContext be navigationParams 's browsing context.

3. Let failure be false.

4. If response is a network error, then set failure to true.

Otherwise, if the result of Should navigation response to navigation request of type in target be blocked by Content Security

Policy? p875 given navigationParams 's request, response, navigationType, and browsingContext is "Blocked", then set failure

to true. p1275 [CSP]

Otherwise, if the result of p857 checking a navigation response's adherence to its embedder policy given response and browsingContext is false, then set failure to true.

Otherwise, if the result of p897 checking a navigation response's adherence to ` X-Frame-Options ` given response,

browsingContext p875 , and navigationParams 's origin is false, then set failure to true.

5. If failure is true, then:

1. p888 Display the inline content with an appropriate error shown to the user given browsingContext.

2. Run the p904 p875 environment discarding steps for navigationParams 's reserved environment.

3. Return.

Note

This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to

users. p1277 [FETCH]

6. If response's status is 204 or 205, then return.

7. If response has a `Content-Disposition` header specifying the attachment disposition type, then:

1. If the result of running the p291 allowed to download given source and browsingContext is true, then handle

response p292 as a download .

2. Return.

8. Let type be the computed type of response.

9. If the user agent has been configured to process resources of the given type using some mechanism other than rendering

the content in a p814 browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the

880

appropriate entry in the following list, and process response as described there:

↪ an HTML MIME type

Follow the steps given in the p886 HTML document section providing navigationParams. Once the steps have completed, return.

↪ p881 an XML MIME type that is not an explicitly supported XML MIME type

Follow the steps given in the p886 XML document section providing navigationParams and type. Once the steps have completed, return.

↪ a JavaScript MIME type

↪ p881 a JSON MIME type that is not an explicitly supported JSON MIME type

↪ p1273 " text/css"

↪ "text/plain"

↪ p1274 " text/vtt"

Follow the steps given in the p886 plain text file section providing navigationParams and type. Once the steps have completed, return.

↪ p1242 " multipart/x-mixed-replace"

Follow the steps given in the p887 multipart/x-mixed-replace section providing navigationParams. Once the steps have completed, return.

↪ A supported image, video, or audio type

Follow the steps given in the p887 media section providing navigationParams and type. Once the steps have completed, return.

↪ A type that will use an external application to render the content in browsingContext

Follow the steps given in the p888 plugin section providing navigationParams and type. Once the steps have completed, return.

An explicitly supported XML MIME type is an XML MIME type for which the user agent is configured to use an external

application to render the content (either a p45 plugin rendering directly in browsingContext, or a separate application), or one for which the user agent has dedicated processing rules (e.g., a web browser with a built-in Atom feed viewer would be said

to explicitly support the p1272 application/atom+xml MIME type), or one for which the user agent has a dedicated handler.

An explicitly supported JSON MIME type is a JSON MIME type for which the user agent is configured to use an external

application to render the content (either a p45 plugin rendering directly in browsingContext, or a separate application), or one for which the user agent has dedicated processing rules, or one for which the user agent has a dedicated handler.

10. Non-document content: If, given type, the new resource is to be handled by displaying some sort of inline content, e.g., a

native rendering of the content or an error message because the specified type is not supported, then display the inline

content p888 given browsingContext, and then return.

11. Otherwise, the document's type is such that the resource will not affect browsingContext, e.g., because the resource is to be

handed to an external application or because it is an unknown type that will be processed p292 as a download . Process the

resource appropriately p881 .

To p814 process a navigate URL scheme , given a URL url and browsing context browsingContext, run these steps:

1. If url is to be handled using a mechanism that does not affect browsingContext, e.g., because url's scheme is handled

externally, then p881 proceed with that mechanism instead .

2. Otherwise, url is to be handled by displaying some sort of inline content, e.g., an error message because the specified

scheme is not one of the supported protocols, or an inline prompt to allow the user to select p971 a registered handler for the

given scheme. p888 Display the inline content given browsingContext.

Note

In the case of a registered handler being used, p876 navigate will be invoked with a new URL.

When a resource is handled by passing its URL or data to an external software package separate from the user agent (e.g.

handing a mailto: URL to a mail client, or a Word document to a word processor), user agents should attempt to mitigate the risk that this is an attempt to exploit the target software, e.g. by prompting the user to confirm that the p876 source browsing context's active

document p814 p841 p876 's origin is to be allowed to invoke the specified software. In particular, if the navigate algorithm was invoked when

source browsing context p876 p814 p770 's active window does not have transient activation , the user agent should not invoke the external software package without prior user confirmation.

881

Example

For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by

tricking a user into clicking a link.

To p814 execute a javascript: URL request , given a request request and two browsing contexts source and browsingContext, run these steps:

1. Let response be a response whose status is 204.

2. If both of the following are true:

◦ p814 p841 p842 p814 p841 source 's active document 's origin is same origin with browsingContext 's active document 's origin .

As explained in issue #2591 this step does not work and presents a security issue.

◦ The result of Should navigation request of type be blocked by Content Security Policy? given request and "other" is

" p1275 Allowed ". [CSP]

then:

1. Let urlString be the result of running the URL serializer on request's url.

2. Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.

3. Let scriptSource be the UTF-8 decoding of the percent-decoding of encodedScriptSource.

4. p814 Append browsingContext 's active document's URL to request's URL list.

5. Let p814 p911 settings be browsingContext 's active document 's relevant settings object.

6. Let p904 baseURL be settings 's API base URL.

7. Let p920 script be the result of creating a classic script given scriptSource, settings, baseURL, and the default classic

script fetch options p913.

8. Let p921 evaluationStatus be the result of running the classic script script.

9. Let result be undefined if evaluationStatus is an abrupt completion or evaluationStatus.[[Value]] is empty, or

evaluationStatus.[[Value]] otherwise.

10. If p90 Type ( result ) is String, then set response to a response whose header list consists of ` Content-Type`/`text/

html p1241` and `Referrer-Policy`/settings's referrer policy, and whose body is result.

The exact conversion between the string result and the bytes that comprise a response body is not yet

specified, pending further investigation into user agent behavior. See issue #1129.

3. Return response.



In addition to the specific issues linked above, p882 javascript: URLs have a dedicated label on the issue tracker documenting various problems with their specification.



Some of the sections below, to which the above algorithm defers in certain cases, use the following steps to create and initialize a Document p875 object , given a type type , content type contentType , and navigation params navigationParams:

1. Let p851 browsingContext be the result of the obtaining a browsing context to use for a navigation response given

navigationParams p875 p875 's browsing context , navigationParams 's final sandboxing flag set, navigationParams's cross-origin

opener policy p875 p875 , and navigationParams 's COOP enforcement result .

2. Let permissionsPolicy be the result of creating a permissions policy from a response given browsingContext,

navigationParams p875 p875 p1280 's origin , and navigationParams 's response . [PERMISSIONSPOLICY]

Note

The p841 p843 creating a permissions policy from a response algorithm makes use of the passed origin . If document.domain

882

has been used for p817 p841 p842 browsingContext 's container document , then its origin cannot be same origin-domain with the passed origin, because these steps run before the document is created, so it cannot itself yet have used

document.domain p843 . Note that this means that Permissions Policy checks are less permissive compared to doing a

same origin p842 check instead.

See below for some examples of this in action.

3. Let p875 creationURL be navigationParams 's response 's URL.

4. If p875 p875 navigationParams 's request is non-null, then set creationURL to navigationParams 's request's current URL.

5. If p858 p51 p115 browsingContext 's only entry in its session history is the initial about:blank Document that was added when that

browsing context p814 p815 p875 p876 p115 was created , and navigationParams 's history handling is " replace ", and that Document's

origin p841 p842 p875 is same origin-domain with navigationParams 's origin , then do nothing.

6. Otherwise:

1. Let p1248 oacHeader be the result of getting a structured field value given ` Origin-Agent-Cluster` and "item" from

response's header list.

2. Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.

3. If p912 reservedEnvironment is a non-secure context, then set requestsOAC to false.

4. Let p901 p875 agent be the result of obtaining a similar-origin window agent given navigationParams 's origin,

browsingContext p818 's group, and requestsOAC.

5. Let p905 realm execution context be the result of creating a new JavaScript realm given agent and the following

customizations:

▪ For the global object, create a new p828 Window object.

▪ For the global p837 this binding, use browsingContext 's WindowProxy object.

6. Let topLevelCreationURL be creationURL.

7. Let p875 topLevelOrigin be navigationParams 's origin.

8. If p817 browsingContext is not a top-level browsing context, then:

1. Let p817 p911 parentEnvironment be browsingContext 's container 's relevant settings object .

2. Set p903 topLevelCreationURL to parentEnvironment 's top-level creation URL .

3. Set p903 topLevelOrigin to parentEnvironment 's top-level origin .

9. p836 Set up a window environment settings object with creationURL, realm execution context, navigationParams's

reserved environment p875, topLevelCreationURL, and topLevelOrigin.

7. Let p115 p841 document be a new Document , whose type is type , content type is contentType , origin is navigationParams's

origin p875 p116 p848 , permissions policy is permissionsPolicy , active sandboxing flag set is navigationParams's final sandboxing

flag set p875 p116 p875 , and cross-origin opener policy is navigationParams 's cross-origin opener policy .

8. Set document's URL to creationURL.

9. Set p116 p875 document 's referrer policy to the result of parsing the ` Referrer-Policy ` header of navigationParams 's response.

[REFERRERPOLICY] p1280

10. Set p116 p857 p875 document 's embedder policy to the result of obtaining an embedder policy from navigationParams 's response.

11. p875 p875 Initialize a Document 's CSP list given document , navigationParams 's response , and navigationParams 's request.

[CSP] p1275

12. If p875 navigationParams 's request is non-null, then:

1. Set p115 document 's referrer to the empty string.

2. Let p875 referrer be navigationParams 's request 's referrer.

883

3. If p115 referrer is a URL record , then set document 's referrer to the serialization of referrer.

Note

Per Fetch, referrer will be either a URL record or "no-referrer" at this point.

13. If p875 p1249 navigationParams 's response has a ` Refresh` header, then:

1. Let value be the isomorphic decoding of the value of the header.

2. Run the p172 shared declarative refresh steps with document and value.

We do not currently have a spec for how to handle multiple ` p1249 Refresh` headers. This is tracked as issue #2900.

14. Return document.

Example

In this example, the child document is not allowed to use p842 PaymentRequest , despite being same origin-domain at the time the

child document tries to use it. At the time the child document is initialized, only the parent document has set p843 document.domain ,

and the child document has not.





Example

In this example, the child document p842 is allowed to use PaymentRequest , despite not being same origin-domain at the time the

child document tries to use it. At the time the child document is initialized, none of the documents have set p843 document.domain

yet so p842 p842 same origin-domain falls back to a normal same origin check.





Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page p875 p115 , given some navigation params navigationParams and a Document newDocument. When a user agent is required to do this, it must p933 p939 p911 queue a global task on the networking task source , given the relevant global object of the p115 p860 Document object of the current entry (not the new one), to run the following steps:

1. p895 p859 p860 Unload the document of the current entry .

884

If this instance of the p876 p895 navigation algorithm is canceled while this step is running the unload a document algorithm,

then the p895 p876 unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)

2. p875 p876 p876 If navigationParams 's history handling is " entry update " or " reload "

1. Replace the p859 p860 document of the current entry , and of any other entries that reference the same

document p859 as that entry, with newDocument.

2. p890 p860 p890 Traverse the history to the current entry with historyHandling set to navigationParams's history

handling p875 .

Otherwise, if the navigation was initiated with a p875 URL that equals navigationParams 's browsing context's

active document p814's URL

1. Let p859 p859 p859 newEntry be a new session history entry whose URL is newDocument 's URL and document is

newDocument.

Some browsers copy over the serialized state of p860 current entry, but this is inconsistent. See issue #6213 for more discussion on this.

2. Insert p860 p875 p858 newEntry after the current entry in navigationParams 's browsing context 's session history.

3. p890 p890 p876 Traverse the history to newEntry with historyHandling set to " replace".

Otherwise, if p875 p876 navigationParams 's history handling is " replace"

1. Let p859 p859 p859 newEntry be a new session history entry whose URL is newDocument 's URL and document is

newDocument.

2. Insert p860 p875 p858 newEntry after the current entry in navigationParams 's browsing context 's session history.

3. p890 p890 p876 Traverse the history to newEntry with historyHandling set to " replace".

Otherwise

1. Assert: p875 p876 navigationParams 's history handling is " default ".

2. Remove all the entries in the p858 p860 p860 session history after the current entry . If the current entry is the last

entry in the session history, then no entries are removed.

Note

This p866 doesn't necessarily have to affect the user agent's user interface.

3. Append a new p859 p858 p859 session history entry to the session history , whose URL is newDocument's URL and

document p859 is newDocument.

4. p890 Traverse the history to the new entry.

3. The p876 navigation algorithm has now matured.

4. p885 Try to scroll to the fragment for newDocument.

To p115 p42 try to scroll to the fragment for a Document document , perform the following steps in parallel:

1. Wait for an implementation-defined amount of time. (This is intended to allow the user agent to optimize the user experience

in the face of performance concerns.)

2. p933 p939 p911 Queue a global task on the networking task source given document 's relevant global object to run these steps:

1. If p1161 document has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user

is no longer interested in scrolling to the fragment, then abort these steps.

2. p889 p890 Scroll to the fragment given in document 's URL . If this does not find an indicated part of the document, then

try to scroll to the fragment p885 for document.



885

7.10.2 Page load processing model for HTML files p88 §

6

When p875 p933 an HTML document is to be loaded , given navigation params navigationParams , the user agent must queue a task on

the p939 networking task source to:

1. Let p882 document be the result of creating and initializing a Document object given "html", "text/html", and

navigationParams.

2. Create an p1076 p932 p939 HTML parser and associate it with the document . Each task that the networking task source places on

the p931 p1082 task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the

HTML parser p1076 to perform the appropriate processing of the input stream.

Note

The p1082 p1094 input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on

character encoding information found in the real p90 Content-Type metadata of the resource; the computed type is not used for this purpose.

When no more bytes are available, the user agent must p933 p939 queue a global task on the networking task source given the newly-

created p115 p911 Document 's relevant global object for the parser to process the implied EOF character, which eventually causes a

load p1271 event to be fired.

After creating the p115 p1161 Document object, but before any script execution, certainly before the parser stops, the user agent must

update the session history with the new page p884 p115 given navigationParams and the newly-created Document .



7.10.3 Page load processing model for XML files p88 §

6

When faced with displaying an XML file inline, provided p875 navigation params navigationParams and a string type, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications to create

and initialize a p882 p1184 Document object given " xml ", type , and navigationParams . They must also create a corresponding XML parser.

[XML] p1283 p1283 p1281 p1277 [XMLNS] [RFC7303] [DOM]

Note

At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.

The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.

Then, with the newly created p115 p884 Document , the user agent must update the session history with the new page given navigationParams p115 and the newly-created Document. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.

Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the

Document p115.



7.10.4 Page load processing model for text files p88 §

6

When a plain text document is to be loaded, provided p875 navigation params navigationParams and a string type, the user agent must

queue a task p933 p939 on the networking task source to:

1. Let p882 document be the result of creating and initializing a Document object given "html", type, and navigationParams.

2. Create an p1076 HTML parser and associate it with the document. Act as if the tokenizer had emitted a start tag token with the

tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the p1076 HTML parser's tokenizer to the

PLAINTEXT state p1096 p932 p939 p931 . Each task that the networking task source places on the task queue while fetching runs must

then fill the parser's p1082 p1076 input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.



886

The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (i.e., type).

The document's character encoding must be set to the character encoding used to decode the document.

When no more bytes are available, the user agent must p933 p939 queue a global task on the networking task source given the newly-

created p115 p911 Document 's relevant global object for the parser to process the implied EOF character, which eventually causes a

load p1271 event to be fired.

After creating the p115 Document object, but potentially before the page has finished parsing, the user agent must update the session

history with the new page p884 p115 given navigationParams and the newly-created Document .

User agents may add content to the p154 p115 head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a p155 title.

Note

In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra

styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.



7.10.5 Page load processing model for multipart/x-mixed-replace resources p88 §

7

When a resource with the type p1242 p814 multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must parse the resource using the rules for multipart types. p1280 [RFC2046]



This algorithm is passed p875 navigation params, but it's unclear how exactly to use them.



For each body part obtained from the resource, the user agent must run p880 process a navigate response using the new body part and the same p814 p875 p876 browsing context , with history handling set to " replace " if a previous body part from the same resource resulted in a p882 p876 creating and initializing a Document object , and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.

For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.

Note

Thus, p1271 p1272 load events (and for that matter unload events) do fire for each body part loaded.



7.10.6 Page load processing model for media p88 §

7

When an image, video, or audio resource is to be loaded, provided p875 navigation params navigationParams and a string type, the user agent should:

1. Let p882 document be the result of creating and initializing a Document object given "html", type, and navigationParams.

2. Append an p153 html element to document.

3. Append a p154 p153 head element to the html element.

4. Append a p179 p153 body element to the html element.

5. Append an element p179 host element for the media, as described below, to the body element.

6. Set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio

resource.

The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.

887

Type of media Element for the media Appropriate attribute

Image p321 p322 img src

Video p380 p390 video src

Audio p384 p390 audio src

Then, the user agent must act as if it had p1161 stopped parsing.

After creating the p115 Document object, but potentially before the page has finished fully loading, the user agent must update the

session history with the new page p884 p115 given navigationParams and the newly-created Document .

User agents may add content to the p154 p115 head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a p155 p408 title , or to make the media autoplay.



7.10.7 Page load processing model for content that uses plugins p88 §

8

When a resource that requires an external resource to be rendered is to be loaded, provided p875 navigation params navigationParams and a string type, the user agent should:

1. Let p882 document be the result of creating and initializing a Document object given "html", type, and navigationParmas.

2. Mark document as being a plugin document

3. Append an p153 html element to document.

4. Append a p154 p153 head element to the html element.

5. Append a p179 p153 body element to the html element.

6. Append an p369 p179 embed to the body element

7. Set the p370 p369 src attribute of the embed element to the address of the resource.

Note

The term p888 p362 plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used

to evade p1275 plugin-types directives. [CSP]

Then, the user agent must act as if it had p1161 stopped parsing.

After creating the p115 Document object, but potentially before the page has finished fully loading, the user agent must update the

session history with the new page p884 p115 given navigationParams and the newly-created Document .

User agents may add content to the p154 p115 p369 head element of the Document , or attributes to the embed element, e.g. to link to a style sheet or to give the document a p155 title.

Note

If the p115 p848 p846 Document 's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized

embed p369 p372 p45 p45 element will fail to render the content if the relevant plugin cannot be secured.



7.10.8 Page load processing model for inline content that doesn't have a DOM p88 §

8

When the user agent is to display a user agent page inline, provided a p814 browsing context browsingContext, the user agent should:

1. Let p875 p875 p875 p875 navigationParams be a new navigation params whose request is null, response is null, origin is a new

opaque origin p841 p875 p875 , final sandboxing flag set is an empty set, cross-origin opener policy is a new cross-origin opener

policy p848 p875 p850 p875 , COOP enforcement result is a new cross-origin opener policy enforcement result , reserved environment

is null, and p875 browsing context is browsingContext.

The algorithm called in the next step is not prepared to deal with a null p875 response . Probably we should synthesize one

888

instead.

2. Let p882 document be the result of creating and initializing a Document object given "html", "text/html", and

navigationParams.

3. Either associate p115 document with a custom rendering that is not rendered using the normal Document rendering rules, or

mutate document until it represents the content the user agent wants to render.

Once the page has been set up, the user agent must act as if it had p1161 stopped parsing.

After creating the p115 Document object, but potentially before the page has been completely set up, the user agent must update the

session history with the new page p884 p115 given navigationParams and the newly-created Document .



7.10.9 Navigating to a fragment p88 §

9

To p814 p876 navigate to a fragment given a browsing context browsingContext , a URL url , and a history handling behavior historyHandling:

1. If p876 p858 historyHandling is not " replace ", then remove all the entries in browsingContext 's session history after the current

entry p860 p860 . (If the current entry is the last entry in the session history, then no entries are removed.)

Note

This p866 doesn't necessarily have to affect the user agent's user interface.

2. Remove any p932 p939 p115 tasks queued by the history traversal task source that are associated with any Document objects in

browsingContext p817 p819 's top-level browsing context 's document family.

3. Append a new p859 p858 p859 p859 p860 session history entry to the session history whose URL is url , document is the current entry's

document p859 p859 p860 p859 , and scroll restoration mode is the current entry 's scroll restoration mode.

4. p890 p890 p890 Traverse the history to the new entry, with historyHandling set to historyHandling and with nonBlockingEvents set

to true. This will p889 scroll to the fragment given in what is now the document's URL.

Note

If the scrolling fails because the relevant p876 ID has not yet been parsed, then the original navigation algorithm will take care of the

scrolling instead, as the last few steps of its p884 update the session history with the new page algorithm.



When the user agent is required to p890 p1188 scroll to the fragment and the indicated part of the document , if any, is being rendered, the user agent must either change the scrolling position of the document using the following algorithm, or perform some other action such that p890 the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not p1188 being rendered, then the user agent must do nothing. The aforementioned algorithm is as follows:

1. If there is no p890 p115 p890 indicated part of the document , set the Document 's target element to null.

2. If the p890 indicated part of the document is the top of the document, then:

1. Set the p115 p890 Document 's target element to null.

2. p115 p1276 Scroll to the beginning of the document for the Document . [CSSOMVIEW]

3. Otherwise:

1. Let p890 target be element that is the indicated part of the document .

2. Set the p115 p890 Document 's target element to target.

3. Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest".

[CSSOMVIEW] p1276

4. Run the p779 p115 focusing steps for target , with the Document's viewport as the fallback target.

5. Move the p782 sequential focus navigation starting point to target.

889

The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the p115 MIME type used by the Document (for example, the processing of p1281 fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]

There is also a p115 p729 target element for each Document , which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.

For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of

the document p890 is.

1. Let fragment be the document's URL's fragment.

2. If p890 fragment is the empty string, then the indicated part of the document is the top of the document; return.

3. If p890 find a potential indicated element with fragment returns non-null, then the return value is the indicated part of the

document p890; return.

4. Let fragmentBytes be the result of percent-decoding fragment.

5. Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.

6. If p890 find a potential indicated element with decodedFragment returns non-null, then the return value is the indicated part of

the document p890 ; return.

7. If p890 decodedFragment is an ASCII case-insensitive match for the string top , then the indicated part of the document is the

top of the document; return.

8. There is no p890 indicated part of the document.

To find a potential indicated element given a string fragment, run these steps:

1. If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.

2. If there is an p239 p1224 a element in the document tree that has a name attribute whose value is equal to fragment, then return

the first such element in tree order.

3. Return null.



7.10.10 History traversal p89 §

0

To p859 p876 traverse the history to a session history entry entry , with an optional history handling behavior historyHandling (default

" p876 default "), an optional boolean nonBlockingEvents (default false), and an optional boolean explicitHistoryNavigation (default false): Note

This algorithm is not just invoked when p862 explicitly going back or forwards in the session history — it is also invoked in other

situations, for example when p876 p884 navigating a browsing context , as part of updating the session history with the new page.

1. If p859 entry 's document is null, then:

1. Assert: p876 historyHandling is " default".

2. Let p859 request be a new request whose url is entry 's URL .

3. If explicitHistoryNavigation is true, then set request's history-navigation flag.

4. p876 p814 p876 p876 Navigate the browsing context to request with historyHandling set to " entry update ". The navigation

must be done using the same p876 source browsing context as was used the first time entry was created.

Note

The " p876 navigate " algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point

entry p859 's document is non-null.



890

Note

If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.

5. Return.

2. If the p860 p859 p859 p118 current entry 's title is null, then set its title to the value returned by the document.title IDL attribute.

3. p892 p860 Save persisted state to the current entry.

4. Let p859 newDocument be entry 's document.

5. If p860 p859 p876 newDocument is different than the current entry 's document , or historyHandling is " entry update" or

" p876 reload", then:

1. Remove any p932 p939 p115 tasks queued by the history traversal task source that are associated with any Document

objects in the p817 p819 top-level browsing context 's document family .

2. If p841 p842 p860 p859 p841 newDocument 's origin is not same origin with the current entry 's document 's origin , then:

1. Let p859 p858 p859 p841 entriesToUpdate be all entries in the session history whose document 's origin is same

origin p842 p814 p860 as the active document and that are contiguous with the current entry.

2. p859 For each entryToUpdate of entriesToUpdate , set entryToUpdate 's browsing context name to the

current p822 browsing context name .

3. If the browsing context is a p817 p818 top-level browsing context , but not an auxiliary browsing context , then

set the browsing context's p822 name to the empty string.

3. p815 p814 Set the active document of the browsing context to newDocument.

4. If p859 entry 's browsing context name is not null, then:

1. Set the browsing context's p822 p859 name to entry 's browsing context name .

2. Let p859 p858 p859 p841 entriesToUpdate be all entries in the session history whose document 's origin is same

origin p842 p814 as the new active document and that are contiguous with entry.

3. p859 For each entryToUpdate of entriesToUpdate , set entryToUpdate 's browsing context name to null.

5. If p580 p575 p605 newDocument has any form controls whose autofill field name is " off ", invoke the reset algorithm of

each of those elements.

6. If p118 p933 newDocument 's current document readiness " complete ", then queue a global task on the DOM

manipulation task source p939 p911 given newDocument 's relevant global object to run the following steps:

1. If p894 newDocument 's page showing flag is true, then abort these steps.

2. Set p894 newDocument 's page showing flag to true.

3. Run any session history document visibility change steps for newDocument that are defined by

other applicable specifications p65.

Note

This is specifically intended for use by p1279 Page Visibility . [PAGEVIS]

4. p1272 p911 Fire an event named pageshow at newDocument 's relevant global object, using

PageTransitionEvent p894 p894 , with the persisted attribute initialized to true, and legacy target override flag set.

6. Set p859 newDocument 's URL to entry 's URL .

7. Let hashChanged be false, and let oldURL and newURL be null.

8. If p859 p860 p859 p859 entry 's URL 's fragment is not identical to the current entry 's URL 's fragment , and entry 's document equals the

current entry p860 p859 p860 p859 's document , then set hashChanged to true, set oldURL to the current entry 's URL, and set

newURL p859 to entry 's URL .

891

9. If p876 p858 historyHandling is " replace ", then remove the entry immediately before entry in the session history .

10. If p859 p859 p889 entry 's persisted user state is null, and its URL 's fragment is non-null, then scroll to the fragment .

11. Set the p860 current entry to entry.

12. Let targetRealm be the current Realm Record.

13. Let state be null.

14. If p859 p108 p859 entry 's serialized state is not null, then set state to StructuredDeserialize ( entry 's serialized state, targetRealm). If

this throws an exception, catch it and ignore the exception.

15. Set p860 p861 newDocument 's History object's state to state.

16. Let p860 stateChanged be true if newDocument has a latest entry , and that entry is not entry; otherwise let it be false.

17. Set p860 newDocument 's latest entry to entry.

18. If p42 p933 nonBlockingEvents is false, then run the following steps immediately . Otherwise, queue a global task on the DOM

manipulation task source p939 p911 given newDocument 's relevant global object to run the following steps instead.

1. If p1272 p911 stateChanged is true, then fire an event named popstate at newDocument 's relevant global object , using

PopStateEvent p893 p893 , with the state attribute initialized to state.

2. p892 Restore persisted state from entry.

3. If p1271 p814 p814 hashChanged is true, then fire an event named hashchange at the browsing context 's active window,

using p893 p893 p893 HashChangeEvent , with the oldURL attribute initialized to oldURL and the newURL attribute initialized to newURL.



7.10.10.1 Persisted history entry state p89 §

2

To p859 save persisted state to a session history entry entry:

1. Set the p859 p859 scroll position data of entry to contain the scroll positions for all of entry 's document's restorable scrollable

regions p892 .

2. Optionally, update p859 entry 's persisted user state to reflect any state that the user agent wishes to persist, such as the

values of form fields.

To p859 restore persisted state from a session history entry entry:

1. If p859 p860 p859 entry 's scroll restoration mode is " auto ", then the user agent may use entry 's scroll position data to restore the

scroll positions of p859 p892 entry 's document 's restorable scrollable regions.

Note

The user agent not restoring scroll positions does not imply that scroll positions will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.

2. Optionally, update other aspects of p859 entry 's document and its rendering, for instance values of form fields, that the user

agent had previously recorded in p859 entry 's persisted user state .

Note

This can even include updating the p143 p549 p494 p496 dir attribute of textarea elements or input elements whose type

attribute is in either the p500 p500 Text state or the Search state, if the persisted state includes the directionality of user input in such controls.



The p115 restorable scrollable regions of a Document document are document's viewport, and all of document's scrollable regions excepting any p817 child browsing contexts of document.



892

Note

Child browsing context p817 p115 scroll restoration is handled by the history entry for those browsing contexts' Document s.



7.10.10.2 The p893 p89 PopStateEvent interface §

3

IDL ✔ [ Exposed = Window ] MDN

interface PopStateEvent : Event {

constructor(DOMString type, optional PopStateEventInit eventInitDict = {});

readonly attribute any state;

};

dictionary PopStateEventInit : EventInit {

any state = null;

};



For web developers (non-normative)

event p893 . state

Returns a copy of the information that was provided to p864 p864 pushState() or replaceState() .

The state attribute must return the value it was initialized to. It represents the context information for the event, or null, if the state represented is the initial state of the p115 Document .



p893 ✔ MDN

7.10.10.3 The HashChangeEvent interface §p89

3

IDL [Exposed=Window]

interface HashChangeEvent : Event {

constructor(DOMString type, optional HashChangeEventInit eventInitDict = {});

readonly attribute USVString oldURL;

readonly attribute USVString newURL;

};

dictionary HashChangeEventInit : EventInit {

USVString oldURL = "";

USVString newURL = "";

};



For web developers (non-normative)

event p893 . oldURL

Returns the p859 URL of the session history entry that was previously current.

event p893 . newURL

Returns the p859 URL of the session history entry that is now current.



The oldURL attribute must return the value it was initialized to. It represents context information for the event, specifically the URL of ✔ ✔ MDN MDN

the p859 session history entry that was traversed from.

The newURL attribute must return the value it was initialized to. It represents context information for the event, specifically the URL of the p859 session history entry that was traversed to.



893

7.10.10.4 The p894 ✔ MDN p89 PageTransitionEvent interface §

4

IDL [Exposed=Window]

interface PageTransitionEvent : Event {

constructor(DOMString type, optional PageTransitionEventInit eventInitDict = {});

readonly attribute boolean persisted;

};

dictionary PageTransitionEventInit : EventInit {

boolean persisted = false;

};



For web developers (non-normative)

event p894 . persisted

For the p1272 p1271 pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.

For the p1272 pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page. Things that can cause the page to be unsalvageable include:

• The user agent decided to not keep the p115 p859 p895 Document alive in a session history entry after unload

• Having p362 iframe s that are not salvageable

• Active p996 WebSocket objects

• p896 Aborting a Document



The persisted attribute must return the value it was initialized to. It represents the context information for the event. ✔ MDN



7.10.11 Loading documents p89 §

4

A p115 Document has a completely loaded time (a time or null), which is initially null.

A p115 p894 Document is considered completely loaded if its completely loaded time is non-null.

To p115 completely finish loading a Document document:

1. Assert: p814 document 's browsing context is non-null.

2. Set p894 document 's completely loaded time to the current time.

3. Let p814 p817 container be document 's browsing context 's container.

4. If p362 p933 p939 container is an iframe element, then queue an element task on the DOM manipulation task source given

container p365 to run the iframe load event steps given container.

5. Otherwise, if p933 p939 container is non-null, then queue an element task on the DOM manipulation task source given container

to p1271 fire an event named load at container.



7.10.12 Unloading documents p89 §

4

A p115 Document has a salvageable state, which must initially be true, and a page showing flag, which must initially be false. The

page showing p894 p1272 p1272 flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two p1272 p1272 pagehide events in a row without an intervening pageshow, or vice versa).

Event loops p931 have a termination nesting level counter, which must initially be 0.

To p115 prompt to unload , given a Document object document and optionally a recursiveFlag, run these steps:



894

1. Increase the p931 p894 event loop 's termination nesting level by 1.

2. Increase the p955 document 's ignore-opens-during-unload counter by 1.

3. Let p896 event be the result of creating an event using BeforeUnloadEvent.

4. Initialize p1271 event 's type attribute to beforeunload and its cancelable attribute true.

5. p911 Dispatch : Dispatch event at document 's relevant global object.

6. Decrease the p931 p894 event loop 's termination nesting level by 1.

7. If all of the following are true:

◦ p848 p846 document 's active sandboxing flag set does not have its sandboxed modals flag set

◦ p911 p770 document 's relevant global object has sticky activation

◦ p896 event 's canceled flag is set, or the returnValue attribute of event is not the empty string

then the user agent may ask the user to confirm that they wish to unload the document.

Note

The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual

value of the p896 returnValue attribute is ignored.

The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless.

If the user agent asks the user for confirmation, it must p938 pause while waiting for the user's response.

If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.

8. If the recursiveFlag is not set, then:

1. Let p818 descendants be the list of the descendant browsing contexts of document.

2. For each browsingContext in descendants:

1. p894 p814 Prompt to unload browsingContext 's active document with the recursiveFlag set.

2. If the user p895 refused to allow the document to be unloaded , then the user implicitly also refused to

allow p895 document to be unloaded; break.

9. Decrease the p955 document 's ignore-opens-during-unload counter by 1.

To p115 unload a Document document, optionally given a recursiveFlag:

1. Increase the p931 p894 event loop 's termination nesting level by one.

2. Increase p955 document 's ignore-opens-during-unload counter by one.

3. If p894 document 's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the

pagehide p1272 p895 event and don't rerun the unloading document visibility change steps).

4. Set p894 document 's page showing flag to false.

5. If the user agent does not intend to keep p859 document alive in a session history entry (such that it can be reused later on

history traversal p890 p894 ), set document 's salvageable state to false.

6. p1272 p911 p894 Fire an event named pagehide at document 's relevant global object , using PageTransitionEvent , with the

persisted p894 p894 attribute initialized to true if document 's salvageable state is true, and false otherwise, and legacy target override flag set.

7. Run any p65 unloading document visibility change steps for document that are defined by other applicable specifications.

Note

This is specifically intended for use by p1279 Page Visibility . [PAGEVIS]

8. p894 p1272 Unload event : If document 's salvageable state is false, then fire an event named unload at document's relevant

global object p911 , with legacy target override flag set.

895

9. Decrease the p931 p894 event loop 's termination nesting level by one.

10. Run any p896 unloading document cleanup steps for document that are defined by this specification and other applicable

specifications p65.

11. If the recursiveFlag is not set, then:

1. Let p818 descendants be the list of the descendant browsing contexts of document.

2. For each browsingContext in descendants:

1. p895 p814 Unload the active document of browsingContext with the recursiveFlag set.

2. If the p894 p814 salvageable state of the active document of browsingContext is false, then set the

salvageable p894 state of document to false also.

3. If p894 p834 document 's salvageable state is false, then discard document.

12. Decrease p955 document 's ignore-opens-during-unload counter by one.

This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a

Document p115 document:

1. Let p911 window be document 's relevant global object .

2. For each p996 p911 p1003 WebSocket object webSocket whose relevant global object is window , make disappear webSocket.

If this affected any p996 p894 WebSocket objects, then set document 's salvageable state to false.

3. If p894 document 's salvageable state is false, then:

1. For each p988 p911 p995 EventSource object eventSource whose relevant global object is equal to window , forcibly close

eventSource.

2. Empty p960 window 's list of active timers.



7.10.12.1 The p896 ✔ MDN p89 BeforeUnloadEvent interface §

6

IDL [Exposed=Window]

interface BeforeUnloadEvent : Event {

attribute DOMString returnValue;

};



Note

There are no p896 BeforeUnloadEvent-specific initialization methods.

The p896 p894 BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the p896 returnValue attribute to a value besides the empty string. Authors should use the preventDefault()

method, or other means of canceling events, instead of using p896 returnValue.

The p894 returnValue attribute controls the process of prompting to unload. When the event is created, the attribute must be set to the empty string. On getting, it must return the last value it was set to. On setting, the attribute must be set to the new value.

Note

This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the

user for confirmation.



7.10.13 Aborting a document load p89 §

6

To p115 abort a Document document:

896

1. p896 p814 p817 p115 Abort the active documents of every child browsing context . If this results in any of those Document objects

having their p894 p894 salvageable state set to false, then set document 's salvageable state to false also.

2. Cancel any instances of the p932 p933 fetch algorithm in the context of document , discarding any tasks queued for them, and

discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being

canceled or any p933 p932 p894 queued tasks or any network data getting discarded, then set document 's salvageable state to false.

3. If p118 document has an active parser, then:

1. Set p955 document 's active parser was aborted to true.

2. p1162 Abort that parser.

3. Set p894 document 's salvageable state to false.

User agents may allow users to explicitly invoke the p896 p115 abort a document algorithm for a Document. If the user does so, then, if that

Document p115 p814 p933 p1271 p115 is an active document , the user agent should queue a task to fire an event named abort at that Document

object's p911 p896 relevant global object before invoking the abort algorithm.

To p115 stop document loading given a Document object document, run these steps:

1. If p814 document is not an active document, then return.

2. Let p814 browsingContext be document 's browsing context.

3. If there is an existing attempt to p876 navigate browsingContext and that attempt is not currently running the unload a

document p895 p876 algorithm, then cancel that navigation.

4. p896 Abort document.



7.10.14 The ` p1250 p89 X-Frame-Options ` header §

7

The ` p1250 p115 X-Frame-Options ` HTTP response header is a legacy way of controlling whether and how a Document may be loaded inside of a p817 child browsing context. It is obsoleted by the frame-ancestors CSP directive, which provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. p1275 p1281 [CSP] [RFC7034]

Note

In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be

implemented.



Note

Per the below processing model, if both a CSP p1250 frame-ancestors directive and an ` X-Frame-Options` header are used in the

same p1250 response , then ` X-Frame-Options` is ignored.

For web developers and conformance checkers, its value ABNF is:

X-Frame-Options = "DENY" / "SAMEORIGIN"

To p814 check a navigation response's adherence to ` X-Frame-Options ` , given a response response , a browsing context

browsingContext p841 , and an origin destinationOrigin:

1. If p817 browsingContext is not a child browsing context, then return true.

2. For each policy of response's CSP list:

1. If policy's disposition is not "enforce", then continue.

2. If policy's directive set contains a frame-ancestors directive, then return true.

3. Let p1250 rawXFrameOptions be the result of getting, decoding, and splitting ` X-Frame-Options` from response's header list.

897

4. Let xFrameOptions be a new set.

5. For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.

6. If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then

return false.

Note

The intention here is to block any attempts at applying ` p1250 X-Frame-Options` which were trying to do something valid, but appear confused.

Note

This is the only impact of the legacy `ALLOWALL` value on the processing model.

7. If xFrameOptions's size is greater than 1, then return true.

Note

This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.

8. If xFrameOptions[0] is "deny", then return false.

9. If xFrameOptions[0] is "sameorigin", then:

1. Let p817 containerDocument be browsingContext 's container document .

2. While containerDocument is not null:

1. If p841 p842 containerDocument 's origin is not same origin with destinationOrigin, then return false.

2. Let p814 containerBC be containerDocument 's browsing context .

3. Set p817 containerDocument to containerBC 's container document , if containerBC is non-null; otherwise,

null.

10. Return true.

Note

If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.



Example

The following table illustrates the processing of various values for the header, including non-conformant ones:

` p1250 X-Frame-Options` Valid Result

`DENY` ✅ embedding disallowed

`SAMEORIGIN` ✅ same-origin embedding allowed

`INVALID` ❌ embedding allowed

`ALLOWALL` ❌ embedding allowed

`ALLOW-FROM=https://example.com/` ❌ embedding allowed (from anywhere)



Example

The following table illustrates how various non-conformant cases involving multiple values are processed:

` p1250 X-Frame-Options` Result

`SAMEORIGIN, SAMEORIGIN` same-origin embedding allowed

`SAMEORIGIN, DENY` embedding disallowed

`SAMEORIGIN,` embedding disallowed

`SAMEORIGIN, ALLOWALL` embedding disallowed

`SAMEORIGIN, INVALID` embedding disallowed

`ALLOWALL, INVALID` embedding disallowed

898

` p1250 X-Frame-Options` Result

`ALLOWALL,` embedding disallowed

`INVALID, INVALID` embedding allowed

The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple

headers.



899

8 Web application APIs p90 §

0

8.1 Scripting p90 §

0

8.1.1 Introduction p90 §

0

Various mechanisms can cause author-provided executable code to run in the context of a document. These mechanisms include, but are probably not limited to:

• Processing of p614 script elements.

• Navigating to p882 javascript: URLs .

• Event handlers, whether registered through the DOM using addEventListener(), by explicit event handler content

attributes p943 p942 , by event handler IDL attributes, or otherwise.

• Processing of technologies like SVG that have their own scripting features.



8.1.2 Agents and agent clusters p90 §

0

8.1.2.1 Integration with the JavaScript agent formalism p90 §

0

JavaScript defines the concept of an agent. This section gives the mapping of that language-level concept on to the web platform.

Note

Conceptually, the agent concept is an architecture-independent, idealized "thread" in which JavaScript code runs. Such code can

involve multiple globals/ p905 realms that can synchronously access each other, and thus needs to run in a single execution thread.

Two p828 Window objects having the same agent does not indicate they can directly access all objects created in each other's realms.

They would have to be p842 p826 same origin-domain ; see IsPlatformObjectSameOrigin.

The following types of agents exist on the web platform:

Similar-origin window agent

Contains various p828 p843 Window objects which can potentially reach each other, either directly or by using document.domain .

If the encompassing p901 p828 p842 agent cluster 's cross-origin isolated is true, then all the Window objects will be same origin , can reach

each other directly, and p843 document.domain will no-op.

Note

Two p828 p842 p900 Window objects that are same origin can be in different similar-origin window agents , for instance if they are each

in their own p821 browsing context group.

Dedicated worker agent

Contains a single p1034 DedicatedWorkerGlobalScope.

Shared worker agent

Contains a single p1035 SharedWorkerGlobalScope.

Service worker agent

Contains a single ServiceWorkerGlobalScope.

Worklet agent

Contains a single p1050 WorkletGlobalScope object.



900

Note

Although a given worklet can have multiple realms, each such realm needs its own agent, as each realm can be executing code independently and at the same time as the others.

Only p900 p900 shared and dedicated worker agents allow the use of JavaScript Atomics APIs to potentially block.

To create an agent, given a boolean canBlock:

1. Let signifier be a new unique internal value.

2. Let candidateExecution be a new candidate execution.

3. Let agent be a new agent whose [[CanBlock]] is canBlock, [[Signifier]] is signifier, [[CandidateExecution]] is

candidateExecution, and [[IsLockFree1]], [[IsLockFree2]], and [[LittleEndian]] are set at the implementation's discretion.

4. Set p931 p931 agent 's event loop to a new event loop.

5. Return agent.

The p911 relevant agent for a platform object platformObject is platformObject 's relevant Realm's agent. This pointer is not yet defined in the JavaScript specification; see tc39/ecma262#1357.

Note

The agent equivalent of the current Realm Record is the surrounding agent.



8.1.2.2 Integration with the JavaScript agent cluster formalism §p90

1

JavaScript also defines the concept of an agent cluster, which this standard maps to the web platform by placing agents appropriately when they are created using the p901 p902 obtain a similar-origin window agent or obtain a worker/worklet agent algorithms.

The agent cluster concept is crucial for defining the JavaScript memory model, and in particular among which agents the backing data of SharedArrayBuffer objects can be shared.

Note

Conceptually, the agent cluster concept is an architecture-independent, idealized "process boundary" that groups together

multiple "threads" (agents). The agent clusters defined by the specification are generally more restrictive than the actual process

boundaries implemented in user agents. By enforcing these idealized divisions at the specification level, we ensure that web

developers see interoperable behavior with regard to shared memory, even in the face of varying and changing user agent process

models.

An agent cluster has an associated cross-origin isolated (a boolean), which is initially false.

An agent cluster has an associated is origin-keyed (a boolean), which is initially false.



The following defines the allocation of the p900 agent clusters of similar-origin window agents.

An p842 p841 p844 agent cluster key is a site or tuple origin . Without web developer action to achieve origin-keyed agent clusters, it will be a p842 site.

Note

An equivalent formulation is that an p901 p842 p841 agent cluster key can be a scheme-and-host or an origin .

To p841 p821 obtain a similar-origin window agent , given an origin origin , a browsing context group group, and a boolean requestsOAC, run these steps:

1. Let p842 site be the result of obtaining a site with origin.

2. Let key be site.

3. If p821 group 's cross-origin isolated is true, then set key to origin.

901

4. Otherwise, if p822 group 's historical agent cluster key map[origin] exists, then set key to group's historical agent cluster key

map p822[origin].

5. Otherwise:

1. If requestsOAC is true, then set key to origin.

2. Set p822 group 's historical agent cluster key map [origin] to key.

6. If p821 group 's agent cluster map[key] does not exist, then:

1. Let agentCluster be a new agent cluster.

2. Set p901 p821 agentCluster 's cross-origin isolated to group 's cross-origin isolated .

3. Set p901 agentCluster 's is origin-keyed to true if key equals origin; otherwise false.

4. Add the result of p901 creating an agent , given false, to agentCluster.

5. Set p821 group 's agent cluster map[key] to agentCluster.

7. Return the single p900 p821 similar-origin window agent contained in group 's agent cluster map[key].

Note

This means that there is only one p900 similar-origin window agent per browsing context agent cluster. (However, dedicated

worker p900 p900 and worklet agents might be in the same cluster.)



The following defines the allocation of the agent clusters of all other types of agents.

To p904 obtain a worker/worklet agent , given an environment settings object or null outside settings, a boolean isTopLevel, and a boolean canBlock, run these steps:

1. Let agentCluster be null.

2. If isTopLevel is true, then:

1. Set agentCluster to a new agent cluster.

2. Set p901 agentCluster 's is origin-keyed to true.

Note

These workers can be considered to be origin-keyed. However, this is not exposed through any APIs (in the way

that p845 originAgentCluster exposes the origin-keyedness for windows).

3. Otherwise:

1. Assert: outside settings is not null.

2. Let p905 ownerAgent be outside settings 's Realm's agent.

3. Set agentCluster to the agent cluster which contains ownerAgent.

4. Let p901 agent be the result of creating an agent given canBlock.

5. Add agent to agentCluster.

6. Return agent.

To p904 obtain a dedicated/shared worker agent , given an environment settings object outside settings and a boolean isShared, return the result of p902 obtaining a worker/worklet agent given outside settings, isShared, and true.

To p904 obtain a worklet agent , given an environment settings object outside settings, return the result of obtaining a worker/worklet

agent p902 given outside settings, false, and false.

To p902 obtain a service worker agent , return the result of obtaining a worker/worklet agent given null, true, and false.



902

Example

The following pairs of global objects are each within the same agent cluster, and thus can use SharedArrayBuffer instances to

share memory with each other:

• A p828 Window object and a dedicated worker that it created.

• A worker (of any type) and a dedicated worker it created.

• A p828 p828 p362 Window object A and the Window object of an iframe element that A created that could be same origin-

domain p842 with A.

• A p828 p842 p828 Window object and a same origin-domain Window object that opened it.

• A p828 Window object and a worklet that it created.

The following pairs of global objects are not within the same agent cluster, and thus cannot share memory:

• A p828 Window object and a shared worker it created.

• A worker (of any type) and a shared worker it created.

• A p828 Window object and a service worker it created.

• A p828 p828 p362 Window object and the Window object of an iframe element that A created that cannot be same origin-

domain p842 with A.

• Any two p828 p814 p814 p817 Window objects whose browsing contexts do not have a non-null opener or ancestor relationship.

This holds even if the two p828 p842 Window objects are same origin.



8.1.3 Realms and their counterparts p90 §

3

The JavaScript specification introduces the realm concept, representing a global environment in which script is run. Each realm comes with an p905 implementation-defined global object; much of this specification is devoted to defining that global object and its properties.

For web specifications, it is often useful to associate values or algorithms with a realm/global object pair. When the values are specific to a particular type of realm, they are associated directly with the global object in question, e.g., in the definition of the p828 Window or

WorkerGlobalScope p1032 p904 interfaces. When the values have utility across multiple realms, we use the environment settings object

concept.

Finally, in some cases it is necessary to track associated values before a realm/global object/environment settings object even comes into existence (for example, during p876 p903 navigation ). These values are tracked in the environment concept.



8.1.3.1 Environments p90 §

3

An p903 environment is an object that identifies the settings of a current or potential execution environment. An environment has the following fields: An id

An opaque string that uniquely identifies this p903 environment .

A creation URL

A p903 URL that represents the location of the resource with which this environment is associated.

Note

In the case of an p904 p904 environment settings object , this URL might be distinct from the environment settings object's

responsible document p904 p864 's URL , due to mechanisms such as history.pushState() .

A top-level creation URL

Null or a p903 p903 URL that represents the creation URL of the "top-level" environment. It is null for workers and worklets.

A top-level origin

A p841 for now implementation-defined value, null, or an origin . For a "top-level" potential execution environment it is null (i.e.,

when there is no response yet); otherwise it is the "top-level" p903 p904 environment 's origin . For a dedicated worker or worklet it is the

top-level origin p903 of its creator. For a shared or service worker it is an implementation-defined value.

Note

This is distinct from the p903 top-level creation URL's origin when sandboxing, workers, and worklets are involved.

903

A target browsing context

Null or a target p814 browsing context for a navigation request.

An active service worker

Null or a p903 service worker that controls the environment.

An execution ready flag

A flag that indicates whether the environment setup is done. It is initially unset.

Specifications may define p903 environment discarding steps for environments. The steps take an environment as input.

Note

The p904 environment discarding steps are run for only a select few environments: the ones that will never become execution ready

because, for example, they failed to load.



8.1.3.2 Environment settings objects p90 §

4

An p903 environment settings object is an environment that additionally specifies algorithms for: A realm execution context

A p614 JavaScript execution context shared by all scripts that use this settings object, i.e. all scripts in a given JavaScript realm. When

we p921 p922 run a classic script or run a module script, this execution context becomes the top of the JavaScript execution context

stack, on top of which another execution context specific to the script in question is pushed. (This setup ensures ParseScript and

Source Text Module Record's Evaluate know which Realm to use.) A module map

A p928 module map that is used when importing JavaScript modules.

A responsible document

A p115 p904 Document that is assigned responsibility for actions taken by the scripts that use this environment settings object.

Example

For example, the p904 p115 URL of the responsible document is used to set the URL of the Document after it has been reset using

document.open() p956 .

If the p905 p931 p904 responsible event loop is not a window event loop , then the environment settings object has no responsible

document p904.

An API URL character encoding

A character encoding used to encode URLs by APIs called by scripts that use this p904 environment settings object .

An API base URL

A p904 p89 URL used by APIs called by scripts that use this environment settings object to parse URLs.

An origin

An p841 origin used in security checks.

A referrer policy

The default p904 referrer policy for fetches performed using this environment settings object as a request client.

[REFERRERPOLICY] p1280

An embedder policy

An p856 p904 embedder policy used by cross-origin resource policy checks for fetches performed using this environment settings object

as a request client.

A cross-origin isolated capability

A boolean representing whether scripts that use this p904 environment settings object are allowed to use APIs that require cross-origin isolation.

904

An p904 environment settings object also has an outstanding rejected promises weak set and an about-to-be-notified rejected promises list p925 p905 , used to track unhandled promise rejections . The outstanding rejected promises weak set must not create strong references to any of its members, and implementations are free to limit its size, e.g. by removing old entries from it when new ones are added.

An p904 p905 p901 p931 environment settings object 's responsible event loop is its global object 's relevant agent 's event loop.



8.1.3.3 Realms, settings objects, and global objects p90 §

5

A global object is a JavaScript object that is the [[GlobalObject]] field of a JavaScript realm.

Note

In this specification, all p905 p905 p828 JavaScript realms are created with global objects that are either Window or

WorkerGlobalScope p1032 objects.

There is always a 1-to-1-to-1 mapping between p905 p904 JavaScript realms , global objects , and environment settings objects :

• A JavaScript realm has a [[HostDefined]] field, which contains the Realm's settings object.

• A JavaScript realm has a [[GlobalObject]] field, which contains the Realm's global object.

• Each p905 p905 global object in this specification is created during the creation of a corresponding JavaScript realm, known as

the global object's Realm.

• Each p905 p904 global object in this specification is created alongside a corresponding environment settings object, known as its

relevant settings object p911.

• An p904 p904 environment settings object 's realm execution context 's Realm component is the environment settings object's

Realm.

• An p904 p905 environment settings object 's Realm then has a [[GlobalObject]] field, which contains the environment settings

object's global object.

To create a new JavaScript realm in an agent agent, optionally with instructions to create a global object or a global this binding (or both), the following steps are taken:

1. Perform InitializeHostDefinedRealm() with the provided customizations for creating the global object and the global this

binding.

2. Let realm execution context be the running JavaScript execution context.

Note

This is the JavaScript execution context created in the previous step.

3. Remove realm execution context from the JavaScript execution context stack.

4. Let realm be realm execution context's Realm component.

5. Set realm's agent to agent. This pointer is not yet defined in the JavaScript specification; see tc39/ecma262#1357.

6. If p901 agent 's agent cluster 's cross-origin isolated is false, then:

1. Let p905 global be realm 's global object .

2. Let status be ! global.[[Delete]]("SharedArrayBuffer").

3. Assert: status is true.

Note

This is done for compatibility with web content and there is some hope that this can be removed in the future. Web developers can still get at the constructor through new WebAssembly.Memory({ shared:true, initial:0, maximum:0 }).buffer.constructor.

7. Return realm execution context.

905

When defining algorithm steps throughout this specification, it is often important to indicate what JavaScript realm is to be used—or, equivalently, what p905 p904 global object or environment settings object is to be used. In general, there are at least four possibilities:

Entry

This corresponds to the script that initiated the currently running script action: i.e., the function or script that the user agent called into when it called into author code.

Incumbent

This corresponds to the most-recently-entered author function or script on the stack, or the author function or script that originally scheduled the currently-running callback.

Current

This corresponds to the currently-running function object, including built-in user-agent functions which might not be implemented as

JavaScript. (It is derived from the current JavaScript realm.)

Relevant

Every p911 platform object has a relevant Realm, which is roughly the JavaScript realm in which it was created. When writing

algorithms, the most prominent p911 platform object whose relevant Realm might be important is the this value of the currently-

running function object. In some cases, there can be other important p911 relevant Realms , such as those of any arguments.

Note how the p906 p906 p906 p906 entry , incumbent , and current concepts are usable without qualification, whereas the relevant concept must be applied to a particular platform object.

⚠Warning!

The p906 p906 incumbent and entry concepts should not be used by new specifications, as they are excessively

complicated and unintuitive to work with. We are working to remove almost all existing uses from the platform: see

issue #1430 p906 p906 for incumbent , and issue #1431 for entry.

In general, web platform specifications should use the p906 relevant concept, applied to the object being operated on (usually the this value of the current method). This mismatches the JavaScript specification, where p906 current is generally used as the default (e.g. in determining the JavaScript realm whose Array constructor should be used to construct the result in Array.prototype.map). But this inconsistency is so embedded in the platform that we have to accept it going forward.

Example

Consider the following pages, with p362 a.html being loaded in a browser window, b.html being loaded in an iframe as shown, and

c.html and d.html omitted (they can simply be empty documents):





Entry page





Hello





Incumbent page





906

Each page has its own p814 p905 browsing context , and thus its own JavaScript realm , global object , and environment settings

object p904.

When the p966 print() method is called in response to pressing the button in a.html, then:

• The p908 entry Realm is that of a.html.

• The p909 incumbent Realm is that of b.html.

• The p966 current Realm is that of c.html (since it is the print() method from c.html whose code is running).

• The p911 p966 relevant Realm of the object on which the print() method is being called is that of d.html.



Example

One reason why the p906 p906 relevant concept is generally a better default choice than the current concept is that it is more suitable

for creating an object that is to be persisted and returned multiple times. For example, the navigator.getBattery() method

creates promises in the p911 p967 relevant Realm for the Navigator object on which it is invoked. This has the following impact:

[BATTERY] p1275





Relevant Realm demo: outer page





Relevant Realm demo: inner page





If the algorithm for the getBattery() method had instead used the current Realm, all the results would be reversed. That is, after

the first call to p967 getBattery() in outer.html , the Navigator object in inner.html would be permanently storing a Promise

object created in outer.html's JavaScript realm, and calls like that inside the hello() function would thus return a promise from

the "wrong" realm. Since this is undesirable, the algorithm instead uses the p911 relevant Realm, giving the sensible results

indicated in the comments above.



The rest of this section deals with formally defining the p906 p906 p906 p906 entry , incumbent , current , and relevant concepts.



907

8.1.3.3.1 Entry p90 §

8

The process of p921 p904 calling scripts will push or pop realm execution contexts onto the JavaScript execution context stack, interspersed with other execution contexts.

With this in hand, we define the entry execution context to be the most recently pushed item in the JavaScript execution context

stack p904 p908 that is a realm execution context . The entry Realm is the entry execution context's Realm component.

Then, the p905 p908 entry settings object is the environment settings object of the entry Realm.

Similarly, the p905 p908 entry global object is the global object of the entry Realm.



8.1.3.3.2 Incumbent §p90

8

All JavaScript execution contexts must contain, as part of their code evaluation state, a skip-when-determining-incumbent counter p908 p908 value, which is initially zero. In the process of preparing to run a callback and cleaning up after running a callback, this value will be incremented and decremented.

Every p931 event loop has an associated backup incumbent settings object stack, initially empty. Roughly speaking, it is used to determine the p908 incumbent settings object when no author code is on the stack, but author code is responsible for the current algorithm having been run in some way. The process of p908 p908 preparing to run a callback and cleaning up after running a callback

manipulate this stack. p1282 [WEBIDL]

When Web IDL is used to p926 invoke author code, or when HostEnqueuePromiseJob invokes a promise job, they use the following algorithms to track relevant data for determining the p908 incumbent settings object: To p904 prepare to run a callback with an environment settings object settings:

1. Push p908 settings onto the backup incumbent settings object stack.

2. Let p908 context be the topmost script-having execution context .

3. If p908 context is not null, increment context 's skip-when-determining-incumbent counter.

To p904 clean up after running a callback with an environment settings object settings:

1. Let p908 context be the topmost script-having execution context .

Note

This will be the same as the p908 topmost script-having execution context inside the corresponding invocation of prepare

to run a callback p908 .

2. If p908 context is not null, decrement context 's skip-when-determining-incumbent counter.

3. Assert: the topmost entry of the p908 backup incumbent settings object stack is settings.

4. Remove p908 settings from the backup incumbent settings object stack.

Here, the topmost script-having execution context is the topmost entry of the JavaScript execution context stack that has a non-

null ScriptOrModule component, or null if there is no such entry in the JavaScript execution context stack.

With all this in place, the incumbent settings object is determined as follows:

1. Let p908 context be the topmost script-having execution context .

2. If p908 context is null, or if context 's skip-when-determining-incumbent counter is greater than zero, then:

1. Assert: the p908 backup incumbent settings object stack is not empty.

Note

This assert would fail if you try to obtain the p908 incumbent settings object from inside an algorithm that was

triggered neither by p921 calling scripts nor by Web IDL invoking a callback. For example, it would trigger if you

tried to obtain the p908 incumbent settings object inside an algorithm that ran periodically as part of the event

loop p931 p906 , with no involvement of author code. In such cases the incumbent concept cannot be used.

908

2. Return the topmost entry of the p908 backup incumbent settings object stack.

3. Return p905 context 's Realm component's settings object.

Then, the p905 p908 incumbent Realm is the Realm of the incumbent settings object .

Similarly, the p905 p908 incumbent global object is the global object of the incumbent settings object.



The following series of examples is intended to make it clear how all of the different mechanisms contribute to the definition of the

incumbent p908 concept: Example

Consider the following starter example:





There are two interesting p904 environment settings objects here: that of window, and that of frames[0]. Our concern is: what is the

incumbent settings object p908 p1006 at the time that the algorithm for postMessage() executes?

It should be that of window, to capture the intuitive notion that the author script responsible for causing the algorithm to happen is

executing in p1005 p908 window , not frames[0] . This makes sense: the window post message steps use the incumbent settings object

to determine the p987 p986 source property of the resulting MessageEvent, and in this case window is definitely the source of the

message.

Let us now explain how the steps given above give us our intuitively-desired result of p911 window 's relevant settings object.

When the p1005 p908 window post message steps look up the incumbent settings object, the topmost script-having execution

context p908 p614 will be that corresponding to the script element: it was pushed onto the JavaScript execution context stack as part

of p921 ScriptEvaluation during the run a classic script algorithm. Since there are no Web IDL callback invocations involved, the

context's p908 p908 skip-when-determining-incumbent counter is zero, so it is used to determine the incumbent settings object ; the

result is the p904 environment settings object of window.

(Note how the p904 p911 environment settings object of frames[0] is the relevant settings object of this at the time the

postMessage() p1006 method is called, and thus is involved in determining the target of the message. Whereas the incumbent is

used to determine the source.)



Example

Consider the following more complicated example:





This example is very similar to the previous one, but with an extra indirection through Function.prototype.bind as well as

setTimeout() p960 p906 . But, the answer should be the same: invoking algorithms asynchronously should not change the incumbent

concept.

This time, the result involves more complicated mechanisms:

When p908 bound is converted to a Web IDL callback type, the incumbent settings object is that corresponding to window (in the

same manner as in our starter example above). Web IDL stores this as the resulting callback value's callback context.

When the p932 p960 task posted by setTimeout() executes, the algorithm for that task uses Web IDL to invoke the stored callback

909

value. Web IDL in turn calls the above p908 prepare to run a callback algorithm. This pushes the stored callback context onto the

backup incumbent settings object stack p908. At this time (inside the timer task) there is no author code on the stack, so the

topmost script-having execution context p908 p908 is null, and nothing gets its skip-when-determining-incumbent counter

incremented.

Invoking the callback then calls p1006 bound , which in turn calls the postMessage() method of frames[0]. When the

postMessage() p1006 p908 algorithm looks up the incumbent settings object, there is still no author code on the stack, since the bound

function just directly calls the built-in method. So the p908 topmost script-having execution context will be null: the JavaScript

execution context p1006 stack only contains an execution context corresponding to postMessage(), with no ScriptEvaluation context

or similar below it.

This is where we fall back to the p908 backup incumbent settings object stack. As noted above, it will contain as its topmost entry

the p911 p908 relevant settings object of window . So that is what is used as the incumbent settings object while executing the

postMessage() p1006 algorithm.



Example

Consider this final, even more convoluted example:





click me





Again there are two interesting p904 environment settings objects in play: that of a.html, and that of b.html. When the

location.assign() p872 p869 method triggers the Location-object navigate algorithm, what will be the incumbent settings

object p908? As before, it should intuitively be that of a.html: the click listener was originally scheduled by a.html, so even if

something involving p906 b.html causes the listener to fire, the incumbent responsible is that of a.html.

The callback setup is similar to the previous example: when bound is converted to a Web IDL callback type, the incumbent settings

object p908 is that corresponding to a.html, which is stored as the callback's callback context.

When the p771 click() method is called inside b.html, it dispatches a click event on the button that is inside a.html. This time,

when the p908 prepare to run a callback algorithm executes as part of event dispatch, there is author code on the stack; the topmost

script-having execution context p908 p908 is that of the onLoad function, whose skip-when-determining-incumbent counter gets

incremented. Additionally, p904 p946 a.html 's environment settings object (stored as the EventHandler's callback context) is pushed

onto the p908 backup incumbent settings object stack.

Now, when the p869 p908 Location-object navigate algorithm looks up the incumbent settings object , the topmost script-having

execution context p908 is still that of the onLoad function (due to the fact we are using a bound function as the callback). Its skip-

when-determining-incumbent counter p908 p908 value is one, however, so we fall back to the backup incumbent settings object stack .

This gives us the p904 environment settings object of a.html, as expected.

Note that this means that even though it is the p362 iframe inside a.html that navigates, it is a.html itself that is used as the

source browsing context p876, which determines among other things the request client. This is perhaps the only justifiable use of the

incumbent concept on the web platform; in all other cases the consequences of using it are simply confusing and we hope to one

day switch them to use p906 p906 current or relevant as appropriate.

910

8.1.3.3.3 Current p91 §

1

The JavaScript specification defines the p1278 current Realm Record , sometimes abbreviated to the "current Realm". [JAVASCRIPT]

Then, the p905 current settings object is the environment settings object of the current Realm Record.

Similarly, the p905 current global object is the global object of the current Realm Record.



8.1.3.3.4 Relevant p91 §

1

The relevant Realm for a platform object is the value of its [[Realm]] field.

Then, the p905 p911 relevant settings object for a platform object o is the environment settings object of the relevant Realm for o.

Similarly, the p905 p911 relevant global object for a platform object o is the global object of the relevant Realm for o.



8.1.3.4 Enabling and disabling scripting p91 §

1

Scripting is enabled p904 for an environment settings object settings when all of the following conditions are true:

• The user agent supports scripting.

• The user has not disabled scripting for settings at this time. (User agents may provide users with the option to

disable scripting globally, or in a finer-grained manner, e.g., on a per-origin basis, down to the level of individual

environment settings objects p904 .)

• Either p905 p828 p905 p829 settings 's global object is not a Window object, or settings 's global object 's associated Document's

active sandboxing flag set p848 p846 does not have its sandboxed scripts browsing context flag set.

Scripting is disabled p904 p911 for an environment settings object when scripting is not enabled for it, i.e., when any of the above conditions are false.



Scripting is enabled p814 p911 for a node node if node 's node document 's browsing context is non-null, and scripting is enabled for node p911 's relevant settings object .

Scripting is disabled p911 p814 for a node when scripting is not enabled , i.e., when its node document 's browsing context is null or when

scripting is disabled p911 p911 for its relevant settings object.



8.1.3.5 Secure contexts p91 §

1

An p903 environment environment is a secure context if the following algorithm returns true:

1. If p904 environment is an environment settings object , then:

1. Let p905 global be environment 's global object .

2. If p1032 global is a WorkerGlobalScope, then:

1. If p1033 p911 p911 global 's owner set [0]'s relevant settings object is a secure context, then return true.

Note

We only need to check the 0th item since they will necessarily all be consistent.

2. Return false.

3. If p1050 global is a WorkletGlobalScope, then return true.

Note

Worklets can only be created in secure contexts.

911

2. If the result of p903 Is url potentially trustworthy? given environment 's top-level creation URL is "Potentially Trustworthy",

then return true.

3. Return false.

An p903 p911 environment is a non-secure context if it is not a secure context.



8.1.4 Script processing model p91 §

2

8.1.4.1 Scripts p91 §

2

A script is one of two possible structs. All scripts have: A settings object

An p904 p912 environment settings object , containing various settings that are shared with other scripts in the same context.

A record

Either a p912 p912 Script Record , for classic scripts ; a Source Text Module Record , for module scripts; or null. In the former two cases, it represents a parsed script; null represents a failure parsing.

A parse error

A JavaScript value, which has meaning only if the p912 record is null, indicating that the corresponding script source text could not be parsed.

Note

This value is used for internal tracking of immediate parse errors when p920 creating scripts , and is not to be used directly.

Instead, consult the p912 error to rethrow when determining "what went wrong" for this script.

An error to rethrow

A JavaScript value representing an error that will prevent evaluation from succeeding. It will be re-thrown by any attempts to p921 run the script.

Note

This could be the script's p912 p912 p912 parse error , but in the case of a module script it could instead be the parse error from one of

its dependencies, or an error from p929 resolve a module specifier.



Note

Since this exception value is provided by the JavaScript specification, we know that it is never null, so we use null to signal that no error has occurred.

Fetch options

A p913 p912 script fetch options , containing various options related to fetching this script or module scripts that it imports.

A base URL

A base p929 URL used for resolving module specifiers. This will either be the URL from which the script was obtained, for external

scripts, or the p89 document base URL of the containing document, for inline scripts.

A p912 classic script is a type of script that has the following additional item:

A muted errors boolean

A boolean which, if true, means that error information will not be provided for errors in this script. This is used to mute errors for cross-origin scripts, since that can leak private information.

A p912 module script is another type of script . It has no additional items.

The active script is determined by the following algorithm:

1. Let record be GetActiveScriptOrModule().

2. If record is null, return null.

912

3. Return record.[[HostDefined]].

Note

The p912 p912 active script concept is so far only used by the import() feature, to determine the base URL to use for resolving

relative module specifiers.



8.1.4.2 Fetching scripts p91 §

3

This section introduces a number of algorithms for fetching scripts, taking various necessary inputs and resulting in p912 classic or

module scripts p912.



Script fetch options is a struct with the following items:

cryptographic nonce

The cryptographic nonce metadata used for the initial fetch and for fetching any imported modules

integrity metadata

The integrity metadata used for the initial fetch

parser metadata

The parser metadata used for the initial fetch and for fetching any imported modules

credentials mode

The p912 credentials mode used for the initial fetch (for module scripts ) and for fetching any imported modules (for both module

scripts p912 p912 and classic scripts)

referrer policy

The referrer policy used for the initial fetch and for fetching any imported modules Note

Recall that via the p912 p912 import() feature, classic scripts can import module scripts .

The p913 p913 default classic script fetch options are a script fetch options whose cryptographic nonce is the empty string, integrity

metadata p913 p913 p913 is the empty string, parser metadata is " not-parser-inserted ", credentials mode is "same-origin", and referrer

policy p913 is the empty string.

Given a p913 request request and a script fetch options options, we define:

set up the classic script request

Set p913 request 's cryptographic nonce metadata to options 's cryptographic nonce , its integrity metadata to options's integrity

metadata p913 p913 p913 , its parser metadata to options 's parser metadata , and its referrer policy to options 's referrer policy .

set up the module script request

Set p913 request 's cryptographic nonce metadata to options 's cryptographic nonce , its integrity metadata to options's integrity

metadata p913 p913 p913 , its parser metadata to options 's parser metadata , its credentials mode to options 's credentials mode , and its

referrer policy p913 to options 's referrer policy .

For any given p913 p913 script fetch options options , the descendant script fetch options are a new script fetch options whose items all have the same values, except for the p913 integrity metadata, which is instead the empty string.



The algorithms below can be customized by optionally supplying a custom perform the fetch hook, which takes a request and an is

top-level flag. The algorithm must complete with a response (which may be a network error), either synchronously (when using fetch

a classic worker-imported script p915 p913 p912 ) or asynchronously (otherwise). The is top-level flag will be set for all classic script fetches, and for the initial fetch when p916 p917 fetching an external module script graph , fetching a module worker script graph, or fetching an

import() module script graph p916, but not for the fetches resulting from import statements encountered throughout the graph.



913

Note

By default, not supplying the p913 perform the fetch will cause the below algorithms to simply fetch the given request, with

algorithm-specific customizations to the request and validations of the resulting response.

To layer your own customizations on top of these algorithm-specific ones, supply a p913 perform the fetch hook that modifies the

given request, fetches it, and then performs specific validations of the resulting response (completing with a network error if the

validations fail).

The hook can also be used to perform more subtle customizations, such as keeping a cache of responses and avoiding performing

a fetch at all.



Note

Service Workers p1281 is an example of a specification that runs these algorithms with its own options for the hook. [SW]



Now for the algorithms themselves.

To fetch a classic script given a url, a settings object, some options, a CORS setting, and a character encoding, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new p912 classic script (on success).

1. Let p90 request be the result of creating a potential-CORS request given url, "script", and CORS setting.

2. Set request's client to settings object.

3. p913 Set up the classic script request given request and options.

4. If the caller specified custom steps to p913 p913 perform the fetch , perform them on request , with the is top-level flag set. Return

from this algorithm, and when the custom p913 perform the fetch steps complete with response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for

the response response.

Note

response p90 p90 can be either CORS-same-origin or CORS-cross-origin. This only affects how error reporting happens.

5. Set p90 response to response 's unsafe response.

6. If response's type is "error", or response's status is not an ok status, then asynchronously complete this algorithm with null,

and return.

Note

For historical reasons, this algorithm does not include MIME type checking, unlike the other script-fetching algorithms in this section.

7. If p90 response 's Content Type metadata, if any, specifies a character encoding, and the user agent supports that encoding,

then set character encoding to that encoding (ignoring the passed-in value).

8. Let source text be the result of decoding response's body to Unicode, using character encoding as the fallback encoding.

Note

The decode algorithm overrides character encoding if the file contains a BOM.

9. Let p90 muted errors be true if response was CORS-cross-origin, and false otherwise.

10. Let p920 script be the result of creating a classic script given source text, settings object, response's url, options, and muted

errors.

11. Asynchronously complete this algorithm with script.

To fetch a classic worker script given a url, a fetch client settings object, a destination, and a script settings object, run these steps.

The algorithm will asynchronously complete with either null (on failure) or a new p912 classic script (on success).

1. Let request be a new request whose url is url, client is fetch client settings object, destination is destination, mode is "same-

914

origin", credentials mode is "same-origin", parser metadata is "not parser-inserted", and whose use-URL-credentials

flag is set.

2. If the caller specified custom steps to p913 p913 perform the fetch , perform them on request , with the is top-level flag set. Return

from this algorithm, and when the custom p913 perform the fetch steps complete with response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for

the response response.

3. Set p90 response to response 's unsafe response.

4. If either of the following conditions are met:

◦ response's type is "error"; or

◦ response's status is not an ok status,

then asynchronously complete this algorithm with null, and return.

5. If both of the following conditions are met:

◦ response's url's scheme is an HTTP(S) scheme; and

◦ the result of extracting a MIME type from response's header list is not a JavaScript MIME type,

then asynchronously complete this algorithm with null, and return.

Note

Other fetch schemes are exempted from MIME type checking for historical web-compatibility reasons. We might be able

to tighten this in the future; see issue #3255.

6. Let source text be the result of UTF-8 decoding response's body.

7. Let p920 script be the result of creating a classic script using source text, script settings object, response's url, and the default

classic script fetch options p913 .

8. Asynchronously complete this algorithm with script.

To fetch a classic worker-imported script given a url and a settings object, run these steps. The algorithm will synchronously complete with a p912 classic script on success, or throw an exception on failure.

1. Let request be a new request whose url is url, client is settings object, destination is "script", parser metadata is "not

parser-inserted", synchronous flag is set, and whose use-URL-credentials flag is set.

2. If the caller specified custom steps to p913 p913 perform the fetch , perform them on request , with the is top-level flag set. Let

response be the result.

Otherwise, fetch request, and let response be the result.

Note

Unlike other algorithms in this section, the fetching process is synchronous here. Thus any p913 perform the fetch steps will also finish their work synchronously.

3. Set p90 response to response 's unsafe response.

4. If any of the following conditions are met:

◦ response's type is "error"; or

◦ response's status is not an ok status; or

◦ the result of extracting a MIME type from response's header list is not a JavaScript MIME type,

then throw a "NetworkError" DOMException.

5. Let source text be the result of UTF-8 decoding response's body.

6. Let p90 muted errors be true if response was CORS-cross-origin, and false otherwise.

915

7. Let p920 script be the result of creating a classic script given source text, settings object, response's url, the default classic

script fetch options p913, and muted errors.

8. Return script.

To fetch an external module script graph given a url, a settings object, and some options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success).

1. p919 Fetch a single module script given url, settings object, "script", options, settings object, "client", and with the top-level

module fetch flag p913 set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well. Wait until the algorithm asynchronously completes with result.

2. If result is null, asynchronously complete this algorithm with null, and return.

3. Let visited set be « url ».

4. p917 Fetch the descendants of and link result given settings object, destination, and visited set. When this asynchronously

completes with final result, asynchronously complete this algorithm with final result.

To fetch an import() module script graph given a specifier, a base URL, a settings object, and some options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success).

1. Let p929 url be the result of resolving a module specifier given base URL and specifier.

2. If url is failure, then asynchronously complete this algorithm with null, and return.

3. p919 Fetch a single module script given url, settings object, "script", options, settings object, "client", and with the top-level

module fetch flag p913 set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well. Wait until the algorithm asynchronously completes with result.

4. If result is null, asynchronously complete this algorithm with null, and return.

5. Let visited set be « url ».

6. p917 Fetch the descendants of and link result given settings object, destination, and visited set. When this asynchronously

completes with final result, asynchronously complete this algorithm with final result.

To fetch a modulepreload module script graph given a url, a destination, a settings object, and some options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success), although it will perform optional steps even after completing.

1. p919 Fetch a single module script given url, settings object, destination, options, settings object, "client", and with the top-

level module fetch flag set. Wait until algorithm asynchronously completes with result.

2. Asynchronously complete this algorithm with result, but do not return.

3. If result is not null, optionally perform the following steps:

1. Let visited set be « url ».

2. p917 Fetch the descendants of and link result given settings object, destination, and visited set.

Note

Generally, performing these steps will be beneficial for performance, as it allows pre-loading the modules that will

invariably be requested later, via algorithms such as p916 fetch an external module script graph that fetch the entire graph. However, user agents might wish to skip them in bandwidth-constrained situations, or situations where the relevant fetches are already in flight.

To fetch an inline module script graph given a source text, base URL, settings object, and options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success).

1. Let p921 script be the result of creating a module script using source text, settings object, base URL, and options.

2. If script is null, asynchronously complete this algorithm with null, and return.

3. Let visited set be an empty set.

4. p917 Fetch the descendants of and link script, given settings object, the destination "script", and visited set. When this

916

asynchronously completes with final result, asynchronously complete this algorithm with final result.

To fetch a module worker script graph given a url, a fetch client settings object, a destination, a credentials mode, and a module map settings object p917 , fetch a worklet/module worker script graph given url, fetch client settings object, destination, credentials mode, and module map settings object, asynchronously completing with the asynchronous completion result of that algorithm.

To fetch a worklet script graph given a url, a fetch client settings object, a destination, a credentials mode, a module map settings object p917 , and a module responses map , fetch a worklet/module worker script graph given url, fetch client settings object, destination, credentials mode, and module map settings object, asynchronously completing with the asynchronous completion result of that algorithm. Use the following custom steps to p913 perform the fetch given response:

1. Let requestURL be request's url.

2. If p42 p933 moduleResponsesMap [ requestURL ] is " fetching ", wait in parallel until that entry's value changes, then queue a task

on the p939 networking task source to proceed with running the following steps.

3. If p913 moduleResponsesMap [ requestURL ] exists , then asynchronously complete the perform the fetch steps with

moduleResponsesMap[requestURL].

4. Set moduleResponsesMap[requestURL] to "fetching".

5. Fetch request. To process response for the response response:

1. Set moduleResponsesMap[requestURL] to response.

2. Asynchronously complete the p913 perform the fetch steps with response.



The following algorithms are meant for internal use by this specification only as part of p916 fetching an external module script graph or other similar concepts above, and should not be used directly by other specifications.

This diagram illustrates how these algorithms relate to the ones above, as well as to each other:



To fetch a worklet/module worker script graph given a url, a fetch client settings object, a destination, a credentials mode, and a module map settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module

script p912 (on success).

1. Let p913 p913 p913 options be a script fetch options whose cryptographic nonce is the empty string, integrity metadata is the

empty string, p913 p913 parser metadata is " not-parser-inserted ", credentials mode is credentials mode, and referrer

policy p913 is the empty string.

2. p919 Fetch a single module script given url, fetch client settings object, destination, options, module map settings object,

" p913 client ", and with the top-level module fetch flag set. If the caller of this algorithm specified custom perform the fetch

steps, pass those along as well. Wait until the algorithm asynchronously completes with result.

3. If result is null, asynchronously complete this algorithm with null, and return.

4. Let visited set be « url ».

5. p917 Fetch the descendants of and link result given fetch client settings object, destination, and visited set. When this

asynchronously completes with final result, asynchronously complete this algorithm with final result.

To fetch the descendants of and link a module script module script, given a fetch client settings object, a destination, and a visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).

917

1. p918 Fetch the descendants of module script, given fetch client settings object, destination, and visited set.

2. Return from this algorithm, and run the following steps when p918 fetching the descendants of a module script asynchronously

completes with result.

3. If result is null, then asynchronously complete this algorithm with result.

Note

In this case, there was an error fetching one or more of the descendants. We will not attempt to link.

4. Let p920 parse error be the result of finding the first parse error given result.

5. If parse error is null, then:

1. Let p912 record be result 's record.

2. Perform record.Link().

Note

This step will recursively call Link on all of the module's unlinked dependencies.

If this throws an exception, set p912 result 's error to rethrow to that exception.

6. Otherwise, set p912 result 's error to rethrow to parse error.

7. Asynchronously complete this algorithm with result.

To fetch the descendants of a module script module script, given a fetch client settings object, a destination, and a visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).

1. If p912 module script 's record is null, then asynchronously complete this algorithm with module script and return.

2. Let p912 record be module script 's record.

3. If record is not a Cyclic Module Record, or if record.[[RequestedModules]] is empty, asynchronously complete this algorithm

with module script.

4. Let urls be a new empty list.

5. For each string requested of record.[[RequestedModules]],

1. Let p929 p912 url be the result of resolving a module specifier given module script 's base URL and requested.

2. Assert: p929 p921 url is never failure, because resolving a module specifier must have been previously successful with

these same two arguments.

3. If visited set does not contain url, then:

1. Append url to urls.

2. Append url to visited set.

6. Let p913 p912 options be the descendant script fetch options for module script 's fetch options .

7. Assert: p912 options is not null, as module script is a module script .

8. p919 For each url in urls , perform the internal module script graph fetching procedure given url, fetch client settings object,

destination p912 p912 , options , module script 's settings object , visited set , and module script 's base URL. If the caller of this

algorithm specified custom p913 perform the fetch steps, pass those along while performing the internal module script graph

fetching procedure p919.

These invocations of the p919 internal module script graph fetching procedure should be performed in parallel to each other.

If any of the invocations of the p919 internal module script graph fetching procedure asynchronously complete with null, asynchronously complete this algorithm with null, and return.

Otherwise, wait until all of the p919 internal module script graph fetching procedure invocations have asynchronously completed. Asynchronously complete this algorithm with module script.



918

To perform the internal module script graph fetching procedure given a url, a fetch client settings object, a destination, some options, a module map settings object, a visited set, and a referrer, perform these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success).

1. Assert: visited set contains url.

2. p919 Fetch a single module script given url, fetch client settings object, destination, options, module map settings object,

referrer p913 , and with the top-level module fetch flag unset. If the caller of this algorithm specified custom perform the fetch

steps, pass those along while p919 fetching a single module script .

3. Return from this algorithm, and run the following steps when p919 fetching a single module script asynchronously completes

with result:

4. If result is null, asynchronously complete this algorithm with null, and return.

5. p918 Fetch the descendants of result given fetch client settings object, destination, and visited set.

6. When the appropriate algorithm asynchronously completes with final result, asynchronously complete this algorithm with

final result.

To fetch a single module script, given a url, a fetch client settings object, a destination, some options, a module map settings object, a referrer, and a top-level module fetch flag, run these steps. The algorithm will asynchronously complete with either null (on failure) or a p912 module script (on success).

1. Let p904 moduleMap be module map settings object 's module map .

2. If p42 p933 moduleMap [ url ] is " fetching ", wait in parallel until that entry's value changes, then queue a task on the networking

task source p939 to proceed with running the following steps.

3. If moduleMap[url] exists, asynchronously complete this algorithm with moduleMap[url], and return.

4. Set moduleMap[url] to "fetching".

5. Let request be a new request whose url is url, destination is destination, mode is "cors", referrer is referrer, and client is

fetch client settings object.

6. If destination is "worker" or "sharedworker" and the top-level module fetch flag is set, then set request's mode to "same-

origin".

7. p913 Set up the module script request given request and options.

8. If the caller specified custom steps to p913 p913 perform the fetch , perform them on request , setting the is top-level flag if the

top-level module fetch p913 flag is set. Return from this algorithm, and when the custom perform the fetch steps complete with

response response, run the remaining steps.

Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for

the response response.

Note

response p90 is always CORS-same-origin.

9. If any of the following conditions are met:

◦ response's type is "error"; or

◦ response's status is not an ok status; or

◦ the result of extracting a MIME type from response's header list is not a JavaScript MIME type,

then set moduleMap[url] to null, asynchronously complete this algorithm with null, and return.

10. Let source text be the result of UTF-8 decoding response's body.

11. Let p921 module script be the result of creating a module script given source text, module map settings object, response's url,

and options.

12. Set moduleMap[url] to module script, and asynchronously complete this algorithm with module script.



919

Note

It is intentional that the p928 p912 p912 module map is keyed by the request URL , whereas the base URL for the module script

is set to the response URL. The former is used to deduplicate fetches, while the latter is used for URL resolution.

To find the first parse error given a root moduleScript and an optional discoveredSet:

1. Let p912 p904 moduleMap be moduleScript 's settings object 's module map .

2. If discoveredSet was not given, let it be an empty set.

3. Append moduleScript to discoveredSet.

4. If p912 p912 moduleScript 's record is null, then return moduleScript 's parse error.

5. Let p912 childSpecifiers be the value of moduleScript 's record 's [[RequestedModules]] internal slot.

6. Let p929 childURLs be the list obtained by calling resolve a module specifier once for each item of childSpecifiers, given

moduleScript p912 's base URL and that item. (None of these will ever fail, as otherwise moduleScript would have been marked

as itself having a parse error p921.)

7. Let childModules be the list obtained by getting each value in moduleMap whose key is given by an item of childURLs.

8. For each childModule of childModules:

1. Assert: p912 p912 childModule is a module script (i.e., it is not " fetching " or null); by now all module scripts in the

graph rooted at moduleScript will have successfully been fetched.

2. If discoveredSet already contains childModule, continue.

3. Let p920 childParseError be the result of finding the first parse error given childModule and discoveredSet.

4. If childParseError is not null, return childParseError.

9. Return null.



8.1.4.3 Creating scripts p92 §

0

To p904 create a classic script , given a string source , an environment settings object settings, a URL baseURL, some script fetch

options p913 options, and an optional muted errors boolean:

1. If muted errors was not provided, let it be false.

2. If p51 muted errors is true, then set baseURL to about:blank.

Note

When p90 muted errors is true, baseURL is the script's CORS-cross-origin response's url, which shouldn't be exposed to JavaScript. Therefore, baseURL is sanitized here.

3. If p911 scripting is disabled for settings, then set source to the empty string.

4. Let p912 script be a new classic script that this algorithm will subsequently initialize.

5. Set p912 script 's settings object to settings.

6. Set p912 script 's base URL to baseURL.

7. Set p912 script 's fetch options to options.

8. Set p912 script 's muted errors to muted errors.

9. Set p912 p912 script 's parse error and error to rethrow to null.

10. Let p905 result be ParseScript ( source , settings 's Realm, script).

Note

Passing script as the last parameter here ensures result.[[HostDefined]] will be script.

920

11. If result is a list of errors, then:

1. Set p912 p912 script 's parse error and its error to rethrow to result[0].

2. Return script.

12. Set p912 script 's record to result.

13. Return script.

To p904 create a module script , given a string source , an environment settings object settings, a URL baseURL, and some script fetch

options p913 options:

1. If p911 scripting is disabled for settings, then set source to the empty string.

2. Let p912 script be a new module script that this algorithm will subsequently initialize.

3. Set p912 script 's settings object to settings.

4. Set p912 script 's base URL to baseURL.

5. Set p912 script 's fetch options to options.

6. Set p912 p912 script 's parse error and error to rethrow to null.

7. Let p905 result be ParseModule ( source , settings 's Realm, script).

Note

Passing script as the last parameter here ensures result.[[HostDefined]] will be script.

8. If result is a list of errors, then:

1. Set p912 script 's parse error to result[0].

2. Return script.

9. For each string requested of result.[[RequestedModules]]:

1. Let p929 p912 url be the result of resolving a module specifier given script 's base URL and requested.

2. If url is failure, then:

1. Let error be a new TypeError exception.

2. Set p912 script 's parse error to error.

3. Return script.

Note

This step is essentially validating all of the requested module specifiers. We treat a module with unresolvable module specifiers the same as one that cannot be parsed; in both cases, a syntactic issue makes it impossible to ever contemplate linking the module later.

10. Set p912 script 's record to result.

11. Return script.



8.1.4.4 Calling scripts p92 §

1

To p912 run a classic script given a classic script script and an optional boolean rethrow errors (default false):

1. Let p912 settings be the settings object of script.

2. p922 Check if we can run script with settings. If this returns "do not run" then return NormalCompletion(empty).

3. p923 Prepare to run script given settings.

4. Let evaluationStatus be null.

921

5. If p912 script 's error to rethrow is not null, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: script's error to

rethrow p912 , [[Target]]: empty }.

6. Otherwise, set p912 evaluationStatus to ScriptEvaluation ( script 's record).

If p923 ScriptEvaluation does not complete because the user agent has aborted the running script , leave evaluationStatus as null.

7. If evaluationStatus is an abrupt completion, then:

1. If p912 rethrow errors is true and script 's muted errors is false, then:

1. p923 Clean up after running script with settings.

2. Rethrow evaluationStatus.[[Value]].

2. If p912 rethrow errors is true and script 's muted errors is true, then:

1. p923 Clean up after running script with settings.

2. Throw a "NetworkError" DOMException.

3. Otherwise, rethrow errors is false. Perform the following steps:

1. p924 Report the exception given by evaluationStatus.[[Value]] for script.

2. p923 Clean up after running script with settings.

3. Return evaluationStatus.

8. p923 Clean up after running script with settings.

9. If evaluationStatus is a normal completion, then return evaluationStatus.

10. If we've reached this point, p923 evaluationStatus was left as null because the script was aborted prematurely during

evaluation. Return Completion { [[Type]]: throw, [[Value]]: a new "QuotaExceededError" DOMException, [[Target]]: empty }.

To p912 run a module script given a module script script and an optional boolean preventErrorReporting (default false):

1. Let p912 settings be the settings object of script.

2. p922 Check if we can run script with settings. If this returns "do not run", then return a promise resolved with undefined.

3. p923 Prepare to run script given settings.

4. Let evaluationPromise be null.

5. If p912 p912 script 's error to rethrow is not null, then set evaluationPromise to a promise rejected with script 's error to rethrow .

6. Otherwise:

1. Let p912 record be script 's record.

2. Set evaluationPromise to record.Evaluate().

Note

This step will recursively evaluate all of the module's dependencies.

If p923 Evaluate fails to complete as a result of the user agent aborting the running script, then set

evaluationPromise to a promise rejected with a new "QuotaExceededError" DOMException.

7. If p924 preventErrorReporting is false, then upon rejection of evaluationPromise with reason , report the exception given by

reason for script.

8. p923 Clean up after running script with settings.

9. Return evaluationPromise.

The steps to p904 check if we can run script with an environment settings object settings are as follows. They return either "run" or "do not run".

922

1. If the p905 p828 p115 p818 global object specified by settings is a Window object whose Document object is not fully active, then

return "do not run".

2. If p911 scripting is disabled for settings, then return "do not run".

3. Return "run".

The steps to p904 prepare to run script with an environment settings object settings are as follows:

1. Push p904 settings 's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript

execution context.

2. Add p932 p932 settings to the currently running task 's script evaluation environment settings object set .

The steps to p904 clean up after running script with an environment settings object settings are as follows:

1. Assert: p904 settings 's realm execution context is the running JavaScript execution context.

2. Remove p904 settings 's realm execution context from the JavaScript execution context stack.

3. If the p936 JavaScript execution context stack is now empty, perform a microtask checkpoint. (If this runs scripts, these

algorithms will be invoked reentrantly.) Note

These algorithms are not invoked by one script directly calling another, but they can be invoked reentrantly in an indirect manner,

e.g. if a script dispatches an event which has event listeners registered.

The p912 running script is the script in the [[HostDefined]] field in the ScriptOrModule component of the running JavaScript execution

context.



8.1.4.5 Killing scripts p92 §

3

Although the JavaScript specification does not account for this possibility, it's sometimes necessary to abort a running script. This causes any ScriptEvaluation or Source Text Module Record Evaluate invocations to cease immediately, emptying the JavaScript

execution context stack p1278 without triggering any of the normal mechanisms like finally blocks. [JAVASCRIPT]

User agents may impose resource limitations on scripts, for example CPU quotas, memory limits, total execution time limits, or bandwidth limitations. When a script exceeds a limit, the user agent may either throw a "QuotaExceededError" DOMException, abort

the script p923 without an exception, prompt the user, or throttle script execution.

Example

For example, the following script never terminates. A user agent could, after waiting for a few seconds, prompt the user to either

terminate the script or let it continue.





User agents are encouraged to allow users to disable scripting whenever the user is prompted either by a script (e.g. using the

window.alert() p965 API) or because of a script's actions (e.g. because it has exceeded a time limit).

If scripting is disabled while a script is executing, the script should be terminated immediately.

User agents may allow users to specifically disable scripts just for the purposes of closing a p814 browsing context.

Example

For example, the prompt mentioned in the example above could also offer the user with a mechanism to just close the page

entirely, without running any p1272 unload event handlers.



923

8.1.4.6 Runtime script errors p92 §

4

When the user agent is required to p912 report an error for a particular script script with a particular position line:col, using a particular target target, it must run these steps, after which the error is either handled or not handled:

1. If p924 p924 target is in error reporting mode , then return; the error is not handled.

2. Let target be in error reporting mode.

3. Let message be an implementation-defined string describing the error in a helpful manner.

4. Let errorValue be the value that represents the error: in the case of an uncaught exception, that would be the value

that was thrown; in the case of a JavaScript error that would be an Error object. If there is no corresponding value, then the null value must be used instead.

5. Let urlString be the result of applying the URL serializer to the URL record that corresponds to the resource from which script

was obtained.

Note

The resource containing the script will typically be the file from which the p115 Document was parsed, e.g. for inline

script p614 p943 elements or event handler content attributes ; or the JavaScript file that the script was in, for external scripts. Even for dynamically-generated scripts, user agents are strongly encouraged to attempt to keep track of the

original source of a script. For example, if an external script uses the p958 document.write() API to insert an inline

script p614 element during parsing, the URL of the resource containing the script would ideally be reported as being the

external script, and the line number might ideally be reported as the line with the p958 document.write() call or where the string passed to that call was first constructed. Naturally, implementing this can be somewhat non-trivial.

Note

User agents are similarly encouraged to keep careful track of the original line numbers, even in the face of

document.write() p958 p943 calls mutating the document as it is parsed, or event handler content attributes spanning multiple lines.

6. If p912 script 's muted errors is true, then set message to "Script error.", urlString to the empty string, line and col to 0, and

errorValue to null.

7. Let notHandled be true.

8. If p1271 target implements EventTarget , then set notHandled to the result of firing an event named error at target, using

ErrorEvent p924 p925 , with the cancelable attribute initialized to true, the message attribute initialized to message, the

filename p925 p925 p925 attribute initialized to urlString , the lineno attribute initialized to line , the colno attribute initialized to

col p925 , and the error attribute initialized to errorValue.

9. Let p924 target no longer be in error reporting mode .

10. If p924 p924 notHandled is false, then the error is handled . Otherwise, the error is not handled .

Note

Returning true in an event handler cancels the event per p945 the event handler processing algorithm.

When the user agent is to p924 p912 report an exception E , the user agent must report the error for the relevant script , with the

problematic position (line number and column number) in the resource containing the script, using the p905 global object specified by the script's p912 p924 settings object as the target. If the error is still not handled after this, then the error may be reported to a developer console.



The existence of both p924 p924 report an error and report an exception is confusing, and both algorithms have known problems. You

can track future cleanup in this area in ✔ issue #958 . MDN



The p924 ErrorEvent interface is defined as follows:

IDL [Exposed=(Window,Worker)]

interface ErrorEvent : Event {

constructor(DOMString type, optional ErrorEventInit eventInitDict = {});

924

readonly attribute DOMString message;

readonly attribute USVString filename;

readonly attribute unsigned long lineno;

readonly attribute unsigned long colno;

readonly attribute any error;

};

dictionary ErrorEventInit : EventInit {

DOMString message = "";

USVString filename = "";

unsigned long lineno = 0;

unsigned long colno = 0;

any error = null;

};

The message attribute must return the value it was initialized to. It represents the error message.

The filename attribute must return the value it was initialized to. It represents the URL of the script in which the error originally occurred.

The lineno attribute must return the value it was initialized to. It represents the line number where the error occurred in the script.

The colno attribute must return the value it was initialized to. It represents the column number where the error occurred in the script.

The error attribute must return the value it was initialized to. Where appropriate, it is set to the object representing the error (e.g., the exception object in the case of an uncaught DOM exception).



✔ MDN

8.1.4.7 Unhandled promise rejections p92 §

5

In addition to synchronous p924 runtime script errors, scripts may experience asynchronous promise rejections, tracked via the

unhandledrejection p1272 p1272 p928 and rejectionhandled events. Tracking these rejections is done via the HostPromiseRejectionTracker abstract operation, but reporting them is defined here.

To p904 notify about rejected promises on a given environment settings object settings object:

1. Let p905 list be a copy of settings object 's about-to-be-notified rejected promises list.

2. If list is empty, return.

3. Clear p905 settings object 's about-to-be-notified rejected promises list .

4. Let p905 global be settings object 's global object.

5. p933 p939 Queue a global task on the DOM manipulation task source given global to run the following substep:

1. For each promise p in list:

1. If p's [[PromiseIsHandled]] internal slot is true, continue to the next iteration of the loop.

2. Let p1272 notHandled be the result of firing an event named unhandledrejection at global , using

PromiseRejectionEvent p926 p926 , with the cancelable attribute initialized to true, the promise attribute

initialized to p926 p , and the reason attribute initialized to the value of p's [[PromiseResult]] internal slot.

3. If p925 notHandled is false, then the promise rejection is handled . Otherwise, the promise rejection is not

handled p925.

4. If p's [[PromiseIsHandled]] internal slot is false, add p to settings object's outstanding rejected promises

weak set p905.

This algorithm results in promise rejections being marked as p924 handled or not handled . These concepts parallel handled and not ✔ MDN

handled p924 p925 script errors. If a rejection is still not handled after this, then the rejection may be reported to a developer console.

p926 ✔ MDN

The PromiseRejectionEvent interface is defined as follows:

925

IDL [Exposed=(Window,Worker)]

interface PromiseRejectionEvent : Event {

constructor(DOMString type, PromiseRejectionEventInit eventInitDict);

readonly attribute Promise promise;

readonly attribute any reason;

};

dictionary PromiseRejectionEventInit : EventInit {

required Promise promise;

any reason;

};

The ✔ MDN promise ✔ MDN

attribute must return the value it was initialized to. It represents the promise which this notification is about.

The reason attribute must return the value it was initialized to. It represents the rejection reason for the promise.



8.1.5 JavaScript specification host hooks p92 §

6

The JavaScript specification contains a number of implementation-defined abstract operations, that vary depending on the host environment. This section defines them for user agent hosts.



8.1.5.1 HostEnqueuePromiseJob(job, realm) p92 §

6

JavaScript contains an implementation-defined HostEnqueuePromiseJob(job, realm) abstract operation to schedule Promise-related operations. HTML schedules these operations in the microtask queue. User agents must use the following implementation:

[JAVASCRIPT] p1278

1. If p905 realm is not null, then let job settings be the settings object for realm. Otherwise, let job settings be null.

Note

If realm is not null, it is the Realm of the author code that will run. When job is returned by NewPromiseReactionJob, it is

the realm of the promise's handler function. When job is returned by NewPromiseResolveThenableJob, it is the realm of the then function.

If realm is null, either no author code will run or author code is guaranteed to throw. For the former, the author may not have passed in code to run, such as in promise.then(null, null). For the latter, it is because a revoked Proxy was passed. In both cases, all the steps below that would otherwise use job settings get skipped.

2. Let p908 incumbent settings be the incumbent settings object.

3. Let p912 active script be the active script.

4. Let script execution context be null.

5. If active script is not null, set script execution context to a new JavaScript execution context, with its Function field set to null,

its Realm field set to p912 p905 p912 active script 's settings object 's Realm , and its ScriptOrModule set to active script 's record .

Note

As seen below, this is used in order to propagate the current p912 active script forward to the time when the job is executed.

Example

A case where active script is non-null, and saving it in this way is useful, is the following:

Promise.resolve('import(`./example.mjs`)').then(eval);



926

Without this step (and the steps below that use it), there would be no p912 active script when the import() expression is

evaluated, since p912 eval() is a built-in function that does not originate from any particular script.

With this step in place, the active script is propagated from the above code into the job, allowing import() to use the

original script's p912 base URL appropriately.

Example

active script can be null if the user clicks on the following button:

Click me

In this case, the JavaScript function for the p941 event handler will be created by the get the current value of the event

handler p947 algorithm, which creates a function with null [[ScriptOrModule]] value. Thus, when the promise machinery

calls p926 p912 HostEnqueuePromiseJob , there will be no active script to pass along.

As a consequence, this means that when the p912 import() expression is evaluated, there will still be no active script.

Fortunately that is handled by our implementations of p930 HostResolveImportedModule and

HostImportModuleDynamically p930 p911 p904 , by falling back to using the current settings object 's API base URL.

6. p933 p931 Queue a microtask on the surrounding agent 's event loop to perform the following steps:

1. If p922 job settings is not null, then check if we can run script with job settings. If this returns "do not run" then

return.

2. If p923 job settings is not null, then prepare to run script with job settings.

Note

This affects the p906 entry concept while the job runs.

3. p908 Prepare to run a callback with incumbent settings.

Note

This affects the p906 incumbent concept while the job runs.

4. If script execution context is not null, then push script execution context onto the JavaScript execution context

stack.

Note

As explained above, this affects the p912 active script while the job runs.

5. Let result be job().

Note

job is an abstract closure returned by NewPromiseReactionJob or NewPromiseResolveThenableJob.

6. If script execution context is not null, then pop script execution context from the JavaScript execution context

stack.

7. p908 Clean up after running a callback with incumbent settings.

8. If p923 job settings is not null, then clean up after running script with job settings.

9. If p924 result is an abrupt completion , then report the exception given by result.[[Value]].



8.1.5.2 HostEnsureCanCompileStrings(callerRealm, calleeRealm) p92 §

7

JavaScript contains an implementation-defined HostEnsureCanCompileStrings(callerRealm, calleeRealm) abstract operation. User agents must use the following implementation: p1278 [JAVASCRIPT]



927

1. Perform ? p1275 EnsureCSPDoesNotBlockStringCompilation ( callerRealm , calleeRealm ). [CSP]



8.1.5.3 HostPromiseRejectionTracker(promise, operation) p92 §

8

JavaScript contains an implementation-defined HostPromiseRejectionTracker(promise, operation) abstract operation. User agents must use the following implementation: p1278 [JAVASCRIPT]

1. Let p923 script be the running script.

2. If p912 script 's muted errors is true, terminate these steps.

3. Let p912 settings object be script 's settings object .

4. If operation is "reject",

1. Add p905 promise to settings object 's about-to-be-notified rejected promises list .

5. If operation is "handle",

1. If p905 settings object 's about-to-be-notified rejected promises list contains promise, then remove promise from that

list and return.

2. If p905 settings object 's outstanding rejected promises weak set does not contain promise, then return.

3. Remove p905 promise from settings object 's outstanding rejected promises weak set .

4. Let p905 global be settings object 's global object.

5. p933 p939 Queue a global task on the DOM manipulation task source given global to fire an event named

rejectionhandled p1272 p926 p926 at global , using PromiseRejectionEvent , with the promise attribute initialized to

promise p926 , and the reason attribute initialized to the value of promise's [[PromiseResult]] internal slot.



8.1.5.4 Module-related host hooks p92 §

8

The JavaScript specification defines a syntax for modules, as well as some host-agnostic parts of their processing model. This specification defines the rest of their processing model: how the module system is bootstrapped, via the p614 script element with

type p615 p1278 attribute set to " module ", and how modules are fetched, resolved, and executed. [JAVASCRIPT]

Note

Although the JavaScript specification speaks in terms of "scripts" versus "modules", in general this specification speaks in terms of

classic scripts p912 p912 p614 versus module scripts , since both of them use the script element.



For web developers (non-normative)

modulePromise = import(specifier)

Returns a promise for the module namespace object for the p912 module script identified by specifier. This allows dynamic

importing of module scripts at runtime, instead of statically using the p929 import statement form. The specifier will be resolved

relative to the p912 p912 active script 's base URL .

The returned promise will be rejected if an invalid specifier is given, or if a failure is encountered while p916 fetching or

evaluating p922 the resulting module graph.

This syntax can be used inside both p912 p912 classic and module scripts. It thus provides a bridge into the module-script world, from the classic-script world.

url = import . meta . url

Returns the p912 p912 active module script 's base URL.

This syntax can only be used inside p912 module scripts .

A p912 module map is a map of URL records to values that are either a module script, null (used to represent failed fetches), or a placeholder value " p928 fetching ". Module maps are used to ensure that imported JavaScript modules are only fetched, parsed, and evaluated once per p115 p1016 Document or worker.

928

Example

Since p928 p928 module maps are keyed by URL, the following code will create three separate entries in the module map , since it

results in three different URLs:

import "https://example.com/module.mjs";

import "https://example.com/module.mjs#map-buster";

import "https://example.com/module.mjs?debug=true";

That is, URL p928 queries and fragments can be varied to create distinct entries in the module map; they are not ignored. Thus, three

separate fetches and three separate module evaluations will be performed.

In contrast, the following code would only create a single entry in the p928 module map, since after applying the URL parser to these

inputs, the resulting URL records are equal:

import "https://example.com/module2.mjs";

import "https:example.com/module2.mjs";

import "https://///example.com\\module2.mjs";

import "https://example.com/foo/../module2.mjs";

So in this second example, only one fetch and one module evaluation will occur.

Note that this behavior is the same as how p1042 p1035 shared workers are keyed by their parsed constructor url.

To resolve a module specifier given a URL base URL and a string specifier, perform the following steps. It will return either a URL

record or failure.

1. Apply the URL parser to specifier. If the result is not failure, return the result.

2. If specifier does not start with the character U+002F SOLIDUS (/), the two-character sequence U+002E FULL STOP, U+002F

SOLIDUS (./), or the three-character sequence U+002E FULL STOP, U+002E FULL STOP, U+002F SOLIDUS (../), return failure.

Note

This restriction is in place so that in the future we can allow custom module loaders to give special meaning to "bare" import specifiers, like import "jquery" or import "web/crypto". For now any such imports will fail, instead of being treated as relative URLs.

3. Return the result of applying the URL parser to specifier with base URL as the base URL.

Example

The following are valid module specifiers according to the above algorithm:

• https://example.com/apples.mjs

• http:example.com\pears.js (becomes http://example.com/pears.js as step 1 parses with no base URL) • //example.com/bananas

• ./strawberries.mjs.cgi

• ../lychees

• /limes.jsx

• data:text/javascript,export default 'grapes';

• blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f

The following are valid module specifiers according to the above algorithm, but will invariably cause failures when they are

fetched p919:

• javascript:export default 'artichokes';

• data:text/plain,export default 'kale';

• about:legumes

• wss://example.com/celery

The following are not valid module specifiers according to the above algorithm:

• https://eggplant:b/c

• pumpkins.js

• .tomato

• ..zucchini.mjs

• .\yam.es

929

✔ MDN

8.1.5.4.1 HostGetImportMetaProperties(moduleRecord) p93 §

0

JavaScript contains an implementation-defined HostGetImportMetaProperties abstract operation. User agents must use the following implementation: p1278 [JAVASCRIPT]

1. Let module script be moduleRecord.[[HostDefined]].

2. Let p912 urlString be module script 's base URL, serialized.

3. Return « Record { [[Key]]: "url", [[Value]]: urlString } ».



8.1.5.4.2 HostImportModuleDynamically(referencingScriptOrModule, specifier, promiseCapability) p93 §

0

JavaScript contains an implementation-defined HostImportModuleDynamically abstract operation. User agents must use the following implementation: p1278 [JAVASCRIPT]

1. Let p911 settings object be the current settings object.

2. If p905 p1050 settings object 's global object implements WorkletGlobalScope, then:

1. Let completion be Completion { [[Type]]: throw, [[Value]]: a new TypeError, [[Target]]: empty }.

2. Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion).

3. Return.

3. Let p904 base URL be settings object 's API base URL .

4. Let p913 fetch options be the default classic script fetch options .

5. If referencingScriptOrModule is not null, then:

1. Let referencing script be referencingScriptOrModule.[[HostDefined]].

2. Set p912 settings object to referencing script 's settings object .

3. Set p912 base URL to referencing script 's base URL .

4. Set p913 p912 fetch options to the descendant script fetch options for referencing script 's fetch options.

Note

As explained above for p930 HostResolveImportedModule, in the common case, referencingScriptOrModule is non-null.

6. p916 Fetch an import() module script graph given specifier, base URL, settings object, and fetch options. Wait until the

algorithm asynchronously completes with result.

7. Let promise be null.

8. If result is null, then set promise to a promise rejected with a new TypeError.

9. Otherwise, set p922 promise to the result of running a module script given result and true.

10. Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, promise).

11. Return undefined.



8.1.5.4.3 HostResolveImportedModule(referencingScriptOrModule, specifier) p93 §

0

JavaScript contains an implementation-defined HostResolveImportedModule abstract operation. User agents must use the following implementation: p1278 [JAVASCRIPT]

1. Let p911 settings object be the current settings object.

2. Let p904 base URL be settings object 's API base URL .

3. If referencingScriptOrModule is not null, then:

930

1. Let referencing script be referencingScriptOrModule.[[HostDefined]].

2. Set p912 settings object to referencing script 's settings object .

3. Set p912 base URL to referencing script 's base URL .

Example

referencingScriptOrModule is not usually null, but will be so for event handlers per the get the current value of the event

handler p947 algorithm. For example, given:

Click me

If a click event occurs, then at the time the import() expression runs, GetActiveScriptOrModule will return null, which

will be passed to this abstract operation when HostResolveImportedModule is called by FinishDynamicImport.

4. Let p904 moduleMap be settings object 's module map.

5. Let p929 url be the result of resolving a module specifier given base URL and specifier.

6. Assert: p929 url is never failure, because resolving a module specifier must have been previously successful with these same

two arguments (either p921 p916 while creating the corresponding module script , or in fetch an import() module script graph).

7. Let resolved module script be moduleMap[url]. (This entry must exist for us to have gotten to this point.)

8. Assert: p912 resolved module script is a module script (i.e., is not null or "fetching").

9. Assert: p912 resolved module script 's record is not null.

10. Return p912 resolved module script 's record.



8.1.6 Event loops p93 §

1

8.1.6.1 Definitions p93 §

1

To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.

The p931 p900 p931 event loop of a similar-origin window agent is known as a window event loop . The event loop of a dedicated worker

agent p900 p900 p900 p931 , shared worker agent , or service worker agent is known as a worker event loop . And the event loop of a worklet

agent p900 is known as a worklet event loop.

Note

Event loops p931 p931 do not necessarily correspond to implementation threads. For example, multiple window event loops could be

cooperatively scheduled in a single thread.

However, for the various worker agents that are allocated with [[CanBlock]] set to true, the JavaScript specification does place

requirements on them regarding forward progress, which effectively amount to requiring dedicated per-agent threads in those

cases.



An p931 p931 p932 event loop has one or more task queues . A task queue is a set of tasks .

Note

Task queues p931 p934 p932 p932 are sets , not queues , because step one of the event loop processing model grabs the first runnable task

from the chosen queue, instead of dequeuing the first task.



Note

The p932 p931 microtask queue is not a task queue.

Tasks encapsulate algorithms that are responsible for such work as:

931

Events

Dispatching an Event object at a particular EventTarget object is often done by a dedicated task.

Note

Not all events are dispatched using the p931 task queue; many are dispatched during other tasks.

Parsing

The p1076 HTML parser tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.

Callbacks

Calling a callback is often done by a dedicated task.

Using a resource

When an algorithm fetches a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.

Reacting to DOM manipulation

Some elements have tasks that trigger in response to DOM manipulation, e.g. when that element is p44 inserted into the document.

Formally, a task is a struct which has:

Steps

A series of steps specifying the work to be done by the task.

A source

One of the p932 task sources , used to group and serialize related tasks.

A document

A p115 p931 Document associated with the task, or null for tasks that are not in a window event loop.

A script evaluation environment settings object set

A p904 set of environment settings objects used for tracking script evaluation during the task.

A p932 p932 p818 task is runnable if its document is either null or fully active.

Per its p932 p932 p931 p932 source field, each task is defined as coming from a specific task source . For each event loop , every task source

must be associated with a specific p931 task queue .

Note

Essentially, p932 task sources are used within standards to separate logically-different types of tasks, which a user agent might wish

to distinguish between. p931 p931 Task queues are used by user agents to coalesce task sources within a given event loop.



Example

For example, a user agent could have one p931 p939 task queue for mouse and key events (to which the user interaction task source is

associated), and another to which all other p932 task sources are associated. Then, using the freedom granted in the initial step of

the p934 event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the

time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still

enforces that the user agent would never process events from any one p932 task source out of order.



Each p931 p932 event loop has a currently running task , which is either a task or null. Initially, this is null. It is used to handle reentrancy.

Each p931 p932 event loop has a microtask queue , which is a queue of microtasks, initially empty. A microtask is a colloquial way of referring to a p932 p933 task that was created via the queue a microtask algorithm.

Each p931 event loop has a performing a microtask checkpoint boolean, which is initially false. It is used to prevent reentrant invocation of the p936 perform a microtask checkpoint algorithm.



932

8.1.6.2 Queuing tasks p93 §

3

To p932 queue a task on a task source source, which performs a series of steps steps, optionally given an event loop event loop and a document document:

1. If p933 event loop was not given, set event loop to the implied event loop .

2. If p933 document was not given, set document to the implied document.

3. Let p932 task be a new task .

4. Set p932 task 's steps to steps.

5. Set p932 task 's source to source.

6. Set p932 task 's document to the document.

7. Set p932 task 's script evaluation environment settings object set to an empty set.

8. Let p931 queue be the task queue to which source is associated on event loop.

9. Append task to queue.

To p932 p905 queue a global task on a task source source , with a global object global and a series of steps steps:

1. Let p901 p931 event loop be global 's relevant agent 's event loop .

2. Let p829 p828 document be global 's associated Document , if global is a Window object; otherwise null.

3. p933 Queue a task given source, event loop, document, and steps.

To p932 queue an element task on a task source source, with an element element and a series of steps steps:

1. Let p911 global be element 's relevant global object .

2. p933 Queue a global task given source, global, and steps.

To queue a microtask which performs a series of steps steps, optionally given an event loop event loop and a document document:

1. If p933 event loop was not given, set event loop to the implied event loop .

2. If p933 document was not given, set document to the implied document.

3. Let p932 microtask be a new task .

4. Set p932 microtask 's steps to steps.

5. Set p932 microtask 's source to the microtask task source.

6. Set p932 microtask 's document to document.

7. Set p932 task 's script evaluation environment settings object set to an empty set.

8. p932 Enqueue task on event loop 's microtask queue.

Note

It is possible for a p932 p931 p937 microtask to be moved to a regular task queue , if, during its initial execution, it spins the event loop.

This is the only case in which the p932 p932 p932 source , document , and script evaluation environment settings object set of the

microtask are consulted; they are ignored by the p936 perform a microtask checkpoint algorithm.

The implied event loop when queuing a task is the one that can deduced from the context of the calling algorithm. This is generally unambiguous, as most specification algorithms only ever involve a single p931 agent (and thus a single event loop). The exception is algorithms involving or specifying cross-agent communication (e.g., between a window and a worker); for those cases, the implied

event loop p933 p931 p933 concept must not be relied upon and specifications must explicitly provide an event loop when queuing a task or

microtask p933.

The p931 implied document when queuing a task on an event loop event loop is determined as follows:



933

1. If p931 event loop is not a window event loop , then return null.

2. If the task is being queued in the context of an element, then return the element's node document.

3. If the task is being queued in the context of a p814 p814 browsing context , then return the browsing context's active document.

4. If the task is being queued by or for a p912 p912 p904 script , then return the script's settings object 's responsible document .

5. Assert: this step is never reached, because one of the previous conditions must be true. Really?



Both p933 p933 implied event loop and implied document are vaguely-defined and have a lot of action-at-a-distance. Perhaps we can come up with a more explicit architecture, while still avoiding all callers needing to explicitly specify the event loop and document.



8.1.6.3 Processing model p93 §

4

An p931 event loop must continually run through the following steps for as long as it exists:

1. Let p931 p931 taskQueue be one of the event loop 's task queues , chosen in an implementation-defined manner, with the

constraint that the chosen task queue must contain at least one p932 p932 runnable task . If there is no such task queue, then jump to the microtasks step below.

Note

Remember that the p932 p931 microtask queue is not a task queue, so it will not be chosen in this step. However, a task

queue p931 p933 p932 to which the microtask task source is associated might be chosen in this step. In that case, the task

chosen in the next step was originally a p932 p937 microtask , but it got moved as part of spinning the event loop .

2. Let p932 p932 oldestTask be the first runnable task in taskQueue, and remove it from taskQueue.

3. Set the p931 p932 event loop 's currently running task to oldestTask.

4. Let taskStartTime be the current high resolution time.

5. Perform p932 oldestTask 's steps.

6. Set the p931 p932 event loop 's currently running task back to null.

7. p936 Microtasks : Perform a microtask checkpoint.

8. Let hasARenderingOpportunity be false.

9. Let p1278 now be the current high resolution time . [HRT]

10. Report the p932 task 's duration by performing the following steps:

1. Let top-level browsing contexts be an empty set.

2. For each p904 environment settings object settings of oldestTask's script evaluation environment settings object

set p932 p817 , append setting 's top-level browsing context to top-level browsing contexts.

3. Report long tasks, passing in taskStartTime, now (the end time of the task), top-level browsing contexts, and

oldestTask.

11. p931 Update the rendering : if this is a window event loop, then:

1. Let p115 p901 p931 docs be all Document objects whose relevant agent 's event loop is this event loop, sorted arbitrarily

except that the following conditions must be met:

▪ Any p115 p814 p817 Document B whose browsing context 's container document is A must be listed after A in

the list.

▪ If there are two documents p814 p817 A and B whose browsing contexts are both child browsing contexts

whose p817 p115 container documents are another Document C, then the order of A and B in the list must

match the p817 shadow-including tree order of their respective browsing context containers in C's node

tree.

In the steps below that iterate over p115 docs , each Document must be processed in the order it is found in the list.

934

2. p115 p814 Rendering opportunities : Remove from docs all Document objects whose browsing context do not have a

rendering opportunity p935.

A p814 browsing context has a rendering opportunity if the user agent is currently able to present the contents of

the p814 browsing context to the user, accounting for hardware refresh rate constraints and user agent throttling for performance reasons, but considering content presentable even if it's outside the viewport.

Browsing context p814 p935 rendering opportunities are determined based on hardware constraints such as display refresh rates and other factors such as page performance or whether the page is in the background. Rendering opportunities typically occur at regular intervals.

Note

This specification does not mandate any particular model for selecting rendering opportunities. But for example, if the browser is attempting to achieve a 60Hz refresh rate, then rendering opportunities occur at a

maximum of every 60th of a second (about 16.7ms). If the browser finds that a p814 browsing context is not able to sustain this rate, it might drop to a more sustainable 30 rendering opportunities per second for that

browsing context p814 p814 , rather than occasionally dropping frames. Similarly, if a browsing context is not visible, the user agent might decide to drop that page to a much slower 4 rendering opportunities per second, or even less.

3. If docs is not empty, then set hasARenderingOpportunity to true.

4. p115 Unnecessary rendering : Remove from docs all Document objects which meet both of the following conditions:

▪ The user agent believes that updating the rendering of the p115 p814 Document 's browsing context would

have no visible effect, and

▪ The p115 p984 Document 's map of animation frame callbacks is empty.

5. Remove from p115 docs all Document objects for which the user agent believes that it's preferrable to skip updating

the rendering for other reasons.

Note

The step labeled Rendering opportunities prevents the user agent from updating the rendering when it is

unable to present new content to the user (there's no p935 rendering opportunity).

The step labeled Unnecessary rendering prevents the user agent from updating the rendering when there's no new content to draw.

This step enables the user agent to prevent the steps below from running for other reasons, for example, to

ensure certain p932 p936 tasks are executed immediately after each other, with only microtask checkpoints

interleaved (and without, e.g., p984 animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.

6. For each p818 p115 p786 p115 fully active Document in docs , flush autofocus candidates for that Document if its browsing

context p814 p817 is a top-level browsing context.

7. For each p818 p115 p115 fully active Document in docs , run the resize steps for that Document, passing in now as the

timestamp. p1276 [CSSOMVIEW]

8. For each p818 p115 p115 fully active Document in docs , run the scroll steps for that Document, passing in now as the

timestamp. p1276 [CSSOMVIEW]

9. For each p818 p115 p115 fully active Document in docs , evaluate media queries and report changes for that Document,

passing in p1276 now as the timestamp. [CSSOMVIEW]

10. For each p818 p115 p115 fully active Document in docs , update animations and send events for that Document, passing in

now p1282 as the timestamp. [WEBANIMATIONS]

11. For each p818 p115 p115 fully active Document in docs , run the fullscreen steps for that Document, passing in now as the

timestamp. p1277 [FULLSCREEN]

12. For each p818 p115 p984 p115 fully active Document in docs , run the animation frame callbacks for that Document, passing

in now as the timestamp.

13. For each p818 p115 p115 fully active Document in docs , run the update intersection observations steps for that Document,

passing in p1278 now as the timestamp. [INTERSECTIONOBSERVER]

935

14. Invoke the p115 mark paint timing algorithm for each Document object in docs.

15. For each p818 p115 p115 fully active Document in docs , update the rendering or user interface of that Document and its

browsing context p814 to reflect the current state.

12. If all of the following are true

◦ this is a p931 window event loop

◦ there is no p932 p931 p931 p932 p818 task in this event loop 's task queues whose document is fully active

◦ this p931 p932 event loop 's microtask queue is empty

◦ hasARenderingOpportunity is false

then for each p828 p901 p931 Window object whose whose relevant agent 's event loop is this event loop, run the start an idle period

algorithm p828 p1280 , passing the Window . [REQUESTIDLECALLBACK]

13. If this is a p931 worker event loop , then:

1. If this p931 p905 p984 p1034 event loop 's agent 's single realm 's global object is a supported DedicatedWorkerGlobalScope

and the user agent believes that it would benefit from having its rendering updated at this time, then:

1. Let p1278 now be the current high resolution time . [HRT]

2. p984 p1034 Run the animation frame callbacks for that DedicatedWorkerGlobalScope, passing in now as the

timestamp.

3. Update the rendering of that dedicated worker to reflect the current state.

Note

Similar to the notes for p934 p931 updating the rendering in a window event loop, a user agent can determine the rate of rendering in the dedicated worker.

2. If there are no p932 p931 p931 p1032 p1035 tasks in the event loop 's task queues and the WorkerGlobalScope object's closing

flag is true, then destroy the p931 p1036 event loop , aborting these steps, resuming the run a worker steps described in

the p1016 Web workers section below.



When a user agent is to perform a microtask checkpoint:

1. If the p931 p932 event loop 's performing a microtask checkpoint is true, then return.

2. Set the p931 p932 event loop 's performing a microtask checkpoint to true.

3. While the p931 p932 event loop 's microtask queue is not empty:

1. Let p931 p932 oldestMicrotask be the result of dequeuing from the event loop 's microtask queue.

2. Set the p931 p932 event loop 's currently running task to oldestMicrotask.

3. Run oldestMicrotask.

Note

This might involve invoking scripted callbacks, which eventually calls the p923 clean up after running script

steps, which call this p936 perform a microtask checkpoint algorithm again, which is why we use the performing

a microtask checkpoint p932 flag to avoid reentrancy.

4. Set the p931 p932 event loop 's currently running task back to null.

4. For each p904 p905 p931 environment settings object whose responsible event loop is this event loop, notify about rejected

promises p925 p904 on that environment settings object.

5. Cleanup Indexed Database transactions.

6. Set the p931 p932 event loop 's performing a microtask checkpoint to false.



When an algorithm running p42 p933 in parallel is to await a stable state , the user agent must queue a microtask that runs the following steps, and must then stop executing (execution of the algorithm resumes when the microtask is run, as described in the following steps):

936

1. Run the algorithm's synchronous section.

2. Resumes execution of the algorithm p42 in parallel, if appropriate, as described in the algorithm's steps.

Note

Steps in p937 synchronous sections are marked with ⌛.



Algorithm steps that say to spin the event loop until a condition goal is met are equivalent to substituting in the following algorithm steps:

1. Let p931 p932 task be the event loop 's currently running task .

Note

task p932 could be a microtask.

2. Let p932 task source be task 's source.

3. Let old stack be a copy of the JavaScript execution context stack.

4. Empty the JavaScript execution context stack.

5. p936 Perform a microtask checkpoint.

Note

If p932 p932 task is a microtask this step will be a no-op due to performing a microtask checkpoint being true.

6. p42 In parallel:

1. Wait until the condition goal is met.

2. p933 Queue a task on task source to:

1. Replace the JavaScript execution context stack with old stack.

2. Perform any steps that appear after this p937 spin the event loop instance in the original algorithm.

Note

This resumes task.

7. Stop task, allowing whatever algorithm that invoked it to resume.

Note

This causes the p931 p936 event loop 's main set of steps or the perform a microtask checkpoint algorithm to continue.



Note

Unlike other algorithms in this and other specifications, which behave similar to programming-language function calls, spin the

event loop p937 is more like a macro, which saves typing and indentation at the usage site by expanding into a series of steps and

operations.



Example

An algorithm whose steps are:

1. Do something.

2. p937 Spin the event loop until awesomeness happens.

3. Do something else.

is a shorthand which, after "macro expansion", becomes

1. Do something.



937

2. Let old stack be a copy of the JavaScript execution context stack.

3. Empty the JavaScript execution context stack.

4. p936 Perform a microtask checkpoint.

5. p42 In parallel:

1. Wait until awesomeness happens.

2. p933 Queue a task on the task source in which "do something" was done to:

1. Replace the JavaScript execution context stack with old stack.

2. Do something else.



Example

Here is a more full example of the substitution, where the event loop is spun from inside a task that is queued from work in

parallel. The version using p937 spin the event loop :

1. p42 In parallel:

1. Do parallel thing 1.

2. p933 p939 Queue a task on the DOM manipulation task source to:

1. Do task thing 1.

2. p937 Spin the event loop until awesomeness happens.

3. Do task thing 2.

3. Do parallel thing 2.

The fully expanded version:

1. p42 In parallel:

1. Do parallel thing 1.

2. Let old stack be null.

3. p933 p939 Queue a task on the DOM manipulation task source to:

1. Do task thing 1.

2. Set old stack to a copy of the JavaScript execution context stack.

3. Empty the JavaScript execution context stack.

4. p936 Perform a microtask checkpoint.

4. Wait until awesomeness happens.

5. p933 p939 Queue a task on the DOM manipulation task source to:

1. Replace the JavaScript execution context stack with old stack.

2. Do task thing 2.

6. Do parallel thing 2.



Some of the algorithms in this specification, for historical reasons, require the user agent to p932 pause while running a task until a condition goal is met. This means running the following steps:

1. If necessary, update the rendering or user interface of any p115 p814 Document or browsing context to reflect the current state.

938

2. Wait until the condition p932 p931 goal is met. While a user agent has a paused task , the corresponding event loop must not run

further p932 p932 tasks , and any script in the currently running task must block. User agents should remain responsive to user

input while paused, however, albeit in a reduced capacity since the p931 event loop will not be doing anything.

⚠Warning!

Pausing p938 p931 is highly detrimental to the user experience, especially in scenarios where a single event loop is

shared among multiple documents. User agents are encouraged to experiment with alternatives to p938 pausing , such

as p937 spinning the event loop or even simply proceeding without any kind of suspended execution at all, insofar as

it is possible to do so while preserving compatibility with existing content. This specification will happily change if a

less-drastic alternative is discovered to be web-compatible.

In the interim, implementers should be aware that the variety of alternatives that user agents might experiment

with can change subtle aspects of p931 p932 p932 event loop behavior, including task and microtask timing.

Implementations should continue experimenting even if doing so causes them to violate the exact semantics

implied by the p938 pause operation.



8.1.6.4 Generic task sources p93 §

9

The following p932 task sources are used by a number of mostly unrelated features in this and other specifications.

The DOM manipulation task source

This p932 task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when

an element is p44 inserted into the document.

The user interaction task source

This p932 task source is used for features that react to user interaction, for example keyboard or mouse input.

Events sent in response to user input (e.g. p932 p933 click events) must be fired using tasks queued with the user interaction task

source p939 p1282 . [UIEVENTS]

The networking task source

This p932 task source is used for features that trigger in response to network activity.

The history traversal task source

This p932 p862 task source is used to queue calls to history.back() and similar APIs.



8.1.6.5 Dealing with the event loop from other specifications p93 §

9

Writing specifications that correctly interact with the p931 event loop can be tricky. This is compounded by how this specification uses concurrency-model-independent terminology, so we say things like " p931 p42 event loop " and " in parallel" instead of using more familiar model-specific terms like "main thread" or "on a background thread".

By default, specification text generally runs on the p931 p934 event loop . This falls out from the formal event loop processing model , in

that you can eventually trace most algorithms back to a p932 p933 task queued there.

Example

The algorithm steps for any JavaScript method will be invoked by author code calling that method. And author code can only be

run via queued tasks, usually originating somewhere in the p620 script processing model .

From this starting point, the overriding guideline is that any work a specification needs to perform that would otherwise block the event

loop p931 p42 must instead be performed in parallel with it. This includes (but is not limited to):

• performing heavy computation;

• displaying a user-facing prompt;

• performing operations which could require involving outside systems (i.e. "going out of process").



939

The next complication is that, in algorithm sections that are p42 in parallel, you must not create or manipulate objects associated to a specific p905 p904 JavaScript realm , global , or environment settings object. (Stated in more familiar terms, you must not directly access main-thread artifacts from a background thread.) Doing so would create data races observable to JavaScript code, since after all, your algorithm steps are running p42 in parallel to the JavaScript code.

You can, however, manipulate specification-level data structures and values from Infra, as those are realm-agnostic. They are never directly exposed to JavaScript without a specific conversion taking place (often p1278 p1282 via Web IDL ). [INFRA] [WEBIDL]

To affect the world of observable JavaScript objects, then, you must p933 queue a task to perform any such manipulations. This ensures your steps are properly interleaved with respect to other things happening on the p931 event loop. Furthermore, you must choose a task

source p932 p933 p932 when queuing a task ; this governs the relative order of your steps versus others. If you are unsure which task source

to use, pick one of the p939 generic task sources that sounds most applicable.

Most invocations of p933 p933 queue a task use the implied event loop, i.e., the one that is obvious from context. That is because it is very rare for algorithms to be invoked in contexts involving multiple event loops. (Unlike contexts involving multiple global objects, which happen all the time!) So unless you are writing a specification which, e.g., deals with manipulating p1016 workers, you can omit this

argument when p933 queuing a task.

Putting this all together, we can provide a template for a typical algorithm that needs to do work asynchronously:

1. Do any synchronous setup work, while still on the p931 event loop . This may include converting realm-specific JavaScript

values into realm-agnostic specification-level values.

2. Perform a set of potentially-expensive steps p42 in parallel, operating entirely on realm-agnostic values, and producing a

realm-agnostic result.

3. p933 p932 Queue a task , on a specified task source , to convert the realm-agnostic result back into observable effects on the

observable world of JavaScript objects on the p931 event loop .

Example

The following is an algorithm that "encrypts" a passed-in list of scalar value strings input, after parsing them as URLs:

1. Let urls be an empty list.

2. For each string of input:

1. Let p89 p911 parsed be the result of parsing string relative to the current settings object.

2. If parsed is failure, return a promise rejected with a "SyntaxError" DOMException.

3. Let serialized be the result of applying the URL serializer to parsed.

4. Append serialized to urls.

3. Let realm be the current Realm Record.

4. Let p be a new promise.

5. Run the following steps p42 in parallel:

1. Let encryptedURLs be an empty list.

2. For each url of urls:

1. Wait 100 milliseconds, so that people think we're doing heavy-duty encryption.

2. Let encrypted be a new string derived from url, whose nth code unit is equal to url's nth code unit

plus 13.

3. Append encrypted to encryptedURLs.

3. p933 p939 Queue a task , on the networking task source , to perform the following steps:

1. Let array be the result of converting encryptedURLs to a JavaScript array, in realm.

2. Resolve p with array.

6. Return p.

940

Here are several things to notice about this algorithm:

• It does its URL parsing up front, on the p931 p42 event loop , before going to the in parallel steps. This is necessary, since

parsing depends on the p911 p42 current settings object , which would no longer be current after going in parallel.

• Alternately, it could have saved a reference to the p911 p904 current settings object 's API base URL and used it during the in

parallel p42 steps; that would have been equivalent. However, we recommend instead doing as much work as possible up front, as this example does. Attempting to save the correct values can be error prone; for example, if we'd saved just the

current settings object p911 p904 , instead of its API base URL, there would have been a potential race.

• It implicitly passes a p42 list of strings from the initial steps to the in parallel steps. This is OK, as both lists and strings are

realm-agnostic.

• It performs "expensive computation" (waiting for 100 milliseconds per input URL) during the p42 in parallel steps, thus not

blocking the main p931 event loop .

• Promises, as observable JavaScript objects, are never created and manipulated during the p42 in parallel steps. p is

created before entering those steps, and then is manipulated during a p932 p933 task that is queued specifically for that purpose.

• The creation of a JavaScript array object also happens during the queued task, and is careful to specify which realm it

creates the array in since that is no longer obvious from context.

(On these last two points, see also w3ctag/promises-guide issue #52, heycam/webidl issue #135, and heycam/webidl issue #371,

where we are still mulling over the subtleties of the above promise-resolution pattern.)

Another thing to note is that, in the event this algorithm was called from a Web IDL-specified operation taking a

sequence<USVString>, there was an automatic conversion from realm-specific JavaScript objects provided by the author as input,

into the realm-agnostic sequence<USVString> Web IDL type, which we then treat as a list of scalar value strings. So depending on

how your specification is structured, there may be other implicit steps happening on the main p931 event loop that play a part in this

whole process of getting you ready to go p42 in parallel.



8.1.7 Events p94 §

1 MDN

8.1.7.1 Event handlers p94 §

1

Many objects can have event handlers specified. These act as non-capture event listeners for the object on which they are specified.

[DOM] p1277

An p941 event handler is a struct with two items:

• a p946 p946 value , which is either null, a callback object, or an internal raw uncompiled handler . The EventHandler callback

function type describes how this is exposed to scripts. Initially, an p941 p941 event handler 's value must be set to null.

• a p945 listener , which is either null or an event listener responsible for running the event handler processing algorithm.

Initially, an p941 p941 event handler 's listener must be set to null.

Event handlers are exposed in two ways.

The first way, common to all event handlers, is as an p942 event handler IDL attribute.

The second way is as an p943 p44 event handler content attribute . Event handlers on HTML elements and some of the event handlers on

Window p828 objects are exposed in this way.

For both of these two ways, the p941 event handler is exposed through a name, which is a string that always starts with "on" and is followed by the name of the event for which the handler is intended.



Most of the time, the object that exposes an p941 event handler is the same as the object on which the corresponding event listener is added. However, the p179 p1230 p941 p828 body and frameset elements expose several event handlers that act upon the element's Window

object, if one exists. In either case, we call the object an p941 p941 event handler acts upon the target of that event handler .

941

To p941 determine the target of an event handler , given an EventTarget object eventTarget on which the event handler is exposed, and an p941 event handler name name, the following steps are taken:

1. If p179 p1230 eventTarget is not a body element or a frameset element, then return eventTarget.

2. If p952 name is not the name of an attribute member of the WindowEventHandlers interface mixin and the Window-reflecting

body element event handler set p950 does not contain name, then return eventTarget.

3. If p814 eventTarget 's node document is not an active document, then return null.

Note

This could happen if this object is a p179 p828 body element without a corresponding Window object, for example.

Note

This check does not necessarily prevent p179 p1230 p119 body and frameset elements that are not the body element of their

node document p179 p814 from reaching the next step. In particular, a body element created in an active document (perhaps

with p828 p941 document.createElement() ) but not connected will also have its corresponding Window object as the target

of several p941 event handlers exposed through it.

4. Return p911 eventTarget 's node document 's relevant global object.



Each p941 EventTarget object that has one or more event handlers specified has an associated event handler map, which is a map of strings representing p941 p941 p941 names of event handlers to event handlers.

When an p941 p942 EventTarget object that has one or more event handlers specified is created, its event handler map must be initialized such that it contains an p941 p941 p941 entry for each event handler that has that object as target , with items in those event handlers set to

their initial values.

Note

The order of the p942 entries of event handler map could be arbitrary. It is not observable through any algorithms that operate on

the map.



Note

Entries p942 p941 are not created in the event handler map of an object for event handlers that are merely exposed on that object, but

have some other object as their p941 targets.



An p941 event handler IDL attribute is an IDL attribute for a specific event handler . The name of the IDL attribute is the same as the

name p941 p941 of the event handler .

The getter of an p942 event handler IDL attribute with name name, when called, must run these steps:

1. Let p942 eventTarget be the result of determining the target of an event handler given this object and name.

2. If eventTarget is null, then return null.

3. Return the result of p947 getting the current value of the event handler given eventTarget and name.

The setter of an p942 event handler IDL attribute with name name, when called, must run these steps:

1. Let p942 eventTarget be the result of determining the target of an event handler given this object and name.

2. If eventTarget is null, then return.

3. If the given value is null, then p943 deactivate an event handler given eventTarget and name.

4. Otherwise:

1. Let p942 handlerMap be eventTarget 's event handler map .

2. Let eventHandler be handlerMap[name].

3. Set p941 eventHandler 's value to the given value.

942

4. p944 Activate an event handler given eventTarget and name.

Note

Certain p942 p1012 p1010 event handler IDL attributes have additional requirements, in particular the onmessage attribute of MessagePort

objects.



An p941 event handler content attribute is a content attribute for a specific event handler. The name of the content attribute is the same as the p941 p941 name of the event handler.

Event handler content attributes p943 , when specified, must contain valid JavaScript code which, when parsed, would match the

FunctionBody production after automatic semicolon insertion.

The following p943 p941 attribute change steps are used to synchronize between event handler content attributes and event handlers:

[DOM] p1277

1. If p943 namespace is not null, or localName is not the name of an event handler content attribute on element, then return.

2. Let p942 eventTarget be the result of determining the target of an event handler given element and localName.

3. If eventTarget is null, then return.

4. If p943 value is null, then deactivate an event handler given eventTarget and localName.

5. Otherwise:

1. If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when

executed upon p1275 element , " script attribute ", and value , then return. [CSP]

2. Let p942 handlerMap be eventTarget 's event handler map .

3. Let eventHandler be handlerMap[localName].

4. Let location be the script location that triggered the execution of these steps.

5. Set p941 p946 eventHandler 's value to the internal raw uncompiled handler value/location.

6. p944 Activate an event handler given eventTarget and localName.

Note

Per the DOM Standard, these steps are run even if oldValue and value are identical (setting an attribute to its current value), but

not p1277 if oldValue and value are both null (removing an attribute that doesn't currently exist). [DOM]



To p941 deactivate an event handler given an EventTarget object eventTarget and a string name that is the name of an event

handler p941, run these steps:

1. Let p942 handlerMap be eventTarget 's event handler map .

2. Let eventHandler be handlerMap[name].

3. Set p941 eventHandler 's value to null.

4. Let p941 listener be eventHandler 's listener.

5. If listener is not null, then remove an event listener with eventTarget and listener.

6. Set p941 eventHandler 's listener to null.

To erase all event listeners and handlers given an EventTarget object eventTarget, run these steps:

1. If p942 eventTarget has an associated event handler map, then for each name → eventHandler of eventTarget's associated

event handler map p942 p943 , deactivate an event handler given eventTarget and name.

2. Remove all event listeners given eventTarget.



943

Note

This algorithm is used to define p956 document.open().

To p941 activate an event handler given an EventTarget object eventTarget and a string name that is the name of an event

handler p941, run these steps:

1. Let p942 handlerMap be eventTarget 's event handler map .

2. Let eventHandler be handlerMap[name].

3. If p941 eventHandler 's listener is not null, then return.

4. Let callback be the result of creating a Web IDL EventListener instance representing a reference to a function of one

argument that executes the steps of p945 the event handler processing algorithm, given eventTarget, name, and its argument.

The EventListener's callback context can be arbitrary; it does not impact the steps of the event handler processing

algorithm p945 p1277 . [DOM]

Note

The callback is emphatically p941 not the event handler itself. Every event handler ends up registering the same callback, the algorithm defined below, which takes care of invoking the right code, and processing the code's return value.

5. Let listener be a new event listener whose type is the event handler event type corresponding to eventHandler and

callback is callback.

Note

To be clear, an event listener is different from an EventListener.

6. Add an event listener with eventTarget and listener.

7. Set p941 eventHandler 's listener to listener.

Note

The event listener registration happens only if the p941 p941 p941 event handler 's value is being set to non-null, and the event handler is

not already activated. Since listeners are called in the order they were registered, assuming no p943 deactivation occurred, the order

of event listeners for a particular event type will always be:

1. the event listeners registered with p941 p941 addEventListener() before the first time the event handler 's value was set to

non-null

2. then the callback to which it is currently set, if any

3. and finally the event listeners registered with p941 p941 addEventListener() after the first time the event handler 's value

was set to non-null.



Example

This example demonstrates the order in which event listeners are invoked. If the button in this example is clicked by the user, the

page will show four alerts, with the text "ONE", "TWO", "THREE", and "FOUR" respectively.

Start Demo



However, in the following example, the event handler is p943 deactivated after its initial activation (and its event listener is

944

removed), before being reactivated at a later time. The page will show five alerts with "ONE", "TWO", "THREE", "FOUR", and "FIVE"

respectively, in order.

Start Demo





Note

The interfaces implemented by the event object do not influence whether an p941 event handler is triggered or not.

The event handler processing algorithm p941 for an EventTarget object eventTarget , a string name representing the name of an

event handler p941, and an Event object event is as follows:

1. Let p947 callback be the result of getting the current value of the event handler given eventTarget and name.

2. If callback is null, then return.

3. Let p924 p1271 special error event handling be true if event is an ErrorEvent object, event 's type is error, and event's

currentTarget p953 implements the WindowOrWorkerGlobalScope mixin. Otherwise, let special error event handling be false.

4. Process the Event object event as follows:

↪ If special error event handling is true

Invoke p925 callback with five arguments, the first one having the value of event 's message attribute, the second having

the value of p925 p925 event 's filename attribute, the third having the value of event 's lineno attribute, the fourth

having the value of p925 p925 event 's colno attribute, the fifth having the value of event 's error attribute, and with the

callback this value p1282 set to event 's currentTarget . Let return value be the callback's return value. [WEBIDL]

↪ Otherwise

Invoke callback with one argument, the value of which is the Event object event, with the callback this value set to

event p1282 's currentTarget . Let return value be the callback's return value. [WEBIDL]

If an exception gets thrown by the callback, end these steps and allow the exception to propagate. (It will propagate to the

DOM event dispatch logic p924 , which will then report the exception.)

5. Process return value as follows:

↪ p896 p1271 If event is a BeforeUnloadEvent object and event 's type is beforeunload

Note

In this case, the p942 p946 event handler IDL attribute 's type will be OnBeforeUnloadEventHandler , so return value

will have been coerced into either null or a DOMString.

If return value is not null, then:

1. Set event's canceled flag.

2. If p896 p896 event 's returnValue attribute's value is the empty string, then set event 's returnValue attribute's

value to return value.

↪ If special error event handling is true

If return value is true, then set event's canceled flag.

945

↪ Otherwise

If return value is false, then set event's canceled flag.

Note

If we've gotten to this "Otherwise" clause because p1271 event 's type is beforeunload but event is not a

BeforeUnloadEvent p896 object, then return value will never be false, since in such cases return value will have

been coerced into either null or a DOMString.



The p946 EventHandler callback function type represents a callback used for event handlers. It is represented in Web IDL as follows:

IDL [LegacyTreatNonObjectAsNull]

callback EventHandlerNonNull = any (Event event);

typedef EventHandlerNonNull? EventHandler;



Note

In JavaScript, any Function object implements this interface.



Example

For example, the following document fragment:



...leads to an alert saying "[object Window]" when the document is loaded, and an alert saying "[object HTMLBodyElement]"

whenever the user clicks something in the page.



Note

The return value of the function affects whether the event is canceled or not: as described above, if the return value is false, the

event is canceled.

There are two exceptions in the platform, for historical reasons:

• The p950 onerror handlers on global objects, where returning true cancels the event

• The p950 onbeforeunload handler, where returning any non-null and non-undefined value will cancel the event.



For historical reasons, the p950 onerror handler has different arguments:

IDL [LegacyTreatNonObjectAsNull]

callback OnErrorEventHandlerNonNull = any ((Event or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long colno, optional any error);

typedef OnErrorEventHandlerNonNull? OnErrorEventHandler;



Example

window.onerror = (message, source, lineno, colno, error) => { … };



Similarly, the p950 onbeforeunload handler has a different return value:

IDL [LegacyTreatNonObjectAsNull]

callback OnBeforeUnloadEventHandlerNonNull = DOMString? (Event event);

typedef OnBeforeUnloadEventHandlerNonNull? OnBeforeUnloadEventHandler;



An internal raw uncompiled handler is a tuple with the following information:

• An uncompiled script body

946

• A location where the script body originated, in case an error needs to be reported When the user agent is to get the current value of the event handler given an EventTarget object eventTarget and a string name that is the p941 p941 name of an event handler , it must run these steps:

1. Let p942 handlerMap be eventTarget 's event handler map .

2. Let eventHandler be handlerMap[name].

3. If p941 p946 eventHandler 's value is an internal raw uncompiled handler , then:

1. If eventTarget is an element, then let element be eventTarget, and document be element's node document.

Otherwise, p828 eventTarget is a Window object, let element be null, and document be eventTarget's associated

Document p829.

2. If p911 scripting is disabled for document, then return null.

3. Let p941 body be the uncompiled script body in eventHandler 's value .

4. Let p941 location be the location where the script body originated, as given by eventHandler 's value.

5. If p567 p567 element is not null and element has a form owner , let form owner be that form owner . Otherwise, let form

owner be null.

6. Let p911 settings object be the relevant settings object of document.

7. If body is not parsable as FunctionBody or if parsing detects an early error, then follow these substeps:

1. Set p941 eventHandler 's value to null.

Note

This does not p943 deactivate the event handler, which additionally removes the event handler's

listener p941 (if present).

2. p924 p912 Report the error for the appropriate script and with the appropriate position (line number and

column number) given by p905 location , using settings object 's global object. If the error is still not

handled p924 after this, then the error may be reported to a developer console.

3. Return null.

8. Push p904 settings object 's realm execution context onto the JavaScript execution context stack; it is now the running

JavaScript execution context.

Note

This is necessary so the subsequent invocation of OrdinaryFunctionCreate takes place in the correct JavaScript

Realm.

9. Let function be the result of calling OrdinaryFunctionCreate, with arguments:

functionPrototype

%Function.prototype%

sourceText

↪ p950 p828 If name is onerror and eventTarget is a Window object

The string formed by concatenating "function ", name, "(event, source, lineno, colno, error) {", U+000A LF, body, U+000A LF, and "}".

↪ Otherwise

The string formed by concatenating "function ", name, "(event) {", U+000A LF, body, U+000A LF, and "}".

ParameterList

↪ p950 p828 If name is onerror and eventTarget is a Window object

Let the function have five arguments, named event, source, lineno, colno, and error.

↪ Otherwise

Let the function have a single argument called event.



947

Body

The result of parsing body above.

thisMode

non-lexical-this

Scope

1. Let p905 realm be settings object 's Realm .

2. Let scope be realm.[[GlobalEnv]].

3. If p941 eventHandler is an element's event handler, then set scope to

NewObjectEnvironment(document, scope).

(Otherwise, p828 p941 eventHandler is a Window object's event handler.)

4. If form owner is not null, then set scope to NewObjectEnvironment(form owner, scope).

5. If element is not null, then set scope to NewObjectEnvironment(element, scope).

6. Return scope.

10. Remove p904 settings object 's realm execution context from the JavaScript execution context stack.

11. Set function.[[ScriptOrModule]] to null.

Note

This is done because the default behavior, of associating the created function with the nearest p912 script on the stack, can lead to path-dependent results. For example, an event handler which is first invoked by user interaction would end up with null [[ScriptOrModule]] (since then this algorithm would be first invoked when

the p912 active script is null), whereas one that is first invoked by dispatching an event from script would have its [[ScriptOrModule]] set to that script.

Instead, we just always set [[ScriptOrModule]] to null. This is more intuitive anyway; the idea that the first script which dispatches an event is somehow responsible for the event handler code is dubious.

In practice, this only affects the resolution of relative URLs via p912 import() , which consult the base URL of the

associated script. Nulling out [[ScriptOrModule]] means that p930 HostResolveImportedModule and

HostImportModuleDynamically p930 p911 p904 will fall back to the current settings object 's API base URL.

12. Set p941 p946 eventHandler 's value to the result of creating a Web IDL EventHandler callback function object whose

object reference is function and whose callback context is settings object.

4. Return p941 eventHandler 's value .



8.1.7.2 Event handlers on elements, p115 p828 p94 Document objects, and Window objects §

8

The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported by all HTML

elements p44 p943 p942 , as both event handler content attributes and event handler IDL attributes; and that must be supported by all

Document p115 p828 p942 and Window objects, as event handler IDL attributes:

Event handlerp941 p944 Event handler event type

⚠ MDN

onabort p1271 abort

onauxclick auxclick

⚠ MDN

oncancel p1271 cancel

p440 MDN

oncanplay canplay

p440 MDN

oncanplaythrough canplaythrough

onchange change

p1271 ✔ MDN

✔ MDN

onclick click

onclose close

p1271 MDN

p1271 MDN

oncontextmenu contextmenu

p441 MDN

oncuechange cuechange

948

Event handlerp941 p944 Event handler event type

MDN

ondblclick dblclick

ondrag p812 drag

ondragend p812 dragend

ondragenter p812 dragenter

ondragleave p812 dragleave

ondragover p812 dragover

ondragstart p812 dragstart

ondrop p812 drop

p441 MDN

ondurationchange durationchange

onemptied emptied

p440 MDN

MDN

onended endedp441

p1271 MDN

onformdata formdata

oninput p1271 input

MDN

oninvalid p1271 invalid

MDN

onkeydown keydown

MDN

onkeypress keypress

MDN

onkeyup keyup

p440 MDN

onloadeddata loadeddata

p440 MDN

onloadedmetadata loadedmetadata

onloadstart loadstart

p440 ✔ MDN

✔ MDN

onmousedown mousedown

✔ MDN

onmouseenter mouseenter

✔ MDN

onmouseleave mouseleave

✔ MDN

onmousemove mousemove

✔ MDN

onmouseout mouseout

✔ MDN

onmouseover mouseover

✔ MDN

onmouseup mouseup

onpause pause

p441 MDN

MDN

onplay p441 play

onplaying p440 playing

onprogress p440 progress

onratechange p441 ratechange

p1272 ✔ MDN

onreset reset

onsecuritypolicyviolation p1272 securitypolicyviolation

onseeked p441 seeked

onseeking seekingp441

p1272 MDN

onselect select

onslotchange p1272 slotchange

onstalled p440 stalled

p1272 ✔ MDN

onsubmit submit

onsuspend p440 suspend

ontimeupdate p441 timeupdate

ontoggle p1272 toggle

onvolumechange p441 volumechange

onwaiting p441 waiting

onwebkitanimationend webkitAnimationEnd

onwebkitanimationiteration webkitAnimationIteration

onwebkitanimationstart webkitAnimationStart

onwebkittransitionend webkitTransitionEnd

✔ MDN

onwheel wheel



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported by all HTML

elements p44 p179 p1230 p943 other than body and frameset elements, as both event handler content attributes and event handler IDL

attributes p942 p115 p942 ; that must be supported by all Document objects, as event handler IDL attributes ; and that must be supported by

949

all p828 p942 p828 Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler

content attributes p943 p942 p179 p1230 and event handler IDL attributes exposed on all body and frameset elements that are owned by that

Window p828 p829 object's associated Document:

Event handler p941 p944 Event handler event type

p1271 ✔ MDN

onblur blur

p1271 ✔ MDN

onerror error

✔ MDN

onfocus p1271 focus

p1271 ✔ MDN

onload load

✔ MDN

onresize resize

MDN

onscroll scroll

We call the p941 p941 set of the names of the event handlers listed in the first column of this table the Window-reflecting body element event handler set.



The following are the p941 p944 p828 event handlers (and their corresponding event handler event types ) that must be supported by Window

objects, as p942 p828 event handler IDL attributes on the Window objects themselves, and with corresponding event handler content

attributes p943 p942 p179 p1230 and event handler IDL attributes exposed on all body and frameset elements that are owned by that

Window p828 p829 object's associated Document:

Event handlerp941 p944 Event handler event type

p1271 ✔ MDN

onafterprint afterprint

p1271 ✔ MDN

onbeforeprint beforeprint

onbeforeunload beforeunload

p1271 ✔ MDN

p1271 ✔ MDN

onhashchange hashchange

p1271 MDN

onlanguagechange languagechange

onmessage message

p1271 ⚠ MDN

MDN

onmessageerror messageerrorp1272

onoffline p1272 offline

ononline p1272 online

onpagehide p1272 pagehide

onpageshow p1272 pageshow

p1272 ✔ MDN

onpopstate popstate

onrejectionhandled rejectionhandled

p1272 ✔ MDN

p1272 MDN

onstorage storage

p1272 ✔ MDN

onunhandledrejection unhandledrejection

onunload unload

p1272 ✔ MDN



This list of p941 p942 p952 event handlers is reified as event handler IDL attributes through the WindowEventHandlers interface mixin.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported by all HTML

elements p44 p943 p942 , as both event handler content attributes and event handler IDL attributes; and that must be supported by all

Document p115 p942 objects, as event handler IDL attributes:

Event handlerp941 Event handler event typep944

oncut p1271 cut

oncopy p1271 copy

onpaste p1272 paste

This list of p941 p942 p952 event handlers is reified as event handler IDL attributes through the DocumentAndElementEventHandlers interface mixin.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported on

Document p115 p942 objects as event handler IDL attributes :



950

Event handler p941 p944 Event handler event type

onreadystatechange p1272 readystatechange



8.1.7.2.1 IDL definitions p95 §

1

IDL ✔ interface mixin GlobalEventHandlers { MDN

attribute EventHandler onabort;

attribute EventHandler onauxclick;

attribute EventHandler onblur;

attribute EventHandler oncancel;

attribute EventHandler oncanplay;

attribute EventHandler oncanplaythrough;

attribute EventHandler onchange;

attribute EventHandler onclick;

attribute EventHandler onclose;

attribute EventHandler oncontextmenu;

attribute EventHandler oncuechange;

attribute EventHandler ondblclick;

attribute EventHandler ondrag;

attribute EventHandler ondragend;

attribute EventHandler ondragenter;

attribute EventHandler ondragleave;

attribute EventHandler ondragover;

attribute EventHandler ondragstart;

attribute EventHandler ondrop;

attribute EventHandler ondurationchange;

attribute EventHandler onemptied;

attribute EventHandler onended;

attribute OnErrorEventHandler onerror;

attribute EventHandler onfocus;

attribute EventHandler onformdata;

attribute EventHandler oninput;

attribute EventHandler oninvalid;

attribute EventHandler onkeydown;

attribute EventHandler onkeypress;

attribute EventHandler onkeyup;

attribute EventHandler onload;

attribute EventHandler onloadeddata;

attribute EventHandler onloadedmetadata;

attribute EventHandler onloadstart;

attribute EventHandler onmousedown;

[LegacyLenientThis] attribute EventHandler onmouseenter;

[LegacyLenientThis] attribute EventHandler onmouseleave;

attribute EventHandler onmousemove;

attribute EventHandler onmouseout;

attribute EventHandler onmouseover;

attribute EventHandler onmouseup;

attribute EventHandler onpause;

attribute EventHandler onplay;

attribute EventHandler onplaying;

attribute EventHandler onprogress;

attribute EventHandler onratechange;

attribute EventHandler onreset;

attribute EventHandler onresize;

attribute EventHandler onscroll;

attribute EventHandler onsecuritypolicyviolation;

attribute EventHandler onseeked;

attribute EventHandler onseeking;

attribute EventHandler onselect;

951

attribute EventHandler onslotchange;

attribute EventHandler onstalled;

attribute EventHandler onsubmit;

attribute EventHandler onsuspend;

attribute EventHandler ontimeupdate;

attribute EventHandler ontoggle;

attribute EventHandler onvolumechange;

attribute EventHandler onwaiting;

attribute EventHandler onwebkitanimationend;

attribute EventHandler onwebkitanimationiteration;

attribute EventHandler onwebkitanimationstart;

attribute EventHandler onwebkittransitionend;

attribute EventHandler onwheel;

};

interface mixin WindowEventHandlers {

attribute EventHandler onafterprint;

attribute EventHandler onbeforeprint;

attribute OnBeforeUnloadEventHandler onbeforeunload;

attribute EventHandler onhashchange;

attribute EventHandler onlanguagechange;

attribute EventHandler onmessage;

attribute EventHandler onmessageerror;

attribute EventHandler onoffline;

attribute EventHandler ononline;

attribute EventHandler onpagehide;

attribute EventHandler onpageshow;

attribute EventHandler onpopstate;

attribute EventHandler onrejectionhandled;

attribute EventHandler onstorage;

attribute EventHandler onunhandledrejection;

attribute EventHandler onunload;

};

interface mixin DocumentAndElementEventHandlers {

attribute EventHandler oncopy;

attribute EventHandler oncut;

attribute EventHandler onpaste;

};



8.1.7.3 Event firing p95 §

2

Certain operations and methods are defined as firing events on elements. For example, the p771 click() method on the

HTMLElement p125 p1282 interface is defined as firing a click event on the element. [UIEVENTS]

Firing a synthetic pointer event named e at target, with an optional not trusted flag, means running these steps:

1. Let event be the result of creating an event using PointerEvent.

2. Initialize event's type attribute to e.

3. Initialize event's bubbles and cancelable attributes to true.

4. Set event's composed flag.

5. If the not trusted flag is set, initialize event's isTrusted attribute to false.

6. Initialize event's ctrlKey, shiftKey, altKey, and metaKey attributes according to the current state of the key input device, if

any (false for any keys that are not available).

7. Initialize p828 event 's view attribute to target 's node document 's Window object, if any, and null otherwise.

952

8. event's getModifierState() method is to return values appropriately describing the current state of the key input device.

9. Return the result of dispatching event at target.

Firing a p952 click event at target means firing a synthetic pointer event named click at target.



8.2 The p953 ✔ MDN p95 WindowOrWorkerGlobalScope mixin §

3

The p953 p828 p1032 WindowOrWorkerGlobalScope mixin is for use of APIs that are to be exposed on Window and WorkerGlobalScope objects.

Note

Other standards are encouraged to further extend it using p953 partial interface mixin WindowOrWorkerGlobalScope { … };

along with an appropriate reference.



IDL typedef (DOMString or Function) TimerHandler;

interface mixin WindowOrWorkerGlobalScope {

[Replaceable] readonly attribute USVString origin;

readonly attribute boolean isSecureContext;

readonly attribute boolean crossOriginIsolated;

// base64 utility methods

DOMString btoa(DOMString data);

ByteString atob(DOMString data);

// timers

long setTimeout(TimerHandler handler, optional long timeout = 0, any... arguments);

undefined clearTimeout(optional long handle = 0);

long setInterval(TimerHandler handler, optional long timeout = 0, any... arguments);

undefined clearInterval(optional long handle = 0);

// microtask queuing

undefined queueMicrotask(VoidFunction callback);

// ImageBitmap

Promise<ImageBitmap> createImageBitmap(ImageBitmapSource image, optional ImageBitmapOptions options =

{});

Promise<ImageBitmap> createImageBitmap(ImageBitmapSource image, long sx, long sy, long sw, long sh,

optional ImageBitmapOptions options = {});

};

Window includes WindowOrWorkerGlobalScope;

WorkerGlobalScope includes WindowOrWorkerGlobalScope;



For web developers (non-normative)

self . p954 isSecureContext

Returns whether or not this global object represents a p911 p1281 secure context . [SECURE-CONTEXTS]

self . p954 origin

Returns the global object's p841 origin , serialized as string.

self . p954 crossOriginIsolated

Returns whether scripts running in this global are allowed to use APIs that require cross-origin isolation. This depends on the

` p1247 p1247 Cross-Origin-Opener-Policy ` and ` Cross-Origin-Embedder-Policy` HTTP response headers and the "cross-

origin-isolated p67 " feature.



Example

953

Developers are strongly encouraged to use p841 self.origin over location.origin . The former returns the origin of the

environment, the latter of the URL of the environment. Imagine the following script executing in a document on

https://stargate.example/:

var frame = document.createElement("iframe")

frame.onload = function() {

var frameWin = frame.contentWindow

console.log(frameWin.location.origin) // "null"

console.log(frameWin.origin) // "https://stargate.example"

}

document.body.appendChild(frame)

self.origin is a more reliable security indicator.

The p911 ✔ MDN p911 isSecureContext getter steps are to return true if this 's relevant settings object is a secure context , or false otherwise.

⚠ MDN

The p911 p904 p841 origin getter steps are to return this 's relevant settings object 's origin , serialized .

The p911 p904 crossOriginIsolated getter steps are to return this 's relevant settings object 's cross-origin isolated capability .



✔ MDN

8.3 Base64 utility methods p95 §

4

The p954 p954 atob() and btoa() methods allow developers to transform content to and from the base64 encoding.

Note

In these APIs, for mnemonic purposes, the "b" can be considered to stand for "binary", and the "a" for "ASCII". In practice, though,

for primarily historical reasons, both the input and output of these functions are Unicode strings.



For web developers (non-normative)

result p954 = self . btoa( data )

Takes the input data, in the form of a Unicode string containing only characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, and converts it to its base64 representation, which it returns.

Throws an "InvalidCharacterError" DOMException exception if the input string contains any out-of-range characters.

result p954 = self . atob( data )

Takes the input data, in the form of a Unicode string containing base64-encoded binary data, decodes it, and returns a string consisting of characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, corresponding to that binary data.

Throws an "InvalidCharacterError" DOMException if the input string is not valid base64 data.



The btoa(data) method must throw an "InvalidCharacterError" DOMException if data contains any character whose code point is ✔ MDN greater than U+00FF. Otherwise, the user agent must convert data to a byte sequence whose nth byte is the eight-bit representation ✔ MDN

of the nth code point of data, and then must apply forgiving-base64 encode to that byte sequence and return the result.

The atob(data) method, when invoked, must run the following steps:

1. Let decodedData be the result of running forgiving-base64 decode on data.

2. If decodedData is failure, then throw an "InvalidCharacterError" DOMException.

3. Return decodedData.



954

8.4 Dynamic markup insertion p95 §

5

Note

APIs for dynamically inserting markup into the document interact with the parser, and thus their behavior varies depending on

whether they are used with p1076 p1184 HTML documents (and the HTML parser ) or XML documents (and the XML parser).

Document p115 objects have a throw-on-dynamic-markup-insertion counter, which is used in conjunction with the create an element

for the token p1124 p705 p956 algorithm to prevent custom element constructors from being able to use document.open(),

document.close() p957 p958 , and document.write() when they are invoked by the parser. Initially, the counter must be set to zero.



8.4.1 Opening the input stream p95 §

5

For web developers (non-normative)

document p956 = document . open ( )

Causes the p115 p115 Document to be replaced in-place, as if it was a new Document object, but reusing the previous object, which is then returned.

The resulting p115 Document has an HTML parser associated with it, which can be given data to parse using

document.write() p958.

The method has no effect if the p115 Document is still being parsed.

Throws an p115 " InvalidStateError " DOMException if the Document is an XML document.

Throws an p705 " InvalidStateError " DOMException if the parser is currently executing a custom element constructor.

window p956 = document . open ( url, name, features )

Works like the p831 window.open() method.

Document p115 objects have an ignore-opens-during-unload counter, which is used to prevent scripts from invoking the

document.open() p956 p895 method (directly or indirectly) while the document is being unloaded . Initially, the counter must be set to zero.

Document p115 objects have an active parser was aborted boolean, which is used to prevent scripts from invoking the

document.open() p956 p958 p118 and document.write() methods (directly or indirectly) after the document's active parser has been aborted. It is initially false.

The document open steps, given a document, are as follows:

1. If document is an XML document, then throw an "InvalidStateError" DOMException exception.

2. If p955 document 's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError"

DOMException.

3. Let p908 p829 entryDocument be the entry global object 's associated Document.

4. If p841 p842 p841 document 's origin is not same origin to entryDocument 's origin , then throw a "SecurityError" DOMException.

5. If p118 p1078 document has an active parser whose script nesting level is greater than 0, then return document.

Note

This basically causes p956 document.open() to be ignored when it's called in an inline script found during parsing, while still letting it have an effect when called from a non-parser task such as a timer callback or event handler.

6. Similarly, if p955 document 's ignore-opens-during-unload counter is greater than 0, then return document.

Note

This basically causes p956 p1271 p1272 document.open() to be ignored when it's called from a beforeunload , pagehide, or

unload p1272 p115 event handler while the Document is being unloaded.

7. If p955 document 's active parser was aborted is true, then return document.



955

Note

This notably causes p956 p876 document.open() to be ignored if it is called after a navigation has started, but only during

the initial parse. See issue #4723 for more background.

8. If p814 p876 document 's browsing context is non-null and there is an existing attempt to navigate document's browsing

context p814 p897 , then stop document loading given document.

Issue #3447 p876 looks into the distinction between an ongoing instance of the navigate algorithm versus tasks to

navigate p876 that are still queued. For the purpose of implementing this step, both an ongoing instance of the

navigate p876 p876 algorithm and tasks queued to navigate should be counted towards "an existing attempt to

navigate p876," at least until that issue is resolved.

9. For each p943 shadow-including inclusive descendant node of document , erase all event listeners and handlers given node.

10. If p829 p911 document is the associated Document of document 's relevant global object, then erase all event listeners and

handlers p943 p911 given document 's relevant global object.

11. Replace all with null within document, without firing any mutation events.

12. If p818 document is fully active , then:

1. Let newURL be a copy of entryDocument's URL.

2. If entryDocument is not document, then set newURL's fragment to null.

3. Run the p863 URL and history update steps with document and newURL.

13. If p365 p365 document 's iframe load in progress flag is set, then set document 's mute iframe load flag.

14. Set document to no-quirks mode.

15. Create a new p1076 HTML parser and associate it with document. This is a script-created parser (meaning that it can be

closed by the p956 p957 document.open() and document.close() methods, and that the tokenizer will wait for an explicit call to

document.close() p957 p1083 before emitting an end-of-file token). The encoding confidence is irrelevant.

16. Set the p118 current document readiness of document to "loading".

17. Finally, set the p1089 p1088 insertion point to point at just before the end of the input stream (which at this point will be empty).

18. Return document.

Note

The p955 p115 p1162 p894 ✔ MDN document open steps do not affect whether a Document is ready for post-load tasks or completely loaded .

The p955 p115 open( unused1 , unused2 ) method must return the result of running the document open steps with this Document object.

Note

The unused1 and unused2 arguments are ignored, but kept in the IDL to allow code that calls the function with one or two

arguments to continue working. They are necessary due to Web IDL overload resolution algorithm rules, which would throw a

TypeError exception for such calls had the arguments not been there. heycam/webidl issue #581 investigates changing the

algorithm to allow for their removal. p1282 [WEBIDL]

The open(url, name, features) method must run these steps:

1. If this p115 p814 Document object is not an active document, then throw an "InvalidAccessError" DOMException exception.

2. Return the result of running the p830 window open steps with url, name, and features.



8.4.2 Closing the input stream p95 §

6

For web developers (non-normative)

956

document p957 . close()

Closes the input stream that was opened by the p956 document.open() method.

Throws an p115 " InvalidStateError " DOMException if the Document is an XML document.

Throws an p705 " InvalidStateError " DOMException if the parser is currently executing a custom element constructor.



The close() method must run the following steps: ✔ MDN

1. If the p115 Document object is an XML document, then throw an "InvalidStateError" DOMException.

2. If the p115 p955 Document object's throw-on-dynamic-markup-insertion counter is greater than zero, then throw an

"InvalidStateError" DOMException.

3. If there is no p956 script-created parser associated with the document, then return.

4. Insert an p1089 p1088 explicit "EOF" character at the end of the parser's input stream.

5. If there is a p624 pending parsing-blocking script, then return.

6. Run the tokenizer, processing resulting tokens as they are emitted, and stopping when the tokenizer reaches the explicit

"EOF" character p1089 p937 or spins the event loop .



8.4.3 p958 p95 document.write() §

7

For web developers (non-normative)

document p958 . write(text...)

In general, adds the given string(s) to the p115 Document 's input stream. ⚠Warning!

This method has very idiosyncratic behavior. In some cases, this method can affect the state of the HTML

parser p1076 while the parser is running, resulting in a DOM that does not correspond to the source of the document (e.g. if the string written is the string "<plaintext>" or "<!--"). In other cases, the call can clear the

current page first, as if p956 document.open() had been called. In yet more cases, the method is simply ignored,

or throws an exception. Users agents are explicitly allowed to avoid executing script elements inserted via

this method p1133. And to make matters even worse, the exact behavior of this method can in some cases be dependent on network latency, which can lead to failures that are very hard to debug. For all these reasons, use of this method is strongly discouraged.

Throws an "InvalidStateError" DOMException when invoked on XML documents.

Throws an p705 " InvalidStateError " DOMException if the parser is currently executing a custom element constructor.

Document p115 p614 objects have an ignore-destructive-writes counter , which is used in conjunction with the processing of script

elements to prevent external scripts from being able to use p958 document.write() to blow away the document by implicitly calling

document.open() p956 . Initially, the counter must be set to zero.

The p115 document write steps , given a Document object document and a string input, are as follows:

1. If document is an XML document, then throw an "InvalidStateError" DOMException.

2. If p955 document 's throw-on-dynamic-markup-insertion counter is greater than 0, then throw an "InvalidStateError"

DOMException.

3. If p955 document 's active parser was aborted is true, then return.

4. If the p1089 insertion point is undefined, then:

1. If p955 document 's ignore-opens-during-unload counter is greater than 0 or document's ignore-destructive-writes

counter p957 is greater than 0, then return.

2. Run the p955 document open steps with document.

5. Insert p1088 p1089 input into the input stream just before the insertion point.

957

6. If there is no p624 p1076 pending parsing-blocking script , have the HTML parser process input, one code point at a time,

processing resulting tokens as they are emitted, and stopping when the tokenizer reaches the insertion point or when the

processing of the tokenizer is aborted by the tree construction stage (this can happen if a p614 script end tag token is emitted by the tokenizer).

Note

If the p958 document.write() method was called from script executing inline (i.e. executing because the parser parsed a

set of p614 p1077 p1078 script tags), then this is a reentrant invocation of the parser . If the parser pause flag is set, the

tokenizer will abort immediately and no HTML will be parsed, per the tokenizer's p1094 parser pause flag check.

The p957 p115 document.write(...) method, when invoked, must run the document write steps with this Document object and a string ✔ MDN that is the concatanation of all arguments passed.



8.4.4 p958 p95 document.writeln() §

8

For web developers (non-normative)

document p958 . writeln(text...)

Adds the given string(s) to the p115 p956 Document 's input stream, followed by a newline character. If necessary, calls the open()

method implicitly first.

Throws an "InvalidStateError" DOMException when invoked on XML documents.

Throws an p705 " InvalidStateError " DOMException if the parser is currently executing a custom element constructor.



The p957 p115 document.writeln(...) method, when invoked, must run the document write steps with this Document object and a string ✔ MDN that is the concatanation of all arguments passed and U+000A LINE FEED.



✔ MDN

8.5 DOM parsing p95 §

8

The p958 p115 DOMParser interface allows authors to create new Document objects by parsing strings, as either HTML or XML.

For web developers (non-normative)

parser p959 = new DOMParser ()

Constructs a new p958 DOMParser object.

document p959 = parser . parseFromString( string, type )

Parses p115 string using either the HTML or XML parser, according to type , and returns the resulting Document . type can be "text/

html p1241 p1274 p1273 " (which will invoke the HTML parser), or any of " text/xml ", " application/xml", "application/

xhtml+xml p1243 p1273 ", or " image/svg+xml" (which will invoke the XML parser).

For the XML parser, if p115 string cannot be parsed, then the returned Document will contain elements describing the resulting error.

Note that p614 script elements are not evaluated during parsing, and the resulting document's encoding will always be UTF-8.

Values other than the above for type will cause a TypeError exception to be thrown.



Note

The design of p958 p959 DOMParser , as a class that needs to be constructed and then have its parseFromString() method called, is

an unfortunate historical artifact. If we were designing this functionality today it would be a standalone function.



IDL [Exposed=Window]

interface DOMParser {

constructor();

[NewObject] Document parseFromString(DOMString string, DOMParserSupportedType type);

};

958

enum DOMParserSupportedType {

"text/html",

"text/xml",

"application/xml",

"application/xhtml+xml",

"image/svg+xml"

};

The new DOMParser() constructor steps are to do nothing.

The parseFromString(string, type) method steps are:

1. Let p115 p911 document be a new Document , whose content type is type and url is this's relevant global object 's associated

Document p829's URL.

Note

The document's p165 encoding will be left as its default, of UTF-8 . In particular, any XML declarations or meta elements found while parsing string will have no effect.

2. Switch on type:

↪ "text/html"

1. Set document's type to "html".

2. Create an p1076 HTML parser parser, associated with document.

3. Place p1088 p1083 string into the input stream for parser . The encoding confidence is irrelevant.

4. Start parser and let it run until it has consumed all the characters just inserted into the input stream.

Note

This might mutate the document's mode.



Note

Since p814 p911 document does not have a browsing context , scripting is disabled.

↪ Otherwise

1. Create an p1184 p1185 XML parser parse , associated with document , and with XML scripting support disabled.

2. Parse string using parser.

3. If the previous step resulted in an XML well-formedness or XML namespace well-formedness error, then:

1. Assert: document has no child nodes.

2. Let root be the result of creating an element given document, "parsererror", and

"http://www.mozilla.org/newlayout/xml/parsererror.xml".

3. Optionally, add attributes or children to root to describe the nature of the parsing error.

4. Append root to document.

3. Return document.



8.6 Timers p95 §

9

The p960 p960 setTimeout() and setInterval() methods allow authors to schedule timer-based callbacks.



959

For web developers (non-normative)

handle p960 = self . setTimeout ( handler [, timeout [, arguments... ] ] )

Schedules a timeout to run handler after timeout milliseconds. Any arguments are passed straight through to the handler.

handle p960 = self . setTimeout ( code [, timeout ] )

Schedules a timeout to compile and run code after timeout milliseconds.

self . p960 clearTimeout ( handle )

Cancels the timeout set with p960 p960 setTimeout() or setInterval() identified by handle.

handle p960 = self . setInterval( handler [, timeout [, arguments... ] ] )

Schedules a timeout to run handler every timeout milliseconds. Any arguments are passed straight through to the handler.

handle p960 = self . setInterval( code [, timeout ] )

Schedules a timeout to compile and run code every timeout milliseconds.

self . p960 clearInterval( handle )

Cancels the timeout set with p960 p960 setInterval() or setTimeout() identified by handle.



Note

Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.



Note

This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, other tasks, etc, are to be expected.

Objects that implement the p953 WindowOrWorkerGlobalScope mixin have a list of active timers. Each entry in this lists is identified by a number, which must be unique within the list for the lifetime of the object that implements the p953 WindowOrWorkerGlobalScope mixin.



The p960 setTimeout() method must return the value returned by the timer initialization steps, passing them the method's arguments, ✔ MDN

the object on which the method for which the algorithm is running is implemented (a p828 p1032 Window or WorkerGlobalScope object) as ✔ MDN the method context, and the repeat flag set to false.

The p960 setInterval() method must return the value returned by the timer initialization steps , passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a p828 p1032 Window or WorkerGlobalScope object) as ✔ MDN the method context, and the repeat flag set to true.

The p960 clearTimeout() and clearInterval() methods must clear the entry identified as handle from the list of active timers of the

WindowOrWorkerGlobalScope p953 object on which the method was invoked, if any, where handle is the argument passed to the method. (If p960 p953 handle does not identify an entry in the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, the method does nothing.) Note

Because p960 p960 clearTimeout() and clearInterval() clear entries from the same list, either method can be used to clear timers

created by p960 p960 setTimeout() or setInterval() .



The timer initialization steps, which are invoked with some method arguments, a method context, a repeat flag which can be true or false, and optionally (and only if the repeat flag is true) a previous handle, are as follows:

1. Let p1032 p837 method context proxy be method context if that is a WorkerGlobalScope object, or else the WindowProxy that

corresponds to method context.

2. If previous handle was provided, let handle be previous handle; otherwise, let handle be an implementation-defined integer

that is greater than zero that will identify the timeout to be set by this call in the p960 list of active timers .

3. If p960 previous handle was not provided, add an entry to the list of active timers for handle.

4. Let callerRealm be the current Realm Record, and calleeRealm be method context's JavaScript realm.

5. Let p912 initiating script be the active script.

960

6. Assert: initiating script is not null, since this algorithm is always called from some script.

7. Let p932 task be a task that runs the following substeps:

1. If the entry for p960 handle in the list of active timers has been cleared, then abort these steps.

2. Run the appropriate set of steps from the following list:

↪ If the first method argument is a Function

Invoke the Function. Use the third and subsequent method arguments (if any) as the arguments for

invoking the Function. Use method context proxy as the callback this value. If this throws an exception,

catch it, and p924 report the exception .

↪ Otherwise

1. Perform p927 HostEnsureCanCompileStrings(callerRealm, calleeRealm). If this throws an exception,

catch it, p924 report the exception, and abort these steps.

2. Let script source be the first method argument.

3. Let p904 settings object be method context 's environment settings object.

4. Let p912 base URL be initiating script 's base URL.

5. Let p913 p913 fetch options be a script fetch options whose cryptographic nonce is initiating script's

fetch options p912 p913 p913 's cryptographic nonce , integrity metadata is the empty string, parser

metadata p913 p913 is " not-parser-inserted ", credentials mode is initiating script's fetch

options p912 p913 p913 p912 's credentials mode , and referrer policy is initiating script 's fetch options's

referrer policy p913.

Note

The effect of these options ensures that the string compilation done by p960 setTimeout() and

setInterval() p960 p912 behaves equivalently to that done by eval() . That is, module script

fetches via import() will behave the same in both contexts.

6. Let p920 script be the result of creating a classic script given script source, settings object, base

URL, and fetch options.

7. p921 Run the classic script script.

3. If the p960 repeat flag is true, then call timer initialization steps again, passing them the same method arguments,

the same method context, with the repeat flag still set to true, and with the previous handle set to handler.

8. Let timeout be the second method argument.

9. If the currently running p932 p932 task is a task that was created by this algorithm, then let nesting level be the task 's timer

nesting level p961. Otherwise, let nesting level be zero.

Note

The task's p961 p960 timer nesting level is used both for nested calls to setTimeout() , and for the repeating timers created

by p960 setInterval(). (Or, indeed, for any combination of the two.) In other words, it represents nested invocations of this algorithm, not of a particular method.

10. If timeout is less than 0, then set timeout to 0.

11. If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4.

12. Increment nesting level by one.

13. Let task's timer nesting level be nesting level.

14. Return p42 handle , and then continue running this algorithm in parallel.

15. If p828 p115 p818 method context is a Window object, wait until the Document associated with method context has been fully active

for a further timeout milliseconds (not necessarily consecutively).

Otherwise, p1032 method context is a WorkerGlobalScope object; wait until timeout milliseconds have passed with the worker not suspended (not necessarily consecutively).

961

16. Wait until any invocations of this algorithm that had the same method context, that started before this one, and whose

timeout is equal to or less than this one's, have completed.

Note

Argument conversion as defined by Web IDL (for example, invoking toString() methods on objects passed as the first argument) happens in the algorithms defined in Web IDL, before this algorithm is invoked.

Example

So for example, the following rather silly code will result in the log containing "ONE TWO ":

var log = '';

function logger(s) { log += s + ' '; }

setTimeout({ toString: function () {

setTimeout("logger('ONE')", 100);

return "logger('TWO')";

} }, 100);

17. Optionally, wait a further implementation-defined length of time.

Note

This is intended to allow user agents to pad timeouts as needed to optimize the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.

18. p933 Queue a global task on the timer task source given method context to run task.

Note

Once the task has been processed, if the repeat flag is false, it is safe to remove the entry for handle from the list of

active timers p960 (there is no way for the entry's existence to be detected past this point, so it does not technically matter one way or the other).



Example

To run tasks of several milliseconds back to back without any delay, while still yielding back to the browser to avoid starving the

user interface (and to avoid the browser killing the script for hogging the CPU), simply queue the next timer before performing

work:

function doExpensiveWork() {

var done = false;

// ...

// this part of the function takes up to five milliseconds // set done to true if we're done

// ...

return done;

}

function rescheduleWork() {

var handle = setTimeout(rescheduleWork, 0); // preschedule next iteration if (doExpensiveWork())

clearTimeout(handle); // clear the timeout if we don't need it

}

function scheduleWork() {

setTimeout(rescheduleWork, 0);

}

scheduleWork(); // queues a task to do lots of work



962

✔ MDN

8.7 Microtask queuing p96 §

3

For web developers (non-normative)

self p963 . queueMicrotask(callback)

Queues p933 p932 a microtask to run the given callback.

The p933 queueMicrotask( callback ) method must queue a microtask to invoke callback, and if callback throws an exception, report

the exception p924 .

The p963 p932 queueMicrotask() method allows authors to schedule a callback on the microtask queue . This allows their code to run after the currently-executing p932 task has run to completion and the JavaScript execution context stack is empty, but without yielding control back to the p931 p960 event loop , as would be the case when using, for example, setTimeout( f , 0).

Authors ought to be aware that scheduling a lot of microtasks has the same performance downsides as running a lot of synchronous code. Both will prevent the browser from doing its own work, such as rendering or scrolling. In many cases,

requestAnimationFrame() p984 or requestIdleCallback() is a better choice. In particular, if the goal is to run code before the next rendering cycle, that is the purpose of p984 requestAnimationFrame().

As can be seen from the following examples, the best way of thinking about p963 queueMicrotask() is as a mechanism for rearranging synchronous code, effectively placing the queued code immediately after the current task's worth of non-queued JavaScript.

Example

The most common reason for using p963 queueMicrotask() is to create consistent ordering, even in the cases where information is

available synchronously, without introducing undue delay.

For example, consider a custom element firing a load event, that also maintains an internal cache of previously-loaded data. A

naïve implementation might look like:

MyElement.prototype.loadData = function (url) {

if (this._cache[url]) {

this._setData(this._cache[url]);

this.dispatchEvent(new Event("load"));

} else {

fetch(url).then(res => res.arrayBuffer()).then(data => {

this._cache[url] = data;

this._setData(data);

this.dispatchEvent(new Event("load"));

});

}

};

This naïve implementation is problematic, however, in that it causes its users to experience inconsistent behavior. For example,

code such as

element.addEventListener("load", () => console.log("loaded")); console.log("1");

element.loadData();

console.log("2");

will sometimes log "1, 2, loaded" (if the data needs to be fetched), and sometimes log "1, loaded, 2" (if the data is already cached).

Similarly, after the call to loadData(), it will be inconsistent whether or not the data is set on the element.

To get a consistent ordering, p963 queueMicrotask() can be used:

MyElement.prototype.loadData = function (url) {

if (this._cache[url]) {

queueMicrotask(() => {

this._setData(this._cache[url]);

this.dispatchEvent(new Event("load"));

});

963

} else {

fetch(url).then(res => res.arrayBuffer()).then(data => {

this._cache[url] = data;

this._setData(data);

this.dispatchEvent(new Event("load"));

});

}

};

By essentially rearranging the queued code to be after the currently-executing task, this ensures a consistent ordering and update

of the element's state.



Example

Another interesting use of p963 queueMicrotask() is to allow uncoordinated "batching" of work by multiple callers. For example,

consider a library function that wants to send data somewhere as soon as possible, but doesn't want to make multiple network

requests if doing so is easily avoidable. One way to balance this would be like so:

const queuedToSend = [];

function sendData(data) {

queuedToSend.push(data);

if (queuedToSend.length === 1) {

queueMicrotask(() => {

const stringToSend = JSON.stringify(queuedToSend);

queuedToSend.length = 0;

fetch("/endpoint", stringToSend);

});

}

}

With this architecture, multiple subsequent calls to sendData() within the same turn of the event loop will be batched together

into one fetch() call, but with no intervening event loop tasks preempting the fetch (as would have happened with similar code

that instead used p960 setTimeout()).



8.8 User prompts p96 §

4

8.8.1 Simple dialogs p96 §

4

For web developers (non-normative)

window p965 . alert(message)

Displays a modal alert with the given message, and waits for the user to dismiss it.

result p965 = window . confirm (message)

Displays a modal OK/Cancel prompt with the given message, waits for the user to dismiss it, and returns true if the user clicks OK and false if the user clicks Cancel.

result p965 = window . prompt(message [, default] )

Displays a modal text control prompt with the given message, waits for the user to dismiss it, and returns the value that the user entered. If the user cancels the prompt, then returns null instead. If the second argument is present, then the given value is used as a default.



Note

Logic that depends on p932 p932 p388 p389 tasks or microtasks , such as media elements loading their media data, are stalled when these

methods are invoked.

964

To optionally truncate a simple dialog string s, return either s itself or some string derived from s that is shorter. User agents should not provide UI for displaying the elided portion of s, as this makes it too easy for abusers to create dialogs of the form "Important security alert! Click 'Show More' for full details!".

Note

For example, a user agent might want to only display the first 100 characters of a message. Or, a user agent might replace the

middle of the string with "…". These types of modifications can be useful in limiting the abuse potential of unnaturally large,

trustworthy-looking system dialogs. ✔ MDN



The alert(message) method, when invoked, must run the following steps:

1. If the p931 p894 event loop 's termination nesting level is nonzero, optionally return.

2. If the p848 p828 p829 p846 active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag

set, then return.

3. Optionally, return. (For example, the user agent might give the user the option to ignore all alerts, and would thus abort at

this step whenever the method was invoked.)

4. If the method was invoked with no arguments, then let message be the empty string; otherwise, let message be the

method's first argument.

5. Set message to the result of normalizing newlines given message.

6. Set p965 message to the result of optionally truncating message.

7. Show message to the user, treating U+000A LF as a line break.

8. Optionally, p938 pause while waiting for the user to acknowledge the message.

The confirm(message) method, when invoked, must run the following steps: ✔ MDN

1. If the p931 p894 event loop 's termination nesting level is nonzero, optionally return false.

2. If the p848 p828 p829 p846 active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag

set, then return.

3. Optionally, return false. (For example, the user agent might give the user the option to ignore all prompts, and would thus

abort at this step whenever the method was invoked.)

4. Set message to the result of normalizing newlines given message.

5. Set p965 message to the result of optionally truncating message.

6. Show message to the user, treating U+000A LF as a line break, and ask the user to respond with a positive or negative

response.

7. p938 Pause until the user responds either positively or negatively.

8. If the user responded positively, return true; otherwise, the user responded negatively: return false.

The prompt(message, default) method, when invoked, must run the following steps: ✔ MDN

1. If the p931 p894 event loop 's termination nesting level is nonzero, optionally return null.

2. If the p848 p828 p829 p846 active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag

set, then return.

3. Optionally, return null. (For example, the user agent might give the user the option to ignore all prompts, and would thus

abort at this step whenever the method was invoked.)

4. Set p965 message to the result of optionally truncating message.

5. Set message to the result of normalizing newlines given message.

6. Set p965 default to the result of optionally truncating default.

7. Show message to the user, treating U+000A LF as a line break, and ask the user to either respond with a string value or

abort. The response must be defaulted to the value given by default.

965

8. p938 Pause while waiting for the user's response.

9. If the user aborts, then return null; otherwise, return the string that the user responded with.



✔ MDN

8.8.2 Printing p96 §

6

For web developers (non-normative)

window p966 . print()

Prompts the user to print the page.

When the p115 p1162 print() method is invoked, if the Document is ready for post-load tasks, then the user agent must run the printing

steps p966 p115 . Otherwise, the user agent must only set the print when loaded flag on the Document .

User agents should also run the p966 p1220 printing steps whenever the user asks for the opportunity to obtain a physical form (e.g. printed copy), or the representation of a physical form (e.g. PDF copy), of a document.

The printing steps are as follows:

1. The user agent may display a message to the user or return (or both).

Example

For instance, a kiosk browser could silently ignore any invocations of the p966 print() method.

Example

For instance, a browser on a mobile device could detect that there are no printers in the vicinity and display a message saying so before continuing to offer a "save to PDF" option.

2. If the p848 p828 p829 p846 active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag

set, then return.

Note

If the printing dialog is blocked by a p115 p1271 p1271 Document 's sandbox, then neither the beforeprint nor afterprint events will be fired.

3. The user agent must p1271 p911 p115 fire an event named beforeprint at the relevant global object of the Document that is being

printed, as well as any p817 child browsing contexts in it.

Example

The p1271 beforeprint event can be used to annotate the printed copy, for instance adding the time at which the document was printed.

4. The user agent should offer the user the opportunity to p1220 obtain a physical form (or the representation of a physical form)

of the document. The user agent may wait for the user to either accept or decline before returning; if so, the user agent must

pause p938 while the method is waiting. Even if the user agent doesn't wait at this point, the user agent must use the state of the relevant documents as they are at this point in the algorithm if and when it eventually creates the alternate form.

5. The user agent must p1271 p911 p115 fire an event named afterprint at the relevant global object of the Document that is being

printed, as well as any p817 child browsing contexts in it.

Example

The p1271 afterprint event can be used to revert annotations added in the earlier event, as well as showing post-printing UI. For instance, if a page is walking the user through the steps of applying for a home loan, the script could automatically advance to the next step after having printed a form or other.



966

8.9 System state and capabilities p96 §

7 ✔ MDN

8.9.1 The p967 p96 Navigator object §

7

The p828 p967 navigator attribute of the Window interface must return an instance of the Navigator interface, which represents the ✔ MDN identity and state of the user agent (the client), and allows web pages to register themselves as potential protocol handlers:

IDL [Exposed=Window]

interface Navigator {

// objects implementing this interface also implement the interfaces given below

};

Navigator includes NavigatorID;

Navigator includes NavigatorLanguage;

Navigator includes NavigatorOnLine;

Navigator includes NavigatorContentUtils;

Navigator includes NavigatorCookies;

Navigator includes NavigatorPlugins;

Navigator includes NavigatorConcurrentHardware; These interface mixins are defined separately so that p1045 p967 WorkerNavigator can re-use parts of the Navigator interface.



8.9.1.1 Client identification p96 §

7

IDL interface mixin NavigatorID { ✔ MDN

readonly attribute DOMString appCodeName; // constant "Mozilla"

readonly attribute DOMString appName; // constant "Netscape"

readonly attribute DOMString appVersion;

readonly attribute DOMString platform;

readonly attribute DOMString product; // constant "Gecko"

[Exposed=Window] readonly attribute DOMString productSub;

readonly attribute DOMString userAgent;

[Exposed=Window] readonly attribute DOMString vendor;

[Exposed=Window] readonly attribute DOMString vendorSub; // constant ""

};

In certain cases, despite the best efforts of the entire industry, web browsers have bugs and limitations that web authors are forced to work around.

This section defines a collection of attributes that can be used to determine, from script, the kind of user agent in use, in order to work around these issues.

The user agent has a navigator compatibility mode, which is either Chrome, Gecko, or WebKit.

Note

The p967 p967 navigator compatibility mode constrains the NavigatorID interface to the combinations of attribute values and presence

of p969 p969 taintEnabled() and oscpu that are known to be compatible with existing web content.

Client detection should always be limited to detecting known current versions; future versions and unknown versions should always be assumed to be fully compliant.

For web developers (non-normative)

self p967 p968 . navigator . appCodeName

Returns the string "Mozilla".

self p967 p968 . navigator . appName

Returns the string "Netscape".

self p967 p968 . navigator . appVersion

Returns the version of the browser.

967

self p967 p968 . navigator . platform

Returns the name of the platform.

self p967 p968 . navigator . product

Returns the string "Gecko".

window p967 p968 . navigator . productSub

Returns either the string "20030107", or the string "20100101".

self p967 p968 . navigator . userAgent

Returns the complete `User-Agent` header.

window p967 p968 . navigator . vendor

Returns either the empty string, the string "Apple Computer, Inc.", or the string "Google Inc.".

window p967 p968 . navigator . vendorSub

Returns the empty string.

appCodeName

Must return the string "Mozilla".

appName

Must return the string "Netscape".

appVersion

Must return either the string "4.0" or a string representing the version of the browser in detail, e.g. "1.0 (VMS; en-US) Mellblomenator/9000".

platform

Must return either the empty string or a string representing the platform on which the browser is executing, e.g. "MacIntel", "Win32", "FreeBSD i386", "WebTV OS".

product

Must return the string "Gecko".

productSub

Must return the appropriate string from the following list:

↪ p967 If the navigator compatibility mode is Chrome or WebKit

The string "20030107".

↪ p967 If the navigator compatibility mode is Gecko

The string "20100101".

userAgent ✔ MDN

Must return the default `User-Agent` value.

vendor ✔ MDN

Must return the appropriate string from the following list:

↪ p967 If the navigator compatibility mode is Chrome

The string "Google Inc.".

↪ p967 If the navigator compatibility mode is Gecko

The empty string.

↪ p967 If the navigator compatibility mode is WebKit

The string "Apple Computer, Inc.".

vendorSub

Must return the empty string.



968

If the p967 navigator compatibility mode is Gecko, then the user agent must also support the following partial interface:

IDL partial interface mixin NavigatorID {

[Exposed=Window] boolean taintEnabled(); // constant false

[Exposed=Window] readonly attribute DOMString oscpu;

};

The taintEnabled() method must return false.

The oscpu attribute's getter must return either the empty string or a string representing the platform on which the browser is executing, e.g. "Windows NT 10.0; Win64; x64", "Linux x86_64".

⚠Warning!

Any information in this API that varies from user to user can be used to profile the user. In fact, if enough

such information is available, a user can actually be uniquely identified. For this reason, user agent

implementers are strongly urged to include as little information in this API as possible.



8.9.1.2 Language preferences p96 §

9

IDL ✔ interface mixin NavigatorLanguage { MDN

readonly attribute DOMString language;

readonly attribute FrozenArray languages;

};



For web developers (non-normative)

self p967 p969 . navigator . language

Returns a language tag representing the user's preferred language.

self p967 p969 . navigator . languages

Returns an array of language tags representing the user's preferred languages, with the most preferred language first.

The most preferred language is the one returned by p969 navigator.language .



Note

A p1271 p828 p1032 languagechange event is fired at the Window or WorkerGlobalScope object when the user agent's understanding of

what the user's preferred languages are changes.

language ✔ MDN

Must return a valid BCP 47 language tag representing either p969 a plausible language or the user's most preferred language.

[BCP47] p1275

languages ✔ MDN

Must return a p969 frozen array of valid BCP 47 language tags representing either one or more plausible languages , or the user's preferred languages, ordered by preference with the most preferred language first. The same object must be returned until the user

agent needs to return different values, or values in a different order. p1275 [BCP47]

Whenever the user agent needs to make the p969 p828 p1032 navigator.languages attribute of a Window or WorkerGlobalScope object

global p933 p939 return a new set of language tags, the user agent must queue a global task on the DOM manipulation task source

given p1271 global to fire an event named languagechange at global, and wait until that task begins to be executed before actually returning a new value.

To determine a plausible language, the user agent should bear in mind the following:

• Any information in this API that varies from user to user can be used to profile or identify the user.

• If the user is not using a service that obfuscates the user's point of origin (e.g. the Tor anonymity network), then the

value that is least likely to distinguish the user from other users with similar origins (e.g. from the same IP address

block) is the language used by the majority of such users. p1281 [TOR]

969

• If the user is using an anonymizing service, then the value "en-US" is suggested; if all users of the service use that same

value, that reduces the possibility of distinguishing the users from each other.

To avoid introducing any more fingerprinting vectors, user agents should use the same list for the APIs defined in this function as for the HTTP `Accept-Language` header.



✔ MDN

8.9.1.3 Browser state p97 §

0

IDL interface mixin NavigatorOnLine {

readonly attribute boolean onLine;

};



For web developers (non-normative)

self p967 p970 . navigator . onLine

Returns false if the user agent is definitely offline (disconnected from the network). Returns true if the user agent might be online.

The events p1272 p1272 online and offline are fired when the value of this attribute changes.



The navigator.onLine attribute must return false if the user agent will not contact the network when the user follows links or when a ✔ MDN script requests a remote page (or knows that such an attempt would fail), and must return true otherwise.

When the value that would be returned by the p970 p828 p1032 navigator.onLine attribute of a Window or WorkerGlobalScope global changes from true to false, the user agent must p933 p939 queue a global task on the networking task source given global to fire an event

named p1272 offline at global.

On the other hand, when the value that would be returned by the p970 p828 navigator.onLine attribute of a Window or

WorkerGlobalScope p1032 p933 global changes from false to true, the user agent must queue a global task on the networking task

source p939 p1272 p828 p1032 given global to fire an event named online at the Window or WorkerGlobalScope object.

Note

This attribute is inherently unreliable. A computer can be connected to a network without having Internet access.



Example

In this example, an indicator is updated as the browser goes online and offline.





Online status





The network is: (state unknown)





8.9.1.4 Custom scheme handlers: the p971 MDN p97 registerProtocolHandler() method §

0

IDL interface mixin NavigatorContentUtils {

[SecureContext] undefined registerProtocolHandler(DOMString scheme, USVString url);

[SecureContext] undefined unregisterProtocolHandler(DOMString scheme, USVString url);

970

};



For web developers (non-normative)

window p967 p971 . navigator . registerProtocolHandler (scheme, url)

Registers a handler for scheme at url. For example, an online telephone messaging service could register itself as a handler of

the p1281 sms: scheme, so that if the user clicks on such a link, they are given the opportunity to use that web site. [SMS] The string "%s" in url is used as a placeholder for where to put the URL of the content to be handled.

Throws a "SecurityError" DOMException if the user agent blocks the registration (this might happen if trying to register as a handler for "http", for instance).

Throws a "SyntaxError" DOMException if the "%s" string is missing in url.

window p967 p972 . navigator . unregisterProtocolHandler(scheme, url)

Unregisters the handler given by the arguments.

Throws a "SecurityError" DOMException if the user agent blocks the deregistration (this might happen if with invalid schemes, for instance).

Throws a "SyntaxError" DOMException if the "%s" string is missing in url.

The registerProtocolHandler(scheme, url) method steps are:

1. Let ( p972 normalizedScheme , normalizedURLString ) be the result of running normalize protocol handler parameters with

scheme p911 , url , and this 's relevant settings object.

2. p42 In parallel: register a handler for normalizedScheme and normalizedURLString. User agents may, within the constraints

described, do whatever they like. A user agent could, for instance, prompt the user and offer the user the opportunity to add the site to a shortlist of handlers, or make the handlers their default, or cancel the request. User agents could also silently collect the information, providing it only when relevant to the user.

User agents should keep track of which sites have registered handlers (even if the user has declined such registrations) so that the user is not repeatedly prompted with the same request.

When the user agent uses this handler for a URL inputURL:

1. Assert: inputURL's scheme is normalizedScheme.

2. Let inputURLString be the serialization of inputURL.

3. Let encodedURL be the result of running UTF-8 percent-encode on inputURLString using the component percent-

encode set.

4. Let handlerURLString be normalizedURLString.

5. Replace the first instance of "%s" in handlerURLString with encodedURL.

6. Let resultURL be the result of parsing handlerURLString.

7. p876 p814 Navigate an appropriate browsing context to resultURL.

Example

If the user had visited a site at https://example.com/ that made the following call:

navigator.registerProtocolHandler('web+soup', 'soup?url=%s')

...and then, much later, while visiting https://www.example.net/, clicked on a link such as:

Download our Chicken Kïwi soup!

...then the UA might navigate to the following URL:

https://example.com/soup?url=web+soup:chicken-k%C3%AFwi

This site could then do whatever it is that it does with soup (synthesize it and ship it to the user, or whatever).

971

This does not define when the handler is used. To some extent, the p876 processing model for navigating across documents defines some cases where it is relevant, but in general user agents may use this information wherever they would otherwise consider handing schemes to native plugins or helper applications.

The unregisterProtocolHandler(scheme, url) method steps are:

1. Let ( p972 normalizedScheme , normalizedURLString ) be the result of running normalize protocol handler parameters with

scheme p911 , url , and this 's relevant settings object.

2. p42 In parallel: unregister the handler described by normalizedScheme and normalizedURLString.



To p904 normalize protocol handler parameters , given a string scheme , a string url , and an environment settings object environment, run these steps:

1. Set scheme to scheme, converted to ASCII lowercase.

2. If p972 scheme is neither a safelisted scheme nor a string starting with "web+" followed by one or more ASCII lower alphas,

then throw a "SecurityError" DOMException.

Note

This means that including a colon in scheme (as in "mailto:") will throw.

The following schemes are the safelisted schemes:

◦ bitcoin

◦ geo

◦ im

◦ irc

◦ ircs

◦ magnet

◦ mailto

◦ mms

◦ news

◦ nntp

◦ openpgp4fpr

◦ sip

◦ sms

◦ smsto

◦ ssh

◦ tel

◦ urn

◦ webcal

◦ wtai

◦ xmpp

Note

This list can be changed. If there are schemes that ought to be added, please send feedback.

3. If url does not contain "%s", then throw a "SyntaxError" DOMException.

4. p89 Parse url relative to environment.

5. If that fails, then throw a "SyntaxError" DOMException.

Note

This is forcibly the case if the %s placeholder is in the host or port of the URL.

6. If the p89 p89 p842 resulting URL record 's scheme is not " https " or the resulting URL record 's origin is not same origin with

environment p904 's origin , then throw a "SecurityError" DOMException.

7. Return ( p89 scheme , resulting URL string).

Note

The p89 resulting URL string will by definition not be a valid URL string as it includes the string "%s" which is not a valid component in a URL.



972

8.9.1.4.1 Security and privacy p97 §

3

Custom scheme handlers can introduce a number of concerns, in particular privacy concerns.

Hijacking all web usage. User agents should not allow schemes that are key to its normal operation, such as an HTTP(S) scheme, to be rerouted through third-party sites. This would allow a user's activities to be trivially tracked, and would allow user information, even in secure connections, to be collected.

Hijacking defaults. User agents are strongly urged to not automatically change any defaults, as this could lead the user to send data to remote hosts that the user is not expecting. New handlers registering themselves should never automatically cause those sites to be used.

Registration spamming. User agents should consider the possibility that a site will attempt to register a large number of handlers, possibly from multiple domains (e.g., by redirecting through a series of pages each on a different domain, and each registering a handler for web+spam: — analogous practices abusing other web browser features have been used by pornography web sites for many years). User agents should gracefully handle such hostile attempts, protecting the user.

Hostile handler metadata. User agents should protect against typical attacks against strings embedded in their interface, for example ensuring that markup or escape characters in such strings are not executed, that null bytes are properly handled, that over-long strings do not cause crashes or buffer overruns, and so forth.

Leaking private data. Web page authors may reference a custom scheme handler using URL data considered private. They might do so with the expectation that the user's choice of handler points to a page inside the organization, ensuring that sensitive data will not be exposed to third parties. However, a user may have registered a handler pointing to an external site, resulting in a data leak to that third party. Implementors might wish to consider allowing administrators to disable custom handlers on certain subdomains, content types, or schemes.

Leaking credentials. User agents must never send username or password information in the URLs that are escaped and included sent to the handler sites. User agents may even avoid attempting to pass to web-based handlers the URLs of resources that are known to require authentication to access, as such sites would be unable to access the resources in question without prompting the user for credentials themselves (a practice that would require the user to know whether to trust the third-party handler, a decision many users are unable to make or even understand).

Interface interference. User agents should be prepared to handle intentionally long arguments to the methods. For example, if the user interface exposed consists of an "accept" button and a "deny" button, with the "accept" binding containing the name of the handler, it's important that a long name not cause the "deny" button to be pushed off the screen.



8.9.1.5 Cookies p97 §

3

IDL interface mixin NavigatorCookies {

readonly attribute boolean cookieEnabled;

};



For web developers (non-normative)

window p967 p973 . navigator . cookieEnabled

Returns false if setting a cookie will be ignored, and true otherwise.



The cookieEnabled attribute must return true if the user agent attempts to handle cookies according to HTTP State Management ✔ MDN p1275 Mechanism , and false if it ignores cookie change requests. [COOKIES]



8.9.1.6 Plugins p97 §

3

IDL ✔ interface mixin NavigatorPlugins { MDN

[SameObject] readonly attribute PluginArray plugins;

[SameObject] readonly attribute MimeTypeArray mimeTypes;

boolean javaEnabled();

};



973

[Exposed=Window,

LegacyUnenumerableNamedProperties]

interface PluginArray {

undefined refresh(optional boolean reload = false);

readonly attribute unsigned long length;

getter Plugin? item(unsigned long index);

getter Plugin? namedItem(DOMString name);

};

[Exposed=Window,

LegacyUnenumerableNamedProperties]

interface MimeTypeArray {

readonly attribute unsigned long length;

getter MimeType? item(unsigned long index);

getter MimeType? namedItem(DOMString name);

};

[Exposed=Window,

LegacyUnenumerableNamedProperties]

interface Plugin {

readonly attribute DOMString name;

readonly attribute DOMString description;

readonly attribute DOMString filename;

readonly attribute unsigned long length;

getter MimeType? item(unsigned long index);

getter MimeType? namedItem(DOMString name);

};

[Exposed=Window]

interface MimeType {

readonly attribute DOMString type;

readonly attribute DOMString description;

readonly attribute DOMString suffixes; // comma-separated

readonly attribute Plugin enabledPlugin;

};



For web developers (non-normative)

window p967 p975 p976 . navigator . plugins . refresh( [ refresh ] )

Updates the lists of supported plugins and MIME types for this page, and reloads the page if the lists have changed.

window p967 p975 p976 . navigator . plugins . length

Returns the number of plugins, represented by p974 Plugin objects, that the user agent reports.

plugin p967 p975 p976 = window . navigator . plugins . item(index)

window p967 p975 . navigator . plugins[index]

Returns the specified p974 Plugin object.

plugin p967 p975 p976 = window . navigator . plugins . item(name)

window p967 p975 . navigator . plugins[name]

Returns the p974 Plugin object for the plugin with the given name.

window p967 p975 p976 . navigator . mimeTypes . length

Returns the number of MIME types, represented by p974 MimeType objects, supported by the plugins that the user agent reports.

mimeType p967 p975 p976 = window . navigator . mimeTypes . item(index)

window p967 p975 . navigator . mimeTypes [index]

Returns the specified p974 MimeType object.

mimeType p967 p975 p976 = window . navigator . mimeTypes . item(name)

window p967 p975 . navigator . mimeTypes [name]

Returns the p974 MimeType object for the given MIME type.

974

plugin p977 . name

Returns the plugin's name.

plugin p977 . description

Returns the plugin's description.

plugin p977 . filename

Returns the plugin library's filename, if applicable on the current platform.

plugin p977 . length

Returns the number of MIME types, represented by p974 MimeType objects, supported by the plugin.

mimeType p977 = plugin . item(index)

plugin[index]

Returns the specified p974 MimeType object.

mimeType p977 = plugin . item(name)

plugin[name]

Returns the p974 MimeType object for the given MIME type.

mimeType p978 . type

Returns the MIME type.

mimeType p978 . description

Returns the MIME type's description.

mimeType p978 . suffixes

Returns the MIME type's typical file extensions, in a comma-separated list.

mimeType p978 . enabledPlugin

Returns the p974 Plugin object that implements this MIME type.

window p967 p978 . navigator . javaEnabled()

Returns true if there's a plugin that supports the MIME type "application/x-java-vm".

⚠ MDN

The p974 navigator.plugins attribute must return a PluginArray object. ⚠ MDN

The p974 navigator.mimeTypes attribute must return a MimeTypeArray object.



A p974 p45 PluginArray object represents none, some, or all of the plugins supported by the user agent, each of which is represented by a p974 p974 p975 Plugin object. Each of these Plugin objects may be hidden plugins . A hidden plugin can't be enumerated, but can still be inspected by using its name.

Note

The fewer p45 p974 p975 plugins are represented by the PluginArray object, and of those, the more that are hidden, the more the

user's privacy will be protected. Each exposed plugin increases the number of bits that can be derived for fingerprinting. Hiding a

plugin helps, but unless it is an extremely rare plugin, it is likely that a site attempting to derive the list of plugins can still

determine whether the plugin is supported or not by probing for it by name (the names of popular plugins are widely known).

Therefore not exposing a plugin at all is preferred. Unfortunately, many legacy sites use this feature to determine, for example,

which plugin to use to play video. Not exposing any plugins at all might therefore not be entirely plausible.

The p974 p45 PluginArray objects created by a user agent must not be live. The set of plugins represented by the objects must not change once an object is created, except when it is updated by the p976 refresh() method.

Each p45 p974 p45 plugin represented by a PluginArray can support a number of MIME types . For each such plugin, the user agent must

pick one or more of these MIME types to be those that are explicitly supported.

Note

The p975 p45 p974 p974 explicitly supported MIME types of a plugin are those that are exposed through the Plugin and MimeTypeArray

interfaces. As with p45 plugins themselves, any variation between users regarding what is exposed allows sites to fingerprint users.

User agents are therefore encouraged to expose the same p45 MIME types for all users of a plugin, regardless of the actual types

975

supported... at least, within the constraints imposed by compatibility with legacy content.

The p974 p975 supported property indices of a PluginArray object are the numbers from zero to the number of non-hidden

plugins p45 represented by the object, if any.

The p975 p45 length attribute must return the number of non-hidden plugins represented by the object.

The p974 item() method of a PluginArray object must return null if the argument is not one of the object's supported

property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

1. Let p974 p975 p45 p974 list be the Plugin objects representing the non-hidden plugins represented by the PluginArray object.

2. Sort p977 p974 list alphabetically by the name of each Plugin.

3. Return the indexth entry in list.

Note

It is important for privacy that the order of plugins not leak additional information, e.g., the order in which plugins were installed.

The p974 p977 p974 supported property names of a PluginArray object are the values of the name attributes of all the Plugin

objects represented by the p974 PluginArray object.

The p974 namedItem() method of a PluginArray object must return null if the argument is not one of the object's supported

property names p974 p974 , and otherwise must return the Plugin object, of those represented by the PluginArray object, that has a p977 name equal to the method's argument.

The p974 p967 p45 refresh() method of the PluginArray object of a Navigator object, when invoked, must check to see if any plugins

have been installed or reconfigured since the user agent created the p974 PluginArray object. If so, and the method's argument is true, then the user agent must act as if the p873 location.reload() method was called instead. Otherwise, the user agent must update the

PluginArray p974 p974 p967 p974 object and MimeTypeArray object created for attributes of that Navigator object, and the Plugin and

MimeType p974 p974 p974 p974 objects created for those PluginArray and MimeTypeArray objects, using the same Plugin objects for cases where the p977 p974 p978 name is the same, and the same MimeType objects for cases where the type is the same, and creating new objects for cases where there were no matching objects immediately prior to the p976 p974 p974 refresh() call. Old Plugin and MimeType objects must continue to return the same values that they had prior to the update, though naturally now the data is stale and may appear inconsistent (for example, an old p974 p978 p974 MimeType entry might list as its enabledPlugin a Plugin object that no longer lists that

MimeType p974 p974 as a supported MimeType ).



A p974 p975 p45 MimeTypeArray object represents the MIME types explicitly supported by plugins supported by the user agent, each of which is represented by a p974 MimeType object.

The p974 p45 MimeTypeArray objects created by a user agent must not be live. The set of MIME types represented by the objects must not change once an object is created, except when it is updated by the p974 p976 PluginArray object's refresh() method.

The p974 supported property indices of a MimeTypeArray object are the numbers from zero to the number of MIME types

explicitly supported p975 p975 p45 p974 by non-hidden plugins represented by the corresponding PluginArray object, if any.

The p975 p975 p45 length attribute must return the number of MIME types explicitly supported by non-hidden plugins

represented by the corresponding p974 PluginArray object, if any.

The p974 item() method of a MimeTypeArray object must return null if the argument is not one of the object's

supported property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

1. Let p974 p975 p975 p45 list be the MimeType objects representing the MIME types explicitly supported by non-hidden plugins

represented by the corresponding p974 PluginArray object, if any.

2. Sort p978 p974 list alphabetically by the type of each MimeType.

3. Return the indexth entry in list.



976

Note

It is important for privacy that the order of MIME types not leak additional information, e.g., the order in which plugins were

installed.

The p974 p978 p974 supported property names of a MimeTypeArray object are the values of the type attributes of all the MimeType

objects represented by the p974 MimeTypeArray object.

The p974 namedItem() method of a MimeTypeArray object must return null if the argument is not one of the object's supported

property names p974 p978 , and otherwise must return the MimeType object that has a type equal to the method's argument.



A p974 p45 Plugin object represents a plugin. It has several attributes to provide details about the plugin, and can be enumerated to obtain the list of p975 MIME types that it explicitly supports.

The p974 p45 Plugin objects created by a user agent must not be live. The set of MIME types represented by the objects, and the values of the objects' attributes, must not change once an object is created, except when updated by the p974 PluginArray object's

refresh() p976 method.

The p974 p975 p45 reported MIME types for a Plugin object are the MIME types explicitly supported by the corresponding plugin when this object was last created or updated by p976 refresh() , whichever happened most recently.

The p974 p977 supported property indices of a Plugin object are the numbers from zero to the number of reported MIME types.

The p977 length attribute must return the number of reported MIME types.

The p974 item() method of a Plugin object must return null if the argument is not one of the object's supported

property indices, and otherwise must return the result of running the following steps, using the method's argument as index:

1. Let p974 p977 list be the MimeType objects representing the reported MIME types.

2. Sort p978 p974 list alphabetically by the type of each MimeType.

3. Return the indexth entry in list.

Note

It is important for privacy that the order of MIME types not leak additional information, e.g., the order in which plugins were

installed.

The p974 p978 p974 supported property names of a Plugin object are the values of the type attributes of the MimeType objects representing the p977 reported MIME types.

The p974 namedItem() method of a Plugin object must return null if the argument is not one of the object's supported property

names p974 p978 , and otherwise must return the MimeType object that has a type equal to the method's argument.

The p45 name attribute must return the plugin's name.

The p45 description and filename attributes must return implementation-defined (in all likelihood, plugin-defined) strings. In each

case, the same string must be returned each time, except that the strings returned may change when the p976 refresh() method updates the object.

⚠Warning!

If the values returned by the p977 p977 p45 description or filename attributes vary between versions of a plugin ,

they can be used both as a fingerprinting vector and, even more importantly, as a trivial way to determine

what security vulnerabilities a p45 plugin (and thus a browser) may have. It is thus highly recommended that

the p977 p977 p977 description attribute just return the same value as the name attribute, and that the filename

attribute return the empty string.



A p974 p975 p45 MimeType object represents a MIME type that is, or was, explicitly supported by a plugin.

The p974 p45 MimeType objects created by a user agent must not be live. The values of the objects' attributes must not change once an

977

object is created, except when updated by the p974 p976 PluginArray object's refresh() method.

The type attribute must return the valid MIME type string with no parameters describing the MIME type.

The p45 description and suffixes attributes must return implementation-defined (in all likelihood, plugin-defined) strings. In each

case, the same string must be returned each time, except that the strings returned may change when the p976 refresh() method updates the object.

⚠Warning!

If the values returned by the p978 p978 p45 description or suffixes attributes vary between versions of a plugin ,

they can be used both as a fingerprinting vector and, even more importantly, as a trivial way to determine

what security vulnerabilities a p45 plugin (and thus a browser) may have. It is thus highly recommended that

the p978 p978 p978 description attribute just return the same value as the type attribute, and that the suffixes

attribute return the empty string.



Note

Commas in the p978 suffixes attribute are interpreted as separating subsequent filename extensions, as in "htm,html".

The p974 p45 p975 enabledPlugin attribute must return the Plugin object that represents the plugin that explicitly supported the MIME

type p974 p976 that this MimeType object represents when this object was last created or updated by refresh(), whichever happened most recently.



The p45 navigator.javaEnabled() method must return true if the user agent supports a plugin that supports the MIME type ⚠ MDN "application/x-java-vm"; otherwise it must return false.



8.10 Images p97 §

8

IDL MDN [ Exposed =( Window , Worker ), Serializable , Transferable ]

interface ImageBitmap {

readonly attribute unsigned long width;

readonly attribute unsigned long height;

undefined close();

};

typedef (CanvasImageSource or

Blob or

ImageData) ImageBitmapSource;

enum ImageOrientation { "none", "flipY" };

enum PremultiplyAlpha { "none", "premultiply", "default" };

enum ColorSpaceConversion { "none", "default" };

enum ResizeQuality { "pixelated", "low", "medium", "high" };

dictionary ImageBitmapOptions {

ImageOrientation imageOrientation = "none";

PremultiplyAlpha premultiplyAlpha = "default";

ColorSpaceConversion colorSpaceConversion = "default";

[EnforceRange] unsigned long resizeWidth;

[EnforceRange] unsigned long resizeHeight;

ResizeQuality resizeQuality = "low";

};

An p978 ImageBitmap object represents a bitmap image that can be painted to a canvas without undue latency.

Note

The exact judgement of what is undue latency of this is left up to the implementer, but in general if making use of the bitmap 978

requires network I/O, or even local disk I/O, then the latency is probably undue; whereas if it only requires a blocking read from a

GPU or system RAM, the latency is probably acceptable.



For web developers (non-normative)

promise p980 = self . createImageBitmap(image [, options ])

promise p980 = self . createImageBitmap(image, sx, sy, sw, sh [, options ])

Takes p321 p380 p635 image , which can be an img element, an SVG image element, a video element, a canvas element, a Blob

object, an p643 p978 ImageData object, or another ImageBitmap object, and returns a promise that is resolved when a new

ImageBitmap p978 is created.

If no p978 ImageBitmap object can be constructed, for example because the provided image data is not actually an image, then the promise is rejected instead.

If sx, sy, sw, and sh arguments are provided, the source image is cropped to the given pixels, with any pixels missing in the

original replaced by transparent black. These coordinates are in the source image's pixel coordinate space, not in CSS pixels.

If p978 options is provided, the ImageBitmap object's bitmap data is modified according to options. For example, if the

premultiplyAlpha p982 p982 p979 option is set to " premultiply ", the bitmap data 's color channels are premultiplied by its alpha channel.

Rejects the promise with an p321 " InvalidStateError " DOMException if the source image is not in a valid state (e.g., an img

element that hasn't loaded successfully, an p978 p104 ImageBitmap object whose [[Detached]] internal slot value is true, an

ImageData p643 p677 object whose data attribute value's [[ViewedArrayBuffer]] internal slot is detached, or a Blob whose data cannot be interpreted as a bitmap image).

Rejects the promise with a "SecurityError" DOMException if the script is not allowed to access the image data of the source

image (e.g. a p380 p90 p635 video that is CORS-cross-origin , or a canvas being drawn on by a script in a worker from another

origin p841 ).

imageBitmap p982 . close()

Releases p979 imageBitmap 's underlying bitmap data.

imageBitmap p982 . width

Returns the intrinsic width of the image, in CSS pixels.

imageBitmap p983 . height

Returns the intrinsic height of the image, in CSS pixels.

An p978 p104 ImageBitmap object whose [[Detached]] internal slot value is false always has associated bitmap data, with a width and a height. However, it is possible for this data to be corrupted. If an p978 ImageBitmap object's media data can be decoded without errors, it is said to be fully decodable.

An p978 p636 ImageBitmap object's bitmap has an origin-clean flag, which indicates whether the bitmap is tainted by content from a different p841 p980 origin . The flag is initially set to true and may be changed to false by the steps of createImageBitmap() .



ImageBitmap p978 p103 p104 objects are serializable objects and transferable objects.

Their p103 serialization steps, given value and serialized, are:

1. If p636 value 's origin-clean flag is not set, then throw a "DataCloneError" DOMException.

2. Set p979 serialized .[[BitmapData]] to a copy of value 's bitmap data.

Their p103 deserialization steps, given serialized and value, are:

1. Set p979 value 's bitmap data to serialized.[[BitmapData]].

Their p104 transfer steps, given value and dataHolder, are:

1. If p636 value 's origin-clean flag is not set, then throw a "DataCloneError" DOMException.

2. Set p979 dataHolder .[[BitmapData]] to value 's bitmap data .

3. Unset p979 value 's bitmap data.

979

Their p104 transfer-receiving steps, given dataHolder and value, are:

1. Set p979 value 's bitmap data to dataHolder.[[BitmapData]].



The createImageBitmap(image, options) and createImageBitmap(image sx, sy, sw, sh, options) methods, when invoked, MDN must run these steps:

1. Let p be a new promise.

2. If either sw or sh is given and is 0, then return p rejected with a RangeError.

3. If either options's resizeWidth or options's resizeHeight is present and is 0, then return p rejected with an

"InvalidStateError" DOMException.

4. p663 Check the usability of the image argument. If this throws an exception or returns bad, then return p rejected with an

"InvalidStateError" DOMException.

5. Let p978 imageBitmap be a new ImageBitmap object.

6. Switch on image:

↪ p321 img

↪ SVG image

1. If image's media data has no intrinsic dimensions (e.g., it's a vector graphic with no specified content size)

and either p980 p980 options 's resizeWidth or options 's resizeHeight is not present, then return p rejected

with an "InvalidStateError" DOMException.

2. If image's media data has no intrinsic dimensions (e.g., it's a vector graphics with no specified content size),

it should be rendered to a bitmap of the size specified by the p980 p980 resizeWidth and the resizeHeight

options.

3. Set p979 imageBitmap 's bitmap data to a copy of image's media data, cropped to the source rectangle with

formatting p981 p979 . If this is an animated image, imageBitmap 's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.

4. If the p841 p842 p908 p904 origin of image 's image is not same origin with entry settings object 's origin , then set the

origin-clean p636 flag of imageBitmap's bitmap to false.

5. Run this step p42 in parallel:

1. Resolve p with imageBitmap.

↪ p380 video

1. If p392 p392 image 's networkState attribute is NETWORK_EMPTY, then return p rejected with an

"InvalidStateError" DOMException.

2. Set p979 p404 imageBitmap 's bitmap data to a copy of the frame at the current playback position , at the media

resource p389 p383 p383 's intrinsic width and intrinsic height (i.e., after any aspect-ratio correction has been

applied), p981 cropped to the source rectangle with formatting .

3. If the p841 p842 p908 p904 origin of image 's video is not same origin with entry settings object 's origin, then set the

origin-clean p636 flag of imageBitmap's bitmap to false.

4. Run this step p42 in parallel:

1. Resolve p with imageBitmap.

↪ p635 canvas

1. Set p979 p979 imageBitmap 's bitmap data to a copy of image 's bitmap data, cropped to the source rectangle

with formatting p981.

2. Set the p636 p636 origin-clean flag of the imageBitmap 's bitmap to the same value as the origin-clean flag of

image's bitmap.

980

3. Run this step p42 in parallel:

1. Resolve p with imageBitmap.

↪ Blob

Run these step p42 in parallel:

1. Let p57 imageData be the result of reading image 's data. If an error occurs during reading of the object, then

reject p with an "InvalidStateError" DOMException and abort these steps.

2. Apply the image sniffing rules to determine the file format of imageData, with MIME type of image (as given

by image's type attribute) giving the official type.

3. If imageData is not in a supported image file format (e.g., it's not an image at all), or if imageData is

corrupted in some fatal way such that the image dimensions cannot be obtained (e.g., a vector graphic with

no intrinsic size), then reject p with an "InvalidStateError" DOMException and abort these steps.

4. Set p979 p981 imageBitmap 's bitmap data to imageData , cropped to the source rectangle with formatting. If this

is an animated image, p979 imageBitmap 's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.

5. Resolve p with imageBitmap.

↪ p643 ImageData

1. Let p677 buffer be image 's data attribute value's [[ViewedArrayBuffer]] internal slot.

2. If IsDetachedBuffer(buffer) is true, then return p rejected with an "InvalidStateError" DOMException.

3. Set p979 imageBitmap 's bitmap data to image's image data, cropped to the source rectangle with

formatting p981 .

4. Run this step p42 in parallel:

1. Resolve p with imageBitmap.

↪ p978 ImageBitmap

1. Set p979 p979 imageBitmap 's bitmap data to a copy of image 's bitmap data, cropped to the source rectangle

with formatting p981.

2. Set the p636 p636 origin-clean flag of imageBitmap 's bitmap to the same value as the origin-clean flag of

image's bitmap.

3. Run this step p42 in parallel:

1. Resolve p with imageBitmap.

7. Return p.

When the steps above require that the user agent crop bitmap data to the source rectangle with formatting, the user agent must run the following steps:

1. Let p979 input be the bitmap data being transformed.

2. If sx, sy, sw and sh are specified, let sourceRectangle be a rectangle whose corners are the four points (sx, sy), (sx+sw,

sy),(sx+sw, sy+sh), (sx,sy+sh). Otherwise let sourceRectangle be a rectangle whose corners are the four points (0,0), (width of input, 0), (width of input, height of input), (0, height of input).

Note

If either sw or sh are negative, then the top-left corner of this rectangle will be to the left or above the (sx, sy) point.

3. Clip sourceRectangle to the dimensions of input.

4. Let outputWidth be determined as follows:

↪ p980 If the resizeWidth member of options is specified

the value of the p980 resizeWidth member of options

981

↪ p980 p980 If the resizeWidth member of options is not specified, but the resizeHeight member is specified

the width of p980 sourceRectangle , times the value of the resizeHeight member of options, divided by the height of sourceRectangle, rounded up to the nearest integer

↪ p980 p980 If neither resizeWidth nor resizeHeight are specified

the width of sourceRectangle

5. Let outputHeight be determined as follows:

↪ p980 If the resizeHeight member of options is specified

the value of the p980 resizeHeight member of options

↪ p980 p980 If the resizeHeight member of options is not specified, but the resizeWidth member is specified

the height of p980 sourceRectangle , times the value of the resizeWidth member of options, divided by the width of sourceRectangle, rounded up to the nearest integer

↪ p980 p980 If neither resizeWidth nor resizeHeight are specified

the height of sourceRectangle

6. Place input on an infinite transparent black grid plane, positioned so that its top left corner is at the origin of the plane, with

the x-coordinate increasing to the right, and the y-coordinate increasing down, and with each pixel in the input image data occupying a cell on the plane's grid.

7. Let output be the rectangle on the plane denoted by sourceRectangle.

8. Scale output to the size specified by outputWidth and outputHeight. The user agent should use the value of the

resizeQuality option to guide the choice of scaling algorithm.

9. If the value of the imageOrientation member of options is "flipY", output must be flipped vertically, disregarding any

image orientation metadata of the source (such as EXIF metadata), if any. p1277 [EXIF]

Note

If the value is "none", no extra step is required.

10. If p321 image is an img element or a Blob object, let val be the value of the colorSpaceConversion member of options, and

then run these substeps:

1. If val is "default", the color space conversion behavior is implementation-specific, and should be chosen according

to the color space that the implementation uses for drawing images onto the canvas.

2. If val is "none", output must be decoded without performing any color space conversions. This means that the

image decoding algorithm must ignore color profile metadata embedded in the source data as well as the display device color profile.

Note

The native color space of canvas is currently unspecified, but this is expected to change in the future.

11. Let val be the value of premultiplyAlpha member of options, and then run these substeps:

1. If val is "default", the alpha premultiplication behavior is implementation-specific, and should be chosen

according to implementation deems optimal for drawing images onto the canvas.

2. If val is "premultiply", the output that is not premultiplied by alpha must have its color components multiplied by

alpha and that is premultiplied by alpha must be left untouched.

3. If val is "none", the output that is not premultiplied by alpha must be left untouched and that is premultiplied by

alpha must have its color components divided by alpha.

12. Return output.

When the close() method is called, the user agent must run these steps: MDN

1. Set this p978 p104 ImageBitmap object's [[Detached]] internal slot value to true.

2. Unset this p978 p979 ImageBitmap object's bitmap data.

The width attribute's getter must run these steps: MDN

982

1. If this p978 p104 ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.

2. Return this p978 ImageBitmap object's width, in CSS pixels.

The height attribute's getter must run these steps: MDN

1. If this p978 p104 ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.

2. Return this p978 ImageBitmap object's height, in CSS pixels.

The p978 ResizeQuality enumeration is used to express a preference for the interpolation quality to use when scaling images.

The "pixelated" value indicates a preference to scale the image that maximizes the appearance. Scaling algorithms that "smooth" colors are acceptable, such as bilinear interpolation.

The "low" value indicates a preference for a low level of image interpolation quality. Low-quality image interpolation may be more computationally efficient than higher settings.

The "medium" value indicates a preference for a medium level of image interpolation quality.

The "high" value indicates a preference for a high level of image interpolation quality. High-quality image interpolation may be more computationally expensive than lower settings.

Note

Bilinear scaling is an example of a relatively fast, lower-quality image-smoothing algorithm. Bicubic or Lanczos scaling are

examples of image-scaling algorithms that produce higher-quality output. This specification does not mandate that specific

interpolation algorithms be used unless the value is " p983 pixelated".



Example

Using this API, a sprite sheet can be precut and prepared:

var sprites = {};

function loadMySprites() {

var image = new Image();

image.src = 'mysprites.png';

var resolver;

var promise = new Promise(function (arg) { resolver = arg });

image.onload = function () {

resolver(Promise.all([

createImageBitmap(image, 0, 0, 40, 40).then(function (image) { sprites.person = image }), createImageBitmap(image, 40, 0, 40, 40).then(function (image) { sprites.grass = image }), createImageBitmap(image, 80, 0, 40, 40).then(function (image) { sprites.tree = image }), createImageBitmap(image, 0, 40, 40, 40).then(function (image) { sprites.hut = image }), createImageBitmap(image, 40, 40, 40, 40).then(function (image) { sprites.apple = image }), createImageBitmap(image, 80, 40, 40, 40).then(function (image) { sprites.snake = image })

]));

};

return promise;

}

function runDemo() {

var canvas = document.querySelector('canvas#demo');

var context = canvas.getContext('2d');

context.drawImage(sprites.tree, 30, 10);

context.drawImage(sprites.snake, 70, 10);

}

loadMySprites().then(runDemo);



983

✔ MDN

8.11 Animation frames p98 §

4

Some objects include the p984 AnimationFrameProvider interface mixin.

IDL callback FrameRequestCallback = undefined (DOMHighResTimeStamp time);

interface mixin AnimationFrameProvider {

unsigned long requestAnimationFrame(FrameRequestCallback callback);

undefined cancelAnimationFrame(unsigned long handle);

};

Window includes AnimationFrameProvider;

DedicatedWorkerGlobalScope includes AnimationFrameProvider;

Each p984 AnimationFrameProvider object also has a target object that stores the provider's internal state. It is defined as follows: If the p984 p828 AnimationFrameProvider is a Window

The p828 p829 Window 's associated Document

If the p984 p1034 AnimationFrameProvider is a DedicatedWorkerGlobalScope

The p1034 DedicatedWorkerGlobalScope

Each p984 target object has a map of animation frame callbacks, which is an ordered map that must be initially empty, and an animation frame callback identifier, which is a number that must initially be zero.

An p984 AnimationFrameProvider provider is considered supported if any of the following hold:

• p828 provider is a Window .

• p1033 p115 provider 's owner set contains a Document object.

• Any of the p1034 p1033 p984 DedicatedWorkerGlobalScope objects in provider 's owner set are supported.



The requestAnimationFrame(callback) method must run the following steps:

1. If this p984 p984 AnimationFrameProvider is not supported, then throw a "NotSupportedError" DOMException.

2. Let p984 p984 target be this AnimationFrameProvider 's target object.

3. Increment p984 target 's animation frame callback identifier by one, and let handle be the result.

4. Let p984 callbacks be target 's map of animation frame callbacks .

5. Set callbacks[handle] to callback.

6. Return handle.

The cancelAnimationFrame(handle) method must run the following steps: ✔ MDN

1. If this p984 p984 AnimationFrameProvider is not supported, then throw a "NotSupportedError" DOMException.

2. Let p984 p984 p984 callbacks be this AnimationFrameProvider 's target object 's map of animation frame callbacks.

3. Remove callbacks[handle].

To p984 run the animation frame callbacks for a target object target with a timestamp now:

1. Let p984 callbacks be target 's map of animation frame callbacks .

2. Let callbackHandles be the result of getting the keys of callbacks.

3. For each handle in callbackHandles, if handle exists in callbacks:

1. Let callback be callbacks[handle].

2. Remove callbacks[handle].

3. p924 Invoke callback , passing now as the only argument, and if an exception is thrown, report the exception .



984

Example

Inside workers, p984 p690 p635 requestAnimationFrame() can be used together with an OffscreenCanvas transferred from a canvas

element. First, in the document, transfer control to the worker:

const offscreenCanvas = document.getElementById("c").transferControlToOffscreen(); worker.postMessage(offscreenCanvas, [offscreenCanvas]);

Then, in the worker, the following code will draw a rectangle moving from left to right:

let ctx, pos = 0;

function draw(dt) {

ctx.clearRect(0, 0, 100, 100);

ctx.fillRect(pos, 0, 10, 10);

pos += 10 * dt;

requestAnimationFrame(draw);

}

self.onmessage = function(ev) {

const transferredCanvas = ev.data;

ctx = transferredCanvas.getContext("2d");

draw();

};



985

9 Communication p98 §

6

9.1 The p986 p98 MessageEvent interface §

6

Messages in p987 p996 p1004 p1006 server-sent events , web sockets , cross-document messaging , channel messaging, and broadcast ✔ MDN

channels p1013 p986 p1271 use the MessageEvent interface for their message events:

IDL [Exposed=(Window,Worker,AudioWorklet)]

interface MessageEvent : Event {

constructor(DOMString type, optional MessageEventInit eventInitDict = {});

readonly attribute any data;

readonly attribute USVString origin;

readonly attribute DOMString lastEventId;

readonly attribute MessageEventSource? source;

readonly attribute FrozenArray<MessagePort> ports;

undefined initMessageEvent(DOMString type, optional boolean bubbles = false, optional boolean

cancelable = false, optional any data = null, optional USVString origin = "", optional DOMString

lastEventId = "", optional MessageEventSource? source = null, optional sequence<MessagePort> ports = []);

};

dictionary MessageEventInit : EventInit {

any data = null;

USVString origin = "";

DOMString lastEventId = "";

MessageEventSource? source = null;

sequence<MessagePort> ports = [];

};

typedef (WindowProxy or MessagePort or ServiceWorker) MessageEventSource;



For web developers (non-normative)

event p986 . data

Returns the data of the message.

event p986 . origin

Returns the origin of the message, for p987 p1004 server-sent events and cross-document messaging.

event p986 . lastEventId

Returns the p988 p987 last event ID string , for server-sent events .

event p987 . source

Returns the p837 p1004 p1010 WindowProxy of the source window, for cross-document messaging , and the MessagePort being

attached, in the p1271 p1035 connect event fired at SharedWorkerGlobalScope objects.

event p987 . ports

Returns the p1010 p1004 p1006 MessagePort array sent with the message, for cross-document messaging and channel messaging.

✔ MDN

The data attribute must return the value it was initialized to. It represents the message being sent. ✔ MDN

The p987 origin attribute must return the value it was initialized to. It represents, in server-sent events and cross-document

messaging p1004 p841 , the origin of the document that sent the message (typically the scheme, hostname, and port of the document, but ✔ MDN

not its path or fragment).

The p987 p988 lastEventId attribute must return the value it was initialized to. It represents, in server-sent events , the last event ID string ✔ MDN

of the event source.

986

The p1004 p837 source attribute must return the value it was initialized to. It represents, in cross-document messaging , the WindowProxy of

the p814 p828 p1271 browsing context of the Window object from which the message came; and in the connect events used by shared ✔ MDN

workers p1035 p1010 , the newly connecting MessagePort.

The p1004 ports attribute must return the value it was initialized to. It represents, in cross-document messaging and channel

messaging p1006 p1010 , the MessagePort array being sent.

The initMessageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method.

[DOM] p1277

Note

Various APIs (e.g., p996 p988 p986 p1271 WebSocket , EventSource ) use the MessageEvent interface for their message event without using

the p1010 MessagePort API.



✔ MDN

9.2 Server-sent events p98 §

7



9.2.1 Introduction p98 §

7

This section is non-normative.

To enable servers to push data to web pages over HTTP or using dedicated server-push protocols, this specification introduces the

EventSource p988 interface.

Using this API consists of creating an p988 EventSource object and registering an event listener.

var source = new EventSource('updates.cgi');

source.onmessage = function (event) {

alert(event.data);

};

On the server-side, the script (" p1246 updates.cgi " in this case) sends messages in the following form, with the text/event-stream

MIME type:

data: This is the first message.

data: This is the second message, it

data: has two lines.

data: This is the third message.



Authors can separate events by using different event types. Here is a stream that has two event types, "add" and "remove":

event: add

data: 73857293

event: remove

data: 2153

event: add

data: 113411

The script to handle such a stream would look like this (where addHandler and removeHandler are functions that take one argument, the event):

var source = new EventSource('updates.cgi');

source.addEventListener('add', addHandler, false);

987

source.addEventListener('remove', removeHandler, false); The default event type is "message".

Event streams are always decoded as UTF-8. There is no way to specify another character encoding.



Event stream requests can be redirected using HTTP 301 and 307 redirects as with normal HTTP requests. Clients will reconnect if the connection is closed; a client can be told to stop reconnecting using the HTTP 204 No Content response code.

Using this API rather than emulating it using p362 XMLHttpRequest or an iframe allows the user agent to make better use of network resources in cases where the user agent implementer and the network operator are able to coordinate in advance. Amongst other benefits, this can result in significant savings in battery life on portable devices. This is discussed further in the section below on

connectionless push p994 .



9.2.2 The p988 ✔ MDN p98 EventSource interface §

8

IDL [Exposed=(Window,Worker)]

interface EventSource : EventTarget {

constructor(USVString url, optional EventSourceInit eventSourceInitDict = {});

readonly attribute USVString url;

readonly attribute boolean withCredentials;

// ready state

const unsigned short CONNECTING = 0;

const unsigned short OPEN = 1;

const unsigned short CLOSED = 2;

readonly attribute unsigned short readyState;

// networking

attribute EventHandler onopen;

attribute EventHandler onmessage;

attribute EventHandler onerror;

undefined close();

};

dictionary EventSourceInit {

boolean withCredentials = false;

};

Each p988 EventSource object has the following associated with it:

• A url (a URL record). Set during construction.

• A request. This must initially be null.

• A reconnection time, in milliseconds. This must initially be an implementation-defined value, probably in the region of a

few seconds.

• A last event ID string. This must initially be the empty string.

Apart from p988 p988 url these are not currently exposed on the EventSource object.

For web developers (non-normative)

source p989 p988 = new EventSource ( url [, { withCredentials : true } ])

Creates a new p988 EventSource object.

url is a string giving the URL that will provide the event stream.

Setting p988 withCredentials to true will set the credentials mode for connection requests to url to "include".

988

source p990 . close ()

Aborts any instances of the p988 p989 fetch algorithm started for this EventSource object, and sets the readyState attribute to

CLOSED p989 .

source p989 . url

Returns the p988 URL providing the event stream.

source p989 . withCredentials

Returns true if the p988 credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.

source p989 . readyState

Returns the state of this p988 EventSource object's connection. It can have the values described below.



The EventSource(url, eventSourceInitDict) constructor, when invoked, must run these steps: ✔ MDN

1. Let p988 ev be a new EventSource object.

2. Let p911 settings be ev 's relevant settings object.

3. Let p904 p904 urlRecord be the result of parsing url with settings 's API base URL and settings 's API URL character encoding .

4. If urlRecord is failure, then throw a "SyntaxError" DOMException.

5. Set p988 ev 's url to urlRecord.

6. Let p91 corsAttributeState be Anonymous.

7. If the value of p988 p91 eventSourceInitDict 's withCredentials member is true, then set corsAttributeState to Use Credentials

and set p989 ev 's withCredentials attribute to true.

8. Let p90 request be the result of creating a potential-CORS request given urlRecord, the empty string, and corsAttributeState.

9. Set request's client to settings.

10. User agents may p1246 set ` Accept `/` text/event-stream` in request's header list.

11. Set request's cache mode to "no-store".

12. Set p988 ev 's request to request.

13. Run this step p42 in parallel:

1. Fetch request.

14. Return ev.

✔ MDN

The p988 p988 url attribute's getter must return the serialization of this EventSource object's url. ✔ MDN

The withCredentials attribute must return the value to which it was last initialized. When the object is created, it must be initialized ✔ MDN to false.

The readyState attribute represents the state of the connection. It can have the following values: CONNECTING (numeric value 0)

The connection has not yet been established, or it was closed and the user agent is reconnecting.

OPEN (numeric value 1)

The user agent has an open connection and is dispatching events as it receives them.

CLOSED (numeric value 2)

The connection is not open, and the user agent is not trying to reconnect. Either there was a fatal error or the p990 close() method was invoked.

When the object is created its p989 p989 readyState must be set to CONNECTING (0). The rules given below for handling the connection ✔ MDN define when the value changes.

989

The p988 close() method must abort any instances of the fetch algorithm started for this EventSource object, and must set the

readyState p989 p989 attribute to CLOSED.

The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p988 , by all objects implementing the EventSource interface:

Event handler p941 p944 Event handler event type

p1272 ✔ MDN

onopen open

onmessage message

p1271 ✔ MDN

p1271 ✔ MDN

onerror error



9.2.3 Processing model p99 §

0

The resource indicated in the argument to the p989 EventSource constructor is fetched when the constructor is run.

As data is received, the p932 p939 tasks queued by the networking task source to handle the data must act as follows.

HTTP 200 OK responses with a ` p90 p1246 Content-Type ` header specifying the type ` text/event-stream`, ignoring any MIME type

parameters, must be processed line by line p991 as described below.

When a successful response with a supported MIME type is received, such that the user agent begins parsing the contents of the stream, the user agent must p990 announce the connection .

The p932 p939 p931 task that the networking task source places on the task queue once fetching for such a resource (with the correct MIME

type p990 p42 ) has completed must cause the user agent to reestablish the connection in parallel. This applies whether the connection is closed gracefully or unexpectedly (but does not apply when fetching is canceled by the user agent, e.g., in response to

window.stop() p833 p932 , since in those cases the final task is actually discarded). It doesn't apply for the error conditions listed below except where explicitly specified.

HTTP 200 OK responses that have a p90 p90 Content-Type specifying an unsupported type, or that have no Content-Type at all, must cause the user agent to p991 fail the connection.

Network errors that prevents the connection from being established in the first place (e.g. DNS errors), should cause the user agent to

reestablish the connection p990 p42 in parallel, unless the user agent knows that to be futile, in which case the user agent may fail the

connection p991 .

Any other HTTP response code not listed here, as well as the cancelation of the fetch algorithm by the user agent (e.g. in response to

window.stop() p833 p991 or the user canceling the network connection manually) must cause the user agent to fail the connection.



When a user agent is to p933 p989 announce the connection , the user agent must queue a task which, if the readyState attribute is set to a value other than p989 p989 p989 p1272 CLOSED , sets the readyState attribute to OPEN and fires an event named open at the

EventSource p988 object.

When a user agent is to p42 reestablish the connection , the user agent must run the following steps. These steps are run in parallel,

not as part of a p932 p42 task . (The tasks that it queues, of course, are run like normal tasks and not themselves in parallel.)

1. p933 Queue a task to run the following steps:

1. If the p989 p989 readyState attribute is set to CLOSED, abort the task.

2. Set the p989 p989 readyState attribute to CONNECTING.

3. p1271 p988 Fire an event named error at the EventSource object.

2. Wait a delay equal to the reconnection time of the event source.

3. Optionally, wait some more. In particular, if the previous attempt failed, then user agents might introduce an exponential

backoff delay to avoid overloading a potentially already overloaded server. Alternatively, if the operating system has reported that there is no network connectivity, user agents might wait for the operating system to announce that the network connection has returned before retrying.

4. Wait until the aforementioned task has run, if it has not yet run.

990

5. p933 Queue a task to run the following steps:

1. If the p988 p989 p989 EventSource object's readyState attribute is not set to CONNECTING , return.

2. Let p988 p988 request be the EventSource object's request .

3. If the p988 p988 p1250 EventSource object's last event ID string is not the empty string, set ` Last-Event-ID`/last event

ID string p988 , encoded as UTF-8, in request's header list.

4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.

When a user agent is to p933 p989 fail the connection , the user agent must queue a task which, if the readyState attribute is set to a value other than p989 p989 p989 p1271 CLOSED , sets the readyState attribute to CLOSED and fires an event named error at the

EventSource p988 p991 object. Once the user agent has failed the connection, it does not attempt to reconnect!



The p932 p932 p933 p988 task source for any tasks that are queued by EventSource objects is the remote event task source.



9.2.4 Parsing an event stream p99 §

1

This event stream format's p1246 MIME type is text/event-stream.

The event stream format is as described by the stream production of the following ABNF, the character set for which is Unicode.

[ABNF] p1275

stream = [ bom ] *event

event = *( comment / field ) end-of-line

comment = colon *any-char end-of-line

field = 1*name-char [ colon [ space ] *any-char ] end-of-line

end-of-line = ( cr lf / cr / lf )

; characters

lf = %x000A ; U+000A LINE FEED (LF)

cr = %x000D ; U+000D CARRIAGE RETURN (CR)

space = %x0020 ; U+0020 SPACE

colon = %x003A ; U+003A COLON (:)

bom = %xFEFF ; U+FEFF BYTE ORDER MARK

name-char = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF

; a scalar value other than U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or

U+003A COLON (:)

any-char = %x0000-0009 / %x000B-000C / %x000E-10FFFF

; a scalar value other than U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR) Event streams in this format must always be encoded as UTF-8. p1277 [ENCODING]

Lines must be separated by either a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character, or a single U+000D CARRIAGE RETURN (CR) character.

Since connections established to remote servers for such resources are expected to be long-lived, UAs should ensure that appropriate buffering is used. In particular, while line buffering with lines are defined to end with a single U+000A LINE FEED (LF) character is safe, block buffering or line buffering with different expected line endings can cause delays in event dispatch.



9.2.5 Interpreting an event stream p99 §

1

Streams must be decoded using the UTF-8 decode algorithm.

Note

The UTF-8 decode algorithm strips one leading UTF-8 Byte Order Mark (BOM), if any.

991

The stream must then be parsed by reading everything line by line, with a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, and a single U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF) character being the ways in which a line can end.

When a stream is parsed, a data buffer, an event type buffer, and a last event ID buffer must be associated with it. They must be initialized to the empty string Lines must be processed, in the order they are received, as follows:

↪ If the line is empty (a blank line)

Dispatch the event p992 , as defined below.

↪ If the line starts with a U+003A COLON character (:)

Ignore the line.

↪ If the line contains a U+003A COLON character (:)

Collect the characters on the line before the first U+003A COLON character (:), and let field be that string.

Collect the characters on the line after the first U+003A COLON character (:), and let value be that string. If value starts with a U+0020 SPACE character, remove it from value.

Process the field p992 using the steps described below, using field as the field name and value as the field value.

↪ Otherwise, the string is not empty but does not contain a U+003A COLON character (:)

Process the field p992 using the steps described below, using the whole line as the field name, and the empty string as the field value.

Once the end of the file is reached, any pending data must be discarded. (If the file ends in the middle of an event, before the final empty line, the incomplete event is not dispatched.)



The steps to process the field given a field name and a field value depend on the field name, as given in the following list. Field names must be compared literally, with no case folding performed.

↪ If the field name is "event"

Set the event type buffer to field value.

↪ If the field name is "data"

Append the field value to the data buffer, then append a single U+000A LINE FEED (LF) character to the data buffer.

↪ If the field name is "id"

If the field value does not contain U+0000 NULL, then set the last event ID buffer to the field value. Otherwise, ignore the field.

↪ If the field name is "retry"

If the field value consists of only ASCII digits, then interpret the field value as an integer in base ten, and set the event stream's

reconnection time p988 to that integer. Otherwise, ignore the field.

↪ Otherwise

The field is ignored.

When the user agent is required to dispatch the event, the user agent must process the data buffer, the event type buffer, and the last event ID buffer using steps appropriate for the user agent.

For web browsers, the appropriate steps to p992 dispatch the event are as follows:

1. Set the p988 last event ID string of the event source to the value of the last event ID buffer. The buffer does not get reset, so

the p988 last event ID string of the event source remains set to this value until the next time it is set by the server.

2. If the data buffer is an empty string, set the data buffer and the event type buffer to the empty string and return.

3. If the data buffer's last character is a U+000A LINE FEED (LF) character, then remove the last character from the data buffer.

4. Let p986 p911 p988 event be the result of creating an event using MessageEvent , in the relevant Realm of the EventSource object.

5. Initialize p1271 p986 p986 p841 event 's type attribute to message , its data attribute to data , its origin attribute to the serialization of

992

the p986 origin of the event stream's final URL (i.e., the URL after redirects), and its lastEventId attribute to the last event ID

string p988 of the event source.

6. If the event type buffer has a value other than the empty string, change the type of the newly created event to equal the

value of the event type buffer.

7. Set the data buffer and the event type buffer to the empty string.

8. p933 p989 p989 Queue a task which, if the readyState attribute is set to a value other than CLOSED, dispatches the newly created

event at the p988 EventSource object.

Note

If an event doesn't have an "id" field, but an earlier event did set the event source's p988 last event ID string, then the event's

lastEventId p986 field will be set to the value of whatever the last seen "id" field was.

For other user agents, the appropriate steps to p992 dispatch the event are implementation dependent, but at a minimum they must set the data and event type buffers to the empty string before returning.

Example

The following event stream, once followed by a blank line:

data: YHOO

data: +2

data: 10

...would cause an event p1271 p986 p988 message with the interface MessageEvent to be dispatched on the EventSource object. The

event's p986 data attribute would contain the string "YHOO\n+2\n10" (where "\n" represents a newline).

This could be used as follows:

var stocks = new EventSource("https://stocks.example.com/ticker.php"); stocks.onmessage = function (event) {

var data = event.data.split('\n');

updateStocks(data[0], data[1], data[2]);

};

...where updateStocks() is a function defined as:

function updateStocks(symbol, delta, value) { ... }

...or some such.



Example

The following stream contains four blocks. The first block has just a comment, and will fire nothing. The second block has two fields

with names "data" and "id" respectively; an event will be fired for this block, with the data "first event", and will then set the last

event ID to "1" so that if the connection died between this block and the next, the server would be sent a ` p1250 Last-Event-ID`

header with the value "1". The third block fires an event with data "second event", and also has an "id" field, this time with no

value, which resets the last event ID to the empty string (meaning no ` p1250 Last-Event-ID` header will now be sent in the event of

a reconnection being attempted). Finally, the last block just fires an event with the data " third event" (with a single leading space

character). Note that the last still has to end with a blank line, the end of the stream is not enough to trigger the dispatch of the

last event.

: test stream

data: first event

id: 1

data:second event

id

data: third event

993

Example

The following stream fires two events:

data

data

data

data:

The first block fires events with the data set to the empty string, as would the last block if it was followed by a blank line. The

middle block fires an event with the data set to a single newline character. The last block is discarded because it is not followed by

a blank line.



Example

The following stream fires two identical events:

data:test

data: test

This is because the space after the colon is ignored if present.



9.2.6 Authoring notes p99 §

4

Legacy proxy servers are known to, in certain cases, drop HTTP connections after a short timeout. To protect against such proxy servers, authors can include a comment line (one starting with a ':' character) every 15 seconds or so.

Authors wishing to relate event source connections to each other or to specific documents previously served might find that relying on IP addresses doesn't work, as individual clients can have multiple IP addresses (due to having multiple proxy servers) and individual IP addresses can have multiple clients (due to sharing a proxy server). It is better to include a unique identifier in the document when it is served and then pass that identifier as part of the URL when the connection is established.

Authors are also cautioned that HTTP chunking can have unexpected negative effects on the reliability of this protocol, in particular if the chunking is done by a different layer unaware of the timing requirements. If this is a problem, chunking can be disabled for serving event streams.

Clients that support HTTP's per-server connection limitation might run into trouble when opening multiple pages from a site if each page has an p988 EventSource to the same domain. Authors can avoid this using the relatively complex mechanism of using unique domain names per connection, or by allowing the user to enable or disable the p988 EventSource functionality on a per-page basis, or by sharing a single p988 p1035 EventSource object using a shared worker.



9.2.7 Connectionless push and other features p99 §

4

User agents running in controlled environments, e.g. browsers on mobile handsets tied to specific carriers, may offload the management of the connection to a proxy on the network. In such a situation, the user agent for the purposes of conformance is considered to include both the handset software and the network proxy.

Example

For example, a browser on a mobile device, after having established a connection, might detect that it is on a supporting network

and request that a proxy server on the network take over the management of the connection. The timeline for such a situation

might be as follows:

1. Browser connects to a remote HTTP server and requests the resource specified by the author in the p989 EventSource

constructor.

2. The server sends occasional messages.



994

3. In between two messages, the browser detects that it is idle except for the network activity involved in keeping the TCP

connection alive, and decides to switch to sleep mode to save power.

4. The browser disconnects from the server.

5. The browser contacts a service on the network, and requests that the service, a "push proxy", maintain the connection

instead.

6. The "push proxy" service contacts the remote HTTP server and requests the resource specified by the author in the

EventSource p989 p1250 constructor (possibly including a ` Last-Event-ID` HTTP header, etc).

7. The browser allows the mobile device to go to sleep.

8. The server sends another message.

9. The "push proxy" service uses a technology such as OMA push to convey the event to the mobile device, which wakes

only enough to process the event and then returns to sleep.



This can reduce the total data usage, and can therefore result in considerable power savings.

As well as implementing the existing API and p1246 text/event-stream wire format as defined by this specification and in more distributed ways as described above, formats of event framing defined by p65 other applicable specifications may be supported. This specification does not define how they are to be parsed or processed.



9.2.8 Garbage collection p99 §

5

While an p988 p989 p989 EventSource object's readyState is CONNECTING, and the object has one or more event listeners registered for

open p1272 p1271 p1271 p828 p1032 , message or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the p988 p988 EventSource object's constructor was invoked from to the EventSource object itself.

While an p988 p989 p989 EventSource object's readyState is OPEN , and the object has one or more event listeners registered for

message p1271 p1271 p828 p1032 or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the

EventSource p988 p988 object's constructor was invoked from to the EventSource object itself.

While there is a task queued by an p988 p991 EventSource object on the remote event task source, there must be a strong reference from the p828 p1032 p988 Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to that

EventSource p988 object.

If a user agent is to p988 p115 forcibly close an EventSource object (this happens when a Document object goes away permanently), the user agent must abort any instances of the p988 p989 fetch algorithm started for this EventSource object, and must set the readyState

attribute to p989 CLOSED .

If an p988 EventSource object is garbage collected while its connection is still open, the user agent must abort any instance of the fetch

algorithm opened by this p988 EventSource .



9.2.9 Implementation advice p99 §

5

This section is non-normative.

User agents are strongly urged to provide detailed diagnostic information about p988 EventSource objects and their related network connections in their development consoles, to aid authors in debugging code using this API.

For example, a user agent could have a panel displaying all the p988 EventSource objects a page has created, each listing the constructor's arguments, whether there was a network error, what the CORS status of the connection is and what headers were sent by the client and received from the server to lead to that status, the messages that were received and how they were parsed, and so forth.

Implementations are especially encouraged to report detailed information to their development consoles whenever an p1271 error event

995

is fired, since little to no information can be made available in the events themselves.



✔ MDN

9.3 Web sockets p99 §

6



9.3.1 Introduction p99 §

6

This section is non-normative.

To enable web applications to maintain bidirectional communications with server-side processes, this specification introduces the

WebSocket p996 interface.

Note

This interface does not allow for raw access to the underlying network. For example, this interface could not be used to implement

an IRC client without proxying messages through a custom server.



9.3.2 The p996 p99 WebSocket interface §

6

IDL enum BinaryType { "blob", "arraybuffer" };

[Exposed=(Window,Worker)]

interface WebSocket : EventTarget {

constructor(USVString url, optional (DOMString or sequence) protocols = []);

readonly attribute USVString url;

// ready state

const unsigned short CONNECTING = 0;

const unsigned short OPEN = 1;

const unsigned short CLOSING = 2;

const unsigned short CLOSED = 3;

readonly attribute unsigned short readyState;

readonly attribute unsigned long long bufferedAmount;

// networking

attribute EventHandler onopen;

attribute EventHandler onerror;

attribute EventHandler onclose;

readonly attribute DOMString extensions;

readonly attribute DOMString protocol;

undefined close(optional [Clamp] unsigned short code, optional USVString reason);

// messaging

attribute EventHandler onmessage;

attribute BinaryType binaryType;

undefined send(USVString data);

undefined send(Blob data);

undefined send(ArrayBuffer data);

undefined send(ArrayBufferView data);

};

Each p996 WebSocket object has an associated url (a URL record).

For web developers (non-normative)



996

socket p997 = new WebSocket (url [, protocols ] )

Creates a new p996 WebSocket object, immediately establishing the associated WebSocket connection.

url is a string giving the URL over which the connection is established. Only "ws" or "wss" schemes are allowed; others will cause

a "SyntaxError" DOMException. URLs with fragments will also cause such an exception. protocols is either a string or an array of strings. If it is a string, it is equivalent to an array consisting of just that string; if it is omitted, it is equivalent to the empty array. Each string in the array is a subprotocol name. The connection will only be established if the server reports that it has selected one of these subprotocols. The subprotocol names have to match the

requirements for elements that comprise the value of p63 Sec-WebSocket-Protocol fields as defined by The WebSocket protocol.

[WSP] p1282

socket p1000 . send( data )

Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.

socket p998 . close( [ code ] [, reason ] )

Closes the WebSocket connection, optionally using p63 code as the the WebSocket connection close code and reason as the the

WebSocket connection close reason p63.

socket p998 . url

Returns the p996 URL that was used to establish the WebSocket connection.

socket p998 . readyState

Returns the state of the p996 WebSocket object's connection. It can have the values described below.

socket p999 . bufferedAmount

Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using p1000 send() but not yet been transmitted to the network.

If the WebSocket connection is closed, this attribute's value will only increase with each call to the p1000 send() method. (The number does not reset to zero once the connection closes.)

socket p998 . extensions

Returns the extensions selected by the server, if any.

socket p998 . protocol

Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.

socket p999 . binaryType [ = value ]

Returns a string that indicates how binary data from the p996 WebSocket object is exposed to scripts:

" p1001 blob"

Binary data is returned in Blob form.

" p1001 arraybuffer"

Binary data is returned in ArrayBuffer form.

Can be set, to change how binary data is returned. The default is " p1001 blob".



The WebSocket(url, protocols) constructor, when invoked, must run these steps: MDN

1. Let urlRecord be the result of applying the URL parser to url.

2. If urlRecord is failure, then throw a "SyntaxError" DOMException.

3. If urlRecord's scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.

4. If urlRecord's fragment is non-null, then throw a "SyntaxError" DOMException.

5. If protocols is a string, set protocols to a sequence consisting of just that string.

6. If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that

comprise the value of p63 Sec-WebSocket-Protocol fields as defined by The WebSocket protocol, then throw a

" p1282 SyntaxError " DOMException . [WSP]

7. Run this step p42 in parallel:

1. p908 p1277 Establish a WebSocket connection given urlRecord , protocols , and the entry settings object . [FETCH]

997

Note

If the p63 establish a WebSocket connection algorithm fails, it triggers the fail the WebSocket connection

algorithm, which then invokes the p63 close the WebSocket connection algorithm, which then establishes that

the WebSocket connection is closed p63 p1271 p1001 , which fires the close event as described below.

8. Return a new p996 p996 WebSocket object whose url is urlRecord.

✔ MDN

The p996 p996 url attribute's getter must return this WebSocket object's url, serialized. ✔ MDN

The readyState attribute represents the state of the connection. It can have the following values: CONNECTING (numeric value 0)

The connection has not yet been established.

OPEN (numeric value 1)

The WebSocket connection is established p63 and communication is possible.

CLOSING (numeric value 2)

The connection is going through the closing handshake, or the p998 close() method has been invoked.

CLOSED (numeric value 3)

The connection has been closed or could not be opened.

✔ MDN

When the object is created its p998 p998 readyState must be set to CONNECTING (0).

The p63 extensions attribute must initially return the empty string. After the WebSocket connection is established, its value might ✔ MDN change, as defined below.

The p63 protocol attribute must initially return the empty string. After the WebSocket connection is established, its value might ✔ MDN change, as defined below.

The close(code, reason) method, when invoked, must run these steps:

1. If code is present, but is neither an integer equal to 1000 nor an integer in the range 3000 to 4999, inclusive, throw an

"InvalidAccessError" DOMException.

2. If reason is present, then run these substeps:

1. Let reasonBytes be the result of encoding reason.

2. If reasonBytes is longer than 123 bytes, then throw a "SyntaxError" DOMException.

3. Run the first matching steps from the following list:

↪ p998 p998 p998 If the readyState attribute is in the CLOSING (2) or CLOSED (3) state

Do nothing.

Note

The connection is already closing or is already closed. If it has not already, a p1271 close event will eventually fire

as described below p1001.



↪ p63 p1282 If the WebSocket connection is not yet established [WSP]

Fail the WebSocket connection p63 p998 p998 p1282 and set the readyState attribute's value to CLOSING (2). [WSP]

Note

The p63 p63 fail the WebSocket connection algorithm invokes the close the WebSocket connection algorithm, which

then establishes that p63 p1271 the WebSocket connection is closed , which fires the close event as described

below p1001.



↪ p63 p1282 If the WebSocket closing handshake has not yet been started [WSP]

Start the WebSocket closing handshake p63 p998 p998 p1282 and set the readyState attribute's value to CLOSING (2). [WSP]

If neither code nor reason is present, the WebSocket Close message must not have a body.

998

Note

WebSocket Protocol erroneously states that the status code is required for the start the WebSocket closing

handshake p63 algorithm.

If code is present, then the status code to use in the WebSocket Close message must be the integer given by close.

[WSP] p1282

If p1282 reason is also present, then reasonBytes must be provided in the Close message after the status code. [WSP]

Note

The p63 start the WebSocket closing handshake algorithm eventually invokes the close the WebSocket

connection p63 p63 algorithm, which then establishes that the WebSocket connection is closed, which fires the

close p1271 p1001 event as described below.

↪ Otherwise

Set the p998 p998 readyState attribute's value to CLOSING (2).

Note

The WebSocket closing handshake is started p63 p63 , and will eventually invoke the close the WebSocket connection

algorithm, which will establish that p63 p1271 the WebSocket connection is closed , and thus the close event will fire,

as described below p1001.



Note

The p998 close() method does not discard previously sent messages before starting the WebSocket closing handshake — even if, in

practice, the user agent is still busy sending those messages, the handshake will only start after the messages are sent.



The bufferedAmount attribute must return the number of bytes of application data (UTF-8 text and binary data) that have been ✔ MDN

queued using p1000 p931 p934 send() but that, as of the last time the event loop reached step 1, had not yet been transmitted to the network. (This thus includes any text sent during the execution of the current task, regardless of whether the user agent is able to transmit text in the background p42 in parallel with script execution.) This does not include framing overhead incurred by the protocol, or buffering done by the operating system or network hardware.

Example

In this simple example, the p999 bufferedAmount attribute is used to ensure that updates are sent either at the rate of one update

every 50ms, if the network can handle that rate, or at whatever rate the network can handle, if that is too fast.

var socket = new WebSocket('ws://game.example.com:12010/updates'); socket.onopen = function () {

setInterval(function() {

if (socket.bufferedAmount == 0)

socket.send(getUpdateData());

}, 50);

};

The p999 bufferedAmount attribute can also be used to saturate the network without sending the data at a higher rate than the

network can handle, though this requires more careful monitoring of the value of the attribute over time.



When a p996 p1001 WebSocket object is created, its binaryType IDL attribute must be set to the string " blob". On getting, it must return ✔ MDN the last value it was set to. On setting, the user agent must set the IDL attribute to the new value.

Note

User agents can use the p999 binaryType attribute as a hint for how to handle incoming binary data: if the attribute is set to

" p1001 p1001 blob ", it is safe to spool it to disk, and if it is set to " arraybuffer", it is likely more efficient to keep the data in memory.

Naturally, user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in memory or not,

e.g. based on how big the data is or how common it is for a script to change the attribute at the last minute. This latter aspect is

important in particular because it is quite possible for the attribute to be changed after the user agent has received the data but

999

before the user agent has fired the event for it. ✔ MDN



The p998 p998 send( data ) method transmits data using the connection. If the readyState attribute is CONNECTING, it must throw an

"InvalidStateError" DOMException. Otherwise, the user agent must run the appropriate set of steps from the following list: If the argument is a string

If p63 p63 the WebSocket connection is established and the WebSocket closing handshake has not yet started, then the user agent

must p63 send a WebSocket Message comprised of the data argument using a text frame opcode; if the data cannot be sent, e.g.

because it would need to be buffered but the buffer is full, the user agent must p1001 flag the WebSocket as full and then close the

WebSocket connection p63. Any invocation of this method with a string argument that does not throw an exception must increase the

bufferedAmount p999 p1282 p1277 attribute by the number of bytes needed to express the argument as UTF-8. [UNICODE] [ENCODING]

[WSP] p1282

If the argument is a Blob object

If p63 p63 the WebSocket connection is established , and the WebSocket closing handshake has not yet started, then the user agent

must p63 send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it

would need to be buffered but the buffer is full, the user agent must p1001 flag the WebSocket as full and then close the WebSocket

connection p63. The data to be sent is the raw data represented by the Blob object. Any invocation of this method with a Blob

argument that does not throw an exception must increase the p999 bufferedAmount attribute by the size of the Blob object's raw

data, in bytes. p1282 p1277 [WSP] [FILEAPI]

If the argument is an ArrayBuffer object

If p63 p63 the WebSocket connection is established , and the WebSocket closing handshake has not yet started, then the user agent

must p63 send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it

would need to be buffered but the buffer is full, the user agent must p1001 flag the WebSocket as full and then close the WebSocket

connection p63. The data to be sent is the data stored in the buffer described by the ArrayBuffer object. Any invocation of this

method with an p999 ArrayBuffer argument that does not throw an exception must increase the bufferedAmount attribute by the

length of the p1282 ArrayBuffer in bytes. [WSP]

If the argument is an object that matches the ArrayBufferView type definition

If p63 p63 the WebSocket connection is established , and the WebSocket closing handshake has not yet started, then the user agent

must p63 send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it

would need to be buffered but the buffer is full, the user agent must p1001 flag the WebSocket as full and then close the WebSocket

connection p63. The data to be sent is the data stored in the section of the buffer described by the ArrayBuffer object that data references. Any invocation of this method with this kind of argument that does not throw an exception must increase the

bufferedAmount p999 p1282 attribute by the length of data 's buffer in bytes. [WSP]



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p996 , by all objects implementing the WebSocket interface:

Event handler p941 p944 Event handler event type

p1272 ✔ MDN

onopen open

onmessage message

p1271 ✔ MDN

p1271 ✔ MDN

onerror error

p1271 ✔ MDN

onclose close



9.3.3 Feedback from the protocol p10 §

00

When p63 p933 the WebSocket connection is established , the user agent must queue a task to run these steps:

1. Change the p998 p998 readyState attribute's value to OPEN (1).

2. Change the p998 p63 p1282 extensions attribute's value to the extensions in use , if it is not the null value. [WSP]

3. Change the p998 p63 p1282 protocol attribute's value to the subprotocol in use , if it is not the null value. [WSP]

4. p1272 p996 Fire an event named open at the WebSocket object.

1000

Note

Since the algorithm above is p933 queued as a task, there is no race condition between the WebSocket connection being

established p63 p1272 and the script setting up an event listener for the open event.



When p63 p933 a WebSocket message has been received with type type and data data , the user agent must queue a task to follow these steps: p1282 [WSP]

1. If the p998 p998 readyState attribute's value is not OPEN (1), then return.

2. Let p999 dataForEvent be determined by switching on type and binaryType :

↪ type indicates that the data is Text

a new DOMString containing data

↪ p999 type indicates that the data is Binary and binaryType is "blob"

a new p911 p996 Blob object, created in the relevant Realm of the WebSocket object, that represents data as its raw data

[FILEAPI] p1277

↪ p999 type indicates that the data is Binary and binaryType is "arraybuffer"

a new p911 p996 ArrayBuffer object, created in the relevant Realm of the WebSocket object, whose contents are data

3. p1271 p996 p986 p986 Fire an event named message at the WebSocket object, using MessageEvent , with the origin attribute

initialized to the p841 p996 p996 p986 serialization of the WebSocket object's url 's origin , and the data attribute initialized to dataForEvent.

Note

User agents are encouraged to check if they can perform the above steps efficiently before they run the task, picking tasks from

other p931 p999 p1001 task queues while they prepare the buffers if not. For example, if the binaryType attribute was set to " blob" when

the data arrived, and the user agent spooled all the data to disk, but just before running the above p932 task for this particular

message the script switched p999 p1001 binaryType to " arraybuffer", the user agent would want to page the data back to RAM

before running this p932 task so as to avoid stalling the main thread while it created the ArrayBuffer object.



Example

Here is an example of how to define a handler for the p1271 message event in the case of text frames:

mysocket.onmessage = function (event) {

if (event.data == 'on') {

turnLampOn();

} else if (event.data == 'off') {

turnLampOff();

}

};

The protocol here is a trivial one, with the server just sending "on" or "off" messages.



When p63 p933 p998 the WebSocket closing handshake is started , the user agent must queue a task to change the readyState attribute's value to p998 p998 p998 p998 CLOSING (2). (If the close() method was called, the readyState attribute's value will already be set to CLOSING

(2) when this task runs.) p1282 [WSP]



When p63 p933 the WebSocket connection is closed , possibly cleanly , the user agent must queue a task to run the following substeps:

1. Change the p998 p998 readyState attribute's value to CLOSED (3).

2. If the user agent was required to p63 p63 fail the WebSocket connection , or if the the WebSocket connection was closed after

being p996 p1282 flagged as full , fire an event named error at the WebSocket object. [WSP]

3. p1271 p996 p1002 p1003 Fire an event named close at the WebSocket object, using CloseEvent , with the wasClean attribute initialized

to true if the connection closed p1003 cleanly and false otherwise, the code attribute initialized to the WebSocket connection

close code p63 p1003 , and the reason attribute initialized to the result of applying UTF-8 decode without BOM to the WebSocket

1001

connection close reason p63 p1282 . [WSP]

⚠Warning!

User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the

following situations:

• A server whose host name could not be resolved.

• A server to which packets could not successfully be routed.

• A server that refused the connection on the specified port.

• A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be verified).

• A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).

• A WebSocket server that sent a correct opening handshake, but that specified options that caused the

client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).

• A WebSocket server that abruptly closed the connection after successfully completing the opening

handshake.

In all of these cases, the p63 the WebSocket connection close code would be 1006, as required by WebSocket

Protocol p1282 . [WSP]

Allowing a script to distinguish these cases would allow a script to probe the user's local network in preparation for

an attack.

Note

In particular, this means the code 1015 is not used by the user agent (unless the server erroneously uses it in its close frame, of course).



The p932 p932 p933 task source for all tasks queued in this section is the WebSocket task source.



9.3.4 Ping and Pong frames p10 §

02

The WebSocket protocol defines Ping and Pong frames that can be used for keep-alive, heart-beats, network status probing, latency instrumentation, and so forth. These are not currently exposed in the API.

User agents may send ping and unsolicited pong frames as desired, for example in an attempt to maintain local network NAT mappings, to detect failed connections, or to display latency metrics to the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that servers will solicit pongs whenever appropriate for the server's needs.



9.3.5 The p1002 ✔ MDN p10 CloseEvent interface §

02 ⚠ MDN

WebSocket p996 p1002 p1271 objects use the CloseEvent interface for their close events:

IDL [Exposed=(Window,Worker)]

interface CloseEvent : Event {

constructor(DOMString type, optional CloseEventInit eventInitDict = {});

readonly attribute boolean wasClean;

readonly attribute unsigned short code;

readonly attribute USVString reason;

};

dictionary CloseEventInit : EventInit {

1002

boolean wasClean = false;

unsigned short code = 0;

USVString reason = "";

};



For web developers (non-normative)

event p1003 . wasClean

Returns true if the connection closed cleanly; false otherwise.

event p1003 . code

Returns the WebSocket connection close code provided by the server.

event p1003 . reason

Returns the WebSocket connection close reason provided by the server.

The wasClean attribute must return the value it was initialized to. It represents whether the connection closed cleanly or not.

The code attribute must return the value it was initialized to. It represents the WebSocket connection close code provided by the server.

The reason attribute must return the value it was initialized to. It represents the WebSocket connection close reason provided by the server.



9.3.6 Garbage collection p10 §

03

A p996 p998 p998 p931 WebSocket object whose readyState attribute's value was set to CONNECTING (0) as of the last time the event loop

reached p934 p1272 p1271 step 1 must not be garbage collected if there are any event listeners registered for open events, message events,

error p1271 p1271 events, or close events.

A p996 p998 p998 p931 WebSocket object whose readyState attribute's value was set to OPEN (1) as of the last time the event loop reached

step 1 p934 p1271 p1271 p1271 must not be garbage collected if there are any event listeners registered for message events, error , or close events.

A p996 p998 p998 p931 WebSocket object whose readyState attribute's value was set to CLOSING (2) as of the last time the event loop reached

step 1 p934 p1271 p1271 must not be garbage collected if there are any event listeners registered for error or close events.

A p996 p63 WebSocket object with an established connection that has data queued to be transmitted to the network must not be garbage collected. p1282 [WSP]

If a p996 WebSocket object is garbage collected while its connection is still open, the user agent must start the WebSocket closing

handshake p63 p1282 , with no status code for the Close message. [WSP]



If a user agent is to p996 p115 make disappear a WebSocket object (this happens when a Document object goes away), the user agent must follow the first appropriate set of steps from the following list:

↪ p63 p1282 If the WebSocket connection is not yet established [WSP]

Fail the WebSocket connection p63 p1282 . [WSP]

↪ p63 p1282 If the WebSocket closing handshake has not yet been started [WSP]

Start the WebSocket closing handshake p63 p1282 , with the status code to use in the WebSocket Close message being 1001. [WSP]

↪ Otherwise

Do nothing.



1003

✔ MDN

9.4 Cross-document messaging p10 §

04

Web browsers, for security and privacy reasons, prevent documents in different domains from affecting each other; that is, cross-site scripting is disallowed.

While this is an important security feature, it prevents pages from different domains from communicating even when those pages are not hostile. This section introduces a messaging system that allows documents to communicate with each other regardless of their source domain, in a way designed to not enable cross-site scripting attacks.

Note

The p1006 postMessage() API can be used as a tracking vector.



9.4.1 Introduction p10 §

04

This section is non-normative.

Example

For example, if document A contains an p362 iframe element that contains document B, and script in document A calls

postMessage() p1006 p828 on the Window object of document B, then a message event will be fired on that object, marked as

originating from the p828 Window of document A. The script in document A might look like:

var o = document.getElementsByTagName('iframe')[0];

o.contentWindow.postMessage('Hello world', 'https://b.example.org/');

To register an event handler for incoming events, the script would use addEventListener() (or similar mechanisms). For example,

the script in document B might look like:

window.addEventListener('message', receiver, false);

function receiver(e) {

if (e.origin == 'https://example.com') {

if (e.data == 'Hello world') {

e.source.postMessage('Hello', e.origin);

} else {

alert(e.data);

}

}

}

This script first checks the domain is the expected domain, and then looks at the message, which it either displays to the user, or

responds to by sending a message back to the document which sent the message in the first place.



9.4.2 Security p10 §

04

9.4.2.1 Authors p10 §

04

⚠Warning!

Use of this API requires extra care to protect users from hostile entities abusing a site for their own purposes.

Authors should check the p986 origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from. Otherwise, bugs in the author's message handling code could be exploited by hostile sites.

Furthermore, even after checking the p986 origin attribute, authors should also check that the data in question is of the expected format. Otherwise, if the source of the event has been attacked using a cross-site scripting flaw, further unchecked processing of information sent using the p1006 postMessage() method could result in the attack being propagated into the receiver.

Authors should not use the wildcard keyword (*) in the targetOrigin argument in messages that contain any confidential information, as

1004

otherwise there is no way to guarantee that the message is only delivered to the recipient to which it was intended.



Authors who accept messages from any origin are encouraged to consider the risks of a denial-of-service attack. An attacker could send a high volume of messages; if the receiving page performs expensive computation or causes network traffic to be sent for each such message, the attacker's message could be multiplied into a denial-of-service attack. Authors are encouraged to employ rate limiting (only accepting a certain number of messages per minute) to make such attacks impractical.



9.4.2.2 User agents p10 §

05

The integrity of this API is based on the inability for scripts of one p841 origin to post arbitrary events (using dispatchEvent() or otherwise) to objects in other origins (those that are not the p842 same).

Note

Implementors are urged to take extra care in the implementation of this feature. It allows authors to transmit information from one

domain to another domain, which is normally disallowed for security reasons. It also requires that UAs be careful to allow access to

certain properties but not others.



User agents are also encouraged to consider rate-limiting message traffic between different p841 origins , to protect naïve sites from denial-of-service attacks.



9.4.3 Posting messages p10 §

05

For web developers (non-normative)

window p1006 . postMessage(message [, options ] )

Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain

JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and

ArrayBuffer objects.

Objects listed in the p1010 transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.

A target origin can be specified using the p829 targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.

If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".

Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.

window p1006 . postMessage(message, targetOrigin [, transfer ] )

This is an alternate version of p1006 postMessage() where the target origin is specified as a parameter. Calling window.postMessage(message, target, transfer) is equivalent to window.postMessage(message, {targetOrigin, transfer}).



Note

When posting a message to a p828 p814 p115 Window of a browsing context that has just been navigated to a new Document is likely to

result in the message not receiving its intended recipient: the scripts in the target p814 browsing context have to have had time to

set up listeners for the messages. Thus, for instance, in situations where a message is to be sent to the p828 Window of newly

created child p362 p115 iframe , authors are advised to have the child Document post a message to their parent announcing their

readiness to receive messages, and for the parent to wait for this message before beginning posting messages.

The window post message steps, given a targetWindow, message, and options, are as follows:

1. Let p905 targetRealm be targetWindow 's Realm.

2. Let p908 incumbentSettings be the incumbent settings object.

1005

3. Let p829 targetOrigin be options [" targetOrigin "].

4. If p904 targetOrigin is a single U+002F SOLIDUS character (/), then set targetOrigin to incumbentSettings 's origin.

5. Otherwise, if targetOrigin is not a single U+002A ASTERISK character (*), then:

1. Let parsedURL be the result of running the URL parser on targetOrigin.

2. If parsedURL is failure, then throw a "SyntaxError" DOMException.

3. Set targetOrigin to parsedURL's origin.

6. Let p1010 transfer be options [" transfer"].

7. Let p111 serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.

8. p933 Queue a global task on the posted message task source given targetWindow to run the following steps:

1. If the targetOrigin argument is not a single literal U+002A ASTERISK character (*) and targetWindow's associated

Document p829 p841 p842 's origin is not same origin with targetOrigin, then return.

2. Let p841 p904 origin be the serialization of incumbentSettings 's origin.

3. Let p837 p905 p828 source be the WindowProxy object corresponding to incumbentSettings 's global object (a Window

object).

4. Let p112 deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).

If this throws an exception, catch it, p1272 fire an event named messageerror at targetWindow, using

MessageEvent p986 p986 p987 , with the origin attribute initialized to origin and the source attribute initialized to source, and then return.

5. Let messageClone be deserializeRecord.[[Deserialized]].

6. Let p1010 newPorts be a new frozen array consisting of all MessagePort objects in

deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.

7. p1271 p986 p986 Fire an event named message at targetWindow , using MessageEvent , with the origin attribute initialized

to p987 p986 origin , the source attribute initialized to source , the data attribute initialized to messageClone, and the

ports p987 attribute initialized to newPorts.

The p828 postMessage( message , options ) method, when invoked on a Window object, must run the following steps:

1. Let p828 targetWindow be this Window object.

2. Run the p1005 window post message steps providing targetWindow, message, and options.

The p828 postMessage( message , targetOrigin , transfer ) method, when invoked on a Window object, must run the following steps: ✔ MDN

1. Let p828 targetWindow be this Window object.

2. Let p829 p1010 options be «[ " targetOrigin " → targetOrigin , " transfer" → transfer ]».

3. Run the p1005 window post message steps providing targetWindow, message, and options.



✔ MDN

9.5 Channel messaging p10 §

06



9.5.1 Introduction p10 §

06

This section is non-normative.

To enable independent pieces of code (e.g. running in different p814 browsing contexts) to communicate directly, authors can use

channel messaging p1006.

1006

Communication channels in this mechanism are implemented as two-ways pipes, with a port at each end. Messages sent in one port are delivered at the other port, and vice-versa. Messages are delivered as DOM events, without interrupting or blocking running

tasks p932.

To create a connection (two "entangled" ports), the MessageChannel() constructor is called:

var channel = new MessageChannel();

One of the ports is kept as the local port, and the other port is sent to the remote code, e.g. using p1006 postMessage():

otherWindow.postMessage('hello', 'https://example.com', [channel.port2]); To send messages, the p1012 postMessage() method on the port is used:

channel.port1.postMessage('hello');

To receive messages, one listens to p1271 message events:

channel.port1.onmessage = handleMessage;

function handleMessage(event) {

// message is in event.data

// ...

}

Data sent on a port can be structured data; for example here an array of strings is passed on a p1010 MessagePort:

port1.postMessage(['hello', 'world']);



9.5.1.1 Examples p10 §

07

This section is non-normative.

Example

In this example, two JavaScript libraries are connected to each other using p1010 MessagePorts. This allows the libraries to later be

hosted in different frames, or in p1041 Worker objects, without any change to the APIs.



Here's what the "addContactsProvider()" function's implementation could look like:

function addContactsProvider(port) {

port.onmessage = function (event) {

switch (event.data.messageType) {

'search-result': handleSearchResult(event.data.results); break; 'search-done': handleSearchDone(); break;

'search-error': handleSearchError(event.data.message); break; // ...

}

};

};



1007

Alternatively, it could be implemented as follows:

function addContactsProvider(port) {

port.addEventListener('message', function (event) {

if (event.data.messageType == 'search-result')

handleSearchResult(event.data.results);

});

port.addEventListener('message', function (event) {

if (event.data.messageType == 'search-done')

handleSearchDone();

});

port.addEventListener('message', function (event) {

if (event.data.messageType == 'search-error')

handleSearchError(event.data.message);

});

// ...

port.start();

};

The key difference is that when using p1012 addEventListener() , the start() method must also be invoked. When using

onmessage p1012 p1012 , the call to start() is implied.

The p1012 p1012 start() method, whether called explicitly or implicitly (by setting onmessage), starts the flow of messages: messages

posted on message ports are initially paused, so that they don't get dropped on the floor before the script has had a chance to set

up its handlers.



9.5.1.2 Ports as the basis of an object-capability model on the web p10 §

08

This section is non-normative.

Ports can be viewed as a way to expose limited capabilities (in the object-capability model sense) to other actors in the system. This can either be a weak capability system, where the ports are merely used as a convenient model within a particular origin, or as a strong capability model, where they are provided by one origin provider as the only mechanism by which another origin consumer can effect change in or obtain information from provider.

For example, consider a situation in which a social web site embeds in one p362 iframe the user's email contacts provider (an address book site, from a second origin), and in a second p362 iframe a game (from a third origin). The outer social site and the game in the second p362 p362 iframe cannot access anything inside the first iframe; together they can only:

• p876 p362 p828 Navigate the iframe to a new URL , such as the same URL but with a different fragment , causing the Window in the

iframe p362 p1271 to receive a hashchange event.

• Resize the p362 p828 p362 iframe , causing the Window in the iframe to receive a resize event.

• Send a p1271 p828 p362 p1006 message event to the Window in the iframe using the window.postMessage() API.

The contacts provider can use these methods, most particularly the third one, to provide an API that can be accessed by other origins to manipulate the user's address book. For example, it could respond to a message "add-contact Guillaume Tell " by adding the given person and email address to the user's address book.

To avoid any site on the web being able to manipulate the user's contacts, the contacts provider might only allow certain trusted sites, such as the social site, to do this.

Now suppose the game wanted to add a contact to the user's address book, and that the social site was willing to allow it to do so on its behalf, essentially "sharing" the trust that the contacts provider had with the social site. There are several ways it could do this; most simply, it could just proxy messages between the game site and the contacts site. However, this solution has a number of difficulties: it requires the social site to either completely trust the game site not to abuse the privilege, or it requires that the social site verify each request to make sure it's not a request that it doesn't want to allow (such as adding multiple contacts, reading the contacts, or deleting them); it also requires some additional complexity if there's ever the possibility of multiple games simultaneously trying to interact with the contacts provider.

Using message channels and p1010 MessagePort objects, however, all of these problems can go away. When the game tells the social

1008

site that it wants to add a contact, the social site can ask the contacts provider not for it to add a contact, but for the capability to add a single contact. The contacts provider then creates a pair of p1010 MessagePort objects, and sends one of them back to the social site, who forwards it on to the game. The game and the contacts provider then have a direct connection, and the contacts provider knows to only honor a single "add contact" request, nothing else. In other words, the game has been granted the capability to add a single contact.



9.5.1.3 Ports as the basis of abstracting out service implementations p10 §

09

This section is non-normative.

Continuing the example from the previous section, consider the contacts provider in particular. While an initial implementation might have simply used p362 XMLHttpRequest objects in the service's iframe , an evolution of the service might instead want to use a shared

worker p1042 p996 with a single WebSocket connection.

If the initial design used p1010 MessagePort objects to grant capabilities, or even just to allow multiple simultaneous independent sessions, the service implementation can switch from the p362 p996 XMLHttpRequest s-in-each- iframe model to the shared- WebSocket

model without changing the API at all: the ports on the service provider side can all be forwarded to the shared worker without it affecting the users of the API in the slightest.



9.5.2 Message channels §

p10 ✔ MDN

09

IDL [Exposed=(Window,Worker)]

interface MessageChannel {

constructor();

readonly attribute MessagePort port1;

readonly attribute MessagePort port2;

};



For web developers (non-normative)

channel p1009 = new MessageChannel()

Returns a new p1009 p1010 MessageChannel object with two new MessagePort objects.

channel p1009 . port1

Returns the first p1010 MessagePort object.

channel p1009 . port2

Returns the second p1010 MessagePort object.

A p1009 ✔ MDN p1010 MessageChannel object has an associated port 1 and an associated port 2 , both MessagePort objects.

The new MessageChannel() constructor steps are:

1. Set p1009 p1010 p911 this 's port 1 to a new MessagePort in this 's relevant Realm .

2. Set p1009 p1010 p911 this 's port 2 to a new MessagePort in this 's relevant Realm .

3. p1010 p1009 p1009 Entangle this 's port 1 and this 's port 2.

✔ MDN

The p1009 port1 getter steps are to return this 's port 1. ✔ MDN

The p1009 port2 getter steps are to return this 's port 2.



✔ MDN

9.5.3 Message ports p10 §

09

Each channel has two message ports. Data sent through one port is received by the other port, and vice versa.

1009

IDL [Exposed=(Window,Worker,AudioWorklet), Transferable]

interface MessagePort : EventTarget {

undefined postMessage(any message, sequence<object> transfer);

undefined postMessage(any message, optional PostMessageOptions options = {});

undefined start();

undefined close();

// event handlers

attribute EventHandler onmessage;

attribute EventHandler onmessageerror;

};

dictionary PostMessageOptions {

sequence<object> transfer = [];

};



For web developers (non-normative)

port p1012 . postMessage(message [, transfer] )

port p1012 . postMessage(message [, { transfer }] )

Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.

Throws a "DataCloneError" DOMException if transfer contains duplicate objects or port, or if message could not be cloned.

port p1012 . start()

Begins dispatching messages received on the port.

port p1012 . close()

Disconnects the port, so that it is no longer active.

Each p1010 p1010 MessagePort object can be entangled with another (a symmetric relationship). Each MessagePort object also has a task

source p932 p1010 called the port message queue , initially empty. A port message queue can be enabled or disabled, and is initially disabled. Once enabled, a port can never be disabled again (though messages in the queue can get moved to another queue or removed altogether, which has much the same effect). A p1010 MessagePort also has a has been shipped flag, which must initially be false.

When a port's p1010 p931 p932 port message queue is enabled, the event loop must use it as one of its task sources. When a port's relevant

global object p911 p828 p932 p933 p1010 is a Window , all tasks queued on its port message queue must be associated with the port's relevant

global object p911 p829 's associated Document .

Note

If the document is p818 p912 fully active , but the event listeners all have scripts whose settings objects specify responsible

documents p904 p818 that are not fully active , then the messages will not be recieved unless and until the documents become fully

active p818 again.

Each p931 p932 p932 event loop has a task source called the unshipped port message queue . This is a virtual task source : it must act as

if it contained the p932 p1010 p1010 p1010 tasks of each port message queue of each MessagePort whose has been shipped flag is false, whose

port message queue p1010 p901 p931 p931 is enabled, and whose relevant agent 's event loop is that event loop, in the order in which they were added to their respective p932 p932 p1010 task source . When a task would be removed from the unshipped port message queue, it must instead be removed from its p1010 port message queue.

When a p1010 p1010 p1010 MessagePort 's has been shipped flag is false, its port message queue must be ignored for the purposes of the

event loop p931 p1010 . (The unshipped port message queue is used instead.) Note

The p1010 has been shipped flag is set to true when a port, its twin, or the object it was cloned from, is or has been transferred.

When a p1010 p1010 p1010 p932 MessagePort 's has been shipped flag is true, its port message queue acts as a first-class task source ,

unaffected to any p1010 unshipped port message queue.

When the user agent is to p1010 entangle two MessagePort objects, it must run the following steps:

1010

1. If one of the ports is already entangled, then disentangle it and the port that it was entangled with.

Note

If those two previously entangled ports were the two ports of a p1009 MessageChannel object, then that

MessageChannel p1009 object no longer represents an actual channel: the two ports in that object are no longer entangled.

2. Associate the two ports to be entangled, so that they form the two parts of a new channel. (There is no p1009 MessageChannel

object that represents this channel.)

Two ports A and B that have gone through this step are now said to be entangled; one is entangled to the other, and vice versa.

Note

While this specification describes this process as instantaneous, implementations are more likely to implement it via message passing. As with all algorithms, the key is "merely" that the end result be indistinguishable, in a black-box sense, from the specification.



MessagePort p1010 p104 p104 objects are transferable objects . Their transfer steps, given value and dataHolder, are:

1. Set p1010 value 's has been shipped flag to true.

2. Set p1010 dataHolder .[[PortMessageQueue]] to value 's port message queue.

3. If value is entangled with another port remotePort, then:

1. Set p1010 remotePort 's has been shipped flag to true.

2. Set dataHolder.[[RemotePort]] to remotePort.

4. Otherwise, set dataHolder.[[RemotePort]] to null.

Their p104 transfer-receiving steps, given dataHolder and value, are:

1. Set p1010 value 's has been shipped flag to true.

2. Move all the p932 p1271 tasks that are to fire message events in dataHolder.[[PortMessageQueue]] to the port message

queue p1010 p1010 of value , if any, leaving value 's port message queue in its initial disabled state, and, if value's relevant global

object p911 p828 p932 p911 p829 is a Window , associating the moved tasks with value 's relevant global object 's associated Document.

3. If p1010 dataHolder .[[RemotePort]] is not null, then entangle dataHolder.[[RemotePort]] and value. (This will disentangle

dataHolder.[[RemotePort]] from the original port that was transferred.)



The message port post message steps, given a targetPort, message and options are as follows:

1. Let p1010 transfer be options [" transfer"].

2. If p1010 transfer contains this MessagePort, then throw a "DataCloneError" DOMException.

3. Let doomed be false.

4. If targetPort is not null and transfer contains targetPort, then set doomed to true and optionally report to a developer console

that the target port was posted to itself, causing the communication channel to be lost.

5. Let p111 serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.

6. If targetPort is null, or if doomed is true, then return.

7. Add a p932 p1010 task that runs the following steps to the port message queue of targetPort:

1. Let p1010 p1010 finalTargetPort be the MessagePort in whose port message queue the task now finds itself.

Note

This can be different from targetPort, if targetPort itself was transferred and thus all its tasks moved along with it.

1011

2. Let p911 targetRealm be finalTargetPort 's relevant Realm .

3. Let p112 deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).

If this throws an exception, catch it, p1272 fire an event named messageerror at finalTargetPort, using

MessageEvent p986, and then return.

4. Let messageClone be deserializeRecord.[[Deserialized]].

5. Let p1010 newPorts be a new frozen array consisting of all MessagePort objects in

deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.

6. p1271 p986 p986 Fire an event named message at finalTargetPort , using MessageEvent , with the data attribute initialized

to p987 messageClone and the ports attribute initialized to newPorts.

The p1010 postMessage( message , options ) method, when invoked on a MessagePort object must run the following steps:

1. Let p1010 targetPort be the port with which this MessagePort is entangled, if any; otherwise let it be null.

2. Run the p1011 message port post message steps providing targetPort, message and options.

The p1010 postMessage( message , transfer ) method, when invoked on a MessagePort object must run the following steps: ✔ MDN

1. Let p1010 targetPort be the port with which this MessagePort is entangled, if any; otherwise let it be null.

2. Let p1010 options be «[ " transfer" → transfer ]».

3. Run the p1011 message port post message steps providing targetPort, message and options.



The p1010 p1010 start() method, when invoked, must enable this MessagePort object's port message queue, if it is not already enabled. ✔ MDN



The close() method, when invoked, must run these steps: ✔ MDN

1. Set this p1010 p104 MessagePort object's [[Detached]] internal slot value to true.

2. If this p1010 MessagePort object is entangled, disentangle it.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1010 , by all objects implementing the MessagePort interface:

Event handler p941 p944 Event handler event type

onmessage message

p1271 ✔ MDN

p1272 MDN

onmessageerror messageerror

The first time a p1010 p1012 p1010 MessagePort object's onmessage IDL attribute is set, the port's port message queue must be enabled, as if the p1012 start() method had been called.



9.5.4 Broadcasting to many ports p10 §

12

This section is non-normative.

Broadcasting to many ports is in principle relatively simple: keep an array of p1010 MessagePort objects to send messages to, and iterate through the array to send a message. However, this has one rather unfortunate effect: it prevents the ports from being garbage collected, even if the other side has gone away. To avoid this problem, implement a simple protocol whereby the other side acknowledges it still exists. If it doesn't do so after a certain amount of time, assume it's gone, close the p1010 MessagePort object, and let it be garbage collected.



1012

9.5.5 Ports and garbage collection p10 §

13

When a p1010 p1010 MessagePort object o is entangled, user agents must either act as if o 's entangled MessagePort object has a strong reference to p911 o , or as if o 's relevant global object has a strong reference to o.

Note

Thus, a message port can be received, given an event listener, and then forgotten, and so long as that event listener could receive

a message, the channel will be maintained.

Of course, if this was to occur on both sides of the channel, then both ports could be garbage collected, since they would not be

reachable from live code, despite having a strong reference to each other.

Furthermore, a p1010 p932 MessagePort object must not be garbage collected while there exists an event referenced by a task in a task

queue p931 p1010 p1010 p1010 that is to be dispatched on that MessagePort object, or while the MessagePort object's port message queue is enabled and not empty.

Note

Authors are strongly encouraged to explicitly close p1010 MessagePort objects to disentangle them, so that their resources can be

recollected. Creating many p1010 MessagePort objects and discarding them without closing them can lead to high transient memory

usage since garbage collection is not necessarily performed promptly, especially for p1010 MessagePorts where garbage collection

can involve cross-process coordination.



MDN

9.6 Broadcasting to other browsing contexts p10 §

13

Pages on a single p841 p814 origin opened by the same user in the same user agent but in different unrelated browsing contexts sometimes need to send notifications to each other, for example "hey, the user logged in over here, check your credentials again".

For elaborate cases, e.g. to manage locking of shared state, to manage synchronization of resources between a server and multiple local clients, to share a p996 p1042 WebSocket connection with a remote host, and so forth, shared workers are the most appropriate solution.

For simple cases, though, where a shared worker would be an unreasonable overhead, authors can use the simple channel-based MDN broadcast mechanism described in this section.

IDL [Exposed=(Window,Worker)]

interface BroadcastChannel : EventTarget {

constructor(DOMString name);

readonly attribute DOMString name;

undefined postMessage(any message);

undefined close();

attribute EventHandler onmessage;

attribute EventHandler onmessageerror;

};



For web developers (non-normative)

broadcastChannel p1014 = new BroadcastChannel(name)

Returns a new p1013 BroadcastChannel object via which messages for the given channel name can be sent and received.

broadcastChannel p1014 . name

Returns the channel name (as passed to the constructor).

broadcastChannel p1014 . postMessage(message)

Sends the given message to other p1013 BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.

broadcastChannel p1014 . close()

Closes the p1013 BroadcastChannel object, opening it up to garbage collection.

1013





MDN


A p1013 BroadcastChannel object has a channel name and a closed flag.

The new BroadcastChannel(name) constructor steps are:

1. Set p1014 this 's channel name to name.

2. Set p1014 this 's closed flag to false.

p1014 MDN

The name getter steps are to return this's channel name . MDN

The postMessage(message) method steps are:

1. If p1014 this 's closed flag is true, then throw an "InvalidStateError" DOMException.

2. Let p108 serialized be StructuredSerialize(message). Rethrow any exceptions.

3. Let p911 p904 sourceOrigin be this 's relevant settings object 's origin.

4. Let p1013 destinations be a list of BroadcastChannel objects that match the following criteria:

◦ Their p911 relevant global object is either:

▪ a p828 p829 p818 Window object whose associated Document is fully active , or

▪ a p1032 p1035 p1041 WorkerGlobalScope object whose closing flag is false and whose worker is not a

suspendable worker p1036.

◦ Their p911 p904 p842 relevant settings object 's origin is same origin with sourceOrigin.

◦ Their p1014 p1014 channel name is this 's channel name.

5. Remove source from destinations.

6. Sort p1013 p901 destinations such that all BroadcastChannel objects whose relevant agents are the same are sorted in creation

order, oldest first. (This does not define a complete ordering. Within this constraint, user agents may sort the list in any

implementation-defined manner.)

7. For each p933 p939 destination in destinations , queue a global task on the DOM manipulation task source given destination's

relevant global object p911 to perform the following steps:

1. If p1014 destination 's closed flag is true, then abort these steps.

2. Let p911 targetRealm be destination 's relevant Realm .

3. Let p108 data be StructuredDeserialize(serialized, targetRealm).

If this throws an exception, catch it, p1272 p986 fire an event named messageerror at destination , using MessageEvent,

with the p986 p841 origin attribute initialized to the serialization of sourceOrigin, and then abort these steps.

4. p1271 p986 p986 Fire an event named message at destination , using MessageEvent , with the data attribute initialized to

data p986 p841 and the origin attribute initialized to the serialization of sourceOrigin.

While a p1013 p1014 p1271 BroadcastChannel object whose closed flag is false has an event listener registered for message or

messageerror p1272 p1013 p911 events, there must be a strong reference from the BroadcastChannel object's relevant global object to the MDN

BroadcastChannel p1013 object itself.

The p1014 close() method steps are to set this 's closed flag to true.

Note

Authors are strongly encouraged to explicitly close p1013 BroadcastChannel objects when they are no longer needed, so that they

can be garbage collected. Creating many p1013 BroadcastChannel objects and discarding them while leaving them with an event

listener and without closing them can lead to an apparent memory leak, since the objects will continue to live for as long as they

have an event listener (or until their page or worker is closed).



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1013 , by all objects implementing the BroadcastChannel interface:

1014

Event handler p941 p944 Event handler event type

onmessage message

p1271 MDN

p1272 MDN

onmessageerror messageerror



Example

Suppose a page wants to know when the user logs out, even when the user does so from another tab at the same site:

var authChannel = new BroadcastChannel('auth');

authChannel.onmessage = function (event) {

if (event.data == 'logout')

showLogout();

}

function logoutRequested() {

// called when the user asks us to log them out

doLogout();

showLogout();

authChannel.postMessage('logout');

}

function doLogout() {

// actually log the user out (e.g. clearing cookies)

// ...

}

function showLogout() {

// update the UI to indicate we're logged out

// ...

}



1015

10 Web workers §

p10 ✔ MDN

16



10.1 Introduction p10 §

16

10.1.1 Scope p10 §

16

This section is non-normative.

This specification defines an API for running scripts in the background independently of any user interface scripts.

This allows for long-running scripts that are not interrupted by scripts that respond to clicks or other user interactions, and allows long tasks to be executed without yielding to keep the page responsive.

Workers (as these background scripts are called herein) are relatively heavy-weight, and are not intended to be used in large numbers. For example, it would be inappropriate to launch one worker for each pixel of a four megapixel image. The examples below show some appropriate uses of workers.

Generally, workers are expected to be long-lived, have a high start-up performance cost, and a high per-instance memory cost.



10.1.2 Examples p10 §

16

This section is non-normative.

There are a variety of uses that workers can be put to. The following subsections show various examples of this use.



10.1.2.1 A background number-crunching worker p10 §

16

This section is non-normative.

The simplest use of workers is for performing a computationally expensive task without interrupting the user interface.

In this example, the main document spawns a worker to (naïvely) compute prime numbers, and progressively displays the most recently found prime number.

The main page is as follows:





Worker example: One-core computation





The highest prime number discovered so far is:





The p1042 p1041 Worker() constructor call creates a worker and returns a Worker object representing that worker, which is used to

1016

communicate with the worker. That object's p1042 onmessage event handler allows the code to receive messages from the worker.

The worker itself is as follows:

var n = 1;

search: while (true) {

n += 1;

for (var i = 2; i <= Math.sqrt(n); i += 1)

if (n % i == 0)

continue search;

// found a prime!

postMessage(n);

}

The bulk of this code is simply an unoptimized search for a prime number. The p1034 postMessage() method is used to send a message back to the page when a prime is found.

View this example online.



10.1.2.2 Using a JavaScript module as a worker p10 §

17

This section is non-normative.

All of our examples so far show workers that run p912 p912 classic scripts . Workers can instead be instantiated using module scripts, which have the usual benefits: the ability to use the JavaScript import statement to import other modules; strict mode by default; and top-level declarations not polluting the worker's global scope.

As the p1044 import statement is available, the importScripts() method will automatically fail inside module workers.

In this example, the main document uses a worker to do off-main-thread image manipulation. It imports the filters used from another module.

The main page is as follows:





Worker example: image decoding





Type an image URL to decode





Choose a filter to apply

none grayscale brighten by 20%





1017





The worker file is then:

import * as filters from "./filters.js";

self.onmessage = e => {

const { imageData, filter } = e.data;

filters[filter](imageData);

self.postMessage(imageData, [imageData.data.buffer]);

};

Which imports the file filters.js:

export function none() {}

export function grayscale({ data: d }) {

for (let i = 0; i < d.length; i += 4) {

1018

const [r, g, b] = [d[i], d[i + 1], d[i + 2]];

// CIE luminance for the RGB

// The human eye is bad at seeing red and blue, so we de-emphasize them. d[i] = d[i + 1] = d[i + 2] = 0.2126 * r + 0.7152 * g + 0.0722 * b;

}

};

export function brighten({ data: d }) {

for (let i = 0; i < d.length; ++i) {

d[i] *= 1.2;

}

};

View this example online.



MDN

10.1.2.3 Shared workers introduction p10 §

19

This section is non-normative.

This section introduces shared workers using a Hello World example. Shared workers use slightly different APIs, since each worker can have multiple connections.

This first example shows how you connect to a worker and how a worker can send a message back to the page when it connects to it. Received messages are displayed in a log.

Here is the HTML page:





Shared workers: demo 1





Log:





Here is the JavaScript worker:

onconnect = function(e) {

var port = e.ports[0];

port.postMessage('Hello World!');

}

View this example online.



This second example extends the first one by changing two things: first, messages are received using addEventListener() instead of an p942 event handler IDL attribute , and second, a message is sent to the worker, causing the worker to send another message in return. Received messages are again displayed in a log.

Here is the HTML page:





1019

Shared workers: demo 2





Log:





Here is the JavaScript worker:

onconnect = function(e) {

var port = e.ports[0];

port.postMessage('Hello World!');

port.onmessage = function(e) {

port.postMessage('pong'); // not e.ports[0].postMessage!

// e.target.postMessage('pong'); would work also

}

}

View this example online.



Finally, the example is extended to show how two pages can connect to the same worker; in this case, the second page is merely in an

iframe p362 on the first page, but the same principle would apply to an entirely separate page in a separate top-level browsing

context p817 .

Here is the outer HTML page:





Shared workers: demo 3





Log:





Here is the inner HTML page:





Shared workers: demo 3 inner frame





Inner log:





Here is the JavaScript worker:

var count = 0;

onconnect = function(e) {

count += 1;

var port = e.ports[0];

port.postMessage('Hello World! You are connection #' + count); port.onmessage = function(e) {

port.postMessage('pong');

}

}

View this example online.



10.1.2.4 Shared state using a shared worker p10 §

21

This section is non-normative.

In this example, multiple windows (viewers) can be opened that are all viewing the same map. All the windows share the same map information, with a single worker coordinating all the viewers. Each viewer can move around independently, but if they set any data on the map, all the viewers are updated.

The main page isn't interesting, it merely provides a way to open the viewers:





Workers example: Multiviewer





Open a new

viewer





Each viewer opens in a new window. You can have as many viewers as you like, they all view the same data.





The viewer is more involved:





Workers example: Multiviewer viewer





Viewer





Map





Left Up Down Right Set 0 Set 1





Public Chat





Post





Private Chat





There are several key things worth noting about the way the viewer is written.

Multiple listeners. Instead of a single message processing function, the code here attaches multiple event listeners, each one

1023

performing a quick check to see if it is relevant for the message. In this example it doesn't make much difference, but if multiple authors wanted to collaborate using a single port to communicate with a worker, it would allow for independent code instead of changes having to all be made to a single event handling function.

Registering event listeners in this way also allows you to unregister specific listeners when you are done with them, as is done with the configure() method in this example.

Finally, the worker:

var nextName = 0;

function getNextName() {

// this could use more friendly names

// but for now just return a number

return nextName++;

}

var map = [

[0, 0, 0, 0, 0, 0, 0],

[1, 1, 0, 1, 0, 1, 1],

[0, 1, 0, 1, 0, 0, 0],

[0, 1, 0, 1, 0, 1, 1],

[0, 0, 0, 1, 0, 0, 0],

[1, 0, 0, 1, 1, 1, 1],

[1, 1, 0, 1, 1, 0, 1],

];

function wrapX(x) {

if (x < 0) return wrapX(x + map[0].length);

if (x >= map[0].length) return wrapX(x-map[0].length);

return x;

}

function wrapY(y) {

if (y < 0) return wrapY(y + map.length);

if (y >= map[0].length) return wrapY(y-map.length);

return y;

}

function wrap(val, min, max) {

if (val < min)

return val + (max-min)+1;

if (val > max)

return val- (max-min)-1;

return val;

}

function sendMapData(viewer) {

var data = '';

for (var y = viewer.y-1; y <= viewer.y+1; y += 1) {

for (var x = viewer.x-1; x <= viewer.x+1; x += 1) {

if (data != '')

data += ',';

data += map[wrap(y, 0, map[0].length-1)][wrap(x, 0, map.length-1)];

}

}

viewer.port.postMessage('map ' + data);

}

var viewers = {};

onconnect = function (event) {

var name = getNextName();

event.ports[0]._data = { port: event.ports[0], name: name, x: 0, y: 0, }; viewers[name] = event.ports[0]._data;

1024

event.ports[0].postMessage('cfg ' + name);

event.ports[0].onmessage = getMessage;

sendMapData(event.ports[0]._data);

};

function getMessage(event) {

switch (event.data.substr(0, 4)) {

case 'mov ':

var direction = event.data.substr(4);

var dx = 0;

var dy = 0;

switch (direction) {

case 'up': dy = -1; break;

case 'down': dy = 1; break;

case 'left': dx = -1; break;

case 'right': dx = 1; break;

}

event.target._data.x = wrapX(event.target._data.x + dx);

event.target._data.y = wrapY(event.target._data.y + dy);

sendMapData(event.target._data);

break;

case 'set ':

var value = event.data.substr(4);

map[event.target._data.y][event.target._data.x] = value;

for (var viewer in viewers)

sendMapData(viewers[viewer]);

break;

case 'txt ':

var name = event.target._data.name;

var message = event.data.substr(4);

for (var viewer in viewers)

viewers[viewer].port.postMessage('txt ' + name + ' ' + message);

break;

case 'msg ':

var party1 = event.target._data;

var party2 = viewers[event.data.substr(4).split(' ', 1)[0]];

if (party2) {

var channel = new MessageChannel();

party1.port.postMessage('msg ' + party2.name, [channel.port1]); party2.port.postMessage('msg ' + party1.name, [channel.port2]);

}

break;

}

}

Connecting to multiple pages p1035 . The script uses the onconnect event listener to listen for multiple connections.

Direct channels. When the worker receives a "msg" message from one viewer naming another viewer, it sets up a direct connection between the two, so that the two viewers can communicate directly without the worker having to proxy all the messages.

View this example online.



10.1.2.5 Delegation p10 §

25

This section is non-normative.

With multicore CPUs becoming prevalent, one way to obtain better performance is to split computationally expensive tasks amongst multiple workers. In this example, a computationally expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten subworkers.

The main page is as follows, it just reports the result:

1025





Worker example: Multicore computation





Result:





The worker itself is as follows:

// settings

var num_workers = 10;

var items_per_worker = 1000000;

// start the workers

var result = 0;

var pending_workers = num_workers;

for (var i = 0; i < num_workers; i += 1) {

var worker = new Worker('core.js');

worker.postMessage(i * items_per_worker);

worker.postMessage((i+1) * items_per_worker);

worker.onmessage = storeResult;

}

// handle the results

function storeResult(event) {

result += 1*event.data;

pending_workers-= 1;

if (pending_workers <= 0)

postMessage(result); // finished!

}

It consists of a loop to start the subworkers, and then a handler that waits for all the subworkers to respond.

The subworkers are implemented as follows:

var start;

onmessage = getStart;

function getStart(event) {

start = 1*event.data;

onmessage = getEnd;

}

var end;

function getEnd(event) {

end = 1*event.data;

onmessage = null;

work();

}

function work() {

var result = 0;

for (var i = start; i < end; i += 1) {

1026

// perform some complex calculation here

result += 1;

}

postMessage(result);

close();

}

They receive two numbers in two events, perform the computation for the range of numbers thus specified, and then report the result back to the parent.

View this example online.



10.1.2.6 Providing libraries p10 §

27

This section is non-normative.

Suppose that a cryptography library is made available that provides three tasks: Generate a public/private key pair

Takes a port, on which it will send two messages, first the public key and then the private key.

Given a plaintext and a public key, return the corresponding ciphertext

Takes a port, to which any number of messages can be sent, the first giving the public key, and the remainder giving the plaintext, each of which is encrypted and then sent on that same channel as the ciphertext. The user can close the port when it is done encrypting content.

Given a ciphertext and a private key, return the corresponding plaintext

Takes a port, to which any number of messages can be sent, the first giving the private key, and the remainder giving the ciphertext, each of which is decrypted and then sent on that same channel as the plaintext. The user can close the port when it is done decrypting content.

The library itself is as follows:

function handleMessage(e) {

if (e.data == "genkeys")

genkeys(e.ports[0]);

else if (e.data == "encrypt")

encrypt(e.ports[0]);

else if (e.data == "decrypt")

decrypt(e.ports[0]);

}

function genkeys(p) {

var keys = _generateKeyPair();

p.postMessage(keys[0]);

p.postMessage(keys[1]);

}

function encrypt(p) {

var key, state = 0;

p.onmessage = function (e) {

if (state == 0) {

key = e.data;

state = 1;

} else {

p.postMessage(_encrypt(key, e.data));

}

};

}

function decrypt(p) {

1027

var key, state = 0;

p.onmessage = function (e) {

if (state == 0) {

key = e.data;

state = 1;

} else {

p.postMessage(_decrypt(key, e.data));

}

};

}

// support being used as a shared worker as well as a dedicated worker if ('onmessage' in this) // dedicated worker

onmessage = handleMessage;

else // shared worker

onconnect = function (e) { e.port.onmessage = handleMessage; }



// the "crypto" functions:

function _generateKeyPair() {

return [Math.random(), Math.random()];

}

function _encrypt(k, s) {

return 'encrypted-' + k + ' ' + s;

}

function _decrypt(k, s) {

return s.substr(s.indexOf(' ')+1);

}

Note that the crypto functions here are just stubs and don't do real cryptography.

This library could be used as follows:





Worker example: Crypto library





Keys



Public Key:

Private Key:





Input:

Encrypt Decrypt





A later version of the API, though, might want to offload all the crypto work onto subworkers. This could be done as follows:

function handleMessage(e) {

if (e.data == "genkeys")

genkeys(e.ports[0]);

else if (e.data == "encrypt")

encrypt(e.ports[0]);

else if (e.data == "decrypt")

decrypt(e.ports[0]);

}

function genkeys(p) {

var generator = new Worker('libcrypto-v2-generator.js');

generator.postMessage('', [p]);

}

function encrypt(p) {

p.onmessage = function (e) {

var key = e.data;

var encryptor = new Worker('libcrypto-v2-encryptor.js');

encryptor.postMessage(key, [p]);

};

}

function encrypt(p) {

p.onmessage = function (e) {

var key = e.data;

var decryptor = new Worker('libcrypto-v2-decryptor.js');

decryptor.postMessage(key, [p]);

};

}

1029

// support being used as a shared worker as well as a dedicated worker if ('onmessage' in this) // dedicated worker

onmessage = handleMessage;

else // shared worker

onconnect = function (e) { e.ports[0].onmessage = handleMessage }; The little subworkers would then be as follows.

For generating key pairs:

onmessage = function (e) {

var k = _generateKeyPair();

e.ports[0].postMessage(k[0]);

e.ports[0].postMessage(k[1]);

close();

}

function _generateKeyPair() {

return [Math.random(), Math.random()];

}

For encrypting:

onmessage = function (e) {

var key = e.data;

e.ports[0].onmessage = function (e) {

var s = e.data;

postMessage(_encrypt(key, s));

}

}

function _encrypt(k, s) {

return 'encrypted-' + k + ' ' + s;

}

For decrypting:

onmessage = function (e) {

var key = e.data;

e.ports[0].onmessage = function (e) {

var s = e.data;

postMessage(_decrypt(key, s));

}

}

function _decrypt(k, s) {

return s.substr(s.indexOf(' ')+1);

}

Notice how the users of the API don't have to even know that this is happening — the API hasn't changed; the library can delegate to subworkers without changing its API, even though it is accepting data using message channels.

View this example online.



10.1.3 Tutorials p10 §

30

10.1.3.1 Creating a dedicated worker p10 §

30

This section is non-normative.

1030

Creating a worker requires a URL to a JavaScript file. The p1042 Worker() constructor is invoked with the URL to that file as its only argument; a worker is then created and returned:

var worker = new Worker('helper.js');

If you want your worker script to be interpreted as a p912 p912 module script instead of the default classic script, you need to use a slightly different signature:

var worker = new Worker('helper.mjs', { type: "module" });



10.1.3.2 Communicating with a dedicated worker p10 §

31

This section is non-normative.

Dedicated workers use p1010 MessagePort objects behind the scenes, and thus support all the same features, such as sending structured data, transferring binary data, and transferring other ports.

To receive messages from a dedicated worker, use the p1042 p942 p1041 onmessage event handler IDL attribute on the Worker object:

worker.onmessage = function (event) { ... }; You can also use the addEventListener() method.

Note

The implicit p1010 p1010 MessagePort used by dedicated workers has its port message queue implicitly enabled when it is created, so

there is no equivalent to the p1010 p1012 p1041 MessagePort interface's start() method on the Worker interface.

To p1041 send data to a worker, use the postMessage() method. Structured data can be sent over this communication channel. To send

ArrayBuffer objects efficiently (by transferring them rather than cloning them), list them in an array in the second argument.

worker.postMessage({

operation: 'find-edges',

input: buffer, // an ArrayBuffer object

threshold: 0.6,

}, [buffer]);

To receive a message inside the worker, the p1035 p942 onmessage event handler IDL attribute is used.

onmessage = function (event) { ... };

You can again also use the addEventListener() method.

In either case, the data is provided in the event object's p986 data attribute.

To send messages back, you again use p1034 postMessage(). It supports the structured data in the same manner.

postMessage(event.data.input, [event.data.input]); // transfer the buffer back



MDN

10.1.3.3 Shared workers p10 §

31

This section is non-normative.

Shared workers are identified by the URL of the script used to create it, optionally with an explicit name. The name allows multiple instances of a particular shared worker to be started.

Shared workers are scoped by p841 origin. Two different sites using the same names will not collide. However, if a page tries to use the

1031

same shared worker name as another page on the same site, but with a different script URL, it will fail.

Creating shared workers is done using the p1043 SharedWorker() constructor. This constructor takes the URL to the script to use for its first argument, and the name of the worker, if any, as the second argument.

var worker = new SharedWorker('service.js'); Communicating with shared workers is done with explicit p1010 p1043 MessagePort objects. The object returned by the SharedWorker()

constructor holds a reference to the port on its p1043 port attribute.

worker.port.onmessage = function (event) { ... };

worker.port.postMessage('some message');

worker.port.postMessage({ foo: 'structured', bar: ['data', 'also', 'possible']}); Inside the shared worker, new clients of the worker are announced using the p1271 connect event. The port for the new client is given by the event object's p987 source attribute.

onconnect = function (event) {

var newPort = event.source;

// set up a listener

newPort.onmessage = function (event) { ... };

// send a message back to the port

newPort.postMessage('ready!'); // can also send structured data, of course

};



10.2 Infrastructure p10 §

32

This standard defines two kinds of workers: dedicated workers, and shared workers. Dedicated workers, once created, are linked to their creator, but message ports can be used to communicate from a dedicated worker to multiple other browsing contexts or workers.

Shared workers, on the other hand, are named, and once created any script running in the same p841 origin can obtain a reference to that worker and communicate with it. p1281 Service Workers defines a third kind. [SW]



10.2.1 The global scope p10 §

32

The global scope is the "inside" of a worker.



10.2.1.1 The p1032 p10 WorkerGlobalScope common interface §

32

IDL [Exposed=Worker] ✔ MDN

interface WorkerGlobalScope : EventTarget {

readonly attribute WorkerGlobalScope self;

readonly attribute WorkerLocation location;

readonly attribute WorkerNavigator navigator;

undefined importScripts(USVString... urls);

attribute OnErrorEventHandler onerror;

attribute EventHandler onlanguagechange;

attribute EventHandler onoffline;

attribute EventHandler ononline;

attribute EventHandler onrejectionhandled;

attribute EventHandler onunhandledrejection;

};

WorkerGlobalScope p1032 serves as the base class for specific types of worker global scope objects, including

1032

DedicatedWorkerGlobalScope p1034 p1035 , SharedWorkerGlobalScope, and ServiceWorkerGlobalScope.

A p1032 p115 p1032 WorkerGlobalScope object has an associated owner set (a set of Document and WorkerGlobalScope objects). It is initially empty and populated when the worker is created or obtained.

Note

It is a p1035 set , instead of a single owner, to accomodate SharedWorkerGlobalScope objects.

A p1032 p1032 WorkerGlobalScope object has an associated worker set (a set of WorkerGlobalScope objects). It is initially empty and populated when the worker creates or obtains further workers.

A p1032 WorkerGlobalScope object has an associated type ("classic" or "module"). It is set during creation.

A p1032 WorkerGlobalScope object has an associated url (null or a URL). It is initially null.

A p1032 WorkerGlobalScope object has an associated name (a string). It is set during creation.

Note

The p1033 p1032 p1034 name can have different semantics for each subclass of WorkerGlobalScope . For DedicatedWorkerGlobalScope

instances, it is simply a developer-supplied name, useful mostly for debugging purposes. For p1035 SharedWorkerGlobalScope

instances, it allows obtaining a reference to a common shared worker via the p1043 SharedWorker() constructor. For

ServiceWorkerGlobalScope objects, it doesn't make sense (and as such isn't exposed through the JavaScript API at all).

A p1032 WorkerGlobalScope object has an associated referrer policy (a referrer policy). It is initially the empty string.

A p1032 p856 WorkerGlobalScope object has an associated embedder policy (an embedder policy).

A p1032 WorkerGlobalScope object has an associated CSP list, which is a CSP list containing all of the Content Security Policy objects active for the worker. It is initially an empty list.

A p1032 p928 WorkerGlobalScope object has an associated module map . It is a module map , initially empty.

A p1032 WorkerGlobalScope object has an associated cross-origin isolated capability boolean. It is initially false.

For web developers (non-normative)

workerGlobal p1033 . self

Returns workerGlobal.

workerGlobal p1033 . location

Returns p1045 workerGlobal 's WorkerLocation object.

workerGlobal p1045 . navigator

Returns p1045 workerGlobal 's WorkerNavigator object.

workerGlobal p1044 . importScripts(urls...)

Fetches each URL in urls, executes them one-by-one in the order they are passed, and then returns (or throws if something went amiss).

✔ MDN

The p1032 self attribute must return the WorkerGlobalScope object itself. ✔ MDN

The p1045 p1045 location attribute must return the WorkerLocation object whose associated WorkerGlobalScope object is the

WorkerGlobalScope p1032 object.

Note

While the p1045 p1032 WorkerLocation object is created after the WorkerGlobalScope object, this is not problematic as it cannot be

observed from script.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1032 , by objects implementing the WorkerGlobalScope interface:

1033

Event handlerp941 p944 Event handler event type

onerror error

p1271 ✔ MDN

p1271 ✔ MDN

onlanguagechange languagechange

p1272 MDN

onoffline offline

ononline online

p1272 MDN

onrejectionhandled rejectionhandledp1272

onunhandledrejection p1272 unhandledrejection



10.2.1.2 Dedicated workers and the p1034 p10 DedicatedWorkerGlobalScope interface §

34

IDL ✔ [ Global =( Worker , DedicatedWorker ), Exposed = DedicatedWorker ] MDN

interface DedicatedWorkerGlobalScope : WorkerGlobalScope {

[Replaceable] readonly attribute DOMString name;

undefined postMessage(any message, sequence<object> transfer);

undefined postMessage(any message, optional PostMessageOptions options = {});

undefined close();

attribute EventHandler onmessage;

attribute EventHandler onmessageerror;

};

DedicatedWorkerGlobalScope p1034 p1010 objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the

DedicatedWorkerGlobalScope p1034 object.

All messages received by that port must immediately be retargeted at the p1034 DedicatedWorkerGlobalScope object.

For web developers (non-normative)

dedicatedWorkerGlobal p1034 . name

Returns p1033 p1041 dedicatedWorkerGlobal 's name , i.e. the value given to the Worker constructor. Primarily useful for debugging.

dedicatedWorkerGlobal p1034 . postMessage(message [, transfer ])

dedicatedWorkerGlobal p1034 p1010 . postMessage ( message [, { transfer } ])

Clones p1041 message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.

dedicatedWorkerGlobal p1034 . close()

Aborts dedicatedWorkerGlobal.



The p1034 p1033 name attribute must return the DedicatedWorkerGlobalScope object's name. Its value represents the name given to the ✔ MDN MDN

worker using the p1041 Worker constructor, used primarily for debugging purposes.

The p1034 postMessage( message , transfer ) and postMessage( message , options ) methods on DedicatedWorkerGlobalScope

objects act as if, when invoked, it immediately invoked the respective p1012 postMessage( message , transfer ) and

postMessage( p1012 message , options ) on the port, with the same arguments, and returned the same return value.

To close a worker, given a workerGlobal, run these steps:

1. Discard any p932 p901 p931 p931 tasks that have been added to workerGlobal 's relevant agent 's event loop 's task queues .

2. Set p1035 workerGlobal 's closing flag to true. (This prevents any further tasks from being queued.) The p1034 p1034 close() method, when invoked, must close a worker with this DedicatedWorkerGlobalScope object. MDN



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1034 , by objects implementing the DedicatedWorkerGlobalScope interface:

1034

Event handler p941 p944 Event handler event type

onmessage message

p1271 ✔ MDN

p1272 MDN

onmessageerror messageerror



10.2.1.3 Shared workers and the p1035 p10 SharedWorkerGlobalScope interface §

35

IDL ✔ [ Global =( Worker , SharedWorker ), Exposed = SharedWorker ] MDN

interface SharedWorkerGlobalScope : WorkerGlobalScope {

[Replaceable] readonly attribute DOMString name;

undefined close();

attribute EventHandler onconnect;

};

A p1035 SharedWorkerGlobalScope object has an associated constructor origin, constructor url, and credentials. They are initialized when the p1035 p1036 SharedWorkerGlobalScope object is created, in the run a worker algorithm.

Shared workers receive message ports through p1271 p1035 connect events on their SharedWorkerGlobalScope object for each connection.

For web developers (non-normative)

sharedWorkerGlobal p1035 . name

Returns p1033 p1042 p1042 sharedWorkerGlobal 's name , i.e. the value given to the SharedWorker constructor. Multiple SharedWorker

objects can correspond to the same shared worker (and p1035 SharedWorkerGlobalScope), by reusing the same name.

sharedWorkerGlobal p1035 . close()

Aborts sharedWorkerGlobal.



The p1035 p1033 name attribute must return the SharedWorkerGlobalScope object's name. Its value represents the name that can be used ⚠ MDN MDN

to obtain a reference to the worker using the p1042 SharedWorker constructor.

The p1034 p1035 close() method, when invoked, must close a worker with this SharedWorkerGlobalScope object.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1035 , by objects implementing the SharedWorkerGlobalScope interface:

Event handler p941 p944 Event handler event type

onconnect connect

p1271 MDN



10.2.2 The event loop p10 §

35

A p931 p931 p932 worker event loop 's task queues only have events, callbacks, and networking activity as tasks. These worker event

loops p931 p1036 are created by the run a worker algorithm.

Each p1032 WorkerGlobalScope object has a closing flag, which must be initially false, but which can get set to true by the algorithms in the processing model section below.

Once the p1032 p1035 p931 p931 WorkerGlobalScope 's closing flag is set to true, the event loop 's task queues must discard any further

tasks p932 that would be added to them (tasks already on the queue are unaffected except where otherwise specified). Effectively, once the p1035 closing flag is true, timers stop firing, notifications for all pending background operations are dropped, etc.



1035

10.2.3 The worker's lifetime p10 §

36

Workers communicate with other workers and with p814 p1006 p1010 browsing contexts through message channels and their MessagePort objects.

Each p1032 p1010 WorkerGlobalScope object worker global scope has a list of the worker's ports , which consists of all the MessagePort

objects that are entangled with another port and that have one (but only one) port owned by worker global scope. This list includes the implicit p1010 p1034 MessagePort in the case of dedicated workers.

Given an p904 environment settings object o when creating or obtaining a worker, the relevant owner to add depends on the type of

global object p905 p905 p1032 specified by o . If o specifies a global object that is a WorkerGlobalScope object (i.e., if we are creating a nested dedicated worker), then the relevant owner is that global object. Otherwise, p905 p828 o specifies a global object that is a Window

object, and the relevant owner is the p904 responsible document specified by o.



A worker is said to be a p1032 p1033 permissible worker if its WorkerGlobalScope 's owner set is not empty or:

• its p1033 owner set has been empty for no more than a short implementation-defined timeout value,

• its p1032 p1035 WorkerGlobalScope object is a SharedWorkerGlobalScope object (i.e., the worker is a shared worker), and

• the user agent has a p814 p115 p894 browsing context whose Document object is not completely loaded.

Note

The second part of this definition allows a shared worker to survive for a short time while a page is loading, in case that page is

going to contact the shared worker again. This can be used by user agents as a way to avoid the cost of restarting a shared worker

used by a site when the user is navigating from page to page within that site.

A worker is said to be an p1033 p115 p818 active needed worker if any its owners are either Document objects that are fully active or active

needed workers p1036.

A worker is said to be a p1036 protected worker if it is an active needed worker and either it has outstanding timers, database transactions, or network connections, or its list of p1036 p1032 the worker's ports is not empty, or its WorkerGlobalScope is actually a

SharedWorkerGlobalScope p1035 object (i.e., the worker is a shared worker).

A worker is said to be a p1036 p1036 suspendable worker if it is not an active needed worker but it is a permissible worker.



10.2.4 Processing model p10 §

36

When a user agent is to p1041 p1042 run a worker for a script with Worker or SharedWorker object worker, URL url, environment settings

object p904 p1010 p1041 outside settings , MessagePort outside port , and a WorkerOptions dictionary options, it must run the following steps.

1. Let p1042 is shared be true if worker is a SharedWorker object, and false otherwise.

2. Let p1036 owner be the relevant owner to add given outside settings.

3. Let parent worker global scope be null.

4. If p1032 owner is a WorkerGlobalScope object (i.e., we are creating a nested dedicated worker), then set parent worker global

scope to owner.

5. Let p902 agent be the result of obtaining a dedicated/shared worker agent given outside settings and is shared. Run the rest of

these steps in that agent.

For the purposes of timing APIs, this is the official moment of creation of the worker.

6. Let p905 realm execution context be the result of creating a new JavaScript realm given agent and the following

customizations:

◦ For the global object, if p1035 is shared is true, create a new SharedWorkerGlobalScope object. Otherwise, create a

new p1034 DedicatedWorkerGlobalScope object.

7. Let p905 worker global scope be the global object of realm execution context's Realm component.



1036

Note

This is the p1034 p1035 DedicatedWorkerGlobalScope or SharedWorkerGlobalScope object created in the previous step.

8. p1040 Set up a worker environment settings object with realm execution context and outside settings, and let inside settings be

the result.

9. Set p1033 worker global scope 's name to the value of options's name member.

10. p1033 Append owner to worker global scope 's owner set.

11. If p1033 parent worker global scope is not null, then append worker global scope to parent worker global scope 's worker set.

12. If is shared is true, then:

1. Set p1035 p904 worker global scope 's constructor origin to outside settings 's origin.

2. Set p1035 worker global scope 's constructor url to url.

3. Set p1033 worker global scope 's type to the value of options's type member.

4. Set p1035 worker global scope 's credentials to the value of options's credentials member.

13. Let destination be "sharedworker" if is shared is true, and "worker" otherwise.

14. Obtain script by switching on the value of options's type member:

↪ "classic"

Fetch a classic worker script p914 given url, outside settings, destination, and inside settings.

↪ "module"

Fetch a module worker script graph p917 given url, outside settings, destination, the value of the credentials member of options, and inside settings.

In both cases, to p913 p913 perform the fetch given request , perform the following steps if the is top-level flag is set:

1. Set request's reserved client to inside settings.

2. Fetch request, and asynchronously wait to run the remaining steps as part of fetch's process response for the

response response.

3. Set p1033 worker global scope 's url to response's url.

4. Set p1033 worker global scope 's referrer policy to the result of parsing the `Referrer-Policy` header of response.

5. If p1033 response 's url 's scheme is a local scheme , then set worker global scope 's embedder policy to owner's

embedder policy p904.

6. Otherwise, set p1033 p857 worker global scope 's embedder policy to the result of obtaining an embedder policy from

response.

7. If p1033 p856 worker global scope 's embedder policy is " require-corp" and is shared is true, then set agent's agent

cluster p901 's cross-origin isolated to true.

This really ought to be set when the agent cluster is created, which requires a redesign of this section.

8. If the result of p858 checking a global object's embedder policy with worker global scope, owner, and response is

false, then set response to a network error.

9. Set p1033 p901 worker global scope 's cross-origin isolated capability to agent 's agent cluster 's cross-origin isolated.

10. If p904 is shared is false and owner 's cross-origin isolated capability is false, then set worker global scope's cross-

origin isolated capability p1033 to false.

11. If is shared is false and response's url's scheme is "data", then set worker global scope's cross-origin isolated

capability p1033 to false.

Note

This is a conservative default for now, while we figure out how workers in general, and data: URL workers in

1037

particular (which are cross-origin from their owner), will be treated in the context of permissions policies. See

w3c/webappsec-permissions-policy issue #207 for more details.

12. p1275 Initialize a global object's CSP list given worker global scope and response . [CSP]

13. Asynchronously complete the p913 perform the fetch steps with response.

If the algorithm asynchronously completes with null or with a p912 script whose error to rethrow is non-null, then:

1. p933 p939 p911 Queue a global task on the DOM manipulation task source given worker 's relevant global object to fire an

event p1271 named error at worker.

2. Run the p904 environment discarding steps for inside settings.

3. Return.

Otherwise, continue the rest of these steps after the algorithm's asynchronous completion, with script being the asynchronous completion value.

15. Associate worker with worker global scope.

16. Let p1010 p905 inside port be a new MessagePort object in inside settings 's Realm.

17. Associate inside port with worker global scope.

18. p1010 Entangle outside port and inside port.

19. Create a new p1045 WorkerLocation object and associate it with worker global scope.

20. p1036 Closing orphan workers : Start monitoring the worker such that no sooner than it stops being a protected worker, and

no later than it stops being a p1036 p1035 permissible worker , worker global scope 's closing flag is set to true.

21. p1035 Suspending workers : Start monitoring the worker, such that whenever worker global scope 's closing flag is false and

the worker is a p1036 suspendable worker, the user agent suspends execution of script in that worker until such time as either

the p1035 p1036 closing flag switches to true or the worker stops being a suspendable worker.

22. Set p904 inside settings 's execution ready flag.

23. If p912 p921 p912 script is a classic script , then run the classic script script . Otherwise, it is a module script; run the module

script p922 script.

Note

In addition to the usual possibilities of returning a value or failing due to an exception, this could be prematurely

aborted p923 p1039 by the terminate a worker algorithm defined below.

24. Enable p1010 outside port 's port message queue.

25. If p1010 is shared is false, enable the port message queue of the worker's implicit port.

26. If p933 p939 is shared is true, then queue a global task on DOM manipulation task source given worker global scope to fire an

event p1271 p986 p986 named connect at worker global scope , using MessageEvent , with the data attribute initialized to the empty

string, the p987 p987 ports attribute initialized to a new frozen array containing inside port , and the source attribute initialized to inside port.

27. Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is worker

global scope p911 's relevant settings object.

28. p905 Event loop : Run the responsible event loop specified by inside settings until it is destroyed.

Note

The handling of events or the execution of callbacks by p932 p931 tasks run by the event loop might get prematurely

aborted p923 p1039 by the terminate a worker algorithm defined below.

Note

The worker processing model remains on this step until the event loop is destroyed, which happens after the p1035 closing

flag is set to true, as described in the p931 event loop processing model.

1038

29. Empty the p960 worker global scope 's list of active timers.

30. Disentangle all the ports in the list of p1036 the worker's ports.

31. p1033 Empty worker global scope 's owner set.



When a user agent is to p42 terminate a worker it must run the following steps in parallel with the worker's main loop (the "run a

worker p1036" processing model defined above):

1. Set the worker's p1032 p1035 WorkerGlobalScope object's closing flag to true.

2. If there are any p932 p1032 p901 p931 p931 tasks queued in the WorkerGlobalScope object's relevant agent 's event loop 's task queues ,

discard them without processing them.

3. p923 Abort the script currently running in the worker.

4. If the worker's p1032 p1034 WorkerGlobalScope object is actually a DedicatedWorkerGlobalScope object (i.e. the worker is a

dedicated worker), then empty the p1010 port message queue of the port that the worker's implicit port is entangled with.

User agents may invoke the p1039 p1036 terminate a worker algorithm when a worker stops being an active needed worker and the worker continues executing even after its p1035 closing flag was set to true.



10.2.5 Runtime script errors p10 §

39

Whenever an uncaught runtime script error occurs in one of the worker's scripts, if the error did not occur while handling a previous script error, the user agent must p924 p912 report the error for that script , with the position (line number and column number) where the error occurred, using the p1032 WorkerGlobalScope object as the target.

For shared workers, if the error is still p924 not handled afterwards, the error may be reported to a developer console.

For dedicated workers, if the error is still p924 p933 not handled afterwards, the user agent must queue a task to run these steps:

1. Let p1271 p1041 notHandled be the result of firing an event named error at the Worker object associated with the worker, using

ErrorEvent p924 p925 p925 p925 p925 , with the cancelable attribute initialized to true, the message , filename , lineno , and colno

attributes initialized appropriately, and the p925 error attribute initialized to null.

2. If notHandled is true, then the user agent must act as if the uncaught runtime script error had occurred in the global scope

that the p1041 Worker object is in, thus repeating the entire runtime script error reporting process one level up.

If the implicit port connecting the worker to its p1041 Worker object has been disentangled (i.e. if the parent worker has been terminated), then the user agent must act as if the p1041 p1271 Worker object had no error event handler and as if that worker's

onerror p1034 attribute was null, but must otherwise act as described above.

Note

Thus, error reports propagate up to the chain of dedicated workers up to the original p115 Document , even if some of the workers

along this chain have been terminated and garbage collected.

The p932 p939 task source for the task mentioned above is the DOM manipulation task source.



10.2.6 Creating workers p10 §

39

10.2.6.1 The p1039 p10 AbstractWorker mixin §

39

IDL interface mixin AbstractWorker { ✔ MDN

attribute EventHandler onerror;

};

The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1039 , by objects implementing the AbstractWorker interface:

1039

Event handler p941 p944 Event handler event type

onerror error

p1271 ✔ MDN



10.2.6.2 Script settings for workers p10 §

40

To set up a worker environment settings object, given a JavaScript execution context execution context and environment settings

object p904 outside settings:

1. Let p904 inherited origin be outside settings 's origin .

2. Let realm be the value of execution context's Realm component.

3. Let p905 worker global scope be realm 's global object .

4. Let p904 settings object be a new environment settings object whose algorithms are defined as follows:

The p904 realm execution context

Return execution context.

The p904 module map

Return p1033 worker global scope 's module map.

The p904 responsible document

Not applicable (the p905 p931 responsible event loop is not a window event loop).

The p904 API URL character encoding

Return UTF-8.

The p904 API base URL

Return p1033 worker global scope 's url.

The p904 origin

Return a unique p841 p1033 opaque origin if worker global scope 's url's scheme is "data", and inherited origin otherwise.

The p904 referrer policy

Return p1033 worker global scope 's referrer policy.

The p904 embedder policy

Return p1033 worker global scope 's embedder policy.

The p904 cross-origin isolated capability

Return p1033 worker global scope 's cross-origin isolated capability.

5. Set p903 p903 settings object 's id to a new unique opaque string, creation URL to worker global scope's url, top-level creation

URL p903 p904 p904 to null, target browsing context to null, and active service worker to null.

6. If p1034 p903 worker global scope is a DedicatedWorkerGlobalScope object, then set settings object 's top-level origin to outside

settings p903 's top-level origin.

7. Otherwise, set p903 settings object 's top-level origin to an implementation-defined value.

See Client-Side Storage Partitioning for the latest on properly defining this.

8. Set realm's [[HostDefined]] field to settings object.

9. Return settings object.



1040

10.2.6.3 Dedicated workers and the p1041 p10 Worker interface §

41

IDL [Exposed=(Window,DedicatedWorker,SharedWorker)] ✔ MDN

interface Worker : EventTarget {

constructor(USVString scriptURL, optional WorkerOptions options = {});

undefined terminate();

undefined postMessage(any message, sequence<object> transfer);

undefined postMessage(any message, optional PostMessageOptions options = {});

attribute EventHandler onmessage;

attribute EventHandler onmessageerror;

};

dictionary WorkerOptions {

WorkerType type = "classic";

RequestCredentials credentials = "same-origin"; // credentials is only used if type is "module" DOMString name = "";

};

enum WorkerType { "classic", "module" };

Worker includes AbstractWorker;



For web developers (non-normative)

worker p1042 = new Worker(scriptURL [, options ])

Returns a new p1041 Worker object. scriptURL will be fetched and executed in the background, creating a new global environment

for which p1033 worker represents the communication channel. options can be used to define the name of that global environment via the name option, primarily for debugging purposes. It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.

worker p1041 . terminate()

Aborts worker's associated global environment.

worker p1041 . postMessage(message [, transfer ] )

worker p1041 p1010 . postMessage ( message [, { transfer } ] )

Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned.



The p1039 terminate() method, when invoked, must cause the terminate a worker algorithm to be run on the worker with which the ✔ MDN object is associated.

Worker p1041 p1010 objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the p1041 Worker object.

✔ MDN

All messages received by that port must immediately be retargeted at the p1041 Worker object.

The p1041 postMessage( message , transfer ) and postMessage( message , options ) methods on Worker objects act as if, when invoked, they immediately invoked the respective p1012 p1012 postMessage( message , transfer ) and postMessage( message , options )

on the port, with the same arguments, and returned the same return value.

Example

The p1041 postMessage() method's first argument can be structured data:

worker.postMessage({opcode: 'activate', device: 1938, parameters: [23, 102]});



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler IDL attributes p942 p1041 , by objects implementing the Worker interface:



1041

Event handler p941 p944 Event handler event type

onmessage message

p1271 ✔ MDN

p1272 MDN

onmessageerror messageerror



When the Worker(scriptURL, options) constructor is invoked, the user agent must run the following steps: ✔ MDN

1. The user agent may throw a "SecurityError" DOMException if the request violates a policy decision (e.g. if the user agent is

configured to not allow the page to start dedicated workers).

2. Let p911 outside settings be the current settings object .

3. p89 Parse the scriptURL argument relative to outside settings.

4. If this fails, throw a "SyntaxError" DOMException.

5. Let p89 worker URL be the resulting URL record.

Note

Any p842 same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with

an p841 opaque origin.

6. Let p1041 worker be a new Worker object.

7. Let p1010 p905 outside port be a new MessagePort in outside settings 's Realm .

8. Associate the outside port with worker.

9. Run this step p42 in parallel:

1. p1036 Run a worker given worker, worker URL, outside settings, outside port, and options.

10. Return worker.



10.2.6.4 Shared workers and the p1042 p10 SharedWorker interface §

42

IDL MDN [ Exposed = Window ]

interface SharedWorker : EventTarget {

constructor(USVString scriptURL, optional (DOMString or WorkerOptions) options = {});

readonly attribute MessagePort port;

};

SharedWorker includes AbstractWorker;



For web developers (non-normative)

sharedWorker p1043 = new SharedWorker(scriptURL [, name ])

Returns a new p1042 SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global

environment for which p1033 sharedWorker represents the communication channel. name can be used to define the name of that global environment.

sharedWorker p1043 = new SharedWorker(scriptURL [, options ])

Returns a new p1042 SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global

environment for which p1033 sharedWorker represents the communication channel. options can be used to define the name of that global environment via the name option. It can also ensure this new global environment supports JavaScript modules (specify type: "module"), and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option. Note that attempting to construct a shared worker with options whose type or credentials values mismatch an existing shared worker will cause the returned sharedWorker to fire an error event and not connect to the existing shared worker.

sharedWorker p1043 . port

Returns p1010 sharedWorker 's MessagePort object which can be used to communicate with the global environment.



1042 MDN

The p1010 port attribute must return the value it was assigned by the object's constructor. It represents the MessagePort for communicating with the shared worker.

A user agent has an associated p42 shared worker manager which is the result of starting a new parallel queue.

Note

Each user agent has a single p1043 p841 shared worker manager for simplicity. Implementations could use one per origin; that would

not be observably different and enables more concurrency. MDN



When the SharedWorker(scriptURL, options) constructor is invoked:

1. Optionally, throw a "SecurityError" DOMException if the request violates a policy decision (e.g. if the user agent is

configured to not allow the page to start shared workers).

2. If p1041 options is a DOMString , set options to a new WorkerOptions dictionary whose name member is set to the value of

options and whose other members are set to their default values.

3. Let p911 outside settings be the current settings object .

4. p89 Parse scriptURL relative to outside settings.

5. If this fails, throw a "SyntaxError" DOMException.

6. Otherwise, let p89 urlRecord be the resulting URL record.

Note

Any p842 same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with

an p841 opaque origin.

7. Let p1042 worker be a new SharedWorker object.

8. Let p1010 p905 outside port be a new MessagePort in outside settings 's Realm .

9. Assign p1043 outside port to the port attribute of worker.

10. Let p911 callerIsSecureContext be true if outside settings is a secure context; otherwise, false.

11. p42 p1043 Enqueue the following steps to the shared worker manager:

1. Let worker global scope be null.

2. If there exists a p1035 p1035 p1035 SharedWorkerGlobalScope object whose closing flag is false, constructor origin is

same origin p842 p904 p1035 p1033 with outside settings 's origin , constructor url equals urlRecord , and name equals the

value of p1035 options 's name member, then set worker global scope to that SharedWorkerGlobalScope object.

Note

data: p841 p1035 p1035 URLs create a worker with an opaque origin . Both the constructor origin and constructor url

are compared so the same p841 data: URL can be used within an origin to get to the same

SharedWorkerGlobalScope p1035 p842 object, but cannot be used to bypass the same origin restriction.

3. If worker global scope is not null, but the user agent has been configured to disallow communication between the

worker represented by the p912 p912 worker global scope and the scripts whose settings object is outside settings, then set worker global scope to null.

Note

For example, a user agent could have a development mode that isolates a particular top-level browsing

context p817 from all other pages, and scripts in that development mode could be blocked from connecting to shared workers running in the normal browser mode.

4. If p1033 p1035 worker global scope is not null, then check if worker global scope 's type and credentials match the

options p933 p1271 values. If not, queue a task to fire an event named error and abort these steps.

5. If worker global scope is not null, then run these subsubsteps:

1. Let p911 settings object be the relevant settings object for worker global scope.

1043

2. Let p911 workerIsSecureContext be true if settings object is a secure context; otherwise, false.

3. If p933 workerIsSecureContext is not callerIsSecureContext , then queue a task to fire an event named

error p1271 p1281 at worker and abort these steps. [SECURE-CONTEXTS]

4. Associate worker with worker global scope.

5. Let p1010 p905 inside port be a new MessagePort in settings object 's Realm .

6. p1010 Entangle outside port and inside port.

7. p933 p939 p1271 Queue a task , using the DOM manipulation task source , to fire an event named connect at

worker global scope p986 p986 , using MessageEvent , with the data attribute initialized to the empty string,

the p987 p987 ports attribute initialized to a new frozen array containing only inside port , and the source

attribute initialized to inside port.

8. p1036 p1033 Append the relevant owner to add given outside settings to worker global scope 's owner set.

6. Otherwise, p42 p1036 in parallel , run a worker given worker, urlRecord, outside settings, outside port, and options.

12. Return worker.



MDN

10.2.7 Concurrent hardware capabilities p10 §

44

IDL interface mixin NavigatorConcurrentHardware {

readonly attribute unsigned long long hardwareConcurrency;

};



For web developers (non-normative)

self p967 p1044 . navigator . hardwareConcurrency

Returns the number of logical processors potentially available to the user agent.



The navigator.hardwareConcurrency attribute's getter must return a number between 1 and the number of logical MDN

processors potentially available to the user agent. If this cannot be determined, the getter must return 1.

User agents should err toward exposing the number of logical processors available, using lower values only in cases where there are user-agent specific limits in place (such as a limitation on the number of p1041 workers that can be created) or when the user agent desires to limit fingerprinting possibilities.



10.3 APIs available to workers p10 §

44

10.3.1 Importing scripts and libraries p10 §

44

When a script invokes the p1032 importScripts( urls ) method on a WorkerGlobalScope object, the user agent must import scripts into ✔ MDN

worker global scope p1044 p1032 given this WorkerGlobalScope object and urls.

To p1032 import scripts into worker global scope , given a WorkerGlobalScope object worker global scope and a sequence p913 urls , run these steps. The algorithm may optionally be customized by supplying custom perform the fetch

hooks, which if provided will be used when invoking p915 fetch a classic worker-imported script .

1. If p1033 worker global scope 's type is "module", throw a TypeError exception.

2. Let p911 settings object be the current settings object.

3. If urls is empty, return.

4. p89 Parse each value in urls relative to settings object. If any fail, throw a "SyntaxError" DOMException.

5. For each p89 url in the resulting URL records, run these substeps:

1044

1. p915 Fetch a classic worker-imported script given url and settings object, passing along any custom perform the

fetch p913 steps provided. If this succeeds, let script be the result. Otherwise, rethrow the exception.

2. p921 Run the classic script script, with the rethrow errors argument set to true.

Note

script p923 will run until it either returns, fails to parse, fails to catch an exception, or gets prematurely aborted

by the p1039 terminate a worker algorithm defined above.

If an exception was thrown or if the script was p923 prematurely aborted , then abort all these steps, letting the

exception or aborting continue to be processed by the calling p912 script.

Note

Service Workers p913 is an example of a specification that runs this algorithm with its own options for the perform the fetch hook.

[SW] p1281



10.3.2 The p1045 p10 WorkerNavigator interface §

45

The p1032 p1045 navigator attribute of the WorkerGlobalScope interface must return an instance of the WorkerNavigator interface, which ✔ MDN MDN represents the identity and state of the user agent (the client):

IDL [Exposed=Worker]

interface WorkerNavigator {};

WorkerNavigator includes NavigatorID;

WorkerNavigator includes NavigatorLanguage;

WorkerNavigator includes NavigatorOnLine;

WorkerNavigator includes NavigatorConcurrentHardware;



10.3.3 The p1045 p10 WorkerLocation interface §

45

IDL MDN [ Exposed = Worker ]

interface WorkerLocation {

stringifier readonly attribute USVString href;

readonly attribute USVString origin;

readonly attribute USVString protocol;

readonly attribute USVString host;

readonly attribute USVString hostname;

readonly attribute USVString port;

readonly attribute USVString pathname;

readonly attribute USVString search;

readonly attribute USVString hash;

};

A p1045 p1032 WorkerLocation object has an associated WorkerGlobalScope object (a WorkerGlobalScope object).

The p1045 p1033 href attribute's getter must return the associated WorkerGlobalScope object 's url, serialized.

The p841 p1045 p1033 origin attribute's getter must return the serialization of the associated WorkerGlobalScope object 's url's origin.

The p1045 p1033 protocol attribute's getter must return the associated WorkerGlobalScope object 's url's scheme, followed by ":".

The host attribute's getter must run these steps:

1. Let p1045 p1033 url be the associated WorkerGlobalScope object 's url.

2. If url's host is null, return the empty string.

1045

3. If url's port is null, return url's host, serialized.

4. Return url's host, serialized, followed by ":" and url's port, serialized.

The hostname attribute's getter must run these steps:

1. Let p1045 p1033 host be the associated WorkerGlobalScope object 's url's host.

2. If host is null, return the empty string.

3. Return host, serialized.

The port attribute's getter must run these steps:

1. Let p1045 p1033 port be the associated WorkerGlobalScope object 's url's port.

2. If port is null, return the empty string.

3. Return port, serialized.

The pathname attribute's getter must run these steps:

1. Let p1045 p1033 url be the associated WorkerGlobalScope object 's url.

2. If url's cannot-be-a-base-URL flag is set, return the first string in url's path.

3. Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".

The search attribute's getter must run these steps:

1. Let p1045 p1033 query be the associated WorkerGlobalScope object 's url's query.

2. If query is either null or the empty string, return the empty string.

3. Return "?", followed by query.

The hash attribute's getter must run these steps:

1. Let p1045 p1033 fragment be the associated WorkerGlobalScope object 's url's fragment.

2. If fragment is either null or the empty string, return the empty string.

3. Return "#", followed by fragment.



1046

11 Worklets p10 §

47

11.1 Introduction p10 §

47

This section is non-normative.

Worklets are a piece of specification infrastructure which can be used for running scripts independent of the main JavaScript execution environment, while not requiring any particular implementation model.

The worklet infrastructure specified here cannot be used directly by web developers. Instead, other specifications build upon it to create directly-usable worklet types, specialized for running in particular parts of the browser implementation pipeline.



11.1.1 Motivations p10 §

47

This section is non-normative.

Allowing extension points to rendering, or other sensitive parts of the implementation pipeline such as audio output, is difficult. If extension points were done with full access to the APIs available on p828 Window , engines would need to abandon previously-held assumptions for what could happen in the middle of those phases. For example, during the layout phase, rendering engines assume that no DOM will be modified.

Additionaly, defining extension points in the p828 Window environment would restrict user agents to performing work in the same thread as the p828 Window object. (Unless implementations added complex, high-overhead infrastructure to allow thread-safe APIs, as well as thread-joining guarantees.) Worklets are designed to allow extension points, while keeping guarantees that user agents currently rely on. This is done through new global environments, based on subclasses of p1050 WorkletGlobalScope.

Worklets are similar to web workers. However, they:

• Are thread-agnostic. That is, they are not designed to run on a dedicated separate thread, like each worker is.

Implementations can run worklets wherever they choose (including on the main thread).

• Are able to have multiple duplicate instances of the global scope created, for the purpose of parallelism.

• Do not use an event-based API. Instead, classes are registered on the global scope, whose methods are invoked by the user

agent.

• Have a reduced API surface on the global scope.

• Have a lifetime for their p905 global object which is defined by other specifications, often in an implementation-defined

manner.

As worklets have relatively high overhead, they are best used sparingly. Due to this, a given p1050 WorkletGlobalScope is expected to be shared between multiple separate scripts. (This is similar to how a single p828 Window is shared between multiple separate scripts.) Worklets are a general technology that serve different use cases. Some worklets, such as those defined in CSS Painting API, provide extension points intended for stateless, idempotent, and short-running computations, which have special considerations as described in the next couple of sections. Others, such as those defined in Web Audio API, are used for stateful, long-running operations.

[CSSPAINT] p1276 p1282 [WEBAUDIO]



11.1.2 Code idempotence p10 §

47

Some specifications which use worklets are intended to allow user agents to parallelize work over multiple threads, or to move work between threads as required. In these specifications, user agents might invoke methods on a web-developer-provided class in an

implementation-defined order.

As a result of this, to prevent interoperability issues, authors who register classes on such p1050 WorkletGlobalScopes should make their

1047

code idempotent. That is, a method or set of methods on the class should produce the same output given a particular input.

This specification uses the following techniques in order to encourage authors to write code in an idempotent way:

• No reference to the global object is available (i.e., there is no counterpart to p1033 p1050 self on WorkletGlobalScope.

Although this was the intention when worklets were first specified, the introduction of globalThis has made it no longer

true. See issue #6059 for more discussion.

• Code is loaded as a p912 module script , which results in the code being executed in strict mode and with no shared this

referencing the global proxy.

Together, these restrictions help prevent two different scripts from sharing state using properties of the p905 global object.

Additionally, specifications which use worklets and intend to allow implementation-defined behavior must obey the following:

• They must require user agents to always have at least two p1050 p1053 WorkletGlobalScope instances per Worklet, and

randomly assign a method or set of methods on a class to a particular p1050 WorkletGlobalScope instance. These specifications may provide an opt-out under memory constraints.

• These specifications must allow user agents to create and destroy instances of their p1050 WorkletGlobalScope subclasses at

any time.



11.1.3 Speculative evaluation p10 §

48

Some specifications which use worklets can invoke methods on a web-developer-provided class based on the state of the user agent. To increase concurrency between threads, a user agent may invoke a method speculatively, based on potential future states.

In these specifications, user agents might invoke such methods at any time, and with any arguments, not just ones corresponding to the current state of the user agent. The reuslts of such speculative evaluations are not displayed immediately, but can be cached for use if the user agent state matches the speculated state. This can increase the concurrency between the user agent and worklet threads.

As a result of this, to prevent interoperability risks between user agents, authors who register classes on such

WorkletGlobalScope p1050s should make their code stateless. That is, the only effect of invoking a method should be its result, and not any side effects such as updating mutable state.

The same techniques which encourage p1047 code idempotence also encourage authors to write stateless code.



11.2 Examples p10 §

48

This section is non-normative.

For these examples, we'll use a fake worklet. The p828 p1053 Window object provides two Worklet instances, which each run code in their own collection of p1049 FakeWorkletGlobalScopes:

IDL partial interface Window {

[SameObject, SecureContext] readonly attribute Worklet fakeWorklet1;

[SameObject, SecureContext] readonly attribute Worklet fakeWorklet2;

};

Each p828 p1053 Window has two Worklet instances, fake worklet 1 and fake worklet 2. Both of these have their worklet global scope

type p1053 p1049 p1053 set to FakeWorkletGlobalScope , and their worklet destination type set to "fakeworklet". User agents should create at least two p1049 FakeWorkletGlobalScope instances per worklet.

Note

"fakeworklet" is not actually a valid destination per Fetch. But this illustrates how real worklets would generally have their own

1048

worklet-type-specific destination. p1277 [FETCH]

The p1048 fakeWorklet1 getter steps are to return this 's fake worklet 1.

The p1048 fakeWorklet2 getter steps are to return this 's fake worklet 2.



IDL [Global=(Worklet,FakeWorklet),

Exposed=FakeWorklet,

SecureContext]

interface FakeWorkletGlobalScope {

undefined registerFake(DOMString type, Function classConstructor);

};

Each p1049 FakeWorkletGlobalScope has a registered class constructors map, which is an ordered map, initially empty.

The p1049 registerFake( type , classConstructor ) method steps are to set this 's registered class constructors map[type] to classConstructor.



11.2.1 Loading scripts p10 §

49

This section is non-normative.

To load scripts into p1048 fake worklet 1, a web developer would write:

window.fakeWorklet1.addModule('script1.mjs');

window.fakeWorklet1.addModule('script2.mjs'); Note that which script finishes fetching and runs first is dependent on network timing: it could be either script1.mjs or script2.mjs. This generally won't matter for well-written scripts intended to be loaded in worklets, if they follow the suggestions about preparing for

speculative evaluation p1048.

If a web developer wants to perform a task only after the scripts have successfully run and loaded into some worklets, they could write:

Promise.all([

window.fakeWorklet1.addModule('script1.mjs'),

window.fakeWorklet2.addModule('script2.mjs')

]).then(() => {

// Do something which relies on those scripts being loaded.

});



Another important point about script-loading is that loaded scripts can be run in multiple p1050 p1053 WorkletGlobalScope s per Worklet,

as discussed in the section on p1047 p1048 code idempotence . In particular, the specification above for fake worklet 1 and fake worklet

2 p1048 require this. So, consider a scenario such as the following:

// script.mjs

console.log("Hello from a FakeWorkletGlobalScope!");

// app.mjs

window.fakeWorklet1.addModule("script.mjs"); This could result in output such as the following from a user agent's console:

[fakeWorklet1#1] Hello from a FakeWorkletGlobalScope!

[fakeWorklet1#4] Hello from a FakeWorkletGlobalScope!

1049

[fakeWorklet1#2] Hello from a FakeWorkletGlobalScope!

[fakeWorklet1#3] Hello from a FakeWorkletGlobalScope!

If the user agent at some point decided to kill and restart the third instance of p1049 FakeWorkletGlobalScope, the console would again print [fakeWorklet1#3] Hello from a FakeWorkletGlobalScope! when this occurs.



11.2.2 Registering a class and invoking its methods p10 §

50

This section is non-normative.

Let's say that one of the intended usages of our fake worklet by web developers is to allow them to customize the highly-complex process of boolean negation. They might register their customization as follows:

// script.mjs

registerFake('negation-processor', class {

process(arg) {

return !arg;

}

});

// app.mjs

window.fakeWorklet1.addModule("script.mjs"); To make use of such registered classes, the specification for fake worklets could define a find the opposite of true algorithm, given a

Worklet p1053 worklet:

1. Optionally, p1051 create a worklet global scope for worklet.

2. Let p1053 workletGlobalScope be one of worklet 's global scopes, chosen in an implementation-defined manner.

3. Let p1049 classConstructor be workletGlobalScope 's registered class constructors map["negation-processor"].

4. Let classInstance be the result of constructing classConstructor, with no arguments.

5. Let function be Get(classInstance, "process"). Rethrow any exceptions.

6. Let callback be the result of converting function to a Web IDL Function instance.

7. Return the result of invoking callback with the arguments « true » and with classInstance as the callback this value.

Note

Another, perhaps better, specification architecture would be to extract the "process" property and convert it into a Function at

registration time, as part of the p1049 registerFake() method steps.



11.3 Infrastructure p10 §

50

11.3.1 The global scope p10 §

50

Subclasses of p1050 p905 p1053 WorkletGlobalScope are used to create global objects wherein code loaded into a particular Worklet can execute.

IDL [Exposed=Worklet, SecureContext]

interface WorkletGlobalScope {};



Note

Other specifications are intended to subclass p1050 WorkletGlobalScope, adding APIs to register a class, as well as other APIs

specific for their worklet type.

1050

Each p1050 p928 WorkletGlobalScope has an associated module map . It is a module map, initially empty.



11.3.1.1 Agents and event loops p10 §

51

This section is non-normative.

Each p1050 p900 p931 WorkletGlobalScope is contained in its own worklet agent , which has its corresponding event loop. However, in practice, implementation of these agents and event loops is expected to be different from most others.

A p900 p1050 worklet agent exists for each WorkletGlobalScope since, in theory, an implementation could use a separate thread for each

WorkletGlobalScope p1050 instance, and allowing this level of parallelism is best done using agents. However, because their [[CanBlock]] value is false, there is no requirement that agents and threads are one-to-one. This allows implementations the freedom to execute scripts loaded into a worklet on any thread, including one running code from other agents with [[CanBlock]] of false, such as the thread of a p900 p900 similar-origin window agent ("the main thread"). Contrast this with dedicated worker agents , whose true value for [[CanBlock]] effectively requires them to get a dedicated operating system thread.

Worklet p931 p932 p1054 event loops are also somewhat special. They are only used for tasks associated with addModule(), tasks wherein the user agent invokes author-defined methods, and p932 p934 microtasks . Thus, even though the event loop processing model specifies that all event loops run continuously, implementations can achieve observably-equivalent results using a simpler strategy, which just

invokes p936 author-provided methods and then relies on that process to perform a microtask checkpoint .



11.3.1.2 Creation and termination p10 §

51

To p1053 create a worklet global scope for a Worklet worklet:

1. Let p911 outsideSettings be worklet 's relevant settings object .

2. Let p902 agent be the result of obtaining a worklet agent given outsideSettings. Run the rest of these steps in that agent.

3. Let p905 realmExecutionContext be the result of creating a new JavaScript realm given agent and the following customizations:

◦ For the global object, create a new object of the type given by p1053 worklet 's worklet global scope type.

4. Let p905 workletGlobalScope be the global object of realmExecutionContext's Realm component.

5. Let p1052 insideSettings be the result of setting up a worklet environment settings object given realmExecutionContext and

outsideSettings.

6. p1275 Initialize a global object's CSP list given workletGlobalScope . [CSP]

7. p1053 For each moduleURL of worklet 's added modules list:

1. p917 p1053 Fetch a worklet script graph given moduleURL , insideSettings , worklet 's worklet destination type, what

credentials mode? p1053 , insideSettings , and worklet 's module responses map. Wait until the algorithm asynchronously completes with script.

Note

This will not actually perform a network request, as it will just reuse responses from worklet's module

responses map p1053. The main purpose of this step is to create a new workletGlobalScope-specific module

script p912 from the response.

2. Assert: script is not null, since the fetch succeeded and the source text was successfully parsed when worklet's

module responses map p1053 was initially populated with moduleURL.

3. p922 Run a module script given script.

8. p905 p829 p1055 Append workletGlobalScope to outsideSettings 's global object 's associated Document 's worklet global scopes.

9. p1053 Append workletGlobalScope to worklet 's global scopes.

10. Run the p905 responsible event loop specified by insideSettings.

To p1050 terminate a worklet global scope given a WorkletGlobalScope workletGlobalScope:

1051

1. Let p901 p931 eventLoop be workletGlobalScope 's relevant agent 's event loop .

2. If there are any p932 p931 tasks queued in eventLoop 's task queues , discard them without processing them.

3. Wait for p932 eventLoop to complete the currently running task.

4. If the previous step doesn't complete within an p923 implementation-defined period of time, then abort the script currently

running in the worklet.

5. Destroy eventLoop.

6. p1053 p1053 p1053 Remove workletGlobalScope from the global scopes of the Worklet whose global scopes contains

workletGlobalScope.

7. p1055 p115 p1055 Remove workletGlobalScope from the worklet global scopes of the Document whose worklet global scopes

contains workletGlobalScope.



11.3.1.3 Script settings for worklets p10 §

52

To set up a worklet environment settings object, given a JavaScript execution context executionContext and an environment

settings object p904 outsideSettings:

1. Let p841 origin be a unique opaque origin .

2. Let p904 inheritedAPIBaseURL be outsideSettings 's API base URL.

3. Let p904 inheritedReferrerPolicy be outsideSettings 's referrer policy.

4. Let p904 inheritedEmbedderPolicy be outsideSettings 's embedder policy .

5. Let realm be the value of executionContext's Realm component.

6. Let p905 workletGlobalScope be realm 's global object.

7. Let p904 settingsObject be a new environment settings object whose algorithms are defined as follows:

The p904 realm execution context

Return executionContext.

The p904 module map

Return p1051 workletGlobalScope 's module map.

The p904 responsible document

Not applicable (the p905 p931 responsible event loop is not a window event loop).

The p904 API URL character encoding

Return UTF-8.

The p904 API base URL

Return inheritedAPIBaseURL.

Note

Unlike workers or other globals derived from a single resource, worklets have no primary resource; instead, multiple

scripts, each with their own URL, are loaded into the global scope via p1054 worklet.addModule(). So this API base

URL p904 is rather unlike that of other globals. However, so far this doesn't matter, as no APIs available to worklet code

make use of the p904 API base URL .

The p904 origin

Return origin.

The p904 referrer policy

Return inheritedReferrerPolicy.



1052

The p904 embedder policy

Return inheritedEmbedderPolicy.

The p904 cross-origin isolated capability

Return TODO .

8. Set p903 p903 p903 settingsObject 's id to a new unique opaque string, creation URL to inheritedAPIBaseURL , top-level creation URL

to null, p903 p903 p904 top-level origin to outsideSettings 's top-level origin , target browsing context to null, and active service

worker p904 to null.

9. Set realm's [[HostDefined]] field to settingsObject.

10. Return settingsObject.



11.3.2 The p1053 MDN p10 Worklet class §

53

The p1053 p1050 Worklet class provides the capability to add module scripts into its associated WorkletGlobalScopes. The user agent can then create classes registered on the p1050 WorkletGlobalScopes and invoke their methods.

IDL [Exposed=Window, SecureContext]

interface Worklet {

[NewObject] Promise addModule(USVString moduleURL, optional WorkletOptions options = {});

};

dictionary WorkletOptions {

RequestCredentials credentials = "same-origin";

};

Specifications that create p1053 Worklet instances must specify the following for a given instance:

• its p1050 worklet global scope type , which must be a Web IDL type that inherits from WorkletGlobalScope; and

• its worklet destination type, which must be a destination, and is used when fetching scripts.

For web developers (non-normative)

await p1054 p1053 worklet . addModule ( moduleURL [, { credentials }])

Loads and executes the p912 p1053 module script given by moduleURL into all of worklet 's global scopes. It can also create additional global scopes as part of this process, depending on the worklet type. The returned promise will fulfill once the script has been successfully loaded and run in all global scopes.

The p1053 credentials option can be set to a credentials mode to modify the script-fetching process. It defaults to "same-origin".

Any failures in p917 fetching the script or its dependencies will cause the returned promise to be rejected with an "AbortError"

DOMException. Any errors in parsing the script or its dependencies will cause the returned promise to be rejected with the exception generated during parsing.

A p1053 p1053 p1053 Worklet has a list of global scopes , which contains instances of the Worklet 's worklet global scope type. It is initially empty.

A p1053 Worklet has an added modules list, which is a list of URLs, initially empty. Access to this list should be thread-safe.

A p1053 Worklet has a module responses map, which is an ordered map from URLs to responses, initially empty. Access to this map should be thread-safe.

Note

The p1053 p1053 p1050 added modules list and module responses map exist to ensure that WorkletGlobalScopes created at different

times get equivalent p912 module scripts run in them, based on the same source text. This allows the creation of additional

WorkletGlobalScope p1050s to be transparent to the author.



1053

In practice, user agents are not expected to implement these data structures, and the algorithms that consult them, using thread-

safe programming techniques. Instead, when p1054 addModule() is called, user agents can fetch the module graph on the main

thread, and send the fetched source text (i.e., the important data contained in the p1053 module responses map) to each thread

which has a p1050 WorkletGlobalScope.

Then, when a user agent p1051 p1050 p1053 creates a new WorkletGlobalScope for a given Worklet, it can simply send the map of

fetched source text and the list of entry points from the main thread to the thread containing the new p1050 WorkletGlobalScope.



The addModule(moduleURL, options) method steps are: MDN

1. Let p911 outsideSettings be the relevant settings object of this.

2. p89 Parse moduleURL relative to outsideSettings.

3. If this fails, then return a promise rejected with a "SyntaxError" DOMException.

4. Let p89 moduleURLRecord be the resulting URL record.

5. Let promise be a new promise.

6. Run the following steps p42 in parallel:

1. If p1053 this 's global scopes is empty, then:

1. p1051 Create a worklet global scope given this.

2. Optionally, p1051 create additional global scope instances given this, depending on the specific worklet in

question and its specification.

3. Wait for all steps of the p1051 creation process(es) — including those taking place within the worklet

agents p900 — to complete, before moving on.

2. Let p1053 pendingTasks be this 's global scopes's size.

3. Let addedSuccessfully be false.

4. p1053 p933 p939 For each workletGlobalScope of this 's global scopes , queue a global task on the networking task source

given workletGlobalScope to perform the following steps:

1. p917 Fetch a worklet script graph given moduleURLRecord, outsideSettings, this's worklet destination

type p1053 p1053 p911 , options [" credentials "], workletGlobalScope 's relevant settings object, and this's

module responses map p1053. Wait until the algorithm asynchronously completes with script.

Note

Only the first of these fetches will actually perform a network request; the ones for other

WorkletGlobalScope p1050 p1053 s will reuse reuse responses from this 's module responses map.

2. If script is null, then:

1. p933 p939 p911 Queue a global task on the networking task source given this 's relevant global object

to perform the following steps:

1. If pendingTasks is not −1, then:

1. Set pendingTasks to −1.

2. Reject promise with an "AbortError" DOMException.

2. Abort these steps.

3. If p912 script 's error to rethrow is not null, then:

1. p933 p939 p911 Queue a global task on the networking task source given this 's relevant global object

to perform the following steps:

1. If pendingTasks is not −1, then:

1054

1. Set pendingTasks to −1.

2. Reject p912 promise with script 's error to rethrow .

2. Abort these steps.

4. If addedSuccessfully is false, then:

1. p1053 Append moduleURLRecord to this 's added modules list.

2. Set addedSuccessfully to true.

5. p922 Run a module script given script.

6. p933 p939 p911 Queue a global task on the networking task source given this 's relevant global object to

perform the following steps:

1. If pendingTasks is not −1, then:

1. Set pendingTasks to pendingTasks − 1.

2. If pendingTasks is 0, then resolve promise.

7. Return promise.



11.3.3 The worklet's lifetime p10 §

55

The lifetime of a p1053 p828 Worklet has no special considerations; it is tied to the object it belongs to, such as the Window .

Each p115 p1050 Document has a worklet global scopes , which is a set of WorkletGlobalScopes, initially empty.

The lifetime of a p1050 p115 p1055 WorkletGlobalScope is, at a minimum, tied to the Document whose worklet global scopes contain it. In particular, p834 p115 p1051 p1050 discarding the Document will terminate the corresponding WorkletGlobalScope and allow it to be garbage-collected.

Additionally, user agents may, at any time, p1051 p1050 terminate a given WorkletGlobalScope, unless the specification defining the

corresponding worklet type says otherwise. For example, they might terminate them if the p900 p931 worklet agent 's event loop has no

tasks p932 queued, or if the user agent has no pending operations planning to make use of the worklet, or if the user agent detects abnormal operations such as infinite loops or callbacks exceeding imposed time limits.

Finally, specifications for specific worklet types can give more specific details on when to p1051 p1050 create WorkletGlobalScopes for a given worklet type. For example, they might create them during specific processes that call upon worklet code, as in the p1050 example.



1055

12 Web storage §

p10 ✔ MDN

56



12.1 Introduction p10 §

56

This section is non-normative.

This specification introduces two related mechanisms, similar to HTTP session cookies, for storing name-value pairs on the client side.

[COOKIES] p1275

The first is designed for scenarios where the user is carrying out a single transaction, but could be carrying out multiple transactions in different windows at the same time.

Cookies don't really handle this case well. For example, a user could be buying plane tickets in two different windows, using the same site. If the site used cookies to keep track of which ticket the user was buying, then as the user clicked from page to page in both windows, the ticket currently being purchased would "leak" from one window to the other, potentially causing the user to buy two tickets for the same flight without really noticing.

To address this, this specification introduces the p1059 sessionStorage getter. Sites can add data to the session storage, and it will be accessible to any page from the same site opened in that window.

Example

For example, a page could have a checkbox that the user ticks to indicate that they want insurance:





I want insurance on this trip.



A later page could then check, from script, whether the user had checked the checkbox or not:

if (sessionStorage.insurance) { ... }

If the user had multiple windows opened on the site, each one would have its own individual copy of the session storage object.

The second storage mechanism is designed for storage that spans multiple windows, and lasts beyond the current session. In particular, web applications might wish to store megabytes of user data, such as entire user-authored documents or a user's mailbox, on the client side for performance reasons.

Again, cookies do not handle this case well, because they are transmitted with every request.

The p1060 localStorage getter is used to access a page's local storage area.

Example

The site at example.com can display a count of how many times the user has loaded its page by putting the following at the

bottom of its page:





You have viewed this page

an untold number of

time(s).





Each site has its own separate storage area.

⚠Warning!

The p1060 localStorage getter provides access to shared state. This specification does not define the interaction with

other browsing contexts in a multiprocess user agent, and authors are encouraged to assume that there is no

locking mechanism. A site could, for instance, try to read the value of a key, increment its value, then write it back

out, using the new value as a unique identifier for the session; if the site does this twice in two different browser

windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially

disastrous effects.



✔ MDN

12.2 The API p10 §

57



12.2.1 The p1057 p10 Storage interface §

57

IDL [Exposed=Window]

interface Storage {

readonly attribute unsigned long length;

DOMString? key(unsigned long index);

getter DOMString? getItem(DOMString key);

setter undefined setItem(DOMString key, DOMString value);

deleter undefined removeItem(DOMString key);

undefined clear();

};



For web developers (non-normative)

storage p1058 . length

Returns the number of key/value pairs.

storage p1058 . key ( n )

Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs.

value p1058 = storage . getItem ( key )

value = storage[key]

Returns the current value associated with the given key, or null if the given key does not exist.

storage p1058 . setItem ( key, value )

storage[key] = value

Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.

Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)

Dispatches a p1272 p828 p1057 storage event on Window objects holding an equivalent Storage object.

storage p1059 . removeItem ( key )

delete storage[key]

Removes the key/value pair with the given key, if a key/value pair with the given key exists.

Dispatches a p1272 p828 p1057 storage event on Window objects holding an equivalent Storage object.



1057

storage p1059 . clear()

Removes all key/value pairs, if there are any.

Dispatches a p1272 p828 p1057 storage event on Window objects holding an equivalent Storage object.

A p1057 Storage object has an associated:

map

A storage proxy map.

type

"local" or "session".

To p1057 p1058 reorder a Storage object storage , reorder storage 's map's entries in an implementation-defined manner.

Note

Unfortunate as it is, iteration order is not defined and can change upon most mutations.

To p1057 broadcast a Storage object storage, given a key, oldValue, and newValue, run these steps:

1. Let p911 p829 url be storage 's relevant global object 's associated Document 's URL.

2. Let p1057 remoteStorages be all Storage objects excluding storage whose:

◦ p1058 p1058 type is storage 's type

◦ p911 p841 p842 p911 p841 relevant settings object 's origin is same origin with storage 's relevant settings object 's origin.

and, if p1058 p911 p858 type is " session ", whose relevant settings object 's browsing session is storage's relevant settings

object p911 p858 's browsing session .

3. p933 p939 For each remoteStorage of remoteStorages : queue a global task on the DOM manipulation task source given

remoteStorage p911 p1272 p911 's relevant global object to fire an event named storage at remoteStorage 's relevant global object,

using p1060 p1061 p1061 p1061 StorageEvent , with key initialized to key , oldValue initialized to oldValue , newValue initialized to

newValue p1061 p1061 , url initialized to url , and storageArea initialized to remoteStorage.

Note

The p115 p932 p818 Document object associated with the resulting task is not necessarily fully active , but events fired on such

objects are ignored by the p931 p115 p818 event loop until the Document becomes fully active again.



✔ MDN

The p1058 length getter steps are to return this 's map's size. ✔ MDN

The key(n) method steps are:

1. If p1058 n is greater than or equal to this 's map's size, then return null.

2. Let p1058 keys be the result of running get the keys on this 's map.

3. Return keys[n].

The p1057 ✔ MDN p1058 supported property names on a Storage object storage are the result of running get the keys on storage 's map .

The getItem(key) method steps are:

1. If p1058 this 's map[key] does not exist, then return null.

2. Return p1058 this 's map[key].

The setItem(key, value) method are: ✔ MDN

1. Let oldValue be null.

2. Let reorder be true.

1058

3. If p1058 this 's map[key] exists:

1. Set p1058 oldValue to this 's map[key].

2. If oldValue is value, then return.

3. Set reorder to false.

4. If value cannot be stored, then throw a "QuotaExceededError" DOMException exception.

5. p1058 Set this 's map[key] to value.

6. If p1058 reorder is true, then reorder this.

7. p1058 Broadcast this with key, oldValue, and value.

The removeItem(key) method steps are: ✔ MDN

1. If p1058 this 's map[key] does not exist, then return null.

2. Set p1058 oldValue to this 's map[key].

3. p1058 Remove this 's map[key].

4. p1058 Reorder this.

5. p1058 Broadcast this with key, oldValue, and null.

The clear() method steps are: ✔ MDN

1. p1058 Clear this 's map.

2. p1058 Broadcast this with null, null, and null.



12.2.2 The p1059 p10 sessionStorage getter §

59

IDL interface mixin WindowSessionStorage {

readonly attribute Storage sessionStorage;

};

Window includes WindowSessionStorage;



For web developers (non-normative)

window p1059 . sessionStorage

Returns the p1057 Storage object associated with that window's origin's session storage area.

Throws a p115 p841 p841 " SecurityError " DOMException if the Document 's origin is an opaque origin or if the request violates a policy decision (e.g., if the user agent is configured to not allow the page to persist data).

✔ MDN

A p115 p1057 Document object has an associated session storage holder , which is null or a Storage object. It is initially null.

The sessionStorage getter steps are:

1. If p829 p1059 p829 this 's associated Document 's session storage holder is non-null, then return this 's associated Document's

session storage holder p1059.

2. Let p911 map be the result of running obtain a session storage bottle map with this 's relevant settings object and

"sessionStorage".

3. If map is failure, then throw a "SecurityError" DOMException.

4. Let p1057 p1058 storage be a new Storage object whose map is map.

5. Set p829 p1059 this 's associated Document 's session storage holder to storage.

6. Return storage.

1059

Note

While p816 p817 creating a new auxiliary browsing context , the session storage is copied over.



12.2.3 The p1060 p10 localStorage getter §

60

IDL interface mixin WindowLocalStorage {

readonly attribute Storage localStorage;

};

Window includes WindowLocalStorage;



For web developers (non-normative)

window p1060 . localStorage

Returns the p1057 Storage object associated with window's origin's local storage area.

Throws a p115 p841 p841 " SecurityError " DOMException if the Document 's origin is an opaque origin or if the request violates a policy decision (e.g., if the user agent is configured to not allow the page to persist data).

✔ MDN

A p115 p1057 Document object has an associated local storage holder , which is null or a Storage object. It is initially null.

The localStorage getter steps are:

1. If p829 p1060 p829 this 's associated Document 's local storage holder is non-null, then return this 's associated Document 's

local storage holder p1060.

2. Let p911 map be the result of running obtain a local storage bottle map with this 's relevant settings object and

"localStorage".

3. If map is failure, then throw a "SecurityError" DOMException.

4. Let p1057 p1058 storage be a new Storage object whose map is map.

5. Set p829 p1060 this 's associated Document 's local storage holder to storage.

6. Return storage.



12.2.4 The p1060 ✔ MDN p10 StorageEvent interface §

60

IDL [Exposed=Window]

interface StorageEvent : Event {

constructor(DOMString type, optional StorageEventInit eventInitDict = {});

readonly attribute DOMString? key;

readonly attribute DOMString? oldValue;

readonly attribute DOMString? newValue;

readonly attribute USVString url;

readonly attribute Storage? storageArea;

undefined initStorageEvent(DOMString type, optional boolean bubbles = false, optional boolean

cancelable = false, optional DOMString? key = null, optional DOMString? oldValue = null, optional DOMString? newValue = null, optional USVString url = "", optional Storage? storageArea = null); };

dictionary StorageEventInit : EventInit {

DOMString? key = null;

DOMString? oldValue = null;

DOMString? newValue = null;

USVString url = "";

Storage? storageArea = null;

1060

};



For web developers (non-normative)

event p1061 . key

Returns the key of the storage item being changed.

event p1061 . oldValue

Returns the old value of the key of the storage item whose value is being changed.

event p1061 . newValue

Returns the new value of the key of the storage item whose value is being changed.

event p1061 . url

Returns the URL of the document whose storage item changed.

event p1061 . storageArea

Returns the p1057 Storage object that was affected.

The key, oldValue, newValue, url, and storageArea attributes must return the values they were initialized to.

The initStorageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method.

[DOM] p1277



12.3 Privacy p10 §

61

12.3.1 User tracking p10 §

61

A third-party advertiser (or any entity capable of getting content distributed to multiple sites) could use a unique identifier stored in its local storage area to track a user across multiple sessions, building a profile of the user's interests to allow for highly targeted advertising. In conjunction with a site that is aware of the user's real identity (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous web usage.

There are a number of techniques that can be used to mitigate the risk of user tracking: Blocking third-party storage

User agents may restrict access to the p1060 p814 localStorage objects to scripts originating at the domain of the active document of

the p817 p362 top-level browsing context , for instance denying access to the API for pages from other domains running in iframes.

Expiring stored data

User agents may, possibly in a manner configured by the user, automatically delete stored data after a period of time.

For example, a user agent could be configured to treat third-party local storage areas as session-only storage, deleting the data

once the user had closed all the p814 browsing contexts that could access it.

This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when they authenticate with the site itself (e.g. by making a purchase or logging in to a service).

However, this also reduces the usefulness of the API as a long-term storage mechanism. It can also put the user's data at risk, if the user does not fully understand the implications of data expiration.

Treating persistent storage as cookies

If users attempt to protect their privacy by clearing cookies without also clearing data stored in the local storage area, sites can defeat those attempts by using the two features as redundant backup for each other. User agents should present the interfaces for clearing these in a way that helps users to understand this possibility and enables them to delete data in all persistent storage

features simultaneously. p1275 [COOKIES]

Site-specific safelisting of access to local storage areas

User agents may allow sites to access session storage areas in an unrestricted manner, but require the user to authorize access to local storage areas.

1061

Origin-tracking of stored data

User agents may record the p841 origins of sites that contained content from third-party origins that caused data to be stored.

If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that they trust.

Shared blocklists

User agents may allow users to share their persistent storage domain blocklists.

This would allow communities to act together to protect their privacy.

While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.

However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.



12.3.2 Sensitivity of data p10 §

62

User agents should treat persistently stored data as potentially sensitive; it's quite possible for emails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.

To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.



12.4 Security p10 §

62

12.4.1 DNS spoofing attacks p10 §

62

Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only the user, software working on behalf of the user, and other pages using TLS that have certificates identifying them as being from the same domain, can access their storage areas.



12.4.2 Cross-directory attacks p10 §

62

Different authors sharing one host name, for example users hosting content on the now defunct geocities.com, all share one local storage object. There is no feature to restrict the access by pathname. Authors on shared hosts are therefore urged to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.

Note

Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this

protection and access the data from any path.



12.4.3 Implementation risks p10 §

62

The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.

Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user's

1062

shopping wishlist on one domain could be used by another domain for targeted advertising; or a user's work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.

Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add items to a user's wishlist; or a hostile site could set a user's session identifier to a known ID that the hostile site can then use to track the user's actions on the victim site.

Thus, strictly following the p841 origin model described in this specification is important for user security.



1063

13 The HTML syntax p10 §

64

Note

This section only describes the rules for resources labeled with an HTML MIME type. Rules for XML resources are discussed in the

section below entitled " p1184 The XML syntax".



13.1 Writing HTML documents p10 §

64

This section only applies to documents, authoring tools, and markup generators. In particular, it does not apply to conformance checkers; conformance checkers must use the requirements given in the next section ("parsing HTML documents").

Documents must consist of the following parts, in the given order:

1. Optionally, a single U+FEFF BYTE ORDER MARK (BOM) character.

2. Any number of p1075 comments and ASCII whitespace.

3. A p1064 DOCTYPE.

4. Any number of p1075 comments and ASCII whitespace.

5. The p153 p1065 document element , in the form of an html element.

6. Any number of p1075 comments and ASCII whitespace.

The various types of content mentioned above are described in the next few sections.

In addition, there are some restrictions on how p174 character encoding declarations are to be serialized, as discussed in the section on that topic.

Note

ASCII whitespace p153 p153 p154 before the html element, at the start of the html element and before the head element, will be dropped

when the document is parsed; p153 p179 ASCII whitespace after the html element will be parsed as if it were at the end of the body

element. Thus, ASCII whitespace around the document element does not round-trip.

It is suggested that newlines be inserted after the DOCTYPE, after any comments that are before the document element, after the

html p153 p1068 p153 element's start tag (if it is not omitted ), and after any comments that are inside the html element but before the

head p154 element.

Many strings in the HTML syntax (e.g. the names of elements and their attributes) are case-insensitive, but only for ASCII upper alphas

and ASCII lower alphas. For convenience, in this section this is just referred to as "case-insensitive".



13.1.1 The DOCTYPE p10 §

64

A DOCTYPE is a required preamble.

Note

DOCTYPEs are required for legacy reasons. When omitted, browsers tend to use a different rendering mode that is incompatible

with some specifications. Including the DOCTYPE in a document ensures that the browser makes a best-effort attempt at following

the relevant specifications.

A DOCTYPE must consist of the following components, in this order:

1. A string that is an ASCII case-insensitive match for the string "

2. One or more ASCII whitespace.

1064

3. A string that is an ASCII case-insensitive match for the string "html".

4. Optionally, a p1065 DOCTYPE legacy string.

5. Zero or more ASCII whitespace.

6. A U+003E GREATER-THAN SIGN character (>).

Note

In other words, , case-insensitively.



For the purposes of HTML generators that cannot output HTML markup with the short DOCTYPE "", a DOCTYPE legacy string may be inserted into the DOCTYPE (in the position defined above). This string must consist of:

1. One or more ASCII whitespace.

2. A string that is an ASCII case-insensitive match for the string "SYSTEM".

3. One or more ASCII whitespace.

4. A U+0022 QUOTATION MARK or U+0027 APOSTROPHE character (the quote mark).

5. The literal string " p88 about:legacy-compat ".

6. A matching U+0022 QUOTATION MARK or U+0027 APOSTROPHE character (i.e. the same character as in the earlier step

labeled quote mark).

Note

In other words, or , case-

insensitively except for the part in single or double quotes.

The p1065 DOCTYPE legacy string should not be used unless the document is generated from a system that cannot output the shorter string.



13.1.2 Elements p10 §

65

There are six different kinds of p1065 p1065 p1065 elements : void elements , the template element , raw text elements, escapable raw text

elements p1065 p1065 p1065 , foreign elements , and normal elements.

Void elements

area p444 p156 p281 p461 p369 p215 p321 p494 p158 p165 p379 p318 p385 p282 , base , br , col , embed , hr , img , input , link , meta , param , source , track , wbr

The template element

template p630

Raw text elements

script p614 p175 , style

Escapable raw text elements

textarea p549 p155 , title

Foreign elements

Elements from the MathML namespace and the SVG namespace.

Normal elements

All other allowed p44 HTML elements are normal elements.

Tags p1065 p1065 p1065 are used to delimit the start and end of elements in the markup. Raw text , escapable raw text , and normal elements have a p1066 p1067 start tag to indicate where they begin, and an end tag to indicate where they end. The start and end tags of certain

normal elements p1065 p1068 p1068 can be omitted , as described below in the section on optional tags. Those that cannot be omitted must

not be omitted. p1065 p1065 p1065 Void elements only have a start tag; end tags must not be specified for void elements . Foreign elements

must either have a start tag and an end tag, or a start tag that is marked as self-closing, in which case they must not have an end tag.

The p130 p1068 contents of the element must be placed between just after the start tag (which might be implied, in certain cases) and just before the end tag (which again, p1068 might be implied in certain cases). The exact allowed contents of each individual element depend on the p130 content model of that element, as described earlier in this specification. Elements must not contain content that their content model disallows. In addition to the restrictions placed on the contents by those content models, however, the five types of elements have additional syntactic requirements.

Void elements p1065 can't have any contents (since there's no end tag, no content can be put between the start tag and the end tag).

1065

The p1065 p631 p631 p630 template element can have template contents , but such template contents are not children of the template

element itself. Instead, they are stored in a p115 DocumentFragment associated with a different Document — without a browsing

context p814 p630 p115 — so as to avoid the template contents interfering with the main Document. The markup for the template

contents p631 p630 p630 p630 of a template element is placed just after the template element's start tag and just before template element's end tag (as with other elements), and may consist of any p1074 p1074 p1065 p1075 text , character references , elements , and comments, but the

text must not contain the character U+003C LESS-THAN SIGN (<) or an p1075 ambiguous ampersand.

Raw text elements p1065 p1074 p1074 can have text , though it has restrictions described below.

Escapable raw text elements p1065 p1074 p1074 can have text and character references, but the text must not contain an ambiguous

ampersand p1075 p1074 . There are also further restrictions described below.

Foreign elements p1065 whose start tag is marked as self-closing can't have any contents (since, again, as there's no end tag, no content can be put between the start tag and the end tag). p1065 Foreign elements whose start tag is not marked as self-closing can have

text p1074 p1074 p1075 p1065 p1075 , character references , CDATA sections , other elements , and comments, but the text must not contain the character U+003C LESS-THAN SIGN (<) or an p1075 ambiguous ampersand.

Note

The HTML syntax does not support namespace declarations, even in p1065 foreign elements.

For instance, consider the following HTML fragment:





The innermost element, cdr:license, is actually in the SVG namespace, as the "xmlns:cdr" attribute has no effect (unlike in

XML). In fact, as the comment in the fragment above says, the fragment is actually non-conforming. This is because SVG 2 does

not define any elements called "cdr:license" in the SVG namespace.

Normal elements p1065 p1074 p1074 p1065 p1075 can have text , character references , other elements , and comments, but the text must not contain the character U+003C LESS-THAN SIGN (<) or an p1075 p1065 ambiguous ampersand . Some normal elements also have yet more

restrictions p1074 on what content they are allowed to hold, beyond the restrictions imposed by the content model and those described in this paragraph. Those restrictions are described below.

Tags contain a tag name, giving the element's name. HTML elements all have names that only use ASCII alphanumerics. In the HTML

syntax, tag names, even those for p1065 foreign elements, may be written with any mix of lower- and uppercase letters that, when converted to all-lowercase, matches the element's tag name; tag names are case-insensitive.



13.1.2.1 Start tags p10 §

66

Start tags must have the following format:

1. The first character of a start tag must be a U+003C LESS-THAN SIGN character (<).

2. The next few characters of a start tag must be the element's p1066 tag name.

3. If there are to be any attributes in the next step, there must first be one or more ASCII whitespace.

4. Then, the start tag may have a number of attributes, the p1067 syntax for which is described below. Attributes must be

separated from each other by one or more ASCII whitespace.

5. After the attributes, or after the p1066 tag name if there are no attributes, there may be one or more ASCII whitespace. (Some

attributes are required to be followed by a space. See the p1067 attributes section below.)

6. Then, if the element is one of the p1065 p1065 void elements , or if the element is a foreign element, then there may be a single

U+002F SOLIDUS character (/). This character has no effect on p1065 p1065 void elements , but on foreign elements it marks the

1066

start tag as self-closing.

7. Finally, start tags must be closed by a U+003E GREATER-THAN SIGN character (>).



13.1.2.2 End tags p10 §

67

End tags must have the following format:

1. The first character of an end tag must be a U+003C LESS-THAN SIGN character (<).

2. The second character of an end tag must be a U+002F SOLIDUS character (/).

3. The next few characters of an end tag must be the element's p1066 tag name.

4. After the tag name, there may be one or more ASCII whitespace.

5. Finally, end tags must be closed by a U+003E GREATER-THAN SIGN character (>).



13.1.2.3 Attributes p10 §

67

Attributes for an element are expressed inside the element's start tag.

Attributes have a name and a value. Attribute names must consist of one or more characters other than controls, U+0020 SPACE, U+0022 ("), U+0027 ('), U+003E (>), U+002F (/), U+003D (=), and noncharacters. In the HTML syntax, attribute names, even those for p1065 foreign elements, may be written with any mix of ASCII lower and ASCII upper alphas.

Attribute values p1074 p1074 are a mixture of text and character references, except with the additional restriction that the text cannot contain an p1075 ambiguous ampersand.

Attributes can be specified in four different ways:

Empty attribute syntax

Just the p1067 attribute name. The value is implicitly the empty string.

Example

In the following example, the p571 disabled attribute is given with the empty attribute syntax:

disabled>



If an attribute using the empty attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

Unquoted attribute value syntax

The p1067 attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed

by zero or more p1067 ASCII whitespace , followed by the attribute value, which, in addition to the requirements given above for

attribute values, must not contain any literal ASCII whitespace, any U+0022 QUOTATION MARK characters ("), U+0027 APOSTROPHE characters ('), U+003D EQUALS SIGN characters (=), U+003C LESS-THAN SIGN characters (<), U+003E GREATER-THAN SIGN characters (>), or U+0060 GRAVE ACCENT characters (`), and must not be the empty string.

Example

In the following example, the p498 value attribute is given with the unquoted attribute value syntax:

value=yes>



If an attribute using the unquoted attribute syntax is to be followed by another attribute or by the optional U+002F SOLIDUS

character (/) allowed in step 6 of the p1066 start tag syntax above, then there must be ASCII whitespace separating the two.



1067

Single-quoted attribute value syntax

The p1067 attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed

by zero or more p1067 ASCII whitespace , followed by a single U+0027 APOSTROPHE character ('), followed by the attribute value,

which, in addition to the requirements given above for attribute values, must not contain any literal U+0027 APOSTROPHE characters ('), and finally followed by a second single U+0027 APOSTROPHE character (').

Example

In the following example, the p496 type attribute is given with the single-quoted attribute value syntax:

type='checkbox'>



If an attribute using the single-quoted attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

Double-quoted attribute value syntax

The p1067 attribute name, followed by zero or more ASCII whitespace, followed by a single U+003D EQUALS SIGN character, followed

by zero or more p1067 ASCII whitespace , followed by a single U+0022 QUOTATION MARK character ("), followed by the attribute value,

which, in addition to the requirements given above for attribute values, must not contain any literal U+0022 QUOTATION MARK characters ("), and finally followed by a second single U+0022 QUOTATION MARK character (").

Example

In the following example, the p569 name attribute is given with the double-quoted attribute value syntax:

name="be evil">



If an attribute using the double-quoted attribute syntax is to be followed by another attribute, then there must be ASCII whitespace separating the two.

There must never be two or more attributes on the same start tag whose names are an ASCII case-insensitive match for each other.



When a p1065 foreign element has one of the namespaced attributes given by the local name and namespace of the first and second cells of a row from the following table, it must be written using the name given by the third cell from the same row.

Local name Namespace Attribute name

actuate XLink namespace xlink:actuate

arcrole XLink namespace xlink:arcrole

href XLink namespace xlink:href

role XLink namespace xlink:role

show XLink namespace xlink:show

title XLink namespace xlink:title

type XLink namespace xlink:type

lang XML namespace xml:lang

space XML namespace xml:space

xmlns XMLNS namespace xmlns

xlink XMLNS namespace xmlns:xlink

No other namespaced attribute can be expressed in p1064 the HTML syntax.

Note

Whether the attributes in the table above are conforming or not is defined by other specifications (e.g. SVG 2 and MathML); this

section only describes the syntax rules if the attributes are serialized using the HTML syntax.



13.1.2.4 Optional tags §p10

68

Certain tags can be omitted.

1068

Note

Omitting an element's p1066 start tag in the situations described below does not mean the element is not present; it is implied, but it

is still there. For example, an HTML document always has a root p153 html element, even if the string doesn't appear

anywhere in the markup.

An p153 p1066 p153 p1075 html element's start tag may be omitted if the first thing inside the html element is not a comment.

Example

For example, in the following case it's ok to remove the "" tag:





Hello





Welcome to this example.





Doing so would make the document look like this:





Hello





Welcome to this example.





This has the exact same DOM. In particular, note that whitespace around the document element is ignored by the parser. The

following example would also have the exact same DOM:



Hello





Welcome to this example.





However, in the following example, removing the start tag moves the comment to before the p153 html element:





Hello





Welcome to this example.





With the tag removed, the document actually turns into the same as this:



1069





Hello





Welcome to this example.





This is why the tag can only be removed if it is not followed by a comment: removing the tag when there is a comment there

changes the document's resulting parse tree. Of course, if the position of the comment does not matter, then the tag can be

omitted, as if the comment had been moved to before the start tag in the first place.

An p153 p1067 p153 p1075 html element's end tag may be omitted if the html element is not immediately followed by a comment.

A p154 p1066 p154 head element's start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.

A p154 p1067 p154 head element's end tag may be omitted if the head element is not immediately followed by ASCII whitespace or a

comment p1075.

A p179 p1066 p179 body element's start tag may be omitted if the element is empty, or if the first thing inside the body element is not ASCII

whitespace p1075 p179 p165 p158 p614 p175 or a comment , except if the first thing inside the body element is a meta , link , script , style , or

template p630 element.

A p179 p1067 p179 p1075 body element's end tag may be omitted if the body element is not immediately followed by a comment.

Example

Note that in the example above, the p154 p179 head element start and end tags, and the body element start tag, can't be omitted,

because they are surrounded by whitespace:





Hello





Welcome to this example.





(The p179 p153 p179 body and html element end tags could be omitted without trouble; any spaces after those get parsed into the body

element anyway.)

Usually, however, whitespace isn't an issue. If we first remove the whitespace we don't care about:

Hello



Welcome to this example.



Then we can omit a number of tags without affecting the DOM:

Hello



Welcome to this example.



At that point, we can also add some whitespace back:



Hello



1070



Welcome to this example.



This would be equivalent to this document, with the omitted tags shown in their parser-implied positions; the only whitespace text

node that results from this is the newline at the end of the p154 head element:



Hello





Welcome to this example.





An p225 p1067 p225 p225 li element's end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.

A p231 p1067 p231 p231 p232 dt element's end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.

A p232 p1067 p232 p232 p231 dd element's end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.

A p213 p1067 p213 p199 p181 p189 p element's end tag may be omitted if the p element is immediately followed by an address , article , aside,

blockquote p219 p605 p238 p228 p563 p236 p233 p196 p487 p191 p191 p191 p191 , details , div , dl , fieldset , figcaption , figure , footer , form , h1 , h2 , h3 , h4,

h5 p191 p191 p195 p193 p215 p237 p224 p186 p222 p213 p217 p183 p451 p223 , h6 , header , hgroup , hr , main , menu , nav , ol , p , pre , section , table , or ul element, or if there is no more content in the parent element and the parent element is an p44 p239 p384 p313 HTML element that is not an a , audio , del,

ins p312 p443 p628 p380 p705 , map , noscript , or video element, or an autonomous custom element .

Example

We can thus simplify the earlier example further:

Hello



Welcome to this example.



An p259 p1067 p259 p259 p259 rt element's end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

An p259 p1067 p259 p259 p259 rp element's end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.

An p545 p1067 p545 p545 optgroup element's end tag may be omitted if the optgroup element is immediately followed by another optgroup

element, or if there is no more content in the parent element.

An p546 p1067 p546 p546 option element's end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an p545 optgroup element, or if there is no more content in the parent element.

A p460 p1066 p460 p461 colgroup element's start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another p460 p1067 colgroup element whose end tag has been omitted. (It can't be omitted if the element is empty.) A p460 p1067 p460 colgroup element's end tag may be omitted if the colgroup element is not immediately followed by ASCII whitespace or a p1075 comment.

A p459 p1067 p459 caption element's end tag may be omitted if the caption element is not immediately followed by ASCII whitespace or a

comment p1075.

A p463 p1067 p463 p462 p464 thead element's end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.

A p462 p1066 p462 p465 tbody element's start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a p462 p463 p464 p1067 tbody , thead , or tfoot element whose end tag has been omitted. (It can't be omitted if the element is empty.) A p462 p1067 p462 p462 p464 tbody element's end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.

1071

A p464 p1067 tfoot element's end tag may be omitted if there is no more content in the parent element.

A p465 p1067 p465 p465 tr element's end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.

A p466 p1067 p466 p466 p468 td element's end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.

A p468 p1067 p468 p466 p468 th element's end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.

Example

The ability to omit all these table-related tags makes table markup much terser.

Take this example:





37547 TEE Electric Powered Rail Car Train Functions (Abbreviated) Function Control Unit Central Station

Headlights ✔ ✔

Interior Lights ✔ ✔

Electric locomotive operating sounds ✔ ✔

Engineer's cab lighting ✔

Station Announcements - Swiss ✔



The exact same table, modulo some whitespace differences, could be marked up as follows:





1072





37547 TEE Electric Powered Rail Car Train Functions (Abbreviated) Function



Control Unit



Central Station





Headlights



✔



✔





Interior Lights



✔



✔





Electric locomotive operating sounds



✔



✔





Engineer's cab lighting





✔





Station Announcements - Swiss





✔





Since the cells take up much less room this way, this can be made even terser by having each row on one line:





37547 TEE Electric Powered Rail Car Train Functions (Abbreviated) Function Control Unit Central Station





Headlights ✔ ✔





Interior Lights ✔ ✔





Electric locomotive operating sounds ✔ ✔





Engineer's cab lighting ✔





Station Announcements - Swiss ✔





The only differences between these tables, at the DOM level, is with the precise position of the (in any case semantically-neutral)

whitespace.

However p1066 , a start tag must never be omitted if it has any attributes.

Example

Returning to the earlier example with all the whitespace removed and then all the optional tags removed:

Hello



Welcome to this example.

If the p179 p138 p153 p141 body element in this example had to have a class attribute and the html element had to have a lang attribute,

the markup would have to become:

Hello



Welcome to this example.



1073

Note

This section assumes that the document is conforming, in particular, that there are no p130 content model violations. Omitting tags

in the fashion described in this section in a document that does not conform to the p130 content models described in this

specification is likely to result in unexpected DOM differences (this is, in part, what the content models are designed to avoid).



13.1.2.5 Restrictions on content models p10 §

74

For historical reasons, certain elements have extra restrictions beyond even the restrictions given by their content model.

A p451 p465 p451 table element must not contain tr elements, even though these elements are technically allowed inside table elements according to the content models described in this specification. (If a p465 p451 tr element is put inside a table in the markup, it will in fact imply a p462 tbody start tag before it.) A single p1074 p1066 p217 p549 newline may be placed immediately after the start tag of pre and textarea elements. This does not affect the processing of the element. The otherwise optional p1074 newline must be included if the element's contents themselves start with a

newline p1074 (because otherwise the leading newline in the contents would be treated like the optional newline, and ignored).

Example

The following two p217 pre blocks are equivalent:



Hello





Hello





13.1.2.6 Restrictions on the contents of raw text and escapable raw text elements p10 §

74

The text in p1065 p1065 raw text and escapable raw text elements must not contain any occurrences of the string "), or U+002F SOLIDUS (/).



13.1.3 Text p10 §

74

Text is allowed inside elements, attribute values, and comments. Extra constraints are placed on what is and what is not allowed in text based on where the text is to be put, as described in the other sections.



13.1.3.1 Newlines p10 §

74

Newlines in HTML may be represented either as U+000D CARRIAGE RETURN (CR) characters, U+000A LINE FEED (LF) characters, or pairs of U+000D CARRIAGE RETURN (CR), U+000A LINE FEED (LF) characters in that order.

Where p1074 character references are allowed, a character reference of a U+000A LINE FEED (LF) character (but not a U+000D

CARRIAGE RETURN (CR) character) also represents a p1074 newline.



13.1.4 Character references p10 §

74

In certain cases described in other sections, p1074 text may be mixed with character references. These can be used to escape characters that couldn't otherwise legally be included in p1074 text.

Character references must start with a U+0026 AMPERSAND character (&). Following this, there are three possible kinds of character references:

1074

Named character references

The ampersand must be followed by one of the names given in the p1175 named character references section, using the same case. The name must be one that is terminated by a U+003B SEMICOLON character (;).

Decimal numeric character reference

The ampersand must be followed by a U+0023 NUMBER SIGN character (#), followed by one or more ASCII digits, representing a base-ten integer that corresponds to a code point that is allowed according to the definition below. The digits must then be followed by a U+003B SEMICOLON character (;).

Hexadecimal numeric character reference

The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by one or more

ASCII hex digits, representing a hexadecimal integer that corresponds to a code point that is allowed according to the definition below. The digits must then be followed by a U+003B SEMICOLON character (;).

The numeric character reference forms described above are allowed to reference any code point excluding U+000D CR, noncharacters,

and controls other than ASCII whitespace.

An ambiguous ampersand is a U+0026 AMPERSAND character (&) that is followed by one or more ASCII alphanumerics, followed by a U+003B SEMICOLON character (;), where these characters do not match any of the names given in the named character

references p1175 section.



13.1.5 CDATA sections p10 §

75

CDATA sections must consist of the following components, in this order:

1. The string "

2. Optionally, p1074 text, with the additional restriction that the text must not contain the string "]]>".

3. The string "]]>".

Example

CDATA sections can only be used in foreign content (MathML or SVG). In this example, a CDATA section is used to escape the

contents of a MathML ms element:



You can add a string to a number, but this stringifies the number:





+

3

=





13.1.6 Comments p10 §

75

Comments must have the following format:

1. The string "", or "--!>", nor end with the string "

3. The string "-->".

Note

The p1074 text is allowed to end with the string "", as in .

1075

13.2 Parsing HTML documents p10 §

76

This section only applies to user agents, data mining tools, and conformance checkers.

Note

The rules for parsing XML documents into DOM trees are covered by the next section, entitled " p1184 The XML syntax".

User agents must use the parsing rules described in this section to generate the DOM trees from p1241 text/html resources. Together, these rules define what is referred to as the HTML parser.

Note

While the HTML syntax described in this specification bears a close resemblance to SGML and XML, it is a separate language with

its own parsing rules.

Some earlier versions of HTML (in particular from HTML2 to HTML4) were based on SGML and used SGML parsing rules. However,

few (if any) web browsers ever implemented true SGML parsing for HTML documents; the only user agents to strictly handle HTML

as an SGML application have historically been validators. The resulting confusion — with validators claiming documents to have

one representation while widely deployed web browsers interoperably implemented a different representation — has wasted

decades of productivity. This version of HTML thus returns to a non-SGML basis.

Authors interested in using SGML tools in their authoring pipeline are encouraged to use XML tools and the XML serialization of

HTML.

For the purposes of conformance checkers, if a resource is determined to be in p1064 the HTML syntax, then it is an HTML document.

Note

As stated p44 p44 in the terminology section , references to element types that do not explicitly specify a namespace always refer to

elements in the p224 HTML namespace . For example, if the spec talks about "a menu element", then that is an element with the local

name " p225 menu ", the namespace " http://www.w3.org/1999/xhtml ", and the interface HTMLMenuElement. Where possible,

references to such elements are hyperlinked to their definition.



1076

13.2.1 Overview of the parsing model p10 §

77





Network





Byte Stream

Decoder





Input Stream

Preprocessor document.write()





Tokenizer





Tree Script

Construction Execution





DOM





The input to the HTML parsing process consists of a stream of p1094 code points , which is passed through a tokenization stage followed by a p1122 p115 tree construction stage. The output is a Document object.

Note

Implementations that p47 p115 do not support scripting do not have to actually create a DOM Document object, but the DOM tree in

such cases is still used as the model for the rest of the specification.

In the common case, the data handled by the tokenization stage comes from the network, but p955 it can also come from script running in the user agent, e.g. using the p958 document.write() API.

There is only one set of states for the tokenizer stage and the tree construction stage, but the tree construction stage is reentrant, meaning that while the tree construction stage is handling one token, the tokenizer might be resumed, causing further tokens to be emitted and processed before the first token's processing is complete.

Example

In the following example, the tree construction stage will be called upon to handle a "p" start tag token while handling the "script"

end tag token:

...



...

1077

To handle these cases, parsers have a script nesting level, which must be initially set to zero, and a parser pause flag, which must be initially set to false.



13.2.2 Parse errors p10 §

78

This specification defines the parsing rules for HTML documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be p1078 parse errors. The error handling for parse errors is well-defined (that's the processing rules described throughout this specification), but user agents, while parsing an HTML document, may p1162 abort the parser at the first parse

error p1078 that they encounter for which they do not wish to apply the rules described in this specification.

Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document.

Note

Parse errors are only errors with the syntax of HTML. In addition to checking for parse errors, conformance checkers will also verify

that the document obeys all the other conformance requirements described in this specification.

Some parse errors have dedicated codes outlined in the table below that should be used by conformance checkers in reports.

Error descriptions in the table below are non-normative.

Code Description

abrupt-closing-of- p1075 This error occurs if the parser encounters an empty comment that is abruptly closed by a U+003E (>) code point (i.e., or " code point sequence. The parser treats such closed-comment comments as if they are correctly closed by the "-->" code point sequence.

incorrectly- This error occurs if the parser encounters the "" code point sequence that is not immidiately followed by two U+002D (-) code points and

opened-comment p1064 p1075 that is not the start of a DOCTYPE or a CDATA section. All content that follows the "" code point sequence up to a U+003E (>)

code point (if present) or to the end of the p1088 input stream is treated as a comment.

Note

One possible cause of this error is using an XML markup declaration (e.g., ) in HTML.

invalid-character- p1064 This error occurs if the parser encounters any code point sequence other than " PUBLIC " and " SYSTEM " keywords after a DOCTYPE name. sequence-after- In such a case, the parser ignores any following public or system identifiers, and if the DOCTYPE is correctly placed as a document

doctype-name p115 preamble, sets the Document to quirks mode.

invalid-first- p1066 This error occurs if the parser encounters a code point that is not an ASCII alpha where first code point of a start tag name or an end

character-of-tag- p1067 tag name is expected. If a start tag was expected such code point and a preceding U+003C (<) is treated as text content, and all name content that follows is treated as markup. Whereas, if an end tag was expected, such code point and all content that follows up to a

U+003E (>) code point (if present) or to the end of the p1088 input stream is treated as a comment.

Example

For example, consider the following markup:

<42>42>

This will be parsed into:

htmlp153

head p154

body p179

#text: <42>

#comment: 42

Note

While the first code point of a tag name is limited to an ASCII alpha, a wide range of code points (including ASCII digits) is allowed in subsequent positions.

missing-attribute- p1067 This error occurs if the parser encounters a U+003E (>) code point where an attribute value is expected (e.g.,

). The parser value treats the attribute as having an empty value.

missing-doctype- p1064 This error occurs if the parser encounters a DOCTYPE that is missing a name (e.g., ). In such a case, if the DOCTYPE is

name p115 correctly placed as a document preamble, the parser sets the Document to quirks mode.

missing-doctype- p1064 This error occurs if the parser encounters a U+003E (>) code point where start of the DOCTYPE public identifier is expected (e.g.,

public-identifier p115 ). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document

to quirks mode.

1079

Code Description

missing-doctype- This error occurs if the parser encounters a U+003E (>) code point where start of the DOCTYPEp1064 system identifier is expected (e.g.,

system-identifier p115 ). In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document

to quirks mode.

missing-end-tag- p1067 This error occurs if the parser encounters a U+003E (>) code point where an end tag name is expected, i.e., . The parser name completely ignores whole "" code point sequence.

missing-quote- p1064 This error occurs if the parser encounters the DOCTYPE public identifier that is not preceded by a quote (e.g., before-doctype- -//W3C//DTD HTML 4.01//EN">). In such a case, the parser ignores the public identifier, and if the DOCTYPE is correctly placed as a

public-identifier p115 document preamble, sets the Document to quirks mode.

missing-quote- p1064 This error occurs if the parser encounters the DOCTYPE system identifier that is not preceded by a quote (e.g., before-doctype- SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">). In such a case, the parser ignores the system identifier, and

system-identifier p115 if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.

missing- p1074 This error occurs if the parser encounters a character reference that is not terminated by a U+003B (;) code point. Usually the parser semicolon-after- behaves as if character reference is terminated by the U+003B (;) code point; however, there are some ambiguous cases in which the

character- parser includes subsequent code points in the character reference.

reference

Example

For example, ¬in will be parsed as "¬in" whereas ¬in will be parsed as "∉".

missing- p1064 This error occurs if the parser encounters a DOCTYPE whose "PUBLIC" keyword and public identifier are not separated by ASCII

whitespace-after-whitespace. In this case the parser behaves as if ASCII whitespace is present. doctype-public-

keyword

missing- p1064 This error occurs if the parser encounters a DOCTYPE whose "SYSTEM" keyword and system identifier are not separated by ASCII

whitespace-after-whitespace. In this case the parser behaves as if ASCII whitespace is present. doctype-system-

keyword

missing- p1064 This error occurs if the parser encounters a DOCTYPE whose "DOCTYPE" keyword and name are not separated by ASCII whitespace. In whitespace- this case the parser behaves as if ASCII whitespace is present.

before-doctype-

name

missing- p1067 This error occurs if the parser encounters attributes that are not separated by ASCII whitespace (e.g.,

). In whitespace- this case the parser behaves as if ASCII whitespace is present.

between-

attributes

missing- This error occurs if the parser encounters a DOCTYPEp1064 whose public and system identifiers are not separated by ASCII whitespace. In whitespace- this case the parser behaves as if ASCII whitespace is present.

between-doctype-

public-and-

system-identifiers

nested-comment p1075 This error occurs if the parser encounters a nested comment (e.g., -->). Such a comment will be closed by the

first occuring "-->" code point sequence and everything that follows will be treated as markup.

noncharacter- This error occurs if the parser encounters a numeric character referencep1074 that references a noncharacter. The parser resolves such character- character references as-is.

reference

noncharacter-in- p1088 This error occurs if the input stream contains a noncharacter. Such code points are parsed as-is and usually, where parsing rules don't input-stream apply any additional restrictions, make their way into the DOM.

non-void-html- p1066 p1065 This error occurs if the parser encounters a start tag for an element that is not in the list of void elements or is not a part of foreign

element-start- content (i.e., not an SVG or MathML element) that has a U+002F (/) code point right before the closing U+003E (>) code point. The parser tag-with-trailing- behaves as if the U+002F (/) is not present.

solidus

Example

For example, consider the following markup:

<div/><span>span><span>span>

This will be parsed into:

html p153

head p154

body p179

div p238



1080

Code Description



spanp280

span p280

Note

The trailing U+002F (/) in a start tag name can be used only in foreign content to specify self-closing tags. (Self-closing tags don't exist in HTML.) It is also allowed for void elements, but doesn't have any effect in this case.

null-character- p1074 This error occurs if the parser encounters a numeric character reference that references a U+0000 NULL code point. The parser reference resolves such character references to a U+FFFD REPLACEMENT CHARACTER.

surrogate- p1074 This error occurs if the parser encounters a numeric character reference that references a surrogate. The parser resolves such character- character references to a U+FFFD REPLACEMENT CHARACTER.

reference

surrogate-in- p1088 This error occurs if the input stream contains a surrogate. Such code points are parsed as-is and usually, where parsing rules don't input-stream apply any additional restrictions, make their way into the DOM.

Note

Surrogates can only find their way into the input stream via script APIs such as document.write()p958.

unexpected- p1064 This error occurs if the parser encounters any code points other than ASCII whitespace or closing U+003E (>) after the DOCTYPE character-after- system identifier. The parser ignores these code points.

doctype-system-

identifier

unexpected- p1067 This error occurs if the parser encounters a U+0022 ("), U+0027 ('), or U+003C (<) code point in an attribute name. The parser character-in- includes such code points in the attribute name.

attribute-name

Note

Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute name.

Example

For example, consider the following markup:

<div foo<div>

Due to a forgotten U+003E (>) code point after p238 foo the parser treats this markup as a single div element with a "foo" attribute.

As another example of this error, consider the following markup:

<div id'bar'>

Due to a forgotten U+003D (=) code point between an attribute name and value the parser treats this markup as a p238 div element with the attribute "id'bar'" that has an empty value.

unexpected- This error occurs if the parser encounters a U+0022 ("), U+0027 ('), U+003C (<), U+003D (=), or U+0060 (`) code point in an unquoted

character-in- p1067 attribute value. The parser includes such code points in the attribute value. unquoted-

attribute-value Note

Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute value.

Note

U+0060 (`) is in the list of code points that trigger this error because certain legacy user agents treat it as a quote.

Example

For example, consider the following markup:

<div foo=b'ar'>

Due to a misplaced U+0027 (') code point the parser sets the value of the "foo" attribute to "b'ar'".



1081

Code Description

unexpected- This error occurs if the parser encounters a U+003D (=) code point before an attribute name. In this case the parser treats U+003D (=) as equals-sign- the first code point of the attribute name.

before-attribute-

name Note

The common reason for this error is a forgotten attribute name.

Example

For example, consider the following markup:

<div foo="bar" ="baz">

Due to a forgotten attribute name the parser treats this markup as a p238 div element with two attributes: a "foo" attribute with a "bar" value and a "="baz"" attribute with an empty value.

unexpected-null- p1088 This error occurs if the parser encounters a U+0000 NULL code point in the input stream in certain positions. In general, such code character points are either completely ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER.

unexpected- p1066 This error occurs if the parser encounters a U+003F (?) code point where first code point of a start tag name is expected. The U+003F

question-mark- p1088 (?) and all content that follows up to a U+003E (>) code point (if present) or to the end of the input stream is treated as a comment. instead-of-tag-

name Example

For example, consider the following markup:



This will be parsed into:

#comment: ?xml-stylesheet type="text/css" href="style.css"?

html p153

head p154

body p179

Note

The common reason for this error is an XML processing instruction (e.g., ) or an XML declaration (e.g., ) being used in HTML.

unexpected- p1067 This error occurs if the parser encounters a U+002F (/) code point that is not a part of a quoted attribute value and not immediately

solidus-in-tag followed by a U+003E (>) code point in a tag (e.g.,

). In this case the parser behaves as if it encountered ASCII

whitespace.

unknown-named- p1075 This error occurs if the parser encounters an ambiguous ampersand. In this case the parser doesn't resolve the character

character- p1074 reference.

reference



13.2.3 The input byte stream p10 §

82

The stream of code points that comprises the input to the tokenization stage will be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). The bytes encode the actual characters according to a particular character encoding, which the user agent uses to decode the bytes into characters.

Note

For XML documents, the algorithm user agents are required to use to determine the character encoding is given by XML. This

section does not apply to XML documents. p1283 [XML]

Usually, the p1083 encoding sniffing algorithm defined below is used to determine the character encoding.

Given a character encoding, the bytes in the p1082 input byte stream must be converted to characters for the tokenizer's input

stream p1088 p1082 , by passing the input byte stream and character encoding to decode.

Note

A leading Byte Order Mark (BOM) causes the character encoding argument to be ignored and will itself be skipped. 1082

Note

Bytes or sequences of bytes in the original byte stream that did not conform to the Encoding standard (e.g. invalid UTF-8 byte

sequences in a UTF-8 input byte stream) are errors that conformance checkers are expected to report. p1277 [ENCODING]



⚠Warning!

The decoder algorithms describe how to handle invalid input; for security reasons, it is imperative that those rules

be followed precisely. Differences in how invalid byte sequences are handled can result in, amongst other problems,

script injection vulnerabilities ("XSS").

When the HTML parser is decoding an input byte stream, it uses a character encoding and a confidence. The confidence is either tentative, certain, or irrelevant. The encoding used, and whether the confidence in that encoding is tentative or certain, is used during

the parsing p1132 p1088 to determine whether to change the encoding. If no encoding is necessary, e.g. because the parser is operating on a Unicode stream and doesn't have to use a character encoding at all, then the p1083 confidence is irrelevant.

Note

Some algorithms feed the parser by directly adding characters to the p1088 input stream rather than adding bytes to the input byte

stream p1082.



13.2.3.1 Parsing with a known character encoding §p10

83

When the HTML parser is to operate on an input byte stream that has a known definite encoding, then the character encoding is that encoding and the p1083 confidence is certain.



13.2.3.2 Determining the character encoding p10 §

83

In some cases, it might be impractical to unambiguously determine the encoding before parsing the document. Because of this, this specification provides for a two-pass mechanism with an optional pre-scan. Implementations are allowed, as described below, to apply a simplified parsing algorithm to whatever bytes they have available before beginning to parse the document. Then, the real parser is started, using a tentative encoding derived from this pre-parse and other out-of-band metadata. If, while the document is being loaded, the user agent discovers a character encoding declaration that conflicts with this information, then the parser can get reinvoked to perform a parse of the document with the real encoding.

User agents must use the following algorithm, called the encoding sniffing algorithm, to determine the character encoding to use when decoding a document in the first pass. This algorithm takes as input any out-of-band metadata available to the user agent (e.g.

the p90 Content-Type metadata of the document) and all the bytes available so far, and returns a character encoding and a

confidence p1083 that is either tentative or certain.

1. If the result of p1083 BOM sniffing is an encoding, return that encoding with confidence certain.

Note

Although the decode algorithm will itself change the encoding to use based on the presence of a byte order mark, this

algorithm sniffs the BOM as well in order to set the correct p1083 document's character encoding and confidence.

2. If the user has explicitly instructed the user agent to override the document's character encoding with a specific encoding,

optionally return that encoding with the p1083 confidence certain.

Note

Typically, user agents remember such user requests across sessions, and in some cases apply them to documents in

iframe p362 s as well.

3. The user agent may wait for more bytes of the resource to be available, either in this step or at any later step in this

algorithm. For instance, a user agent might wait 500ms or 1024 bytes, whichever came first. In general preparsing the source to find the encoding improves performance, as it reduces the need to throw away the data structures used when parsing upon finding the encoding information. However, if the user agent delays too long to obtain data to determine the encoding, then the cost of the delay could outweigh any performance improvements from the preparse.



1083

Note

The authoring conformance requirements for character encoding declarations limit them to only appearing in the first

1024 bytes p175. User agents are therefore encouraged to use the prescan algorithm below (as invoked by these steps) on the first 1024 bytes, but not to stall beyond that.

4. If the transport layer specifies a character encoding, and it is supported, return that encoding with the p1083 confidence

certain.

5. Optionally p1085 prescan the byte stream to determine its encoding. The end condition is that the user agent decides that

scanning further bytes would not be efficient. User agents are encouraged to only prescan the first 1024 bytes. User agents may decide that scanning any bytes is not efficient, in which case these substeps are entirely skipped.

The aforementioned algorithm either aborts unsuccessfully or returns a character encoding. If it returns a character

encoding, then return the same encoding, with p1083 confidence tentative.

6. If the p1076 p115 p814 HTML parser for which this algorithm is being run is associated with a Document d whose browsing context is

non-null and a p817 child browsing context, then:

1. Let p814 p817 parentDocument be d 's browsing context 's container document .

2. If p841 p842 p841 parentDocument 's origin is same origin with d 's origin and parentDocument's character encoding is not

UTF-16BE/LE p1083 , then return parentDocument 's character encoding , with the confidence tentative.

7. Otherwise, if the user agent has information on the likely encoding for this page, e.g. based on the encoding of the page

when it was last visited, then return that encoding, with the p1083 confidence tentative.

8. The user agent may attempt to autodetect the character encoding from applying frequency analysis or other algorithms to

the data stream. Such algorithms may use information about the resource other than the resource's contents, including the address of the resource. If autodetection succeeds in determining a character encoding, and that encoding is a supported

encoding, then return that encoding, with the p1083 p1282 confidence tentative . [UNIVCHARDET]

Note

User agents are generally discouraged from attempting to autodetect encodings for resources obtained over the network, since doing so involves inherently non-interoperable heuristics. Attempting to detect encodings based on an HTML document's preamble is especially tricky since HTML markup typically uses only ASCII characters, and HTML documents tend to begin with a lot of markup rather than with text content.

Note

The UTF-8 encoding has a highly detectable bit pattern. Files from the local file system that contain bytes with values greater than 0x7F which match the UTF-8 pattern are very likely to be UTF-8, while documents with byte sequences that do not match it are very likely not. When a user agent can examine the whole file, rather than just the preamble,

detecting for UTF-8 specifically can be especially effective. p1280 p1282 [PPUTF8] [UTF8DET]

9. Otherwise, return an p1083 implementation-defined or user-specified default character encoding, with the confidence tentative.

In controlled environments or in environments where the encoding of documents can be prescribed (for example, for user agents intended for dedicated use in new networks), the comprehensive UTF-8 encoding is suggested.

In other environments, the default encoding is typically dependent on the user's locale (an approximation of the languages, and thus often encodings, of the pages that the user is likely to frequent). The following table gives suggested defaults based

on the user's locale, for compatibility with legacy content. Locales are identified by BCP 47 language tags. p1275 [BCP47]

[ENCODING] p1277

Locale language Suggested default encoding

ar Arabic windows-1256

ba Bashkir windows-1251

be Belarusian windows-1251

bg Bulgarian windows-1251

cs Czech windows-1250

el Greek ISO-8859-7

et Estonian windows-1257

fa Persian windows-1256

he Hebrew windows-1255

hr Croatian windows-1250

1084

Locale language Suggested default encoding

hu Hungarian ISO-8859-2

ja Japanese Shift_JIS

kk Kazakh windows-1251

ko Korean EUC-KR

ku Kurdish windows-1254

ky Kyrgyz windows-1251

lt Lithuanian windows-1257

lv Latvian windows-1257

mk Macedonian windows-1251

pl Polish ISO-8859-2

ru Russian windows-1251

sah Yakut windows-1251

sk Slovak windows-1250

sl Slovenian ISO-8859-2

sr Serbian windows-1251

tg Tajik windows-1251

th Thai windows-874

tr Turkish windows-1254

tt Tatar windows-1251

uk Ukrainian windows-1251

vi Vietnamese windows-1258

zh-CN Chinese (People's Republic of China) gb18030

zh-TW Chinese (Taiwan) Big5

All other locales windows-1252

The contents of this table are derived from the intersection of Windows, Chrome, and Firefox defaults.

The document's character encoding must immediately be set to the value returned from this algorithm, at the same time as the user agent uses the returned value to select the decoder to use for the input byte stream.



When an algorithm requires a user agent to prescan a byte stream to determine its encoding, given some defined end condition, then it must run the following steps. These steps either abort unsuccessfully or return a character encoding. If at any point during these steps (including during instances of the p1086 get an attribute algorithm invoked by this one) the user agent either runs out of bytes (meaning the position pointer created in the first step below goes beyond the end of the byte stream obtained so far) or reaches its p1085 end condition , then abort the prescan a byte stream to determine its encoding algorithm unsuccessfully.

1. Let position be a pointer to a byte in the input byte stream, initially pointing at the first byte.

2. Loop: If position points to:

↪ A sequence of bytes starting with: 0x3C 0x21 0x2D 0x2D (`<!--`)

Advance the position pointer so that it points at the first 0x3E byte which is preceded by two 0x2D bytes (i.e. at the end of an ASCII '-->' sequence) and comes after the 0x3C byte that was found. (The two 0x2D bytes can be the same as those in the '" (U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN).

↪ If current node is a ProcessingInstruction

Append the literal string "current node's target IDL attribute, followed by a single U+0020 SPACE character, followed by the value of current node's data IDL attribute, followed by a single U+003E GREATER-THAN SIGN character (>).

↪ If current node is a DocumentType

Append the literal string "current node's name IDL attribute, followed by the literal string ">" (U+003E GREATER-THAN SIGN).

5. Return s.

⚠Warning!

It is possible that the output of this algorithm, if parsed with an p1076 HTML parser, will not return the original tree

structure. Tree structures that do not roundtrip a serialize and reparse step can also be produced by the HTML

parser p1076 itself, although such cases are typically non-conforming.



Example

For instance, if a p549 textarea element to which a Comment node has been appended is serialized and the output is then reparsed,

the comment will end up being displayed in the text control. Similarly, if, as a result of DOM manipulation, an element contains a

comment that contains the literal string "-->", then when the result of serializing the element is parsed, the comment will be

truncated at that point and the rest of the comment will be interpreted as markup. More examples would be making a p614 script

element contain a p213 p223 Text node with the text string " ", or having a p element that contains a ul element (as the

ul p223 p1066 p213 element's start tag would imply the end tag for the p).

This can enable cross-site scripting attacks. An example of this would be a page that lets the user enter some font family names

that are then inserted into a CSS p175 style block via the DOM and which then uses the innerHTML IDL attribute to get the HTML

serialization of that p175 style element: if the user enters "" as a font family name, innerHTML

will return markup that, if parsed in a different context, would contain a p614 p614 script node, even though no script node existed

in the original DOM.



Example

For example, consider the following markup:





This will be parsed into:

html p153

head p154

body p179

form p487 p138 id="outer"

div p238

form p487 p138 id="inner"

input p494



1171

The p494 p487 input element will be associated with the inner form element. Now, if this tree structure is serialized and reparsed, the

p494 p487 start tag will be ignored, and so the input element will be associated with the outer form element

instead.



id="inner">





html p153

head p154

body p179

form p487 p138 id="outer"

div p238

input p494



Example

As another example, consider the following markup:



This will be parsed into:

html p153

head p154

body p179

a p239

a p239

table p451

That is, the p239 p239 p1123 a elements are nested, because the second a element is foster parented. After a serialize-reparse roundtrip,

the p239 p451 p239 a elements and the table element would all be siblings, because the second start tag implicitly closes the first a

element.





html p153

head p154

body p179

a p239

a p239

table p451

For historical reasons, this algorithm does not round-trip an initial U+000A LINE FEED (LF) character in p217 p549 pre , textarea , or

listing p1223 p1076 elements, even though (in the first two cases) the markup being round-tripped can be conforming. The HTML parser

will drop such a character during parsing, but this algorithm does not serialize an extra U+000A LINE FEED (LF) character.

Example

For example, consider the following markup:





Hello.





When this document is first parsed, the p217 pre element's child text content starts with a single newline character. After a serialize-

reparse roundtrip, the p217 pre element's child text content is simply "Hello.".

Because of the special role of the p705 p705 is attribute in signaling the creation of customized built-in elements, in that it provides a mechanism for parsed HTML to set the element's is value, we special-case its handling during serialization.This ensures that an element's is value is preserved through serialize-parse roundtrips.

1172

Example

When creating a p705 p705 customized built-in element via the parser, a developer uses the is attribute directly; in such cases

serialize-parse roundtrips work fine.





Superb!





But when creating a customized built-in element via its p705 p705 constructor or via createElement() , the is attribute is not added.

Instead, the is value (which is what the custom elements machinery uses) is set without intermediating through an attribute.



To ensure that serialize-parse roundtrips still work, the serialization process explicitly writes out the element's p705 is value as an is

attribute:





Escaping a string (for the purposes of the algorithm above) consists of running the following steps:

1. Replace any occurrence of the "&" character by the string "&".

2. Replace any occurrences of the U+00A0 NO-BREAK SPACE character by the string " ".

3. If the algorithm was invoked in the attribute mode, replace any occurrences of the """ character by the string """.

4. If the algorithm was not invoked in the attribute mode, replace any occurrences of the "<" character by the string "<", and

any occurrences of the ">" character by the string ">".



13.4 Parsing HTML fragments p11 §

73

The following steps form the HTML fragment parsing algorithm. The algorithm takes as input an Element node, referred to as the context element, which gives the context for the parser, as well as input, a string to parse, and returns a list of zero or more nodes.



1173

Note

Parts marked fragment case in algorithms in the parser section are parts that only occur if the parser was created for the

purposes of this algorithm. The algorithms have been annotated with such markings for informational purposes only; such

markings have no normative weight. If it is possible for a condition described as a p1174 fragment case to occur even when the

parser wasn't created for the purposes of handling this algorithm, then that is an error in the specification.

1. Create a new p115 Document node, and mark it as being an HTML document.

2. If the p1173 p115 node document of the context element is in quirks mode , then let the Document be in quirks mode. Otherwise,

the p1173 p115 node document of the context element is in limited-quirks mode , then let the Document be in limited-quirks mode.

Otherwise, leave the p115 Document in no-quirks mode.

3. Create a new p1076 p115 HTML parser , and associate it with the just created Document node.

4. Set the state of the p1076 p1094 p1173 HTML parser 's tokenization stage as follows, switching on the context element:

↪ p155 title

↪ p549 textarea

Switch the tokenizer to the p1095 RCDATA state.

↪ p175 style

↪ p1224 xmp

↪ p362 iframe

↪ p1223 noembed

↪ p1223 noframes

Switch the tokenizer to the p1095 RAWTEXT state.

↪ p614 script

Switch the tokenizer to the p1095 script data state.

↪ p628 noscript

If the p1093 p1095 scripting flag is enabled, switch the tokenizer to the RAWTEXT state. Otherwise, leave the tokenizer in

the p1095 data state.

↪ p1223 plaintext

Switch the tokenizer to the p1096 PLAINTEXT state.

↪ Any other element

Leave the tokenizer in the p1095 data state.

Note

For performance reasons, an implementation that does not report errors and that uses the actual state machine described in this specification directly could use the PLAINTEXT state instead of the RAWTEXT and script data states where those are mentioned in the list above. Except for rules regarding parse errors, they are equivalent, since there is

no p1094 appropriate end tag token in the fragment case, yet they involve far fewer state transitions.

5. Let p153 root be a new html element with no attributes.

6. Append the element p115 root to the Document node created above.

7. Set up the parser's p1090 stack of open elements so that it contains just the single element root.

8. If the p1173 p630 p1155 p1089 context element is a template element, push " in template " onto the stack of template insertion modes

so that it is the new p1089 current template insertion mode.

9. Create a start tag token whose name is the local name of p1173 p1173 context and whose attributes are the attributes of context.

Let this start tag token be the start tag token of the p1173 context node, e.g. for the purposes of determining if it is an HTML

integration point p1123.

10. p1089 Reset the parser's insertion mode appropriately.

Note

The parser will reference the p1173 context element as part of that algorithm.

1174

11. Set the parser's p1093 p1173 p487 form element pointer to the nearest node to the context element that is a form element (going

straight up the ancestor chain, and including the element itself, if it is a p487 p487 form element), if any. (If there is no such form

element, the p1093 form element pointer keeps its initial value, null.)

12. Place the p1088 p1076 p1083 input into the input stream for the HTML parser just created. The encoding confidence is irrelevant.

13. Start the parser and let it run until it has consumed all the characters just inserted into the input stream.

14. Return the child nodes of root, in tree order.



13.5 Named character references p11 §

75

This table lists the character reference names that are supported by HTML, and the code points to which they refer. It is referenced by the previous sections.

Note

It is intentional, for legacy compatibility, that many code points have multiple character reference names. For example, some

appear both with and without the trailing semicolon, or with different capitalizations.

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

Aacute; U+000C1 Á angrtvbd; U+0299D ⦝ bernou; U+0212C ℬ

Aacute U+000C1 Á angsph; U+02222 ∢ Bernoullis; U+0212C ℬ

aacute; U+000E1 á angst; U+000C5 Å Beta; U+00392 Β

aacute U+000E1 á angzarr; U+0237C ⍼ beta; U+003B2 β

Abreve; U+00102 Ă Aogon; U+00104 Ą beth; U+02136 ℶ

abreve; U+00103 ă aogon; U+00105 ą between; U+0226C ≬

ac; U+0223E ∾ Aopf; U+1D538 𝔸 Bfr; U+1D505 𝔅

acd; U+0223F ∿ aopf; U+1D552 𝕒 bfr; U+1D51F 𝔟

acE; U+0223E U+00333 ∾̳ ap; U+02248 ≈ bigcap; U+022C2 ⋂

Acirc; U+000C2 Â apacir; U+02A6F ⩯ bigcirc; U+025EF ◯

Acirc U+000C2 Â apE; U+02A70 ⩰ bigcup; U+022C3 ⋃

acirc; U+000E2 â ape; U+0224A ≊ bigodot; U+02A00 ⨀

acirc U+000E2 â apid; U+0224B ≋ bigoplus; U+02A01 ⨁

acute; U+000B4 ´ apos; U+00027 ' bigotimes; U+02A02 ⨂

acute U+000B4 ´ ApplyFunction; U+02061 bigsqcup; U+02A06 ⨆

Acy; U+00410 А approx; U+02248 ≈ bigstar; U+02605 ★

acy; U+00430 а approxeq; U+0224A ≊ bigtriangledown; U+025BD ▽

AElig; U+000C6 Æ Aring; U+000C5 Å bigtriangleup; U+025B3 △

AElig U+000C6 Æ Aring U+000C5 Å biguplus; U+02A04 ⨄

aelig; U+000E6 æ aring; U+000E5 å bigvee; U+022C1 ⋁

aelig U+000E6 æ aring U+000E5 å bigwedge; U+022C0 ⋀

af; U+02061 Ascr; U+1D49C 𝒜 bkarow; U+0290D ⤍

Afr; U+1D504 𝔄 ascr; U+1D4B6 𝒶 blacklozenge; U+029EB ⧫

afr; U+1D51E 𝔞 Assign; U+02254 ≔ blacksquare; U+025AA ▪

Agrave; U+000C0 À ast; U+0002A * blacktriangle; U+025B4 ▴

Agrave U+000C0 À asymp; U+02248 ≈ blacktriangledown; U+025BE ▾

agrave; U+000E0 à asympeq; U+0224D ≍ blacktriangleleft; U+025C2 ◂

agrave U+000E0 à Atilde; U+000C3 Ã blacktriangleright; U+025B8 ▸

alefsym; U+02135 ℵ Atilde U+000C3 Ã blank; U+02423 ␣

aleph; U+02135 ℵ atilde; U+000E3 ã blk12; U+02592 ▒

Alpha; U+00391 Α atilde U+000E3 ã blk14; U+02591 ░

alpha; U+003B1 α Auml; U+000C4 Ä blk34; U+02593 ▓

Amacr; U+00100 Ā Auml U+000C4 Ä block; U+02588 █

amacr; U+00101 ā auml; U+000E4 ä bne; U+0003D U+020E5 =⃥

amalg; U+02A3F ⨿ auml U+000E4 ä bnequiv; U+02261 U+020E5 ≡⃥

AMP; U+00026 & awconint; U+02233 ∳ bNot; U+02AED ⫭

AMP U+00026 & awint; U+02A11 ⨑ bnot; U+02310 ⌐

amp; U+00026 & backcong; U+0224C ≌ Bopf; U+1D539 𝔹

amp U+00026 & backepsilon; U+003F6 ϶ bopf; U+1D553 𝕓

And; U+02A53 ⩓ backprime; U+02035 ‵ bot; U+022A5 ⊥

and; U+02227 ∧ backsim; U+0223D ∽ bottom; U+022A5 ⊥

andand; U+02A55 ⩕ backsimeq; U+022CD ⋍ bowtie; U+022C8 ⋈

andd; U+02A5C ⩜ Backslash; U+02216 ∖ boxbox; U+029C9 ⧉

andslope; U+02A58 ⩘ Barv; U+02AE7 ⫧ boxDL; U+02557 ╗

andv; U+02A5A ⩚ barvee; U+022BD ⊽ boxDl; U+02556 ╖

ang; U+02220 ∠ Barwed; U+02306 ⌆ boxdL; U+02555 ╕

ange; U+029A4 ⦤ barwed; U+02305 ⌅ boxdl; U+02510 ┐

angle; U+02220 ∠ barwedge; U+02305 ⌅ boxDR; U+02554 ╔

angmsd; U+02221 ∡ bbrk; U+023B5 ⎵ boxDr; U+02553 ╓

angmsdaa; U+029A8 bbrktbrk; U+023B6 ⦨ ⎶ boxdR; U+02552 ╒

angmsdab; U+029A9 ⦩ bcong; U+0224C ≌ boxdr; U+0250C ┌

angmsdac; U+029AA ⦪ Bcy; U+00411 Б boxH; U+02550 ═

angmsdad; U+029AB ⦫ bcy; U+00431 б boxh; U+02500 ─

angmsdae; U+029AC bdquo; U+0201E „ boxHD; U+02566 ╦ ⦬

angmsdaf; becaus; U+02235 ∵ boxHd; U+02564 ╤ U+029AD ⦭

angmsdag; Because; U+02235 ∵ boxhD; U+02565 ╥ U+029AE ⦮

angmsdah; because; U+02235 ∵ boxhd; U+0252C ┬ U+029AF ⦯

angrt; bemptyv; U+029B0 ⦰ boxHU; U+02569 ╩ U+0221F ∟

angrtvb; bepsi; U+003F6 ϶ boxHu; U+02567 ╧ U+022BE ⊾

1175

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

boxhU; U+02568 ╨ chi; U+003C7 χ cwint; U+02231 ∱

boxhu; U+02534 ┴ cir; U+025CB ○ cylcty; U+0232D ⌭

boxminus; U+0229F ⊟ circ; U+002C6 ˆ Dagger; U+02021 ‡

boxplus; U+0229E ⊞ circeq; U+02257 ≗ dagger; U+02020 †

boxtimes; U+022A0 ⊠ circlearrowleft; U+021BA ↺ daleth; U+02138 ℸ

boxUL; U+0255D ╝ circlearrowright; U+021BB ↻ Darr; U+021A1 ↡

boxUl; U+0255C ╜ circledast; U+0229B ⊛ dArr; U+021D3 ⇓

boxuL; U+0255B ╛ circledcirc; U+0229A ⊚ darr; U+02193 ↓

boxul; U+02518 ┘ circleddash; U+0229D ⊝ dash; U+02010 ‐

boxUR; U+0255A ╚ CircleDot; U+02299 ⊙ Dashv; U+02AE4 ⫤

boxUr; U+02559 ╙ circledR; U+000AE ® dashv; U+022A3 ⊣

boxuR; U+02558 ╘ circledS; U+024C8 Ⓢ dbkarow; U+0290F ⤏

boxur; U+02514 └ CircleMinus; U+02296 ⊖ dblac; U+002DD ˝

boxV; U+02551 ║ CirclePlus; U+02295 ⊕ Dcaron; U+0010E Ď

boxv; U+02502 │ CircleTimes; U+02297 ⊗ dcaron; U+0010F ď

boxVH; U+0256C ╬ cirE; U+029C3 ⧃ Dcy; U+00414 Д

boxVh; U+0256B ╫ cire; U+02257 ≗ dcy; U+00434 д

boxvH; U+0256A ╪ cirfnint; U+02A10 ⨐ DD; U+02145 ⅅ

boxvh; U+0253C ┼ cirmid; U+02AEF ⫯ dd; U+02146 ⅆ

boxVL; U+02563 ╣ cirscir; U+029C2 ⧂ ddagger; U+02021 ‡

boxVl; U+02562 ╢ ClockwiseContourIntegral; U+02232 ∲ ddarr; U+021CA ⇊

boxvL; U+02561 ╡ CloseCurlyDoubleQuote; U+0201D ” DDotrahd; U+02911 ⤑

boxvl; U+02524 ┤ CloseCurlyQuote; U+02019 ’ ddotseq; U+02A77 ⩷

boxVR; U+02560 ╠ clubs; U+02663 ♣ deg; U+000B0 °

boxVr; U+0255F ╟ clubsuit; U+02663 ♣ deg U+000B0 °

boxvR; U+0255E ╞ Colon; U+02237 ∷ Del; U+02207 ∇

boxvr; U+0251C ├ colon; U+0003A : Delta; U+00394 Δ

bprime; U+02035 ‵ Colone; U+02A74 ⩴ delta; U+003B4 δ

Breve; U+002D8 ˘ colone; U+02254 ≔ demptyv; U+029B1 ⦱

breve; U+002D8 ˘ coloneq; U+02254 ≔ dfisht; U+0297F ⥿

brvbar; U+000A6 ¦ comma; U+0002C , Dfr; U+1D507 𝔇

brvbar U+000A6 ¦ commat; U+00040 @ dfr; U+1D521 𝔡

Bscr; U+0212C ℬ comp; U+02201 ∁ dHar; U+02965 ⥥

bscr; U+1D4B7 𝒷 compfn; U+02218 ∘ dharl; U+021C3 ⇃

bsemi; U+0204F ⁏ complement; U+02201 ∁ dharr; U+021C2 ⇂

bsim; U+0223D ∽ complexes; U+02102 ℂ DiacriticalAcute; U+000B4 ´

bsime; U+022CD ⋍ cong; U+02245 ≅ DiacriticalDot; U+002D9 ˙

bsol; U+0005C \ congdot; U+02A6D ⩭ DiacriticalDoubleAcute; U+002DD ˝

bsolb; U+029C5 ⧅ Congruent; U+02261 ≡ DiacriticalGrave; U+00060 `

bsolhsub; U+027C8 ⟈ Conint; U+0222F ∯ DiacriticalTilde; U+002DC ˜

bull; U+02022 • conint; U+0222E ∮ diam; U+022C4 ⋄

bullet; U+02022 • ContourIntegral; U+0222E ∮ Diamond; U+022C4 ⋄

bump; U+0224E ≎ Copf; U+02102 ℂ diamond; U+022C4 ⋄

bumpE; U+02AAE ⪮ copf; U+1D554 𝕔 diamondsuit; U+02666 ♦

bumpe; U+0224F ≏ coprod; U+02210 ∐ diams; U+02666 ♦

Bumpeq; U+0224E ≎ Coproduct; U+02210 ∐ die; U+000A8 ¨

bumpeq; U+0224F ≏ COPY; U+000A9 © DifferentialD; U+02146 ⅆ

Cacute; U+00106 Ć COPY U+000A9 © digamma; U+003DD ϝ

cacute; U+00107 ć copy; U+000A9 © disin; U+022F2 ⋲

Cap; U+022D2 ⋒ copy U+000A9 © div; U+000F7 ÷

cap; U+02229 ∩ copysr; U+02117 ℗ divide; U+000F7 ÷

capand; U+02A44 ⩄ CounterClockwiseContourIntegral; U+02233 ∳ divide U+000F7 ÷

capbrcup; U+02A49 ⩉ crarr; U+021B5 ↵ divideontimes; U+022C7 ⋇

capcap; U+02A4B ⩋ Cross; U+02A2F ⨯ divonx; U+022C7 ⋇

capcup; U+02A47 ⩇ cross; U+02717 ✗ DJcy; U+00402 Ђ

capdot; U+02A40 ⩀ Cscr; U+1D49E 𝒞 djcy; U+00452 ђ

CapitalDifferentialD; U+02145 ⅅ cscr; U+1D4B8 𝒸 dlcorn; U+0231E ⌞

caps; U+02229 U+0FE00 ∩︀ csub; U+02ACF ⫏ dlcrop; U+0230D ⌍

caret; U+02041 ⁁ csube; U+02AD1 ⫑ dollar; U+00024 $

caron; U+002C7 ˇ csup; U+02AD0 ⫐ Dopf; U+1D53B 𝔻

Cayleys; U+0212D ℭ csupe; U+02AD2 ⫒ dopf; U+1D555 𝕕

ccaps; U+02A4D ⩍ ctdot; U+022EF ⋯ Dot; U+000A8 ¨

Ccaron; U+0010C Č cudarrl; U+02938 ⤸ dot; U+002D9 ˙

ccaron; U+0010D č cudarrr; U+02935 ⤵ DotDot; U+020DC ◌⃜

Ccedil; U+000C7 Ç cuepr; U+022DE ⋞ doteq; U+02250 ≐

Ccedil U+000C7 Ç cuesc; U+022DF ⋟ doteqdot; U+02251 ≑

ccedil; U+000E7 ç cularr; U+021B6 ↶ DotEqual; U+02250 ≐

ccedil U+000E7 ç cularrp; U+0293D ⤽ dotminus; U+02238 ∸

Ccirc; U+00108 Ĉ Cup; U+022D3 ⋓ dotplus; U+02214 ∔

ccirc; U+00109 ĉ cup; U+0222A ∪ dotsquare; U+022A1 ⊡

Cconint; U+02230 ∰ cupbrcap; U+02A48 ⩈ doublebarwedge; U+02306 ⌆

ccups; U+02A4C ⩌ CupCap; U+0224D ≍ DoubleContourIntegral; U+0222F ∯

ccupssm; U+02A50 ⩐ cupcap; U+02A46 ⩆ DoubleDot; U+000A8 ¨

Cdot; U+0010A Ċ cupcup; U+02A4A DoubleDownArrow; U+021D3 ⇓ ⩊

cdot; U+0010B ċ DoubleLeftArrow; U+021D0 ⇐ cupdot; U+0228D ⊍

cedil; U+000B8 ¸ DoubleLeftRightArrow; U+021D4 ⇔ cupor; U+02A45 ⩅

cedil U+000B8 ¸ DoubleLeftTee; U+02AE4 cups; U+0222A U+0FE00 ∪︀ ⫤

Cedilla; U+000B8 ¸ curarr; U+021B7 ↷ DoubleLongLeftArrow; U+027F8 ⟸

cemptyv; U+029B2 ⦲ curarrm; U+0293C DoubleLongLeftRightArrow; U+027FA ⟺ ⤼

cent; U+000A2 ¢ DoubleLongRightArrow; U+027F9 ⟹ curlyeqprec; U+022DE ⋞

cent U+000A2 ¢ DoubleRightArrow; U+021D2 ⇒ curlyeqsucc; U+022DF ⋟

CenterDot; U+000B7 · DoubleRightTee; U+022A8 ⊨ curlyvee; U+022CE ⋎

centerdot; U+000B7 · DoubleUpArrow; U+021D1 ⇑ curlywedge; U+022CF ⋏

Cfr; U+0212D ℭ DoubleUpDownArrow; U+021D5 ⇕ curren; U+000A4 ¤

cfr; U+1D520 𝔠 DoubleVerticalBar; U+02225 ∥ curren U+000A4 ¤

CHcy; U+00427 Ч DownArrow; U+02193 ↓ curvearrowleft; U+021B6 ↶

chcy; U+00447 ч Downarrow; U+021D3 ⇓ curvearrowright; U+021B7 ↷

check; U+02713 ✓ downarrow; U+02193 ↓ cuvee; U+022CE ⋎

checkmark; U+02713 ✓ DownArrowBar; U+02913 cuwed; U+022CF ⋏ ⤓

Chi; U+003A7 Χ DownArrowUpArrow; U+021F5 ⇵ cwconint; U+02232 ∲

1176

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

DownBreve; U+00311 ◌̑ epsilon; U+003B5 ε gammad; U+003DD ϝ

downdownarrows; U+021CA ⇊ epsiv; U+003F5 ϵ gap; U+02A86 ⪆

downharpoonleft; U+021C3 ⇃ eqcirc; U+02256 ≖ Gbreve; U+0011E Ğ

downharpoonright; U+021C2 ⇂ eqcolon; U+02255 ≕ gbreve; U+0011F ğ

DownLeftRightVector; U+02950 ⥐ eqsim; U+02242 ≂ Gcedil; U+00122 Ģ

DownLeftTeeVector; U+0295E ⥞ eqslantgtr; U+02A96 ⪖ Gcirc; U+0011C Ĝ

DownLeftVector; U+021BD ↽ eqslantless; U+02A95 ⪕ gcirc; U+0011D ĝ

DownLeftVectorBar; U+02956 ⥖ Equal; U+02A75 ⩵ Gcy; U+00413 Г

DownRightTeeVector; U+0295F ⥟ equals; U+0003D = gcy; U+00433 г

DownRightVector; U+021C1 ⇁ EqualTilde; U+02242 ≂ Gdot; U+00120 Ġ

DownRightVectorBar; U+02957 ⥗ equest; U+0225F ≟ gdot; U+00121 ġ

DownTee; U+022A4 ⊤ Equilibrium; U+021CC ⇌ gE; U+02267 ≧

DownTeeArrow; U+021A7 ↧ equiv; U+02261 ≡ ge; U+02265 ≥

drbkarow; U+02910 ⤐ equivDD; U+02A78 ⩸ gEl; U+02A8C ⪌

drcorn; U+0231F ⌟ eqvparsl; U+029E5 ⧥ gel; U+022DB ⋛

drcrop; U+0230C ⌌ erarr; U+02971 ⥱ geq; U+02265 ≥

Dscr; U+1D49F 𝒟 erDot; U+02253 ≓ geqq; U+02267 ≧

dscr; U+1D4B9 𝒹 Escr; U+02130 ℰ geqslant; U+02A7E ⩾

DScy; U+00405 Ѕ escr; U+0212F ℯ ges; U+02A7E ⩾

dscy; U+00455 ѕ esdot; U+02250 ≐ gescc; U+02AA9 ⪩

dsol; U+029F6 ⧶ Esim; U+02A73 ⩳ gesdot; U+02A80 ⪀

Dstrok; U+00110 Đ esim; U+02242 ≂ gesdoto; U+02A82 ⪂

dstrok; U+00111 đ Eta; U+00397 Η gesdotol; U+02A84 ⪄

dtdot; U+022F1 ⋱ eta; U+003B7 η gesl; U+022DB U+0FE00 ⋛︀

dtri; U+025BF ▿ ETH; U+000D0 Ð gesles; U+02A94 ⪔

dtrif; U+025BE ▾ ETH U+000D0 Ð Gfr; U+1D50A 𝔊

duarr; U+021F5 ⇵ eth; U+000F0 ð gfr; U+1D524 𝔤

duhar; U+0296F eth U+000F0 ð Gg; U+022D9 ⋙ ⥯

dwangle; U+029A6 Euml; U+000CB Ë gg; U+0226B ≫ ⦦

DZcy; U+0040F Џ Euml U+000CB Ë ggg; U+022D9 ⋙

dzcy; U+0045F џ euml; U+000EB ë gimel; U+02137 ℷ

dzigrarr; U+027FF ⟿ euml U+000EB ë GJcy; U+00403 Ѓ

Eacute; U+000C9 É euro; U+020AC € gjcy; U+00453 ѓ

Eacute U+000C9 É excl; U+00021 ! gl; U+02277 ≷

eacute; U+000E9 é exist; U+02203 ∃ gla; U+02AA5 ⪥

eacute U+000E9 é Exists; U+02203 ∃ glE; U+02A92 ⪒

easter; U+02A6E expectation; U+02130 ℰ glj; U+02AA4 ⩮ ⪤

Ecaron; U+0011A Ě ExponentialE; U+02147 ⅇ gnap; U+02A8A ⪊

ecaron; U+0011B ě exponentiale; U+02147 ⅇ gnapprox; U+02A8A ⪊

ecir; U+02256 ≖ fallingdotseq; U+02252 ≒ gnE; U+02269 ≩

Ecirc; U+000CA Ê Fcy; U+00424 Ф gne; U+02A88 ⪈

Ecirc U+000CA Ê fcy; U+00444 ф gneq; U+02A88 ⪈

ecirc; U+000EA ê female; U+02640 ♀ gneqq; U+02269 ≩

ecirc U+000EA ê ffilig; U+0FB03 ffi gnsim; U+022E7 ⋧

ecolon; U+02255 ≕ fflig; U+0FB00 ff Gopf; U+1D53E 𝔾

Ecy; ffllig; U+0FB04 ffl gopf; U+1D558 𝕘 U+0042D Э

ecy; Ffr; U+1D509 U+0044D э 𝔉 grave; U+00060 `

eDDot; U+02A77 ffr; U+1D523 ⩷ 𝔣 GreaterEqual; U+02265 ≥

Edot; U+00116 Ė filig; U+0FB01 fi GreaterEqualLess; U+022DB ⋛

eDot; U+02251 ≑ FilledSmallSquare; U+025FC ◼ GreaterFullEqual; U+02267 ≧

edot; U+00117 ė FilledVerySmallSquare; U+025AA ▪ GreaterGreater; U+02AA2 ⪢

ee; U+02147 ⅇ fjlig; U+00066 U+0006A fj GreaterLess; U+02277 ≷

efDot; U+02252 ≒ flat; U+0266D ♭ GreaterSlantEqual; U+02A7E ⩾

Efr; U+1D508 fllig; U+0FB02 fl GreaterTilde; U+02273 ≳ 𝔈

efr; U+1D522 fltns; U+025B1 ▱ Gscr; U+1D4A2 𝒢 𝔢

eg; U+02A9A ⪚ fnof; U+00192 ƒ gscr; U+0210A ℊ

Egrave; Fopf; U+1D53D 𝔽 U+000C8 È gsim; U+02273 ≳

Egrave fopf; U+1D557 𝕗 U+000C8 È gsime; U+02A8E ⪎

egrave; ForAll; U+02200 ∀ U+000E8 è gsiml; U+02A90 ⪐

egrave forall; U+02200 ∀ U+000E8 è GT; U+0003E >

egs; fork; U+022D4 ⋔ U+02A96 ⪖ GT U+0003E >

egsdot; forkv; U+02AD9 U+02A98 ⪘ ⫙ Gt; U+0226B ≫

el; Fouriertrf; U+02131 ℱ gt; U+0003E > U+02A99 ⪙

Element; fpartint; U+02A0D ⨍ gt U+0003E > U+02208 ∈

elinters; frac12; U+000BD ½ gtcc; U+02AA7 U+023E7 ⪧ ⏧

ell; frac12 U+000BD ½ U+02113 ℓ gtcir; U+02A7A ⩺

els; frac13; U+02153 ⅓ U+02A95 ⪕ gtdot; U+022D7 ⋗

elsdot; frac14; U+000BC ¼ U+02A97 ⪗ gtlPar; U+02995 ⦕

Emacr; frac14 U+000BC ¼ U+00112 Ē gtquest; U+02A7C ⩼

emacr; frac15; U+02155 ⅕ U+00113 ē gtrapprox; U+02A86 ⪆

empty; frac16; U+02159 ⅙ U+02205 ∅ gtrarr; U+02978 ⥸

emptyset; frac18; U+0215B ⅛ U+02205 ∅ gtrdot; U+022D7 ⋗

EmptySmallSquare; frac23; U+02154 ⅔ U+025FB ◻ gtreqless; U+022DB ⋛

emptyv; U+02205 ∅ frac25; U+02156 ⅖ gtreqqless; U+02A8C ⪌

EmptyVerySmallSquare; U+025AB ▫ frac34; U+000BE ¾ gtrless; U+02277 ≷

emsp; U+02003 frac34 U+000BE ¾ gtrsim; U+02273 ≳

emsp13; U+02004 frac35; U+02157 ⅗ gvertneqq; U+02269 U+0FE00 ≩︀

emsp14; U+02005 frac38; U+0215C ⅜ gvnE; U+02269 U+0FE00 ≩︀

ENG; U+0014A Ŋ frac45; U+02158 ⅘ Hacek; U+002C7 ˇ

eng; U+0014B ŋ frac56; U+0215A ⅚ hairsp; U+0200A

ensp; frac58; U+0215D ⅝ U+02002 half; U+000BD ½

Eogon; frac78; U+0215E ⅞ U+00118 Ę hamilt; U+0210B ℋ

eogon; frasl; U+02044 ⁄ U+00119 ę HARDcy; U+0042A Ъ

Eopf; frown; U+02322 U+1D53C 𝔼 ⌢ hardcy; U+0044A ъ

eopf; U+1D556 𝕖 Fscr; U+02131 ℱ hArr; U+021D4 ⇔

epar; U+022D5 ⋕ fscr; U+1D4BB 𝒻 harr; U+02194 ↔

eparsl; U+029E3 gacute; U+001F5 ǵ ⧣ harrcir; U+02948 ⥈

eplus; U+02A71 Gamma; U+00393 Γ ⩱ harrw; U+021AD ↭

epsi; U+003B5 ε gamma; U+003B3 γ Hat; U+0005E ^

Epsilon; U+00395 Ε Gammad; U+003DC Ϝ hbar; U+0210F ℏ

1177

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

Hcirc; U+00124 Ĥ iopf; U+1D55A 𝕚 lbrace; U+0007B {

hcirc; U+00125 ĥ Iota; U+00399 Ι lbrack; U+0005B [

hearts; U+02665 ♥ iota; U+003B9 ι lbrke; U+0298B ⦋

heartsuit; U+02665 ♥ iprod; U+02A3C ⨼ lbrksld; U+0298F ⦏

hellip; U+02026 … iquest; U+000BF ¿ lbrkslu; U+0298D ⦍

hercon; U+022B9 ⊹ iquest U+000BF ¿ Lcaron; U+0013D Ľ

Hfr; U+0210C ℌ Iscr; U+02110 ℐ lcaron; U+0013E ľ

hfr; U+1D525 𝔥 iscr; U+1D4BE 𝒾 Lcedil; U+0013B Ļ

HilbertSpace; U+0210B ℋ isin; U+02208 ∈ lcedil; U+0013C ļ

hksearow; U+02925 ⤥ isindot; U+022F5 ⋵ lceil; U+02308 ⌈

hkswarow; U+02926 ⤦ isinE; U+022F9 ⋹ lcub; U+0007B {

hoarr; U+021FF ⇿ isins; U+022F4 ⋴ Lcy; U+0041B Л

homtht; U+0223B ∻ isinsv; U+022F3 ⋳ lcy; U+0043B л

hookleftarrow; U+021A9 ↩ isinv; U+02208 ∈ ldca; U+02936 ⤶

hookrightarrow; U+021AA ↪ it; U+02062 ldquo; U+0201C “

Hopf; U+0210D ℍ Itilde; U+00128 Ĩ ldquor; U+0201E „

hopf; U+1D559 𝕙 itilde; U+00129 ĩ ldrdhar; U+02967 ⥧

horbar; U+02015 ― Iukcy; U+00406 І ldrushar; U+0294B ⥋

HorizontalLine; U+02500 ─ iukcy; U+00456 і ldsh; U+021B2 ↲

Hscr; U+0210B ℋ Iuml; U+000CF Ï lE; U+02266 ≦

hscr; U+1D4BD 𝒽 Iuml U+000CF Ï le; U+02264 ≤

hslash; U+0210F ℏ iuml; U+000EF ï LeftAngleBracket; U+027E8 ⟨

Hstrok; U+00126 Ħ iuml U+000EF ï LeftArrow; U+02190 ←

hstrok; U+00127 ħ Jcirc; U+00134 Ĵ Leftarrow; U+021D0 ⇐

HumpDownHump; U+0224E ≎ jcirc; U+00135 ĵ leftarrow; U+02190 ←

HumpEqual; U+0224F ≏ Jcy; U+00419 Й LeftArrowBar; U+021E4 ⇤

hybull; U+02043 ⁃ jcy; U+00439 й LeftArrowRightArrow; U+021C6 ⇆

hyphen; U+02010 ‐ Jfr; U+1D50D 𝔍 leftarrowtail; U+021A2 ↢

Iacute; U+000CD Í jfr; U+1D527 𝔧 LeftCeiling; U+02308 ⌈

Iacute U+000CD Í jmath; U+00237 ȷ LeftDoubleBracket; U+027E6 ⟦

iacute; U+000ED í Jopf; U+1D541 𝕁 LeftDownTeeVector; U+02961 ⥡

iacute U+000ED í jopf; U+1D55B 𝕛 LeftDownVector; U+021C3 ⇃

ic; U+02063 ⁣ Jscr; U+1D4A5 𝒥 LeftDownVectorBar; U+02959 ⥙

Icirc; U+000CE Î jscr; U+1D4BF 𝒿 LeftFloor; U+0230A ⌊

Icirc U+000CE Î Jsercy; U+00408 Ј leftharpoondown; U+021BD ↽

icirc; U+000EE î jsercy; U+00458 ј leftharpoonup; U+021BC ↼

icirc U+000EE î Jukcy; U+00404 Є leftleftarrows; U+021C7 ⇇

Icy; U+00418 И jukcy; U+00454 є LeftRightArrow; U+02194 ↔

icy; U+00438 и Kappa; U+0039A Κ Leftrightarrow; U+021D4 ⇔

Idot; U+00130 İ kappa; U+003BA κ leftrightarrow; U+02194 ↔

IEcy; U+00415 Е kappav; U+003F0 ϰ leftrightarrows; U+021C6 ⇆

iecy; U+00435 е Kcedil; U+00136 Ķ leftrightharpoons; U+021CB ⇋

iexcl; U+000A1 ¡ kcedil; U+00137 ķ leftrightsquigarrow; U+021AD ↭

iexcl U+000A1 ¡ Kcy; U+0041A К LeftRightVector; U+0294E ⥎

iff; U+021D4 ⇔ kcy; U+0043A к LeftTee; U+022A3 ⊣

Ifr; U+02111 ℑ Kfr; U+1D50E 𝔎 LeftTeeArrow; U+021A4 ↤

ifr; U+1D526 𝔦 kfr; U+1D528 𝔨 LeftTeeVector; U+0295A ⥚

Igrave; U+000CC Ì kgreen; U+00138 ĸ leftthreetimes; U+022CB ⋋

Igrave U+000CC Ì KHcy; U+00425 Х LeftTriangle; U+022B2 ⊲

igrave; U+000EC ì khcy; U+00445 х LeftTriangleBar; U+029CF ⧏

igrave U+000EC ì KJcy; U+0040C Ќ LeftTriangleEqual; U+022B4 ⊴

ii; U+02148 ⅈ kjcy; U+0045C ќ LeftUpDownVector; U+02951 ⥑

iiiint; U+02A0C ⨌ Kopf; U+1D542 𝕂 LeftUpTeeVector; U+02960 ⥠

iiint; U+0222D ∭ kopf; U+1D55C 𝕜 LeftUpVector; U+021BF ↿

iinfin; U+029DC ⧜ Kscr; U+1D4A6 𝒦 LeftUpVectorBar; U+02958 ⥘

iiota; U+02129 ℩ kscr; U+1D4C0 𝓀 LeftVector; U+021BC ↼

IJlig; U+00132 Ĳ lAarr; U+021DA ⇚ LeftVectorBar; U+02952 ⥒

ijlig; U+00133 ĳ Lacute; U+00139 Ĺ lEg; U+02A8B ⪋

Im; U+02111 ℑ lacute; U+0013A ĺ leg; U+022DA ⋚

Imacr; U+0012A Ī laemptyv; U+029B4 ⦴ leq; U+02264 ≤

imacr; U+0012B ī lagran; U+02112 ℒ leqq; U+02266 ≦

image; U+02111 ℑ Lambda; U+0039B Λ leqslant; U+02A7D ⩽

ImaginaryI; U+02148 ⅈ lambda; U+003BB λ les; U+02A7D ⩽

imagline; U+02110 ℐ Lang; U+027EA ⟪ lescc; U+02AA8 ⪨

imagpart; U+02111 ℑ lang; U+027E8 ⟨ lesdot; U+02A7F ⩿

imath; U+00131 ı langd; U+02991 ⦑ lesdoto; U+02A81 ⪁

imof; U+022B7 ⊷ langle; U+027E8 ⟨ lesdotor; U+02A83 ⪃

imped; U+001B5 Ƶ lap; U+02A85 ⪅ lesg; U+022DA U+0FE00 ⋚︀

Implies; U+021D2 ⇒ Laplacetrf; U+02112 ℒ lesges; U+02A93 ⪓

in; U+02208 ∈ laquo; U+000AB « lessapprox; U+02A85 ⪅

incare; U+02105 ℅ laquo U+000AB « lessdot; U+022D6 ⋖

infin; U+0221E ∞ Larr; U+0219E ↞ lesseqgtr; U+022DA ⋚

infintie; U+029DD ⧝ lArr; U+021D0 ⇐ lesseqqgtr; U+02A8B ⪋

inodot; U+00131 ı larr; U+02190 ← LessEqualGreater; U+022DA ⋚

Int; U+0222C ∬ larrb; U+021E4 ⇤ LessFullEqual; U+02266 ≦

int; U+0222B ∫ larrbfs; U+0291F ⤟ LessGreater; U+02276 ≶

intcal; U+022BA ⊺ larrfs; U+0291D ⤝ lessgtr; U+02276 ≶

integers; U+02124 ℤ larrhk; U+021A9 ↩ LessLess; U+02AA1 ⪡

Integral; U+0222B ∫ larrlp; U+021AB ↫ lesssim; U+02272 ≲

intercal; U+022BA ⊺ larrpl; U+02939 ⤹ LessSlantEqual; U+02A7D ⩽

Intersection; U+022C2 ⋂ larrsim; U+02973 ⥳ LessTilde; U+02272 ≲

intlarhk; U+02A17 ⨗ larrtl; U+021A2 ↢ lfisht; U+0297C ⥼

intprod; U+02A3C ⨼ lat; U+02AAB ⪫ lfloor; U+0230A ⌊

InvisibleComma; U+02063 ⁣ lAtail; U+0291B ⤛ Lfr; U+1D50F 𝔏

InvisibleTimes; U+02062 latail; U+02919 ⤙ lfr; U+1D529 𝔩

IOcy; U+00401 Ё

late; U+02AAD ⪭ lg; U+02276 ≶

iocy; U+00451 ё

lates; U+02AAD U+0FE00 ⪭︀ lgE; U+02A91 ⪑

Iogon; U+0012E Į

lBarr; U+0290E ⤎ lHar; U+02962 ⥢

iogon; U+0012F į lbarr; U+0290C ⤌ lhard; U+021BD ↽

Iopf; U+1D540 𝕀

lbbrk; U+02772 ❲ lharu; U+021BC ↼

1178

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

lharul; U+0296A ⥪ macr; U+000AF ¯ NestedLessLess; U+0226A ≪

lhblk; U+02584 ▄ macr U+000AF ¯ NewLine; U+0000A ␊

LJcy; U+00409 Љ male; U+02642 ♂ nexist; U+02204 ∄

ljcy; U+00459 љ malt; U+02720 ✠ nexists; U+02204 ∄

Ll; U+022D8 ⋘ maltese; U+02720 ✠ Nfr; U+1D511 𝔑

ll; U+0226A ≪ Map; U+02905 ⤅ nfr; U+1D52B 𝔫

llarr; U+021C7 ⇇ map; U+021A6 ↦ ngE; U+02267 U+00338 ≧̸

llcorner; U+0231E ⌞ mapsto; U+021A6 ↦ nge; U+02271 ≱

Lleftarrow; U+021DA ⇚ mapstodown; U+021A7 ↧ ngeq; U+02271 ≱

llhard; U+0296B ⥫ mapstoleft; U+021A4 ↤ ngeqq; U+02267 U+00338 ≧̸

lltri; U+025FA ◺ mapstoup; U+021A5 ↥ ngeqslant; U+02A7E U+00338 ⩾̸

Lmidot; U+0013F Ŀ marker; U+025AE ▮ nges; U+02A7E U+00338 ⩾̸

lmidot; U+00140 ŀ mcomma; U+02A29 ⨩ nGg; U+022D9 U+00338 ⋙̸

lmoust; U+023B0 ⎰ Mcy; U+0041C М ngsim; U+02275 ≵

lmoustache; U+023B0 ⎰ mcy; U+0043C м nGt; U+0226B U+020D2 ≫⃒

lnap; U+02A89 ⪉ mdash; U+02014 — ngt; U+0226F ≯

lnapprox; U+02A89 ⪉ mDDot; U+0223A ∺ ngtr; U+0226F ≯

lnE; U+02268 ≨ measuredangle; U+02221 ∡ nGtv; U+0226B U+00338 ≫̸

lne; U+02A87 ⪇ MediumSpace; U+0205F nhArr; U+021CE ⇎

lneq; U+02A87 ⪇ Mellintrf; U+02133 ℳ nharr; U+021AE ↮

lneqq; U+02268 ≨ Mfr; U+1D510 𝔐 nhpar; U+02AF2 ⫲

lnsim; U+022E6 ⋦ mfr; U+1D52A 𝔪 ni; U+0220B ∋

loang; U+027EC ⟬ mho; U+02127 ℧ nis; U+022FC ⋼

loarr; U+021FD ⇽ micro; U+000B5 µ nisd; U+022FA ⋺

lobrk; U+027E6 ⟦ micro U+000B5 µ niv; U+0220B ∋

LongLeftArrow; U+027F5 ⟵ mid; U+02223 ∣ NJcy; U+0040A Њ

Longleftarrow; U+027F8 ⟸ midast; U+0002A * njcy; U+0045A њ

longleftarrow; U+027F5 ⟵ midcir; U+02AF0 ⫰ nlArr; U+021CD ⇍

LongLeftRightArrow; U+027F7 ⟷ middot; U+000B7 · nlarr; U+0219A ↚

Longleftrightarrow; U+027FA ⟺ middot U+000B7 · nldr; U+02025 ‥

longleftrightarrow; U+027F7 ⟷ minus; U+02212 − nlE; U+02266 U+00338 ≦̸

longmapsto; U+027FC ⟼ minusb; U+0229F ⊟ nle; U+02270 ≰

LongRightArrow; U+027F6 ⟶ minusd; U+02238 ∸ nLeftarrow; U+021CD ⇍

Longrightarrow; U+027F9 ⟹ minusdu; U+02A2A ⨪ nleftarrow; U+0219A ↚

longrightarrow; U+027F6 ⟶ MinusPlus; U+02213 ∓ nLeftrightarrow; U+021CE ⇎

looparrowleft; U+021AB ↫ mlcp; U+02ADB ⫛ nleftrightarrow; U+021AE ↮

looparrowright; U+021AC ↬ mldr; U+02026 … nleq; U+02270 ≰

lopar; U+02985 ⦅ mnplus; U+02213 ∓ nleqq; U+02266 U+00338 ≦̸

Lopf; U+1D543 𝕃 models; U+022A7 ⊧ nleqslant; U+02A7D U+00338 ⩽̸

lopf; U+1D55D 𝕝 Mopf; U+1D544 𝕄 nles; U+02A7D U+00338 ⩽̸

loplus; U+02A2D ⨭ mopf; U+1D55E 𝕞 nless; U+0226E ≮

lotimes; U+02A34 ⨴ mp; U+02213 ∓ nLl; U+022D8 U+00338 ⋘̸

lowast; U+02217 ∗ Mscr; U+02133 ℳ nlsim; U+02274 ≴

lowbar; U+0005F _ mscr; U+1D4C2 𝓂 nLt; U+0226A U+020D2 ≪⃒

LowerLeftArrow; U+02199 ↙ mstpos; U+0223E ∾ nlt; U+0226E ≮

LowerRightArrow; U+02198 ↘ Mu; U+0039C Μ nltri; U+022EA ⋪

loz; U+025CA ◊ mu; U+003BC μ nltrie; U+022EC ⋬

lozenge; U+025CA ◊ multimap; U+022B8 ⊸ nLtv; U+0226A U+00338 ≪̸

lozf; U+029EB ⧫ mumap; U+022B8 ⊸ nmid; U+02224 ∤

lpar; U+00028 ( nabla; U+02207 ∇ NoBreak; U+02060 ⁠

lparlt; U+02993 ⦓ Nacute; U+00143 Ń NonBreakingSpace; U+000A0

lrarr; U+021C6 ⇆ nacute; U+00144 ń Nopf; U+02115 ℕ

lrcorner; U+0231F ⌟ nang; U+02220 U+020D2 ∠⃒ nopf; U+1D55F 𝕟

lrhar; U+021CB ⇋ nap; U+02249 ≉ Not; U+02AEC ⫬

lrhard; U+0296D ⥭ napE; U+02A70 U+00338 ⩰̸ not; U+000AC ¬

lrm; U+0200E napid; U+0224B U+00338 ≋̸ not U+000AC ¬

lrtri; U+022BF ⊿ napos; U+00149 ŉ NotCongruent; U+02262 ≢

lsaquo; U+02039 ‹ napprox; U+02249 ≉ NotCupCap; U+0226D ≭

Lscr; U+02112 ℒ natur; U+0266E ♮ NotDoubleVerticalBar; U+02226 ∦

lscr; U+1D4C1 𝓁 natural; U+0266E ♮ NotElement; U+02209 ∉

Lsh; U+021B0 ↰ naturals; U+02115 ℕ NotEqual; U+02260 ≠

lsh; U+021B0 ↰ nbsp; U+000A0 NotEqualTilde; U+02242 U+00338 ≂̸

lsim; U+02272 ≲ nbsp U+000A0 NotExists; U+02204 ∄

lsime; U+02A8D ⪍ nbump; U+0224E U+00338 ≎̸ NotGreater; U+0226F ≯

lsimg; U+02A8F ⪏ nbumpe; U+0224F U+00338 ≏̸ NotGreaterEqual; U+02271 ≱

lsqb; U+0005B [ ncap; U+02A43 ⩃ NotGreaterFullEqual; U+02267 U+00338 ≧̸

lsquo; U+02018 ‘ Ncaron; U+00147 Ň NotGreaterGreater; U+0226B U+00338 ≫̸

lsquor; U+0201A ‚ ncaron; U+00148 ň NotGreaterLess; U+02279 ≹

Lstrok; U+00141 Ł Ncedil; U+00145 Ņ NotGreaterSlantEqual; U+02A7E U+00338 ⩾̸

lstrok; U+00142 ł ncedil; U+00146 ņ NotGreaterTilde; U+02275 ≵

LT; U+0003C < ncong; U+02247 ≇ NotHumpDownHump; U+0224E U+00338 ≎̸

LT U+0003C < ncongdot; U+02A6D U+00338 ⩭̸ NotHumpEqual; U+0224F U+00338 ≏̸

Lt; U+0226A ≪ ncup; U+02A42 ⩂ notin; U+02209 ∉

lt; U+0003C < Ncy; U+0041D Н notindot; U+022F5 U+00338 ⋵̸

lt U+0003C < ncy; U+0043D н notinE; U+022F9 U+00338 ⋹̸

ltcc; U+02AA6 ⪦ ndash; U+02013 – notinva; U+02209 ∉

ltcir; U+02A79 ⩹ ne; U+02260 ≠ notinvb; U+022F7 ⋷

ltdot; U+022D6 ⋖ nearhk; U+02924 notinvc; U+022F6 ⋶ ⤤

lthree; U+022CB ⋋ NotLeftTriangle; U+022EA ⋪ neArr; U+021D7 ⇗

ltimes; U+022C9 ⋉ nearr; U+02197 ↗ NotLeftTriangleBar; U+029CF U+00338 ⧏̸

ltlarr; U+02976 ⥶ nearrow; U+02197 ↗ NotLeftTriangleEqual; U+022EC ⋬

ltquest; U+02A7B ⩻ nedot; U+02250 U+00338 ≐̸ NotLess; U+0226E ≮

ltri; U+025C3 ◃ NegativeMediumSpace; U+0200B NotLessEqual; U+02270 ≰

ltrie; U+022B4 ⊴ NegativeThickSpace; U+0200B NotLessGreater; U+02278 ≸

ltrif; U+025C2 ◂ NegativeThinSpace; U+0200B NotLessLess; U+0226A U+00338 ≪̸

ltrPar; U+02996 ⦖ NegativeVeryThinSpace; U+0200B NotLessSlantEqual; U+02A7D U+00338 ⩽̸

lurdshar; U+0294A ⥊ nequiv; U+02262 ≢ NotLessTilde; U+02274 ≴

luruhar; U+02966 ⥦ nesear; U+02928 NotNestedGreaterGreater; U+02AA2 U+00338 ⪢̸ ⤨

lvertneqq; U+02268 U+0FE00 ≨︀ nesim; U+02242 U+00338 ≂̸ NotNestedLessLess; U+02AA1 U+00338 ⪡̸

lvnE; U+02268 U+0FE00 ≨︀ NestedGreaterGreater; U+0226B ≫ notni; U+0220C ∌

1179

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

notniva; U+0220C ∌ nVdash; U+022AE ⊮ oslash; U+000F8 ø

notnivb; U+022FE ⋾ nvDash; U+022AD ⊭ oslash U+000F8 ø

notnivc; U+022FD ⋽ nvdash; U+022AC ⊬ osol; U+02298 ⊘

NotPrecedes; U+02280 ⊀ nvge; U+02265 U+020D2 ≥⃒ Otilde; U+000D5 Õ

NotPrecedesEqual; U+02AAF U+00338 ⪯̸ nvgt; U+0003E U+020D2 >⃒ Otilde U+000D5 Õ

NotPrecedesSlantEqual; U+022E0 ⋠ nvHarr; U+02904 ⤄ otilde; U+000F5 õ

NotReverseElement; U+0220C ∌ nvinfin; U+029DE ⧞ otilde U+000F5 õ

NotRightTriangle; U+022EB ⋫ nvlArr; U+02902 ⤂ Otimes; U+02A37 ⨷

NotRightTriangleBar; U+029D0 U+00338 ⧐̸ nvle; U+02264 U+020D2 ≤ otimes; U+02297 ⊗ ⃒

NotRightTriangleEqual; U+022ED ⋭ nvlt; U+0003C U+020D2 < otimesas; U+02A36 ⃒ ⨶

NotSquareSubset; U+0228F U+00338 ⊏̸ nvltrie; U+022B4 U+020D2 ⊴ Ouml; U+000D6 Ö ⃒

NotSquareSubsetEqual; U+022E2 ⋢ nvrArr; U+02903 Ouml U+000D6 Ö ⤃

NotSquareSuperset; U+02290 U+00338 ⊐̸ ouml; U+000F6 ö nvrtrie; U+022B5 U+020D2 ⊵ ⃒

NotSquareSupersetEqual; U+022E3 ⋣ ouml U+000F6 ö nvsim; U+0223C U+020D2 ∼ ⃒

NotSubset; U+02282 U+020D2 ⊂⃒ ovbar; U+0233D nwarhk; U+02923 ⌽ ⤣

NotSubsetEqual; U+02288 ⊈ OverBar; U+0203E ‾ nwArr; U+021D6 ⇖

NotSucceeds; U+02281 ⊁ OverBrace; U+023DE nwarr; U+02196 ↖ ⏞

NotSucceedsEqual; U+02AB0 U+00338 ⪰̸ nwarrow; U+02196 ↖ OverBracket; U+023B4 ⎴

NotSucceedsSlantEqual; U+022E1 ⋡ nwnear; U+02927 OverParenthesis; U+023DC ⤧ ⏜

NotSucceedsTilde; U+0227F U+00338 ≿̸ Oacute; U+000D3 Ó par; U+02225 ∥

NotSuperset; U+02283 U+020D2 ⊃⃒ Oacute U+000D3 Ó para; U+000B6 ¶

NotSupersetEqual; U+02289 ⊉ oacute; U+000F3 ó para U+000B6 ¶

NotTilde; U+02241 ≁ oacute U+000F3 ó parallel; U+02225 ∥

NotTildeEqual; U+02244 ≄ oast; U+0229B ⊛ parsim; U+02AF3 ⫳

NotTildeFullEqual; U+02247 ≇ ocir; U+0229A ⊚ parsl; U+02AFD ⫽

NotTildeTilde; U+02249 ≉ Ocirc; U+000D4 Ô part; U+02202 ∂

NotVerticalBar; U+02224 ∤ Ocirc U+000D4 Ô PartialD; U+02202 ∂

npar; U+02226 ∦ Pcy; ocirc; U+000F4 ô U+0041F П

nparallel; U+02226 ∦ pcy; ocirc U+000F4 ô U+0043F п

nparsl; U+02AFD U+020E5 ⫽⃥ Ocy; U+0041E О percnt; U+00025 %

npart; U+02202 U+00338 ∂̸ ocy; U+0043E о period; U+0002E .

npolint; U+02A14 ⨔ odash; U+0229D ⊝ permil; U+02030 ‰

npr; U+02280 ⊀ Odblac; U+00150 Ő perp; U+022A5 ⊥

nprcue; U+022E0 ⋠ pertenk; odblac; U+00151 ő U+02031 ‱

npre; U+02AAF U+00338 ⪯̸ Pfr; odiv; U+02A38 U+1D513 ⨸ 𝔓

nprec; U+02280 ⊀ pfr; odot; U+02299 ⊙ U+1D52D 𝔭

npreceq; U+02AAF U+00338 ⪯̸ Phi; odsold; U+029BC ⦼ U+003A6 Φ

nrArr; U+021CF ⇏ phi; OElig; U+00152 Œ U+003C6 φ

nrarr; U+0219B ↛ phiv; oelig; U+00153 œ U+003D5 ϕ

nrarrc; U+02933 U+00338 ⤳̸ ofcir; U+029BF phmmat; U+02133 ℳ ⦿

nrarrw; U+0219D U+00338 ↝̸ phone; Ofr; U+1D512 U+0260E ☎ 𝔒

nRightarrow; U+021CF ⇏ Pi; U+003A0 Π ofr; U+1D52C 𝔬

nrightarrow; U+0219B ↛ pi; U+003C0 π ogon; U+002DB ˛

nrtri; U+022EB ⋫ pitchfork; U+022D4 ⋔ Ograve; U+000D2 Ò

nrtrie; U+022ED ⋭ piv; U+003D6 ϖ Ograve U+000D2 Ò

nsc; U+02281 ⊁ planck; U+0210F ℏ ograve; U+000F2 ò

nsccue; U+022E1 ⋡ planckh; U+0210E ℎ ograve U+000F2 ò

nsce; U+02AB0 U+00338 ⪰̸ plankv; U+0210F ℏ ogt; U+029C1 ⧁

Nscr; U+1D4A9 𝒩 plus; U+0002B + ohbar; U+029B5 ⦵

nscr; U+1D4C3 𝓃 plusacir; U+02A23 ohm; U+003A9 Ω ⨣

nshortmid; U+02224 ∤ plusb; U+0229E ⊞ oint; U+0222E ∮

nshortparallel; U+02226 ∦ pluscir; U+02A22 olarr; U+021BA ↺ ⨢

nsim; U+02241 ≁ plusdo; U+02214 ∔ olcir; U+029BE ⦾

nsime; U+02244 ≄ plusdu; U+02A25 olcross; U+029BB ⨥ ⦻

nsimeq; U+02244 ≄ pluse; oline; U+0203E ‾ U+02A72 ⩲

nsmid; U+02224 ∤ PlusMinus; olt; U+029C0 U+000B1 ± ⧀

nspar; U+02226 ∦ plusmn; U+000B1 ± Omacr; U+0014C Ō

nsqsube; U+022E2 ⋢ plusmn U+000B1 ± omacr; U+0014D ō

nsqsupe; U+022E3 ⋣ plussim; U+02A26 Omega; U+003A9 Ω ⨦

nsub; U+02284 ⊄ plustwo; omega; U+003C9 ω U+02A27 ⨧

nsubE; U+02AC5 U+00338 ⫅̸ pm; Omicron; U+0039F Ο U+000B1 ±

nsube; U+02288 ⊈ Poincareplane; omicron; U+003BF ο U+0210C ℌ

nsubset; U+02282 U+020D2 ⊂⃒ pointint; omid; U+029B6 U+02A15 ⨕ ⦶

nsubseteq; U+02288 ⊈ Popf; U+02119 ℙ ominus; U+02296 ⊖

nsubseteqq; U+02AC5 U+00338 ⫅̸ popf; U+1D561 𝕡 Oopf; U+1D546 𝕆

nsucc; U+02281 ⊁ pound; oopf; U+1D560 𝕠 U+000A3 £

nsucceq; U+02AB0 U+00338 ⪰̸ pound opar; U+029B7 U+000A3 £ ⦷

nsup; U+02285 ⊅ Pr; U+02ABB OpenCurlyDoubleQuote; U+0201C “ ⪻

nsupE; U+02AC6 U+00338 ⫆̸ pr; U+0227A ≺ OpenCurlyQuote; U+02018 ‘

nsupe; U+02289 ⊉ prap; U+02AB7 ⪷ operp; U+029B9 ⦹

nsupset; U+02283 U+020D2 ⊃⃒ prcue; U+0227C ≼ oplus; U+02295 ⊕

nsupseteq; U+02289 ⊉ prE; U+02AB3 ⪳ Or; U+02A54 ⩔

nsupseteqq; U+02AC6 U+00338 ⫆̸ pre; U+02AAF ⪯ or; U+02228 ∨

ntgl; U+02279 ≹ prec; U+0227A ≺ orarr; U+021BB ↻

Ntilde; U+000D1 Ñ precapprox; U+02AB7 ⪷ ord; U+02A5D ⩝

Ntilde U+000D1 Ñ preccurlyeq; U+0227C ≼ order; U+02134 ℴ

ntilde; U+000F1 ñ Precedes; U+0227A ≺ orderof; U+02134 ℴ

ntilde U+000F1 ñ PrecedesEqual; U+02AAF ⪯ ordf; U+000AA ª

ntlg; U+02278 ≸ PrecedesSlantEqual; U+0227C ≼ ordf U+000AA ª

ntriangleleft; U+022EA ⋪ PrecedesTilde; U+0227E ≾

ordm; U+000BA º

ntrianglelefteq; U+022EC ⋬ preceq; U+02AAF ⪯

ordm U+000BA º

ntriangleright; U+022EB ⋫ precnapprox; U+02AB9 ⪹

origof; U+022B6 ⊶

ntrianglerighteq; U+022ED ⋭ precneqq; U+02AB5 ⪵

oror; U+02A56 ⩖

Nu; U+0039D Ν precnsim; U+022E8 ⋨

orslope; U+02A57 ⩗

nu; U+003BD ν precsim; U+0227E ≾ orv; U+02A5B ⩛

num; U+00023 # Prime; U+02033 ″ Ⓢ oS; U+024C8

numero; U+02116 № prime; U+02032 ′

Oscr; U+1D4AA 𝒪

numsp; U+02007 primes; U+02119 ℙ

oscr; U+02134 ℴ

nvap; U+0224D U+020D2 ≍⃒ prnap; U+02AB9 ⪹

Oslash; U+000D8 Ø

nVDash; U+022AF ⊯ prnE; U+02AB5 ⪵

Oslash U+000D8 Ø

1180

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

prnsim; U+022E8 ⋨ realpart; U+0211C ℜ ruluhar; U+02968 ⥨

prod; U+0220F ∏ reals; U+0211D ℝ rx; U+0211E ℞

Product; U+0220F ∏ rect; U+025AD ▭ Sacute; U+0015A Ś

profalar; U+0232E ⌮ REG; U+000AE ® sacute; U+0015B ś

profline; U+02312 ⌒ REG U+000AE ® sbquo; U+0201A ‚

profsurf; U+02313 ⌓ reg; U+000AE ® Sc; U+02ABC ⪼

prop; U+0221D ∝ reg U+000AE ® sc; U+0227B ≻

Proportion; U+02237 ∷ ReverseElement; U+0220B ∋ scap; U+02AB8 ⪸

Proportional; U+0221D ∝ ReverseEquilibrium; U+021CB ⇋ Scaron; U+00160 Š

propto; U+0221D ∝ ReverseUpEquilibrium; U+0296F ⥯ scaron; U+00161 š

prsim; U+0227E ≾ rfisht; U+0297D ⥽ sccue; U+0227D ≽

prurel; U+022B0 ⊰ rfloor; U+0230B ⌋ scE; U+02AB4 ⪴

Pscr; U+1D4AB 𝒫 Rfr; U+0211C ℜ sce; U+02AB0 ⪰

pscr; U+1D4C5 𝓅 rfr; U+1D52F 𝔯 Scedil; U+0015E Ş

Psi; U+003A8 Ψ rHar; U+02964 ⥤ scedil; U+0015F ş

psi; U+003C8 ψ rhard; U+021C1 ⇁ Scirc; U+0015C Ŝ

puncsp; U+02008 rharu; U+021C0 ⇀ scirc; U+0015D ŝ

Qfr; U+1D514 𝔔 rharul; U+0296C ⥬ scnap; U+02ABA ⪺

qfr; U+1D52E 𝔮 Rho; U+003A1 Ρ scnE; U+02AB6 ⪶

qint; U+02A0C ⨌ rho; U+003C1 ρ scnsim; U+022E9 ⋩

Qopf; U+0211A ℚ rhov; U+003F1 ϱ scpolint; U+02A13 ⨓

qopf; U+1D562 𝕢 RightAngleBracket; U+027E9 ⟩ scsim; U+0227F ≿

qprime; U+02057 ⁗ RightArrow; U+02192 → Scy; U+00421 С

Qscr; U+1D4AC 𝒬 Rightarrow; U+021D2 ⇒ scy; U+00441 с

qscr; U+1D4C6 𝓆 rightarrow; U+02192 → sdot; U+022C5 ⋅

quaternions; U+0210D ℍ RightArrowBar; U+021E5 ⇥ sdotb; U+022A1 ⊡

quatint; U+02A16 ⨖ RightArrowLeftArrow; U+021C4 ⇄ sdote; U+02A66 ⩦

quest; U+0003F ? rightarrowtail; U+021A3 ↣ searhk; U+02925 ⤥

questeq; U+0225F ≟ RightCeiling; U+02309 ⌉ seArr; U+021D8 ⇘

QUOT; U+00022 " RightDoubleBracket; U+027E7 ⟧ searr; U+02198 ↘

QUOT U+00022 " RightDownTeeVector; U+0295D ⥝ searrow; U+02198 ↘

quot; U+00022 " RightDownVector; U+021C2 ⇂ sect; U+000A7 §

quot U+00022 " RightDownVectorBar; U+02955 ⥕ sect U+000A7 §

rAarr; U+021DB ⇛ RightFloor; U+0230B ⌋ semi; U+0003B ;

race; U+0223D U+00331 ∽̱ rightharpoondown; U+021C1 ⇁ seswar; U+02929 ⤩

Racute; U+00154 Ŕ rightharpoonup; U+021C0 ⇀ setminus; U+02216 ∖

racute; U+00155 ŕ rightleftarrows; U+021C4 ⇄ setmn; U+02216 ∖

radic; U+0221A √ rightleftharpoons; U+021CC ⇌ sext; U+02736 ✶

raemptyv; U+029B3 ⦳ rightrightarrows; U+021C9 ⇉ Sfr; U+1D516 𝔖

Rang; U+027EB ⟫ rightsquigarrow; U+0219D ↝ sfr; U+1D530 𝔰

rang; U+027E9 ⟩ RightTee; U+022A2 ⊢ sfrown; U+02322 ⌢

rangd; U+02992 ⦒ RightTeeArrow; U+021A6 ↦ sharp; U+0266F ♯

range; U+029A5 ⦥ RightTeeVector; U+0295B ⥛ SHCHcy; U+00429 Щ

rangle; U+027E9 ⟩ rightthreetimes; U+022CC ⋌ shchcy; U+00449 щ

raquo; U+000BB » RightTriangle; U+022B3 ⊳ SHcy; U+00428 Ш

raquo U+000BB » RightTriangleBar; U+029D0 ⧐ shcy; U+00448 ш

Rarr; U+021A0 ↠ RightTriangleEqual; U+022B5 ⊵ ShortDownArrow; U+02193 ↓

rArr; U+021D2 ⇒ RightUpDownVector; U+0294F ⥏ ShortLeftArrow; U+02190 ←

rarr; U+02192 → RightUpTeeVector; U+0295C ⥜ shortmid; U+02223 ∣

rarrap; U+02975 ⥵ RightUpVector; U+021BE ↾ shortparallel; U+02225 ∥

rarrb; U+021E5 ⇥ RightUpVectorBar; U+02954 ⥔ ShortRightArrow; U+02192 →

rarrbfs; U+02920 ⤠ RightVector; U+021C0 ⇀ ShortUpArrow; U+02191 ↑

rarrc; U+02933 ⤳ RightVectorBar; U+02953 ⥓ shy; U+000AD

rarrfs; U+0291E ⤞ ring; U+002DA ˚ shy U+000AD

rarrhk; U+021AA ↪ risingdotseq; U+02253 ≓ Sigma; U+003A3 Σ

rarrlp; U+021AC ↬ rlarr; U+021C4 ⇄ sigma; U+003C3 σ

rarrpl; U+02945 ⥅ rlhar; U+021CC ⇌ sigmaf; U+003C2 ς

rarrsim; U+02974 ⥴ rlm; U+0200F sigmav; U+003C2 ς

Rarrtl; U+02916 rmoust; U+023B1 ⤖ ⎱ sim; U+0223C ∼

rarrtl; U+021A3 ↣ rmoustache; U+023B1 ⎱ simdot; U+02A6A ⩪

rarrw; U+0219D ↝ rnmid; U+02AEE sime; U+02243 ≃ ⫮

rAtail; U+0291C ⤜ roang; U+027ED simeq; U+02243 ≃ ⟭

ratail; U+0291A ⤚ U+021FE roarr; simg; U+02A9E ⪞ ⇾

ratio; U+02236 ∶ U+027E7 robrk; simgE; U+02AA0 ⪠ ⟧

rationals; U+0211A ℚ U+02986 ropar; siml; U+02A9D ⪝ ⦆

RBarr; U+02910 ⤐ U+0211D Ropf; simlE; U+02A9F ⪟ ℝ

rBarr; U+0290F U+1D563 ropf; simne; U+02246 ≆ 𝕣 ⤏

rbarr; U+0290D U+02A2E roplus; simplus; U+02A24 ⨤ ⤍ ⨮

rbbrk; U+02773 ❳ U+02A35 rotimes; simrarr; U+02972 ⥲ ⨵

rbrace; U+0007D } U+02970 RoundImplies; slarr; U+02190 ← ⥰

rbrack; U+0005D ] U+00029 rpar; SmallCircle; U+02218 ∘ )

rbrke; U+0298C ⦌ U+02994 rpargt; smallsetminus; U+02216 ∖ ⦔

rbrksld; U+0298E ⦎ U+02A12 rppolint; smashp; U+02A33 ⨒ ⨳

rbrkslu; U+02990 ⦐ U+021C9 rrarr; smeparsl; U+029E4 ⇉ ⧤

Rcaron; U+00158 Ř U+021DB Rrightarrow; smid; U+02223 ∣ ⇛

rcaron; U+00159 ř U+0203A rsaquo; smile; U+02323 › ⌣

Rcedil; U+00156 Ŗ U+0211B Rscr; smt; U+02AAA ℛ ⪪

rcedil; U+00157 ŗ rscr; U+1D4C7 smte; U+02AAC 𝓇 ⪬

rceil; U+02309 ⌉ Rsh; U+021B1 ↱ smtes; U+02AAC U+0FE00 ⪬︀

rcub; U+0007D } rsh; U+021B1 ↱ SOFTcy; U+0042C Ь

Rcy; U+00420 Р rsqb; U+0005D ] softcy; U+0044C ь

rcy; U+00440 р rsquo; U+02019 ’ sol; U+0002F /

rdca; U+02937 ⤷ rsquor; U+02019 ’ solb; U+029C4 ⧄

rdldhar; U+02969 rthree; U+022CC ⋌ solbar; U+0233F ⌿ ⥩

rdquo; U+0201D ” rtimes; U+022CA ⋊ Sopf; U+1D54A 𝕊

rdquor; U+0201D ” rtri; U+025B9 ▹ sopf; U+1D564 𝕤

rdsh; U+021B3 ↳ rtrie; U+022B5 ⊵ spades; U+02660 ♠

Re; U+0211C ℜ rtrif; U+025B8 ▸ spadesuit; U+02660 ♠

real; U+0211C ℜ rtriltri; U+029CE ⧎ spar; U+02225 ∥

realine; U+0211B ℛ RuleDelayed; U+029F4 sqcap; U+02293 ⊓ ⧴

1181

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

sqcaps; U+02293 U+0FE00 ⊓︀ supmult; U+02AC2 ⫂ Tscr; U+1D4AF 𝒯

sqcup; U+02294 ⊔ supnE; U+02ACC ⫌ tscr; U+1D4C9 𝓉

sqcups; U+02294 U+0FE00 ⊔︀ supne; U+0228B ⊋ TScy; U+00426 Ц

Sqrt; U+0221A √ supplus; U+02AC0 ⫀ tscy; U+00446 ц

sqsub; U+0228F ⊏ Supset; U+022D1 ⋑ TSHcy; U+0040B Ћ

sqsube; U+02291 ⊑ supset; U+02283 ⊃ tshcy; U+0045B ћ

sqsubset; U+0228F ⊏ supseteq; U+02287 ⊇ Tstrok; U+00166 Ŧ

sqsubseteq; U+02291 ⊑ supseteqq; U+02AC6 ⫆ tstrok; U+00167 ŧ

sqsup; U+02290 ⊐ supsetneq; U+0228B ⊋ twixt; U+0226C ≬

sqsupe; U+02292 ⊒ supsetneqq; U+02ACC ⫌ twoheadleftarrow; U+0219E ↞

sqsupset; U+02290 ⊐ supsim; U+02AC8 ⫈ twoheadrightarrow; U+021A0 ↠

sqsupseteq; U+02292 ⊒ supsub; U+02AD4 Uacute; U+000DA Ú ⫔

squ; U+025A1 □ supsup; U+02AD6 Uacute U+000DA Ú ⫖

Square; U+025A1 □ swarhk; U+02926 uacute; U+000FA ú ⤦

square; U+025A1 □ uacute U+000FA ú swArr; U+021D9 ⇙

SquareIntersection; U+02293 ⊓ swarr; U+02199 ↙ Uarr; U+0219F ↟

SquareSubset; U+0228F ⊏ swarrow; U+02199 ↙ uArr; U+021D1 ⇑

SquareSubsetEqual; U+02291 ⊑ swnwar; U+0292A uarr; U+02191 ↑ ⤪

SquareSuperset; U+02290 ⊐ Uarrocir; U+02949 szlig; U+000DF ß ⥉

SquareSupersetEqual; U+02292 ⊒ Ubrcy; U+0040E Ў szlig U+000DF ß

SquareUnion; U+02294 ⊔ Tab; U+00009 ubrcy; U+0045E ў ␉

squarf; U+025AA ▪ Ubreve; U+0016C Ŭ target; U+02316 ⌖

squf; U+025AA ▪ ubreve; U+0016D ŭ Tau; U+003A4 Τ

srarr; U+02192 → Ucirc; U+000DB Û tau; U+003C4 τ

Sscr; U+1D4AE 𝒮 Ucirc U+000DB Û tbrk; U+023B4 ⎴

sscr; U+1D4C8 𝓈 ucirc; U+000FB û Tcaron; U+00164 Ť

ssetmn; U+02216 ∖ ucirc U+000FB û tcaron; U+00165 ť

ssmile; U+02323 ⌣ Ucy; U+00423 У Tcedil; U+00162 Ţ

sstarf; U+022C6 ⋆ ucy; U+00443 у tcedil; U+00163 ţ

Star; U+022C6 ⋆ udarr; U+021C5 ⇅ Tcy; U+00422 Т

star; U+02606 ☆ Udblac; U+00170 Ű tcy; U+00442 т

starf; U+02605 ★ udblac; U+00171 ű tdot; U+020DB ◌⃛

straightepsilon; U+003F5 ϵ udhar; U+0296E telrec; U+02315 ⥮ ⌕

straightphi; U+003D5 ϕ ufisht; U+0297E Tfr; U+1D517 ⥾ 𝔗

strns; U+000AF ¯ Ufr; U+1D518 tfr; U+1D531 𝔘 𝔱

Sub; U+022D0 ⋐ ufr; U+1D532 𝔲 there4; U+02234 ∴

sub; U+02282 ⊂ Ugrave; U+000D9 Ù Therefore; U+02234 ∴

subdot; U+02ABD ⪽ therefore; U+02234 ∴ Ugrave U+000D9 Ù

subE; U+02AC5 ⫅ Theta; U+00398 Θ ugrave; U+000F9 ù

sube; U+02286 ⊆ ugrave U+000F9 ù theta; U+003B8 θ

subedot; U+02AC3 ⫃ uHar; U+02963 thetasym; U+003D1 ϑ ⥣

submult; U+02AC1 ⫁ thetav; U+003D1 ϑ uharl; U+021BF ↿

subnE; U+02ACB ⫋ thickapprox; U+02248 ≈ uharr; U+021BE ↾

subne; U+0228A ⊊ thicksim; U+0223C ∼ uhblk; U+02580 ▀

subplus; U+02ABF ⪿ ulcorn; U+0231C ⌜ ThickSpace; U+0205F U+0200A

subrarr; U+02979 ⥹ ulcorner; U+0231C ⌜ thinsp; U+02009

Subset; U+022D0 ⋐ ulcrop; U+0230F ⌏ ThinSpace; U+02009

subset; U+02282 ⊂ ultri; U+025F8 ◸ thkap; U+02248 ≈

subseteq; U+02286 ⊆ Umacr; U+0016A Ū thksim; U+0223C ∼

subseteqq; U+02AC5 ⫅ umacr; U+0016B ū THORN; U+000DE Þ

SubsetEqual; U+02286 ⊆ uml; U+000A8 ¨ THORN U+000DE Þ

subsetneq; U+0228A ⊊ uml U+000A8 ¨ thorn; U+000FE þ

subsetneqq; U+02ACB ⫋ UnderBar; U+0005F _ thorn U+000FE þ

subsim; U+02AC7 ⫇ UnderBrace; U+023DF Tilde; U+0223C ∼ ⏟

subsub; U+02AD5 UnderBracket; U+023B5 ⫕ tilde; U+002DC ˜ ⎵

subsup; U+02AD3 ⫓ TildeEqual; U+02243 ≃ UnderParenthesis; U+023DD ⏝

succ; U+0227B ≻ TildeFullEqual; U+02245 ≅ Union; U+022C3 ⋃

succapprox; U+02AB8 ⪸ TildeTilde; U+02248 ≈ UnionPlus; U+0228E ⊎

succcurlyeq; U+0227D ≽ times; U+000D7 × Uogon; U+00172 Ų

Succeeds; U+0227B ≻ times U+000D7 × uogon; U+00173 ų

SucceedsEqual; U+02AB0 ⪰ timesb; U+022A0 ⊠ Uopf; U+1D54C 𝕌

SucceedsSlantEqual; U+0227D ≽ timesbar; U+02A31 ⨱ uopf; U+1D566 𝕦

SucceedsTilde; U+0227F ≿ timesd; U+02A30 UpArrow; U+02191 ↑ ⨰

succeq; U+02AB0 ⪰ Uparrow; U+021D1 ⇑ tint; U+0222D ∭

succnapprox; U+02ABA ⪺ uparrow; U+02191 ↑ toea; U+02928 ⤨

succneqq; U+02AB6 ⪶ UpArrowBar; U+02912 top; U+022A4 ⊤ ⤒

succnsim; U+022E9 ⋩ topbot; U+02336 UpArrowDownArrow; U+021C5 ⇅ ⌶

succsim; U+0227F ≿ UpDownArrow; U+02195 ↕ topcir; U+02AF1 ⫱

SuchThat; U+0220B ∋ Updownarrow; U+021D5 ⇕ Topf; U+1D54B 𝕋

Sum; U+02211 ∑ updownarrow; U+02195 ↕ topf; U+1D565 𝕥

sum; U+02211 ∑ UpEquilibrium; U+0296E topfork; U+02ADA ⥮ ⫚

sung; U+0266A ♪ upharpoonleft; U+021BF ↿ tosa; U+02929 ⤩

Sup; U+022D1 ⋑ upharpoonright; U+021BE ↾ tprime; U+02034 ‴

sup; U+02283 ⊃ uplus; U+0228E ⊎ TRADE; U+02122 ™

sup1; U+000B9 ¹ UpperLeftArrow; U+02196 ↖ trade; U+02122 ™

sup1 U+000B9 ¹ UpperRightArrow; U+02197 ↗ triangle; U+025B5 ▵

sup2; U+000B2 ² Upsi; U+003D2 ϒ triangledown; U+025BF ▿

sup2 U+000B2 ² upsi; U+003C5 υ triangleleft; U+025C3 ◃

sup3; U+000B3 ³ upsih; U+003D2 ϒ trianglelefteq; U+022B4 ⊴

sup3 U+000B3 ³ Upsilon; U+003A5 Υ triangleq; U+0225C ≜

supdot; U+02ABE ⪾ upsilon; U+003C5 υ triangleright; U+025B9 ▹

supdsub; U+02AD8 ⫘ UpTee; U+022A5 ⊥ trianglerighteq; U+022B5 ⊵

supE; U+02AC6 ⫆ UpTeeArrow; U+021A5 ↥ tridot; U+025EC ◬

supe; U+02287 ⊇ upuparrows; U+021C8 ⇈ trie; U+0225C ≜

supedot; U+02AC4 urcorn; U+0231D ⌝ ⫄ triminus; U+02A3A ⨺

Superset; U+02283 ⊃ urcorner; U+0231D ⌝ TripleDot; U+020DB ◌⃛

SupersetEqual; U+02287 ⊇ urcrop; U+0230E ⌎ triplus; U+02A39 ⨹

suphsol; U+027C9 Uring; U+0016E Ů ⟉ trisb; U+029CD ⧍

suphsub; U+02AD7 uring; U+0016F ů ⫗ tritime; U+02A3B ⨻

suplarr; U+0297B urtri; U+025F9 ◹ ⥻ trpezium; U+023E2 ⏢

1182

Name Character(s) Glyph Name Character(s) Glyph Name Character(s) Glyph

Uscr; U+1D4B0 𝒰 Vfr; U+1D519 𝔙 xscr; U+1D4CD 𝓍

uscr; U+1D4CA 𝓊 vfr; U+1D533 𝔳 xsqcup; U+02A06 ⨆

utdot; U+022F0 ⋰ vltri; U+022B2 ⊲ xuplus; U+02A04 ⨄

Utilde; U+00168 Ũ vnsub; U+02282 U+020D2 ⊂⃒ xutri; U+025B3 △

utilde; U+00169 ũ vnsup; U+02283 U+020D2 ⊃⃒ xvee; U+022C1 ⋁

utri; U+025B5 ▵ Vopf; U+1D54D 𝕍 xwedge; U+022C0 ⋀

utrif; U+025B4 ▴ vopf; U+1D567 𝕧 Yacute; U+000DD Ý

uuarr; U+021C8 ⇈ vprop; U+0221D ∝ Yacute U+000DD Ý

Uuml; U+000DC Ü vrtri; U+022B3 ⊳ yacute; U+000FD ý

Uuml U+000DC Ü Vscr; U+1D4B1 𝒱 yacute U+000FD ý

uuml; U+000FC ü vscr; U+1D4CB 𝓋 YAcy; U+0042F Я

uuml U+000FC ü vsubnE; U+02ACB U+0FE00 ⫋︀ yacy; U+0044F я

uwangle; U+029A7 ⦧ vsubne; U+0228A U+0FE00 ⊊︀ Ycirc; U+00176 Ŷ

vangrt; U+0299C ⦜ vsupnE; U+02ACC U+0FE00 ⫌︀ ycirc; U+00177 ŷ

varepsilon; U+003F5 ϵ vsupne; U+0228B U+0FE00 ⊋︀ Ycy; U+0042B Ы

varkappa; U+003F0 ϰ Vvdash; U+022AA ⊪ ycy; U+0044B ы

varnothing; U+02205 ∅ vzigzag; U+0299A yen; U+000A5 ¥ ⦚

varphi; U+003D5 ϕ Wcirc; U+00174 Ŵ yen U+000A5 ¥

varpi; U+003D6 ϖ wcirc; U+00175 ŵ Yfr; U+1D51C 𝔜

varpropto; U+0221D ∝ wedbar; U+02A5F ⩟ yfr; U+1D536 𝔶

vArr; U+021D5 ⇕ Wedge; U+022C0 ⋀ YIcy; U+00407 Ї

varr; U+02195 ↕ wedge; U+02227 ∧ yicy; U+00457 ї

varrho; U+003F1 ϱ wedgeq; U+02259 ≙ Yopf; U+1D550 𝕐

varsigma; U+003C2 ς weierp; U+02118 ℘ yopf; U+1D56A 𝕪

varsubsetneq; U+0228A U+0FE00 ⊊︀ Wfr; U+1D51A 𝔚 Yscr; U+1D4B4 𝒴

varsubsetneqq; U+02ACB U+0FE00 ⫋︀ wfr; U+1D534 yscr; U+1D4CE 𝔴 𝓎

varsupsetneq; U+0228B U+0FE00 ⊋︀ Wopf; U+1D54E 𝕎 YUcy; U+0042E Ю

varsupsetneqq; U+02ACC U+0FE00 ⫌︀ wopf; U+1D568 𝕨 yucy; U+0044E ю

vartheta; U+003D1 ϑ wp; U+02118 ℘ Yuml; U+00178 Ÿ

vartriangleleft; U+022B2 ⊲ wr; U+02240 ≀ yuml; U+000FF ÿ

vartriangleright; U+022B3 ⊳ wreath; U+02240 ≀ yuml U+000FF ÿ

Vbar; U+02AEB ⫫ Wscr; U+1D4B2 Zacute; U+00179 Ź 𝒲

vBar; U+02AE8 ⫨ wscr; U+1D4CC zacute; U+0017A ź 𝓌

vBarv; U+02AE9 ⫩ xcap; U+022C2 ⋂ Zcaron; U+0017D Ž

Vcy; U+00412 В xcirc; U+025EF ◯ zcaron; U+0017E ž

vcy; U+00432 в xcup; U+022C3 ⋃ Zcy; U+00417 З

VDash; U+022AB ⊫ xdtri; U+025BD ▽ zcy; U+00437 з

Vdash; U+022A9 ⊩ Xfr; U+1D51B Zdot; U+0017B Ż 𝔛

vDash; U+022A8 ⊨ xfr; U+1D535 zdot; U+0017C ż 𝔵

vdash; U+022A2 ⊢ zeetrf; U+02128 ℨ xhArr; U+027FA ⟺

Vdashl; U+02AE6 ⫦ ZeroWidthSpace; U+0200B xharr; U+027F7 ⟷

Vee; U+022C1 ⋁ Zeta; U+00396 Ζ Xi; U+0039E Ξ

vee; U+02228 ∨ zeta; U+003B6 ζ xi; U+003BE ξ

veebar; U+022BB ⊻ Zfr; U+02128 ℨ xlArr; U+027F8 ⟸

veeeq; U+0225A ≚ zfr; U+1D537 xlarr; U+027F5 ⟵ 𝔷

vellip; U+022EE ⋮ ZHcy; U+00416 Ж xmap; U+027FC ⟼

Verbar; U+02016 ‖ zhcy; U+00436 ж xnis; U+022FB ⋻

verbar; U+0007C | zigrarr; U+021DD ⇝ xodot; U+02A00 ⨀

Vert; U+02016 ‖ Zopf; U+02124 ℤ Xopf; U+1D54F 𝕏

vert; U+0007C | zopf; U+1D56B 𝕫 xopf; U+1D569 𝕩

VerticalBar; U+02223 ∣ Zscr; U+1D4B5 xoplus; U+02A01 ⨁ 𝒵

VerticalLine; U+0007C | zscr; U+1D4CF xotime; U+02A02 ⨂ 𝓏

VerticalSeparator; U+02758 ❘ xrArr; U+027F9 ⟹ zwj; U+0200D ‍

VerticalTilde; U+02240 ≀ xrarr; U+027F6 ⟶ zwnj; U+0200C

VeryThinSpace; U+0200A Xscr; U+1D4B3 𝒳

This data is also available as a JSON file.

The glyphs displayed above are non-normative. Refer to Unicode for formal definitions of the characters listed above.

Note

The character reference names originate from XML Entity Definitions for Characters, though only the above is considered

normative. p1283 [XMLENTITY]



1183

14 The XML syntax §

p11 ✔ MDN

84

Note

This section only describes the rules for XML resources. Rules for p1241 text/html resources are discussed in the section above

entitled " p1064 The HTML syntax".



14.1 Writing documents in the XML syntax p11 §

84

Note

The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons,

because no such term is used for the HTML syntaxes of MathML and SVG).

The syntax for XML is defined in p1283 p1283 XML and Namespaces in XML . [XML] [XMLNS]

This specification does not define any syntax-level requirements beyond those defined for XML proper.

XML documents may contain a DOCTYPE if desired, but this is not required to conform to this specification. This specification does not define a public or system identifier, nor provide a formal DTD.

Note

According to XML, XML processors are not guaranteed to process the external DTD subset referenced in the DOCTYPE. This means,

for example, that using entity references for characters in XML documents is unsafe if they are defined in an external file (except

for <, >, &, " and ').



14.2 Parsing XML documents p11 §

84

This section describes the relationship between XML and the DOM, with a particular emphasis on how this interacts with HTML.

An XML parser, for the purposes of this specification, is a construct that follows the rules given in XML to map a string of bytes or characters into a p115 Document object.

Note

At the time of writing, no such rules actually exist.

An p1184 p115 XML parser is either associated with a Document object when it is created, or creates one implicitly.

This p115 Document must then be populated with DOM nodes that represent the tree structure of the input passed to the parser, as defined by XML, Namespaces in XML, and DOM. When creating DOM nodes representing elements, the create an element for a

token p1124 algorithm or some equivalent that operates on appropriate XML datastructures must be used, to ensure the proper element

interfaces p705 are created and that custom elements are set up correctly.

DOM mutation events must not fire for the operations that the p1184 p115 XML parser performs on the Document's tree, but the user agent must act as if elements and attributes were individually appended and set respectively so as to trigger rules in this specification regarding what happens when an element is inserted into a document or has its attributes set, and DOM's requirements regarding

mutation observers p1283 p1283 p1277 mean that mutation observers are fired (unlike mutation events). [XML] [XMLNS] [DOM]

[UIEVENTS] p1282

Between the time an element's start tag is parsed and the time either the element's end tag is parsed or the parser detects a well-

formedness error, the user agent must act as if the element was in a p1090 stack of open elements.



1184

Note

This is used, e.g. by the p373 p379 object element to avoid instantiating plugins before the param element children have been parsed.

This specification provides the following additional information that user agents should use when retrieving an external entity: the public identifiers given in the following list all correspond to the URL given by this link. (This URL is a DTD containing the entity

declarations p1175 p1283 for the names listed in the named character references section.) [XML]

•-//W3C//DTD XHTML 1.0 Transitional//EN

•-//W3C//DTD XHTML 1.1//EN

•-//W3C//DTD XHTML 1.0 Strict//EN

•-//W3C//DTD XHTML 1.0 Frameset//EN

•-//W3C//DTD XHTML Basic 1.0//EN

•-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN

•-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN

•-//W3C//DTD MathML 2.0//EN

•-//WAPFORUM//DTD XHTML Mobile 1.0//EN

Furthermore, user agents should attempt to retrieve the above external entity's content when one of the above public identifiers is used, and should not attempt to retrieve any other external entity's content.

Note

This is not strictly a p27 violation of XML, but it does contradict the spirit of XML's requirements. This is motivated by a desire for

user agents to all handle entities in an interoperable fashion without requiring any network access for handling external subsets.

[XML] p1283

XML parsers can be invoked with XML scripting support enabled or XML scripting support disabled. Except where otherwise specified, XML parsers are invoked with p1185 XML scripting support enabled.

When an p1184 p1185 p614 p620 XML parser with XML scripting support enabled creates a script element, it must have its parser document

set and its p620 p1187 "non-blocking" flag must be unset. If the parser was created as part of the XML fragment parsing algorithm, then the element must be marked as p620 "already started" also. When the element's end tag is subsequently parsed, the user agent must

perform a microtask checkpoint p936 p620 p614 , and then prepare the script element. If this causes there to be a pending parsing-blocking

script p624, then the user agent must run the following steps:

1. Block this instance of the p1184 p931 p932 XML parser , such that the event loop will not run tasks that invoke it.

2. p937 p115 p179 Spin the event loop until the parser's Document has no style sheet that is blocking scripts and the pending parsing-

blocking script p624 p620 's "ready to be parser-executed" flag is set.

3. Unblock this instance of the p1184 p932 XML parser , such that tasks that invoke it can again be run.

4. p624 p624 Execute the pending parsing-blocking script .

5. There is no longer a p624 pending parsing-blocking script.

Note

Since the p958 p1076 document.write() API is not available for XML documents , much of the complexity in the HTML parser is not

needed in the p1184 XML parser.



Note

When the p1184 p1185 XML parser has XML scripting support disabled, none of this happens.

When an p1184 p630 p630 XML parser would append a node to a template element, it must instead append it to the template element's

template contents p631 (a DocumentFragment node).

Note

This is a p27 p630 willful violation of XML ; unfortunately, XML is not formally extensible in the manner that is needed for template

processing. p1283 [XML]

When an p1184 XML parser creates a Node object, its node document must be set to the node document of the node into which the newly created node is to be inserted.

Certain algorithms in this specification p1184 spoon-feed the parser characters one string at a time. In such cases, the XML parser

1185

must act as it would have if faced with a single string consisting of the concatenation of all those characters.

When an p1184 p1161 p1076 XML parser reaches the end of its input, it must stop parsing , following the same rules as the HTML parser. An

XML parser p1184 p1162 p1076 can also be aborted , which must again be done in the same way as for an HTML parser.

For the purposes of conformance checkers, if a resource is determined to be in p1184 the XML syntax, then it is an XML document.



14.3 Serializing XML fragments p11 §

86

The p115 XML fragment serialization algorithm for a Document or Element node either returns a fragment of XML that represents that node or throws an exception.

For p115 Document s, the algorithm must return a string in the form of a document entity, if none of the error cases below apply.

For Elements, the algorithm must return a string in the form of an internal general parsed entity, if none of the error cases below apply.

In both cases, the string returned must be XML namespace-well-formed and must be an isomorphic serialization of all of that node's

relevant child nodes p1186, in tree order. User agents may adjust prefixes and namespace declarations in the serialization (and indeed might be forced to do so in some cases to obtain namespace-well-formed XML). User agents may use a combination of regular text and character references to represent Text nodes in the DOM.

A node's relevant child nodes are those that apply given the following rules: For p630 template elements

The p1186 p630 p631 relevant child nodes are the child nodes of the template element's template contents, if any.

For all other nodes

The p1186 relevant child nodes are the child nodes of node itself, if any.

For Elements, if any of the elements in the serialization are in no namespace, the default namespace in scope for those elements must be explicitly declared as the empty string. (This doesn't apply in the p115 p1283 p1283 Document case.) [XML] [XMLNS]

For the purposes of this section, an internal general parsed entity is considered XML namespace-well-formed if a document consisting of an element with no namespace declarations whose contents are the internal general parsed entity would itself be XML namespace-well-formed.

If any of the following error cases are found in the DOM subtree being serialized, then the algorithm must throw an

"InvalidStateError" DOMException instead of returning a string:

• A p115 Document node with no child element nodes.

• A DocumentType node that has an external subset public identifier that contains characters that are not matched by the XML

PubidChar p1283 production. [XML]

• A DocumentType node that has an external subset system identifier that contains both a U+0022 QUOTATION MARK (") and a

U+0027 APOSTROPHE (') or that contains characters that are not matched by the XML p1283 Char production. [XML]

• A node with a local name containing a U+003A COLON (:).

• A node with a local name that does not match the XML p1283 Name production. [XML]

• An p1283 Attr node with no namespace whose local name is the lowercase string " xmlns ". [XMLNS]

• An Element node with two or more attributes with the same local name and namespace.

• An Attr node, Text node, Comment node, or ProcessingInstruction node whose data contains characters that are not

matched by the XML p1283 Char production. [XML]

• A Comment node whose data contains two adjacent U+002D HYPHEN-MINUS characters (-) or ends with such a character.

• A ProcessingInstruction node whose target name is an ASCII case-insensitive match for the string "xml".

• A ProcessingInstruction node whose target name contains a U+003A COLON (:).

• A ProcessingInstruction node whose data contains the string "?>".

1186

Note

These are the only ways to make a DOM unserialisable. The DOM enforces all the other XML constraints; for example, trying to

append two elements to a p115 Document node will throw a "HierarchyRequestError" DOMException.



14.4 Parsing XML fragments p11 §

87

The p115 XML fragment parsing algorithm either returns a Document or throws a "SyntaxError" DOMException. Given a string input and a context element p1173 context, the algorithm is as follows:

1. Create a new p1184 XML parser.

2. p1185 p1173 Feed the parser just created the string corresponding to the start tag of the context element, declaring all the

namespace prefixes that are in scope on that element in the DOM, as well as declaring the default namespace (if any) that is in scope on that element in the DOM.

A namespace prefix is in scope if the DOM lookupNamespaceURI() method on the element would return a non-null value for that prefix.

The default namespace is the namespace for which the DOM isDefaultNamespace() method on the element would return true.

Note

No DOCTYPE is passed to the parser, and therefore no external subset is referenced, and therefore no entities will be recognized.

3. p1185 Feed the parser just created the string input.

4. p1185 p1173 Feed the parser just created the string corresponding to the end tag of the context element.

5. If there is an XML well-formedness or XML namespace well-formedness error, then throw a "SyntaxError" DOMException.

6. If the p115 document element of the resulting Document has any sibling nodes, then throw a "SyntaxError" DOMException.

7. Return the child nodes of the p115 document element of the resulting Document , in tree order.



1187

15 Rendering p11 §

88

User agents are not required to present HTML documents in any particular way. However, this section provides a set of suggestions for rendering HTML documents that, if followed, are likely to lead to a user experience that closely resembles the experience intended by the documents' authors. So as to avoid confusion regarding the normativity of this section, "must" has not been used. Instead, the term "expected" is used to indicate behavior that will lead to this experience. For the purposes of conformance for user agents designated as p47 supporting the suggested default rendering, the term "expected" in this section has the same conformance implications as "must".



15.1 Introduction p11 §

88

In general, user agents are expected to support CSS, and many of the suggestions in this section are expressed in CSS terms. User agents that use other presentation mechanisms can derive their expected behavior by translating from the CSS rules given in this section.

In the absence of style-layer rules to the contrary (e.g. author style sheets), user agents are expected to render an element so that it conveys to the user the meaning that the element p124 represents , as described by this specification.

The suggestions in this section generally assume a visual output medium with a resolution of 96dpi or greater, but HTML is intended to apply to multiple media (it is a media-independent language). User agent implementers are encouraged to adapt the suggestions in this section to their target media.



An element is being rendered if it has any associated CSS layout boxes, SVG layout boxes, or some equivalent in other styling languages.

Note

Just being off-screen does not mean the element is not p1188 p768 being rendered . The presence of the hidden attribute normally

means the element is not p1188 being rendered, though this might be overridden by the style sheets.

An element is said to p1188 intersect the viewport when it is being rendered and its associated CSS layout box intersects the viewport.

Note

This specification does not define the precise timing for when the intersection is tested, but it is suggested that the timing match

that of the Intersection Observer API. p1278 [INTERSECTIONOBSERVER]



User agents that do not honor author-level CSS style sheets are nonetheless expected to act as if they applied the CSS rules given in these sections in a manner consistent with this specification and the relevant CSS and Unicode specifications. p1275 [CSS]

[UNICODE] p1282 p1275 [BIDI]

Note

This is especially important for issues relating to the 'display', 'unicode-bidi', and 'direction' properties.



15.2 The CSS user agent style sheet and presentational hints p11 §

88

The CSS rules given in these subsections are, except where otherwise specified, expected to be used as part of the user-agent level style sheet defaults for all documents that contain p44 HTML elements.

Some rules are intended for the author-level zero-specificity presentational hints part of the CSS cascade; these are explicitly called out as presentational hints.

1188

When the text below says that an attribute attribute on an element element maps to the pixel length property (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for parsing non-

negative integers p69 doesn't generate an error, then the user agent is expected to use the parsed value as a pixel length for a

presentational hint p1188 for properties.

When the text below says that an attribute attribute on an element element maps to the dimension property (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for parsing

dimension values p71 doesn't generate an error, then the user agent is expected to use the parsed dimension as the value for a

presentational hint p1188 for properties, with the value given as a pixel length if the dimension was a length, and with the value given as a percentage if the dimension was a percentage.

When the text below says that an attribute attribute on an element element maps to the dimension property (ignoring zero) (or properties) properties, it means that if element has an attribute attribute set, and parsing that attribute's value using the rules for

parsing nonzero dimension values p72 doesn't generate an error, then the user agent is expected to use the parsed dimension as the value for a p1188 presentational hint for properties, with the value given as a pixel length if the dimension was a length, and with the value given as a percentage if the dimension was a percentage.

When a user agent is to align descendants of a node, the user agent is expected to align only those descendants that have both their 'margin-inline-start' and 'margin-inline-end' properties computing to a value other than 'auto', that are over-constrained and that have one of those two margins with a used value forced to a greater value, and that do not themselves have an applicable align attribute. When multiple elements are to p1189 align a particular descendant, the most deeply nested such element is expected to override the others. Aligned elements are expected to be aligned by having the used values of their margins on the line-left and line-

right p1276 p1277 sides be set accordingly. [CSSLOGICAL] [CSSWM]



15.3 Non-replaced elements p11 §

89

15.3.1 Hidden elements p11 §

89

CSS ✔ @namespace url ( http://www.w3.org/1999/xhtml ); MDN

[hidden], area, base, basefont, datalist, head, link, meta, noembed, noframes, param, rp, script, source, style, template, track, title {

display: none;

}

embed[hidden] { display: inline; height: 0; width: 0; }

input[type=hidden i] { display: none !important; }

@media (scripting) {

noscript { display: none !important; }

}



15.3.2 The page p11 §

89

CSS @namespace url(http://www.w3.org/1999/xhtml);

html, body { display: block; }

For each property in the table below, given a p179 p1189 body element, the first attribute that exists maps to the pixel length property on

the p179 body element. If none of the attributes for a property are found, or if the value of the attribute that was found cannot be parsed successfully, then a default value of 8px is expected to be used for that property instead.

Property Source

'margin-top' p179 p1227 The body element's marginheight attribute

The p179 p1227 body element's topmargin attribute

The p179 p1190 p1227 body element's container frame element 's marginheight attribute

1189

Property Source

'margin-right' p179 p1227 The body element's marginwidth attribute

The p179 p1227 body element's rightmargin attribute

The p179 p1190 p1227 body element's container frame element 's marginwidth attribute

'margin-bottom' p179 p1227 The body element's marginheight attribute

The p179 p1227 body element's bottommargin attribute

The p179 p1190 p1227 body element's container frame element 's marginheight attribute

'margin-left' p179 p1227 The body element's marginwidth attribute

The p179 p1227 body element's leftmargin attribute

The p179 p1190 p1227 body element's container frame element 's marginwidth attribute

If the p179 p814 p817 p817 body element's node document 's browsing context is a child browsing context , and the container of that browsing

context p814 p1231 p362 p179 p1231 is a frame or iframe element, then the container frame element of the body element is that frame or

iframe p362 p1190 element. Otherwise, there is no container frame element.

⚠Warning!

The above requirements imply that a page can change the margins of another page (including one from another

origin p841 p362 ) using, for example, an iframe. This is potentially a security risk, as it might in some cases allow an

attack to contrive a situation in which a page is rendered not as the author intended, possibly for the purposes of

phishing or otherwise misleading the user.



If a p115 p814 p817 Document 's browsing context is a child browsing context , then it is expected to be positioned and sized to fit inside the

content box p817 p814 p817 p1188 p814 of the container of that browsing context . If the container is not being rendered , the browsing context is

expected to have a viewport with zero width and zero height.

If a p115 p814 p817 p817 p814 p1231 Document 's browsing context is a child browsing context , the container of that browsing context is a frame or

iframe p362 element, that element has a scrolling attribute, and that attribute's value is an ASCII case-insensitive match for the string

"off", "noscroll", or "no", then the user agent is expected to prevent any scrollbars from being shown for the viewport of the

Document p115 p814 's browsing context, regardless of the 'overflow' property that applies to that viewport.



When a p179 p1228 p89 body element has a background attribute set to a non-empty value, the new value is expected to be parsed relative to the element's p1188 node document , and if this is successful, the user agent is expected to treat the attribute as a presentational hint

setting the element's p89 'background-image' property to the resulting URL string.

When a p179 p1227 body element has a bgcolor attribute set, the new value is expected to be parsed using the rules for parsing a legacy

color value p86 p1188 , and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-color' property to the resulting color.

When a p179 p1227 p86 body element has a text attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's

'color' property to the resulting color.

When a p179 p1227 p86 body element has a link attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a p1188 presentational hint setting the 'color'

property of any element in the p115 p728 Document matching the :link pseudo-class to the resulting color.

When a p179 p1227 body element has a vlink attribute, its value is expected to be parsed using the rules for parsing a legacy color

value p86 p1188 , and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the

'color' p115 p728 property of any element in the Document matching the :visited pseudo-class to the resulting color.

When a p179 p1227 body element has an alink attribute, its value is expected to be parsed using the rules for parsing a legacy color

value p86 p1188 , and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the

'color' p115 p728 p728 property of any element in the Document matching the :active pseudo-class and either the :link pseudo-class or the

:visited p728 pseudo-class to the resulting color.



1190

15.3.3 Flow content p11 §

91

CSS @namespace url(http://www.w3.org/1999/xhtml);

address, blockquote, center, dialog, div, figure, figcaption, footer, form, header, hr, legend, listing, main, p, plaintext, pre, xmp {

display: block;

}

blockquote, figure, listing, p, plaintext, pre, xmp {

margin-block-start: 1em; margin-block-end: 1em;

}

blockquote, figure { margin-inline-start: 40px; margin-inline-end: 40px; }

address { font-style: italic; }

listing, plaintext, pre, xmp {

font-family: monospace; white-space: pre;

}

dialog:not([open]) { display: none; }

dialog {

position: absolute;

inset-inline-start: 0; inset-inline-end: 0;

width: fit-content;

height: fit-content;

margin: auto;

border: solid;

padding: 1em;

background: white;

color: black;

}

dialog::backdrop {

background: rgba(0,0,0,0.1);

}

slot {

display: contents;

}

The following rules are also expected to apply, as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

pre[wrap] { white-space: pre-wrap; }

In quirks mode, the following rules are also expected to apply:

CSS @namespace url(http://www.w3.org/1999/xhtml);

form { margin-block-end: 1em; }



The p1224 p238 p1227 center element, and the div element when it has an align attribute whose value is an ASCII case-insensitive match for either the string "center" or the string "middle", are expected to center text within themselves, as if they had their 'text-align'

property set to 'center' in a p1188 p1189 presentational hint , and to align descendants to the center.

The p238 p1227 div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "left", is expected to left-align text within itself, as if it had its p1188 'text-align' property set to 'left' in a presentational hint, and to align

descendants p1189 to the left.



1191

The p238 p1227 div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "right", is expected to right-align text within itself, as if it had its p1188 'text-align' property set to 'right' in a presentational hint, and to align

descendants p1189 to the right.

The p238 p1227 div element, when it has an align attribute whose value is an ASCII case-insensitive match for the string "justify", is expected to full-justify text within itself, as if it had its p1188 'text-align' property set to 'justify' in a presentational hint, and to align

descendants p1189 to the left.

The p611 p614 dialog element, when its is modal flag is true, is expected to act as if it had a user-agent-level style sheet rule setting the following properties:

• 'position' property to 'fixed'

• 'overflow' property to 'auto'

• 'inset-block-start' property to '0'

• 'inset-block-end' property to '0'

• 'max-width' property to 'calc(100% - 6px - 2em)'

• 'max-height' property to 'calc(100% - 6px - 2em)'



15.3.4 Phrasing content p11 §

92

CSS @namespace url(http://www.w3.org/1999/xhtml);

cite, dfn, em, i, var { font-style: italic; }

b, strong { font-weight: bolder; }

code, kbd, samp, tt { font-family: monospace; }

big { font-size: larger; }

small { font-size: smaller; }

sub { vertical-align: sub; }

sup { vertical-align: super; }

sub, sup { line-height: normal; font-size: smaller; }

ruby { display: ruby; }

rt { display: ruby-text; }

:link { color: #0000EE; }

:visited { color: #551A8B; }

:link:active, :visited:active { color: #FF0000; }

:link, :visited { text-decoration: underline; cursor: pointer; }

:focus { outline: auto; }

mark { background: yellow; color: black; } /* this color is just a suggestion and can be changed based on implementation feedback */

abbr[title], acronym[title] { text-decoration: dotted underline; } ins, u { text-decoration: underline; }

del, s, strike { text-decoration: line-through; }

q::before { content: open-quote; }

q::after { content: close-quote; }

br { display-outside: newline; } /* this also has bidi implications */ nobr { white-space: nowrap; }

wbr { display-outside: break-opportunity; } /* this also has bidi implications */ nobr wbr { white-space: normal; }

1192

The following rules are also expected to apply, as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

br[clear=left i] { clear: left; }

br[clear=right i] { clear: right; }

br[clear=all i], br[clear=both i] { clear: both; }

For the purposes of the CSS ruby model, runs of children of p253 p259 p259 ruby elements that are not rt or rp elements are expected to be wrapped in anonymous boxes whose p1277 'display' property has the value 'ruby-base' . [CSSRUBY]

When a particular part of a ruby has more than one annotation, the annotations should be distributed on both sides of the base text so as to minimize the stacking of ruby annotations on one side.

Note

When it becomes possible to do so, the preceding requirement will be updated to be expressed in terms of CSS ruby. (Currently,

CSS ruby does not handle nested p253 p259 ruby elements or multiple sequential rt elements, which is how this semantic is

expressed.)

User agents that do not support correct ruby rendering are expected to render parentheses around the text of p259 rt elements in the absence of p259 rp elements.



User agents are expected to support the p281 p1227 'clear' property on inline elements (in order to render br elements with clear attributes) in the manner described in the non-normative note to this effect in CSS.

The initial value for the 'color' property is expected to be black. The initial value for the 'background-color' property is expected to be 'transparent'. The canvas's background is expected to be white.



When a p1224 p86 font element has a color attribute, its value is expected to be parsed using the rules for parsing a legacy color value,

and if that does not return an error, the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's

'color' property to the resulting color.

The p1224 font element is expected to override the color of any text decoration that spans the text of the element to the used value of the element's 'color' property.

When a p1224 p1188 font element has a face attribute, the user agent is expected to treat the attribute as a presentational hint setting the element's 'font-family' property to the attribute's value.

When a p1224 font element has a size attribute, the user agent is expected to use the following steps, known as the rules for parsing a legacy font size p1188 , to treat the attribute as a presentational hint setting the element's 'font-size' property:

1. Let input be the attribute's value.

2. Let position be a pointer into input, initially pointing at the start of the string.

3. Skip ASCII whitespace within input given position.

4. If p1188 position is past the end of input , there is no presentational hint. Return.

5. If the character at position is a U+002B PLUS SIGN character (+), then let mode be relative-plus, and advance position to the

next character. Otherwise, if the character at position is a U+002D HYPHEN-MINUS character (-), then let mode be relative-minus, and advance position to the next character. Otherwise, let mode be absolute.

6. Collect a sequence of code points that are ASCII digits from input given position, and let the resulting sequence be digits.

7. If p1188 digits is the empty string, there is no presentational hint. Return.

8. Interpret digits as a base-ten integer. Let value be the resulting number.

9. If mode is relative-plus, then increment value by 3. If mode is relative-minus, then let value be the result of subtracting value

from 3.

10. If value is greater than 7, let it be 7.

1193

11. If value is less than 1, let it be 1.

12. Set 'font-size' to the keyword corresponding to the value of value according to the following table:

value 'font-size' keyword

1 'x-small'

2 'small'

3 'medium'

4 'large'

5 'x-large'

6 'xx-large'

7 'xxx-large'



15.3.5 Bidirectional text p11 §

94

CSS @namespace url(http://www.w3.org/1999/xhtml);

[dir]:dir(ltr), bdi:dir(ltr), input[type=tel i]:dir(ltr) { direction: ltr; } [dir]:dir(rtl), bdi:dir(rtl) { direction: rtl; }

address, blockquote, center, div, figure, figcaption, footer, form, header, hr, legend, listing, main, p, plaintext, pre, summary, xmp, article, aside, h1, h2, h3, h4, h5, h6, hgroup, nav, section, table, caption, colgroup, col, thead, tbody, tfoot, tr, td, th, dir, dd, dl, dt, menu, ol, ul, li, bdi, output, [dir=ltr i], [dir=rtl i], [dir=auto i] {

unicode-bidi: isolate;

}

bdo, bdo[dir] { unicode-bidi: isolate-override; }

input[dir=auto i]:is([type=search i], [type=tel i], [type=url i], [type=email i]), textarea[dir=auto i], pre[dir=auto i] {

unicode-bidi: plaintext;

}

/* see prose for input elements whose type attribute is in the Text state */

/* the rules setting the 'content' property on br and wbr elements also has bidi implications */

When an p494 p143 p143 p496 p500 input element's dir attribute is in the auto state and its type attribute is in the Text state, then the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'unicode-bidi' property to 'plaintext'.

Input fields (i.e. p549 p494 p496 p500 p500 textarea elements, and input elements when their type attribute is in the Text , Search ,

Telephone p501 p502 p503 , URL , or Email state) are expected to present an editing user interface with a directionality that matches the element's 'direction' property.

When the document's character encoding is ISO-8859-8, the following rules are additionally expected to apply, following those above:

[ENCODING] p1277

CSS @namespace url(http://www.w3.org/1999/xhtml);

address, blockquote, center, div, figure, figcaption, footer, form, header, hr, legend, listing, main, p, plaintext, pre, summary, xmp, article, aside, h1, h2, h3, h4, h5, h6, hgroup, nav, section, table, caption, colgroup, col, thead, tbody, tfoot, tr, td, th, dir, dd, dl, dt, menu, ol, ul, li, [dir=ltr i], [dir=rtl i], [dir=auto i], *|* {

unicode-bidi: bidi-override;

}

input:not([type=submit i]):not([type=reset i]):not([type=button i]), textarea {

1194

unicode-bidi: normal;

}



15.3.6 Sections and headings p11 §

95

CSS @namespace url(http://www.w3.org/1999/xhtml);

article, aside, h1, h2, h3, h4, h5, h6, hgroup, nav, section {

display: block;

}

h1 { margin-block-start: 0.67em; margin-block-end: 0.67em; font-size: 2.00em; font-weight: bold; } h2 { margin-block-start: 0.83em; margin-block-end: 0.83em; font-size: 1.50em; font-weight: bold; } h3 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; font-weight: bold; } h4 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; font-weight: bold; } h5 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; font-weight: bold; } h6 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; font-weight: bold; }

In the following CSS block, x is shorthand for the following selector: :is(article, aside, nav, section)

CSS @namespace url(http://www.w3.org/1999/xhtml);

x h1 { margin-block-start: 0.83em; margin-block-end: 0.83em; font-size: 1.50em; } x x h1 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; } x x x h1 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; } x x x x h1 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; } x x x x x h1 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h2 { margin-block-start: 1.00em; margin-block-end: 1.00em; font-size: 1.17em; } x x hgroup > h1 ~ h2 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; } x x x hgroup > h1 ~ h2 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; } x x x x hgroup > h1 ~ h2 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h3 { margin-block-start: 1.33em; margin-block-end: 1.33em; font-size: 1.00em; } x x hgroup > h1 ~ h3 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; } x x x hgroup > h1 ~ h3 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h4 { margin-block-start: 1.67em; margin-block-end: 1.67em; font-size: 0.83em; } x x hgroup > h1 ~ h4 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }

x hgroup > h1 ~ h5 { margin-block-start: 2.33em; margin-block-end: 2.33em; font-size: 0.67em; }



Note

The shorthand is used to keep this block at least mildly readable.



15.3.7 Lists p11 §

95

CSS @namespace url(http://www.w3.org/1999/xhtml);

dir, dd, dl, dt, menu, ol, ul { display: block; }

li { display: list-item; }

dir, dl, menu, ol, ul { margin-block-start: 1em; margin-block-end: 1em; }

:is(dir, dl, menu, ol, ul) :is(dir, dl, menu, ol, ul) {

1195

margin-block-start: 0; margin-block-end: 0;

}

dd { margin-inline-start: 40px; }

dir, menu, ol, ul { padding-inline-start: 40px; }

ol { list-style-type: decimal; }

dir, menu, ul {

list-style-type: disc;

}

:is(dir, menu, ol, ul) :is(dir, menu, ul) {

list-style-type: circle;

}

:is(dir, menu, ol, ul) :is(dir, menu, ol, ul) :is(dir, menu, ul) {

list-style-type: square;

}

The following rules are also expected to apply, as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

ol[type="1"], li[type="1"] { list-style-type: decimal; }

ol[type=a s], li[type=a s] { list-style-type: lower-alpha; }

ol[type=A s], li[type=A s] { list-style-type: upper-alpha; }

ol[type=i s], li[type=i s] { list-style-type: lower-roman; }

ol[type=I s], li[type=I s] { list-style-type: upper-roman; }

ul[type=none i], li[type=none i] { list-style-type: none; }

ul[type=disc i], li[type=disc i] { list-style-type: disc; }

ul[type=circle i], li[type=circle i] { list-style-type: circle; } ul[type=square i], li[type=square i] { list-style-type: square; }

When rendering p225 p226 p225 li elements, non-CSS user agents are expected to use the ordinal value of the li element to render the counter in the list item marker.



This specification does not yet define the CSS-specific rules for rendering p225 li elements, because CSS doesn't yet provide sufficient hooks for this purpose.



15.3.8 Tables p11 §

96

CSS @namespace url(http://www.w3.org/1999/xhtml);

table { display: table; }

caption { display: table-caption; }

colgroup, colgroup[hidden] { display: table-column-group; }

col, col[hidden] { display: table-column; }

thead, thead[hidden] { display: table-header-group; }

tbody, tbody[hidden] { display: table-row-group; }

tfoot, tfoot[hidden] { display: table-footer-group; }

tr, tr[hidden] { display: table-row; }

td, th { display: table-cell; }

colgroup[hidden], col[hidden], thead[hidden], tbody[hidden], tfoot[hidden], tr[hidden] {

visibility: collapse;

}

table {

1196

box-sizing: border-box;

border-spacing: 2px;

border-collapse: separate;

text-indent: initial;

}

td, th { padding: 1px; }

th { font-weight: bold; }

caption { text-align: center; }

thead, tbody, tfoot, table > tr { vertical-align: middle; }

tr, td, th { vertical-align: inherit; }

thead, tbody, tfoot, tr { border-color: inherit; }

table[rules=none i], table[rules=groups i], table[rules=rows i], table[rules=cols i], table[rules=all i], table[frame=void i], table[frame=above i], table[frame=below i], table[frame=hsides i], table[frame=lhs i], table[frame=rhs i], table[frame=vsides i], table[frame=box i], table[frame=border i],

table[rules=none i] > tr > td, table[rules=none i] > tr > th, table[rules=groups i] > tr > td, table[rules=groups i] > tr > th, table[rules=rows i] > tr > td, table[rules=rows i] > tr > th, table[rules=cols i] > tr > td, table[rules=cols i] > tr > th, table[rules=all i] > tr > td, table[rules=all i] > tr > th, table[rules=none i] > thead > tr > td, table[rules=none i] > thead > tr > th, table[rules=groups i] > thead > tr > td, table[rules=groups i] > thead > tr > th, table[rules=rows i] > thead > tr > td, table[rules=rows i] > thead > tr > th, table[rules=cols i] > thead > tr > td, table[rules=cols i] > thead > tr > th, table[rules=all i] > thead > tr > td, table[rules=all i] > thead > tr > th, table[rules=none i] > tbody > tr > td, table[rules=none i] > tbody > tr > th, table[rules=groups i] > tbody > tr > td, table[rules=groups i] > tbody > tr > th, table[rules=rows i] > tbody > tr > td, table[rules=rows i] > tbody > tr > th, table[rules=cols i] > tbody > tr > td, table[rules=cols i] > tbody > tr > th, table[rules=all i] > tbody > tr > td, table[rules=all i] > tbody > tr > th, table[rules=none i] > tfoot > tr > td, table[rules=none i] > tfoot > tr > th, table[rules=groups i] > tfoot > tr > td, table[rules=groups i] > tfoot > tr > th, table[rules=rows i] > tfoot > tr > td, table[rules=rows i] > tfoot > tr > th, table[rules=cols i] > tfoot > tr > td, table[rules=cols i] > tfoot > tr > th, table[rules=all i] > tfoot > tr > td, table[rules=all i] > tfoot > tr > th {

border-color: black;

}

The following rules are also expected to apply, as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

table[align=left i] { float: left; }

table[align=right i] { float: right; }

table[align=center i] { margin-inline-start: auto; margin-inline-end: auto; } thead[align=absmiddle i], tbody[align=absmiddle i], tfoot[align=absmiddle i], tr[align=absmiddle i], td[align=absmiddle i], th[align=absmiddle i] {

text-align: center;

}

caption[align=bottom i] { caption-side: bottom; }

p[align=left i], h1[align=left i], h2[align=left i], h3[align=left i], h4[align=left i], h5[align=left i], h6[align=left i] {

text-align: left;

}

p[align=right i], h1[align=right i], h2[align=right i], h3[align=right i], h4[align=right i], h5[align=right i], h6[align=right i] {

text-align: right;

}

1197

p[align=center i], h1[align=center i], h2[align=center i], h3[align=center i], h4[align=center i], h5[align=center i], h6[align=center i] {

text-align: center;

}

p[align=justify i], h1[align=justify i], h2[align=justify i], h3[align=justify i], h4[align=justify i], h5[align=justify i], h6[align=justify i] {

text-align: justify;

}

thead[valign=top i], tbody[valign=top i], tfoot[valign=top i], tr[valign=top i], td[valign=top i], th[valign=top i] {

vertical-align: top;

}

thead[valign=middle i], tbody[valign=middle i], tfoot[valign=middle i], tr[valign=middle i], td[valign=middle i], th[valign=middle i] {

vertical-align: middle;

}

thead[valign=bottom i], tbody[valign=bottom i], tfoot[valign=bottom i], tr[valign=bottom i], td[valign=bottom i], th[valign=bottom i] {

vertical-align: bottom;

}

thead[valign=baseline i], tbody[valign=baseline i], tfoot[valign=baseline i], tr[valign=baseline i], td[valign=baseline i], th[valign=baseline i] {

vertical-align: baseline;

}

td[nowrap], th[nowrap] { white-space: nowrap; }

table[rules=none i], table[rules=groups i], table[rules=rows i], table[rules=cols i], table[rules=all i] {

border-style: hidden;

border-collapse: collapse;

}

table[border] { border-style: outset; } /* only if border is not equivalent to zero */ table[frame=void i] { border-style: hidden; }

table[frame=above i] { border-style: outset hidden hidden hidden; } table[frame=below i] { border-style: hidden hidden outset hidden; } table[frame=hsides i] { border-style: outset hidden outset hidden; } table[frame=lhs i] { border-style: hidden hidden hidden outset; } table[frame=rhs i] { border-style: hidden outset hidden hidden; } table[frame=vsides i] { border-style: hidden outset; }

table[frame=box i], table[frame=border i] { border-style: outset; }

table[border] > tr > td, table[border] > tr > th,

table[border] > thead > tr > td, table[border] > thead > tr > th, table[border] > tbody > tr > td, table[border] > tbody > tr > th, table[border] > tfoot > tr > td, table[border] > tfoot > tr > th {

/* only if border is not equivalent to zero */

border-width: 1px;

border-style: inset;

}

table[rules=none i] > tr > td, table[rules=none i] > tr > th, table[rules=none i] > thead > tr > td, table[rules=none i] > thead > tr > th, table[rules=none i] > tbody > tr > td, table[rules=none i] > tbody > tr > th, table[rules=none i] > tfoot > tr > td, table[rules=none i] > tfoot > tr > th, table[rules=groups i] > tr > td, table[rules=groups i] > tr > th, table[rules=groups i] > thead > tr > td, table[rules=groups i] > thead > tr > th, table[rules=groups i] > tbody > tr > td, table[rules=groups i] > tbody > tr > th, table[rules=groups i] > tfoot > tr > td, table[rules=groups i] > tfoot > tr > th, table[rules=rows i] > tr > td, table[rules=rows i] > tr > th, table[rules=rows i] > thead > tr > td, table[rules=rows i] > thead > tr > th, table[rules=rows i] > tbody > tr > td, table[rules=rows i] > tbody > tr > th, table[rules=rows i] > tfoot > tr > td, table[rules=rows i] > tfoot > tr > th {

1198

border-width: 1px;

border-style: none;

}

table[rules=cols i] > tr > td, table[rules=cols i] > tr > th, table[rules=cols i] > thead > tr > td, table[rules=cols i] > thead > tr > th, table[rules=cols i] > tbody > tr > td, table[rules=cols i] > tbody > tr > th, table[rules=cols i] > tfoot > tr > td, table[rules=cols i] > tfoot > tr > th {

border-width: 1px;

border-block-start-style: none;

border-inline-end-style: solid;

border-block-end-style: none;

border-inline-start-style: solid;

}

table[rules=all i] > tr > td, table[rules=all i] > tr > th, table[rules=all i] > thead > tr > td, table[rules=all i] > thead > tr > th, table[rules=all i] > tbody > tr > td, table[rules=all i] > tbody > tr > th, table[rules=all i] > tfoot > tr > td, table[rules=all i] > tfoot > tr > th {

border-width: 1px;

border-style: solid;

}

table[rules=groups i] > colgroup {

border-inline-start-width: 1px;

border-inline-start-style: solid;

border-inline-end-width: 1px;

border-inline-end-style: solid;

}

table[rules=groups i] > thead,

table[rules=groups i] > tbody,

table[rules=groups i] > tfoot {

border-block-start-width: 1px;

border-block-start-style: solid;

border-block-end-width: 1px;

border-block-end-style: solid;

}

table[rules=rows i] > tr, table[rules=rows i] > thead > tr, table[rules=rows i] > tbody > tr, table[rules=rows i] > tfoot > tr {

border-block-start-width: 1px;

border-block-start-style: solid;

border-block-end-width: 1px;

border-block-end-style: solid;

}

In quirks mode, the following rules are also expected to apply:

CSS @namespace url(http://www.w3.org/1999/xhtml);

table {

font-weight: initial;

font-style: initial;

font-variant: initial;

font-size: initial;

line-height: initial;

white-space: initial;

text-align: initial;

}



For the purposes of the CSS table model, the p461 col element is expected to be treated as if it was present as many times as its

span p461 p69 attribute specifies.

1199

For the purposes of the CSS table model, the p460 p461 colgroup element, if it contains no col element, is expected to be treated as if it had as many such children as its p461 p69 span attribute specifies.

For the purposes of the CSS table model, the p470 p470 p466 p468 colspan and rowspan attributes on td and th elements are expected to

provide p69 the special knowledge regarding cells spanning rows and columns.

In HTML documents, the following rules are also expected to apply:

CSS @namespace url(http://www.w3.org/1999/xhtml);

:is(table, thead, tbody, tfoot, tr) > form { display: none !important; }



The p451 p1228 p1189 table element's cellspacing attribute maps to the pixel length property 'border-spacing' on the element.

The p451 p1228 p1189 table element's cellpadding attribute maps to the pixel length properties 'padding-top', 'padding-right', 'padding-

bottom' p466 p468 p471 p471 , and 'padding-left' of any td and th elements that have corresponding cells in the table corresponding to the

table p451 element.

The p451 p1228 p1189 p451 table element's height attribute maps to the dimension property (ignoring zero) 'height' on the table element.

The p451 p1228 p1189 p451 table element's width attribute maps to the dimension property (ignoring zero) 'width' on the table element.

The p461 p1227 p1189 p461 col element's width attribute maps to the dimension property 'width' on the col element.

The p463 p462 p464 p1228 p1189 thead , tbody , and tfoot elements' height attribute maps to the dimension property 'height' on the element.

The p465 p1228 p1189 p465 tr element's height attribute maps to the dimension property (ignoring zero) 'height' on the tr element.

The p466 p468 p1228 p1189 td and th elements' height attributes map to the dimension property (ignoring zero) 'height' on the element.

The p466 p468 p1228 p1189 td and th elements' width attributes map to the dimension property (ignoring zero) 'width' on the element.



The p463 p462 p464 p465 p466 p468 thead , tbody , tfoot , tr , td , and th elements, when they have an align attribute whose value is an ASCII

case-insensitive match for either the string "center" or the string "middle", are expected to center text within themselves, as if they had their p1188 p1189 'text-align' property set to 'center' in a presentational hint , and to align descendants to the center.

The p463 p462 p464 p465 p466 p468 thead , tbody , tfoot , tr , td , and th elements, when they have an align attribute whose value is an ASCII

case-insensitive match for the string "left", are expected to left-align text within themselves, as if they had their 'text-align' property set to 'left' in a p1188 p1189 presentational hint , and to align descendants to the left.

The p463 p462 p464 p465 p466 p468 thead , tbody , tfoot , tr , td , and th elements, when they have an align attribute whose value is an ASCII

case-insensitive match for the string "right", are expected to right-align text within themselves, as if they had their 'text-align'

property set to 'right' in a p1188 p1189 presentational hint , and to align descendants to the right.

The p463 p462 p464 p465 p466 p468 thead , tbody , tfoot , tr , td , and th elements, when they have an align attribute whose value is an ASCII

case-insensitive match for the string "justify", are expected to full-justify text within themselves, as if they had their 'text-align'

property set to 'justify' in a p1188 p1189 presentational hint , and to align descendants to the left.

User agents are expected to have a rule in their user agent style sheet that matches p468 th elements that have a parent node whose

computed value for the 'text-align' property is its initial value, whose declaration block consists of just a single declaration that sets the

'text-align' property to the value 'center'.



When a p451 p463 p462 p464 p465 p466 p468 p1228 table , thead , tbody , tfoot , tr , td , or th element has a background attribute set to a non-empty value, the new value is expected to be p89 parsed relative to the element's node document, and if this is successful, the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's 'background-image' property to the resulting URL

string p89.

When a p451 p463 p462 p464 p465 p466 p468 table , thead , tbody , tfoot , tr , td , or th element has a bgcolor attribute set, the new value is expected to be parsed using the p86 rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's 'background-color' property to the resulting color.

1200

When a p451 p1228 table element has a bordercolor attribute, its value is expected to be parsed using the rules for parsing a legacy

color value p86 p1188 , and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'border-top-color', 'border-right-color', 'border-bottom-color', and 'border-left-color' properties to the resulting color.



The p451 p1228 p1189 table element's border attribute maps to the pixel length properties 'border-top-width', 'border-right-width', 'border-

bottom-width', 'border-left-width' on the element. If the attribute is present but parsing the attribute's value using the rules for parsing

non-negative integers p69 generates an error, a default value of 1px is expected to be used for that property instead.

Rules marked " p1228 only if border is not equivalent to zero " in the CSS block above is expected to only be applied if the border

attribute mentioned in the selectors for the rule is not only present but, when parsed using the rules for parsing non-negative

integers p69, is also found to have a value other than zero or to generate an error.



In p466 p468 p1228 p1228 quirks mode , a td element or a th element that has a nowrap attribute but also has a width attribute whose value, when parsed using the p72 rules for parsing nonzero dimension values, is found to be a length (not an error or a number classified as a percentage), is expected to have a p1188 presentational hint setting the element's 'white-space' property to 'normal', overriding the rule in the CSS block above that sets it to 'nowrap'.



15.3.9 Margin collapsing quirks p12 §

01

A node is p130 substantial if it is a text node that is not inter-element whitespace, or if it is an element node.

A node is p1201 blank if it is an element that contains no substantial nodes.

The p219 p1223 p228 p191 p191 p191 p191 p191 elements with default margins are the following elements: blockquote , dir , dl , h1 , h2 , h3 , h4 , h5,

h6 p191 p1223 p224 p222 p213 p1223 p217 p223 p1224 , listing , menu , ol , p , plaintext , pre , ul , xmp

In p1201 p179 p466 p468 quirks mode , any element with default margins that is the child of a body , td , or th element and has no

substantial p1201 previous siblings is expected to have a user-agent level style sheet rule that sets its 'margin-block-start' property to zero.

In p1201 p179 p466 p468 p1201 quirks mode , any element with default margins that is the child of a body , td , or th element, has no substantial

previous siblings, and is p1201 blank, is expected to have a user-agent level style sheet rule that sets its 'margin-block-end' property to zero also.

In p1201 p466 p468 p1201 quirks mode , any element with default margins that is the child of a td or th element, has no substantial following siblings, and is p1201 blank, is expected to have a user-agent level style sheet rule that sets its 'margin-block-start' property to zero.

In p213 p466 p468 p1201 quirks mode , any p element that is the child of a td or th element and has no substantial following siblings, is expected to have a user-agent level style sheet rule that sets its 'margin-block-end' property to zero.



15.3.10 Form controls p12 §

01

CSS @namespace url(http://www.w3.org/1999/xhtml);

input, select, button, textarea {

letter-spacing: initial;

word-spacing: initial;

line-height: initial;

text-transform: initial;

text-indent: initial;

text-shadow: initial;

}

input, select, textarea {

text-align: initial;

}

1201

input:is([type=reset i], [type=button i], [type=submit i]), button {

text-align: center;

}

input:is([type=reset i], [type=button i], [type=submit i], [type=color i]), button {

display: inline-block;

}

input:is([type=radio i], [type=checkbox i], [type=reset i], [type=button i], [type=submit i], [type=color i], [type=search i]), select, button {

box-sizing: border-box;

}

textarea { white-space: pre-wrap; }

In quirks mode, the following rules are also expected to apply:

CSS @namespace url(http://www.w3.org/1999/xhtml);

input:not([type=image i]), textarea { box-sizing: border-box; }

Each kind of form control is also described in the p1209 Widgets section, which describes the look and feel of the control.



15.3.11 The p215 p12 hr element §

02

CSS @namespace url(http://www.w3.org/1999/xhtml);

hr {

color: gray;

border-style: inset;

border-width: 1px;

margin-block-start: 0.5em;

margin-inline-end: auto;

margin-block-end: 0.5em;

margin-inline-start: auto;

overflow: hidden;

}

The following rules are also expected to apply, as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

hr[align=left i] { margin-left: 0; margin-right: auto; }

hr[align=right i] { margin-left: auto; margin-right: 0; }

hr[align=center i] { margin-left: auto; margin-right: auto; }

hr[color], hr[noshade] { border-style: solid; }

If an p215 p1227 p1227 p1227 hr element has either a color attribute or a noshade attribute, and furthermore also has a size attribute, and parsing that attribute's value using the p69 rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the parsed value divided by two as a pixel length for p1188 presentational hints for the properties 'border-top-width',

'border-right-width', 'border-bottom-width', and 'border-left-width' on the element.

Otherwise, if an p215 p1227 p1227 p1227 hr element has neither a color attribute nor a noshade attribute, but does have a size attribute, and parsing that attribute's value using the p69 rules for parsing non-negative integers doesn't generate an error, then: if the parsed value is one, then the user agent is expected to use the attribute as a p1188 presentational hint setting the element's 'border-bottom-width' to 0; otherwise, if the parsed value is greater than one, then the user agent is expected to use the parsed value minus two as a pixel length for p1188 presentational hints for the 'height' property on the element.

1202

The p1227 p215 p1189 width attribute on an hr element maps to the dimension property 'width' on the element.

When an p215 p1227 p86 hr element has a color attribute, its value is expected to be parsed using the rules for parsing a legacy color value, and if that does not return an error, the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's

'color' property to the resulting color.



15.3.12 The p563 p566 p12 fieldset and legend elements §

03

CSS @namespace url(http://www.w3.org/1999/xhtml);

fieldset {

display: block;

margin-inline-start: 2px;

margin-inline-end: 2px;

border: groove 2px ThreeDFace;

padding-block-start: 0.35em;

padding-inline-end: 0.75em;

padding-block-end: 0.625em;

padding-inline-start: 0.75em;

min-inline-size: min-content;

}

legend {

padding-inline-start: 2px; padding-inline-end: 2px;

}

legend[align=left i] {

justify-self: left;

}

legend[align=center i] {

justify-self: center;

}

legend[align=right i] {

justify-self: right;

}

The p563 fieldset element, when it generates a CSS box, is expected to act as follows:

• The element is expected to establish a new block formatting context.

• The 'display' property is expected to act as follows:

◦ If the computed value of 'display' is a value such that the outer display type is 'inline', then behave as 'inline-

block'.

◦ Otherwise, behave as 'flow-root'.

Note

This does not change the computed value.

• If the element's box has a child box that matches the conditions in the list below, then the first such child box is the 'fieldset'

element's rendered legend:

◦ The child is a p566 legend element.

◦ The child's used value of 'float' is 'none'.

◦ The child's used value of 'position' is not 'absolute' or 'fixed'.

• If the element has a p1203 rendered legend, then the border is expected to not be painted behind the rectangle defined as

follows, using the writing mode of the fieldset:

1. The block-start edge of the rectangle is the smaller of the block-start edge of the p1203 rendered legend's margin

1203

rectangle at its static position (ignoring transforms), and the block-start outer edge of the p563 fieldset's border.

2. The block-end edge of the rectangle is the larger of the block-end edge of the p1203 rendered legend's margin

rectangle at its static position (ignoring transforms), and the block-end outer edge of the p563 fieldset's border.

3. The inline-start edge of the rectangle is the smaller of the inline-start edge of the p1203 rendered legend's border

rectangle at its static position (ignoring transforms), and the inline-start outer edge of the p563 fieldset's border.

4. The inline-end edge of the rectangle is the larger of the inline-end edge of the p1203 rendered legend's border

rectangle at its static position (ignoring transforms), and the inline-end outer edge of the p563 fieldset 's border.

• The space allocated for the element's border on the block-start side is expected to be the element's 'border-block-start-width'

or the p1203 p563 rendered legend 's margin box size in the fieldset's block-flow direction, whichever is greater.

• For the purpose of calculating the used 'block-size', if the computed 'block-size' is not 'auto', the space allocated for the

rendered legend p1203's margin box that spills out past the border, if any, is expected to be substracted from the 'block-size'. If the content box's block-size would be negative, then let the content box's block-size be zero instead.

• If the element has a p1203 rendered legend, then that element is expected to be the first child box.

• The p1204 p1203 anonymous fieldset content box is expected to appear after the rendered legend and is expected to contain the

content (including the '::before' and '::after' pseudo-elements) of the p563 fieldset element except for the rendered

legend p1203, if there is one.

• The used value of the 'padding-top', 'padding-right', 'padding-bottom', and 'padding-left' properties are expected to be zero.

• For the purpose of calculating the min-content inline size, use the greater of the min-content inline size of the rendered

legend p1203 p1204 and the min-content inline size of the anonymous fieldset content box.

• For the purpose of calculating the max-content inline size, use the greater of the max-content inline size of the rendered

legend p1203 p1204 and the max-content inline size of the anonymous fieldset content box.

A p563 p1203 fieldset element's rendered legend, if any, is expected to act as follows:

• The element is expected to establish a new formatting context for its contents. The type of this formatting context is

determined by its 'display' value, as usual.

• The 'display' property is expected to behave as if its computed value was blockified.

Note

This does not change the computed value.

• If the computed value of 'inline-size' is 'auto', then the used value is the fit-content inline size.

• The element is expected to be positioned in the inline direction as is normal for blocks (e.g., taking into account margins and

the 'justify-self' property).

• The element's box is expected to be constrained in the inline direction by the inline content size of the p563 fieldset as if it

had used its computed inline padding.

Example

For example, if the p563 p1203 fieldset has a specified padding of 50px, then the rendered legend will be positioned 50px in

from the p563 p1204 fieldset 's border. The padding will further apply to the anonymous fieldset content box instead of the

fieldset p563 element itself.

• The element is expected to be positioned in the block-flow direction such that its border box is centered over the border on

the block-start side of the p563 fieldset element.

A p563 fieldset element's anonymous fieldset content box is expected to act as follows:

• The 'display' property is expected to act as follows:

◦ If the computed value of p563 'display' on the fieldset element is 'grid' or 'inline-grid', then set the used value to

'grid'.

◦ If the computed value of p563 'display' on the fieldset element is 'flex' or 'inline-flex', then set the used value to

'flex'.

1204

◦ Otherwise, set the used value to 'flow-root'.

• The following properties are expected to inherit from the p563 fieldset element:

◦ 'align-content'

◦ 'align-items'

◦ 'border-radius'

◦ 'column-count'

◦ 'column-fill'

◦ 'column-gap'

◦ 'column-rule'

◦ 'column-width'

◦ 'flex-direction'

◦ 'flex-wrap'

◦ 'grid-auto-columns'

◦ 'grid-auto-flow'

◦ 'grid-auto-rows'

◦ 'grid-column-gap'

◦ 'grid-row-gap'

◦ 'grid-template-areas'

◦ 'grid-template-columns'

◦ 'grid-template-rows'

◦ 'justify-content'

◦ 'justify-items'

◦ 'overflow'

◦ 'padding-bottom'

◦ 'padding-left'

◦ 'padding-right'

◦ 'padding-top'

◦ 'text-overflow'

◦ 'unicode-bidi'

• The 'block-size' property is expected to be set to '100%'.

• For the purpose of calculating percentage padding, act as if the padding was calculated for the p563 fieldset element.

Note



fieldset's margin



padding legend's margin

legend



anonymous fieldset content box

padding

content



The legend is rendered over the top border, and the top border area reserves vertical space for the legend. The fieldset's top

margin starts at the top margin edge of the legend. The legend's horizontal margins, or the 'justify-self' property, gives its

horizontal position. The p1204 anonymous fieldset content box appears below the legend.



15.4 Replaced elements p12 §

05

Note

The following elements can be p384 p635 p369 p362 p321 p494 p373 replaced elements : audio , canvas , embed , iframe , img , input , object , and

1205

video p380 .



15.4.1 Embedded content p12 §

06

The p369 p362 p380 embed , iframe , and video elements are expected to be treated as replaced elements.

A p635 p124 p133 canvas element that represents embedded content is expected to be treated as a replaced element; the contents of such

elements are the element's bitmap, if any, or else a transparent black bitmap with the same intrinsic dimensions as the element. Other

canvas p635 elements are expected to be treated as ordinary elements in the rendering model.

An p373 p124 p817 object element that represents an image, plugin, or its nested browsing context is expected to be treated as a replaced

element p373 . Other object elements are expected to be treated as ordinary elements in the rendering model.

The p384 p437 audio element, when it is exposing a user interface, is expected to be treated as a replaced element about one line high, as wide as is necessary to expose the user agent's user interface features. When an p384 audio element is not exposing a user

interface p437, the user agent is expected to force its 'display' property to compute to 'none', irrespective of CSS rules.

Whether a p380 p437 video element is exposing a user interface is not expected to affect the size of the rendering; controls are expected to be overlaid above the page content without causing any layout changes, and are expected to disappear when the user does not need them.

When a p380 video element represents a poster frame or frame of video, the poster frame or frame of video is expected to be rendered at the largest size that maintains the aspect ratio of that poster frame or frame of video without being taller or wider than the

video p380 p380 element itself, and is expected to be centered in the video element.

Any subtitles or captions are expected to be overlayed directly on top of their p380 video element, as defined by the relevant rendering rules; for WebVTT, those are the p1282 rules for updating the display of WebVTT text tracks . [WEBVTT]

When the user agent starts p437 p380 exposing a user interface for a video element, the user agent should run the rules for updating the

text track rendering p423 p422 p380 p422 p423 of each of the text tracks in the video element's list of text tracks that are showing and whose

text track kind p422 p422 p422 p422 is one of subtitles or captions (e.g., for text tracks based on WebVTT, the rules for updating the display

of WebVTT text tracks p1282 ). [WEBVTT]

Note

Resizing p380 p635 video and canvas elements does not interrupt video playback or clear the canvas.



The following CSS rules are expected to apply:

CSS @namespace url(http://www.w3.org/1999/xhtml);

iframe { border: 2px inset; }

video { object-fit: contain; }



15.4.2 Images p12 §

06

User agents are expected to render p321 p494 p496 p519 img elements and input elements whose type attributes are in the Image Button state, according to the first applicable rules from the following list:

↪ p124 If the element represents an image

The user agent is expected to treat the element as a replaced element and render the image according to the rules for doing so defined in CSS.

↪ p124 If the element does not represent an image and either:

• the user agent has reason to believe that the image will become p337 available and be rendered in due course, or • the element has no alt attribute, or

1206

• the p115 Document is in quirks mode, and the element already has intrinsic dimensions (e.g., from the dimension

attributes p450 or CSS rules)

The user agent is expected to treat the element as a replaced element whose content is the text that the element represents, if

any, optionally alongside an icon indicating that the image is being obtained (if applicable). For p494 input elements, the element

is expected to appear button-like to indicate that the element is a p487 button.

↪ p321 p124 If the element is an img element that represents some text and the user agent does not expect this to change

The user agent is expected to treat the element as a non-replaced phrasing element whose content is the text, optionally with an icon indicating that an image is missing, so that the user can request the image be displayed or investigate why it is not rendering. In non-graphical contexts, such an icon should be omitted.

↪ p321 p124 If the element is an img element that represents nothing and the user agent does not expect this to change

The user agent is expected to treat the element as a replaced element whose intrinsic dimensions are 0. (In the absence of further styles, this will cause the element to essentially not be rendered.)

↪ p494 p124 If the element is an input element that does not represent an image and the user agent does not expect this

to change

The user agent is expected to treat the element as a replaced element consisting of a button whose content is the element's

alternative text. The intrinsic dimensions of the button are expected to be about one line in height and whatever width is necessary to render the text on one line.

The icons mentioned above are expected to be relatively small so as not to disrupt most text but be easily clickable. In a visual environment, for instance, icons could be 16 pixels by 16 pixels square, or 1em by 1em if the images are scalable. In an audio environment, the icon could be a short bleep. The icons are intended to indicate to the user that they can be used to get to whatever options the UA provides for images, and, where appropriate, are expected to provide access to the context menu that would have come up if the user interacted with the actual image.



All animated images with the same absolute URL and the same image data are expected to be rendered synchronized to the same timeline as a group, with the timeline starting at the time of the least recent addition to the group.

Note

In other words, when a second image with the same absolute URL and animated image data is inserted into a document, it jumps

to the point in the animation cycle that is currently being displayed by the first image.

When a user agent is to p321 restart the animation for an img element showing an animated image, all animated images with the same p321 absolute URL and the same image data in that img element's node document are expected to restart their animation from the beginning.



The following CSS rules are expected to apply when the p115 Document is in quirks mode:

CSS @namespace url(http://www.w3.org/1999/xhtml);

img[align=left i] { margin-right: 3px; }

img[align=right i] { margin-left: 3px; }



15.4.3 Attributes for embedded content and images p12 §

07

The following CSS rules are expected to apply as p1188 presentational hints:

CSS @namespace url(http://www.w3.org/1999/xhtml);

iframe[frameborder='0'], iframe[frameborder=no i] { border: none; }

embed[align=left i], iframe[align=left i], img[align=left i], input[type=image i][align=left i], object[align=left i] {

float: left;

}

1207

embed[align=right i], iframe[align=right i], img[align=right i], input[type=image i][align=right i], object[align=right i] {

float: right;

}

embed[align=top i], iframe[align=top i], img[align=top i], input[type=image i][align=top i], object[align=top i] {

vertical-align: top;

}

embed[align=baseline i], iframe[align=baseline i], img[align=baseline i], input[type=image i][align=baseline i], object[align=baseline i] {

vertical-align: baseline;

}

embed[align=texttop i], iframe[align=texttop i], img[align=texttop i], input[type=image i][align=texttop i], object[align=texttop i] {

vertical-align: text-top;

}

embed[align=absmiddle i], iframe[align=absmiddle i], img[align=absmiddle i], input[type=image i][align=absmiddle i], object[align=absmiddle i], embed[align=abscenter i], iframe[align=abscenter i], img[align=abscenter i], input[type=image i][align=abscenter i], object[align=abscenter i] {

vertical-align: middle;

}

embed[align=bottom i], iframe[align=bottom i], img[align=bottom i], input[type=image i][align=bottom i], object[align=bottom i] {

vertical-align: bottom;

}

When an p369 p362 p321 p373 p494 p496 embed , iframe , img , or object element, or an input element whose type attribute is in the Image

Button p519 state, has an align attribute whose value is an ASCII case-insensitive match for the string "center" or the string "middle", the user agent is expected to act as if the element's 'vertical-align' property was set to a value that aligns the vertical middle of the element with the parent element's baseline.

The p369 p321 p373 p494 p496 hspace attribute of embed , img , or object elements, and input elements with a type attribute in the Image

Button p519 p1189 state, maps to the dimension properties 'margin-left' and 'margin-right' on the element.

The p369 p321 p373 p494 p496 vspace attribute of embed , img , or object elements, and input elements with a type attribute in the Image

Button p519 p1189 state, maps to the dimension properties 'margin-top' and 'margin-bottom' on the element.

When an p321 p373 p494 p496 p519 img element, object element, or input element with a type attribute in the Image Button state has a border p69 attribute whose value, when parsed using the rules for parsing non-negative integers, is found to be a number greater than zero, the user agent is expected to use the parsed value for eight p1188 presentational hints: four setting the parsed value as a pixel length for the element's 'border-top-width', 'border-right-width', 'border-bottom-width', and 'border-left-width' properties, and four setting the element's 'border-top-style', 'border-right-style', 'border-bottom-style', and 'border-left-style' properties to the value 'solid'.

The p450 p450 p369 p362 p321 p373 p380 p494 width and height attributes on embed , iframe , img , object or video elements, and input elements with a p496 p519 type attribute in the Image Button state and that either represents an image or that the user expects will eventually represent an image, p1189 map to the dimension properties 'width' and 'height' on the element respectively.

The p321 intrinsic aspect ratio for an img element img is computed as follows:

1. If p337 p337 img 's current request is available and has an intrinsic aspect ratio, then use that intrinsic aspect ratio.

2. If p450 p450 p71 img 's width and height attribute values, when parsed using the rules for parsing dimension values, are both not

an error, not a percentage, and non-zero, then use the ratio resulting from dividing the p450 width attribute value by the

height p450 attribute value.

3. Otherwise, img has no intrinsic aspect ratio.

1208

15.4.4 Image maps p12 §

09

Shapes on an p446 p444 image map are expected to act, for the purpose of the CSS cascade, as elements independent of the original area

element that happen to match the same style rules but inherit from the p321 p373 img or object element.

For the purposes of the rendering, only the 'cursor' property is expected to have any effect on the shape.

Example

Thus, for example, if an p444 p145 area element has a style attribute that sets the 'cursor' property to 'help', then when the user

designates that shape, the cursor would change to a Help cursor.



Example

Similarly, if an p444 area element had a CSS rule that set its 'cursor' property to 'inherit' (or if no rule setting the 'cursor' property

matched the element at all), the shape's cursor would be inherited from the p321 p373 p446 img or object element of the image map,

not from the parent of the p444 area element.



15.5 Widgets p12 §

09

15.5.1 Introduction p12 §

09

The elements defined in this section can be rendered in a variety of manners, within the guidelines provided below. User agents are encouraged to set the 'appearance' CSS property appropriately to achieve platform-native appearances for widgets, and are expected to implement any relevant animations, etc, that are appropriate for the platform.



15.5.2 Button layout p12 §

09

Button layout is as follows:

• The 'display' property is expected to act as follows:

◦ If the computed value of 'display' is 'inline-grid', 'grid', 'inline-flex', or 'flex', then behave as the computed value.

◦ Otherwise, if the computed value of 'display' is a value such that the outer display type is 'inline', then behave as

'inline-block'.

◦ Otherwise, behave as 'flow-root'.

• The element is expected to establish a new formatting context for its contents. The type of this formatting context is

determined by its 'display' value, as usual.

• If the element is absolutely positioned, then for the purpose of the CSS visual formatting model, act as if the element is a

replaced element p1275 . [CSS]

• If the computed value of 'inline-size' is 'auto', then the used value is the fit-content inline size.

• For the purpose of the 'normal' keyword of the 'align-self' property, act as if the element is a replaced element.

• If the element is an p494 p536 input element, or if it is a button element and its computed value for 'display' is not 'inline-grid',

'grid', 'inline-flex', or 'flex', then the element's box has a child anonymous button content box with the following behaviors:

◦ The box is a block-level block container that establishes a new block formatting context (i.e., 'display' is 'flow-root').

◦ If the box does not overflow in the horizontal axis, then it is centered horizontally.

◦ If the box does not overflow in the vertical axis, then it is centered vertically.

Otherwise, there is no p1209 anonymous button content box.



1209

15.5.3 The p536 p12 button element §

10

The p536 p1209 button element, when it generates a CSS box , is expected to depict a button and to use button layout whose anonymous

button content box p1209 p1209 's contents (if there is an anonymous button content box) are the child boxes the element's box would otherwise have.



15.5.4 The p605 p608 p12 details and summary elements §

10

CSS @namespace url(http://www.w3.org/1999/xhtml);

summary {

display: list-item;

counter-increment: list-item 0;

list-style: disclosure-closed inside;

}

details[open] > summary {

list-style-type: disclosure-open;

}

The p605 details element is expected to render as a block box. The element is also expected to have an internal shadow tree with two

slots p605 p608 . The first slot is expected to take the details element's first summary element child, if any. The second slot is expected to take the p605 details element's remaining descendants, if any.

The p605 p608 details element's first summary element child, if any, is expected to allow the user to request the details be shown or hidden.

The p605 p605 details element's second slot is expected to be removed from the rendering when the details element does not have an

open p605 attribute.



15.5.5 The p494 p12 input element as a text entry widget §

10

An p494 p496 p500 p500 p501 p502 p503 input element whose type attribute is in the Text , Search , Telephone , URL , or Email state, is expected to render as an 'inline-block' box depicting a text control. Additionally, the 'line-height' property, if it has a computed value equivalent to a value that is less than 1.0, must have a used value of 1.0.

An p494 p496 p504 input element whose type attribute is in the Password state is expected to render as an 'inline-block' box depicting a text control that obscures data entry.

If these text controls provide a text selection, then, when the user changes the current selection, the user agent is expected to queue

an element task p933 p939 p494 p1272 on the user interaction task source given the input element to fire an event named select at the element, with the bubbles attribute initialized to true.

If an p494 p496 p523 input element whose type attribute is in one of the above states has a size attribute, and parsing that attribute's value using the p69 rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a

presentational hint p1188 for the 'width' property on the element, with the value obtained from applying the converting a character width

to pixels p1210 algorithm to the value of the attribute.

If an p494 p496 p523 input element whose type attribute is in one of the above states does not have a size attribute, then the user agent is expected to act as if it had a user-agent-level style sheet rule setting the 'width' property on the element to the value obtained from applying the p1210 converting a character width to pixels algorithm to the number 20.

The converting a character width to pixels algorithm returns (size-1)×avg + max, where size is the character width to convert, avg is the average character width of the primary font for the element for which the algorithm is being run, in pixels, and max is the maximum character width of that same font, also in pixels. (The element's 'letter-spacing' property does not affect the result.)



1210

15.5.6 The p494 p12 input element as domain-specific widgets §

11

An p494 p496 p505 input element whose type attribute is in the Date state is expected to render as an 'inline-block' box depicting a date control.

An p494 p496 p506 input element whose type attribute is in the Month state is expected to render as an 'inline-block' box depicting a month control.

An p494 p496 p507 input element whose type attribute is in the Week state is expected to render as an 'inline-block' box depicting a week control.

An p494 p496 p508 input element whose type attribute is in the Time state is expected to render as an 'inline-block' box depicting a time control.

An p494 p496 p509 input element whose type attribute is in the Local Date and Time state is expected to render as an 'inline-block' box depicting a local date and time control.

An p494 p496 p510 input element whose type attribute is in the Number state is expected to render as an 'inline-block' box depicting a number control.

These controls are all expected to be about one line high, and about as wide as necessary to show the widest possible value.



15.5.7 The p494 p12 input element as a range control §

11

An p494 p496 p511 input element whose type attribute is in the Range state is expected to render as an 'inline-block' box depicting a slider control.

When the control is wider than it is tall (or square), the control is expected to be a horizontal slider, with the lowest value on the right if the 'direction' property on this element has a computed value of 'rtl', and on the left otherwise. When the control is taller than it is wide, it is expected to be a vertical slider, with the lowest value on the bottom.

Predefined suggested values (provided by the p529 list attribute) are expected to be shown as tick marks on the slider, which the slider can snap to.

User agents are expected to use the used value of the 'direction' property on the element to determine the direction in which the slider operates. Typically, a left-to-right ('ltr') horizontal control would have the lowest value on the left and the highest value on the right, and vice versa.



15.5.8 The p494 p12 input element as a color well §

11

An p494 p496 p514 input element whose type attribute is in the Color state is expected to depict a color well, which, when activated, provides the user with a color picker (e.g. a color wheel or color palette) from which the color can be changed. The element, when it generates a p1209 p1209 CSS box , is expected to use button layout , that has no child boxes of the anonymous button content box. The

anonymous button content box p1209 p1188 is expected to have a presentational hint setting the 'background-color' property to the element's p567 value.

Predefined suggested values (provided by the p529 list attribute) are expected to be shown in the color picker interface, not on the color well itself.



15.5.9 The p494 p12 input element as a checkbox and radio button widgets §

11

An p494 p496 p514 input element whose type attribute is in the Checkbox state is expected to render as an 'inline-block' box containing a single checkbox control, with no label.

An p494 p496 p515 input element whose type attribute is in the Radio Button state is expected to render as an 'inline-block' box containing a single radio button control, with no label.



1211

15.5.10 The p494 p12 input element as a file upload control §

12

An p494 p496 p516 input element whose type attribute is in the File Upload state, when it generates a CSS box, is expected to render as an

'inline-block' p516 box containing a span of text giving the file name(s) of the selected files, if any, followed by a button that, when activated, provides the user with a file picker from which the selection can be changed. The button is expected to use button

layout p1209 p1209 and the contents of the anonymous button content box are expected to be implementation-defined (and possibly locale-specific) text, for example "Choose file".



15.5.11 The p494 p12 input element as a button §

12

An p494 p496 p519 p521 p522 input element whose type attribute is in the Submit Button , Reset Button , or Button state, when it generates a

CSS box p1209 p1209 , is expected to depict a button and use button layout and the contents of the anonymous button content box are expected to be the text of the element's p498 p496 value attribute, if any, or text derived from the element's type attribute in an

implementation-defined (and probably locale-specific) fashion, if not.



15.5.12 The p1228 p12 marquee element §

12

CSS @namespace url(http://www.w3.org/1999/xhtml);

marquee {

display: inline-block;

text-align: initial;

}

The p1228 p1229 marquee element, while turned on, is expected to render in an animated fashion according to its attributes as follows: If the element's p1229 p1229 behavior attribute is in the scroll state

Slide the contents of the element in the direction described by the p1229 direction attribute as defined below, such that it begins off

the start side of the p1228 marquee, and ends flush with the inner end side.

Example

For example, if the p1229 p1229 direction attribute is left (the default), then the contents would start such that their left edge are

off the side of the right edge of the p1228 marquee's content area, and the contents would then slide up to the point where the left

edge of the contents are flush with the left inner edge of the p1228 marquee's content area.

Once the animation has ended, the user agent is expected to p1230 increment the marquee current loop index. If the element is still

turned on p1229 after this, then the user agent is expected to restart the animation.

If the element's p1229 p1229 behavior attribute is in the slide state

Slide the contents of the element in the direction described by the p1229 direction attribute as defined below, such that it begins off

the start side of the p1228 p1228 marquee , and ends off the end side of the marquee.

Example

For example, if the p1229 p1229 direction attribute is left (the default), then the contents would start such that their left edge are

off the side of the right edge of the p1228 marquee's content area, and the contents would then slide up to the point where the

right p1228 edge of the contents are flush with the left inner edge of the marquee's content area.

Once the animation has ended, the user agent is expected to p1230 increment the marquee current loop index. If the element is still

turned on p1229 after this, then the user agent is expected to restart the animation.

If the element's p1229 p1229 behavior attribute is in the alternate state

When the p1230 marquee current loop index is even (or zero), slide the contents of the element in the direction described by the

direction p1229 p1228 attribute as defined below, such that it begins flush with the start side of the marquee, and ends flush with the

end side of the p1228 marquee.

When the p1230 marquee current loop index is odd, slide the contents of the element in the opposite direction than that described by

1212

the p1229 p1228 direction attribute as defined below, such that it begins flush with the end side of the marquee, and ends flush with the

start side of the p1228 marquee.

Example

For example, if the p1229 p1229 direction attribute is left (the default), then the contents would with their right edge flush with the

right inner edge of the p1228 marquee's content area, and the contents would then slide up to the point where the left edge of the

contents are flush with the left inner edge of the p1228 marquee's content area.

Once the animation has ended, the user agent is expected to p1230 increment the marquee current loop index. If the element is still

turned on p1229 after this, then the user agent is expected to continue the animation.

The p1229 direction attribute has the meanings described in the following table:

direction p1229 attribute state Direction of animation Start edge End edge Opposite direction

left p1229 ← Right to left Right Left → Left to Right

right p1229 → Left to Right Left Right ← Right to left

up p1229 ↑ Up (Bottom to Top) Bottom Top ↓ Down (Top to Bottom)

down p1229 ↓ Down (Top to Bottom) Top Bottom ↑ Up (Bottom to Top)

In any case, the animation should proceed such that there is a delay given by the p1229 marquee scroll interval between each frame, and such that the content moves at most the distance given by the p1230 marquee scroll distance with each frame.

When a p1228 marquee element has a bgcolor attribute set, the value is expected to be parsed using the rules for parsing a legacy color

value p86 p1188 , and if that does not return an error, the user agent is expected to treat the attribute as a presentational hint setting the element's 'background-color' property to the resulting color.

The p1228 p1189 width and height attributes on a marquee element map to the dimension properties 'width' and 'height' on the element respectively.

The p1228 p1229 p1229 p1229 intrinsic height of a marquee element with its direction attribute in the up or down states is 200 CSS pixels.

The p1228 p1189 vspace attribute of a marquee element maps to the dimension properties 'margin-top' and 'margin-bottom' on the element. The p1228 p1189 hspace attribute of a marquee element maps to the dimension properties 'margin-left' and 'margin-right' on the element.

The p1228 'overflow' property on the marquee element is expected to be ignored; overflow is expected to always be hidden.



15.5.13 The p558 p12 meter element §

13

The p558 meter element is expected to render as an 'inline-block' box with a 'height' of '1em' and a 'width' of '5em', a 'vertical-align' of '-0.2em', and with its contents depicting a gauge.

When the element is wider than it is tall (or square), the depiction is expected to be of a horizontal gauge, with the minimum value on the right if the 'direction' property on this element has a computed value of 'rtl', and on the left otherwise. When the element is taller than it is wide, it is expected to depict a vertical gauge, with the minimum value on the bottom.

User agents are expected to use a presentation consistent with platform conventions for gauges, if any.

Note

Requirements for what must be depicted in the gauge are included in the definition of the p558 meter element.



15.5.14 The p556 p12 progress element §

13

The p556 progress element is expected to render as an 'inline-block' box with a 'height' of '1em' and a 'width' of '10em', and a 'vertical-

align' of '-0.2em'.



1213



When the element is wider than it is tall, the element is expected to be depicted as a horizontal progress bar, with the start on the right and the end on the left if the 'direction' property on this element has a computed value of 'rtl', and with the start on the left and the end on the right otherwise. When the element is taller than it is wide, it is expected to be depicted as a vertical progress bar, with the lowest value on the bottom. When the element is square, it is expected to be depicted as a direction-independent progress widget (e.g. a circular progress ring).

User agents are expected to use a presentation consistent with platform conventions for progress bars. In particular, user agents are expected to use different presentations for determinate and indeterminate progress bars. User agents are also expected to vary the presentation based on the dimensions of the element.

Example

For example, on some platforms for showing indeterminate progress there is a "spinner" progress indicator with square

dimensions, which could be used when the element is square, and an indeterminate progress bar, which could be used when the

element is wide.



Note

Requirements for how to determine if the progress bar is determinate or indeterminate, and what progress a determinate progress

bar is to show, are included in the definition of the p556 progress element.



15.5.15 The p538 p12 select element §

14

A p538 select element is either a list box or a drop-down box, depending on its attributes.

A p538 p540 p1214 select element whose multiple attribute is present is expected to render as a multi-select list box.

A p538 p540 p540 select element whose multiple attribute is absent, and whose display size is greater than 1, is expected to render as a single-select p1214 list box.

When the element renders as a p1214 list box, it is expected to render as an 'inline-block' box whose 'height' is the height necessary to contain as many rows for items as given by the element's p540 display size, or four rows if the attribute is absent, and whose 'width' is the p1214 width of the select 's labels plus the width of a scrollbar.

A p538 p540 p540 select element whose multiple attribute is absent, and whose display size is 1, is expected to render as a one-line drop-

down box p1214 p1214 whose width is the width of the select 's labels.

In either case ( p1214 p1214 p540 list box or drop-down box ), the element's items are expected to be the element's list of options , with the

element's p545 optgroup element children providing headers for groups of options where applicable.

An p545 p546 optgroup element is expected to be rendered by displaying the element's label attribute.

An p546 p547 p545 option element is expected to be rendered by displaying the element's label , indented under its optgroup element if it has one.

The p545 width of the select 's labels is the wider of the width necessary to render the widest optgroup, and the width necessary to render the widest p546 p540 option element in the element's list of options (including its indent, if any).

If a p538 p540 p546 select element contains a placeholder label option , the user agent is expected to render that option in a manner that conveys that it is a label, rather than a valid option of the control. This can include preventing the p540 placeholder label option from being explicitly selected by the user. When the p540 p548 placeholder label option 's selectedness is true, the control is expected to be displayed in a fashion that indicates that no valid option is currently selected.

User agents are expected to render the labels in a p538 select in such a manner that any alignment remains consistent whether the label is being displayed as part of the page or in a menu control.

1214

15.5.16 The p549 p12 textarea element §

15

The p549 textarea element is expected to render as an 'inline-block' box depicting a multiline text control. If this multiline text control provides a selection, then, when the user changes the current selection, the user agent is expected to p933 queue an element task on the p939 p549 p1272 user interaction task source given the textarea element to fire an event named select at the element, with the

bubbles attribute initialized to true.

If the element has a p551 p69 cols attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a p1188 presentational hint for the 'width' property on the element, with the value being the p1215 textarea effective width (as defined below). Otherwise, the user agent is expected to act as if it had a user-agent-level style sheet rule setting the p1215 'width' property on the element to the textarea effective width.

The p549 p551 textarea effective width of a textarea element is size × avg + sbw , where size is the element's character width, avg is the average character width of the primary font of the element, in CSS pixels, and sbw is the width of a scrollbar, in CSS pixels. (The

element's 'letter-spacing' property does not affect the result.) If the element has a p551 p69 rows attribute, and parsing that attribute's value using the rules for parsing non-negative integers doesn't generate an error, then the user agent is expected to use the attribute as a p1188 presentational hint for the 'height' property on the element, with the value being the p1215 textarea effective height (as defined below). Otherwise, the user agent is expected to act as if it had a user-agent-level style sheet rule setting the p1215 'height' property on the element to the textarea effective height.

The p549 textarea effective height of a textarea element is the height in CSS pixels of the number of lines specified the element's

character height p551, plus the height of a scrollbar in CSS pixels.

User agents are expected to apply the p549 'white-space' CSS property to textarea elements. For historical reasons, if the element has a

wrap p552 attribute whose value is an ASCII case-insensitive match for the string "off", then the user agent is expected to treat the attribute as a p1188 presentational hint setting the element's 'white-space' property to 'pre'.



15.6 Frames and framesets p12 §

15

User agent are expected to render p1230 frameset elements as a box with the height and width of the viewport, with a surface rendered according to the following layout algorithm:

1. The cols and rows variables are lists of zero or more pairs consisting of a number and a unit, the unit being one of

percentage, relative, and absolute.

Use the p73 rules for parsing a list of dimensions to parse the value of the element's cols attribute, if there is one. Let cols be the result, or an empty list if there is no such attribute.

Use the p73 rules for parsing a list of dimensions to parse the value of the element's rows attribute, if there is one. Let rows be the result, or an empty list if there is no such attribute.

2. For any of the entries in cols or rows that have the number zero and the unit relative, change the entry's number to one.

3. If cols has no entries, then add a single entry consisting of the value 1 and the unit relative to cols.

If rows has no entries, then add a single entry consisting of the value 1 and the unit relative to rows.

4. Invoke the algorithm defined below to p1216 convert a list of dimensions to a list of pixel values using cols as the input list, and

the width of the surface that the p1230 frameset is being rendered into, in CSS pixels, as the input dimension. Let sized cols be the resulting list.

Invoke the algorithm defined below to p1216 convert a list of dimensions to a list of pixel values using rows as the input list,

and the height of the surface that the p1230 frameset is being rendered into, in CSS pixels, as the input dimension. Let sized rows be the resulting list.

5. Split the surface into a grid of w×h rectangles, where w is the number of entries in sized cols and h is the number of entries

in sized rows.

Size the columns so that each column in the grid is as many CSS pixels wide as the corresponding entry in the sized cols list.

Size the rows so that each row in the grid is as many CSS pixels high as the corresponding entry in the sized rows list.

6. Let p1231 p1230 p1230 children be the list of frame and frameset elements that are children of the frameset element for which the

1215

algorithm was invoked.

7. For each row of the grid of rectangles created in the previous step, from top to bottom, run these substeps:

1. For each rectangle in the row, from left to right, run these substeps:

1. If there are any elements left in children, take the first element in the list, and assign it to the rectangle.

If this is a p1230 p1230 frameset element, then recurse the entire frameset layout algorithm for that

frameset p1230 element, with the rectangle as the surface.

Otherwise, it is a p1231 p817 frame element; render its nested browsing context, positioned and sized to fit the rectangle.

2. If there are any elements left in children, remove the first element from children.

8. If the p1230 p1216 frameset element has a border, draw an outer set of borders around the rectangles, using the element's frame

border color p1216.

For each rectangle, if there is an element assigned to that rectangle, and that element p1216 has a border, draw an inner set of

borders around that rectangle, using the element's p1216 frame border color.

For each (visible) border that does not abut a rectangle that is assigned a p1231 frame element with a noresize attribute

(including rectangles in further nested p1230 frameset elements), the user agent is expected to allow the user to move the

border, resizing the rectangles within, keeping the proportions of any nested p1230 frameset grids.

A p1230 p1231 frameset or frame element has a border if the following algorithm returns true:

1. If the element has a frameborder attribute whose value is not the empty string and whose first character is either

a U+0031 DIGIT ONE (1) character, a U+0079 LATIN SMALL LETTER Y character (y), or a U+0059 LATIN CAPITAL LETTER Y character (Y), then return true.

2. Otherwise, if the element has a frameborder attribute, return false.

3. Otherwise, if the element has a parent element that is a p1230 frameset element, then return true if that element

has a border p1216, and false if it does not.

4. Otherwise, return true.

The p1230 p1231 frame border color of a frameset or frame element is the color obtained from the following algorithm:

1. If the element has a p86 bordercolor attribute, and applying the rules for parsing a legacy color value to that

attribute's value does not result in an error, then return the color so obtained.

2. Otherwise, if the element has a parent element that is a p1230 frameset element, then return the frame border

color p1216 of that element.

3. Otherwise, return gray.

The algorithm to convert a list of dimensions to a list of pixel values consists of the following steps:

1. Let input list be the list of numbers and units passed to the algorithm.

Let output list be a list of numbers the same length as input list, all zero.

Entries in output list correspond to the entries in input list that have the same position.

2. Let input dimension be the size passed to the algorithm.

3. Let count percentage be the number of entries in input list whose unit is percentage.

Let total percentage be the sum of all the numbers in input list whose unit is percentage.

Let count relative be the number of entries in input list whose unit is relative.

Let total relative be the sum of all the numbers in input list whose unit is relative.

Let count absolute be the number of entries in input list whose unit is absolute.

Let total absolute be the sum of all the numbers in input list whose unit is absolute.

1216

Let remaining space be the value of input dimension.

4. If total absolute is greater than remaining space, then for each entry in input list whose unit is absolute, set the

corresponding value in output list to the number of the entry in input list multiplied by remaining space and divided by total absolute. Then, set remaining space to zero.

Otherwise, for each entry in input list whose unit is absolute, set the corresponding value in output list to the number of the entry in input list. Then, decrement remaining space by total absolute.

5. If total percentage multiplied by the input dimension and divided by 100 is greater than remaining space, then for each entry

in input list whose unit is percentage, set the corresponding value in output list to the number of the entry in input list multiplied by remaining space and divided by total percentage. Then, set remaining space to zero.

Otherwise, for each entry in input list whose unit is percentage, set the corresponding value in output list to the number of the entry in input list multiplied by the input dimension and divided by 100. Then, decrement remaining space by total percentage multiplied by the input dimension and divided by 100.

6. For each entry in input list whose unit is relative, set the corresponding value in output list to the number of the entry in

input list multiplied by remaining space and divided by total relative.

7. Return output list.

User agents working with integer values for frame widths (as opposed to user agents that can lay frames out with subpixel accuracy) are expected to distribute the remainder first to the last entry whose unit is relative, then equally (not proportionally) to each entry whose unit is percentage, then equally (not proportionally) to each entry whose unit is absolute, and finally, failing all else, to the last entry.



The contents of a p1231 p1230 frame element that does not have a frameset parent are expected to be rendered as transparent black; the

user agent is expected to not render its p817 p817 nested browsing context in this case, and its nested browsing context is expected to have a viewport with zero width and zero height.



15.7 Interactive media p12 §

17

15.7.1 Links, forms, and navigation p12 §

17

User agents are expected to allow the user to control aspects of p284 p596 hyperlink activation and form submission , such as which

browsing context p814 p876 is to be used for the subsequent navigation .

User agents are expected to allow users to discover the destination of p284 p487 hyperlinks and of forms before triggering their

navigation p876 .

User agents are expected to inform the user of whether a p284 p294 hyperlink includes hyperlink auditing, and to let them know at a minimum which domains will be contacted as part of such auditing.

User agents may allow users to p876 p814 p89 p248 navigate browsing contexts to the URLs indicated by the cite attributes on q ,

blockquote p219 p312 p313 , ins , and del elements.

User agents may surface p284 p158 hyperlinks created by link elements in their user interface.

Note

While p158 p284 p728 p728 link elements that create hyperlinks will match the :link or :visited pseudo-classes, will react to clicks if

visible, and so forth, this does not extend to any browser interface constructs that expose those same links. Activating a link

through the browser's interface, rather than in the page itself, does not trigger click events and the like.



15.7.2 The p140 p12 title attribute §

17

User agents are expected to expose the p140 advisory information of elements upon user request, and to make the user aware of the presence of such information.

1217

On interactive graphical systems where the user can use a pointing device, this could take the form of a tooltip. When the user is unable to use a pointing device, then the user agent is expected to make the content available in some other fashion, e.g. by making the element a p773 p140 p774 focusable area and always displaying the advisory information of the currently focused element, or by showing the p140 advisory information of the elements under the user's finger on a touch device as the user pans around the screen.

U+000A LINE FEED (LF) characters are expected to cause line breaks in the tooltip; U+0009 CHARACTER TABULATION (tab) characters are expected to render as a nonzero horizontal shift that lines up the next glyph with the next tab stop, with tab stops occurring at points that are multiples of 8 times the width of a U+0020 SPACE character.

Example

For example, a visual user agent could make elements with a p140 p775 p774 title attribute focusable , and could make any focused

element with a p140 title attribute show its tooltip under the element while the element has focus. This would allow a user to tab

around the document to find all the advisory text.



Example

As another example, a screen reader could provide an audio cue when reading an element with a tooltip, with an associated key to

read the last tooltip for which a cue was played.



15.7.3 Editing hosts p12 §

18

The current text editing caret (i.e. the p792 active range , if it is empty and in an editing host), if any, is expected to act like an inline

replaced element with the vertical dimensions of the caret and with zero width for the purposes of the CSS rendering model.

Note

This means that even an empty block can have the caret inside it, and that when the caret is in such an element, it prevents

margins from collapsing through the element.



15.7.4 Text rendered in native user interfaces p12 §

18

User agents are expected to honor the Unicode semantics of text that is exposed in user interfaces, for example supporting the bidirectional algorithm in text shown in dialogs, title bars, popup menus, and tooltips. Text from the contents of elements is expected to be rendered in a manner that honors p143 the directionality of the element from which the text was obtained. Text from attributes is expected to be rendered in a manner that honours the p144 directionality of the attribute .

Example

Consider the following markup, which has Hebrew text asking for a programming language, the languages being text for which a

left-to-right direction is important given the punctuation in some of their names:





:תונכת תפש רחב

> select>

C++

C#

FreePascal

F#





If the p538 select element was rendered as a drop down box, a correct rendering would ensure that the punctuation was the same

both in the drop down, and in the box showing the current selection.



1218



Example

The directionality of attributes depends on the attribute and on the element's p143 dir attribute, as the following example

demonstrates. Consider this markup:





A



A



A





If the p469 abbr attributes are rendered, e.g. in a tooltip or other user interface, the first will have a left parenthesis (because the

direction is 'ltr'), the second will have a right parenthesis (because the direction is 'rtl'), and the third will have a right parenthesis

(because the direction is determined from the attribute value to be 'rtl').

However, if instead the attribute was not a p144 directionality-capable attribute, the results would be different:





A



A



A





In this case, if the user agent were to expose the data-abbr attribute in the user interface (e.g. in a debugging environment), the

last case would be rendered with a left parenthesis, because the direction would be determined from the element's contents.

A string provided by a script (e.g. the argument to p965 window.alert()) is expected to be treated as an independent set of one or more bidirectional algorithm paragraphs when displayed, as defined by the bidirectional algorithm, including, for instance, supporting the paragraph-breaking behavior of U+000A LINE FEED (LF) characters. For the purposes of determining the paragraph level of such text in the bidirectional algorithm, this specification does p1275 not provide a higher-level override of rules P2 and P3. [BIDI]

When necessary, authors can enforce a particular direction for a given paragraph by starting it with the Unicode U+200E LEFT-TO-RIGHT MARK or U+200F RIGHT-TO-LEFT MARK characters.

Example

Thus, the following script:

alert('\u05DC\u05DE\u05D3 HTML \u05D4\u05D9\u05D5\u05DD!')

...would always result in a message reading "!םויה HTML דמל" (not "דמל HTML םויה!"), regardless of the language of the user agent

interface or the direction of the page or any of its elements.



Example

For a more complex example, consider the following script:

/* Warning: this script does not handle right-to-left scripts correctly */ var s;



1219

if (s = prompt('What is your name?')) {

alert(s + '! Ok, Fred, ' + s + ', and Wilma will get the car.');

}

When the user enters "Kitty", the user agent would alert "Kitty! Ok, Fred, Kitty, and Wilma will get the car.".

However, if the user enters "مهفأ لا", then the bidirectional algorithm will determine that the direction of the paragraph is right-to-

left, and so the output will be the following unintended mess: ".and Wilma will get the car ,مهفأ لا ,Ok, Fred !مهفأ لا"

To force an alert that starts with user-provided text (or other text of unknown directionality) to render left-to-right, the string can be

prefixed with a U+200E LEFT-TO-RIGHT MARK character:

var s;

if (s = prompt('What is your name?')) {

alert('\u200E' + s + '! Ok, Fred, ' + s + ', and Wilma will get the car.');

}



15.8 Print media p12 §

20

User agents are expected to allow the user to request the opportunity to obtain a physical form (or a representation of a physical form) of a p115 p1280 Document . For example, selecting the option to print a page or convert it to PDF format. [PDF]

When the user actually p1220 p115 obtains a physical form (or a representation of a physical form) of a Document , the user agent is

expected to create a new rendering of the p115 Document for the print media.



15.9 Unstyled XML documents p12 §

20

HTML user agents may, in certain circumstances, find themselves rendering non-HTML documents that use vocabularies for which they lack any built-in knowledge. This section provides for a way for user agents to handle such documents in a somewhat useful manner.

While a p115 p1220 p1220 Document is an unstyled document , the user agent is expected to render an unstyled document view.

A p115 Document is an unstyled document while it matches the following conditions:

• The p115 Document has no author style sheets (whether referenced by HTTP headers, processing instructions, elements like

link p158 p175 , inline elements like style, or any other mechanism).

• None of the elements in the p115 p1188 Document have any presentational hints.

• None of the elements in the p115 Document have any style attributes.

• None of the elements in the p115 Document are in any of the following namespaces: HTML namespace, SVG namespace,

MathML namespace

• The p115 p773 Document has no focusable area (e.g. from XLink) other than the viewport.

• The p115 p284 Document has no hyperlinks (e.g. from XLink).

• There exists no p912 p912 p115 p904 script whose settings object specifies this Document as the responsible document.

• None of the elements in the p115 Document have any registered event listeners.

An unstyled document view is one where the DOM is not rendered according to CSS (which would, since there are no applicable styles in this context, just result in a wall of text), but is instead rendered in a manner that is useful for a developer. This could consist of just showing the p115 Document object's source, maybe with syntax highlighting, or it could consist of displaying just the DOM tree, or simply a message saying that the page is not a styled document.



1220

Note

If a p115 p1220 Document stops being an unstyled document, then the conditions above stop applying, and thus a user agent following

these requirements will switch to using the regular CSS rendering.



1221

16 Obsolete features p12 §

22

16.1 Obsolete but conforming features p12 §

22

Features listed in this section will trigger warnings in conformance checkers.

Authors should not specify a p1227 p321 border attribute on an img element. If the attribute is present, its value must be the string "0". CSS should be used instead.

Authors should not specify a p1224 p614 charset attribute on a script element. If the attribute is present, its value must be an ASCII case-

insensitive match for "utf-8". (This has no effect in a document that conforms to the requirements elsewhere in this standard of being encoded as UTF-8.)

Authors should not specify a p1226 p614 language attribute on a script element. If the attribute is present, its value must be an ASCII

case-insensitive p615 match for the string " JavaScript " and either the type attribute must be omitted or its value must be an ASCII

case-insensitive match for the string "text/javascript". The attribute should be entirely omitted instead (with the value

" p615 JavaScript ", it has no effect), or replaced with use of the type attribute.

Authors should not specify a value for the p615 p614 type attribute on script elements that is the empty string or a JavaScript MIME type

essence match. Instead, they should omit the attribute, which has the same effect.

Authors should not specify a p1226 p175 type attribute on a style element. If the attribute is present, its value must be an ASCII case-

insensitive p1273 match for " text/css".

Authors should not specify the p1224 p239 name attribute on a elements. If the attribute is present, its value must not be the empty string and must neither be equal to the value of any of the IDs in the element's tree other than the element's own ID, if any, nor be equal to

the value of any of the other p1224 p239 name attributes on a elements in the element's tree. If this attribute is present and the element has an ID, then the attribute's value must be equal to the element's ID. In earlier versions of the language, this attribute was intended as a way to specify possible targets for p138 fragments in URLs . The id attribute should be used instead.

Authors should not, but may despite requirements to the contrary elsewhere in this specification, specify the p523 maxlength and

size p523 p494 p496 p510 attributes on input elements whose type attributes are in the Number state. One valid reason for using these attributes regardless is to help legacy user agents that do not support p494 input elements with type="number" to still render the text control with a useful width.



16.1.1 Warnings for obsolete but conforming features p12 §

22

To ease the transition from HTML4 Transitional documents to the language defined in this specification, and to discourage certain features that are only allowed in very few circumstances, conformance checkers must warn the user when the following features are used in a document. These are generally old obsolete features that have no effect, and are allowed only to distinguish between likely mistakes (regular conformance errors) and mere vestigial markup or unusual and discouraged practices (these warnings).

The following features must be categorized as described above:

• The presence of a p1227 p321 border attribute on an img element if its value is the string "0".

• The presence of a p1224 p614 charset attribute on a script element if its value is an ASCII case-insensitive match for "utf-8".

• The presence of a p1226 p614 language attribute on a script element if its value is an ASCII case-insensitive match for the string

" p615 JavaScript " and if there is no type attribute or there is and its value is an ASCII case-insensitive match for the string "text/javascript".

• The presence of a p1226 p614 type attribute on a script element if its value is a JavaScript MIME type essence match.

• The presence of a p1226 p175 type attribute on a style element if its value is an ASCII case-insensitive match for "text/

css p1273".

• The presence of a p1224 p239 name attribute on an a element, if its value is not the empty string.

• The presence of a p523 p494 p496 p510 maxlength attribute on an input element whose type attribute is in the Number state.

1222

• The presence of a p523 p494 p496 p510 size attribute on an input element whose type attribute is in the Number state.

Conformance checkers must distinguish between pages that have no conformance errors and have none of these obsolete features, and pages that have no conformance errors but do have some of these obsolete features.

Example

For example, a validator could report some pages as "Valid HTML" and others as "Valid HTML with warnings".



16.2 Non-conforming features p12 §

23

Elements in the following list are entirely obsolete, and must not be used by authors: applet

Use p369 p373 embed or object instead.

acronym

Use p251 abbr instead.

bgsound

Use p384 audio instead.

dir

Use p223 ul instead.

frame p1231

frameset p1230

noframes

Either use p362 iframe and CSS instead, or use server-side includes to generate complete pages with the various invariant parts merged in.

isindex

Use an explicit p487 p500 form and text control combination instead.

keygen

For enterprise device management use cases, use native on-device management capabilities.

For certificate enrollment use cases, use the Web Cryptography API to generate a keypair for the certificate, and then export the

certificate and key to allow the user to install them manually. p1282 [WEBCRYPTO]

listing

Use p217 p268 pre and code instead.

menuitem

To implement a custom context menu, use script to handle the p1271 contextmenu event.

nextid

Use GUIDs instead.

noembed

Use p373 p369 object instead of embed when fallback is necessary.

plaintext

Use the "text/plain" MIME type instead.

rb

rtc

Providing the ruby base directly inside the p253 p253 ruby element or using nested ruby elements is sufficient.



1223

strike

Use p313 p246 del instead if the element is marking an edit, otherwise use s instead.

xmp

Use p217 p268 pre and code instead, and escape "<" and "&" characters as "<" and "&" respectively.

basefont

big

blink

center

font

marquee p1228

multicol

nobr

spacer

tt

Use appropriate elements or CSS instead.

Where the p1224 p271 tt element would have been used for marking up keyboard input, consider the kbd element; for variables,

consider the p269 p268 p270 var element; for computer code, consider the code element; and for computer output, consider the samp element.

Similarly, if the p1224 p191 big element is being used to denote a heading, consider using the h1 element; if it is being used for marking

up important passages, consider the p243 strong element; and if it is being used for highlighting text for reference purposes, consider

the p276 mark element.

See also the p283 text-level semantics usage summary for more suggestions with examples.



The following attributes are obsolete (though the elements are still part of the language), and must not be used by authors: charset p239 on a elements charset p158 on link elements

Use an HTTP ` p90 Content-Type` header on the linked resource instead.

charset p614 on script elements (except as noted in the previous section)

Omit the attribute. Both documents and scripts are required to use p614 UTF-8 , so it is redundant to specify it on the script element since it inherits from the document.

coords p239 on a elements shape p239 on a elements

Use p444 p239 area instead of a for image maps.

methods p239 on a elements methods p158 on link elements

Use the HTTP OPTIONS feature instead.

name p239 on a elements (except as noted in the previous section) name p369 on embed elements name p321 on img elements name p546 on option elements

Use the p138 id attribute instead.

rev p239 on a elements rev p158 on link elements

Use the p285 rel attribute instead, with an opposite term. (For example, instead of rev="made", use rel="author".)



1224

urn p239 on a elements urn p158 on link elements

Specify the preferred persistent identifier using the p285 href attribute instead.

accept p487 on form elements

Use the p517 p494 accept attribute directly on the input elements instead.

hreflang p444 on area elements type p444 on area elements

These attributes do not do anything useful, and for historical reasons there are no corresponding IDL attributes on p444 area elements. Omit them altogether.

nohref p444 on area elements

Omitting the p285 p1225 href attribute is sufficient; the nohref attribute is unnecessary. Omit it altogether.

profile p154 on head elements

Unnecessary. Omit it altogether.

manifest p153 on html elements

Use service workers instead. p1281 [SW]

version p153 on html elements

Unnecessary. Omit it altogether.

ismap p494 on input elements

Unnecessary. Omit it altogether. All p494 p496 p519 input elements with a type attribute in the Image Button state are processed as server-side image maps.

usemap p494 on input elements

Use p321 p494 img instead of input for image maps.

longdesc p362 on iframe elements longdesc p321 on img elements

Use a regular p239 p446 a element to link to the description, or (in the case of images) use an image map to provide a link from the image to the image's description.

lowsrc p321 on img elements

Use a progressive JPEG image (given in the p322 src attribute), instead of using two separate images.

target p158 on link elements

Unnecessary. Omit it altogether.

type p224 on menu elements

To implement a custom context menu, use script to handle the p1271 contextmenu event. For toolbar menus, omit the attribute.

label p224 on menu elements contextmenu on all elements

onshow on all elements

To implement a custom context menu, use script to handle the p1271 contextmenu event.

scheme p165 on meta elements

Use only one scheme per field, or make the scheme declaration part of the value.

archive p373 on object elements classid p373 on object elements code p373 on object elements codebase p373 on object elements codetype p373 on object elements

Use the p374 p375 p45 p379 data and type attributes to invoke plugins . To set parameters with these names in particular, the param element can be used.

1225

declare p373 on object elements

Repeat the p373 object element completely each time the resource is to be reused.

standby p373 on object elements

Optimize the linked resource so that it loads quickly or, at least, incrementally.

typemustmatch p373 on object elements

Avoid using p373 object elements with untrusted resources.

type p379 on param elements valuetype p379 on param elements

Use the p379 p379 name and value attributes without declaring value types.

language p614 on script elements (except as noted in the previous section)

Omit the attribute for JavaScript; for p616 p615 data blocks , use the type attribute instead.

event p614 on script elements for p614 on script elements

Use DOM events mechanisms to register event listeners. p1277 [DOM]

type p175 on style elements (except as noted in the previous section)

Omit the attribute for CSS; for p616 p614 p175 data blocks , use script as the container instead of style.

datapagesize p451 on table elements

Unnecessary. Omit it altogether.

summary p451 on table elements

Use one of the p456 p451 techniques for describing tables given in the table section instead.

abbr p466 on td elements

Use text that begins in an unambiguous and terse manner, and include any more elaborate text after that. The p140 title attribute

can also be useful in including more detailed text, so that the cell's contents can be made terse. If it's a heading, use p468 th (which

has an p469 abbr attribute).

axis p466 p468 on td and th elements

Use the p468 p468 scope attribute on the relevant th.

scope p466 on td elements

Use p468 th elements for heading cells.

datasrc p239 p536 p238 p1231 p362 p321 p494 p491 p566 p1228 p373 on a , button , div , frame , iframe , img , input , label , legend , marquee , object,

option p546 p538 p280 p451 p549 , select , span , table , and textarea elements datafld p239 p536 p238 p563 p1231 p362 p321 p494 p491 p566 p1228 on a , button , div , fieldset , frame , iframe , img , input , label , legend , marquee,

object p373 p379 p538 p280 p549 , param , select , span , and textarea elements dataformatas p536 p238 p494 p491 p566 p1228 p373 p546 p538 p280 on button , div , input , label , legend , marquee , object , option , select , span, and

table p451 elements

Use script and a mechanism such as p1283 XMLHttpRequest to populate the page dynamically. [XHR]

dropzone on all elements

Use script to handle the p812 p812 dragenter and dragover events instead.



1226

alink p179 on body elements bgcolor p179 on body elements bottommargin p179 on body elements leftmargin p179 on body elements link p179 on body elements marginheight p179 on body elements marginwidth p179 on body elements rightmargin p179 on body elements text p179 on body elements topmargin p179 on body elements vlink p179 on body elements clear p281 on br elements align p459 on caption elements align p461 on col elements char p461 on col elements charoff p461 on col elements valign p461 on col elements width p461 on col elements align p238 on div elements compact p228 on dl elements align p369 on embed elements hspace p369 on embed elements vspace p369 on embed elements align p215 on hr elements color p215 on hr elements noshade p215 on hr elements size p215 on hr elements width p215 on hr elements align p191 p191 on h1 — h6 elements align p362 on iframe elements allowtransparency p362 on iframe elements frameborder p362 on iframe elements framespacing p362 on iframe elements hspace p362 on iframe elements marginheight p362 on iframe elements marginwidth p362 on iframe elements scrolling p362 on iframe elements vspace p362 on iframe elements align p494 on input elements border p494 on input elements hspace p494 on input elements vspace p494 on input elements align p321 on img elements border p321 on img elements (except as noted in the previous section) hspace p321 on img elements vspace p321 on img elements align p566 on legend elements type p225 on li elements compact p224 on menu elements align p373 on object elements border p373 on object elements hspace p373 on object elements vspace p373 on object elements

1227

compact p222 on ol elements align p213 on p elements width p217 on pre elements align p451 on table elements bgcolor p451 on table elements border p451 on table elements bordercolor p451 on table elements cellpadding p451 on table elements cellspacing p451 on table elements frame p451 on table elements height p451 on table elements rules p451 on table elements width p451 on table elements align p462 p463 p464 on tbody , thead , and tfoot elements char p462 p463 p464 on tbody , thead , and tfoot elements charoff p462 p463 p464 on tbody , thead , and tfoot elements height p463 p462 p464 on thead , tbody , and tfoot elements valign p462 p463 p464 on tbody , thead , and tfoot elements align p466 p468 on td and th elements bgcolor p466 p468 on td and th elements char p466 p468 on td and th elements charoff p466 p468 on td and th elements height p466 p468 on td and th elements nowrap p466 p468 on td and th elements valign p466 p468 on td and th elements width p466 p468 on td and th elements align p465 on tr elements bgcolor p465 on tr elements char p465 on tr elements charoff p465 on tr elements height p465 on tr elements valign p465 on tr elements compact p223 on ul elements type p223 on ul elements background p179 p451 p463 p462 p464 p465 p466 p468 on body , table , thead , tbody , tfoot , tr , td , and th elements

Use CSS instead.



16.3 Requirements for implementations p12 §

28

16.3.1 The marquee element p12 §

28

The p1228 marquee element is a presentational element that animates content. CSS transitions and animations are a more appropriate mechanism. p1276 p1277 [CSSANIMATIONS] [CSSTRANSITIONS]

The p1228 p1228 marquee element must implement the HTMLMarqueeElement interface.

IDL [Exposed=Window]

interface HTMLMarqueeElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString behavior;

[CEReactions] attribute DOMString bgColor;

[CEReactions] attribute DOMString direction;

1228

[CEReactions] attribute DOMString height;

[CEReactions] attribute unsigned long hspace;

[CEReactions] attribute long loop;

[CEReactions] attribute unsigned long scrollAmount;

[CEReactions] attribute unsigned long scrollDelay;

[CEReactions] attribute boolean trueSpeed;

[CEReactions] attribute unsigned long vspace;

[CEReactions] attribute DOMString width;

attribute EventHandler onbounce;

attribute EventHandler onfinish;

attribute EventHandler onstart;

undefined start();

undefined stop();

};

A p1228 p1229 marquee element can be turned on or turned off . When it is created, it is turned on.

When the p1228 p1229 start() method is called, the marquee element must be turned on.

When the p1228 p1229 stop() method is called, the marquee element must be turned off.

When a p1228 p933 p939 marquee element is created, the user agent must queue an element task on the DOM manipulation task source

given the p1228 marquee element to fire an event named start at the element.



The p1228 p68 behavior content attribute on marquee elements is an enumerated attribute with the following keywords (all non-conforming):

Keyword State

scroll scroll

slide slide

alternate alternate

The p68 p68 p1229 missing value default and invalid value default are the scroll state.



The p1228 p68 direction content attribute on marquee elements is an enumerated attribute with the following keywords (all non-conforming):

Keyword State

left left

right right

up up

down down

The p68 p68 p1229 missing value default and invalid value default are the left state.



The p1228 p67 truespeed content attribute on marquee elements is a boolean attribute.



A p1228 marquee element has a marquee scroll interval, which is obtained as follows:

1. If the element has a p69 scrolldelay attribute, and parsing its value using the rules for parsing non-negative integers does

not return an error, then let delay be the parsed value. Otherwise, let delay be 85.

2. If the element does not have a p1229 truespeed attribute, and the delay value is less than 60, then let delay be 60 instead.

3. The p1229 marquee scroll interval is delay, interpreted in milliseconds.

1229

A p1228 marquee element has a marquee scroll distance, which, if the element has a scrollamount attribute, and parsing its value using the p69 rules for parsing non-negative integers does not return an error, is the parsed value interpreted in CSS pixels, and otherwise is 6 CSS pixels.



A p1228 marquee element has a marquee loop count, which, if the element has a loop attribute, and parsing its value using the rules

for parsing integers p68 does not return an error or a number less than 1, is the parsed value, and otherwise is −1.

The p1230 loop IDL attribute, on getting, must return the element's marquee loop count; and on setting, if the new value is different than the element's p1230 p1230 marquee loop count and either greater than zero or equal to −1, must set the element's loop content attribute (adding it if necessary) to the p68 valid integer that represents the new value. (Other values are ignored.) A p1228 marquee element also has a marquee current loop index, which is zero when the element is created.

The rendering layer will occasionally increment the marquee current loop index, which must cause the following steps to be run:

1. If the p1230 marquee loop count is −1, then return.

2. Increment the p1230 marquee current loop index by one.

3. If the p1230 p1230 p1229 marquee current loop index is now equal to or greater than the element's marquee loop count , turn off the

marquee p1228 p933 p939 p1228 element and queue an element task on the DOM manipulation task source given the marquee

element to p1228 fire an event named finish at the marquee element.

Otherwise, if the p1229 p1229 p933 behavior attribute is in the alternate state, then queue an element task on the DOM

manipulation task source p939 p1228 p1228 given the marquee element to fire an event named bounce at the marquee element.

Otherwise, p933 p939 p1228 queue an element task on the DOM manipulation task source given the marquee element to fire an

event p1228 named start at the marquee element.



The following are the p941 p944 event handlers (and their corresponding event handler event types ) that must be supported, as event

handler content attributes p943 p942 p1228 and event handler IDL attributes , by marquee elements:

Event handler p941 p944 Event handler event type

onbounce bounce

onfinish finish

onstart start



The p95 behavior , direction , height , hspace , vspace , and width IDL attributes must reflect the respective content attributes of the same name.

The p95 bgColor IDL attribute must reflect the bgcolor content attribute.

The p95 scrollAmount IDL attribute must reflect the scrollamount content attribute. The default value is 6.

The p95 scrollDelay IDL attribute must reflect the scrolldelay content attribute. The default value is 85.

The p95 p1229 trueSpeed IDL attribute must reflect the truespeed content attribute.



16.3.2 Frames p12 §

30

The p119 frameset element acts as the body element in documents that use frames.

The p1230 p1230 frameset element must implement the HTMLFrameSetElement interface.

IDL [Exposed=Window]

interface HTMLFrameSetElement : HTMLElement {

[HTMLConstructor] constructor();



1230

[CEReactions] attribute DOMString cols;

[CEReactions] attribute DOMString rows;

};

HTMLFrameSetElement includes WindowEventHandlers;

The p1230 p95 cols and rows IDL attributes of the frameset element must reflect the respective content attributes of the same name.

The p1230 p943 p941 p828 frameset element exposes as event handler content attributes a number of the event handlers of the Window object.

It also mirrors their p942 event handler IDL attributes .

The p941 p828 p950 event handlers of the Window object named by the Window-reflecting body element event handler set, exposed on the

frameset p1230 p941 p44 element, replace the generic event handlers with the same names normally supported by HTML elements.



The p817 p362 p1230 frame element has a nested browsing context similar to the iframe element, but rendered within a frameset element.

A p1231 frame element is said to be an active frame element when it is in a document.

When a p1231 p1231 p1231 frame element element is created as an active frame element , or becomes an active frame element after not having been one, the user agent must run these steps:

1. p817 Create a new nested browsing context for element.

2. p1231 p1231 Process the frame attributes for element , with initialInsertion set to true.

When a p1231 p1231 p835 frame element stops being an active frame element , the user agent must discard the element's nested browsing

context p817 p817 , and then set the element's nested browsing context to null.

Whenever a p1231 p817 frame element with a non-null nested browsing context has its src attribute set, changed, or removed, the user agent must p1231 process the frame attributes.

To process the frame attributes for an element element, with an optional boolean initialInsertion:

1. If element has a src attribute specified, or initialInsertion is false, then run the shared attribute processing steps for iframe

and p364 frame elements given element.

The p1231 p365 frame element potentially delays the load event.

The p1231 p1231 frame element must implement the HTMLFrameElement interface.

IDL [Exposed=Window]

interface HTMLFrameElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString scrolling;

[CEReactions] attribute USVString src;

[CEReactions] attribute DOMString frameBorder;

[CEReactions] attribute USVString longDesc;

[CEReactions] attribute boolean noResize;

readonly attribute Document? contentDocument;

readonly attribute WindowProxy? contentWindow;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString marginHeight;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString marginWidth;

};

The p1231 p95 name , scrolling , and src IDL attributes of the frame element must reflect the respective content attributes of the same name. For the purposes of reflection, the p1231 frame element's src content attribute is defined as containing a URL.

The p1231 p95 frameBorder IDL attribute of the frame element must reflect the element's frameborder content attribute.

The p1231 p95 longDesc IDL attribute of the frame element must reflect the element's longdesc content attribute, which for the purposes

1231

of reflection is defined as containing a URL.

The p1231 p95 noResize IDL attribute of the frame element must reflect the element's noresize content attribute.

The p1231 p819 contentDocument IDL attribute, on getting, must return the frame element's content document.

The p837 p1231 p817 contentWindow IDL attribute must return the WindowProxy object of the frame element's nested browsing context, if the element's p817 nested browsing context is non-null, or return null otherwise.

The p1231 p95 marginHeight IDL attribute of the frame element must reflect the element's marginheight content attribute.

The p1231 p95 marginWidth IDL attribute of the frame element must reflect the element's marginwidth content attribute.



16.3.3 Other elements, attributes and APIs p12 §

32

User agents must treat p1223 p251 acronym elements in a manner equivalent to abbr elements in terms of semantics and for purposes of rendering.



IDL partial interface HTMLAnchorElement {

[CEReactions] attribute DOMString coords;

[CEReactions] attribute DOMString charset;

[CEReactions] attribute DOMString name;

[CEReactions] attribute DOMString rev;

[CEReactions] attribute DOMString shape;

};

The p239 p95 coords , charset , name , rev , and shape IDL attributes of the a element must reflect the respective content attributes of the same name.



IDL partial interface HTMLAreaElement {

[CEReactions] attribute boolean noHref;

};

The p444 p95 p1225 noHref IDL attribute of the area element must reflect the element's nohref content attribute.



IDL partial interface HTMLBodyElement {

[CEReactions] attribute [LegacyNullToEmptyString] DOMString text;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString link;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString vLink;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString aLink;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString bgColor;

[CEReactions] attribute DOMString background;

};

The p179 p95 p1227 text IDL attribute of the body element must reflect the element's text content attribute.

The p179 p95 p1227 link IDL attribute of the body element must reflect the element's link content attribute.

The p179 p95 p1227 aLink IDL attribute of the body element must reflect the element's alink content attribute.

The p179 p95 p1227 vLink IDL attribute of the body element must reflect the element's vlink content attribute.

The p179 p95 p1227 bgColor IDL attribute of the body element must reflect the element's bgcolor content attribute.

The p179 p95 p1228 background IDL attribute of the body element must reflect the element's background content attribute. (The

background p1228 content is not defined to contain a URL, despite rules regarding its handling in the rendering section above.)

1232

IDL partial interface HTMLBRElement {

[CEReactions] attribute DOMString clear;

};

The p281 p95 clear IDL attribute of the br element must reflect the content attribute of the same name.



IDL partial interface HTMLTableCaptionElement {

[CEReactions] attribute DOMString align;

};

The p459 p95 align IDL attribute of the caption element must reflect the content attribute of the same name.



IDL partial interface HTMLTableColElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString ch;

[CEReactions] attribute DOMString chOff;

[CEReactions] attribute DOMString vAlign;

[CEReactions] attribute DOMString width;

};

The p461 p95 align and width IDL attributes of the col element must reflect the respective content attributes of the same name.

The p461 p95 p1227 ch IDL attribute of the col element must reflect the element's char content attribute.

The p461 p95 p1227 chOff IDL attribute of the col element must reflect the element's charoff content attribute.

The p461 p95 p1227 vAlign IDL attribute of the col element must reflect the element's valign content attribute.



User agents must treat p1223 p223 dir elements in a manner equivalent to ul elements in terms of semantics and for purposes of rendering.

The p1223 p1233 dir element must implement the HTMLDirectoryElement interface.

IDL [Exposed=Window]

interface HTMLDirectoryElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute boolean compact;

};

The p1223 p95 compact IDL attribute of the dir element must reflect the content attribute of the same name.



IDL partial interface HTMLDivElement {

[CEReactions] attribute DOMString align;

};

The p238 p95 align IDL attribute of the div element must reflect the content attribute of the same name.



IDL partial interface HTMLDListElement {

[CEReactions] attribute boolean compact;

};

The p228 p95 compact IDL attribute of the dl element must reflect the content attribute of the same name.

1233

IDL partial interface HTMLEmbedElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString name;

};

The p369 p95 name and align IDL attributes of the embed element must reflect the respective content attributes of the same name.



The p1224 p1234 font element must implement the HTMLFontElement interface.

IDL [Exposed=Window]

interface HTMLFontElement : HTMLElement {

[HTMLConstructor] constructor();

[CEReactions] attribute [LegacyNullToEmptyString] DOMString color;

[CEReactions] attribute DOMString face;

[CEReactions] attribute DOMString size;

};

The p1224 p95 color , face , and size IDL attributes of the font element must reflect the respective content attributes of the same name.



IDL partial interface HTMLHeadingElement {

[CEReactions] attribute DOMString align;

};

The p191 p191 p95 align IDL attribute of the h1 – h6 elements must reflect the content attribute of the same name.



Note

The p154 p154 profile IDL attribute on head elements (with the HTMLHeadElement interface) is intentionally omitted. Unless so

required by p65 another applicable specification, implementations would therefore not support this attribute. (It is mentioned here

as it was defined in a previous version of DOM.)



IDL partial interface HTMLHRElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString color;

[CEReactions] attribute boolean noShade;

[CEReactions] attribute DOMString size;

[CEReactions] attribute DOMString width;

};

The p215 p95 align , color , size , and width IDL attributes of the hr element must reflect the respective content attributes of the same name.

The p215 p95 p1227 noShade IDL attribute of the hr element must reflect the element's noshade content attribute.



IDL partial interface HTMLHtmlElement {

[CEReactions] attribute DOMString version;

};

The p153 p95 version IDL attribute of the html element must reflect the content attribute of the same name.



IDL partial interface HTMLIFrameElement {

[CEReactions] attribute DOMString align;

1234

[CEReactions] attribute DOMString scrolling;

[CEReactions] attribute DOMString frameBorder;

[CEReactions] attribute USVString longDesc;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString marginHeight;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString marginWidth;

};

The p362 p95 align and scrolling IDL attributes of the iframe element must reflect the respective content attributes of the same name.

The p362 p95 p1227 frameBorder IDL attribute of the iframe element must reflect the element's frameborder content attribute.

The p362 p95 p1225 longDesc IDL attribute of the iframe element must reflect the element's longdesc content attribute, which for the purposes of reflection is defined as containing a URL.

The p362 p95 p1227 marginHeight IDL attribute of the iframe element must reflect the element's marginheight content attribute.

The p362 p95 p1227 marginWidth IDL attribute of the iframe element must reflect the element's marginwidth content attribute.



IDL partial interface HTMLImageElement {

[CEReactions] attribute DOMString name;

[CEReactions] attribute USVString lowsrc;

[CEReactions] attribute DOMString align;

[CEReactions] attribute unsigned long hspace;

[CEReactions] attribute unsigned long vspace;

[CEReactions] attribute USVString longDesc;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString border;

};

The p321 p95 name , align , border , hspace , and vspace IDL attributes of the img element must reflect the respective content attributes of the same name.

The p321 p95 p1225 longDesc IDL attribute of the img element must reflect the element's longdesc content attribute, which for the purposes of reflection is defined as containing a URL.

The p321 p95 p1225 lowsrc IDL attribute of the img element must reflect the element's lowsrc content attribute, which for the purposes of reflection is defined as containing a URL.



IDL partial interface HTMLInputElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString useMap;

};

The p494 p95 align IDL attribute of the input element must reflect the content attribute of the same name.

The p494 p95 p1225 useMap IDL attribute of the input element must reflect the element's usemap content attribute.



IDL partial interface HTMLLegendElement {

[CEReactions] attribute DOMString align;

};

The p566 p95 align IDL attribute of the legend element must reflect the content attribute of the same name.



IDL partial interface HTMLLIElement {

1235

[CEReactions] attribute DOMString type;

};

The p225 p95 type IDL attribute of the li element must reflect the content attribute of the same name.



IDL partial interface HTMLLinkElement {

[CEReactions] attribute DOMString charset;

[CEReactions] attribute DOMString rev;

[CEReactions] attribute DOMString target;

};

The p158 p95 charset , rev , and target IDL attributes of the link element must reflect the respective content attributes of the same name.



User agents must treat p1223 p217 listing elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering.



IDL partial interface HTMLMenuElement {

[CEReactions] attribute boolean compact;

};

The p224 p95 compact IDL attribute of the menu element must reflect the content attribute of the same name.



IDL partial interface HTMLMetaElement {

[CEReactions] attribute DOMString scheme;

};

User agents may treat the p1225 p165 p166 scheme content attribute on the meta element as an extension of the element's name content attribute when processing a p165 p166 meta element with a name attribute whose value is one that the user agent recognizes as supporting the p1225 scheme attribute.

User agents are encouraged to ignore the p1225 scheme attribute and instead process the value given to the metadata name as if it had been specified for each expected value of the p1225 scheme attribute.

Example

For example, if the user agent acts on p165 p166 meta elements with name attributes having the value "eGMS.subject.keyword", and

knows that the p1225 p1225 scheme attribute is used with this metadata name, then it could take the scheme attribute into account,

acting as if it was an extension of the p166 p165 name attribute. Thus the following two meta elements could be treated as two

elements giving values for two different metadata names, one consisting of a combination of "eGMS.subject.keyword" and "LGCL",

and the other consisting of a combination of "eGMS.subject.keyword" and "ORLY":





The suggested processing of this markup, however, would be equivalent to the following:





The p165 p95 scheme IDL attribute of the meta element must reflect the content attribute of the same name.



1236

IDL partial interface HTMLObjectElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString archive;

[CEReactions] attribute DOMString code;

[CEReactions] attribute boolean declare;

[CEReactions] attribute unsigned long hspace;

[CEReactions] attribute DOMString standby;

[CEReactions] attribute unsigned long vspace;

[CEReactions] attribute DOMString codeBase;

[CEReactions] attribute DOMString codeType;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString border;

};

The p373 p95 align , archive , border , code , declare , hspace , standby , and vspace IDL attributes of the object element must reflect the

respective content attributes of the same name.

The p373 p95 p1225 codeBase IDL attribute of the object element must reflect the element's codebase content attribute, which for the purposes of reflection is defined as containing a URL.

The p373 p95 p1225 codeType IDL attribute of the object element must reflect the element's codetype content attribute.



IDL partial interface HTMLOListElement {

[CEReactions] attribute boolean compact;

};

The p222 p95 compact IDL attribute of the ol element must reflect the content attribute of the same name.



IDL partial interface HTMLParagraphElement {

[CEReactions] attribute DOMString align;

};

The p213 p95 align IDL attribute of the p element must reflect the content attribute of the same name.



IDL partial interface HTMLParamElement {

[CEReactions] attribute DOMString type;

[CEReactions] attribute DOMString valueType;

};

The p379 p95 type IDL attribute of the param element must reflect the content attribute of the same name.

The p379 p95 p1226 valueType IDL attribute of the param element must reflect the element's valuetype content attribute.



User agents must treat p1223 p217 plaintext elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering. (The parser has special behavior for this element, though.)



IDL partial interface HTMLPreElement {

[CEReactions] attribute long width;

};

The p217 p95 width IDL attribute of the pre element must reflect the content attribute of the same name.



1237

IDL partial interface HTMLStyleElement {

[CEReactions] attribute DOMString type;

};

The p175 p95 p1226 type IDL attribute of the style element must reflect the element's type content attribute.



IDL partial interface HTMLScriptElement {

[CEReactions] attribute DOMString charset;

[CEReactions] attribute DOMString event;

[CEReactions] attribute DOMString htmlFor;

};

The p614 p95 charset and event IDL attributes of the script element must reflect the respective content attributes of the same name.

The p614 p95 p1226 htmlFor IDL attribute of the script element must reflect the element's for content attribute.



IDL partial interface HTMLTableElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString border;

[CEReactions] attribute DOMString frame;

[CEReactions] attribute DOMString rules;

[CEReactions] attribute DOMString summary;

[CEReactions] attribute DOMString width;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString bgColor;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString cellPadding;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString cellSpacing;

};

The p451 p95 align , border , frame , summary , rules , and width , IDL attributes of the table element must reflect the respective content attributes of the same name.

The p451 p95 p1228 bgColor IDL attribute of the table element must reflect the element's bgcolor content attribute.

The p451 p95 p1228 cellPadding IDL attribute of the table element must reflect the element's cellpadding content attribute.

The p451 p95 p1228 cellSpacing IDL attribute of the table element must reflect the element's cellspacing content attribute.



IDL partial interface HTMLTableSectionElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString ch;

[CEReactions] attribute DOMString chOff;

[CEReactions] attribute DOMString vAlign;

};

The p462 p463 p464 p95 align IDL attribute of the tbody , thead , and tfoot elements must reflect the content attribute of the same name.

The p462 p463 p464 p95 p1228 ch IDL attribute of the tbody , thead , and tfoot elements must reflect the elements' char content attributes.

The p462 p463 p464 p95 p1228 chOff IDL attribute of the tbody , thead , and tfoot elements must reflect the elements' charoff content attributes.

The p462 p463 p464 p95 p1228 vAlign IDL attribute of the tbody , thead , and tfoot element must reflect the elements' valign content attributes.



1238

IDL partial interface HTMLTableCellElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString axis;

[CEReactions] attribute DOMString height;

[CEReactions] attribute DOMString width;

[CEReactions] attribute DOMString ch;

[CEReactions] attribute DOMString chOff;

[CEReactions] attribute boolean noWrap;

[CEReactions] attribute DOMString vAlign;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString bgColor;

};

The p466 p468 p95 align , axis , height , and width IDL attributes of the td and th elements must reflect the respective content attributes of the same name.

The p466 p468 p95 p1228 ch IDL attribute of the td and th elements must reflect the elements' char content attributes.

The p466 p468 p95 p1228 chOff IDL attribute of the td and th elements must reflect the elements' charoff content attributes.

The p466 p468 p95 p1228 noWrap IDL attribute of the td and th elements must reflect the elements' nowrap content attributes.

The p466 p468 p95 p1228 vAlign IDL attribute of the td and th elements must reflect the elements' valign content attributes.

The p466 p468 p95 p1228 bgColor IDL attribute of the td and th elements must reflect the elements' bgcolor content attributes.



IDL partial interface HTMLTableRowElement {

[CEReactions] attribute DOMString align;

[CEReactions] attribute DOMString ch;

[CEReactions] attribute DOMString chOff;

[CEReactions] attribute DOMString vAlign;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString bgColor;

};

The p465 p95 align IDL attribute of the tr element must reflect the content attribute of the same name.

The p465 p95 p1228 ch IDL attribute of the tr element must reflect the element's char content attribute.

The p465 p95 p1228 chOff IDL attribute of the tr element must reflect the element's charoff content attribute.

The p465 p95 p1228 vAlign IDL attribute of the tr element must reflect the element's valign content attribute.

The p465 p95 p1228 bgColor IDL attribute of the tr element must reflect the element's bgcolor content attribute.



IDL partial interface HTMLUListElement {

[CEReactions] attribute boolean compact;

[CEReactions] attribute DOMString type;

};

The p223 p95 compact and type IDL attributes of the ul element must reflect the respective content attributes of the same name.



User agents must treat p1224 p217 xmp elements in a manner equivalent to pre elements in terms of semantics and for purposes of rendering. (The parser has special behavior for this element though.)



1239

IDL partial interface Document {

[CEReactions] attribute [LegacyNullToEmptyString] DOMString fgColor;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString linkColor;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString vlinkColor;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString alinkColor;

[CEReactions] attribute [LegacyNullToEmptyString] DOMString bgColor;

[SameObject] readonly attribute HTMLCollection anchors;

[SameObject] readonly attribute HTMLCollection applets;

undefined clear();

undefined captureEvents();

undefined releaseEvents();

[SameObject] readonly attribute HTMLAllCollection all;

};

The attributes of the p115 p95 Document object listed in the first column of the following table must reflect the content attribute on the

body element p119 p119 with the name given in the corresponding cell in the second column on the same row, if the body element is a

body p179 p1230 p119 p1230 element (as opposed to a frameset element). When there is no body element or if it is a frameset element, the attributes must instead return the empty string on getting and do nothing on setting.

IDL attribute Content attribute

fgColor p1227 text

linkColor p1227 link

vlinkColor p1227 vlink

alinkColor p1227 alink

bgColor p1227 bgcolor



The p115 p239 anchors attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with

name p1224 attributes.

The p115 applets attribute must return an HTMLCollection rooted at the Document node, whose filter matches nothing. (It exists for historical reasons.) The clear(), captureEvents(), and releaseEvents() methods must do nothing.



The p97 p115 all attribute must return an HTMLAllCollection rooted at the Document node, whose filter matches all elements.



IDL partial interface Window {

undefined captureEvents();

undefined releaseEvents();

[Replaceable, SameObject] readonly attribute External external;

};

The captureEvents() and releaseEvents() methods must do nothing.

The p828 p1240 external attribute of the Window interface must return an instance of the External interface:

IDL [Exposed=Window]

interface External {

undefined AddSearchProvider();

undefined IsSearchProviderInstalled();

};

The AddSearchProvider() and IsSearchProviderInstalled() methods must do nothing.

1240

17 IANA considerations p12 §

41

17.1 text/html p12 §

41

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

text

Subtype name:

html

Required parameters:

No required parameters

Optional parameters:

charset

The charset parameter may be provided to specify the document's character encoding, overriding any character encoding

declarations p174 in the document other than a Byte Order Mark (BOM). The parameter's value must be an ASCII case-insensitive

match for the string " p1277 utf-8 ". [ENCODING]

Encoding considerations:

8bit (see the section on p174 character encoding declarations) Security considerations:

Entire novels have been written about the security considerations that apply to HTML documents. Many are listed in this document, to which the reader is referred for more details. Some general concerns bear mentioning here, however:

HTML is scripted language, and has a large number of APIs (some of which are described in this document). Script can expose the user to potential risks of information leakage, credential leakage, cross-site scripting attacks, cross-site request forgeries, and a host of other problems. While the designs in this specification are intended to be safe if implemented correctly, a full implementation is a massive undertaking and, as with any software, user agents are likely to have security bugs.

Even without scripting, there are specific features in HTML which, for historical reasons, are required for broad compatibility with

legacy content but that expose the user to unfortunate security problems. In particular, the p321 img element can be used in conjunction with some other features as a way to effect a port scan from the user's location on the Internet. This can expose local network topologies that the attacker would otherwise not be able to determine.

HTML relies on a compartmentalization scheme sometimes known as the p841 same-origin policy . An origin in most cases consists of all the pages served from the same host, on the same port, using the same protocol.

It is critical, therefore, to ensure that any untrusted content that forms part of a site be hosted on a different p841 origin than any sensitive content on that site. Untrusted content can easily spoof any other page on the same origin, read data from that origin, cause scripts in that origin to execute, submit forms to and from that origin even if they are protected from cross-site request forgery attacks by unique tokens, and make use of any third-party resources exposed to or rights granted to that origin.

Interoperability considerations:

Rules for processing both conforming and non-conforming content are defined in this specification.

Published specification:

This document is the relevant specification. Labeling a resource with the p1241 text/html type asserts that the resource is an HTML

document p1064 using the HTML syntax.

Applications that use this media type:

Web browsers, tools for processing web content, HTML authoring tools, search engines, validators.

Additional information:

Magic number(s):

No sequence of bytes can uniquely identify an HTML document. More information on detecting HTML documents is available in

MIME Sniffing p1279 . [MIMESNIFF]

File extension(s):

"html" and "htm" are commonly, but certainly not exclusively, used as the extension for HTML documents.

1241

Macintosh file type code(s):

TEXT

Person & email address to contact for further information:

Ian Hickson

Intended usage:

Common

Restrictions on usage:

No restrictions apply.

Author:

Ian Hickson

Change controller:

W3C

Fragments p1241 p890 used with text/html resources either refer to the indicated part of the document or provide state information for in-page scripts.



17.2 multipart/x-mixed-replace p12 §

42

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

multipart

Subtype name:

x-mixed-replace

Required parameters:

• p1280 boundary (defined in RFC2046) [RFC2046]

Optional parameters:

No optional parameters.

Encoding considerations:

binary

Security considerations:

Subresources of a p1242 multipart/x-mixed-replace resource can be of any type, including types with non-trivial security

implications such as p1241 text/html.

Interoperability considerations:

None.

Published specification:

This specification describes processing rules for web browsers. Conformance requirements for generating resources with this type

are the same as for p1273 p1280 multipart/mixed . [RFC2046]

Applications that use this media type:

This type is intended to be used in resources generated by web servers, for consumption by web browsers.

Additional information:

Magic number(s):

No sequence of bytes can uniquely identify a p1242 multipart/x-mixed-replace resource.

File extension(s):

No specific file extensions are recommended for this type.

Macintosh file type code(s):

No specific Macintosh file type codes are recommended for this type.

Person & email address to contact for further information:

Ian Hickson

1242

Intended usage:

Common

Restrictions on usage:

No restrictions apply.

Author:

Ian Hickson

Change controller:

W3C

Fragments p1242 used with multipart/x-mixed-replace resources apply to each body part as defined by the type used by that body part.



17.3 application/xhtml+xml p12 §

43

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

application

Subtype name:

xhtml+xml

Required parameters:

Same as for p1273 p1281 application/xml [RFC7303]

Optional parameters:

Same as for p1273 p1281 application/xml [RFC7303]

Encoding considerations:

Same as for p1273 p1281 application/xml [RFC7303]

Security considerations:

Same as for p1273 p1281 application/xml [RFC7303]

Interoperability considerations:

Same as for p1273 p1281 application/xml [RFC7303]

Published specification:

Labeling a resource with the p1243 application/xhtml+xml type asserts that the resource is an XML document that likely has a

document element from the HTML namespace. Thus, the relevant specifications are XML, Namespaces in XML, and this

specification. p1283 p1283 [XML] [XMLNS]

Applications that use this media type:

Same as for p1273 p1281 application/xml [RFC7303]

Additional information:

Magic number(s):

Same as for p1273 p1281 application/xml [RFC7303]

File extension(s):

"xhtml" and "xht" are sometimes used as extensions for XML resources that have a document element from the HTML

namespace.

Macintosh file type code(s):

TEXT

Person & email address to contact for further information:

Ian Hickson

Intended usage:

Common



1243

Restrictions on usage:

No restrictions apply.

Author:

Ian Hickson

Change controller:

W3C

Fragments p1243 p1281 used with application/xhtml+xml resources have the same semantics as with any XML MIME type . [RFC7303]



17.4 text/ping p12 §

44

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

text

Subtype name:

ping

Required parameters:

No parameters

Optional parameters:

charset

The charset parameter may be provided. The parameter's value must be "utf-8". This parameter serves no purpose; it is only allowed for compatibility with legacy servers.

Encoding considerations:

Not applicable.

Security considerations:

If used exclusively in the fashion described in the context of p294 hyperlink auditing , this type introduces no new security concerns.

Interoperability considerations:

Rules applicable to this type are defined in this specification.

Published specification:

This document is the relevant specification.

Applications that use this media type:

Web browsers.

Additional information:

Magic number(s):

text/ping p1244 resources always consist of the four bytes 0x50 0x49 0x4E 0x47 (`PING`).

File extension(s):

No specific file extension is recommended for this type.

Macintosh file type code(s):

No specific Macintosh file type codes are recommended for this type.

Person & email address to contact for further information:

Ian Hickson

Intended usage:

Common

Restrictions on usage:

Only intended for use with HTTP POST requests generated as part of a web browser's processing of the p285 ping attribute.

Author:

Ian Hickson

1244

Change controller:

W3C

Fragments p1244 have no meaning with text/ping resources.



17.5 application/microdata+json p12 §

45

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

application

Subtype name:

microdata+json

Required parameters:

Same as for p1273 p1278 application/json [JSON]

Optional parameters:

Same as for p1273 p1278 application/json [JSON]

Encoding considerations:

8bit (always UTF-8)

Security considerations:

Same as for p1273 p1278 application/json [JSON]

Interoperability considerations:

Same as for p1273 p1278 application/json [JSON]

Published specification:

Labeling a resource with the p1245 application/microdata+json type asserts that the resource is a JSON text that consists of an object with a single entry called "items" consisting of an array of entries, each of which consists of an object with an entry called "id" whose value is a string, an entry called "type" whose value is another string, and an entry called "properties" whose value is an object whose entries each have a value consisting of an array of either objects or strings, the objects being of the same form as

the objects in the aforementioned " p1278 items " entry. Thus, the relevant specifications are JSON and this specification. [JSON]

Applications that use this media type:

Applications that transfer data intended for use with HTML's microdata feature, especially in the context of drag-and-drop, are the primary application class for this type.

Additional information:

Magic number(s):

Same as for p1273 p1278 application/json [JSON]

File extension(s):

Same as for p1273 p1278 application/json [JSON]

Macintosh file type code(s):

Same as for p1273 p1278 application/json [JSON]

Person & email address to contact for further information:

Ian Hickson

Intended usage:

Common

Restrictions on usage:

No restrictions apply.

Author:

Ian Hickson

Change controller:

W3C

1245

Fragments p1245 used with application/microdata+json resources have the same semantics as when used with application/

json p1273 p1278 (namely, at the time of writing, no semantics at all). [JSON]



17.6 text/event-stream p12 §

46

This registration is for community review and will be submitted to the IESG for review, approval, and registration with IANA.

Type name:

text

Subtype name:

event-stream

Required parameters:

No parameters

Optional parameters:

charset

The charset parameter may be provided. The parameter's value must be "utf-8". This parameter serves no purpose; it is only allowed for compatibility with legacy servers.

Encoding considerations:

8bit (always UTF-8)

Security considerations:

An event stream from an origin distinct from the origin of the content consuming the event stream can result in information

leakage. To avoid this, user agents are required to apply CORS semantics. p1277 [FETCH]

Event streams can overwhelm a user agent; a user agent is expected to apply suitable restrictions to avoid depleting local resources because of an overabundance of information from an event stream.

Servers can be overwhelmed if a situation develops in which the server is causing clients to reconnect rapidly. Servers should use a 5xx status code to indicate capacity problems, as this will prevent conforming clients from reconnecting automatically.

Interoperability considerations:

Rules for processing both conforming and non-conforming content are defined in this specification.

Published specification:

This document is the relevant specification.

Applications that use this media type:

Web browsers and tools using web services.

Additional information:

Magic number(s):

No sequence of bytes can uniquely identify an event stream.

File extension(s):

No specific file extensions are recommended for this type.

Macintosh file type code(s):

No specific Macintosh file type codes are recommended for this type.

Person & email address to contact for further information:

Ian Hickson

Intended usage:

Common

Restrictions on usage:

This format is only expected to be used by dynamic open-ended streams served using HTTP or a similar protocol. Finite resources are not expected to be labeled with this type.

Author:

Ian Hickson

1246

Change controller:

W3C

Fragments p1246 have no meaning with text/event-stream resources.



17.7 `Cross-Origin-Embedder-Policy` p12 §

47

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Cross-Origin-Embedder-Policy

Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.8 `Cross-Origin-Embedder-Policy-Report-Only` p12 §

47

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Cross-Origin-Embedder-Policy-Report-Only Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.9 `Cross-Origin-Opener-Policy` p12 §

47

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Cross-Origin-Opener-Policy

Applicable protocol:

http

1247

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.10 `Cross-Origin-Opener-Policy-Report-Only` p12 §

48

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Cross-Origin-Opener-Policy-Report-Only

Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.11 `Origin-Agent-Cluster` p12 §

48

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Origin-Agent-Cluster

Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



1248

17.12 `Ping-From` p12 §

49

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Ping-From

Applicable protocol:

http

Status:

standard

Author/Change controller:

W3C

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.13 `Ping-To` p12 §

49

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Ping-To

Applicable protocol:

http

Status:

standard

Author/Change controller:

W3C

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.14 `Refresh` p12 §

49

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Refresh

Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

1249

Related information:

None.



17.15 `Last-Event-ID` p12 §

50

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

Last-Event-ID

Applicable protocol:

http

Status:

standard

Author/Change controller:

W3C

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.16 `X-Frame-Options` p12 §

50

This section describes a header for registration in the Permanent Message Header Field Registry. p1280 [RFC3864]

Header field name:

X-Frame-Options

Applicable protocol:

http

Status:

standard

Author/Change controller:

WHATWG

Specification document(s):

This document is the relevant specification.

Related information:

None.



17.17 web+ scheme prefix p12 §

50

This section describes a convention for use with the IANA URI scheme registry. It does not itself register a specific scheme.

[RFC7595] p1280

Scheme name:

Schemes starting with the four characters "web+" followed by one or more letters in the range a-z.

Status:

Permanent

1250

Scheme syntax:

Scheme-specific.

Scheme semantics:

Scheme-specific.

Encoding considerations:

All "web+" schemes should use UTF-8 encodings where relevant.

Applications/protocols that use this scheme name:

Scheme-specific.

Interoperability considerations:

The scheme is expected to be used in the context of web applications.

Security considerations:

Any web page is able to register a handler for all "web+" schemes. As such, these schemes must not be used for features intended to be core platform features (e.g. network transfer protocols like HTTP or FTP). Similarly, such schemes must not store confidential information in their URLs, such as usernames, passwords, personal information, or confidential project names.

Contact:

Ian Hickson

Change controller:

Ian Hickson

References:

Custom scheme handlers p970 , HTML Living Standard: https://html.spec.whatwg.org/#custom-handlers



1251

Index p12 §

52

The following sections only cover conforming elements and features.



Elements p12 §

52

This section is non-normative.

List of elements

Element Description Categories Parents† Children Attributes Interface

a p239 p132 p133 p134 p137 p285 p285 p285 p240 Hyperlink flow ; phrasing transparent * globals ; href ; target ; download ; HTMLAnchorElement

phrasingp133 p285 p285 p285 p285 *; ping ; rel ; hreflang ; type ;

interactive p133 p285 ; referrerpolicy

palpable p134

abbr p251 p132 p133 p137 p125 p133 Abbreviation flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

address p199 p132 p132 p132 p137 p125 Contact flow ; flow flow * globals HTMLElement

information p134 palpable

for a page or

article p181

element

area p444 p133 p137 p445 p446 p132 p445 p445 Hyperlink or flow ; phrasing * empty globals ; alt ; coords ; shape ; HTMLAreaElement

dead area on p133 p285 p285 p285 p285 phrasing href ; target ; download ; ping ;

an image relp285; referrerpolicyp285

map

article p181 p132 p132 p132 p137 p125 Self-flow ; flow flow globals HTMLElement

contained sectioningp132;

syndicatable p134 palpable

or reusable

composition

aside p189 p132 p132 p132 p137 p125 Sidebar for flow ; flow flow globals HTMLElement

tangentially p132 sectioning;

related p134 palpable

content

audio p384 p132 p133 p318 p137 p390 p391 p385 Audio player flow ; phrasing source *; globals ; src ; crossorigin ; HTMLAudioElement

phrasingp133 p385 p402 p408 p406 p438 ; track *; preload ; autoplay ; loop ; muted;

embeddedp133 p134 p437 ; transparent * controls

interactive p133;

palpable p134*

b p274 p132 p133 p133 p137 p125 Keywords flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

base p156 p132 p154 p137 p157 p157 p156 Base URL and metadata head empty globals ; href ; target HTMLBaseElement

default target

browsing

context p814

for

hyperlinks p285

and p573 forms

bdi p279 p132 p133 p133 p137 p125 Text flow ; phrasing phrasing globals HTMLElement

directionality p133 phrasing ;

isolation palpablep134

bdo p280 p132 p133 p133 p137 p125 Text flow ; phrasing phrasing globals HTMLElement

directionality p133 phrasing ;

formatting p134 palpable

blockquote p219 p132 p132 p132 p137 p219 p219 A section flow ; flow flow globals ; cite HTMLQuoteElement

quoted from sectioning

another p200 root;

source p134 palpable

bodyp179 Document sectioning htmlp153 flowp132 globalsp137 ; onafterprintp950 ; HTMLBodyElementp180

1252

Element Description Categories Parents† Children Attributes Interface

body rootp200 onbeforeprintp950; onbeforeunloadp950;

onhashchange p950 p950 ; onlanguagechange;

onmessage p950 p950 ; onmessageerror;

onoffline p950 p950 p950 ; ononline ; onpagehide;

onpageshow p950 p950 ; onpopstate;

onrejectionhandled p950 p950 ; onstorage;

onunhandledrejection p950 p950 ; onunload

br p281 p132 p133 p137 p281 Line break, flow ; phrasing empty globals HTMLBRElement

e.g. in poem p133 phrasing

or postal

address

button p536 p132 p133 p133 p137 p571 p567 p537 Button control flow ; phrasing phrasing * globals ; disabled ; form ; HTMLButtonElement

phrasingp133 p572 p573 ; formaction ; formenctype;

interactive p133 p572 p573 ; formmethod ; formnovalidate;

listed p487 p573 p569 p537 p538 ; formtarget ; name ; type ; value

labelablep487 ;

submittablep487;

form-

associated p487 ;

palpable p134

canvas p635 p132 p133 p134 p137 p636 p636 p635 Scriptable flow ; phrasing transparent globals ; width ; height HTMLCanvasElement

bitmap p133 phrasing ;

canvas p133 embedded ;

palpable p134

caption p459 p451 p132 p137 p459 Table caption none table flow * globals HTMLTableCaptionElement

cite p247 p132 p133 p133 p137 p125 Title of a work flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

code p268 p132 p133 p133 p137 p125 Computer flow ; phrasing phrasing globals HTMLElement

code p133 phrasing ;

palpablep134

col p461 p460 p137 p461 p461 Table column none colgroup empty globals ; span HTMLTableColElement

colgroup p460 p451 p461 p137 p461 p461 Group of none table col *; globals ; span HTMLTableColElement

columns in a p630 template *

table

data p260 p132 p133 p133 p137 p261 p261 Machine-flow ; phrasing phrasing globals ; value HTMLDataElement

readable p133 phrasing ;

equivalent p134 palpable

datalist p544 p132 p133 p133 p137 p544 Container for flow ; phrasing phrasing *; globals HTMLDataListElement

options for phrasingp133 optionp546 *;

combo box script-

control p529 supporting

elements p134*

dd p232 p228 p238 p132 p137 p125 Content for none dl ; div * flow globals HTMLElement

corresponding

dt p231

element(s)

del p313 p132 p133 p134 p137 p314 p314 p314 A removal flow ; phrasing transparent globals ; cite ; datetime HTMLModElement

from the p133 phrasing *

document

details p605 p132 p132 p608 p137 p605 p605 Disclosure flow ; flow summary *; globals ; open HTMLDetailsElement

control for sectioning flowp132

hiding details p200 root;

interactive p133;

palpable p134

dfn p250 p132 p133 p133 p137 p125 Defining flow ; phrasing phrasing * globals HTMLElement

instance p133 phrasing ;

palpable p134

dialog p611 p132 p132 p132 p137 p612 p612 Dialog box or flow ; flow flow globals ; open HTMLDialogElement

window sectioning

root p200

div p238 p132 p132 p132 p228 p137 p239 Generic flow flow ; flow ; dl flow globals HTMLDivElement

container, or p134 palpable

container for

name-value

groups in

dl p228

1253

Element Description Categories Parents† Children Attributes Interface

elements

dl p228 p132 p132 p231 p232 p137 p228 Association flow ; flow dt *; dd *; globals HTMLDListElement

list consisting p134 p238 palpable div *; script-

of zero or supporting

more name- p134 elements

value groups

dt p231 p228 p238 p132 p137 p125 Legend for none dl ; div * flow * globals HTMLElement

corresponding

dd p232

element(s)

em p242 p132 p133 p133 p137 p125 Stress flow ; phrasing phrasing globals HTMLElement

emphasis p133 phrasing ;

palpable p134

embed p369 p45 p132 p133 p137 p370 p370 p450 p370 Plugin flow ; phrasing empty globals ; src ; type ; width ; HTMLEmbedElement

phrasingp133 p450 ; height; any*

embeddedp133 ;

interactive p133;

palpable p134

fieldset p563 p132 p132 p566 p137 p564 p567 p569 p563 Group of form flow ; flow legend *; globals ; disabled ; form ; name HTMLFieldSetElement

controls sectioning p132 flow

root p200;

listed p487; form-

associated p487 ;

palpable p134

figcaption p236 p233 p132 p137 p125 Caption for none figure flow globals HTMLElement

figure p233

figure p233 p132 p236 p132 p137 p125 Figure with flow ; flow figcaption *; globals HTMLElement

optional sectioning p132 flow

caption p200 root;

palpable p134

footer p196 p132 p132 p132 p137 p125 Footer for a flow ; flow flow * globals HTMLElement

page or p134 palpable

section

form p487 p132 p132 p132 p137 p488 p572 p488 User-flow ; flow flow * globals ; accept-charset ; action ; HTMLFormElement

submittable p134 p489 p573 p572 palpable autocomplete ; enctype ; method;

form p488 p573 p573 name ; novalidate ; target

h1 p191 p191 p132 p566 p133 p137 p191 , h2 , Section flow ; legend ; phrasing globals HTMLHeadingElement

h3 p191 p191 p133 p608 , h4 , heading heading ; summary;

h5 p191 p191 p134 p132 , h6 palpable flow

head p154 p137 p153 p154 Container for none html metadata globals HTMLHeadElement

document p132 content*

metadata

header p195 p132 p132 p132 p137 p125 Introductory flow ; flow flow * globals HTMLElement

or p134 palpable

navigational

aids for a

page or

section

hgroup p193 p132 p566 p191 p191 p137 p125 heading flow ; legend ; h1 ; h2 ; globals HTMLElement

group p133 p608 p191 p191 heading ; summary ; h3 ; h4 ;

palpable p134 p132 p191 p191 flow h5 ; h6 ;

script-

supporting

elements p134

hr p215 p132 p132 p137 p216 Thematic flow flow empty globals HTMLHRElement

break

html p153 p154 p137 p1225 p153 Root element none none* head *; globals ; manifest HTMLHtmlElement

body p179 *

i p273 p133 p132 p133 p137 p125 Alternate flow ; phrasing phrasing globals HTMLElement

voice p133 phrasing ;

palpable p134

iframe p362 p132 p133 p137 p362 p363 p366 p362 Nested flow ; phrasing empty globals ; src ; srcdoc ; name ; HTMLIFrameElement

browsing p133 p366 p368 p368 phrasing ; sandbox ; allow ; allowfullscreen;

context p817 p133 p450 p450 p369 embedded ; width ; height ; referrerpolicy;

interactive p133 p369 ; loading

palpable p134

img p321 p132 p133 p137 p322 p322 p322 p321 Image flow ; phrasing ; empty globals ; alt ; src ; srcset ; HTMLImageElement

1254

Element Description Categories Parents† Children Attributes Interface

phrasingp133 ; picturep317 sizesp322; crossoriginp322; usemapp446;

embeddedp133 p324 p450 p450 ; ismap ; width ; height;

interactive p133 p322 p322 *; referrerpolicy ; decoding;

form- p322 loading

associated p487 ;

palpable p134

input p494 p132 p133 p137 p517 p520 p495 Form control flow ; phrasing empty globals ; accept ; alt ; HTMLInputElement

phrasingp133 p574 p498 p570 ; autocomplete ; checked ; dirname;

interactive p133 p571 p567 p572 *; disabled ; form ; formaction;

listed p487 p573 p572 ; formenctype ; formmethod;

labelablep487 p573 p573 ; formnovalidate ; formtarget;

submittable p487 p450 p529 p527 p523 ; height ; list ; max ; maxlength ;

resettable p487 p527 p523 p525 p569 ; min ; minlength ; multiple ; name;

form- p526 p531 p523 pattern ; placeholder ; readonly;

associated p487 p524 p523 p519 p528 ; required ; size ; src ; step ;

palpablep134* p496 p498 p450 type ; value ; width

ins p312 p134 p132 p133 p137 p314 p314 p314 An addition to flow ; phrasing transparent globals ; cite ; datetime HTMLModElement

the document p133 phrasing *;

palpable p134

kbd p271 p132 p133 p133 p137 p125 User input flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

label p491 p132 p133 p133 p137 p492 p492 Caption for a flow ; phrasing phrasing * globals ; for HTMLLabelElement

form control p133 phrasing ;

interactive p133;

palpable p134

legend p566 p563 p133 p137 p566 Caption for none fieldset phrasing ; globals HTMLLegendElement

fieldset p563 heading

content p133

li p225 p222 p223 p132 p137 p226 p226 List item none ol ; ul ; flow globals ; value * HTMLLIElement

menu p224*

link p158 p132 p154 p137 p159 p159 p159 p158 Link metadata ; head ; empty globals ; href ; crossorigin ; rel ; HTMLLinkElement

metadata p132 p628 p161 p160 p160 p160 flow *; noscript *; as ; media ; hreflang ; type ;

phrasingp133 p133 p161 p160 p160 * phrasing * sizes ; imagesrcset ; imagesizes;

referrerpolicy p160 p160 ; integrity;

color p162 p162 ; disabled

main p237 p132 p132 p132 p137 p125 Container for flow ; flow * flow globals HTMLElement

the dominant p134 palpable

contents of

the document

map p443 p132 p133 p134 p137 p443 p443 Image flow ; phrasing transparent ; globals ; name HTMLMapElement

map p446 p133 p444 phrasing *; area *

palpable p134

mark p276 p133 p133 p132 p137 p125 Highlight flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

MathML p132 p133 p1279 math MathML root flow ; phrasing per per [MATHML] Element

phrasingp133 p1279 ; [MATHML]

embeddedp133 ;

palpable p134

menu p224 p132 p132 p225 p137 p225 Menu of flow ; flow li ; script-globals HTMLMenuElement

commands p134 palpable* supporting

elements p134

meta p165 p132 p154 p137 p166 p171 p166 Text metadata ; head ; empty globals ; name ; http-equiv ; HTMLMetaElement

metadata p132 p628 p166 p166 flow *; noscript *; content ; charset

phrasingp133 p133 * phrasing*

meter p558 p137 p559 p559 p559 p132 p133 p133 p559 p559 Gauge flow ; phrasing phrasing * globals ; value ; min ; max ; low ; HTMLMeterElement

phrasingp133 p559 p559 ; high ; optimum

labelablep487 ;

palpable p134

nav p186 p132 p132 p132 p137 p125 Section with flow ; flow flow globals HTMLElement

navigational p132 sectioning;

links p134 palpable

noscriptp628 Fallback metadatap132; headp154*; varies* globalsp137 HTMLElementp125

content for p132 p133 flow ; phrasing*

script p133 phrasing

object p373 p132 p133 p379 p137 p374 p375 p375 p374 Image, flow ; phrasing param *; globals ; data ; type ; name ; HTMLObjectElement

1255

Element Description Categories Parents† Children Attributes Interface

nested phrasingp133 ; transparent p134 usemapp446; formp567; widthp450; heightp450

browsing p133 embedded ;

contextp817, or p133 interactive*;

plugin p45 p487 listed;

submittable p487;

form-

associated p487 ;

palpable p134

ol p222 p132 p225 p137 p222 p222 p222 p222 p132 Ordered list flow ; flow li ; script-globals ; reversed ; start ; type HTMLOListElement

palpable p134* supporting

elements p134

optgroup p545 p538 p546 p137 p546 p546 p546 Group of none select option ; globals ; disabled ; label HTMLOptGroupElement

options in a script-

list box supporting

elements p134

optionp546 Option in a none selectp538; textp133* globalsp137 ; disabledp547; labelp547; HTMLOptionElement p547

list box or p544 p548 p547 datalist ; selected ; value

combo box p545 optgroup

control

output p554 p132 p133 p133 p137 p555 p567 p569 p555 Calculated flow ; phrasing phrasing globals ; for ; form ; name HTMLOutputElement

output value p133 phrasing ;

listed p487;

labelablep487 ;

resettable p487;

form-

associated p487 ;

palpable p134

p p213 p132 p132 p133 p137 p213 Paragraph flow ; flow phrasing globals HTMLParagraphElement

palpablep134

param p379 p373 p137 p379 p379 p379 Parameter for none object empty globals ; name ; value HTMLParamElement

object p373

picture p317 p132 p133 p318 p137 p317 Image flow ; phrasing source *; one globals HTMLPictureElement

phrasingp133 p321 ; img ; script-

embeddedp133 supporting

elements p134

pre p217 p132 p132 p133 p137 p217 Block of flow ; flow phrasing globals HTMLPreElement

preformatted p134 palpable

text

progress p556 p132 p133 p133 p557 p137 p557 p557 Progress bar flow ; phrasing phrasing * globals ; value ; max HTMLProgressElement

phrasingp133 ;

labelablep487 ;

palpable p134

q p248 p132 p133 p133 p137 p249 p219 Quotation flow ; phrasing phrasing globals ; cite HTMLQuoteElement

phrasingp133 ;

palpable p134

rp p259 p253 p133 p137 p125 Parenthesis none ruby text globals HTMLElement

for ruby

annotation

text

rt p259 p253 p133 p137 p125 Ruby none ruby phrasing globals HTMLElement

annotation

text

ruby p253 p133 p132 p133 p137 p125 Ruby flow ; phrasing phrasing ; globals HTMLElement

annotation(s) p133 p259 p259 phrasing ; rt ; rp *

palpable p134

s p246 p132 p133 p133 p137 p125 Inaccurate flow ; phrasing phrasing globals HTMLElement

text p133 phrasing ;

palpable p134

samp p270 p132 p133 p133 p137 p125 Computer flow ; phrasing phrasing globals HTMLElement

output p133 phrasing ;

palpable p134

script p614 p132 p154 p137 p616 p615 p616 p615 Embedded metadata ; head ; script, data, or globals ; src ; type ; async ; HTMLScriptElement

script p132 p133 p616 p617 p617 flow ; phrasing ; script defer ; crossorigin ; integrity;

phrasingp133 ; script- documentation* referrerpolicyp617

script- p134 supporting

supporting p134

section p183 p132 p132 p132 p137 p125 Generic flow ; flow flow globals HTMLElement

1256

Element Description Categories Parents† Children Attributes Interface

document or sectioningp132;

application p134 palpable

section

select p538 p132 p133 p546 p137 p574 p571 p539 List box flow ; phrasing option ; globals ; autocomplete ; disabled ; HTMLSelectElement

control p133 p545 p567 p540 p569 p540 phrasing ; optgroup ; form ; multiple ; name ; required;

interactive p133 p540 ; script-size

listed p487; supporting

labelablep487 p134 ; elements

submittable p487;

resettable p487;

form-

associated p487 ;

palpable p134

slot p633 p132 p133 p134 p137 p634 p634 Shadow tree flow ; phrasing transparent globals ; name HTMLSlotElement

slot p133 phrasing

smallp245 Side flowp132 ; phrasingp133 phrasingp133 globalsp137 HTMLElementp125

comment p133 phrasing ;

palpable p134

source p318 p317 p137 p319 p318 p318 p318 Image source none picture ; empty globals ; src ; type ; srcset ; HTMLSourceElement

for p321 p380 p319 p319 img or video ; sizes ; media

media source p384 audio

for p380 video

or p384 audio

span p280 p132 p133 p133 p137 p281 Generic flow ; phrasing phrasing globals HTMLSpanElement

phrasing p133 phrasing ;

container p134 palpable

strong p243 p132 p133 p133 p137 p125 Importance flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

style p175 p132 p154 p137 p176 p176 Embedded metadata head ; text* globals ; media HTMLStyleElement

styling p628 noscript*

information

subp272 Subscript flowp132 ; phrasingp133 phrasingp133 globalsp137 HTMLElementp125

phrasingp133 ;

palpable p134

summary p608 p133 p605 p137 p125 Caption for none details phrasing ; globals HTMLElement

details p605 heading

content p133

sup p272 p132 p133 p133 p137 p125 Superscript flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

SVG p132 p133 p1281 p1281 svg SVG root flow ; phrasing per [SVG] per [SVG] SVGSVGElement

phrasingp133 ;

embeddedp133 ;

palpable p134

table p451 p132 p459 p137 p452 p132 Table flow ; flow caption *; globals HTMLTableElement

palpablep134 colgroupp460 *;

thead p463 *;

tbody p462 *;

tfoot p464 *;

tr p465 *; script-

supporting

elements p134

tbody p462 p451 p465 p137 p462 Group of rows none table tr ; script-globals HTMLTableSectionElement

in a table supporting

elements p134

td p466 p465 p132 p137 p470 p470 p467 Table cell sectioning tr flow globals ; colspan ; rowspan ; HTMLTableCellElement

rootp200 p470 headers

template p630 p132 p132 p137 p631 Template metadata ; metadata ; empty globals HTMLTemplateElement

flowp132 p133 ; phrasing;

phrasingp133 ; script-

script- p134 supporting;

supporting p134 p460 colgroup*

textarea p549 p132 p133 p133 p137 p551 p570 p550 Multiline text flow ; phrasing text globals ; cols ; dirname ; HTMLTextAreaElement

controls p133 p571 p567 p552 phrasing ; disabled ; form ; maxlength;

interactive p133 p552 p569 p552 ; minlength ; name ; placeholder;

listed p487 p550 p552 p551 p552 ; readonly ; required ; rows ; wrap

1257

Element Description Categories Parents† Children Attributes Interface

labelablep487 ;

submittable p487;

resettable p487;

form-

associated p487 ;

palpable p134

tfoot p464 p451 p465 p137 p462 Group of none table tr ; script-globals HTMLTableSectionElement

footer rows in supporting

a table elements p134

th p468 p133 p465 p132 p137 p470 p470 p467 Table header interactive * tr flow * globals ; colspan ; rowspan ; HTMLTableCellElement

cell p470 p468 p469 headers ; scope ; abbr

thead p463 p451 p465 p137 p462 Group of none table tr ; script-globals HTMLTableSectionElement

heading rows supporting

in a table p134 elements

time p261 p132 p133 p133 p137 p262 p262 Machine-flow ; phrasing phrasing globals ; datetime HTMLTimeElement

readable p133 phrasing ;

equivalent of p134 palpable

date- or time-

related data

title p155 p132 p154 p133 p137 p155 Document metadata head text * globals HTMLTitleElement

title

tr p465 p451 p468 p466 p137 p465 Table row none table ; th *; td ; globals HTMLTableRowElement

thead p463; script-

tbody p462; supporting

tfoot p464 p134 elements

track p385 p384 p137 p387 p386 p387 p386 Timed text none audio ; empty globals ; default ; kind ; label ; HTMLTrackElement

track p380 p386 p387 video src ; srclang

u p276 p132 p133 p133 p137 p125 Unarticulated flow ; phrasing phrasing globals HTMLElement

annotation p133 phrasing ;

palpable p134

ul p223 p132 p132 p225 p137 p224 List flow ; flow li ; script-globals HTMLUListElement

palpable p134* supporting

elements p134

var p269 p132 p133 p133 p137 p125 Variable flow ; phrasing phrasing globals HTMLElement

phrasingp133 ;

palpable p134

video p380 p132 p133 p318 p137 p390 p391 p381 Video player flow ; phrasing source *; globals ; src ; crossorigin ; HTMLVideoElement

phrasingp133 p385 p381 p402 p408 ; track *; poster ; preload ; autoplay;

embeddedp133 p134 p382 p406 p438 ; transparent * playsinline ; loop ; muted;

interactive p133 p437 p450 p450 ; controls ; width ; height

palpable p134

wbr p282 p132 p133 p137 p125 Line breaking flow ; phrasing empty globals HTMLElement

opportunity p133 phrasing

autonomous p132 p132 p134 p137 Author-flow ; flow ; transparent globals ; any, as decided by the element's Supplied by the element's

custom p133 p133 defined phrasing ; phrasing author author (inherits from

elements p705 p134 p125 elements palpable HTMLElement )

An asterisk (*) in a cell indicates that the actual rules are more complicated than indicated in the table above. † Categories in the "Parents" column refer to parents that list the given categories in their content model, not to elements that themselves are in

those categories. For example, the p239 a element's "Parents" column says "phrasing", so any element whose content model contains the "phrasing"

category could be a parent of an p239 p468 a element. Since the "flow" category includes all the "phrasing" elements, that means the th element could be

a parent to an p239 a element.



Element content categories p12 §

58

This section is non-normative.

List of element content categories

Category Elements Elements with exceptions

Metadata p156 p158 p165 p628 p614 p175 p630 p155 base ; link ; meta ; noscript ; script ; style ; template ; title —

content p132

Flow p239 p251 p199 p181 p189 p384 p274 p279 p280 p444 p443 a ; abbr ; address ; article ; aside ; audio ; b ; bdi ; bdo ; area (if it is a descendant of a map

content p132 p219 p281 p536 p635 p247 p268 p260 p544 p158 blockquote ; br ; button ; canvas ; cite ; code ; data ; datalist ; element); link (if it is allowed in the

1258

Category Elements Elements with exceptions

delp313; detailsp605; dfnp250; dialogp611; divp238; dlp228; emp242 ; embedp369 ; fieldsetp563 ; bodyp159); mainp237 (if it is a hierarchically correct

figure p233 p196 p487 p191 p191 p191 p191 p191 p191 p195 p237 p165 p739 ; footer ; form ; h1 ; h2 ; h3 ; h4 ; h5 ; h6 ; header ; main element ); meta (if the itemprop

hgroup p193 p215 p273 p362 p321 p494 p312 p271 p491 p443 ; hr ; i ; iframe ; img ; input ; ins ; kbd ; label ; map; attribute is present)

mark p276 p224 p558 p186 p628 p373 p222 ; MathML math ; menu ; meter ; nav ; noscript ; object ; ol ;

output p554 p213 p317 p217 p556 p248 p253 p246 p270 p614 ; p ; picture ; pre ; progress ; q ; ruby ; s ; samp ; script;

section p183 p538 p633 p245 p280 p243 p272 p272 ; select ; slot ; small ; span ; strong ; sub ; sup ; SVG svg;

table p451 p630 p549 p261 p276 p223 p269 p380 p282 ; template ; textarea ; time ; u ; ul ; var ; video ; wbr ;

autonomous custom elementsp705; Textp133

Sectioning p181 p189 p186 p183 article ; aside ; nav ; section —

content p132

Heading p191 p191 p191 p191 p191 p191 p193 h1 ; h2 ; h3 ; h4 ; h5 ; h6 ; hgroup —

content p133

Phrasing p239 p251 p384 p274 p279 p280 p281 p536 p635 p247 p444 p443 a ; abbr ; audio ; b ; bdi ; bdo ; br ; button ; canvas ; cite ; area (if it is a descendant of a map

content p133 p268 p260 p544 p313 p250 p242 p369 p273 p362 p321 p158 code ; data ; datalist ; del ; dfn ; em ; embed ; i ; iframe ; img ; element); link (if it is allowed in the

input p494 p312 p271 p491 p443 p276 p558 p628 p159 p165 p739 ; ins ; kbd ; label ; map ; mark ; MathML math ; meter ; noscript ; body ); meta (if the itemprop attribute

object p373 p554 p317 p556 p248 p253 p246 p270 p614 ; output ; picture ; progress ; q ; ruby ; s ; samp ; script ; is present)

select p538 p633 p245 p280 p243 p272 p272 p630 ; slot ; small ; span ; strong ; sub ; sup ; SVG svg ; template;

textarea p549 p261 p276 p269 p380 p282 p705 ; time ; u ; var ; video ; wbr ; autonomous custom elements;

Text p133

Embedded p384 p635 p369 p362 p321 p373 p317 audio ; canvas ; embed ; iframe ; img ; MathML math ; object ; picture; —

content p133 p380 SVG svg ; video

Interactive p536 p605 p369 p362 p491 p538 p549 p239 p285 button ; details ; embed ; iframe ; label ; select ; textarea a (if the href attribute is present);

contentp133 p384 p437 audio (if the controls attribute is

present); p321 p446 img (if the usemap attribute is

present); p494 p496 input (if the type attribute is not

in the p500 p373 Hidden state); object (if the

usemap p446 p380 attribute is present); video (if the

controls p437 attribute is present)

Sectioning p219 p179 p605 p611 p563 p233 p466 blockquote ; body ; details ; dialog ; fieldset ; figure ; td —

roots p200

Form- p536 p563 p494 p491 p373 p554 p538 button ; fieldset ; input ; label ; object ; output ; select; —

associated p549 p321 p706 textarea ; img ; form-associated custom elements

elements p487

Listed p536 p563 p494 p373 p554 p538 p549 button ; fieldset ; input ; object ; output ; select ; textarea; form- —

elements p487 p706 associated custom elements

Submittable p536 p494 p373 p538 p549 button ; input ; object ; select ; textarea; form-associated custom —

elements p487 p706 elements

Resettable p494 p554 p538 p549 p706 input ; output ; select ; textarea ; form-associated custom elements —

elements p487

Autocapitalize- p536 p563 p494 p554 p538 p549 button ; fieldset ; input ; output ; select ; textarea —

inheriting

elements p487

Labelable p536 p494 p558 p554 p556 p538 p549 button ; input ; meter ; output ; progress ; select ; textarea; form- —

elements p487 p706 associated custom elements

Palpable p239 p251 p199 p181 p189 p274 p279 p280 p219 p384 p437 a ; abbr ; address ; article ; aside ; b ; bdi ; bdo ; blockquote ; audio (if the controls attribute is

content p134 p536 p635 p247 p268 p260 p605 p250 p238 p242 p228 button ; canvas ; cite ; code ; data ; details ; dfn ; div ; em ; present); dl (if the element's children include

embed p369 p563 p233 p196 p487 p191 p191 p191 p191 p191 p494 ; fieldset ; figure ; footer ; form ; h1 ; h2 ; h3 ; h4 ; h5 ; at least one name-value group); input (if the

h6 p191 p195 p193 p273 p362 p321 p312 p271 p491 p237 p496 p500 ; header ; hgroup ; i ; iframe ; img ; ins ; kbd ; label ; main ; type attribute is not in the Hidden state);

map p443 p276 p558 p186 p373 p554 p213 p217 p224 ; mark ; MathML math ; meter ; nav ; object ; output ; p ; pre ; menu (if the element's children include at least

progress p556 p248 p253 p246 p270 p183 p538 p245 p280 p225 p222 ; q ; ruby ; s ; samp ; section ; select ; small ; span ; one li element); ol (if the element's

strongp243 ; subp272; supp272; SVG svg; table p451; textareap549 ; timep261 ; up276 ; varp269; children include at least one lip225 element);

video p380 p705 p223 ; autonomous custom elements ul (if the element's children include at least

one p225 p133 li element); Text that is not inter-

element whitespace p130

Script- p614 p630 script ; template —

supporting

elements p134



Attributes p12 §

59

This section is non-normative.



1259

List of attributes (excluding event handler content attributes)

Attribute Element(s) Description Value

abbr p469 th Alternative label to use for the p130 Text*

header cell when referencing the

cell in other contexts

accept p517 p87 input Hint for expected file type in file Set of comma-separated tokens* consisting of valid MIME type strings with

upload controls p516 no parameters or audio/*, video/*, or image/*

accept-charset p488 form Character encodings to use for ASCII case-insensitive match for "UTF-8"

form submission p596

accesskey p788 HTML elements Keyboard shortcut to activate or p87 Ordered set of unique space-separated tokens , none of which are identical to

focus element another, each consisting of one code point in length

action p572 form URL to use for form p88 Valid non-empty URL potentially surrounded by spaces

submission p596

allow p368 iframe Permissions policy to be applied Serialized permissions policy

to the iframep362's contents

allowfullscreen p368 p362 p67 iframe Whether to allow the iframe 's Boolean attribute

contents to use

requestFullscreen()

alt p445 p322 p130 area ; img ; Replacement text for use when Text*

input p520 images are not available

as linkp161 Potential destination for a preload Potential destination, for relp159 ="preloadp306"; script-like destination, for

request (for p159 p302 rel =" modulepreload"

relp159="preloadp306 " and

rel p159 p302 =" modulepreload ")

async p616 p67 script Execute script when available, Boolean attribute

without blocking while fetching

autocapitalize p794 p795 p795 HTML elements Recommended autocapitalization p795 p795 p795 p795 " on "; " off "; " none "; " sentences "; " words "; " characters "

behavior (for supported input

methods)

autocomplete p489 form Default setting for autofill feature "on"; "off"

for controls in the form

autocomplete p574 p574 p576 input ; select ; Hint for form autofill feature Autofill field name and related tokens*

textarea p574

autofocus p785 HTML elements Automatically focus the element p67 Boolean attribute

when the page is loaded

autoplay p408 p408 p389 p67 audio ; video Hint that the media resource Boolean attribute

can be started automatically

when the page is loaded

charset p166 meta Character encoding "utf-8"

declaration p174

checked p498 p67 input Whether the control is checked Boolean attribute

cite p219 p314 p88 blockquote ; del ; Link to the source of the Valid URL potentially surrounded by spaces

ins p314 p249 ; q quotation or more information

about the edit

class p138 p87 HTML elements Classes to which the element Set of space-separated tokens

belongs

color p162 link Color to use when customizing a CSS <color>

site's icon (for p159 rel="mask-

icon")

cols p551 p69 textarea Maximum number of characters Valid non-negative integer greater than zero

per line

colspan p470 p470 td ; th Number of columns that the cell p69 Valid non-negative integer greater than zero

is to span

content p166 p130 meta Value of the element Text*

contenteditable p790 HTML elements Whether the element is editable "true"; "false"

controls p437 p437 p67 audio ; video Show user agent controls Boolean attribute

coords p446 area Coordinates for the shape to be p72 Valid list of floating-point numbers *

created in an p446 image map

crossorigin p391 p322 p91 p91 audio ; img ; How the element handles " anonymous "; " use-credentials"

link p159 p617 ; script; crossorigin requests

video p391

data p374 p88 object Address of the resource Valid non-empty URL potentially surrounded by spaces

datetime p314 p314 p85 del ; ins Date and (optionally) time of the Valid date string with optional time

change

1260

Attribute Element(s) Description Value

datetime timep262 Machine-readable value Valid month stringp74, valid date string p75, valid yearless date stringp75, valid

time string p76 p77 , valid local date and time string, valid time-zone offset

string p78 p79 p81 , valid global date and time string , valid week string , valid non-

negative integer p69 p82 , or valid duration string

decoding p322 p339 img Decoding hint to use when p339 p339 " sync "; " async "; " auto"

processing this image for

presentation

default p387 p67 track Enable the track if no other text Boolean attribute

track p422 is more suitable

defer p616 p67 script Defer script execution Boolean attribute

dir p143 p143 p143 p143 p143 HTML elements The text directionality of the " ltr "; " rtl "; " auto"

element

dir p280 p143 p143 p143 bdo The text directionality of the " ltr "; " rtl"

element

dirname p570 p570 p130 input ; textarea Name of form control to use for Text*

sending the element's

directionality p143 in form

submission p596

disabled p571 p571 p67 button ; input ; Whether the form control is Boolean attribute

optgroup p546 p547 ; option; disabled

select p571 p571 ; textarea;

form-associated custom

elements p571

disabled p564 p67 fieldset Whether the descendant form Boolean attribute

controls, except any inside

legend p566, are disabled

disabled linkp162 Whether the link is disabled Boolean attributep67

download p285 p285 a ; area Whether to download the Text

resource instead of navigating to

it, and its file name if so

draggable HTML elementsp812 Whether the element is "true"; "false"

draggable

enctype p573 p573 p573 form Entry list encoding type to use for " application/x-www-form-urlencoded "; " multipart/form-data";

form submission p596 p573 " text/plain"

enterkeyhint p796 p796 p796 p796 p796 p796 p796 HTML elements Hint for selecting an enter key " enter "; " done "; " go "; " next "; " previous "; " search ";

action p796 " send"

for labelp492 Associate the label with form ID*

control

for p555 p87 output Specifies controls from which the Unordered set of unique space-separated tokens consisting of IDs*

output was calculated

form p567 p567 button ; fieldset; Associates the element with a ID*

input p567 p567 p487 ; object ; form element

output p567 p567 ; select;

textarea p567; form-

associated custom

elements p567

formaction p572 p572 p88 button ; input URL to use for form Valid non-empty URL potentially surrounded by spaces

submission p596

formenctype p573 p573 p573 p573 button ; input Entry list encoding type to use for " application/x-www-form-urlencoded "; " multipart/form-data";

form submissionp596 p573 " text/plain"

formmethod p572 p572 button ; input Variant to use for form "GET"; "POST"; "dialog"

submission p596

formnovalidate p573 p573 p67 button ; input Bypass form control validation for Boolean attribute

form submission p596

formtarget p573 p573 p814 p822 button ; input Browsing context for form Valid browsing context name or keyword

submission p596

headers tdp470; thp470 The header cells for this cell Unordered set of unique space-separated tokensp87 consisting of IDs*

height p636 p450 p69 canvas ; embed ; Vertical dimension Valid non-negative integer

iframe p450 p450 ; img;

input p450 p450 ; object;

video p450

hidden HTML elementsp768 Whether the element is relevant Boolean attributep67

high p559 p69 meter Low limit of high range Valid floating-point number*

href p285 p285 p284 p88 a ; area Address of the hyperlink Valid URL potentially surrounded by spaces

1261

Attribute Element(s) Description Value

href linkp159 Address of the hyperlinkp284 Valid non-empty URL potentially surrounded by spaces p88

href p157 p89 p88 base Document base URL Valid URL potentially surrounded by spaces

hreflang p285 p160 a ; link Language of the linked resource Valid BCP 47 language tag

http-equiv p171 p171 p171 meta Pragma directive p171 " content-type "; " default-style "; " refresh "; "x-ua-

compatiblep171 "; "content-security-policy p171"

id p138 p130 HTML elements The element's ID Text*

imagesizes p160 p336 link Image sizes for different page Valid source size list

layouts (for

rel p159 p306 =" preload ")

imagesrcset p160 link Images to use in different p336 Comma-separated list of image candidate strings

situations, e.g., high-resolution

displays, small monitors, etc. (for

rel p159 p306 =" preload ")

inputmode p796 p796 HTML elements Hint for selecting an input p796 p796 p796 p796 p796 " none "; " text "; " tel "; " email "; " url "; " numeric ";

modality p796 p796 " decimal "; " search"

integrity p160 p617 p130 link ; script Integrity metadata used in Text

Subresource Integrity checks

[SRI] p1281

is p705 p706 p705 HTML elements Creates a customized built-in Valid custom element name of a defined customized built-in element

element p705

ismap p324 p67 img Whether the image is a server-Boolean attribute

side image map

itemid p738 p738 p88 HTML elements Global identifier for a Valid URL potentially surrounded by spaces

microdata item

itemprop p739 p740 p87 HTML elements Property names of a Unordered set of unique space-separated tokens consisting of valid absolute

microdata item p740 URLs , defined property names, or text*

itemref p738 p124 p87 HTML elements Referenced elements Unordered set of unique space-separated tokens consisting of IDs*

itemscope p737 p67 HTML elements Introduces a microdata item Boolean attribute

itemtype p737 p737 p87 HTML elements Item types of a microdata Unordered set of unique space-separated tokens consisting of valid absolute

item URLs*

kind p386 p386 p386 p386 p386 track The type of text track " subtitles "; " captions "; " descriptions "; " chapters ";

" p386 metadata"

label p546 p547 p130 optgroup ; option ; User-visible label Text

track p387

lang p141 p141 HTML elements Language of the element Valid BCP 47 language tag or the empty string

list p529 input List of autocomplete options ID*

loading p322 p369 p93 p93 img ; iframe Used when determining loading " lazy "; " eager"

deferral

loop p406 p406 audio ; video Whether to loop the media p67 Boolean attribute

resource p389

low p559 p69 meter High limit of low range Valid floating-point number*

max p527 input Maximum value Varies*

max p559 p557 p69 meter ; progress Upper bound of range Valid floating-point number*

maxlength p523 p552 p69 input ; textarea Maximum length of value Valid non-negative integer

media p160 p319 p88 link ; source ; Applicable media Valid media query list

style p176

method p572 p572 p572 p572 form Variant to use for form " GET "; " POST "; " dialog"

submission p596

min p527 input Minimum value Varies*

min p559 p69 meter Lower bound of range Valid floating-point number*

minlength p523 p552 p69 input ; textarea Minimum length of value Valid non-negative integer

multiple p525 p540 p67 input ; select Whether to allow multiple values Boolean attribute

muted p438 p438 p67 audio ; video Whether to mute the media Boolean attribute

resource p389 by default

name p569 p569 p130 button ; fieldset ; Name of the element to use for Text*

input p569 p569 p596 ; output ; form submission and in the

select p569 p569 p489 ; textarea ; form.elements API

form-associated custom

elements p569

name p488 p130 form Name of form to use in the Text*

document.forms p120 API

1262

Attribute Element(s) Description Value

name iframep366; objectp375 Name of nested browsing Valid browsing context name or keywordp822

contextp817

name p443 p446 p130 map Name of image map to Text*

referencep124 p446 from the usemap

attribute

name p166 meta Metadata name p130 Text*

name paramp379 Name of parameter Textp130

name p634 p130 slot Name of shadow tree slot Text

nomodule p616 p67 script Prevents execution in user agents Boolean attribute

that support p912 module scripts

nonce p92 p130 HTML elements Cryptographic nonce used in Text

Content Security Policy checks

[CSP] p1275

novalidate p573 form Bypass form control validation for p67 Boolean attribute

form submission p596

open p605 p67 details Whether the details are visible Boolean attribute

open p612 dialog Whether the dialog box is p67 Boolean attribute

showing

optimum meterp559 Optimum value in gauge Valid floating-point number p69*

pattern p526 input Pattern to be matched by the Regular expression matching the JavaScript Pattern production

form control's value

ping p285 p285 p87 p88 a ; area URLs to ping Set of space-separated tokens consisting of valid non-empty URLs

placeholder p531 p552 p130 input ; textarea User-visible label to be placed Text*

within the form control

playsinline p382 video Encourage the user agent to p67 Boolean attribute

display video content within the

element's playback area

poster p381 p88 video Poster frame to show prior to Valid non-empty URL potentially surrounded by spaces

video playback

preload p402 p402 p402 p402 p402 audio ; video Hints how much buffering the " none "; " metadata "; " auto"

media resourcep389 will likely

need

readonly inputp523; textareap550 Whether to allow the value to be Boolean attributep67

edited by the user

readonly p594 p67 form-associated custom Affects willValidate , plus Boolean attribute

elements p706 any behavior added by the

custom element author

referrerpolicy p285 p285 p369 a ; area ; iframe; Referrer policy for fetches Referrer policy

img p322 p160 ; link; initiated by the element

script p617

rel p285 p285 p87 a ; area Relationship between the location Unordered set of unique space-separated tokens *

in the document containing the

hyperlinkp284 and the destination

resource

rel p159 p87 link Relationship between the Unordered set of unique space-separated tokens *

document containing the

hyperlinkp284 and the destination

resource

required p524 p540 p67 input ; select ; Whether the control is required Boolean attribute

textarea p552 p596 for form submission

reversed p222 p67 ol Number the list backwards Boolean attribute

rows p551 p69 textarea Number of lines to show Valid non-negative integer greater than zero

rowspan p470 p470 p69 td ; th Number of rows that the cell is to Valid non-negative integer

span

sandbox p366 iframe Security rules for nested content p87 Unordered set of unique space-separated tokens , ASCII case-insensitive,

consisting of "allow-formsp847 ", "allow-modalsp847 ", "allow-orientation-

lock p847 p847 p847 ", " allow-pointer-lock ", " allow-popups ", "allow-popups-to-

escape-sandbox p847 p847 p847 ", " allow-presentation ", " allow-same-origin",

" p847 p847 allow-scripts " and " allow-top-navigation"

scope p468 p468 th Specifies which cells the header p468 p468 p469 " row "; " col "; " rowgroup "; " colgroup"

cell applies to

selected p548 p67 option Whether the option is selected by Boolean attribute

default

1263

Attribute Element(s) Description Value

shape areap445 The kind of shape to be created "circlep445"; "defaultp445"; "polyp445"; "rectp445"

in an p446 image map

size p523 p540 p69 input ; select Size of the control Valid non-negative integer greater than zero

sizes p161 p87 link Sizes of the icons (for Unordered set of unique space-separated tokens , ASCII case-insensitive,

rel p159 p299 =" icon") consisting of sizes*

sizes p322 p319 p336 img ; source Image sizes for different page Valid source size list

layouts

slot HTML elementsp138 The element's desired slot Textp130

span p461 p461 p69 col ; colgroup Number of columns spanned by Valid non-negative integer greater than zero

the element

spellcheck p792 HTML elements Whether the element is to have "true"; "false"

its spelling and grammar checked

src p390 p370 audio ; embed; Address of the resource p88 Valid non-empty URL potentially surrounded by spaces

iframe p362 p322 ; img;

input p519 p616 ; script;

source p319 p386 ; track;

video p390

srcdoc p363 p363 iframe A document to render in the The source of an iframe srcdoc document*

iframep362

srclang p387 track Language of the text track Valid BCP 47 language tag

srcset p322 p318 img ; source Images to use in different p336 Comma-separated list of image candidate strings

situations, e.g., high-resolution

displays, small monitors, etc.

start p222 p222 p68 ol Starting value of the list Valid integer

step p528 p69 input Granularity to be matched by the Valid floating-point number greater than zero, or "any"

form control's value

style p145 HTML elements Presentational and formatting CSS declarations*

instructions

tabindex p776 HTML elements Whether the element is p68 Valid integer

focusable p775 and sequentially

focusable p775, and the relative

order of the element for the

purposes of sequential focus

navigation p782

target ap285; areap285 Browsing contextp814 for Valid browsing context name or keywordp822

hyperlinkp284 p876 navigation

target p157 p814 p822 base Default browsing context for Valid browsing context name or keyword

hyperlinkp284 p876 navigation and

form submission p596

target formp573 Browsing contextp814 for form Valid browsing context name or keywordp822

submission p596

title p140 p130 HTML elements Advisory information for the Text

element

title p251 p250 p130 abbr ; dfn Full term or expansion of Text

abbreviation

title p527 input Description of pattern (when p130 Text

used with p526 pattern attribute)

title p160 p130 link Title of the link Text

title p160 p176 p130 link ; style CSS style sheet set name Text

translate p142 HTML elements Whether the element is to be "yes"; "no"

translated when the page is

localized

type p285 p160 a ; link Hint for the type of the Valid MIME type string

referenced resource

type buttonp537 Type of button "submitp537"; "resetp537"; "buttonp537"

type p370 p375 embed ; object; Type of embedded resource Valid MIME type string

source p318

type p496 p496 input Type of form control input type keyword

type olp222 Kind of list marker "1p223"; "ap223"; "Ap223"; "ip223"; "Ip223"

type p615 script Type of script "module"; a valid MIME type string that is not a JavaScript MIME type essence

match

usemap p446 p446 p446 p88 img ; object Name of image map to use Valid hash-name reference *

value p538 p547 p130 button ; option Value to be used for form Text

1264

Attribute Element(s) Description Value

submissionp596

value p261 p130 data Machine-readable value Text*

value p498 input Value of the form control Varies*

value p226 p226 p68 li Ordinal value of the list item Valid integer

value p559 p557 p69 meter ; progress Current value of the element Valid floating-point number

value p379 p130 param Value of parameter Text

width p636 p450 canvas ; embed; Horizontal dimension p69 Valid non-negative integer

iframe p450 p450 ; img;

input p450 p450 ; object;

video p450

wrap p552 p552 p552 textarea How the value of the form control " soft "; " hard"

is to be wrapped for form

submission p596

An asterisk (*) in a cell indicates that the actual rules are more complicated than indicated in the table above.



List of event handler content attributes ✔ MDN

Attribute Element(s) Description Value

onabort p948 p1271 p943 HTML elements abort event handler Event handler content attribute

onauxclick p948 p943 HTML elements auxclick event handler Event handler content attribute

onafterprint p950 p1271 p828 p943 body afterprint event handler for Window object Event handler content attribute

onbeforeprint p950 p1271 p828 p943 body beforeprint event handler for Window object Event handler content attribute

onbeforeunload p950 p1271 p828 p943 body beforeunload event handler for Window object Event handler content attribute

onblur p950 p1271 p943 HTML elements blur event handler Event handler content attribute

oncancel HTML elementsp948 cancelp1271 event handler Event handler content attribute p943

oncanplay p948 p440 p943 HTML elements canplay event handler Event handler content attribute

oncanplaythrough p948 p440 p943 HTML elements canplaythrough event handler Event handler content attribute

onchange p948 p1271 p943 HTML elements change event handler Event handler content attribute

onclick p948 p943 HTML elements click event handler Event handler content attribute

onclose p948 p1271 p943 HTML elements close event handler Event handler content attribute

oncontextmenu p948 p1271 p943 HTML elements contextmenu event handler Event handler content attribute

oncopy p950 p1271 p943 HTML elements copy event handler Event handler content attribute

oncuechange p948 p441 p943 HTML elements cuechange event handler Event handler content attribute

oncut p950 p1271 p943 HTML elements cut event handler Event handler content attribute

ondblclick HTML elementsp949 dblclick event handler Event handler content attribute p943

ondrag p949 p812 p943 HTML elements drag event handler Event handler content attribute

ondragend p949 p812 p943 HTML elements dragend event handler Event handler content attribute

ondragenter p949 p812 p943 HTML elements dragenter event handler Event handler content attribute

ondragleave p949 p812 p943 HTML elements dragleave event handler Event handler content attribute

ondragover p949 p812 p943 HTML elements dragover event handler Event handler content attribute

ondragstart p949 p812 p943 HTML elements dragstart event handler Event handler content attribute

ondrop p949 p812 p943 HTML elements drop event handler Event handler content attribute

ondurationchange p949 p441 p943 HTML elements durationchange event handler Event handler content attribute

onemptied p949 p440 p943 HTML elements emptied event handler Event handler content attribute

onended HTML elementsp949 endedp441 event handler Event handler content attribute p943

onerror p950 p1271 p943 HTML elements error event handler Event handler content attribute

onfocus p950 p1271 p943 HTML elements focus event handler Event handler content attribute

onformdata p949 p1271 p943 HTML elements formdata event handler Event handler content attribute

onhashchange p950 p1271 p828 p943 body hashchange event handler for Window object Event handler content attribute

oninput p949 p1271 p943 HTML elements input event handler Event handler content attribute

oninvalid p949 p1271 p943 HTML elements invalid event handler Event handler content attribute

onkeydown p949 p943 HTML elements keydown event handler Event handler content attribute

onkeypress p949 p943 HTML elements keypress event handler Event handler content attribute

onkeyup p949 HTML elements keyup event handler p943 Event handler content attribute

onlanguagechange bodyp950 languagechangep1271 event handler for Windowp828 object Event handler content attribute p943

onload p950 p1271 p943 HTML elements load event handler Event handler content attribute

1265

Attribute Element(s) Description Value

onloadeddata HTML elementsp949 loadeddatap440 event handler Event handler content attribute p943

onloadedmetadata p949 p440 p943 HTML elements loadedmetadata event handler Event handler content attribute

onloadstart p949 p440 p943 HTML elements loadstart event handler Event handler content attribute

onmessage p950 p1271 p828 p943 body message event handler for Window object Event handler content attribute

onmessageerror p950 p1272 p828 p943 body messageerror event handler for Window object Event handler content attribute

onmousedown p949 p943 HTML elements mousedown event handler Event handler content attribute

onmouseenter p949 HTML elements mouseenter event handler p943 Event handler content attribute

onmouseleave p949 p943 HTML elements mouseleave event handler Event handler content attribute

onmousemove p949 p943 HTML elements mousemove event handler Event handler content attribute

onmouseout p949 p943 HTML elements mouseout event handler Event handler content attribute

onmouseover HTML elementsp949 mouseover event handler Event handler content attribute p943

onmouseup p949 p943 HTML elements mouseup event handler Event handler content attribute

onoffline p950 p1272 p828 p943 body offline event handler for Window object Event handler content attribute

ononline p950 p1272 p828 p943 body online event handler for Window object Event handler content attribute

onpagehide p950 p1272 p828 p943 body pagehide event handler for Window object Event handler content attribute

onpageshow p950 p1272 p828 p943 body pageshow event handler for Window object Event handler content attribute

onpaste p950 p1272 p943 HTML elements paste event handler Event handler content attribute

onpause p949 p441 p943 HTML elements pause event handler Event handler content attribute

onplay p949 p441 p943 HTML elements play event handler Event handler content attribute

onplaying p949 p440 p943 HTML elements playing event handler Event handler content attribute

onpopstate bodyp950 popstatep1272 event handler for Windowp828 object Event handler content attribute p943

onprogress p949 p440 p943 HTML elements progress event handler Event handler content attribute

onratechange p949 p441 p943 HTML elements ratechange event handler Event handler content attribute

onreset p949 p1272 p943 HTML elements reset event handler Event handler content attribute

onresize p950 p943 HTML elements resize event handler Event handler content attribute

onrejectionhandled p950 p1272 p828 p943 body rejectionhandled event handler for Window object Event handler content attribute

onscroll p950 p943 HTML elements scroll event handler Event handler content attribute

onsecuritypolicyviolation p949 p1272 p943 HTML elements securitypolicyviolation event handler Event handler content attribute

onseeked p949 p441 p943 HTML elements seeked event handler Event handler content attribute

onseeking p949 p441 p943 HTML elements seeking event handler Event handler content attribute

onselect HTML elementsp949 selectp1272 event handler Event handler content attribute p943

onslotchange p949 p1272 p943 HTML elements slotchange event handler Event handler content attribute

onstalled p949 p440 p943 HTML elements stalled event handler Event handler content attribute

onstorage p950 p1272 p828 p943 body storage event handler for Window object Event handler content attribute

onsubmit p949 p1272 p943 HTML elements submit event handler Event handler content attribute

onsuspend p949 p440 p943 HTML elements suspend event handler Event handler content attribute

ontimeupdate p949 p441 p943 HTML elements timeupdate event handler Event handler content attribute

ontoggle p949 p1272 p943 HTML elements toggle event handler Event handler content attribute

onunhandledrejection p950 p1272 p828 p943 body unhandledrejection event handler for Window object Event handler content attribute

onunload p950 p1272 p828 p943 body unload event handler for Window object Event handler content attribute

onvolumechange HTML elementsp949 volumechangep441 event handler Event handler content attribute p943

onwaiting p949 p441 p943 HTML elements waiting event handler Event handler content attribute

onwheel p949 p943 HTML elements wheel event handler Event handler content attribute



Element Interfaces p12 §

66

This section is non-normative.

List of interfaces for elements

Element(s) Interface(s)

a p239 p240 p125 HTMLAnchorElement : HTMLElement

abbr p251 p125 HTMLElement

address p199 p125 HTMLElement

1266

Element(s) Interface(s)

areap444 HTMLAreaElementp445 : HTMLElementp125

article p181 p125 HTMLElement

aside p189 p125 HTMLElement

audio p384 p385 p388 p125 HTMLAudioElement : HTMLMediaElement : HTMLElement

b p274 p125 HTMLElement

base p156 p156 p125 HTMLBaseElement : HTMLElement

bdi p279 p125 HTMLElement

bdo p280 p125 HTMLElement

blockquote p219 p219 p125 HTMLQuoteElement : HTMLElement

body p179 p180 p125 HTMLBodyElement : HTMLElement

brp281 HTMLBRElementp281 : HTMLElementp125

button p536 p537 p125 HTMLButtonElement : HTMLElement

canvas p635 p635 p125 HTMLCanvasElement : HTMLElement

caption p459 p459 p125 HTMLTableCaptionElement : HTMLElement

cite p247 p125 HTMLElement

code p268 p125 HTMLElement

col p461 p461 p125 HTMLTableColElement : HTMLElement

colgroup p460 p461 p125 HTMLTableColElement : HTMLElement

data p260 p261 p125 HTMLDataElement : HTMLElement

datalist p544 p544 p125 HTMLDataListElement : HTMLElement

ddp232 HTMLElementp125

del p313 p314 p125 HTMLModElement : HTMLElement

details p605 p605 p125 HTMLDetailsElement : HTMLElement

dfn p250 p125 HTMLElement

dialog p611 p612 p125 HTMLDialogElement : HTMLElement

div p238 p239 p125 HTMLDivElement : HTMLElement

dl p228 p228 p125 HTMLDListElement : HTMLElement

dt p231 p125 HTMLElement

em p242 p125 HTMLElement

embed p369 p370 p125 HTMLEmbedElement : HTMLElement

fieldsetp563 HTMLFieldSetElementp563 : HTMLElement p125

figcaption p236 p125 HTMLElement

figure p233 p125 HTMLElement

footer p196 p125 HTMLElement

form p487 p488 p125 HTMLFormElement : HTMLElement

h1 p191 p191 p125 HTMLHeadingElement : HTMLElement

h2 p191 p191 p125 HTMLHeadingElement : HTMLElement

h3 p191 p191 p125 HTMLHeadingElement : HTMLElement

h4 p191 p191 p125 HTMLHeadingElement : HTMLElement

h5 p191 p191 p125 HTMLHeadingElement : HTMLElement

h6p191 HTMLHeadingElementp191 : HTMLElement p125

head p154 p154 p125 HTMLHeadElement : HTMLElement

header p195 p125 HTMLElement

hgroup p193 p125 HTMLElement

hr p215 p216 p125 HTMLHRElement : HTMLElement

html p153 p153 p125 HTMLHtmlElement : HTMLElement

i p273 p125 HTMLElement

iframe p362 p362 p125 HTMLIFrameElement : HTMLElement

img p321 p321 p125 HTMLImageElement : HTMLElement

input p494 p495 p125 HTMLInputElement : HTMLElement

ins p312 p314 p125 HTMLModElement : HTMLElement

kbd p271 p125 HTMLElement

label p491 p492 p125 HTMLLabelElement : HTMLElement

legend p566 p566 p125 HTMLLegendElement : HTMLElement

1267

Element(s) Interface(s)

lip225 HTMLLIElementp226 : HTMLElementp125

link p158 p158 p125 HTMLLinkElement : HTMLElement

main p237 p125 HTMLElement

map p443 p443 p125 HTMLMapElement : HTMLElement

mark p276 p125 HTMLElement

menu p224 p225 p125 HTMLMenuElement : HTMLElement

meta p165 p166 p125 HTMLMetaElement : HTMLElement

meter p558 p559 p125 HTMLMeterElement : HTMLElement

nav p186 p125 HTMLElement

noscript p628 p125 HTMLElement

objectp373 HTMLObjectElementp374 : HTMLElement p125

ol p222 p222 p125 HTMLOListElement : HTMLElement

optgroup p545 p546 p125 HTMLOptGroupElement : HTMLElement

option p546 p547 p125 HTMLOptionElement : HTMLElement

output p554 p555 p125 HTMLOutputElement : HTMLElement

p p213 p213 p125 HTMLParagraphElement : HTMLElement

param p379 p379 p125 HTMLParamElement : HTMLElement

picture p317 p317 p125 HTMLPictureElement : HTMLElement

pre p217 p217 p125 HTMLPreElement : HTMLElement

progress p556 p557 p125 HTMLProgressElement : HTMLElement

qp248 HTMLQuoteElementp219 : HTMLElementp125

rp p259 p125 HTMLElement

rt p259 p125 HTMLElement

ruby p253 p125 HTMLElement

s p246 p125 HTMLElement

samp p270 p125 HTMLElement

script p614 p615 p125 HTMLScriptElement : HTMLElement

section p183 p125 HTMLElement

select p538 p539 p125 HTMLSelectElement : HTMLElement

slot p633 p634 p125 HTMLSlotElement : HTMLElement

smallp245 HTMLElementp125

source p318 p318 p125 HTMLSourceElement : HTMLElement

span p280 p281 p125 HTMLSpanElement : HTMLElement

strong p243 p125 HTMLElement

style p175 p176 p125 HTMLStyleElement : HTMLElement

sub p272 p125 HTMLElement

summary p608 p125 HTMLElement

sup p272 p125 HTMLElement

table p451 p452 p125 HTMLTableElement : HTMLElement

tbody p462 p462 p125 HTMLTableSectionElement : HTMLElement

tdp466 HTMLTableCellElementp467 : HTMLElement p125

template p630 p631 p125 HTMLTemplateElement : HTMLElement

textarea p549 p550 p125 HTMLTextAreaElement : HTMLElement

tfoot p464 p462 p125 HTMLTableSectionElement : HTMLElement

th p468 p467 p125 HTMLTableCellElement : HTMLElement

thead p463 p462 p125 HTMLTableSectionElement : HTMLElement

time p261 p262 p125 HTMLTimeElement : HTMLElement

title p155 p155 p125 HTMLTitleElement : HTMLElement

tr p465 p465 p125 HTMLTableRowElement : HTMLElement

track p385 p386 p125 HTMLTrackElement : HTMLElement

u p276 p125 HTMLElement

ul p223 p224 p125 HTMLUListElement : HTMLElement

var p269 p125 HTMLElement

video p380 p381 p388 p125 HTMLVideoElement : HTMLMediaElement : HTMLElement

1268

Element(s) Interface(s)

wbrp282 HTMLElementp125

custom elements p705 p125 supplied by the element's author (inherits from HTMLElement )



All Interfaces p12 §

69

This section is non-normative.

• p418 AudioTrack

• p418 AudioTrackList

• p835 BarProp

• p896 BeforeUnloadEvent

• p1013 BroadcastChannel

• p642 CanvasGradient

• p642 CanvasPattern

• p639 CanvasRenderingContext2D

• p1002 CloseEvent

• p708 CustomElementRegistry

• p958 DOMParser

• p102 DOMStringList

• p147 DOMStringMap

• p800 DataTransfer

• p804 DataTransferItem

• p803 DataTransferItemList

• p1034 DedicatedWorkerGlobalScope

• p115 p115 p1240 Document , partial 1 1

• p805 DragEvent

• p717 ElementInternals

• p924 ErrorEvent

• p988 EventSource

• p1240 External

• p604 FormDataEvent

• p97 HTMLAllCollection

• p240 p1232 HTMLAnchorElement , partial

• p445 p1232 HTMLAreaElement , partial

• p385 HTMLAudioElement

• p281 p1233 HTMLBRElement , partial

• p156 HTMLBaseElement

• p180 p1232 HTMLBodyElement , partial

• p537 HTMLButtonElement

• p635 HTMLCanvasElement

• p228 p1233 HTMLDListElement , partial

• p261 HTMLDataElement

• p544 HTMLDataListElement

• p605 HTMLDetailsElement

• p612 HTMLDialogElement

• p1233 HTMLDirectoryElement

• p239 p1233 HTMLDivElement , partial

• p125 HTMLElement

• p370 p1234 HTMLEmbedElement , partial

• p563 HTMLFieldSetElement

• p1234 HTMLFontElement

• p99 HTMLFormControlsCollection

• p488 HTMLFormElement

• p1231 HTMLFrameElement

• p1230 HTMLFrameSetElement

• p216 p1234 HTMLHRElement , partial

• p154 HTMLHeadElement

• p191 p1234 HTMLHeadingElement , partial

• p153 p1234 HTMLHtmlElement , partial

• p362 p1234 HTMLIFrameElement , partial

• p321 p1235 HTMLImageElement , partial

• p495 p1235 HTMLInputElement , partial

• p226 p1235 HTMLLIElement , partial

• p492 HTMLLabelElement

• p566 p1235 HTMLLegendElement , partial

• p158 p1236 HTMLLinkElement , partial

• p443 HTMLMapElement

• p1228 HTMLMarqueeElement

• p388 HTMLMediaElement

1269

• p225 p1236 HTMLMenuElement , partial

• p166 p1236 HTMLMetaElement , partial

• p559 HTMLMeterElement

• p314 HTMLModElement

• p222 p1237 HTMLOListElement , partial

• p374 p1237 HTMLObjectElement , partial

• p546 HTMLOptGroupElement

• p547 HTMLOptionElement

• p100 HTMLOptionsCollection

• p555 HTMLOutputElement

• p213 p1237 HTMLParagraphElement , partial

• p379 p1237 HTMLParamElement , partial

• p317 HTMLPictureElement

• p217 p1237 HTMLPreElement , partial

• p557 HTMLProgressElement

• p219 HTMLQuoteElement

• p615 p1238 HTMLScriptElement , partial

• p539 HTMLSelectElement

• p634 HTMLSlotElement

• p318 HTMLSourceElement

• p281 HTMLSpanElement

• p176 p1238 HTMLStyleElement , partial

• p459 p1233 HTMLTableCaptionElement , partial

• p467 p1239 HTMLTableCellElement , partial

• p461 p1233 HTMLTableColElement , partial

• p452 p1238 HTMLTableElement , partial

• p465 p1239 HTMLTableRowElement , partial

• p462 p1238 HTMLTableSectionElement , partial

• p631 HTMLTemplateElement

• p550 HTMLTextAreaElement

• p262 HTMLTimeElement

• p155 HTMLTitleElement

• p386 HTMLTrackElement

• p224 p1239 HTMLUListElement , partial

• p125 HTMLUnknownElement

• p381 HTMLVideoElement

• p893 HashChangeEvent

• p860 History

• p978 ImageBitmap

• p688 ImageBitmapRenderingContext

• p643 ImageData

• p867 Location

• p390 MediaError

• p1009 MessageChannel

• p986 MessageEvent

• p1010 MessagePort

• p974 MimeType

• p974 MimeTypeArray

• p967 Navigator

• p690 OffscreenCanvas

• p694 OffscreenCanvasRenderingContext2D

• p894 PageTransitionEvent

• p643 Path2D

• p45 Plugin

• p974 PluginArray

• p893 PopStateEvent

• p926 PromiseRejectionEvent

• p99 RadioNodeList

• p1042 SharedWorker

• p1035 SharedWorkerGlobalScope

• p1057 Storage

• p1060 StorageEvent

• p604 SubmitEvent

• p643 TextMetrics

• p430 TextTrack

• p434 TextTrackCue

• p433 TextTrackCueList

• p429 TextTrackList

• p439 TimeRanges

• p439 TrackEvent

• p594 ValidityState

• p418 VideoTrack

• p418 VideoTrackList

• p996 WebSocket

• p828 p1240 Window , partial

• p1041 Worker

1270

• p1032 WorkerGlobalScope

• p1045 WorkerLocation

• p1045 WorkerNavigator

• p1053 Worklet

• p1050 WorkletGlobalScope



Events p12 §

71

This section is non-normative.

List of events

Event Interface Interesting targets Description

abort p828 p828 Event Window Fired at the Window when the download was

p115 ✔ MDN p115 aborted by the user

DOMContentLoaded Event Document Fired at the Document once the parser has

finished

✔ MDN

beforeprint p828 ✔ MDN p828 Event afterprint Event Windowp828 Fired at the Windowp828 after printing

beforeunload p896 ✔ MDN p828 p828 BeforeUnloadEvent Window Fired at the Window before printing

Window Fired at the Window when the page is about to be

unloaded, in case the page would like to show a

warning prompt

cancel p611 MDN p611 Event blur Event p828 p774 Window , elements Fired at nodes when they stop being focused

dialog elements Fired at dialog elements when they are canceled

by the user (e.g. by pressing the Escape key)

change Event Form controls Fired at controls when the user commits a value

change (see also the p1271 input event)

click PointerEvent Elements Normally a mouse event; also synthetically fired at

an element before its activation behavior is run,

when an element is activated from a non-pointer

input device (e.g. a keyboard)

⚠ MDN

close p1002 p611 p996 p611 Event or CloseEvent dialog elements, WebSocket Fired at dialog elements when they are closed,

and at p996 WebSocket objects when the connection is

terminated

MDN

connect p986 p1035 MessageEvent SharedWorkerGlobalScope Fired at a shared worker's global scope when a new

client connects

✔ MDN

contextmenu PointerEvent Elements Fired at elements when the user requests their

context menu

copy Event Elements Fired at elements when the user copies data to the

clipboard

cut Event Elements Fired at elements when the user copies the selected

data on the clipboard and removes the selection from

the document

✔ MDN

error Event or ErrorEventp924 Global scope objects, Workerp1041 objects, Fired when unexpected errors occur (e.g. networking

elements, networking-related objects errors, script errors, decoding errors)

formdata p604 MDN p487 p487 FormDataEvent focus Event p828 p774 Window , elements Fired at nodes gaining focus

form elements Fired at a form element when it is constructing

hashchange p893 ✔ MDN p828 p828 HashChangeEvent the entry list p600

Window Fired at the Window when the fragment part of the

document's URL changes

✔ MDN

input Event Form controls Fired at controls when the user changes the value

(see also the p1271 change event)

invalid Event Form controls Fired at controls during form validation if they do not

satisfy their constraints

MDN

languagechange Event Global scope objects Fired at the global scope object when the user's

preferred languages change

load p828 p828 Event Window , elements Fired at the Window when the document has

finished loading; fired at an element containing a

resource (e.g. p321 p369 img , embed) when its resource

has finished loading

MDN

message p986 p828 p988 p996 MessageEvent Window , EventSource , WebSocket, Fired at an object when it receives a message

MessagePort p1010 p1013 , BroadcastChannel,

DedicatedWorkerGlobalScope p1034 p1041 , Worker,

ServiceWorkerContainer

1271

Event Interface Interesting targets Description

MDN

messageerror MessageEventp986 Windowp828 , MessagePortp1010, Fired at an object when it receives a message that

BroadcastChannel p1013, cannot be deserialized

DedicatedWorkerGlobalScope p1034 p1041 , Worker,

ServiceWorkerContainer

✔ MDN

offline Event Global scope objects Fired at the global scope object when the network

connections fails

✔ MDN

online Event Global scope objects Fired at the global scope object when the network

open p988 ✔ MDN p996 Event connections returns

EventSource , WebSocket Fired at networking-related objects when a

pagehide p894 ✔ MDN p828 p828 PageTransitionEvent connection is established

Window Fired at the Window when the page's entry in the

session history p858 p860 stops being the current entry

✔ MDN

pageshow PageTransitionEventp894 Windowp828 Fired at the Windowp828 when the page's entry in the

session history p858 p860 becomes the current entry

paste Event Elements Fired at elements when the user will insert the

clipboard data in the most suitable format (if any)

p893 ✔ MDN p828 supported for the given context

popstate p828 PopStateEvent Window Fired at the Window when the user navigates the

readystatechange p115 ✔ MDN p115 Event session history p858

Document Fired at the Document when it finishes parsing and

again when all its subresources have finished loading

rejectionhandled p926 PromiseRejectionEvent Global scope objects Fired at global scope objects when a previously-

reset p487 ✔ MDN p487 p604 Event unhandled promise rejection becomes handled

form elements Fired at a form element when it is reset

securitypolicyviolation Event Elements Fired at elements when a Content Security Policy

violation is generated p1275 [CSP]

select Event Form controls Fired at form controls when their text selection is

adjusted (whether by an API or by the user)

slotchange Event p633 p633 slot elements Fired at slot elements when their assigned nodes

storage p1060 MDN p828 p828 StorageEvent change

Window Fired at Window event when the corresponding

localStorage p1060 p1059 or sessionStorage storage

submit p487 ✔ MDN p487 p597 Event areas change

form elements Fired at a form element when it is submitted

toggle Event p605 details element Fired at details elements when they open or

p605 ✔ MDN

close

unhandledrejection p926 PromiseRejectionEvent Global scope objects Fired at global scope objects when a promise

rejection goes unhandled

unload Event p828 Window Fired at the Window object when the page is going

p828 ✔ MDN

away



Note

See also p440 p812 media element events and drag-and-drop events.



MIME Types p12 §

72

This section is non-normative.

The following MIME types are mentioned in this specification:

application/atom+xml

Atom p1275 [ATOM]

application/ecmascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

application/javascript

JavaScript (legacy type) p1278 [JAVASCRIPT]



1272

application/json

JSON p1278 [JSON]

application/x-ecmascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

application/x-javascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

application/octet-stream

Generic binary data p1280 [RFC2046]

application/microdata+json p1245

Microdata as JSON

application/rss+xml

RSS

application/x-www-form-urlencoded

Form submission

application/xhtml+xml p1243

HTML

application/xml

XML p1283 p1281 [XML] [RFC7303]

image/gif

GIF images p1278 [GIF]

image/jpeg

JPEG images p1278 [JPEG]

image/png

PNG images p1280 [PNG]

image/svg+xml

SVG images p1281 [SVG]

multipart/form-data

Form submission p1281 [RFC7578]

multipart/mixed

Generic mixed content p1280 [RFC2046]

multipart/x-mixed-replace p1242

Streaming server push

text/css

CSS p1275 [CSS]

text/ecmascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/event-stream p1246

Server-sent event streams

text/javascript

JavaScript p1278 [JAVASCRIPT]

text/javascript1.0

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/javascript1.1

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/javascript1.2

JavaScript (legacy type) p1278 [JAVASCRIPT]

1273

text/javascript1.3

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/javascript1.4

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/javascript1.5

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/jscript

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/json

JSON (legacy type)

text/livescript

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/plain

Generic plain text p1280 p1280 [RFC2046] [RFC3676]

text/html p1241

HTML

text/ping p1244

Hyperlink auditing

text/uri-list

List of URLs p1280 [RFC2483]

text/vcard

vCard p1281 [RFC6350]

text/vtt

WebVTT p1282 [WEBVTT]

text/x-ecmascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/x-javascript

JavaScript (legacy type) p1278 [JAVASCRIPT]

text/xml

XML p1283 p1281 [XML] [RFC7303]

video/mp4

MPEG-4 video p1280 [RFC4337]

video/mpeg

MPEG video p1280 [RFC2046]



1274

References p12 §

75

All references are normative unless marked "Non-normative".

[ABNF]

Augmented BNF for Syntax Specifications: ABNF, D. Crocker, P. Overell. IETF.

[ABOUT]

The 'about' URI scheme, S. Moonesamy. IETF.

[APNG]

(Non-normative) APNG Specification. S. Parmenter, V. Vukicevic, A. Smith. Mozilla.

[ARIA]

Accessible Rich Internet Applications (WAI-ARIA), J. Diggs, J. Nurthen, M. Cooper. W3C.

[ARIAHTML]

ARIA in HTML, S. Faulkner, S. O'Hara. W3C.

[ATAG]

(Non-normative) Authoring Tool Accessibility Guidelines (ATAG) 2.0, J. Richards, J. Spellman, J. Treviranus. W3C.

[ATOM]

(Non-normative) The Atom Syndication Format, M. Nottingham, R. Sayre. IETF.

[BATTERY]

(Non-normative) Battery Status API, A. Kostiainen, M. Lamouri. W3C.

[BCP47]

Tags for Identifying Languages; Matching of Language Tags, A. Phillips, M. Davis. IETF.

[BEZIER]

Courbes à poles, P. de Casteljau. INPI, 1959.

[BIDI]

UAX #9: Unicode Bidirectional Algorithm, M. Davis. Unicode Consortium.

[BOCU1]

(Non-normative) UTN #6: BOCU-1: MIME-Compatible Unicode Compression, M. Scherer, M. Davis. Unicode Consortium.

[CESU8]

(Non-normative) UTR #26: Compatibility Encoding Scheme For UTF-16: 8-BIT (CESU-8), T. Phipps. Unicode Consortium.

[CHARMOD]

(Non-normative) Character Model for the World Wide Web 1.0: Fundamentals, M. Dürst, F. Yergeau, R. Ishida, M. Wolf, T. Texin. W3C.

[COMPOSITE]

Compositing and Blending, R. Cabanier, N. Andronikos. W3C.

[COMPUTABLE]

(Non-normative) On computable numbers, with an application to the Entscheidungsproblem, A. Turing. In Proceedings of the London Mathematical Society, series 2, volume 42, pages 230-265. London Mathematical Society, 1937.

[COOKIES]

HTTP State Management Mechanism, A. Barth. IETF.

[CSP]

Content Security Policy, M. West, D. Veditz. W3C.

[CSS]

Cascading Style Sheets Level 2 Revision 2, B. Bos, T. Çelik, I. Hickson, H. Lie. W3C.

[CSSALIGN]

CSS Box Alignment, E. Etemad, T. Atkins. W3C.



1275

[CSSANIMATIONS]

CSS Animations, D. Jackson, D. Hyatt, C. Marrin, S. Galineau, L. Baron. W3C.

[CSSATTR]

CSS Style Attributes, T. Çelik, E. Etemad. W3C.

[CSSBG]

CSS Backgrounds and Borders, B. Bos, E. Etemad, B. Kemper. W3C.

[CSSCASCADE]

CSS Cascading and Inheritance, E. Etemad, T. Atkins. W3C.

[CSSCOLOR]

CSS Color Module, T. Çelik, C. Lilley, L. Baron. W3C.

[CSSCOLORADJUST]

CSS Color Adjustment Module, E. Etemad, R. Atanassov, R. Lillesveen, T. Atkins. W3C.

[CSSDISPLAY]

CSS Display, T. Atkins, E. Etemad. W3C.

[CSSFONTLOAD]

CSS Font Loading, T. Atkins, J. Daggett. W3C.

[CSSFONTS]

CSS Fonts, J. Daggett. W3C.

[CSSFLEXBOX]

CSS Flexible Box Layout, T. Atkins, E. Etemad, R. Atanassov. W3C.

[CSSGC]

CSS Generated Content, H. Lie, E. Etemad, I. Hickson. W3C.

[CSSGRID]

CSS Grid Layout, T. Atkins, E. Etemad, R. Atanassov. W3C.

[CSSIMAGES]

CSS Images Module, E. Etemad, T. Atkins, L. Verou. W3C.

[CSSIMAGES4]

CSS Images Module Level 4, E. Etemad, T. Atkins, L. Verou. W3C.

[CSSINLINE]

CSS Inline Layout, D. Cramer, E. Etemad. W3C.

[CSSLISTS]

CSS Lists and Counters, T. Atkins. W3C.

[CSSLOGICAL]

CSS Logical Properties, R. Atanassov, E. Etemad. W3C.

[CSSMULTICOL]

CSS Multi-column Layout, H. Lie, F. Rivoal, R. Andrew. W3C.

[CSSOM]

Cascading Style Sheets Object Model (CSSOM), S. Pieters, G. Adams. W3C.

[CSSOMVIEW]

CSSOM View Module, S. Pieters, G. Adams. W3C.

[CSSOVERFLOW]

CSS Overflow Module, L. Baron, F. Rivoal. W3C.

[CSSPAINT]

(Non-normative) CSS Painting API, I. Kilpatrick, D. Jackson. W3C.

[CSSPOSITION]

CSS Positioned Layout, R. Atanassov, A. Eicholz. W3C.



1276

[CSSRUBY]

CSS3 Ruby Module, R. Ishida. W3C.

[CSSSCOPING]

CSS Scoping Module, T. Atkins. W3C.

[CSSSIZING]

CSS Intrinsic & Extrinsic Sizing Module, T. Atkins, E. Etemad. W3C.

[CSSTRANSITIONS]

(Non-normative) CSS Transitions, D. Jackson, D. Hyatt, C. Marrin, L. Baron. W3C.

[CSSUI]

CSS3 Basic User Interface Module, T. Çelik. W3C.

[CSSSYNTAX]

CSS Syntax, T. Atkins, S. Sapin. W3C.

[CSSTABLE]

CSS Table, F. Remy, G. Whitworth. W3C.

[CSSTEXT]

CSS Text, E. Etemad, K. Ishii. W3C.

[CSSVALUES]

CSS3 Values and Units, H. Lie, T. Atkins, E. Etemad. W3C.

[CSSWM]

CSS Writing Modes, E. Etemad, K. Ishii. W3C.

[DASH]

Dynamic adaptive streaming over HTTP (DASH). ISO.

[DOM]

DOM, A. van Kesteren, A. Gregor, Ms2ger. WHATWG.

[DOMPARSING]

DOM Parsing and Serialization, T. Leithead. W3C.

[DOT]

(Non-normative) The DOT Language. Graphviz.

[E163]

Recommendation E.163 — Numbering Plan for The International Telephone Service, CCITT Blue Book, Fascicle II.2, pp. 128-134, November 1988.

[ENCODING]

Encoding, A. van Kesteren, J. Bell. WHATWG.

[EXECCOMMAND]

execCommand, J. Wilm, A. Gregor. W3C Editing APIs CG.

[EXIF]

(Non-normative) Exchangeable image file format. JEITA.

[FETCH]

Fetch, A. van Kesteren. WHATWG.

[FILEAPI]

File API, A. Ranganathan. W3C.

[FILTERS]

Filter Effects, D. Jackson, E. Dahlström, D. Schulze. W3C.

[FULLSCREEN]

Fullscreen, A. van Kesteren, T. Çelik. WHATWG.

[GEOMETRY]

Geometry Interfaces. S. Pieters, D. Schulze, R. Cabanier. W3C.

1277

[GIF]

(Non-normative) Graphics Interchange Format. CompuServe.

[GRAPHICS]

(Non-normative) Computer Graphics: Principles and Practice in C, Second Edition, J. Foley, A. van Dam, S. Feiner, J. Hughes. Addison-Wesley. ISBN 0-201-84840-6.

[GREGORIAN]

(Non-normative) Inter Gravissimas, A. Lilius, C. Clavius. Gregory XIII Papal Bull, February 1582.

[HRT]

High Resolution Time, I. Grigorik, J. Simonsen, J. Mann. W3C.

[HTMLAAM]

HTML Accessibility API Mappings 1.0, S. Faulkner, A. Surkov, S. O'Hara. W3C.

[HTTP]

Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing, R. Fielding, J. Reschke. IETF.

Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, R. Fielding, J. Reschke. IETF.

Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests, R. Fielding, J. Reschke. IETF.

Hypertext Transfer Protocol (HTTP/1.1): Range Requests, R. Fielding, Y. Lafon, J. Reschke. IETF.

Hypertext Transfer Protocol (HTTP/1.1): Caching, R. Fielding, M. Nottingham, J. Reschke. IETF.

Hypertext Transfer Protocol (HTTP/1.1): Authentication, R. Fielding, J. Reschke. IETF.

[INDEXEDDB]

Indexed Database API, A. Alabbas, J. Bell. W3C.

[INBAND]

Sourcing In-band Media Resource Tracks from Media Containers into HTML, S. Pfeiffer, B. Lund. W3C.

[INFRA]

Infra, A. van Kesteren, D. Denicola. WHATWG.

[INTERSECTIONOBSERVER]

Intersection Observer, S. Zager. W3C.

[ISO3166]

ISO 3166: Codes for the representation of names of countries and their subdivisions. ISO.

[ISO4217]

ISO 4217: Codes for the representation of currencies and funds. ISO.

[ISO8601]

(Non-normative) ISO8601: Data elements and interchange formats — Information interchange — Representation of dates and times. ISO.

[JAVASCRIPT]

ECMAScript Language Specification. Ecma International.

[JLREQ]

Requirements for Japanese Text Layout. W3C.

[JPEG]

JPEG File Interchange Format, E. Hamilton.

[JSERRORSTACKS]

(Non-normative) Error Stacks. Ecma International.

[JSINTL]

ECMAScript Internationalization API Specification. Ecma International.

[JSTLA]

Top-Level Await. Ecma International.

[JSON]

The JavaScript Object Notation (JSON) Data Interchange Format, T. Bray. IETF.

[LONGTASKS]

Long Tasks, D. Denicola, I. Grigorik, S. Panicker. W3C.

1278

[MAILTO]

(Non-normative) The 'mailto' URI scheme, M. Duerst, L. Masinter, J. Zawinski. IETF.

[MANIFEST]

Web App Manifest, M. Caceres, K. Rohde Christiansen, M. Lamouri, A. Kostiainen, M. Giuca, A. Gustafson. W3C.

[MATHML]

Mathematical Markup Language (MathML), D. Carlisle, P. Ion, R. Miner. W3C.

[MEDIAFRAG]

Media Fragments URI, R. Troncy, E. Mannens, S. Pfeiffer, D. Van Deursen. W3C.

[MEDIASOURCE]

Media Source Extensions, A. Colwell, A. Bateman, M. Watson. W3C.

[MEDIASTREAM]

Media Capture and Streams, D. Burnett, A. Bergkvist, C. Jennings, A. Narayanan. W3C.

[REPORTING]

Reporting, D. Creager, I. Clelland, M. West. W3C.

[MFREL]

Microformats Wiki: existing rel values. Microformats.

[MIMESNIFF]

MIME Sniffing, G. Hemsley. WHATWG.

[MIX]

Mixed Content, M. West. W3C.

[MNG]

MNG (Multiple-image Network Graphics) Format. G. Randers-Pehrson.

[MPEG2]

ISO/IEC 13818-1: Information technology — Generic coding of moving pictures and associated audio information: Systems. ISO/IEC.

[MPEG4]

ISO/IEC 14496-12: ISO base media file format. ISO/IEC.

[MQ]

Media Queries, H. Lie, T. Çelik, D. Glazman, A. van Kesteren. W3C.

[MULTIPLEBUFFERING]

(Non-normative) Multiple buffering. Wikipedia.

[NAVMODEL]

A Model of Navigation History. C. Brewster, A. Jeffrey.

[NPAPI]

(Non-normative) Gecko Plugin API Reference. Mozilla.

[OGGSKELETONHEADERS]

SkeletonHeaders. Xiph.Org.

[OPENSEARCH]

Autodiscovery in HTML/XHTML. In OpenSearch 1.1 Draft 4, Section 4.6.2. OpenSearch.org.

[ORIGIN]

(Non-normative) The Web Origin Concept, A. Barth. IETF.

[PAINTTIMING]

Paint Timing, S. Panicker. W3C.

[PAGEVIS]

(Non-normative) Page Visibility Level 2, I. Grigorik, A. Jain, J. Mann. W3C.

[PAYMENTREQUEST]

Payment Request API, M. Cáceres, D. Wang, R. Solomakhin, I. Jacobs. W3C.



1279

[PDF]

(Non-normative) Document management — Portable document format — Part 1: PDF. ISO.

[PERMISSIONSPOLICY]

Permissions Policy, I. Clelland, W3C.

[PINGBACK]

Pingback 1.0, S. Langridge, I. Hickson.

[PNG]

Portable Network Graphics (PNG) Specification, D. Duce. W3C.

[POINTEREVENTS]

Pointer Events, J. Rossi, M. Brubeck, R. Byers, P. H. Lauke. W3C.

[POINTERLOCK]

Pointer Lock, V. Scheib. W3C.

[PPUTF8]

(Non-normative) The Properties and Promises of UTF-8, M. Dürst. University of Zürich. In Proceedings of the 11th International Unicode Conference.

[PRELOAD]

Preload, I. Grigorik. W3C.

[PRESENTATION]

Presentation API, M. Foltz, D. Röttsches. W3C.

[REFERRERPOLICY]

Referrer Policy, J. Eisinger, E. Stark. W3C.

[REQUESTIDLECALLBACK]

Cooperative Scheduling of Background Tasks, R. McIlroy, I. Grigorik. W3C.

[RESOURCEHINTS]

Resource Hints, I. Grigorik. W3C.

[RFC1034]

Domain Names - Concepts and Facilities, P. Mockapetris. IETF, November 1987.

[RFC1123]

Requirements for Internet Hosts -- Application and Support, R. Braden. IETF, October 1989.

[RFC2046]

Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types, N. Freed, N. Borenstein. IETF.

[RFC2397]

The "data" URL scheme, L. Masinter. IETF.

[RFC5545]

Internet Calendaring and Scheduling Core Object Specification (iCalendar), B. Desruisseaux. IETF.

[RFC2483]

URI Resolution Services Necessary for URN Resolution, M. Mealling, R. Daniel. IETF.

[RFC3676]

The Text/Plain Format and DelSp Parameters, R. Gellens. IETF.

[RFC3864]

Registration Procedures for Message Header Fields, G. Klyne, M. Nottingham, J. Mogul. IETF.

[RFC4329]

(Non-normative) Scripting Media Types, B. Höhrmann. IETF.

[RFC4337]

(Non-normative) MIME Type Registration for MPEG-4, Y. Lim, D. Singer. IETF.

[RFC7595]

Guidelines and Registration Procedures for URI Schemes, D. Thaler, T. Hansen, T. Hardie. IETF.

1280

[RFC5322]

Internet Message Format, P. Resnick. IETF.

[RFC6381]

The 'Codecs' and 'Profiles' Parameters for "Bucket" Media Types, R. Gellens, D. Singer, P. Frojdh. IETF.

[RFC6266]

Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP), J. Reschke. IETF.

[RFC6350]

vCard Format Specification, S. Perreault. IETF.

[RFC6596]

The Canonical Link Relation, M. Ohye, J. Kupke. IETF.

[RFC7034]

(Non-normative) HTTP Header Field X-Frame-Options, D. Ross, T. Gondrom. IETF.

[RFC7303]

XML Media Types, H. Thompson, C. Lilley. IETF.

[RFC7578]

Returning Values from Forms: multipart/form-data, L. Masinter. IETF.

[SCREENORIENTATION]

Screen Orientation API, M. Lamouri, M. Cáceres. W3C.

[SCSU]

(Non-normative) UTR #6: A Standard Compression Scheme For Unicode, M. Wolf, K. Whistler, C. Wicksteed, M. Davis, A. Freytag, M. Scherer. Unicode Consortium.

[SECURE-CONTEXTS]

Secure Contexts, M. West. W3C.

[SELECTION]

Selection API, R. Niwa. W3C.

[SELECTORS]

Selectors, E. Etemad, T. Çelik, D. Glazman, I. Hickson, P. Linss, J. Williams. W3C.

[SMS]

(Non-normative) URI Scheme for Global System for Mobile Communications (GSM) Short Message Service (SMS), E. Wilde, A. Vaha-Sipila. IETF.

[STRUCTURED-FIELDS]

Structured Field Values for HTTP, M. Nottingham, P-H. Kamp. IETF.

[SRGB]

IEC 61966-2-1: Multimedia systems and equipment — Colour measurement and management — Part 2-1: Colour management —

Default RGB colour space — sRGB. IEC.

[SRI]

Subresource Integrity, D. Akhawe, F. Braun, F. Marier, J. Weinberger. W3C.

[STORAGE]

Storage, A. van Kesteren. WHATWG.

[SVG]

Scalable Vector Graphics (SVG) 2, N Andronikos, R. Atanassov, T. Bah, B. Birtles, B. Brinza, C. Concolato, E. Dahlström, C. Lilley, C. McCormack, D. Schepers, R. Schwerdtfeger, D. Storey, S. Takagi, J. Watt. W3C.

[SW]

Service Workers, A. Russell, J. Song, J. Archibald. W3C.

[TOR]

(Non-normative) Tor.

[TOUCH]

Touch Events, D. Schepers, S. Moon, M. Brubeck, A. Barstow, R. Byers. W3C.

1281

[TZDATABASE]

(Non-normative) Time Zone Database. IANA.

[UAAG]

(Non-normative) User Agent Accessibility Guidelines (UAAG) 2.0, J. Allan, K. Ford, J. Richards, J. Spellman. W3C.

[UIEVENTS]

UI Events Specification, G. Kacmarcik, T. Leithead. W3C.

[UNICODE]

The Unicode Standard. Unicode Consortium.

[UNIVCHARDET]

(Non-normative) A composite approach to language/encoding detection, S. Li, K. Momoi. Netscape. In Proceedings of the 19th International Unicode Conference.

[URL]

URL, A. van Kesteren. WHATWG.

[URN]

URN Syntax, R. Moats. IETF.

[UTF7]

(Non-normative) UTF-7: A Mail-Safe Transformation Format of Unicode, D. Goldsmith, M. Davis. IETF.

[UTF8DET]

(Non-normative) Multilingual form encoding, M. Dürst. W3C.

[UTR36]

(Non-normative) UTR #36: Unicode Security Considerations, M. Davis, M. Suignard. Unicode Consortium.

[WASMJS]

(Non-normative) WebAssembly JavaScript Interface, D. Ehrenberg. W3C.

[WCAG]

(Non-normative) Web Content Accessibility Guidelines (WCAG), A. Kirkpatrick, J. O Connor, A. Campbell, M. Cooper. W3C.

[WEBANIMATIONS]

Web Animations, B. Birtles, S. Stephens, D. Stockwell. W3C.

[WEBAUDIO]

(Non-normative) Web Audio API, P. Adenot, H. Choi. W3C.

[WEBCRYPTO]

(Non-normative) Web Cryptography API, M. Watson. W3C.

[WEBGL]

WebGL Specifications, D. Jackson, J. Gilbert. Khronos Group.

[WEBIDL]

Web IDL, C. McCormack. W3C.

[WEBLINK]

Web Linking, M. Nottingham. IETF.

[WEBMCG]

WebM Container Guidelines. The WebM Project.

[WEBVTT]

WebVTT, S. Pieters. W3C.

[WHATWGWIKI]

The WHATWG Wiki. WHATWG.

[WSP]

The WebSocket protocol, I. Fette, A. Melnikov. IETF.

[X121]

Recommendation X.121 — International Numbering Plan for Public Data Networks, CCITT Blue Book, Fascicle VIII.3, pp. 317-332.

1282

[XFN]

XFN 1.1 profile, T. Çelik, M. Mullenweg, E. Meyer. GMPG.

[XHR]

XMLHttpRequest, A. van Kesteren. WHATWG.

[XKCD1288]

(Non-normative) Substitutions, Randall Munroe. xkcd.

[XML]

Extensible Markup Language, T. Bray, J. Paoli, C. Sperberg-McQueen, E. Maler, F. Yergeau. W3C.

[XMLENTITY]

(Non-normative) XML Entity Definitions for Characters, D. Carlisle, P. Ion. W3C.

[XMLNS]

Namespaces in XML, T. Bray, D. Hollander, A. Layman, R. Tobin. W3C.

[XMLSSPI]

Associating Style Sheets with XML documents, J. Clark, S. Pieters, H. Thompson. W3C.

[XPATH10]

XML Path Language (XPath) Version 1.0, J. Clark, S. DeRose. W3C.

[XSLT10]

(Non-normative) XSL Transformations (XSLT) Version 1.0, J. Clark. W3C.

[XSLTP]

(Non-normative) DOM XSLTProcessor, WHATWG Wiki. WHATWG.



1283

Acknowledgments p12 §

84

Thanks to Tim Berners-Lee for inventing HTML, without which none of this would exist.

Thanks to Aankhen, Aaqa Ishtyaq, Aaron Boodman, Aaron Leventhal, Abhishek Gupta, Adam Barth, Adam de Boor, Adam Hepton, Adam Klein, Adam Roben, Addison Phillips, Adele Peterson, Adrian Bateman, Adrian Roselli, Adrian Sutton, Agustín Fernández, Aharon (Vladimir) Lanin, Ajai Tirumali, Ajay Poshak, Akatsuki Kitamura, Alan Plum, Alastair Campbell, Alejandro G. Castro, Alex Bishop, Alex Nicolaou, Alex Nozdriukhin, Alex Rousskov, Alexander Farkas, Alexander J. Vincent, Alexandre Dieulot, Alexandre Morgaut, Alexey Feldgendler, Алексей Проскуряков (Alexey Proskuryakov), Alexey Shvayka, Alexis Deveria, Alfred Agrell, Ali Juma, Alice Boxhall, Alice Wonder, Allan Clements, Allen Wirfs-Brock, Alex Komoroske, Alex Russell, Alphan Chen, Aman Ansari, Ami Fischman, Amos Jeffries, Amos Lim, Anders Carlsson, André Bargull, André E. Veltstra, Andrea Rendine, Andreas, Andreas Deuschlinger, Andreas Kling, Andrei Popescu, Andres Gomez, Andres Rios, Andreu Botella, Andrew Barfield, Andrew Clover, Andrew Gove, Andrew Grieve, Andrew Macpherson, Andrew Oakley, Andrew Simons, Andrew Smith, Andrew W. Hagen, Andrey V. Lukyanov, Andry Rendy, Andy Davies, Andy Earnshaw, Andy Heydon, Andy Paicu, Andy Palay, Anjana Vakil, Ankur Kaushal, Anna Belle Leiserson, Anna Sidwell, Anthony Boyd, Anthony Bryan, Anthony Hickson, Anthony Ramine, Anthony Ricaud, Anton Vayvod, Antti Koivisto, Arfat Salman, Arkadiusz Michalski, Arne Thomassen, Aron Spohr, Arphen Lin, Arthur Stolyar, Arun Patole, Aryeh Gregor, Asbjørn Ulsberg, Ashley Gullen, Ashley Sheridan, Atsushi Takayama, Attila Haraszti, Aurelien Levy, Ave Wrigley, Avi Drissman, Axel Dahmen, Ben Boyle, Ben Godfrey, Ben Golightly, Ben Kelly, Ben Lerner, Ben Leslie, Ben Meadowcroft, Ben Millard, Benjamin Carl Wiley Sittler, Benjamin Hawkes-Lewis, Benji Bilheimer, Benoit Ren, Bert Bos, Bijan Parsia, Bil Corry, Bill Mason, Bill McCoy, Billy Wong, Billy Woods, Bjartur Thorlacius, Björn Höhrmann, Blake Frantz, Bob Lund, Bob Owen, Bobby Holley, Boris Zbarsky, Brad Fults, Brad Neuberg, Brad Spencer, Bradley Meck, Brady Eidson, Brandon Jones, Brendan Eich, Brenton Simpson, Brett Wilson, Brett Zamir, Brian Birtles, Brian Blakely, Brian Campbell, Brian Korver, Brian Kuhn, Brian M. Dube, Brian Ryner, Brian Smith, Brian Wilson, Bryan Sullivan, Bruce Bailey, Bruce D'Arcus, Bruce Lawson, Bruce Miller, Bugs Nash, C. Scott Ananian, C. Williams, Cameron McCormack, Cameron Zemek, Cao Yipeng, Carlos Amengual, Carlos Gabriel Cardona, Carlos Perelló Marín, Carolyn MacLeod, Casey Leask, Cătălin Badea, Cătălin Mariș, Cem Turesoy, ceving, Chao Cai, 윤석찬 (Channy Yun), Charl van Niekerk, Charlene Wright, Charles Iliya Krempeaux, Charles McCathie Nevile, Charlie Reis, 白丞祐 (Cheng-You Bai), Chris Apers, Chris Cressman, Chris Dumez, Chris Evans, Chris Harrelson, Chris Markiewicz, Chris Morris, Chris Nardi, Chris Needham, Chris Pearce, Chris Peterson, Chris Rebert, Chris Weber, Chris Wilson, Christian Biesinger, Christian Johansen, Christian Schmidt, Christoph Päper, Christophe Dumez, Christopher Aillon, Christopher Ferris, Chriswa, Clark Buehler, Cole Robison, Colin Fine, Collin Jackson, Corey Farwell, Corprew Reed, Craig Cockburn, Csaba Gabor, Csaba Marton, Cynthia Shelly, Cyrille Tuzi, Daksh Shah, Dan Callahan, Dan Yoder, Dane Foster, Daniel Barclay, Daniel Bratell, Daniel Brooks, Daniel Brumbaugh Keeney, Daniel Buchner, Daniel Cheng, Daniel Clark, Daniel Davis, Daniel Ehrenberg, Daniel Glazman, Daniel Holbert, Daniel Peng, Daniel Schattenkirchner, Daniel Spång, Daniel Steinberg, Daniel Tan, Daniel Trebbien, Danny Sullivan, Daphne Preston-Kendal, Darien Maillet Valentine, Darin Adler, Darin Fisher, Darxus, Dave Camp, Dave Cramer, Dave Hodder, Dave Lampton, Dave Singer, Dave Tapuska, Dave Townsend, David Baron, David Bloom, David Bruant, David Carlisle, David E. Cleary, David Egan Evans, David Fink, David Flanagan, David Gerard, David Grogan, David Håsäther, David Hyatt, David I. Lehn, David John Burrowes, David Matja, David Remahl, David Resseguie, David Smith, David Storey, David Vest, David Woolley, David Zbarsky, Dave Methvin, DeWitt Clinton, Dean Edridge, Dean Edwards, Dean Jackson, Debi Orton, Delan Azabani, Derek Featherstone, Derek Guenther, Devarshi Pant, Devdatta, Diego Ferreiro Val, Diego Ponce de León, Dimitri Glazkov, Dimitry Golubovsky, Dirk Pranke, Dirk Schulze, Dirkjan Ochtman, Divya Manian, Dmitry Lazutkin, Dmitry Titov, dolphinling, Dominic Cooney, Dominic Farolino, Dominique Hazaël-Massieux, Don Brutzman, Donovan Glover, Doron Rosenberg, Doug Kramer, Doug Simpkinson, Drew Wilson, Edgar Chen, Edmund Lai, Eduard Pascual, Eduardo Vela, Edward Welbourne, Edward Z. Yang, Ehsan Akhgari, Eira Monstad, Eitan Adler, Eli Friedman, Eli Grey, Eliot Graff, Elisabeth Robson, Elizabeth Castro, Elliott Sprehn, Elliotte Harold, Emilio Cobos Álvarez, Emily Stark, Eric Carlson, Eric Casler, Eric Lawrence, Eric Portis, Eric Rescorla, Eric Semling, Eric Willigers, Erik Arvidsson, Erik Charlebois, Erik Rose, 栗本 英理子 (Eriko Kurimoto), espretto, Evan Jacobs, Evan Martin, Evan Prodromou, Evan Stade, Evert, Evgeny Kapun, ExE-Boss, Ezequiel Garzón, fantasai, Félix Sanz, Felix Sasaki, Fernando Altomare Serboncini, Forbes Lindesay, Francesco Schwarz, Francis Brosnan Blazquez, Franck 'Shift' Quélain, François Marier, Frank Barchard, Frank Liberato, Franklin Shirley, Fredrik Söderquist, 鵜飼文敏 (Fumitoshi Ukai), Futomi Hatano, Gavin Carothers, Gavin Kistner, Gareth Rees, Garrett Smith, Gary Blackwood, Gary Kacmarcik, Gary Katsevman, Geoff Richards, Geoffrey Garen, Georg Neis, George Lund, Gianmarco Armellin, Giovanni Campagna, Giuseppe Pascale, Glenn Adams, Glenn Maynard, Graham Klyne, Greg Botten, Greg Houston, Greg Wilkins, Gregg Tavares, Gregory J. Rosmaita, Gregory Terzian, Grey, Guilherme Johansson Tramontina, guest271314, Gytis Jakutonis, Håkon Wium Lie, Habib Virji, Hajime Morrita, Hallvord Reiar Michaelsen Steen, Hanna Laakso, Hans S. Tømmerhalt, Hans Stimer, Harald Alvestrand, Hayato Ito, 何志翔 (HE Zhixiang), Henri Sivonen, Henrik Lied, Henry Lewis, Henry Mason, Henry Story, Hermann Donfack Zeufack, 中川博貴 (Hiroki Nakagawa), Hiroshige Hayashizaki, Hitoshi Yoshida, Hongchan Choi, Hugh Bellamy, Hugh Guiney, Hugh Winkler, Ian Bicking, Ian Clelland, Ian Davis, Ian Fette, Ian Henderson, Ian Kilpatrick, Ibrahim Ahmed, Ido Green, Ignacio Javier, Igor Oliveira, Ingvar Stepanyan, isonmad, Iurii Kucherov, Ivan Enderlin, Ivan Nikulin, Ivo Emanuel Gonçalves, J. King, J.C. Jones, Jackson Ray Hamilton, Jacob Davies, Jacques Distler, Jake Archibald, Jake Verbaten, Jakub Vrána, Jakub Łopuszański, Jakub Wilk, James Craig, James Graham, James Greene, James Justin Harrell, James Kozianski, James M Snell, James Perrett, James Robinson, Jamie Liu, Jamie Lokier, Jan Kühle, Jan Miksovsky, Janice Shiu, Janusz Majnert, Jan-Ivar Bruaroey, Jan-Klaas Kollhof, Jared Jacobs, Jason Duell, Jason Kersey, Jason Lustig, Jason Orendorff, Jason White, Jasper Bryant-Greene, Jasper St. Pierre, Jatinder Mann, Jean-Yves Avenard, Jed Hartman, Jeff Balogh, Jeff Cutsinger, Jeff "=JeffH" Hodges, Jeff Schiller, Jeff Walden, Jeffrey Yasskin, Jeffrey Zeldman, 胡慧鋒 (Jennifer Braithwaite), Jellybean Stonerfish, Jennifer

1284

Apacible, Jens Bannmann, Jens Fendler, Jens Oliver Meiert, Jens Widell, Jer Noble, Jeremey Hustman, Jeremy Keith, Jeremy Orlow, Jeremy Roman, Jeroen van der Meer, Jerry Smith, Jesse Renée Beach, Jessica Jong, jfkthame, Jian Li, Jihye Hong, Jim Jewett, Jim Ley, Jim Meehan, Jim Michaels, Jinho Bang, Jinjiang (勾三股四), Jirka Kosek, Jjgod Jiang, Joaquim Medeiros, João Eiras, Jochen Eisinger, Joe Clark, Joe Gregorio, Joel Spolsky, Joel Verhagen, Joey Arhar, Johan Herland, Johanna Herman, John Boyer, John Bussjaeger, John Carpenter, John Daggett, John Fallows, John Foliot, John Harding, John Keiser, John Law, John Musgrave, John Snyders, John Stockton, John-Mark Bell, Johnny Stenback, Jon Coppeard, Jon Ferraiolo, Jon Gibbins, Jon Perlow, Jonas Sicking, Jonathan Cook, Jonathan Neal, Jonathan Oddy, Jonathan Rees, Jonathan Watt, Jonathan Worent, Jonny Axelsson, Joram Schrijver, Jordan Tucker, Jorgen Horstink, Joris van der Wel, Jorunn Danielsen Newth, Joseph Kesselman, Joseph Mansfield, Joseph Pecoraro, Josh Aas, Josh Hart, Josh Juran, Josh Levenberg, Josh Matthews, Joshua Bell, Joshua Randall, Juan Olvera, Juanmi Huertas, Jukka K. Korpela, Jules Clément-Ripoche, Julian Reschke, Julio Lopez, 小勝　純 (Jun Kokatsu), Jun Yang (harttle), Jungkee Song, Jürgen Jeka, Justin Lebar, Justin Novosad, Justin Rogers, Justin Schuh, Justin Sinclair, Juuso Lapinlampi, Ka-Sing Chou, Kagami Sascha Rosylight, Kai Hendry, Kamishetty Sreeja, 呂康豪 (KangHao Lu), Karl Dubost, Karl Tomlinson, Kartik Arora, Kartikaya Gupta, 葛依寧 (Kat Hackett), Kathy Walton, Keith Rollin, Keith Yeung, Kelly Ford, Kelly Norton, Ken Russell, Kenji Baheux, Kevin Benson, Kevin Cole, Kevin Gadd, Kevin Venkiteswaran, Kinuko Yasuda, Koji Ishii, Kornél Pál, Kornel Lesinski, 上野 康平 (UENO, Kouhei), Kris Northfield, Kristof Zelechovski, Krzysztof Maczyński, 黒澤剛志 (Kurosawa Takeshi), Kyle Barnhart, Kyle Hofmann, Kyle Huey, Léonard Bouchet, Léonie Watson, Lachlan Hunt, Larry Masinter, Larry Page, Lars Gunther, Lars Solberg, Laura Carlson, Laura Granka, Laura L. Carlson, Laura Wisewell, Laurens Holst, Lawrence Forooghian, Lee Kowalkowski, Leif Halvard Silli, Leif Kornstaedt, Lenny Domnitser, Leonard Rosenthol, Leons Petrazickis, Liviu Tinta, Lobotom Dysmon, Logan, Loune, Lucas Gadani, Łukasz Pilorz, Luke Kenneth Casson Leighton, Maciej Stachowiak, Magne Andersson, Magnus Kristiansen, Maik Merten, Majid Valipour, Malcolm Rowe, Manish Goregaokar, Manish Tripathi, Manuel Martinez-Almeida, Marc Hoyois, Marc-André Choquette, Marc-André Lafortune, Marco Zehe, Marcus Bointon, Marijn Kruisselbrink, Mark Amery, Mark Birbeck, Mark Davis, Mark Green, Mark Miller, Mark Nottingham, Mark Pilgrim, Mark Rogers, Mark Rowe, Mark Schenk, Mark Vickers, Mark Wilton-Jones, Markus Stange, Martijn van der Ven, Martijn Wargers, Martin Atkins, Martin Chaov, Martin Dürst, Martin Honnen, Martin Janecke, Martin Kutschker, Martin Nilsson, Martin Thomson, Masataka Yakura, Masatoshi Kimura, Mason Freed, Mason Mize, Mathias Bynens, Mathieu Henri, Matias Larsson, Matt Brubeck, Matt Di Pasquale, Matt Falkenhagen, Matt Schmidt, Matt Wright, Matthew Gregan, Matthew Mastracci, Matthew Noorenberghe, Matthew Raymond, Matthew Thomas, Matthew Tylee Atkinson, Mattias Waldau, Max Romantschuk, Maxim Tsoy, Menachem Salomon, Menno van Slooten, Micah Dubinko, Michael 'Ratt' Iannarelli, Michael A. Nachbaur, Michael A. Puls II, Michael Carter, Michael Daskalov, Michael Day, Michael Dyck, Michael Enright, Michael Gratton, Michael Kohler, Michael McKelvey, Michael Nordman, Michael Powers, Michael Rakowski, Michael(tm) Smith, Michael Walmsley, Michal Zalewski, Michel Buffa, Michel Fortin, Michelangelo De Simone, Michiel van der Blonk, Miguel Casas-Sanchez, Mihai Şucan, Mihai Parparita, Mike Brown, Mike Dierken, Mike Dixon, Mike Hearn, Mike Pennisi, Mike Schinkel, Mike Shaver, Mikko Rantalainen, Mingye Wang, Mohamed Zergaoui, Mohammad Al Houssami, Mohammad Reza Zakerinasab, Momdo Nakamura, Morten Stenshorne, Mounir Lamouri, Ms2ger, mtrootyy, 邱慕安 (Mu-An Chiou), Mukilan Thiyagarajan, Mustaq Ahmed, Myles Borins, Nadia Heninger, NARUSE Yui, Navid Zolghadr, Neil Deakin, Neil Rashbrook, Neil Soiffer, Nicholas Shanks, Nicholas Stimpson, Nicholas Zakas, Nickolay Ponomarev, Nicolas Gallagher, Nicolas Pena Moreno, Nikki Bee, Noah Mendelsohn, Noah Slater, Noel Gordon, Nolan Waite, NoozNooz42, Norbert Lindenberg, Oisín Nolan, Ojan Vafai, Olaf Hoffmann, Olav Junker Kjær, Oldřich Vetešník, Oli Studholme, Oliver Hunt, Oliver Rigby, Olivia (Xiaoni) Lai, Olivier Gendrin, Olli Pettay, Ondřej Žára, Ori Avtalion, oSand, Pablo Flouret, Patrick Dark, Patrick Garies, Patrick H. Lauke, Patrik Persson, Paul Adenot, Paul Lewis, Paul Norman, Per-Erik Brodin, 一丝 (percyley), Perry Smith, Peter Beverloo, Peter Karlsson, Peter Kasting, Peter Moulder, Peter Occil, Peter Stark, Peter Van der Beken, Peter van der Zee, Peter-Paul Koch, Phil Pickering, Philip Ahlberg, Philip Taylor, Philip TAYLOR, Philippe De Ryck, Pierre-Arnaud Allumé, Pierre-Marie Dartus, Pooja Sanklecha, Prashant Hiremath, Prashanth Chandra, Prateek Rungta, Pravir Gupta, Prayag Verma, 李普君 (Pujun Li), Rachid Finge, Rafael Weinstein, Rafał Miłecki, Rahul Purohit, Raj Doshi, Rajas Moonka, Rakina Zata Amni, Ralf Stoltze, Ralph Giles, Raphael Champeimont, Rebecca Star, Remci Mizkur, Remco, Remy Sharp, Rene Saarsoo, Rene Stach, Ric Hardacre, Rich Clark, Rich Doughty, Richa Rupela, Richard Gibson, Richard Ishida, Ricky Mondello, Rigo Wenning, Rikkert Koppes, Rimantas Liubertas, Riona Macnamara, Rob Buis, Rob Ennals, Rob Jellinghaus, Rob S, Robert Blaut, Robert Collins, Robert Hogan, Robert Kieffer, Robert Linder, Robert Millan, Robert O'Callahan, Robert Sayre, Robin Berjon, Robin Schaufler, Rodger Combs, Roland Steiner, Roma Matusevich, Roman Ivanov, Roy Fielding, Rune Lillesveen, Russell Bicknell, Ruud Steltenpool, Ryan King, Ryan Landay, Ryan Sleevi, Ryo Kato, Ryosuke Niwa, S. Mike Dierken, Salvatore Loreto, Sam Dutton, Sam Kuper, Sam Ruby, Sam Sneddon, Sam Weinig, Samikshya Chand, Samuel Bronson, Samy Kamkar, Sander van Lambalgen, Sanjoy Pal, Sarah Gebauer, Sarven Capadisli, Schalk Neethling, Scott Beardsley, Scott González, Scott Hess, Scott Miles, Scott O'Hara, Sean B. Palmer, Sean Feng, Sean Fraser, Sean Hayes, Sean Hogan, Sean Knapp, Sebastian Markbåge, Sebastian Schnitzenbaumer, Sendil Kumar N, Seth Call, Seth Dillingham, Shannon Moeller, Shanti Rao, Shaun Inman, Shiino Yuki, 贺师俊 (HE Shi-Jun), Shiki Okasaka, Shivani Sharma, shreyateeza, Shubheksha Jalan, Sidak Singh Aulakh, Sierk Bornemann, Sigbjørn Finne, Sigbjørn Vik, Silver Ghost, Silvia Pfeiffer, Šime Vidas, Simon Fraser, Simon Montagu, Simon Sapin, Simon Spiegel, skeww, Smylers, Srirama Chandra Sekhar Mogali, Stanton McCandlish, stasoid, Stefan Håkansson, Stefan Haustein, Stefan Santesson, Stefan Schumacher, Ştefan Vargyas, Stefan Weiss, Steffen Meschkat, Stephen Ma, Stephen Stewart, Stephen White, Steve Comstock, Steve Faulkner, Steve Orvell, Steve Runyon, Steven Bennett, Steven Bingler, Steven Garrity, Steven Tate, Stewart Brodie, Stuart Ballard, Stuart Langridge, Stuart Parmenter, Subramanian Peruvemba, Sudhanshu Jaiswal, sudokus999, Sunava Dutta, Surma, Susan Borgrink, Susan Lesch, Sylvain Pasche, T. J. Crowder, Tab Atkins-Bittner, Taiju Tsuiki, Takashi Toyoshima, Takayoshi Kochi, Takeshi Yoshino, Tantek Çelik, 田村健人 (Kent TAMURA), Taylor Hunt, Ted Mielczarek, Terrence Wood, Tetsuharu OHZEKI, Theresa O'Connor, Thijs van der Vossen, Thomas Broyer, Thomas Koetter, Thomas O'Connor, Tim Altman, Tim Dresser, Tim Johansson, Tim Perry, Tim van der Lippe, TJ VanToll, Tobias Schneider, Tobie Langel, Toby Inkster, Todd Moody, Tom Baker, Tom Pike, Tom Schuster, Tom ten Thij, Tomasz Jakut, Tomek Wytrębowicz, Tommy Thorsen, Tony Ross, Tooru Fujisawa, Toru Kobayashi, Travis Leithead, Trevor Rowbotham, Trevor Saunders, Trey Eckels, triple-underscore, Tristan Fraipont, Tyler Close, Valentin Gosu, Vardhan Gupta, Veli Şenol, Victor Carbune, Victor Costan, Vipul Snehadeep Chawathe, Vitya Muhachev, Vlad Levin, Vladimir Katardjiev, Vladimir Vukićević, Vyacheslav Aristov, voracity, Walter Steiner, Wakaba, Wayne Carr, Wayne Pollock, Wellington Fernando de Macedo,

1285

Weston Ruter, Wilhelm Joys Andersen, Will Levine, Will Ray, William Chen, William Swanson, Willy Martin Aguirre Rodriguez, Wladimir Palant, Wojciech Mach, Wolfram Kriesing, Xan Gregg, xenotheme, XhmikosR, Xida Chen, Xidorn Quan, Xue Fuqiao, Yang Chen, Yao Xiao, Yash Handa, Yay295, Ye-Kui Wang, Yehuda Katz, Yi Xu, Yi-An Huang, Yngve Nysaeter Pettersen, Yoav Weiss, Yonathan Randolph, Yu Huojiang, Yury Delendik, 平野裕 (Yutaka Hirano), Yuzo Fujishima, Zhenbin Xu, 张智强 (Zhiqiang Zhang), Zoltan Herczeg, and Øistein E. Andersen, for their useful comments, both large and small, that have led to changes to this specification over the years.

Thanks also to everyone who has ever posted about HTML to their blogs, public mailing lists, or forums, including all the contributors to the various W3C HTML WG lists and the various WHATWG lists.

Special thanks to Richard Williamson for creating the first implementation of p635 canvas in Safari, from which the canvas feature was designed.

Special thanks also to the Microsoft employees who first implemented the event-based drag-and-drop mechanism,

contenteditable p790 , and other features first widely deployed by the Windows Internet Explorer browser.

Special thanks and $10,000 to David Hyatt who came up with a broken implementation of the p1144 adoption agency algorithm that the editor had to reverse engineer and fix before using it in the parsing section.

Thanks to the participants of the microdata usability study for allowing us to use their mistakes as a guide for designing the microdata feature.

Thanks to the many sources that provided inspiration for the examples used in the specification.

Thanks also to the Microsoft blogging community for some ideas, to the attendees of the W3C Workshop on Web Applications and Compound Documents for inspiration, to the #mrt crew, the #mrt.no crew, and the #whatwg crew, and to Pillar and Hedral for their ideas and support.

Thanks to Igor Zhbanov for generating PDF versions of the specification.

Special thanks to the p317 RICG for developing the picture element and related features; in particular thanks to Adrian Bateman, Bruce Lawson, David Newton, Ilya Grigorik, John Schoenick, Leon de Rijke, Mat Marquis, Marcos Cáceres, Tab Atkins, Theresa O'Connor, and Yoav Weiss for their contributions.

Special thanks to the p697 WPWG for incubating the custom elements feature. In particular, thanks to David Hyatt and Ian Hickson for their influence through the XBL specifications, Dimitri Glazkov for the first draft of the custom elements specification, and to Alex Komoroske, Alex Russell, Andres Rios, Boris Zbarsky, Brian Kardell, Daniel Buchner, Dominic Cooney, Erik Arvidsson, Elliott Sprehn, Hajime Morrita, Hayato Ito, Jan Miksovsky, Jonas Sicking, Olli Pettay, Rafael Weinstein, Roland Steiner, Ryosuke Niwa, Scott Miles, Steve Faulkner, Steve Orvell, Tab Atkins, Theresa O'Connor, Tim Perry, and William Chen for their contributions.

Special thanks to the p1047 CSSWG for developing the worklets. In particular, thanks to Ian Kilpatrik for his work as editor of the original worklets specification.

For about ten years starting in 2003, this standard was almost entirely written by Ian Hickson (Google, ian@hixie.ch). More recently, Simon Pieters (Bocoup, zcorpan@gmail.com), Anne van Kesteren (Mozilla, annevk@annevk.nl), Philip Jägenstedt (Google,

philip@foolip.org), and Domenic Denicola (Google, d@domenic.me), all previously long-time contributors, have joined Ian in editing the text directly.



1286

Intellectual property rights p12 §

87

The image in the introduction is based on a photo by Wonderlane. (CC BY 2.0)

The image of the wolf in the embedded content introduction is based on a photo by Barry O'Neill. (Public domain) The image of the kettlebell swing in the embedded content introduction is based on a photo by kokkarina. (CC0 1.0)

The Blue Robot Player sprite used in the canvas demo is based on a work by JohnColburn. (CC BY-SA 3.0) The photograph of robot 148 climbing the tower at the FIRST Robotics Competition 2013 Silicon Valley Regional is based on a work by

Lenore Edman. (CC BY 2.0) The diagram showing how p616 p616 p614 async and defer impact script loading is based on a similar diagram from a blog post by Peter

Beverloo. (CC0 1.0)

The image decoding demo used to demonstrate module-based workers draws on some example code from a tutorial by Ilmari

Heikkinen. (CC BY 3.0) The example was inspired by a custom element by Steven Skelton. (MIT)

Part of the revision history of the p317 picture element and related features can be found in the ResponsiveImagesCG/picture-

element repository, which is available under the W3C Software and Document License.

Part of the revision history of the p168 theme-color metadata name can be found in the whatwg/meta-theme-color repository, which is available under CC0.

Part of the revision history of the p697 custom elements feature can be found in the w3c/webcomponents repository, which is available under the W3C Software and Document License.

Part of the revision history of the p149 innerText getter and setter can be found in the rocallahan/innerText-spec repository, which is available under CC0.

Part of the revision history of the p1047 worklets feature can be found in the w3c/css-houdini-drafts repository, which is available under the W3C Software and Document License.

Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a Creative Commons Attribution 4.0 International

License.

This is the Living Standard. Those interested in the patent-review version should view the Living Standard Review Draft.



1287





