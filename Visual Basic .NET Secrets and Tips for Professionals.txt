

Contents
About	1
Chapter 1: Getting started with Visual Basic .NET Language	2
Section 1.1: Hello World	2
Section 1.2: Hello World on a Textbox upon Clicking of a Button	2
Section 1.3: Region	3
Section 1.4: Creating a simple Calculator to get familiar with the interface and code	4
Chapter 2: Console	7
Section 2.1: Console.ReadLine()	7
Section 2.2: Console.Read()	7
Section 2.3: Console.ReadKey()	7
Section 2.4: Prototype of command line prompt	8
Section 2.5: Console.WriteLine()	9
Chapter 3: Array	9
Section 3.1: Array definition	9
Section 3.2: Null Array Variables	10
Section 3.3: Array initialization	10
Section 3.4: Declare a single-dimension array and set array element values	10
Section 3.5: Jagged Array Initialization	10
Section 3.6: Non-zero lower bounds	11
Section 3.7: Referencing Same Array from Two Variables	11
Section 3.8: Multidimensional Array initialization	11
Chapter 4: Visual Basic 14.0 Features	12
Section 4.1: Null conditional operator	12
Section 4.2: String interpolation	12
Section 4.3: Read-Only Auto-Properties	13
Section 4.4: NameOf operator	13
Section 4.5: Multiline string literals	14
Section 4.6: Partial Modules and Interfaces	14
Section 4.7: Comments after implicit line continuation	15
Section 4.8: #Region directive improvements	15
Chapter 5: Extension methods	16
Section 5.1: Creating an extension method	16
Section 5.2: Making the language more functional with extension methods	16
Section 5.3: Getting Assembly Version From Strong Name	16
Section 5.4: Padding Numerics	17
Chapter 6: Reflection	18
Section 6.1: Retrieve Properties for an Instance of a Class	18
Section 6.2: Get a method and invoke it	18
Section 6.3: Create an instance of a generic type	18
Section 6.4: Get the members of a type	18
Chapter 7: Looping	19
Section 7.1: For...Next	19
Section 7.2: For Each...Next loop for looping through collection of items	20
Section 7.3: Short Circuiting	20
Section 7.4: While loop to iterate while some condition is true	21
Section 7.5: Nested Loop	22
Section 7.6: Do...Loop	22
Chapter 8: Enum	23
Section 8.1: GetNames()	23
Section 8.2: HasFlag()	24
Section 8.3: Enum definition	24
Section 8.4: Member initialization	25
Section 8.5: The Flags attribute	25
Section 8.6: GetValues()	26
Section 8.7: String parsing	26
Section 8.8: ToString()	26
Section 8.9: Determine whether a Enum has FlagsAttribute specified or not	27
Section 8.10: For-each flag (flag iteration)	27
Section 8.11: Determine the amount of flags in a flag combination	28
Section 8.12: Find the nearest value in a Enum	28
Chapter 9: Threading	29
Section 9.1: Performing thread-safe calls using Control.Invoke()	29
Section 9.2: Performing thread-safe calls using Async/Await	30
Chapter 10: Dictionaries	30
Section 10.1: Create a dictionary filled with values	31
Section 10.2: Loop through a dictionary and print all entries	31
Section 10.3: Checking for key already in dictionary - data reduction	31
Section 10.4: Getting a dictionary value	31
Chapter 11: File Handling	32
Section 11.1: Write Data to a File	32
Section 11.2: Read All Contents of a File	32
Section 11.3: Write Lines Individually to a Text File using StreamWriter	33
Chapter 12: Short-Circuiting Operators (AndAlso - OrElse)	33
Section 12.1: OrElse Usage	33
Section 12.2: AndAlso Usage	33
Section 12.3: Avoiding NullReferenceException	33
Chapter 13: Task-based asynchronous pattern	35
Section 13.1: Basic usage of Async/Await	35
Section 13.2: Using TAP with LINQ	35
Chapter 14: LINQ	36
Section 14.1: Selecting from array with simple condition	36
Section 14.2: Mapping array by Select clause	36
Section 14.3: Ordering output	36
Section 14.4: Generating Dictionary From IEnumerable	36
Section 14.5: Projection	37
Section 14.6: Getting distinct values (using the Distinct method)	37
Chapter 15: Data Access	37
Section 15.1: Read field from Database	37
Section 15.2: Simple Function to read from Database and return as DataTable	38
Chapter 16: Disposable objects	39
Section 16.1: Basic concept of IDisposable	39
Section 16.2: Declaring more objects in one Using	40
Chapter 17: Operators	40
Section 17.1: String Concatenation	40
Section 17.2: Math	41
Section 17.3: Assignment	42
Section 17.4: Comparison	42
Section 17.5: Bitwise	43
Section 17.6: Widening and Narrowing	44
Section 17.7: Operator Overloading	44
Chapter 18: Declaring variables	44
Section 18.1: Declaring and assigning a variable using a primitive type	44
Section 18.2: Levels of declaration - Local and Member variables	46
Section 18.3: Example of Access Modifiers	47
Chapter 19: Classes	48
Section 19.1: Abstract Classes	48
Section 19.2: Creating classes	48
Chapter 20: Lists	49
Section 20.1: Add items to a List	49
Section 20.2: Check if item exists in a List	50
Section 20.3: Loop trough items in list	50
Section 20.4: Create a List	50
Section 20.5: Remove items from a List	51
Section 20.6: Retrieve items from a List	51
Chapter 21: Date	52
Section 21.1: Converting (Parsing) a String to a Date	52
Section 21.2: Converting a Date To A String	52
Chapter 22: Introduction to Syntax	53
Section 22.1: Intellisense Helper	53
Section 22.2: Declaring a Variable	53
Section 22.3: Comments	54
Section 22.4: Modifiers	54
Section 22.5: Object Initializers	54
Section 22.6: Collection Initializer	56
Section 22.7: Writing a function	58
Chapter 23: Option Strict	58
Section 23.1: Why Use It?	58
Section 23.2: How to Switch It On	59
Chapter 24: NullReferenceException	60
Section 24.1: Empty Return	60
Section 24.2: Uninitialized variable	60
Chapter 25: FTP server	60
Section 25.1: Download file from FTP server	60
Section 25.2: Download file from FTP server when login required	61
Section 25.3: Upload file to FTP server	61
Section 25.4: Upload file to FTP server when login required	61
Chapter 26: Error Handling	61
Section 26.1: Try...Catch...Finally Statement	61
Section 26.2: Creating custom exception and throwing	62
Section 26.3: Try Catch in Database Operation	62
Section 26.4: The Un-catchable Exception	62
Section 26.5: Critical Exceptions	63
Chapter 27: OOP Keywords	63
Section 27.1: Defining a class	63
Section 27.2: Inheritance Modifiers (on classes)	63
Section 27.3: Inheritance Modifiers (on properties and methods)	64
Section 27.4: MyBase	66
Section 27.5: Me vs MyClass	66
Section 27.6: Overloading	67
Section 27.7: Shadows	67
Section 27.8: Interfaces	69
Chapter 28: Working with Windows Forms	69
Section 28.1: Using the default Form instance	69
Section 28.2: Passing Data From One Form To Another	70
Chapter 29: File/Folder Compression	70
Section 29.1: Adding File Compression to your project	70
Section 29.2: Creating zip archive from directory	70
Section 29.3: Extracting zip archive to directory	71
Section 29.4: Create zip archive dynamicaly	71
Chapter 30: ByVal and ByRef keywords	71
Section 30.1: ByRef keyword	71
Section 30.2: ByVal keyword	72
Chapter 31: Type conversion	72
Section 31.1: Converting Text of The Textbox to an Integer	73
Chapter 32: Option Explicit	73
Section 32.1: What is it?	73
Section 32.2: How to switch it on?	73
Chapter 33: Option Infer	74
Section 33.1: How to enable/disable it	74
Section 33.2: What is it?	74
Section 33.3: When to use type inference	75
Chapter 34: GDI+	76
Section 34.1: Draw Shapes	76
Section 34.2: Fill Shapes	76
Section 34.3: Text	77
Section 34.4: Create Graphic Object	77
Chapter 35: Google Maps in a Windows Form	78
Section 35.1: How to use a Google Map in a Windows Form	78
Chapter 36: BackgroundWorker	87
Section 36.1: Using BackgroundWorker	87
Section 36.2: Accessing GUI components in BackgroundWorker	88
Chapter 37: Connection Handling	88
Section 37.1: Public connection property	88
Chapter 38: Using BackgroundWorker	88
Section 38.1: Basic implementation of Background worker class	88
Chapter 39: Generics	89
Section 39.1: Create a generic class	89
Section 39.2: Instance of a Generic Class	89
Section 39.3: Define a 'generic' class	89
Section 39.4: Use a generic class	90
Section 39.5: Limit the possible types given	90
Section 39.6: Create a new instance of the given type	90
Chapter 40: Multithreading	91
Section 40.1: Multithreading using Thread Class	91
Chapter 41: Unit Testing in VB.NET	92
Section 41.1: Unit Testing for Tax Calculation	92
Section 41.2: Testing Employee Class assigned and derived Properties	94
Chapter 42: Reading compressed textfile on-the-fly	97
Section 42.1: Reading .gz textfile line after line	97
Chapter 43: Conditions	97
Section 43.1: If operator	97
Section 43.2: IF...Then...Else	98
Chapter 44: Recursion	98
Section 44.1: Compute nth Fibonacci number	98
Chapter 45: Using Statement	99
Section 45.1: See examples under Disposable objects	99
Chapter 46: WPF XAML Data Binding	99
Section 46.1: Binding a String in the ViewModel to a TextBox in the View	99
Chapter 47: WinForms SpellCheckBox	100
Section 47.1: ElementHost WPF TextBox	101
Chapter 48: Debugging your application	103
Section 48.1: Debug in the console	104
Section 48.2: Indenting your debug output	104
Section 48.3: Debug in a text file	105
Chapter 49: Functions	105
Section 49.1: Defining a Function	105
Section 49.2: Defining a Function #2	106
Chapter 50: Using axWindowsMediaPlayer in VB.Net	106
Section 50.1: Adding the axWindowsMediaPlayer	106
Section 50.2: Play a Multimedia File	107
Chapter 51: Random	107
Section 51.1: Declaring an instance	107
Section 51.2: Generate a random number from an instance of Random	108
Credits	109
You may also like	111


About

Chapter 1: Getting started with Visual Basic .NET Language
VB.NET Version Visual Studio Version .NET Framework Version Release Date
7.0	2002	1.0	2002-02-13
7.1	2003	1.1	2003-04-24
8.0	2005	2.0 / 3.0	2005-10-18
9.0	2008	3.5	2007-11-19
10.0	2010	4.0	2010-04-12
11.0	2012	4.5	2012-08-15
12.0	2013	4.5.1 / 4.5.2	2013-10-17
14.0	2015	4.6.0 ~ 4.6.2	2015-07-20
15.0	2017	4.7	2017-03-07
Section 1.1: Hello World
First, install a version of Microsoft Visual Studio, including the free Community edition. Then, create a Visual Basic Console Application project of type Console Application, and the following code will print the string 'Hello World' to the Console:

'Hello World'Then, save and press F5 on the keyboard (or go to the Debug menu, then click Run without Debug or Run) to compile and run the program.  should appear in the console window.

Section 1.2: Hello World on a Textbox upon Clicking of a Button
Drag 1 textbox and 1 button

Button1_Click eventDouble click the button1 and you will be transferred to the 

TextType the name of the object that you want to target, in our case it is the textbox1. . is the property that we want to use if we want to put a text on it.
Property Textbox.Text, gets or sets the current text in the TextBox. Now, we have Textbox1.TextTextbox1.TextWe need to set the value of that  so we will use the = sign. The value that we want to put in the
TextTextTextbox1Textbox1. is Hello World. Overall, this is the total code for putting a value of Hello World to the .


Section 1.3: Region
For the sake of readability, which will be useful for beginners when reading VB code as well for full time developers to maintain the code, we can use "Region" to set a region of the same set of events, functions, or variables:

This region block could be collapsed to gain some visual help when the code row goes to 1000+. It is also save your scroll efforts.

Tested on VS 2005, 2008 2010, 2015 and 2017.
Section 1.4: Creating a simple Calculator to get familiar with the interface and code.
1. Once you have installed Visual Studio from https://www.visualstudio.com/downloads/, start a new project.
2. 
3. Select 'Windows Forms Application' from Visual Basic Tab. You can rename it here if you need to.
4. Once you click 'OK', you will see this window:

5. Click on the 'Toolbox' tab on the left. The toolbar has 'auto-hide' option enabled by default. To disable this option, click the small symbol between the 'down arrow' symbol and the 'x' symbol, on the top-right corner of Toolbox window.
6. Get yourself familiar with the tools provided in the box. I have made a calculator interface by using buttons and a Textbox.

7. Click on the Properties tab (It is on the right side of the editor). You can change the Text property of a button, and the textbox to rename them. Font property can be used to alter the font of the controls.
8. To write the specific action for an event(eg. clicking on a button), double click on the control. Code window will open.

9. VB.Net is a powerful language designed for fast development. High encapsulation and abstraction is cost for it. You do not need to add semicolon to indicate the end of a statement, there are no brackets, and most of the time, it auto-corrects the case of the alphabets.
10. Code provided in the picture should be simple to understand. Dim is the keyword used to initialize a variable, and new allocates memory. Anything you type in the textbox is of type string by default. Casting is required to use the value as a different type.
Enjoy your first creation in VB.Net!
Chapter 2: Console
Section 2.1: Console.ReadLine()

Console.ReadLine() will read the console input from the user, up until the next newline is detected (usually upon
pressing the Enter or Return key). Code execution is paused in the current thread until a newline is provided. Afterwards, the next line of code will be executed.
Section 2.2: Console.Read()
Dim inputCode As Integer = Console.Read()
Console.Read() awaits input from the user and, upon receipt, returns an integer value corresponding with the
character code of the entered character. If the input stream is ended in some way before input can be obtained, -1 is returned instead.
Section 2.3: Console.ReadKey()
Dim inputChar As ConsoleKeyInfo = Console.ReadKey()
Console.ReadKey() awaits input from the user and, upon receipt, returns an object of class ConsoleKeyInfo, which
holds information relevant to the character which the user provided as input. For detail regarding the information provided, visit the MSDN documentation.
Section 2.4: Prototype of command line prompt

This prototype generate a basic command line interpreter.
It automatically get the application name and version to communicate to the user. For each input line, it recognize the command and an arbitrary list of arguments, all separated by space.
As a basic example, this code understand ver, quit and exit commands.
The parameter Project.BaseClass is a class of your project where the Assembly details are set.
Section 2.5: Console.WriteLine()
Dim x As Int32 = 128
Console.WriteLine(x) ' Variable '
Console.WriteLine(3) ' Integer '
Console.WriteLine(3.14159) ' Floating-point number '
Console.WriteLine("Hello, world") ' String '
Console.WriteLine(myObject) ' Outputs the value from calling myObject.ToString()
Console.WriteLineThe () method will print the given argument(s) with a newline attached at the end. This will print any object supplied, including, but not limited to, strings, integers, variables, floating-point numbers.
ToStringToStringWhen writing objects that are not explicitly called out by the various WriteLine overloads (that is, you are using the overload that expects a value of type Object, WriteLine will use the .() method to generate a String to actually write. Your custom objects should OverRide the . method and produce something more meaningful than the default implementation (which typically just writes the fully qualified type name).
Chapter 3: Array
Section 3.1: Array definition
Dim array(9) As Integer ' Defines an array variable with 10 Integer elements (0-9).
Dim array = New Integer(10) {} ' Defines an array variable with 11 Integer elements (0-10)                                'using New.
Dim array As Integer() = {1, 2, 3, 4} ' Defines an Integer array variable and populate it                                       'using an array literal. Populates the array with                                       '4 elements.
ReDim Preserve array(10) ' Redefines the size of an existing array variable preserving any
                         'existing values in the array. The array will now have 11 Integer                          'elements (0-10).
ReDim array(10) ' Redefines the size of an existing array variable discarding any
                'existing values in the array. The array will now have 11 Integer                 'elements (0-10).
Zero-Based
Dim array(5 To 10All arrays in VB.NET are zero-based. In other words, the index of the first item (the lower bound) in a VB.NET array is always 0. Older versions of VB, such as VB6 and VBA, were one-based by default, but they provided a way to override the default bounds. In those earlier versions of VB, the lower and upper bounds could be explicitly stated (e.g. ). In VB.NET, in order to maintain compatibility with other .NET languages, that flexibility was removed and the lower bound of 0 is now always enforced. However, the To syntax can still be used in VB.NET, which may make the range more explicitly clear. For instance, the following examples are all equivalent to the ones listed above:

Nested Array Declarations

Section 3.2: Null Array Variables
Since arrays are reference types, an array variable can be null. To declare a null array variable, you must declare it without a size:

Or

Is NothingTo check if an array is null, test to see if it :

To set an existing array variable to null, simply set it to Nothing:

Or use Erase, which does the same thing:

Section 3.3: Array initialization
Dim array() As Integer = {2, 0, 1, 6}                   ''Initialize an array of four Integers.
Dim strings() As String = {"this", "is", "an", "array"} ''Initialize an array of four Strings.
Dim floats() As Single = {56.2, 55.633, 1.2, 5.7743, 22.345}
              ''Initialize an array of five Singles, which are the same as floats in C#.
Dim miscellaneous() as Object = { New Object(), "Hello", New List(of String) }
              ''Initialize an array of three references to any reference type objects               ''and point them to objects of three different types.
Section 3.4: Declare a single-dimension array and set array element values

or

Section 3.5: Jagged Array Initialization
Note the parenthesis to distinguish between a jagged array and a multidimensional array SubArrays can be of different length
Dim jaggedArray()() As Integer = { ({1, 2, 3}), ({4, 5, 6}), ({7}) }
' jaggedArray(0) is {1, 2, 3} and so jaggedArray(0)(0) is 1
' jaggedArray(1) is {4, 5, 6} and so jaggedArray(1)(0) is 4
' jaggedArray(2) is {7} and so jaggedArray(2)(0) is 7
Section 3.6: Non-zero lower bounds
Option Strict OnindexWith , although the .NET Framework allows the creation of single dimension arrays with non-zero lower bounds they are not "vectors" and so not compatible with VB.NET typed arrays. This means they can only be seen as Array and so cannot use normal array () references.

Option Strict Off, you can get the (indexAs well as by using ) syntax back by treating the array as an IList, but
then it's not an array, so you can't use LBound and UBound on that variable name (and you're still not avoiding boxing):

Multi-dimensional non-zero lower bounded arrays are compatible with VB.NET multi-dimensional typed arrays:
Dim nza(,) As Integer = DirectCast(Array.CreateInstance(GetType(Integer),
                                   {4, 3}, {1, -1}), Integer(,))
For y = LBound(nza) To UBound(nza)     For w = LBound(nza, 2) To UBound(nza, 2)
        nza(y, w) = -y * w + nza(UBound(nza) - y + LBound(nza),
                                 UBound(nza, 2) - w + LBound(nza, 2))
    Next Next
For y = LBound(nza) To UBound(nza)
    Dim ly = y
    Console.WriteLine(String.Join(" ",
        Enumerable.Repeat(ly & ":", 1).Concat(
            Enumerable.Range(LBound(nza, 2), UBound(nza, 2) - LBound(nza, 2) + 1) _
            .Select(Function(w) CStr(nza(ly, w))))))
Next
MSDN reference: Array.CreateInstance
Section 3.7: Referencing Same Array from Two Variables
Since arrays are reference types, it is possible to have multiple variables pointing to the same array object.

Section 3.8: Multidimensional Array initialization
Dim array2D(,) As Integer = {{1, 2, 3}, {4, 5, 6}}
' array2D(0, 0) is 1 ; array2D(0, 1) is 2 ; array2D(1, 0) is 4
Dim array3D(,,) As Integer = {{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}}
' array3D(0, 0, 0) is 1 ; array3D(0, 0, 1) is 2
' array3D(0, 1, 0) is 4 ; array3D(1, 0, 0) is 7
Chapter 4: Visual Basic 14.0 Features
Visual Basic 14 is the version of Visual Basic that was shipped as part of Visual Studio 2015.
This version was rewritten from scratch in about 1.3 million lines of VB. Many features were added to remove common irritations and to make common coding patterns cleaner.
The version number of Visual Basic went straight from 12 to 14, skipping 13. This was done to keep VB in line with the version numbering of Visual Studio itself.
Section 4.1: Null conditional operator
To avoid verbose null checking, the ?. operator has been introduced in the language.
The old verbose syntax:
If myObject IsNot Nothing AndAlso myObject.Value >= 10 Then Can be now replaced by the concise:

The ? operator is particularly powerful when you have a chain of properties. Consider the following:

Normally you would have to write something like this:


Section 4.2: String interpolation
String.FormatThis new feature makes the string concatenation more readable. This syntax will be compiled to its equivalent  call.
Without string interpolation:

With string interpolation:

String.FormatThe two lines are equivalent and both get compiled to a call to .
String.FormatAs in , the brackets can contain any single expression (call to a method, property, a null coalescing operator et cetera).
String.FormatString.FormatString Interpolation is the preferred method over  because it prevents some runtime errors from occurring. Consider the following  line:
String.Format("The number of people is {0}/{1}", numPeople)
This will compile, but will cause a runtime error as the compiler does not check that the number of arguments match the placeholders.
Section 4.3: Read-Only Auto-Properties
Read-only properties were always possible in VB.NET in this format:

The new version of Visual Basic allows a short hand for the property declaration like so:

The actual implementation that is generated by the compiler is exactly the same for both examples. The new method to write it is just a short hand. The compiler will still generate a private field with the format:
PropertyName_<> to back the read-only property.
Section 4.4: NameOf operator
The NameOf operator resolves namespaces, types, variables and member names at compile time and replaces them with the string equivalent.
One of the use cases:

The old syntax will expose the risk of renaming the variable and leaving the hard-coded string to the wrong value.

With NameOf, renaming the variable only will raise a compiler error. This will also allow the renaming tool to rename both with a single effort.
The NameOf operator only uses the last component of the reference in the brackets. This is important when handling something like namespaces in the NameOf operator.

The operator also uses the name of the reference that is typed in without resolving any name changing imports. For example:

Section 4.5: Multiline string literals
VB now allows string literals that split over multiple lines.
Old syntax:
Dim text As String = "Line1" & Environment.NewLine & "Line2" New syntax:

Section 4.6: Partial Modules and Interfaces
Similar to partial classes the new version of Visual Basic is now able to handle partial modules and partial interfaces. The syntax and behaviour is exactly the same as it would be for partial classes.
A partial module example:

And a partial interface:


Just like for partial classes the definitions for the partial modules and interfaces have to be located in the same namespace and the same assembly. This is because the partial parts of the modules and interfaces are merged during the compilation and the compiled assembly does not contain any indication that the original definition of the module or interface was split.
Section 4.7: Comments after implicit line continuation
VB 14.0 introduces the ability to add comments after implicit line continuation.

Section 4.8: #Region directive improvements
#Region directive can now be placed inside methods and can even span over methods, classes and modules.


Chapter 5: Extension methods
Section 5.1: Creating an extension method
Extension methods are useful to extend the behaviour of libraries we don't own.
They are used similar to instance methods thanks to the compiler's syntactic sugar:

To have a usable extension method, the method needs the Extension attribute and needs to be declared in a Module.
Section 5.2: Making the language more functional with extension methods
A good use of extension method is to make the language more functional

Section 5.3: Getting Assembly Version From Strong Name
Example of calling an extension method as an extension and as a regular method.


The Extension Method in a Module. Make the Module Public if extensions are compiled to a dll and will be referenced in another assembly.

Section 5.4: Padding Numerics


Chapter 6: Reflection
Section 6.1: Retrieve Properties for an Instance of a Class

The Parameter of GetProperties defines which kinds of Properties will be returned by the function. Since we pass Public and Instance, the method will return only properties that are both public and non-shared. See The Flags attribute for and explanation on how Flag-enums can be combined.
Section 6.2: Get a method and invoke it
Static method:
Dim parseMethod = GetType(Integer).GetMethod("Parse",{GetType(String)}) Dim result = DirectCast(parseMethod.Invoke(Nothing,{"123"}), Integer) Instance method:

Section 6.3: Create an instance of a generic type
    Dim openListType = GetType(List(Of ))
    Dim typeParameters = {GetType(String)}
    Dim stringListType = openListType.MakeGenericType(typeParameters)     Dim instance = DirectCast(Activator.CreateInstance(stringListType), List(Of String))     instance.Add("Hello")
Section 6.4: Get the members of a type
Dim flags = BindingFlags.Static Or BindingFlags.Public Or BindingFlags.Instance
Dim members = GetType(String).GetMembers(flags)

Chapter 7: Looping
Section 7.1: For...Next
For...Next loop is used for repeating the same action for a finite number of times. The statements inside the following loop will be executed 11 times. The first time, i will have the value 0, the second time it will have the value 1, the last time it will have the value 10.

Any integer expression can be used to parameterize the loop. It is permitted, but not required, for the control variable (in this case i) to also be stated after the Next. It is permitted for the control variable to be declared in advance, rather than within the For statement.

Being able to define the Start and End integers allows loops to be created that directly reference other objects, such as:

This would then loop through every row in DataGridView1 and perform the action of writing the value of Column 1 to the Console. (The -1 is because the first row of the counted rows would be 1, not 0) It is also possible to define how the control variable must increment.

This outputs:
1 3 5 7 9
It is also possible to decrement the control variable (count down).

This outputs:
10 9 8 7 6 5 4 3 2 1
You should not attempt to use (read or update) the control variable outside the loop.
Section 7.2: For Each...Next loop for looping through collection of items
For Each...NextYou can use a  loop to iterate through any IEnumerable type. This includes arrays, lists, and anything else that may be of type IEnumerable or returns an IEnumerable.
An example of looping through a DataTable's Rows property would look like this:

For EachSystem.InvalidOperationExceptionAn important thing to note is that the collection must not be modified while in a  loop. Doing so will cause a  with the message:
Collection was modified; enumeration operation may not execute.
Section 7.3: Short Circuiting
Any loop may be terminated or continued early at any point by using the Exit or Continue statements.
Exiting
You can stop any loop by exiting early. To do this, you can use the keyword Exit along with the name of the loop.
	Loop	Exit Statement
Exit ForFor
Exit ForFor Each
Exit DoDo While
Exit WhileWhile
Exiting a loop early is a great way to boost performance by only looping the necessary number of times to satisfy the application's needs. Below is example where the loop will exit once it finds the number 2.

Continuing
Along with exiting early, you can also decide that you need to just move on to the next loop iteration. This is easily done by using the Continue statement. Just like Exit, it is proceeded by the loop name.
	Loop	Continue Statement
Continue ForFor
Continue ForFor Each
Continue DoDo While
Continue WhileWhile
Here's an example of preventing even numbers from being added to the sum.

Usage Advice
There are two alternative techniques that can be used instead of using Exit or Continue.
You can declare a new Boolean variable, initializing it to one value and conditionally setting it to the other value inside the loop; you then use a conditional statement (e.g. If) based on that variable to avoid execution of the statements inside the loop in subsequent iterations.

One of the objections to this technique is that it may be inefficient. For example, if in the above example N is 1000000 and the first element of the array A is equal to SoughtValue, the loop will iterate a further 999999 times without doing anything useful. However, this technique can have the advantage of greater clarity in some cases.
You can use the GoTo statement to jump out of the loop. Note that you cannot use GoTo to jump into a loop.

This technique can sometimes be the neatest way to jump out of the loop and avoid one or more statements that are executed just after the natural end of the loop.
You should consider all of the alternatives, and use whichever one best fits your requirements, considering such things as efficiency, speed of writing the code, and readability (thus maintainability).
Do not be put off using GoTo on those occasions when it is the best alternative.
Section 7.4: While loop to iterate while some condition is true
A While loop starts by evaluating a condition. If it is true, the body of the loop is executed. After the body of the loop is executed, the While condition is evaluated again to determine whether to re-execute the body.


This outputs:
1 2 3 4 5 6 7 8 9 10
Warning: A While loop can lead to an infinite loop. Consider what would happen if the line of code that increments iteration were removed. In such a case the condition would never be True and the loop would continue indefinitely.
Section 7.5: Nested Loop
A nested loop is a loop within a loop, an inner loop within the body of an outer one. How this works is that the first pass of the outer loop triggers the inner loop, which executes to completion. Then the second pass of the outer loop triggers the inner loop again. This repeats until the outer loop finishes. a break within either the inner or outer loop would interrupt this process.
The Structure of a For Next nested loop is :

Example :

Section 7.6: Do...Loop
Do...LoopUse  to repeat a block of statements While or Until a condition is true, checking the condition either at the beginning or at the end of the loop.

or

0 1 2 3 4 5 6 7 8 9

or

0 1 2 3 4 5 6 7 8 9
Continue Do can be used to skip to the next iteration of the loop:

1 3 5 7 9
Exit DoYou can terminate the loop with  - note that in this example, the lack of any condition would otherwise cause an infinite loop:

0 1 2 3 4 5 6 7 8 9
Chapter 8: Enum
Section 8.1: GetNames()
Returns the names of constants in the specified Enum as a string array:


Output:
Small
Medium
Large
Section 8.2: HasFlag()
HasFlagThe () method can be used to check if a flag is set.

For more information about the Flags-attribute and how it should be used see the official Microsoft documentation.
Section 8.3: Enum definition
An enum is a set of logically related constants.


Section 8.4: Member initialization
Each of the enum members may be initialized with a value. If a value is not specified for a member, by default it's initialized to 0 (if it's the first member in the member list) or to a value greater by 1 than the value of the preceding member.

Section 8.5: The Flags attribute
FlagsWith the <> attribute, the enum becomes a set of flags. This attribute enables assigning multiple values to an enum variable. The members of a flags enum should be initialized with powers of 2 (1, 2, 4, 8...).

Section 8.6: GetValues()
' This method is useful for iterating Enum values '

Prints:
1
2
4
Section 8.7: String parsing
An Enum instance can be created by parsing a string representation of the Enum.

See also: Parse a string to an Enum value in VB.NET
Section 8.8: ToString()
The ToString method on an enum returns the string name of the enumeration. For instance:


If, however, the string representation of the actual integer value of the enum is desired, you can cast the enum to an Integer and then call ToString:

Section 8.9: Determine whether a Enum has FlagsAttribute specified or not
The next example can be used to determine whether a enumeration has the FlagsAttribute specified. The methodology used is based on Reflection.
This example will give a True result:
Dim enu As [Enum] = New FileAttributes() Dim hasFlags As Boolean = enu.GetType().GetCustomAttributes(GetType(FlagsAttribute), inherit:=False).Any() Console.WriteLine("{0} Enum has FlagsAttribute?: {1}", enu.GetType().Name, hasFlags)
This example will give a False result:
Dim enu As [Enum] = New ConsoleColor() Dim hasFlags As Boolean = enu.GetType().GetCustomAttributes(GetType(FlagsAttribute), inherit:=False).Any() Console.WriteLine("{0} Enum has FlagsAttribute?: {1}", enu.GetType().Name, hasFlags) We can design a generic usage extension method like this one:
<DebuggerStepThrough>
<Extension>
<EditorBrowsable(EditorBrowsableState.Always)>
Public Function HasFlagsAttribute(ByVal sender As [Enum]) As Boolean
    Return sender.GetType().GetCustomAttributes(GetType(FlagsAttribute), inherit:=False).Any()
End Function
Usage Example:
Dim result As Boolean = (New FileAttributes).HasFlagsAttribute()
Section 8.10: For-each flag (flag iteration)
In some very specific scenarios we would feel the need to perform a specific action for each flag of the source enumeration.
We can write a simple Generic extension method to realize this task.


Usage Example:

Section 8.11: Determine the amount of flags in a flag combination
The next example is intended to count the amount of flags in the specified flag combination.
The example is provided as a extension method:

Usage Example:
Dim flags As FileAttributes = (FileAttributes.Archive Or FileAttributes.Compressed)
Dim count As Integer = flags.CountFlags()
Console.WriteLine(count)
Section 8.12: Find the nearest value in a Enum
The next code illustrates how to find the nearest value of a Enum.
First we define this Enum that will serve to specify search criteria (search direction)

And now we implement the search algorithm:
<DebuggerStepThrough>
Public Shared Function FindNearestEnumValue(Of T)(ByVal value As Long,
                                                  ByVal direction As EnumFindDirection) As T
    Select Case direction
        Case EnumFindDirection.Nearest
            Return (From enumValue As T In [Enum].GetValues(GetType(T)).Cast(Of T)()
                    Order By Math.Abs(value - Convert.ToInt64(enumValue))
                    ).FirstOrDefault
        Case EnumFindDirection.Less
            If value < Convert.ToInt64([Enum].GetValues(GetType(T)).Cast(Of T).First) Then
                Return [Enum].GetValues(GetType(T)).Cast(Of T).FirstOrDefault

Usage Example:

Chapter 9: Threading
Section 9.1: Performing thread-safe calls using Control.Invoke()
Control.InvokeUsing the () method you may move the execution of a method or function from a background
thread to the thread that the control was created on, which is usually the UI (User Interface) thread. By doing so your code will be queued to run on the control's thread instead, which removes the possibility of concurrency.
Control.InvokeRequiredThe  property should also be checked in order to determine whether you need to invoke, or if the code is already running on the same thread as the control.
InvokeThe () method takes a delegate as its first parameter. A delegate holds the reference, parameter list and return type to another method.
In Visual Basic 2010 (10.0) or higher, lambda expressions can be used to create a delegate method on the fly:

Whereas in Visual Basic 2008 (9.0) or lower, you have to declare the delegate on your own:

Section 9.2: Performing thread-safe calls using Async/Await
If we try to change an object on the UI thread from a different thread we will get a cross-thread operation exception:
Private Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' Cross thread-operation exception as the assignment is executed on a different thread     ' from the UI one:
    Task.Run(Sub() MyButton.Text = Thread.CurrentThread.ManagedThreadId)
End Sub
Before VB 14.0 and .NET 4.5 the solution was invoking the assignment on and object living on the UI thread:
Private Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' This will run the conde on the UI thread:
    MyButton.Invoke(Sub() MyButton.Text = Thread.CurrentThread.ManagedThreadId)
End Sub
With VB 14.0, we can run a Task on a different thread and then have the context restored once the execution is complete and then perform the assignment with Async/Await:
Private Async Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' This will run the code on a different thread then the context is restored     ' so the assignment happens on the UI thread:
    MyButton.Text = Await Task.Run(Function() Thread.CurrentThread.ManagedThreadId)
End Sub
Chapter 10: Dictionaries
A dictionary represents a collection of keys and values. See MSDN Dictionary(Tkey, TValue) Class.
Section 10.1: Create a dictionary filled with values

This creates a dictionary and immediately fills it with three KeyValuePairs.
You can also add new values later on by using the Add method:

Note that the key (the first parameter) needs to be unique in the dictionary, otherwise an Exception will be thrown.
Section 10.2: Loop through a dictionary and print all entries
For EachEach pair in the dictionary is an instance of KeyValuePair with the same type parameters as the Dictionary. When you loop through the dictionary with , each iteration will give you one of the Key-Value Pairs stored in the dictionary.
For Each kvp As KeyValuePair(Of String, String) In currentDictionary
  Console.WriteLine("{0}: {1}", kvp.Key, kvp.Value)
Next
Section 10.3: Checking for key already in dictionary - data reduction
The ConstainsKey method is the way to know if a key already exists in the Dictionary.
This come in handy for data reduction. In the sample below, each time we encountner a new word, we add it as a key in the dictionary, else we increment the counter for this specific word.

XML reduction example : getting all the child nodes names and occurence in an branch of an XML document

Section 10.4: Getting a dictionary value
You can get the value of an entry in the dictionary using the 'Item' property:

If the key is not present in the dictionary, a KeyNotFoundException will be thrown.
Chapter 11: File Handling
System.IO.File.ReadAllLines(path As StringSystem.IO.File.ReadAllText(path As StringSystem.IO.File.WriteAllText(path As String, contents As StringSystem.IO.File.WriteAllLines(path As String, contents() As String)
)
)
)
Section 11.1: Write Data to a File
To write the contents of a string to a file:
Dim toWrite As String = "This will be written to the file."
System.IO.File.WriteAllText("filename.txt", toWrite)
WriteAllText will open the specified file, write the data, and then close the file. If the target file exists, it is overwritten. If the target file does not exist, it is created.
To write the contents of an array to a file:
Dim toWrite As String() = {"This", "Is", "A", "Test"} System.IO.File.WriteAllLines("filename.txt", toWrite)
WriteAllLines will open the specified file, write each value of the array on a new line, and then close the file. If the target file exists, it is overwritten. If the target file does not exist, it is created.
Section 11.2: Read All Contents of a File
To read the contents to a file into a string variable:
Dim fileContents As String = System.IO.File.ReadAllText("filename.txt")
ReadAllText will open the specified file, read data to the end, then close the file.
To read a file, separating it into an array element for each line:
Dim fileLines As String() = System.IO.File.ReadAllLines("filename.txt")
ReadAllLines will open the specified file, read each line of the file into a new index in an array until the end of the file, then close the file.
Section 11.3: Write Lines Individually to a Text File using StreamWriter

The use of a Using block is recommended good practice when using an object that Implements IDisposable
Chapter 12: Short-Circuiting Operators (AndAlso OrElse)
result = expression1 AndAlso expression2 result = expression1 OrElse expression2
Parameter	Details
            Required. Any Boolean expression. The result is the Boolean result of comparison of the two result expressions.
expression1 Required. Any Boolean expression. expression2 Required. Any Boolean expression.
Section 12.1: OrElse Usage
' The OrElse operator is the homologous of AndAlso. It lets us perform a boolean
' comparison evaluating the second condition only if the first one is False
If testFunction(5) = True OrElse otherFunction(4) = True Then
    ' If testFunction(5) is True, otherFunction(4) is not called.
    ' Insert code to be executed.
End If
Section 12.2: AndAlso Usage

Section 12.3: Avoiding NullReferenceException
Version≥7.0
    End If
Version≥7.0 AndAlso


Visual Basic 14.0 introduced the null conditional operator, allowing to rewrite the functions in a cleaner way, mimicking the behavior of the AndAlso version of the example.
Chapter 13: Task-based asynchronous pattern
Section 13.1: Basic usage of Async/Await
You can start some slow process in parallel and then collect the results when they are done:

After two seconds both the results will be available.
Section 13.2: Using TAP with LINQ
AddressOf AsyncMethodTask.WhenAllYou can create an IEnumerable of Task by passing  to the LINQ Select method and then start and wait all the results with 
If your method has parameters matching the previous LINQ chain call, they will be automatically mapped.

AddressOf MethodTo map different arguments you can replace  with a lambda:
Function(linqData As Integer) MyNonMatchingMethod(linqData, "Other parameter")
Chapter 14: LINQ
LINQ (Language Integrated Query) is an expression that retrieves data from a data source. LINQ simplifies this situation by offering a consistent model for working with data across various kinds of data sources and formats. In a LINQ query, you are always working with objects. You use the same basic coding patterns to query and transform data in XML documents, SQL databases, ADO.NET Datasets, .NET collections, and any other format for which a LINQ provider is available.
Section 14.1: Selecting from array with simple condition
Dim sites() As String = {"Stack Overflow", "Super User", "Ask Ubuntu", "Hardware  Recommendations"}
Dim query = From x In sites Where x.StartsWith("S")
' result = "Stack Overflow", "Super User"
Query will be enumerable object containing Stack Overflow and Super User. x in the query is iterating variable where will be stored each object checked by Where clause.
Section 14.2: Mapping array by Select clause

Query result will be enumerable object containing lengths of strings in input array. In this example this would be values 14, 10, 10, 24. x in the query is iterating variable where will be stored each object from the input array.
Section 14.3: Ordering output

OrderBy clause orders the output by the value returned from the clause. In this example it is Length of each string. Default output order is ascending. If you need descending you could specify Descending keyword after clause.

Section 14.4: Generating Dictionary From IEnumerable

Public Sub Example()
    'Setup the list of items
    Dim originalList As New List(Of A)     originalList.Add(New A() With {.ID = 1, .Name = "Item 1", .OtherValue = "Item 1 Value"})     originalList.Add(New A() With {.ID = 2, .Name = "Item 2", .OtherValue = "Item 2 Value"})     originalList.Add(New A() With {.ID = 3, .Name = "Item 3", .OtherValue = "Item 3 Value"})
    'Convert the list to a dictionary based on the ID
    Dim dict As Dictionary(Of Integer, A) = originalList.ToDictionary(function(c) c.ID, function(c) c)
    'Access Values From The Dictionary     console.Write(dict(1).Name) ' Prints "Item 1"
    console.Write(dict(1).OtherValue) ' Prints "Item 1 Value" End Sub
Section 14.5: Projection

We can project multiple result at once too

Section 14.6: Getting distinct values (using the Distinct method)
Dim duplicateFruits = New List(Of String) From {"Grape", "Apple", "Grape", "Apple", "Grape"} 'At this point, duplicateFruits.Length = 5
Dim uniqueFruits = duplicateFruits.Distinct();
'Now, uniqueFruits.Count() = 2
'If iterated over at this point, it will contain 1 each of "Grape" and "Apple"
Chapter 15: Data Access
Section 15.1: Read field from Database


Using the above function is simply:
   Dim UserFirstName as string=GetUserFirstName(UserName)
Section 15.2: Simple Function to read from Database and return as DataTable
This simple function will execute the specified Select SQL command and return the result as data set.


Now you can execute the above function from below codes

The above example expects that your SQL Express instance "SQLEXPRESS" is currently installed on "MYDEVPC" and your database "MyDatabase" contains "Customers", "Suppliers" and "Employees" tables and the "sa" user password is "pwd22". Please change these values as per your setup to get the desired results.
Chapter 16: Disposable objects
Section 16.1: Basic concept of IDisposable
DisposeAny time you instantiate a class that Implements IDisposable, you should call .1 on that class when you have finished using it. This allows the class to clean up any managed or unmanaged dependencies that it may be using. Not doing this could cause a memory leak.
DisposeThe Using keyword ensures that . is called, without you having to explicitly call it.
For example without Using:

Now with Using:

DisposeOne major advantage Using has is when an exception is thrown, because it ensures . is called.
Consider the following. If an exception is thrown, you need to need to remember to call .Dispose but you might also have to check the state of the object to ensure you don't get a null reference error, etc.

A using block means you don't have to remember to do this and you can declare your object inside the try:

1 Do I always have to call Dispose() on my DbContext objects? Nope
Section 16.2: Declaring more objects in one Using
Sometimes, you have to create two Disposable objects in a row. There is an easy way to avoid nesting Using blocks. This code

can be shortened into this one. The main advantage is that you gain one indentation level:

Chapter 17: Operators
Section 17.1: String Concatenation
String concatenation is when you combine two or more strings into a single string variable.
String concatenation is performed with the & symbol.

Non-string values will be converted to string when using &.
Dim result as String = "2" & 10 ' result  = "210" Always use & (ampersand) to perform string concatenation.
DON'T DO THIS
While it is possible, in the simplest of cases, to use the + symbol to do string concatenation, you should never do this. If one side of the plus symbol is not a string, when Option strict is off, the behavior becomes non-intuitive, when Option strict is on it will produce a compiler error. Consider:
Dim value = "2" + 10    ' result = 12  (data type Double)
Dim value = "2" + "10"  ' result = "210"  (data type String)
Dim value = "2g" + 10   ' runtime error
The problem here is that if the + operator sees any operand that is a numeric type, it will presume that the programmer wanted to perform an arithmetic operation and attempt to cast the other operand to the equivalent numeric type. In cases where the other operand is a string that contains a number (for example, "10"), the string is converted to a number and then arithmetically added to the other operand. If the other operand cannot be converted to a number (for example, "2g"), the operation will crash due to a data conversion error. The + operator will only perform string concatenation if both operands are of String type.
The & operator, however, is designed for string concatenation and will cast non-string types to strings.
Section 17.2: Math
If you have the following variables

Addition Performed by the plus sign +.

Subtraction Performed by the minus sign -.

Multiplication Performed by the star symbol *.

Division Performed by the forward slash symbol /.

Integer Division Performed by the backslash symbol \.


Modulus Performed by the Mod keyword.

Raise to a Power of Performed by the ^ symbol.

Section 17.3: Assignment
There is a single assignment operator in VB.
 The equal sign = is used both for equality comparison and assignment.
Dim value = 5
Notes
Watch out for assignment vs. equality comparison.

In this example you can see the equal sign being used as both a comparison operator and an assignment operator, unlike other languages. In this case, result will be of type Boolean and will contain the value of the equality comparison between leftValue and rightValue.
Related: Using Option Strict On to declare variables properly
Section 17.4: Comparison
Comparison operators compare two values and return to you a boolean (True or False) as the result.
Equality
 The equal sign = is used both for equality comparison and assignment.
If leftValue = rightValue Then ...
Inequality
 The left angle bracket nest to the right angle bracket <> performs an unequal comparison.
If leftValue <> rightValue Then ...
Greater Than
 The left angle bracket < performs a greater than comparison.
If leftValue < rightValue Then ...
Greater Than Or Equal
 The equal sign nest to the left angle bracket => performs a greater than or equals comparison.
If leftValue =< rightValue Then ...
Less Than
 The right angle bracket > performs a less than comparison.
If leftValue > rightValue Then ...
Less Than Or Equal
 The equal sign nest to the right angle bracket => performs a greater than or equals comparison.
If leftValue => rightValue Then ...
Like
The Like operator tests the equality of a string and a search pattern. The Like operator relies on the Option Compare Statement The following table lists the available patterns. Source:
https://msdn.microsoft.com/en-us/library/swf8kaxw.aspx (Remarks section)
Characters in the Pattern	Matches in the String
?Any single character*Zero or more characters#Any single digit (0 - 9)[charlist]Any single character in charlist[!charlist]Any single character not in charlist See further info on MSDN in the remarks section.
If string Like pattern Then ...
Section 17.5: Bitwise
These are the bitwise operators in VB.NET : And, Or, Xor, Not
Example of And bitwise operation

The value of a will be 1. The result is obtained after comparing 3 and 5 in binary for. 3 in binary form is 011 and 5 in binary form is 101. The And operator places 1 if both bits are 1. If any of the bits are 0 then the value will be 0

So the binary result is 001 and when that is converted to decimal, the answer will be 1.
Or operator places 1 if both or one bit is 1

Xor operator places 1 if only one of the bit is 1 (not both)

Not operator reverts the bits including sign

Section 17.6: Widening and Narrowing
Needs editing.
Section 17.7: Operator Overloading
Needs editing.
Chapter 18: Declaring variables
Public counter As Integer
Private _counter As Integer
Dim counter As Integer
Section 18.1: Declaring and assigning a variable using a primitive type
Variables in Visual Basic are declared using the Dim keyword. For example, this declares a new variable called counter with the data type Integer:

A variable declaration can also include an access modifier, such as Public, Protected, Friend, or Private. This works in conjunction with the variable's scope to determine its accessibility.
Access Modifier	Meaning
Public	All types which can access the enclosing type
Protected	Only the enclosing class and those that inherit from it
Friend	All types in the same assembly that can access the enclosing type
The enclosing class and its inheritors, or the types in the same assembly that can access the
Protected Friend
enclosing class
Private	Only the enclosing type
Static	Only on local variables and only initializes once.
As a shorthand, the Dim keyword can be replaced with the access modifier in the variable's declaration:

The supported data types are outlined in the table below:
	Type	Alias	Memory allocation	Example
Dim example As SByte = 10SByte	N/A	1 byte
Dim example As Short = 10Int16	Short	2 bytes
Dim example As Integer = 10Int32	Integer	4 bytes
Dim example As Long = 10Int64	Long	8 bytes
Dim example As Single = 10.95Single	N/A	4 bytes
Dim example As Double = 10.95Double	N/A	8 bytes
Dim example As Decimal = 10.95Decimal	N/A	16 bytes
Dim example As Boolean = TrueBoolean	N/A	Dictated by implementing platform
Dim example As Char = "A"Char	N/A	2 BytesC
Dim example As String = "Stack Overflow"String	N/A	source
Dim example As Date = Date.NowDateTime Date	8 Bytes
Dim example As Byte = 10Byte	N/A	1 byte
Dim example As UShort = 10UInt16	UShort	2 bytes
Dim example As UInteger = 10UInt32	UInteger 4 bytes
Dim example As ULong = 10UInt64	ULong	8 bytes
Dim example As Object = Nothing4 bytes 32 bit architecture, 8 bytes 64 bit
Object	N/A architecture
There also exist data identifier and literal type characters usable in replacement for the textual type and or to force literal type:
Type (or Alias) Identifier type character	Literal type character
example = 10SShort	N/A
Dim exampleexample = 10% or example = 10IInteger%
Dim exampleexample = 10& or example = 10LLong&
Dim exampleexample = 10! or example = 10FSingle!
example = 10# or example = 10RDouble	Dim example#
example example  10@ or example = 10D "A"Decimal	Dim example@=
Char	N/A=C
String	Dim example$	N/A
example = 10USUShort	N/A
example = 10UIUInteger	N/A
example = 10ULULong	N/A
The integral suffixes are also usable with hexadecimal (&H) or octal (&O) prefixes:
example O77H8000S or example = &= &&
Date(Time) objects can also be defined using literal syntax:
Dim example As Date = #7/26/2016 12:8 PM#Once a variable is declared it will exist within the Scope of the containing type, Sub or Function declared, as an example:

End FunctionThe counter variable will only exist until the  and then will be out of scope. If this counter variable is needed outside of the function you will have to define it at class/structure or module level.

Alternatively, you can use the Static (not to be confused with Shared) modifier to allow a local variable to retain it's value between calls of its enclosing method:


Section 18.2: Levels of declaration - Local and Member variables
ExampleFunctionLocal variables - Those declared within a procedure (subroutine or function) of a class (or other structure). In this example, exampleLocalVariable is a local variable declared within ():

The Static keyword allows a local variable to be retained and keep its value after termination (where usually, local variables cease to exist when the containing procedure terminates).
ExampleSub() from MainIn this example, the console is 024. On each call to () the static variable retains the value it had at the end of the previous call:

Member variables - Declared outside of any procedure, at the class (or other structure) level. They may be instance variables, in which each instance of the containing class has its own distinct copy of that variable, or Shared variables, which exist as a single variable associated with the class itself, independent of any instance.
Here, ExampleClass2 contains two member variables. Each instance of the ExampleClass2 has an individual ExampleInstanceVariable which can be accessed via the class reference. The shared variable ExampleSharedVariable however is accessed using the class name:


Section 18.3: Example of Access Modifiers
In the following example consider you have a solution hosting two projects: ConsoleApplication1 and
SampleClassLibrary. The first project will have the classes SampleClass1 and SampleClass2. The second one will have SampleClass3 and SampleClass4. In other words we have two assemblies with two classes each. ConsoleApplication1 has a reference to SampleClassLibrary.
See how SampleClass1.MethodA interacts with other classes and methods.
SampleClass1.vb:
Imports SampleClassLibrary Public Class SampleClass1 Public Sub MethodA() 'MethodA can call any of the following methods because 'they all are in the same scope. MethodB() MethodC() MethodD() MethodE() 'Sample2 is defined as friend. It is accessible within 'the type itself and all namespaces and code within the same assembly. Dim class2 As New SampleClass2() class2.MethodA() 'class2.MethodB() 'SampleClass2.MethodB is not accessible because 'this method is private. SampleClass2.MethodB 'can only be called from SampleClass2.MethodA,
'SampleClass2.MethodC, SampleClass2.MethodD 'and SampleClass2.MethodE class2.MethodC() 'class2.MethodD() 'SampleClass2.MethodD is not accessible because 'this method is protected. SampleClass2.MethodD 'can only be called from any class that inherits 'SampleClass2, SampleClass2.MethodA, SampleClass2.MethodC,
'SampleClass2.MethodD and SampleClass2.MethodE class2.MethodE() Dim class3 As New SampleClass3()
'SampleClass3 resides in other 'assembly and is defined as public. 'It is accessible anywhere. class3.MethodA() 'class3.MethodB() 'SampleClass3.MethodB is not accessible because 'this method is private. SampleClass3.MethodB can 'only be called from SampleClass3.MethodA, 'SampleClass3.MethodC, SampleClass3.MethodD 'and
SampleClass3.MethodE 'class3.MethodC() 'SampleClass3.MethodC is not accessible because 'this method is friend and resides in another assembly. 'SampleClass3.MethodC can only be called anywhere from the 'same assembly, SampleClass3.MethodA, SampleClass3.MethodB, 'SampleClass3.MethodD and SampleClass3.MethodE 'class4.MethodD() 'SampleClass3.MethodE is not accessible because 'this method is protected friend.
SampleClass3.MethodD 'can only be called from any class that resides inside 'the same assembly and inherits
SampleClass3, 'SampleClass3.MethodA, SampleClass3.MethodB, 'SampleClass3.MethodC and
SampleClass3.MethodD 'Dim class4 As New SampleClass4() 'SampleClass4 is not accessible because 'it is defined as friend and resides in 'other assembly. End Sub Private Sub MethodB() 'Doing MethodB stuff... End Sub Friend Sub
MethodC() 'Doing MethodC stuff... End Sub Protected Sub MethodD() 'Doing MethodD stuff... End Sub Protected Friend Sub MethodE() 'Doing MethodE stuff... End Sub End Class
SampleClass2.vb:
Friend Class SampleClass2 Public Sub MethodA() 'Doing MethodA stuff... End Sub Private Sub MethodB() 'Doing
MethodB stuff... End Sub Friend Sub MethodC() 'Doing MethodC stuff... End Sub Protected Sub MethodD() 'Doing MethodD stuff... End Sub Protected Friend Sub MethodE() 'Doing MethodE stuff... End Sub End Class
SampleClass3.vb:
Public Class SampleClass3 Public Sub MethodA() 'Doing MethodA stuff... End Sub Private Sub MethodB() 'Doing
MethodB stuff... End Sub Friend Sub MethodC() 'Doing MethodC stuff... End Sub Protected Sub MethodD() 'Doing MethodD stuff... End Sub Protected Friend Sub MethodE() 'Doing MethodE stuff... End Sub End Class
SampleClass4.vb:
Friend Class SampleClass4 Public Sub MethodA() 'Doing MethodA stuff... End Sub Private Sub MethodB() 'Doing
MethodB stuff... End Sub Friend Sub MethodC() 'Doing MethodC stuff... End Sub Protected Sub MethodD() 'Doing MethodD stuff... End Sub Protected Friend Sub MethodE() 'Doing MethodE stuff... End Sub End Class
Chapter 19: Classes
A class groups different functions, methods, variables, and properties, which are called its members. A class encapsulates the members, which can be accessed by an instance of the class, called an object. Classes are extremely useful for the programmer, as they make the task convenient and fast, with characteristics such as modularity, re-usability, maintainability, and readability of the code.
Classes are the building blocks of object-oriented programming languages.
Section 19.1: Abstract Classes
If classes share common functionality you can group this in a base or abstract class. Abstract classes can contain partial or no implementation at all and allow the derived type to override the base implementation.
Abstract classes within VisualBasic.NET must be declared as MustInherit and cannot be instantiated.

A sub type can then inherit this abstract class as shown below:

Car will inherit all of the declared types within vehicle, but can only access them based upon the underlying access modifier.

DisplayWheelCountIn the above example a new Car instance is created. The () method is then invoked which will call the base class Vehicles implementation.
Section 19.2: Creating classes
Classes provide a way of creating your own types within the .NET framework. Within a class definition you may include the following:
Fields
Properties
Methods
Constructors Events
To declare a class you use the following syntax:

Other .NET types can be encapsulated within the class and exposed accordingly, as shown below:

Chapter 20: Lists
List.Add(item As Type)
List.RemoveRange(index As Integer, count As Integer)
List.Remove(index As Integer)
List.AddRange(collection)
List.Find(match as Predicate(of String))
List.Insert(index as Integer , item as Type) List.Contains(item as Type)
Section 20.1: Add items to a List

To add more than one item at a time use AddRange. Always adds to the end of the list

In order to add items to the middle of the list use Insert
Insert will place the item at the index, and renumber the remaining items


New Output:

Section 20.2: Check if item exists in a List
    Sub Main()
        Dim People = New List(Of String)({"Bob Barker", "Ricky Bobby", "Jeff Bridges"})
        Console.WriteLine(People.Contains("Rick James"))
        Console.WriteLine(People.Contains("Ricky Bobby"))
        Console.WriteLine(People.Contains("Barker"))
        Console.Read
    End Sub
Produces the following output:

Section 20.3: Loop trough items in list

Produces the following output:

Another option, would be to loop through using the index of each element:

Section 20.4: Create a List
Lists can populated with any data type as necessary, with the format

For example:
Create a new, empty list of Strings

Create a new list of strings, and populate with some data
VB.NET 2005/2008:
Dim aList as New List(Of String)(New String() {"one", "two", "three"})
VB.NET 2010:
Dim aList as New List(Of String) From {"one", "two", "three"}
--
VB.NET 2015:
Dim aList as New List(Of String)(New String() {"one", "two", "three"})
NOTE:
If you are receiving the following when the code is ran:
Object reference not set to an instance of an object.
Dim aList as New List(Of StringDim aList as List(Of String New List(Of StringMake sure you either declare as New i.e. ) or if declaring without the New, make sure you set the list to a new list - ) =)
Section 20.5: Remove items from a List

Section 20.6: Retrieve items from a List

Hello, World
If you do not know the index of the item or only know part of the string then use the Find or FindAll method

Hello, World
The FindAll method returns a new List (of String)

output(0) = "Hello, Test" output(1) = "Test"
Chapter 21: Date
Section 21.1: Converting (Parsing) a String to a Date
DateTime.ParseExactIf you know the format of the string you are converting (parsing) you should use 

DateTime.TryParseExactIf you are not certain for the format of the string, you can use  and test the result to see if parsed or not:

Section 21.2: Converting a Date To A String
ToStringSimply use the . overload of a DateTime object to get the format you require:
Dim dateValue As DateTime = New DateTime(2001, 03, 06)
Dim dateString As String = dateValue.ToString("yyyy-MM-dd") '2001-03-06
Chapter 22: Introduction to Syntax
Section 22.1: Intellisense Helper
One interesting thing is the ability to add you own comments into Visual Studio Intellisense. So you can make your own written functions and classes self-explanatory. To do so, you must type the comment symbol three times the line above your function.
Once done, Visual Studio will automatically add an XML documentation :

After that, if you type in your Test function somewhere in your code, this little help will show up :

Section 22.2: Declaring a Variable
In VB.NET, every variable must be declared before it is used (If Option Explicit is set to On). There are two ways of declaring variables:
Inside a Function or a Sub:
Dim w 'Declares a variable named w of type Object (invalid if Option Strict is On)
Dim x As String 'Declares a variable named x of type String
Dim y As Long = 45 'Declares a variable named y of type Long and assigns it the value 45
Dim z = 45 'Declares a variable named z whose type is inferred
           'from the type of the assigned value (Integer here) (if Option Infer is On)
           'otherwise the type is Object (invalid if Option Strict is On)
           'and assigns that value (45) to it
Option ExplicitSee this answer for full details about , Strict and Infer.
 Inside a Class or a Module:
These variables (also called fields in this context) will be accessible for each instance of the Class they are declared in. They might be accessible from outside the declared Class depending on the modifier (Public, Private,
Protected FriendProtected,  or Friend)
Private x 'Declares a private field named x of type Object (invalid if Option Strict is On)
Public y As String 'Declares a public field named y of type String
Friend z As Integer = 45 'Declares a friend field named z of type Integer and assigns it the value 45
These fields can also be declared with Dim but the meaning changes depending on the enclosing type:


Section 22.3: Comments
The first interesting thing to know is how to write comments.
In VB .NET, you write a comment by writing an apostrophe ' or writing REM. This means the rest of the line will not be taken into account by the compiler.

Section 22.4: Modifiers
Modifiers are a way to indicate how external objects can access an object's data.
 Public
Means any object can access this without restriction
 Private
Means only the declaring object can access and view this
 Protected
Means only the declaring object and any object that inherits from it can access and view this.
 Friend
Means only the delcaring object, any object that inherits from it and any object in the same namespace can access and view this.

Section 22.5: Object Initializers



Although similar anonymousInstance doesn't have same type as someInstance
Member name must be unique in the anonymous type, and can be taken from a variable or another object member name

Each member can be preceded by the Key keyword. Those members will be ReadOnly properties, those without will be read/write properties

Two anonymous instance defined with the same members (name, type, presence of Key and order) will have the same anonymous type.

Anonymous types are structurally equatable. Two instance of the same anonymous types having at least one Key property with the same Key values will be equal. You have to use Equals method to test it, using = won't compile and Is will compare the object reference.
  Dim anon1 = New With { Key .Name = "Foo", Key .Age = 10, .Salary = 0 }
  Dim anon2 = New With { Key .Name = "Bar", Key .Age = 20, .Salary = 0 }   Dim anon3 = New With { Key .Name = "Foo", Key .Age = 10, .Salary = 10000 }
  anon1.Equals(anon2) ' False
  anon1.Equals(anon3) ' True although non-Key Salary isn't the same
Both Named and Anonymous types initializer can be nested and mixed

Section 22.6: Collection Initializer

Is equivalent to

Items can be the result of a constructor, a method call, a property access. It can also be mixed with Object initializer.

It is not possible to use Object initializer syntax AND collection initializer syntax for the same object at the same time. For example, these won't work


We can also allow collection initializer syntax by providing for a custom type.
It must implement IEnumerable and have an accessible and compatible by overload rules Add method (instance, Shared or even extension method) Contrived example :

List(Of PersonIf we wanted to add Person object to a ) by just putting the name in the collection initializer
(but we can't modify the List(Of Person) class) we can use an Extension method


Section 22.7: Writing a function
A function is a block of code that will be called several times during the execution. Instead of writing the same piece of code again and again, one can write this code inside a function and call that function whenever it is needed.
A function :


is just the same as

Chapter 23: Option Strict
 Option Strict { On | Off }
Section 23.1: Why Use It?
Option Strict On prevents three things from happening:
1. Implicit Narrowing Conversion Errors
It prevents you from assigning to a variable that has less precision or smaller capacity (a narrowing conversion) without an explicit cast. Doing so would result in data loss.
Dim d As Double = 123.4
Dim s As Single = d 'This line does not compile with Option Strict On
2. Late Binding Calls
Late binding is not allowed. This is to prevent typos that would compile, but fail at runtime

3. Implicit Object Type Errors
This prevents variable being inferred as an Object when in fact they should have been declared as a type
Dim something = Nothing. 'This line does not compile with Option Strict On Conclusion
Option Strict OnUnless you need to do late binding, you should always have  as it will cause the mentioned errors to generate compile time errors instead of runtime exceptions.
If you have to do late binding, you can either
Option Strict OffProject Properties > Compile Tab Wrap all your late binding calls into one class/module and use  at the top of the code file
(this is the preferred method as it reduces the likelihood of a typos in other files), or
Specify that Late Binding does not cause a compilation failure (>
Warning Configuration)
Section 23.2: How to Switch It On

Project > [Project] Properties > Compile Tab > Option Strict > On

Tools > Options > Projects and Solutions > VB defaults > Option Strict Set it to On.
Chapter 24: NullReferenceException
Section 24.1: Empty Return

BAD CODE

GOOD CODE

Version=14.0
Null Conditional Operator

Section 24.2: Uninitialized variable
BAD CODE

GOOD CODE
Dim f As System.Windows.Forms.Form = New System.Windows.Forms.Form ' Dim f As New System.Windows.Forms.Form ' alternative syntax f.ShowModal()
EVEN BETTER CODE (Ensure proper disposal of IDisposable object more info)

Chapter 25: FTP server
My.Computer.Network.DownloadFile(serverFile As String, localFile As String)
My.Computer.Network.DownloadFile(serverFile As String, localFile As String, user As String, password As String)
My.Computer.Network.UploadFile(localFile As String, serverFile As String)
My.Computer.Network.UploadFile(localFile As String, serverFile As String, user As String, password As String)
Section 25.1: Download file from FTP server
My.Computer.Network.DownloadFile("ftp://server.my/myfile.txt", "donwloaded_file.txt")
myfile.txt file from server named server.my and saves it as donwloaded_file.txtThis command download  into working directory. You can specify absolute path for downloaded file.
Section 25.2: Download file from FTP server when login required
My.Computer.Network.DownloadFile("ftp://srv.my/myfile.txt", "donwload.txt", "Peter", "1234")
myfile.txt file from server named srv.my and saves it as donwload.txtThis command download  into working
directory. You can specify absolute path for downloaded file. File is download by user Peter with password 1234.
Section 25.3: Upload file to FTP server
My.Computer.Network.UploadFile("example.txt", "ftp://server.my/server_example.txt")
example.txtserver.my. File stored on the server will be named server_example.txtThis command upload  file from working directory (you could specify absolute path if you want) to server named .
Section 25.4: Upload file to FTP server when login required
My.Computer.Network.UploadFile("doc.txt", "ftp://server.my/on_server.txt", "Peter", "1234")
doc.txtserver.my. File stored on the server will be named server_example.txtThis command upload  file from working directory (you could specify absolute path if you want) to server named . Fill is send on the server by user
Peter and password 1234.
Chapter 26: Error Handling
Section 26.1: Try...Catch...Finally Statement
Structure:
Try
    'Your program will try to run the code in this block.  
    'If any exceptions are thrown, the code in the Catch Block will be executed,     'without executing the lines after the one which caused the exception.
Catch ex As System.IO.IOException
    'If an exception occurs when processing the Try block, each Catch statement
    'is examined in textual order to determine which handles the exception.
    'For example, this Catch block handles an IOException.
Catch ex As Exception
    'This catch block handles all Exception types.
    'Details of the exception, in this case, are in the "ex" variable.
    'You can show the error in a MessageBox with the below line.
    MessageBox.Show(ex.Message)
Finally
    'A finally block is always executed, regardless of if an Exception occurred. End Try
Example Code:


Section 26.2: Creating custom exception and throwing
You can create a custom exception and throw them during the execution of your function. As a general practice you should only throw an exception when your function could not achieve its defined functionality.

Section 26.3: Try Catch in Database Operation
You can use Try..Catch to rollback database operation by placing the rollback statement at the Catch Segment.

Section 26.4: The Un-catchable Exception
Catch ex As ExceptionAlthough  claims that it can handle all exceptions - there are one exception (no pun intended).

System.StackOverflowExceptionOops... There is an un-caught  while the console didn't even print out anything!
According to MSDN,
Starting with the .NET Framework 2.0, you can't catch a StackOverflowException object with a try/catch block, and the corresponding process is terminated by default. Consequently, you should write your code to detect and prevent a stack overflow.
System.StackOverflowExceptionSo,  is un-catchable. Beware of that!
Section 26.5: Critical Exceptions
Generally most of the exceptions are not that critical, but there are some really serious exceptions that you might
System.StackOverflowExceptionnot be capable to handle, such as the famous . However, there are others that
Catch ex As Exception, such as System.OutOfMemoryExceptionmight get hidden by ,
System.BadImageFormatException and System.InvalidProgramException. It is a good programming practice to leave these out if you cannot correctly handle them. To filter out these exceptions, we need a helper method:
Public Shared Function IsCritical(ex As Exception) As Boolean
    Return TypeOf ex Is OutOfMemoryException OrElse
           TypeOf ex Is AppDomainUnloadedException OrElse
           TypeOf ex Is AccessViolationException OrElse
           TypeOf ex Is BadImageFormatException OrElse
           TypeOf ex Is CannotUnloadAppDomainException OrElse
           TypeOf ex Is ExecutionEngineException OrElse ' Obsolete one, but better to include
           TypeOf ex Is InvalidProgramException OrElse
           TypeOf ex Is System.Threading.ThreadAbortException
End Function Usage:

Chapter 27: OOP Keywords
Section 27.1: Defining a class
Classes are vital aspects of OOP. A class is like the "blueprint" of an object. An object has the properties of a class, but the characteristics are not defined within the class itself. As each object can be different, they define their own characteristics.

A class can also contain subclasses. A subclass inherits the same properties and behaviors as its parent class, but can have its own unique properties and classes.
Section 27.2: Inheritance Modifiers (on classes)
Inherits
Specifies the base (or parent) class


Possible objects:

Prevents programmers from using the class as a base class.

Possible objects:
Dim p As New Person
MustInherit
Specifies that the class is intended for use as a base class only. (Abstract class)

Possible objects:

Section 27.3: Inheritance Modifiers (on properties and methods)
Overridable
Allows a property or method in a class to be overridden in a derived class.

Overrides an Overridable property or method defined in the base class.

End Class
NotOverridable
Prevents a property or method from being overridden in an inheriting class. Default behaviour. Can only be declared on overrides methods

Example Usage:

Output:

MustOverride
Requires that a derived class override the property or method.
MustOverride methods must be declared in MustInherit classes.


Example Usage:

Output:

Section 27.4: MyBase
The MyBase keyword behaves like an object variable that refers to the base class of the current instance of a class.

Usage example:

Output:

Section 27.5: Me vs MyClass
Me uses the current object instance.
MyClass uses the memberdefinition in the class where the member is called


Example Usage:

Output:

Section 27.6: Overloading
Overloading is the creation of more than one procedure, instance constructor, or property in a class with the same name but different argument types.

Section 27.7: Shadows
It redeclares a member that is not overridable. Only calls to the instance will be affected. Code inside the base classes will not be affected by this.


Example usage:

Output:

Pitfalls:
Example1, Creating a new object through a generic. Which function will be used??

example usage:

Output: By intuition the result should be the same. Yet that is not true.

Example 2:


Output: By intuition you could think that p and s are equal and will behave equal. Yet that is not true.

In this simple examples it is easy to learn the strange behaviour of Shadows. But in real-life it brings a lot of surprises. It is advisably to prevent the usage of shadows. One should use other alternatives as much as possible (overrides etc..)
Section 27.8: Interfaces

Chapter 28: Working with Windows Forms
Section 28.1: Using the default Form instance
VB.NET offers default Form instances. The developer does not need to create the instance as it is created behind the scenes. However, it is not preferable to use the default instance all but the simplest programs.

See also:
Do you have to explicitly create instance of form in VB.NET?
Why is there a default instance of every form in VB.Net but not in C#?
Section 28.2: Passing Data From One Form To Another
Sometimes you might want to pass information that has been generated in one form, to another form for additional use. This is useful for forms that display a search tool, or a settings page among many other uses.
Let's say you want to pass a DataTable between a form that is already open (MainForm) and a new form (NewForm):
In The MainForm:

In The NewForm

Now when the NewForm is opened, it is passed DataTable1 from MainForm and stored as NewDataTable in NewForm for use by that form.
This can be extremely useful when trying to pass large amounts of information between forms, especially when combining all of the information in to a single ArrayList and passing the ArrayList to the new form.
Chapter 29: File/Folder Compression
Section 29.1: Adding File Compression to your project
1. In Solution Explorer go to your project, right click on References then Add reference...
2. Search for Compression and select System.IO.Compression.FileSystem then press OK.
Imports System.IO.Compression3. Add  to the top of your code file (before any class or module, with the other
Imports statements).

Plese note that this class (ZipArchive) is only available from .NET verison 4.5 onwards
Section 29.2: Creating zip archive from directory
System.IO.Compression.ZipFile.CreateFromDirectory("myfolder", "archive.zip")
Create archive.zip file containing files which are in myfolder. In example paths are relative to program working directory. You can specify absolute paths.
Section 29.3: Extracting zip archive to directory
System.IO.Compression.ZipFile.ExtractToDirectory("archive.zip", "myfolder")
Extracts archive.zip to myfolder directory. In example paths are relative to program working directory. You can specify absolute paths.
Section 29.4: Create zip archive dynamicaly

Chapter 30: ByVal and ByRef keywords
Section 30.1: ByRef keyword
ByRef keyword before method parameter says that parameter will be sent in a way allowing the method to change (assign a new value) the variable underlying the parameter.

Section 30.2: ByVal keyword
ByVal keyword before method parameter (or no keyword as ByVal is assumed by default) says that parameter will be sent in a way not allowing the method to change (assign a new value) the variable underlying the parameter. It doesn't prevent the content (or state) of the argument to be changed if it's a class.

Chapter 31: Type conversion
CBool(expression)
CByte(expression)
CChar(expression)
CDate(expression)
CDbl(expression)
CDec(expression)
CInt(expression)
CLng(expression)
CObj(expression)
CSByte(expression)
CShort(expression)
CSng(expression)
CStr(expression)
CUInt(expression)
CULng(expression)
CUShort(expression)
Function name	Range for Expression argument
CBool	Any valid Char or String or numeric expression CByte	0 through 255 (unsigned); fractional parts are rounded.
Any valid Char or String expression; only first character of a String is converted; value can be 0
CChar through 65535 (unsigned).
Section 31.1: Converting Text of The Textbox to an Integer
From MSDN
Use the CInt function to provide conversions from any other data type to an Integer subtype. For example, CInt forces integer arithmetic when currency, single-precision, or double-precision arithmetic would normally occur.
Assuming that you have 1 button and 2 textbox. If you type on textbox1.text 5.5 and on textbox2.text 10.
If you have this code:

CInt(expressionIn order to add the values of the 2 textboxes you need to convert their values to Int by using the ).

Note: When the fractional part of a value is exactly 0.5, the CInt function rounds to the closest even number. For example, 0.5 rounds to 0, while 1.5 rounds to 2, and 3.5 rounds to 4. The purpose of rounding to the closest even number is to compensate for a bias that could accumulate when many numbers are added together.
Chapter 32: Option Explicit
Section 32.1: What is it?
It forces you to explicitly declare all variables.
What is the difference between explicitly declaring and implicitly declaring a variable?
Explicitly declaring a variable:

Implicitly declaring a variable:

Conclusion
Option Explicit OnTherefore, you should always have  as you could misspel a variable during assignment, which cause your program to behave unexpectedly.
Section 32.2: How to switch it on?
Document level
Option Explicit OnIt is on by default, but you can have an extra layer of protection by placing  at the top of the code file. The option will apply to the whole document.
Project level
You can switch it on via the menu in Visual Studio:
Project > [Project] Properties > Compile Tab > Option Explicit
Choose On in the drop-down menu. The option will apply to the whole document.
All new projects
You can switch it On by default for all new Projects by selecting: Tools > Options > Projects and Solutions > VB defaults > Option Explicit
Choose On in the drop-down menu.
Chapter 33: Option Infer
Section 33.1: How to enable/disable it
Document level
Option Infer On|OffIt is on by default, but you can set it by placing  at the top of the code file. The option will apply to the whole document.
Project level
You can switch it on/off via the menu in Visual Studio:
Project > [Project] Properties > Compile Tab > Option infer
On|OffChoose  in the drop-down menu. The option will apply to the whole document.
All new projects
You can switch it On by default for all new Projects by selecting: Tools > Options > Projects and Solutions > VB defaults > Option Infer
On|OffChoose  in the drop-down menu.
Section 33.2: What is it?
Enables the use of local type inference in declaring variables.
What is type inference?
You can declare local variables without explicitly stating a data type. The compiler infers the data type of a variable from the type of its initialization expression.
Option Infer On:
Dim aString  = "1234" '--> Will be treated as String by the compiler
Dim aNumber  = 4711   '--> Will be treated as Integer by the compiler
vs. explicit type declaration:

Option Infer Off:
Option Infer Off depends on the Option StrictThe compiler behavior with  setting which is already documented here.
 Option Infer Off - Option Strict Off Option Infer Off - Option Strict On
All variables without explicit type declarations are declared as Object.
The compiler won´t let you declare a variable without an explicit type.
'Dim aString  = "1234" '--> Will not compile due to missing type in declaration
Section 33.3: When to use type inference
Basically you can use type inference whenever it is possible.
Option Infer Off and Option Strict OffHowever, be careful when combining , as this can lead to undesired runtime behavior:

Anonymous Type
Option Infer OnAnonymous types can only be declared with .
They are often used when dealing with LINQ:

Option Strict OnOption Strict OffThe compiler will either throw an error (with ) or will consider q as type object (with ).
Both cases will produce the outcome that you cannot use the anonymous type.
Doubles/Decimals
Numeric variables with decimal places will be infered as Double by default:
Dim aNumber = 44.11 '--> Will be treated as type `Double` by the compiler
If another type like Decimal is desired the value which initialized the variable needs to be marked:
Dim mDecimal = 47.11D '--> Will be treated as type `Decimal` by the compiler
Chapter 34: GDI+
Section 34.1: Draw Shapes
To start drawing a shape you need to define a pen object The Pen accepts two parameters:
1. Pen Color or Brush
2. Pen Width
The Pen Object is used to create an outline of the object you want to draw
After Defining the Pen you can set specific Pen Properties
   Dim pens As New Pen(Color.Purple)    pens.DashStyle = DashStyle.Dash 'pen will draw with a dashed line    pens.EndCap = LineCap.ArrowAnchor 'the line will end in an arrow    pens.StartCap = LineCap.Round 'The line draw will start rounded
   '*Notice* - the Start and End Caps will not show if you draw a closed shape
Then use the graphics object you created to draw the shape
  Private Sub GraphicForm_Paint(sender As Object, e As PaintEventArgs) Handles MyBase.Paint
    Dim pen As New Pen(Color.Blue, 15) 'Use a blue pen with a width of 15
    Dim point1 As New Point(5, 15) 'starting point of the line     Dim point2 As New Point(30, 100) 'ending point of the line     e.Graphics.DrawLine(pen, point1, point2)
    e.Graphics.DrawRectangle(pen, 60, 90, 200, 300) 'draw an outline of the rectangle
By default, the pen's width is equal to 1
    Dim pen2 as New Pen(Color.Orange) 'Use an orange pen with width of 1
    Dim origRect As New Rectangle(90, 30, 50, 60) 'Define bounds of arc
    e.Graphics.DrawArc(pen2, origRect, 20, 180) 'Draw arc in the rectangle bounds
End Sub
Section 34.2: Fill Shapes
Graphics.FillShapes draws a shape and fills it in with the color given. Fill Shapes can use
1. Brush Tool - to fill shape with a solid color
Dim rect As New Rectangle(50, 50, 50, 50)
e.Graphics.FillRectangle(Brushes.Green, rect) 'draws a rectangle that is filled with green
e.Graphics.FillPie(Brushes.Silver, rect, 0, 180) 'draws a half circle that is filled with silver
2. HatchBrush Tool - to fill shape with a pattern
Dim hBrush As New HatchBrush(HatchStyle.ZigZag, Color.SkyBlue, Color.Gray)
'creates a HatchBrush Tool with a background color of blue, foreground color of gray,
'and will fill with a zigzag pattern
Dim rectan As New Rectangle(100, 100, 100, 100)
e.Graphics.FillRectangle(hBrush, rectan)
3. LinearGradientBrush - to fill shape with a gradient
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)  Dim rect As New Rectangle(50, 50, 200, 200)
 e.Graphics.FillRectangle(lBrush, rect)
4. TextureBrush - to fill shape with a picture
You can choose a picture from resources, an already defined Bitmap, or from a file name
   Dim textBrush As New TextureBrush(New Bitmap("C:\ColorPic.jpg"))     Dim rect As New Rectangle(400, 400, 100, 100)
    e.Graphics.FillPie(textBrush, rect, 0, 360)
Both the Hatch Brush Tool and LinearGradientBrush import the following statement : Imports System.Drawing.Drawing2D
Section 34.3: Text
To draw text onto the form use the DrawString Method
When you draw a string you can use any of the 4 brushes listed above
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)
e.Graphics.DrawString("HELLO", New Font("Impact", 60, FontStyle.Bold), lBrush, New Point(40, 400)) 'this will draw the word "Hello" at the given point, with a linearGradient Brush
Since you can't define the width or height of the text use Measure Text to check text size
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)
Dim TextSize =  e.Graphics.MeasureString("HELLO", New Font("Impact", 60, FontStyle.Bold), lBrush)
'Use the TextSize to determine where to place the string, or if the font needs to be smaller
Ex: You need to draw the word "Test" on top of the form. The form's width is 120. Use this loop to decrease the font size till it will fit into the forms width

Section 34.4: Create Graphic Object
There are three ways to create a graphics object
1. From the Paint Event
Every time the control is redrawn (resized, refreshed...) this event is called, use this way if you want the control to consistently draw on the control

2. Create Graphic
This is most often used when you want to create a one time graphic on the control, or you don't want the control to repaint itself

3. From an Existing Graphic
Use this method when you want to draw and change an existing graphic
   'The existing image can be from a filename, stream or Drawing.Graphic
   Dim image = New Bitmap("C:\TempBit.bmp")
   Dim gr As Graphics = Graphics.FromImage(image)
Chapter 35: Google Maps in a Windows Form
Section 35.1: How to use a Google Map in a Windows Form
The first part of this example explains how to implement it. In the second, I will explain how it works. This tries to be a general example. The template for the map (see step 3) and the example functions are fully customizable.
################################# IMPLEMENTATION #################################
Step 1. Firstly, create a new project and select Windows Form Application. Let's leave its name as "Form1".

Step 2. Add a WebBrowser control (which will hold your map) to your Form1. Let's call it "wbmap"
Step 3. Create a .html file named "googlemap_template.html" with your favourite text editor and paste the following code:
googlemap_template.html


This will serve as our map template. I will explain how it works later.
Step 4. Add the googlemap_template.hmtl file to your project (right click on your project->add->existing item) Step 5. Once it appears in your Solution Explorer, set its properties to:

Step 6. Add a new class (right click on your project->add->class). In my example I'll call it GoogleMapHelper.

Step 7. Paste the following code into your class:
GoogleMapHelper.vb
    Imports System.IO
    Imports System.Reflection
    Imports System.Text
   
    Public Class GoogleMapHelper
    ' 1- googlemap_template.html must be copied in the main project folder
    ' 2- add the file into the Visual Studio Solution Explorer (add existing file)
    ' 3- set the properties of the file to:
    '                                   Build Action -> Embedded Resource
    '                                   Custom Tool Namespace -> write the name of the project
    Private Const ICON_FOLDER As String = "marker_icons/" 'images must be stored in a folder inside  Debug/Release folder
    Private Const MAP_TEMPLATE As String = "WindowsApplication1.googlemap_template.html"
    Private Const TEXT_TO_REPLACE_MARKER_DATA As String = "[[MARKER_DATA]]"
    Private Const TMP_NAME As String = "tmp_map.html"
   

    Private mWebBrowser As WebBrowser
    'MARKER POSITIONS
    Private mPositions As Double(,) 'lat, lon
    ' marker data allows different formats to include lat,long and optionally title and icon:
    ' op1: mMarkerData = New String(N-1, 1) {{lat1, lon1}, {lat2, lon2}, {latN, lonN}}
    ' op2: mMarkerData = New String(N-1, 2) {{lat1, lon1,'title1'}, {lat2, lon2,'title2'}, {latN, lonN, 'titleN'}}
    ' op3: mMarkerData = New String(N-1, 3) {{lat1, lon1,'title1','image1.png'}, {lat2, lon2,'title2','image2.png'}, {latN, lonN, 'titleN','imageN.png'}}
    Private mMarkerData As String(,) = Nothing
   
    Public Sub New(ByRef wb As WebBrowser, pos As Double(,))         mWebBrowser = wb         mPositions = pos
        mMarkerData = getMarkerDataFromPositions(pos)     End Sub
    Public Sub New(ByRef wb As WebBrowser, md As String(,))         mWebBrowser = wb         mMarkerData = md     End Sub
    Public Sub loadMap()
        mWebBrowser.Navigate(getMapTemplate())     End Sub
    Private Function getMapTemplate() As String
        If mMarkerData Is Nothing Or mMarkerData.GetLength(1) > 4 Then
            MessageBox.Show("Marker data has not the proper size. It must have 2, 3 o 4 columns")
            Return Nothing
        End If
        Dim htmlTemplate As New StringBuilder()
        Dim tmpFolder As String = Environment.GetEnvironmentVariable("TEMP")
        Dim dataSize As Integer = mMarkerData.GetLength(1) 'number of columns
        Dim mMarkerDataAsText As String = String.Empty
        Dim myresourcePath As String = My.Resources.ResourceManager.BaseName
        Dim myresourcefullPath As String = Path.GetFullPath(My.Resources.ResourceManager.BaseName)
        Dim localPath = myresourcefullPath.Replace(myresourcePath, "").Replace("\", "/") & ICON_FOLDER
        htmlTemplate.AppendLine(getStringFromResources(MAP_TEMPLATE))         mMarkerDataAsText = "["
        For i As Integer = 0 To mMarkerData.GetLength(0) - 1             If i <> 0 Then
                mMarkerDataAsText += ","             End If
            If dataSize = 2 Then 'lat,lon
                mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & "]"             ElseIf dataSize = 3 Then 'lat,lon and title                 mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & ",'" & mMarkerData(i, 2) & "']"
            ElseIf dataSize = 4 Then 'lat,lon,title and image                 mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & ",'" & mMarkerData(i, 2) & "','" & localPath & mMarkerData(i, 3) & "']" 'Ojo a las comillas simples en las columnas 3 y 4
            End If
        Next
Note: The MAP_TEMPLATE constant must include the name of your project
Step 8. Now we can use our GoogleMapHelper class to load the map into our webbrowser by simply creating and instance and calling its loadMap() method. How you build your markerData is up to you. In this example, for clarification, I write them by hand. There are 3 options to define the marker data (see GoogleMapHelper class comments). Note that if you use the third option (including title and icons) you must create a folder called "marker_icons" (or whatever you define in the GoogleMapHelper constant ICON_FOLDER) in your Debug/Release folder and place there your .png files. In my case:

I created two buttons in my Form1 to illustrate how the map and the WF interact. Here is how it looks:

And here is the code:
Form1.vb

{"42.13684", "-0.40884", "marker1"}, {"42.13716", "-0.40729", "marker2"}}
    Dim positonTitlesAndIcons As String(,) = New String(2, 3) {{"42.13557", "-0.40806", "marker0",
"truck_red.png"}, {"42.13684", "-0.40884", "marker1", "truck_red.png"}, {"42.13716", "-0.40729", "marker2", "truck_red.png"}}
    'Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, onlyPositions)
    'Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, positonAndTitles)     Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, positonTitlesAndIcons)     gmh.loadMap() End Sub
'############################### CALLING JAVASCRIPT METHODS ##############################
'This methods call methods written in googlemap_template.html
Private Sub callMapJavascript(sender As Object, e As EventArgs) Handles Button1.Click     wbmap.Document.InvokeScript("showJavascriptHelloWorld") End Sub
Private Sub callMapJavascriptWithArguments(sender As Object, e As EventArgs) Handles Button2.Click     wbmap.Document.InvokeScript("focusMarkerFromIdx", New String() {2}) End Sub
'#########################################################################################
'############################### METHODS CALLED FROM JAVASCRIPT ########################## 'This methods are called by the javascript defined in googlemap_template.html when some events are triggered
Public Sub getMarkerDataFromJavascript(title As String, idx As String)
    MsgBox("Title: " & title & " idx: " & idx)
End Sub
Public Sub showVbHelloWorld()
    MsgBox("Hello world in WF from HTML")
End Sub End Class
IMPORTANT : don't forget to add these lines before your class Form1 definition:
<PermissionSet(SecurityAction.Demand, Name:="FullTrust")>
<System.Runtime.InteropServices.ComVisible(True)>
What they do is to tell the .NET Framework that we want fulltrust and make the class visible to COM so Form1 is visible to JavaScript.
Also don't forget this in your Form1 load function:

It exposes your Form1 class to the JavaScript on the googlemap_template.hmtl page.
Now you can execute and it should be working
################################# HOW IT WORKS#################################
Basically, what our GoogleMapHelper class does is to read our googlemap_template.html, make a temporal copy, replace the code related to the markers ([[MARKER_DATA]]) and execute the page in the web browser control of our form. This html loops through all the markers and assigns a 'click' listener to each one. This click function is obviously fully customizable. In the example it opens an infowindow if the marker has a title, centers the map in such marker and calls two external functions that are defined in our Form1 class.
On the other hand, we can define other javascript functions (with or without arguments) in this html to be called from our Windows Form (by using wbmap.Document.InvokeScript).
Chapter 36: BackgroundWorker
Section 36.1: Using BackgroundWorker
Executing a task with the background worker.
Double Click on the BackgroundWorker control from the Toolbox

This is how the BackgroundWorker appears after adding it.

Double click on the added control to get the BackgroundWorker1_DoWork event and add the code to be executed when the BackgroundWorker is called. Something like this:

Calling the BackgroundWorker to perform the task can be done at any event like Button_Click, Textbox_TextChanged, etc. as follows:

Modify the RunWorkerCompleted event to capture the task finished event of the BackgroundWorker as follows:
Private Sub BackgroundWorker1_RunWorkerCompleted(ByVal sender As Object, ByVal e As
System.ComponentModel.RunWorkerCompletedEventArgs) Handles BackgroundWorker1.RunWorkerCompleted
    MsgBox("Done")
End Sub
This will display a message box saying Done when the worker finishes the task assigned to it.
Section 36.2: Accessing GUI components in BackgroundWorker
You cannot access any GUI components from the BackgroudWorker. For example if you try to do something like this

you will receive a runtime error saying that "Cross-thread operation not valid: Control 'TextBox1' accessed from a thread other than the thread it was created on."
This is because the BackgroundWorker runs your code on another thread in parallel with the main thread, and the GUI components are not thread-safe. You have to set your code to be run on the main thread using the Invoke method, giving it a delegate:
Private Sub BackgroundWorker1_DoWork(sender As Object, e As DoWorkEventArgs)
    Me.Invoke(New MethodInvoker(Sub() Me.TextBox1.Text = "Done"))
End Sub
Or you can use the ReportProgress method of the BackgroundWorker:
Private Sub BackgroundWorker1_DoWork(sender As Object, e As DoWorkEventArgs)
    Me.BackgroundWorker1.ReportProgress(0, "Done")
End Sub
Private Sub BackgroundWorker1_ProgressChanged(sender As Object, e As ProgressChangedEventArgs)
    Me.TextBox1.Text = DirectCast(e.UserState, String)
End Sub
Chapter 37: Connection Handling
Section 37.1: Public connection property

Chapter 38: Using BackgroundWorker
Section 38.1: Basic implementation of Background worker class
You need to import System.ComponentModel for using background worker

Then Declare a private variable

You need to create two methods for background worker's DoWork and RunWorkerCompleted events and assign them.

The below sub will be executed when the worker finishes the job

Then within your code add the below lines to start the background worker
    bgWorker = New BackgroundWorker     AddHandler bgWorker.DoWork, AddressOf MyWorker_DoWork     AddHandler bgWorker.RunWorkerCompleted, AddressOf MyWorker_RunWorkerCompleted     bgWorker.RunWorkerAsync()
When you call RunWorkerAsync() function, MyWorker_DoWork will be executed.
Chapter 39: Generics
Section 39.1: Create a generic class
A generic type is created to adapt so that the same functionallity can be accessible for different data types.

Section 39.2: Instance of a Generic Class
By creating an instance of the same class with a different type given, the interface of the class changes depending on the given type.

Section 39.3: Define a 'generic' class
A generic class is a class who adapts to a later-given type so that the same functionality can be offered to different types.
In this basic example a generic class is created. It has a sub who uses the generic type T. While programming this class, we don't know the type of T. In this case T has all the characteristics of Object.

Section 39.4: Use a generic class
In this example there are 2 instances created of the SomeClass Class. Depending on the type given the 2 instances have a different interface:

The most famous generic class is List(of )
Section 39.5: Limit the possible types given
The possible types passed to a new instance of SomeClass must inherit SomeBaseClass. This can also be an interface. The characteristics of SomeBaseClass are accessible within this class definition.

Section 39.6: Create a new instance of the given type
Creating a new intance of a generic type can be done/checed at compile time.

Or with limited types:


The baseClass (if none given it is Object) must have a parameter less constructor.
This can also be done at runtime through reflection
Chapter 40: Multithreading
Section 40.1: Multithreading using Thread Class
This example uses the Thread Class, but multithreaded applications can also be made using BackgroundWorker. The AddNumber, SubstractNumber, and DivideNumber functions will be executed by separate threads:
Edit: Now the UI thread waits for the child threads to finish and shows the result.


Chapter 41: Unit Testing in VB.NET
Section 41.1: Unit Testing for Tax Calculation
This example is divided into two pillars
 SalaryCalculation Class : Calculating the net salary after tax deduction
SalaryCalculationTests Class : For testing the method that calculates the net salary
Step 1: Create Class Library, name it WagesLibrary or any appropriate name. Then rename the class to SalaryCalculation
''' ''' Class for Salary Calculations ''' Public Class SalaryCalculation

Step 2 : Create Unit Test Project. Add reference to the created class library and paste the below code

Assert.Equal checks the expected value against the actual calculated value. the value 0.1 is used to allow
tolerance or variation between expected and actual result.
Step 3 : Run the test of the method to see result

Test result 
Section 41.2: Testing Employee Class assigned and derived Properties
This example has more tests available in unit testing.
Employee.vb (Class Library)


EmployeeTest.vb (Test Project)


Result after running tests


Chapter 42: Reading compressed textfile on-the-fly
Section 42.1: Reading .gz textfile line after line
.NextLine()This class open a .gz file (usual format of compressed log files) and will return a line at each call of There is no memory usage for temporary decompression, very useful for large file.

Note : there is no failsafe, for readbility purpose.
Chapter 43: Conditions
Section 43.1: If operator
Version≥9.0

We can use the If operator instead of If...Then...Else..End If statement blocks.
Consider the following example:


is the same as

Ifcondition?a:b() uses short-circuit evaluation, which means that it will only evaluate the arguments it uses. If the condition is false (or a Nullable that is Nothing), the first alternative will not be evaluated at all, and none of its side effects will be observed. This is effectively the same as C#'s ternary operator in the form of .
This is especially useful in avoiding exceptions:

IfWe all know that dividing by zero will throw an exception, but () here guards against this by short-circuiting to only the expression that the condition has already ensured is valid.
Another example:
Dim varDate as DateTime = If(varString <> "N/A", Convert.ToDateTime(varString), Now.Date)
varString <> "N/A" evaluates to False, it will assign varDate's value as Now.DateIf  without evaluating the first expression.
Version<9.0
If() operator and have to make do with the IIfOlder versions of VB do not have the () built-in function. As it's a
If..Thenfunction, not an operator, it does not short-circuit; all expressions are evaluated, with all possible side-effects, including performance penalties, changing state, and throwing exceptions. (Both of the above examples that avoid exceptions would throw if converted to IIf.) If any of these side effects present a problem, there's no way to use an inline conditional; instead, rely on  blocks as usual.
Section 43.2: IF...Then...Else

Chapter 44: Recursion
Section 44.1: Compute nth Fibonacci number
Visual Basic.NET, like most languages, permits recursion, a process by which a function calls itself under certain conditions.
Here is a basic function in Visual Basic .NET to compute Fibonacci numbers.

Precondition: Must be greater than or equal to 1.</param>
''' <returns>The nth Fibonacci number. Throws an exception if a precondition is violated.</returns>
Public Shared Function Fibonacci(ByVal n as Integer) as Integer
    If n<1
        Throw New ArgumentOutOfRangeException("n must be greater than or equal to one.")
    End If
    If (n=1) or (n=2)
        ''Base case. The first two Fibonacci numbers (n=1 and n=2) are both 1, by definition.
        Return 1     End If
    ''Recursive case.
    ''Get the two previous Fibonacci numbers via recursion, add them together, and return the result.
    Return Fibonacci(n-1) + Fibonacci(n-2)
End Function
This function works by first checking if the function has been called with the parameter n equal to 1 or 2. By definition, the first two values in the Fibonacci sequence are 1 and 1, so no further computation is necessary to determine this. If n is greater than 2, we cannot look up the associated value as easily, but we know that any such Fibonacci number is equal to the sum of the prior two numbers, so we request those via recursion (calling our own
Fibonacci function). Since successive recursive calls get called with smaller and smaller numbers via decrements of -1 and -2, we know that eventually they will reach numbers that are smaller than 2. Once those conditions (called base cases) are reached, the stack unwinds and we get our final result.
Chapter 45: Using Statement
 Using a = New DisposableClass [, b = ...]
...
End Using
 Using a = GetDisposable(...) [, b = ...]
...
End Using
Section 45.1: See examples under Disposable objects
Basic concept of IDisposable
Chapter 46: WPF XAML Data Binding
This example shows how to create a ViewModel and a View within the MVVM pattern and WPF, and how to bind the two together, so that each is updated whenever the other is changed.
Section 46.1: Binding a String in the ViewModel to a TextBox in the View
SampleViewModel.vb


Option Strict OnA DependencyProperty can be easily added by using the wpfdp code snippet (type wpfdp, then press the TAB key twice), however, the code snippet is not type safe, and will not compile under .
SampleWindow.xaml

SampleWindow.xaml.vb

Note that this is a very rudimentary way to implement MVVM and databinding. A more robust practice would be to use a platform like Unity to "inject" the ViewModel into the View.
Chapter 47: WinForms SpellCheckBox
Example on how to add a spell check box to a WindowsForms application. This example DOES NOT require Word to be installed nor does it use Word in any way.
It uses WPF Interop using the ElementHost control to create a WPF UserControl from a WPF TextBox. WPF TextBox has a built in function for spell check. We are going to leverage this built in function rather than relying on an external program.
Section 47.1: ElementHost WPF TextBox
This example is was modeled after an example that I found on the internet. I can't find the link or I would give the author credit. I took the sample that I found and modified it to work for my application.
1. Add the following references:
System.Xaml, PresentationCore, PresentationFramework, WindowsBase, and WindowsFormsIntegration
2. Create a new Class and past this code


3. Rebuild the solution.
4. Add a new form.
5. Search the toolbox for your Class name. This example is "SpellCheck". It should be listed under 'YourSoulutionName' Components.
6. Drag the new control to your form
7. Set any of the mapped properties in the forms load event

7. The last thing that you need to do is to change the DPI Awareness of your application. This is because you are using WinForms application. By default all WinForms applications are DPI UNAWARE. Once you execute a control that has an element host (WPF Interop), the application will now become DPI AWARE. This may or may not mess with your UI Elements. The solution to this is to FORCE the application to become DPI
UNAWARE. There are 2 ways to do this. The first is through the manifest file and the second is to hard code it in to your program. If you are using OneClick to deploy your application, you must hard code it, not use the manifest file or errors will be inevitable.
Both of the following examples can be found at the following: WinForms Scaling at Large DPI Settings - Is It Even Possible? Thanks to Telerik.com for the great explanation on DPI.
Hard coded DPI Aware code example. This MUST be executed before the first form is initialized. I always place this in the ApplicationEvents.vb file. You can get to this file by right clicking on your project name in the solution explorer and choosing "Open". Then choose the application tab on the left and then click on "View Application Events" on the lower right next to the splash screen drop down.

Manifest Example
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemasmicrosoft-com:asm.v3" >
   <asmv3:application>
        <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
             <dpiAware>true</dpiAware>
        </asmv3:windowsSettings>
   </asmv3:application>
</assembly>
Chapter 48: Debugging your application
Whenever you have a problem in your code, it is always a good idea to know what is going on inside. The class System.Diagnostics.Debug in .Net Framework will help you a lot in this task.
The first advantage of the Debug class is that it produces code only if you build your application in Debug mode. When you build your application in Release mode, no code will be generated from the Debug calls.
Section 48.1: Debug in the console

will produce:

Section 48.2: Indenting your debug output

will produce:

Section 48.3: Debug in a text file
At the beginning of your application, your must add a TextWriterTraceListener to the Listeners list of the Debug class.

All the Debug code produced will be outputed in the Visual Studio console AND in the text file you chose.
If the file is always the same:
Debug.Listeners.Add(New TextWriterTraceListener("Debug.txt"))
The output will be appended to the file every time AND a new file starting with a GUID then your filename will be generated.
Chapter 49: Functions
The function is just like sub. But function returns a value. A function can accept single or multiple parameters.
Section 49.1: Defining a Function
It's really easy to define the functions.
Function GetAreaOfARectangle(ByVal Edge1 As Integer, ByVal Edge2 As Integer) As Integer
    Return Edge1 * Edge2
End Function
Dim Area As Integer = GetAreaOfARectangle(5, 8)
Console.Writeline(Area) 'Output: 40
Section 49.2: Defining a Function #2
Function Age(ByVal YourAge As Integer) As String      Select Case YourAge         Case Is < 18
            Return("You are younger than 18! You are teen!")
        Case 18 to 64
            Return("You are older than 18 but younger than 65! You are adult!")
        Case Is >= 65
            Return("You are older than 65! You are old!")                
    End Select End Function
Console.WriteLine(Age(48)) 'Output: You are older than 18 but younger than 65! You are adult!
Chapter 50: Using axWindowsMediaPlayer in VB.Net
axWindowsMediaPlayer is the control for the playing multimedia files like videos and music.
Section 50.1: Adding the axWindowsMediaPlayer
Right-click on the Toolbox, then click "Choose Items".
Select the COM Components tab, and then check Windows Media Player. axWindowsMediaPlayer will be added to Toolbox.
Select this checkbox to use axWindowsMediaPlayer

Then you can use axWindowsMediaPlayer :)

Section 50.2: Play a Multimedia File
AxWindowsMediaPlayer1.URL = "C:\My Files\Movies\Avatar.mp4"
AxWindowsMediaPlayer1.Ctlcontrols.play()
This code will play Avatar in the axWindowsMediaPlayer.
Chapter 51: Random
The Random class is used to generate non-negative pseudo-random integers that are not truly random, but are for general purposes close enough.
The sequence is calculated using an initial number (called the Seed) In earlier versions of .net, this seed number was the same every time an application was run. So what would happen was that you would get the same sequence of pseudo-random numbers every time the application was executed. Now, the seed is based on the time the object is declared.
Section 51.1: Declaring an instance

This declares an instance of the Random class called rng. In this case, the current time at the point where the object is created is used to calculate the seed. This is the most common usage, but has its own problems as we shall see later in the remarks
Instead of allowing the program to use the current time as part of the calculation for the initial seed number, you can specify the initial seed number. This can be any 32 bit integer literal, constant or variable. See below for examples. Doing this means that your instance will generate the same sequence of pseudo-random numbers, which can be useful in certain situations.

or

where x has been declared elsewhere in your program as an Integer constant or variable.
Section 51.2: Generate a random number from an instance of Random
NextThe following example declares a new instance of the Random class and then uses the method . to generate the next number in the sequence of pseudo-random numbers.

The last line above will generate the next pseudo-random number and assign it to x. This number will be in the range of 0 - 2147483647. However, you can also specify the range of numbers to be generated as in the example below.

Please note however, that using these parameters, range of numbers will be between 15 or above and 199 or below.
NextDoubleYou can also generate floating point numbers of the type Double by using . e.g

You cannot however specify a range for this. It will always be in the range of 0.0 to less than 1.0.
Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
Adam ZuckermanChapters 26 and 30Alessandro MascoloChapter 24Alex B.Chapter 33Allen BinuyaChapter 43Andrew MortonChapter 23AxarydaxChapter 6Bart JollingChapter 12Berken UsarChapters 49 and 50BjørnChapters 4 and 17BlackwoodChapter 4BunkerMentalityChapter 3Carlos BorauChapter 35Cary BondocChapters 1, 17 and 31Chetan SanghaniChapter 43CiccioRoccaChapters 7, 8 and 12Cody GrayChapters 18 and 29Dan DrewsChapter 14Darren DaviesChapters 18 and 19DavidChapter 27David WilsonChapter Chapter 52debaterChapter 7djvChapters 8 and 28DmanChapters 20 and 34Drarig29Chapter 3DrDonutChapters 10 and 20ElektroStudiosChapter 8FütemireChapters 4, 5, 18 and 20glaubergftChapter 18Happypig375Chapters 26 and 32HarjotChapter 1Imran Ali KhanChapter 7InteXXChapter 5JDCChapters 27 and 39Jonas_HessChapter 37Jones JosephChapter 36KendraChapter 12keronconkChapter 18kodkodChapter 8LogicalFlapsChapters 18 and 33lucamauriChapter 2Luke SheppardChapters 11, 20 and 26MarkChapter 7Mark HurdChapters 3 and 22Martin SolesChapter 2Martin VerjansChapters 1, 22 and 48MattChapter 6Matt WilkoChapters 4, 5, 11, 16, 21 and 23MatVADChapters 3, 7, 15, 17, 18, 26, 29, 38 and 40Mike RobertsonChapter 15
Milliron XChapter 46MisazChapters 11, 14, 16, 25, 29 and 30Nadeem_MKChapter 4NathanChapter 47Nathan TuggyChapter 43Nico AgustaChapters 1, 15, 22 and 26NitramChapter 4Proger_CbskChapters 10 and 42Robert ColumbiaChapters 3, 17, 43 and 44RoyalPotatoChapter 17Ryan ThomasChapter 3Sam AxeChapters 2, 3, 5, 16, 17 and 23sansknwoledgeChapter 32Scott MitchellChapter 7SeandkChapter 20SehnsuchtChapters 3, 10, 14, 18, 22, 24 and 30Shayan ToqraeeChapter 36Shog9Chapter 8SilverShotBeeChapters 7 and 28StardustGogetaChapters 1 and 2Stefano d'AntonioChapters 4, 5, 9 and 13Steven DoggartChapters 3 and 8TuxCopterChapter 3TyCobbChapter 7varocarbasChapter 17vbnet3dChapters 2, 3, 7, 11, 23, 28 and 29VishalChapter 26Visual VincentChapter 9voidChapters 6, 7, 8, 10 and 17VortixDevChapters 2 and 3VV5198722Chapter 45wbadryChapter 41Zev SpitzChapter 14zyabin101Chapter 3
You may also like







Complete Visual Basic(r) .NET Tips & Secrets for Professionals	1

Complete Visual Basic(r) .NET Tips & Secrets for Professionals	1

Complete Visual Basic(r) .NET Tips & Secrets for Professionals	1







