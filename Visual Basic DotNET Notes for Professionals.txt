

Contents
About	1
Chapter 1: Getting started with Visual Basic .NET Language	2
Section 1.1: Hello World	2
Section 1.2: Hello World on a Textbox upon Clicking of a Button	2
Section 1.3: Region	3
Section 1.4: Creating a simple Calculator to get familiar with the interface and code	4
Chapter 2: Declaring variables	8
Section 2.1: Declaring and assigning a variable using a primitive type	8
Section 2.2: Levels of declaration - Local and Member variables	10
Section 2.3: Example of Access Modifiers	11
Chapter 3: Introduction to Syntax	14
Section 3.1: Intellisense Helper	14
Section 3.2: Declaring a Variable	14
Section 3.3: Comments	15
Section 3.4: Modifiers	15
Section 3.5: Object Initializers	16
Section 3.6: Collection Initializer	17
Section 3.7: Writing a function	19
Chapter 4: Operators	21
Section 4.1: String Concatenation	21
Section 4.2: Math	21
Section 4.3: Assignment	22
Section 4.4: Comparison	23
Section 4.5: Bitwise	23
Chapter 5: Conditions	25
Section 5.1: If operator	25
Section 5.2: IF...Then...Else	25
Chapter 6: Short-Circuiting Operators (AndAlso - OrElse)	27
Section 6.1: OrElse Usage	27
Section 6.2: AndAlso Usage	27
Section 6.3: Avoiding NullReferenceException	27
Chapter 7: Date	30
Section 7.1: Converting (Parsing) a String to a Date	30
Section 7.2: Converting a Date To A String	30
Chapter 8: Array	31
Section 8.1: Array definition	31
Section 8.2: Null Array Variables	31
Section 8.3: Array initialization	32
Section 8.4: Declare a single-dimension array and set array element values	32
Section 8.5: Jagged Array Initialization	32
Section 8.6: Non-zero lower bounds	32
Section 8.7: Referencing Same Array from Two Variables	33
Section 8.8: Multidimensional Array initialization	33
Chapter 9: Lists	34
Section 9.1: Add items to a List	34
Section 9.2: Check if item exists in a List	34
Section 9.3: Loop through items in list	34
Section 9.4: Create a List	35
Section 9.5: Remove items from a List	36
Section 9.6: Retrieve items from a List	36
Chapter 10: Enum	38
Section 10.1: GetNames()	38
Section 10.2: HasFlag()	38
Section 10.3: Enum definition	39
Section 10.4: Member initialization	39
Section 10.5: The Flags attribute	39
Section 10.6: GetValues()	40
Section 10.7: String parsing	40
Section 10.8: ToString()	41
Section 10.9: Determine whether a Enum has FlagsAttribute specified or not	41
Section 10.10: For-each flag (flag iteration)	42
Section 10.11: Determine the amount of flags in a flag combination	42
Section 10.12: Find the nearest value in a Enum	43
Chapter 11: Dictionaries	45
Section 11.1: Create a dictionary filled with values	45
Section 11.2: Loop through a dictionary and print all entries	45
Section 11.3: Checking for key already in dictionary - data reduction	45
Section 11.4: Getting a dictionary value	46
Chapter 12: Looping	47
Section 12.1: For...Next	47
Section 12.2: For Each...Next loop for looping through collection of items	48
Section 12.3: Short Circuiting	48
Section 12.4: While loop to iterate while some condition is true	50
Section 12.5: Nested Loop	50
Section 12.6: Do...Loop	51
Chapter 13: File Handling	53
Section 13.1: Write Data to a File	53
Section 13.2: Read All Contents of a File	53
Section 13.3: Write Lines Individually to a Text File using StreamWriter	53
Chapter 14: File/Folder Compression	54
Section 14.1: Adding File Compression to your project	54
Section 14.2: Creating zip archive from directory	54
Section 14.3: Extracting zip archive to directory	54
Section 14.4: Create zip archive dynamicaly	54
Chapter 15: Connection Handling	55
Section 15.1: Public connection property	55
Chapter 16: Data Access	56
Section 16.1: Read field from Database	56
Section 16.2: Simple Function to read from Database and return as DataTable	57
Chapter 17: Type conversion	58
Section 17.1: Converting Text of The Textbox to an Integer	58
Chapter 18: ByVal and ByRef keywords	59
Section 18.1: ByRef keyword	59
Section 18.2: ByVal keyword	59
Chapter 19: Console	61
Section 19.1: Console.ReadLine()	61
Section 19.2: Console.Read()	61
Section 19.3: Console.ReadKey()	61
Section 19.4: Prototype of command line prompt	61
Section 19.5: Console.WriteLine()	62
Chapter 20: Functions	63
Section 20.1: Defining a Function	63
Section 20.2: Defining a Function #2	63
Chapter 21: Recursion	64
Section 21.1: Compute nth Fibonacci number	64
Chapter 22: Random	65
Section 22.1: Declaring an instance	65
Section 22.2: Generate a random number from an instance of Random	65
Chapter 23: Classes	67
Section 23.1: Abstract Classes	67
Section 23.2: Creating classes	67
Chapter 24: Generics	69
Section 24.1: Create a generic class	69
Section 24.2: Instance of a Generic Class	69
Section 24.3: Define a 'generic' class	69
Section 24.4: Use a generic class	69
Section 24.5: Limit the possible types given	70
Section 24.6: Create a new instance of the given type	70
Chapter 25: Disposable objects	71
Section 25.1: Basic concept of IDisposable	71
Section 25.2: Declaring more objects in one Using	71
Chapter 26: NullReferenceException	73
Section 26.1: Empty Return	73
Section 26.2: Uninitialized variable	73
Chapter 27: Using Statement	74
Section 27.1: See examples under Disposable objects	74
Chapter 28: Option Strict	75
Section 28.1: Why Use It?	75
Section 28.2: How to Switch It On	75
Chapter 29: Option Explicit	77
Section 29.1: What is it?	77
Section 29.2: How to switch it on?	77
Chapter 30: Option Infer	78
Section 30.1: How to enable/disable it	78
Section 30.2: What is it?	78
Section 30.3: When to use type inference	79
Chapter 31: Error Handling	81
Section 31.1: Try...Catch...Finally Statement	81
Section 31.2: Creating custom exception and throwing	81
Section 31.3: Try Catch in Database Operation	82
Section 31.4: The Un-catchable Exception	82
Section 31.5: Critical Exceptions	82
Chapter 32: OOP Keywords	84
Section 32.1: Defining a class	84
Section 32.2: Inheritance Modifiers (on classes)	84
Section 32.3: Inheritance Modifiers (on properties and methods)	85
Section 32.4: MyBase	86
Section 32.5: Me vs MyClass	87
Section 32.6: Overloading	88
Section 32.7: Shadows	88
Section 32.8: Interfaces	90
Chapter 33: Extension methods	91
Section 33.1: Creating an extension method	91
Section 33.2: Making the language more functional with extension methods	91
Section 33.3: Getting Assembly Version From Strong Name	91
Section 33.4: Padding Numerics	92
Chapter 34: Reflection	94
Section 34.1: Retrieve Properties for an Instance of a Class	94
Section 34.2: Get a method and invoke it	94
Section 34.3: Create an instance of a generic type	94
Section 34.4: Get the members of a type	94
Chapter 35: Visual Basic 14.0 Features	96
Section 35.1: Null conditional operator	96
Section 35.2: String interpolation	96
Section 35.3: Read-Only Auto-Properties	97
Section 35.4: NameOf operator	97
Section 35.5: Multiline string literals	98
Section 35.6: Partial Modules and Interfaces	98
Section 35.7: Comments after implicit line continuation	99
Section 35.8: #Region directive improvements	99
Chapter 36: LINQ	101
Section 36.1: Selecting from array with simple condition	101
Section 36.2: Mapping array by Select clause	101
Section 36.3: Ordering output	101
Section 36.4: Generating Dictionary From IEnumerable	101
Section 36.5: Projection	102
Section 36.6: Getting distinct values (using the Distinct method)	102
Chapter 37: FTP server	103
Section 37.1: Download file from FTP server	103
Section 37.2: Download file from FTP server when login required	103
Section 37.3: Upload file to FTP server	103
Section 37.4: Upload file to FTP server when login required	103
Chapter 38: Working with Windows Forms	104
Section 38.1: Using the default Form instance	104
Section 38.2: Passing Data From One Form To Another	104
Chapter 39: Google Maps in a Windows Form	106
Section 39.1: How to use a Google Map in a Windows Form	106
Chapter 40: GDI+	115
Section 40.1: Draw Shapes	115
Section 40.2: Fill Shapes	115
Section 40.3: Text	116
Section 40.4: Create Graphic Object	116
Chapter 41: WinForms SpellCheckBox	118
Section 41.1: ElementHost WPF TextBox	118
Chapter 42: Using axWindowsMediaPlayer in VB.Net	122
Section 42.1: Adding the axWindowsMediaPlayer	122
Section 42.2: Play a Multimedia File	123
Chapter 43: WPF XAML Data Binding	124
Section 43.1: Binding a String in the ViewModel to a TextBox in the View	124
Chapter 44: Reading compressed textfile on-the-fly	126
Section 44.1: Reading .gz textfile line after line	126
Chapter 45: Threading	127
Section 45.1: Performing thread-safe calls using Control.Invoke()	127
Section 45.2: Performing thread-safe calls using Async/Await	127
Chapter 46: Multithreading	129
Section 46.1: Multithreading using Thread Class	129
Chapter 47: BackgroundWorker	131
Section 47.1: Using BackgroundWorker	131
Section 47.2: Accessing GUI components in BackgroundWorker	132
Chapter 48: Using BackgroundWorker	133
Section 48.1: Basic implementation of Background worker class	133
Chapter 49: Task-based asynchronous pattern	134
Section 49.1: Basic usage of Async/Await	134
Section 49.2: Using TAP with LINQ	134
Chapter 50: Debugging your application	135
Section 50.1: Debug in the console	135
Section 50.2: Indenting your debug output	135
Section 50.3: Debug in a text file	136
Chapter 51: Unit Testing in VB.NET	137
Section 51.1: Unit Testing for Tax Calculation	137
Section 51.2: Testing Employee Class assigned and derived Properties	138
Credits	141
You may also like	143


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/VisualBasic_NETBook
This Visual Basic(r) .NET Notes for Professionals book is compiled from Stack
Overflow Documentation, the content is written by the beautiful people at Stack
Overflow. Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Visual Basic(r) .NET group(s) or company(s) nor Stack
Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Visual Basic .NET Language
VB.NET Version Visual Studio Version .NET Framework Version Release Date
7.020021.02002-02-137.120031.12003-04-248.020052.0 / 3.02005-10-189.020083.52007-11-1910.020104.02010-04-1211.020124.52012-08-1512.020134.5.1 / 4.5.22013-10-1714.020154.6.0 ~ 4.6.22015-07-2015.020174.72017-03-07Section 1.1: Hello World
First, install a version of Microsoft Visual Studio, including the free Community edition. Then, create a Visual Basic Console Application project of type Console Application, and the following code will print the string 'Hello World' to the Console:

Then, save and press  F5  on the keyboard (or go to the Debug menu, then click Run without Debug or Run) to compile and run the program. 'Hello World' should appear in the console window.

Section 1.2: Hello World on a Textbox upon Clicking of a Button
Drag 1 textbox and 1 button

Button1_Click eventDouble click the button1 and you will be transferred to the 

TextType the name of the object that you want to target, in our case it is the textbox1. . is the property that we want to use if we want to put a text on it.
Property Textbox.Text, gets or sets the current text in the TextBox. Now, we have Textbox1.TextTextbox1.TextWe need to set the value of that  so we will use the = sign. The value that we want to put in the
TextTextTextbox1Textbox1. is Hello World. Overall, this is the total code for putting a value of Hello World to the .


Section 1.3: Region
For the sake of readability, which will be useful for beginners when reading VB code as well for full time developers to maintain the code, we can use "Region" to set a region of the same set of events, functions, or variables:

This region block could be collapsed to gain some visual help when the code row goes to 1000+. It is also save your scroll efforts.

Tested on VS 2005, 2008 2010, 2015 and 2017.
Section 1.4: Creating a simple Calculator to get familiar with the interface and code
1. Once you have installed Visual Studio from https://www.visualstudio.com/downloads/, start a new project.
2. 
3. Select 'Windows Forms Application' from Visual Basic Tab. You can rename it here if you need to.
4. Once you click 'OK', you will see this window:

5. Click on the 'Toolbox' tab on the left. The toolbar has 'auto-hide' option enabled by default. To disable this option, click the small symbol between the 'down arrow' symbol and the 'x' symbol, on the top-right corner of Toolbox window.
6. Get yourself familiar with the tools provided in the box. I have made a calculator interface by using buttons and a Textbox.

7. Click on the Properties tab (It is on the right side of the editor). You can change the Text property of a button, and the textbox to rename them. Font property can be used to alter the font of the controls.
8. To write the specific action for an event(eg. clicking on a button), double click on the control. Code window will open.

9. VB.Net is a powerful language designed for fast development. High encapsulation and abstraction is cost for it. You do not need to add semicolon to indicate the end of a statement, there are no brackets, and most of the time, it auto-corrects the case of the alphabets.
10. Code provided in the picture should be simple to understand. Dim is the keyword used to initialize a variable, and new allocates memory. Anything you type in the textbox is of type string by default. Casting is required to use the value as a different type.
Enjoy your first creation in VB.Net!
Chapter 2: Declaring variables
Section 2.1: Declaring and assigning a variable using a primitive type
Variables in Visual Basic are declared using the Dim keyword. For example, this declares a new variable called counter with the data type Integer:

A variable declaration can also include an access modifier, such as Public, Protected, Friend, or Private. This works in conjunction with the variable's scope to determine its accessibility.
Access Modifier	Meaning
Public	All types which can access the enclosing type
Protected	Only the enclosing class and those that inherit from it
Friend	All types in the same assembly that can access the enclosing type
The enclosing class and its inheritors, or the types in the same assembly that can access the
Protected Friend
enclosing class
Private	Only the enclosing type
Static	Only on local variables and only initializes once.
As a shorthand, the Dim keyword can be replaced with the access modifier in the variable's declaration:

The supported data types are outlined in the table below:
	Type	Alias	Memory allocation	Example
Dim example As SByte = 10SByte	N/A	1 byte
Dim example As Short = 10Int16	Short	2 bytes
Dim example As Integer = 10Int32	Integer	4 bytes
Dim example As Long = 10Int64	Long	8 bytes
Dim example As Single = 10.95Single	N/A	4 bytes
Dim example As Double = 10.95Double	N/A	8 bytes
Dim example As Decimal = 10.95Decimal	N/A	16 bytes
Dim example As Boolean = TrueBoolean	N/A	Dictated by implementing platform
Dim example As Char = "A"Char	N/A	2 BytesC
Dim example As String = "Stack Overflow"String	N/A	source
Dim example As Date = Date.NowDateTime Date	8 Bytes
Dim example As Byte = 10Byte	N/A	1 byte
Dim example As UShort = 10UInt16	UShort	2 bytes
Dim example As UInteger = 10UInt32	UInteger 4 bytes
Dim example As ULong = 10UInt64	ULong	8 bytes
Dim example As Object = Nothing4 bytes 32 bit architecture, 8 bytes 64 bit
Object	N/A architecture
There also exist data identifier and literal type characters usable in replacement for the textual type and or to force literal type:
Type (or Alias) Identifier type character	Literal type character
example = 10SShort	N/A
Dim exampleexample = 10% or example = 10IInteger%
Dim exampleexample = 10& or example = 10LLong&
Dim exampleexample = 10! or example = 10FSingle!
example = 10# or example = 10RDouble	Dim example#
example = 10@ or example = 10DDecimal	Dim example@
example = "A"Char	N/AC
String	Dim example$	N/A
example = 10USUShort	N/A
example = 10UIUInteger	N/A
example = 10ULULong	N/A
The integral suffixes are also usable with hexadecimal (&H) or octal (&O) prefixes:
example O77H8000S or example = &= &&
Date(Time) objects can also be defined using literal syntax:
Dim example As Date = #7/26/2016 12:8 PM#Once a variable is declared it will exist within the Scope of the containing type, Sub or Function declared, as an example:

End FunctionThe counter variable will only exist until the  and then will be out of scope. If this counter variable is needed outside of the function you will have to define it at class/structure or module level.

Alternatively, you can use the Static (not to be confused with Shared) modifier to allow a local variable to retain it's value between calls of its enclosing method:

Section 2.2: Levels of declaration - Local and Member variables
ExampleFunctionLocal variables - Those declared within a procedure (subroutine or function) of a class (or other structure). In this example, exampleLocalVariable is a local variable declared within ():

The Static keyword allows a local variable to be retained and keep its value after termination (where usually, local variables cease to exist when the containing procedure terminates).
ExampleSub() from MainIn this example, the console is 024. On each call to () the static variable retains the value it had at the end of the previous call:

Member variables - Declared outside of any procedure, at the class (or other structure) level. They may be instance variables, in which each instance of the containing class has its own distinct copy of that variable, or Shared variables, which exist as a single variable associated with the class itself, independent of any instance.
Here, ExampleClass2 contains two member variables. Each instance of the ExampleClass2 has an individual ExampleInstanceVariable which can be accessed via the class reference. The shared variable ExampleSharedVariable however is accessed using the class name:


Section 2.3: Example of Access Modifiers
In the following example consider you have a solution hosting two projects: ConsoleApplication1 and
SampleClassLibrary. The first project will have the classes SampleClass1 and SampleClass2. The second one will have SampleClass3 and SampleClass4. In other words we have two assemblies with two classes each. ConsoleApplication1 has a reference to SampleClassLibrary.
See how SampleClass1.MethodA interacts with other classes and methods.
SampleClass1.vb:
Imports SampleClassLibrary
Public Class SampleClass1
    Public Sub MethodA()
        'MethodA can call any of the following methods because         'they all are in the same scope.
        MethodB()
        MethodC()
        MethodD()
        MethodE()
        'Sample2 is defined as friend. It is accessible within
        'the type itself and all namespaces and code within the same assembly.         Dim class2 As New SampleClass2()         class2.MethodA()
        'class2.MethodB() 'SampleClass2.MethodB is not accessible because
                          'this method is private. SampleClass2.MethodB
                          'can only be called from SampleClass2.MethodA,
                          'SampleClass2.MethodC, SampleClass2.MethodD
                          'and SampleClass2.MethodE         class2.MethodC()
        'class2.MethodD() 'SampleClass2.MethodD is not accessible because
                          'this method is protected. SampleClass2.MethodD
                          'can only be called from any class that inherits
                          'SampleClass2, SampleClass2.MethodA, SampleClass2.MethodC,
                          'SampleClass2.MethodD and SampleClass2.MethodE         class2.MethodE()
        Dim class3 As New SampleClass3() 'SampleClass3 resides in other
                                         'assembly and is defined as public.
                                         'It is accessible anywhere.         class3.MethodA()
        'class3.MethodB() 'SampleClass3.MethodB is not accessible because
                          'this method is private. SampleClass3.MethodB can
                          'only be called from SampleClass3.MethodA,
                          'SampleClass3.MethodC, SampleClass3.MethodD
                          'and SampleClass3.MethodE

SampleClass2.vb:

SampleClass3.vb:


SampleClass4.vb:

Chapter 3: Introduction to Syntax
Section 3.1: Intellisense Helper
One interesting thing is the ability to add you own comments into Visual Studio Intellisense. So you can make your own written functions and classes self-explanatory. To do so, you must type the comment symbol three times the line above your function.
Once done, Visual Studio will automatically add an XML documentation :

After that, if you type in your Test function somewhere in your code, this little help will show up :

Section 3.2: Declaring a Variable
In VB.NET, every variable must be declared before it is used (If Option Explicit is set to On). There are two ways of declaring variables:
Inside a Function or a Sub:
Dim w 'Declares a variable named w of type Object (invalid if Option Strict is On)
Dim x As String 'Declares a variable named x of type String
Dim y As Long = 45 'Declares a variable named y of type Long and assigns it the value 45
Dim z = 45 'Declares a variable named z whose type is inferred
           'from the type of the assigned value (Integer here) (if Option Infer is On)
           'otherwise the type is Object (invalid if Option Strict is On)
           'and assigns that value (45) to it
Option ExplicitSee this answer for full details about , Strict and Infer.
 Inside a Class or a Module:
These variables (also called fields in this context) will be accessible for each instance of the Class they are declared in. They might be accessible from outside the declared Class depending on the modifier (Public, Private,
Protected FriendProtected,  or Friend)
Private x 'Declares a private field named x of type Object (invalid if Option Strict is On)
Public y As String 'Declares a public field named y of type String
Friend z As Integer = 45 'Declares a friend field named z of type Integer and assigns it the value 45
These fields can also be declared with Dim but the meaning changes depending on the enclosing type:

Section 3.3: Comments
The first interesting thing to know is how to write comments.
In VB .NET, you write a comment by writing an apostrophe ' or writing REM. This means the rest of the line will not be taken into account by the compiler.

Section 3.4: Modifiers
Modifiers are a way to indicate how external objects can access an object's data.
 Public
Means any object can access this without restriction
 Private
Means only the declaring object can access and view this
 Protected
Means only the declaring object and any object that inherits from it can access and view this.
 Friend
Means only the delcaring object, any object that inherits from it and any object in the same namespace can access and view this.

Section 3.5: Object Initializers


Although similar anonymousInstance doesn't have same type as someInstance
Member name must be unique in the anonymous type, and can be taken from a variable or another object member name

Each member can be preceded by the Key keyword. Those members will be ReadOnly properties, those without will be read/write properties

Two anonymous instance defined with the same members (name, type, presence of Key and order) will have the same anonymous type.

Anonymous types are structurally equatable. Two instance of the same anonymous types having at least one Key property with the same Key values will be equal. You have to use Equals method to test it, using = won't compile and Is will compare the object reference.
  Dim anon1 = New With { Key .Name = "Foo", Key .Age = 10, .Salary = 0 }
  Dim anon2 = New With { Key .Name = "Bar", Key .Age = 20, .Salary = 0 }   Dim anon3 = New With { Key .Name = "Foo", Key .Age = 10, .Salary = 10000 }
  anon1.Equals(anon2) ' False
  anon1.Equals(anon3) ' True although non-Key Salary isn't the same
Both Named and Anonymous types initializer can be nested and mixed

Section 3.6: Collection Initializer

Is equivalent to

Items can be the result of a constructor, a method call, a property access. It can also be mixed with Object initializer.


It is not possible to use Object initializer syntax AND collection initializer syntax for the same object at the same time. For example, these won't work

We can also allow collection initializer syntax by providing for a custom type.
It must implement IEnumerable and have an accessible and compatible by overload rules Add method (instance, Shared or even extension method)
Contrived example :


List(Of PersonIf we wanted to add Person object to a ) by just putting the name in the collection initializer (but we can't modify the List(Of Person) class) we can use an Extension method

Section 3.7: Writing a function
A function is a block of code that will be called several times during the execution. Instead of writing the same piece of code again and again, one can write this code inside a function and call that function whenever it is needed.
A function :


is just the same as



Chapter 4: Operators
Section 4.1: String Concatenation
String concatenation is when you combine two or more strings into a single string variable.
String concatenation is performed with the  &  symbol.

Non-string values will be converted to string when using  & .

Always use  &  (ampersand) to perform string concatenation.
DON'T DO THIS
While it is possible, in the simplest of cases, to use the  +  symbol to do string concatenation, you should never do this. If one side of the plus symbol is not a string, when Option strict is off, the behavior becomes non-intuitive, when Option strict is on it will produce a compiler error. Consider:
Dim value = "2" + 10    ' result = 12  (data type Double)
Dim value = "2" + "10"  ' result = "210"  (data type String) Dim value = "2g" + 10   ' runtime error
The problem here is that if the + operator sees any operand that is a numeric type, it will presume that the programmer wanted to perform an arithmetic operation and attempt to cast the other operand to the equivalent numeric type. In cases where the other operand is a string that contains a number (for example, "10"), the string is converted to a number and then arithmetically added to the other operand. If the other operand cannot be converted to a number (for example, "2g"), the operation will crash due to a data conversion error. The + operator will only perform string concatenation if both operands are of String type.
The & operator, however, is designed for string concatenation and will cast non-string types to strings.
Section 4.2: Math
If you have the following variables

Addition Performed by the plus sign  + .

Subtraction Performed by the minus sign  - .


Multiplication Performed by the star symbol  * .

Division Performed by the forward slash symbol  / .

Integer Division Performed by the backslash symbol  \ .

Modulus Performed by the  Mod  keyword.

Raise to a Power of Performed by the  ^  symbol.

Section 4.3: Assignment
There is a single assignment operator in VB.
 The equal sign  =  is used both for equality comparison and assignment.
Dim value = 5
Notes
Watch out for assignment vs. equality comparison.

In this example you can see the equal sign being used as both a comparison operator and an assignment operator, unlike other languages. In this case, result will be of type Boolean and will contain the value of the equality comparison between leftValue and rightValue.
Related: Using Option Strict On to declare variables properly
Section 4.4: Comparison
Comparison operators compare two values and return to you a boolean (True or False) as the result.
Equality
 The equal sign  =  is used both for equality comparison and assignment.
If leftValue = rightValue Then ...
Inequality
 The left angle bracket nest to the right angle bracket  <>  performs an unequal comparison.
If leftValue <> rightValue Then ...
Greater Than
 The left angle bracket  <  performs a greater than comparison.
If leftValue < rightValue Then ...
Greater Than Or Equal
 The equal sign nest to the left angle bracket  =>  performs a greater than or equals comparison.
If leftValue =< rightValue Then ...
Less Than
 The right angle bracket  >  performs a less than comparison.
If leftValue > rightValue Then ...
Less Than Or Equal
 The equal sign nest to the right angle bracket  =>  performs a greater than or equals comparison.
If leftValue => rightValue Then ...
Like
The  Like  operator tests the equality of a string and a search pattern. The  Like  operator relies on the Option Compare Statement The following table lists the available patterns. Source:
https://msdn.microsoft.com/en-us/library/swf8kaxw.aspx (Remarks section)
Characters in the Pattern	Matches in the String
?Any single character*Zero or more characters#Any single digit (0 - 9)[charlist]Any single character in charlist[!charlist]Any single character not in charlist See further info on MSDN in the remarks section.
If string Like pattern Then ...
Section 4.5: Bitwise
These are the bitwise operators in VB.NET : And, Or, Xor, Not
Example of And bitwise operation

The value of a will be 1. The result is obtained after comparing 3 and 5 in binary for. 3 in binary form is 011 and 5 in binary form is 101. The And operator places 1 if both bits are 1. If any of the bits are 0 then the value will be 0

So the binary result is 001 and when that is converted to decimal, the answer will be 1.
Or operator places 1 if both or one bit is 1

Xor operator places 1 if only one of the bit is 1 (not both)

Not operator reverts the bits including sign

Chapter 5: Conditions
Section 5.1: If operator
Version ≥ 9.0

We can use the If operator instead of If...Then...Else..End If statement blocks.
Consider the following example:

is the same as

Ifcondition?a:b() uses short-circuit evaluation, which means that it will only evaluate the arguments it uses. If the condition is false (or a Nullable that is Nothing), the first alternative will not be evaluated at all, and none of its side effects will be observed. This is effectively the same as C#'s ternary operator in the form of .
This is especially useful in avoiding exceptions:

IfWe all know that dividing by zero will throw an exception, but () here guards against this by short-circuiting to only the expression that the condition has already ensured is valid.
Another example:
Dim varDate as DateTime = If(varString <> "N/A", Convert.ToDateTime(varString), Now.Date)
varString <> "N/A" evaluates to False, it will assign varDate's value as Now.DateIf  without evaluating the first expression.
Version < 9.0
If() operator and have to make do with the IIfOlder versions of VB do not have the () built-in function. As it's a
If..Thenfunction, not an operator, it does not short-circuit; all expressions are evaluated, with all possible side-effects, including performance penalties, changing state, and throwing exceptions. (Both of the above examples that avoid exceptions would throw if converted to IIf.) If any of these side effects present a problem, there's no way to use an inline conditional; instead, rely on  blocks as usual.
Section 5.2: IF...Then...Else



Chapter 6: Short-Circuiting Operators (AndAlso - OrElse)
Parameter	Details
            Required. Any Boolean expression. The result is the Boolean result of comparison of the two result expressions.
expression1 Required. Any Boolean expression. expression2 Required. Any Boolean expression.
Section 6.1: OrElse Usage
' The OrElse operator is the homologous of AndAlso. It lets us perform a boolean
' comparison evaluating the second condition only if the first one is False
If testFunction(5) = True OrElse otherFunction(4) = True Then
    ' If testFunction(5) is True, otherFunction(4) is not called.
    ' Insert code to be executed. End If
Section 6.2: AndAlso Usage

Section 6.3: Avoiding NullReferenceException
Version ≥ 7.0
OrElse

    End If
Version ≥ 7.0
AndAlso

Visual Basic 14.0 introduced the null conditional operator, allowing to rewrite the functions in a cleaner way, mimicking the behavior of the AndAlso version of the example.

Chapter 7: Date
Section 7.1: Converting (Parsing) a String to a Date
DateTime.ParseExactIf you know the format of the string you are converting (parsing) you should use 

DateTime.TryParseExactIf you are not certain for the format of the string, you can use  and test the result to see if parsed or not:

Section 7.2: Converting a Date To A String
.ToStringSimply use the  overload of a DateTime object to get the format you require:
Dim dateValue As DateTime = New DateTime(2001, 03, 06)
Dim dateString As String = dateValue.ToString("yyyy-MM-dd") '2001-03-06
Chapter 8: Array
Section 8.1: Array definition
Dim array(9) As Integer ' Defines an array variable with 10 Integer elements (0-9).
Dim array = New Integer(10) {} ' Defines an array variable with 11 Integer elements (0-10)                                'using New.
Dim array As Integer() = {1, 2, 3, 4} ' Defines an Integer array variable and populate it                                       'using an array literal. Populates the array with                                       '4 elements.
ReDim Preserve array(10) ' Redefines the size of an existing array variable preserving any
                         'existing values in the array. The array will now have 11 Integer                          'elements (0-10).
ReDim array(10) ' Redefines the size of an existing array variable discarding any
                'existing values in the array. The array will now have 11 Integer                 'elements (0-10).
Zero-Based
Dim array(5 To 10All arrays in VB.NET are zero-based. In other words, the index of the first item (the lower bound) in a VB.NET array is always 0. Older versions of VB, such as VB6 and VBA, were one-based by default, but they provided a way to override the default bounds. In those earlier versions of VB, the lower and upper bounds could be explicitly stated (e.g. ). In VB.NET, in order to maintain compatibility with other .NET languages, that flexibility was removed and the lower bound of 0 is now always enforced. However, the To syntax can still be used in VB.NET, which may make the range more explicitly clear. For instance, the following examples are all equivalent to the ones listed above:

Nested Array Declarations

Section 8.2: Null Array Variables
Since arrays are reference types, an array variable can be null. To declare a null array variable, you must declare it without a size:

Or

Is NothingTo check if an array is null, test to see if it :

To set an existing array variable to null, simply set it to Nothing:

Or use Erase, which does the same thing:

Section 8.3: Array initialization
Dim array() As Integer = {2, 0, 1, 6}                   ''Initialize an array of four Integers.
Dim strings() As String = {"this", "is", "an", "array"} ''Initialize an array of four Strings.
Dim floats() As Single = {56.2, 55.633, 1.2, 5.7743, 22.345}
              ''Initialize an array of five Singles, which are the same as floats in C#.
Dim miscellaneous() as Object = { New Object(), "Hello", New List(of String) }
              ''Initialize an array of three references to any reference type objects               ''and point them to objects of three different types.
Section 8.4: Declare a single-dimension array and set array element values

or

Section 8.5: Jagged Array Initialization
Note the parenthesis to distinguish between a jagged array and a multidimensional array SubArrays can be of different length
Dim jaggedArray()() As Integer = { ({1, 2, 3}), ({4, 5, 6}), ({7}) }
' jaggedArray(0) is {1, 2, 3} and so jaggedArray(0)(0) is 1
' jaggedArray(1) is {4, 5, 6} and so jaggedArray(1)(0) is 4
' jaggedArray(2) is {7} and so jaggedArray(2)(0) is 7
Section 8.6: Non-zero lower bounds
Option Strict On(index)With , although the .NET Framework allows the creation of single dimension arrays with non-zero lower bounds they are not "vectors" and so not compatible with VB.NET typed arrays. This means they can only be seen as Array and so cannot use normal array  references.

Option Strict Off, you can get the (indexAs well as by using ) syntax back by treating the array as an IList, but
then it's not an array, so you can't use LBound and UBound on that variable name (and you're still not avoiding boxing):

Multi-dimensional non-zero lower bounded arrays are compatible with VB.NET multi-dimensional typed arrays:

MSDN reference: Array.CreateInstance
Section 8.7: Referencing Same Array from Two Variables
Since arrays are reference types, it is possible to have multiple variables pointing to the same array object.

Section 8.8: Multidimensional Array initialization
Dim array2D(,) As Integer = {{1, 2, 3}, {4, 5, 6}}
' array2D(0, 0) is 1 ; array2D(0, 1) is 2 ; array2D(1, 0) is 4
Dim array3D(,,) As Integer = {{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}}
' array3D(0, 0, 0) is 1 ; array3D(0, 0, 1) is 2
' array3D(0, 1, 0) is 4 ; array3D(1, 0, 0) is 7
Chapter 9: Lists
Section 9.1: Add items to a List

To add more than one item at a time use AddRange. Always adds to the end of the list

In order to add items to the middle of the list use Insert
Insert will place the item at the index, and renumber the remaining items

New Output:

Section 9.2: Check if item exists in a List

Produces the following output:

Section 9.3: Loop through items in list


Produces the following output:

Another option, would be to loop through using the index of each element:

Section 9.4: Create a List
Lists can populated with any data type as necessary, with the format

For example:
Create a new, empty list of Strings

Create a new list of strings, and populate with some data VB.NET 2005/2008:
 Dim aList as New List(Of String)(New String() {"one", "two", "three"}) VB.NET 2010:

--
VB.NET 2015:
Dim aList as New List(Of String)(New String() {"one", "two", "three"})
NOTE:
If you are receiving the following when the code is ran:
		Object reference not set to an instance of an object.
Dim aList as New List(Of StringDim aList as List(Of String New List(Of StringMake sure you either declare as New i.e. ) or if declaring without the New, make sure you set the list to a new list - ) =)
Section 9.5: Remove items from a List

Section 9.6: Retrieve items from a List

		Hello, World
If you do not know the index of the item or only know part of the string then use the Find or FindAll method

		Hello, World
The FindAll method returns a new List (of String)



Chapter 10: Enum
Section 10.1: GetNames()
Returns the names of constants in the specified Enum as a string array:

Output:
Small
Medium
Large
Section 10.2: HasFlag()
HasFlag()The  method can be used to check if a flag is set.


For more information about the Flags-attribute and how it should be used see the official Microsoft documentation.
Section 10.3: Enum definition
An enum is a set of logically related constants.

Section 10.4: Member initialization
Each of the enum members may be initialized with a value. If a value is not specified for a member, by default it's initialized to 0 (if it's the first member in the member list) or to a value greater by 1 than the value of the preceding member.

Section 10.5: The Flags attribute
<FlagsWith the > attribute, the enum becomes a set of flags. This attribute enables assigning multiple values to an enum variable. The members of a flags enum should be initialized with powers of 2 (1, 2, 4, 8...).


Section 10.6: GetValues()
' This method is useful for iterating Enum values '

Prints:
1
2
4
Section 10.7: String parsing
An Enum instance can be created by parsing a string representation of the Enum.


See also: Parse a string to an Enum value in VB.NET
Section 10.8: ToString()
The ToString method on an enum returns the string name of the enumeration. For instance:

If, however, the string representation of the actual integer value of the enum is desired, you can cast the enum to an Integer and then call ToString:

Section 10.9: Determine whether a Enum has FlagsAttribute specified or not
The next example can be used to determine whether a enumeration has the FlagsAttribute specified. The methodology used is based on Reflection.
This example will give a True result:
 Dim enu As [Enum] = New FileAttributes() Dim hasFlags As Boolean = enu.GetType().GetCustomAttributes(GetType(FlagsAttribute), inherit:=False).Any() Console.WriteLine("{0} Enum has FlagsAttribute?: {1}", enu.GetType().Name, hasFlags) This example will give a False result:
Dim enu As [Enum] = New ConsoleColor() Dim hasFlags As Boolean = enu.GetType().GetCustomAttributes(GetType(FlagsAttribute), inherit:=False).Any() Console.WriteLine("{0} Enum has FlagsAttribute?: {1}", enu.GetType().Name, hasFlags)
We can design a generic usage extension method like this one:

Usage Example:

Section 10.10: For-each flag (flag iteration)
In some very specific scenarios we would feel the need to perform a specific action for each flag of the source enumeration.
We can write a simple Generic extension method to realize this task.

Usage Example:

Section 10.11: Determine the amount of flags in a flag combination
The next example is intended to count the amount of flags in the specified flag combination.
The example is provided as a extension method:

Usage Example:
Dim flags As FileAttributes = (FileAttributes.Archive Or FileAttributes.Compressed)
Dim count As Integer = flags.CountFlags()

Section 10.12: Find the nearest value in a Enum
The next code illustrates how to find the nearest value of a Enum.
First we define this Enum that will serve to specify search criteria (search direction)

And now we implement the search algorithm:
<DebuggerStepThrough>
Public Shared Function FindNearestEnumValue(Of T)(ByVal value As Long,
                                                  ByVal direction As EnumFindDirection) As T
    Select Case direction
        Case EnumFindDirection.Nearest
            Return (From enumValue As T In [Enum].GetValues(GetType(T)).Cast(Of T)()
                    Order By Math.Abs(value - Convert.ToInt64(enumValue))
                    ).FirstOrDefault
        Case EnumFindDirection.Less
            If value < Convert.ToInt64([Enum].GetValues(GetType(T)).Cast(Of T).First) Then
                Return [Enum].GetValues(GetType(T)).Cast(Of T).FirstOrDefault
            Else
                Return (From enumValue As T In [Enum].GetValues(GetType(T)).Cast(Of T)()
                        Where Convert.ToInt64(enumValue) < value
                        ).LastOrDefault
            End If
        Case EnumFindDirection.LessOrEqual
            If value < Convert.ToInt64([Enum].GetValues(GetType(T)).Cast(Of T).First) Then
                Return [Enum].GetValues(GetType(T)).Cast(Of T).FirstOrDefault
            Else
                Return (From enumValue As T In [Enum].GetValues(GetType(T)).Cast(Of T)()
                        Where Convert.ToInt64(enumValue) <= value
                        ).LastOrDefault
            End If
        Case EnumFindDirection.Greater
            If value > Convert.ToInt64([Enum].GetValues(GetType(T)).Cast(Of T).Last) Then
                Return [Enum].GetValues(GetType(T)).Cast(Of T).LastOrDefault
            Else
                Return (From enumValue As T In [Enum].GetValues(GetType(T)).Cast(Of T)()
                        Where Convert.ToInt64(enumValue) > value
                        ).FirstOrDefault
            End If
        Case EnumFindDirection.GreaterOrEqual

Usage Example:


Chapter 11: Dictionaries
A dictionary represents a collection of keys and values. See MSDN Dictionary(Tkey, TValue) Class.
Section 11.1: Create a dictionary filled with values

This creates a dictionary and immediately fills it with three KeyValuePairs.
You can also add new values later on by using the Add method:

Note that the key (the first parameter) needs to be unique in the dictionary, otherwise an Exception will be thrown.
Section 11.2: Loop through a dictionary and print all entries
For EachEach pair in the dictionary is an instance of KeyValuePair with the same type parameters as the Dictionary. When you loop through the dictionary with , each iteration will give you one of the Key-Value Pairs stored in the dictionary.

Section 11.3: Checking for key already in dictionary - data reduction
The ConstainsKey method is the way to know if a key already exists in the Dictionary.
This come in handy for data reduction. In the sample below, each time we encountner a new word, we add it as a key in the dictionary, else we increment the counter for this specific word.

XML reduction example : getting all the child nodes names and occurrence in an branch of an XML document


Section 11.4: Getting a dictionary value
You can get the value of an entry in the dictionary using the 'Item' property:

If the key is not present in the dictionary, a KeyNotFoundException will be thrown.

Chapter 12: Looping
Section 12.1: For...Next
For...Next loop is used for repeating the same action for a finite number of times. The statements inside the following loop will be executed 11 times. The first time, i will have the value 0, the second time it will have the value 1, the last time it will have the value 10.

Any integer expression can be used to parameterize the loop. It is permitted, but not required, for the control variable (in this case i) to also be stated after the Next. It is permitted for the control variable to be declared in advance, rather than within the For statement.

Being able to define the Start and End integers allows loops to be created that directly reference other objects, such as:

This would then loop through every row in DataGridView1 and perform the action of writing the value of Column 1 to the Console. (The -1 is because the first row of the counted rows would be 1, not 0) It is also possible to define how the control variable must increment.

This outputs:
		1 3 5 7 9
It is also possible to decrement the control variable (count down).

This outputs:
		10 9 8 7 6 5 4 3 2 1
You should not attempt to use (read or update) the control variable outside the loop.
Section 12.2: For Each...Next loop for looping through collection of items
For Each...NextYou can use a  loop to iterate through any IEnumerable type. This includes arrays, lists, and anything else that may be of type IEnumerable or returns an IEnumerable.
An example of looping through a DataTable's Rows property would look like this:

For EachSystem.InvalidOperationExceptionAn important thing to note is that the collection must not be modified while in a  loop. Doing so will cause a  with the message:
		Collection was modified; enumeration operation may not execute.
Section 12.3: Short Circuiting
Any loop may be terminated or continued early at any point by using the Exit or Continue statements.
Exiting
You can stop any loop by exiting early. To do this, you can use the keyword Exit along with the name of the loop.
Exit For  Loop	Exit Statement For
Exit ForFor Each
Exit DoDo While
Exit WhileWhile
Exiting a loop early is a great way to boost performance by only looping the necessary number of times to satisfy the application's needs. Below is example where the loop will exit once it finds the number 2.

Continuing
Along with exiting early, you can also decide that you need to just move on to the next loop iteration. This is easily done by using the Continue statement. Just like Exit, it is proceeded by the loop name.
Continue For  Loop	Continue Statement For
Continue ForFor Each
Continue DoContinue WhileDo While While
Here's an example of preventing even numbers from being added to the sum.

Usage Advice
There are two alternative techniques that can be used instead of using Exit or Continue.
You can declare a new Boolean variable, initializing it to one value and conditionally setting it to the other value inside the loop; you then use a conditional statement (e.g. If) based on that variable to avoid execution of the statements inside the loop in subsequent iterations.

One of the objections to this technique is that it may be inefficient. For example, if in the above example N is 1000000 and the first element of the array A is equal to SoughtValue, the loop will iterate a further 999999 times without doing anything useful. However, this technique can have the advantage of greater clarity in some cases.
You can use the GoTo statement to jump out of the loop. Note that you cannot use GoTo to jump into a loop.

This technique can sometimes be the neatest way to jump out of the loop and avoid one or more statements that are executed just after the natural end of the loop.
You should consider all of the alternatives, and use whichever one best fits your requirements, considering such things as efficiency, speed of writing the code, and readability (thus maintainability).
Do not be put off using GoTo on those occasions when it is the best alternative.
Section 12.4: While loop to iterate while some condition is true
A While loop starts by evaluating a condition. If it is true, the body of the loop is executed. After the body of the loop is executed, the While condition is evaluated again to determine whether to re-execute the body.

This outputs:
		1 2 3 4 5 6 7 8 9 10
Warning: A While loop can lead to an infinite loop. Consider what would happen if the line of code that increments iteration were removed. In such a case the condition would never be True and the loop would continue indefinitely.
Section 12.5: Nested Loop
A nested loop is a loop within a loop, an inner loop within the body of an outer one. How this works is that the first pass of the outer loop triggers the inner loop, which executes to completion. Then the second pass of the outer loop triggers the inner loop again. This repeats until the outer loop finishes. a break within either the inner or outer loop would interrupt this process.
The Structure of a For Next nested loop is :

Example :


Section 12.6: Do...Loop
Do...LoopUse  to repeat a block of statements While or Until a condition is true, checking the condition either at the beginning or at the end of the loop.




Exit DoYou can terminate the loop with  - note that in this example, the lack of any condition would otherwise cause an infinite loop:


Chapter 13: File Handling
Section 13.1: Write Data to a File
To write the contents of a string to a file:
Dim toWrite As String = "This will be written to the file."
System.IO.File.WriteAllText("filename.txt", toWrite)
WriteAllText will open the specified file, write the data, and then close the file. If the target file exists, it is overwritten. If the target file does not exist, it is created.
To write the contents of an array to a file:

WriteAllLines will open the specified file, write each value of the array on a new line, and then close the file. If the target file exists, it is overwritten. If the target file does not exist, it is created.
Section 13.2: Read All Contents of a File
To read the contents to a file into a string variable:
Dim fileContents As String = System.IO.File.ReadAllText("filename.txt")
ReadAllText will open the specified file, read data to the end, then close the file.
To read a file, separating it into an array element for each line:
Dim fileLines As String() = System.IO.File.ReadAllLines("filename.txt")
ReadAllLines will open the specified file, read each line of the file into a new index in an array until the end of the file, then close the file.
Section 13.3: Write Lines Individually to a Text File using StreamWriter

The use of a Using block is recommended good practice when using an object that Implements IDisposable
Chapter 14: File/Folder Compression
Section 14.1: Adding File Compression to your project
1. In Solution Explorer go to your project, right click on References then Add reference...
2. Search for Compression and select System.IO.Compression.FileSystem then press OK.
Imports System.IO.Compression3. Add  to the top of your code file (before any class or module, with the other
Imports statements).

Plese note that this class (ZipArchive) is only available from .NET verison 4.5 onwards
Section 14.2: Creating zip archive from directory
System.IO.Compression.ZipFile.CreateFromDirectory("myfolder", "archive.zip")
Create archive.zip file containing files which are in myfolder. In example paths are relative to program working directory. You can specify absolute paths.
Section 14.3: Extracting zip archive to directory
System.IO.Compression.ZipFile.ExtractToDirectory("archive.zip", "myfolder")
Extracts archive.zip to myfolder directory. In example paths are relative to program working directory. You can specify absolute paths.
Section 14.4: Create zip archive dynamicaly

Chapter 15: Connection Handling
Section 15.1: Public connection property


Chapter 16: Data Access
Section 16.1: Read field from Database

Using the above function is simply:

Section 16.2: Simple Function to read from Database and return as DataTable
This simple function will execute the specified Select SQL command and return the result as data set.

Now you can execute the above function from below codes

The above example expects that your SQL Express instance "SQLEXPRESS" is currently installed on "MYDEVPC" and your database "MyDatabase" contains "Customers", "Suppliers" and "Employees" tables and the "sa" user password is "pwd22". Please change these values as per your setup to get the desired results.
Chapter 17: Type conversion
Function name	Range for Expression argument
CBool	Any valid Char or String or numeric expression
CByte	0 through 255 (unsigned); fractional parts are rounded.
Any valid Char or String expression; only first character of a String is converted; value can be 0
CChar through 65535 (unsigned).
Section 17.1: Converting Text of The Textbox to an Integer
From MSDN
Use the CInt function to provide conversions from any other data type to an Integer subtype. For example, CInt forces integer arithmetic when currency, single-precision, or double-precision arithmetic would normally occur.
Assuming that you have 1 button and 2 textbox. If you type on textbox1.text 5.5 and on textbox2.text 10.
If you have this code:

In order to add the values of the 2 textboxes you need to convert their values to Int by using the

Chapter 18: ByVal and ByRef keywords
Section 18.1: ByRef keyword
ByRef keyword before method parameter says that parameter will be sent in a way allowing the method to change (assign a new value) the variable underlying the parameter.

Section 18.2: ByVal keyword
ByVal keyword before method parameter (or no keyword as ByVal is assumed by default) says that parameter will be sent in a way not allowing the method to change (assign a new value) the variable underlying the parameter. It doesn't prevent the content (or state) of the argument to be changed if it's a class.



Chapter 19: Console
Section 19.1: Console.ReadLine()

Console.ReadLine() will read the console input from the user, up until the next newline is detected (usually upon pressing the Enter or Return key). Code execution is paused in the current thread until a newline is provided. Afterwards, the next line of code will be executed.
Section 19.2: Console.Read()

Console.Read() awaits input from the user and, upon receipt, returns an integer value corresponding with the
character code of the entered character. If the input stream is ended in some way before input can be obtained, -1 is returned instead.
Section 19.3: Console.ReadKey()

Console.ReadKey() awaits input from the user and, upon receipt, returns an object of class ConsoleKeyInfo, which
holds information relevant to the character which the user provided as input. For detail regarding the information provided, visit the MSDN documentation.
Section 19.4: Prototype of command line prompt


This prototype generate a basic command line interpreter.
It automatically get the application name and version to communicate to the user. For each input line, it recognize the command and an arbitrary list of arguments, all separated by space.
As a basic example, this code understand ver, quit and exit commands.
The parameter Project.BaseClass is a class of your project where the Assembly details are set.
Section 19.5: Console.WriteLine()

Console.WriteLineThe () method will print the given argument(s) with a newline attached at the end. This will print any object supplied, including, but not limited to, strings, integers, variables, floating-point numbers.
ToStringToStringWhen writing objects that are not explicitly called out by the various WriteLine overloads (that is, you are using the overload that expects a value of type Object, WriteLine will use the .() method to generate a String to actually write. Your custom objects should OverRide the . method and produce something more meaningful than the default implementation (which typically just writes the fully qualified type name).
Chapter 20: Functions
The function is just like sub. But function returns a value. A function can accept single or multiple parameters.
Section 20.1: Defining a Function
It's really easy to define the functions.


Section 20.2: Defining a Function #2

Console.WriteLine(Age(48)) 'Output: You are older than 18 but younger than 65! You are adult!
Chapter 21: Recursion
Section 21.1: Compute nth Fibonacci number
Visual Basic.NET, like most languages, permits recursion, a process by which a function calls itself under certain conditions.
Here is a basic function in Visual Basic .NET to compute Fibonacci numbers.
''' <summary>
''' Gets the n'th Fibonacci number
''' </summary> ''' <param name="n">The 1-indexed ordinal number of the Fibonacci sequence that you wish to receive.
Precondition: Must be greater than or equal to 1.</param>
''' <returns>The nth Fibonacci number. Throws an exception if a precondition is violated.</returns>
Public Shared Function Fibonacci(ByVal n as Integer) as Integer
    If n<1
        Throw New ArgumentOutOfRangeException("n must be greater than or equal to one.")
    End If
    If (n=1) or (n=2)
        ''Base case. The first two Fibonacci numbers (n=1 and n=2) are both 1, by definition.
        Return 1
    End If
    ''Recursive case.
    ''Get the two previous Fibonacci numbers via recursion, add them together, and return the result.
    Return Fibonacci(n-1) + Fibonacci(n-2) End Function
This function works by first checking if the function has been called with the parameter n equal to 1 or 2. By definition, the first two values in the Fibonacci sequence are 1 and 1, so no further computation is necessary to determine this. If n is greater than 2, we cannot look up the associated value as easily, but we know that any such Fibonacci number is equal to the sum of the prior two numbers, so we request those via recursion (calling our own
Fibonacci function). Since successive recursive calls get called with smaller and smaller numbers via decrements of -1 and -2, we know that eventually they will reach numbers that are smaller than 2. Once those conditions (called base cases) are reached, the stack unwinds and we get our final result.
Chapter 22: Random
The Random class is used to generate non-negative pseudo-random integers that are not truly random, but are for general purposes close enough.
The sequence is calculated using an initial number (called the Seed) In earlier versions of .net, this seed number was the same every time an application was run. So what would happen was that you would get the same sequence of pseudo-random numbers every time the application was executed. Now, the seed is based on the time the object is declared.
Section 22.1: Declaring an instance

This declares an instance of the Random class called rng. In this case, the current time at the point where the object is created is used to calculate the seed. This is the most common usage, but has its own problems as we shall see later in the remarks
Instead of allowing the program to use the current time as part of the calculation for the initial seed number, you can specify the initial seed number. This can be any 32 bit integer literal, constant or variable. See below for examples. Doing this means that your instance will generate the same sequence of pseudo-random numbers, which can be useful in certain situations.

or

where x has been declared elsewhere in your program as an Integer constant or variable.
Section 22.2: Generate a random number from an instance of Random
NextThe following example declares a new instance of the Random class and then uses the method . to generate the next number in the sequence of pseudo-random numbers.

The last line above will generate the next pseudo-random number and assign it to x. This number will be in the range of 0 - 2147483647. However, you can also specify the range of numbers to be generated as in the example below.

Please note however, that using these parameters, range of numbers will be between 15 or above and 199 or below.
NextDoubleYou can also generate floating point numbers of the type Double by using . e.g

You cannot however specify a range for this. It will always be in the range of 0.0 to less than 1.0.

Chapter 23: Classes
A class groups different functions, methods, variables, and properties, which are called its members. A class encapsulates the members, which can be accessed by an instance of the class, called an object. Classes are extremely useful for the programmer, as they make the task convenient and fast, with characteristics such as modularity, re-usability, maintainability, and readability of the code.
Classes are the building blocks of object-oriented programming languages.
Section 23.1: Abstract Classes
If classes share common functionality you can group this in a base or abstract class. Abstract classes can contain partial or no implementation at all and allow the derived type to override the base implementation.
Abstract classes within VisualBasic.NET must be declared as MustInherit and cannot be instantiated.

A sub type can then inherit this abstract class as shown below:

Car will inherit all of the declared types within vehicle, but can only access them based upon the underlying access modifier.

DisplayWheelCountIn the above example a new Car instance is created. The () method is then invoked which will call the base class Vehicles implementation.
Section 23.2: Creating classes
Classes provide a way of creating your own types within the .NET framework. Within a class definition you may include the following:
Fields
Properties
Methods
Constructors
 Events
To declare a class you use the following syntax:

Other .NET types can be encapsulated within the class and exposed accordingly, as shown below:


Chapter 24: Generics
Section 24.1: Create a generic class
A generic type is created to adapt so that the same functionallity can be accessible for different data types.

Section 24.2: Instance of a Generic Class
By creating an instance of the same class with a different type given, the interface of the class changes depending on the given type.

Section 24.3: Define a 'generic' class
A generic class is a class who adapts to a later-given type so that the same functionality can be offered to different types.
In this basic example a generic class is created. It has a sub who uses the generic type T. While programming this class, we don't know the type of T. In this case T has all the characteristics of Object.

Section 24.4: Use a generic class
In this example there are 2 instances created of the SomeClass Class. Depending on the type given the 2 instances have a different interface:

The most famous generic class is List(of )
Section 24.5: Limit the possible types given
The possible types passed to a new instance of SomeClass must inherit SomeBaseClass. This can also be an interface. The characteristics of SomeBaseClass are accessible within this class definition.

Section 24.6: Create a new instance of the given type
Creating a new intance of a generic type can be done/checed at compile time.

Or with limited types:

The baseClass (if none given it is Object) must have a parameter less constructor.
This can also be done at runtime through reflection
Chapter 25: Disposable objects
Section 25.1: Basic concept of IDisposable
DisposeAny time you instantiate a class that Implements IDisposable, you should call .1 on that class when you have finished using it. This allows the class to clean up any managed or unmanaged dependencies that it may be using. Not doing this could cause a memory leak.
DisposeThe Using keyword ensures that . is called, without you having to explicitly call it.
For example without Using:

Now with Using:

DisposeOne major advantage Using has is when an exception is thrown, because it ensures . is called.
Consider the following. If an exception is thrown, you need to need to remember to call .Dispose but you might also have to check the state of the object to ensure you don't get a null reference error, etc.

A using block means you don't have to remember to do this and you can declare your object inside the try:

1 Do I always have to call Dispose() on my DbContext objects? Nope
Section 25.2: Declaring more objects in one Using
Sometimes, you have to create two Disposable objects in a row. There is an easy way to avoid nesting Using blocks.
This code

can be shortened into this one. The main advantage is that you gain one indentation level:


Chapter 26: NullReferenceException
Section 26.1: Empty Return

BAD CODE

GOOD CODE

Version = 14.0
Null Conditional Operator

Section 26.2: Uninitialized variable
BAD CODE

GOOD CODE

EVEN BETTER CODE (Ensure proper disposal of IDisposable object more info)

Chapter 27: Using Statement
Section 27.1: See examples under Disposable objects
Basic concept of IDisposable

Chapter 28: Option Strict
Section 28.1: Why Use It?
Option Strict On prevents three things from happening:
1. Implicit Narrowing Conversion Errors
It prevents you from assigning to a variable that has less precision or smaller capacity (a narrowing conversion) without an explicit cast. Doing so would result in data loss.

2. Late Binding Calls
Late binding is not allowed. This is to prevent typos that would compile, but fail at runtime

3. Implicit Object Type Errors
This prevents variable being inferred as an Object when in fact they should have been declared as a type
Dim something = Nothing. 'This line does not compile with Option Strict On
Conclusion
Option Strict OnUnless you need to do late binding, you should always have  as it will cause the mentioned errors to generate compile time errors instead of runtime exceptions.
If you have to do late binding, you can either
Option Strict OffProject Properties > Compile Tab Wrap all your late binding calls into one class/module and use  at the top of the code file
(this is the preferred method as it reduces the likelihood of a typos in other files), or
Specify that Late Binding does not cause a compilation failure (>
Warning Configuration)
Section 28.2: How to Switch It On



Chapter 29: Option Explicit
Section 29.1: What is it?
It forces you to explicitly declare all variables.
What is the difference between explicitly declaring and implicitly declaring a variable?
Explicitly declaring a variable:

Implicitly declaring a variable:

Conclusion
Option Explicit OnTherefore, you should always have  as you could misspel a variable during assignment, which cause your program to behave unexpectedly.
Section 29.2: How to switch it on?
Document level
Option Explicit OnIt is on by default, but you can have an extra layer of protection by placing  at the top of the code file. The option will apply to the whole document.
Project level
You can switch it on via the menu in Visual Studio:
		Project > [Project] Properties > Compile Tab > Option Explicit
Choose On in the drop-down menu. The option will apply to the whole document.
All new projects
You can switch it On by default for all new Projects by selecting:
		Tools > Options > Projects and Solutions > VB defaults > Option Explicit
Choose On in the drop-down menu.
Chapter 30: Option Infer
Section 30.1: How to enable/disable it
Document level
Option Infer On|OffIt is on by default, but you can set it by placing  at the top of the code file. The option will apply to the whole document.
Project level
You can switch it on/off via the menu in Visual Studio:
		Project > [Project] Properties > Compile Tab > Option infer
On|OffChoose  in the drop-down menu. The option will apply to the whole document.
All new projects
You can switch it On by default for all new Projects by selecting:
		Tools > Options > Projects and Solutions > VB defaults > Option Infer
On|OffChoose  in the drop-down menu.
Section 30.2: What is it?
Enables the use of local type inference in declaring variables.
What is type inference?
You can declare local variables without explicitly stating a data type. The compiler infers the data type of a variable from the type of its initialization expression.
Option Infer On:
Dim aString  = "1234" '--> Will be treated as String by the compiler
Dim aNumber  = 4711   '--> Will be treated as Integer by the compiler
vs. explicit type declaration:

Option Infer Off:
Option Infer Off depends on the Option StrictThe compiler behavior with  setting which is already documented here.
 Option Infer Off - Option Strict Off
All variables without explicit type declarations are declared as Object.
Option Infer Off - Option Strict On
The compiler won´t let you declare a variable without an explicit type.
'Dim aString  = "1234" '--> Will not compile due to missing type in declaration
Section 30.3: When to use type inference
Basically you can use type inference whenever it is possible.
Option Infer Off and Option Strict OffHowever, be careful when combining , as this can lead to undesired runtime behavior:

Anonymous Type
Option Infer OnAnonymous types can only be declared with .
They are often used when dealing with LINQ:

Option Strict OnOption Strict OffThe compiler will either throw an error (with ) or will consider q as type object (with ).
Both cases will produce the outcome that you cannot use the anonymous type.
Doubles/Decimals
Numeric variables with decimal places will be infered as Double by default:
Dim aNumber = 44.11 '--> Will be treated as type `Double` by the compiler
If another type like Decimal is desired the value which initialized the variable needs to be marked:
Dim mDecimal = 47.11D '--> Will be treated as type `Decimal` by the compiler

Chapter 31: Error Handling
Section 31.1: Try...Catch...Finally Statement
Structure:
Try
    'Your program will try to run the code in this block.  
    'If any exceptions are thrown, the code in the Catch Block will be executed,     'without executing the lines after the one which caused the exception.
Catch ex As System.IO.IOException
    'If an exception occurs when processing the Try block, each Catch statement
    'is examined in textual order to determine which handles the exception.
    'For example, this Catch block handles an IOException.
Catch ex As Exception
    'This catch block handles all Exception types.
    'Details of the exception, in this case, are in the "ex" variable.
    'You can show the error in a MessageBox with the below line.
    MessageBox.Show(ex.Message)
Finally
    'A finally block is always executed, regardless of if an Exception occurred. End Try
Example Code:

Section 31.2: Creating custom exception and throwing
You can create a custom exception and throw them during the execution of your function. As a general practice you should only throw an exception when your function could not achieve its defined functionality.


Section 31.3: Try Catch in Database Operation
You can use Try..Catch to rollback database operation by placing the rollback statement at the Catch Segment.

Section 31.4: The Un-catchable Exception
Catch ex As ExceptionAlthough  claims that it can handle all exceptions - there are one exception (no pun intended).

System.StackOverflowExceptionOops... There is an un-caught  while the console didn't even print out anything!
According to MSDN,
Starting with the .NET Framework 2.0, you can't catch a StackOverflowException object with a try/catch block, and the corresponding process is terminated by default. Consequently, you should write your code to detect and prevent a stack overflow.
System.StackOverflowExceptionSo,  is un-catchable. Beware of that!
Section 31.5: Critical Exceptions
Generally most of the exceptions are not that critical, but there are some really serious exceptions that you might
System.StackOverflowExceptionnot be capable to handle, such as the famous . However, there are others that
Catch ex As Exception, such as System.OutOfMemoryExceptionmight get hidden by ,
System.BadImageFormatException and System.InvalidProgramException. It is a good programming practice to leave these out if you cannot correctly handle them. To filter out these exceptions, we need a helper method:
Public Shared Function IsCritical(ex As Exception) As Boolean
    Return TypeOf ex Is OutOfMemoryException OrElse
           TypeOf ex Is AppDomainUnloadedException OrElse
           TypeOf ex Is AccessViolationException OrElse
           TypeOf ex Is BadImageFormatException OrElse
           TypeOf ex Is CannotUnloadAppDomainException OrElse
           TypeOf ex Is ExecutionEngineException OrElse ' Obsolete one, but better to include
           TypeOf ex Is InvalidProgramException OrElse
           TypeOf ex Is System.Threading.ThreadAbortException
End Function
Usage:


Chapter 32: OOP Keywords
Section 32.1: Defining a class
Classes are vital aspects of OOP. A class is like the "blueprint" of an object. An object has the properties of a class, but the characteristics are not defined within the class itself. As each object can be different, they define their own characteristics.

A class can also contain subclasses. A subclass inherits the same properties and behaviors as its parent class, but can have its own unique properties and classes.
Section 32.2: Inheritance Modifiers (on classes)
Inherits
Specifies the base (or parent) class

Possible objects:

Prevents programmers from using the class as a base class.

Possible objects:

MustInherit
Specifies that the class is intended for use as a base class only. (Abstract class)


Possible objects:

Section 32.3: Inheritance Modifiers (on properties and methods)
Overridable
Allows a property or method in a class to be overridden in a derived class.

Overrides an Overridable property or method defined in the base class.

NotOverridable
Prevents a property or method from being overridden in an inheriting class. Default behaviour. Can only be declared on overrides methods


Example Usage:

Output:

MustOverride
Requires that a derived class override the property or method.
MustOverride methods must be declared in MustInherit classes.

Example Usage:

Output:

Section 32.4: MyBase
The MyBase keyword behaves like an object variable that refers to the base class of the current instance of a class.


Usage example:

Output:

Section 32.5: Me vs MyClass
Me uses the current object instance.
MyClass uses the memberdefinition in the class where the member is called

Example Usage:

Output:

Section 32.6: Overloading
Overloading is the creation of more than one procedure, instance constructor, or property in a class with the same name but different argument types.

Section 32.7: Shadows
It redeclares a member that is not overridable. Only calls to the instance will be affected. Code inside the base classes will not be affected by this.

Example usage:


Output:

Pitfalls:
Example1, Creating a new object through a generic. Which function will be used??

example usage:

Output: By intuition the result should be the same. Yet that is not true.

Example 2:

Output: By intuition you could think that p and s are equal and will behave equal. Yet that is not true.

In this simple examples it is easy to learn the strange behaviour of Shadows. But in real-life it brings a lot of surprises. It is advisably to prevent the usage of shadows. One should use other alternatives as much as possible (overrides etc..)
Section 32.8: Interfaces


Chapter 33: Extension methods
Section 33.1: Creating an extension method
Extension methods are useful to extend the behaviour of libraries we don't own.
They are used similar to instance methods thanks to the compiler's syntactic sugar:

To have a usable extension method, the method needs the Extension attribute and needs to be declared in a Module.
Section 33.2: Making the language more functional with extension methods
A good use of extension method is to make the language more functional

Section 33.3: Getting Assembly Version From Strong Name
Example of calling an extension method as an extension and as a regular method.


The Extension Method in a Module. Make the Module Public if extensions are compiled to a dll and will be referenced in another assembly.

Section 33.4: Padding Numerics



Chapter 34: Reflection
Section 34.1: Retrieve Properties for an Instance of a Class

The Parameter of GetProperties defines which kinds of Properties will be returned by the function. Since we pass Public and Instance, the method will return only properties that are both public and non-shared. See The Flags attribute for and explanation on how Flag-enums can be combined.
Section 34.2: Get a method and invoke it
Static method:
Dim parseMethod = GetType(Integer).GetMethod("Parse",{GetType(String)})
 Dim result = DirectCast(parseMethod.Invoke(Nothing,{"123"}), Integer) Instance method:

Section 34.3: Create an instance of a generic type
    Dim openListType = GetType(List(Of ))
    Dim typeParameters = {GetType(String)}
    Dim stringListType = openListType.MakeGenericType(typeParameters)     Dim instance = DirectCast(Activator.CreateInstance(stringListType), List(Of String))     instance.Add("Hello")
Section 34.4: Get the members of a type



Chapter 35: Visual Basic 14.0 Features
Visual Basic 14 is the version of Visual Basic that was shipped as part of Visual Studio 2015.
This version was rewritten from scratch in about 1.3 million lines of VB. Many features were added to remove common irritations and to make common coding patterns cleaner.
The version number of Visual Basic went straight from 12 to 14, skipping 13. This was done to keep VB in line with the version numbering of Visual Studio itself.
Section 35.1: Null conditional operator
To avoid verbose null checking, the ?. operator has been introduced in the language.
The old verbose syntax:

Can be now replaced by the concise:

The ? operator is particularly powerful when you have a chain of properties. Consider the following:

Normally you would have to write something like this:


Section 35.2: String interpolation
String.FormatThis new feature makes the string concatenation more readable. This syntax will be compiled to its equivalent  call.
Without string interpolation:

With string interpolation:

String.FormatThe two lines are equivalent and both get compiled to a call to .
String.FormatAs in , the brackets can contain any single expression (call to a method, property, a null coalescing operator et cetera).
String.FormatString.FormatString Interpolation is the preferred method over  because it prevents some runtime errors from occurring. Consider the following  line:

This will compile, but will cause a runtime error as the compiler does not check that the number of arguments match the placeholders.
Section 35.3: Read-Only Auto-Properties
Read-only properties were always possible in VB.NET in this format:

The new version of Visual Basic allows a short hand for the property declaration like so:

The actual implementation that is generated by the compiler is exactly the same for both examples. The new method to write it is just a short hand. The compiler will still generate a private field with the format:
PropertyName_<> to back the read-only property.
Section 35.4: NameOf operator
The NameOf operator resolves namespaces, types, variables and member names at compile time and replaces them with the string equivalent.
One of the use cases:

The old syntax will expose the risk of renaming the variable and leaving the hard-coded string to the wrong value.

With NameOf, renaming the variable only will raise a compiler error. This will also allow the renaming tool to rename both with a single effort.
The NameOf operator only uses the last component of the reference in the brackets. This is important when handling something like namespaces in the NameOf operator.

The operator also uses the name of the reference that is typed in without resolving any name changing imports. For example:

Section 35.5: Multiline string literals
VB now allows string literals that split over multiple lines.
Old syntax:

New syntax:

Section 35.6: Partial Modules and Interfaces
Similar to partial classes the new version of Visual Basic is now able to handle partial modules and partial interfaces. The syntax and behaviour is exactly the same as it would be for partial classes.
A partial module example:


And a partial interface:

Just like for partial classes the definitions for the partial modules and interfaces have to be located in the same namespace and the same assembly. This is because the partial parts of the modules and interfaces are merged during the compilation and the compiled assembly does not contain any indication that the original definition of the module or interface was split.
Section 35.7: Comments after implicit line continuation
VB 14.0 introduces the ability to add comments after implicit line continuation.

Section 35.8: #Region directive improvements
#Region directive can now be placed inside methods and can even span over methods, classes and modules.



Chapter 36: LINQ
LINQ (Language Integrated Query) is an expression that retrieves data from a data source. LINQ simplifies this situation by offering a consistent model for working with data across various kinds of data sources and formats. In a LINQ query, you are always working with objects. You use the same basic coding patterns to query and transform data in XML documents, SQL databases, ADO.NET Datasets, .NET collections, and any other format for which a LINQ provider is available.
Section 36.1: Selecting from array with simple condition
Dim sites() As String = {"Stack Overflow", "Super User", "Ask Ubuntu", "Hardware  Recommendations"}
Dim query = From x In sites Where x.StartsWith("S")
' result = "Stack Overflow", "Super User"
Query will be enumerable object containing Stack Overflow and Super User. x in the query is iterating variable where will be stored each object checked by Where clause.
Section 36.2: Mapping array by Select clause

Query result will be enumerable object containing lengths of strings in input array. In this example this would be values 14, 10, 10, 24. x in the query is iterating variable where will be stored each object from the input array.
Section 36.3: Ordering output

OrderBy clause orders the output by the value returned from the clause. In this example it is Length of each string. Default output order is ascending. If you need descending you could specify Descending keyword after clause.

Section 36.4: Generating Dictionary From IEnumerable


Section 36.5: Projection

We can project multiple result at once too

Section 36.6: Getting distinct values (using the Distinct method)
Dim duplicateFruits = New List(Of String) From {"Grape", "Apple", "Grape", "Apple", "Grape"} 'At this point, duplicateFruits.Length = 5
Dim uniqueFruits = duplicateFruits.Distinct();
'Now, uniqueFruits.Count() = 2
'If iterated over at this point, it will contain 1 each of "Grape" and "Apple"
Chapter 37: FTP server
Section 37.1: Download file from FTP server
My.Computer.Network.DownloadFile("ftp://server.my/myfile.txt", "donwloaded_file.txt")
myfile.txt file from server named server.my and saves it as donwloaded_file.txtThis command download  into working directory. You can specify absolute path for downloaded file.
Section 37.2: Download file from FTP server when login required
My.Computer.Network.DownloadFile("ftp://srv.my/myfile.txt", "donwload.txt", "Peter", "1234")
myfile.txt file from server named srv.my and saves it as donwload.txtThis command download  into working directory. You can specify absolute path for downloaded file. File is download by user Peter with password 1234.
Section 37.3: Upload file to FTP server
My.Computer.Network.UploadFile("example.txt", "ftp://server.my/server_example.txt")
example.txtserver.my. File stored on the server will be named server_example.txtThis command upload  file from working directory (you could specify absolute path if you want) to server named .
Section 37.4: Upload file to FTP server when login required
My.Computer.Network.UploadFile("doc.txt", "ftp://server.my/on_server.txt", "Peter", "1234")
doc.txtserver.my. File stored on the server will be named server_example.txtThis command upload  file from working directory (you could specify absolute path if you want) to server named . Fill is send on the server by user
Peter and password 1234.
Chapter 38: Working with Windows Forms
Section 38.1: Using the default Form instance
VB.NET offers default Form instances. The developer does not need to create the instance as it is created behind the scenes. However, it is not preferable to use the default instance all but the simplest programs.

See also:
Do you have to explicitly create instance of form in VB.NET?
 Why is there a default instance of every form in VB.Net but not in C#?
 Section 38.2: Passing Data From One Form To Another
Sometimes you might want to pass information that has been generated in one form, to another form for additional use. This is useful for forms that display a search tool, or a settings page among many other uses.
Let's say you want to pass a DataTable between a form that is already open (MainForm) and a new form (NewForm):
In The MainForm:

In The NewForm


Now when the NewForm is opened, it is passed DataTable1 from MainForm and stored as NewDataTable in NewForm for use by that form.
This can be extremely useful when trying to pass large amounts of information between forms, especially when combining all of the information in to a single ArrayList and passing the ArrayList to the new form.

Chapter 39: Google Maps in a Windows Form
Section 39.1: How to use a Google Map in a Windows Form
The first part of this example explains how to implement it. In the second, I will explain how it works. This tries to be a general example. The template for the map (see step 3) and the example functions are fully customizable.
################################# IMPLEMENTATION #################################
Step 1. Firstly, create a new project and select Windows Form Application. Let's leave its name as "Form1".

Step 2. Add a WebBrowser control (which will hold your map) to your Form1. Let's call it "wbmap"
Step 3. Create a .html file named "googlemap_template.html" with your favourite text editor and paste the following code:
googlemap_template.html


        height: 100%;         margin: 0;         padding: 0;       }       #gmap {
        height: 100%;       }
     </style>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
    <script type="text/javascript">         function initialize() {
            //Use window.X instead of var X to make a variable globally available             window.markers = new Array();             window.marker_data = [[MARKER_DATA]];             window.gmap = new google.maps.Map(document.getElementById('gmap'), {             zoom: 15,             center: new google.maps.LatLng(marker_data[0][0], marker_data[0][1]),             mapTypeId: google.maps.MapTypeId.ROADMAP           });           var infowindow = new google.maps.InfoWindow();           var newmarker, i;           for (i = 0; i < marker_data.length; i++) {               if (marker_data[0].length == 2) {                   newmarker = new google.maps.Marker({                       position: new google.maps.LatLng(marker_data[i][0], marker_data[i][1]),                       map: gmap                   });               } else if (marker_data[0].length == 3) {                   newmarker = new google.maps.Marker({                       position: new google.maps.LatLng(marker_data[i][0], marker_data[i][1]),                       map: gmap,                       title: (marker_data[i][2])                   });               } else {                   newmarker = new google.maps.Marker({                       position: new google.maps.LatLng(marker_data[i][0], marker_data[i][1]),                       map: gmap,                       title: (marker_data[i][2]),                       icon: (marker_data[i][3])                   });               }             google.maps.event.addListener(newmarker, 'click', (function (newmarker, i) {                 return function () {                     if (newmarker.title) {                         infowindow.setContent(newmarker.title);                         infowindow.open(gmap, newmarker);
                    }                     gmap.setCenter(newmarker.getPosition());                     // Calling functions written in the WF                     window.external.showVbHelloWorld();                     window.external.getMarkerDataFromJavascript(newmarker.title,i);                 }             })(newmarker, i));             markers[i] = newmarker;           }         }         google.maps.event.addDomListener(window, 'load', initialize);     </script>
    <script type="text/javascript">
        // Function triggered from the WF with no arguments         function showJavascriptHelloWorld() {             alert("Hello world in HTML from WF");
This will serve as our map template. I will explain how it works later.
Step 4. Add the googlemap_template.hmtl file to your project (right click on your project->add->existing item) Step 5. Once it appears in your Solution Explorer, set its properties to:

Step 6. Add a new class (right click on your project->add->class). In my example I'll call it GoogleMapHelper.

Step 7. Paste the following code into your class:
GoogleMapHelper.vb
    Imports System.IO
    Imports System.Reflection
    Imports System.Text
   
    Public Class GoogleMapHelper
    ' 1- googlemap_template.html must be copied in the main project folder
    ' 2- add the file into the Visual Studio Solution Explorer (add existing file)
    ' 3- set the properties of the file to:
    '                                   Build Action -> Embedded Resource
    '                                   Custom Tool Namespace -> write the name of the project
    Private Const ICON_FOLDER As String = "marker_icons/" 'images must be stored in a folder inside  Debug/Release folder
    Private Const MAP_TEMPLATE As String = "WindowsApplication1.googlemap_template.html"
    Private Const TEXT_TO_REPLACE_MARKER_DATA As String = "[[MARKER_DATA]]"
    Private Const TMP_NAME As String = "tmp_map.html"

       Private mWebBrowser As WebBrowser
    'MARKER POSITIONS
    Private mPositions As Double(,) 'lat, lon
    ' marker data allows different formats to include lat,long and optionally title and icon:
    ' op1: mMarkerData = New String(N-1, 1) {{lat1, lon1}, {lat2, lon2}, {latN, lonN}}
    ' op2: mMarkerData = New String(N-1, 2) {{lat1, lon1,'title1'}, {lat2, lon2,'title2'}, {latN, lonN, 'titleN'}}
    ' op3: mMarkerData = New String(N-1, 3) {{lat1, lon1,'title1','image1.png'}, {lat2, lon2,'title2','image2.png'}, {latN, lonN, 'titleN','imageN.png'}}
    Private mMarkerData As String(,) = Nothing
   
    Public Sub New(ByRef wb As WebBrowser, pos As Double(,))         mWebBrowser = wb         mPositions = pos
        mMarkerData = getMarkerDataFromPositions(pos)     End Sub
    Public Sub New(ByRef wb As WebBrowser, md As String(,))         mWebBrowser = wb         mMarkerData = md     End Sub
    Public Sub loadMap()
        mWebBrowser.Navigate(getMapTemplate())     End Sub
    Private Function getMapTemplate() As String
        If mMarkerData Is Nothing Or mMarkerData.GetLength(1) > 4 Then
            MessageBox.Show("Marker data has not the proper size. It must have 2, 3 o 4 columns")
            Return Nothing
        End If
        Dim htmlTemplate As New StringBuilder()
        Dim tmpFolder As String = Environment.GetEnvironmentVariable("TEMP")
        Dim dataSize As Integer = mMarkerData.GetLength(1) 'number of columns
        Dim mMarkerDataAsText As String = String.Empty
        Dim myresourcePath As String = My.Resources.ResourceManager.BaseName
        Dim myresourcefullPath As String = Path.GetFullPath(My.Resources.ResourceManager.BaseName)
        Dim localPath = myresourcefullPath.Replace(myresourcePath, "").Replace("\", "/") & ICON_FOLDER
        htmlTemplate.AppendLine(getStringFromResources(MAP_TEMPLATE))         mMarkerDataAsText = "["
        For i As Integer = 0 To mMarkerData.GetLength(0) - 1             If i <> 0 Then
                mMarkerDataAsText += ","             End If
            If dataSize = 2 Then 'lat,lon
                mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & "]"             ElseIf dataSize = 3 Then 'lat,lon and title                 mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & ",'" & mMarkerData(i, 2) & "']"
            ElseIf dataSize = 4 Then 'lat,lon,title and image                 mMarkerDataAsText += "[" & mMarkerData(i, 0) & "," + mMarkerData(i, 1) & ",'" & mMarkerData(i, 2) & "','" & localPath & mMarkerData(i, 3) & "']" 'Ojo a las comillas simples en las columnas 3 y 4
Note: The MAP_TEMPLATE constant must include the name of your project Step 8. Now we can use our GoogleMapHelper class to load the map into our webbrowser by simply creating and instance and calling its loadMap() method. How you build your markerData is up to you. In this example, for clarification, I write them by hand. There are 3 options to define the marker data (see GoogleMapHelper class comments). Note that if you use the third option (including title and icons) you must create a folder called "marker_icons" (or whatever you define in the GoogleMapHelper constant ICON_FOLDER) in your Debug/Release folder and place there your .png files. In my case:

I created two buttons in my Form1 to illustrate how the map and the WF interact. Here is how it looks:

And here is the code:
Form1.vb

    Dim onlyPositions As Double(,) = New Double(2, 1) {{42.13557, -0.40806}, {42.13684, -0.40884}, {42.13716, -0.40729}}
    Dim positonAndTitles As String(,) = New String(2, 2) {{"42.13557", "-0.40806", "marker0"},
{"42.13684", "-0.40884", "marker1"}, {"42.13716", "-0.40729", "marker2"}}
    Dim positonTitlesAndIcons As String(,) = New String(2, 3) {{"42.13557", "-0.40806", "marker0",
"truck_red.png"}, {"42.13684", "-0.40884", "marker1", "truck_red.png"}, {"42.13716", "-0.40729", "marker2", "truck_red.png"}}
    'Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, onlyPositions)
    'Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, positonAndTitles)     Dim gmh As GoogleMapHelper = New GoogleMapHelper(wbmap, positonTitlesAndIcons)     gmh.loadMap() End Sub
'############################### CALLING JAVASCRIPT METHODS ##############################
'This methods call methods written in googlemap_template.html
Private Sub callMapJavascript(sender As Object, e As EventArgs) Handles Button1.Click     wbmap.Document.InvokeScript("showJavascriptHelloWorld") End Sub
Private Sub callMapJavascriptWithArguments(sender As Object, e As EventArgs) Handles Button2.Click     wbmap.Document.InvokeScript("focusMarkerFromIdx", New String() {2}) End Sub
'#########################################################################################
'############################### METHODS CALLED FROM JAVASCRIPT ########################## 'This methods are called by the javascript defined in googlemap_template.html when some events are triggered
Public Sub getMarkerDataFromJavascript(title As String, idx As String)
    MsgBox("Title: " & title & " idx: " & idx)
End Sub
Public Sub showVbHelloWorld()
    MsgBox("Hello world in WF from HTML")
End Sub
End Class
IMPORTANT : don't forget to add these lines before your class Form1 definition:

What they do is to tell the .NET Framework that we want fulltrust and make the class visible to COM so Form1 is visible to JavaScript.
Also don't forget this in your Form1 load function:

It exposes your Form1 class to the JavaScript on the googlemap_template.hmtl page.
Now you can execute and it should be working
################################# HOW IT WORKS#################################
Basically, what our GoogleMapHelper class does is to read our googlemap_template.html, make a temporal copy, replace the code related to the markers ([[MARKER_DATA]]) and execute the page in the web browser control of our form. This html loops through all the markers and assigns a 'click' listener to each one. This click function is obviously fully customizable. In the example it opens an infowindow if the marker has a title, centers the map in such marker and calls two external functions that are defined in our Form1 class.
On the other hand, we can define other javascript functions (with or without arguments) in this html to be called from our Windows Form (by using wbmap.Document.InvokeScript).

Chapter 40: GDI+
Section 40.1: Draw Shapes
To start drawing a shape you need to define a pen object The Pen accepts two parameters:
1. Pen Color or Brush
2. Pen Width
The Pen Object is used to create an outline of the object you want to draw
After Defining the Pen you can set specific Pen Properties
   Dim pens As New Pen(Color.Purple)    pens.DashStyle = DashStyle.Dash 'pen will draw with a dashed line    pens.EndCap = LineCap.ArrowAnchor 'the line will end in an arrow    pens.StartCap = LineCap.Round 'The line draw will start rounded
   '*Notice* - the Start and End Caps will not show if you draw a closed shape
Then use the graphics object you created to draw the shape
  Private Sub GraphicForm_Paint(sender As Object, e As PaintEventArgs) Handles MyBase.Paint
    Dim pen As New Pen(Color.Blue, 15) 'Use a blue pen with a width of 15
    Dim point1 As New Point(5, 15) 'starting point of the line     Dim point2 As New Point(30, 100) 'ending point of the line     e.Graphics.DrawLine(pen, point1, point2)
    e.Graphics.DrawRectangle(pen, 60, 90, 200, 300) 'draw an outline of the rectangle
By default, the pen's width is equal to 1

Section 40.2: Fill Shapes
Graphics.FillShapes draws a shape and fills it in with the color given. Fill Shapes can use
1. Brush Tool - to fill shape with a solid color
Dim rect As New Rectangle(50, 50, 50, 50)
e.Graphics.FillRectangle(Brushes.Green, rect) 'draws a rectangle that is filled with green
e.Graphics.FillPie(Brushes.Silver, rect, 0, 180) 'draws a half circle that is filled with silver
2. HatchBrush Tool - to fill shape with a pattern
Dim hBrush As New HatchBrush(HatchStyle.ZigZag, Color.SkyBlue, Color.Gray)
'creates a HatchBrush Tool with a background color of blue, foreground color of gray,
'and will fill with a zigzag pattern
Dim rectan As New Rectangle(100, 100, 100, 100)

3. LinearGradientBrush - to fill shape with a gradient
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)  Dim rect As New Rectangle(50, 50, 200, 200)
 e.Graphics.FillRectangle(lBrush, rect)
4. TextureBrush - to fill shape with a picture
You can choose a picture from resources, an already defined Bitmap, or from a file name
   Dim textBrush As New TextureBrush(New Bitmap("C:\ColorPic.jpg"))     Dim rect As New Rectangle(400, 400, 100, 100)
    e.Graphics.FillPie(textBrush, rect, 0, 360)
Both the Hatch Brush Tool and LinearGradientBrush import the following statement : Imports System.Drawing.Drawing2D
Section 40.3: Text
To draw text onto the form use the DrawString Method
When you draw a string you can use any of the 4 brushes listed above
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)
e.Graphics.DrawString("HELLO", New Font("Impact", 60, FontStyle.Bold), lBrush, New Point(40, 400))
'this will draw the word "Hello" at the given point, with a linearGradient Brush
Since you can't define the width or height of the text use Measure Text to check text size
Dim lBrush As New LinearGradientBrush(point1, point2, Color.MediumVioletRed, Color.PaleGreen)
Dim TextSize =  e.Graphics.MeasureString("HELLO", New Font("Impact", 60, FontStyle.Bold), lBrush)
'Use the TextSize to determine where to place the string, or if the font needs to be smaller
Ex: You need to draw the word "Test" on top of the form. The form's width is 120. Use this loop to decrease the font size till it will fit into the forms width
Dim FontSize as Integer = 80
Dim TextSize = e.graphics.measeString("Test", New Font("Impact",FontSize, FontStyle.Bold), new
Brush(colors.Blue, 10)    
Do while TextSize.Width >120
FontSize = FontSize -1
TextSize = e.graphics.measeString("Test", New Font("Impact",FontSize, FontStyle.Bold), new
Brush(colors.Blue, 10)  
Loop
Section 40.4: Create Graphic Object
There are three ways to create a graphics object
1. From the Paint Event
Every time the control is redrawn (resized, refreshed...) this event is called, use this way if you want the control to consistently draw on the control

2. Create Graphic
This is most often used when you want to create a one time graphic on the control, or you don't want the control to repaint itself

3. From an Existing Graphic
Use this method when you want to draw and change an existing graphic
   'The existing image can be from a filename, stream or Drawing.Graphic
   Dim image = New Bitmap("C:\TempBit.bmp")
   Dim gr As Graphics = Graphics.FromImage(image)

Chapter 41: WinForms SpellCheckBox
Example on how to add a spell check box to a WindowsForms application. This example DOES NOT require Word to be installed nor does it use Word in any way.
It uses WPF Interop using the ElementHost control to create a WPF UserControl from a WPF TextBox. WPF TextBox has a built in function for spell check. We are going to leverage this built in function rather than relying on an external program.
Section 41.1: ElementHost WPF TextBox
This example is was modeled after an example that I found on the internet. I can't find the link or I would give the author credit. I took the sample that I found and modified it to work for my application.
1. Add the following references:
	System.Xaml, PresentationCore, PresentationFramework, WindowsBase, and WindowsFormsIntegration 2. Create a new Class and past this code


3. Rebuild the solution.
4. Add a new form.
5. Search the toolbox for your Class name. This example is "SpellCheck". It should be listed under 'YourSoulutionName' Components.
6. Drag the new control to your form
7. Set any of the mapped properties in the forms load event

7. The last thing that you need to do is to change the DPI Awareness of your application. This is because you are using WinForms application. By default all WinForms applications are DPI UNAWARE. Once you execute a control that has an element host (WPF Interop), the application will now become DPI AWARE. This may or may not mess with your UI Elements. The solution to this is to FORCE the application to become DPI
UNAWARE. There are 2 ways to do this. The first is through the manifest file and the second is to hard code it in to your program. If you are using OneClick to deploy your application, you must hard code it, not use the manifest file or errors will be inevitable.
Both of the following examples can be found at the following: WinForms Scaling at Large DPI Settings - Is It Even Possible? Thanks to Telerik.com for the great explanation on DPI.



Chapter 42: Using axWindowsMediaPlayer in VB.Net
axWindowsMediaPlayer is the control for the playing multimedia files like videos and music.
Section 42.1: Adding the axWindowsMediaPlayer
Right-click on the Toolbox, then click "Choose Items".
 Select the COM Components tab, and then check Windows Media Player. axWindowsMediaPlayer will be added to Toolbox.
Select this checkbox to use axWindowsMediaPlayer

Then you can use axWindowsMediaPlayer :)

Section 42.2: Play a Multimedia File

This code will play Avatar in the axWindowsMediaPlayer.
Chapter 43: WPF XAML Data Binding
This example shows how to create a ViewModel and a View within the MVVM pattern and WPF, and how to bind the two together, so that each is updated whenever the other is changed.
Section 43.1: Binding a String in the ViewModel to a TextBox in the View
SampleViewModel.vb

Option Strict OnA DependencyProperty can be easily added by using the wpfdp code snippet (type wpfdp, then press the TAB key twice), however, the code snippet is not type safe, and will not compile under .
SampleWindow.xaml

SampleWindow.xaml.vb

Note that this is a very rudimentary way to implement MVVM and databinding. A more robust practice would be to use a platform like Unity to "inject" the ViewModel into the View.

Chapter 44: Reading compressed textfile on-the-fly
Section 44.1: Reading .gz textfile line after line
.NextLine()This class open a .gz file (usual format of compressed log files) and will return a line at each call of There is no memory usage for temporary decompression, very useful for large file.

Note : there is no failsafe, for readbility purpose.
Chapter 45: Threading
Section 45.1: Performing thread-safe calls using Control.Invoke()
Control.InvokeUsing the () method you may move the execution of a method or function from a background
thread to the thread that the control was created on, which is usually the UI (User Interface) thread. By doing so your code will be queued to run on the control's thread instead, which removes the possibility of concurrency.
Control.InvokeRequiredThe  property should also be checked in order to determine whether you need to invoke, or if the code is already running on the same thread as the control.
InvokeThe () method takes a delegate as its first parameter. A delegate holds the reference, parameter list and return type to another method.
In Visual Basic 2010 (10.0) or higher, lambda expressions can be used to create a delegate method on the fly:

Whereas in Visual Basic 2008 (9.0) or lower, you have to declare the delegate on your own:

Section 45.2: Performing thread-safe calls using Async/Await
If we try to change an object on the UI thread from a different thread we will get a cross-thread operation exception:
Private Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' Cross thread-operation exception as the assignment is executed on a different thread     ' from the UI one:
    Task.Run(Sub() MyButton.Text = Thread.CurrentThread.ManagedThreadId)
End Sub
Before VB 14.0 and .NET 4.5 the solution was invoking the assignment on and object living on the UI thread:
Private Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' This will run the conde on the UI thread:
    MyButton.Invoke(Sub() MyButton.Text = Thread.CurrentThread.ManagedThreadId)
End Sub
With VB 14.0, we can run a Task on a different thread and then have the context restored once the execution is complete and then perform the assignment with Async/Await:
Private Async Sub Button_Click(sender As Object, e As EventArgs) Handles MyButton.Click     ' This will run the code on a different thread then the context is restored     ' so the assignment happens on the UI thread:
    MyButton.Text = Await Task.Run(Function() Thread.CurrentThread.ManagedThreadId)
End Sub

Chapter 46: Multithreading
Section 46.1: Multithreading using Thread Class
This example uses the Thread Class, but multithreaded applications can also be made using BackgroundWorker. The AddNumber, SubstractNumber, and DivideNumber functions will be executed by separate threads:
Edit: Now the UI thread waits for the child threads to finish and shows the result.


Chapter 47: BackgroundWorker
Section 47.1: Using BackgroundWorker
Executing a task with the background worker.
Double Click on the BackgroundWorker control from the Toolbox

This is how the BackgroundWorker appears after adding it.

Double click on the added control to get the BackgroundWorker1_DoWork event and add the code to be executed when the BackgroundWorker is called. Something like this:

Calling the BackgroundWorker to perform the task can be done at any event like Button_Click, Textbox_TextChanged, etc. as follows:

Modify the RunWorkerCompleted event to capture the task finished event of the BackgroundWorker as follows:
Private Sub BackgroundWorker1_RunWorkerCompleted(ByVal sender As Object, ByVal e As
System.ComponentModel.RunWorkerCompletedEventArgs) Handles BackgroundWorker1.RunWorkerCompleted
    MsgBox("Done")
End Sub
This will display a message box saying Done when the worker finishes the task assigned to it.
Section 47.2: Accessing GUI components in BackgroundWorker
You cannot access any GUI components from the BackgroudWorker. For example if you try to do something like this

you will receive a runtime error saying that "Cross-thread operation not valid: Control 'TextBox1' accessed from a thread other than the thread it was created on."
This is because the BackgroundWorker runs your code on another thread in parallel with the main thread, and the GUI components are not thread-safe. You have to set your code to be run on the main thread using the Invoke method, giving it a delegate:
Private Sub BackgroundWorker1_DoWork(sender As Object, e As DoWorkEventArgs)
    Me.Invoke(New MethodInvoker(Sub() Me.TextBox1.Text = "Done"))
End Sub
Or you can use the ReportProgress method of the BackgroundWorker:

Chapter 48: Using BackgroundWorker
Section 48.1: Basic implementation of Background worker class
You need to import System.ComponentModel for using background worker

Then Declare a private variable

You need to create two methods for background worker's DoWork and RunWorkerCompleted events and assign them.

The below sub will be executed when the worker finishes the job

Then within your code add the below lines to start the background worker
    bgWorker = New BackgroundWorker     AddHandler bgWorker.DoWork, AddressOf MyWorker_DoWork     AddHandler bgWorker.RunWorkerCompleted, AddressOf MyWorker_RunWorkerCompleted     bgWorker.RunWorkerAsync()
When you call RunWorkerAsync() function, MyWorker_DoWork will be executed.
Chapter 49: Task-based asynchronous pattern
Section 49.1: Basic usage of Async/Await
You can start some slow process in parallel and then collect the results when they are done:

After two seconds both the results will be available.
Section 49.2: Using TAP with LINQ
AddressOf AsyncMethodTask.WhenAllYou can create an IEnumerable of Task by passing  to the LINQ SELECT method and then start and wait all the results with 
If your method has parameters matching the previous LINQ chain call, they will be automatically mapped.

AddressOf MethodTo map different arguments you can replace  with a lambda:
Function(linqData As Integer) MyNonMatchingMethod(linqData, "Other parameter")
Chapter 50: Debugging your application
Whenever you have a problem in your code, it is always a good idea to know what is going on inside. The class System.Diagnostics.Debug in .Net Framework will help you a lot in this task.
The first advantage of the Debug class is that it produces code only if you build your application in Debug mode. When you build your application in Release mode, no code will be generated from the Debug calls.
Section 50.1: Debug in the console

will produce:

Section 50.2: Indenting your debug output


will produce:

Section 50.3: Debug in a text file
At the beginning of your application, your must add a TextWriterTraceListener to the Listeners list of the Debug class.

All the Debug code produced will be outputed in the Visual Studio console AND in the text file you chose.
If the file is always the same:

The output will be appended to the file every time AND a new file starting with a GUID then your filename will be generated.
Chapter 51: Unit Testing in VB.NET
Section 51.1: Unit Testing for Tax Calculation
This example is divided into two pillars
SalaryCalculation Class : Calculating the net salary after tax deduction
SalaryCalculationTests Class : For testing the method that calculates the net salary
Step 1: Create Class Library, name it WagesLibrary or any appropriate name. Then rename the class to SalaryCalculation
''' ''' Class for Salary Calculations ''' Public Class SalaryCalculation

Step 2 : Create Unit Test Project. Add reference to the created class library and paste the below code

Assert.Equal checks the expected value against the actual calculated value. the value 0.1 is used to allow
tolerance or variation between expected and actual result.
Step 3 : Run the test of the method to see result

Section 51.2: Testing Employee Class assigned and derived Properties
This example has more tests available in unit testing.
Employee.vb (Class Library)


EmployeeTest.vb (Test Project)


Result after running tests


Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
Adam ZuckermanChapters 18 and 31Alessandro MascoloChapter 26Alex B.Chapter 30Allen BinuyaChapter 5Andrew MortonChapter 28AxarydaxChapter 34BabbillumpaChapters 6, 10 and 12Bart JollingChapter 6Berken UsarChapters 20 and 42BjørnChapters 4 and 35BlackwoodChapter 35BunkerMentalityChapter 8Carlos BorauChapter 39Cary BondocChapters 1, 4 and 17Chetan SanghaniChapter 5Cody GrayChapters 2 and 14Dan DrewsChapter 36Darren DaviesChapters 2 and 23DavidChapter 32David WilsonChapter 22debaterChapter 12djvChapters 10 and 38DmanChapters 9 and 40Drarig29Chapter 8DrDonutChapters 9 and 11ElektroStudiosChapter 10FütemireChapters 2, 9, 33 and 35glaubergftChapter 2Happypig375Chapters 29 and 31HarjotChapter 1Imran Ali KhanChapter 12InteXXChapter 33JDCChapters 24 and 32Jonas_HessChapter 15Jones JosephChapter 47KendraChapter 6keronconkChapter 2kodkodChapter 10LogicalFlapsChapters 2 and 30lucamauriChapter 19Luke SheppardChapters 9, 13 and 31MarkChapter 12Mark HurdChapters 3 and 8Martin SolesChapter 19Martin VerjansChapters 1, 3 and 50MattChapter 34Matt WilkoChapters 7, 13, 25, 28, 33 and 35
MatVADChapters 2, 4, 8, 12, 14, 16, 31, 46 and 48Mike RobertsonChapter 16Milliron XChapter 43MisazChapters 13, 14, 18, 25, 36 and 37Nadeem_MKChapter 35NathanChapter 41Nathan TuggyChapter 5Nico AgustaChapters 1, 3, 16 and 31NitramChapter 35Proger_CbskChapters 11 and 44Robert ColumbiaChapters 4, 5, 8 and 21RoyalPotatoChapter 4Ryan ThomasChapter 8Sam AxeChapters 4, 8, 19, 25, 28 and 33sansknwoledgeChapter 29Scott MitchellChapter 12SeandkChapter 9SehnsuchtChapters 2, 3, 8, 11, 18, 26 and 36Shayan ToqraeeChapter 47Shog9Chapter 10SilverShotBeeChapters 12 and 38StardustGogetaChapters 1 and 19Stefano d'AntonioChapters 33, 35, 45 and 49Steven DoggartChapters 8 and 10TuxCopterChapter 8TyCobbChapter 12varocarbasChapter 4vbnet3dChapters 8, 12, 13, 14, 19, 28 and 38VishalChapter 31Visual VincentChapter 45voidChapters 4, 10, 11, 12 and 34VortixDevChapters 8 and 19VV5198722Chapter 27wbadryChapter 51Zev SpitzChapter 36zyabin101Chapter 8
You may also like







GoalKicker.com - Visual Basic(r) .NET Notes for Professionals	1

GoalKicker.com - Visual Basic(r) .NET Notes for Professionals	1

GoalKicker.com - Visual Basic(r) .NET Notes for Professionals	1







