

Contents

Chapter 7: Stack and Heap	26
Section 7.1: Value types in use	26
Section 7.2: Reference types in use	26
Chapter 8: LINQ	28
Section 8.1: SelectMany (flat map)	28
Section 8.2: Where (filter)	29
Section 8.3: Any	29
Section 8.4: GroupJoin	30
Section 8.5: Except	31
Section 8.6: Zip	31
Section 8.7: Aggregate (fold)	31
Section 8.8: ToLookup	32
Section 8.9: Intersect	32
Section 8.10: Concat	32
Section 8.11: All	32
Section 8.12: Sum	33
Section 8.13: SequenceEqual	33
Section 8.14: Min	33
Section 8.15: Distinct	34
Section 8.16: Count	34
Section 8.17: Cast	34
Section 8.18: Range	34
Section 8.19: ThenBy	35
Section 8.20: Repeat	35
Section 8.21: Empty	35
Section 8.22: Select (map)	35
Section 8.23: OrderBy	36
Section 8.24: OrderByDescending	36
Section 8.25: Contains	36
Section 8.26: First (find)	36
Section 8.27: Single	37
Section 8.28: Last	37
Section 8.29: LastOrDefault	37
Section 8.30: SingleOrDefault	38
Section 8.31: FirstOrDefault	38
Section 8.32: Skip	38
Section 8.33: Take	39
Section 8.34: Reverse	39
Section 8.35: OfType	39
Section 8.36: Max	39
Section 8.37: Average	39
Section 8.38: GroupBy	40
Section 8.39: ToDictionary	40
Section 8.40: Union	41
Section 8.41: ToArray	42
Section 8.42: ToList	42
Section 8.43: ElementAt	42
Section 8.44: ElementAtOrDefault	42
Section 8.45: SkipWhile	42
Section 8.46: TakeWhile	43
Section 8.47: DefaultIfEmpty	43
Section 8.48: Join	43
Section 8.49: Left Outer Join	44
Chapter 9: ForEach	46
Section 9.1: Extension method for IEnumerable	46
Section 9.2: Calling a method on an object in a list	46
Chapter 10: Reflection	47
Section 10.1: What is an Assembly?	47
Section 10.2: Compare two objects with reflection	47
Section 10.3: Creating Object and setting properties using reflection	48
Section 10.4: How to create an object of T using Reflection	48
Section 10.5: Getting an attribute of an enum with reflection (and caching it)	48
Chapter 11: Expression Trees	50
Section 11.1: building a predicate of form field == value	50
Section 11.2: Simple Expression Tree Generated by the C# Compiler	50
Section 11.3: Expression for retrieving a static field	51
Section 11.4: InvocationExpression Class	51
Chapter 12: Custom Types	54
Section 12.1: Struct Definition	54
Section 12.2: Class Definition	54
Chapter 13: Code Contracts	56
Section 13.1: Contracts for Interfaces	56
Section 13.2: Installing and Enabling Code Contracts	56
Section 13.3: Preconditions	58
Section 13.4: Postconditions	59
Chapter 14: Settings	60
Section 14.1: AppSettings from ConfigurationSettings in .NET 1.x	60
Section 14.2: Reading AppSettings from ConfigurationManager in .NET 2.0 and later	60
Section 14.3: Introduction to strongly-typed application and user settings support from Visual Studio 	61
Section 14.4: Reading strongly-typed settings from custom section of configuration file	62
Chapter 15: Regular Expressions (System.Text.RegularExpressions)	65
Section 15.1: Check if pattern matches input	65
Section 15.2: Remove non alphanumeric characters from string	65
Section 15.3: Passing Options	65
Section 15.4: Match into groups	65
Section 15.5: Find all matches	65
Section 15.6: Simple match and replace	66
Chapter 16: File Input/Output	67
Section 16.1: C# File.Exists()	67
Section 16.2: VB WriteAllText	67
Section 16.3: VB StreamWriter	67
Section 16.4: C# StreamWriter	67
Section 16.5: C# WriteAllText()	68
Chapter 17: System.IO	69
Section 17.1: Reading a text file using StreamReader	69
Section 17.2: Serial Ports using System.IO.SerialPorts	69
Section 17.3: Reading/Writing Data Using System.IO.File	70
Chapter 18: System.IO.File class	72
Section 18.1: Delete a file	72
Section 18.2: Strip unwanted lines from a text file	73
Section 18.3: Convert text file encoding	73
Section 18.4: Enumerate files older than a specified amount	74
Section 18.5: Move a File from one location to another	74
Chapter 19: Reading and writing Zip files	76
Section 19.1: Listing ZIP contents	76
Section 19.2: Extracting files from ZIP files	76
Section 19.3: Updating a ZIP file	76
Chapter 20: Managed Extensibility Framework	78
Section 20.1: Connecting (Basic)	78
Section 20.2: Exporting a Type (Basic)	78
Section 20.3: Importing (Basic)	79
Chapter 21: SpeechRecognitionEngine class to recognize speech	80
Section 21.1: Asynchronously recognizing speech based on a restricted set of phrases	80
Section 21.2: Asynchronously recognizing speech for free text dictation	80
Chapter 22: System.Runtime.Caching.MemoryCache (ObjectCache)	81
Section 22.1: Adding Item to Cache (Set)	81
Section 22.2: System.Runtime.Caching.MemoryCache (ObjectCache)	81
Chapter 23: System.Reflection.Emit namespace	83
Section 23.1: Creating an assembly dynamically	83
Chapter 24: .NET Core	86
Section 24.1: Basic Console App	86
Chapter 25: ADO.NET	87
Section 25.1: Best Practices - Executing Sql Statements	87
Section 25.2: Executing SQL statements as a command	88
Section 25.3: Using common interfaces to abstract away vendor specific classes	89
Chapter 26: Dependency Injection	90
Section 26.1: How Dependency Injection Makes Unit Testing Easier	90
Section 26.2: Dependency Injection - Simple example	90
Section 26.3: Why We Use Dependency Injection Containers (IoC Containers)	91
Chapter 27: Platform Invoke	94
Section 27.1: Marshaling structs	94
Section 27.2: Marshaling unions	95
Section 27.3: Calling a Win32 dll function	96
Section 27.4: Using Windows API	97
Section 27.5: Marshalling arrays	97
Chapter 28: NuGet packaging system	98
Section 28.1: Uninstalling a package from one project in a solution	98
Section 28.2: Installing a specific version of a package	98
Section 28.3: Adding a package source feed (MyGet, Klondike, ect)	98
Section 28.4: Installing the NuGet Package Manager	98
Section 28.5: Managing Packages through the UI	99
Section 28.6: Managing Packages through the console	99
Section 28.7: Updating a package	99
Section 28.8: Uninstalling a package	100
Section 28.9: Uninstall a specific version of package	100
Chapter 29: Globalization in ASP.NET MVC using Smart internationalization for ASP.NET 	101
Section 29.1: Basic configuration and setup	101
Chapter 30: System.Net.Mail	103
Section 30.1: MailMessage	103
Section 30.2: Mail with Attachment	104
Chapter 31: Using Progress<T> and IProgress<T>	105
Section 31.1: Simple Progress reporting	105
Section 31.2: Using IProgress<T>	105
Chapter 32: JSON Serialization	107
Section 32.1: Deserialization using System.Web.Script.Serialization.JavaScriptSerializer	107
Section 32.2: Serialization using Json.NET	107
Section 32.3: Serialization-Deserialization using Newtonsoft.Json	108
Section 32.4: Deserialization using Json.NET	108
Section 32.5: Dynamic binding	108
Section 32.6: Serialization using Json.NET with JsonSerializerSettings	109
Chapter 33: JSON in .NET with Newtonsoft.Json	110
Section 33.1: Deserialize an object from JSON text	110
Section 33.2: Serialize object into JSON	110
Chapter 34: XmlSerializer	111
Section 34.1: Formatting: Custom DateTime format	111
Section 34.2: Serialize object	111
Section 34.3: Deserialize object	111
Section 34.4: Behaviour: Map array name to property (XmlArray)	111
Section 34.5: Behaviour: Map Element name to Property	112
Section 34.6: Eciently building multiple serializers with derived types specified dynamically	112
Chapter 35: VB Forms	115
Section 35.1: Hello World in VB.NET Forms	115
Section 35.2: For Beginners	115
Section 35.3: Forms Timer	115
Chapter 36: JIT compiler	118
Section 36.1: IL compilation sample	118
Chapter 37: CLR	121
Section 37.1: An introduction to Common Language Runtime	121
Chapter 38: TPL Dataflow	122
Section 38.1: Asynchronous Producer Consumer With A Bounded BuerBlock	122
Section 38.2: Posting to an ActionBlock and waiting for completion	122
Section 38.3: Linking blocks to create a pipeline	122
Section 38.4: Synchronous Producer/Consumer with BuerBlock<T>	123
Chapter 39: Threading	125
Section 39.1: Accessing form controls from other threads	125
Chapter 40: Process and Thread anity setting	127
Section 40.1: Get process anity mask	127
Section 40.2: Set process anity mask	127
Chapter 41: Parallel processing using .Net framework	129
Section 41.1: Parallel Extensions	129
Chapter 42: Task Parallel Library (TPL)	130
Section 42.1: Basic producer-consumer loop (BlockingCollection)	130
Section 42.2: Parallel.Invoke	130
Section 42.3: Task: Returning a value	131
Section 42.4: Parallel.ForEach	131
Section 42.5: Parallel.For	131
Section 42.6: Task: basic instantiation and Wait	132
Section 42.7: Task.WhenAll	132
Section 42.8: Flowing execution context with AsyncLocal	132
Section 42.9: Parallel.ForEach in VB.NET	133
Section 42.10: Task: WaitAll and variable capturing	133
Section 42.11: Task: WaitAny	134
Section 42.12: Task: handling exceptions (using Wait)	134
Section 42.13: Task: handling exceptions (without using Wait)	134
Section 42.14: Task: cancelling using CancellationToken	135
Section 42.15: Task.WhenAny	136
Chapter 43: Task Parallel Library (TPL) API Overviews	137
Section 43.1: Perform work in response to a button click and update the UI	137
Chapter 44: Synchronization Contexts	138
Section 44.1: Execute code on the UI thread after performing background work	138
Chapter 45: Memory management	139
Section 45.1: Use SafeHandle when wrapping unmanaged resources	139
Section 45.2: Unmanaged Resources	139
Chapter 46: Garbage Collection	141
Section 46.1: A basic example of (garbage) collection	141
Section 46.2: Live objects and dead objects - the basics	141
Section 46.3: Multiple dead objects	142
Section 46.4: Weak References	142
Section 46.5: Dispose() vs. finalizers	143
Section 46.6: Proper disposal and finalization of objects	144
Chapter 47: Exceptions	146
Section 47.1: Catching and rethrowing caught exceptions	146
Section 47.2: Using a finally block	147
Section 47.3: Exception Filters	147
Section 47.4: Rethrowing an exception within a catch block	148
Section 47.5: Throwing an exception from a dierent method while preserving its information	148
Section 47.6: Catching an exception	149
Chapter 48: System.Diagnostics	150
Section 48.1: Run shell commands	150
Section 48.2: Send Command to CMD and Receive Output	150
Section 48.3: Stopwatch	152
Chapter 49: Encryption / Cryptography	153
Section 49.1: Encryption and Decryption using Cryptography (AES)	153
Section 49.2: RijndaelManaged	154
Section 49.3: Encrypt and decrypt data using AES (in C#)	155
Section 49.4: Create a Key from a Password / Random SALT (in C#)	158
Chapter 50: Work with SHA1 in C#	161
Section 50.1: #Generate SHA1 checksum of a file	161
Section 50.2: #Generate hash of a text	161
Chapter 51: Unit testing	162
Section 51.1: Adding MSTest unit testing project to an existing solution	162
Section 51.2: Creating a sample test method	162
Chapter 52: Write to and read from StdErr stream	163
Section 52.1: Write to standard error output using Console	163
Section 52.2: Read from standard error of child process	163
Chapter 53: Upload file and POST data to webserver	164
Section 53.1: Upload file with WebRequest	164
Chapter 54: Networking	166
Section 54.1: Basic TCP chat (TcpListener, TcpClient, NetworkStream)	166
Section 54.2: Basic SNTP client (UdpClient)	167
Chapter 55: HTTP servers	169
Section 55.1: Basic read-only HTTP file server (ASP.NET Core)	169
Section 55.2: Basic read-only HTTP file server (HttpListener)	170
Chapter 56: HTTP clients	173
Section 56.1: Reading GET response as string using System.Net.HttpClient	173
Section 56.2: Basic HTTP downloader using System.Net.Http.HttpClient	173
Section 56.3: Reading GET response as string using System.Net.HttpWebRequest	174
Section 56.4: Reading GET response as string using System.Net.WebClient	174
Section 56.5: Sending a POST request with a string payload using System.Net.HttpWebRequest	174
Section 56.6: Sending a POST request with a string payload using System.Net.WebClient	175
Section 56.7: Sending a POST request with a string payload using System.Net.HttpClient	175
Chapter 57: Serial Ports	176
Section 57.1: Basic operation	176
Section 57.2: List available port names	176
Section 57.3: Asynchronous read	176
Section 57.4: Synchronous text echo service	176
Section 57.5: Asynchronous message receiver	177
Appendix A: Acronym Glossary	180
Section A.1: .Net Related Acronyms	180
Credits	181
You may also like	184


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/DotNETFrameworkBook
This .NET Framework Notes for Professionals book is compiled from Stack Overflow Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official .NET Framework group(s) or company(s) nor Stack
Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with .NET Framework
.NET
Version Release Date
1.0	2002-02-13
1.1	2003-04-24
2.0	2005-11-07
3.0	2006-11-06
3.5	2007-11-19
3.5 SP1 2008-08-11
4.0	2010-04-12
4.5	2012-08-15
4.5.1	2013-10-17
4.5.2	2014-05-05
4.6	2015-07-20
4.6.1	2015-11-17
4.6.2	2016-08-02
4.7	2017-04-05
4.7.1	2017-10-17
Compact Framework
Version Release Date
1.0	2000-01-01
2.0	2005-10-01
3.5	2007-11-19
3.7	2009-01-01
3.9	2013-06-01
Micro Framework
Version Release Date
4.2	2011-10-04
4.3	2012-12-04
4.4	2015-10-20
Section 1.1: Hello World in C#

Console.WriteLine has several overloads. In this case, the string "Hello World" is the parameter, and it will output
.ToStringthe "Hello World" to the standard out stream during execution. Other overloads may call the  of the argument before writing to the stream. See the .NET Framework Documentation for more information. Live Demo in Action at .NET Fiddle
Introduction to C# Section 1.2: Hello World in F#

Live Demo in Action at .NET Fiddle
Introduction to F# Section 1.3: Hello World in Visual Basic .NET

Live Demo in Action at .NET Fiddle
Introduction to Visual Basic .NET
Section 1.4: Hello World in C++/CLI

Section 1.5: Hello World in IL


Section 1.6: Hello World in PowerShell

Introduction to PowerShell
Section 1.7: Hello World in Nemerle

Section 1.8: Hello World in Python (IronPython)

Section 1.9: Hello World in Oxygene

Section 1.10: Hello World in Boo

Chapter 2: Strings
Section 2.1: Count characters
System.CharIf you need to count characters then, for the reasons explained in Remarks section, you can't simply use Length property because it's the length of the array of  which are not characters but code-units (not Unicode code-points nor graphemes). Correct code is then:

EnumerateCharactersA small optimization may rewrite () extension method specifically for this purpose:

Section 2.2: Count distinct characters
If you need to count distinct characters then, for the reasons explained in Remarks section, you can't simply use
System.Chartext.Distinct().CountLength property because it's the length of the array of  which are not characters but code-units (not Unicode code-points nor graphemes). If, for example, you simply write () you will get incorrect results, correct code:

One step further is to count occurrences of each character, if performance aren't an issue you may simply do it like this (in this example regardless of case):
var frequencies = text.EnumerateCharacters()
    .GroupBy(x => x, StringComparer.CurrentCultureIgnoreCase)
    .Select(x => new { Character = x.Key, Count = x.Count() };
Section 2.3: Convert string to/from another encoding
System.CharSystem.Byte.NET strings contain  (UTF-16 code-units). If you want to save (or manage) text with another encoding you have to work with an array of .
System.Text.Encoder and System.Text.DecoderConversions are performed by classes derived from  which,
byteSystem.Stringtogether, can convert to/from another encoding (from a byte X encoded array [] to an UTF-16 encoded  and vice-versa).
System.Text.EncodingBecause the encoder/decoder usually works very close to each other they're grouped together in a class derived from , derived classes offer conversions to/from popular encodings (UTF-8, UTF-16 and so on).
Examples:
Convert a string to UTF-8


Change encoding of an existing text file
This code will read content of an UTF-8 encoded text file and save it back encoded as UTF-16. Note that this code is not optimal if file is big because it will read all its content into memory:

Section 2.4: Comparing strings
Despite String is a reference type == operator compares string values rather than references.
As you may know string is just an array of characters. But if you think that strings equality check and comparison is made character by character, you are mistaken. This operation is culture specific (see Remarks below): some character sequences can be treated as equal depending on the culture.
Think twice before short circuiting equality check by comparing Length properties of two strings!
String.EqualsUse overloads of  method which accept additional StringComparison enumeration value, if you need to change default behavior. Section 2.5: Count occurrences of a character
Because of the reasons explained in Remarks section you can't simply do this (unless you want to count occurrences of a specific code-unit):

You need a more complex function:

Note that string comparison (in contrast to character comparison which is culture invariant) must always be performed according to rules to a specific culture. Section 2.6: Split string into fixed length blocks
System.CharWe cannot break a string into arbitrary points (because a  may not be valid alone because it's a combining character or part of a surrogate) then code must take that into account (note that with length I mean the number of graphemes not the number of code-units):

Section 2.7: Object.ToString() virtual method
ToStringEverything in .NET is an object, hence every type has () method defined in Object class which can be overridden. Default implementation of this method just returns the name of the type:

ToString() is implicitly called when concatinating value with a string:

The result of this method is also extensively used by debugging tools. If, for some reason, you do not want to override this method, but want to customize how debugger shows the value of your type, use DebuggerDisplay Attribute (MSDN):

Section 2.8: Immutability of strings
Strings are immutable. You just cannot change existing string. Any operation on the string crates a new instance of the string having new value. It means that if you need to replace a single character in a very long string, memory will be allocated for a new value.

If you need to perform many operations with string value, use StringBuilder class which is designed for efficient strings manipulation:


Chapter 3: DateTime parsing
Section 3.1: ParseExact

CultureInfo.CurrentCultureNote that passing  as the third parameter is identical to passing null. Or, you can pass a specific culture.
Format Strings
Input string can be in any format that matches the format string

Any characters that are not format specifiers are treated as literals

Case matters for format specifiers

Note that the month and minute values were parsed into the wrong destinations.
Single-character format strings must be one of the standard formats
var date = DateTime.ParseExact("11/24/2015", "d", new CultureInfo("en-US")); var date = DateTime.ParseExact("2015-11-24T10:15:45", "s", null); var date = DateTime.ParseExact("2015-11-24 10:15:45Z", "u", null);
Exceptions
ArgumentNullException
var date = DateTime.ParseExact(null, "yyyy-MM-dd", null); var date = DateTime.ParseExact("2015-11-24", null, null);
FormatException
var date = DateTime.ParseExact("", "yyyy-MM-dd", null); var date = DateTime.ParseExact("2015-11-24", "", null); var date = DateTime.ParseExact("2015-0C-24", "yyyy-MM-dd", null); var date = DateTime.ParseExact("2015-11-24", "yyyy-QQ-dd", null);
// Single-character format strings must be one of the standard formats var date = DateTime.ParseExact("2015-11-24", "q", null);
// Format strings must match the input exactly* (see next section) var date = DateTime.ParseExact("2015-11-24", "d", null); // Expects 11/24/2015 or 24/11/2015 for most cultures
Handling multiple possible formats
var date = DateTime.ParseExact("2015-11-24T10:15:45",
  new [] { "s", "t", "u", "yyyy-MM-dd" }, // Will succeed as long as input matches one of these   CultureInfo.CurrentCulture, DateTimeStyles.None);

Section 3.2: TryParse
This method accepts a string as input, attempts to parse it into a DateTime, and returns a Boolean result indicating success or failure. If the call succeeds, the variable passed as the out parameter is populated with the parsed result.
DateTime.MinValueIf the parse fails, the variable passed as the out parameter is set to the default value, .
TryParse(string, out DateTime)

This method attempts to parse the input string based on the system regional settings and known formats such as ISO 8601 and other common formats.
DateTime.TryParse("11/24/2015 14:28:42", out parsedValue); // true DateTime.TryParse("2015-11-24 14:28:42", out parsedValue); // true
DateTime.TryParse("2015-11-24T14:28:42", out parsedValue); // true
DateTime.TryParse("Sat, 24 Nov 2015 14:28:42", out parsedValue); // true
Since this method does not accept culture info, it uses the system locale. This can lead to unexpected results.

Note that if you are in the US, you might be surprised that the parsed result is November 10, not October 11.
TryParse(string, IFormatProvider, DateTimeStyles, out DateTime)
if (DateTime.TryParse(" monkey ", new CultureInfo("en-GB"),
    DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite, out parsedValue)
{
    Console.WriteLine("Apparently, ' monkey ' is a date/time value. Who knew?");
}
Unlike its sibling method, this overload allows a specific culture and style(s) to be specified. Passing null for the IFormatProvider parameter uses the system culture.
Exceptions
Note that it is possible for this method to throw an exception under certain conditions. These relate to the parameters introduced for this overload: IFormatProvider and DateTimeStyles.
NotSupportedException: IFormatProvider specifies a neutral culture
ArgumentException: DateTimeStyles is not a valid option, or contains incompatible flags such as AssumeLocal and AssumeUniversal.
Section 3.3: TryParseExact
This method behaves as a combination of TryParse and ParseExact: It allows custom format(s) to be specified, and returns a Boolean result indicating success or failure rather than throwing an exception if the parse fails.
TryParseExact(string, string, IFormatProvider, DateTimeStyles, out DateTime)
This overload attempts to parse the input string against a specific format. The input string must match that format in order to be parsed.
DateTime.TryParseExact("11242015", "MMddyyyy", null, DateTimeStyles.None, out parsedValue); // true
TryParseExact(string, string[], IFormatProvider, DateTimeStyles, out DateTime)
This overload attempts to parse the input string against an array of formats. The input string must match at least one format in order to be parsed.
DateTime.TryParseExact("11242015", new [] { "yyyy-MM-dd", "MMddyyyy" }, null, DateTimeStyles.None, out parsedValue); // true

Chapter 4: Dictionaries
Section 4.1: Initializing a Dictionary with a Collection Initializer

Section 4.2: Adding to a Dictionary

Alternatively they can be added/set via the an indexer. (An indexer internally looks like a property, having a get and set, but takes a parameter of any type which is specified between the brackets) :

Unlike the Add method which throws an exception, if a key is already contained in the dictionary, the indexer just replaces the existing value.
ConcurrentDictionary<TKey, TValue>For thread-safe dictionary use :
var dict = new ConcurrentDictionary<int, string>(); dict.AddOrUpdate(1, "First", (oldKey, oldValue) => "First");
Section 4.3: Getting a value from a dictionary
Given this setup code:


You may want to read the value for the entry with key 1. If key doesn't exist getting a value will throw KeyNotFoundException, so you may want to first check for that with ContainsKey:

This has one disadvantage: you will search through your dictionary twice (once to check for existence and one to read the value). For a large dictionary this can impact performance. Fortunately both operations can be performed together:

Section 4.4: Make a Dictionary<string, T> with Case-
Insensivitve keys
var MyDict = new Dictionary<string,T>(StringComparison.InvariantCultureIgnoreCase)
Section 4.5: IEnumerable to Dictionary (≥ .NET 3.5)
Create a Dictionary<TKey, TValue> from an IEnumerable<T>:



Section 4.6: Enumerating a Dictionary
You can enumerate through a Dictionary in one of 3 ways:
Using KeyValue pairs

Using Keys

Using Values

Section 4.7: ConcurrentDictionary<TKey, TValue> (from .NET
4.0)
Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.
Creating an instance
Dictionary<TKey, TValueCreating an instance works pretty much the same way as with >, e.g.:

Adding or Updating
You might be surprised, that there is no Add method, but instead there is AddOrUpdate with 2 overloads:
AddOrUpdate(TKey key, TValue, Func<TKey, TValue, TValue> addValue(1) ) - Adds a key/value pair if the key does not already exist, or updates a key/value pair by using the specified function if the key already exists.
AddOrUpdate(TKey key, Func<TKey, TValue> addValue, Func<TKey, TValue, TValue> updateValueFactory(2) )
- Uses the specified functions to add a key/value pair to the if the key does not already exist, or to update a key/value pair if the key already exists.
Adding or updating a value, no matter what was the value if it was already present for given key (1): string addedValue = dict.AddOrUpdate(1, "First", (updateKey, valueOld) => "First");
Adding or updating a value, but now altering the value in update, based on the previous value (1):
string addedValue2 = dict.AddOrUpdate(1, "First", (updateKey, valueOld) => $"{valueOld} Updated");
Using the overload (2) we can also add new value using a factory:
string addedValue3 = dict.AddOrUpdate(1, (key) => key == 1 ? "First" : "Not First", (updateKey, valueOld) => $"{valueOld} Updated");
Getting value
Dictionary<TKey,TValueGetting a value is the same as with the >:

Getting or Adding a value
There are two mehod overloads, that will get or add a value in a thread-safe manner.
Get value with key 2, or add value "Second" if the key is not present:

Using a factory for adding a value, if value is not present: string theValue2 = dict.GetOrAdd(2, (key) => key == 2 ? "Second" : "Not Second." );
Section 4.8: Dictionary to List
Creating a list of KeyValuePair:
Dictionary<int, int> dictionary = new Dictionary<int, int>(); List<KeyValuePair<int, int>> list = new List<KeyValuePair<int, int>>(); list.AddRange(dictionary);
Creating a list of keys:

Creating a list of values:

Section 4.9: Removing from a Dictionary
Given this setup code:

Use the Remove method to remove a key and its associated value.

Executing this code removes the key 2 and it's value from the dictionary. Remove returns a boolean value indicating whether the specified key was found and removed from the dictionary. If the key does not exist in the dictionary, nothing is removed from the dictionary, and false is returned (no exception is thrown).
It's incorrect to try and remove a key by setting the value for the key to null.

This will not remove the key. It will just replace the previous value with a value of null.
To remove all keys and values from a dictionary, use the Clear method.

After executing Clear the dictionary's Count will be 0, but the internal capacity remains unchanged. Section 4.10: ContainsKey(TKey)
ContainsKey(TKeyTo check if a Dictionary has an specifique key, you can call the method ) and provide the key of TKey type. The method returns a bool value when the key exists on the dictionary. For sample:

And check if a C2 exists on the Dictionary:

Dictionary<TKey, TValueThe ContainsKey method is available on the generic version >.
Section 4.11: ConcurrentDictionary augmented with Lazy'1 reduces duplicated computation
Problem
ConcurrentDictionary shines when it comes to instantly returning of existing keys from cache, mostly lock free, and contending on a granular level. But what if the object creation is really expensive, outweighing the cost of context switching, and some cache misses occur?
If the same key is requested from multiple threads, one of the objects resulting from colliding operations will be eventually added to the collection, and the others will be thrown away, wasting the CPU resource to create the object and memory resource to store the object temporarily. Other resources could be wasted as well. This is really bad.
Solution
ConcurrentDictionary<TKey, TValue> with Lazy<TValueWe can combine >. The idea is that ConcurrentDictionary
GetOrAdd method can only return the value which was actually added to the collection. The loosing Lazy objects could be wasted in this case too, but that's not much problem, as the Lazy object itself is relatively unexpensive. The Value property of the losing Lazy is never requested, because we are smart to only request the Value property of the one actually added to the collection - the one returned from the GetOrAdd method:

Caching of XmlSerializer objects can be particularly expensive, and there is a lot of contention at the application startup too. And there is more to this: if those are custom serializers, there will be a memory leak too for the rest of the process lifecycle. The only benefit of the ConcurrentDictionary in this case is that for the rest of the process lifecycle there will be no locks, but application startup and memory usage would be inacceptable. This is a job for our ConcurrentDictionary, augmented with Lazy:

Chapter 5: Collections
Section 5.1: Using collection initializers
Some collection types can be initialized at the declaration time. For example, the following statement creates and initializes the numbers with some integers:
List<int> numbers = new List<int>(){10, 9, 8, 7, 7, 6, 5, 10, 4, 3, 2, 1};
Internally, the C# compiler actually converts this initialization to a series of calls to the Add method. Consequently, you can use this syntax only for collections that actually support the Add method.
Stack<T> and Queue		The 	<T> classes do not support it.
Dictionary<TKey, TValueFor complex collections such as the > class, that take key/value pairs, you can specify each key/value pair as an anonymous type in the initializer list.
Dictionary<int, string> employee = new Dictionary<int, string>()
     {{44, "John"}, {45, "Bob"}, {47, "James"}, {48, "Franklin"}};
The first item in each pair is the key, and the second is the value. Section 5.2: Stack
There is a collection in .Net used to manage values in a Stack that uses the LIFO (last-in first-out) concept. The
Push(T item) which is used to add elements in the stack and Popbasics of stacks is the method () which is used to
get the last element added and remove it from the stack. The generic version can be used like the following code for a queue of strings. First, add the namespace:

and use it:

There is a non generic version of the type, which works with objects.
The namespace is:

And a code sample of non generic stack:

There is also a method called Peek() which returns the last element added but without removing it from the Stack.

It is possible to iterate on the elements on the stack and it will respect the order of the stack (LIFO).

The output (without removing):

Section 5.3: Creating an initialized List with Custom Types

List<ModelHere we have a Class with no constructor with two properties: Name and a nullable boolean property Selected. If we wanted to initialize a >, there are a few different ways to execute this.

Here, we are creating several new instances of our Model class, and initializing them with data. What if we added a constructor?

This allows us to initialize our List a little differently.

What about a Class where one of the properties is a class itself?

Notice we reverted the constructor on the Model class to simplify the example a little bit.


List<ExtendedModel> with Collection<ExtendedModel>, ExtendedModelNote that we can interchange our [],
object       [], or even simply []. Section 5.4: Queue
There is a collection in .Net used to manage values in a Queue that uses the FIFO (first-in first-out) concept. The
Enqueue(T item) which is used to add elements in the queue and Dequeuebasics of queues is the method () which
is used to get the first element and remove it from the queue. The generic version can be used like the following code for a queue of strings.
First, add the namespace:

and use it:

There is a non generic version of the type, which works with objects.
The namespace is:

Adn a code sample fo non generic queue:

There is also a method called Peek() which returns the object at the beginning of the queue without removing it the elements.

The output (without removing):


Chapter 6: ReadOnlyCollections
Section 6.1: Creating a ReadOnlyCollection
Using the Constructor
A ReadOnlyCollection is created by passing an existing IList object into the constructor:
var groceryList = new List<string> { "Apple", "Banana" };
var readOnlyGroceryList = new ReadOnlyCollection<string>(groceryList);
Using LINQ
AsReadOnly()Additionaly, LINQ provides an  extension method for IList objects:

Note
Typically, you want to maintain the source collection privately and allow public access to the ReadOnlyCollection. While you could create a ReadOnlyCollection from an in-line list, you would be unable to modify the collection after you created it.
var readOnlyGroceryList = new List<string> {"Apple", "Banana"}.AsReadOnly(); // Great, but you will not be able to update the grocery list because //  you do not have a reference to the source list anymore!
If you find yourself doing this, you may want to consider using another data structure, such as an ImmutableCollection. Section 6.2: Updating a ReadOnlyCollection
A ReadOnlyCollection cannot be edited directly. Instead, the source collection is updated and the
ReadOnlyCollection will reflect these changes. This is the key feature of the ReadOnlyCollection.
var groceryList = new List<string> { "Apple", "Banana" }; var readOnlyGroceryList = new ReadOnlyCollection<string>(groceryList); var itemCount = readOnlyGroceryList.Count;  // There are currently 2 items
//readOnlyGroceryList.Add("Candy");         // Compiler Error - Items cannot be added to a ReadOnlyCollection object groceryList.Add("Vitamins");                // ..but they can be added to the original collection
itemCount = readOnlyGroceryList.Count;      // Now there are 3 items
var lastItem = readOnlyGroceryList.Last();  // The last item on the read only list is now "Vitamins"
View Demo
Section 6.3: Warning: Elements in a ReadOnlyCollection are not inherently read-only
If the source collection is of a type that is not immutable, elements accessed through a ReadOnlyCollection can be modified.

View Demo
Chapter 7: Stack and Heap
Section 7.1: Value types in use
Value types simply contain a value.
All value types are derived from the System.ValueType class, and this includes most of the built in types.
When creating a new value type, the an area of memory called the stack is used.
The stack will grow accordingly, by the size the declared type. So for example, an int will always be allocated 32 bits of memory on the stack. When the value type is no longer in scope, the space on the stack will be deallocated.
The code below demonstrates a value type being assigned to a new variable. A struct is being used as a convenient way to create a custom value type (the System.ValueType class cannot be otherwise extended).
The important thing to understand is that when assigning a value type, the value itself copied to the new variable, meaning we have two distinct instances of the object, that cannot affect each other.

Section 7.2: Reference types in use
Reference types are comprised of both a reference to a memory area, and a value stored within that area. This is analogous to pointers in C/C++.
All reference types are stored on what is known as the heap.
The heap is simply a managed area of memory where objects are stored. When a new object is instantiated, a part of the heap will be allocated for use by that object, and a reference to that location of the heap will be returned. The heap is managed and maintained by the garbage collector, and does not allow for manual intervention.
In addition to the memory space required for the instance itself, additional space is required to store the reference itself, along with additional temporary information required by the .NET CLR.
The code below demonstrates a reference type being assigned to a new variable. In this instance, we are using a class, all classes are reference types (even if static).
When a reference type is assigned to another variable, it is the reference to the object that is copied over, not the value itself. This is an important distinction between value types and reference types.
The implications of this are that we now have two references to the same object. Any changes to the values within that object will be reflected by both variables.

Chapter 8: LINQ
LINQ (Language Integrated Query) is an expression that retrieves data from a data source. LINQ simplifies this situation by offering a consistent model for working with data across various kinds of data sources and formats. In a LINQ query, you are always working with objects. You use the same basic coding patterns to query and transform data in XML documents, SQL databases, ADO.NET Datasets, .NET collections, and any other format for which a provider is available. LINQ can be used in C# and VB.
Section 8.1: SelectMany (flat map)
Enumerable.Select returns an output element for every input element. Whereas Enumerable.SelectManyproduces a variable number of output elements for each input element. This means that the output sequence may contain more or fewer elements than were in the input sequence.
Enumerable.SelectEnumerable.SelectManyLambda expressions passed to  must return a single item. Lambda expressions passed to  must produce a child sequence. This child sequence may contain a varying number of
elements for each element in the input sequence.
Example

Output:
		1,2,3,4,5,6
View Demo
Enumerable.SelectMany can also be achieved with a syntax-based query using two consecutive from clauses:

Section 8.2: Where (filter)
This method returns an IEnumerable with all the elements that meets the lambda expression Example

Output:
		Foo,Fizz
View Demo
Section 8.3: Any
Returns true if the collection has any elements that meets the condition in the lambda expression:

Section 8.4: GroupJoin

//Foobuzz's projects: Hello World 3D, Super Fizzbuzz Maker
//Barfizz's projects: Citizen Kane - The action game, Pro Pong 2016
Section 8.5: Except

Section 8.6: Zip
.NET Version ≥ 4.0

Section 8.7: Aggregate (fold)
Generating a new object in each step:

Using the same object in all steps:

Using a result selector:
var commaSeparatedElements3 = elements.Aggregate(     seed: new StringBuilder(),     func: (seed, element) => seed.Append($"{element},"),     resultSelector: (seed) => seed.ToString());
Console.WriteLine(commaSeparatedElements3);  //1,2,3,4,5,
If a seed is omitted, the first element becomes the seed:

Section 8.8: ToLookup

Section 8.9: Intersect

Section 8.10: Concat

Note that duplicates are kept in the result. If this is undesirable, use Union instead.
Section 8.11: All


Note that the All method functions by checking for the first element to evaluate as false according to the predicate. Therefore, the method will return true for any predicate in the case that the set is empty:

Section 8.12: Sum

Section 8.13: SequenceEqual

Section 8.14: Min

Section 8.15: Distinct

Section 8.16: Count

Section 8.17: Cast
IEnumerableCast is different from the other methods of Enumerable in that it is an extension method for IEnumerable, not for <T>. Thus it can be used to convert instances of the former into instances of the later.
IEnumerableThis does not compile since ArrayList does not implement <T>:

This works as expected:

Cast does not perform conversion casts. The following compiles but throws InvalidCastException at runtime:

The proper way to perform a converting cast to a collection is as follows:

Section 8.18: Range
The two parameters to Range are the first number and the count of elements to produce (not the last number).

Section 8.19: ThenBy
ThenBy can only be used after a OrderBy clause allowing to order using multiple criteria

Section 8.20: Repeat
Enumerable.Repeat generates a sequence of a repeated value. In this example it generates "Hello" 4 times.

Section 8.21: Empty
To create an empty IEnumerable of int:

This empty IEnumerable is cached for each Type T, so that:
Enumerable.Empty<decimal>() == Enumerable.Empty<decimal>(); // This is True
Enumerable.Empty<int>() == Enumerable.Empty<decimal>();     // This is False
Section 8.22: Select (map)


This type of function is usually called map in functional programming languages.
Section 8.23: OrderBy

Section 8.24: OrderByDescending

Section 8.25: Contains

Section 8.26: First (find)

The following throws InvalidOperationException with message "Sequence contains no matching element":

Section 8.27: Single

The following throws InvalidOperationException since there is more than one element in the sequence:

Section 8.28: Last


Section 8.29: LastOrDefault


Section 8.30: SingleOrDefault


Section 8.31: FirstOrDefault

Section 8.32: Skip
Skip will enumerate the first N items without returning them. Once item number N+1 is reached, Skip starts returning every enumerated item:

Section 8.33: Take
This method takes the first n elements from an enumerable.

Section 8.34: Reverse

Section 8.35: OfType

Section 8.36: Max

Section 8.37: Average

This method calculates the average of enumerable of numbers.


This method calculates the average of enumerable using delegated function.
Section 8.38: GroupBy

Group invoices by country, generating a new object with the number of record, total paid, and average paid
var a = db.Invoices.GroupBy(i => i.Country)           .Select(g => new { Country = g.Key,
                             Count = g.Count(),
                             Total = g.Sum(i => i.Paid),
                             Average = g.Average(i => i.Paid) });
If we want only the totals, no group
var a = db.Invoices.GroupBy(i => 1)           .Select(g => new { Count = g.Count(),
                             Total = g.Sum(i => i.Paid),
                             Average = g.Average(i => i.Paid) });
If we need several counts
var a = db.Invoices.GroupBy(g => 1)           .Select(g => new { High = g.Count(i => i.Paid >= 1000),
                             Low = g.Count(i => i.Paid < 1000),
                             Sum = g.Sum(i => i.Paid) });
Section 8.39: ToDictionary
Returns a new dictionary from the source IEnumerable using the provided keySelector function to determine keys.
Will throw an ArgumentException if keySelector is not injective(returns a unique value for each member of the source collection.) There are overloads which allow one to specify the value to be stored as well as the key.

Dictionary<TKey,TValSpecifying just a key selector function will create a > with TKey the return Type of the key selector, TVal the original object Type, and the original object as the stored value.

Dictionary<TKey,TValSpecifying a value selector function as well will create a > with TKey still the return type of the key selector, but TVal now the return type of the value selector function, and the returned value as the stored value.

As stated above, the keys returned by the key selector must be unique. The following will throw an exception.

If a unique key can not be given for the source collection, consider using ToLookup instead. On the surface,
ToLookup behaves similarly to ToDictionary, however, in the resulting Lookup each key is paired with a collection of values with matching keys.
Section 8.40: Union

Note that duplicates are removed from the result. If this is undesirable, use Concat instead.
Section 8.41: ToArray

Section 8.42: ToList

Section 8.43: ElementAt

Section 8.44: ElementAtOrDefault

Section 8.45: SkipWhile


Section 8.46: TakeWhile

Section 8.47: DefaultIfEmpty

Section 8.48: Join


Section 8.49: Left Outer Join



Chapter 9: ForEach
Section 9.1: Extension method for IEnumerable
ForEach() is defined on the List<T> class, but not on IQueryable<T> or IEnumerable<T>. You have two choices in those cases:
ToList first
The enumeration (or query) will be evaluated, copying the results into a new list or calling the database. The method is then called on each item.

This method has obvious memory usage overhead, as an intermediate list is created.
Extension method Write an extension method:

Use:

Caution: The Framework's LINQ methods have been designed with the intention of being pure, which means they do not produce side effects. The ForEach method's only purpose is to produce side effects, and deviates from the other methods in this aspect. You may consider just using a plain foreach loop instead.
Section 9.2: Calling a method on an object in a list

Chapter 10: Reflection
Section 10.1: What is an Assembly?
Assemblies are the building block of any Common Language Runtime (CLR) application. Every type you define, together with its methods, properties and their bytecode, is compiled and packaged inside an Assembly.


Assemblies are self-documenting: they do not only contain types, methods and their IL code, but also the Metadata necessary to inspect and consume them, both at compile and runtime:

Assemblies have names which describes their full, unique identity:
Console.WriteLine(typeof(int).Assembly.FullName);
// Will print: "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
If this name includes a PublicKeyToken, it is called a strong name. Strong-naming an assembly is the process of creating a signature by using the private key that corresponds to the public key distributed with the assembly. This signature is added to the Assembly manifest, which contains the names and hashes of all the files that make up the assembly, and its PublicKeyToken becomes part of the name. Assemblies that have the same strong name should be identical; strong names are used in versioning and to prevent assembly conflicts.
Section 10.2: Compare two objects with reflection


Note: this example do a field based comparasion (ignore static fields and properties) for simplicity
Section 10.3: Creating Object and setting properties using reflection
Lets say we have a class Classy that has property Propertua

to set Propertua using reflection:

Section 10.4: How to create an object of T using Reflection
Using the default constructor

Using parameterized constructor

Section 10.5: Getting an attribute of an enum with reflection (and caching it)
Attributes can be useful for denoting metadata on enums. Getting the value of this can be slow, so it is important to cache results.



Chapter 11: Expression Trees
Section 11.1: building a predicate of form field == value
_ => _.Field == "VALUE"To build up an expression like  at runtime.
_ => _.FieldGiven a predicate  and a string value "VALUE", create an expression that tests whether or not the predicate is true.
The expression is suitable for:
<T> to test the predicate.
IQueryable<T>, IEnumerableentity framework or Linq to SQL to create a Where clause that tests the predicate.
This method will build an appropriate Equal expression that tests whether or not Field equals "VALUE".

The predicate can be used by including the predicate in a Where extension method.

Section 11.2: Simple Expression Tree Generated by the C# Compiler
Consider the following C# code

Because the C# compiler sees that the lambda expression is assigned to an Expression type rather than a delegate type it generates an expression tree roughly equivalent to this code
ParameterExpression parameterA = Expression.Parameter(typeof(int), "a"); var expression = (Expression<Func<int, int>>)Expression.Lambda(                                                  Expression.Add(                                                      parameterA,                                                      Expression.Constant(1)),                                                  parameterA);
The root of the tree is the lambda expression which contains a body and a list of parameters. The lambda has 1 parameter called "a". The body is a single expression of CLR type BinaryExpression and NodeType of Add. This expression represents addition. It has two subexpressions denoted as Left and Right. Left is the ParameterExpression for the parameter "a" and Right is a ConstantExpression with the value 1.
The simplest usage of this expression is printing it:

Which prints the equivalent C# code.
The expression tree can be compiled into a C# delegate and executed by the CLR

Usually expressions are translated to other languages like SQL, but can be also used to invoke private, protected and internal members of public or non-public types as alternative to Reflection.
Section 11.3: Expression for retrieving a static field
Having example type like this:

We can retrieve value of StaticPublicField:
var fieldExpr = Expression.Field(null, typeof(TestClass), "StaticPublicField"); var labmda = Expression.Lambda<Func<string>>(fieldExpr);
It can be then i.e. compiled into a delegate for retrieving field value.

//fieldValue result is StaticPublicFieldValue
Section 11.4: InvocationExpression Class
InvocationExpression class allows invocation of other lambda expressions that are parts of the same Expression tree.
Expression.InvokeYou create them with static  method.
Problem We want to get on the items which have "car" in their description. We need to check it for null before searching for a string inside but we don't want it to be called excessively, as the computation could be expensive.


            new Element { Description = "car" },             new Element { Description = "cargo" },             new Element { Description = "wheel" },             new Element { Description = null },
            new Element { Description = "Madagascar" },         };            var elementIsInterestingExpression = CreateSearchPredicate(             searchTerm: "car",             whereToSearch: (Element e) => e.Description);            
        Console.WriteLine(elementIsInterestingExpression.ToString());                    var elementIsInteresting = elementIsInterestingExpression.Compile();         var interestingElements = elements.Where(elementIsInteresting);         foreach (var e in interestingElements)
        {
            Console.WriteLine(e.Description);
        }        
        var countExpensiveComputations = 0;         Action incCount = () => countExpensiveComputations++;         elements             .Where(
                CreateSearchPredicate(
                    "car",                     (Element e) => ExpensivelyComputed(                         e, incCount                     )
                ).Compile()
            )
            .Count();
                   
        Console.WriteLine("Property extractor is called {0} times.", countExpensiveComputations);
    }        private class Element     {         public string Description { get; set; }     }        private static string ExpensivelyComputed(Element source, Action count)     {         count();         return source.Description;     }        private static Expression<Func<T, bool>> CreateSearchPredicate<T>(             string searchTerm,             Expression<Func<T, string>> whereToSearch)     {         var extracted = Expression.Parameter(typeof(string), "extracted");    
        Expression<Func<string, bool>> coalesceNullCheckWithSearch =
            Expression.Lambda<Func<string, bool>>(
                Expression.AndAlso(
                    Expression.Not(
                        Expression.Call(typeof(string), "IsNullOrEmpty", null, extracted)                     ),
                    Expression.Call(extracted, "Contains", null, Expression.Constant(searchTerm))                 ),                 extracted);
Output

First thing to note is how the actual propery access, wrapped in an Invoke:

Description, and this is the only part that touches e., and in place of it, extracted parameter of type string is passed to the next one:

Another important thing to note here is AndAlso. It computes only the left part, if the first part returns 'false'. It's a common mistake to use the bitwise operator 'And' instead of it, which always computes both parts, and would fail with a NullReferenceException in this example.
Chapter 12: Custom Types
Section 12.1: Struct Definition
Structs inherit from System.ValueType, are value types, and live on the stack. When value types are passed as a parameter, they are passed by value.

Passed by value means that the value of the parameter is copied for the method, and any changes made to the parameter in the method are not reflected outside of the method. For instance, consider the following code, which calls a method named AddNumbers, passing in the variables a and b, which are of type int, which is a Value type.

Even though we added 5 to x inside the method, the value of a remains unchanged, because it's a Value type, and that means x was a copy of a's value, but not actually a.
Remember, Value types live on the stack, and are passed by value.
Section 12.2: Class Definition
Classes inherit from System.Object, are reference types, and live on the heap. When reference types are passed as a parameter, they are passed by reference.

Passed by reference means that a reference to the parameter is passed to the method, and any changes to the parameter will be reflected outside of the method when it returns, because the reference is to the exact same object in memory. Let's use the same example as before, but we'll "wrap" the ints in a class first.


sample.a to 10, the value of instanceOfMyClassThis time, when we changed .a also changes, because it was passed
by reference. Passed by reference means that a reference (also sometimes called a pointer) to the object was passed into the method, instead of a copy of the object itself.
Remember, Reference types live on the heap, and are passed by reference.

Chapter 13: Code Contracts
Section 13.1: Contracts for Interfaces
Using Code Contracts it is possible to apply a contract to an interface. This is done by declaring an abstract class that implments the interfaces. The interface should be tagged with the ContractClassAttribute and the contract definition (the abstract class) should be tagged with the ContractClassForAttribute C# Example...

Static Analysis Result...

Section 13.2: Installing and Enabling Code Contracts
System.Diagnostics.ContractsWhile  is included within the .Net Framework. To use Code Contracts you must install the Visual Studio extensions.
Under Extensions and Updates search for Code Contracts then install the Code Contracts Tools

Static CheckingAfter the tools are installed you must enable Code Contracts within your Project solution. At the minimum you probably want to enable the  (check after build). If you are implementing a library that will be used by other solutions you may want to consider also enabling Runtime Checking.

Section 13.3: Preconditions
Preconditions allows methods to provide minimum required values for input parameters
Example...

Static Analysis Result...

Section 13.4: Postconditions
Postconditions ensure that the returned results from a method will match the provided definition. This provides the caller with a definition of the expected result. Postconditions may allowed for simplied implmentations as some possible outcomes can be provided by the static analyizer.
Example...

Static Analyis Result...

Chapter 14: Settings
Section 14.1: AppSettings from ConfigurationSettings in .NET 1.x
Deprecated usage
The ConfigurationSettings class was the original way to retrieve settings for an assembly in .NET 1.0 and 1.1. It has been superseded by the ConfigurationManager class and the WebConfigurationManager class.
If you have two keys with the same name in the appSettings section of the configuration file, the last one is used. app.config

Program.cs

Section 14.2: Reading AppSettings from ConfigurationManager in .NET 2.0 and later
The ConfigurationManager class supports the AppSettings property, which allows you to continue reading settings from the appSettings section of a configuration file the same way as .NET 1.x supported.
app.config


Program.cs

Section 14.3: Introduction to strongly-typed application and user settings support from Visual Studio
Visual Studio helps manage user and application settings. Using this approach has these benefits over using the appSettings section of the configuration file.
1. Settings can be made strongly typed. Any type which can be serialized can be used for a settings value.
web.configuser.config2. Application settings can be easily separated from user settings. Application settings are stored in a single configuration file:  for Web sites and Web applications, and app.config, renamed as assembly.exe.config, where assembly is the name of the executable. User settings (not used by Web projects) are stored in a  file in the user's Application Data folder (which varies with the operating system version).
3. Application settings from class libraries can be combined into a single configuration file without risk of name collisions, since each class library can have its own custom settings section.
In most project types, the Project Properties Designer has a Settings tab which is the starting point for creating custom application and user settings. Initially, the Settings tab will be blank, with a single link to create a default settings file. Clicking the link results in these changes:
app.config or web.config1. If a configuration file () does not exist for the project, one will be created.
2. The Settings tab will be replaced with a grid control which enables you to create, edit, and delete individual settings entries.
Settings.settings3. In Solution Explorer, a  item is added under the Properties special folder. Opening this
item will open the Settings tab.
Settings.Designer.__4. A new file with a new partial class is added under the Properties folder in the project folder. This new file is named  (.cs, .vb, etc.), and the class is named Settings. The class is code-generated,
so it should not be edited, but the class is a partial class, so you can extend the class by putting additional members in a separate file. Furthermore, the class is implemented using the Singleton Pattern, exposing the singleton instance with the property named Default.
As you add each new entry to the Settings tab, Visual Studio does these two things:
1. Saves the setting in the configuration file, in a custom configuration section designed to be managed by the Settings class.
2. Creates a new member in the Settings class to read, write, and present the setting in the specific type selected from the Settings tab.
Section 14.4: Reading strongly-typed settings from custom section of configuration file
Starting from a new Settings class and custom configuration section:

Add an application setting named ExampleTimeout, using the time System.Timespan, and set the value to 1 minute:

Save the Project Properties, which saves the Settings tab entries, as well as re-generates the custom Settings class and updates the project configuration file.
Use the setting from code (C#):
Program.cs

Under the covers
Look in the project configuration file to see how the application setting entry has been created: app.config (Visual Studio updates this automatically)

Notice that the appSettings section is not used. The applicationSettings section contains a custom namespacequalified section that has a setting element for each entry. The type of the value is not stored in the configuration file; it is only known by the Settings class.
Look in the Settings class to see how it uses the ConfigurationManager class to read this custom section. Settings.designer.cs (for C# projects)
...
    [global::System.Configuration.ApplicationScopedSettingAttribute()]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Configuration.DefaultSettingValueAttribute("00:01:00")]     public global::System.TimeSpan ExampleTimeout {         get {             return ((global::System.TimeSpan)(this["ExampleTimeout"]));

Notice that a DefaultSettingValueAttribute was created to stored the value entered in the Settings tab of the Project Properties Designer. If the entry is missing from the configuration file, this default value is used instead.

Chapter 15: Regular Expressions (System.Text.RegularExpressions)
Section 15.1: Check if pattern matches input

Section 15.2: Remove non alphanumeric characters from string

Section 15.3: Passing Options

Section 15.4: Match into groups

Section 15.5: Find all matches
Using

Code


Section 15.6: Simple match and replace


Chapter 16: File Input/Output
Parameter	Details
string path Path of the file to check. (relative or fully qualified)
Section 16.1: C# File.Exists()

Can also be used in a ternary operator.
Console.WriteLine(File.Exists(pathToFile) ? "Exists" : "Does not exist");
Section 16.2: VB WriteAllText

Section 16.3: VB StreamWriter

Section 16.4: C# StreamWriter


Section 16.5: C# WriteAllText()


Chapter 17: System.IO
Section 17.1: Reading a text file using StreamReader

Note that this StreamReader constructor overload does some auto encoding detection, which may or may not conform to the actual encoding used in the file.
System.IO.FileFile.ReadAllText(path) and File.ReadAllLines(path)Please note that there are some convenience methods that read all text from file available on the class, namely .
Section 17.2: Serial Ports using System.IO.SerialPorts


NOTE: Those are just three of the seven overloads of the constructor for the SerialPort type.
Reading/Writing data over the SerialPort
SerialPort.Read and SerialPort.WriteSystem.IO.StreamThe simplest way is to use the  methods. However you can also retrieve a  object which you can use to stream data over the SerialPort. To do this, use
SerialPort.BaseStream.
Reading

You can also read all data available:

Or simply read to the first newline encountered in the incoming data:

Writing
The easiest way to write data over the SerialPort is:

However you can also send data over like this when needed:

Section 17.3: Reading/Writing Data Using System.IO.File
First, let's see three different ways of extracting data from a file.

Next, let's see three different methods of appending data to a file. If the file you specify doesn't exist, each method will automatically create the file before attempting to append the data to it.
 File.AppendAllText(file, "Here is some data that is\nappended to the file.");
 File.AppendAllLines(file, new string[2] { "Here is some data that is", "appended to the file." });  using (StreamWriter stream = File.AppendText(file))
 {      stream.WriteLine("Here is some data that is");      stream.Write("appended to the file.");
 }
On the first line we simply add a string to the end of the specified file.
On the second line we add each element of the array onto a new line in the file.
File.AppendTextFinally on the third line we use  to open up a streamwriter which will append whatever data is written to it.
And lastly, let's see three different methods of writing data to a file. The difference between appending and writing being that writing over-writes the data in the file while appending adds to the data in the file. If the file you specify doesn't exist, each method will automatically create the file before attempting to write the data to it.
File.WriteAllText(file, "here is some data\nin this file.");
File.WriteAllLines(file, new string[2] { "here is some data", "in this file" }); File.WriteAllBytes(file, new byte[2] { 0, 255 });
The first line writes a string to the file.
The second line writes each string in the array on it's own line in the file.
 And the third line allows you to write a byte array to the file.

Chapter 18: System.IO.File class
 Parameter	Details source	The file that is to be moved to another location.
The directory in which you would like to move source to (this variable should also contain the name
destination (and file extension) of the file.
Section 18.1: Delete a file
To delete a file (if you have required permissions) is as simple as:

However many things may go wrong:
You do not have required permissions (UnauthorizedAccessException is thrown).
File may be in use by someone else (IOException is thrown).
File cannot be deleted because of low level error or media is read-only (IOException is thrown). File does not exist anymore (IOException is thrown).
Note that last point (file does not exist) is usually circumvented with a code snippet like this:

File.ExistsFile.DeleteHowever it's not an atomic operation and file may be delete by someone else between the call to () and before (). Right approach to handle I/O operation requires exception handling (assuming an alternative course of actions may be taken when operation fails):

Note that this I/O errors sometimes are transitory (file in use, for example) and if a network connection is involved then it may automatically recover without any action from our side. It's then common to retry an I/O operation few times with a small delay between each attempt:


FileShare.DeleteNote: in Windows environment file will not be really deleted when you call this function, if someone else open the file using  then file can be deleted but it will effectively happen only when owner will close the file.
Section 18.2: Strip unwanted lines from a text file
To change a text file is not easy because its content must be moved around. For small files easiest method is to read its content in memory and then write back modified text.
In this example we read all lines from a file and drop all blank lines then we write back to original path:

If file is too big to load it in memory and output path is different from input path:

Section 18.3: Convert text file encoding
Text is saved encoded (see also Strings topic) then sometimes you may need to change its encoding, this example assumes (for simplicity) that file is not too big and it can be entirely read in memory:

When performing conversions do not forget that file may contain BOM (Byte Order Mark), to better understand how it's managed refer to Encoding.UTF8.GetString doesn't take into account the Preamble/BOM.
Section 18.4: Enumerate files older than a specified amount
This snippet is an helper function to enumerate all files older than a specified age, it's useful - for example - when you have to delete old log files or old cached data.
static IEnumerable<string> EnumerateAllFilesOlderThan(                                TimeSpan maximumAge,                                string path,
                               string searchPattern = "*.*",                                SearchOption options = SearchOption.TopDirectoryOnly)
{
    DateTime oldestWriteTime = DateTime.Now - maximumAge;
    return Directory.EnumerateFiles(path, searchPattern, options)         .Where(x => Directory.GetLastWriteTime(x) < oldestWriteTime);
}
Used like this: var oldFiles = EnumerateAllFilesOlderThan(TimeSpan.FromDays(7), @"c:\log", "*.log");
Few things to note:
Directory.EnumerateFiles() instead of Directory.GetFilesSearch is performed using (). Enumeration is alive then you won't need to wait until all file system entries have been fetched.
We're checking for last write time but you may use creation time or last access time (for example to delete unused cached files, note that access time may be disabled).
 Granularity isn't uniform for all those properties (write time, access time, creation time), check MSDN for details about this.
 Section 18.5: Move a File from one location to another
File.Move
In order to move a file from one location to another, one simple line of code can achieve this:
File.Move(@"C:\TemporaryFile.txt", @"C:\TemporaryFiles\TemporaryFile.txt");
However, there are many things that could go wrong with this simple operation. For instance, what if the user running your program does not have a Drive that is labelled 'C'? What if they did - but they decided to rename it to 'B', or 'M'?
What if the Source file (the file in which you would like to move) has been moved without your knowing - or what if it simply doesn't exist.
This can be circumvented by first checking to see whether the source file does exist:

File.ExistsThis will ensure that at that very moment, the file does exist, and can be moved to another location. There may be times where a simple call to  won't be enough. If it isn't, check again, convey to the user that the operation failed - or handle the exception.
A FileNotFoundException is not the only exception you are likely to encounter.
See below for possible exceptions:
Exception TypeDescriptionIOExceptionThe file already exists or the source file could not be found.ArgumentNullExceptionThe value of the Source and/or Destination parameters is null.ArgumentExceptionThe value of the Source and/or Destination parameters are empty, or contain invalid characters.UnauthorizedAccessException You do not have the required permissions in order to perform this action.
The Source, Destination or specified path(s) exceed the maximum length. On
PathTooLongException	Windows, a Path's length must be less than 248 characters, while File names must be less than 260 characters.
DirectoryNotFoundException The specified directory could not be found.
NotSupportedException	The Source or Destination paths or file names are in an invalid format.

Chapter 19: Reading and writing Zip files
The ZipFile class lives in the System.IO.Compression namespace. It can be used to read from, and write to Zip files.
Section 19.1: Listing ZIP contents
This snippet will list all the filenames of a zip archive. The filenames are relative to the zip root.

Section 19.2: Extracting files from ZIP files
Extracting all the files into a directory is very easy:

When the file already exists, a System.IO.IOException will be thrown.
Extracting specific files:
using (FileStream fs = new FileStream("archive.zip", FileMode.Open)) using (ZipArchive archive = new ZipArchive(fs, ZipArchiveMode.Read)) {
    // Get a root entry file     archive.GetEntry("test.txt").ExtractToFile("test_extracted_getentries.txt", true);
    // Enter a path if you want to extract files from a subdirectory     archive.GetEntry("sub/subtest.txt").ExtractToFile("test_sub.txt", true);
    // You can also use the Entries property to find files     archive.Entries.FirstOrDefault(f => f.Name ==
"test.txt")?.ExtractToFile("test_extracted_linq.txt", true);
    // This will throw a System.ArgumentNullException because the file cannot be found     archive.GetEntry("nonexistingfile.txt").ExtractToFile("fail.txt", true); }
Any of these methods will produce the same result.
Section 19.3: Updating a ZIP file
To update a ZIP file, the file has to be opened with ZipArchiveMode.Update instead.


There is also the option to write directly to a file within the archive:


Chapter 20: Managed Extensibility Framework
Section 20.1: Connecting (Basic)
See the other (Basic) examples above.

[Export(typeof(IUserProvider))]As long as something in the application's assembly search path has ,
UserWriter's corresponding import will be satisfied and the users will be printed.
Other types of catalogs (e.g., DirectoryCatalog) can be used instead of (or in addition to) ApplicationCatalog, to look in other places for exports that satisfy the imports.
Section 20.2: Exporting a Type (Basic)


This could be defined virtually anywhere; all that matters is that the application knows where to look for it (via the ComposablePartCatalogs it creates).
Section 20.3: Importing (Basic)

This is a type that has a dependency on an IUserProvider, which could be defined anywhere. Like the previous example, all that matters is that the application knows where to look for the matching export (via the ComposablePartCatalogs it creates).
Chapter 21: SpeechRecognitionEngine class to recognize speech
LoadGrammar: ParametersDetailsgrammarThe grammar to load. For example, a DictationGrammar object to allow free text dictation.RecognizeAsync: ParametersDetailsmodeThe RecognizeMode for the current recognition: Single for just oneGrammarBuilder.Append             recognition, Multiple to allow multiple. : Parameters Details
choicesAppends some choices to the grammar builder. This means that, when the user inputs speech, the recognizer can follow different "branches" from a grammar.Choices constructor: ParametersDetailsGrammarBuilder.Appendchoices	An array of choices for the grammar builder. See .
Grammar constructor: ParameterDetailsbuilderThe GrammarBuilder to construct a Grammar from.Section 21.1: Asynchronously recognizing speech based on a restricted set of phrases
SpeechRecognitionEngine recognitionEngine = new SpeechRecognitionEngine(); GrammarBuilder builder = new GrammarBuilder(); builder.Append(new Choices("I am", "You are", "He is", "She is", "We are", "They are")); builder.Append(new Choices("friendly", "unfriendly")); recognitionEngine.LoadGrammar(new Grammar(builder)); recognitionEngine.SpeechRecognized += delegate(object sender, SpeechRecognizedEventArgs e) {
    Console.WriteLine("You said: {0}", e.Result.Text); }; recognitionEngine.SetInputToDefaultAudioDevice(); recognitionEngine.RecognizeAsync(RecognizeMode.Multiple);
Section 21.2: Asynchronously recognizing speech for free text dictation

Chapter 22: System.Runtime.Caching.MemoryCache (ObjectCache)
Section 22.1: Adding Item to Cache (Set)
Set function inserts a cache entry into the cache by using a CacheItem instance to supply the key and value for the cache entry.
ObjectCache.Set(CacheItem, CacheItemPolicy)This function Overrides 

Section 22.2: System.Runtime.Caching.MemoryCache (ObjectCache)
This function gets existing item form cache, and if the item don't exist in cache, it will fetch item based on the valueFetchFactory function.



Chapter 23: System.Reflection.Emit namespace
Section 23.1: Creating an assembly dynamically


        // Add a private field of type int (Int32).
        FieldBuilder fbNumber = tb.DefineField(
            "m_number",             typeof(int),
            FieldAttributes.Private);
        // Next, we make a simple sealed method.
        MethodBuilder mbMyMethod = tb.DefineMethod(
            "MyMethod",             MethodAttributes.Public,             typeof(int),
            new[] { typeof(int) });
        ILGenerator il = mbMyMethod.GetILGenerator();         il.Emit(OpCodes.Ldarg_0); // Load this - always the first argument of any instance method         il.Emit(OpCodes.Ldfld, fbNumber);         il.Emit(OpCodes.Ldarg_1); // Load the integer argument         il.Emit(OpCodes.Mul); // Multiply the two numbers with no overflow checking         il.Emit(OpCodes.Ret); // Return
        // Next, we build the property. This involves building the property itself, as well as the         // getter and setter methods.
        PropertyBuilder pbNumber = tb.DefineProperty(
            "Number", // Name             PropertyAttributes.None,             typeof(int), // Type of the property             new Type[0]); // Types of indices, if any
        MethodBuilder mbSetNumber = tb.DefineMethod(
            "set_Number", // Name - setters are set_Property by convention
            // Setter is a special method and we don't want it to appear to callers from C#
            MethodAttributes.PrivateScope | MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.SpecialName,             typeof(void), // Setters don't return a value             new[] { typeof(int) }); // We have a single argument of type System.Int32
        // To generate the body of the method, we'll need an IL generator         il = mbSetNumber.GetILGenerator();         il.Emit(OpCodes.Ldarg_0); // Load this         il.Emit(OpCodes.Ldarg_1); // Load the new value         il.Emit(OpCodes.Stfld, fbNumber); // Save the new value to this.m_number         il.Emit(OpCodes.Ret); // Return
        // Finally, link the method to the setter of our property         pbNumber.SetSetMethod(mbSetNumber);
        MethodBuilder mbGetNumber = tb.DefineMethod(
            "get_Number",
            MethodAttributes.PrivateScope | MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.SpecialName,             typeof(int),             new Type[0]);
        il = mbGetNumber.GetILGenerator();         il.Emit(OpCodes.Ldarg_0); // Load this         il.Emit(OpCodes.Ldfld, fbNumber); // Load the value of this.m_number         il.Emit(OpCodes.Ret); // Return the value
        pbNumber.SetGetMethod(mbGetNumber);        
        // Finally, we add the two constructors.
        // Constructor needs to call the constructor of the parent class, or another constructor inthe same class
        ConstructorBuilder intConstructor = tb.DefineConstructor(
            MethodAttributes.Public, CallingConventions.Standard | CallingConventions.HasThis, new[] { typeof(int) });         il = intConstructor.GetILGenerator();         il.Emit(OpCodes.Ldarg_0); // this         il.Emit(OpCodes.Call, typeof(object).GetConstructor(new Type[0])); // call parent's constructor         il.Emit(OpCodes.Ldarg_0); // this         il.Emit(OpCodes.Ldarg_1); // our int argument         il.Emit(OpCodes.Stfld, fbNumber); // store argument in this.m_number         il.Emit(OpCodes.Ret);
        var parameterlessConstructor = tb.DefineConstructor(
            MethodAttributes.Public, CallingConventions.Standard | CallingConventions.HasThis, new Type[0]);         il = parameterlessConstructor.GetILGenerator();         il.Emit(OpCodes.Ldarg_0); // this         il.Emit(OpCodes.Ldc_I4_S, (byte)42); // load 42 as an integer constant         il.Emit(OpCodes.Call, intConstructor); // call this(42)         il.Emit(OpCodes.Ret);
        // And make sure the type is created
        Type ourType = tb.CreateType();
        // The types from the assembly can be used directly using reflection, or we can save the assembly to use as a reference
        object ourInstance = Activator.CreateInstance(ourType);
        Console.WriteLine(ourType.GetProperty("Number").GetValue(ourInstance)); // 42        
        // Save the assembly for use elsewhere. This is very useful for debugging - you can use e.g. ILSpy to look at the equivalent IL/C# code.
        ab.Save(@"DynamicAssemblyExample.dll");
        // Using newly created type         var myDynamicType = tb.CreateType();
        var myDynamicTypeInstance = Activator.CreateInstance(myDynamicType);         Console.WriteLine(myDynamicTypeInstance.GetType()); // MyDynamicType
        var numberField = myDynamicType.GetField("m_number", BindingFlags.NonPublic | BindingFlags.Instance);
        numberField.SetValue (myDynamicTypeInstance, 10);
        Console.WriteLine(numberField.GetValue(myDynamicTypeInstance)); // 10
    }
}
Chapter 24: .NET Core
.NET Core is a general purpose development platform maintained by Microsoft and the .NET community on GitHub. It is cross-platform, supporting Windows, macOS and Linux, and can be used in device, cloud, and embedded/IoT scenarios.
When you think of .NET Core the following should come to mind (flexible deployment, cross-platform, commandline tools, open source).
Another great thing is that even if it's open source Microsoft is actively supporting it.
Section 24.1: Basic Console App


Chapter 25: ADO.NET
ADO(ActiveX Data Objects).Net is a tool provided by Microsoft which provides access to data sources such as SQL Server, Oracle, and XML through its components. .Net front-end applications can retrieve, create, and manipulate data, once they are connected to a data source through ADO.Net with appropriate privileges.
ADO.Net provides a connection-less architecture. It is a secure approach to interact with a database, since, the connection doesn't have to be maintained during the entire session.
Section 25.1: Best Practices - Executing Sql Statements
public void SaveNewEmployee(Employee newEmployee) {
    // best practice - wrap all database connections in a using block so they are always closed & disposed even in the event of an Exception
    // best practice - retrieve the connection string by name from the app.config or web.config
(depending on the application type) (note, this requires an assembly reference to System.configuration)
    using(SqlConnection con = new
SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["MyConnectionName"].Conne ctionString))     {
        // best practice - use column names in your INSERT statement so you are not dependent on the sql schema column order
        // best practice - always use parameters to avoid sql injection attacks and errors if malformed text is used like including a single quote which is the sql equivalent of escaping or starting a string (varchar/nvarchar)
        // best practice - give your parameters meaningful names just like you do variables in your code
        using(SqlCommand sc = new SqlCommand("INSERT INTO employee (FirstName, LastName,
DateOfBirth /*etc*/) VALUES (@firstName, @lastName, @dateOfBirth /*etc*/)", con))         {
            // best practice - always specify the database data type of the column you are using             // best practice - check for valid values in your code and/or use a database constraint, if inserting NULL then use System.DbNull.Value             sc.Parameters.Add(new SqlParameter("@firstName", SqlDbType.VarChar, 200){Value = newEmployee.FirstName ?? (object) System.DBNull.Value});             sc.Parameters.Add(new SqlParameter("@lastName", SqlDbType.VarChar, 200){Value = newEmployee.LastName ?? (object) System.DBNull.Value});
            // best practice - always use the correct types when specifying your parameters, Value is assigned to a DateTime instance and not a string representation of a Date             sc.Parameters.Add(new SqlParameter("@dateOfBirth", SqlDbType.Date){ Value = newEmployee.DateOfBirth });
            // best practice - open your connection as late as possible unless you need to verify that the database connection is valid and won't fail and the proceeding code execution takes a long time (not the case here)             con.Open();
            sc.ExecuteNonQuery();         }
        // the end of the using block will close and dispose the SqlConnection
        // best practice - end the using block as soon as possible to release the database connection
    }
}
// supporting class used as parameter for example public class Employee

Best practice for working with ADO.NET
 Rule of thumb is to open connection for minimal time. Close the connection explicitly once your procedure execution is over this will return the connection object back to connection pool. Default connection pool max size = 100. As connection pooling enhances the performance of physical connection to SQL
Server.Connection Pooling in SQL Server
Wrap all database connections in a using block so they are always closed & disposed even in the event of an
Exception. See using Statement (C# Reference) for more information on using statements
Retrieve the connection strings by name from the app.config or web.config (depending on the application type)
This requires an assembly reference to System.configuration
See Connection Strings and Configuration Files for additional information on how to structure your configuration file
Always use parameters for incoming values to
Avoid sql injection attacks
Avoid errors if malformed text is used like including a single quote which is the sql equivalent of escaping or starting a string (varchar/nvarchar)
Letting the database provider reuse query plans (not supported by all database providers) which increases efficiency
When working with parameters
Sql parameters type and size mismatch is a common cause of insert/ updated/ select failure
Give your Sql parameters meaningful names just like you do variables in your code
Specify the database data type of the column you are using, this ensures the wrong parameter types is not used which could lead to unexpected results
Validate your incoming parameters before you pass them into the command (as the saying goes,
"garbage in, garbage out"). Validate incoming values as early as possible in the stack
Use the correct types when assigning your parameter values, example: do not assign the string value of a DateTime, instead assign an actual DateTime instance to the value of the parameter
Specify the size of string-type parameters. This is because SQL Server can re-use execution plans if the parameters match in type and size. Use -1 for MAX
Do not use the method AddWithValue, the main reason is it is very easy to forget to specify the parameter type or the precision/scale when needed. For additional information see Can we stop using AddWithValue already?
When using database connections
Open the connection as late as possible and close it as soon as possible. This is a general guideline when working with any external resource
Never share database connection instances (example: having a singleton host a shared instance of type SqlConnection). Have your code always create a new database connection instance when needed and then have the calling code dispose of it and "throw it away" when it is done. The reason for this is Most database providers have some sort of connection pooling so creating new managed connections is cheap
It eliminates any future errors if the code starts working with multiple threads
Section 25.2: Executing SQL statements as a command
// Uses Windows authentication. Replace the Trusted_Connection parameter with
// User Id=...;Password=...; to use SQL Server authentication instead. You may // want to find the appropriate connection string for your server. string connectionString = @"Server=myServer\myInstance;Database=myDataBase;Trusted_Connection=True;"
string sql = "INSERT INTO myTable (myDateTimeField, myIntField) " +     "VALUES (@someDateTime, @someInt);";
// Most ADO.NET objects are disposable and, thus, require the using keyword. using (var connection = new SqlConnection(connectionString)) using (var command = new SqlCommand(sql, connection)) {
    // Use parameters instead of string concatenation to add user-supplied
    // values to avoid SQL injection and formatting issues. Explicitly supply datatype.
    // System.Data.SqlDbType is an enumeration. See Note1     command.Parameters.Add("@someDateTime", SqlDbType.DateTime).Value = myDateTimeVariable;     command.Parameters.Add("@someInt", SqlDbType.Int).Value = myInt32Variable;
    // Execute the SQL statement. Use ExecuteScalar and ExecuteReader instead
    // for query that return results (or see the more specific examples, once     // those have been added).
    connection.Open();     command.ExecuteNonQuery(); }
Note 1: Please see SqlDbType Enumeration for the MSFT SQL Server-specific variation.
Note 2: Please see MySqlDbType Enumeration for the MySQL-specific variation.
Section 25.3: Using common interfaces to abstract away vendor specific classes

Chapter 26: Dependency Injection
Section 26.1: How Dependency Injection Makes Unit Testing Easier
This builds on the previous example of the Greeter class which has two dependencies, IGreetingProvider and IGreetingWriter.
The actual implementation of IGreetingProvider might retrieve a string from an API call or a database. The implementation of IGreetingWriter might display the greeting in the console. But because Greeter has its dependencies injected into its constructor, it's easy to write a unit test that injects mocked versions of those interfaces. In real life we might use a framework like Moq, but in this case I'll write those mocked implementations.

The behavior of IGreetingProvider and IGreetingWriter are not relevant to this test. We want to test that
Greeter gets a greeting and writes it. The design of Greeter (using dependency injection) allows us to inject mocked dependencies without any complicated moving parts. All we're testing is that Greeter interacts with those dependencies as we expect it to.
Section 26.2: Dependency Injection - Simple example
This class is called Greeter. Its responsibility is to output a greeting. It has two dependencies. It needs something that will give it the greeting to output, and then it needs a way to output that greeting. Those dependencies are both described as interfaces, IGreetingProvider and IGreetingWriter. In this example, those two dependencies are "injected" into Greeter. (Further explanation following the example.)

The Greeting class depends on both IGreetingProvider and IGreetingWriter, but it is not responsible for creating instances of either. Instead it requires them in its constructor. Whatever creates an instance of Greeting must provide those two dependencies. We can call that "injecting" the dependencies.
Because dependencies are provided to the class in its constructor, this is also called "constructor injection." A few common conventions:
The constructor saves the dependencies as private fields. As soon as the class is instantiated, those dependencies are available to all other non-static methods of the class.
The private fields are readonly. Once they are set in the constructor they cannot be changed. This indicates that those fields should not (and cannot) be modified outside of the constructor. That further ensures that those dependencies will be available for the lifetime of the class.
 The dependencies are interfaces. This is not strictly necessary, but is common because it makes it easier to substitute one implementation of the dependency with another. It also allows providing a mocked version of the interface for unit testing purposes.
Section 26.3: Why We Use Dependency Injection Containers (IoC Containers)
Dependency injection means writing classes so that they do not control their dependencies - instead, their dependencies are provided to them ("injected.")
This is not the same thing as using a dependency injection framework (often called a "DI container", "IoC container", or just "container") like Castle Windsor, Autofac, SimpleInjector, Ninject, Unity, or others.
A container just makes dependency injection easier. For example, suppose you write a number of classes that rely on dependency injection. One class depends on several interfaces, the classes that implement those interfaces depend on other interfaces, and so on. Some depend on specific values. And just for fun, some of those classes implement IDisposable and need to be disposed.
Each individual class is well-written and easy to test. But now there's a different problem: Creating an instance of a class has become much more complicated. Suppose we're creating an instance of a CustomerService class. It has dependencies and its dependencies have dependencies. Constructing an instance might look something like this:
public CustomerData GetCustomerData(string customerNumber) {     var customerApiEndpoint = ConfigurationManager.AppSettings["customerApi:customerApiEndpoint"];     var logFilePath = ConfigurationManager.AppSettings["logwriter:logFilePath"];     var authConnectionString =
ConfigurationManager.ConnectionStrings["authorization"].ConnectionString;     using(var logWriter = new LogWriter(logFilePath ))     {         using(var customerApiClient = new CustomerApiClient(customerApiEndpoint))         {             var customerService = new CustomerService(                 new SqlAuthorizationRepository(authorizationConnectionString, logWriter),                 new CustomerDataRepository(customerApiClient, logWriter),                 logWriter             );  
           
            // All this just to create an instance of CustomerService!                    return customerService.GetCustomerData(string customerNumber);         }
    }
}
You might wonder, why not put the whole giant construction in a separate function that just returns
GetCustomerServiceCustomerService? One reason is that because the dependencies for each class are injected into it, a class isn't responsible for knowing whether those dependencies are IDisposable or disposing them. It just uses them. So if a we had a () function that returned a fully-constructed CustomerService, that class might contain a number of disposable resources and no way to access or dispose them.
And aside from disposing IDisposable, who wants to call a series of nested constructors like that, ever? That's a short example. It could get much, much worse. Again, that doesn't mean that we wrote the classes the wrong way. The classes might be individually perfect. The challenge is composing them together.
A dependency injection container simplifies that. It allows us to specify which class or value should be used to fulfill each dependency. This slightly oversimplified example uses Castle Windsor:
var container = new WindsorContainer() container.Register(     Component.For<CustomerService>(),
    Component.For<ILogWriter, LogWriter>()
        .DependsOn(Dependency.OnAppSettingsValue("logFilePath", "logWriter:logFilePath")),
    Component.For<IAuthorizationRepository, SqlAuthorizationRepository>()
        .DependsOn(Dependency.OnValue(connectionString,
ConfigurationManager.ConnectionStrings["authorization"].ConnectionString)),
    Component.For<ICustomerDataProvider, CustomerApiClient>()
         .DependsOn(Dependency.OnAppSettingsValue("apiEndpoint",
"customerApi:customerApiEndpoint"))  
);
We call this "registering dependencies" or "configuring the container." Translated, this tells our WindsorContainer:
 If a class requires ILogWriter, create an instance of LogWriter. LogWriter requires a file path. Use this value from AppSettings.
If a class requires IAuthorizationRepository, create an instance of SqlAuthorizationRepository. It requires a connection string. Use this value from the ConnectionStrings section.
If a class requires ICustomerDataProvider, create a CustomerApiClient and provide the string it needs from AppSettings.
When we request a dependency from the container we call that "resolving" a dependency. It's bad practice to do that directly using the container, but that's a different story. For demonstration purposes, we could now do this:
var customerService = container.Resolve<CustomerService>(); var data = customerService.GetCustomerData(customerNumber); container.Release(customerService);
The container knows that CustomerService depends on IAuthorizationRepository and ICustomerDataProvider. It knows what classes it needs to create to fulfill those requirements. Those classes, in turn, have more dependencies, and the container knows how to fulfill those. It will create every class it needs to until it can return an instance of CustomerService.
If it gets to a point where a class requires a dependency that we haven't registered, like IDoesSomethingElse, then when we try to resolve CustomerService it will throw a clear exception telling us that we haven't registered anything to fulfill that requirement.
Each DI framework behaves a little differently, but typically they give us some control over how certain classes are instantiated. For example, do we want it to create one instance of LogWriter and provide it to every class that depends on ILogWriter, or do we want it to create a new one every time? Most containers have a way to specify that.
container.Release(customerServiceWhat about classes that implement IDisposable? That's why we call ); at the
end. Most containers (including Windsor) will step back through all of the dependencies created and Dispose the ones that need disposing. If CustomerService is IDisposable it will dispose that too.
Registering dependencies as seen above might just look like more code to write. But when we have lots of classes with lots of dependencies then it really pays off. And if we had to write those same classes without using dependency injection then that same application with lots of classes would become difficult to maintain and test.
This scratches the surface of why we use dependency injection containers. How we configure our application to use one (and use it correctly) is not just one topic - it's a number of topics, as the instructions and examples vary from one container to the next.
Chapter 27: Platform Invoke
Section 27.1: Marshaling structs
Simple struct
C++ signature:

C# definition

Struct with unknown size array fields. Passing in
C++ signature

When passed from managed to unmanaged code, this
Marshal.AllocHGlobal() (and freed with Marshal.FreeHGlobal()The data array should be defined as IntPtr and memory should be explicitly allocated with  afterwords):


Struct with unknown size array fields. Receiving C++ signature:

Marshal.PtrToStringAnsiWhen such data is passed out of unmanaged code and memory is allocated by the unmanaged functions, the managed caller should receive it into an IntPrt variable and convert the buffer to a managed array. In case of strings there is a convenient () method:

Section 27.2: Marshaling unions
Value-type fields only
C++ declaration


C# declaration

Mixing value-type and reference fields
FieldOffsetOverlapping a reference value with a value type one is not allowed so you cannot simply use the (0)
text; FieldOffset(0) i; will not compile for

and generally you would have to employ custom marshaling. However, in particular cases like this simpler technics may be used:

Section 27.3: Calling a Win32 dll function

static externDeclare a function as  stting DllImportAttribute with its Value property set to .dll name. Don't forget to use System.Runtime.InteropServices namespace. Then call it as an regular static method.
The Platform Invocation Services will take care of loading the .dll and finding the desired finction. The P/Invoke in most simple cases will also marshal parameters and return value to and from the .dll (i.e. convert from .NET datatypes to Win32 ones and vice versa).
Section 27.4: Using Windows API
Use pinvoke.net.
Before declaring an extern Windows API function in your code, consider looking for it on pinvoke.net. They most likely already have a suitable declaration with all supporting types and good examples.
Section 27.5: Marshalling arrays
Arrays of simple type

Arrays of string


Chapter 28: NuGet packaging system
Section 28.1: Uninstalling a package from one project in a solution

Section 28.2: Installing a specific version of a package

Section 28.3: Adding a package source feed (MyGet, Klondike, ect)

Section 28.4: Installing the NuGet Package Manager
In order to be able to manage your projects' packages, you need the NuGet Package Manager. This is a Visual Studio Extension, explained in the official docs: Installing and Updating NuGet Client.
Starting with Visual Studio 2012, NuGet is included in every edition, and can be used from: Tools -> NuGet Package Manager -> Package Manager Console.
You do so through the Tools menu of Visual Studio, clicking Extensions and Updates:

This installs both the GUI:
 Available through clicking "Manage NuGet Packages..." on a project or its References folder
And the Package Manager Console:
     Tools -> NuGet Package Manager -> Package Manager Console.
  Section 28.5: Managing Packages through the UI
When you right-click a project (or its References folder), you can click the "Manage NuGet Packages..." option. This shows the Package Manager Dialog.

Section 28.6: Managing Packages through the console
Click the menus Tools -> NuGet Package Manager -> Package Manager Console to show the console in your IDE. Official documentation here.
install-packageHere you can issue, amongst others,  commands which installs the entered package into the currently selected "Default project":

You can also provide the project to install the package to, overriding the selected project in the "Default project" dropdown:

Section 28.7: Updating a package
To update a package use the following command:

Install-Package EntityFrameworkwhere EntityFramework is the name of the package to be updated. Note that update will run for all projects, and so is different from  which would install to "Default project" only.
You can also specify a single project explicitly:

Section 28.8: Uninstalling a package

Section 28.9: Uninstall a specific version of package


Chapter 29: Globalization in ASP.NET MVC using Smart internationalization for ASP.NET
Section 29.1: Basic configuration and setup
1. Add the I18N nuget package to your MVC project.
i18n.LocalizingModule to your <httpModules> or <modules2. In web.config, add the > section.

3. Add a folder named "locale" to the root of your site. Create a subfolder for each culture you wish to support.
locale/frFor example, //.
messages.po4. In each culture-specific folder, create a text file named .
messages.po5. For testing purposes, enter the following lines of text in your  file:

6. Add a controller to your project which returns some text to translate.

7. Run your MVC application and browse to the route corresponding to your controller action, such as http://localhost:[yourportnumber]/default.
Observe that the URL is changed to reflect your default culture, such as http://localhost:[yourportnumber]/en/default.
en/ in the URL with /fr8. Replace // (or whatever culture you've selected.) The page should now display the translated version of your text.
default9. Change your browser's language setting to prefer your alternate culture and browse to / again. Observe that the URL is changed to reflect your alternate culture and the translated text appears.
10. In web.config, add handlers so that users cannot browse to your locale folder.


Chapter 30: System.Net.Mail
Section 30.1: MailMessage
Here is the example of creating of mail message with attachments. After creating we send this message with the help of SmtpClient class. Default 25 port is used here.


Section 30.2: Mail with Attachment
MailMessage represents mail message which can be sent further using SmtpClient class. Several attachments (files) can be added to mail message.


Chapter 31: Using Progress<T> and IProgress<T>
Section 31.1: Simple Progress reporting
IProgress<T> can be used to report progress of some procedure to another procedure. This example shows how
you can create a basic method that reports its progress.

Output:

IProgress<T>.Report()Note that when you this code runs, you may see numbers be output out of order. This is because the  method is run asynchronously, and is therefore not as suitable for situations where the
progress must be reported in order.
Section 31.2: Using IProgress<T>
System.Progress<T> class does not have the Report()It's important to note that the  method available on it. This
IProgress<T>method was implemented explicitly from the  interface, and therefore must be called on a
Progress<T> when it's cast to an IProgress<T>.



Chapter 32: JSON Serialization
Section 32.1: Deserialization using System.Web.Script.Serialization.JavaScriptSerializer
JavaScriptSerializer.Deserialize<T>(input)<T>The  method attempts to deserialize a string of valid JSON into an object of the specified type , using the default mappings natively supported by JavaScriptSerializer.

Note: The JavaScriptSerializer object was introduced in .NET version 3.5
Section 32.2: Serialization using Json.NET

Notice how properties (and classes) can be decorated with attributes to change their appearance in resulting json string or to remove them from json string at all (JsonIgnore).
More information about Json.NET serialization attributes can be found here.
In C#, public identifiers are written in PascalCase by convention. In JSON, the convention is to use camelCase for all names. You can use a contract resolver to convert between the two.


Section 32.3: Serialization-Deserialization using Newtonsoft.Json
Unlike the other helpers, this one uses static class helpers to serialize and deserialize, hence it is a little bit easier than the others to use.
using Newtonsoft.Json;
var rawJSON      = "{\"Name\":\"Fibonacci Sequence\",\"Numbers\":[0, 1, 1, 2, 3, 5, 8, 13]}"; var fibo         = JsonConvert.DeserializeObject<Dictionary<string, object>>(rawJSON); var rawJSON2     = JsonConvert.SerializeObject(fibo);
Section 32.4: Deserialization using Json.NET

For more information, refer to the Json.NET official site.
Note: Json.NET supports .NET version 2 and higher.
Section 32.5: Dynamic binding
Newtonsoft's Json.NET allows you to bind json dynamically (using ExpandoObject / Dynamic objects) without the need to create the type explicitly.
Serialization

De-serialization
var rawJson = "{\"Name\":\"Fibonacci Sequence\",\"Numbers\":[0, 1, 1, 2, 3, 5, 8, 13]}"; dynamic parsedJson = JObject.Parse(rawJson);
Console.WriteLine("Name: " + parsedJson.Name);
Console.WriteLine("Name: " + parsedJson.Numbers.Length);
Notice that the keys in the rawJson object have been turned into member variables in the dynamic object.
This is useful in cases where an application can accept/ produce varying formats of JSON. It is however suggested to use an extra level of validation for the Json string or to the dynamic object generated as a result of serialization/ deserialization.
Section 32.6: Serialization using Json.NET with JsonSerializerSettings
This serializer has some nice features that the default .net json serializer doesn't have, like Null value handling, you just need to create the JsonSerializerSettings :

List<StudentAnother serious serializer issue in .net is the self referencing loop. In the case of a student that is enrolled in a course, its instance has a course property and a course has a collection of students that means a > which will create a reference loop. You can handle this with JsonSerializerSettings :

You can put various serializations option like this:

Chapter 33: JSON in .NET with Newtonsoft.Json
Newtonsoft.JsonThe NuGet package  has become the defacto standard for using and manipulating JSON formatted text and objects in .NET. It is a robust tool that is fast, and easy to use.
Section 33.1: Deserialize an object from JSON text

This yields a Person object with Name "Joe Smith" and Age 21.
Section 33.2: Serialize object into JSON

This results in this JSON: {"Name":"Joe Smith","Age":21}

Chapter 34: XmlSerializer
Section 34.1: Formatting: Custom DateTime format

Section 34.2: Serialize object

Section 34.3: Deserialize object

Section 34.4: Behaviour: Map array name to property (XmlArray)



Section 34.5: Behaviour: Map Element name to Property


Section 34.6: Eciently building multiple serializers with derived types specified dynamically
Where we came from
Sometimes we can't provide all of the required metadata needed for the XmlSerializer framework in attribute.
Suppose we have a base class of serialized objects, and some of the derived classes are unknown to the base class. We can't place an attribute for all of the classes which are not know at the design time of the base type. We could have another team developing some of the derived classes.
What can we do
new XmlSerializer(type, knownTypesWe can use ), but that would be a O(N^2) operation for N serializers, at least to discover all of the types supplied in arguments:
// Beware of the N^2 in terms of the number of types. var allSerializers = allTypes.Select(t => new XmlSerializer(t, allTypes)); var serializerDictionary = Enumerable.Range(0, allTypes.Length)     .ToDictionary (i => allTypes[i], i => allSerializers[i])
In this example, the the Base type is not aware of it's derived types, which is normal in OOP.
Doing it efficiently
Luckily, there is a method which addresses this particular problem - supplying known types for multiple serializers efficiently:
System.Xml.Serialization.XmlSerializer.FromTypes Method (Type[])



Output:
Trying to serialize without a derived class metadata:
<?xml version="1.0" encoding="utf-16"?>
 System.InvalidOperationException: The type Program+Derived was not expected. Use the XmlInclude or SoapInclude attribute to specify types that are not known statically.
at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationWriter1.Write2_Base(String n, String ns, Base o, Boolean isNullable, Boolean needType) at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationWriter1.Write3_Container(String n, String ns, Container o, Boolean isNullable, Boolean needType) at Microsoft.Xml.Serialization.GeneratedAssembly.XmlSerializationWriter1.Write4_Container(Object o) at System.Xml.Serialization.XmlSerializer.Serialize(XmlWriter xmlWriter, Object o, XmlSerializerNamespaces namespaces, String encodingStyle, String id)
--- End of inner exception stack trace --at System.Xml.Serialization.XmlSerializer.Serialize(XmlWriter xmlWriter, Object o, XmlSerializerNamespaces namespaces, String encodingStyle, String id) at System.Xml.Serialization.XmlSerializer.Serialize(XmlWriter xmlWriter, Object o, XmlSerializerNamespaces namespaces, String encodingStyle) at System.Xml.Serialization.XmlSerializer.Serialize(XmlWriter xmlWriter, Object o, XmlSerializerNamespaces namespaces) at Program.Serialize[T](T o) at Program.Main() Now trying to serialize with all of the type information:
<?xml version="1.0" encoding="utf-16"?>
0
0
Slides down well this time!
What's in the output
This error message recommends what we tried to avoid (or what we can not do in some scenarios) - referencing derived types from base class:
Use the XmlInclude or SoapInclude attribute to specify types that are not known statically.
This is how we get our derived class in the XML:
<Base xsi:type="Derived">
Base corresponds to the property type declared in the Container type, and Derived being the type of the instance actually supplied.
Here is a working example fiddle
Chapter 35: VB Forms
Section 35.1: Hello World in VB.NET Forms
To show a message box when the form has been shown:

Load() will be called first, and only once, when the form first loads. Show() will be called every time the user launches the form. Activate() will be called every time the user makes the form active.
Load() will execute before Show() is called, but be warned: calling msgBox() in show can cause that msgBox() to execute before Load() is finished. It is generally a bad idea to depend on event ordering between Load(), Show(), and similar.
Section 35.2: For Beginners
Some things all beginners should know / do that will help them have a good start with VB .Net:
Set the following Options:

Use &, not + for string concatenation. Strings should be studied in some detail as they are widely used.
Spend some time understanding Value and Reference Types.
Never use Application.DoEvents. Pay attention to the 'Caution'. When you reach a point where this seems like something you must use, ask.
The documentation is your friend.
Section 35.3: Forms Timer
The Windows.Forms.Timer component can be used to provide the user information that is not time critical. Create a form with one button, one label, and a Timer component.
For example it could be used to show the user the time of day periodically.

But this timer is not suited for timing. An example would be using it for a countdown. In this example we will simulate a countdown to three minutes. This may very well be one of the most boringly important examples here.

After button1 is clicked, about three minutes pass and label1 shows the results. Does label1 show 180? Probably not. On my machine it showed 182.5!
The reason for the discrepancy is in the documentation, "The Windows Forms Timer component is single-threaded, and is limited to an accuracy of 55 milliseconds." This is why it shouldn't be used for timing.
By using the timer and stopwatch a little differently we can obtain better results.

There are other timers that can be used as needed. This search should help in that regard.
Chapter 36: JIT compiler
JIT compilation, or just-in-time compilation, is an alternative approach to interpretation of code or ahead-of-time compilation. JIT compilation is used in the .NET framework. The CLR code (C#, F#, Visual Basic, etc.) is first compiled into something called Interpreted Language, or IL. This is lower level code that is closer to machine code, but is not platform specific. Rather, at runtime, this code is compiled into machine code for the relevant system.
Section 36.1: IL compilation sample
Simple Hello World Application:

Equivalent IL Code (which will be JIT compiled)
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.6.1055.0 //  Copyright (c) Microsoft Corporation.  All rights reserved.
// Metadata version: v4.0.30319
.assembly extern mscorlib
{ .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
.ver 4:0:0:0
}
.assembly HelloWorld
{
.custom instance void
[mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00
08 00 00 00 00 00 )
.custom instance void
[mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00
54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
// --- The following custom attribute is added automatically, do not uncomment -------
//  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype
[mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 )
.custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 )    // ...HelloWorld..
.custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = (
01 00 00 00 00 )
.custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) =
( 01 00 00 00 00 )
.custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01
00 00 00 00 )
.custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 )    // ...HelloWorld..
.custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 12 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ...Copyright ..
20 32 30 31 37 00 00 )                            //  2017..
.custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01
00 00 00 00 )
.custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) =
( 01 00 00 00 00 )
.custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01
00 24 33 30 38 62 33 64 38 36 2D 34 31 37 32   // ..$308b3d86-4172
2D 34 30 32 32 2D 61 66 63 63 2D 33 66 38 65 33   // -4022-afcc-3f8e3 32 33 33 63 35 62 30 00 00 )                      // 233c5b0..
.custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
.custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string)
= ( 01 00 1C 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework 2C 56 65 72 73 69 6F 6E 3D 76 34 2E 35 2E 32 01   // ,Version=v4.5.2.
00 54 0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73   // .T..FrameworkDis
70 6C 61 79 4E 61 6D 65 14 2E 4E 45 54 20 46 72   // playName..NET Fr
61 6D 65 77 6F 72 6B 20 34 2E 35 2E 32 )          // amework 4.5.2
.hash algorithm 0x00008004
.ver 1:0:0:0
}
.module HelloWorld.exe
// MVID: {2A7E1D59-1272-4B47-85F6-D7E1ED057831}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0003       // WINDOWS_CUI
.corflags 0x00020003    //  ILONLY 32BITPREFERRED
// Image base: 0x0000021C70230000
// =============== CLASS MEMBERS DECLARATION ===================
.class private auto ansi beforefieldinit HelloWorld.Program extends [mscorlib]System.Object {
.method private hidebysig static void  Main(string[] args) cil managed
{
.entrypoint
// Code size       13 (0xd)
.maxstack  8
IL_0000:  nop
IL_0001:  ldstr      "Hello World"
IL_0006:  call       void [mscorlib]System.Console::WriteLine(string)
IL_000b:  nop
IL_000c:  ret
} // end of method Program::Main
.method public hidebysig specialname rtspecialname instance void  .ctor() cil managed {
// Code size       8 (0x8)
.maxstack  8
IL_0000:  ldarg.0
IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
IL_0006:  nop
IL_0007:  ret
} // end of method Program::.ctor
} // end of class HelloWorld.Program
Generated with MS ILDASM tool (IL disassembler)

Chapter 37: CLR
Section 37.1: An introduction to Common Language Runtime
The Common Language Runtime (CLR) is a virtual machine environment and part of the .NET Framework. It contains:
A portable bytecode language called Common Intermediate Language (abbreviated CIL, or IL)
A Just-In-Time compiler that generates machine code
A tracing garbage collector that provides automatic memory management
Support for lightweight sub-processes called AppDomains
Security mechanisms through the concepts of verifiable code and trust levels
Code that runs in the CLR is referred to as managed code to distinguish it from code running outside the CLR (usually native code) which is referred to as unmanaged code. There are various mechanisms that facilitate interoperability between managed and unmanaged code.

Chapter 38: TPL Dataflow
Section 38.1: Asynchronous Producer Consumer With A Bounded BuerBlock

Section 38.2: Posting to an ActionBlock and waiting for completion

Section 38.3: Linking blocks to create a pipeline

    async uri => await httpClient.GetStringAsync(uri));
// Create a block that accepts the content and prints it to the console var printerBlock = new ActionBlock<string>(     contents => Console.WriteLine(contents));
// Make the downloaderBlock complete the printerBlock when its completed. var dataflowLinkOptions = new DataflowLinkOptions {PropagateCompletion = true};
// Link the block to create a pipeline downloaderBlock.LinkTo(printerBlock, dataflowLinkOptions);
// Post urls to the first block which will pass their contents to the second one.
downloaderBlock.Post("http://youtube.com"); downloaderBlock.Post("http://github.com"); downloaderBlock.Post("http://twitter.com");
downloaderBlock.Complete(); // Completion will propagate to printerBlock
await printerBlock.Completion; // Only need to wait for the last block in the pipeline
Section 38.4: Synchronous Producer/Consumer with BuerBlock<T>



Chapter 39: Threading
Section 39.1: Accessing form controls from other threads
If you want to change an attribute of a control such as a textbox or label from another thread than the GUI thread that created the control, you will have to invoke it or else you might get an error message stating:
"Cross-thread operation not valid: Control 'control_name' accessed from a thread other than the thread it was created on."
Using this example code on a system.windows.forms form will cast an exception with that message:

Instead when you want to change a textbox's text from within a thread that doesn't own it use Control.Invoke or Control.BeginInvoke. You can also use Control.InvokeRequired to check if invoking the control is necessary.

If you need to do this often, you can write an extension for invokeable objects to reduce the amount of code necessary to make this check:

And updating the textbox from any thread becomes a bit simpler:

Be aware that Control.BeginInvoke as used in this example is asynchronous, meaning that code coming after a call to Control.BeginInvoke can be run immedeately after, whether or not the passed delegate has been executed yet.
If you need to be sure that textBox1 is updated before continuing, use Control.Invoke instead, which will block the calling thread until your delegate has been executed. Do note that this approach can slow your code down significantly if you make many invoke calls and note that it will deadlock your application if your GUI thread is waiting for the calling thread to complete or release a held resource.

Chapter 40: Process and Thread anity setting
Parameter	Details
integer that describes the set of processors on which the process is allowed to run. For example, on a 8
affinity	processor system if you want your process to be executed only on processors 3 and 4 than you choose affinity like this : 00001100 which equals 12
Section 40.1: Get process anity mask

Example of usage :

Section 40.2: Set process anity mask
    public static void SetProcessAffinityMask(int affinity, string processName = null)

Example of usage :


Chapter 41: Parallel processing using .Net framework
This Topic is about Multi core programming using Task Parallel Library with .NET framework. The task parallel library allows you to write code which is human readable and adjusts itself with the number of Cores available. So you can be sure that your software would auto-upgrade itself with the upgrading environment.
Section 41.1: Parallel Extensions
Parallel extensions have been introduced along with the Task Parallel Library to achieve data Parallelism. Data parallelism refers to scenarios in which the same operation is performed concurrently (that is, in parallel) on elements in a source collection or array. The .NET provides new constructs to achieve data parallelism by using Parallel.For and Parallel.Foreach constructs.

The above mentioned Parallel.ForEach construct utilizes the multiple cores and thus enhances the performance in the same fashion.
Chapter 42: Task Parallel Library (TPL)
Section 42.1: Basic producer-consumer loop (BlockingCollection)

collection.CompleteAdding();collection.CompleteAdding();It is worth noting that if you do not call , you are able to keep adding to the collection even if your consumer task is running. Just call  when you are sure there
are no more additions. This functionality can be used to make a Multiple Producer to a Single Consumer pattern where you have multiple sources feeding items into the BlockingCollection and a single consumer pulling items out and doing something with them. If your BlockingCollection is empty before you call complete adding, the
collection.GetConsumingEnumerable()Enumerable from  will block until a new item is added to the collection or
BlockingCollection.CompleteAdding(); is called and the queue is empty.

Section 42.2: Parallel.Invoke


Section 42.3: Task: Returning a value
Task< TResult Task that return a value has return type of > where TResult is the type of value that needs to be returned. You can query the outcome of a Task by its Result property.

If the Task execute asynchronously than awaiting the Task returns it's result.

Section 42.4: Parallel.ForEach
Parallel.ForEachInterlocked.AddThis example uses  to calculate the sum of the numbers between 1 and 10000 by using multiple threads. To achieve thread-safety,  is used to sum the numbers.

Section 42.5: Parallel.For
Parallel.ForInterlocked.AddThis example uses  to calculate the sum of the numbers between 1 and 10000 by using multiple threads. To achieve thread-safety,  is used to sum the numbers.


Section 42.6: Task: basic instantiation and Wait
A task can be created by directly instantiating the Task class...

Task.Run...or by using the static  method:

Note that only in the first case it is necessary to explicitly invoke Start.
Section 42.7: Task.WhenAll

Section 42.8: Flowing execution context with AsyncLocal
When you need to pass some data from the parent task to its children tasks, so it logically flows with the execution, use AsyncLocal class:


AsynLocal.ValueNote: As can be seen from the example above  has copy on read semantic, but if you flow some
reference type and change its properties you will affect other tasks. Hence, best practice with AsyncLocal is to use value types or immutable types.
Section 42.9: Parallel.ForEach in VB.NET

Section 42.10: Task: WaitAll and variable capturing


Section 42.11: Task: WaitAny

Note: The final WaitAll is necessary becasue WaitAny does not cause exceptions to be observed.
Section 42.12: Task: handling exceptions (using Wait)

Section 42.13: Task: handling exceptions (without using Wait)


Section 42.14: Task: cancelling using CancellationToken

As an alternative to ThrowIfCancellationRequested, the cancellation request can be detected with IsCancellationRequested and a OperationCanceledException can be thrown manually:


Note how the cancellation token is passed to the task constructor in the cancellationToken parameter. This is needed so that the task transitions to the Canceled state, not to the Faulted state, when
ThrowIfCancellationRequested is invoked. Also, for the same reason, the cancellation token is explicitly supplied in the constructor of OperationCanceledException in the second case.
Section 42.15: Task.WhenAny

Chapter 43: Task Parallel Library (TPL) API Overviews
Section 43.1: Perform work in response to a button click and update the UI
This example demonstrates how you can respond to a button click by performing some work on a worker thread and then update the user interface to indicate completion


Chapter 44: Synchronization Contexts
Section 44.1: Execute code on the UI thread after performing background work
This example shows how to update a UI component from a background thread by using a SynchronizationContext

MyTextBox.TextIn this example, if you tried to directly update  inside the for loop, you would get a threading error.
By posting the UpdateCallback action to the SynchronizationContext, the text box is updated on the same thread as the rest of the UI.
System.IProgress<T>System.Progress<T>In practice, progress updates should be performed using an instance of . The default implementation  automatically captures the synchronisation context it is created on.
Chapter 45: Memory management
Section 45.1: Use SafeHandle when wrapping unmanaged resources
When writing wrappers for unmanaged resources, you should subclass SafeHandle rather than trying to implement IDisposable and a finalizer yourself. Your SafeHandle subclass should be as small and simple as possible to minimize the chance of a handle leak. This likely means that your SafeHandle implementation would an internal implementation detail of a class which wraps it to provide a usable API. This class ensures that, even if a program leaks your SafeHandle instance, your unmanaged handle is released.

Disclaimer: This example is an attempt to show how to guard a managed resource with SafeHandle which implements IDisposable for you and configures finalizers appropriately. It is very contrived and likely pointless to allocate a chunk of memory in this manner.
Section 45.2: Unmanaged Resources
When we talk about the GC and the "heap", we're really talking about what's called the managed heap. Objects on the managed heap can access resources not on the managed heap, for example, when writing to or reading from a file. Unexpected behavior can occur when, a file is opened for reading and then an exception occurs, preventing the file handle from closing as it normally would. For this reason, .NET requires that unmanaged resources implement the IDisposable interface. This interface has a single method called Dispose with no parameters:

DisposeWhen handling unmanaged resources, you should make sure that they are properly disposed. You can do this by explicitly calling () in a finally block, or with a using statement.


or

The latter is the preferred method, and is automatically expanded to the former during compilation.

Chapter 46: Garbage Collection
In .Net, objects created with new() are allocated on the managed heap. These objects are never explicitly finalized by the program that uses them; instead, this process is controlled by the .Net Garbage Collector.
Some of the examples below are "lab cases" to show the Garbage Collector at work and some significant details of its behavior, while other focus on how to prepare classes for proper handling by the Garbage Collector.
Section 46.1: A basic example of (garbage) collection
Given the following class:

A program that creates an instance, even without using it:

Produces the following output:

If nothing else happens, the object is not finalized until the program ends (which frees all objects on the managed heap, finalizing these in the process).
It is possible to force the Garbage Collector to run at a given point, as follows:

Which produces the following result:

This time, as soon as the Garbage Collector was invoked, the unused (aka "dead") object was finalized and freed from the managed heap.
Section 46.2: Live objects and dead objects - the basics
Rule of thumb: when garbage collection occurs, "live objects" are those still in use, while "dead objects" are those no longer used (any variable or field referencing them, if any, has gone out of scope before the collection occurs).
In the following example (for convenience, FinalizableObject1 and FinalizableObject2 are subclasses of
FinalizableObject from the example above and thus inherit the initialization / finalization message behavior):
var obj1 = new FinalizableObject1(); // Finalizable1 instance allocated here var obj2 = new FinalizableObject2(); // Finalizable2 instance allocated here obj1 = null; // No more references to the Finalizable1 instance GC.Collect();
The output will be:

At the time when the Garbage Collector is invoked, FinalizableObject1 is a dead object and gets finalized, while FinalizableObject2 is a live object and it is kept on the managed heap.
Section 46.3: Multiple dead objects
What if two (or several) otherwise dead objects reference one another? This is shown in the example below, supposing that OtherObject is a public property of FinalizableObject:

This produces the following output:

The two objects are finalized and freed from the managed heap despite referencing each other (because no other reference exists to any of them from an actually live object).
Section 46.4: Weak References
Weak references are... references, to other objects (aka "targets"), but "weak" as they do not prevent those objects from being garbage-collected. In other words, weak references do not count when the Garbage Collector evaluates objects as "live" or "dead".
The following code:

Produces the output:


The object is freed from the managed heap despite being referenced by the WeakReference variable (still in scope when the Garbage collector was invoked).
Consequence #1: at any time, it is unsafe to assume whether a WeakReference target is still allocated on the managed heap or not.
Consequence #2: whenever a program needs to access the target of a Weakreference, code should be provided for both cases, of the target being still allocated or not. The method to access the target is TryGetTarget:

The generic version of WeakReference is available since .Net 4.5. All framework versions provide a non-generic, untyped version that is built in the same way and checked as follows:

Section 46.5: Dispose() vs. finalizers
Implement Dispose() method (and declare the containing class as IDisposable) as a means to ensure any memoryheavy resources are freed as soon as the object is no longer used. The "catch" is that there is no strong guarantee the the Dispose() method would ever be invoked (unlike finalizers that always get invoked at the end of the life of the object).
One scenario is a program calling Dispose() on objects it explicitly creates:

Another scenario is declaring a class to be instantiated by the framework. In this case the new class usually inherits a base class, for instance in MVC one creates a controller class as a subclass of System.Web.Mvc.ControllerBase. When the base class implements IDisposable interface, this is a good hint that Dispose() would be invoked properly by the framework - but again there is no strong guarantee.
Thus Dispose() is not a substitute for a finalizer; instead, the two should be used for different purposes:
A finalizer eventually frees resources to avoid memory leaks that would occur otherwise
 Dispose() frees resources (possibly the same ones) as soon as these are no longer needed, to ease pressure on overall memory allocation.
 Section 46.6: Proper disposal and finalization of objects
As Dispose() and finalizers are aimed to different purposes, a class managing external memory-heavy resources should implement both of them. The consequence is writing the class so that it handles well two possible scenarios:
When only the finalizer is invoked
When Dispose() is invoked first and later the finalizer is invoked as well
One solution is writing the cleanup code in such a way that running it once or twice would produce the same result as running it only once. Feasibility depends on the nature of the cleanup, for instance:
Closing an already closed database connection would probably have no effect so it works
Updating some "usage count" is dangerous and would produce a wrong result when called twice instead of once.
A safer solution is ensuring by design that the cleanup code is called once and only once whatever the external context. This can be achieved the "classic way" using a dedicated flag:


Alternately, the Garbage Collector provides a specific method SuppressFinalize() that allows skipping the finalizer after Dispose has been invoked:


Chapter 47: Exceptions
Section 47.1: Catching and rethrowing caught exceptions
When you want to catch an exception and do something, but you can't continue execution of the current block of code because of the exception, you may want to rethrow the exception to the next exception handler in the call stack. There are good ways and bad ways to do this.


You can filter by exception type and even by exception properties (new in C# 6.0, a bit longer available in VB.NET (citation needed)):
Documentation/C#/new features
Section 47.2: Using a finally block
finally { ... } block of a try-finally or try-catch-finallyThe  will always execute, regardless of whether an
Environment.FailFastexception occurred or not (except when a StackOverflowException has been thrown or call has been made to ()).
try { ... It can be utilized to free or clean up resources acquired in the } block safely.

Section 47.3: Exception Filters
Since C# 6.0 exceptions can be filtered using the when operator.
This is similar to using a simple if but does not unwind the stack if the condition inside the when is not met.
Example

The same info can be found in the C# 6.0 Features here: Exception filters
Section 47.4: Rethrowing an exception within a catch block
Within a catch block the throw keyword can be used on its own, without specifying an exception value, to rethrow the exception which was just caught. Rethrowing an exception allows the original exception to continue up the exception handling chain, preserving its call stack or associated data:

throw exA common anti-pattern is to instead , which has the effect of limiting the next exception handler's view of the stack trace:

throw exthrow exIn general using  isn't desirable, as future exception handlers which inspect the stack trace will only be able to see calls as far back as . By omitting the ex variable, and using the throw keyword alone the original exception will "bubble-up".
Section 47.5: Throwing an exception from a dierent method while preserving its information
Occasionally you'd want to catch an exception and throw it from a different thread or method while preserving the original exception stack. This can be done with ExceptionDispatchInfo:


Section 47.6: Catching an exception
Code can and should throw exceptions in exceptional circumstances. Examples of this include:
Attempting to read past the end of a stream
Not having necessary permissions to access a file
Attempting to perform an invalid operation, such as dividing by zero A timeout occurring when downloading a file from the internet
The caller can handle these exceptions by "catching" them, and should only do so when:
It can actually resolve the exceptional circumstance or recover appropriately, or;
It can provide additional context to the exception that would be useful if the exception needs to be re-thrown
(re-thrown exceptions are caught by exception handlers further up the call stack)
It should be noted that choosing not to catch an exception is perfectly valid if the intention is for it to be handled at a higher level.
try { ... Catching an exception is done by wrapping the potentially-throwing code in a } block as follows, and catching the exceptions it's able to handle in a 

Chapter 48: System.Diagnostics
Section 48.1: Run shell commands
 string strCmdText = "/C copy /b Image1.jpg + Archive.rar Image2.jpg"; System.Diagnostics.Process.Start("CMD.exe",strCmdText); This is to hide the cmd window.
System.Diagnostics.Process process = new System.Diagnostics.Process();
System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden; startInfo.FileName = "cmd.exe"; startInfo.Arguments = "/C copy /b Image1.jpg + Archive.rar Image2.jpg"; process.StartInfo = startInfo; process.Start();
Section 48.2: Send Command to CMD and Receive Output
Cmd.exeThis method allows a command to be sent to , and returns the standard output (including standard error) as a string:

Usage
var servername = "SVR-01.domain.co.za";
var currentUsers = SendCommand($"/C QUERY USER /SERVER:{servername}")
Output
		string currentUsers = "USERNAME SESSIONNAME ID STATE IDLE TIME LOGON TIME Joe.Bloggs ica-cgp#0 2
Active 24692+13:29 25/07/2016 07:50 Jim.McFlannegan ica-cgp#1 3 Active . 25/07/2016 08:33 Andy.McAnderson ica-cgp#2 4 Active . 25/07/2016 08:54 John.Smith ica-cgp#4 5 Active 14 25/07/2016
08:57 Bob.Bobbington ica-cgp#5 6 Active 24692+13:29 25/07/2016 09:05 Tim.Tom ica-cgp#6 7 Active .
25/07/2016 09:08 Bob.Joges ica-cgp#7 8 Active 24692+13:29 25/07/2016 09:13"
On some occasions, access to the server in question may be restricted to certain users. If you have the login credentials for this user, then it is possible to send queries with this method:

Getting the password:

Notes
Both of the above methods will return a concatenation of STDOUT and STDERR, as OutputDataReceived and ErrorDataReceived are both appending to the same variable - cmdOut.
Section 48.3: Stopwatch
This example shows how Stopwatch can be used to benchmark a block of code.

Chapter 49: Encryption / Cryptography
Section 49.1: Encryption and Decryption using Cryptography (AES)
Decryption Code

Encryption Code


Usage

Section 49.2: RijndaelManaged


Usage

Note:
 Rijndael is the predecessor of the standard symmetric cryptographic algorithm AES.
Section 49.3: Encrypt and decrypt data using AES (in C#)


                {
                    // Encrypt the string to an array of bytes.
                    byte[] encrypted = EncryptStringToBytes_Aes(original,                                                                 myAes.Key,                                                                 myAes.IV);
                    // Decrypt the bytes to a string.
                    string roundtrip = DecryptStringFromBytes_Aes(encrypted,                                                                   myAes.Key,                                                                   myAes.IV);
                    //Display the original data and the decrypted data.
                    Console.WriteLine("Original:   {0}", original);                     Console.WriteLine("Round Trip: {0}", roundtrip);
                }             }             catch (Exception e)             {
                Console.WriteLine("Error: {0}", e.Message);
            }         }
        static byte[] EncryptStringToBytes_Aes(string plainText, byte[] Key, byte[] IV)         {
            // Check arguments.
            if (plainText == null || plainText.Length <= 0)                 throw new ArgumentNullException("plainText");             if (Key == null || Key.Length <= 0)                 throw new ArgumentNullException("Key");             if (IV == null || IV.Length <= 0)                 throw new ArgumentNullException("IV");             byte[] encrypted;
            // Create an Aes object with the specified key and IV.             using (Aes aesAlg = Aes.Create())             {                 aesAlg.Key = Key;                 aesAlg.IV = IV;
                // Create a decrytor to perform the stream transform.
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key,                                                                     aesAlg.IV);
                // Create the streams used for encryption.
                using (MemoryStream msEncrypt = new MemoryStream())                 {                     using (CryptoStream csEncrypt = new CryptoStream(msEncrypt,                                                                      encryptor,                                                                      CryptoStreamMode.Write))                     {                         using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))                         {
                            //Write all data to the stream.
                            swEncrypt.Write(plainText);                         }
                        encrypted = msEncrypt.ToArray();                     }
                }
            }
This example is from MSDN.
It is a console demo application, showing how to encrypt a string by using the standard AES encryption, and how to decrypt it afterwards.
(AES = Advanced Encryption Standard, a specification for the encryption of electronic data established by the U.S. National Institute of Standards and Technology (NIST) in 2001 which is still the de-facto standard for symmetric encryption)
Notes:
CipherMode.ECB In a real encryption scenario, you need to choose a proper cipher mode (can be assigned to the Mode property by selecting a value from the CipherMode enumeration). Never use the  (electronic codebook mode), since this procuces a weak cypher stream
 To create a good (and not a weak) Key, either use a cryptographic random generator or use the example above (Create a Key from a Password). The recommended KeySize is 256 bit. Supported key sizes are available via the LegalKeySizes property.
To initialize the initialization vector IV, you can use a SALT as shown in the example above (Random SALT)
Supported block sizes are available via the SupportedBlockSizes property, the block size can be assigned via the BlockSize property
Usage: see Main() method.
Section 49.4: Create a Key from a Password / Random SALT (in C#)


This example is taken from MSDN.
It is a console demo, and it shows how to create a secure key based on a user-defined password, and how to create a random SALT based on the cryptographic random generator.
Notes:
 The built-in function PasswordDeriveBytes uses the standard PBKDF1 algorithm to generate a key from the password. Per default, it uses 100 iterations to generate the key to slow down brute force attacks. The SALT generated randomly further strenghens the key.
 The function CryptDeriveKey converts the key generated by PasswordDeriveBytes into a key compatible with the specified encryption algorithm (here "TripleDES") by using the specified hash algorithm (here "SHA1"). The keysize in this example is 192 bytes, and the initialization vector IV is taken from the triple-DES crypto provider
 Usually, this mechanism is used to protect a stronger random generated key by a password, which encrypts large amount of data. You can also use it to provide multiple passwords of different users to give access to the same data (being protected by a different random key).
 Unfortunately, CryptDeriveKey does currently not support AES. See here.
NOTE: As a workaround, you can create a random AES key for encryption of the data to be protected with AES and store the AES key in a TripleDES-Container which uses the key generated by CryptDeriveKey. But that limits the security to TripleDES, does not take advantage of the larger keysizes of AES and creates a dependency to TripleDES.
Usage: See Main() method.

Chapter 50: Work with SHA1 in C#
in this project you see how to work with SHA1 cryptographic hash function. for example get hash from string and how to crack SHA1 hash.
source compelete on github: https://github.com/mahdiabasi/SHA1Tool
Section 50.1: #Generate SHA1 checksum of a file

Section 50.2: #Generate hash of a text

Chapter 51: Unit testing
Section 51.1: Adding MSTest unit testing project to an existing solution
Foo.TestsRight click on the solution, Add new project
From the Test section, select an Unit Test Project
 Pick a name for the assembly - if you are testing project Foo, the name can be Add a reference to the tested project in the unit test project references
 Section 51.2: Creating a sample test method
[TestClass][TestMethod]MSTest (the default testing framework) requires you to have your test classes decorated by a  attribute, and the test methods with a  attribute, and to be public.

Chapter 52: Write to and read from StdErr stream
Section 52.1: Write to standard error output using Console

Section 52.2: Read from standard error of child process

Chapter 53: Upload file and POST data to webserver
Section 53.1: Upload file with WebRequest
To send a file and form data in single request, content should have multipart/form-data type.

Usage:



Chapter 54: Networking
Section 54.1: Basic TCP chat (TcpListener, TcpClient, NetworkStream)


Section 54.2: Basic SNTP client (UdpClient)
See RFC 2030 for details on the SNTP protocol.


Chapter 55: HTTP servers
Section 55.1: Basic read-only HTTP file server (ASP.NET Core)
1 - Create an empty folder, it will contain the files created in the next steps.
project.json2 - Create a file named  with the following content (adjust the port number and rootDirectory as appropriate):

Startup.cs3 - Create a file named  with the following code:


4 - Open a command prompt, navigate to the folder and execute:

Note: These commands need to be run only once. Use dnvm list to check the actual number of the latest installed version of the core CLR.
http://localhost:60000/path/to/file.ext5 - Start the server with: dnx web. Files can now be requested at .
For simplicity, filenames are assumed to be all ASCII (for the filename part in the Content-Disposition header) and file access errors are not handled.
Section 55.2: Basic read-only HTTP file server (HttpListener)
Notes:
This example must be run in administrative mode.
Only one simultaneous client is supported.
For simplicity, filenames are assumed to be all ASCII (for the filename part in the Content-Disposition header) and file access errors are not handled.


        listener = new HttpListener();         listener.Prefixes.Add("http://*:" + port + "/");         listener.Start();
        Console.WriteLine("--- Server stated, base path is: " + baseFilesystemPath);         Console.WriteLine("--- Listening, exit with Ctrl-C");         try         {
            ServerLoop();         }         catch(Exception ex)         {             Console.WriteLine(ex);             if(response != null)
            {
                SendErrorResponse(500, "Internal server error");
            }
        }     }
    static void ServerLoop()     {         while(true)         {             var context = listener.GetContext();
            var request = context.Request;             response = context.Response;
            var fileName = request.RawUrl.Substring(1);
            Console.WriteLine(
                "--- Got {0} request for: {1}",                 request.HttpMethod, fileName);
            if (request.HttpMethod.ToUpper() != "GET")
            {                 SendErrorResponse(405, "Method must be GET");                 continue;             }
            var fullFilePath = Path.Combine(baseFilesystemPath, fileName);             if(!File.Exists(fullFilePath))
            {
                SendErrorResponse(404, "File not found");                 continue;             }
            Console.Write("    Sending file...");             using (var fileStream = File.OpenRead(fullFilePath))
            {                 response.ContentType = "application/octet-stream";                 response.ContentLength64 = (new FileInfo(fullFilePath)).Length;                 response.AddHeader(
                    "Content-Disposition",                     "Attachment; filename=\"" + Path.GetFileName(fullFilePath) + "\"");                 fileStream.CopyTo(response.OutputStream);
            }
            response.OutputStream.Close();             response = null;             Console.WriteLine(" Ok!");
        }
    }

Chapter 56: HTTP clients
Section 56.1: Reading GET response as string using System.Net.HttpClient
HttpClient is available through NuGet: Microsoft HTTP Client Libraries.

Section 56.2: Basic HTTP downloader using System.Net.Http.HttpClient


Section 56.3: Reading GET response as string using System.Net.HttpWebRequest

Section 56.4: Reading GET response as string using System.Net.WebClient

Section 56.5: Sending a POST request with a string payload using System.Net.HttpWebRequest


Section 56.6: Sending a POST request with a string payload using System.Net.WebClient

Section 56.7: Sending a POST request with a string payload using System.Net.HttpClient
HttpClient is available through NuGet: Microsoft HTTP Client Libraries.

Chapter 57: Serial Ports
Section 57.1: Basic operation

Section 57.2: List available port names

Section 57.3: Asynchronous read

Section 57.4: Synchronous text echo service


Section 57.5: Asynchronous message receiver


This program waits for messages enclosed in STX and ETX bytes and outputs the text coming between them. Everything else is discarded. On write buffer overflow it stops. On other errors it reset input and output buffers and waits for further messages.
The code illustrates:
SerialPort.DataReceivedAsynchronous serial port reading (see  usage).
SerialPort.ErrorReceivedSerial port error processing (see  usage).
Non-text message-based protocol implementation.
Partial message reading.
SerialPort.DataReceivedThe  event may happen earlier than entire message (up to ETX) comes. The entire message may also not be available in the input buffer (SerialPort.Read(..., ..., port.BytesToRead) reads only a part of the message). In this case we stash the received part (unprocessedBuffer) and carry on waiting for further data.
 Dealing with several messages coming in one go.
SerialPort.DataReceived The 	 event may happen only after several messages have been sent by the other end.

Appendix A: Acronym Glossary
Section A.1: .Net Related Acronyms
Please note that some terms like JIT and GC are generic enough to apply to many programming language environments and runtimes.
CLR: Common Language Runtime
IL: Intermediate Language
EE: Execution Engine
JIT: Just-in-time compiler
GC: Garbage Collector
OOM: Out of memory
STA: Single-threaded apartment
MTA: Multi-threaded apartment

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
Adi LesterChapters 42 and 47Adil MammadovChapter 8Adriano RepettiChapters 1, 2, 4 and 18Akshay AnandChapter 25Alan McBeeChapters 12, 14 and 47ale10anderChapters 16 and 35Aleks AndreevChapters 10, 52 and 53Alexander MandtChapter 49Alexander V.Chapter 8Alfred MyersChapter 47Aman SharmaChapters 5 and 42Andrew JensChapter 1Andrew MortonChapter 25Andrey ShchekinChapter 28AndriusChapter 32Anik SahaChapter 28AphelionChapter 34Arvin BaccayChapter 47ArxaeChapter 19AshtonianChapter 28AthariChapter 1avatChapter 46AxarydaxChapter 51BananaSftChapter 47BassieChapter 48BehzadChapter 39Benjamin HodgsonChapter 8binkiChapter 45BjørnChapters 4 and 10Bradley GraingerChapter 8Bruno GarciaChapter 8BrunoLMChapter 15Carlos MuñozChapter 8CodeCasterChapters 8, 17, 28, 47 and 56Daniel A. WhiteChapters 1 and 25Darrel LeeChapter 4Dave R.Chapter 47dbasnettChapter 35delete meChapter 18demonplusChapters 30 and 49DenuathChapter 15DLehChapters 31 and 33Dmitry EgorovChapters 27 and 57DoNotChapter 8Dr Rob LangChapter 9DrewChapter 25DrewJordanChapters 12 and 45
Eduardo MolteniChapter 8Ehsan SajjadChapter 8EricChapter 32Felipe OrianiChapters 4 and 5Filip FrączChapter 17FredouChapter 48GajendraChapter 37GalacticCowboyChapters 3 and 8George PolevoyChapters 4, 11 and 34GuanxiChapter 22GusdorChapters 43 and 44HaneyChapter 8harriyottChapter 5hatchetChapter 4HeinziChapter 25HoganChapter 4Hywel ReesChapter 7i3arnonChapter 38IanChapter 4IgorChapter 25IngenioushaxChapter 16Jacobr365Chapters 38, 42 and 43Jagadisha B SChapter 49JamyRyalsChapter 42jbtuleChapter 8JigarChapter 10JimChapter 11jnovoChapter 8Joe AmentaChapters 8 and 20JohnChapter 3Kevin MontroseChapter 1KonamimanChapters 8, 42, 54, 55 and 56Krikor AilanjianChapter 36KritnerChapter 47lokuskingChapter 49Lorenzo DemattéChapter 10LuaanChapter 23Lucas TrzesniewskiChapter 9M22anChapter 32MafiiChapter 47mahdi abasiChapter 50MarcinJuraszekChapters 1 and 8Mark C.Chapter 5Matas VaitkeviciusChapters 10 and 28Mathias MüllerChapter 42MattChapter 49Matt dcChapter 15matteeyahChapter 1Matthew WhitedChapter 13McKayChapter 8MellowChapter 39Mihail StancescuChapter 24Mr.MindorChapter 8
MSEChapter 40n.podbielskiChapter 11Nate BarbettiniChapter 8Nikola.LukovicChapter 38NikolayKondratyevChapter 23OgglasChapter 48Ondřej ŠtorcChapter 48Ozair KafrayChapter 28Pavel MayorovChapter 42Pavel VoroninChapters 2 and 42PedroSoukiChapter 32ProgramFOXChapter 21RingilChapter 4Rion WilliamsChapter 1Robert ColumbiaChapter 4RoyalPotatoChapter 17Ruben SteinsChapter 8Salvador Rubio MartinezChapter 8SammiChapter 8Scott HannenChapters 26 and 29SeeuD1Chapter 1Sergio DomínguezChapter 8Sidewinder94Chapter 8smdragerChapter 10starbeamrainbowlabsChapters 37 and 47SteveChapter 30Steven DoggartChapter 1StilgarChapter 11Tanveer BadarChapter 58tehDorfChapters 6 and 15the berserkerChapter 4Theodoros
ChatzigiannakisChapter 37Thomas BledsoeChapter 42ThriggleChapter 32toddmoChapter 23Tolga EvcimenChapter 32Tomáš HübelbauerChapter 4user2321864Chapter 25vickyChapter 30wangengzhengChapter 11YahfoufiChapter 41ʇolɐǝz ǝɥʇ qoqChapter 1
You may also like







GoalKicker.com - .NET Framework Notes for Professionals	1

GoalKicker.com - .NET Framework Notes for Professionals	1

GoalKicker.com - .NET Framework Notes for Professionals	1







