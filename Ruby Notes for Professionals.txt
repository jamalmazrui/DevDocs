

Contents
About  ................................................................................................................................................................................... 1
Chapter 1: Getting started with Ruby Language  .......................................................................................... 2
Section 1.1: Hello World  ................................................................................................................................................. 2
Section 1.2: Hello World as a Self-Executable File-using Shebang (Unix-like operating systems only)
     .................................................................................................................................................................................. 2 Section 1.3: Hello World from IRB  ................................................................................................................................ 3
Section 1.4: Hello World without source files  .............................................................................................................. 3 Section 1.5: Hello World with tk  .................................................................................................................................... 3
Section 1.6: My First Method  ......................................................................................................................................... 4
Chapter 2: Casting (type conversion)  ................................................................................................................. 6
Section 2.1: Casting to a Float  ...................................................................................................................................... 6 Section 2.2: Casting to a String  .................................................................................................................................... 6 Section 2.3: Casting to an Integer  ................................................................................................................................ 6
Section 2.4: Floats and Integers  ................................................................................................................................... 6
Chapter 3: Operators  .................................................................................................................................................. 8
Section 3.1: Operator Precedence and Methods  ........................................................................................................ 8
Section 3.2: Case equality operator (===)  ................................................................................................................. 10 Section 3.3: Safe Navigation Operator  ...................................................................................................................... 11 Section 3.4: Assignment Operators  ........................................................................................................................... 11
Section 3.5: Comparison Operators  .......................................................................................................................... 12
Chapter 4: Variable Scope and Visibility  ....................................................................................................... 13
Section 4.1: Class Variables  ........................................................................................................................................ 13 Section 4.2: Local Variables  ....................................................................................................................................... 14
Section 4.3: Global Variables  ...................................................................................................................................... 15
Section 4.4: Instance Variables  .................................................................................................................................. 16
Chapter 5: Environment Variables  .................................................................................................................... 18
Section 5.1: Sample to get user profile path  ............................................................................................................. 18
Chapter 6: Constants  ................................................................................................................................................ 19
Section 6.1: Define a constant  .................................................................................................................................... 19 Section 6.2: Modify a Constant  .................................................................................................................................. 19 Section 6.3: Constants cannot be defined in methods  ............................................................................................ 19
Section 6.4: Define and change constants in a class  .............................................................................................. 19
Chapter 7: Special Constants in Ruby  .............................................................................................................. 20
Section 7.1: __FILE__  .................................................................................................................................................. 20
Section 7.2: __dir__  ................................................................................................................................................... 20
Section 7.3: $PROGRAM_NAME or $0  ....................................................................................................................... 20
Section 7.4: $$  .............................................................................................................................................................. 20 Section 7.5: $1, $2, etc  .................................................................................................................................................. 20
Section 7.6: ARGV or $*  ............................................................................................................................................... 20 Section 7.7: STDIN  ....................................................................................................................................................... 20 Section 7.8: STDOUT  ................................................................................................................................................... 20 Section 7.9: STDERR  .................................................................................................................................................... 20 Section 7.10: $stderr  .................................................................................................................................................... 21 Section 7.11: $stdout  ..................................................................................................................................................... 21
Section 7.12: $stdin  ...................................................................................................................................................... 21
Section 7.13: ENV  .......................................................................................................................................................... 21 Chapter 8: Comments  .............................................................................................................................................. 22
Section 8.1: Single & Multiple line comments  ............................................................................................................ 22
Chapter 9: Arrays  ....................................................................................................................................................... 23
Section 9.1: Create Array of Strings  ........................................................................................................................... 23 Section 9.2: Create Array with Array::new  ................................................................................................................ 23 Section 9.3: Create Array of Symbols  ....................................................................................................................... 24
Section 9.4: Manipulating Array Elements  ................................................................................................................ 24
Section 9.5: Accessing elements  ................................................................................................................................ 25
Section 9.6: Creating an Array with the literal constructor [ ]  ................................................................................ 26
Section 9.7: Decomposition  ........................................................................................................................................ 26 Section 9.8: Arrays union, intersection and dierence  ............................................................................................ 27
Section 9.9: Remove all nil elements from an array with #compact  .................................................................... 28
Section 9.10: Get all combinations / permutations of an array  ............................................................................. 28
Section 9.11: Inject, reduce  .......................................................................................................................................... 29
Section 9.12: Filtering arrays  ...................................................................................................................................... 30
Section 9.13: #map  ...................................................................................................................................................... 30
Section 9.14: Arrays and the splat (*) operator  ........................................................................................................ 31
Section 9.15: Two-dimensional array  ........................................................................................................................ 31
Section 9.16: Turn multi-dimensional array into a one-dimensional (flattened) array  ........................................ 32
Section 9.17: Get unique array elements  ................................................................................................................... 32
Section 9.18: Create Array of numbers  ..................................................................................................................... 32
Section 9.19: Create an Array of consecutive numbers or letters  .......................................................................... 33
Section 9.20: Cast to Array from any object  ............................................................................................................ 33
Chapter 10: Multidimensional Arrays  ................................................................................................................ 35
Section 10.1: Initializing a 2D array  ............................................................................................................................. 35 Section 10.2: Initializing a 3D array  ............................................................................................................................ 35
Section 10.3: Accessing a nested array  ..................................................................................................................... 35
Section 10.4: Array flattening  ..................................................................................................................................... 35
Chapter 11: Strings  ...................................................................................................................................................... 37
Section 11.1: Dierence between single-quoted and double-quoted String literals  .............................................. 37
Section 11.2: Creating a String  .................................................................................................................................... 37 Section 11.3: Case manipulation  ................................................................................................................................. 38 Section 11.4: String concatenation  ............................................................................................................................. 38 Section 11.5: Positioning strings  .................................................................................................................................. 39 Section 11.6: Splitting a String  ..................................................................................................................................... 40
Section 11.7: String starts with  ..................................................................................................................................... 40
Section 11.8: Joining Strings  ........................................................................................................................................ 40 Section 11.9: String interpolation  ................................................................................................................................ 41 Section 11.10: String ends with  ..................................................................................................................................... 41 Section 11.11: Formatted strings  .................................................................................................................................. 41 Section 11.12: String Substitution  ................................................................................................................................. 41 Section 11.13: Multiline strings  ...................................................................................................................................... 41 Section 11.14: String character replacements  ............................................................................................................ 42
Section 11.15: Understanding the data in a string  ..................................................................................................... 43
Chapter 12: DateTime  ............................................................................................................................................... 44
Section 12.1: DateTime from string  ............................................................................................................................ 44
Section 12.2: New  ......................................................................................................................................................... 44
Section 12.3: Add/subtract days to DateTime  .......................................................................................................... 44
Chapter 13: Time  .......................................................................................................................................................... 46 Section 13.1: How to use the strftime method  ........................................................................................................... 46 Section 13.2: Creating time objects  ............................................................................................................................ 46
Chapter 14: Numbers  ................................................................................................................................................ 47
Section 14.1: Converting a String to Integer  .............................................................................................................. 47 Section 14.2: Creating an Integer  ............................................................................................................................... 47 Section 14.3: Rounding Numbers  ............................................................................................................................... 47
Section 14.4: Even and Odd Numbers  ....................................................................................................................... 48 Section 14.5: Rational Numbers  ................................................................................................................................. 48 Section 14.6: Complex Numbers  ................................................................................................................................. 48
Section 14.7: Converting a number to a string  ......................................................................................................... 49
Section 14.8: Dividing two numbers  ........................................................................................................................... 49
Chapter 15: Symbols  .................................................................................................................................................. 50
Section 15.1: Creating a Symbol  ................................................................................................................................. 50 Section 15.2: Converting a String to Symbol  ............................................................................................................. 50
Section 15.3: Converting a Symbol to String  ............................................................................................................. 51
Chapter 16: Comparable  ......................................................................................................................................... 52
Section 16.1: Rectangle comparable by area  ........................................................................................................... 52
Chapter 17: Control Flow  ......................................................................................................................................... 53
Section 17.1: if, elsif, else and end  ............................................................................................................................... 53 Section 17.2: Case statement  ..................................................................................................................................... 53
Section 17.3: Truthy and Falsy values  ....................................................................................................................... 55 Section 17.4: Inline if/unless  ........................................................................................................................................ 56 Section 17.5: while, until  ............................................................................................................................................... 56 Section 17.6: Flip-Flop operator  .................................................................................................................................. 57
Section 17.7: Or-Equals/Conditional assignment operator (||=)  .............................................................................. 57
Section 17.8: unless  ...................................................................................................................................................... 58 Section 17.9: throw, catch  ............................................................................................................................................ 58 Section 17.10: Ternary operator  ................................................................................................................................. 58 Section 17.11: Loop control with break, next, and redo  ............................................................................................. 59
Section 17.12: return vs. next: non-local return in a block  ........................................................................................ 61
Section 17.13: begin, end  .............................................................................................................................................. 61
Section 17.14: Control flow with logic statements  ..................................................................................................... 62
Chapter 18: Methods  .................................................................................................................................................. 63
Section 18.1: Defining a method  ................................................................................................................................. 63 Section 18.2: Yielding to blocks  .................................................................................................................................. 63 Section 18.3: Default parameters  ............................................................................................................................... 64 Section 18.4: Optional parameter(s) (splat operator)  ............................................................................................. 65
Section 18.5: Required default optional parameter mix  .......................................................................................... 65 Section 18.6: Use a function as a block  ..................................................................................................................... 66
Section 18.7: Single required parameter  ................................................................................................................... 66
Section 18.8: Tuple Arguments  ................................................................................................................................... 66
Section 18.9: Capturing undeclared keyword arguments (double splat)  .............................................................. 67
Section 18.10: Multiple required parameters  ............................................................................................................. 67
Section 18.11: Method Definitions are Expressions  .................................................................................................... 67
Chapter 19: Hashes  ..................................................................................................................................................... 69
Section 19.1: Creating a hash  ...................................................................................................................................... 69
Section 19.2: Setting Default Values  .......................................................................................................................... 70 Section 19.3: Accessing Values  ................................................................................................................................... 71
Section 19.4: Automatically creating a Deep Hash  .................................................................................................. 72
Section 19.5: Iterating Over a Hash  ........................................................................................................................... 73
Section 19.6: Filtering hashes  ...................................................................................................................................... 74 Section 19.7: Conversion to and from Arrays  ........................................................................................................... 74 Section 19.8: Overriding hash function  ...................................................................................................................... 74
Section 19.9: Getting all keys or values of hash  ....................................................................................................... 75 Section 19.10: Modifying keys and values  ................................................................................................................. 75
Section 19.11: Set Operations on Hashes  ................................................................................................................... 76
Chapter 20: Blocks and Procs and Lambdas  ............................................................................................... 77
Section 20.1: Lambdas  ................................................................................................................................................ 77 Section 20.2: Partial Application and Currying  ........................................................................................................ 78
Section 20.3: Objects as block arguments to methods  ........................................................................................... 80
Section 20.4: Converting to Proc  ............................................................................................................................... 80
Section 20.5: Blocks  .................................................................................................................................................... 81
Chapter 21: Iteration  ................................................................................................................................................. 83
Section 21.1: Each  ......................................................................................................................................................... 83 Section 21.2: Implementation in a class  .................................................................................................................... 84
Section 21.3: Iterating over complex objects  ............................................................................................................ 84 Section 21.4: For iterator  ............................................................................................................................................. 85
Section 21.5: Iteration with index  ................................................................................................................................ 85
Section 21.6: Map  ......................................................................................................................................................... 86
Chapter 22: Exceptions  ............................................................................................................................................ 87
Section 22.1: Creating a custom exception type  ...................................................................................................... 87
Section 22.2: Handling multiple exceptions  .............................................................................................................. 87 Section 22.3: Handling an exception  ......................................................................................................................... 88 Section 22.4: Raising an exception  ............................................................................................................................ 90
Section 22.5: Adding information to (custom) exceptions  ...................................................................................... 90
Chapter 23: Enumerators  ....................................................................................................................................... 91
Section 23.1: Custom enumerators  ............................................................................................................................ 91
Section 23.2: Existing methods  ................................................................................................................................... 91
Section 23.3: Rewinding  .............................................................................................................................................. 91
Chapter 24: Enumerable in Ruby  ....................................................................................................................... 93
Section 24.1: Enumerable module  .............................................................................................................................. 93
Chapter 25: Classes  ................................................................................................................................................... 96
Section 25.1: Constructor  ............................................................................................................................................ 96 Section 25.2: Creating a class  .................................................................................................................................... 96 Section 25.3: Access Levels  ........................................................................................................................................ 96 Section 25.4: Class Methods types  ............................................................................................................................ 98
Section 25.5: Accessing instance variables with getters and setters  .................................................................. 100 Section 25.6: New, allocate, and initialize  ............................................................................................................... 101 Section 25.7: Dynamic class creation  ..................................................................................................................... 101
Section 25.8: Class and instance variables  ............................................................................................................ 102
Chapter 26: Inheritance  ......................................................................................................................................... 104
Section 26.1: Subclasses  ............................................................................................................................................ 104 Section 26.2: What is inherited?  ............................................................................................................................... 104
Section 26.3: Multiple Inheritance  ............................................................................................................................ 106
Section 26.4: Mixins  ................................................................................................................................................... 106
Section 26.5: Refactoring existing classes to use Inheritance  .............................................................................. 107
Chapter 27: method_missing  ............................................................................................................................. 109
Section 27.1: Catching calls to an undefined method  ............................................................................................ 109
Section 27.2: Use with block  ..................................................................................................................................... 109
Section 27.3: Use with parameter  ............................................................................................................................ 109 Section 27.4: Using the missing method  ................................................................................................................. 110
Chapter 28: Regular Expressions and Regex Based Operations  ..................................................... 111
Section 28.1: =~ operator  ........................................................................................................................................... 111
Section 28.2: Regular Expressions in Case Statements  ........................................................................................ 111
Section 28.3: Groups, named and otherwise  .......................................................................................................... 111
Section 28.4: Quantifiers  ........................................................................................................................................... 112 Section 28.5: Common quick usage  ........................................................................................................................ 113
Section 28.6: match? - Boolean Result  ................................................................................................................... 113 Section 28.7: Defining a Regexp  .............................................................................................................................. 113
Section 28.8: Character classes  ............................................................................................................................... 114
Chapter 29: File and I/O Operations  .............................................................................................................. 116
Section 29.1: Writing a string to a file  ...................................................................................................................... 116 Section 29.2: Reading from STDIN  .......................................................................................................................... 116
Section 29.3: Reading from arguments with ARGV  ............................................................................................... 116 Section 29.4: Open and closing a file  ...................................................................................................................... 117
Section 29.5: get a single char of input  ................................................................................................................... 117
Chapter 30: Ruby Access Modifiers  ................................................................................................................. 118
Section 30.1: Instance Variables and Class Variables  ........................................................................................... 118
Section 30.2: Access Controls  .................................................................................................................................. 120
Chapter 31: Design Patterns and Idioms in Ruby  ..................................................................................... 123
Section 31.1: Decorator Pattern  ................................................................................................................................ 123 Section 31.2: Observer  ............................................................................................................................................... 124 Section 31.3: Singleton  ............................................................................................................................................... 125
Section 31.4: Proxy  ..................................................................................................................................................... 126
Chapter 32: Loading Source Files  ..................................................................................................................... 129
Section 32.1: Require files to be loaded only once  ................................................................................................. 129
Section 32.2: Automatically loading source files  ................................................................................................... 129 Section 32.3: Loading optional files  ......................................................................................................................... 129 Section 32.4: Loading files repeatedly  .................................................................................................................... 130
Section 32.5: Loading several files  .......................................................................................................................... 130
Chapter 33: Thread  .................................................................................................................................................. 131
Section 33.1: Accessing shared resources  ............................................................................................................... 131 Section 33.2: Basic Thread Semantics  .................................................................................................................... 131 Section 33.3: Terminating a Thread  ........................................................................................................................ 132
Section 33.4: How to kill a thread  ............................................................................................................................ 132
Chapter 34: Range  ................................................................................................................................................... 133
Section 34.1: Ranges as Sequences  ......................................................................................................................... 133 Section 34.2: Iterating over a range  ........................................................................................................................ 133
Section 34.3: Range between dates  ........................................................................................................................ 133
Chapter 35: Modules  ............................................................................................................................................... 134
Section 35.1: A simple mixin with include  ................................................................................................................. 134
Section 35.2: Modules and Class Composition  ....................................................................................................... 134 Section 35.3: Module as Namespace  ...................................................................................................................... 135
Section 35.4: A simple mixin with extend  ................................................................................................................ 135
Chapter 36: Introspection in Ruby  ................................................................................................................... 136
Section 36.1: Introspection of class  .......................................................................................................................... 136
Section 36.2: Lets see some examples  .................................................................................................................... 136
Chapter 37: Monkey Patching in Ruby  ........................................................................................................... 139 Section 37.1: Changing an existing ruby method  ................................................................................................... 139 Section 37.2: Monkey patching a class  ................................................................................................................... 139 Section 37.3: Monkey patching an object  ............................................................................................................... 139 Section 37.4: Safe Monkey patching with Refinements  ........................................................................................ 140
Section 37.5: Changing a method with parameters  .............................................................................................. 140 Section 37.6: Adding Functionality  .......................................................................................................................... 141 Section 37.7: Changing any method  ....................................................................................................................... 141
Section 37.8: Extending an existing class  ................................................................................................................ 141
Chapter 38: Recursion in Ruby  .......................................................................................................................... 142
Section 38.1: Tail recursion  ....................................................................................................................................... 142
Section 38.2: Recursive function  .............................................................................................................................. 143
Chapter 39: Splat operator (*)  ........................................................................................................................... 145
Section 39.1: Variable number of arguments  ......................................................................................................... 145
Section 39.2: Coercing arrays into parameter list  ................................................................................................. 145
Chapter 40: JSON with Ruby  .............................................................................................................................. 146
Section 40.1: Using JSON with Ruby  ........................................................................................................................ 146
Section 40.2: Using Symbols  .................................................................................................................................... 146
Chapter 41: Pure RSpec JSON API testing  ................................................................................................... 147
Section 41.1: Testing Serializer object and introducing it to Controller  ................................................................ 147
Chapter 42: Gem Creation/Management  ................................................................................................... 150
Section 42.1: Gemspec Files  ...................................................................................................................................... 150 Section 42.2: Building A Gem  ................................................................................................................................... 151
Section 42.3: Dependencies  ..................................................................................................................................... 151
Chapter 43: rbenv  .................................................................................................................................................... 152
Section 43.1: Uninstalling a Ruby  ............................................................................................................................. 152
Section 43.2: Install and manage versions of Ruby with rbenv  ........................................................................... 152
Chapter 44: Gem Usage  ....................................................................................................................................... 154
Section 44.1: Installing ruby gems  ........................................................................................................................... 154 Section 44.2: Gem installation from github/filesystem  ......................................................................................... 154
Section 44.3: Checking if a required gem is installed from within code  .............................................................. 155
Section 44.4: Using a Gemfile and Bundler  ............................................................................................................ 156
Section 44.5: Bundler/inline (bundler v1.10 and later)  ........................................................................................... 156
Chapter 45: Singleton Class  ............................................................................................................................... 158
Section 45.1: Introduction  .......................................................................................................................................... 158
Section 45.2: Inheritance of Singleton Class  .......................................................................................................... 158
Section 45.3: Singleton classes  ................................................................................................................................ 159 Section 45.4: Message Propagation with Singleton Class  .................................................................................... 159
Section 45.5: Reopening (monkey patching) Singleton Classes  .......................................................................... 160
Section 45.6: Accessing Singleton Class  ................................................................................................................. 161
Section 45.7: Accessing Instance/Class Variables in Singleton Classes  .............................................................. 161
Chapter 46: Queue  ................................................................................................................................................... 163
Section 46.1: Multiple Workers One Sink  ................................................................................................................. 163
Section 46.2: Converting a Queue into an Array  ................................................................................................... 163 Section 46.3: One Source Multiple Workers  ............................................................................................................ 163
Section 46.4: One Source - Pipeline of Work - One Sink  ....................................................................................... 164 Section 46.5: Pushing Data into a Queue - #push  ................................................................................................. 164 Section 46.6: Pulling Data from a Queue - #pop  ................................................................................................... 165
Section 46.7: Synchronization - After a Point in Time  ........................................................................................... 165
    Section 46.8: Merging Two Queues  ......................................................................................................................... 165 Chapter 47: Destructuring  ................................................................................................................................... 167 Section 47.1: Overview  ............................................................................................................................................... 167
Section 47.2: Destructuring Block Arguments  ........................................................................................................ 167
Chapter 48: Struct  ................................................................................................................................................... 168 Section 48.1: Creating new structures for data  ...................................................................................................... 168
Section 48.2: Customizing a structure class  ........................................................................................................... 168
Section 48.3: Attribute lookup  .................................................................................................................................. 168
Chapter 49: Metaprogramming  ....................................................................................................................... 169
Section 49.1: Implementing "with" using instance evaluation  ............................................................................... 169
Section 49.2: send() method  .................................................................................................................................... 169 Section 49.3: Defining methods dynamically  ......................................................................................................... 170
Section 49.4: Defining methods on instances  ........................................................................................................ 171
Chapter 50: Dynamic Evaluation  ...................................................................................................................... 172
Section 50.1: Instance evaluation  ............................................................................................................................. 172
Section 50.2: Evaluating a String  ............................................................................................................................. 172 Section 50.3: Evaluating Inside a Binding  ............................................................................................................... 172
Section 50.4: Dynamically Creating Methods from Strings  .................................................................................. 173
Chapter 51: instance_eval  ................................................................................................................................... 175
Section 51.1: Instance evaluation  .............................................................................................................................. 175
Section 51.2: Implementing with  ............................................................................................................................... 175
Chapter 52: Message Passing  ............................................................................................................................ 177
Section 52.1: Introduction  .......................................................................................................................................... 177 Section 52.2: Message Passing Through Inheritance Chain  ................................................................................. 177
Section 52.3: Message Passing Through Module Composition  ............................................................................ 178
Section 52.4: Interrupting Messages  ....................................................................................................................... 179
Chapter 53: Keyword Arguments  ..................................................................................................................... 181
Section 53.1: Using arbitrary keyword arguments with splat operator  ............................................................... 181
Section 53.2: Using keyword arguments  ................................................................................................................ 182
Section 53.3: Required keyword arguments  .......................................................................................................... 183
Chapter 54: Truthiness  .......................................................................................................................................... 184 Section 54.1: All objects may be converted to booleans in Ruby  ......................................................................... 184
Section 54.2: Truthiness of a value can be used in if-else constructs  ................................................................. 184
Chapter 55: Implicit Receivers and Understanding Self  ...................................................................... 185
Section 55.1: There is always an implicit receiver  .................................................................................................. 185
Section 55.2: Keywords change the implicit receiver  ............................................................................................ 185
Section 55.3: When to use self?  ............................................................................................................................... 186
Chapter 56: Introspection  .................................................................................................................................... 188
Section 56.1: View an object's methods  .................................................................................................................. 188 Section 56.2: View an object's Instance Variables  ................................................................................................. 189
Section 56.3: View Global and Local Variables  ...................................................................................................... 190
Section 56.4: View Class Variables  .......................................................................................................................... 190
Chapter 57: Refinements  ...................................................................................................................................... 192
Section 57.1: Monkey patching with limited scope  ................................................................................................. 192
Section 57.2: Dual-purpose modules (refinements or global patches)  ............................................................... 192
Section 57.3: Dynamic refinements  ......................................................................................................................... 193
Chapter 58: Catching Exceptions with Begin / Rescue  ......................................................................... 195
Section 58.1: A Basic Error Handling Block  ............................................................................................................. 195 Section 58.2: Saving the Error  .................................................................................................................................. 195
Section 58.3: Checking for Dierent Errors  ............................................................................................................ 196
Section 58.4: Retrying  ............................................................................................................................................... 197 Section 58.5: Checking Whether No Error Was Raised  ......................................................................................... 198
Section 58.6: Code That Should Always Run  .......................................................................................................... 198
Chapter 59: Command Line Apps  ..................................................................................................................... 200
Section 59.1: How to write a command line tool to get the weather by zip code  .............................................. 200
Chapter 60: IRB  .......................................................................................................................................................... 201
Section 60.1: Starting an IRB session inside a Ruby script  .................................................................................... 201
Section 60.2: Basic Usage  ........................................................................................................................................ 201
Chapter 61: ERB  ......................................................................................................................................................... 203
Section 61.1: Parsing ERB  .......................................................................................................................................... 203
Chapter 62: Generate a random number  .................................................................................................... 204
Section 62.1: 6 Sided die  ............................................................................................................................................ 204
Section 62.2: Generate a random number from a range (inclusive)  .................................................................. 204
Chapter 63: Getting started with Hanami  .................................................................................................... 205
Section 63.1: About Hanami  ...................................................................................................................................... 205 Section 63.2: How to install Hanami?  ...................................................................................................................... 205
Section 63.3: How to start the server?  .................................................................................................................... 206
Chapter 64: OptionParser  .................................................................................................................................... 208
Section 64.1: Mandatory and optional command line options  ............................................................................. 208
Section 64.2: Default values  ..................................................................................................................................... 209
Section 64.3: Long descriptions  ............................................................................................................................... 209
Chapter 65: Operating System or Shell commands  ............................................................................... 210
Section 65.1: Recommended ways to execute shell code in Ruby:  ...................................................................... 210
Section 65.2: Clasic ways to execute shell code in Ruby:  ...................................................................................... 211
Chapter 66: C Extensions  ...................................................................................................................................... 213
Section 66.1: Your first extension  .............................................................................................................................. 213 Section 66.2: Working with C Structs  ....................................................................................................................... 214
Section 66.3: Writing Inline C - RubyInLine  ............................................................................................................. 215
Chapter 67: Debugging  .......................................................................................................................................... 217
Section 67.1: Stepping through code with Pry and Byebug  .................................................................................. 217
Chapter 68: Ruby Version Manager  ................................................................................................................ 218
Section 68.1: How to create gemset  ........................................................................................................................ 218
Section 68.2: Installing Ruby with RVM  ................................................................................................................... 218
Appendix A: Installation  ......................................................................................................................................... 219
Section A.1: Installing Ruby macOS  ......................................................................................................................... 219
Section A.2: Gems  ..................................................................................................................................................... 219 Section A.3: Linux - Compiling from source  ............................................................................................................ 220
Section A.4: Linux-Installation using a package manager  .................................................................................. 220 Section A.5: Windows - Installation using installer  ................................................................................................ 221
Section A.6: Linux - troubleshooting gem install  .................................................................................................... 221
Credits  ............................................................................................................................................................................ 222
You may also like  ...................................................................................................................................................... 226

About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/RubyBook
This Ruby(r) Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Ruby(r) group(s) or company(s) nor Stack Overflow. All
trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Ruby Language
Version Release Date
2.5.12018-03-282.42016-12-252.32015-12-252.22014-12-252.12013-12-252.02013-02-241.92007-12-251.82003-08-041.6.82002-12-24Section 1.1: Hello World
		This example assumes Ruby is installed.
hello.rbPlace the following in a file named :

From the command line, type the following command to execute the Ruby code from the source file:

This should output:

The output will be immediately displayed to the console. Ruby source files don't need to be compiled before being executed. The Ruby interpreter compiles and executes the Ruby file at runtime.
Section 1.2: Hello World as a Self-Executable File-using Shebang (Unix-like operating systems only)
hello_world.rbYou can add an interpreter directive (shebang) to your script. Create a file called  which contains:

Give the script executable permissions. Here's how to do that in Unix:

Now you do not need to call the Ruby interpreter explicitly to run your script.

Section 1.3: Hello World from IRB
Alternatively, you can use the Interactive Ruby Shell (IRB) to immediately execute the Ruby statements you previously wrote in the Ruby file.
Start an IRB session by typing:

Then enter the following command:

This results in the following console output (including newline):

If you don't want to start a new line, you can use print:

Section 1.4: Hello World without source files
Run the command below in a shell after installing Ruby. This shows how you can execute simple Ruby programs without creating a Ruby file:

You can also feed a Ruby program to the interpreter's standard input. One way to do that is to use a here document in your shell command:

Section 1.5: Hello World with tk
Tk is the standard graphical user interface (GUI) for Ruby. It provides a cross-platform GUI for Ruby programs.
Example code: require "tk" The result:

Step by Step explanation:

Load the tk package.

Define a widget with the title Hello World

Start the main loop and display the widget.
Section 1.6: My First Method
Overview
my_first_method.rbCreate a new file named 
Place the following code inside the file:

Now, from a command line, execute the following:

The output should be:
Hello world!
Explanation
puts "Hello world!"def is a keyword that tells us that we're def-ining a method - in this case, hello_world is the name of our method.
 puts (or pipes to the console) the string Hello world!
end is a keyword that signifies we're ending our definition of the hello_world method
 as the hello_world method doesn't accept any arguments, you can omit the parenthesis by invoking the method

Chapter 2: Casting (type conversion)
Section 2.1: Casting to a Float

However, there is a difference when the string is not a valid Float:

Section 2.2: Casting to a String

String()Usually,  will just call #to_s.
Kernel#sprintf and String#%Methods  behave similar to C:

Section 2.3: Casting to an Integer

A string will take the value of any integer at its start, but will not take integers from anywhere else:

However, there is a difference when the string is not a valid Integer:

Section 2.4: Floats and Integers

Since we are dividing two integers, the result is an integer. To solve this problem, we need to cast at least one of those to Float:

Alternatively, fdiv may be used to return the floating point result of division without explicitly casting either operand:


Chapter 3: Operators
Section 3.1: Operator Precedence and Methods
From highest to lowest, this is the precedence table for Ruby. High precedence operations happen before low precedence operations.
╔════════════════════╦═════════════════════════════════╦════════╗
║ Operators             ║                 Operations            ║  Method? ║
╠════════════════════╬═════════════════════════════════╬════════╣
║ .                     ║ Method call (e.g. foo.bar)             ║         ║
║ []  []=               ║ Bracket Lookup, Bracket Set            ║    ✓¹   ║
║ ! ~ +                 ║ Boolean NOT, complement, unary plus    ║    ✓²    ║
║ **                    ║ Exponentiation                         ║    ✓    ║
║ -                     ║ Unary minus                            ║    ✓²    ║
║ * / %                 ║ Multiplication, division, modulo       ║    ✓    ║
║ + -                   ║ Addition, subtraction                  ║    ✓    ║
║ <>                    ║ Bitwise shift                          ║    ✓    ║
║ &                     ║ Bitwise AND                            ║    ✓    ║
║ | ^                   ║ Bitwise OR, Bitwise XOR                ║    ✓    ║
║ < <= >= >             ║ Comparison                             ║    ✓    ║
║ <=> == != === =~ !~   ║ Equality, pattern matching, comparison ║    ✓³   ║
║ &&                    ║ Boolean AND                            ║         ║
║ ||                    ║ Boolean OR                             ║         ║
║ .. ...                ║ Inclusive range, Exclusive range       ║         ║
║ ? :                   ║ Ternary operator                       ║         ║
║ rescue                ║ Modifier rescue                        ║         ║
║ = += -=               ║ Assignments                            ║         ║
║ defined?              ║ Defined operator                       ║         ║
║ not                   ║ Boolean NOT                            ║         ║
║ or and                ║ Boolean OR, Boolean AND                ║         ║
║ if unless while until ║ Modifier if, unless, while, until      ║         ║
║ { }                   ║ Block with braces                      ║         ║
║ do end                ║ Block with do end                      ║         ║ ╚═══════════════════╩═══════════════════════════════════╩═══════╝
+obj, -obj or -(some_expression)Unary + and unary - are for .
Modifier-if, modifier-unless, etc. are for the modifier versions of those keywords. For example, this is a modifierunless expression:

Operators with a ✓ may be defined as methods. Most methods are named exactly as the operator is named, for example:


¹ The Bracket Lookup and Bracket Set methods ([] and []=) have their arguments defined after the name, for example:

² The "unary plus" and "unary minus" operators are defined as methods named +@ and -@, for example

³ In early versions of Ruby the inequality operator != and the non-matching operator !~ could not be defined as methods. Instead, the method for the corresponding equality operator == or matching operator =~ was invoked, and the result of that method was boolean inverted by Ruby.
If you do not define your own != or !~ operators the above behavior is still true. However, as of Ruby 1.9.1, those two operators may also be defined as methods:


Section 3.2: Case equality operator (===)
Also known as triple equals.
This operator does not test equality, but rather tests if the right operand has an IS A relationship with the left operand. As such, the popular name case equality operator is misleading.
This SO answer describes it thus: the best way to describe a === b is "if I have a drawer labeled a, does it make sense to put b in it?" In other words, does the set a include the member b?
Examples (source)

Classes that override ===
Many classes override === to provide meaningful semantics in case statements. Some of them are:

Recommended practice
Explicit use of the case equality operator === should be avoided. It doesn't test equality but rather subsumption, and its use can be confusing. Code is clearer and easier to understand when the synonym method is used instead.

Section 3.3: Safe Navigation Operator
object &&object.property && object.property.methodRuby 2.3.0 added the safe navigation operator, &.. This operator is intended to shorten the paradigm of  in conditional statements.
For example, you have a House object with an address property, and you want to find the street_name from the address. To program this safely to avoid nil errors in older Ruby versions, you'd use code something like this:

The safe navigation operator shortens this condition. Instead, you can write:

Caution:
The safe navigation operator doesn't have exactly the same behavior as the chained conditional. Using the chained conditional (first example), the if block would not be executed if, say address was false. The safe navigation operator only recognises nil values, but permits values such as false. If address is false, using the SNO will yield an error:

Section 3.4: Assignment Operators
Simple Assignment
= is a simple assignment. It creates a new local variable if the variable was not previously referenced.

This will output:

Parallel Assignment
x, y = 3, Variables can also be assigned in parallel, e.g. 9. This is especially useful for swapping values:

This will output:

Abbreviated Assignment
It's possible to mix operators and assignment. For example:

Shows the following output:

Various operations can be used in abbreviated assignment:
Operator	Description	Example Equivalent to

x += y
x = x + y+=	Adds and reassigns the variable

x -= y
x = x - y-=	Subtracts and reassigns the variable

x *= y
x = x * y*=	Multiplies and reassigns the variable

x /= y
x = x / y/=	Divides and reassigns the variable

x %= y
x = x % y%=	Divides, takes the remainder, and reassigns the variable
x **= y**	=	Calculates the exponent and reassigns the variablex = x ** y
Section 3.5: Comparison OperatorsOperatorDescription==true if the two values are equal.!=true if the two values are not equal.<true if the value of the operand on the left is less than the value on the right.>true if the value of the operand on the left is greater than the value on the right.>=true if the value of the operand on the left is greater than or equal to the value on the right.<=true if the value of the operand on the left is less than or equal to the value on the right.
0 if the value of the operand on the left is equal to the value on the right,<=>	1 if the value of the operand on the left is greater than the value on the right, -1 if the value of the operand on the left is less than the value on the right.
Chapter 4: Variable Scope and Visibility
Section 4.1: Class Variables
Class variables have a class wide scope, they can be declared anywhere in the class. A variable will be considered a class variable when prefixed with @@

Class variables are shared between related classes and can be overwritten from a child class

This behaviour is unwanted most of the time and can be circumvented by using class-level instance variables.
Class variables defined inside a module will not overwrite their including classes class variables:

Section 4.2: Local Variables
Local variables (unlike the other variable classes) do not have any prefix

Its scope is dependent on where it has been declared, it can not be used outside the "declaration containers" scope. For example, if a local variable is declared in a method, it can only be used inside that method.

do ... endOf course, local variables are not limited to methods, as a rule of thumb you could say that, as soon as you declare a variable inside a  block or wrapped in curly braces {} it will be local and scoped to the block it has been declared in.

However, local variables declared in if or case blocks can be used in the parent-scope:

While local variables can not be used outside of its block of declaration, it will be passed down to blocks:


But not to method / class / module definitions

The variables used for block arguments are (of course) local to the block, but will overshadow previously defined variables, without overwriting them.

Section 4.3: Global Variables
Global variables have a global scope and hence, can be used everywhere. Their scope is not dependent on where they are defined. A variable will be considered global, when prefixed with a $ sign.

Since a global variable can be defined everywhere and will be visible everywhere, calling an "undefined" global variable will return nil instead of raising an error.

Although global variables are easy to use its usage is strongly discouraged in favour of constants. Section 4.4: Instance Variables
Instance variables have an object wide scope, they can be declared anywhere in the object, however an instance variable declared on class level, will only be visible in the class object. A variable will be considered an instance variable when prefixed with @. Instance variables are used to set and get an objects attributes and will return nil if not defined.

The instance variable declared on class level can not be accessed on object level:

However, we used the instance variable @base_sound to instantiate the sound when no sound is passed to the new method:

Instance variables can be declared anywhere in the object, even inside a block:

Instance variables are not shared between instances of the same class

This can be used to create class level variables, that will not be overwritten by a child-class, since classes are also objects in Ruby.

Chapter 5: Environment Variables
Section 5.1: Sample to get user profile path


Chapter 6: Constants
Section 6.1: Define a constant

Constant name start with capital letter. Everything that start with capital letter are considered as constant in Ruby. So class and module are also constant. Best practice is use all capital letter for declaring constant. Section 6.2: Modify a Constant

The above code results in a warning, because you should be using variables if you want to change their values. However it is possible to change one letter at a time in a constant without a warning, like this:

Now, after changing the second letter of MY_CONSTANT, it becomes "Hullo, world". Section 6.3: Constants cannot be defined in methods

The above code results in an error: SyntaxError: (irb):2: dynamic constant assignment.
Section 6.4: Define and change constants in a class

The constant DEFAULT_MESSAGE can be changed with the following code:

Chapter 7: Special Constants in Ruby
Section 7.1: __FILE__
Is the relative path to the file from the current execution directory Assume we have this directory structure: /home/stackoverflow/script.rb script.rb contains:

ruby script.rbIf you are inside /home/stackoverflow and execute the script like  then __FILE__ will output
script.rb If you are inside /home then it will output stackoverflow/script.rbVery useful to get the path of the script in versions prior to 2.0 where __dir__ doesn't exist.
Note __FILE__ is not equal to __dir__ Section 7.2: __dir__
__dir__ is not a constant but a function
File.dirname(File.realpath(__FILE__))__dir__ is equal to 
Section 7.3: $PROGRAM_NAME or $0
Contains the name of the script being executed.
Is the same as __FILE__ if you are executing that script. Section 7.4: $$
The process number of the Ruby running this script Section 7.5: $1, $2, etc
Contains the subpattern from the corresponding set of parentheses in the last successful pattern matched, not counting patterns matched in nested blocks that have been exited already, or nil if the last pattern match failed. These variables are all read-only. Section 7.6: ARGV or $*
Command line arguments given for the script. The options for Ruby interpreter are already removed. Section 7.7: STDIN
The standard input. The default value for $stdin Section 7.8: STDOUT
The standard output. The default value for $stdout Section 7.9: STDERR
The standard error output. The default value for $stderr
Section 7.10: $stderr
The current standard error output. Section 7.11: $stdout
The current standard output Section 7.12: $stdin
The current standard input Section 7.13: ENV
The hash-like object contains current environment variables. Setting a value in ENV changes the environment for child processes.

Chapter 8: Comments
Section 8.1: Single & Multiple line comments
Comments are programmer-readable annotations that are ignored at runtime. Their purpose is to make source code easier to understand.
Single line comments
The # character is used to add single line comments.

When executed, the above program will output Hello World!
Multiline comments
=endMultiple-line comments can be added by using =begin and  syntax (also known as the comment block markers) as follows:

When executed, the above program will output Hello World!
Chapter 9: Arrays
Section 9.1: Create Array of Strings
Arrays of strings can be created using ruby's percent string syntax:

This is functionally equivalent to defining the array as:

...}, %w[...] or %w<...Instead of %w() you may use other matching pairs of delimiters: %w{>.
w!...!, %w#...# or %w@...@It is also possible to use arbitrary non-alphanumeric delimiters, such as: %.
%W can be used instead of %w to incorporate string interpolation. Consider the following:

Multiple words can be interpreted by escaping the space with a \.
%w(Colorado California New\ York) # => ["Colorado", "California", "New York"]
Section 9.2: Create Array with Array::new
Array::newAn empty Array ([]) can be created with Array's class method, :

To set the length of the array, pass a numerical argument:

There are two ways to populate an array with default values:

Section 9.3: Create Array of Symbols
Version ≥ 2.0

[:one, :two, :three, :four]Creates the array .
%i(...), you may use %i{...} or %i[...] or %i!...!Instead of 
Additionally, if you want to use interpolation, you can do this with %I.

array_one = [:hello, :goodbye, :world] and array_two = [:"\#{a}", :"\#{b}", :world]Creates the arrays: 
Section 9.4: Manipulating Array Elements
Adding elements:

Removing elements:


Combining arrays:

You can also multiply arrays, e.g.

Section 9.5: Accessing elements
You can access the elements of an array by their indices. Array index numbering starts at 0.

You can crop an array using range
%w(a b c d)[1..2] # => ['b', 'c'] (indices from 1 to 2, including the 2)
%w(a b c d)[1...2] # => ['b'] (indices from 1 to 2, excluding the 2)
This returns a new array, but doesn't affect the original. Ruby also supports the use of negative indices.

You can combine negative and positive indices as well

Other useful methods
Use first to access the first element in an array:

firstOr (n) to access the first n elements returned in an array:

lastSimilarly for last and (n):

Use sample to access a random element in a array:

sampleOr (n):

Section 9.6: Creating an Array with the literal constructor [ ]
Arrays can be created by enclosing a list of elements in square brackets ([ and ]). Array elements in this notation are separated with commas:

Arrays can contain any kind of objects in any combination with no restrictions on type:

Section 9.7: Decomposition
Any array can be quickly decomposed by assigning its elements into multiple variables. A simple example:

Preceding a variable with the splat operator (*) puts into it an array of all the elements that haven't been captured by other variables. If none are left, empty array is assigned. Only one splat can be used in a single assignment:

Decomposition is safe and never raises errors. nils are assigned where there's not enough elements, matching the behavior of [] operator when accessing an index out of bounds:


Decomposition tries to call to_ary implicitly on the object being assigned. By implementing this method in your type you get the ability to decompose it:

If the object being decomposed doesn't respond_to? to_ary, it's treated as a single-element array:

Decomposition can also be nested by using a ()-delimited decomposition expression in place of what otherwise would be a single element:

This is effectively the opposite of splat.
Actually, any decomposition expression can be delimited by (). But for the first level decomposition is optional.

Edge case: a single identifier cannot be used as a destructuring pattern, be it outer or a nested one:

When assigning an array literal to a destructuring expression, outer [] can be omitted:

This is known as parallel assignment, but it uses the same decomposition under the hood. This is particularly handy for exchanging variables' values without employing additional temporary variables:

Values are captured when building the right-hand side of the assignment, so using the same variables as source and destination is relatively safe.
Section 9.8: Arrays union, intersection and dierence

Union (|) contains elements from both arrays, with duplicates removed:

Intersection (&) contains elements which are present both in first and second array:

Difference (-) contains elements which are present in first array and not present in second array:

Section 9.9: Remove all nil elements from an array with #compact
Array#compactIf an array happens to have one or more nil elements and these need to be removed, the  or Array#compact! methods can be used, as below.

Finally, notice that if #compact or #compact! are called on an array with no nil elements, these will return nil.

Section 9.10: Get all combinations / permutations of an array
The permutation method, when called with a block yields a two dimensional array consisting of all ordered sequences of a collection of numbers.
If this method is called without a block, it will return an enumerator. To convert to an array, call the to_a method.
	Example	Result
permutation[1,2,3].#<Enumerator: [1,2,3]:permutation
permutation.to_a[1,2,3].[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
permutation(2).to_a[1,2,3].[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
permutation(4).to_a[1,2,3].[] -> No permutations of length 4
The combination method on the other hand, when called with a block yields a two-dimensional array consisting of all sequences of a collection of numbers. Unlike permutation, order is disregarded in combinations. For example, [1,2,3] is the same as [3,2,1]
	Example	Result
combination[1,2,3].(1)	#<Enumerator: [1,2,3]:combination
combination(1).to_a[1,2,3].[[1],[2],[3]]
combination(3).to_a[1,2,3].[[1,2,3]]
combination(4).to_a[1,2,3].[] -> No combinations of length 4
Calling the combination method by itself will result in an enumerator. To get an array, call the to_a method.
The repeated_combination and repeated_permutation methods are similar, except the same element can be repeated multiple times.
For example the sequences [1,1], [1,3,3,1], [3,3,3] would not be valid in regular combinations and permutations.
	Example	# Combos
combination(3).to_a.length[1,2,3].1
repeated_combination(3).to_a.length[1,2,3].6
combination(5).to_a.lengthrepeated_combination(5).to_a.length[1,2,3,4,5].1 [1,2,3].126
Section 9.11: Inject, reduce
Inject and reduce are different names for the same thing. In other languages these functions are often called folds (like foldl or foldr). These methods are available on every Enumerable object.
Inject takes a two argument function and applies that to all of the pairs of elements in the Array.

Here we pass the function a starting value and a block that says to add all of the values together. The block is first run with 0 as a and 1 as b it then takes the result of that as the next a so we are then adding 1 to the second value 2. Then we take the result of that (3) and add that on to the final element in the list (also 3) giving us our result (6).
If we omit the first argument, it will set a to being the first element in the list, so the example above is the same as:

In addition, instead of passing a block with a function, we can pass a named function as a symbol, either with a starting value, or without. With this, the above example could be written as:

or omitting the starting value:

Section 9.12: Filtering arrays
Often we want to operate only on elements of an array that fulfill a specific condition:
Select
Will return elements that match a specific condition

Reject
Will return elements that do not match a specific condition

Both #select and #reject return an array, so they can be chained:

Section 9.13: #map
#map, provided by Enumerable, creates an array by invoking a block on each element and collecting the results:

The original array is not modified; a new array is returned containing the transformed values in the same order as the source values. map! can be used if you want to modify the original array.
In map method you can call method or use proc to all elements in array.

map is synonymous with collect.
Section 9.14: Arrays and the splat (*) operator
The * operator can be used to unpack variables and arrays so that they can be passed as individual arguments to a method.
This can be used to wrap a single object in an Array if it is not already:

In the above example, the wrap_in_array method accepts one argument, value.
If value is an Array, its elements are unpacked and a new array is created containing those element.
If value is a single object, a new array is created containing that single object.
If value is nil, an empty array is returned.
The splat operator is particularly handy when used as an argument in methods in some cases. For example, it allows nil, single values and arrays to be handled in a consistent manner:

Section 9.15: Two-dimensional array
Array::newUsing the  constructor, your can initialize an array with a given size and a new array in each of its slots.
The inner arrays can also be given a size and and initial value.
For instance, to create a 3x4 array of zeros:

The array generated above looks like this when printed with p:

You can read or write to elements like this:

Section 9.16: Turn multi-dimensional array into a onedimensional (flattened) array

If you have a multi-dimensional array and you need to make it a simple (i.e. one-dimensional) array, you can use the #flatten method. Section 9.17: Get unique array elements
In case you need to read an array elements avoiding repetitions you case use the #uniq method:

Instead, if you want to remove all duplicated elements from an array, you may use #uniq! method:

While the output is the same, #uniq! also stores the new array:

Section 9.18: Create Array of numbers
The normal way to create an array of numbers:

Range objects can be used extensively to create an array of numbers:

#step and #map methods allow us to impose conditions on the range of numbers:

All the above methods load the numbers eagerly. If you have to load them lazily:

Section 9.19: Create an Array of consecutive numbers or letters
Enumerable#to_aThis can be easily accomplished by calling  on a Range object:

a..b) means that it will include all numbers between a and b. To exclude the last number, use a...(b

or

a..A convenient shortcut for creating an array is [*b]

Section 9.20: Cast to Array from any object
Kernel#ArrayTo get Array from any object, use .
The following is an example:

For example, you could replace join_as_string method from the following code

to the following code.


Chapter 10: Multidimensional Arrays
Multidimensional Arrays in Ruby are just arrays whose elements are other arrays.
The only catch is that since Ruby arrays can contain elements of mixed types, you must be confident that the array that you are manipulating is effectively composed of other arrays and not, for example, arrays and strings. Section 10.1: Initializing a 2D array
Let's first recap how to initialize a 1D ruby array of integers:

Being a 2D array simply an array of arrays, you can initialize it like this:

Section 10.2: Initializing a 3D array
You can go a level further down and add a third layer of arrays. The rules don't change:

Section 10.3: Accessing a nested array
Accessing the 3rd element of the first subarray:

Section 10.4: Array flattening
Given a multidimensional array:

the operation of flattening is to decompose all array children into the root array:


Chapter 11: Strings
Section 11.1: Dierence between single-quoted and doublequoted String literals
The main difference is that double-quoted String literals support string interpolations and the full set of escape sequences.
For instance, they can include arbitrary Ruby expressions via interpolation:

\n", "\tDouble-quoted strings also support the entire set of escape sequences including ""...

\'' and '\\... while single-quoted strings support no escape sequences, baring the minimal set necessary for single-quoted strings to be useful: Literal single quotes and backslashes, '' respectively. Section 11.2: Creating a String
Ruby provides several ways to create a String object. The most common way is using single or double quotes to create a "string literal":

The main difference is that double-quoted string literals are a little bit more flexible as they support interpolation and some backslash escape sequences.
There are also several other possible ways to create a string literal using arbitrary string delimiters. An arbitrary string delimiter is a % followed by a matching pair of delimiters:

Finally, you can use the %q and %Q sequence, that are equivalent to ' and "":


%q and %Q sequences are useful when the string contains either single quotes, double quotes, or a mix of both. In this way, you don't need to escape the content:

You can use several different delimiters, as long as there is a matching pair:

Section 11.3: Case manipulation

These four methods do not modify the original receiver. For example,

There are four similar methods that perform the same actions but modify original receiver.

For example,

Notes:
     prior to Ruby 2.4 these methods do not handle unicode. Section 11.4: String concatenation
Concatenate strings with the + operator:



Note that the << operator modifies the object on the left hand side.
You also can multiply strings, e.g.

Section 11.5: Positioning strings
In Ruby, strings can be left-justified, right-justified or centered
To left-justify string, use the ljust method. This takes in two parameters, an integer representing the number of characters of the new string and a string, representing the pattern to be filled.
If the integer is greater than the length of the original string, the new string will be left-justified with the optional string parameter taking the remaining space. If the string parameter is not given, the string will be padded with spaces.

To right-justify a string, use the rjust method. This takes in two parameters, an integer representing the number of characters of the new string and a string, representing the pattern to be filled.
If the integer is greater than the length of the original string, the new string will be right-justified with the optional string parameter taking the remaining space. If the string parameter is not given, the string will be padded with spaces.

To center a string, use the center method. This takes in two parameters, an integer representing the width of the new string and a string, which the original string will be padded with. The string will be aligned to the center.

Section 11.6: Splitting a String
String#split splits a String into an Array, based on a delimiter.

An empty String results into an empty Array:

A non-matching delimiter results in an Array containing a single item:

You can also split a string using regular expressions:

The delimiter is optional, by default a string is split on whitespace:

Section 11.7: String starts with
To find if a string starts with a pattern, the start_with? method comes in handy

You can also check the position of the pattern with index

Section 11.8: Joining Strings
Array#join joins an Array into a String, based on a delimiter:

The delimiter is optional, and defaults to an empty String.

An empty Array results in an empty String, no matter which delimiter is used.


Section 11.9: String interpolation
The double-quoted delimiter " and %Q sequence supports string interpolation using #{ruby_expression}:

Section 11.10: String ends with
To find if a string ends with a pattern, the end_with? method comes in handy

Section 11.11: Formatted strings
Ruby can inject an array of values into a string by replacing any placeholders with the values from the supplied array.

'Hello', 'br3nt'The place holders are represented by two %s and the values are supplied by the array []. The % operator instructs the string to inject the values of the array.
Section 11.12: String Substitution

Section 11.13: Multiline strings
The easiest way to create a multiline string is to just use multiple lines between quotation marks:
address = "Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal."
The main problem with that technique is that if the string includes a quotation, it'll break the string syntax. To work around the problem, you can use a heredoc instead:
puts <<-RAVEN   Once upon a midnight dreary, while I pondered, weak and weary,
  Over many a quaint and curious volume of forgotten lore-
      While I nodded, nearly napping, suddenly there came a tapping,   As of some one gently rapping, rapping at my chamber door.
  "'Tis some visitor," I muttered, "tapping at my chamber door-
              Only this and nothing more."
  RAVEN
<EOTRuby supports shell-style here documents with <, but the terminating text must start the line. That screws up code indentation, so there's not a lot of reason to use that style. Unfortunately, the string will have indentations depending no how the code itself is indented.
Ruby 2.3 solves the problem by introducing <<~ which strips out excess leading spaces:
Version ≥ 2.3

Percent Strings also work to create multiline strings:

There are a few ways to avoid interpolation and escape sequences:

Section 11.14: String character replacements
The tr method returns a copy of a string where the characters of the first argument are replaced by the characters of the second argument.

To replace only the first occurrence of a pattern with with another expression use the sub method

If you would like to replace all occurrences of a pattern with that expression use gsub

To delete characters, pass in an empty string for the second parameter
You can also use regular expressions in all these methods.
It's important to note that these methods will only return a new copy of a string and won't modify the string in place. To do that, you need to use the tr!, sub! and gsub! methods respectively. Section 11.15: Understanding the data in a string
UTF-8, US-ASCIIASCII-8BITIn Ruby, a string is just a sequence of bytes along with the name of an encoding (such as , ) that specifies how you might interpret those bytes as characters.
Ruby strings can be used to hold text (basically a sequence of characters), in which case the UTF-8 encoding is usually used.

Ruby strings can also be used to hold binary data (a sequence of bytes), in which case the ASCII-8BIT encoding is usually used.

It is possible for the sequence of bytes in a string to not match the encoding, resulting in errors if you try to use the string.
"\xFF \xFF".valid_encoding? # => false
"\xFF \xFF".split(' ')      # ArgumentError: invalid byte sequence in UTF-8
Chapter 12: DateTime
Section 12.1: DateTime from string
DateTime.parse is a very useful method which construct a DateTime from a string, guessing its format.
DateTime.parse('Jun, 8 2016')
# => #<DateTime: 2016-06-08T00:00:00+00:00 ((2457548j,0s,0n),+0s,2299161j)>
DateTime.parse('201603082330')
# => #<DateTime: 2016-03-08T23:30:00+00:00 ((2457456j,84600s,0n),+0s,2299161j)> DateTime.parse('04-11-2016 03:50')
# => #<DateTime: 2016-11-04T03:50:00+00:00 ((2457697j,13800s,0n),+0s,2299161j)>
DateTime.parse('04-11-2016 03:50 -0300')
# => #<DateTime: 2016-11-04T03:50:00-03:00 ((2457697j,24600s,0n),-10800s,2299161j)
Note: There are lots of other formats that parse recognizes. Section 12.2: New

Current time:

Note that it gives the current time in your timezone Section 12.3: Add/subtract days to DateTime
DateTime + Fixnum (days quantity)
DateTime.new(2015,12,30,23,0) + 1
# => #<DateTime: 2015-12-31T23:00:00+00:00 ((2457388j,82800s,0n),+0s,2299161j)>
DateTime + Float (days quantity)
DateTime.new(2015,12,30,23,0) + 2.5
# => #<DateTime: 2016-01-02T11:00:00+00:00 ((2457390j,39600s,0n),+0s,2299161j)>
DateTime + Rational (days quantity)
DateTime.new(2015,12,30,23,0) + Rational(1,2)
# => #<DateTime: 2015-12-31T11:00:00+00:00 ((2457388j,39600s,0n),+0s,2299161j)>
DateTime - Fixnum (days quantity)
DateTime.new(2015,12,30,23,0) - 1
# => #<DateTime: 2015-12-29T23:00:00+00:00 ((2457388j,82800s,0n),+0s,2299161j)>
DateTime - Float (days quantity)

# => #<DateTime: 2015-12-28T11:00:00+00:00 ((2457385j,39600s,0n),+0s,2299161j)>
DateTime - Rational (days quantity)
DateTime.new(2015,12,30,23,0) - Rational(1,2)
# => #<DateTime: 2015-12-30T11:00:00+00:00 ((2457387j,39600s,0n),+0s,2299161j)>

Chapter 13: Time
Section 13.1: How to use the strftime method
Converting a time to a string is a pretty common thing to do in Ruby. strftime is the method one would use to convert time to a string.
Here are some examples:

This can be simplified even further

Section 13.2: Creating time objects
Get current time:

Get specific time:
Time.new(2010, 3, 10) #10 March 2010 (Midnight)
Time.new(2015, 5, 3, 10, 14) #10:14 AM on 3 May 2015
 Time.new(2050, "May", 3, 21, 8, 16, "+10:00") #09:08:16 PM on 3 May 2050 To convert a time to epoch you can use the to_i method:

You can also convert back from epoch to Time using the at method:

Chapter 14: Numbers
Section 14.1: Converting a String to Integer
You can use the Integer method to convert a String to an Integer:

You can also pass a base parameter to the Integer method to convert numbers from a certain base

Note that the method raises an ArgumentError if the parameter cannot be converted:

String#to_iYou can also use the  method. However, this method is slightly more permissive and has a different behavior than Integer:

String#to_i accepts an argument, the base to interpret the number as:

Section 14.2: Creating an Integer

By default the notation is base 10. However, there are some other built-in notations for different bases:
0xFF    # Hexadecimal representation of 255, starts with a 0x
0b100   # Binary representation of 4, starts with a 0b
0555    # Octal representation of 365, starts with a 0 and digits
Section 14.3: Rounding Numbers
The round method will round a number up if the first digit after its decimal place is 5 or higher and round down if that digit is 4 or lower. This takes in an optional argument for the precision you're looking for.

Floating point numbers can also be rounded down to the highest integer lower than the number with the floor method

They can also be rounded up to the lowest integer higher than the number using the ceil method

Section 14.4: Even and Odd Numbers
The even? method can be used to determine if a number is even

The odd? method can be used to determine if a number is odd

Section 14.5: Rational Numbers
Rational represents a rational number as numerator and denominator:

Other ways of creating a Rational

Section 14.6: Complex Numbers

polar.rectangular # => [-0.4161468365471424, 0.9092974268256817] rectangular.polar # => [3.605551275463989, 0.982793723247329] rectangular + polar # => (1.5838531634528576+3.909297426825682i)
Section 14.7: Converting a number to a string
Fixnum#to_s takes an optional base argument and represents the given number in that base:

If no argument is provided, then it represents the number in base 10

Section 14.8: Dividing two numbers
When dividing two numbers pay attention to the type you want in return. Note that dividing two integers will invoke the integer division. If your goal is to run the float division, at least one of the parameters should be of float type.
Integer division:

Float division

Chapter 15: Symbols
Section 15.1: Creating a Symbol
The most common way to create a Symbol object is by prefixing the string identifier with a colon:

Here are some alternative ways to define a Symbol, in combination with a String literal:

Symbols also have a %s sequence that supports arbitrary delimiters similar to how %q and %Q work for strings:

The %s is particularly useful to create a symbol from an input that contains white space:

While some interesting symbols (:/, :[], :^, etc.) can be created with certain string identifiers, note that symbols cannot be created using a numeric identifier:

Symbols may end with a single ? or ! without needing to use a string literal as the symbol's identifier:

Note that all of these different methods of creating symbols will return the same object:

Since Ruby 2.0 there is a shortcut for creating an array of symbols from words:

Section 15.2: Converting a String to Symbol
Given a String:

there are several ways to convert it to a Symbol:


Section 15.3: Converting a Symbol to String
Given a Symbol:

Symbol#to_sThe simplest way to convert it to a String is by using the  method:

Symbol#id2name method which is an alias for the Symbol#to_sAnother way to do it is by using the  method. But it's a method that is unique to the Symbol class:


Chapter 16: Comparable
Parameter	Details
other	The instance to be compared to self
Section 16.1: Rectangle comparable by area
Comparable is one of the most popular modules in Ruby. Its purpose is to provide with convenience comparison methods.
include Comparable and define the space-ship operator (<=>To use it, you have to ):

Chapter 17: Control Flow
Section 17.1: if, elsif, else and end
Ruby offers the expected if and else expressions for branching logic, terminated by the end keyword:

In Ruby, if statements are expressions that evaluate to a value, and the result can be assigned to a variable:

Ruby also offers C-style ternary operators (see here for details) that can be expressed as:

This means the above example using if-else can also be written as

Additionally, Ruby offers the elsif keyword which accepts an expression to enables additional branching logic:

nil.to_sIf none of the conditions in an if/elsif chain are true, and there is no else clause, then the expression evaluates to nil. This can be useful inside string interpolation, since  is the empty string:

Section 17.2: Case statement
Ruby uses the case keyword for switch statements.
As per the Ruby Docs:

Case statements consist of an optional condition, which is in the position of an argument to case, and zero or more when clauses. The first when clause to match the condition (or to evaluate to Boolean truth, if the condition is null) "wins", and its code stanza is executed. The value of the case statement is the value of the successful when clause, or nil if there is no such clause.
A case statement can end with an else clause. Each when a statement can have multiple candidate values, separated by commas.
Example:

Shorter version:

The value of the case clause is matched with each when clause using the === method (not ==). Therefore it can be used with a variety of different types of objects.





By implementing the === method you can create your own match classes:

A case statement can be used without a value to match against:

A case statement has a value, so you can use it as a method argument or in an assignment:

Section 17.3: Truthy and Falsy values
In Ruby, there are exactly two values which are considered "falsy", and will return false when tested as a condition for an if expression. They are:
nil boolean false
All other values are considered "truthy", including:
\n0 - numeric zero (Integer or otherwise)
"" - Empty strings
"" - Strings containing only whitespace
[] - Empty arrays
{} - Empty hashes
Take, for example, the following code:


Will output:

Section 17.4: Inline if/unless
A common pattern is to use an inline, or trailing, if or unless:

This is known as a conditional modifier, and is a handy way of adding simple guard code and early returns:

It is not possible to add an else clause to these modifiers. Also it is generally not recommended to use conditional modifiers inside the main logic -- For complex code one should use normal if, elsif, else instead. Section 17.5: while, until
A while loop executes the block while the given condition is met:

An until loop executes the block while the conditional is false:

Section 17.6: Flip-Flop operator
The flip flop operator .. is used between two conditions in a conditional statement:

The condition evaluates to false until the first part becomes true. Then it evaluates to true until the second part becomes true. After that it switches to false again.
This example illustrates what is being selected:

The flip-flop operator only works inside ifs (including unless) and ternary operator. Otherwise it is being considered as the range operator.

It can switch from false to true and backwards multiple times:

Section 17.7: Or-Equals/Conditional assignment operator (||=)
Ruby has an or-equals operator that allows a value to be assigned to a variable if and only if that variable evaluates to either nil or false.

this operator with the double pipes representing or and the equals sign representing assigning of a value. You may think it represents something like this:

this above example is not correct. The or-equals operator actually represents this:

If x evaluates to nil or false then x is assigned the value of y, and left unchanged otherwise.
Here is a practical use-case of the or-equals operator. Imagine you have a portion of your code that is expected to send an email to a user. What do you do if for what ever reason there is no email for this user. You might write something like this:

Using the or-equals operator we can cut this entire chunk of code, providing clean, clear control and functionality.

In cases where false is a valid value, care must be taken to not override it accidentally:

Section 17.8: unless
if !(some conditionA common statement is ). Ruby offers the alternative of the unless statement.
The structure is exactly the same as an if statement, except the condition is negative. Also, the unless statement does not support elsif, but it does support else:

Section 17.9: throw, catch
Unlike many other programming languages, the throw and catch keywords are not related to exception handling in Ruby.
In Ruby, throw and catch act a bit like labels in other languages. They are used to change the control flow, but are not related to a concept of "error" like Exceptions are.

Section 17.10: Ternary operator
Ruby has a ternary operator (?:), which returns one of two value based on if a condition evaluates as truthy:


if a then b else c endit is the same as writing , though the ternary is preferred Examples:

Section 17.11: Loop control with break, next, and redo
The flow of execution of a Ruby block may be controlled with the break, next, and redo statements. break
The break statement will exit the block immediately. Any remaining instructions in the block will be skipped, and the iteration will end:

The next statement will return to the top of the block immediately, and proceed with the next iteration. Any remaining instructions in the block will be skipped:


The redo statement will return to the top of the block immediately, and retry the same iteration. Any remaining instructions in the block will be skipped:

In addition to loops, these statements work with Enumerable iteration methods, such as each and map:

Block result values
In both the break and next statements, a value may be provided, and will be used as a block result value:


Section 17.12: return vs. next: non-local return in a block

never reached that line. next with a value does the trick. It acts as a block-level return.

In the absence of a return, the value returned by the block is the value of its last expression. Section 17.13: begin, end
The begin block is a control structure that groups together multiple statements.

A begin block will return the value of the last statement in the block. The following example will return 3.

||The begin block is useful for conditional assignment using the = operator where multiple statements may be required to return a result.


It can also be combined with other block structures such as rescue, ensure, while, if, unless, etc to provide greater control of program flow.
 ... } or do ... endBegin blocks are not code blocks, like {; they cannot be passed to functions. Section 17.14: Control flow with logic statements
While it might seem counterintuitive, you can use logical operators to determine whether or not a statement is run. For instance:
File.exist?(filename) or STDERR.puts "#{filename} does not exist!"
This will check to see if the file exists and only print the error message if it doesn't. The or statement is lazy, which means it'll stop executing once it's sure which whether it's value is true or false. As soon as the first term is found to be true, there's no need to check the value of the other term. But if the first term is false, it must check the second term.
A common use is to set a default value:

That sets the value of glass to 'full' if it's not already set. More concisely, you can use the symbolic version of or:

It's also possible to run the second statement only if the first one is false:

Again, and is lazy so it will only execute the second statement if necessary to arrive at a value.
The or operator has lower precedence than and. Similarly, || has lower precedence than &&. The symbol forms have higher precedence than the word forms. This is handy to know when you want to mix this technique with assignment:

Note that the Ruby Style Guide recommends:
The and and or keywords are banned. The minimal added readability is just not worth the high probability of introducing subtle bugs. For boolean expressions, always use && and || instead. For flow control, use if and unless; && and || are also acceptable but less clear.
Chapter 18: Methods
Functions in Ruby provide organized, reusable code to preform a set of actions. Functions simplify the coding process, prevent redundant logic, and make code easier to follow. This topic describes the declaration and utilization of functions, arguments, parameters, yield statements and scope in Ruby. Section 18.1: Defining a method
Methods are defined with the def keyword, followed by the method name and an optional list of parameter names in parentheses. The Ruby code between def and end represents the body of the method.

A method invocation specifies the method name, the object on which it is to be invoked (sometimes called the receiver), and zero or more argument values that are assigned to the named method parameters.

When the receiver is not explicit, it is self.
Parameter names can be used as variables within the method body, and the values of these named parameters come from the arguments to a method invocation.

Section 18.2: Yielding to blocks
You can send a block to your method and it can call that block multiple times. This can be done by sending a proc/lambda or such, but is easier and faster with yield:

 puts ... Note that the {} is not inside the parentheses, it implicitly comes after. This also means we can only have one yield block. We can pass arguments to the yield:


With yield we can easily make iterators or any functions that work on other code:

In fact, it is with yield that things like foreach, each and times are generally implemented in classes.
If you want to find out if you have been given a block or not, use block_given?:

This example assumes that the Employees class has an @employees list that can be iterated with each to get objects that have employee names using the name method. If we are given a block, then we'll yield the name to the block, otherwise we just push it to an array that we return. Section 18.3: Default parameters


It's possible to include defaults for multiple arguments:

However, it's not possible to supply the second without also supplying the first. Instead of using positional parameters, try keyword parameters:

Or a hash parameter that stores options:

Default parameter values can be set by any ruby expression. The expression will run in the context of the method, so you can even declare local variables here. Note, won't get through code review. Courtesy of caius for pointing this out.

Section 18.4: Optional parameter(s) (splat operator)

welcome_guests('Tom')    # Welcome Tom! welcome_guests('Rob', 'Sally', 'Lucas') # Welcome Rob!
                                        # Welcome Sally!
                                        # Welcome Lucas!
welcome_guests(['Rob', 'Sally', 'Lucas']) will output Welcome ["Rob", "Sally", "Lucas"Note that ]!
welcome_guests(*['Rob', 'Sally', 'Lucas'Instead, if you have a list, you can do ]) and that will work as
welcome_guests('Rob', 'Sally', 'Lucas').
Section 18.5: Required default optional parameter mix


Call as follows:

Section 18.6: Use a function as a block
Many functions in Ruby accept a block as an argument. E.g.:

&method(:fn)If you already have a function that does what you want, you can turn it into a block using :

Section 18.7: Single required parameter


Section 18.8: Tuple Arguments
A method can take an array parameter and destructure it immediately into named local variables. Found on Mathias Meyer's blog.

Section 18.9: Capturing undeclared keyword arguments (double splat)
The ** operator works similarly to the * operator but it applies to keyword parameters.

**other_options is not used, an ArgumentError: unknown keyword: foo, barIn the above example, if the  error would be raised.

This is handy when you have a hash of options that you want to pass to a method and you do not want to filter the keys.

It is also possible to unpack a hash using the ** operator. This allows you to supply keyword directly to a method in addition to values from other hashes:

Section 18.10: Multiple required parameters


Section 18.11: Method Definitions are Expressions
Defining a method in Ruby 2.x returns a symbol representing the name:


This allows for interesting metaprogramming techniques. For instance, methods can be wrapped by other methods:

Chapter 19: Hashes
A Hash is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type. You retrieve or create a new entry in a Hash by referring to its key. Section 19.1: Creating a hash
A hash in Ruby is an object that implements a hash table, mapping keys to values. Ruby supports a specific literal syntax for defining hashes using {}:

A hash can also be created using the standard new method:

Hashes can have values of any type, including complex types like arrays, objects and other hashes:

Also keys can be of any type, including complex ones:

Symbols are commonly used as hash keys, and Ruby 1.9 introduced a new syntax specifically to shorten this process. The following hashes are equivalent:

The following hash (valid in all Ruby versions) is different, because all keys are strings:

While both syntax versions can be mixed, the following is discouraged.

With Ruby 2.2+, there is an alternative syntax for creating a hash with symbol keys (most useful if the symbol contains spaces):

Section 19.2: Setting Default Values
By default, attempting to lookup the value for a key which does not exist will return nil. You can optionally specify some other value to return (or an action to take) when the hash is accessed with a non-existent key. Although this is referred to as "the default value", it need not be a single value; it could, for example, be a computed value such as the length of the key.
The default value of a hash can be passed to its constructor:

A default can also be specified on an already constructed Hash:

It is important to note that the default value is not copied each time a new key is accessed, which can lead to surprising results when the default value is a reference type:

To circumvent this problem, the Hash constructor accepts a block which is executed each time a new key is accessed, and the returned value is used as the default:

Note that above we had to use += instead of << because the default value is not automatically assigned to the hash; using << would have added to the array, but authors[:homer] would have remained undefined:

In order to be able to assign default values on access, as well as to compute more sophisticated defaults, the default block is passed both the hash and the key:


You can also use a default block to take an action and/or return a value dependent on the key (or some other data):

You can even create more complex hashes:
page_views = Hash.new { |hash, key| hash[key] = { count: 0, url: key } } page_views["http://example.com"][:count] += 1
 page_views # => {"http://example.com"=>{:count=>1, :url=>"http://example.com"}} In order to set the default to a Proc on an already-existing hash, use default_proc=:

Section 19.3: Accessing Values
Individual values of a hash are read and written using the [] and []= methods:

By default, accessing a key which has not been added to the hash returns nil, meaning it is always safe to attempt to look up a key's value:

Hashes can also contain keys in strings. If you try to access them normally it will just return a nil, instead you access them by their string keys:

For situations where keys are expected or required to exist, hashes have a fetch method which will raise an exception when accessing a key that does not exist:

fetch accepts a default value as its second argument, which is returned if the key has not been previously set:

fetch can also accept a block which is returned if the key has not been previously set:

Hashes also support a store method as an alias for []=:

You can also get all values of a hash using the values method:

Note: This is only for Ruby 2.3+ #dig is handy for nested Hashs. Extracts the nested value specified by the sequence of idx objects by calling dig at each step, returning nil if any intermediate step is nil.

Section 19.4: Automatically creating a Deep Hash
Hash has a default value for keys that are requested but don't exist (nil):

When creating a new Hash, one can specify the default:

mkdir Hash.new also takes a block, which allows you to automatically create nested hashes, such as Perl's autovivification behavior or -p:

Section 19.5: Iterating Over a Hash
Enumerable#eachA Hash includes the Enumerable module, which provides several iteration methods, such as: ,
Enumerable#each_pair, Enumerable#each_key, and Enumerable#each_value.



each_with_index. iterates over the elements and provides the index of the iteration:

Section 19.6: Filtering hashes
SELECT returns a new hash with key-value pairs for which the block evaluates to true.
{ :a => 1, :b => 2, :c => 3 }.select { |k, v| k != :a && v.even? } # => { :b => 2 }
When you will not need the key or value in a filter block, the convention is to use an _ in that place:
{ :a => 1, :b => 2, :c => 3 }.select { |_, v| v.even? } # => { :b => 2 }
 { :a => 1, :b => 2, :c => 3 }.select { |k, _| k == :c } # => { :c => 3 } reject returns a new hash with key-value pairs for which the block evaluates to false:
{ :a => 1, :b => 2, :c => 3 }.reject { |_, v| v.even? } # => { :a => 1, :c => 3 }
{ :a => 1, :b => 2, :c => 3 }.reject { |k, _| k == :b } # => { :a => 1, :c => 3 }
Section 19.7: Conversion to and from Arrays
Hashes can be freely converted to and from arrays. Converting a hash of key/value pairs into an array will produce an array containing nested arrays for pair:

In the opposite direction a Hash can be created from an array of the same format:

HashSimilarly, Hashes can be initialized using [] and a list of alternating keys and values:

Or from an array of arrays with two values each:

flattenHashes can be converted back to an Array of alternating keys and values using ():

The easy conversion to and from an array allows Hash to work well with many Enumerable methods such as collect and zip:

Section 19.8: Overriding hash function
Ruby hashes use the methods hash and eql? to perform the hash operation and assign objects stored in the hash to internal hash bins. The default implementation of hash in Ruby is the murmur hash function over all member fields of the hashed object. To override this behavior it is possible to override hash and eql? methods.
a.hash == b.hashAs with other hash implementations, two objects a and b, will be hashed to the same bucket if 
a.eqland will be deemed identical if ?(b). Thus, when reimplementing hash and eql? one should take care to ensure that if a and b are equal under eql? they must return the same hash value. Otherwise this might result in duplicate entries in a hash. Conversely, a poor choice in hash implementation might lead many objects to share the same hash bucket, effectively destroying the O(1) look-up time and causing O(n) for calling eql? on all objects.
In the example below only the instance of class A is stored as a key, as it was added first:

Section 19.9: Getting all keys or values of hash
{foo: 'bar', biz: 'baz'}.keys   # => [:foo, :biz]
{foo: 'bar', biz: 'baz'}.values # => ["bar", "baz"]
{foo: 'bar', biz: 'baz'}.to_a   # => [[:foo, "bar"], [:biz, "baz"]]
{foo: 'bar', biz: 'baz'}.each   #<Enumerator: {:foo=>"bar", :biz=>"baz"}:each>
Section 19.10: Modifying keys and values
You can create a new hash with the keys or values modified, indeed you can also add or delete keys, using inject (AKA, reduce). For example to produce a hash with stringified keys and upper case values:

Hash is an enumerable, in essence a collection of key/value pairs. Therefore is has methods such as each, map and inject.
For every key/value pair in the hash the given block is evaluated, the value of memo on the first run is the seed value passed to inject, in our case an empty hash, {}. The value of memo for subsequent evaluations is the returned value of the previous blocks evaluation, this is why we modify memo by setting a key with a value and then return memo at the end. The return value of the final blocks evaluation is the return value of inject, in our case memo.
To avoid the having to provide the final value, you could use each_with_object instead: new_fruit = fruit.each_with_object({}) { |(k,v), memo| memo[k.to_s] = v.upcase }
Or even map:
Version ≥ 1.8

(See this answer for more details, including how to manipulate hashes in place.)
Section 19.11: Set Operations on Hashes
 Intersection of Hashes
To get the intersection of two hashes, return the shared keys the values of which are equal:

keys in a hash are unique, if a key occurs in both hashes which are to be merged, the one from the hash that merge is called on is overwritten:

Chapter 20: Blocks and Procs and Lambdas
Section 20.1: Lambdas


Here you can see that a lambda is almost the same as a proc. However, there are several caveats:
 The arity of a lambda's arguments are enforced; passing the wrong number of arguments to a lambda, will raise an ArgumentError. They can still have default parameters, splat parameters, etc.
 returning from within a lambda returns from the lambda, while returning from a proc returns out of the enclosing scope:


Section 20.2: Partial Application and Currying
Technically, Ruby doesn't have functions, but methods. However, a Ruby method behaves almost identically to functions in other language:

This normal method/function takes a parameter n, doubles it and returns the value. Now let's define a higher order function (or method):

Instead of returning a number, triple returns a method. You can test it using the Interactive Ruby Shell:

If you want to actually get the tripled number, you need to call (or "reduce") the lambda:

Or more concisely:

Currying and Partial Applications
add_one(2) = This is not useful in terms of defining very basic functionality, but it is useful if you want to have methods/functions that are not instantly called or reduced. For example, let's say you want to define methods that add a number by a specific number (for example 3). If you had to define a ton of these you could do:

However, you could also do this:

(λa.(λb.Using lambda calculus we can say that add is (a+b))). Currying is a way of partially applying add. So
add.curry.(1), is (λa.(λb.(a+b)))(1) which can be reduced to (λb.(1+b)). Partial application means that we passed one argument to add but left the other argument to be supplied later. The output is a specialized method.
More useful examples of currying
Let's say we have really big general formula, that if we specify certain arguments to it, we can get specific formulae from it. Consider this formula:

This formula is made for working in three dimensions, but let's say we only want this formula with regards to y and z. Let's also say that to ignore x, we want to set it's value to pi/2. Let's first make the general formula:

Now, let's use currying to get our yz formula:

Then to call the lambda stored in f_yz:

Math::PIThis is pretty simple, but let's say we want to get the formula for xz. How can we set y to /2 if it's not the last argument? Well, it's a bit more complicated:

In this case, we need to provide placeholders for the parameter we aren't pre-filling. For consistency we could write f_xy like this:

Here's how the lambda calculus works for f_yz:
f = (λx.(λy.(λz.(sin(x*y) * sin(y*z) * sin(z*x)))) f_yz = (λx.(λy.(λz.(sin(x*y) * sin(y*z) * sin(z*x)))) (π/2) # Reduce => f_yz = (λy.(λz.(sin((π/2)*y) * sin(y*z) * sin(z*(π/2))))
Now let's look at f_xz
f = (λx.(λy.(λz.(sin(x*y) * sin(y*z) * sin(z*x)))) f_xz = (λx.(λy.(λz.(sin(x*y) * sin(y*z) * sin(z*x)))) (λt.t) (π/2)  # Reduce => f_xz = (λt.(λz.(sin(t*(π/2)) * sin((π/2)*z) * sin(z*t))))
For more reading about lambda calculus try this.
Section 20.3: Objects as block arguments to methods
Putting a & (ampersand) in front of an argument will pass it as the method's block. Objects will be converted to a Proc using the to_proc method.

This is a common pattern in Ruby and many standard classes provide it.
For example, Symbols implement to_proc by sending themselves to the argument:

:symbolThis enables the useful & idiom, commonly used with Enumerable objects:

Section 20.4: Converting to Proc
Objects that respond to to_proc can be converted to procs with the & operator (which will also allow them to be passed as blocks).
The class Symbol defines #to_proc so it tries to call the corresponding method on the object it receives as parameter.

Method objects also define #to_proc.

Section 20.5: Blocks
do..endBlocks are chunks of code enclosed between braces {} (usually for single-line blocks) or  (used for multi-line blocks).

Yielding
Blocks can be used inside methods and functions using the word yield:

Be careful though if yield is called without a block it will raise a LocalJumpError. For this purpose ruby provides another method called block_given? this allows you to check if a block was passed before calling yield



While this is a simple example yielding can be very useful for allowing direct access to instance variables or evaluations inside the context of another object. For Example:

As you can see using yield in this manner makes the code more readable than continually calling
app.configuration.#method_name. Instead you can perform all the configuration inside the block keeping the code
contained. Variables
Variables for blocks are local to the block (similar to the variables of functions), they die when the block is executed.

Blocks can't be saved, they die once executed. In order to save blocks you need to use procs and lambdas.
Chapter 21: Iteration
Section 21.1: Each
Ruby has many types of enumerators but the first and most simple type of enumerator to start with is each. We will print out even or odd for each number between 1 and 10 to show how each works.
Basically there are two ways to pass so called blocks. A block is a piece of code being passed which will be executed by the method which is called. The each method takes a block which it calls for every element of the collection of objects it was called on.
There are two ways to pass a block to a method:
Method 1: Inline
(1..10).each { |i| puts i.even? ? 'even' : 'odd' }
This is a very compressed and ruby way to solve this. Let's break this down piece by piece.
..10) is a range from 1 to 10 inclusive. If we wanted it to be 1 to 10 exclusive, we would write (1...101. (1).
each2. . is an enumerator that enumerates over each element in the object it is acting on. In this case, it acts on each number in the range.
 puts i.even? ? 'even' : 'odd' 3. { |i|} is the block for the each statement, which itself can be broken down further.
1. |i| this means that each element in the range is represented within the block by the identifier i.
2. puts is an output method in Ruby that has an automatic line break after each time it prints. (We can use print if we don't want the automatic line break)
 == i.even? checks if i is even. We could have also used i 3.% 20; however, it is preferable to use built in methods.
? "even" : "odd"4. this is ruby's ternary operator. The way a ternary operator is constructed isexpression ? a : b. This is short for
if expression a else b end
For code longer than one line the block should be passed as a multiline block.
Method 2: Multiline
(1..10).each do |i| if i.even? puts 'even' else puts 'odd' end end
In a multiline block the do replaces the opening bracket and end replaces the closing bracket from the inline style.
Ruby supports reverse_each as well. It will iterate the array backwards.

Section 21.2: Implementation in a class
Enumerable is the most popular module in Ruby. Its purpose is to provide you with iterable methods like map, SELECT, reduce, etc. Classes that use Enumerable include Array, Hash, Range. To use it, you have to include Enumerable and implement each.

Section 21.3: Iterating over complex objects
Arrays
You can iterate over nested arrays:

The following syntax is allowed too:

Will produce:

Hashes
You can iterate over key-value pairs:

Will produce:

You can iterate over keys and values simultaneously:

Will produce:

Section 21.4: For iterator
This iterates from 4 to 13 (inclusive).

We can also iterate over arrays using for

Section 21.5: Iteration with index
Sometimes you want to know the position (index) of the current element while iterating over an enumerator. For such purpose, Ruby provides the with_index method. It can be applied to all the enumerators. Basically, by adding with_index to an enumeration, you can enumerate that enumeration. Index is passed to a block as the second argument.

with_index has an optional argument - the first index which is 0 by default:

each.with_indexThere is a specific method each_with_index. The only difference between it and  is that you can't pass an argument to that, so the first index is 0 all the time.


Section 21.6: Map
Returns the changed object, but the original object remains as it was. For example:

map! changes the original object:

Note: you can also use collect to do the same thing.

Chapter 22: Exceptions
Section 22.1: Creating a custom exception type
A custom exception is any class that extends Exception or a subclass of Exception.
In general, you should always extend StandardError or a descendant. The Exception family are usually for virtualmachine or system errors, rescuing them can prevent a forced interruption from working as expected.

It's common to name exceptions by adding the Error suffix at the end:
 ConnectionError
DontPanicError
However, when the error is self-explanatory, you don't need to add the Error suffix because would be redundant:
 FileNotFound vs FileNotFoundError
 DatabaseExploded vs DatabaseExplodedError
 Section 22.2: Handling multiple exceptions
You can handle multiple errors in the same rescue declaration:

You can also add multiple rescue declarations:

The order of the rescue blocks is relevant: the first match is the one executed. Therefore, if you put StandardError as the first condition and all your exceptions inherit from StandardError, then the other rescue statements will never be executed.

Some blocks have implicit exception handling like def, class, and module. These blocks allow you to skip the begin statement.

Section 22.3: Handling an exception
begin/rescueUse the  block to catch (rescue) an exception and handle it:

A rescue clause is analogous to a catch block in a curly brace language like C# or Java.
A bare rescue like this rescues StandardError.
Note: Take care to avoid catching Exception instead of the default StandardError. The Exception class includes SystemExit and NoMemoryError and other serious exceptions that you usually don't want to catch. Always consider catching StandardError (the default) instead.
You can also specify the exception class that should be rescued:

This rescue clause will not catch any exception that is not a CustomError.
You can also store the exception in a specific variable:


If you failed to handle an exception, you can raise it any time in a rescue block.

If you want to retry your begin block, call retry:

You can be stuck in a loop if you catch an exception in every retry. To avoid this, limit your retry_count to a certain number of tries.

You can also provide an else block or an ensure block. An else block will be executed when the begin block completes without an exception thrown. An ensure block will always be executed. An ensure block is analogous to a finally block in a curly brace language like C# or Java.

If you are inside a def, module or class block, there is no need to use the begin statement.

Section 22.4: Raising an exception
Kernel#raiseTo raise an exception use  passing the exception class and/or message:
raise StandardError # raises a StandardError.new
raise StandardError, "An error" # raises a StandardError.new("An error")
You can also simply pass an error message. In this case, the message is wrapped into a RuntimeError:

Here's an example:

Section 22.5: Adding information to (custom) exceptions
It may be helpful to include additional information with an exception, e.g. for logging purposes or to allow conditional handling when the exception is caught:

Raising the exception:

Catching the exception and accessing the additional information provided:

Chapter 23: Enumerators
Parameter	Details
yield	Responds to yield, which is aliased as <<. Yielding to this object implements iteration.
An Enumerator is an object that implements iteration in a controlled fashion.
Instead of looping until some condition is satisfied, the object enumerates values as needed. Execution of the loop is paused until the next value is requested by the owner of the object.
Enumerators make infinite streams of values possible.
Section 23.1: Custom enumerators


Section 23.2: Existing methods
If an iteration method such as each is called without a block, an Enumerator should be returned.
This can be done using the enum_for method:

This enables the programmer to compose Enumerable operations:

Section 23.3: Rewinding
Use rewind to restart the enumerator.



Chapter 24: Enumerable in Ruby
Enumberable module, a set of methods are available to do traversing, sorting, searching etc across the collection(Array, Hashes, Set, HashMap).
Section 24.1: Enumerable module


arr = [1,2,3,4,5] newArr = arr.map do |x|     -x       end
puts arr [1,2,3,4,5]
puts newArr [-1, -2, -3, -4, -5]
map is returning the modified copy of the current value of the collection. arr has unaltered value.
Difference between each and map:
1. map returned the modified value of the collection.
Let us see the example: arr = [1,2,3,4,5] newArr = arr.map do |x|     puts x     -x       end
puts newArr [-1, -2, -3, -4, -5] map method is the iterator and also return the copy of transformed collection.
arr = [1,2,3,4,5] newArr = arr.each do |x|     puts x     -x       end
puts newArr [1,2,3,4,5]
each block will throw the array because this is just the iterator. Each iteration, does not actually alter each element in the iteration.
   
6. map!
map with bang changes the orginal collection and returned the modified collection not the copy of the modified collection.
arr = [1,2,3,4,5] arr.map! do |x|     puts x     -x end puts  arr [-1, -2, -3, -4, -5]
7. Combining map and each_with_index
Here each_with_index will iterator over the collection and map will return the modified copy of the collection. CountriesName = ["India", "Canada", "America", "Iraq"] newArray = CountriesName.each_with_index.map do |value, index|     puts "Value is #{value} and the index is #{index}"
Summary: Best way to transform the collection is to make use of Enumerable module to compact the clunky code.
Chapter 25: Classes
Section 25.1: Constructor
A class can have only one constructor, that is a method called initialize. The method is automatically invoked when a new instance of the class is created.

Section 25.2: Creating a class
You can define a new class using the class keyword.

.newOnce defined, you can create a new instance using the  method

Section 25.3: Access Levels
Ruby has three access levels. They are public, private and protected.
Methods that follow the private or protected keywords are defined as such. Methods that come before these are implicitly public methods.
Public Methods
A public method should describe the behavior of the object being created. These methods can be called from outside the scope of the created object.


These methods are public ruby methods, they describe the behavior for initializing a new cat and the behavior of the speak method. public keyword is unnecessary, but can be used to escape private or protected

Private Methods
Private methods are not accessible from outside of the object. They are used internally by the object. Using the cat example again:

As you can see in the example above, the newly created Cat object has access to the calculate_cat_age method internally. We assign the variable age to the result of running the private calculate_cat_age method which prints the name and age of the cat to the console.
When we try and call the calculate_cat_age method from outside the my_cat object, we receive a NoMethodError because it's private. Get it?
Protected Methods
Protected methods are very similar to private methods. They cannot be accessed outside the instance of object in the same way private methods can't be. However, using the self ruby method, protected methods can be called within the context of an object of the same type.

You can see we've added an age parameter to the cat class and created three new cat objects with the name and age. We are going to call the own_age protected method to compare the age's of our cat objects.

self.own_agecat2.own_ageLook at that, we were able to retrieve cat1's age using the  protected method and compare it against cat2's age by calling  inside of cat1. Section 25.4: Class Methods types
Classes have 3 types of methods: instance, singleton and class methods.
Instance Methods
These are methods that can be called from an instance of the class.


Class Method
These are static methods, i.e, they can be invoked on the class, and not on an instantiation of that class.

It is equivalent to use self in place of the class name. The following code is equivalent to the code above:

Invoke the method by writing

Singleton Methods
These are only available to specific instances of the class, but not to all.

Both the singleton and class methods are called eigenclasses. Basically, what ruby does is to create an anonymous class that holds such methods so that it won't interfere with the instances that are created.
class <<Another way of doing this is by the  constructor. For example:


Section 25.5: Accessing instance variables with getters and setters
We have three methods:
1. attr_reader: used to allow reading the variable outside the class.
2. attr_writer: used to allow modifying the variable outside the class.
3. attr_accessor: combines both methods.

Note that the parameters are symbols. this works by creating a method.

Is basically the same as:

Section 25.6: New, allocate, and initialize
In many languages, new instances of a class are created using a special new keyword. In Ruby, new is also used to create instances of a class, but it isn't a keyword; instead, it's a static/class method, no different from any other static/class method. The definition is roughly this:

allocate performs the real 'magic' of creating an uninitialized instance of the class
Note also that the return value of initialize is discarded, and obj is returned instead. This makes it immediately clear why you can code your initialize method without worrying about returning self at the end.
The 'normal' new method that all classes get from Class works as above, but it's possible to redefine it however you like, or to define alternatives that work differently. For example:

Section 25.7: Dynamic class creation
Class.newClasses can be created dynamically through the use of .

In the above example, a new class is created and assigned to the constant MyClass. This class can be instantiated and used just like any other class.
Class.newThe  method accepts a Class which will become the superclass of the dynamically created class.

Class.newThe  method also accepts a block. The context of the block is the newly created class. This allows methods to be defined.

Section 25.8: Class and instance variables
There are several special variable types that a class can use for more easily sharing data.
Instance variables, preceded by @. They are useful if you want to use the same variable in different methods.

Class variable, preceded by @@. They contain the same values across all instances of a class.


Global Variables, preceded by $. These are available anywhere to the program, so make sure to use them wisely.

Chapter 26: Inheritance
Section 26.1: Subclasses
Inheritance allows classes to define specific behaviour based on an existing class.

In this example:
Dog Inherits from Animal, making it a Subclass.
Dog gains both the say_hello and eat methods from Animal.
 Dog overrides the say_hello method with different functionality. Section 26.2: What is inherited?
Methods are inherited

Class methods are inherited

Constants are inherited

But beware, they can be overridden:

Instance variables are inherited:

Beware, if you override the methods that initialize instance variables without calling super, they will be nil. Continuing from above:

Class instance variables are not inherited:

Class variables aren't really inherited
They are shared between the base class and all subclasses as 1 variable:

So continuing from above:

Section 26.3: Multiple Inheritance
Multiple inheritance is a feature that allows one class to inherit from multiple classes(i.e., more than one parent). Ruby does not support multiple inheritance. It only supports single-inheritance (i.e. class can have only one parent), but you can use composition to build more complex classes using Modules. Section 26.4: Mixins
Mixins are a beautiful way to achieve something similar to multiple inheritance. It allows us to inherit or rather include methods defined in a module into a class. These methods can be included as either instance or class methods. The below example depicts this design.


Section 26.5: Refactoring existing classes to use Inheritance

The eat method is exactly the same in these two classes. While this works, it is hard to maintain. The problem will get worse if there are more animals with the same eat method. Inheritance can solve this problem.


We have created a new class, Animal, and moved our eat method to that class. Then, we made Cat and Dog inherit from this new common superclass. This removes the need for repeating code

Chapter 27: method_missing
Parameter	Details
           The name of the method that has been called (in the above example this is :say_moo, note that this is a method symbol.
*args	The arguments passed in to this method. Can be any number, or none
{ }&block	The block of the method called, this can either be a do block, or a  enclosed block
Section 27.1: Catching calls to an undefined method

Section 27.2: Use with block

Section 27.3: Use with parameter

Section 27.4: Using the missing method


Chapter 28: Regular Expressions and Regex Based Operations
Section 28.1: =~ operator

'haystack' =~ /hay/Note: The order is significant. Though  is in most cases an equivalent, side effects might differ:
Regexp#=~Strings captured from named capture groups are assigned to local variables only when  is called
(regexp =~ str);
Since the right operand might be is an arbitrary object, for regexp =~ str there will be called either
Regexp#=~ or String#=~.
Note that this does not return a true/false value, it instead returns either the index of the match if found, or nil if not found. Because all integers in ruby are truthy (including 0) and nil is falsy, this works. If you want a boolean value, use
#=== as shown in another example.
Section 28.2: Regular Expressions in Case Statements
You can test if a string matches several regular expressions using a switch statement.
Example

This works because case statements are checked for equality using the === operator, not the == operator. When a regex is on the left hand side of a comparison using ===, it will test a string to see if it matches. Section 28.3: Groups, named and otherwise
(...) with a named group, (?<name>...)Ruby extends the standard group syntax . This allows for extraction by name instead of having to count how many groups you have.


The index of the match is counted based on the order of the left parentheses (with the entire regex being the first group at index 0)

Section 28.4: Quantifiers

By default, quantifiers are greedy, which means they take as many characters as they can while still making a match. Normally this is not noticeable:
/(?<site>.*) Stack Exchange/ =~ 'Motor Vehicle Maintenance & Repair Stack Exchange'
The named capture group site will be set to ''Motor Vehicle Maintenance & Repair' as expected. But if 'Stack Exchange' is an optional part of the string (because it could be 'Stack Overflow' instead), the naive solution will not work as expected:

This version will still match, but the named capture will include 'Stack Exchange' since * greedily eats those characters. The solution is to add another question mark to make the * lazy:

Appending ? to any quantifier will make it lazy. Section 28.5: Common quick usage
Regular expressions are often used in methods as parameters to check if other strings are present or to search and/or replace strings.
You'll often see the following:

So you can simply use this as a check if a string contains a substring

More advanced but still short and quick: search for a specific group by using the second parameter, 2 is the second in this example because numbering starts at 1 and not 0, a group is what is enclosed in parentheses.

Also often used: search and replace with sub or gsub, \1 gives the first found group, \2 the second: string.gsub(/(n.t).+(l.ng)/, '\1 very \2') # My not very long string
The last result is remembered and can be used on the following lines

Section 28.6: match? - Boolean Result
Returns true or false, which indicates whether the regexp is matched or not without updating $~ and other related variables. If the second parameter is present, it specifies the position in the string to begin the search.

Ruby 2.4+
Section 28.7: Defining a Regexp
A Regexp can be created in three different ways in Ruby.

Section 28.8: Character classes
Describes ranges of symbols
You can enumerate symbols explicitly

Or use ranges

It is possible to combine ranges and single symbols

Leading dash (-) is treated as character

Classes can be negative when preceding symbols with ^

There are some shortcuts for widespread classes and special characters, plus line endings


\n will be understood simply as new line
To escape any reserved character, such as / or [] and others use backslash (left slash)


Chapter 29: File and I/O Operations
Flag	Meaning
"r"	Read-only, starts at beginning of file (default mode).
"r+" Read-write, starts at beginning of file.
"w"	Write-only, truncates existing file to zero length or creates a new file for writing.
"w+" Read-write, truncates existing file to zero length or creates a new file for reading and writing.
"a"	Write-only, starts at end of file if file exists, otherwise creates a new file for writing.
"a+" Read-write, starts at end of file if file exists, otherwise creates a new file for reading and writing.
File.new("test.txt", "rb") would open test.txt in read-only     Binary file mode. Suppresses EOL <-> CRLF conversion on Windows. And sets external encoding to ASCII-8BIT "b"	unless explicitly specified. (This flag may only appear in conjunction with the above flags. For example,  mode as a binary file.)
File.new("test.txt", "wt") would open test.txt in write-only     Text file mode. (This flag may only appear in conjunction with the above flags. For example, "t"
 mode as a text file.)
Section 29.1: Writing a string to a file
A string can be written to a file with an instance of the File class.

The File class also offers a shorthand for the new and close operations with the open method.

File.writeFor simple write operations, a string can be also written directly to a file with . Note that this will overwrite the file by default.

File.writeTo specify a different mode on , pass it as the value of a key called mode in a hash as another parameter.
File.write('tmp.txt', "NaNaNaNa\n" * 4 + 'Batman!\n', { mode: 'a'})
Section 29.2: Reading from STDIN

Section 29.3: Reading from arguments with ARGV


Section 29.4: Open and closing a file
Manually open and close a file.

Automatically close a file using a block.

Section 29.5: get a single char of input
gets.chompUnlike  this will not wait for a newline.
First part of the stdlib must be included

Then a helper method can be written:

control+cIts' imporant to exit if  is pressed.
Chapter 30: Ruby Access Modifiers
Access control(scope) to various methods, data members, initialize methods. Section 30.1: Instance Variables and Class Variables
Let's first brush up with what are the Instance Variables: They behave more like properties for an object. They are initialized on an object creation. Instance variables are accessible through instance methods. Per Object has per instance variables. Instance Variables are not shared between objects.
Sequence class has @from, @to and @by as the instance variables.


Class Variables Treat class variable same as static variables of java, which are shared among the various objects of that class. Class Variables are stored in heap memory.

Shared among object and object1.
Comparing the instance and class variables of Ruby against Java:

Section 30.2: Access Controls
Comparison of access controls of Java against Ruby: If method is declared private in Java, it can only be accessed by other methods within the same class. If a method is declared protected it can be accessed by other classes which exist within the same package as well as by subclasses of the class in a different package. When a method is public it is visible to everyone. In Java, access control visibility concept depends on where these classes lie's in the inheritance/package hierarchy.
Whereas in Ruby, the inheritance hierarchy or the package/module don't fit. It's all about which object is the receiver of a method.
For a private method in Ruby, it can never be called with an explicit receiver. We can (only) call the private method with an implicit receiver.
This also means we can call a private method from within a class it is declared in as well as all subclasses of this class.


Protected method can be called with an implicit receiver, as like private. In addition protected method can also be called by an explicit receiver (only) if the receiver is "self" or "an object of the same class".

Consider Public methods with maximum visibility
Summary
1. Public: Public methods have maximum visibility
2. Protected: Protected method can be called with an implicit receiver, as like private. In addition protected method can also be called by an explicit receiver (only) if the receiver is "self" or "an object of the same class".
3. Private: For a private method in Ruby, it can never be called with an explicit receiver. We can (only) call the private method with an implicit receiver. This also means we can call a private method from within a class it is declared in as well as all subclasses of this class.

Chapter 31: Design Patterns and Idioms in Ruby
Section 31.1: Decorator Pattern
Decorator pattern adds behavior to objects without affecting other objects of the same class. The decorator pattern is a useful alternative to creating sub-classes.
Create a module for each decorator. This approach is more flexible than inheritance because you can mix and match responsibilities in more combinations. Additionally, because the transparency allows decorators to be nested recursively, it allows for an unlimited number of responsibilities.
Assume the Pizza class has a cost method that returns 300:

Represent pizza with an added layer of cheese burst and the cost goes up by 50. The simplest approach is to create a PizzaWithCheese subclass that returns 350 in the cost method.

Next, we need to represent a large pizza that adds 100 to the cost of a normal pizza. We can represent this using a LargePizza subclass of Pizza.

We could also have an ExtraLargePizza which adds a further cost of 15 to our LargePizza. If we were to consider that these pizza types could be served with cheese, we would need to add LargePizzaWithChese and ExtraLargePizzaWithCheese subclasses.we end up with a total of 6 classes.
To simplify the approach, use modules to dynamically add behavior to Pizza class:
Module + extend + super decorator:->


Section 31.2: Observer
The observer pattern is a software design pattern in which an object (called subject) maintains a list of its dependents (called observers), and notifies them automatically of any state changes, usually by calling one of their methods.
Ruby provides a simple mechanism to implement the Observer design pattern. The module Observable provides the logic to notify the subscriber of any changes in the Observable object.
For this to work, the observable has to assert it has changed and notify the observers.
updateObjects observing have to implement an () method, which will be the callback for the Observer.
Let's implement a small chat, where users can subscribe to users and when one of them write something, the subscribers get notified.


Producing the following output:

We've triggered the method write at the Moderator class twice, notifying its subscribers, in this case just one.
The more subscribers we add the more the changes will propagate. Section 31.3: Singleton
Ruby Standard Library has a Singleton module which implements the Singleton pattern. The first step in creating a Singleton class is to require and include the Singleton module in a class:

If you try to instantiate this class as you normally would a regular class, a NoMethodError exception is raised. The constructor is made private to prevent other instances from being accidentally created:

instanceTo access the instance of this class, we need to use the ():

Logger example


Without Singleton include
The above singleton implementations can also be done without the inclusion of the Singleton module. This can be achieved with the following:

which is a shorthand notation for the following:

However, keep in mind that the Singleton module is tested and optimized, therefore being the better option to implement your singleton with. Section 31.4: Proxy
Proxy object is often used to ensure guarded access to another object, which internal business logic we don't want to pollute with safety requirements.
Suppose we'd like to guarantee that only user of specific permissions can access resource.
Proxy definition: (it ensure that only users which actually can see reservations will be able to consumer reservation_service)

Models and ReservationService:


Consumer service:

Test:

BENEFITS
we're avoiding any changes in ReservationService when access restrictions are changed.
we're not mixing business related data (date_from, date_to, reservations_count) with domain unrelated concepts (user permissions) in service.
Consumer (StatsService) is free from permissions related logic as well
CAVEATS
 Proxy interface is always exactly the same as the object it hides, so that user that consumes service wrapped by proxy wasn't even aware of proxy presence.

Chapter 32: Loading Source Files
Section 32.1: Require files to be loaded only once
rb, .so, .o or .dllThe Kernel#require method will load files only once (several calls to require will result in the code in that file being evaluated only once). It will search your ruby $LOAD_PATH to find the required file if the parameter is not an absolute path. Extensions like . are optional. Relative paths will be resolved to the current working directory of the process.

The Kernel#require_relative allows you to load files relative to the file in which require_relative is called.

Section 32.2: Automatically loading source files
Kernel#autoload registers filename to be loaded (using Kernel::requireThe method ) the first time that module
(which may be a String or a symbol) is accessed.

The method Kernel#autoload? returns filename to be loaded if name is registered as autoload.

Section 32.3: Loading optional files
When files are not available, the require family will throw a LoadError. This is an example which illustrates loading optional modules only if they exist.


Section 32.4: Loading files repeatedly
The Kernel#load method will evaluate the code in the given file. The search path will be constructed as with require. It will re-evaluate that code on every subsequent call unlike require. There is no load_relative.

Section 32.5: Loading several files
You can use any ruby technique to dynamically create a list of files to load. Illustration of globbing for files starting with test, loaded in alphabetical order.


Chapter 33: Thread
Section 33.1: Accessing shared resources
Use a mutex to synchronise access to a variable which is accessed from multiple threads:

Otherwise, the value of counter currently visible to one thread could be changed by another thread.
Thread Example without Mutex (see e.g. 0, where Before and After differ by more than 1):


Section 33.2: Basic Thread Semantics
Thread.newA new thread separate from the main thread's execution, can be created using .

This will automatically start the execution of the new thread.
To freeze execution of the main Thread, until the new thread stops, use join:

Note that the Thread may have already finished when you call join, in which case execution will continue normally.
If a sub-thread is never joined, and the main thread completes, the sub-thread will not execute any remaining code. Section 33.3: Terminating a Thread
A thread terminates if it reaches the end of its code block. The best way to terminate a thread early is to convince it to reach the end of its code block. This way, the thread can run cleanup code before dying.
This thread runs a loop while the instance variable continue is true. Set this variable to false, and the thread will die a natural death:

Section 33.4: How to kill a thread
Thread.kill or Thread.terminateYou call use :

Chapter 34: Range
Section 34.1: Ranges as Sequences
The most important use of ranges is to express a sequence Syntax:
(begin..end) => this construct will include end value
 (begin...end) => this construct will exclude end value or
Range.new(begin,end,exclude_end) => exclude_end is by default false
Most important end value must be greater the begin, otherwise it will return nothing.
Examples:

Section 34.2: Iterating over a range
You can easily do something to each element in a range.

Section 34.3: Range between dates

Chapter 35: Modules
Section 35.1: A simple mixin with include

Now Bar is a mix of its own methods and the methods from SomeMixin.
Note that how a mixin is used in a class depends on how it is added:
 the include keyword evaluates the module code in the class context (eg. method definitions will be methods on instances of the class), extend will evaluate the module code in the context of the singleton class of the object (methods are available directly on the extended object). Section 35.2: Modules and Class Composition
include ModuleNameYou can use Modules to build more complex classes through composition. The  directive incorporates a module's methods into a class.

Baz now contains methods from both Foo and Bar in addition to its own methods.

Section 35.3: Module as Namespace
Modules can contain other modules and classes:

Section 35.4: A simple mixin with extend
A mixin is just a module that can be added (mixed in) to a class. one way to do it is with the extend method. The extend method adds methods of the mixin as class methods.

Chapter 36: Introspection in Ruby
What is introspection?
Introspection is looking inward to know about the inside. That is a simple definition of introspection.
In programming and Ruby in general...introspection is the ability to look at object, class... at run time to know about that one. Section 36.1: Introspection of class
Lets following are the class definition class A def a; end end module B def b; end end class C < A include B def c; end end
What are the instance methods of C?
C.instance_methods # [:c, :b, :a, :to_json, :instance_of?...]
What are the instance methods that declare only on C?
C.instance_methods(false) # [:c]What are the ancestors of class C?
C.ancestors # [C, B, A, Object,...]
Superclass of C?
C.superclass # A
Section 36.2: Lets see some examples
Example:

Then we find out something about s. Lets begin:
So you want to know what is the class of s at run time?

Ohh, good. But what are the methods of s?
irb(main):002:0> s.methods => [:unicode_normalize, :include?, :to_c, :unicode_normalize!, :unicode_normalized?, :%, :*, :+,
:count, :partition, :unpack, :encode, :encode!, :next, :casecmp, :insert, :bytesize, :match,
:succ!, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :+@, :-@, :setbyte, :getbyte, :<=>,
:<<, :scrub, :scrub!, :byteslice, :==, :===, :dump, :=~, :downcase, :[], :[]=, :upcase, :downcase!,
:capitalize, :swapcase, :upcase!, :oct, :empty?, :eql?, :hex, :chars, :split, :capitalize!,
:swapcase!, :concat, :codepoints, :reverse, :lines, :bytes, :prepend, :scan, :ord, :reverse!,
:center, :sub, :freeze, :inspect, :intern, :end_with?, :gsub, :chop, :crypt, :gsub!, :start_with?,
:rstrip, :sub!, :ljust, :length, :size, :strip!, :succ, :rstrip!, :chomp, :strip, :rjust, :lstrip!,
:tr!, :chomp!, :squeeze, :lstrip, :tr_s!, :to_str, :to_sym, :chop!, :each_byte, :each_char,
:each_codepoint, :to_s, :to_i, :tr_s, :delete, :encoding, :force_encoding, :sum, :delete!, :squeeze!, :tr, :to_f, :valid_encoding?, :slice, :slice!, :rpartition, :each_line, :b,
:ascii_only?, :hash, :to_r, :<, :>, :<=, :>=, :between?, :instance_of?, :public_send,
:instance_variable_get, :instance_variable_set, :instance_variable_defined?,
:remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :is_a?, :extend,
:to_enum, :enum_for, :!~, :respond_to?, :display, :object_id, :send, :method, :public_method,
:singleton_method, :define_singleton_method, :nil?, :class, :singleton_class, :clone, :dup,
:itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods,
:frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval,
:instance_exec, :__id__]
You want to know if s is an instance of String?

What are the public methods of s?
irb(main):026:0* s.public_methods => [:unicode_normalize, :include?, :to_c, :unicode_normalize!, :unicode_normalized?, :%, :*, :+,
:count, :partition, :unpack, :encode, :encode!, :next, :casecmp, :insert, :bytesize, :match,
:succ!, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :+@, :-@, :setbyte, :getbyte, :<=>,
:<<, :scrub, :scrub!, :byteslice, :==, :===, :dump, :=~, :downcase, :[], :[]=, :upcase, :downcase!,
:capitalize, :swapcase, :upcase!, :oct, :empty?, :eql?, :hex, :chars, :split, :capitalize!,
:swapcase!, :concat, :codepoints, :reverse, :lines, :bytes, :prepend, :scan, :ord, :reverse!,
:center, :sub, :freeze, :inspect, :intern, :end_with?, :gsub, :chop, :crypt, :gsub!, :start_with?,
:rstrip, :sub!, :ljust, :length, :size, :strip!, :succ, :rstrip!, :chomp, :strip, :rjust, :lstrip!,
:tr!, :chomp!, :squeeze, :lstrip, :tr_s!, :to_str, :to_sym, :chop!, :each_byte, :each_char,
:each_codepoint, :to_s, :to_i, :tr_s, :delete, :encoding, :force_encoding, :sum, :delete!,
:squeeze!, :tr, :to_f, :valid_encoding?, :slice, :slice!, :rpartition, :each_line, :b,
:ascii_only?, :hash, :to_r, :<, :>, :<=, :>=, :between?, :pretty_print, :pretty_print_cycle,
:pretty_print_instance_variables, :pretty_print_inspect, :instance_of?, :public_send,
:instance_variable_get, :instance_variable_set, :instance_variable_defined?,
:remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :pretty_inspect,
:is_a?, :extend, :to_enum, :enum_for, :!~, :respond_to?, :display, :object_id, :send, :method,
:public_method, :singleton_method, :define_singleton_method, :nil?, :class, :singleton_class,
:clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?,
 :instance_eval, :instance_exec, :__id__] and private methods....
irb(main):030:0* s.private_methods => [:initialize, :initialize_copy, :DelegateClass, :default_src_encoding, :irb_binding, :sprintf,
:format, :Integer, :Float, :String, :Array, :Hash, :catch, :throw, :loop, :block_given?, :Complex,
:set_trace_func, :trace_var, :untrace_var, :at_exit, :Rational, :caller, :caller_locations,
:select, :test, :fork, :exit, :`, :gem_original_require, :sleep, :pp, :respond_to_missing?, :load, :exec, :exit!, :system, :spawn, :abort, :syscall, :printf, :open, :putc, :print, :readline, :puts,
:p, :srand, :readlines, :gets, :rand, :proc, :lambda, :trap, :initialize_clone, :initialize_dup,
:gem, :require, :require_relative, :autoload, :autoload?, :binding, :local_variables, :warn,
:raise, :fail, :global_variables, :__method__, :__callee__, :__dir__, :eval, :iterator?,
 :method_missing, :singleton_method_added, :singleton_method_removed, :singleton_method_undefined] Yes, do s have a method name upper. You want to get the upper case version of s? Lets try:

Look like not, the correct method is upcase lets check:


Chapter 37: Monkey Patching in Ruby
Monkey Patching is a way of modifying and extending classes in Ruby. Basically, you can modify already defined classes in Ruby, adding new methods and even modifying previously defined methods.
Section 37.1: Changing an existing ruby method

Section 37.2: Monkey patching a class
Monkey patching is the modification of classes or objects outside of the class itself.
Sometimes it is useful to add custom functionality.
Example: Override String Class to provide parsing to boolean

to_b()As you can see, we add the  method to the String class, so we can parse any string to a boolean value.

Section 37.3: Monkey patching an object
Like patching of classes, you can also patch single objects. The difference is that only that one instance can use the new method.
Example: Override a string object to provide parsing to boolean


Section 37.4: Safe Monkey patching with Refinements
Since Ruby 2.0, Ruby allows to have safer Monkey Patching with refinements. Basically it allows to limit the Monkey Patched code to only apply when it is requested.
First we create a refinement in a module:

Then we can decide where to use it:

Section 37.5: Changing a method with parameters
You can access the exact same context as the method you override.


Section 37.6: Adding Functionality
You can add a method to any class in Ruby, whether it's a builtin or not. The calling object is referenced using self.

Section 37.7: Changing any method

Section 37.8: Extending an existing class

Chapter 38: Recursion in Ruby
Section 38.1: Tail recursion
Many recursive algorithms can be expressed using iteration. For instance, the greatest common denominator function can be written recursively:

or iteratively:

The two algorithms are equivalent in theory, but the recursive version risks a SystemStackError. However, since the recursive method ends with a call to itself, it could be optimized to avoid a stack overflow. Another way to put it: the recursive algorithm can result in the same machine code as the iterative if the compiler knows to look for the recursive method call at the end of the method. Ruby doesn't do tail call optimization by default, but you can turn it on with:

In addition to turning on tail-call optimization, you also need to turn off instruction tracing. Unfortunately, these options only apply at compile time, so you either need to require the recursive method from another file or eval the method definition:

Finally, the final return call must return the method and only the method. That means you'll need to re-write the standard factorial function:

To something like:


This version passes the accumulated sum via a second (optional) argument that defaults to 1.
Further reading: Tail Call Optimization in Ruby and Tailin' Ruby. Section 38.2: Recursive function
Let's start with a simple algorithm to see how recursion could be implemented in Ruby.
A bakery has products to sell. Products are in packs. It services orders in packs only. Packaging starts from the largest pack size and then the remaining quantities are filled by next pack sizes available.
For e.g. If an order of 16 is received, bakery allocates 2 from 5 pack and 2 from 3 pack. 25+23 = 16. Let's see how this is implemented in recursion. "allocate" is the recursive function here.

Output is:
		Pack combination is: [3, 3, 5, 5]

Chapter 39: Splat operator (*)
Section 39.1: Variable number of arguments
The splat operator removes individual elements of an array and makes them into a list. This is most commonly used to create a method that accepts a variable number of arguments:

Notice that an array only counts as one item on the list, so you will need to us the splat operator on the calling side too if you have an array you want to pass:

Section 39.2: Coercing arrays into parameter list
Suppose you had an array:

And a method that takes two arguments:

You might think you could just pass the array: print_pair(pair) # wrong number of arguments (1 for 2) (ArgumentError)
Since the array is just one argument, not two, so Ruby throws an exception. You could pull out each element individually:

Or you can use the splat operator to save yourself some effort:

Chapter 40: JSON with Ruby
Section 40.1: Using JSON with Ruby
JSON (JavaScript Object Notation) is a lightweight data interchange format. Many web applications use it to send and receive data.
In Ruby you can simply work with JSON.
require 'json', then you can parse a JSON string via the JSON.parse()At first you have to  command.

What happens here, is that the parser generates a Ruby Hash out of the JSON.
The other way around, generating JSON out of a Ruby hash is as simple as parsing. The method of choice is

Section 40.2: Using Symbols
You can use JSON together with Ruby symbols. With the option symbolize_names for the parser, the keys in the resulting hash will be symbols instead of strings.

Chapter 41: Pure RSpec JSON API testing
Section 41.1: Testing Serializer object and introducing it to Controller
Let say you want to build your API to comply jsonapi.org specification and the result should look like:

Test for Serializer object may look like this:


Serializer object may look like this:

When we run our "serializers" specs everything passes.
type: "articles"That's pretty boring. Let's introduce a typo to our Article Serializer: Instead of  let's return type:
"events" and rerun our tests.

Once you've run the test it's pretty easy to spot the error.
Once you fix the error (correct the type to be article) you can introduce it to Controller like this:

This example is based on article: http://www.eq8.eu/blogs/30-pure-rspec-json-api-testing

Chapter 42: Gem Creation/Management
Section 42.1: Gemspec Files
<gem name>.gemspecEach gem has a file in the format of  which contains metadata about the gem and it's files. The format of a gemspec is as follows:

The fields required by RubyGems are:
author = string or authors = arrayEither 
Use author = if there is only one author, and authors = when there are multiple. For authors= use an array which lists the authors names.

Dirlib/ directory, then you can use files = Dir["/lib/"Here array is a list of all the files in the gem. This can also be used with the [] function, for example if all your files are in the /].

Here string is just the name of your gem. Rubygems recommends a few rules you should follow when naming your gem.
1. Use underscores, NO SPACES
2. Use only lowercase letters
example-extension3. Use hypens for gem extension (e.g. if your gem is named example for an extension you would name it ) so that when then extension is required it can be required as require "example/extension".
RubyGems also adds "If you publish a gem on rubygems.org it may be removed if the name is objectionable, violates intellectual property or the contents of the gem meet these criteria. You can report such a gem on the RubyGems Support site."

I don't know

I don't know

String is a summery of the gems purpose and anything that you would like to share about the gem.

The current version number of the gem.
The recommended fields are:

An email address that will be associated with the gem.

The website where the gem lives.
Either license= or licenses=
I don't know
Section 42.2: Building A Gem
Once you have created your gem to publish it you have to follow a few steps:
gem build <gem name>.gemspec1. Build your gem with  (the gemspec file must exist)
2. Create a RubyGems account if you do not already have one here
3. Check to make sure that no gems exist that share your gems name
gem publish <gem name>.<gem version number>.gem4. Publish your gem with 
  Section 42.3: Dependencies
To list the dependency tree:

To list which gems depend on a specific gem (bundler for example)

Chapter 43: rbenv
Section 43.1: Uninstalling a Ruby
There are two ways to uninstall a particular version of Ruby. The easiest is to simply remove the directory from
rbenv/versions~/.:

Alternatively, you can use the uninstall command, which does exactly the same thing:

If this version happens to be in use somewhere, you'll need to update your global or local version. To revert to the version that's first in your path (usually the default provided by your system) use:

Section 43.2: Install and manage versions of Ruby with rbenv
The easiest way to install and manage various versions of Ruby with rbenv is to use the ruby-build plugin.
First clone the rbenv repository to your home directory:

Then clone the ruby-build plugin:
bash_profile or .zshrc $ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build Ensure that rbenv is initialized in your shell session, by adding this to your .:

(This essentially first checks if rbenv is available, and initializes it).
You will probably have to restart your shell session - or simply open a new Terminal window.
Note: If you're running on OSX, you will also need to install the Mac OS Command Line Tools with:

You can also install rbenv using Homebrew instead of building from the source:

Then follow the instructions given by:

Install a new version of Ruby:
List the versions available with:

Choose a version and install it with:

Mark the installed version as the global version - i.e. the one that your system uses by default:

Check what your global version is with:

You can specify a local project version with:

Footnotes:
[1]: Understanding PATH

Chapter 44: Gem Usage
Section 44.1: Installing ruby gems
This guide assumes you already have Ruby installed. If you're using Ruby < 1.9 you'll have to manually install RubyGems as it won't be included natively.
To install a ruby gem, enter the command:

If you are working on a project with a list of gem dependencies, then these will be listed in a file named Gemfile. To install a new gem in the project, add the following line of code in the Gemfile:

This Gemfile is used by the Bundler gem to install dependencies your project requires, this does however mean that you'll have to install Bundler first by running (if you haven't already):

Save the file, and then run the command: bundle install
Specifying versions
The version number can be specified on the command live, with the -v flag, such as:

When specifying version numbers in a Gemfile, you have several options available:
gem 'gemname'gem 'gemname', '3.14'gem 'gemname', '>=3.14'No version specified () -- Will install the latest version which is compatible with other gems in the Gemfile.
Exact version specified () -- Will only attempt to install version 3.14 (and fail if this is incompatible with other gems in the Gemfile).
Optimistic minimum version number () -- Will only attempt to install the latest
version which is compatible with other gems in the Gemfile, and fails if no version greater than or equal to
3.14 is compatible. The operator > can also be used.
gem 'gemname', '~>3.14'	 Pessimistic minimum version number (	) -- This is functionally equivalent to using
gem 'gemname', '>=3.14', '<4'. In other words, only the number after the final period is permitted to
increase.
As a best practice: You might want to use one of the Ruby version management libraries like rbenv or rvm.
Through these libraries, you can install different versions of Ruby runtimes and gems accordingly. So, when working in a project, this will be especially handy because most of the projects are coded against a known Ruby version. Section 44.2: Gem installation from github/filesystem
You can install a gem from github or filesystem. If the gem has been checked out from git or somehow already on the file system, you could install it using

Installing gem from github. Download the sources from github

Build the gem

Section 44.3: Checking if a required gem is installed from within code
To check if a required gem is installed, from within your code, you can use the following (using nokogiri as an example):

However, this can be further extended to a function that can be used in setting up functionality within your code.

Now you can check if the required gem is installed, and print an error message.

or

Section 44.4: Using a Gemfile and Bundler
A Gemfile is the standard way to organize dependencies in your application. A basic Gemfile will look like this:

You can specify the versions of the gem you want as follows:

You can also pull gems straight from a git repo:
# pull a gem from github gem 'sinatra', git: 'https://github.com/sinatra/sinatra.git'
# you can specify a sha gem 'sinatra', git: 'https://github.com/sinatra/sinatra.git', sha:
'30d4fb468fd1d6373f82127d845b153f17b54c51'
# you can also specify a branch, though this is often unsafe
 gem 'sinatra', git: 'https://github.com/sinatra/sinatra.git', branch: 'master' You can also group gems depending on what they are used for. For example:

You can specify which platform certain gems should run on if you application needs to be able to run on multiple platforms. For example:

To install all the gems from a Gemfile do:

Section 44.5: Bundler/inline (bundler v1.10 and later)
Sometimes you need to make a script for someone but you are not sure what he has on his machine. Is there everything that your script needs? Not to worry. Bundler has a great function called in line.
It provides a gemfile method and before the script is run it downloads and requires all the necessary gems. A little example:


Chapter 45: Singleton Class
Section 45.1: Introduction
Ruby has three types of objects:
Classes and modules which are instances of class Class or class Module. Instances of classes. Singleton Classes.
Each object has a class which contains its methods:

Objects themselves can't contain methods, only their class can. But with singleton classes, it is possible to add methods to any object including other singleton classes.

foo is defined on singleton class of object. Other Example instances can not reply to foo.
Ruby creates singleton classes on demand. Accessing them or adding methods to them forces Ruby to create them. Section 45.2: Inheritance of Singleton Class
Subclassing also Subclasses Singleton Class

Extending or Including a Module does not Extend Singleton Class


Section 45.3: Singleton classes
All objects are instances of a class. However, that is not the whole truth. In Ruby, every object also has a somewhat hidden singleton class.
This is what allows methods to be defined on individual objects. The singleton class sits between the object itself and its actual class, so all methods defined on it are available for that object, and that object only.

The example above could have been written using define_singleton_method:

Which is the same as defining the method on object's singleton_class:

Before the existence of singleton_class as part of Ruby's core API, singleton classes were known as metaclasses and could be accessed via the following idiom:

Section 45.4: Message Propagation with Singleton Class
Instances never contain a method they only carry data. However we can define a singleton class for any object including an instance of a class.
When a message is passed to an object (method is called) Ruby first checks if a singleton class is defined for that object and if it can reply to that message otherwise Ruby checks instance's class' ancestors chain and walks up on that.

Section 45.5: Reopening (monkey patching) Singleton Classes




Every object has a singleton class which you can access

Section 45.6: Accessing Singleton Class
There are two ways to get singleton class of an object


Section 45.7: Accessing Instance/Class Variables in Singleton Classes
Singleton classes share their instance/class variables with their object.



Blocks close around their instance/class variables target. Accessing instance or class variables using a block in class_eval or instance_eval isn't possible. Passing a string to class_eval or using class_variable_get works around the problem.

Chapter 46: Queue
Section 46.1: Multiple Workers One Sink
We want to gather data created by multiple Workers.
First we create a Queue:

Then 16 workers all generating a random number and pushing it into sink:

And to get the data, convert a Queue to an Array:

Section 46.2: Converting a Queue into an Array

Or a one liner:

Section 46.3: One Source Multiple Workers
We want to process data in parallel.
Let's populate source with some data:

Then create some workers to process data:


Section 46.4: One Source - Pipeline of Work - One Sink
We want to process data in parallel and push it down the line to be processed by other workers.
Since Workers both consume and produce data we have to create two queues:

First wave of workers read an item from first_input_source, process the item, and write results in

Second wave of workers uses first_output_sink as its input source and reads, process then writes to another output sink:

Now second_output_sink is the sink, let's convert it to an array:

Section 46.5: Pushing Data into a Queue - #push

Section 46.6: Pulling Data from a Queue - #pop

Section 46.7: Synchronization - After a Point in Time

Section 46.8: Merging Two Queues
 To avoid infinitely blocking, reading from queues shouldn't happen on the thread merge is happening on. To avoid synchronization or infinitely waiting for one of queues while other has data, reading from queues shouldn't happen on same thread.
Let's start by defining and populating two queues:

We should create another queue and push data from other threads into it:

If you know you can completely consume both queues (consumption speed is higher than production, you won't run out of RAM) there is a simpler approach:



Chapter 47: Destructuring
Section 47.1: Overview
Most of the magic of destructuring uses the splat (*) operator.
	Example	Result / comment
a, b = [0,1]a=0, b=1a, *rest = [0,1,2,3]a=0, rest=[1,2,3]a, * = [0,1,2,3]a=.first0   Equivalent to 
*, z = [0,1,2,3]z=3   Equivalent to .lastSection 47.2: Destructuring Block Arguments


Chapter 48: Struct
Section 48.1: Creating new structures for data
Struct defines new classes with the specified attributes and accessor methods.

You can then instantiate objects and use them:

Section 48.2: Customizing a structure class

Section 48.3: Attribute lookup
Attributes can be accessed strings and symbols as keys. Numerical indexes also work.

Chapter 49: Metaprogramming
Metaprogramming can be described in two ways:
"Computer programs that write or manipulate other programs (or themselves) as their data, or that do part of the work at compile time that would otherwise be done at runtime".
More simply put: Metaprogramming is writing code that writes code during runtime to make your life easier. Section 49.1: Implementing "with" using instance evaluation
Many languages feature a with statement that allows programmers to omit the receiver of method calls.
with can be easily emulated in Ruby using instance_eval:

The with method can be used to seamlessly execute methods on objects:

Section 49.2: send() method
send() is used to pass message to object. sendsendsend() is an instance method of the Object class. The first argument in () is the message that you're sending to the object - that is, the name of a method. It could be string or symbol but symbols are preferred. Then arguments those need to pass in method, those will be the remaining arguments in ().

Here is the more descriptive example


send() itself is not recommended anymore. Use __send__Note: () which has the power to call private methods, or
public_send(recommended) ()
Section 49.3: Defining methods dynamically
With Ruby you can modify the structure of the program in execution time. One way to do it, is by defining methods dynamically using the method method_missing.
Let's say that we want to be able to test if a number is greater than other number with the syntax

One important thing to remember when using method_missing that one should also override respond_to? method:

600.is_greater_than_123Forgetting to do so leads to a inconsistent situation, when you can successfully call , but
600.respond_to(:is_greater_than_123                                          ) returns false.
                     Section 49.4: Defining methods on instances
In ruby you can add methods to existing instances of any class. This allows you to add behavior to and instance of a class without changing the behavior of the rest of the instances of that class.


Chapter 50: Dynamic Evaluation
Parameter	Details
"source" Any Ruby source code binding	An instance of Binding class proc	An instance of Proc class
Section 50.1: Instance evaluation
The instance_eval method is available on all objects. It evaluates code in the context of the receiver:

instance_eval sets self to object for the duration of the code block:

The receiver is also passed to the block as its only argument:

The instance_exec method differs in this regard: it passes its arguments to the block instead.

Section 50.2: Evaluating a String

Section 50.3: Evaluating Inside a Binding
Kernel#binding and evaluate string inside a binding via Binding#evalRuby keeps track of local variables and self variable via an object called binding. We can get binding of a scope with calling .



Section 50.4: Dynamically Creating Methods from Strings
Ruby offers define_method as a private method on modules and classes for defining new instance methods. However, the 'body' of the method must be a Proc or another existing method.
One way to create a method from raw string data is to use eval to create a Proc from the code:



Chapter 51: instance_eval
Parameter	Details
string	Contains the Ruby source code to be evaluated. filename File name to use for error reporting. lineno	Line number to use for error reporting. block	The block of code to be evaluated. obj	The receiver is passed to the block as its only argument.
Section 51.1: Instance evaluation
The instance_eval method is available on all objects. It evaluates code in the context of the receiver:

instance_eval sets self to object for the duration of the code block:

The receiver is also passed to the block as its only argument:

The instance_exec method differs in this regard: it passes its arguments to the block instead.

Section 51.2: Implementing with
Many languages feature a with statement that allows programmers to omit the receiver of method calls.
with can be easily emulated in Ruby using instance_eval:

The with method can be used to seamlessly execute methods on objects:



Chapter 52: Message Passing
Section 52.1: Introduction
In Object Oriented Design, objects receive messages and reply to them. In Ruby, sending a message is calling a method and result of that method is the reply.
In Ruby message passing is dynamic. When a message arrives rather than knowing exactly how to reply to it Ruby uses a predefined set of rules to find a method that can reply to it. We can use these rules to interrupt and reply to the message, send it to another object or modify it among other actions.
Each time an object receives a message Ruby checks:
   1. If this object has a singleton class and it can reply to this message.
   2. Looks up this object's class then class' ancestors chain.
   3. One by one checks if a method is available on this ancestor and moves up the chain. Section 52.2: Message Passing Through Inheritance Chain

SubExample#subexample_methodTo find a suitable method for  Ruby first looks at ancestors chain of SubExample
SubExample.ancestors # => [SubExample, Example, Object, Kernel, BasicObject]
Example#subexample_methodIt starts from SubExample. If we send subexample_method message Ruby chooses the one available one SubExample and ignores .

After SubExample it checks Example. If we send example_method Ruby checks if SubExample can reply to it or not and since it can't Ruby goes up the chain and looks into Example.

After Ruby checks all defined methods then it runs method_missing to see if it can reply or not. If we send missing_subexample_method Ruby won't be able to find a defined method on SubExample so it moves up to Example. It can't find a defined method on Example or any other class higher in chain either. Ruby starts over and runs method_missing. method_missing of SubExample can reply to missing_subexample_method.

However if a method is defined Ruby uses defined version even if it is higher in the chain. For example if we send not_missed_method even though method_missing of SubExample can reply to it Ruby walks up on SubExample because it doesn't have a defined method with that name and looks into Example which has one.

Section 52.3: Message Passing Through Module Composition
Ruby moves up on ancestors chain of an object. This chain can contain both modules and classes. Same rules about moving up the chain apply to modules as well.


Section 52.4: Interrupting Messages
There are two ways to interrupt messages.
Use method_missing to interrupt any non defined message.
Define a method in middle of a chain to intercept the message
After interrupting messages, it is possible to:
Reply to them.
Send them somewhere else.
Modify the message or its result.

Intercepting message and modifying it:

Now let's imagine our data is "title:body" and we have to split them before calling Example. We can define


Intercepting message and sending it to another object:


Chapter 53: Keyword Arguments
Section 53.1: Using arbitrary keyword arguments with splat operator
You can define a method to accept an arbitrary number of keyword arguments using the double splat (**) operator:

The arguments are captured in a Hash. You can manipulate the Hash, for example to extract the desired arguments.

Using a the splat operator with keyword arguments will prevent keyword argument validation, the method will never raise an ArgumentError in case of unknown keyword.
As for the standard splat operator, you can re-convert a Hash into keyword arguments for a method:

This is generally used when you need to manipulate incoming arguments, and pass them to an underlying method:


Section 53.2: Using keyword arguments
You define a keyword argument in a method by specifying the name in the method definition:

You can define multiple keyword arguments, the definition order is irrelevant:

Keyword arguments can be mixed with positional arguments:

Mixing keyword argument with positional argument was a very common approach before Ruby 2.1, because it was not possible to define required keyword arguments.
Moreover, in Ruby < 2.0, it was very common to add an Hash at the end of a method definition to use for optional arguments. The syntax is very similar to keyword arguments, to the point where optional arguments via Hash are compatible with Ruby 2 keyword arguments.


Note that trying to pass a not-defined keyword argument will result in an error:

Section 53.3: Required keyword arguments
Version ≥ 2.1
Required keyword arguments were introduced in Ruby 2.1, as an improvement to keyword arguments.
To define a keyword argument as required, simply declare the argument without a default value.

You can also mix required and non-required keyword arguments:

Chapter 54: Truthiness
Section 54.1: All objects may be converted to booleans in Ruby
Use the double negation syntax to check for truthiness of values. All values correspond to a boolean, irrespective of their type.


Section 54.2: Truthiness of a value can be used in if-else constructs
You do not need to use double negation in if-else statements.

The above code prints 'hey!' on the screen.
Chapter 55: Implicit Receivers and Understanding Self
Section 55.1: There is always an implicit receiver
In Ruby, there is always an implicit receiver for all method calls. The language keeps a reference to the current implicit receiver stored in the variable self. Certain language keywords like class and module will change what self points to. Understanding these behaviors is very helpful in mastering the language.
For example, when you first open irb

In this case the main object is the implicit receiver (see http://stackoverflow.com/a/917842/417872 for more about main).
You can define methods on the implicit receiver using the def keyword. For example:

This has defined the method foo on the instance of main object running in your repl.
Note that local variables are looked up before method names, so that if you define a local variable with the same name, its reference will supersede the method reference. Continuing from the previous example:

The method method can still find the foo method because it doesn't check for local variables, while the normal reference foo does. Section 55.2: Keywords change the implicit receiver
When you define a class or module, the implicit receiver becomes a reference to the class itself. For example:

Executing the above code will print:

Section 55.3: When to use self?
Most Ruby code utilizes the implicit receiver, so programmers who are new to Ruby are often confused about when to use self. The practical answer is that self is used in two major ways:
1. To change the receiver.
Ordinarily the behavior of def inside a class or module is to create instance methods. Self can be used to define methods on the class instead.

2. To disambiguate the receiver
When local variables may have the same name as a method an explicit receiver may be required to disambiguate.
Examples:

The other common case requiring disambiguation involves methods that end in the equals sign. For instance:


Chapter 56: Introspection
Section 56.1: View an object's methods
Inspecting an Object
You can find the public methods an object can respond to using either the methods or public_methods methods, which return an array of symbols:
class Foo   def bar; 42; end end f = Foo.new def f.yay; 17; end p f.methods.sort
#=> [:!, :!=, :!~, :<=>, :==, :===, :=~, :__id__, :__send__, :bar, :class, :clone,
#=>  :define_singleton_method, :display, :dup, :enum_for, :eql?, :equal?, :extend,
#=>  :freeze, :frozen?, :hash, :inspect, :instance_eval, :instance_exec,
#=>  :instance_of?, :instance_variable_defined?, :instance_variable_get,
#=>  :instance_variable_set, :instance_variables, :is_a?, :itself, :kind_of?,
#=>  :method, :methods, :nil?, :object_id, :private_methods, :protected_methods,
#=>  :public_method, :public_methods, :public_send, :remove_instance_variable,
#=>  :respond_to?, :send, :singleton_class, :singleton_method, :singleton_methods,
#=>  :taint, :tainted?, :tap, :to_enum, :to_s, :trust, :untaint, :untrust,
#=>  :untrusted?, :yay]
For a more targeted list, you can remove methods common to all objects, e.g.

Alternatively, you can pass false to methods or public_methods:

You can find the private and protected methods of an object using private_methods and protected_methods:
p f.private_methods.sort
#=> [:Array, :Complex, :DelegateClass, :Float, :Hash, :Integer, :Rational, :String,
#=>  :__callee__, :__dir__, :__method__, :`, :abort, :at_exit, :autoload, :autoload?,
#=>  :binding, :block_given?, :caller, :caller_locations, :catch,
#=>  :default_src_encoding, :eval, :exec, :exit, :exit!, :fail, :fork, :format, :gem,
#=>  :gem_original_require, :gets, :global_variables, :initialize, :initialize_clone,
#=>  :initialize_copy, :initialize_dup, :irb_binding, :iterator?, :lambda, :load,
#=>  :local_variables, :loop, :method_missing, :open, :p, :print, :printf, :proc,
#=>  :putc, :puts, :raise, :rand, :readline, :readlines, :require, :require_relative,
#=>  :respond_to_missing?, :select, :set_trace_func, :singleton_method_added,
#=>  :singleton_method_removed, :singleton_method_undefined, :sleep, :spawn,
#=>  :sprintf, :srand, :syscall, :system, :test, :throw, :trace_var, :trap, #=>  :untrace_var, :warn]
p f.protected_methods
#=> []
As with methods and public_methods, you can pass false to private_methods and protected_methods to trim away inherited methods.
Inspecting a Class or Module
In addition to methods, public_methods, protected_methods, and private_methods, classes and modules expose instance_methods, public_instance_methods, protected_instance_methods, and private_instance_methods to determine the methods exposed for objects that inherit from the class or module. As above, you can pass false to these methods to exclude inherited methods:
p Foo.instance_methods.sort
#=> [:!, :!=, :!~, :<=>, :==, :===, :=~, :__id__, :__send__, :bar, :class,
#=>  :clone, :define_singleton_method, :display, :dup, :enum_for, :eql?,
#=>  :equal?, :extend, :freeze, :frozen?, :hash, :inspect, :instance_eval,
#=>  :instance_exec, :instance_of?, :instance_variable_defined?,
#=>  :instance_variable_get, :instance_variable_set, :instance_variables,
#=>  :is_a?, :itself, :kind_of?, :method, :methods, :nil?, :object_id,
#=>  :private_methods, :protected_methods, :public_method, :public_methods,
#=>  :public_send, :remove_instance_variable, :respond_to?, :send,
#=>  :singleton_class, :singleton_method, :singleton_methods, :taint, #=>  :tainted?, :tap, :to_enum, :to_s, :trust, :untaint, :untrust, :untrusted?]
p Foo.instance_methods(false) #=> [:bar]
Finally, if you forget the names of most of these in the future, you can find all of these methods using methods:

Section 56.2: View an object's Instance Variables
It is possible to query an object about its instance variables using instance_variables, instance_variable_defined?, and instance_variable_get, and modify them using instance_variable_set and remove_instance_variable:

The names of instance variables include the @ symbol. You will get an error if you omit it:

Section 56.3: View Global and Local Variables
The Kernel exposes methods for getting the list of global_variables and local_variables:

Unlike instance variables there are no methods specifically for getting, setting, or removing global or local variables.
Looking for such functionality is usually a sign that your code should be rewritten to use a Hash to store the values. However, if you must modify global or local variables by name, you can use eval with a string:

By default, eval will evaluate your variables in the current scope. To evaluate local variables in a different scope, you must capture the binding where the local variables exist.

In the above, test_1 did not pass a binding to local_variable_get, and so the eval was executed within the context of that method, where a local variable named foo was set to :inside. Section 56.4: View Class Variables
Classes and modules have the same methods for introspecting instance variables as any other object. Class and modules also have similar methods for querying the class variables (@@these_things):

Similar to instance variables, the name of class variables must begin with @@, or you will get an error:
p Bar.class_variable_defined?( :instances )
#=> NameError: `instances' is not allowed as a class variable name

Chapter 57: Refinements
Section 57.1: Monkey patching with limited scope
Monkey patching's main issue is that it pollutes the global scope. Your code working is at the mercy of all the modules you use not stepping on each others toes. The Ruby solution to this is refinements, which are basically monkey patches in a limited scope.

Section 57.2: Dual-purpose modules (refinements or global patches)
It's a good practice to scope patches using Refinements, but sometimes it's nice to load it globally (for example in development, or testing).
Say for example you want to start a console, require your library, and then have the patched methods available in the global scope. You couldn't do this with refinements because using needs to be called in a class/module definition. But it's possible to write the code in such a way that it's dual purpose:


Section 57.3: Dynamic refinements
Refinements have special limitations.
send :refinerefine can only be used in a module scope, but can be programmed using .
using is more limited. It can only be called in a class/module definition. Still, it can accept a variable pointing to a module, and can be invoked in a loop.
An example showing these concepts:

Since using is so static, there can be issued with load order if the refinement files are not loaded first. A way to address this is to wrap the patched class/module definition in a proc. For example:


Calling the proc creates the patched class Foo::Bar. This can be delayed until after all the code has loaded.

Chapter 58: Catching Exceptions with Begin / Rescue
Section 58.1: A Basic Error Handling Block
Let's make a function to divide two numbers, that's very trusting about its input:

This will work fine for a lot of inputs:

But not all

begin... endWe can rewrite the function by wrapping the risky division operation in a  block to check for errors, and use a rescue clause to output a message and return nil if there is a problem.

Section 58.2: Saving the Error
You can save the error if you want to use it in the rescue clause

There was a ZeroDivisionError (divided by 0)        from (irb):10:in `/'        from (irb):10        from /Users/username/.rbenv/versions/2.3.1/bin/irb:11:in `<main>'
> divide(10, 'a')
There was a TypeError (String can't be coerced into Fixnum)
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/workspace.rb:87:in `eval'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/workspace.rb:87:in `evaluate'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/context.rb:380:in `evaluate'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:489:in `block (2 levels) in eval_input'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:623:in `signal_status'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:486:in `block in eval_input' /Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/ruby-lex.rb:246:in `block (2 levels) in each_top_level_statement'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/ruby-lex.rb:232:in `loop' /Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/ruby-lex.rb:232:in `block in each_top_level_statement' /Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/ruby-lex.rb:231:in `catch'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb/ruby-lex.rb:231:in
`each_top_level_statement'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:485:in `eval_input'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:395:in `block in start'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:394:in `catch'
/Users/username/.rbenv/versions/2.3.1/lib/ruby/2.3.0/irb.rb:394:in `start'
/Users/username/.rbenv/versions/2.3.1/bin/irb:11:in `<main>'
Section 58.3: Checking for Dierent Errors
If you want to do different things based on the kind of error, use multiple rescue clauses, each with a different error type as an argument.

If you want to save the error for use in the rescue block:

Use a rescue clause with no argument to catch errors of a type not specified in another rescue clause.


In this case, trying to divide nil by 2 is not a ZeroDivisionError or a TypeError, so it handled by the default rescue clause, which prints out a message to let us know that it was a NoMethodError. Section 58.4: Retrying
In a rescue clause, you can use retry to run the begin clause again, presumably after changing the circumstance that caused the error.

If we pass parameters that we know will cause a TypeError, the begin clause is executed (flagged here by printing out "About to divide") and the error is caught as before, and nil is returned:

But if we pass parameters that will cause a ZeroDivisionError, the begin clause is executed, the error is caught, the divisor changed from 0 to 1, and then retry causes the begin block to be run again (from the top), now with a different y. The second time around there is no error and the function returns a value.

Section 58.5: Checking Whether No Error Was Raised
You can use an else clause for code that will be run if no error is raised.

The else clause does not run if there is an error that transfers control to one of the rescue clauses:

But if no error is raised, the else clause executes:

Note that the else clause will not be executed if you return from the begin clause

Section 58.6: Code That Should Always Run
Use an ensure clause if there is code you always want to execute.


The ensure clause will be executed when there is an error:

And when there is no error:

The ensure clause is useful when you want to make sure, for instance, that files are closed.
Note that, unlike the else clause, the ensure clause is executed before the begin or rescue clause returns a value. If the ensure clause has a return that will override the return value of any other clause!
Chapter 59: Command Line Apps
Section 59.1: How to write a command line tool to get the weather by zip code
This will be a relatively comprehensive tutorial of how to write a command line tool to print the weather from the zip code provided to the command line tool. The first step is to write the program in ruby to do this action. Let's
weather(zip_codestart by writing a method ) (This method requires the yahoo_weatherman gem. If you do not have this gem you can install it by typing gem install yahoo_weatherman from the command line)

We now have a very basic method that gives the weather when a zip code is provided to it. Now we need to make this into a command line tool. Very quickly let's go over how a command line tool is called from the shell and the associated variables. When a tool is called like this tool argument other_argument, in ruby there is a variable ARGV
'argument', 'other_argument'which is an array equal to []. Now let us implement this in our application

weather.rbGood! Now we have a command line application that can be run. Notice the she-bang line at the beginning of the file (#!/usr/bin/ruby). This allows the file to become an executable. We can save this file as weather. (Note: Do not save this as , there is no need for the file extension and the she-bang tells whatever you need to tell that this is a ruby file). Now we can run these commands in the shell (do not type in the $).

usr/bin/localAfter testing that this works, we can now sym-link this to the // by running this command

Now weather can be called on the command line no matter the directory you are in.
Chapter 60: IRB
	Option	Details
-f	Suppress read of ~/.irbrc
-m	Bc mode (load mathn, fraction or matrix are available)
-d	Set $DEBUG to true (same as `ruby -d')
-r load-module	Same as `ruby -r'
-I path	Specify $LOAD_PATH directory
ruby -U	Same as -U
ruby -E enc	Same as -E
ruby -w	Same as -w
ruby -W[level=2]	Same as -W
--inspectUse `inspect' for output (default except for bc mode)--noinspectDon't use inspect for output--readlineUse Readline extension module--noreadlineDon't use Readline extension moduledefault',simple', xmp' and--prompt prompt-mode Switch prompt mode. Pre-defined prompt modes are inf-ruby'
--inf-ruby-modeUse prompt appropriate for inf-ruby-mode on emacs. Suppresses --readline.--simple-promptSimple prompt mode--nopromptNo prompt mode--tracerDisplay trace for each execution of commands.--back-trace-limit nDisplay backtrace top n and tail n. The default value is 16.--irb_debug nSet internal debug level to n (not for popular use)-v, --versionPrint the version of irbIRB means "Interactive Ruby Shell". Basically it lets you execute ruby commands in real time (like the normal shell does). IRB is an indispensable tool when dealing with Ruby API. Works as classical rb script. Use it for short and easy commands. One of the nice IRB functions is that when you press tab while typing a method it will give you an advice to what you can use (This is not an IntelliSense) Section 60.1: Starting an IRB session inside a Ruby script
As of Ruby 2.4.0, you can start an interactive IRB session inside any Ruby script using these lines:

This will start an IBR REPL where you will have the expected value for self and you will be able to access all local variables and instance variables that are in scope. Type Ctrl+D or quit in order to resume your Ruby program.
This can be very useful for debugging. Section 60.2: Basic Usage
IRB means "Interactive Ruby Shell", letting us execute ruby expressions from the standart input.
To start, type irb into your shell. You can write anything in Ruby, from simple expressions:


to complex cases like methods:


Chapter 61: ERB
ERB stands for Embedded Ruby, and is used to insert Ruby variables inside templates, e.g. HTML and YAML. ERB is a Ruby class that accepts text, and evaluates and replaces Ruby code surrounded by ERB markup.
Section 61.1: Parsing ERB

Chapter 62: Generate a random number
How to generate a random number in Ruby.
Section 62.1: 6 Sided die

Section 62.2: Generate a random number from a range (inclusive)


Chapter 63: Getting started with Hanami
My mission here is to contribute with the community to help new people who wants to learn about this amazing framework - Hanami.
But how it is going to work?
Short and easygoing tutorials showing with examples about Hanami and following the next tutorials we will see how to test our application and build a simple REST API.
Let's start!
Section 63.1: About Hanami
Besides Hanami be a lightweight and fast framework one of the points that most call attention is the Clean
Architecture concept where shows to us that the framework is not our application as Robert Martin said before.
Hanami arquitecture design offer to us the use of Container, in each Container we have our application independently of the framework. This means that we can grab our code and put it into a Rails framework for example.
Hanami is a MVC Framework?
The MVC's frameworks idea is to build one structure following the Model -> Controller -> View. Hanami follows the Model | Controller -> View -> Template. The result is an application more uncopled, following SOLID principles, and much cleaner.
- Important links.
Hanami http://hanamirb.org/
Robert Martin - Clean Arquitecture https://www.youtube.com/watch?v=WpkDN78P884
Clean Arquitecture https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html
SOLID Principles http://practicingruby.com/articles/solid-design-principles
Section 63.2: How to install Hanami?

Open up a command line or terminal. To generate a new hanami application, use hanami new followed by the name of your app and the rspec test param.

Obs. By default Hanami sets Minitest as testing framework.
This will create a hanami application called myapp in a myapp directory and install the gem dependencies that are already mentioned in Gemfile using bundle install.
To switch to this directory, use the cd command, which stands for change directory.

The myapp directory has a number of auto-generated files and folders that make up the structure of a Hanami application. Following is a list of files and folders that are created by default:
Gemfile defines our Rubygems dependencies (using Bundler).
Rakefile describes our Rake tasks.
apps contains one or more web applications compatible with Rack. Here we can find the first generated Hanami application called Web. It's the place where we find our controllers, views, routes and templates. config contains configuration files. config.ru is for Rack servers. db contains our database schema and migrations. lib contains our business logic and domain model, including entities and repositories. public will contain compiled static assets. spec contains our tests.
Important links.
Hanami gem https://github.com/hanami/hanami
Hanami official Getting Started http://hanamirb.org/guides/getting-started/
Section 63.3: How to start the server?



Chapter 64: OptionParser
OptionParser can be used for parsing command line options from ARGV.
Section 64.1: Mandatory and optional command line options
It's relatively easy to parse the command line by hand if you aren't looking for anything too complex:

But when your options start to get more complicated, you probably will need to use an option parser such as, well, OptionParser:

There's also a non-destructive parse, but it's a lot less useful if you plan on using the remainder of what's in ARGV.
--siteThe OptionParser class doesn't have a way to enforce mandatory arguments (such as  in this case). However you can do you own checking after running parse!:

For a more generic mandatory option handler, see this answer. In case it isn't clear, all options are optional unless you go out of your way to make them mandatory.
Section 64.2: Default values
With OptionsParser, it's really easy to set up default values. Just pre-populate the hash you store the options in:

When you define the parser, it will overwrite the default if a user provide a value:

Section 64.3: Long descriptions
irb Sometimes your description can get rather long. For instance -h lists on argument that reads:
  --context-mode n  Set n[0-3] to method to create Binding Object,                     when new workspace was created
It's not immediately clear how to support this. Most solutions require adjusting to make the indentation of the second and following lines align to the first. Fortunately, the on method supports multiple description lines by adding them as separate arguments:

You can add as many description lines as you like to fully explain the option.
Chapter 65: Operating System or Shell commands
There are many ways to interact with the operating system. From within Ruby you can run shell/system commands or sub-processes.
Section 65.1: Recommended ways to execute shell code in Ruby:
Open3.popen3 or Open3.capture3:
Open3 actually just uses Ruby's spawn command, but gives you a much better API. Open3.popen3
Popen3 runs in a sub-process and returns stdin, stdout, stderr and wait_thr.

or

will output: stdout is: stderr is:fatal: Not a git repository (or any of the parent directories): .git or

will output:
Pinging www.google.com [216.58.223.36] with 32 bytes of data:
Reply from 216.58.223.36: bytes=32 time=16ms TTL=54
Reply from 216.58.223.36: bytes=32 time=10ms TTL=54
Reply from 216.58.223.36: bytes=32 time=21ms TTL=54
Reply from 216.58.223.36: bytes=32 time=29ms TTL=54 Ping statistics for 216.58.223.36:
Packets: Sent = 4, Received = 4, Lost = 0 (0% loss), Approximate round trip times in milli-seconds:
Minimum = 10ms, Maximum = 29ms, Average = 19ms
Open3.capture3:

or

Not recommended though, due to additional overhead and the potential for shell injections.
If the command reads from stdin and you want to feed it some data:
 Open3.capture3('my_funky_command', stdin_data: 'read from stdin')  Run the command with a different working directory, by using chdir:

Section 65.2: Clasic ways to execute shell code in Ruby:
Exec:

or

The System Command:

Will output "hello world" in the command window. or

The system command can return a true if the command was successful or nill when not.

The backticks (`):
echo "hello world" Will output "hello world" in the command window.
You can also catch the result.

IO.popen:


Chapter 66: C Extensions
Section 66.1: Your first extension
C extensions are comprised of two general pieces:
1. The C Code itself.
2. The extension configuration file.
extconf.rbTo get started with your first extension put the following in a file named :

A couple of things to point out:
First, the name hello_c is what the output of your compiled extension is going to be named. It will be what you use in conjunction with require.
extconf.rbruby extconf.rbhello.c and run ruby extconf.rb && makeSecond, the  file can actually be named anything, it's just traditionally what is used to build gems that have native code, the file that is actually going to compile the extension is the Makefile generated when running . The default Makefile that is generated compiles all .c files in the current directory. Put the following in a file named 

A breakdown of the code:
extconf.rbThe name Init_hello_c must match the name defined in your  file, otherwise when dynamically loading the extension, Ruby won't be able to find the symbol to bootstrap your extension.
The call to rb_define_module is creating a Ruby module named HelloC which we're going to namespace our C functions under.
HelloC.worldFinally, the call to rb_define_singleton_method makes a module level method tied directly to the HelloC module which we can invoke from ruby with .
After having compiled the extension with the call to make we can run the code in our C extension.
Fire up a console!


Section 66.2: Working with C Structs
In order to be able to work with C structs as Ruby objects, you need to wrap them with calls to Data_Wrap_Struct and Data_Get_Struct.
Data_Wrap_Struct wraps a C data structure in a Ruby object. It takes a pointer to your data structure, along with a few pointers to callback functions, and returns a VALUE. The Data_Get_Struct macro takes that VALUE and gives you back a pointer to your C data structure.
Here's a simple example:

  rb_define_alloc_func(cStruct, rb_example_struct_alloc);   rb_define_method(cStruct, "initialize", rb_example_struct_init, 1);   rb_define_method(cStruct, "name", rb_example_struct_name, 0); }
extconf.rbAnd the :

After compiling the extension:

Section 66.3: Writing Inline C - RubyInLine
RubyInline is a framework that lets you embed other languages inside your Ruby code. It defines the Module# inline method, which returns a builder object. You pass the builder a string containing code written in a language other than Ruby, and the builder transforms it into something that you can call from Ruby.
When given C or C++ code (the two languages supported in the default RubyInline install), the builder objects writes a small extension to disk, compiles it, and loads it. You don't have to deal with the compilation yourself, but you can see the generated code and compiled extensions in the .ruby_inline subdirectory of your home directory.
Embed C code right in your Ruby program:


C function copy_file now exists as an instance method of Copier:


Chapter 67: Debugging
Section 67.1: Stepping through code with Pry and Byebug
pry-byebugFirst, you need to install  gem. Run this command:

.rbAdd this line at the top of your  file:

Then insert this line wherever you want a breakpoint:

hello.rbA  example:

hello.rbexit-programWhen you run the  file, the program will pause at that line. You can then step through your code with the step command. Type a variable's name to learn its value. Exit the debugger with  or !!!.
Chapter 68: Ruby Version Manager
Section 68.1: How to create gemset
.rvmrcTo create a gemset we need to create a  file.
Syntax:

Example:

.rvmrcThe above line will create a  file in the root directory of the app.
To get the list of available gemsets, use the following command:

Section 68.2: Installing Ruby with RVM
The Ruby Version Manager is a command line tool to simply install and manage different versions of Ruby.

Appendix A: Installation
Section A.1: Installing Ruby macOS
So the good news is that Apple kindly includes a Ruby interpreter. Unfortunately, it tends not to be a recent version:

If you have Homebrew installed, you can get the latest Ruby with:

(It's likely you'll see a more recent version if you try this.)
usr/local/binIn order to pick up the brewed version without using the full path, you'll want to add / to the start of your $PATH environment variable:

bash_profileAdding that line to ~/. ensures that you will get this version after you restart your system:

Homebrew will install gem for installing Gems. It's also possible to build from the source if you need that. Homebrew also includes that option:

Section A.2: Gems
In this example we will use 'nokogiri' as an example gem. 'nokogiri' can later on be replaced by any other gem name.
To work with gems we use a command line tool called gem followed by an option like install or update and then names of the gems we want to install, but that is not all.
Install gems:

But that is not the only thing we need. We can also specify version, source from which to install or search for gems. Lets start with some basic use cases (UC) and you can later on post request for an update.
Listing all the installed gems:

Uninstalling gems:

If we have more version of the nokogiri gem we will be prompted to specify which one we want to uninstall. We will get a list that is ordered and numbered and we just write the number. Updating gems

or if we want to update them all

Comman gem has many more usages and options to be explored. For more please turn to the official documentation. If something is not clear post a request and I will add it. Section A.3: Linux - Compiling from source
`This way you will get the newest ruby but it has its downsides. Doing it like this ruby will not be managed by any application.
!! Remember to chagne the version so it coresponds with your !!
1. you need to download a tarball find a link on an official website (https://www.ruby-lang.org/en/downloads/)
2. Extract the tarball
3. Install

usr/localThis will install ruby into /. If you are not happy with this location you can pass an argument to the
configure --prefix=DIR./ where DIR is the directory you want to install ruby to.
Section A.4: Linux-Installation using a package manager
Probably the easiest choice, but beware, the version is not always the newest one. Just open up terminal and type
(depending on your distribution) in Debian or Ubuntu using apt

in CentOS, openSUSE or Fedora

You can use the -y option so you are not prompted to agree with the installation but in my opinion it is a good practice to always check what is the package manager trying to install.
Section A.5: Windows - Installation using installer
Probably the easies way to set up ruby on windows is to go to http://rubyinstaller.org/ and from there donwload an executable that you will install.
You don't have to set almost anything, but there will be one important window. It will have a check box saying Add ruby executable to your PATH. Confirm that it is checked, if not check it or else you won't be able to run ruby and will have to set the PATH variable on your own.
Then just go next until it installs and thats that. Section A.6: Linux - troubleshooting gem install
 gem install nokogiriFirst UC in the example Gems $> can have a problem installing gems because we don't have the permissions for it. This can be sorted out in more then just one way.
First UC solution a:
U can use sudo. This will install the gem for all the users. This method should be frowned upon. This should be used only with the gem you know will be usable by all the users. Usualy in real life you don't want some user having access to sudo.

First UC solution b
--user-install which installs the gems into your users gem folder (usualy at ~/.gemU can use the option )

First UC solution c
U can set GEM_HOME and GEM_PATH wich then will make command gem install install all the gems to a folder which you specify. I can give you an example of that (the usual way)
Now you will need to restart terminal or write to use gem isntall nokogiri and it will install those gems in the folder you specified.
Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
AbdullahChapters 11 and 22Adam SandersonChapter 18AddisonChapter 28AJ GregoryChapter 11Ajedi32Chapter 9alebruckChapter 9alexungerChapters 14 and 31Ali MasudianPourChapter 31AluChapters 40 and 68amingilaniChapter 61Andrea MazzarellaChapter 9AndrewChapter 55angelparrasChapter 17Anthony StauntonChapter 44Arman Jon VillalobosChapter 19ArtOfCodeChapter 3Artur TsudaChapters 15 and 27Arun Kumar MChapter 15Atul KhanduriChapter 19Austin Vern SongerChapters 33, 47 and 66AutomaticoChapter 9br3ntChapters 9, 11, 17, 18, 20, 25 and 26C dot StrifeVIIChapters 19 and 49CalmBitChapter 1Charan Kumar BorraChapter 21Charlie EganChapters 11 and 19ChrisChapter 21Christoph PetschnigChapter 19Christopher OezbekChapter 19coreywardChapter 20DChapters 9 and 17danieroChapters 9 and 17DarKyChapter 17Darpan ChhatravalaChapter 1David GraysonChapters 1, 9, 11, 17, 19 and 60David Ljung MadisonChapter 18davidhu2000Chapters 9, 11 and 25DawnPaladinChapters 1, 9, 34 and 67Dimitry_NChapter 17Divya SharmaChapter 31divyumChapter 19djaszczurowskiChapter 31DoodadChapter 29DorianChapter 37ElenianChapters 17, 25 and 28Eli SadoffChapters 9, 14, 20, 21 and 59engineersmnkyChapter 20Engr. Hasanuzzaman
SumonChapters 6 and 36equivalent8Chapter 41Francesco BoffaChapter 10Francesco Lupo RenziChapters 9 and 17G. Allen Morris IIIChapter 19GaelanChapter 26GeoffroyChapter 45gornChapter 19Hardik Kanjariya ツChapter 68iGbanamChapter 9iltempoChapter 19Inanc GumusChapter 44iturgeonChapter 22JasperChapter 20JewellerChapter 19JoeyBChapters 17 and 25Jon EricsonChapter 28Jon WoodChapter 2JonathanChapter 3jose_castro_arnaudChapter 17joshaidanChapter 9Justin ChadwellChapter 25kamaradclimberChapter 22KathrynChapters 11, 17, 18, 19, 38, 39, 43, 64 and 69Katsuhiko YoshidaChapter 9Kirti ThoratChapter 26kleaverChapter 19knutChapters 1 and 9KoraktorChapter 19KrisChapter 19LahiruChapter 17LomefinChapter 22Lucas CostaChapters 1, 5, 9, 11, 13, 19, 22 and 31Lukas BaliakChapters 9, 19, 20 and 22lwassinkChapter 9LynnChapter 35mahatmanichChapter 18manasouzaChapter 42MarcChapter 20Martin VelezChapters 1, 19, 25 and 29Masa SakanoChapter 9Matheus MoreiraChapters 4, 23, 45, 48, 49, 50 and 51Mauricio JuniorChapter 63max pleanerChapters 29 and 57Maxim FedotovChapters 33 and 60Maxim PontyushenkoChapter 21meagarChapters 2, 9, 11, 17, 19 and 20MegaTomChapters 13, 21, 25, 26, 33, 35, 45 and 56metaChapter 49MhmdChapters 2, 9, 19, 20 and 25Michael GaskillChapter 17Michael KuhinicaChapters 19 and 22
Mike HChapter 9Milo PChapter 29mlabarcaChapter 26moertelChapters 17, 19, 22 and 33mrcasalsChapter 35mrleeChapter 19MrTheWalrusChapter 9mudasobwaChapter 28MZaragozaChapter 19NakilonChapter 2NateSHollandChapter 44NateWChapter 11ndnChapters 14, 16, 17 and 21Neha ChopraChapters 24 and 30neontapirChapter 19New AlexandriaChapter 19Nic HartleyChapter 20Nic NilovChapter 19Nick RozChapters 9, 11, 17, 19, 21, 25 and 28NinigiChapter 4Nuno SilvaChapter 29nusChapters 3, 18, 19, 20, 26, 32, 35 and 45ogirgincChapter 67Old ProChapter 19OwenChapter 15Ozgur AkyaziChapter 21Pablo TorrecillaChapters 9 and 17paradojaChapter 37peterChapter 28philomoryChapter 25photoionizedChapter 66PhrogzChapters 3, 50 and 56pjamChapter 19pjrebschChapter 15PJSCopelandChapter 19Pooyan KhosraviChapters 45, 46, 50 and 52PragashChapter 26Rahul SinghChapters 8 and 34RedithionChapters 7, 12, 14 and 18Richard HamiltonChapters 9, 11 and 14Roan FourieChapter 65Robert ColumbiaChapter 22russtChapter 17Sagar PandyaChapter 9SajithPChapters 21 and 38Saroj SasmalChapter 9Saša ZejnilovićChapters 44 and 69ScudellettiChapter 28Sean RedmondChapter 58ShadoathChapter 9ShelvacuChapter 28SidChapters 11 and 19SidOfcChapter 44
Simon SorianoChapter 49Simone CarlettiChapters 1, 11, 14, 15, 18, 19, 22, 25 and 53snonovChapter 5Sourabh UpadhyayChapter 49spencer.smChapter 25squadetteChapter 9SteveChapters 1 and 17stevendanielsChapters 13, 19, 25 and 58suhao399Chapter 36SuryaChapter 33thesecretmasterChapter 42Tom Harrison JrChapters 3 and 27Tom LordChapters 9, 14, 17, 19 and 44Tot ZamChapter 1Umang RaghuvanshiChapter 54user1213904Chapter 31user1489580Chapter 44user1821961Chapter 62user2367593Chapter 6VasfedChapters 11, 26 and 35VenChapters 17 and 19vgoffChapter 17VidurChapter 43Vishnu Y SChapter 1wirefoxChapters 14 and 19wjordanChapter 11xavdidChapter 57Yonatha AlmeidaChapter 34YuleChapters 17 and 27ZazChapters 18 and 47
You may also like







GoalKicker.com - Ruby(r) Notes for Professionals	1

GoalKicker.com - Ruby(r) Notes for Professionals	1

GoalKicker.com - Ruby(r) Notes for Professionals	1







