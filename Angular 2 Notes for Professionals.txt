

Contents
About	1
Chapter 1: Getting started with Angular 2+	2
Section 1.1: Getting started with Angular 2 with node.js/expressjs backend (http example included)	2
Section 1.2: Install angular2 with angular-cli	7
Section 1.3: Getting started with Angular 2 without angular-cli	10
Section 1.4: Getting through that pesky company proxy	14
Section 1.5: Keeping Visual Studios in sync with NPM and NODE Updates	15
Section 1.6: Let's dive into Angular 4!	16
Chapter 2: Components	20
Section 2.1: A simple component	20
Section 2.2: Templates & Styles	20
Section 2.3: Testing a Component	21
Section 2.4: Nesting components	22
Chapter 3: Component interactions	24
Section 3.1: Pass data from parent to child with input binding	24
Section 3.2: Parent - Child interaction using @Input & @Output properties	30
Section 3.3: Parent - Child interaction using ViewChild	31
Section 3.4: Bidirectional parent-child interaction through a service	32
Chapter 4: Directives	35
Section 4.1: *ngFor	35
Section 4.2: Attribute directive	36
Section 4.3: Component is a directive with template	36
Section 4.4: Structural directives	36
Section 4.5: Custom directive	36
Section 4.6: Copy to Clipboard directive	36
Section 4.7: Testing a custom directive	38
Chapter 5: Page title	40
Section 5.1: changing the page title	40
Chapter 6: Templates	41
Section 6.1: Angular 2 Templates	41
Chapter 7: Commonly built-in directives and services	42
Section 7.1: Location Class	42
Section 7.2: AsyncPipe	42
Section 7.3: Displaying current Angular 2 version used in your project	43
Section 7.4: Currency Pipe	43
Chapter 8: Directives & components : @Input @Output	44
Section 8.1: Angular 2 @Input and @Output in a nested component	44
Section 8.2: Input example	45
Section 8.3: Angular 2 @Input with asynchronous data	46
Chapter 9: Attribute directives to aect the value of properties on the host node byusing the @HostBinding decorator	48
Section 9.1: @HostBinding	48
Chapter 10: How to Use ngif	49
Section 10.1: To run a function at the start or end of *ngFor loop Using *ngIf	49
Section 10.2: Display a loading message	49
Section 10.3: Show Alert Message on a condition	49
Section 10.4: Use *ngIf with*ngFor	50
Chapter 11: How to use ngfor	51
Section 11.1: *ngFor with pipe	51
Section 11.2: Unordered list example	51
Section 11.3: More complext template example	51
Section 11.4: Tracking current interaction example	51
Section 11.5: Angular 2 aliased exported values	52
Chapter 12: Angular - ForLoop	53
Section 12.1: NgFor - Markup For Loop	53
Section 12.2: *ngFor with component	53
Section 12.3: Angular 2 for-loop	53
Section 12.4: *ngFor X amount of items per row	54
Section 12.5: *ngFor in the Table Rows	54
Chapter 13: Modules	55
Section 13.1: A simple module	55
Section 13.2: Nesting modules	55
Chapter 14: Pipes	57
Section 14.1: Custom Pipes	57
Section 14.2: Built-in Pipes	58
Section 14.3: Chaining Pipes	58
Section 14.4: Debugging With JsonPipe	59
Section 14.5: Dynamic Pipe	59
Section 14.6: Unwrap async values with async pipe	60
Section 14.7: Stateful Pipes	61
Section 14.8: Creating Custom Pipe	62
Section 14.9: Globally Available Custom Pipe	63
Section 14.10: Extending an Existing Pipe	63
Section 14.11: Testing a pipe	63
Chapter 15: OrderBy Pipe	65
Section 15.1: The Pipe	65
Chapter 16: Angular 2 Custom Validations	68
Section 16.1: get/set formBuilder controls parameters	68
Section 16.2: Custom validator examples:	68
Section 16.3: Using validators in the Formbuilder	69
Chapter 17: Routing	70
Section 17.1: ResolveData	70
Section 17.2: Routing with Children	72
Section 17.3: Basic Routing	73
Section 17.4: Child Routes	76
Chapter 18: Routing (3.0.0+)	78
Section 18.1: Controlling Access to or from a Route	78
Section 18.2: Add guard to route configuration	79
Section 18.3: Using Resolvers and Guards	80
Section 18.4: Use Guard in app bootstrap	81
Section 18.5: Bootstrapping	81
Section 18.6: Configuring router-outlet	82
Section 18.7: Changing routes (using templates & directives)	82
Section 18.8: Setting the Routes	83
Chapter 19: Dynamically add components using ViewContainerRef.createComponent	85
Section 19.1: A wrapper component that adds dynamic components declaratively	85
Section 19.2: Dynamically add component on specific event(click)	86
Section 19.3: Rendered dynamically created component array on template HTML in Angular 2	87
Chapter 20: Installing 3rd party plugins with angular-cli@1.0.0-beta.10	91
Section 20.1: Add 3rd party library that does not have typings	91
Section 20.2: Adding jquery library in angular-cli project	91
Chapter 21: Lifecycle Hooks	94
Section 21.1: OnChanges	94
Section 21.2: OnInit	94
Section 21.3: OnDestroy	94
Section 21.4: AfterContentInit	95
Section 21.5: AfterContentChecked	95
Section 21.6: AfterViewInit	95
Section 21.7: AfterViewChecked	96
Section 21.8: DoCheck	96
Chapter 22: Angular RXJS Subjects and Observables with API requests	98
Section 22.1: Wait for multiple requests	98
Section 22.2: Basic request	98
Section 22.3: Encapsulating API requests	98
Chapter 23: Services and Dependency Injection	100
Section 23.1: Example service	100
Section 23.2: Example with Promise.resolve	101
Section 23.3: Testing a Service	102
Chapter 24: Service Worker	105
Section 24.1: Add Service Worker to our app	105
Chapter 25: EventEmitter Service	108
Section 25.1: Catching the event	108
Section 25.2: Live example	109
Section 25.3: Class Component	109
Section 25.4: Class Overview	109
Section 25.5: Emmiting Events	109
Chapter 26: Optimizing rendering using ChangeDetectionStrategy	110
Section 26.1: Default vs OnPush	110
Chapter 27: Angular 2 Forms Update	111
Section 27.1: Angular 2 : Template Driven Forms	111
Section 27.2: Angular 2 Form - Custom Email/Password Validation	111
Section 27.3: Simple Password Change Form with Multi Control Validation	113
Section 27.4: Angular 2 Forms ( Reactive Forms ) with registration form and confirm password validation 	114
Section 27.5: Angular 2: Reactive Forms (a.k.a Model-driven Forms)	116
Section 27.6: Angular 2 - Form Builder	117
Chapter 28: Detecting resize events	119
Section 28.1: A component listening in on the window resize event	119
Chapter 29: Testing ngModel	120
Section 29.1: Basic test	120
Chapter 30: Feature Modules	122
Section 30.1: A Feature Module	122
Chapter 31: Bootstrap Empty module in angular 2	123
Section 31.1: An empty module	123
Section 31.2: Application Root Module	123
Section 31.3: Bootstrapping your module	123
Section 31.4: A module with networking on the web browser	123
Section 31.5: Static bootstrapping with factory classes	124
Chapter 32: Lazy loading a module	125
Section 32.1: Lazy loading example	125
Chapter 33: Advanced Component Examples	127
Section 33.1: Image Picker with Preview	127
Section 33.2: Filter out table values by the input	128
Chapter 34: Bypassing Sanitizing for trusted values	130
Section 34.1: Bypassing Sanitizing with pipes (for code re-use)	130
Chapter 35: Angular 2 Data Driven Forms	133
Section 35.1: Data driven form	133
Chapter 36: Angular 2 In Memory Web API	135
Section 36.1: Setting Up Multiple Test API Routes	135
Section 36.2: Basic Setup	135
Chapter 37: Ahead-of-time (AOT) compilation with Angular 2	137
Section 37.1: Why we need compilation, Flow of events compilation and example?	137
Section 37.2: Using AoT Compilation with Angular CLI	138
Section 37.3: Install Angular 2 dependencies with compiler	138
Section 37.4: Add `angularCompilerOptions` to your `tsconfig.json` file	138
Section 37.5: Run ngc, the angular compiler	138
Section 37.6: Modify `main.ts` file to use NgFactory and static platform browser	139
Chapter 38: CRUD in Angular 2 with Restful API	140
Section 38.1: Read from an Restful API in Angular 2	140
Chapter 39: Use native webcomponents in Angular 2	141
Section 39.1: Include custom elements schema in your module	141
Section 39.2: Use your webcomponent in a template	141
Chapter 40: Update typings	142
Section 40.1: Update typings when: typings WARN deprecated	142
Chapter 41: Mocking @ngrx/Store	143
Section 41.1: Unit Test For Component With Mock Store	143
Section 41.2: Angular 2 - Mock Observable ( service + component )	144
Section 41.3: Observer Mock	147
Section 41.4: Unit Test For Component Spying On Store	147
Section 41.5: Simple Store	148
Chapter 42: ngrx	151
Section 42.1: Complete example : Login/logout a user	151
Chapter 43: Http Interceptor	157
Section 43.1: Using our class instead of Angular's Http	157
Section 43.2: Simple Class Extending angular's Http class	157
Section 43.3: Simple HttpClient AuthToken Interceptor (Angular 4.3+)	158
Chapter 44: Animation	160
Section 44.1: Transition between null states	160
Section 44.2: Animating between multiple states	160
Chapter 45: Zone.js	162
Section 45.1: Getting reference to NgZone	162
Section 45.2: Using NgZone to do multiple HTTP requests before showing the data	162
Chapter 46: Angular 2 Animations	163
Section 46.1: Basic Animation - Transitions an element between two states driven by a model attribute 	163
Chapter 47: Create an Angular 2+ NPM package	165
Section 47.1: Simplest package	165
Chapter 48: Angular 2 CanActivate	169
Section 48.1: Angular 2 CanActivate	169
Chapter 49: Angular 2 - Protractor	170
Section 49.1: Angular 2 Protractor - Installation	170
Section 49.2: Testing Navbar routing with Protractor	171
Chapter 50: Example for routes such as /route/subroute for static urls	173
Section 50.1: Basic route example with sub routes tree	173
Chapter 51: Angular 2 Input() output()	174
Section 51.1: Input()	174
Section 51.2: Simple example of Input Properties	175
Chapter 52: Angular-cli	176
Section 52.1: New project with scss/sass as stylesheet	176
Section 52.2: Set yarn as default package manager for @angular/cli	176
Section 52.3: Create empty Angular 2 application with angular-cli	176
Section 52.4: Generating Components, Directives, Pipes and Services	177
Section 52.5: Adding 3rd party libs	177
Section 52.6: build with angular-cli	177
Chapter 53: Angular 2 Change detection and manual triggering	178
Section 53.1: Basic example	178
Chapter 54: Angular 2 Databinding	180
Section 54.1: @Input()	180
Chapter 55: Brute Force Upgrading	182
Section 55.1: Scaolding a New Angular CLI Project	182
Chapter 56: Angular 2 provide external data to App before bootstrap	183
Section 56.1: Via Dependency Injection	183
Chapter 57: custom ngx-bootstrap datepicker + input	184
Section 57.1: custom ngx-bootstrap datepicker	184
Chapter 58: Using third party libraries like jQuery in Angular 2	187
Section 58.1: Configuration using angular-cli	187
Section 58.2: Using jQuery in Angular 2.x components	187
Chapter 59: Configuring ASP.net Core application to work with Angular 2 and	
TypeScript	188
Section 59.1: Asp.Net Core + Angular 2 + Gulp	188
Section 59.2: [Seed] Asp.Net Core + Angular 2 + Gulp on Visual Studio 2017	192
Section 59.3: MVC <-> Angular 2	192
Chapter 60: Angular 2 using webpack	194
Section 60.1: Angular 2 webpack setup	194
Chapter 61: Angular material design	198
Section 61.1: Md2Accordion and Md2Collapse	198
Section 61.2: Md2Select	198
Section 61.3: Md2Toast	199
Section 61.4: Md2Datepicker	199
Section 61.5: Md2Tooltip	199
Chapter 62: Dropzone in Angular 2	200
Section 62.1: Dropzone	200
Chapter 63: angular redux	201
Section 63.1: Basic	201
Section 63.2: Get current state	202
Section 63.3: change state	202
Section 63.4: Add redux chrome tool	203
Chapter 64: Creating an Angular npm library	204
Section 64.1: Minimal module with service class	204
Chapter 65: Barrel	208
Section 65.1: Using Barrel	208
Chapter 66: Testing an Angular 2 App	209
Section 66.1: Setting up testing with Gulp, Webpack, Karma and Jasmine	209
Section 66.2: Installing the Jasmine testing framework	213
Section 66.3: Testing Http Service	213
Section 66.4: Testing Angular Components - Basic	215
Chapter 67: angular-cli test coverage	217
Section 67.1: A simple angular-cli command base test coverage	217
Section 67.2: Detailed individual component base graphical test coverage reporting	217
Chapter 68: Debugging Angular 2 TypeScript application using Visual Studio Code	219
Section 68.1: Launch.json setup for you workspace	219
Chapter 69: unit testing	221
Section 69.1: Basic unit test	221
Credits	222
You may also like	225


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from:
https://goalkicker.com/Angular2Book
This Angular 2+ Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Angular 2+ group(s) or company(s) nor Stack Overflow. All
trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Angular 2+
Version	Release Date
6.0.0	2018-05-04
6.0.0-rc.5	2018-04-14
6.0.0-beta.0 2018-01-25
5.0.02017-11-014.3.32017-08-024.3.22017-07-264.3.12017-07-194.3.02017-07-144.2.02017-06-084.1.02017-04-264.0.02017-03-232.3.02016-12-082.2.02016-11-142.1.02016-10-132.0.22016-10-052.0.12016-09-232.0.02016-09-142.0.0-rc.72016-09-132.0.0-rc.62016-08-312.0.0-rc.52016-08-092.0.0-rc.42016-06-302.0.0-rc.32016-06-212.0.0-rc.22016-06-152.0.0-rc.12016-05-032.0.0-rc.02016-05-02Section 1.1: Getting started with Angular 2 with node.js/expressjs backend (http example included)
@NgModuleWe will create a simple "Hello World!" app with Angular2 2.4.1 ( change) with a node.js (expressjs) backend.
Prerequisites
Node.js v4.x.x or higher npm v3.x.x or higher or yarn
npm install -g typescriptThen run  or yarn global add typescriptto install typescript globally
Roadmap
Step 1
Angular2-expressCreate a new folder (and the root dir of our back-end) for our app. Let's call it . command line:

Step2
package.json (for dependencies) and app.js (for bootstrapping) for our node.jsCreate the  app.
package.json:

app.js:

npm installThen run an  or yarn to install the dependencies.
Now our back-end structure is complete. Let's move on to the front-end.
Step3
Angular2-expressOur front-end should be in a folder named front inside our  folder. command line:

package.json, systemjs.config.js, tsconfig.jsonJust like we did with our back-end our front-end needs the dependency files too. Let's go ahead and create the following files: 
package.json:

systemjs.config.js:


tsconfig.json:

npm installThen run an  or yarn to install the dependencies.
index.htmlNow that our dependency files are complete. Let's move on to our : index.html:


Now we're ready to create our first component. Create a folder named app inside our front folder. command line:

main.ts, app.module.ts, app.component.tsLet's make the following files named main.ts:

app.module.ts:

app.component.ts:

After this, compile the typescript files to javascript files. Go 2 levels up from the current dir (inside Angular2-express folder) and run the command below.
command line:

Our folder structure should look like:

node app.jslocalhost:9999Finally, inside Angular2-express folder, run  command in the command line. Open your favorite browser and check  to see your app.
Section 1.2: Install angular2 with angular-cli
This example is a quick setup of Angular 2 and how to generate a quick example project.
Prerequisites:
Node.js v4 or greater. npm v3 or greater or yarn.
Open a terminal and run the commands one by one:

or

depending on your choice of package manager.
The previous command installs @angular/cli globally, adding the executable ng to PATH.
To setup a new project
Navigate with the terminal to a folder where you want to set up the new project.
Run the commands:

That is it, you now have a simple example project made with Angular 2. You can now navigate to the link displayed in terminal and see what it is running.
To add to an existing project
Navigate to the root of your current project.
Run the command:

This will add the necessary scaffolding to your project. The files will be created in the current directory so be sure to run this in an empty directory.
Running The Project Locally
In order to see and interact with your application while it's running in the browser you must start a local development server hosting the files for your project.

If the server started successfully it should display an address at which the server is running. Usually is this:

Out of the box this local development server is hooked up with Hot Module Reloading, so any changes to the html, typescript, or css, will trigger the browser to be automatically reloaded (but can be disabled if desired).
Generating Components, Directives, Pipes and Services
nameng generate <scaffold-typename> (or simply ng g <scaffold-typeThe > <> <>) command allows you to automatically generate Angular components:
# The command below will generate a component in the folder you are currently at ng generate component my-generated-component # Using the alias (same outcome as above) ng g component my-generated-component
There are several possible types of scaffolds angular-cli can generate:
Scaffold Type	Usage
ng g module my-new-moduleModule
ng g component my-new-componentComponent
ng g directive my-new-directiveDirective
ng g pipe my-new-pipePipe
ng g service my-new-serviceService
ng g class my-new-classClass
ng g interface my-new-interfaceInterface
ng g enum my-new-enumEnum
You can also replace the type name by its first letter. For example:
ng g m my-new-module to generate a new module or ng g c my-new-component to create a component.
Building/Bundling
When you are all finished building your Angular 2 web app and you would like to install it on a web server like Apache Tomcat, all you need to do is run the build command either with or without the production flag set. Production will minifiy the code and optimize for a production setting.

or

distThen look in the projects root directory for a / folder, which contains the build.
If you'd like the benefits of a smaller production bundle, you can also use Ahead-of-Time template compilation, which removes the template compiler from the final build:

Unit Testing
Angular 2 provides built-in unit testing, and every item created by angular-cli generates a basic unit test, that can be expanded. The unit tests are written using jasmine, and executed through Karma. In order to start testing execute the following command:

This command will execute all the tests in the project, and will re-execute them every time a source file changes, whether it is a test or code from the application.
For more info also visit: angular-cli github page
Section 1.3: Getting started with Angular 2 without angular-cli
Angular 2.0.0-rc.4
In this example we'll create a "Hello World!" app with only one root component (AppComponent) for the sake of simplicity.
Prerequisites:
node -v and npm -vNode.js v5 or later npm v3 or later
Note: You can check versions by running  in the console/terminal.
Step 1
angular2-exampleCreate and enter a new folder for your project. Let's call it .

Step 2
package.json, tsconfig.jsonBefore we start writing our app code, we'll add the 4 files provided below: ,
typings.json, and systemjs.config.js.
		Disclaimer: The same files can be found in the Official 5 Minute Quickstart.
package.json- Allows us to download all dependencies with npm and provides simple script execution to make life
easier for simple projects. (You should consider using something like Gulp in the future to automate tasks).


tsconfig.json- Configures the TypeScript transpiler.

typings.json- Makes TypeScript recognize libraries we're using.

systemjs.config.js- Configures SystemJS (you can also use webpack).


Step 3
Let's install the dependencies by typing

in the console/terminal.
Step 4
index.html inside of the angular2-exampleCreate  folder.


my-appYour application will be rendered between the  tags.
However, Angular still doesn't know what to render. To tell it that, we'll define AppComponent.
Step 5
main.tsCreate a subfolder called app where we can define the components and services that make up our app. (In this case, it'll just contain the AppComponent code and .)

Step 6
app/app.component.tsCreate the file 

ComponentWhat's happening? First, we're importing the @ decorator which we use to give Angular the HTML tag and template for this component. Then, we're creating the class AppComponent with title and messages variables that we can use in the template.
Now let's look at that template:


We're displaying the title variable in an h1 tag and then making a list showing each element of the messages array
ngFor directive. For each element in the array, *ngForby using the * creates a message variable that we use within the li element. The result will be:

Step 7
main.tsNow we create a  file, which will be the first file that Angular looks at.
app/main.tsCreate the file .

We're importing the bootstrap function and AppComponent class, then using bootstrap to tell Angular which component to use as the root.
Step 8
It's time to fire up your first app. Type

package.jsontsin your console/terminal. This will run a prepared script from  that starts lite-server, opens your app in a browser window, and runs the TypeScript transpiler in watch mode (so . files will be transpiled and the browser will refresh when you save changes).
What now?
Check out the official Angular 2 guide and the other topics on StackOverflow's documentation.
You can also edit AppComponent to use external templates, styles or add/edit component variables. You should see your changes immediately after saving files.
Section 1.4: Getting through that pesky company proxy
If you are attempting to get an Angular2 site running on your Windows work computer at XYZ MegaCorp the chances are that you are having problems getting through the company proxy.
There are (at least) two package managers that need to get through the proxy:
1. NPM
2. Typings
npmrcFor NPM you need to add the following lines to the . file:
typingsrc proxy=http://[DOMAIN]%5C[USER]:[PASS]@[PROXY]:[PROXYPORT]/ https-proxy=http://[DOMAIN]%5C[USER]:[PASS]@[PROXY]:[PROXYPORT]/ For Typings you need to add the following lines to the . file:

These files probably don't exist yet, so you can create them as blank text files. They can be added to the project root
package.json or you can put them in %HOMEPATH(same place as % and they will be available to all your projects.
5CThe bit that isn't obvious and is the main reason people think the proxy settings aren't working is the % which is the URL encode of the \ to separate the domain and user names. Thanks to Steve Roberts for that one: Using npm behind corporate proxy .pac
Section 1.5: Keeping Visual Studios in sync with NPM and NODE Updates
Step 1: Locate your download of Node.js, typically it is installed under C:/program files/nodejs
Step 2: Open Visual Studios and navigate to "Tools>Options"
Step 3: In the options window navigate to "Projects and Solutions>External Web Tools"
Step 4: Add new entry with you Node.js file location (C:/program files/nodejs), IMPORTANT use the arrow buttons on menu to move your reference to the top of the list.

Step 5: Restart Visual Studios and Run an npm install, against your project, from npm command window
Section 1.6: Let's dive into Angular 4!
Angular 4 is now available! Actually Angular uses semver since Angular 2, which requires the major number being increased when breaking changes were introduced. The Angular team postponed features that cause breaking changes, which will be released with Angular 4. Angular 3 was skipped to be able to align the version numbers of the core modules, because the Router already had version 3.
As per the Angular team, Angular 4 applications are going to be less space consuming and faster than before. They have separated animation package from @angular/core package. If anybody is not using animation package so extra space of code will not end up in the production. The template binding syntax now supports if/else style syntax. Angular 4 is now compatible with most recent version of Typescript 2.1 and 2.2. So, Angular 4 is going to be more exciting.
Now I'll show you how to do setup of Angular 4 in your project.
Let's start Angular setup with three different ways:
You can use Angular-CLI (Command Line Interface) , It will install all dependencies for you.
You can migrate from Angular 2 to Angular 4.
You can use github and clone the Angular4-boilerplate. (It is the easiest one.???? ) Angular Setup using Angular-CLI(command Line Interface).
Before You start using Angular-CLI , make sure You have node installed in your machine. Here, I am using node v7.8.0. Now, Open your terminal and type the following command for Angular-CLI.

or

depending on the package manager you use.
Let's install Angular 4 using Angular-CLI.

cd Angular4-boilerplate We are all set for Angular 4. Its pretty easy and straightforward method.????
Angular Setup by migrating from Angular 2 to Angular 4
Now Let's see the second approach. I ll show you how to migrate Angular 2 to Angular 4. For that You need clone any Angular 2 project and update Angular 2 dependencies with the Angular 4 Dependency in your package.json as following:


These are the main dependencies for Angular 4. Now You can npm install and then npm start to run the application. For reference my package.json.
Angular setup from github project
Before starting this step make sure you have git installed in your machine. Open your terminal and clone the angular4-boilerplate using below command:

Then install all dependencies and run it.

And you are done with the Angular 4 setup. All the steps are very straightforward so you can opt any of them.
Directory Structure of the angular4-boilerplate


Basic understanding for Directory structure:
All the code resides in src folder.
mocks folder is for mock data that is used in testing purpose. model folder contains the class and interface that used in component.
modules folder contains list of components such as app, login, widget etc. All component contains typescript, html and css file. index.ts is for exporting all the class.
services folder contains list of services used in application. I have separated rest service and different component service. In rest service contains different http methods. Login service works as mediator between login component and rest service. app.routing.ts file describes all possible routes for the application.
app.module.ts describes app module as root component.
bootstrap.ts will run the whole application. webpack folder contains webpack configuration file.
package.json file is for all list of dependencies. karma contains karma configuration for unit test. node_modules contains list of package bundles.
Lets start with Login component. In login.component.html

In login.component.ts


We need to export this component to in index.ts.

we need to set routes for login in app.routes.ts

In root component, app.module.ts file you just need to import that component.

and after that npm install and npm start. Here, you go! You can check login screen in your localhost. In case of any difficulty, You can refer the angular4-boilerplate.
Basically I can feel less building package and more faster response with Angular 4 application and Although I found Exactly similar to Angular 2 in coding.
Chapter 2: Components
Angular components are elements composed by a template that will render your application.
Section 2.1: A simple component
ComponentTo create a component we add @ decorator in a class passing some parameters:
providers: Resources that will be injected into the component constructor selector: The query selector that will find the element in the HTML and replace by the component styles: Inline styles. NOTE: DO NOT use this parameter with require, it works on development but when you build the application in production all your styles are lost styleUrls: Array of path to style files template: String that contains your HTML templateUrl: Path to a HTML file
There are other parameters you can configure, but the listed ones are what you will use the most.
A simple example:

Section 2.2: Templates & Styles
Templates are HTML files that may contain logic.
You can specify a template in two ways:
Passing template as a file path

Passing a template as an inline code

ComponentTemplates may contain styles. The styles declared in @ are different from your application style file, anything applied in the component will be restricted to this scope. For example, say you add:

All divs inside the component will be red, but if you have other components, other divs in your HTML they will not be changed at all.
The generated code will look like this:

You can add styles to a component in two ways:
Passing an array of file paths


You shouldn't use styles with require as it will not work when you build your application to production.
Section 2.3: Testing a Component
hero.component.html

hero.component.ts

hero.component.spec.ts


Section 2.4: Nesting components
Components will render in their respective selector, so you can use that to nest components.
If you have a component that shows a message:

app-requiredYou can use it inside another component using  (this component's selector):



Chapter 3: Component interactions
	Name	Value
pageCount	Used to tell number of pages to be created to the child component. pageNumberClicked Name of output variable in the child component. pageChanged	Function at parent component that listening for child components output.
Section 3.1: Pass data from parent to child with input binding
HeroChildComponent has two input properties, typically adorned with @Input decorations.

Intercept input property changes with a setter
Use an input property setter to intercept and act upon a value from the parent.
The setter of the name input property in the child NameChildComponent trims the whitespace from a name and replaces an empty value with default text.

Here's the NameParentComponent demonstrating name variations including a name with all spaces:


Parent listens for child event
The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events.
The child's EventEmitter property is an output property, typically adorned with an @Output decoration as seen in this VoterComponent:

Clicking a button triggers emission of a true or false (the boolean payload).
The parent VoteTakerComponent binds an event handler (onVoted) that responds to the child event payload ($event) and updates a counter.

Parent interacts with child via local variable
A parent component cannot use data binding to read child properties or invoke child methods. We can do both by creating a template reference variable for the child element and then reference that variable within the parent template as seen in the following example.
We have a child CountdownTimerComponent that repeatedly counts down to zero and launches a rocket. It has start and stop methods that control the clock and it displays a countdown status message in its own template.

Let's see the CountdownLocalVarParentComponent that hosts the timer component.

The parent component cannot data bind to the child's start and stop methods nor to its seconds property.
We can place a local variable (#timer) on the tag () representing the child component. That gives us a reference to the child component itself and the ability to access any of its properties or methods from within the parent template.
In this example, we wire parent buttons to the child's start and stop and use interpolation to display the child's seconds property.
Here we see the parent and child working together.
Parent calls a ViewChild
The local variable approach is simple and easy. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component itself has no access to the child.
We can't use the local variable technique if an instance of the parent component class must read or write child component values or must call child component methods.
When the parent component class requires that kind of access, we inject the child component into the parent as a ViewChild.
We'll illustrate this technique with the same Countdown Timer example. We won't change its appearance or behavior. The child CountdownTimerComponent is the same as well.
We are switching from the local variable to the ViewChild technique solely for the purpose of demonstration. Here is the parent, CountdownViewChildParentComponent:

It takes a bit more work to get the child view into the parent component class.
We import references to the ViewChild decorator and the AfterViewInit lifecycle hook.
We inject the child CountdownTimerComponent into the private timerComponent property via the @ViewChild property decoration.
The #timer local variable is gone from the component metadata. Instead we bind the buttons to the parent component's own start and stop methods and present the ticking seconds in an interpolation around the parent component's seconds method.
These methods access the injected timer component directly.
The ngAfterViewInit lifecycle hook is an important wrinkle. The timer component isn't available until after Angular displays the parent view. So we display 0 seconds initially.
Then Angular calls the ngAfterViewInit lifecycle hook at which time it is too late to update the parent view's display of the countdown seconds. Angular's unidirectional data flow rule prevents us from updating the parent view's in the same cycle. We have to wait one turn before we can display the seconds.
We use setTimeout to wait one tick and then revise the seconds method so that it takes future values from the timer component.
Parent and children communicate via a service
A parent component and its children share a service whose interface enables bi-directional communication within the family.
The scope of the service instance is the parent component and its children. Components outside this component subtree have no access to the service or their communications.
This MissionService connects the MissionControlComponent to multiple AstronautComponent children.

The MissionControlComponent both provides the instance of the service that it shares with its children (through the providers metadata array) and injects that instance into itself through its constructor:


The AstronautComponent also injects the service in its constructor. Each AstronautComponent is a child of the MissionControlComponent and therefore receives its parent's service instance:


Notice that we capture the subscription and unsubscribe when the AstronautComponent is destroyed. This is a memory-leak guard step. There is no actual risk in this app because the lifetime of a AstronautComponent is the same as the lifetime of the app itself. That would not always be true in a more complex application.
We do not add this guard to the MissionControlComponent because, as the parent, it controls the lifetime of the MissionService. The History log demonstrates that messages travel in both directions between the parent MissionControlComponent and the AstronautComponent children, facilitated by the service:
Section 3.2: Parent - Child interaction using @Input & @Output properties
We have a DataListComponent that shows a data we pull from a service. DataListComponent also has a PagerComponent as it's child.
PagerComponent creates page number list based on total number of pages it gets from the DataListComponent.
PagerComponent also lets the DataListComponent know when user clicks any page number via Output property.


PagerComponent lists all the page numbers. We set click event on each of them so we can let the parent know about the clicked page number.

Section 3.3: Parent - Child interaction using ViewChild
Viewchild offers one way interaction from parent to child. There is no feedback or output from child when ViewChild is used.
We have a DataListComponent that shows some information. DataListComponent has PagerComponent as it's child. When user makes a search on DataListComponent, it gets a data from a service and ask PagerComponent to refresh paging layout based on new number of pages.


In this way you can call functions defined at child components.
Child component is not available until parent component is rendered. Attempting to access to the child before parents AfterViewInit life cyle hook will cause exception.
Section 3.4: Bidirectional parent-child interaction through a service
Service that is used for communication:

Parent component:

Child component:

AppModule:


Chapter 4: Directives
Section 4.1: *ngFor
form1.component.ts:

Output:

ngFor has two parts : let In its most simple form, *>variableName of object/array
fruit 'Apples', 'Oranges', 'Bananas', 'Limes', 'Lemons'In the case of = [];,
Apples, Oranges, and so on are the values inside the array fruit.
value]="f" will be equal to each current fruit (f) that *ngFor[ has iterated over.
ng-options for <select> and ng-repeatUnlike AngularJS, Angular2 has not continued with the use of  for all other general repetitions.
ngFor is very similar to ng-repeat* with slightly varied syntax.
References:
Angular2 | Displaying Data
Angular2 | ngFor
Angular2 | Forms
Section 4.2: Attribute directive

Section 4.3: Component is a directive with template

Section 4.4: Structural directives

Section 4.5: Custom directive

Usage:

Section 4.6: Copy to Clipboard directive
In this example we are going to create a directive to copy a text into the clipboard by clicking on an element copy-text.directive.ts


some-page.component.html
Remember to inject TEXT_COPY_DIRECTIVES into the directives array of your component
...
    <!-- Insert variable as the attribute's value, let textToBeCopied = 'http://facebook.com/' -->
    <button [text-copy]="textToBeCopied">Copy URL</button>
    <button [text-copy]="'https://www.google.com/'">Copy URL</button> ...
Section 4.7: Testing a custom directive
Given a directive that highlights text on mouse events

It can be tested like this


Chapter 5: Page title
How can you change the title of the page
Section 5.1: changing the page title
1. First we need to provide Title service.
2. Using setTitle


Chapter 6: Templates
Templates are very similar to templates in Angular 1, though there are many small syntactical changes that make it more clear what is happening.
Section 6.1: Angular 2 Templates
A SIMPLE TEMPLATE
Let's start with a very simple template that shows our name and our favorite thing:

{}: RENDERING
To render a value, we can use the standard double-curly syntax:

Pipes, previously known as "Filters," transform a value into a new value, like localizing a string or converting a floating point value into a currency representation:
[]: BINDING PROPERTIES
To resolve and bind a variable to a component, use the [] syntax. If we have this.currentVolume in our component, we will pass this through to our component and the values will stay in sync:

(): HANDLING EVENTS To listen for an event on a component, we use the () syntax

[()]: TWO-WAY DATA BINDING
To keep a binding up to date given user input and other events, use the [()] syntax. Think of it as a combination of handling an event and binding a property:
<input [(ngModel)]="myName"> The this.myName value of your component will stay in sync with the input value.
*: THE ASTERISK
Indicates that this directive treats this component as a template and will not draw it as-is. For example, ngFor takes our and stamps it out for each item in items, but it never renders our initial since it's a template:

Other similar directives that work on templates rather than rendered components are *ngIf and *ngSwitch.
Chapter 7: Commonly built-in directives and services
@angular/common - commonly needed directives and services @angular/core - the angular core framework
Section 7.1: Location Class
Location is a service that applications can use to interact with a browser's URL. Depending on which LocationStrategy is used, Location will either persist to the URL's path or the URL's hash segment.
Location is responsible for normalizing the URL against the application's base href.

Section 7.2: AsyncPipe
The async pipe subscribes to an Observable or Promise and returns the latest value it has emitted. When a new value is emitted, the async pipe marks the component to be checked for changes. When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.

Section 7.3: Displaying current Angular 2 version used in your project
To display current version, we can use VERSION from @angular/core package.

Section 7.4: Currency Pipe
The currency pipe allows you to work with you data as regular numbers but display it with standard currency formatting (currency symbol, decimal places, etc.) in the view.

The pipe takes three optional parameters:
currencyCode: Allows you to specify the ISO 4217 currency code.
symbolDisplay: Boolean indicating whether to use the currency symbol digitInfo: Allows you to specify how the decimal places should be displayed.
More documentation on the currency pipe:
https://angular.io/docs/ts/latest/api/common/index/CurrencyPipe-pipe.html
Chapter 8: Directives & components : @Input @Output
Section 8.1: Angular 2 @Input and @Output in a nested component
@Input()@OutputA Button directive which accepts an  to specify a click limit until the button gets disabled. The parent component can listen to an event which will be emitted when the click limit is reached via :

Parent component which uses the Button directive and alerts a message when the click limit is reached:

Section 8.2: Input example
@input is useful to bind data between components
First, import it in your component

Then, add the input as a property of your component class

Let's say that the selector of your component is 'car-component', when you call the component, add the attribute
'car'

Now your car is accessible as an attribute in your object (this.car)
Full Example :
1. car.entity.ts

2. car.component.ts

3. garage.component.ts


4. garage.html

5. car.html

Section 8.3: Angular 2 @Input with asynchronous data
InputSometimes you need to fetch data asynchronously before passing it to a child component to use. If the child component tries to use the data before it has been received, it will throw an error. You can use ngOnChanges to detect changes in a components' @s and wait until they are defined before acting upon them.


Child component which has async data as input
This child component takes the async data as input. Therefore it must wait for the data to exist before Using it. We use ngOnChanges which fires whenever a component's input changes, check if the data exists and use it if it does. Notice that the template for the child will not show if a property that relies on the data being passed in is not true.

Chapter 9: Attribute directives to aect the value of properties on the host node by using the @HostBinding decorator.
Section 9.1: @HostBinding
The @HostBinding decorator allows us to programmatically set a property value on the directive's host element. It works similarly to a property binding defined in a template, except it specifically targets the host element. The binding is checked for every change detection cycle, so it can change dynamically if desired. For example, lets say that we want to create a directive for buttons that dynamically adds a class when we press on it. That could look something like:

Notice that for both use cases of @HostBinding we are passing in a string value for which property we want to affect. If we don't supply a string to the decorator, then the name of the class member will be used instead. In the first @HostBinding, we are statically setting the role attribute to button. For the second example, the pressed class will be applied when isPressed is true
Chapter 10: How to Use ngif
*NgIf: It removes or recreates a part of DOM tree depending on an expression evaluation. It is a structural directive and structural directives alter the layout of the DOM by adding, replacing and removing its elements.
Section 10.1: To run a function at the start or end of *ngFor loop Using *ngIf
NgFor provides Some values that can be aliased to local variables
index -(variable) position of the current item in the iterable starting at 0 first -(boolean) true if the current item is the first item in the iterable last -(boolean) true if the current item is the last item in the iterable even -(boolean) true if the current index is an even number odd -(boolean) true if the current index is an odd number
<div *ngFor="let note of csvdata; let i=index; let lastcall=last">
      <h3>{{i}}</h3> <-- to show index position
     <h3>{{note}}</h3>
      <span *ngIf="lastcall">{{anyfunction()}} </span><-- this lastcall boolean value will be true only if this is last in loop
     // anyfunction() will run at the end of loop same way we can do at start    </div>
Section 10.2: Display a loading message
If our component is not ready and waiting for data from server, then we can add loader using *ngIf. Steps:
First declare a boolean:

Next, in your component add a lifecycle hook called ngOnInit

and after you get complete data from server set you loading boolean to false.

In your html template use *ngIf with the loading property:

Section 10.3: Show Alert Message on a condition
<p class="alert alert-success" *ngIf="names.length > 2">Currently there are more than 2 names!</p>
Section 10.4: Use *ngIf with*ngFor
ngIf and *ngForngIf in the *ngForWhile you are not allowed to use * in the same div (it will gives an error in the runtime) you can nest the * to get the desired behavior.
Example 1: General syntax

Example 2: Display elements with even index

The downside is that an additional outer div element needs to be added.
But consider this use case where a div element needs to be iterated (using *ngFor) and also includes a check whether the element need to be removed or not (using *ngIf), but adding an additional div is not preferred. In this case you can use the template tag for the *ngFor:

<templateThis way adding an additional outer div is not needed and furthermore the > element won't be added to the DOM. The only elements added in the DOM from the above example are the iterated div elements.
<template> has been deprecated in favour of <ng-templateNote: In Angular v4 > and will be removed in v5. In
<templateAngular v2.x releases > is still valid.
Chapter 11: How to use ngfor
The ngFor directive is used by Angular2 to instantiate a template once for every item in an iterable object. This directive binds the iterable to the DOM, so if the content of the iterable changes, the content of the DOM will be also changed.
Section 11.1: *ngFor with pipe

Section 11.2: Unordered list example

Section 11.3: More complext template example

Section 11.4: Tracking current interaction example

In this case, i will take the value of index, which is the current loop iteration.
Section 11.5: Angular 2 aliased exported values
Angular2 provides several exported values that can be aliased to local variables. These are:
index
first last
even odd
Except index, the other ones take a Boolean value. As the previous example using index, it can be used any of these exported values:
<div *ngFor="let item of items; let firstItem = first; let lastItem = last">   <p *ngIf="firstItem">I am the first item and I am gonna be showed</p>
  <p *ngIf="firstItem">I am not the first item and I will not show up :(</p>
  <p *ngIf="lastItem">But I'm gonna be showed as I am the last item :)</p> </div>

Chapter 12: Angular - ForLoop
Section 12.1: NgFor - Markup For Loop
The NgFor directive instantiates a template once per item from an iterable. The context for each instantiated template inherits from the outer context with the given loop variable set to the current item from the iterable.
To customize the default tracking algorithm, NgFor supports trackBy option. trackBy takes a function which has two arguments: index and item. If trackBy is given, Angular tracks changes by the return value of the function.

Additional Options: NgFor provides several exported values that can be aliased to local variables:
index will be set to the current loop iteration for each template context. first will be set to a boolean value indicating whether the item is the first one in the iteration. last will be set to a boolean value indicating whether the item is the last one in the iteration. even will be set to a boolean value indicating whether this item has an even index. odd will be set to a boolean value indicating whether this item has an odd index.
Section 12.2: *ngFor with component

Section 12.3: Angular 2 for-loop
For live plnkr click...


Section 12.4: *ngFor X amount of items per row
Example shows 5 items per row:

Section 12.5: *ngFor in the Table Rows

Chapter 13: Modules
Angular modules are containers for different parts of your app.
app.moduleYou can have nested modules, your  is already actually nesting other modules such as BrowserModule and you can add RouterModule and so on.
Section 13.1: A simple module
NgModule decorator. To create a module we add @NgModuleA module is a class with the @ passing some parameters:
bootstrap: The component that will be the root of your application. This configuration is only present on your root module declarations: Resources the module declares. When you add a new component you have to update the declarations (ng generate component does it automatically) exports: Resources the module exports that can be used in other modules imports: Resources the module uses from other modules (only module classes are accepted) providers: Resources that can be injected (di) in a component
A simple example:

Section 13.2: Nesting modules
NgModuleModules can be nested by using the imports parameter of @ decorator.
core.moduleWe can create a  in our application that will contain generic things, like a ReservePipe (a pipe that reverse a string) and bundle those in this module:

app.moduleThen in the :


Chapter 14: Pipes
	Function/Parameter	Explanation
@Pipe({name, pure})	metadata for pipe, must immediately precede pipe class name: string	what you will use inside the template pure: boolean	defaults to true, mark this as false to have your pipe re-evaluated more often transform( value, args[]? ) the function that is called to transform the values in the template
value: any	the value that you want to transform
                          the arguments that you may need included in your transform. Mark optional args with args: any[] the ? operator like so transform(value, arg1, arg2?)
The pipe | character is used to apply pipes in Angular 2. Pipes are very similar to filters in AngularJS in that they both help to transform the data into a specified format.
Section 14.1: Custom Pipes
my.pipe.ts

my.component.ts

my.module.ts


Section 14.2: Built-in Pipes
Angular2 comes with a few built-in pipes:
	Pipe	Usage	Example
{{ dateObj | date }} // output is 'Jun 15, 2015'DatePipe	date
{{ value | uppercase }} // output is 'SOMETEXT'UpperCasePipeuppercase
{{ value | lowercase }} // output is 'sometext'LowerCasePipelowercase
{{ 31.00 | currency:'USD':true }} // output is '$31'{{ 0.03 | percent }} //output is %3CurrencyPipe currency PercentPipe percent
There are others. Look here for their documentation.


Output

Section 14.3: Chaining Pipes
Pipes may be chained.

Section 14.4: Debugging With JsonPipe
The JsonPipe can be used for debugging the state of any given internal.
Code

Output

Section 14.5: Dynamic Pipe
Use case scenario: A table view consists of different columns with different data format that needs to be transformed with different pipes. table.component.ts

dynamic.pipe.ts


table.component.html

Result
| ID | Page Title     | Page URL    | Created          | Status     |
---------------------------------------------------------------------
|  1 | Home           | home        | 4 minutes ago    | Enabled    |
|  2 | About Us       | about       | Yesterday        | Enabled    |
|  4 | Contact Us     | contact     | Yesterday        | Disabled   |
---------------------------------------------------------------------
Section 14.6: Unwrap async values with async pipe


Becomes:

Section 14.7: Stateful Pipes
Angular 2 offers two different types of pipes - stateless and stateful. Pipes are stateless by default. However, we can implement stateful pipes by setting the pure property to false. As you can see in the parameter section, you can specify a name and declare whether the pipe should be pure or not, meaning stateful or stateless. While data flows through a stateless pipe (which is a pure function) that does not remember anything, data can be managed and remembered by stateful pipes. A good example of a stateful pipe is the AsyncPipe that is provided by Angular 2.
Important
Notice that most pipes should fall into the category of stateless pipes. That's important for performance reasons since Angular can optimize stateless pipes for the change detector. So use stateful pipes cautiously. In general, the optimization of pipes in Angular 2 have a major performance enhancement over filters in Angular 1.x. In Angular 1 the digest cycle always had to re-run all filters even though the data hasn't changed at all. In Angular 2, once a pipe's value has been computed, the change detector knows not to run this pipe again unless the input changes.
Implementation of a stateful pipe


You can then use the pipe as usual:

It's important that your pipe also implements the OnDestroy interface so you can clean up once your pipe gets destroyed. In the example above, it's necessary to clear the interval to avoid memory leaks.
Section 14.8: Creating Custom Pipe
app/pipes.pipe.ts

app/my-component.component.ts


Section 14.9: Globally Available Custom Pipe
To make a custom pipe available application wide, During application bootstrap, extending PLATFORM_PIPES.

Tutorial here: https://scotch.io/tutorials/create-a-globally-available-custom-pipe-in-angular-2
Section 14.10: Extending an Existing Pipe

Section 14.11: Testing a pipe
Given a pipe that reverse a string


It can be tested configuring the spec file like this


Chapter 15: OrderBy Pipe
How to write order pipe and use it.
Section 15.1: The Pipe
The Pipe implementation


How to use the pipe in the HTML - order ascending by first name

How to use the pipe in the HTML - order descending by first name



Chapter 16: Angular 2 Custom Validations
parameter	description
           This is the control that is being validated. Typically you will want to see if control.value meets some control criteria.
Section 16.1: get/set formBuilder controls parameters
There are 2 ways to set formBuilder controls parameters.
1. On initialize:

2.After initialize:

Get formBuilder control value:

Section 16.2: Custom validator examples:
Angular 2 has two kinds of custom validators. Synchronous validators as in the first example that will run directly on the client and asynchronous validators (the second example) that you can use to call a remote service to do the validation for you. In this example the validator should call the server to see if a value is unique.

If your control value is valid you simply return null to the caller. Otherwise you can return an object which describes
the error.
Section 16.3: Using validators in the Formbuilder

Here we use the FormBuilder to create a very basic form with two input boxes. The FromBuilder takes an array for three arguments for each input control.
1. The default value of the control.
2. The validators that will run on the client. You can use Validators.compose([arrayOfValidators]) to apply multiple validators on your control.
3. One or more async validators in a similar fashion as the second argument.

Chapter 17: Routing
Section 17.1: ResolveData
This example will show you how you can resolve data fetched from a service before rendering your application's view.
Uses angular/router 3.0.0-beta.2 at the time of writing users.service.ts

users.resolver.ts

@Injectable() export class UsersResolver implements Resolve<User[] | User> {
    // Inject UsersService into the resolver     constructor(private service:UsersService) {}
    resolve(route:ActivatedRouteSnapshot, state:RouterStateSnapshot):Observable<User[] | User> {         // If userId param exists in current URL, return a single user, else return all users         // Uses brackets notation to access `id` to suppress editor warning, may use dot notation if you create an interface extending ActivatedRoute with an optional id? attribute         if (route.params['id']) return this.service.get(route.params['id']);         return this.service.index();     }
 } users.component.ts
data.users with data.userThis is a page component with a list of all users. It will work similarly for User detail page component, replace  or whatever key defined in app.routes.ts(see below)

app.routes.ts


app.resolver.ts
Optionally bundle multiple resolvers together.
IMPORTANT: Services used in resolver must be imported first or you will get a 'No provider for ..Resolver error'. Remember that these services will be available globally and you will not need to declare them in any component's providers anymore. Be sure to unsubscribe from any subscription to prevent memory leak

main.browser.ts
Resolvers have to be injected during bootstrapping.

Section 17.2: Routing with Children
Contrary to original documentation, I found this to be the way to properly nest children routes inside the app.routing.ts or app.module.ts file (depending on your preference). This approach works when using either WebPack or SystemJS.
The example below shows routes for home, home/counter, and home/counter/fetch-data. The first and last routes being examples of redirects. Finally at the end of the example is a proper way to export the Route to be imported in a separate file. For ex. app.module.ts
To further explain, Angular requires that you have a pathless route in the children array that includes the parent component, to represent the parent route. It's a little confusing but if you think about a blank URL for a child route, it would essentially equal the same URL as the parent route.

Great Example and Description via Siraj
Section 17.3: Basic Routing
Router enables navigation from one view to another based on user interactions with the application.
Following are the steps in implementing basic routing in Angular 2 -
Basic precaution: Ensure you have the tag

as the first child under your head tag in your index.html file. This tag tells that your app folder is the application root. Angular 2 would then know to organize your links.
First step is to check if you are pointing to correct/latest routing dependencies in package.json -

Second step is to define the route as per it's class definition -

route/routes.tsIn a routes file (), import all the components which you need to configure for different routing paths. Empty path means that view is loaded by default. ":" in the path indicates dynamic parameter passed to the loaded component.
Routes are made available to application via dependency injection. ProviderRouter method is called with RouterConfig as parameter so that it can be injected to the components for calling routing specific tasks.
import { provideRouter, RouterConfig } from '@angular/router'; import { BarDetailComponent } from '../components/bar-detail.component'; import { DashboardComponent } from '../components/dashboard.component'; import { LoginComponent } from '../components/login.component'; import { SignupComponent } from '../components/signup.component';
export const appRoutes: RouterConfig = [
  { path: '', pathMatch: 'full', redirectTo: 'login' },   { path: 'dashboard', component: DashboardComponent },
  { path: 'bars/:id', component: BarDetailComponent },
  { path: 'login', component: LoginComponent },
  { path: 'signup',   component: SignupComponent } ]; export const APP_ROUTER_PROVIDER = [provideRouter(appRoutes)];
Third step is to bootstrap the route provider.
main.tsIn your  (It can be any name. basically, it should your main file defined in systemjs.config)
import { bootstrap } from '@angular/platform-browser-dynamic'; import { AppComponent } from './components/app.component'; import { APP_ROUTER_PROVIDER } from "./routes/routes"; bootstrap(AppComponent, [ APP_ROUTER_PROVIDER ]).catch(err => console.error(err));
Fourth step is to load/display the router components based on path accessed. directive is used to tell angular where to load the component. To use import the ROUTER_DIRECTIVES.

Fifth step is to link the other routes. By default, RouterOutlet will load the component for which empty path is specified in the RouterConfig. RouterLink directive is used with html anchor tag to load the components attached to routes. RouterLink generates the href attribute which is used to generate links. For Ex:

Now, we are good with routing to static path. RouterLink support dynamic path also by passing extra parameters along with the path.
import { Component } from '@angular/core'; import { ROUTER_DIRECTIVES } from '@angular/router';


RouterLink takes an array where first element is the path for routing and subsequent elements are for the dynamic routing parameters.
Section 17.4: Child Routes
Sometimes it makes sense to nest view's or routes within one another. For example on the dashboard you want several sub views, similar to tabs but implemented via the routing system, to show the users' projects, contacts, messages ets. In order to support such scenarios the router allows us to define child routes.
First we adjust our RouterConfig from above and add the child routes:
import { ProjectsComponent } from '../components/projects.component'; import { MessagesComponent} from '../components/messages.component';
export const appRoutes: RouterConfig = [
  { path: '', pathMatch: 'full', redirectTo: 'login' },   { path: 'dashboard', component: DashboardComponent,     children: [
      { path: '', redirectTo: 'projects', pathMatch: 'full' },
      { path: 'projects', component: 'ProjectsComponent' },       { path: 'messages', component: 'MessagesComponent' }
    ] },
  { path: 'bars/:id', component: BarDetailComponent },
  { path: 'login', component: LoginComponent },
  { path: 'signup',   component: SignupComponent }
];
Now that we have our child routes defined we have to make sure those child routes can be displayed within our DashboardComponent, since that's where we have added the childs to. Previously we have learned that the
<router-outlet></router-outletcomponents are displayed in a > tag. Similar we declare another RouterOutlet in

As you can see, we have added another RouterOutlet in which the child routes will be displayed. Usually the route with an empty path will be shown, however, we set up a redirect to the projects route, because we want that to be shown immediately when the dashboard route is loaded. That being said, we need an empty route, otherwise you'll get an error like this:

So by adding the empty route, meaning a route with an empty path, we have defined an entry point for the router.

Chapter 18: Routing (3.0.0+)
Section 18.1: Controlling Access to or from a Route
The default Angular router allows navigation to and from any route unconditionally. This is not always the desired behavior.
In a scenario where a user may conditionally be allowed to navigate to or from a route, a Route Guard may be used to restrict this behavior.
If your scenario fits one of the following, consider using a Route Guard,
User is required to be authenticated to navigate to the target component.
User is required to be authorized to navigate to the target component.
Component requires asynchronous request before initialization. Component requires user input before navigated away from.
How Route Guards work
Route Guards work by returning a boolean value to control the behavior of router navigation. If true is returned, the router will continue with navigation to the target component. If false is returned, the router will deny navigation to the target component.
Route Guard Interfaces
The router supports multiple guard interfaces:
CanActivate: occurs between route navigation.
CanActivateChild: occurs between route navigation to a child route.
CanDeactivate: occurs when navigating away from the current route.
CanLoad: occurs between route navigation to a feature module loaded asynchronously. Resolve: used to perform data retrieval before route activation.
These interfaces can be implemented in your guard to grant or remove access to certain processes of the navigation.
Synchronous vs. Asynchronous Route Guards
Route Guards allow synchronous and asynchronous operations to conditionally control navigation.
Synchronous Route Guard
A synchronous route guard returns a boolean, such as by computing an immediate result, in order to conditionally control navigation.


Asynchronous Route Guard
For more complex behavior, a route guard can asynchronously block navigation. An asynchronous route guard can return an Observable or Promise.
This is useful for situations like waiting for user input to answer a question, waiting to successfully save changes to the server, or waiting to receive data fetched from a remote server.

Section 18.2: Add guard to route configuration
File app.routes

Export the APP_ROUTER_PROVIDERS to be used in app bootstrap

Section 18.3: Using Resolvers and Guards
We're using a toplevel guard in our route config to catch the current user on first page load, and a resolver to store the value of the currentUser, which is our authenticated user from the backend.
A simplified version of our implementation looks as follows:
Here is our top level route:





Section 18.4: Use Guard in app bootstrap
File main.ts (or boot.ts)
Consider the examples above:
1. Create the guard (where the Guard is created) and
2. Add guard to route configuration, (where the Guard is configured for route, then APP_ROUTER_PROVIDERS is exported), we can couple the bootstrap to Guard as follows

Section 18.5: Bootstrapping
Now that the routes are defined, we need to let our application know about the routes. To do this, bootstrap the provider we exported in the previous example.
main.tsFind your bootstrap configuration (should be in , but your mileage may vary).

Section 18.6: Configuring router-outlet
Now that the router is configured and our app knows how to handle the routes, we need to show the actual components that we configured.
To do so, configure your HTML template/file for your top-level (app) component like so:

<router-outlet></router-outletThe > element will switch the content given the route. Another good aspect about this element is that it does not have to be the only element in your HTML.
<router-outletFor example: Lets say you wanted a a toolbar on every page that stays constant between routes, similar to how Stack Overflow looks. You can nest the > under elements so that only certain parts of the page change.
Section 18.7: Changing routes (using templates & directives)
Now that the routes are set up, we need some way to actually change routes.
This example will show how to change routes using the template, but it is possible to change routes in TypeScript.
Here is one example (without binding):

home. The router knows how to handle /homeIf the user clicks on that link, it will route to /, so it will display the Home Component.
Here is an example with data binding:

app.tsWhich would require an array called links to exist, so add this to :

<aThis will loop through the array and add an > element with the routerLink directive = the value of the current element in the array, creating this:

This is particularly helpful if you have a lot of links, or maybe the links need to be constantly changed. We let Angular handle the busy work of adding links by just feeding it the info it requires.
linksRight now, [] is static, but it is possible to feed it data from another source.
Section 18.8: Setting the Routes
NOTE: This example is based on the 3.0.0.-beta.2 release of the @angular/router. At the time of writing, this is the latest version of the router.
To use the router, define routes in a new TypeScript file like such

In the first line, we import provideRouter so we can let our application know what the routes are during the bootstrap phase.
Home and Profile are just two components as an example. You will need to import each Component you need as a route.
Then, export the array of routes. path: The path to the component. YOU DO NOT NEED TO USE '/........' Angular will do this automatically component: The component to load when the route is accessed redirectTo: Optional. If you need to automatically redirect a user when they access a particular route, supply this.
Finally, we export the configured router. provideRouter will return a provider that we can boostrap so our application knows how to handle each route.

Chapter 19: Dynamically add components using ViewContainerRef.createComponent
Section 19.1: A wrapper component that adds dynamic components declaratively
A custom component that takes the type of a component as input and creates an instance of that component type inside itself. When the input is updated, the previously added dynamic component is removed and the new one added instead.

This allows you to create dynamic components like

Plunker example
Section 19.2: Dynamically add component on specific event(click)
Main Component File:

childComp.ts :

app.module.ts :

Plunker example
Section 19.3: Rendered dynamically created component array on template HTML in Angular 2
We can create dynamic component and get the instances of component into an array and finally rendered it on template.
For example, we can can consider two widget component, ChartWidget and PatientWidget which extended the class WidgetComponent that I wanted to add in the container. ChartWidget.ts

chart-widget.compoment.html (using primeng Panel)
<p-panel [style]="{'margin-bottom':'20px'}">
    <p-header>
        <div class="ui-helper-clearfix">
           <span class="ui-panel-title" style="font-size:14px;display:inline-block;margintop:2px">Chart Widget</span>
            <div class="ui-toolbar-group-right">                
               <button pButton type="button" icon="fa-window-minimize"
(click)="minimize()"</button>
              <button pButton type="button" icon="fa-refresh" (click)="refresh()"></button>               <button pButton type="button"  icon="fa-expand" (click)="expand()" ></button>
             <button pButton type="button" (click)="close()" icon="fa-window-close"></button>
                    </div>
                </div>     </p-header>       some data

DataWidget.ts

data-widget.compoment.html (same as chart-widget using primeng Panel) WidgetComponent.ts

we can creat dynamic component instances by selecting the pre-existing components. For example,

Finally we use it in app component. app.component.ts


app.component.html

https://plnkr.co/edit/lugU2pPsSBd3XhPHiUP1?p=preview Some modification by @yurzui to use mouse event on the widgets view.directive.ts import { ViewRef, Directive, Input, ViewContainerRef } from '@angular/core';


app.component.ts

app.component.html

https://plnkr.co/edit/JHpIHR43SvJd0OxJVMfV?p=preview

Chapter 20: Installing 3rd party plugins with angular-cli@1.0.0-beta.10
Section 20.1: Add 3rd party library that does not have typings
		Notice, this is only for angular-cli up to 1.0.0-beta.10 version !
Some libraries or plugins may not have typings. Without these, TypeScript can't type check them and therefore causes compilation errors. These libraries can still be used but differently than imported modules.
index.html1. Include a script reference to the library on your page ()
<script src="//cdn.somewhe.re/lib.min.js" type="text/javascript"></script>
<script src="/local/path/to/lib.min.js" type="text/javascript"></script>
These scripts should add a global (eg. THREE, mapbox, $, etc.) or attach to a global
2. In the component that requires these, use declare to initialize a variable matching the global name used by the lib. This lets TypeScript know that it has already been initialized. 1

Some libs attach to window, which would need to be extended in order to be accessible in the app.

3. Use the lib in your components as needed.

Section 20.2: Adding jquery library in angular-cli project


2. Add jquery to angular-cli-build.js file to vendorNpmFiles array:
This is required so the build system will pick up the file. After setup the angular-cli-build.js should look like this:

3. Configure SystemJS mappings to know where to look for jquery :
SystemJS configuration is located in system-config.ts and after the custom configuration is done the related section should look like:


or
 <script src="/vendor/jquery/dist/jquery.slim.js" type="text/javascript"></script> and
<script src="/vendor/jquery/dist/jquery.slim.min.js" type="text/javascript"></script>
5. Importing and using jquery library in your project source files:
Import jquery library in your source .ts files like this:

If you followed the steps correctly you should now have jquery library working in your project. Enjoy!

Chapter 21: Lifecycle Hooks
Section 21.1: OnChanges
Fired when one or more of the component or directive properties have been changed.

On change event will log

Section 21.2: OnInit
Fired when component or directive properties have been initialized.
(Before those of the child directives)

Section 21.3: OnDestroy
Fired when the component or directive instance is destroyed.

Section 21.4: AfterContentInit
Fire after the initialization of the content of the component or directive has finished.
(Right after OnInit)

Section 21.5: AfterContentChecked
Fire after the view has been fully initialized.
(Only available for components)

Section 21.6: AfterViewInit
Fires after initializing both the component view and any of its child views. This is a useful lifecycle hook for plugins outside of the Angular 2 ecosystem. For example, you could use this method to initialize a jQuery date picker based on the markup that Angular 2 has rendered.

Section 21.7: AfterViewChecked
Fire after the check of the view, of the component, has finished.
(Only available for components)

Section 21.8: DoCheck
Allows to listen for changes only on specified properties



Chapter 22: Angular RXJS Subjects and Observables with API requests
Section 22.1: Wait for multiple requests
One common scenario is to wait for a number of requests to finish before continuing. This can be accomplished using the forkJoin method.
.subscribe method will be called when both Observables complete. The parameters supplied by .subscribe.forkJoinIn the following example, forkJoin is used to call two methods that return Observables. The callback specified in the match the order given in the call to . In this case, first posts then tags.

Section 22.2: Basic request
http.get()The following example demonstrates a simple HTTP GET request.  returns an Observable which has the method subscribe. This one appends the returned data to the posts array.

Section 22.3: Encapsulating API requests
http.get() method and calls .mapIt may be a good idea to encapsulate the HTTP handling logic in its own class. The following class exposes a method for getting Posts. It calls the  on the returned Observable to convert the Response object to a Post object.


The previous example uses a Post class to hold the returned data, which could look as follows:

A component now can use the BlogApi class to easily retrieve Post data without concerning itself with the workings of the Http class.

Chapter 23: Services and Dependency Injection
Section 23.1: Example service
services/my.service.ts

The service provider registration in the bootstrap method will make the service available globally. main.ts

In version RC5 global service provider registration can be done inside the module file. In order to get a single instance of your service for your whole application the service should be declared in the providers list in the ngmodule of your application. app_module.ts

components/my.component.ts
Alternative approach to register application providers in application components. If we add providers at component level whenever the component is rendered it will create a new instance of the service.

Section 23.2: Example with Promise.resolve
services/my.service.ts

getData() now acts likes a REST call that creates a Promise, which gets resolved immediately. The results can be
thenhandheld inside .() and errors can also be detected. This is good practice and convention for asynchronous methods.
components/my.component.ts

Section 23.3: Testing a Service
Given a service that can login a user:

It can be tested like this:


          new Response(             new ResponseOptions({               body: {                 accessToken: 'abcdef',
              },
            }),
          ),
        );       });       const result = await authService.signIn({ password: 'ok', user: 'bruno' });
      expect(result).toEqual({         accessToken: 'abcdef',
      });
    }))
  );
  // Alternative 2   it('should login user if right credentials are passed', async () => {     const backend: MockBackend = TestBed.get(ConnectionBackend);     const http: Http = TestBed.get(Http);
    backend.connections.subscribe((c: MockConnection) => {
      c.mockRespond(         new Response(           new ResponseOptions({             body: {               accessToken: 'abcdef',
            },
          }),
        ),
      );     });     const authService: AuthService = TestBed.get(AuthService);     const result = await authService.signIn({ password: 'ok', user: 'bruno' });
    expect(result).toEqual({       accessToken: 'abcdef',
    });
  });
  // Alternative 3   it('should login user if right credentials are passed', async (done) => {     const authService: AuthService = TestBed.get(AuthService);
    const backend: MockBackend = TestBed.get(ConnectionBackend);     const http: Http = TestBed.get(Http);
    backend.connections.subscribe((c: MockConnection) => {
      c.mockRespond(         new Response(           new ResponseOptions({             body: {               accessToken: 'abcdef',
            },
          }),
        ),
      );
    });

Chapter 24: Service Worker
We will see how to set up a service working on angular, to allow our web app to have offline capabilities.
A Service worker is a special script which runs in the background in the browser and manages network requests to a given origin. It's originally installed by an app and stays resident on the user's machine/device. It's activated by the browser when a page from its origin is loaded and has the option to respond to HTTP requests during the page loading
Section 24.1: Add Service Worker to our app
First in case you are consulting mobile.angular.io the flag --mobile doesn't work anymore.
So to start , we can create a normal project with angular cli.

Now the important thing, to said to angular cli that we want to use service worker we need to do: ng set apps.0.serviceWorker=true
If for some reason you don't have @angular/service-worker installed, you will see a message:
npm install --save-dev @angular/service-worker and try again, or run ng setapps.0.serviceWorker=falseYour project is configured with serviceWorker = true, but @angular/service-worker is not installed. Run
 in your .angular-cli.json.
Check the .angular-cli.json and you now should see this: "serviceWorker": true
When this flag is true, production builds will be set up with a service worker.
A ngsw-manifest.json file will be generated (or augmented in case we have create a ngsw-manifest.json in the root of the project, usually this is done to specify the routing ,in a future this will probably be done automatic) in the dist/ root, and the service worker script will be copied there. A short script will be added to index.html to register the service worker.
Now if we build the app in production mode ng build --prod
And check dist/ folder.
You will see three new files there :
worker-basic.min.js sw-register.HASH.bundle.js ngsw-manifest.json
Also, index.html now includes this sw-register script, which registers a Angular Service Worker (ASW) for us.
Refresh the page in your browser (served by the Web Server for Chrome)
Open Developer Tools. Go to the Application -> Service Workers

Good now the Service Worker is up and running!
Now our application, should load faster and we should be able to use the app offline.
Now if you enable the offline mode in the chrome console , you should see that our app in http://localhost:4200/index.html is working without connection to internet.
But in http://localhost:4200/ we have a problem and it doesn't load, this is due to the static content cache only serves files listed in the manifest.
For example, if the manifest declares a URL of /index.html, requests to /index.html will be answered by the cache, but a request to / or /some/route will go to the network.
That's where the route redirection plugin comes in. It reads a routing config from the manifest and redirects configured routes to a specified index route.
Currently, this section of configuration must be hand-written (19-7-2017). Eventually, it will be generated from the route configuration present in the application source.
So if now we create or ngsw-manifest.json in the root of the project

And we build again our app, now when we go to http://localhost:4200/, we should be redirected to http://localhost:4200/index.html.
For further information about routing read the official documentation here
Here you can find more documentation about service workers: https://developers.google.com/web/fundamentals/getting-started/primers/service-workers https://docs.google.com/document/d/19S5ozevWighny788nI99worpcIMDnwWVmaJDGf_RoDY/edit#
And here you can see an alternative way to implement the service working using SW precache library : https://coryrylan.com/blog/fast-offline-angular-apps-with-service-workers

Chapter 25: EventEmitter Service
Section 25.1: Catching the event
Create a service-

Create a component to use the service-

Section 25.2: Live example
A live example for this can be found here.
Section 25.3: Class Component

Section 25.4: Class Overview

Section 25.5: Emmiting Events

Chapter 26: Optimizing rendering using ChangeDetectionStrategy
Section 26.1: Default vs OnPush
Consider the following component with one input myInput and an internal value called someInternalValue. Both of them are used in a component's template.

changeDetection:By default, the  property in the component decorator will be set to
ChangeDetectionStrategy.Default; implicit in the example. In this situation, any changes to any of the values in
the template will trigger a re-render of MyComponent. In other words, if I change myInput or someInternalValue angular 2 will exert energy and re-render the component.
Suppose, however, that we only want to re-render when the inputs change. Consider the following component with
changeDetection: set to ChangeDetectionStrategy.OnPush
changeDetection: to ChangeDetectionStrategy.OnPushBy setting , MyComponent will only re-render when its inputs change. In this case, myInput will need to receive a new value from its parent to trigger a re-render.
Chapter 27: Angular 2 Forms Update
Section 27.1: Angular 2 : Template Driven Forms

Section 27.2: Angular 2 Form - Custom Email/Password Validation
For live demo click..
App index ts

Custom validator


Form Components ts

Form Components HTML


Section 27.3: Simple Password Change Form with Multi Control Validation
The below examples use the new form API introduced in RC3.
pw-change.template.html



pw-validators.ts

A gist including some bootstrap classes can be found here.
Section 27.4: Angular 2 Forms ( Reactive Forms ) with registration form and confirm password validation
app.module.ts
Add these into your app.module.ts file to use reactive forms


app.component.ts

app.component.html

   <input type="text" placeholder="Enter username" formControlName="username" />
   <input type="text" placeholder="Enter Email Address" formControlName="email"/>
   <input type="password" placeholder="Enter Password" formControlName="password" />    <input type="password" placeholder="Confirm Password" name="password2" formControlName="password2"/>
   <div class='error' *ngIf="addForm.controls.password2.touched">
    <div class="alert-danger errormessageadduser" *ngIf="addForm.hasError('mismatchedPasswords')">
                                 Passwords do not match
  </div>
</div>
<select name="Role" formControlName="role">
    <option value="admin" >Admin</option>
    <option value="Accounts">Accounts</option>
    <option value="guest">Guest</option>
</select>
<br/>
<br/>
<button type="submit" (click)="addUser()"><span><i class="fa fa-user-plus" ariahidden="true"></i></span> Add User </button> </form>
</div>
validators.ts

Section 27.5: Angular 2: Reactive Forms (a.k.a Model-driven Forms)
This example uses Angular 2.0.0 Final Release registration-form.component.ts

registration-form.html

Section 27.6: Angular 2 - Form Builder
FormComponent.ts

form.component.html



Chapter 28: Detecting resize events
Section 28.1: A component listening in on the window resize event
Suppose we have a component which will hide at a certain window width.

window:resizeA p tag in our template will hide whenever visible is false. visible will change value whenever the onResize event handler is invoked. Its call occurs every time  fires an event.
Chapter 29: Testing ngModel
Is a example for how you can test a component in Angular2 that have a ngModel.
Section 29.1: Basic test



Chapter 30: Feature Modules
Section 30.1: A Feature Module

app.module.tsNow, in your root (usually ):

Chapter 31: Bootstrap Empty module in angular 2
Section 31.1: An empty module

This is an empty module containing no declarations, imports, providers, or components to bootstrap. Use this a reference.
Section 31.2: Application Root Module

Section 31.3: Bootstrapping your module

In this example, MyModule is the module containing your root component. By bootstrapping MyModule your Angular 2 app is ready to go.
Section 31.4: A module with networking on the web browser


MyRootComponent is the root component packaged in MyModule. It is the entry point to your Angular 2 application.
Section 31.5: Static bootstrapping with factory classes
We can statically bootstrap an application by taking the plain ES5 Javascript output of the generated factory classes. Then we can use that output to bootstrap the application:

This will cause the application bundle to be much smaller, because all the template compilation was already done in a build step, using either ngc or calling its internals directly.

Chapter 32: Lazy loading a module
Section 32.1: Lazy loading example
Lazy loading modules helps us decrease the startup time. With lazy loading our application does not need to load everything at once, it only needs to load what the user expects to see when the app first loads. Modules that are lazily loaded will only be loaded when the user navigates to their routes. app/app.module.ts

app/app.component.ts

app/app.routing.ts
import { ModuleWithProviders } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { EagerComponent } from './eager.component'; const routes: Routes = [
  { path: '', redirectTo: 'eager', pathMatch: 'full' },
  { path: 'eager', component: EagerComponent },
  { path: 'lazy', loadChildren: './lazy.module' } ];
 export const routing: ModuleWithProviders = RouterModule.forRoot(routes); app/eager.component.ts


There's nothing special about LazyModule other than it has its own routing and a component called LazyComponent (but it's not necessary to name your module or simliar so).
app/lazy.module.ts

app/lazy.routing.ts

app/lazy.component.ts

Chapter 33: Advanced Component Examples
Section 33.1: Image Picker with Preview
In this example, we are going to create an image picker that previews your picture before uploading. The previewer also supports drag and dropping files into the input. In this example, I am only going to cover uploading single files, but you can tinker a bit to get multi file upload working.
image-preview.html
This is the html layout of our image preview
<!-- Icon as placeholder when no file picked -->
<i class="material-icons">cloud_upload</i>
<!-- file input, accepts images only. Detect when file has been picked/changed with Angular's native
(change) event listener -->
<input type="file" accept="image/*" (change)="updateSource($event)">
 <!-- img placeholder when a file has been picked. shows only when 'source' is not empty --> <img *ngIf="source" [src]="source" src=""> image-preview.ts
<image-preview>This is the main file for our  component


another.component.html

And that's it. Way more easier than it was in AngularJS 1.x. I actually made this component based on an older version I made in AngularJS 1.5.5.
Section 33.2: Filter out table values by the input



Chapter 34: Bypassing Sanitizing for trusted values
	Params	Details
<selector>selector	tag name you reference your component by in the html a string that represents html which will be inserted wherever the  tag is. template(templateUrl)
templateUrl is a path to an html file with the same behavior
pipes	an array of pipes that are used by this component.
Section 34.1: Bypassing Sanitizing with pipes (for code re-use)
Project is following the structure from the Angular2 Quickstart guide here.

This finds the index.html file in the root of the project, and builds off of that.

This is the top level component that groups other components that are used.
		pipeUser.component.ts

This component provides the view for the Pipe to work with.



If you were to inspect the html while the app is running you would see that it looks like this:

Chapter 35: Angular 2 Data Driven Forms
Section 35.1: Data driven form
Component

function customValidator(control: Control): {[s: string]: boolean} {   if(!control.value.match("[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[az0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?")) {     return {error: true}   }
}
HTML Markup

Chapter 36: Angular 2 In Memory Web API
Section 36.1: Setting Up Multiple Test API Routes
mock-data.ts

Now, you can interact with both app/mock and app/data to extract their corresponding data.
Section 36.2: Basic Setup
mock-data.ts
Create the mock api data

main.ts
Have the dependency injector provide the InMemoryBackendService for XHRBackend requests. Also, provide a class that includes a createDb() function (in this case, MockData) specifying the mocked API routes for SEED_DATA requests.
import { XHRBackend, HTTP_PROVIDERS } from '@angular/http'; import { InMemoryBackendService, SEED_DATA } from 'angular2-in-memory-web-api'; import { MockData } from './mock-data'; import { bootstrap } from '@angular/platform-browser-dynamic'; import { AppComponent } from './app.component';

mock.service.ts
Example of calling a get request for the created API route

Chapter 37: Ahead-of-time (AOT) compilation with Angular 2
Section 37.1: Why we need compilation, Flow of events compilation and example?
Q. Why we need compilation? Ans. We need compilation for achieving higher level of efficiency of our Angular applications.
Take a look at the following example,

Using the code above to render the template,

Is much slower compared to:
// ... this._text_9 = this.renderer.createText(this._el_3, '\n', null); this._text_10 = this.renderer.createText(parentRenderNode, '\n\n', null); this._el_11 = this.renderer.createElement(parentRenderNode, 'ul', null); this._text_12 = this.renderer.createText(this._el_11, '\n  ', null); this._anchor_13 = this.renderer.createTemplateAnchor(this._el_11, null); this._appEl_13 = new import2.AppElement(13, 11, this, this._anchor_13); this._TemplateRef_13_5 = new import17.TemplateRef_(this._appEl_13, viewFactory_HomeComponent1); this._NgFor_13_6 = new import15.NgFor(this._appEl_13.vcRef, this._TemplateRef_13_5, this.parentInjector.get(import18.IterableDiffers), this.ref); // ...
Flow of events with Ahead-of-Time Compilation In contrast, with AoT we get through the following steps:
1. Development of Angular 2 application with TypeScript.
2. Compilation of the application with ngc.
3. Performs compilation of the templates with the Angular compiler to TypeScript.
4. Compilation of the TypeScript code to JavaScript.
5. Bundling.
6. Minification.
7. Deployment.
Although the above process seems lightly more complicated the user goes only through the steps:
1. Download all the assets.
2. Angular bootstraps.
3. The application gets rendered.
As you can see the third step is missing which means faster/better UX and on top of that tools like angular2-seed and angular-cli will automate the build process dramatically.
I hope it might help you! Thank you!
Section 37.2: Using AoT Compilation with Angular CLI
The Angular CLI command-line interface has AoT compilation support since beta 17.
To build your app with AoT compilation, simply run:

Section 37.3: Install Angular 2 dependencies with compiler
NOTE: for best results, make sure your project was created using the Angular-CLI.
npm install angular/{core,common,compiler,platform-browser,platform-browserdynamic,http,router,forms,compiler-cli,tsc-wrapped,platform-server}
You don't have to do this step if you project already has angular 2 and all of these dependencies installed. Just make sure that the compiler is in there.
Section 37.4: Add `angularCompilerOptions` to your `tsconfig.json` file

This is the output folder of the compiler.
Section 37.5: Run ngc, the angular compiler
node_modules/.bin/ngc -p srcfrom the root of your project ./ where src is where all your angular 2 code lives.
This will generate a folder called ngfactory where all your compiled code will live.
"node_modules/.bin/ngc" -p src for windows
Section 37.6: Modify `main.ts` file to use NgFactory and static platform browser
// this is the static platform browser, the usual counterpart is @angular/platform-browser-dynamic. import { platformBrowser } from '@angular/platform-browser';
// this is generated by the angular compiler import { AppModuleNgFactory } from './ngfactory/app/app.module.ngfactory';
// note the use of `bootstrapModuleFactory`, as opposed to `bootstrapModule`. platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);
At this point you should be able to run your project. In this case, my project was created using the Angular-CLI.


Chapter 38: CRUD in Angular 2 with Restful API
Section 38.1: Read from an Restful API in Angular 2
To separate API logic from the component, we are creating the API client as a separate class. This example class makes a request to Wikipedia API to get random wiki articles.

And have a component to consume our new API client.

Chapter 39: Use native webcomponents in Angular 2
Section 39.1: Include custom elements schema in your module

Section 39.2: Use your webcomponent in a template


Chapter 40: Update typings
Section 40.1: Update typings when: typings WARN deprecated
Warning message:
typings WARN deprecated 10/25/2016: "registry:dt/jasmine#2.5.0+20161003201800" is deprecated
(updated, replaced or removed)
Update the reference with:
npm run typings -- install dt~jasmine --save --global
Replace [jazmine] for any library that is throwing warning

Chapter 41: Mocking @ngrx/Store
	name	description
value	next value to be observed error	description err	error to be thrown super	description
action$	mock Observer that does nothing unless defined to do so in the mock class actionReducer$ mock Observer that does nothing unless defined to do so in the mock class obs$	mock Observable
@ngrx/Store is becoming more widely used in Angular 2 projects. As such, the Store is required to be injected into the constructor of any Component or Service that wishes to use it. Unit testing Store isn't as easy as testing a simple service though. As with many problems, there are a myriad of ways to implement solutions. However, the basic recipe is to write a mock class for the Observer interface and to write a mock class for Store. Then you can inject Store as a provider in your TestBed.
Section 41.1: Unit Test For Component With Mock Store
This is a unit test of a component that has Store as a dependency. Here, we are creating a new class called MockStore that is injected into our component instead of the usual Store.


Section 41.2: Angular 2 - Mock Observable ( service + component )






Section 41.3: Observer Mock

Section 41.4: Unit Test For Component Spying On Store
This is a unit test of a component that has Store as a dependency. Here, we are able to use a store with the default "initial state" while preventing it from actually dispatching actions when store.dispatch() is called.


Section 41.5: Simple Store
simple.action.ts

simple.efficts.ts


simple.reducer.ts

store/index.ts

app.module.ts


app.component.ts

result 0 1 3 6
Chapter 42: ngrx
Ngrx is a powerful library that you can use with Angular2. The idea behind is to merge two concepts that plays well together to have a reactive app with a predictable state container : - [Redux][1] - [RxJs][2] The main advantages : Sharing data in your app between your components is going to easier - Testing your app core logic consists to test pure functions, without any dependency on Angular2 (very easy so !) [1]: http://redux.js.org [2]: http://reactivex.io/rxjs
Section 42.1: Complete example : Login/logout a user
Prerequisites
This topic is not about Redux and/or Ngrx :
You need to be comfortable with Redux
At least understand the basics of RxJs and Observable pattern
First, let's define an example from the very beginning and play with some code :
As a developer, I want to :
1. Have an IUser interface that defines the properties of a User
2. Declare the actions that we'll use later to manipulate the User in the Store
3. Define the initial state of the UserReducer
4. Create the reducer UserReducer
5. Import our UserReducer into our main module to build the Store
6. Use data from the Store to display information in our view
Spoiler alert : If you want to try the demo right away or read the code before we even get started, here's a Plunkr (embed view or run view).
1) Define IUser interface
I like to split my interfaces in two parts :
The properties we'll get from a server
The properties we define only for the UI (should a button be spinning for example)
And here's the interface IUser we'll be using :
user.interface.ts
Now we've got to think about what kind of actions our reducers are supposed to handle. Let say here :
user.actions.ts
But before we use those actions, let me explain why we're going to need a service to dispatch some of those actions for us :
Let say that we want to connect a user. So we'll be clicking on a login button and here's what's going to happen :
userService.loginuserService.login method dispatch an event to update our store property : user.isConnectingClick on the button
The component catch the event and call 
An HTTP call is fired (we'll use a setTimeout in the demo to simulate the async behaviour)
Once the HTTP call is finished, we'll dispatch another action to warn our store that a user is logged
user.service.ts

3) Define the initial state of the UserReducer
user.state.ts
A reducer takes 2 arguments :
Action<{type: string, payload: anyThe current state
An Action of type }>
Reminder : A reducer needs to be initialized at some point
As we defined the default state of our reducer in part 3), we'll be able to use it like that :
user.reducer.ts
Hopefully, there's an easier way to write that by using our factory function to return an object and within the reducer use an (ES6) default parameters value :

Object.assignThen, we need to handle every actions in our reducer : TIP: Use ES6  function to keep our state immutable
export const UserReducer: ActionReducer<IUser> = (user: IUser = UserFactory(), action: Action) => {   switch (action.type) {     case UserActions.USR_IS_CONNECTING:
      return Object.assign({}, user, { isConnecting: true });
    case UserActions.USR_IS_CONNECTED:       return Object.assign({}, user, { isConnecting: false, isConnected: true, username:

5) Import our UserReducer into our main module to build the Store
app.module.ts
6) Use data from the Store to display information in our view
Everything is now ready on logic side and we just have to display what we want in two components :
Input UserComponent: [Dumb component] We'll just pass the user object from the store using @	 property and async pipe. This way, the component will receive the user only once it's available (and the user will be of type
Observable<IUserIUser and not of type > !)
 LoginComponent [Smart component] We'll directly inject the Store into this component and work only on user as an Observable.
user.component.ts



As Ngrx is a merge of Redux and RxJs concepts, it can be quite hard to understand the ins an outs at the beginning. But this is a powerful pattern that allows you as we've seen in this example to have a reactive app and were you can easily share your data. Don't forget that there's a Plunkr available and you can fork it to make your own tests !
I hope it was helpful even tho the topic is quite long, cheers !
Chapter 43: Http Interceptor
Section 43.1: Using our class instead of Angular's Http
After extending the Http class, we need to tell angular to use this class instead of Http class.
In order to do this, in our main module(or depending on the needs, just a particular module), we need to write in the providers section:

Note: ApplicationConfiguration is just a service I use to hold some values for the duration of the application
Section 43.2: Simple Class Extending angular's Http class
import { Http, Request, RequestOptionsArgs, Response, RequestOptions, ConnectionBackend, Headers } from '@angular/http'; import { Router } from '@angular/router'; import { Observable } from 'rxjs/Observable'; import 'rxjs/add/observable/empty'; import 'rxjs/add/observable/throw'; import 'rxjs/add/operator/catch'; import { ApplicationConfiguration } from '../application-configuration/application-configuration';
/** * This class extends the Http class from angular and adds automaticaly the server URL(if in development mode) and 2 headers by default: * Headers added: 'Content-Type' and 'X-AUTH-TOKEN'. * 'Content-Type' can be set in any othe service, and if set, it will NOT be overwritten in this class any more. */ export class HttpServiceLayer extends Http {
  constructor(backend: ConnectionBackend, defaultOptions: RequestOptions, private _router: Router, private appConfig: ApplicationConfiguration) {

Section 43.3: Simple HttpClient AuthToken Interceptor (Angular 4.3+)
import { Injectable } from '@angular/core'; import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http'; import { UserService } from '../services/user.service'; import { Observable } from 'rxjs/Observable';

Providing Interceptor (some-module.module.ts)
{provide: HTTP_INTERCEPTORS, useClass: AuthHeaderInterceptor, multi: true},

Chapter 44: Animation
Section 44.1: Transition between null states

Section 44.2: Animating between multiple states
<div>The  in this template grows to 50px and then 100px and then shrinks back to 20px when you click the button.
@ComponentEach state has an associated style described in the  metadata.
The logic for whichever state is active can be managed in the component logic. In this case, the component variable size holds the string value "small", "medium" or "large".
<div> element respond to that value through the trigger specified in the @ComponentThe  metadata:
[@size]="size".



Chapter 45: Zone.js
Section 45.1: Getting reference to NgZone
NgZone reference can be injected via the Dependency Injection (DI). my.component.ts

Section 45.2: Using NgZone to do multiple HTTP requests before showing the data
runOutsideAngular can be used to run code outside Angular 2 so that it does not trigger change detection unnecessarily. This can be used to for example run multiple HTTP request to get all the data before rendering it. To execute code again inside Angular 2, run method of NgZone can be used.
my.component.ts

Chapter 46: Angular 2 Animations
Angular's animation system lets you build animations that run with the same kind of native performance found in pure CSS animations. You can also tightly integrate your animation logic with the rest of your application code, for ease of control.
Section 46.1: Basic Animation - Transitions an element between two states driven by a model attribute
app.component.html

app.component.ts



Chapter 47: Create an Angular 2+ NPM package
Sometimes we need to share some component between some apps and publishing it in npm is one of the best ways of doing this.
There are some tricks that we need to know to be able to use a normal component as npm package without changing the structure as inlining external styles.
You can see a minimal example here
Section 47.1: Simplest package
Here we are sharing some minimal workflow to build and publish an Angular 2+ npm package.
Configuration files
We need some config files to tell git, npm, gulp and typescript how to act.
.gitignore
gitignoreFirst we create a . file to avoid versioning unwanted files and folders. The content is:

.npmignore
npmignoreSecond we create a . file to avoid publishing unwanted files and folders. The content is:

gulpfile.js
gulpfile.jsWe need to create a  to tell Gulp how to compile our application. This part is necessary because we need to minimize and inline all the external templates and styles before publishing our package. The content is:

index.d.ts
index.d.tsThe  file is used by typescript when importing an external module. It helps editor with auto-completion and function tips.

index.js
This is the package entry point. When you install this package using NPM and import in your application, you just need to pass the package name and your application will learn where to find any EXPORTED component of your package. exports.AngularXMinimalNpmPackageModule = require('./lib').AngularXMinimalNpmPackageModule;
libWe used lib folder because when we compile our code, the output is placed inside / folder.
package.json
This file is used to configure your npm publication and defines the necessary packages to it to work.

dist/tsconfig.json
Create a dist folder and place this file inside. This file is used to tell Typescript how to compile your application. Where to to get the typescript folder and where to put the compiled files.

<angular-x-minimal-npm-package></angular-x-minimal-npm-After create the configuration files, we must create our component and module. This component receives a click and displays a message. It is used like a html tag 
package>. Just instal this npm package and load its module in the model you want to use it.
src/angular-x-minimal-npm-package.component.ts

src/angular-x-minimal-npm-package.component.html

src/angular-x-data-table.component.css



After that, you must compile, build and publish your package.
Build and compile
scripts.buildFor build we use gulp and for compiling we use tsc. The command are set in package.json file, at 
gulp js:build && rm -rf lib && tsc -p distoption. We have this set . This is our chain tasks that will do the job for us.
To build and compile, run the following command at the root of your package: npm run build
dist folder and the compiled package in your /libindex.js we exported the code from /lib folder and not from /srcThis will trigger the chain and you will end up with your build in / folder. This is why in .
Publish
Now we just need to publish our package so we can install it through npm. For that, just run the command: npm publish
That is all!!!

Chapter 48: Angular 2 CanActivate
Section 48.1: Angular 2 CanActivate
Implemented in a router:



Chapter 49: Angular 2 - Protractor
Section 49.1: Angular 2 Protractor - Installation
npm install -g protractorwebdriver-manager updatewebdriver-manager startrun the follows commands at cmd
     **create protractor.conf.js file in the main app root. very important to decleare useAllAngular2AppRoots: true


Section 49.2: Testing Navbar routing with Protractor
First lets create basic navbar.html with 3 options. (Home, List , Create)

second lets create navbar.e2e-spec.ts



Chapter 50: Example for routes such as /route/subroute for static urls
Section 50.1: Basic route example with sub routes tree
app.module.ts

app.routes.ts

subTreeRoutes.ts

Chapter 51: Angular 2 Input() output()
Section 51.1: Input()
Parent Component : Initialize users lists.

Child component get user from parent component with Input()


Section 51.2: Simple example of Input Properties
Parent element html

Parent element ts

Child component ts:

Child component html:

This code will send the inputPropValue from the parent component to the child and it will have the value we have set in the parent component when it arrives there - false in our case. We can then use that value in the child component to, for example add a class to an element.

Chapter 52: Angular-cli
Here you will find how to start with angular-cli , generating new component/service/pipe/module with angular-cli , add 3 party like bootstrap , build angular project.
Section 52.1: New project with scss/sass as stylesheet
@angular/cliThe default style files generated and compiled by  are css.
If you want to use scss instead, generate your project with:

If you want to use sass, generate your project with:

Section 52.2: Set yarn as default package manager for @angular/cli
Yarn is an alternative for npm, the default package manager on @angular/cli. If you want to use yarn as package manager for @angular/cli follow this steps:
Requirements
npm install --global yarnnpm install -g @angular/cli or yarn global add @angular/cliyarn ( or see the installation page)
@angular/cli ()
To set yarn as @angular/cli package manager:
ng set --global packageManager=yarn
To set back npm as @angular/cli package manager:
ng set --global packageManager=npm
Section 52.3: Create empty Angular 2 application with angular-cli
Requirements:
NodeJS : Download page npm or yarn
Run the following commands with cmd from new directory folder:
npm install -g @angular/cli or yarn global add @angular/cli1.
ng new PROJECT_NAME2.
cd PROJECT_NAME3.
4. ng serve
Open your browser at localhost:4200
Section 52.4: Generating Components, Directives, Pipes and Services
just use your cmd: You can use the ng generate (or just ng g) command to generate Angular components:
ng g component my-new-componentng g directive my-new-directiveng g pipe my-new-pipeng g service my-new-serviceng g class my-new-classtng g interface my-new-interfaceng g enum my-new-enumng g module my-moduleComponent: 
Directive: 
Pipe: 
Service: 
Class: 
Interface: 
Enum: 
 Module: 
 Section 52.5: Adding 3rd party libs
In angular-cli.json you can change the app configuration.
If you want to add ng2-bootstrap for example:
npm install ng2-bootstrap --save or yarn add ng2-bootstrap1.
2. In angular-cli.json just add the path of the bootstrap at node-modules.

Section 52.6: build with angular-cli
In angular-cli.json at outDir key you can define your build directory; these are equivalent

and so are these

When building you can modify base tag () in your index.html with --base-href your-url option.
Sets base tag href to /myUrl/ in your index.html

Chapter 53: Angular 2 Change detection and manual triggering
Section 53.1: Basic example
Parent component :

Parent HTML:

child component :


child HTML :

Chapter 54: Angular 2 Databinding
Section 54.1: @Input()
Parent Component : Initialize users lists.

Child component get user from parent component with Input()



Chapter 55: Brute Force Upgrading
If you want to upgrade the Angular CLI version of your project you may run into tough-to-fix errors and bugs from simply changing the Angular CLI version number in your project. Also, because the Angular CLI hides a lot of what's going on in the build and bundles process, you can't really do much when things go wrong there.
Sometimes the easiest way to update the Angular CLI version of the project is to just scaffold out a new proejct with the Angular CLI version that you wish to use.
Section 55.1: Scaolding a New Angular CLI Project

or


Chapter 56: Angular 2 provide external data to App before bootstrap
In this post I will demonstrate how to pass external data to Angular app before the app bootstraps. This external data could be configuration data, legacy data, server rendered etc.
Section 56.1: Via Dependency Injection
Instead of invoking the Angular's bootstrap code directly, wrap the bootstrap code into a function and export the function. This function can also accept parameters.

Then, in any services or components we can inject the "legacy model" and gain access to it.

Require the app and then run it.

Chapter 57: custom ngx-bootstrap datepicker + input
Section 57.1: custom ngx-bootstrap datepicker


  @Output() dateModelChange = new EventEmitter();   constructor(el: ElementRef) {     this.inputElement = el;   }
  changedDate(){     if(this.value === ''){       this.dateModelChange.emit(null);     }else if(this.value.split('/').length === 3){       this.dateModelChange.emit(DatepickerComponent.convertToDate(this.value));     }   }
  clickOutSide(event : Event){     if(this.inputElement.nativeElement !== event.target) {       console.log('click outside', event);     }   }
  onClick(event) {     if (!this.inputElement.nativeElement.contains(event.target)) {       this.close();     }   }   ngOnChanges(changes: SimpleChanges): void {     if (this.value !== null && this.value !== undefined && this.value.length > 0) {       this.value = null;       this.dt  = null;     }else {       if(this.value !== null){         this.dt = new Date(this.value);         this.value = moment(this.value).format('MM/DD/YYYY');
      }
    }   }
  private static transformDate(date: Date): string {     return new DatePipe('pt-PT').transform(date, 'MM/dd/yyyy');
  }
  openCloseDatepicker(): void {     if (!this.disabledDatePicker) {       this.showDatepicker = !this.showDatepicker;     }   }
  open(): void {     this.showDatepicker = true;   }
  close(): void {     this.showDatepicker = false;   }
  private apply(): void {     this.value = DatepickerComponent.transformDate(this.dt);     this.dateModelChange.emit(this.dt);   }
  onSelectionDone(event: Date): void {     this.dt = event;     this.apply();

Chapter 58: Using third party libraries like jQuery in Angular 2
When building applications using Angular 2.x there are times when it's required to use any third party libraries like jQuery, Google Analytics, Chat Integration JavaScript APIs and etc.
Section 58.1: Configuration using angular-cli
NPM
If external library like jQuery is installed using NPM
npm install --save jquery
angular-cli.jsonAdd script path into your 

Assets Folder
assets/js directory and include the same in angular-cli.jsonYou can also save the library file in your 

Note
jquery-cycle-pluginangular-cli.jsonSave your main library jquery and their dependencies like  into the assets directory and add both of them into , make sure the order is maintained for the dependencies.
Section 58.2: Using jQuery in Angular 2.x components
To use jquery in your Angular 2.x components, declare a global variable on the top If using $ for jQuery
declare var $: any;
If using jQuery for jQuery
declare var jQuery: any
This will allow using $ or jQuery into your Angular 2.x component.
Chapter 59: Configuring ASP.net Core application to work with Angular 2 and
TypeScript
SCENARIO: ASP.NET Core background Angular 2 Front-End Angular 2 Components using Asp.net Core Controllers
It way can implement Angular 2 over Asp.Net Core app. It let us call MVC Controllers from Angular 2 components too with the MVC result View supporting Angular 2.
Section 59.1: Asp.Net Core + Angular 2 + Gulp
Startup.cs


tsConfig.json


Package.json

bundleconfig.json


Convert bundleconfig.json to gulpfile (RightClick bundleconfig.json on solution explorer, Bundler&Minifier > Convert to Gulp
Views/Home/Index.cshtml

For wwwroot folder use https://github.com/angular/quickstart seed. You need: index.html main.ts, systemjsangular-loader.js, systemjs.config.js, tsconfig.json And the app folder wwwroot/Index.html

You can call as it to Controllers from templateUrl. wwwroot/app/app.component.ts


Section 59.2: [Seed] Asp.Net Core + Angular 2 + Gulp on Visual Studio 2017
1. Download seed
2. Run dotnet restore
3. Run npm install
Always. Enjoy.
https://github.com/SamML/CoreAngular000
Section 59.3: MVC <-> Angular 2
How to: CALL ANGULAR 2 HTML/JS COMPONENT FROM ASP.NET Core CONTROLLER:
We call the HTML instead return View()

And load angular component in the html. Here we can decide if we want to work with same or diferent module. Depends on situation. wwwroot/html/About.html

(*)Already this seed needs to load the entire list of resources
How to: CALL ASP.NET Core Controller to show a MVC View with Angular2 support:



Chapter 60: Angular 2 using webpack
Section 60.1: Angular 2 webpack setup
webpack.config.js


vendor.config.js


helpers.js

vendor.ts

index.html

package.json



Chapter 61: Angular material design
Section 61.1: Md2Accordion and Md2Collapse
Md2Collapse : Collapse is a directive, it's allow the user to toggle visiblity of the section.
Examples

Md2Accordion : Accordion it's allow the user to toggle visiblity of the multiple sections.
Examples

Section 61.2: Md2Select

Section 61.3: Md2Toast

Section 61.4: Md2Datepicker
Datepicker allow the user to select date and time.

see for more details here
Section 61.5: Md2Tooltip
Tooltip is a directive, it allows the user to show hint text while the user mouse hover over an element.

Chapter 62: Dropzone in Angular 2
Section 62.1: Dropzone
Angular 2 wrapper library for Dropzone.
		npm install angular2-dropzone-wrapper --save-dev


Chapter 63: angular redux
Section 63.1: Basic


Section 63.2: Get current state

Section 63.3: change state


Section 63.4: Add redux chrome tool

Chapter 64: Creating an Angular npm library
How to publish your NgModule, written in TypeScript in npm registry. Setting up npm project, typescript compiler, rollup and continous integration build.
Section 64.1: Minimal module with service class

src/awesome.service.ts:

src/awesome.module.ts:

Make your module and service accessible outside.
/index.ts:
export { AwesomeService } from './src/awesome.service'; export { AnotherAwesomeService } from './src/another-awesome.service'; export { AwesomeModule } from './src/awesome.module';
Compilation
In compilerOptions.paths you need to specify all external modules which you used in your package. /tsconfig.json

Specify your externals again
/rollup.config.js

NPM settings
Now, lets place some instructions for npm
/package.json

We can also specify what files, npm should ignore
/.npmignore


Continuous integration
Finally you can set up continuous integration build
.travis.yml

Demo can be found here: https://github.com/maciejtreder/awesome-angular-module

Chapter 65: Barrel
A barrel is a way to rollup exports from several ES2015 modules into a single convenience ES2015 module. The barrel itself is an ES2015 module file that re-exports selected exports of other ES2015 modules.
Section 65.1: Using Barrel
For example without a barrel, a consumer would need three import statements:
import { HeroComponent } from '../heroes/hero.component.ts';                                import { Hero }          from '../heroes/hero.model.ts';                                      import { HeroService }   from '../heroes/hero.service.ts';
We can add a barrel by creating a file in the same component folder. In this case the folder is called 'heroes' named index.ts (using the conventions) that exports all of these items:
export * from './hero.model.ts';   // re-export all of its exports export * from './hero.service.ts'; // re-export all of its exports                          export { HeroComponent } from './hero.component.ts'; // re-export the named thing
Now a consumer can import what it needs from the barrel.
import { Hero, HeroService } from '../heroes/index';
Still, this can become a very long line; which could be reduced further.

 as hThat's pretty reduced! The * imports all of the modules and aliases as h
Chapter 66: Testing an Angular 2 App
Section 66.1: Setting up testing with Gulp, Webpack, Karma and Jasmine
The first thing we need is to tell karma to use Webpack to read our tests, under a configuration we set for the webpack engine. Here, I am using babel because I write my code in ES6, you can change that for other flavors, such as Typescript. Or I use Pug (formerly Jade) templates, you don't have to.
Still, the strategy remains the same.
So, this is a webpack config:

And then, we need a karma.config.js file to use that webpack config:


So far, we have told Karma to use webpack, and we have told it to start at a file called karma.shim.js. this file will have the job of acting as the starting point for webpack. webpack will read this file and use the import and require statements to gather all our dependencies and run our tests.
So now, let's look at the karma.shim.js file:


In essence, we are importing TestBed from angular core testing, and initiating the environment, as it needs to be initiated only once for all of our tests. Then, we are going through the src/app directory recursively and reading every file that ends with .spec.js and feed them to testContext, so they will run.
I usually try to put my tests the same place as the class. Personat taste, it makes it easier for me to import dependencies and refactor tests with classes. But if you want to put your tests somewhere else, like under src/test directory for example, here is you chance. change the line before last in the karma.shim.js file.
Perfect. what is left? ah, the gulp task that uses the karma.config.js file we made above:

I am now starting the server with the config file we created, telling it to run once and don't watch for changes. I find this to suite me better as the tests will run only if I am ready for them to run, but of course if you want different you know where to change.
And as my final code sample, here is a set of tests for the Angular 2 tutorial, "Tour of Heroes".

        });     }));
    it("Should have an array of heros", async(()=>         this.fixture.whenStable().then(()=> {             const cmp = this.fixture.componentInstance;             expect(cmp.heroes).toBeDefined("component should have a list of heroes");             expect(cmp.heroes.length).toEqual(10, "heroes list should have 10 members");             cmp.heroes.map((h, i)=> {                 expect(h instanceof Hero).toBeTruthy(`member ${i} is not a Hero instance. ${h}`)             });         })));
        it("Should have one list item per hero", async(()=>         this.fixture.whenStable().then(()=> {             const ul = this.fixture.nativeElement.querySelector("ul.heroes");             const li = Array.prototype.slice.call(                 this.fixture.nativeElement.querySelectorAll("ul.heroes>li"));             const cmp = this.fixture.componentInstance;             expect(ul).toBeTruthy("There should be an unnumbered list for heroes");             expect(li.length).toEqual(cmp.heroes.length, "there should be one li for each hero");             li.forEach((li, i)=> {                 expect(li.querySelector("span.badge"))                     .toBeTruthy(`hero ${i} has to have a span for id`);                 expect(li.querySelector("span.badge").textContent.trim())                     .toEqual(cmp.heroes[i].id.toString(), `hero ${i} had wrong id displayed`);                 expect(li.textContent)                     .toMatch(cmp.heroes[i].name, `hero ${i} has wrong name displayed`);
            });         })));
    it("should have correct styling of hero items", async(()=>         this.fixture.whenStable().then(()=> {             const hero = this.fixture.nativeElement.querySelector("ul.heroes>li");             const win = hero.ownerDocument.defaultView ||hero.ownerDocument.parentWindow;             const styles = win.getComputedStyle(hero);             expect(styles["cursor"]).toEqual("pointer", "cursor should be pointer on hero");             expect(styles["borderRadius"]).toEqual("4px", "borderRadius should be 4px");         })));
    it("should have a click handler for hero items",async(()=>         this.fixture.whenStable().then(()=>{             const cmp = this.fixture.componentInstance;             expect(cmp.onSelect)
                .toBeDefined("should have a click handler for heros");             expect(this.fixture.nativeElement.querySelector("input.heroName"))
                .toBeNull("should not show the hero details when no hero has been selected");             expect(this.fixture.nativeElement.querySelector("ul.heroes li.selected"))
                .toBeNull("Should not have any selected heroes at start");
            spyOn(cmp,"onSelect").and.callThrough();             this.fixture.nativeElement.querySelectorAll("ul.heroes li")[5].click();
            expect(cmp.onSelect)                 .toHaveBeenCalledWith(cmp.heroes[5]);             expect(cmp.selectedHero)                 .toEqual(cmp.heroes[5], "click on hero should change hero");
        })
    ));
});
Noteworthy in this is how we have beforeEach() configure a test module and create the component in test, and how we call detectChanges() so that angular actually goes through the double-binding and all.
Notice that each test is a call to async() and it always waits for whenStable promise to resolve before examining the fixture. It then has access to the component through componentInstance and to the element through nativeElement.
There is one test which is checking the correct styling. as part of the Tutorial, Angular team demonstrates use of styles inside components. In our test, we use getComputedStyle() to check that styles are coming from where we specified, however we need the Window object for that, and we are getting it from the element as you can see in the test.
Section 66.2: Installing the Jasmine testing framework
The most common way to test Angular 2 apps is with the Jasmine test framework. Jasmine allows you to test your code in the browser.
Install
jasmine-coreTo get started, all you need is the  package (not jasmine).

Verify
src/unit-tests.htmlTo verify that Jasmine is set up properly, create the file ./ with the following content and open it in the browser.

Section 66.3: Testing Http Service
Usually, services call remote Api to retrieve/send data. But unit tests shouldn't do network calls. Angular internally uses XHRBackend class to do http requests. User can override this to change behavior. Angular testing module provides MockBackend and MockConnection classes which can be used to test and assert http requests.
posts.service.ts This service hits an api endpoint to fetch list of posts.


posts.service.spec.ts Here, we will test above service by mocking http api calls.


Section 66.4: Testing Angular Components - Basic
The component code is given as below.


angular/core/testingFor angular testing, angular provide its testing utilities along with the testing framework which helps in writing the good test case in angular. Angular utilities can be imported from @

In the above example, there is only one test case which explain the test case for component existence. In the above example angular testing utilities like TestBed and ComponentFixture are used.
TestBed is used to create the angular testing module and we configure this module with the configureTestingModule method to produce the module environment for the class we want to test. Testing module to be configured before the execution of every test case that's why we configure the testing module in the beforeEach function. createComponent method of TestBed is used to create the instance of the component under test. createComponent return the ComponentFixture. The fixture provides access to the component instance itself.
Chapter 67: angular-cli test coverage
test coverage is defined as a technique which determines whether our test cases are actually covering the application code and how much code is exercised when we run those test cases.
Angular CLI has built in code coverage feature with just a simple command ng test --cc
Section 67.1: A simple angular-cli command base test coverage
If you want to see overall test coverage statistics than of course in Angular CLI you can just type below command, and see the bottom of your command prompt window for results.


Section 67.2: Detailed individual component base graphical test coverage reporting
if you want to see component's individual coverage of tests follow these steps.
npm install --save-dev karma-teamcity-reporter1.
2. Add `require('karma-teamcity-reporter')` to list of plugins in karma.conf.js
ng test --code-coverage --reporters=teamcity,coverage-istanbul3.
note that list of reporters is comma-separated, as we have added a new reporter, teamcity.
index.htmlafter running this command you can see the folder coverage in your dir and open  for a graphical view of test coverage.

karma.conf.jsYou can also set the coverage threshold that you want to achieve, in , like this.


Chapter 68: Debugging Angular 2 TypeScript application using Visual Studio Code
Section 68.1: Launch.json setup for you workspace
1. Turn on Debug from menu - view > debug
2. it return some error during start debug, show pop out notification and open launch.json from this popup notification It is just because of launch.json not set for your workspace. copy and paste below code in to launch.json //new launch.json your old launch.json

Now update your launch.json as below new launch.json
**// remember please mention your main.js path into it**


3. Now it debug is working, show notification popup for step by step debugging

Chapter 69: unit testing
Section 69.1: Basic unit test
component file

Test file

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
Abrar JahinChapter 25acdcjuniorChapters 1, 8 and 14ahmadalibalochChapter 67aholtryChapters 12 and 17AjeyChapter 56Alex MoralesChapter 20Alexandre JungesChapter 21amansoni211Chapter 19Amit kumarChapters 10 and 27Andrei ZhytkevichChapter 4Anil SinghChapters 12, 27 and 37ApmisChapter 17Arnold WiersmaChapter 16Arun RedhuChapter 66AryanJChapters 17, 30 and 31Ashok VishwakarmaChapter 58Bean0341Chapter 1Berseker59Chapter 12Bhoomi BhalaniChapter 1BogdanCChapters 1 and 52borislemkeChapters 4, 14, 17 and 33BrianRTChapter 41brians69Chapter 1briantylerChapter 1BrunoLMChapters 2, 4, 13, 14 and 23cDecker32Chapter 1Christopher TaylorChapters 14 and 27ChybieChapter 14dafyddPrysChapter 8daniellmbChapters 21 and 22DaredzikChapter 20echonaxChapter 1elliotChapter 14Eric JimenezChapters 26, 28, 31 and 37filoxoChapter 20Fredrik LundinChapter 14Günter ZöchbauerChapter 19Gaurav MukherjeeChapter 44Gerard SimpsonChapter 18gerlChapter 12H. PauwelynChapter 1HarryChapters 1 and 37HatemChapter 41He11ionChapter 1Jaime StillChapter 36Jarod MoserChapter 14Jeff CrossChapter 14
jesussegadoChapter 29JimChapters 1, 7, 41 and 55JorgeChapter 11K3v1nChapter 27KaloyanChapter 51Kaspars BergsChapters 20 and 23kEpExChapter 40Ketan AkbariChapters 61 and 62KhaledChapter 19lexithChapters 4 and 8LLLChapter 3Logan HChapter 1LordTribualChapters 14 and 17luukgruijsChapter 60M4R1KUChapter 32Maciej TrederChapters 22 and 64MatrimChapter 23MatWaligoraChapter 35Max KarpovetsChapters 6 and 9MaximeChapter 42meorfiChapter 18michaelbahrChapters 14 and 66Michal PietraszkoChapter 1MihaiChapters 1 and 43Mike KovetskyChapter 43Nate MayChapter 44nickChapter 66Nicolas IrisarriChapter 1ob1Chapters 10 and 12pd farhadChapter 20PeterChapter 1PotatoEngineerChapter 43ppovoskiChapter 10PSabuwalaChapter 68Pujan SrivastavaChapter 12RezaChapter 66rivanovChapter 18Roberto FernandezChapter 24Robin DijkhofChapter 37Ronald ZarītsChapter 22Roope HakulinenChapters 23 and 45Rumit ParakhiyaChapter 66Sachin SChapters 17 and 27SamChapter 59Sam StorieChapter 22samAlvinChapter 10SanketChapters 7 and 31SbatsChapter 21ScramboChapter 34SefaChapters 3 and 38Shailesh LadumorChapter 61SlashTagChapter 18smnbbrvChapter 33
Stian StandahlChapter 4Syam PradeepChapters 23 and 32TechJholaChapter 65theblindprophetChapters 4 and 23ThomasP1988Chapter 8TrentChapter 18ugreenChapter 39vijaykumarChapter 27vinagretiChapter 47Yoav SchniedermanChapters 5, 11, 12, 15, 16, 27, 41, 46, 48, 49, 50, 51, 52, 53, 54, 57, 63 and 69
You may also like







GoalKicker.com - Angular 2+ Notes for Professionals	1

GoalKicker.com - Angular 2+ Notes for Professionals	1

GoalKicker.com - Angular 2+ Notes for Professionals	1







