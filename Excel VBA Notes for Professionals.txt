

Contents
About	1
Chapter 1: Getting started with Excel VBA	2
Section 1.1: Opening the Visual Basic Editor (VBE)	3
Section 1.2: Declaring Variables	5
Section 1.3: Adding a new Object Library Reference	6
Section 1.4: Hello World	10
Section 1.5: Getting Started with the Excel Object Model	12
Chapter 2: Arrays	16
Section 2.1: Dynamic Arrays (Array Resizing and Dynamic Handling)	16
Section 2.2: Populating arrays (adding values)	16
Section 2.3: Jagged Arrays (Arrays of Arrays)	17
Section 2.4: Check if Array is Initialized (If it contains elements or not)	17
Section 2.5: Dynamic Arrays [Array Declaration, Resizing]	17
Chapter 3: Conditional statements	19
Section 3.1: The If statement	19
Chapter 4: Ranges and Cells	21
Section 4.1: Ways to refer to a single cell	21
Section 4.2: Creating a Range	21
Section 4.3: Oset Property	23
Section 4.4: Saving a reference to a cell in a variable	23
Section 4.5: How to Transpose Ranges (Horizontal to Vertical & vice versa)	23
Chapter 5: Named Ranges	25
Section 5.1: Define A Named Range	25
Section 5.2: Using Named Ranges in VBA	25
Section 5.3: Manage Named Range(s) using Name Manager	26
Section 5.4: Named Range Arrays	28
Chapter 6: Merged Cells / Ranges	29
Section 6.1: Think twice before using Merged Cells/Ranges	29
Chapter 7: Locating duplicate values in a range	30
Section 7.1: Find duplicates in a range	30
Chapter 8: User Defined Functions (UDFs)	32
Section 8.1: Allow full column references without penalty	32
Section 8.2: Count Unique values in Range	33
Section 8.3: UDF - Hello World	33
Chapter 9: Conditional formatting using VBA	36
Section 9.1: FormatConditions.Add	36
Section 9.2: Remove conditional format	37
Section 9.3: FormatConditions.AddUniqueValues	37
Section 9.4: FormatConditions.AddTop10	38
Section 9.5: FormatConditions.AddAboveAverage	38
Section 9.6: FormatConditions.AddIconSetCondition	38
Chapter 10: Workbooks	41
Section 10.1: When To Use ActiveWorkbook and ThisWorkbook	41
Section 10.2: Changing The Default Number of Worksheets In A New Workbook	41
Section 10.3: Application Workbooks	41
Section 10.4: Opening A (New) Workbook, Even If It's Already Open	42
Section 10.5: Saving A Workbook Without Asking The User	43
Chapter 11: Working with Excel Tables in VBA	44
Section 11.1: Instantiating a ListObject	44
Section 11.2: Working with ListRows / ListColumns	44
Section 11.3: Converting an Excel Table to a normal range	44
Chapter 12: Loop through all Sheets in Active Workbook	45
Section 12.1: Retrieve all Worksheets Names in Active Workbook	45
Section 12.2: Loop Through all Sheets in all Files in a Folder	45
Chapter 13: Use Worksheet object and not Sheet object	47
Section 13.1: Print the name of the first object	47
Chapter 14: Methods for Finding the Last Used Row or Column in a Worksheet	48
Section 14.1: Find the Last Non-Empty Cell in a Column	48
Section 14.2: Find the Last Non-Empty Row in Worksheet	48
Section 14.3: Find the Last Non-Empty Column in Worksheet	49
Section 14.4: Find the Last Non-Empty Cell in a Row	50
Section 14.5: Get the row of the last cell in a range	50
Section 14.6: Find Last Row Using Named Range	50
Section 14.7: Last cell in Range.CurrentRegion	51
Section 14.8: Find the Last Non-Empty Cell in Worksheet - Performance (Array)	51
Chapter 15: Creating a drop-down menu in the Active Worksheet with a Combo Box	54
Section 15.1: Example 2: Options Not Included	54
Section 15.2: Jimi Hendrix Menu	55
Chapter 16: File System Object	57
Section 16.1: File, folder, drive exists	57
Section 16.2: Basic file operations	57
Section 16.3: Basic folder operations	58
Section 16.4: Other operations	58
Chapter 17: Pivot Tables	60
Section 17.1: Adding Fields to a Pivot Table	60
Section 17.2: Creating a Pivot Table	60
Section 17.3: Pivot Table Ranges	63
Section 17.4: Formatting the Pivot Table Data	63
Chapter 18: Binding	64
Section 18.1: Early Binding vs Late Binding	64
Chapter 19: autofilter ; Uses and best practices	66
Section 19.1: Smartfilter!	66
Chapter 20: Application object	70
Section 20.1: Simple Application Object example: Display Excel and VBE Version	70
Section 20.2: Simple Application Object example: Minimize the Excel window	70
Chapter 21: Charts and Charting	71
Section 21.1: Creating a Chart with Ranges and a Fixed Name	71
Section 21.2: Creating an empty Chart	72
Section 21.3: Create a Chart by Modifying the SERIES formula	73
Section 21.4: Arranging Charts into a Grid	75
Chapter 22: CustomDocumentProperties in practice	79
Section 22.1: Organizing new invoice numbers	79
Chapter 23: PowerPoint Integration Through VBA	82
Section 23.1: The Basics: Launching PowerPoint from VBA	82
Chapter 24: How to record a Macro	83
Section 24.1: How to record a Macro	83
Chapter 25: SQL in Excel VBA - Best Practices	85
Section 25.1: How to use ADODB.Connection in VBA?	85
Chapter 26: Excel-VBA Optimization	87
Section 26.1: Optimizing Error Search by Extended Debugging	87
Section 26.2: Disabling Worksheet Updating	88
Section 26.3: Row Deletion - Performance	88
Section 26.4: Disabling All Excel Functionality Before executing large macros	89
Section 26.5: Checking time of execution	90
Section 26.6: Using With blocks	91
Chapter 27: VBA Security	93
Section 27.1: Password Protect your VBA	93
Chapter 28: Debugging and Troubleshooting	94
Section 28.1: Immediate Window	94
Section 28.2: Use Timer to Find Bottlenecks in Performance	95
Section 28.3: Debugger Locals Window	95
Section 28.4: Debug.Print	96
Section 28.5: Stop	97
Section 28.6: Adding a Breakpoint to your code	97
Chapter 29: VBA Best Practices	98
Section 29.1: ALWAYS Use "Option Explicit"	98
Section 29.2: Work with Arrays, Not With Ranges	100
Section 29.3: Switch o properties during macro execution	101
Section 29.4: Use VB constants when available	102
Section 29.5: Avoid using SELECT or ACTIVATE	103
Section 29.6: Always define and set references to all Workbooks and Sheets	105
Section 29.7: Use descriptive variable naming	105
Section 29.8: Document Your Work	106
Section 29.9: Error Handling	107
Section 29.10: Never Assume The Worksheet	109
Section 29.11: Avoid re-purposing the names of Properties or Methods as your variables	109
Section 29.12: Avoid using ActiveCell or ActiveSheet in Excel	110
Section 29.13: WorksheetFunction object executes faster than a UDF equivalent	111
Chapter 30: Excel VBA Tips and Tricks	113
Section 30.1: Using xlVeryHidden Sheets	113
Section 30.2: Using Strings with Delimiters in Place of Dynamic Arrays	114
Section 30.3: Worksheet .Name, .Index or .CodeName	114
Section 30.4: Double Click Event for Excel Shapes	116
Section 30.5: Open File Dialog - Multiple Files	117
Chapter 31: Common Mistakes	118
Section 31.1: Qualifying References	118
Section 31.2: Deleting rows or columns in a loop	119
Section 31.3: ActiveWorkbook vs. ThisWorkbook	119
Section 31.4: Single Document Interface Versus Multiple Document Interfaces	120
Credits	122
You may also like	124


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from:
https://goalkicker.com/ExcelVBABook
This Excel(r) VBA Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Excel(r) VBA group(s) or company(s) nor Stack Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Excel VBA
Microsoft Excel includes a comprehensive macro programming language called VBA. This programming language provides you with at least three additional resources:
1. Automatically drive Excel from code using Macros. For the most part, anything that the user can do by manipulating Excel from the user interface can be done by writing code in Excel VBA.
2. Create new, custom worksheet functions.
3. Interact Excel with other applications such as Microsoft Word, PowerPoint, Internet Explorer, Notepad, etc.
VBA stands for Visual Basic for Applications. It is a custom version of the venerable Visual Basic programming language that has powered Microsoft Excel's macros since the mid-1990s.
IMPORTANT
Please ensure any examples or topics created within the excel-vba tag are specific and relevant to the use of VBA with Microsoft Excel. Any suggested topics or examples provided that are generic to the VBA language should be declined in order to prevent duplication of efforts.
 on-topic examples:
✓ Creating and interacting with worksheet objects
✓ The WorksheetFunction class and respective methods ✓ Using the xlDirection enumeration to navigate a range
 off-topic examples:
✗ How to create a 'for each' loop
✗ MsgBox class and how to display a message ✗ Using WinAPI in VBA
VB
Version Release Date
	VB6	1998-10-01
	VB7	2001-06-06
WIN32 1998-10-01
WIN64 2001-06-06
MAC	1998-10-01
Excel
Version Release Date
	16	2016-01-01
	15	2013-01-01
	14	2010-01-01
	12	2007-01-01
	11	2003-01-01
	10	2001-01-01
	9	1999-01-01
	8	1997-01-01
	7	1995-01-01
	5	1993-01-01
	2	1987-01-01
Section 1.1: Opening the Visual Basic Editor (VBE)
Step 1: Open a Workbook

Step 2 Option A: Press  Alt  +  F11 
This is the standard shortcut to open the VBE.
Step 2 Option B: Developer Tab --> View Code
First, the Developer Tab must be added to the ribbon. Go to File -> Options -> Customize Ribbon, then check the box for developer.

Then, go to the developer tab and click "View Code" or "Visual Basic"

Step 2 Option C: View tab > Macros > Click Edit button to open an Existing Macro
All three of these options will open the Visual Basic Editor (VBE):

Section 1.2: Declaring Variables
To explicitly declare variables in VBA, use the Dim statement, followed by the variable name and type. If a variable is used without being declared, or if no type is specified, it will be assigned the type Variant.
Option ExplicitUse the  statement on first line of a module to force all variables to be declared before usage (see ALWAYS Use "Option Explicit" ).
Option ExplicitAlways using  is highly recommended because it helps prevent typo/spelling errors and ensures variables/objects will stay their intended type.

Multiple variables can be declared on a single line using commas as delimiters, but each type must be declared individually, or they will default to the Variant type.

Debug.Print TypeName(Str)    'Output: String
Debug.Print TypeName(IntOne) 'Output: Variant <--- !!!
Debug.Print TypeName(IntTwo) 'Output: Integer
Debug.Print TypeName(Lng)    'Output: Long
Variables can also be declared using Data Type Character suffixes ($ % & ! # @), however using these are increasingly discouraged.

Other ways of declaring variables are:
Static CounterVariable as IntegerPublic CounterVariable as IntegerPrivate CounterVariable as IntegerStatic like: 
When you use the Static statement instead of a Dim statement, the declared variable will retain its value between calls.
Public like: 
Public variables can be used in any procedures in the project. If a public variable is declared in a standard module or a class module, it can also be used in any projects that reference the project where the public variable is declared.
Private like: 
Private variables can be used only by procedures in the same module.
Source and more info:
MSDN-Declaring Variables
Type Characters (Visual Basic)
Section 1.3: Adding a new Object Library Reference
The procedure describes how to add an Object library reference, and afterwards how to declare new variables with reference to the new library class objects.
The example below shows how to add the PowerPoint library to the existing VB Project. As can be seen, currently the PowerPoint Object library is not available.

Step 1: Select Menu Tools --> References...

Step 2: Select the Reference you want to add. This example we scroll down to find "Microsoft PowerPoint 14.0 Object Library", and then press "OK".

Note: PowerPoint 14.0 means that Office 2010 version is installed on the PC.
Step 3: in the VB Editor, once you press Ctrl+Space together, you get the autocomplete option of PowerPoint.

After selecting PowerPoint and pressing ., another menu appears with all objects options related to the PowerPoint Object Library. This example shows how to select the PowerPoint's object Application.

Step 4: Now the user can declare more variables using the PowerPoint object library.
Declare a variable that is referencing the Presentation object of the PowerPoint object library.

Declare another variable that is referencing the Slide object of the PowerPoint object library.

Now the variables declaration section looks like in the screen-shot below, and the user can start using these variables in his code.

Code version of this tutorial:

Section 1.4: Hello World
1. Open the Visual Basic Editor ( see Opening the Visual Basic Editor )
2. Click Insert --> Module to add a new Module :

3. Copy and Paste the following code in the new module :

To obtain :

4. Click on the green "play" arrow (or press F5) in the Visual Basic toolbar to run the program:

5. Select the new created sub "hello" and click Run :

6. Done, your should see the following window:

Section 1.5: Getting Started with the Excel Object Model
		This example intend to be a gentle introduction to the Excel Object Model for beginners.
1. Open the Visual Basic Editor (VBE)
2. Click View --> Immediate Window to open the Immediate Window (or  ctrl  +  G ):

3. You should see the following Immediate Window at the bottom on VBE:

This window allow you to directly test some VBA code. So let's start, type in this console :

VBE has intellisense and then it should open a tooltip as in the following figure :

CoutSelect .Count in the list or directly type . to obtain :

4. Then press Enter. The expression is evaluated and it should returns 1. This indicates the number of Worksheet currently present in the workbook. The question mark (?) is an alias for Debug.Print.
Worksheets is an Object and Count is a Method. Excel has several Object (Workbook, Worksheet, Range, Chart ..) and each of one contains specific methods and properties. You can find the complete list of Object in the Excel VBA reference. Worksheets Object is presented here .
This Excel VBA reference should become your primary source of information regarding the Excel Object Model.
5. Now let's try another expression, type (without the ? character):

StackOverflow6. Press Enter. This should create a new worksheet called .:

To understand this expression you need to read the Add function in the aforementioned Excel reference. You will find the following:


Worksheets.AddSo the () create a new worksheet and return it. Worksheet(without s) is itself a Object that can be found in the documentation and Name is one of its property (see here). It is defined as :

Worksheets.Add().Name So, by investigating the different objects definitions we are able to understand this code = "StackOveflow".
Add() creates and add a new worksheet and return a reference to it, then we set its Name property to
"StackOverflow"
Now let's be more formal, Excel contains several Objects. These Objects may be composed of one or several collection(s) of Excel objects of the same class. It is the case for WorkSheets which is a collection of Worksheet object. Each Object has some properties and methods that the programmer can interact with.
		The Excel Object model refers to the Excel object hierarchy
At the top of all objects is the Application object, it represents the Excel instance itself. Programming in VBA requires a good understanding of this hierarchy because we always need a reference to an object to be able to call a Method or to Set/Get a property.
The (very simplified) Excel Object Model can be represented as,

A more detail version for the Worksheet Object (as it is in Excel 2007) is shown below,

Workbook.WindowActivateFinally some objects may have events (ex: ) that are also part of the Excel Object Model.
Chapter 2: Arrays
Section 2.1: Dynamic Arrays (Array Resizing and Dynamic Handling)
Due to not being Excel-VBA exclusive contents this Example has been moved to VBA documentation.
Link: Dynamic Arrays (Array Resizing and Dynamic Handling)
Section 2.2: Populating arrays (adding values)
There are multiple ways to populate an array.
Directly

Using Array() function
'one-dimensional only
From range




Section 2.3: Jagged Arrays (Arrays of Arrays)
Due to not being Excel-VBA exclusive contents this Example has been moved to VBA documentation.
Link: Jagged Arrays (Arrays of Arrays)
Section 2.4: Check if Array is Initialized (If it contains elements or not)
A common problem might be trying to iterate over Array which has no values in it. For example:

To avoid this issue, and to check if an Array contains elements, use this oneliner:
If Not Not myArray Then MsgBox UBound(myArray) Else MsgBox "myArray not initialised"
Section 2.5: Dynamic Arrays [Array Declaration, Resizing]



Chapter 3: Conditional statements
Section 3.1: The If statement
x The If control statement allows different code to be executed depending upon the evaluation of a conditional (Boolean) statement. A conditional statement is one that evaluates to either True or False, e.g. > 2.
There are three patterns that can be used when implementing an If statement, which are described below. Note that an If conditional evaluation is always followed by a Then.
1. Evaluating one If conditional statement and doing something if it is True
Single line If statement
End IfThis is the shortest way to use an If and it is useful when only one statement needs to be carried out upon a True evaluation. When using this syntax, all of the code must be on a single line. Do not include an  at the end of the line.

If block
If multiple lines of code need to be executed upon a True evaluation, an If block may be used.

End IfNote that, if a multi-line If block is used, a corresponding  is required.
2. Evaluating one conditional If statement, doing one thing if it is True and doing something else if it is
False
Single line If, Else statement
End IfThis may be used if one statement is to be carried out upon a True evaluation and a different statement is to be carried out on a False evaluation. Be careful using this syntax, as it is often less clear to readers that there is an Else statement. When using this syntax, all of the code must be on a single line. Do not include an  at the end of the line.
If [Some condition is True] Then [Do something] Else [Do something else]
If, Else block
Use an If, Else block to add clarity to your code, or if multiple lines of code need to be executed under either a True or a False evaluation.

End IfNote that, if a multi-line If block is used, a corresponding  is required.
3. Evaluating many conditional statements, when preceding statements are all False, and doing something different for each one
This pattern is the most general use of If and would be used when there are many non-overlapping conditions that require different treatment. Unlike the first two patterns, this case requires the use of an If block, even if only one line of code will be executed for each condition.
If, ElseIf, ..., Else block
Instead of having to create many If blocks one below another, an ElseIf may be used evaluate an extra condition. The ElseIf is only evaluated if any preceding If evaluation is False.

End IfEnd IfAs many ElseIf control statements may be included between an If and an  as required. An Else control statement is not required when using ElseIf (although it is recommended), but if it is included, it must be the final control statement before the .

Chapter 4: Ranges and Cells
Section 4.1: Ways to refer to a single cell
The simplest way to refer to a single cell on the current Excel worksheet is simply to enclose the A1 form of its reference in square brackets:

Note that square brackets are just convenient syntactic sugar for the Evaluate method of the Application object, so technically, this is identical to the following code:

You could also call the Cells method which takes a row and a column and returns a cell reference.

Remember that whenever you pass a row and a column to Excel from VBA, the row is always first, followed by the column, which is confusing because it is the opposite of the common A1 notation where the column appears first.
In both of these examples, we did not specify a worksheet, so Excel will use the active sheet (the sheet that is in front in the user interface). You can specify the active sheet explicitly:

Or you can provide the name of a particular sheet:

There are a wide variety of methods that can be used to get from one range to another. For example, the Rows method can be used to get to the individual rows of any range, and the Cells method can be used to get to individual cells of a row or column, so the following code refers to cell C1:

Section 4.2: Creating a Range
A Range cannot be created or populated the same way a string would:

It is considered best practice to qualify your references, so from now on we will use the same approach here. More about Creating Object Variables (e.g. Range) on MSDN . More about Set Statement on MSDN.
There are different ways to create the same Range:
Sub SetRangeVariable()
    Dim ws As Worksheet
    Dim r As Range
    Set ws = ThisWorkbook.Worksheets(1) ' The first Worksheet in Workbook with this code in it    
    ' These are all equivalent:
    Set r = ws.Range("A2")
    Set r = ws.Range("A" & 2)
    Set r = ws.Cells(2, 1) ' The cell in row number 2, column number 1
    Set r = ws.[A2] 'Shorthand notation of Range.
    Set r = Range("NamedRangeInA2") 'If the cell A2 is named NamedRangeInA2. Note, that this is Sheet independent.
    Set r = ws.Range("A1").Offset(1, 0) ' The cell that is 1 row and 0 columns away from A1     Set r = ws.Range("A1").Cells(2,1) ' Similar to Offset. You can "go outside" the original Range.
    Set r = ws.Range("A1:A5").Cells(2) 'Second cell in bigger Range.
    Set r = ws.Range("A1:A5").Item(2) 'Second cell in bigger Range.     Set r = ws.Range("A1:A5")(2) 'Second cell in bigger Range. End Sub
Note in the example that Cells(2, 1) is equivalent to Range("A2"). This is because Cells returns a Range object. Some sources: Chip Pearson-Cells Within Ranges; MSDN-Range Object; John Walkenback-Referring To Ranges In Your VBA Code.
Also note that in any instance where a number is used in the declaration of the range, and the number itself is outside of quotation marks, such as Range("A" & 2), you can swap that number for a variable that contains an integer/long. For example:

If you are using double loops, Cells is better:


Section 4.3: Oset Property
     Offset(Rows, Columns) - The operator used to statically reference another point from the current cell. Often used in loops. It should be understood that positive numbers in the rows section moves right, wheres as negatives move left. With the columns section positives move down and negatives move up. i.e

This code selects B2, puts a new string there, then moves that string back to A1 afterwards clearing out B2.
Section 4.4: Saving a reference to a cell in a variable
To save a reference to a cell in a variable, you must use the Set syntax, for example:

later...

Why is the Set keyword required? Set tells Visual Basic that the value on the right hand side of the = is meant to be an object.
Section 4.5: How to Transpose Ranges (Horizontal to Vertical & vice versa)


Note: Copy/PasteSpecial also has a Paste Transpose option which updates the transposed cells' formulas as well.

Chapter 5: Named Ranges
Topic should include information specifically related to named ranges in Excel including methods for creating, modifying, deleting, and accessing defined named ranges.
Section 5.1: Define A Named Range
Using named ranges allows you to describe the meaning of a cell(s) contents and use this defined name in place of an actual cell address.
A5*B5 can be replaced with =Width*HeightFor example, formula = to make the formula much easier to read and understand.
To define a new named range, select cell or cells to name and then type new name into the Name Box next to the formula bar.

Note: Named Ranges default to global scope meaning that they can be accessed from anywhere within the workbook. Older versions of Excel allow for duplicate names so care must be taken to prevent duplicate names of global scope otherwise results will be unpredictable. Use Name Manager from Formulas tab to change scope.
Section 5.2: Using Named Ranges in VBA
Create new named range called 'MyRange' assigned to cell A1

Delete defined named range by name

Access Named Range by name

Access a Named Range with a Shortcut
Just like any other range, named ranges can be accessed directly with through a shortcut notation that does not require a Range object to be created. The three lines from the code excerpt above can be replaced by a single line:

You can also call methods on the range. The following selects MyRange:

Section 5.3: Manage Named Range(s) using Name Manager
Formulas tab > Defined Names group > Name Manager button
Named Manager allows you to:
1. Create or change name
2. Create or change cell reference
3. Create or change scope
4. Delete existing named range

Named Manager provides a useful quick look for broken links.

Section 5.4: Named Range Arrays
Example sheet

Code

Result

Chapter 6: Merged Cells / Ranges
Section 6.1: Think twice before using Merged Cells/Ranges
First of all, Merged Cells are there only to improve the look of your sheets.
So it is literally the last thing that you should do, once your sheet and workbook are totally functional!
Where is the data in a Merged Range?
When you merge a Range, you'll only display one block.
The data will be in the very first cell of that Range, and the others will be empty cells!
One good point about it : no need to fill all the cells or the range once merged, just fill the first cell! ;)
The other aspects of this merged ranged are globally negative :
 If you use a method for finding last row or column, you'll risk some errors
If you loop through rows and you have merged some ranges for a better readability, you'll encounter empty cells and not the value displayed by the merged range

Chapter 7: Locating duplicate values in a range
At certain points, you will be evaluating a range of data and you will need to locate the duplicates in it. For bigger data sets, there are a number of approaches you can take that use either VBA code or conditional functions. This example uses a simple if-then condition within two nested for-next loops to test whether each cell in the range is equal in value to any other cell in the range.
Section 7.1: Find duplicates in a range
The following tests range A2 to A7 for duplicate values. Remark: This example illustrates a possible solution as a first approach to a solution. It's faster to use an array than a range and one could use collections or dictionaries or xml methods to check for duplicates.
    Sub find_duplicates()
' Declare variables
  Dim ws     As Worksheet               ' worksheet
  Dim cell   As Range                   ' cell within worksheet range
  Dim n      As Integer                 ' highest row number
  Dim bFound As Boolean                 ' boolean flag, if duplicate is found
  Dim sFound As String: sFound = "|"    ' found duplicates
  Dim s      As String                  ' message string
  Dim s2     As String                  ' partial message string
' Set Sheet to memory
  Set ws = ThisWorkbook.Sheets("Duplicates")
' loop thru FULLY QUALIFIED REFERENCE   For Each cell In ws.Range("A2:A7")     bFound = False: s2 = ""             ' start each cell with empty values
 '  Check if first occurrence of this value as duplicate to avoid further searches
    If InStr(sFound, "|" & cell & "|") = 0 Then
   
      For n = cell.Row + 1 To 7           ' iterate starting point to avoid REDUNDANT SEARCH
        If cell = ws.Range("A" & n).Value Then
           If cell.Row <> n Then        ' only other cells, as same cell cannot be a duplicate                  bFound = True             ' boolean flag
              '  found duplicates in cell A{n}
                 s2 = s2 & vbNewLine & " -> duplicate in A" & n
           End If
        End If
       Next
     End If
   ' notice all found duplicates
     If bFound Then
         ' add value to list of all found duplicate values          ' (could be easily split to an array for further analyze)            sFound = sFound & cell & "|"
           s = s & cell.Address & " (value=" & cell & ")" & s2 & vbNewLine & vbNewLine      End If
   Next
' Messagebox with final result
  MsgBox "Duplicate values are " & sFound & vbNewLine & vbNewLine & s, vbInformation, "Found duplicates" End Sub
Depending on your needs, the example can be modified - for instance, the upper limit of n can be the row value of last cell with data in the range, or the action in case of a True If condition can be edited to extract the duplicate value somewhere else. However, the mechanics of the routine would not change.

Chapter 8: User Defined Functions (UDFs)
Section 8.1: Allow full column references without penalty
It's easier to implement some UDFs on the worksheet if full column references can be passed in as parameters. However, due to the explicit nature of coding, any loop involving these ranges may be processing hundreds of thousands of cells that are completely empty. This reduces your VBA project (and workbook) to a frozen mess while unnecessary non-values are processed.
Looping through a worksheet's cells is one of the slowest methods of accomplishing a task but sometimes it is unavoidable. Cutting the work performed down to what is actually required makes perfect sense.
The solution is to truncate the full column or full row references to the Worksheet.UsedRange property with the Intersect method. The following sample will loosely replicate a worksheet's native SUMIF function so the criteria_range will also be resized to suit the sum_range since each value in the sum_range must be accompanied by a value in the criteria_range.
The Application.Caller for a UDF used on a worksheet is the cell in which it resides. The cell's .Parent property is the worksheet. This will be used to define the .UsedRange.


While this is a fairly simplistic example, it adequately demonstrates passing in two full column references (1,048,576 rows each) but only processing 15 rows of data and criteria.
Linked official MSDN documentation of individual methods and properties courtesy of Microsoft(tm).
Section 8.2: Count Unique values in Range

Collections
Section 8.3: UDF - Hello World
1. Open Excel
2. Open the Visual Basic Editor ( see Opening the Visual Basic Editor )
3. Add a new module by clicking Insert --> Module :

4. Copy and Paste the following code in the new module :

To obtain :

5. Go back to your workbook and type "=Hello()" into a cell to see the "Hello World".


Chapter 9: Conditional formatting using VBA
Section 9.1: FormatConditions.Add
Syntax:

Parameters:
Name	Required / Optional	Data Type
Type	RequiredXlFormatConditionTypeOperator OptionalVariantFormula1 OptionalVariantFormula2 OptionalVariantXlFormatConditionType enumaration:
         Name	Description xlAboveAverageCondition Above average condition
xlBlanksConditionBlanks conditionxlCellValueCell valuexlColorScaleColor scalexlDatabarDatabarxlErrorsConditionErrors conditionxlExpressionExpressionXlIconSetIcon setxlNoBlanksConditionNo blanks conditionxlNoErrorsConditionNo errors conditionxlTextStringText stringxlTimePeriodTime periodxlTop10Top 10 valuesxlUniqueValuesUnique valuesFormatting by cell value:

Operators:
Name
xlBetween xlEqual xlGreater xlGreaterEqual xlLess xlLessEqual xlNotBetween xlNotEqual
If Type is xlExpression, the Operator argument is ignored.
Formatting by text contains:

Operators:
	Name	Description
xlBeginsWith	Begins with a specified value. xlContains	Contains a specified value.
xlDoesNotContain Does not contain the specified value.
xlEndsWith	Endswith the specified value Formatting by time period

Operators:
Name
xlYesterday xlTomorrow xlLast7Days xlLastWeek xlThisWeek xlNextWeek xlLastMonth xlThisMonth xlNextMonth
Section 9.2: Remove conditional format

Remove all conditional format in worksheet:
Cells.FormatConditions.Delete
Section 9.3: FormatConditions.AddUniqueValues
Highlighting Duplicate Values


Highlighting Unique Values

Section 9.4: FormatConditions.AddTop10
Highlighting Top 5 Values

Section 9.5: FormatConditions.AddAboveAverage

Operators:
NameDescriptionXlAboveAverageAbove averageXlAboveStdDevAbove standard deviationXlBelowAverageBelow averageXlBelowStdDevBelow standard deviationXlEqualAboveAverage Equal above average
XlEqualBelowAverage Equal below average
Section 9.6: FormatConditions.AddIconSetCondition

IconSet:
Name
xl3Arrows xl3ArrowsGray xl3Flags xl3Signs xl3Stars xl3Symbols xl3Symbols2 xl3TrafficLights1 xl3TrafficLights2 xl3Triangles xl4Arrows xl4ArrowsGray xl4CRV xl4RedToBlack xl4TrafficLights xl5Arrows xl5ArrowsGray xl5Boxes xl5CRV xl5Quarters

Type:
Name
xlConditionValuePercent xlConditionValueNumber xlConditionValuePercentile xlConditionValueFormula
Operator:
    Name	Value xlGreater	5 xlGreaterEqual 7 Value:
Returns or sets the threshold value for an icon in a conditional format.
Chapter 10: Workbooks
Section 10.1: When To Use ActiveWorkbook and ThisWorkbook
It's a VBA Best Practice to always specify which workbook your VBA code refers. If this specification is omitted, then VBA assumes the code is directed at the currently active workbook (ActiveWorkbook).

However, when several workbooks are open at the same time -- particularly and especially when VBA code is running from an Excel Add-In -- references to the ActiveWorkbook may be confused or misdirected. For example, an add-in with a UDF that checks the time of day and compares it to a value stored on one of the add-in's worksheets (that are typically not readily visible to the user) will have to explicitly identify which workbook is being referenced.
EarlyOrLateIn our example, our open (and active) workbook has a formula in cell A1 =() and does NOT have any VBA written for that active workbook. In our add-in, we have the following User Defined Function (UDF):

The code for the UDF is written and stored in the installed Excel add-in. It uses data stored on a worksheet in the add-in called "WatchTime". If the UDF had used ActiveWorkbook instead of ThisWorkbook, then it would never be able to guarantee which workbook was intended.
Section 10.2: Changing The Default Number of Worksheets In A New Workbook
The "factory default" number of worksheets created in a new Excel workbook is generally set to three. Your VBA code can explicitly set the number of worksheets in a new workbook.

Section 10.3: Application Workbooks
In many Excel applications, the VBA code takes actions directed at the workbook in which it's contained. You save that workbook with a ".xlsm" extension and the VBA macros only focus on the worksheets and data within. However, there are often times when you need to combine or merge data from other workbooks, or write some of your data to a separate workbook. Opening, closing, saving, creating, and deleting other workbooks is a common need for many VBA applications.
At any time in the VBA Editor, you can view and access any and all workbooks currently open by that instance of Excel by using the Workbooks property of the Application object. The MSDN Documentation explains it with references.
Section 10.4: Opening A (New) Workbook, Even If It's Already Open
If you want to access a workbook that's already open, then getting the assignment from the Workbooks collection is straightforward:

If you want to create a new workbook, then use the Workbooks collection object to Add a new entry.

There are times when you may not or (or care) if the workbook you need is open already or not, or possible does not exist. The example function shows how to always return a valid workbook object.
Option Explicit
Function GetWorkbook(ByVal wbFilename As String) As Workbook
    '--- returns a workbook object for the given filename, including checks
    '    for when the workbook is already open, exists but not open, or
    '    does not yet exist (and must be created)
    '    ***  wbFilename must be a fully specified pathname
    Dim folderFile As String
    Dim returnedWB As Workbook
   
    '--- check if the file exists in the directory location     folderFile = File(wbFilename)
    If folderFile = "" Then
        '--- the workbook doesn't exist, so create it
        Dim pos1 As Integer
        Dim fileExt As String
        Dim fileFormatNum As Long
        '--- in order to save the workbook correctly, we need to infer which workbook
        '    type the user intended from the file extension         pos1 = InStrRev(sFullName, ".", , vbTextCompare)         fileExt = Right(sFullName, Len(sFullName) - pos1)         Select Case fileExt             Case "xlsx"
                fileFormatNum = 51             Case "xlsm"
                fileFormatNum = 52             Case "xls"
                fileFormatNum = 56             Case "xlsb"
                fileFormatNum = 50
            Case Else
                Err.Raise vbObjectError + 1000, "GetWorkbook function", _
                         "The file type you've requested (file extension) is not recognized. " & _
                         "Please use a known extension: xlsx, xlsm, xls, or xlsb."
        End Select
        Set returnedWB = Workbooks.Add         Application.DisplayAlerts = False         returnedWB.SaveAs filename:=wbFilename, FileFormat:=fileFormatNum

Section 10.5: Saving A Workbook Without Asking The User
Often saving new data in an existing workbook using VBA will cause a pop-up question noting that the file already exists.
To prevent this pop-up question, you have to suppress these types of alerts.
Application.DisplayAlerts = False        'disable user prompt to overwrite file myWB.SaveAs FileName:="NewOrExistingFilename.xlsx"
Application.DisplayAlerts = True         're-enable user prompt to overwrite file

Chapter 11: Working with Excel Tables in VBA
This topic is about working with tables in VBA, and assumes knowledge of Excel Tables. In VBA, or rather the Excel Object Model, tables are known as ListObjects. The most frequently used properties of a ListObject are ListRow(s), ListColumn(s), DataBodyRange, Range and HeaderRowRange.
Section 11.1: Instantiating a ListObject

Section 11.2: Working with ListRows / ListColumns

Section 11.3: Converting an Excel Table to a normal range

Chapter 12: Loop through all Sheets in Active Workbook
Section 12.1: Retrieve all Worksheets Names in Active Workbook

Section 12.2: Loop Through all Sheets in all Files in a Folder



Chapter 13: Use Worksheet object and not Sheet object
Plenty of VBA users consider Worksheets and Sheets objects synonyms. They are not.
Sheets object consists of both Worksheets and Charts. Thus, if we have charts in our Excel Workbook, we should be careful, not to use Sheets and Worksheets as synonyms.
Section 13.1: Print the name of the first object

The result:

Chapter 14: Methods for Finding the Last Used Row or Column in a Worksheet
Section 14.1: Find the Last Non-Empty Cell in a Column
In this example, we will look at a method for returning the last non-empty row in a column for a data set.
This method will work regardless of empty regions within the data set.
However caution should be used if merged cells are involved, as the End method will be "stopped" against a merged region, returning the first cell of the merged region.
In addition non-empty cells in hidden rows will not be taken into account.

To address the limitations indicated above, the line:
LastRow = wS.Cells(wS.Rows.Count, "A").End(xlUp).Row
may be replaced with:
1. for last used row of "Sheet1":
LastRow = wS.UsedRange.Row - 1 + wS.UsedRange.Rows.Count.
2. for last non-empty cell of Column "A" in "Sheet1":

Section 14.2: Find the Last Non-Empty Row in Worksheet

You can choose between 2 options, regarding if you want to know if there is no data in the worksheet :
wS.Cells(LastRow_1(wS),...)NO : Use LastRow_1 : You can use it directly within 
YES : Use LastRow_0 : You need to test if the result you get from the function is 0 or not before using it

Section 14.3: Find the Last Non-Empty Column in Worksheet

You can choose between 2 options, regarding if you want to know if there is no data in the worksheet :
wS.Cells(...,LastCol_1(wSNO : Use LastCol_1 : You can use it directly within ))
YES : Use LastCol_0 : You need to test if the result you get from the function is 0 or not before using it
Public Function LastCol_1(wS As Worksheet) As Double
    With wS
        If Application.WorksheetFunction.CountA(.Cells) <> 0 Then
            LastCol_1 = .Cells.Find(What:="*", _
                                After:=.Range("A1"), _
                                Lookat:=xlPart, _
                                LookIn:=xlFormulas, _
                                SearchOrder:=xlByColumns, _
                                SearchDirection:=xlPrevious, _
                                MatchCase:=False).Column
        Else
            LastCol_1 = 1
        End If
    End With
End Function
The Err object's properties are automatically reset to zero upon function exit.
Public Function LastCol_0(wS As Worksheet) As Double
    On Error Resume Next
    LastCol_0 = wS.Cells.Find(What:="*", _
                            After:=ws.Range("A1"), _
                            Lookat:=xlPart, _
                            LookIn:=xlFormulas, _
                            SearchOrder:=xlByColumns, _
                            SearchDirection:=xlPrevious, _
                            MatchCase:=False).Column
End Function
Section 14.4: Find the Last Non-Empty Cell in a Row
In this example, we will look at a method for returning the last non-empty column in a row.
This method will work regardless of empty regions within the data set.
However caution should be used if merged cells are involved, as the End method will be "stopped" against a merged region, returning the first cell of the merged region.
In addition non-empty cells in hidden columns will not be taken into account.

Section 14.5: Get the row of the last cell in a range

Section 14.6: Find Last Row Using Named Range
In case you have a Named Range in your Sheet, and you want to dynamically get the last row of that Dynamic Named Range. Also covers cases where the Named Range doesn't start from the first Row.


Update:
A potential loophole was pointed out by @Jeeped for a a named range with non-contiguous rows as it generates unexpected result. To addresses that issue, the code is revised as below.
Asumptions: targes sheet = form, named range = MyNameRange

Section 14.7: Last cell in Range.CurrentRegion
Range.CurrentRegion is a rectangular range area surrounded by empty cells. Blank cells with formulas such as =""or ' are not considered blank (even by the ISBLANK Excel function).
Dim rng As Range, lastCell As Range
Set rng = Range("C3").CurrentRegion       ' or Set rng = Sheet1.UsedRange.CurrentRegion Set lastCell = rng(rng.Rows.Count, rng.Columns.Count)
Section 14.8: Find the Last Non-Empty Cell in Worksheet Performance (Array)
ThisWorkbook.ActiveSheetCell, The first function, using an array, is much faster
If called without the optional parameter, will default to .
If the range is empty will returns ( 11 ) as default, instead of Nothing
Speed:




.
MicroTimer:


Chapter 15: Creating a drop-down menu in the Active Worksheet with a Combo Box
This is a simple example demonstrating how to create a drop down menu in the Active Sheet of your workbook by inserting a Combo Box Activex object in the sheet. You'll be able to insert one of five Jimi Hendrix songs in any activated cell of the sheet and be able to clear it, accordingly.
Section 15.1: Example 2: Options Not Included
This example is used in specifying options that might not be included in a database of available housing and its attendant amenities.
It builds on the previous example, with some differences:
1. Two procedures are no longer necessary for a single combo box, done by combining the code into a single procedure.
2. The use of the LinkedCell property to allow for the correct input of the user selection every time
3. The inclusion of a backup feature for ensuring the active cell is in the correct column and an error prevention code, based on previous experience, where numeric values would formatted as strings when populated to the active cell.


The above macro is initiated every time a cell is activated with the SelectionChange event in the worksheet module:

Section 15.2: Jimi Hendrix Menu
In general, the code is placed in the module of a sheet.
This is the Worksheet_SelectionChange event, which fires each time a different cell is selected in the active sheet. You can select "Worksheet" from the first drop-down menu above the code window, and "Selection_Change" from the drop down menu next to it. In this case, every time you activate a cell, the code is redirected to the Combo Box's code.

Here, the routine dedicated to the ComboBox is coded to the Change event by default. In it, there is a fixed array, populated with all the options. Not the CLEAR option in the last position, which will be used to clear the contents of a cell. The array then is handed to to the Combo Box and passed to the routine that does the work.

The array is passed to the routine that fills the cells with the song name or null value to empty them. First, an integer variable is given the value of the position of the choice that the user makes. Then, the Combo Box is moved to the TOP LEFT corner of the cell the user activates and its dimensions adjusted to make the experience more fluid. The active cell is then assigned the value in the position in the integer variable, which tracks the user choice. In case the user selects CLEAR from the options, the cell is emptied.
The entire routine repeats for each selected cell.

Chapter 16: File System Object
Section 16.1: File, folder, drive exists


Drive exists:

Section 16.2: Basic file operations
Copy:

Move:

Delete:


Section 16.3: Basic folder operations
Create:

Copy:

Move:

Delete:

Section 16.4: Other operations






Chapter 17: Pivot Tables
Section 17.1: Adding Fields to a Pivot Table
Two important things to note when adding fields to a Pivot Table are Orientation and Position. Sometimes a developer may assume where a field is placed, so it's always clearer to explicitly define these parameters. These actions only affect the given Pivot Table, not the Pivot Cache.

Section 17.2: Creating a Pivot Table
One of the most powerful capabilities in Excel is the use of Pivot Tables to sort and analyze data. Using VBA to create and manipulate the Pivots is easier if you understand the relationship of Pivot Tables to Pivot Caches and how to reference and use the different parts of the Tables.
At its most basic, your source data is a Range area of data on a Worksheet. This data area MUST identify the data columns with a header row as the first row in the range. Once the Pivot Table is created, the user may view and change the source data at any time. However, changes may not be automatically or immediately reflected in the Pivot Table itself because there is an intermediate data storage structure called the Pivot Cache that is directly connected to the Pivot Table itself.

If multiple Pivot Tables are needed, based on the same source data, the Pivot Cache may be re-used as the internal data store for each of the Pivot Tables. This is a good practice because it saves memory and reduces the size of the Excel file for storage.


As an example, to create a Pivot Table based on the source data shown in the Figures above:

		References MSDN Pivot Table Object
Section 17.3: Pivot Table Ranges
These excellent reference sources provide descriptions and illustrations of the various ranges in Pivot Tables.
References
Referencing Pivot Table Ranges in VBA - from Jon Peltier's Tech Blog
Referencing an Excel Pivot Table Range using VBA - from globaliconnect Excel VBA
Section 17.4: Formatting the Pivot Table Data
This example changes/sets several formats in the data range area (DataBodyRange) of the given Pivot Table. All formattable parameters in a standard Range are available. Formatting the data only affects the Pivot Table itself, not the Pivot Cache.
NOTE: the property is named TableStyle2 because the TableStyle property is not a member of the PivotTable's object properties.

Chapter 18: Binding
Section 18.1: Early Binding vs Late Binding
Binding is the process of assigning an object to an identifier or variable name. Early binding (also known as static binding) is when an object declared in Excel is of a specific object type, such as a Worksheet or Workbook. Late binding occurs when general object associations are made, such as the Object and Variant declaration types.
Early binding of references some advantages over late binding.
Early binding is operationally faster than late binding during run-time. Creating the object with late binding in run-time takes time that early binding accomplishes when the VBA project is initially loaded.
Early binding offers additional functionality through the identification of Key/Item pairs by their ordinal position.
Depending on code structure, early binding may offer an additional level of type checking and reduce errors. The VBE's capitalization correction when typing a bound object's properties and methods is active with early binding but unavailable with late binding.


However, if you are using early binding and the document is run on a system that lacks one of the libraries you have referenced, you will encounter problems. Not only will the routines that utilize the missing library not function properly, but the behavior of all code within the document will become erratic. It is likely that none of the document's code will function on that computer.
This is where late binding is advantageous. When using late binding you do not have to add the reference in the Tools>References menu. On machines that have the appropriate library, the code will still work. On machines without that library, the commands that reference the library will not work, but all the other code in your document will continue to function.
If you are not thoroughly familiar with the library you are referencing, it may be useful to use early binding while writing the code, then switch to late binding before deployment. That way you can take advantage of the VBE's IntelliSense and Object Browser during development.
Chapter 19: autofilter ; Uses and best practices
Autofilter ultimate goal is to provide in the quickest way possible data mining from hundreds or thousands of rows data in order to get the attention in the items we want to focus on. It can receive parameters such as
"text/values/colors" and they can be stacked among columns. You may connect up to 2 criteria per column based in logical connectors and sets of rules. Remark: Autofilter works by filtering rows, there is no Autofilter to filter columns (at least not natively).
Section 19.1: Smartfilter!
Problem situation
Warehouse administrator has a sheet ("Record") where every logistics movement performed by the facility is stored, he may filter as needed, although, this is very time consuming and he would like to improve the process in order to calculate inquiries faster, for example: How many "pulp" do we have now (in all racks)? How many pulp do we have now (in rack #5)? Filters are a great tool but, they are somewhat limited to answer these kind of question in matter of seconds.

Macro solution:
The coder knows that autofilters are the best, fast and most reliable solution in these kind of scenarios since the data exists already in the worksheet and the input for them can be obtained easily -in this case, by user input-. The approach used is to create a sheet called "SmartFilter" where administrator can easily filter multiple data as needed and calculation will be performed instantly as well.
He uses 2 modules and the Worksheet_Change event for this matter
Code For SmartFilter Worksheet:

Code for module 1, called "General_Functions"

    If 1 = 2 Or DummyRange Is Nothing Then '99. If error Err01General_Functions_Find_Title:
    If IsNeededToExist = True Then MsgBox "Err01General_Functions_Find_Title: Ttile '" &
TitleToFind & "' was not found in sheet '" & InSheet & "'", vbCritical: Call ExcelNormal: On Error
GoTo -1: End
    End If '99. If error
End Function
Code for module 2, called "Inventory_Handling"
Const TitleDesc As String = "DESCRIPTION"
Const TitleLocation As String = "LOCATION"
Const TitleActn As String = "ACTION"
Const TitleQty As String = "QUANTITY"
Const SheetRecords As String = "Record"
Const SheetSmartFilter As String = "SmartFilter"
Const RowFilter As Long = 2
Const ColDataToPaste As Long = 2
Const RowDataToPaste As Long = 7
Const RangeInResult As String = "K1"
Const RangeOutResult As String = "K2"
Sub Inventory_Filter()
Dim ColDesc As Long: ColDesc = General_Functions_Find_Title(SheetSmartFilter, TitleDesc,
IsNeededToExist:=True, IsWhole:=True).Column
Dim ColLocation As Long: ColLocation = General_Functions_Find_Title(SheetSmartFilter,
TitleLocation, IsNeededToExist:=True, IsWhole:=True).Column
Dim ColActn As Long: ColActn = General_Functions_Find_Title(SheetSmartFilter, TitleActn,
IsNeededToExist:=True, IsWhole:=True).Column
Dim ColQty As Long: ColQty = General_Functions_Find_Title(SheetSmartFilter, TitleQty,
IsNeededToExist:=True, IsWhole:=True).Column
Dim CounterQty As Long
Dim TotalQty As Long
Dim TotalIn As Long
Dim TotalOut As Long
Dim RangeFiltered As Range
    Call Select_Sheet(SheetSmartFilter)
    If Cells(Rows.Count, ColDataToPaste).End(xlUp).Row > RowDataToPaste - 1 Then
Rows(RowDataToPaste & ":" & Cells(Rows.Count, "B").End(xlUp).Row).Delete
    Sheets(SheetRecords).AutoFilterMode = False
    If Cells(RowFilter, ColDesc).Value <> "" Or Cells(RowFilter, ColLocation).Value <> "" Or
Cells(RowFilter, ColActn).Value <> "" Then ' 1. If Cells(RowFilter, ColDesc).Value <> "" Or
Cells(RowFilter, ColLocation).Value <> "" Or Cells(RowFilter, ColActn).Value <> ""
    With Sheets(SheetRecords).UsedRange
    If Sheets(SheetSmartFilter).Cells(RowFilter, ColDesc).Value <> "" Then .AutoFilter
Field:=General_Functions_Find_Title(SheetRecords, TitleDesc, IsNeededToExist:=True,
IsWhole:=True).Column, Criteria1:=Sheets(SheetSmartFilter).Cells(RowFilter, ColDesc).Value
    If Sheets(SheetSmartFilter).Cells(RowFilter, ColLocation).Value <> "" Then .AutoFilter
Field:=General_Functions_Find_Title(SheetRecords, TitleLocation, IsNeededToExist:=True,
IsWhole:=True).Column, Criteria1:=Sheets(SheetSmartFilter).Cells(RowFilter, ColLocation).Value
    If Sheets(SheetSmartFilter).Cells(RowFilter, ColActn).Value <> "" Then .AutoFilter
Field:=General_Functions_Find_Title(SheetRecords, TitleActn, IsNeededToExist:=True,
IsWhole:=True).Column, Criteria1:=Sheets(SheetSmartFilter).Cells(RowFilter, ColActn).Value
    'If we don't use a filter we would need to use a cycle For/to or For/Each Cell in range
    'to determine whether or not the row meets the criteria that we are looking and then
    'save it on an array, collection, dictionary, etc
    'IG: For CounterRow = 2 To TotalRows
    'If Sheets(SheetSmartFilter).Cells(RowFilter, ColDesc).Value <> "" and
Sheets(SheetRecords).cells(CounterRow,ColDescInRecords).Value=
Sheets(SheetSmartFilter).Cells(RowFilter, ColDesc).Value then
    'Redim Preserve MyUnecessaryArray(UnecessaryNumber) ''Save to array:
(UnecessaryNumber)=MyUnecessaryArray. Or in a dictionary, etc. At the end, we would transpose this values into the sheet, at the end
    'both are the same, but, just try to see the time invested on each logic.
    If .Cells(1, 1).End(xlDown).Value <> "" Then Set RangeFiltered = .Rows("2:" &
Sheets(SheetRecords).Cells(Rows.Count, "A").End(xlUp).Row).SpecialCells(xlCellTypeVisible)     'If it is not <>"" means that there was not filtered data!
    If RangeFiltered Is Nothing Then MsgBox "Err01Inventory_Filter: No data was found with the given criteria!", vbCritical: Call ExcelNormal: End     RangeFiltered.Copy Destination:=Cells(RowDataToPaste, ColDataToPaste)
    TotalQty = Cells(Rows.Count, ColQty).End(xlUp).Row
    For CounterQty = RowDataToPaste + 1 To TotalQty
    If Cells(CounterQty, ColActn).Value = "In" Then ' 2. If Cells(CounterQty, ColActn).Value = "In"
    TotalIn = Cells(CounterQty, ColQty).Value + TotalIn
    ElseIf Cells(CounterQty, ColActn).Value = "Out" Then ' 2. If Cells(CounterQty, ColActn).Value = "In"
    TotalOut = Cells(CounterQty, ColQty).Value + TotalOut
    End If ' 2. If Cells(CounterQty, ColActn).Value = "In"
    Next CounterQty
    Range(RangeInResult).Value = TotalIn
    Range(RangeOutResult).Value = -(TotalOut)
    End With
    End If ' 1. If Cells(RowFilter, ColDesc).Value <> "" Or Cells(RowFilter, ColLocation).Value <>
"" Or Cells(RowFilter, ColActn).Value <> "" End Sub
Testing and results:

As we saw in the previous image, this task has been achieved easily. By using autofilters a solution was provided that just takes seconds to compute, is easy to explain to the user -since s/he is familiar with this command- and took a few lines to the coder.
Chapter 20: Application object
Section 20.1: Simple Application Object example: Display Excel and VBE Version

The use of the Application.Version property is useful for ensuring code only operates on a compatible version of Excel.
Section 20.2: Simple Application Object example: Minimize the Excel window
This code uses the top level Application object to minimize the main Excel window.


Chapter 21: Charts and Charting
Section 21.1: Creating a Chart with Ranges and a Fixed Name
Charts can be created by working directly with the Series object that defines the chart data. In order to get to the Series without an exisitng chart, you create a ChartObject on a given Worksheet and then get the Chart object from it. The upside of working with the Series object is that you can set the Values and XValues by referring to Range objects. These data properties will properly define the Series with references to those ranges. The downside to this approach is that the same conversion is not handled when setting the Name; it is a fixed value. It will not adjust with the underlying data in the original Range. Checking the SERIES formula and it is obvious that the name is fixed. This must be handled by creating the SERIES formula directly.
Code used to create chart
Note that this code contains extra variable declarations for the Chart and Worksheet. These can be omitted if they're not used. They can be useful however if you are modifying the style or any other chart properties.

Original data/ranges and resulting Chart after code runs
Note that the SERIES formula includes a "B" for the series name instead of a reference to the Range that created it.

Section 21.2: Creating an empty Chart
The starting point for the vast majority of charting code is to create an empty Chart. Note that this Chart is subject to the default chart template that is active and may not actually be empty (if the template has been modified).
ChartObjects.Add(Left, Top,The key to the ChartObject is determining its location. The syntax for the call is 
Width, Height). Once the ChartObject is created, you can use its Chart object to actually modify the chart. The ChartObject behaves more like a Shape to position the chart on the sheet.
Code to create an empty chart


Resulting Chart

Section 21.3: Create a Chart by Modifying the SERIES formula
For complete control over a new Chart and Series object (especially for a dynamic Series name), you must resort to modifying the SERIES formula directly. The process to set up the Range objects is straightforward and the main hurdle is simply the string building for the SERIES formula.
The SERIES formula takes the following syntax:

These contents can be supplied as references or as array values for the data items. Order represents the series position within the chart. Note that the references to the data will not work unless they are fully qualified with the sheet name. For an example of a working formula, click any existing series and check the formula bar.
Code to create a chart and set up data using the SERIES formula
Address(,,,TrueNote that the string building to create the SERIES formula uses .). This ensures that the external Range reference is used so that a fully qualified address with the sheet name is included. You will get an error if the sheet name is excluded.

Original data and resulting chart
Note that for this chart, the series name is properly set with a range to the desired cell. This means that updates will propagate to the Chart.

Section 21.4: Arranging Charts into a Grid
A common chore with charts in Excel is standardizing the size and layout of multiple charts on a single sheet. If done manually, you can hold down  ALT  while resizing or moving the chart to "stick" to cell boundaries. This works for a couple charts, but a VBA approach is much simpler.
Code to create a grid
This code will create a grid of charts starting at a given (Top, Left) position, with a defined number of columns, and a defined common chart size. The charts will be placed in the order they were created and wrap around the edge to form a new row.


Result with several charts
These pictures show the original random layout of charts and the resulting grid from running the code above.
Before

After

Chapter 22: CustomDocumentProperties in practice
Using CustomDocumentProperties (CDPs) is a good method to store user defined values in a relatively safe way within the same work book, but avoiding to show related cell values simply in an unprotected work sheet *).
Note: CDPs represent a separate collection comparable to BuiltInDocumentProperties, but allow to create user defined property names of your own instead of a fixed collection.
*) Alternatively, you could enter values also in a hidden or "very hidden" workbook.
Section 22.1: Organizing new invoice numbers
Incrementing an invoice number and saving its value is a frequent task. Using CustomDocumentProperties (CDPs) is a good method to store such numbers in a relatively safe way within the same work book, but avoiding to show related cell values simply in an unprotected work sheet.
Additional hint:
Alternatively, you could enter values also in a hidden worksheet or even a so called "very hidden" worksheet (see Using xlVeryHidden Sheets. Of course, it's possible to save data also to external files (e.g. ini file, csv or any other type) or the registry.
Example content:
The example below shows
a function NextInvoiceNo that sets and returns the next invoice number, a procedure DeleteInvoiceNo, that deletes the invoice CDP completely, as well as a procedure showAllCDPs listing the complete CDPs collection with all names. Not using VBA, you can also list them via the workbook's information: Info | Properties [DropDown:] | Advanced Properties | Custom
You can get and set the next invoice number (last no plus one) simply by calling the above mentioned function, returning a string value in order to facilitate adding prefixes. "InvoiceNo" is implicitly used as CDP name in all procedures.

Example code:


End Sub


Chapter 23: PowerPoint Integration Through VBA
Section 23.1: The Basics: Launching PowerPoint from VBA
While there are many parameters that can be changed and variations that can be added depending on the desired functionality, this example lays out the basic framework for launching PowerPoint.
Note: This code requires that the PowerPoint reference has been added to the active VBA Project. See the References Documentation entry to learn how to enable the reference.
First, define variables for the Application, Presentation, and Slide Objects. While this can be done with late binding, it is always best to use early binding when applicable.

On Error Resume NextNext, open or create a new instance of the PowerPoint application. Here, the  call is used to avoid an error being thrown by GetObject if PowerPoint has not yet been opened. See the Error Handling example of the Best Practices Topic for a more detailed explanation.

Once the application has been launched, a new presentation and subsequently contained slide is generated for use.
'Generate new Presentation and slide for graphic creation
Set PPPres = PPApp.Presentations.Add
Set PPSlide = PPPres.Slides.Add(1, ppLayoutBlank)
'Here, the slide type is set to the 4:3 shape with slide numbers enabled and the window
'maximized on the screen.  These properties can, of course, be altered as needed
PPApp.ActiveWindow.ViewType = ppViewSlide
PPPres.PageSetup.SlideOrientation = msoOrientationHorizontal
PPPres.PageSetup.SlideSize = ppSlideSizeOnScreen
PPPres.SlideMaster.HeadersFooters.SlideNumber.Visible = msoTrue
PPApp.ActiveWindow.WindowState = ppWindowMaximized
Upon completion of this code, a new PowerPoint window with a blank slide will be open. By using the object variables, shapes, text, graphics, and excel ranges can be added as desired
Chapter 24: How to record a Macro
Section 24.1: How to record a Macro
The easiest way to record a macro is the button in the lower left corner of Excel looks like this: 
When you click on this you will get a pop-up asking you to name the Macro and decide if you want to have a shortcut key. Also, asks where to store the macro and for a description. You can choose any name you want, no spaces are allowed.

If you want to have a shortcut assigned to your macro for quick use choose a letter that you will remember so that you can quickly and easily use the macro over and over.
You can store the macro in "This Workbook," "New Workbook," or "Personal Macro Workbook." If you want the macro you're about to record to be available only in the current workbook, choose "This Workbook." If you want it saved to a brand new workbook, choose "New Workbook." And if you want the macro to be available to any workbook you open, choose "Personal Macro Workbook."
After you have filled out this pop-up click on "Ok".
Then perform whatever actions you want to repeat with the macro. When finished click the same button to stop recording. It now looks like this:

Now you can go to the Developer Tab and open Visual Basic. (or use Alt + F11)
You will now have a new Module under the Modules folder. 
The newest module will contain the macro you just recorded. Double-click on it to bring it up.
I did a simple copy and paste:

If you don't want it to always paste into "A12" you can use Relative References by checking the "Use Relative
References" box on the Developer Tab: 
Following the same steps as before will now turn the Macro into this:

Still copying the value from "A1" into a cell 11 rows down, but now you can perform the same macro with any starting cell and the value from that cell will be copied to the cell 11 rows down.
Chapter 25: SQL in Excel VBA - Best Practices
Section 25.1: How to use ADODB.Connection in VBA?
Requirements:


Create connection
a. with Windows Authentication
Private Sub OpenConnection(pServer As String, pCatalog As String)
    Call mDataBase.Open("Provider=SQLOLEDB;Initial Catalog=" & pCatalog & ";Data Source=" & pServer & ";Integrated Security=SSPI")     mCmd.ActiveConnection = mDataBase End Sub
b. with SQL Server Authentication
Private Sub OpenConnection2(pServer As String, pCatalog As String, pUser As String, pPsw As String)
    Call mDataBase.Open("Provider=SQLOLEDB;Initial Catalog=" & pCatalog & ";Data Source=" & pServer & ";Integrated Security=SSPI;User ID=" & pUser & ";Password=" & pPsw)     mCmd.ActiveConnection = mDataBase End Sub
Execute sql command



How to use it?

Result
ShipperID: 1 CompanyName: Speedy Express Phone: (503) 555-9831
ShipperID: 2 CompanyName: United Package Phone: (503) 555-3199
ShipperID: 3 CompanyName: Federal Shipping Phone: (503) 555-9931
ShipperID: 4 CompanyName: speedy shipping Phone: (503) 555-1234
Chapter 26: Excel-VBA Optimization
Excel-VBA Optimization refers also to coding better error handling by documentation and additional details. This is shown here.
Section 26.1: Optimizing Error Search by Extended Debugging
Using Line Numbers ... and documenting them in case of error ("The importance of seeing Erl")
Detecting which line raises an error is a substantial part of any debugging and narrows the search for the cause. To document identified error lines with a short description completes a successful error tracking, at best together with the names of module and procedure. The example below saves these data to a log file.
Back ground
The error object returns error number (Err.Number) and error description (Err.Description), but doesn't explicitly respond to the question where to locate the error. The Erl function, however, does, but on condition that you add *line numbers ) to the code (BTW one of several other concessions to former Basic times).
If there are no error lines at all, then the Erl function returns 0, if numbering is incomplete you'll get the procedure's last preceding line number.


'Additional Code to show log file

Section 26.2: Disabling Worksheet Updating
Disabling calculation of the worksheet can decrease running time of the macro significantly. Moreover, disabling events, screen updating and page breaks would be beneficial. Following Sub can be used in any macro for this purpose.

For optimization follow the below pseudo-code:

Section 26.3: Row Deletion - Performance
Deleting rows is slow, specially when looping through cells and deleting rows, one by one
A different approach is using an AutoFilter to hide the rows to be deleted
Copy the visible range and Paste it into a new WorkSheet
Remove the initial sheet entirely
 With this method, the more rows to delete, the faster it will be
Example:

Section 26.4: Disabling All Excel Functionality Before executing large macros
The procedures bellow will temporarily disable all Excel features at WorkBook and WorkSheet level
FastWB() is a toggle that accepts On or Off flags
FastWS() accepts an Optional WorkSheet object, or none
If the ws parameter is missing it will turn all features on and off for all WorkSheets in the collection
A custom type can be used to capture all settings before turning them off
At the end of the process, the initial settings can be restored
Public Sub FastWB(Optional ByVal opt As Boolean = True)
    With Application
        .Calculation = IIf(opt, xlCalculationManual, xlCalculationAutomatic)
        If .DisplayAlerts <> Not opt Then .DisplayAlerts = Not opt
        If .DisplayStatusBar <> Not opt Then .DisplayStatusBar = Not opt
        If .EnableAnimations <> Not opt Then .EnableAnimations = Not opt
        If .EnableEvents <> Not opt Then .EnableEvents = Not opt         If .ScreenUpdating <> Not opt Then .ScreenUpdating = Not opt
    End With
    FastWS , opt

Restore all Excel settings to default

Section 26.5: Checking time of execution
Different procedures can give out the same result, but they would use different processing time. In order to check out which one is faster, a code like this can be used:


MicroTimer:

Section 26.6: Using With blocks
Using with blocks can accelerate the process of running a macro. Instead writing a range, chart name, worksheet, etc. you can use with-blocks like below;

Which is faster than this:

Notes:
 Once a With block is entered, object can't be changed. As a result, you can't use a single With statement to affect a number of different objects
 Don't jump into or out of With blocks. If statements in a With block are executed, but either the With or End With statement is not executed, a temporary variable containing a reference to the object remains in memory until you exit the procedure
Don't Loop inside With statements, especially if the cached object is used as an iterator
You can nest With statements by placing one With block within another. However, because members of outer
With blocks are masked within the inner With blocks, you must provide a fully qualified object reference in an inner With block to any member of an object in an outer With block.
Nesting Example:
This example uses the With statement to execute a series of statements on a single object. The object and its properties are generic names used for illustration purposes only.
With MyObject
    .Height = 100               'Same as MyObject.Height = 100.
    .Caption = "Hello World"    'Same as MyObject.Caption = "Hello World".
    With .Font
        .Color = Red            'Same as MyObject.Font.Color = Red.
        .Bold = True            'Same as MyObject.Font.Bold = True.
        MyObject.Height = 200   'Inner-most With refers to MyObject.Font (must be qualified
    End With
End With
More Info on MSDN

Chapter 27: VBA Security
Section 27.1: Password Protect your VBA
Sometimes you have sensitive information in your VBA (e.g., passwords) that you don't want users to have access to. You can achieve basic security on this information by password-protecting your VBA project.
Follow these steps:
1. Open your Visual Basic Editor (Alt + F11)
2. Navigate to Tools -> VBAProject Properties...
3. Navigate to the Protection tab
4. Check off the "Lock project for viewing" checkbox
5. Enter your desired password in the Password and Confirm Password textboxes
Now when someone wants to access your code within an Office application, they will first need to enter the password. Be aware, however, that even a strong VBA project password is trivial to break.

Chapter 28: Debugging and Troubleshooting
Section 28.1: Immediate Window
If you would like to test a line of macro code without needing to run an entire sub, you can type commands directly into the Immediate Window and hit ENTER to run the line.
For testing the output of a line, you can precede it with a question mark ? to print directly to the Immediate Window. Alternatively, you can also use the print command to have the output printed.
CTRL + GWhile in the Visual Basic Editor, press  to open the Immediate Window. To rename your currently selected sheet to "ExampleSheet", type the following in the Immediate Window and hit ENTER

To print the currently selected sheet's name directly in the Immediate Window

This method can be very useful to test the functionality of built in or user defined functions before implementing them in code. The example below demonstrates how the Immediate Window can be used to test the output of a function or series of functions to confirm an expected.
'In this example, the Immediate Window was used to confirm that a series of Left and Right
'string methods would return the desired string
'expected output: "value" print Left(Right("1111value1111",9),5) ' <---- written code here, ENTER pressed value                                  ' <---- output
The Immediate Window can also be used to set or reset Application, Workbook, or other needed properties. This
Application.EnableEvents = Falsecan be useful if you have  in a subroutine that unexpectedly throws an error,
causing it to close without resetting the value to True (which can cause frustrating and unexpected functionality. In that case, the commands can be typed directly into the Immediate Window and run:
? Application.EnableEvents       ' <---- Testing the current state of "EnableEvents"
False                            ' <---- Output
Application.EnableEvents = True  ' <---- Resetting the property value to True
? Application.EnableEvents       ' <---- Testing the current state of "EnableEvents" True                             ' <---- Output
For more advanced debugging techniques, a colon : can be used as a line separator. This can be used for multi-line expressions such as looping in the example below.

Section 28.2: Use Timer to Find Bottlenecks in Performance
The first step in optimizing for speed is finding the slowest sections of code. The Timer VBA function returns the number of seconds elapsed since midnight with a precision of 1/256th of a second (3.90625 milliseconds) on Windows based PCs. The VBA functions Now and Time are only accurate to a second.

Section 28.3: Debugger Locals Window
The Locals window provides easy access to the current value of variables and objects within the scope of the function or subroutine you are running. It is an essential tool to debugging your code and stepping through changes in order to find issues. It also allows you to explore properties you might not have known existed.
Take the following example,

In the VBA Editor, click View --> Locals Window

Then by stepping through the code using F8 after clicking inside the subroutine, we have stopped before getting to assigning findMeinLocals. Below you can see the value is 0 --- and this is what would be used if you never assigned it a value. The range object is 'Nothing'.


If we stop right before the subroutine ends, we can see the final values of the variables.

We can see findMeInLocals with a value of 1 and type of Integer, and FindMeInLocals2 with a type of Range/Range. If we click the + sign we can expand the object and see its properties, such as count or column.

Section 28.4: Debug.Print
Debug.PrintTo print a listing of the Error Code descriptions to the Immediate Window, pass it to the  function:

You can show the Immediate Window by:
 Selecting View | Immediate Window from the menu bar Using the keyboard shortcut Ctrl-G
 Section 28.5: Stop
The Stop command will pause the execution when called. From there, the process can be resumed or be executed step by step.

Section 28.6: Adding a Breakpoint to your code
You can easily add a breakpoint to your code by clicking on the grey column to the left of the line of your VBA code where you want execution to stop. A red dot appears in the column and the breakpoint code is also highlighted in red.
You can add multiple breakpoints throughout your code and resuming execution is achieved by pressing the "play" icon in your menu bar. Not all code can be a breakpoint as variable definition lines, the first or last line of a procedure and comment lines cannot be selected as a breakpoint.

Chapter 29: VBA Best Practices
Section 29.1: ALWAYS Use "Option Explicit"
In the VBA Editor window, from the Tools menu select "Options":

Then in the "Editor" tab, make sure that "Require Variable Declaration" is checked:

Option ExplicitSelecting this option will automatically put  at the top of every VBA module.
Small note: This is true for the modules, class modules, etc. that haven't been opened so far. So if you already had a look at e.g. the code of Sheet1 before activating the option "Require Variable Declaration", Option Explicit will not be added!
Option ExplicitOption Explicit requires that every variable has to be defined before use, e.g. with a Dim statement. Without  enabled, any unrecognized word will be assumed by the VBA compiler to be a new variable of the
Option ExplicitVariant type, causing extremely difficult-to-spot bugs related to typographical errors. With enabled, any unrecognized words will cause a compile error to be thrown, indicating the offending line.
Example :
If you run the following code :

You will get the following message :

Option ExplicitYou have made an error by writing myvariable instead of my_variable, then the message box displays an empty variable. If you use  , this error is not possible because you will get a compile error message indicating the problem.

Now if you add the correct declaration :

You will obtain an error message indicating precisely the error with myvariable :

Dim arr() as LongReDim ar() 'creates new array "ar" - "ReDim ar()" acts like "Dim ar()"Note on Option Explicit and Arrays (Declaring a Dynamic Array):
You can use the ReDim statement to declare an array implicitly within a procedure.
Be careful not to misspell the name of the array when you use the ReDim statement
Even if the Option Explicit statement is included in the module, a new array will be created
Section 29.2: Work with Arrays, Not With Ranges
Office Blog - Excel VBA Performance Coding Best Practices
Often, best performance is achieved by avoiding the use of Range as much as possible. In this example we read in an entire Range object into an array, square each number in the array, and then return the array back to the Range. This accesses Range only twice, whereas a loop would access it 20 times for the read/writes.


More tips and info with timed examples can be found in Charles Williams's Writing efficient VBA UDFs (Part 1) and other articles in the series.
Section 29.3: Switch o properties during macro execution
It is best practice in any programming language to avoid premature optimization. However, if testing reveals that your code is running too slowly, you may gain some speed by switching off some of the application's properties while it runs. Add this code to a standard module:

More info on Office Blog - Excel VBA Performance Coding Best Practices And just call it at beginning and end of macros:

Public SubWhile these can largely be considered "enhancements" for regular  procedures, disabling event
Application.EnableEvents = Falsehandling with  should be considered mandatory for Worksheet_Change and
Workbook_SheetChange private event macros that change values on one or more worksheets. Failure to disable event triggers will cause the event macro to recursively run on top of itself when a value changes and can lead to a "frozen" workbook. Remember to turn events back on before leaving the event macro, possibly through a "safe exit" error handler.

SpeedUp TrueOne caveat: While disabling these settings will improve run time, they may make debugging your application much more difficult. If your code is not functioning correctly, comment out the  call until you figure out the problem.
Application.CalculateThis is particularly important if you are writing to cells in a worksheet and then reading back in calculated results from worksheet functions since the xlCalculationManual prevents the workbook from calculating. To get around this without disabling SpeedUp, you may want to include  to run a calculation at specific points.
NOTE: Since these are properties of the Application itself, you need to ensure that they are enabled again before your macro exits. This makes it particularly important to use error handlers and to avoid multiple exit points (i.e.
Unload MeEnd or ).
With error handling:

Section 29.4: Use VB constants when available

can be used in place of

in order to improve readability.
Use Object Browser to find available VB constants. View → Object Browser or  F2  from VB Editor.

Enter class to search

View members available

Section 29.5: Avoid using SELECT or ACTIVATE
It is very rare that you'll ever want to use SELECT or Activate in your code, but some Excel methods do require a worksheet or workbook to be activated before they'll work as expected.
If you're just starting to learn VBA, you'll often be suggested to record your actions using the macro recorder, then go look at the code. For example, I recorded actions taken to enter a value in cell D3 on Sheet2, and the macro code looks like this:


Sheets("Sheet2").SelectRange("D3").SelectRange("D4").SelectRemember though, the macro recorder creates a line of code for EACH of your (user) actions. This includes clicking on the worksheet tab to select Sheet2 (), clicking on cell D3 before entering the value (), and using the Enter key (which is effectively "selecting" the cell below the currently selected cell: ).
SelectThere are multiple issues with using . here:
Select() is slow. Even if Application.ScreenUpdatingSelect() is unruly. If Application.ScreenUpdatingThe worksheet is not always specified. This happens if you don't switch worksheets while recording, and means that the code will yield different results for different active worksheets.
. is set to False, this is an unneccessary operation to be processed.
. is left to True, Excel will actually select the cells, the
worksheet, the form... whatever it is you're working with. This is stressful to the eyes and really unpleasant to watch.
SelectWorksheet_SelectionChange .	() will trigger listeners. This is a bit advanced already, but unless worked around, functions like () will be triggered.
When you're coding in VBA, all of the "typing" actions (i.e. SELECT statements) are no longer necessary. Your code may be reduced to a single statement to put the value in the cell:

(The BETTER example above shows using intermediate variables to separate different parts of the cell reference. The GOOD example will always work just fine, but can be very cumbersome in much longer code modules and more difficult to debug if one of the references is mistyped.)
**NOTE: the macro recorder makes many assumptions about the type of data you're entering, in this case entering a string value as a formula to create the value. Your code doesn't have to do this and can simply assign a numerical value directly to the cell as shown above.
**NOTE2: the recommended practice is to set your local workbook variable to ThisWorkbook instead of ActiveWorkbook (unless you explicitly need it). The reason is your macro will generally need/use resources in whatever workbook the VBA code originates and will NOT look outside of that workbook -- again, unless you explicitly direct your code to work with another workbook. When you have multiple workbooks open in Excel, the ActiveWorkbook is the one with the focus which may be different from the workbook being viewed in your VBA Editor. So you think you're executing in a one workbook when you're really referencing another. ThisWorkbook refers to the workbook containing the code being executed.
Section 29.6: Always define and set references to all Workbooks and Sheets
When working with multiple open Workbooks, each of which may have multiple Sheets, it's safest to define and set reference to all Workbooks and Sheets.
Don't rely on ActiveWorkbook or ActiveSheet as they might be changed by the user.
The following code example demonstrates how to copy a range from "Raw_Data" sheet in the "Data.xlsx" workbook to "Refined_Data" sheet in the "Results.xlsx" workbook.
The procedure also demonstrates how to copy and paste without using the SELECT method.

Section 29.7: Use descriptive variable naming
Descriptive names and structure in your code help make comments unnecessary

is better than

This is especially helpful when you are copying data from one place to another, whether it's a cell, range, worksheet, or workbook. Help yourself by using names such as these:

If you declare multiple variables in one line make sure to specify a type for every variable like:

The following will only declare the last variable and the first ones will remain Variant:

Section 29.8: Document Your Work
It's good practice to document your work for later use, especially if you are coding for a dynamic workload. Good comments should explain why the code is doing something, not what the code is doing.

If your code is so obscure that it requires comments to explain what it is doing, consider rewriting it to be more clear instead of explaining it through comments. For example, instead of:

Clarify the code to be easier to follow, such as:


Section 29.9: Error Handling
Good error handling prevents end users from seeing VBA runtime errors and helps the developer easily diagnose and correct errors.
There are three main methods of Error Handling in VBA, two of which should be avoided for distributed programs unless specifically required in the code.

or

Prefer using:

On Error GoTo 0
On Error GoTo If no error handling is set in your code, 0 is the default error handler. In this mode, any runtime errors will launch the typical VBA error message, allowing you to either end the code or enter debug mode, identifying the source. While writing code, this method is the simplest and most useful, but it should always be avoided for code that is distributed to end users, as this method is very unsightly and difficult for end users to understand.
On Error Resume Next
Error Resume NextOn Error Resume Next will cause VBA to ignore any errors that are thrown at runtime for all lines following the error call until the error handler has been changed. In very specific instances, this line can be useful, but it should be avoided outside of these cases. For example, when launching a separate program from an Excel Macro, the On  call can be useful if you are unsure whether or not the program is already open:

On Error Resume NextOn Error Resume NextHad we not used the  call and the Powerpoint application was not already open, the GetObject method would throw an error. Thus,  was necessary to avoid creating two instances of the application.
On ErrorResume NextNote: It is also a best practice to immediately reset the error handler as soon as you no longer need the  call
On Error GoTo <line>
On Error GoTo <lineOn Error GoTo <lineThis method of error handling is recommended for all code that is distributed to other users. This allows the programmer to control exactly how VBA handles an error by sending the code to the specified line. The tag can be filled with any string (including numeric strings), and will send the code to the corresponding string that is followed by a colon. Multiple error handling blocks can be used by making different calls of >. The subroutine below demonstrates the syntax of an > call.
Exit SubNote: It is essential that the  line is placed above the first error handler and before every subsequent error handler to prevent the code from naturally progressing into the block without an error being called. Thus, it is best practice for function and readability to place error handlers at the end of a code block.

If you exit your method with your error handling code, ensure that you clean up:
End SubUndo anything that is partially completed
Close files
Reset screen updating
Reset calculation mode
Reset events
Reset mouse pointer
Call unload method on instances of objects, that persist after the 
     Reset status bar
  Section 29.10: Never Assume The Worksheet
Even when all your work is directed at a single worksheet, it's still a very good practice to explicitly specify the worksheet in your code. This habit makes it much easier to expand your code later, or to lift parts (or all) of a Sub or Function to be re-used someplace else. Many developers establish a habit of (re)using the same local variable name for a worksheet in their code, making re-use of that code even more straightforward.
As an example, the following code is ambiguous -- but works! -- as long the developer doesn't activate or change to a different worksheet:

If Sheet1 is active, then cell A1 on Sheet1 will be filled with the current date and time. But if the user changes worksheets for any reason, then the code will update whatever the worksheet is currently active. The destination worksheet is ambiguous.
The best practice is to always identify which worksheet to which your code refers:

The code above is clear in identifying both the workbook and the worksheet. While it may seem like overkill, creating a good habit concerning target references will save you from future problems.
Section 29.11: Avoid re-purposing the names of Properties or Methods as your variables
It is generally not considered 'best practice' to re-purpose the reserved names of Properties or Methods as the name(s) of your own procedures and variables.
Bad Form - While the following is (strictly speaking) legal, working code the re-purposing of the Find method as well as the Row, Column and Address properties can cause problems/conflicts with name ambiguity and is just plain confusing in general.

        Set address = .SpecialCells(xlCellTypeLastCell)         row = .find(what:=find, after:=address).row        '< note .row not capitalized         column = .find(what:=find, after:=address).column  '< note .column not capitalized        
        Debug.Print "The first 'something' is in " & .Cells(row, column).address(0, 0)
    End With
End Sub
Good Form - With all of the reserved words renamed into close but unique approximations of the originals, any potential naming conflicts have been avoided.

While there may come a time when you want to intentionally rewrite a standard method or property to your own specifications, those situations are few and far between. For the most part, stay away from reusing reserved names for your own constructs.
Section 29.12: Avoid using ActiveCell or ActiveSheet in Excel
Using ActiveCell or ActiveSheet can be source of mistakes if (for any reason) the code is executed in the wrong place.
ActiveCell.Value = "Hello"
'will place "Hello" in the cell that is currently selected
Cells(1, 1).Value = "Hello"
'will always place "Hello" in A1 of the currently selected sheet
ActiveSheet.Cells(1, 1).Value = "Hello"
'will place "Hello" in A1 of the currently selected sheet
Sheets("MySheetName").Cells(1, 1).Value = "Hello"
'will always place "Hello" in A1 of the sheet named "MySheetName"
ActiveThe use of * can create problems in long running macros if your user gets bored and clicks on another worksheet or opens another workbook.
It can create problems if your code opens or creates another workbook.
Sheets("MyOtherSheet").SelectIt can create problems if your code uses  and you've forgotten which sheet you were on before you start reading from or writing to it.
Section 29.13: WorksheetFunction object executes faster than a UDF equivalent
VBA is compiled in run-time, which has a huge negative impact on it's performance, everything built-in will be faster, try to use them.
As an example I'm comparing SUM and COUNTIF functions, but you can use if for anything you can solve with WorkSheetFunctions.
A first attempt for those would be to loop through the range and process it cell by cell (using a range):

One improvement can be to store the range values in an array and process that:

Application.WorksheetfunctionBut instead of writing any loop you can use  which is very handy for executing simple formulas:


Application.EvaluateOr, for more complex calculations you can even use :

And finally, running above Subs 25,000 times each, here is the average (5 tests) time in milliseconds (of course it'll be different on each pc, but compared to each other they'll behave similarly):
1. UseWorksheetFunction: 2156 ms
2. UseArray: 2219 ms (+ 3 %)
3. UseEvaluate: 4693 ms (+ 118 %)
4. UseRange: 6530 ms (+ 203 %)

Chapter 30: Excel VBA Tips and Tricks
Section 30.1: Using xlVeryHidden Sheets
Worksheets in excel have three options for the Visible property. These options are represented by constants in the xlSheetVisibility enumeration and are as follows:
1. xlVisible or xlSheetVisible value: -1 (the default for new sheets)
2. xlHidden or xlSheetHidden value: 0
3. xlVeryHidden xlSheetVeryHidden value: 2
Visible sheets represent the default visibility for sheets. They are visible in the sheet tab bar and can be freely selected and viewed. Hidden sheets are hidden from the sheet tab bar and are thus not selectable. However, hidden sheets can be unhidden from the excel window by right clicking on the sheet tabs and selecting "Unhide"
Very Hidden sheets, on the other hand, are only accessible through the Visual Basic Editor. This makes them an incredibly useful tool for storing data across instances of excel as well as storing data that should be hidden from end users. The sheets can be accessed by named reference within VBA code, allowing easy use of the stored data.
To manually change a worksheet's .Visible property to xlSheetVeryHidden, open the VBE's Properties window ( F4 ), select the worksheet you want to change and use the drop-down in the thirteenth row to make your selection.

To change a worksheet's .Visible property to xlSheetVeryHidden¹ in code, similarly access the .Visible property and assign a new value.

¹ Both xlVeryHidden and xlSheetVeryHidden return a numerical value of 2 (they are interchangeable).
Section 30.2: Using Strings with Delimiters in Place of Dynamic Arrays
ReDim PreserveSplitUsing Dynamic Arrays in VBA can be quite clunky and time intensive over very large data sets. When storing simple data types in a dynamic array (Strings, Numbers, Booleans etc.), one can avoid the  statements required of dynamic arrays in VBA by using the () function with some clever string procedures. For example, we will look at a loop that adds a series of values from a range to a string based on some conditions, then uses that string to populate the values of a ListBox.

The Delimiter string itself can be set to any value, but it is prudent to choose a value which will not naturally occur within the set. Say, for example, you were processing a column of dates. In that case, using ., -, or / would be unwise as delimiters, as the dates could be formatted to use any one of these, generating more data points than you anticipated.
Note: There are limitations to using this method (namely the maximum length of strings), so it should be used with caution in cases of very large datasets. This is not necessarily the fastest or most effective method for creating dynamic arrays in VBA, but it is a viable alternative.
Section 30.3: Worksheet .Name, .Index or .CodeName
We know that 'best practise' dictates that a range object should have its parent worksheet explicitly referenced. A worksheet can be referred to by its .Name property, numerical .Index property or its .CodeName property but a user can reorder the worksheet queue by simply dragging a name tab or rename the worksheet with a double-click on the same tab and some typing in an unprotected workbook.
Consider a standard three worksheet. You have renamed the three worksheets Monday, Tuesday and Wednesday in that order and coded VBA sub procedures that reference these. Now consider that one user comes along and decides that Monday belongs at the end of the worksheet queue then another comes along and decides that the worksheet names look better in French. You now have a workbook with a worksheet name tab queue that looks something like the following.
      
If you had used either of the following worksheet reference methods, your code would now be broken.


Both the original order and the original worksheet name have been compromised. However, if you had used the worksheet's .CodeName property, your sub procedure would still be operational

The following image shows the VBA Project window ([Ctrl]+R) which lists the worksheets by .CodeName then by .Name (in brackets). The order they are displayed does not change; the ordinal .Index is taken by the order they are displayed in the name tab queue in the worksheet window.
      
While it is uncommon to rename a .CodeName, it is not impossible. Simply open the VBE's Properties window ([F4]).

The worksheet .CodeName is in the first row. The worksheet's .Name is in the tenth. Both are editable.
Section 30.4: Double Click Event for Excel Shapes
By default, Shapes in Excel do not have a specific way to handle single vs. double clicks, containing only the "OnAction" property to allow you to handle clicks. However, there may be instances where your code requires you to act differently (or exclusively) on a double click. The following subroutine can be added into your VBA project and, when set as the OnAction routine for your shape, allow you to act on double clicks.

This routine will cause the shape to functionally ignore the first click, only running your desired code on the second click within the specified time span.
Section 30.5: Open File Dialog - Multiple Files
This subroutine is a quick example on how to allow a user to select multiple files and then do something with those file paths, such as get the file names and send it to the console via debug.print.

Chapter 31: Common Mistakes
Section 31.1: Qualifying References
When referring to a worksheet, a range or individual cells, it is important to fully qualify the reference.
For example:
ThisWorkbook.Worksheets("Sheet1").Range(Cells(1, 2), Cells(2, 3)).Copy
Is not fully qualified: The Cells references do not have a workbook and worksheet associated with them. Without an explicit reference, Cells refers to the ActiveSheet by default. So this code will fail (produce incorrect results) if a worksheet other than Sheet1 is the current ActiveSheet.
The easiest way to correct this is to use a With statement as follows:

Alternatively, you can use a Worksheet variable. (This will most likely be preferred method if your code needs to reference multiple Worksheets, like copying data from one sheet to another.)

Another frequent problem is referencing the Worksheets collection without qualifying the Workbook. For example:

The worksheet Sheet1 is not fully qualified, and lacks a workbook. This could fail if multiple workbooks are referenced in the code. Instead, use one of the following:
ThisWorkbook.Worksheets("Sheet1")       '<--ThisWorkbook refers to the workbook containing
                                        'the running VBA code
 Workbooks("Book1").Worksheets("Sheet1") '<--Where Book1 is the workbook containing Sheet1 However, avoid using the following:
ActiveWorkbook.Worksheets("Sheet1")     '<--Valid, but if another workbook is activated
                                        'the reference will be changed
Similarly for range objects, if not explicitly qualified, the range will refer to the currently active sheet:

Is the same as:

Section 31.2: Deleting rows or columns in a loop
If you want to delete rows (or columns) in a loop, you should always loop starting from the end of range and move back in every step. In case of using the code:

You will miss some rows. For example, if the code deletes row 3, then row 4 becomes row 3. However, variable i will change to 4. So, in this case the code will miss one row and check another, which wasn't in range previously.
The right code would be

Section 31.3: ActiveWorkbook vs. ThisWorkbook
ActiveWorkbook and ThisWorkbook sometimes get used interchangeably by new users of VBA without fully understanding which each object relates to, this can cause undesired behaviour at run-time. Both of these objects belong to the Application Object
The ActiveWorkbook object refers to the workbook that is currently in the top-most view of the Excel application object at the time of execution. (e.g. The workbook that you can see and interact with at the point when this object is referenced)

The ThisWorkbook object refers to the workbook in which the code belongs to at the time it is being executed.


Section 31.4: Single Document Interface Versus Multiple Document Interfaces
Be aware that Microsoft Excel 2013 (and higher) uses Single Document Interface (SDI) and that Excel 2010 (And below) uses Multiple Document Interfaces (MDI).
This implies that for Excel 2013 (SDI), each workbook in a single instance of Excel contains its own ribbon UI:

Conversely for Excel 2010, each workbook in a single instance of Excel utilized a common ribbon UI (MDI):

This raise some important issues if you want to migrate a VBA code (2010 <->2013) that interact with the Ribbon.
A procedure has to be created to update ribbon UI controls in the same state across all workbooks for Excel 2013 and Higher.
Note that :
1. All Excel application-level window methods, events, and properties remain unaffected.
Application.ActiveWindow, Application.Windows( ... )
2. In Excel 2013 and higher (SDI) all of the workbook-level window methods, events, and properties now operate on the top level window. It is possible to retrieve the handle of this top level window with
Application.HwndTo get more details, see the source of this example: MSDN.
This also causes some trouble with modeless userforms. See Here for a solution.
Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
AdamChapter 4Alexis OlsonChapter 29Alon AdlerChapter 2Andy TerraChapters 5 and 30Branislav KollárChapters 1, 4 and 29Byron WallChapter 21Captain GrumpyChapters 18 and 20ChelChapters 27 and 29Cody G.Chapters 1, 28, 29 and 30CominternChapter 29curiousChapter 14Doug CoatsChapters 1, 4 and 12EEMChapter 1Egan WolfChapter 31EtheurChapter 28Excel DevelopersChapter 11FreeManChapter 29genesposChapter 29Gordon BellChapters 1 and 31Gregor yChapter 28HubisanChapters 2, 14 and 29JeepedChapters 8, 18, 29 and 30jlookupChapter 18Joel SpolskyChapters 1, 4 and 20Julian KuchlbauerChapter 28KazChapter 1KyleChapters 28 and 29Máté JuhászChapter 29Macro ManChapters 1, 29, 30 and 31MalickChapters 1, 8, 18, 29 and 31MasoudChapter 26Miguel_RyuChapter 2MikeChapter 24Miqi180Chapter 14MunkeefaceChapter 29paul bicaChapters 14, 26 and 29PeterTChapters 10, 17 and 29Portland RunnerChapters 5 and 29P	ʜChapter 29quadratureChapters 7 and 15R3uKChapters 6 and 14RGAChapters 1, 14, 23, 28, 29 and 30RobbyChapter 24Ron McMahonChapter 28SgdvaChapter 19ShahinChapter 2Shai RadoChapters 1, 12, 14 and 29SlaiChapters 8 and 14Stefan PinnowChapter 29SteveESChapter 3Steven SchroederChapters 28 and 29SWaChapter 31T.M.Chapters 7, 22 and 26TheGuyThatDoesn'tKnowMuch Chapter 27
ThunderFrame Chapter 29 Toast Chapters 1, 28 and 31 user3561813 Chapter 8 Vegard Chapters 4 and 8
Verzweifler Chapter 29 Vityata	Chapter 13
Zsmaster	Chapters 9, 16 and 25

You may also like







GoalKicker.com - Excel(r) VBA Notes for Professionals	1

GoalKicker.com - Excel(r) VBA Notes for Professionals	1

GoalKicker.com - Excel(r) VBA Notes for Professionals	1







