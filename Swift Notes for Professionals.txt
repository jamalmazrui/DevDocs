

Contents
About	1
Chapter 1: Getting started with Swift Language	2
Section 1.1: Your first Swift program	2
Section 1.2: Your first program in Swift on a Mac (using a Playground)	3
Section 1.3: Your first program in Swift Playgrounds app on iPad	7
Section 1.4: Installing Swift	8
Section 1.5: Optional Value and Optional enum	8
Chapter 2: Variables & Properties	10
Section 2.1: Creating a Variable	10
Section 2.2: Property Observers	10
Section 2.3: Lazy Stored Properties	11
Section 2.4: Property Basics	11
Section 2.5: Computed Properties	12
Section 2.6: Local and Global Variables	12
Section 2.7: Type Properties	13
Chapter 3: Numbers	14
Section 3.1: Number types and literals	14
Section 3.2: Convert numbers to/from strings	15
Section 3.3: Rounding	15
Section 3.4: Random number generation	16
Section 3.5: Convert one numeric type to another	17
Section 3.6: Exponentiation	17
Chapter 4: Strings and Characters	18
Section 4.1: String & Character Literals	18
Section 4.2: Concatenate strings	19
Section 4.3: String Encoding and Decomposition	20
Section 4.4: Examine and compare strings	20
Section 4.5: Reversing Strings	21
Section 4.6: Check if String contains Characters from a Defined Set	21
Section 4.7: String Iteration	22
Section 4.8: Splitting a String into an Array	24
Section 4.9: Unicode	24
Section 4.10: Converting Swift string to a number type	25
Section 4.11: Convert String to and from Data / NSData	25
Section 4.12: Formatting Strings	26
Section 4.13: Uppercase and Lowercase Strings	26
Section 4.14: Remove characters from a string not defined in Set	27
Section 4.15: Count occurrences of a Character into a String	27
Section 4.16: Remove leading and trailing WhiteSpace and NewLine	27
Chapter 5: Booleans	29
Section 5.1: What is Bool?	29
Section 5.2: Booleans and Inline Conditionals	29
Section 5.3: Boolean Logical Operators	30
Section 5.4: Negate a Bool with the prefix ! operator	30
Chapter 6: Arrays	31
Section 6.1: Basics of Arrays	31
Section 6.2: Extracting values of a given type from an Array with flatMap(_:)	32
Section 6.3: Combining an Array's elements with reduce(_:combine:)	32
Section 6.4: Flattening the result of an Array transformation with flatMap(_:)	33
Section 6.5: Lazily flattening a multidimensional Array with flatten()	33
Section 6.6: Filtering out nil from an Array transformation with flatMap(_:)	34
Section 6.7: Subscripting an Array with a Range	34
Section 6.8: Removing element from an array without knowing it's index	35
Section 6.9: Sorting an Array of Strings	35
Section 6.10: Accessing indices safely	36
Section 6.11: Filtering an Array	37
Section 6.12: Transforming the elements of an Array with map(_:)	37
Section 6.13: Useful Methods	38
Section 6.14: Sorting an Array	38
Section 6.15: Finding the minimum or maximum element of an Array	39
Section 6.16: Modifying values in an array	40
Section 6.17: Comparing 2 Arrays with zip	40
Section 6.18: Grouping Array values	41
Section 6.19: Value Semantics	42
Section 6.20: Accessing Array Values	42
Chapter 7: Tuples	44
Section 7.1: What are Tuples?	44
Section 7.2: Decomposing into individual variables	44
Section 7.3: Tuples as the Return Value of Functions	45
Section 7.4: Using a typealias to name your tuple type	45
Section 7.5: Swapping values	46
Section 7.6: Tuples as Case in Switch	46
Chapter 8: Enums	48
Section 8.1: Basic enumerations	48
Section 8.2: Enums with associated values	48
Section 8.3: Indirect payloads	49
Section 8.4: Raw and Hash values	50
Section 8.5: Initializers	51
Section 8.6: Enumerations share many features with classes and structures	52
Section 8.7: Nested Enumerations	53
Chapter 9: Structs	54
Section 9.1: Structs are value types	54
Section 9.2: Accessing members of struct	54
Section 9.3: Basics of Structs	54
Section 9.4: Mutating a Struct	55
Section 9.5: Structs cannot inherit	55
Chapter 10: Sets	57
Section 10.1: Declaring Sets	57
Section 10.2: Performing operations on sets	57
Section 10.3: CountedSet	58
Section 10.4: Modifying values in a set	58
Section 10.5: Checking whether a set contains a value	58
Section 10.6: Adding values of my own type to a Set	58
Chapter 11: Dictionaries	60
Section 11.1: Declaring Dictionaries	60
Section 11.2: Accessing Values	60
Section 11.3: Change Value of Dictionary using Key	61
Section 11.4: Get all keys in Dictionary	61
Section 11.5: Modifying Dictionaries	61
Section 11.6: Merge two dictionaries	62
Chapter 12: Switch	63
Section 12.1: Switch and Optionals	63
Section 12.2: Basic Use	63
Section 12.3: Matching a Range	63
Section 12.4: Partial matching	64
Section 12.5: Using the where statement in a switch	65
Section 12.6: Matching Multiple Values	65
Section 12.7: Switch and Enums	66
Section 12.8: Switches and tuples	66
Section 12.9: Satisfy one of multiple constraints using switch	67
Section 12.10: Matching based on class - great for prepareForSegue	67
Section 12.11: Switch fallthroughs	68
Chapter 13: Optionals	69
Section 13.1: Types of Optionals	69
Section 13.2: Unwrapping an Optional	69
Section 13.3: Nil Coalescing Operator	71
Section 13.4: Optional Chaining	71
Section 13.5: Overview - Why Optionals?	72
Chapter 14: Conditionals	74
Section 14.1: Optional binding and "where" clauses	74
Section 14.2: Using Guard	75
Section 14.3: Basic conditionals: if-statements	75
Section 14.4: Ternary operator	76
Section 14.5: Nil-Coalescing Operator	77
Chapter 15: Error Handling	78
Section 15.1: Error handling basics	78
Section 15.2: Catching dierent error types	79
Section 15.3: Catch and Switch Pattern for Explicit Error Handling	80
Section 15.4: Disabling Error Propagation	81
Section 15.5: Create custom Error with localized description	81
Chapter 16: Loops	83
Section 16.1: For-in loop	83
Section 16.2: Repeat-while loop	85
Section 16.3: For-in loop with filtering	85
Section 16.4: Sequence Type forEach block	86
Section 16.5: while loop	86
Section 16.6: Breaking a loop	87
Chapter 17: Protocols	88
Section 17.1: Protocol Basics	88
Section 17.2: Delegate pattern	90
Section 17.3: Associated type requirements	91
Section 17.4: Class-Only Protocols	93
Section 17.5: Protocol extension for a specific conforming class	94
Section 17.6: Using the RawRepresentable protocol (Extensible Enum)	94
Section 17.7: Implementing Hashable protocol	95
Chapter 18: Functions	97
Section 18.1: Basic Use	97
Section 18.2: Functions with Parameters	97
Section 18.3: Subscripts	98
Section 18.4: Methods	99
Section 18.5: Variadic Parameters	100
Section 18.6: Operators are Functions	100
Section 18.7: Passing and returning functions	101
Section 18.8: Function types	101
Section 18.9: Inout Parameters	101
Section 18.10: Throwing Errors	101
Section 18.11: Returning Values	102
Section 18.12: Trailing Closure Syntax	102
Section 18.13: Functions With Closures	103
Chapter 19: Extensions	105
Section 19.1: What are Extensions?	105
Section 19.2: Variables and functions	105
Section 19.3: Initializers in Extensions	106
Section 19.4: Subscripts	106
Section 19.5: Protocol extensions	106
Section 19.6: Restrictions	107
Section 19.7: What are extensions and when to use them	107
Chapter 20: Classes	109
Section 20.1: Defining a Class	109
Section 20.2: Properties and Methods	109
Section 20.3: Reference Semantics	109
Section 20.4: Classes and Multiple Inheritance	110
Section 20.5: deinit	111
Chapter 21: Type Casting	112
Section 21.1: Downcasting	112
Section 21.2: Type casting in Swift Language	112
Section 21.3: Upcasting	114
Section 21.4: Example of using a downcast on a function parameter involving subclassing	114
Section 21.5: Casting with switch	115
Chapter 22: Generics	116
Section 22.1: The Basics of Generics	116
Section 22.2: Constraining Generic Placeholder Types	117
Section 22.3: Generic Class Examples	118
Section 22.4: Using Generics to Simplify Array Functions	119
Section 22.5: Advanced Type Constraints	119
Section 22.6: Generic Class Inheritance	120
Section 22.7: Use generics to enhance type-safety	121
Chapter 23: OptionSet	122
Section 23.1: OptionSet Protocol	122
Chapter 24: Reading & Writing JSON	123
Section 24.1: JSON Serialization, Encoding, and Decoding with Apple Foundation and the Swift StandardLibrary	123
Section 24.2: SwiftyJSON	126
Section 24.3: Freddy	127
Section 24.4: JSON Parsing Swift 3	129
Section 24.5: Simple JSON parsing into custom objects	131
Section 24.6: Arrow	132
Chapter 25: Advanced Operators	135
Section 25.1: Bitwise Operators	135
Section 25.2: Custom Operators	136
Section 25.3: Overflow Operators	137
Section 25.4: Commutative Operators	137
Section 25.5: Overloading + for Dictionaries	138
Section 25.6: Precedence of standard Swift operators	138
Chapter 26: Method Swizzling	140
Section 26.1: Extending UIViewController and Swizzling viewDidLoad	140
Section 26.2: Basics of Swift Swizzling	141
Section 26.3: Basics of Swizzling - Objective-C	141
Chapter 27: Reflection	143
Section 27.1: Basic Usage for Mirror	143
Section 27.2: Getting type and names of properties for a class without having to instantiate it	143
Chapter 28: Access Control	147
Section 28.1: Basic Example using a Struct	147
Section 28.2: Subclassing Example	148
Section 28.3: Getters and Setters Example	148
Chapter 29: Closures	149
Section 29.1: Closure basics	149
Section 29.2: Syntax variations	150
Section 29.3: Passing closures into functions	150
Section 29.4: Captures, strong/weak references, and retain cycles	152
Section 29.5: Using closures for asynchronous coding	153
Section 29.6: Closures and Type Alias	154
Chapter 30: Initializers	155
Section 30.1: Convenience init	155
Section 30.2: Setting default property values	157
Section 30.3: Customizing initialization with parameters	158
Section 30.4: Throwable Initilizer	159
Chapter 31: Associated Objects	160
Section 31.1: Property, in a protocol extension, achieved using associated object	160
Chapter 32: Concurrency	163
Section 32.1: Obtaining a Grand Central Dispatch (GCD) queue	163
Section 32.2: Concurrent Loops	163
Section 32.3: Running tasks in a Grand Central Dispatch (GCD) queue	164
Section 32.4: Running Tasks in an OperationQueue	166
Section 32.5: Creating High-Level Operations	167
Chapter 33: Getting Started with Protocol Oriented Programming	169
Section 33.1: Using protocols as first class types	169
Section 33.2: Leveraging Protocol Oriented Programming for Unit Testing	172
Chapter 34: Functional Programming in Swift	174
Section 34.1: Extracting a list of names from a list of Person(s)	174
Section 34.2: Traversing	174
Section 34.3: Filtering	174
Section 34.4: Using Filter with Structs	175
Section 34.5: Projecting	176
Chapter 35: Function as first class citizens in Swift	178
Section 35.1: Assigning function to a variable	178
Section 35.2: Passing function as an argument to another function, thus creating a Higher-Order Function 	179
Section 35.3: Function as return type from another function	179
Chapter 36: Blocks	180
Section 36.1: Non-escaping closure	180
Section 36.2: Escaping closure	180
Chapter 37: The Defer Statement	182
Section 37.1: When to use a defer statement	182
Section 37.2: When NOT to use a defer statement	182
Chapter 38: Style Conventions	183
Section 38.1: Fluent Usage	183
Section 38.2: Clear Usage	184
Section 38.3: Capitalization	185
Chapter 39: NSRegularExpression in Swift	187
Section 39.1: Extending String to do simple pattern matching	187
Section 39.2: Basic Usage	188
Section 39.3: Replacing Substrings	188
Section 39.4: Special Characters	189
Section 39.5: Validation	189
Section 39.6: NSRegularExpression for mail validation	189
Chapter 40: RxSwift	191
Section 40.1: Disposing	191
Section 40.2: RxSwift basics	191
Section 40.3: Creating observables	192
Section 40.4: Bindings	193
Section 40.5: RxCocoa and ControlEvents	193
Chapter 41: Swift Package Manager	196
Section 41.1: Creation and usage of a simple Swift package	196
Chapter 42: Working with C and Objective-C	198
Section 42.1: Use a module map to import C headers	198
Section 42.2: Using Objective-C classes from Swift code	198
Section 42.3: Specify a bridging header to swiftc	200
Section 42.4: Use the C standard library	200
Section 42.5: Fine-grained interoperation between Objective-C and Swift	200
Section 42.6: Using Swift classes from Objective-C code	201
Chapter 43: Documentation markup	203
Section 43.1: Class documentation	203
Section 43.2: Documentation styles	203
Chapter 44: Typealias	207
Section 44.1: typealias for closures with parameters	207
Section 44.2: typealias for empty closures	207
Section 44.3: typealias for other types	207
Chapter 45: Dependency Injection	208
Section 45.1: Dependency Injection with View Controllers	208
Section 45.2: Dependency Injection Types	211
Chapter 46: Caching on disk space	214
Section 46.1: Reading	214
Section 46.2: Saving	214
Chapter 47: Algorithms with Swift	215
Section 47.1: Sorting	215
Section 47.2: Insertion Sort	218
Section 47.3: Selection sort	218
Section 47.4: Asymptotic analysis	219
Section 47.5: Quick Sort - O(n log n) complexity time	219
Section 47.6: Graph, Trie, Stack	220
Chapter 48: Swift Advance functions	234
Section 48.1: Flatten multidimensional array	234
Section 48.2: Introduction with advance functions	234
Chapter 49: Completion Handler	236
Section 49.1: Completion handler with no input argument	236
Section 49.2: Completion handler with input argument	236
Chapter 50: Swift HTTP server by Kitura	238
Section 50.1: Hello world application	238
Chapter 51: Generate UIImage of Initials from String	241
Section 51.1: InitialsImageFactory	241
Chapter 52: Design Patterns - Creational	242
Section 52.1: Singleton	242
Section 52.2: Builder Pattern	242
Section 52.3: Factory Method	248
Section 52.4: Observer	249
Section 52.5: Chain of responsibility	250
Section 52.6: Iterator	252
Chapter 53: Design Patterns - Structural	253
Section 53.1: Adapter	253
Section 53.2: Facade	253
Chapter 54: (Unsafe) Buer Pointers	255
Section 54.1: UnsafeMutablePointer	255
Section 54.2: Practical Use-Case for Buer Pointers	256
Chapter 55: Cryptographic Hashing	257
Section 55.1: HMAC with MD5, SHA1, SHA224, SHA256, SHA384, SHA512 (Swift 3)	257
Section 55.2: MD2, MD4, MD5, SHA1, SHA224, SHA256, SHA384, SHA512 (Swift 3)	258
Chapter 56: AES encryption	260
Section 56.1: AES encryption in CBC mode with a random IV (Swift 3.0)	260
Section 56.2: AES encryption in CBC mode with a random IV (Swift 2.3)	262
Section 56.3: AES encryption in ECB mode with PKCS7 padding	264
Chapter 57: PBKDF2 Key Derivation	266
Section 57.1: Password Based Key Derivation 2 (Swift 3)	266
Section 57.2: Password Based Key Derivation 2 (Swift 2.3)	267
Section 57.3: Password Based Key Derivation Calibration (Swift 2.3)	268
Section 57.4: Password Based Key Derivation Calibration (Swift 3)	268
Chapter 58: Logging in Swift	270
Section 58.1: dump	270
Section 58.2: Debug Print	271
Section 58.3: print() vs dump()	272
Section 58.4: print vs NSLog	272
Chapter 59: Memory Management	274
Section 59.1: Reference Cycles and Weak References	274
Section 59.2: Manual Memory Management	275
Chapter 60: Performance	276
Section 60.1: Allocation Performance	276
Credits	278
You may also like	282


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/SwiftBook
This Swift(tm) Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Swift(tm) group(s) or company(s) nor Stack Overflow. All
trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Swift Language
	Swift Version	Xcode Version Release Date
development began (first commit) -2010-07-171.0Xcode 62014-06-021.1Xcode 6.12014-10-161.2Xcode 6.32015-02-092.0Xcode 72015-06-082.1Xcode 7.12015-09-23open-source debut-2015-12-032.2Xcode 7.32016-03-212.3Xcode 82016-09-133.0Xcode 82016-09-133.1Xcode 8.32017-03-274.0Xcode 92017-11-194.1Xcode 9.32018-03-29Section 1.1: Your first Swift program

This will compile your code into hello file. To run it, enter ./, followed by a filename.

code in the interpreter:


Press  CTRL + D  to quit from REPL.
Section 1.2: Your first program in Swift on a Mac (using a Playground)
From your Mac, download and install Xcode from the Mac App Store following this link.
After the installation is complete, open Xcode and select Get started with a Playground:

On the next panel, you can give your Playground a name or you can leave it MyPlayground and press Next:

Select a location where to save the Playground and press Create:

The Playground will open and your screen should look something like this:


Finally delete the text inside Playground and type:

You should see 'Hello world' in the Debug Area and "Hello world\n" in the right Sidebar:

Congratulations! You've created your first program in Swift!
Section 1.3: Your first program in Swift Playgrounds app on iPad
Swift Playgrounds app is a great way to get started coding Swift on the go. To use it:
1- Download Swift Playgrounds for iPad from App Store.

2- Open the app.
3- In the My Playgrounds tab, tap + on the top left corner and then select Blank template.
4- Enter your code.
5- Tap Run My Code to run your code.
6- At the front of each line, the result will be stored in a small square. Tap it to reveal the result.
7- To step slowly through code to trace it, tap the button next to Run My Code.
Section 1.4: Installing Swift
First, download the compiler and components.
Next, add Swift to your path. On macOS, the default location for the downloadable toolchain is /Library/Developer/Toolchains. Run the following command in Terminal: export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:"${PATH}" On Linux, you will need to install clang:

If you installed the Swift toolchain to a directory other than the system root, you will need to run the following command, using the actual path of your Swift installation:

You can verify you have the current version of Swift by running this command:

Section 1.5: Optional Value and Optional enum
Optionals type, which handles the absence of a value. Optionals say either "there is a value, and it equals x" or "there isn't a value at all".
SomeAn Optional is a type on its own, actually one of Swift's new super-powered enums. It has two possible values, None and (T), where T is an associated value of the correct data type available in Swift.
Let's have a look at this piece of code for example:

print(x.dynamicTypeIn fact if you add a ) statement in the code above you'll see this in the console:

String? is actually syntactic sugar for Optional, and Optional is a type in its own right.
Here's a simplified version of the header of Optional, which you can see by command-clicking on the word Optional in your code from Xcode:

nonesomeOptional is actually an enum, defined in relation to a generic type Wrapped. It has two cases: . to represent the absence of a value, and . to represent the presence of a value, which is stored as its associated value of type Wrapped.
String? is not a String but an Optional<StringLet me go through it again: >.The fact that Optional is a type means that it has its own methods, for example map and flatMap.
Chapter 2: Variables & Properties
Section 2.1: Creating a Variable
Declare a new variable with var, followed by a name, type, and value:

Variables can have their values changed:

Unless they're defined with let:

Swift infers the type of variable, so you don't always have to declare variable type:

Variable names aren't restricted to letters and numbers - they can also contain most other unicode characters, although there are some restrictions

Section 2.2: Property Observers
Property observers respond to changes to a property's value.

 didSet is called after myProperty is set. The old value is available as oldValue, and the new value is now available as myProperty .

Section 2.3: Lazy Stored Properties
Lazy stored properties have values that are not calculated until first accessed. This is useful for memory saving when the variable's calculation is computationally expensive. You declare a lazy property with lazy:

Often it is assigned to a return value of a closure:

Section 2.4: Property Basics
Properties can be added to a class or struct (technically enums too, see "Computed Properties" example). These add values that associate with instances of classes/structs:

In the above case, instances of Dog have a property named name of type String. The property can be accessed and modified on instances of Dog:

These types of properties are considered stored properties, as they store something on an object and affect its memory.
Section 2.5: Computed Properties
Different from stored properties, computed properties are built with a getter and a setter, performing necessary code when accessed and set. Computed properties must define a type:

A read-only computed property is still declared with a var:

Read-only computed properties can be shortened to exclude get:

Section 2.6: Local and Global Variables
Local variables are defined within a function, method, or closure:


Global variables are defined outside of a function, method, or closure, and are not defined within a type (think outside of all brackets). They can be used anywhere:

Global variables are defined lazily (see "Lazy Properties" example).
Section 2.7: Type Properties
Type properties are properties on the type itself, not on the instance. They can be both stored or computed properties. You declare a type property with static:

In a class, you can use the class keyword instead of static to make it overridable. However, you can only apply this on computed properties:

This is used often with the singleton pattern.
Chapter 3: Numbers
Section 3.1: Number types and literals
Swift's built-in numeric types are:
Word-sized (architecture-dependent) signed Int and unsigned UInt.
Fixed-size signed integers Int8, Int16, Int32, Int64, and unsigned integers UInt8, UInt16, UInt32, UInt64. Floating-point types Float32/Float, Float64/Double, and Float80 (x86-only).
Literals
A numeric literal's type is inferred from context:

Underscores (_) may be used to separate digits in numeric literals. Leading zeros are ignored.
Floating point literals may be specified using significand and exponent parts (gnificand" e "exponent" for decimal; b> "significand" p "exponent" for hexadecimal).


let hexadecimal = 0xFEEDp+3         // equivalent to 65261×2³, or 522088.0 let hexadecimal = 0x1234.5P4        // equivalent to 0x12345, or 74565.0 let hexadecimal = 0x123.45P8        // equivalent to 0x12345, or 74565.0 let hexadecimal = 0x12.345P12       // equivalent to 0x12345, or 74565.0 let hexadecimal = 0x1.2345P16       // equivalent to 0x12345, or 74565.0 let hexadecimal = 0x0.12345P20      // equivalent to 0x12345, or 74565.0
Section 3.2: Convert numbers to/from strings
Use String initializers for converting numbers into strings:
String(1635999)                              // returns "1635999"
String(1635999, radix: 10)                   // returns "1635999"
String(1635999, radix: 2)                    // returns "110001111011010011111"
String(1635999, radix: 16)                   // returns "18f69f" String(1635999, radix: 16, uppercase: true)  // returns "18F69F" String(1635999, radix: 17)                   // returns "129gf4"
 String(1635999, radix: 36)                   // returns "z2cf" Or use string interpolation for simple cases:

Use initializers of numeric types to convert strings into numbers:
if let num = Int("42") { /* ... */ }                // num is 42 if let num = Int("Z2cF") { /* ... */ }              // returns nil (not a number) if let num = Int("z2cf", radix: 36) { /* ... */ }   // num is 1635999 if let num = Int("Z2cF", radix: 36) { /* ... */ }   // num is 1635999
if let num = Int8("Z2cF", radix: 36) { /* ... */ }  // returns nil (too large for Int8)
Section 3.3: Rounding
round
Rounds the value to the nearest whole number with x.5 rounding up (but note that -x.5 rounds down).

ceil
Rounds any number with a decimal value up to the next larger whole number.


Rounds any number with a decimal value down to the next smaller whole number.

Int

     round, ceil and floor handle both 64 and 32 bit architecture.
  Section 3.4: Random number generation
arc4random_uniform(someNumber: UInt32) -> UInt32someNumber This gives you random integers in the range 0 to - 1.
32 The maximum value for UInt32 is 4,294,967,295 (that is, 2^- 1).
Examples:

General form:

where number, max, and min are UInt32.
Notes
 There is a slight modulo bias with arc4random so arc4random_uniform is preferred. You can cast a UInt32 value to an Int but just beware of going out of range.
 Section 3.5: Convert one numeric type to another

Integer initializers produce a runtime error if the value overflows or underflows:

Float-to-integer conversion rounds values towards zero:

Integer-to-float conversion may be lossy:

Section 3.6: Exponentiation
powIn Swift, we can exponentiate Doubles with the built-in () method:

In the code below, the base (5) is set to the power of the exponent (2) :

Chapter 4: Strings and Characters
Section 4.1: String & Character Literals
String literals in Swift are delimited with double quotes ("):

Characters can be initialized from string literals, as long as the literal contains only one grapheme cluster:

String Interpolation
String interpolation allows injecting an expression directly into a string literal. This can be done with all types of values, including strings, integers, floating point numbers and more.
\\(valueThe syntax is a backslash followed by parentheses wrapping the value: ). Any valid expression may appear in the parentheses, including function calls.
let number = 5 let interpolatedNumber = "\\(number)"  // string is "5" let fortyTwo = "\\(6 * 7)"             // string is "42"
let example = "This post has \\(number) view\\(number == 1 ? "" : "s")"
// It will output "This post has 5 views" for the above example.
// If the variable number had the value 1, it would output "This post has 1 view" instead.
\\(myobj)" is equivalent to String(myobjFor custom types, the default behavior of string interpolation is that "),
print(myobjthe same representation used by ). You can customize this behavior by implementing the CustomStringConvertible protocol for your type.
Version ≥ 3.0
String.init<T>(_:) has been renamed to String.init<T>(describingFor Swift 3, in accordance with SE-0089, :).
\\(myobj)" will prefer the new String.init<T: LosslessStringConvertibleinit<T>(describingThe string interpolation ">(_:) initializer, but will fall back to :) if the value is not LosslessStringConvertible.
Special Characters
Certain characters require a special escape sequence to use them in string literals:
Character	Meaning
\\	0	the null character
\\\\a plain backslash, \\\\ta tab character\\va vertical tab\\ra carriage return\\na line feed ("newline")\\	"	a double quote, "
\\'	a single quote, '
\\u{n}	the Unicode code point n (in hexadecimal) Example:

Section 4.2: Concatenate strings
Concatenate strings with the + operator to produce a new string:

Append to a mutable string using the += compound assignment operator, or using a method:

Append a single character to a mutable String:

Append multiple characters to a mutable String
var alphabet:String = "my ABCs: " alphabet.append(contentsOf: (0x61...0x7A).map(UnicodeScalar.init)
                                         .map(Character.init) )
// produces a modified string (alphabet) = "my ABCs: abcdefghijklmnopqrstuvwxyz"
Version ≥ 3.0
appendContentsOf(_:) has been renamed to append(_:).
joinWithSeparatorJoin a sequence of strings to form a new string using (_:):

Version ≥ 3.0
joinWithSeparator(_:) has been renamed to joined(separator:).
"a", "b", "c"].joined() == "abc"The separator is the empty string by default, so [.
Section 4.3: String Encoding and Decomposition
A Swift String is made of Unicode code points. It can be decomposed and encoded in several different ways. let str = "ที่
Decomposing Strings
A string's characters are Unicode extended grapheme clusters:
Array(str.characters)  // ["ท", "ี่	", "①", "!"]
The unicodeScalars are the Unicode code points that make up a string (notice that ท is one grapheme cluster, butี่ 3 code points - 3607, 3637, 3656 - so the length of the resulting array is not the same as with characters): str.unicodeScalars.map{ $0.value }  // [3607, 3637, 3656, 128076, 9312, 33]
You can encode and decompose strings as UTF-8 (a sequence of UInt8s) or UTF-16 (a sequence of UInt16s):
Array(str.utf8)   // [224, 184, 151, 224, 184, 181, 224, 185, 136, 240, 159, 145, 140, 226, 145, 160, 33]
Array(str.utf16)  // [3607, 3637, 3656, 55357, 56396, 9312, 33]
String Length and Iteration
A string's characters, unicodeScalars, utf8, and utf16 are all Collections, so you can get their count and iterate over them:

Section 4.4: Examine and compare strings
Check whether a string is empty:

Check whether two strings are equal (in the sense of Unicode canonical equivalence):


Check whether a string starts/ends with another string:

Section 4.5: Reversing Strings
Version = 2.2

Version = 3.0

Section 4.6: Check if String contains Characters from a Defined Set
Letters
Version = 3.0

Version = 2.2

The new CharacterSet struct that is also bridged to the Objective-C NSCharacterSet class define several predefined sets as:
decimalDigits capitalizedLetters alphanumerics controlCharacters illegalCharacters and more you can find in the NSCharacterSet reference.
You also can define your own set of characters:
Version = 3.0

Version = 2.2

You can also include range:
Version = 3.0

Section 4.7: String Iteration
Version < 3.0

string[string.endIndexNote: endIndex is after the end of the string (i.e. ] is an error, but
string[string.startIndex] is fine). Also, in an empty string (""), string.startIndex == string.endIndex is true.
startIndex.successorBe sure to check for empty strings, since you cannot call () on an empty string.
Version = 3.0
successor(), predecessor(), advancedBy(_:), advancedBy(_:limitIn Swift 3, String indexes no longer have :), or
distanceTo(_:).
Instead, those operations are moved to the collection, which is now responsible for incrementing and decrementing its indices.
index(after:), .index(before:) and .index(_:, offsetByAvailable methods are .:).

indexNote: we're using currentIndex as a variable name to avoid confusion with the . method.
And, for example, if you want to go the other way:
Version < 3.0

(Or you could just reverse the string first, but if you don't need to go all the way through the string you probably would prefer a method like this) Version = 3.0

Note, Index is an object type, and not an Int. You cannot access a character of string as follows:

But you can get a specific index as follows:
Version < 3.0

Version = 3.0

And can go backwards like this:
Version < 3.0

Version = 3.0

If you might exceed the string's bounds, or you want to specify a limit you can use:
Version < 3.0

Version = 3.0 currentIndex = string.index(string.startIndex, offsetBy: 20, limitedBy: string.endIndex)
Alternatively one can just iterate through the characters in a string, but this might be less useful depending on the context:

Section 4.8: Splitting a String into an Array
In Swift you can easily separate a String into an array by slicing it at a certain character:
Version = 3.0

Version = 2.2

Or when the separator isn't present:


Section 4.9: Unicode
Setting values
Using Unicode directly

Using hexadecimal values
var str: String = "\\u{61}\\u{5927}\\u{1F34E}\\u{3C0}" // a大	π var character: Character = "\\u{65}\\u{301}" // é = "e" + accent mark
Note that the Swift Character can be composed of multiple Unicode code points, but appears to be a single character. This is called an Extended Grapheme Cluster.
Conversions
String --> Hex

Hex --> String

Note that for UTF-8 and UTF-16 the conversion is not always this easy because things like emoji cannot be encoded with a single UTF-16 value. It takes a surrogate pair.
Section 4.10: Converting Swift string to a number type

Note that doing this returns an Optional value, which should be unwrapped accordingly before being used.
Section 4.11: Convert String to and from Data / NSData
UTFTo convert String to and from Data / NSData we need to encode this string with a specific encoding. The most famous one is -8 which is an 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems. Here is a list of all available String Encodings
String to Data/NSData
Version = 3.0

Version = 2.2

Data/NSData to String
Version = 3.0

Version = 2.2

Section 4.12: Formatting Strings



Alternatively one could use specialized initializer that does the same:


 36Radix is Int in [2,].
Section 4.13: Uppercase and Lowercase Strings
To make all the characters in a String uppercase or lowercase:



Section 4.14: Remove characters from a string not defined in Set
Version = 2.2 func removeCharactersNotInSetFromText(text: String, set: Set<Character>) -> String {    return String(text.characters.filter { set.contains( $0) })
}
let text = "Swift 3.0 Come Out" var chars = Set([Character]("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ".characters)) let newText = removeCharactersNotInSetFromText(text, set: chars) // "SwiftComeOut"
Version = 3.0 func removeCharactersNotInSetFromText(text: String, set: Set<Character>) -> String {   return String(text.characters.filter { set.contains( $0) })
}
let text = "Swift 3.0 Come Out" var chars = Set([Character]("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ".characters)) let newText = removeCharactersNotInSetFromText(text: text, set: chars)
Section 4.15: Count occurrences of a Character into a String
Given a String and a Character

We can count the number of times the Character appears into the String using
let sensitiveCount = text.characters.filter { $0 == char }.count // case-sensitive let insensitiveCount = text.lowercaseString.characters.filter { $0 == Character(String(char).lowercaseString) } // case-insensitive
Section 4.16: Remove leading and trailing WhiteSpace and NewLine
Version < 3.0

Method stringByTrimmingCharactersInSet returns a new string made by removing from both ends of the String characters contained in a given character set.
We can also just remove only whitespace or newline.
Removing only whitespace:

 someString.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet()) // "Swift Language  \n" Removing only newline:

Version = 3.0

import FoundationNote: all these methods belong to Foundation. Use  if Foundation isn't already imported via other libraries like Cocoa or UIKit.

Chapter 5: Booleans
Section 5.1: What is Bool?
Bool is a Boolean type with two possible values: true and false.

Bools are used in control-flow statements as conditions. The if statement uses a Boolean condition to determine which block of code to run:

Section 5.2: Booleans and Inline Conditionals
A clean way to handle booleans is using an inline conditional with the a ? b : c ternary operator, which is part of Swift's Basic Operations.
The inline conditional is made up of 3 components:

where question is a boolean that is evaluated and answerIfTrue is the value returned if the question is true, and answerIfFalse is the value returned if the question is false.
The expression above is the same as:

With inline conditionals you return a value based on a boolean:

You can also call methods based on a boolean value:


Inline conditionals allow for clean one-liner boolean evaluations
Section 5.3: Boolean Logical Operators
The OR (||) operator returns true if one of its two operands evaluates to true, otherwise it returns false. For example, the following code evaluates to true because at least one of the expressions either side of the OR operator is true:

The AND (&&) operator returns true only if both operands evaluate to be true. The following example will return false because only one of the two operand expressions evaluates to true:

The XOR (^) operator returns true if one and only one of the two operands evaluates to true. For example, the following code will return true since only one operator evaluates to be true:

Section 5.4: Negate a Bool with the prefix ! operator
true returns false, and !falseThe prefix ! operator returns the logical negation of its argument. That is, ! returns

Chapter 6: Arrays
Array is an ordered, random-access collection type. Arrays are one of the most commonly used data types in an app. We use the Array type to hold elements of a single type, the array's Element type. An array can store any kind of elements---from integers to strings to classes.
Section 6.1: Basics of Arrays
Array is an ordered collection type in the Swift standard library. It provides O(1) random access and dynamic reallocation. Array is a generic type, so the type of values it contains are known at compile time.
As Array is a value type, its mutability is defined by whether it is annotated as a var (mutable) or let (immutable).
Int] (meaning: an array containing Ints) is syntactic sugar for ArrayThe type [<T>.
Read more about arrays in The Swift Programming Language.
Empty arrays
The following three declarations are equivalent:
// A mutable array of Strings, initially empty.
var arrayOfStrings: [String] = []      // type annotation + array literal var arrayOfStrings = [String]()        // invoking the [String] initializer var arrayOfStrings = Array<String>()   // without syntactic sugar
Array literals
An array literal is written with square brackets surrounding comma-separated elements:

The compiler can usually infer the type of an array based on the elements in the literal, but explicit type annotations can override the default:
let arrayOfUInt8s: [UInt8] = [2, 4, 7]   // type annotation on the variable let arrayOfUInt8s = [2, 4, 7] as [UInt8] // type annotation on the initializer expression let arrayOfUInt8s = [2 as UInt8, 4, 7]   // explicit for one element, inferred for the others
Arrays with repeated values
// An immutable array of type [String], containing ["Example", "Example", "Example"] let arrayOfStrings = Array(repeating: "Example",count: 3)
Creating arrays from other sequences

Multi-dimensional arrays
IntIn Swift, a multidimensional array is created by nesting arrays: a 2-dimensional array of Int is [[]] (or
Array<Array<Int>>).


To create a multidimensional array of repeated values, use nested calls of the array initializer: var array3x4x5 = Array(repeating: Array(repeating: Array(repeating: 0,count: 5),count: 4),count: 3)
Section 6.2: Extracting values of a given type from an Array with flatMap(_:)
The things Array contains values of Any type.

IntWe can extract values of a given type and create a new Array of that specific type. Let's say we want to extract all the (s) and put them into an Int Array in a safe way.

IntNow numbers is defined as []. The flatMap function discard all nil elements and the result thus contains only the following values:

Section 6.3: Combining an Array's elements with reduce(_:combine:)
reduce(_:combine:) can be used in order to combine the elements of a sequence into a single value. It takes an
initial value for the result, as well as a closure to apply to each element - which will return the new accumulated value.
For example, we can use it to sum an array of numbers:

N + 36We're passing 0 into the initial value, as that's the logical initial value for a summation. If we passed in a value of N, the resulting sum would be . The closure passed to reduce has two arguments. accumulator is the current accumulated value, which is assigned the value that the closure returns at each iteration. element is the current element in the iteration.
Int, Int) -> IntAs in this example, we're passing an ( closure to reduce, which is simply outputting the addition of the two inputs - we can actually pass in the + operator directly, as operators are functions in Swift:

Section 6.4: Flattening the result of an Array transformation with flatMap(_:)
flatMapAs well as being able to create an array by filtering out nil from the transformed elements of a sequence, there is also a version of (_:) that expects the transformation closure to return a sequence S.

S.Generator.ElementEach sequence from the transformation will be concatenated, resulting in an array containing the combined elements of each sequence - [].
Combining the characters in an array of strings
For example, we can use it to take an array of prime strings and combine their characters into a single array:
let primes = ["2", "3", "5", "7", "11", "13", "17", "19"] let allCharacters = primes.flatMap { $0.characters }
 // => "["2", "3", "5", "7", "1", "1", "1", "3", "1", "7", "1", "9"]" Breaking the above example down:
String] (As an array is a sequence, we can call flatMap1. primes is a [(_:) on it).
2. The transformation closure takes in one of the elements of primes, a String
Array<String>.Generator.Element().
String.CharacterView3. The closure then returns a sequence of type .
String.CharacterView.Generator.Element4. The result is then an array containing the combined elements of all the sequences from each of the transformation closure calls - [].
Flattening a multidimensional array
flatMapAs (_:) will concatenate the sequences returned from the transformation closure calls, it can be used to flatten a multidimensional array - such as a 2D array into a 1D array, a 3D array into a 2D array etc.
This can simply be done by returning the given element $0 (a nested array) in the closure:

Section 6.5: Lazily flattening a multidimensional Array with flatten()
flattenWe can use () in order to lazily reduce the nesting of a multi-dimensional sequence.
For example, lazy flattening a 2D array into a 1D array:


flattencontainsIn the above example, () will return a FlattenBidirectionalCollection, which will lazily apply the flattening of the array. Therefore (_:) will only require the first two nested arrays of array2D to be flattened - as it will short-circuit upon finding the desired element.
Section 6.6: Filtering out nil from an Array transformation with flatMap(_:)
flatMap(_:) in a similar manner to mapYou can use (_:) in order to create an array by applying a transform to a sequence's elements.

flatMapThe difference with this version of (_:) is that it expects the transform closure to return an Optional value T? for each of the elements. It will then safely unwrap each of these optional values, filtering out nil - resulting in an array of [T].
String] into a [IntFor example, you can this in order to transform a [] using Int's failable String initializer, filtering out any elements that cannot be converted:

flatMapYou can also use (_:)'s ability to filter out nil in order to simply convert an array of optionals into an array of non-optionals:

Section 6.7: Subscripting an Array with a Range
One can extract a series of consecutive elements from an Array using a Range.

Subscripting an Array with a Range returns an ArraySlice. It's a subsequence of the Array.
ArraySlice<StringIn our example, we have an Array of Strings, so we get back >.
Although an ArraySlice conforms to CollectionType and can be used with sort, filter, etc, its purpose is not for long-term storage but for transient computations: it should be converted back into an Array as soon as you've finished working with it.
ArrayFor this, use the () initializer:

To sum up in a simple example without intermediary steps:
let words = ["Hey", "Hello", "Bonjour", "Welcome", "Hi", "Hola"] let selectedWords = Array(words[2...4]) // ["Bonjour", "Welcome", "Hi"]
Section 6.8: Removing element from an array without knowing it's index
remove(atGenerally, if we want to remove an element from an array, we need to know it's index so that we can remove it easily using :) function.
But what if we don't know the index but we know the value of element to be removed!
So here is the simple extension to an array which will allow us to remove an element from array easily without knowing it's index: Swift3

e.g.

array.remove(25Also if, by mistake, we did something like this: ) i.e. we provided value with different data type, compiler will throw an error mentioningcannot convert value to expected argument type
Section 6.9: Sorting an Array of Strings
Version = 3.0
sortedThe most simple way is to use ():

sortor ()

You can pass a closure as an argument for sorting:
 let words = ["Hello", "Bonjour", "Salute", "Ahola"] let sortedWords = words.sorted(isOrderedBefore: { $0 > $1 }) print(sortedWords) // ["Salute", "Hello", "Bonjour", "Ahola"] Alternative syntax with a trailing closure:
let words = ["Hello", "Bonjour", "Salute", "Ahola"] let sortedWords = words.sorted() { $0 > $1 }
print(sortedWords) // ["Salute", "Hello", "Bonjour", "Ahola"]
But there will be unexpected results if the elements in the array are not consistent:

To address this issue, either sort on a lowercase version of the elements:
let words = ["Hello", "bonjour", "Salute", "ahola"] let sortedWords = words.sorted { $0.lowercased() < $1.lowercased() } print(sortedWords) // ["ahola", "bonjour", "Hello", "Salute"]
import FoundationOr  and use NSString's comparison methods like caseInsensitiveCompare:
let words = ["Hello", "bonjour", "Salute", "ahola"] let sortedWords = words.sorted { $0.caseInsensitiveCompare($1) == .orderedAscending } print(sortedWords) // ["ahola", "bonjour", "Hello", "Salute"]
Alternatively, use localizedCaseInsensitiveCompare, which can manage diacritics.
numericTo properly sort Strings by the numeric value they contain, use compare with the . option:
let files = ["File-42.txt", "File-01.txt", "File-5.txt", "File-007.txt", "File-10.txt"] let sortedFiles = files.sorted() { $0.compare($1, options: .numeric) == .orderedAscending } print(sortedFiles) // ["File-01.txt", "File-5.txt", "File-007.txt", "File-10.txt", "File-42.txt"]
Section 6.10: Accessing indices safely
By adding the following extension to array indices can be accessed without knowing if the index is inside bounds.

example:

Section 6.11: Filtering an Array
filterYou can use the (_:) method on SequenceType in order to create a new array containing the elements of the sequence that satisfy a given predicate, which can be provided as a closure.
IntFor example, filtering even numbers from an []:


Section 6.12: Transforming the elements of an Array with map(_:)
map throws -> BAs Array conforms to SequenceType, we can use (_:) to transform an array of A into an array of B using a closure of type (A).
For example, we could use it to transform an array of Ints into an array of Strings like so:

map(_:) will iterate through the array, applying the given closure to each element. The result of that closure will be used to populate a new array with the transformed elements.
Since String has an initialiser that receives an Int we can also use this clearer syntax:

mapA (_:) transform need not change the type of the array - for example, it could also be used to multiply an array of Ints by two:

Section 6.13: Useful Methods
Determine whether an array is empty or return its size

Reverse an Array Note: The result is not performed on the array the method is called on and must be put into its own variable.

Section 6.14: Sorting an Array

Creating a new sorted array
As Array conforms to SequenceType, we can generate a new array of the sorted elements using a built in sort method.
Version = 2.1 Version = 2.2
sortIn Swift 2, this is done with the () method.

Version ≥ 3.0
sortedAs of Swift 3, it has been re-named to (). let sorted = array.sorted()  // [1, 2, 3]
Sorting an existing array in place
As Array conforms to MutableCollectionType, we can sort its elements in place.
Version = 2.1 Version = 2.2
sortInPlaceIn Swift 2, this is done using the () method.

Version ≥ 3.0

Sorting an array with a custom ordering
You may also sort an array using a closure to define whether one element should be ordered before another - which isn't restricted to arrays where the elements must be Comparable. For example, it doesn't make sense for a Landmark to be Comparable - but you can still sort an array of landmarks by height or name.

Version = 2.1 Version = 2.2
// sort landmarks by height (ascending) landmarks.sortInPlace {$0.metersTall < $1.metersTall}
print(landmarks) // [Landmark(name: "Eifell Tower", metersTall: 300), Landmark(name: "The Shard", metersTall: 310), Landmark(name: "Empire State Building", metersTall: 443)]
// create new array of landmarks sorted by name let alphabeticalLandmarks = landmarks.sort {$0.name < $1.name}
print(alphabeticalLandmarks) // [Landmark(name: "Eifell Tower", metersTall: 300), Landmark(name:
"Empire State Building", metersTall: 443), Landmark(name: "The Shard", metersTall: 310)]
Version ≥ 3.0

Section 6.15: Finding the minimum or maximum element of an Array
Version = 2.1 Version = 2.2
minElement() and maxElementYou can use the () methods to find the minimum or maximum element in a given sequence. For example, with an array of numbers:

Version ≥ 3.0
min() and maxAs of Swift 3, the methods have been renamed to () respectively:

The returned values from these methods are Optional to reflect the fact that the array could be empty - if it is, nil will be returned.
		Note: The above methods require the elements to conform to the Comparable protocol.
Finding the minimum or maximum element with a custom ordering
You may also use the above methods with a custom closure, defining whether one element should be ordered before another, allowing you to find the minimum or maximum element in an array where the elements aren't necessarily Comparable.
For example, with an array of vectors:


let lowestMagnitudeVec2 = vectors.min { $0.magnitude < $1.magnitude } let highestMagnitudeVec2 = vectors.max { $0.magnitude < $1.magnitude }
Section 6.16: Modifying values in an array
There are multiple ways to append values onto an array

and remove values from an array

Section 6.17: Comparing 2 Arrays with zip
The zip function accepts 2 parameters of type SequenceType and returns a Zip2Sequence where each element contains a value from the first sequence and one from the second sequence.
Example

nomsAndAnimals now contains the following values
sequence1 sequence1
1 "Dog"
2 "Cat"
3 "Tiger"
This is useful when you want to perform some kind of comparation between the n-th element of each Array.
Example
IntGiven 2 Arrays of (s)

you want to check whether each value into list1 is the double of the related value in list0. let list1HasDoubleOfList0 = !zip(list0, list1).filter { $0 != (2 * $1)}.isEmpty
Section 6.18: Grouping Array values
If we have a struct like this


we can group the boxes by the thingsInside property in order to get a Dictionary where the key is the number of things and the value is an array of boxes.

Int:[BoxNow grouped is a []] and has the following content
[
    2: [Box(name: "Box 1", thingsInside: 2), Box(name: "Box 4", thingsInside: 2)],
    3: [Box(name: "Box 2", thingsInside: 3), Box(name: "Box 5", thingsInside: 3)],
    1: [Box(name: "Box 0", thingsInside: 1), Box(name: "Box 3", thingsInside: 1), Box(name: "Box
6", thingsInside: 1)]
]
Section 6.19: Value Semantics
Copying an array will copy all of the items inside the original array.
Changing the new array will not change the original array.

Copied arrays will share the same space in memory as the original until they are changed. As a result of this there is a performance hit when the copied array is given its own space in memory as it is changed for the first time.
Section 6.20: Accessing Array Values
The following examples will use this array to demonstrate accessing values

To access a value at a known index use the following syntax:

Note: The value at index two is the third value in the Array. Arrays use a zero based index which means the first element in the Array is at index 0.

Access a subset of an Array using filter:

Filters can have complex conditions like filtering only even numbers:


It is also possible to return the index of a given value, returning nil if the value wasn't found.

There are methods for the first, last, maximum or minimum value in an Array. These methods will return nil if the Array is empty.


Chapter 7: Tuples
A tuple type is a comma-separated list of types, enclosed in parentheses.
This list of types also can have name of the elements and use those names to refer to the values of the individual elements.
An element name consists of an identifier followed immediately by a colon (:).
Common use -
We can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values
Section 7.1: What are Tuples?
Tuples group multiple values into a single compound value. The values within a tuple can be of any type and do not have to be of the same type as each other.
Tuples are created by grouping any amount of values:

Also individual values can be named when the tuple is defined:

They can also be named when being used as a variable and even have the ability to have optional values inside:

Section 7.2: Decomposing into individual variables
Tuples can be decomposed into individual variables with the following syntax:


This syntax can be used regardless of if the tuple has unnamed properties:

Specific properties can be ignored by using underscore (_):

Section 7.3: Tuples as the Return Value of Functions
Functions can return tuples:

If you assign parameter names, they can be used from the return value:

Section 7.4: Using a typealias to name your tuple type
Occasionally you may want to use the same tuple type in multiple places throughout your code. This can quickly get messy, especially if your tuple is complex:
// Define a circle tuple by its center point and radius let unitCircle: (center: (x: CGFloat, y: CGFloat), radius: CGFloat) = ((0.0, 0.0), 1.0)
func doubleRadius(ofCircle circle: (center: (x: CGFloat, y: CGFloat), radius: CGFloat)) -> (center:
(x: CGFloat, y: CGFloat), radius: CGFloat) {     return (circle.center, circle.radius * 2.0) }
If you use a certain tuple type in more than one place, you can use the typealias keyword to name your tuple type.

func doubleRadius(ofCircle circle: Circle) -> Circle {
    // Aliased tuples also have access to value labels in the original tuple type.     return (circle.center, circle.radius * 2.0) }
If you find yourself doing this too often, however, you should consider using a struct instead.
Section 7.5: Swapping values
Tuples are useful to swap values between 2 (or more) variables without using temporary variables.
Example with 2 variables Given 2 variables

we can easily swap the values

Result:

Example with 4 variables

Section 7.6: Tuples as Case in Switch
Use tuples in a switch

Or in combination with an Enum For example with Size Classes:


Chapter 8: Enums
Section 8.1: Basic enumerations
An enum provides a set of related values:

Enum values can be used by their fully-qualified name, but you can omit the type name when it can be inferred:

The most fundamental way of comparing/extracting enum values is with a switch statement:

Simple enums are automatically Hashable, Equatable and have string conversions:

Section 8.2: Enums with associated values
Enum cases can contain one or more payloads (associated values):


The payload must be provided when instantiating the enum value:

The switch statement can extract the associated value:

if caseA single case extraction can be done using :

guard caseThe  syntax can be used for later use extraction:

Enums with associated values are not Equatable by default. Implementation of the == operator must be done manually:

Section 8.3: Indirect payloads
Normally, enums can't be recursive (because they would require infinite storage):

The indirect keyword makes the enum store its payload with a layer of indirection, rather than storing it inline. You can use this keyword on a single case:

indirect also works on the whole enum, making any case indirect when necessary:

Section 8.4: Raw and Hash values
Enums without payloads can have raw values of any literal type:

Enums without any specific type do not expose the rawValue property

Integer raw values are assumed to start at 0 and increase monotonically:

String raw values can be synthesized automatically:

rawValueA raw-valued enum automatically conforms to RawRepresentable. You can get an enum value's corresponding raw value with .:

init?(rawValueYou can also create an enum from a raw value using :):

If you wish to get the hash value of a specific enum you can access its hashValue, The hash value will return the index of the enum starting from zero.

Section 8.5: Initializers
init?(rawValueEnums can have custom init methods that can be more useful than the default :). Enums can also
store values as well. This can be useful for storing the values they where initialized with and retrieving that value later.


Using that initializer we can do this:
var direction = CompassDirection(degrees: 0) // Returns CompassDirection.north direction = CompassDirection(degrees: 90) // Returns CompassDirection.east print(direction.value) //prints 90
direction = CompassDirection(degrees: 500) // Returns nil
Section 8.6: Enumerations share many features with classes and structures
Enums in Swift are much more powerful than some of their counterparts in other languages, such as C. They share many features with classes and structs, such as defining initialisers, computed properties, instance methods, protocol conformances and extensions.


Section 8.7: Nested Enumerations
You can nest enumerations one inside an other, this allows you to structure hierarchical enums to be more organized and clear.

And you can use it like that:

Chapter 9: Structs
Section 9.1: Structs are value types
Unlike classes, which are passed by reference, structures are passed through copying:

String is a structure, therefore it's copied on assignment.
Structures also cannot be compared using identity operator:
window0 === window1 // works because a window is a class instance "hello" === "hello" // error: binary operator '===' cannot be applied to two 'String' operands
Every two structure instances are deemed identical if they compare equal.
Collectively, these traits that differentiate structures from classes are what makes structures value types.
Section 9.2: Accessing members of struct
In Swift, structures use a simple "dot syntax" to access their members.
For example:

You can access(print) the range like this:

You can even access members of members using dot syntax:

Similar to how you can read values with dot syntax, you can also assign them.

Section 9.3: Basics of Structs


This defines a Repository struct with three stored properties, an integer identifier, a string name, and an optional string description. The identifier and name are constants, as they've been declared using the let-keyword. Once set during initialization, they cannot be modified. The description is a variable. Modifying it updates the value of the structure.
Structure types automatically receive a memberwise initializer if they do not define any of their own custom initializers. The structure receives a memberwise initializer even if it has stored properties that do not have default values.
Repository contains three stored properties of which only description has a default value (nil). Further it defines no initializers of its own, so it receives a memberwise initializer for free:

Section 9.4: Mutating a Struct
A method of a struct that change the value of the struct itself must be prefixed with the mutating keyword

When you can use mutating methods
The mutating methods are only available on struct values inside variables.

When you can NOT use mutating methods
On the other hand, mutating methods are NOT available on struct values inside constants

Section 9.5: Structs cannot inherit
Unlike classes, structures cannot inherit:

Structures, however, can adopt protocols:


Chapter 10: Sets
Section 10.1: Declaring Sets
Sets are unordered collections of unique values. Unique values must be of the same type.

You can declare a set with values by using the array literal syntax.

Section 10.2: Performing operations on sets
Common values from both sets:
intersectYou can use the (_:) method to create a new set containing all the values common to both sets.

All values from each set:
unionYou can use the (_:) method to create a new set containing all the unique values from each set.
let union = favoriteColors.union(newColors) // a OR b
// union = {"Red", "Purple", "Green", "Orange", "Blue"}
Notice how the value "Green" only appears once in the new set.
Values that don't exist in both sets:
exclusiveOrYou can use the (_:) method to create a new set containing the unique values from either but not both sets.
let exclusiveOr = favoriteColors.exclusiveOr(newColors) // a XOR b
// exclusiveOr = {"Red", "Purple", "Orange", "Blue"}
Notice how the value "Green" doesn't appear in the new set, since it was in both sets.
Values that are not in a set:
subtractYou can use the (_:) method to create a new set containing values that aren't in a specific set.

Notice how the value "Green" doesn't appear in the new set, since it was also in the second set.
Section 10.3: CountedSet
Version = 3.0
Swift 3 introduces the CountedSet class (it's the Swift version of the NSCountedSet Objective-C class).
CountedSet, as suggested by the name, keeps track of how many times a value is present.

Section 10.4: Modifying values in a set

insert(_:)You can use the  method to add a new item into a set.

remove(_:)You can use the  method to remove an item from a set. It returns optional containing value that was removed or nil if value was not in the set.

Section 10.5: Checking whether a set contains a value

contains(_:)You can use the  method to check whether a set contains a value. It will return true if the set contains that value.

Section 10.6: Adding values of my own type to a Set
In order to define a Set of your own type you need to conform your type to Hashable


let ships : Set<Starship> = [Starship(name:"Enterprise D"), Starship(name:"Voyager"),
Starship(name:"Defiant") ]

Chapter 11: Dictionaries
Section 11.1: Declaring Dictionaries
Dictionaries are an unordered collection of keys and values. Values relate to unique keys and must be of the same type.
When initializing a Dictionary the full syntax is as follows:

Although a more concise way of initializing:

Declare a dictionary with keys and values by specifying them in a comma separated list. The types can be inferred from the types of keys and values.

Section 11.2: Accessing Values
A value in a Dictionary can be accessed using its key:

The values of a dictionary can be iterated through using the values property:

Similarly, the keys of a dictionary can be iterated through using its keys property:

To get all key and value pair corresponding to each other (you will not get in proper order since it is a Dictionary)


Note that a Dictionary, unlike an Array, in inherently unordered-that is, there is no guarantee on the order during iteration.
If you want to access multiple levels of a Dictionary use a repeated subscript syntax.

Section 11.3: Change Value of Dictionary using Key

Section 11.4: Get all keys in Dictionary

Section 11.5: Modifying Dictionaries
Add a key and value to a Dictionary

updateValue returns the original value if one exists or nil.

Remove value and their keys with similar syntax

Section 11.6: Merge two dictionaries


Chapter 12: Switch
Parameter	Details
Value to test The variable that to compare against
Section 12.1: Switch and Optionals
Some example cases when the result is an optional.

Section 12.2: Basic Use

switch statements also work with data types other than integers. They work with any data type.Here's an example of switching on a string:

This will print the following:

Section 12.3: Matching a Range
A single case in a switch statement can match a range of values.

Section 12.4: Partial matching
Switch statement make use of partial matching.

1. Matches precisely the case where the value is (0,0,0). This is the origin of 3D space.
2. Matches y=0, z=0 and any value of x. This means the coordinate is on the x- axis.
3. Matches x=0, z=0 and any value of y. This means the coordinate is on they- axis.
4. Matches x=0, y=0 and any value of z. This means the coordinate is on the z- axis.
5. Matches the remainder of coordinates.
Note: using the underscore to mean that you don't care about the value.
If you don't want to ignore the value, then you can use it in your switch statement, like this:

Here, the axis cases use the let syntax to pull out the pertinent values. The code then prints the values using string interpolation to build the string.
Note: you don't need a default in this switch statement. This is because the final case is essentially the default-it matches anything, because there are no constraints on any part of the tuple. If the switch statement exhausts all possible values with its cases, then no default is necessary.
We can also use the let-where syntax to match more complex cases. For example:

Here, We match the "y equals x" and "y equals x squared" lines.
Section 12.5: Using the where statement in a switch
The where statement may be used within a switch case match to add additional criteria required for a positive match. The following example checks not only for the range, but also if the number is odd or even:

Section 12.6: Matching Multiple Values
A single case in a switch statement can match on multiple values.

Section 12.7: Switch and Enums

Section 12.8: Switches and tuples
Switches can switch on tuples:

Section 12.9: Satisfy one of multiple constraints using switch
You can create a tuple and use a switch like so:

Section 12.10: Matching based on class - great for prepareForSegue
You can also make a switch statement switch based on the class of the thing you're switching on.
An example where this is useful is in prepareForSegue. I used to switch based on the segue identifier, but that's fragile. if you change your storyboard later and rename the segue identifier, it breaks your code. Or, if you use segues to multiple instances same view controller class (but different storyboard scenes) then you can't use the segue identifier to figure out the class of the destination.
Swift switch statements to the rescue.
case let var as ClassUse Swift  syntax, like this:
Version < 3.0

Version ≥ 3.0
In Swift 3 the sytax has changed slightly:


Section 12.11: Switch fallthroughs
It is worth noting that in swift, unlike other languages people are familiar with, there is an implicit break at the end of each case statement. In order to follow through to the next case (i.e. have multiple cases execute) you need to use fallthrough statement.

this is useful for things like streams.

Chapter 13: Optionals
" An optional value either contains a value or contains nil to indicate that a value is missing"
Excerpt From: Apple Inc. "The Swift Programming Language (Swift 3.1 Edition)." iBooks. https://itun.es/us/k5SW7.l
Basic optional use cases include: for a constant (let), use of an optional within a loop (if-let), safely unwrapping an optional value within a method (guard-let), and as part of switch loops (case-let), defaulting to a value if nil, using the coalesce operator (??)
Section 13.1: Types of Optionals
Optionals are a generic enum type that acts as a wrapper. This wrapper allows a variable to have one of two states: the value of the user-defined type or nil, which represents the absence of a value.
This ability is particularly important in Swift because one of the stated design objectives of the language is to work well with Apple's frameworks. Many (most) of Apple's frameworks utilize nil due to its ease of use and significance to programming patterns and API design within Objective-C.
In Swift, for a variable to have a nil value, it must be an optional. Optionals can be created by appending either a ! or a ? to the variable type. For example, to make an Int optional, you could use

Int? optionals must be explicitly unwrapped, and should be used if you aren't certain whether or not the variable will have a value when you access it. For example, when turning a string into an Int, the result is an optional ?, because nil will be returned if the string is not a valid number

! optionals are automatically unwrapped, and should only be used when you are certain that the variable will have a
UIButton! variable that is initialized in viewDidLoadvalue when you access it. For example, a global ()

Section 13.2: Unwrapping an Optional
In order to access the value of an Optional, it needs to be unwrapped.
You can conditionally unwrap an Optional using optional binding and force unwrap an Optional using the ! operator.
Conditionally unwrapping effectively asks "Does this variable have a value?" while force unwrapping says "This variable has a value!".
If you force unwrap a variable that is nil, your program will throw an unexpectedly found nil while unwrapping an optional exception and crash, so you need to consider carefully if using ! is appropriate.

if-letFor safe unwrapping, you can use an  statement, which will not throw an exception or crash if the wrapped value is nil:

Or, a guard statement:

if-letNote that the scope of the unwrappedNumber variable is inside the  statement and outside of the guard block.
You can chain unwrapping of many optionals, this is mainly useful in cases that your code requires more then variable to run correctly:

Note that all the variables have to be unwrapped in order to pass successfully the test, otherwise you would have no way to determine which variables were unwrapped and which weren't.
You can chain conditional statements using your optionals immediately after it is unwrapped. This means no nested if - else statements!

Section 13.3: Nil Coalescing Operator
You can use the nil coalescing operator to unwrap a value if it is non-nil, otherwise provide a different value:

This operator is able to short-circuit, meaning that if the left operand is non-nil, the right operand will not be evaluated:

someExpensiveComputationIn this example, as foo is non-nil, () will not be called.
You can also chain multiple nil coalescing statements together:

In this example baz will be assigned the unwrapped value of foo if it is non-nil, otherwise it will be assigned the unwrapped value of bar if it is non-nil, otherwise it will be assigned the fallback value.
Section 13.4: Optional Chaining
You can use Optional Chaining in order to call a method, access a property or subscript an optional. This is done by placing a ? between the given optional variable and the given member (method, property or subscript).

doSomethingIf foo contains a value, () will be called on it. If foo is nil, then nothing bad will happen - the code will simply fail silently and continue executing.

(This is similar behaviour to sending messages to nil in Objective-C)
The reason that Optional Chaining is named as such is because 'optionality' will be propagated through the members you call/access. What this means is that the return values of any members used with optional chaining will be optional, regardless of whether they are typed as optional or not.

foo?.bar is returning an IntHere ? even though bar is non-optional, as foo itself is optional.
VoidAs optionality is propagated, methods returning Void will return ? when called with optional chaining. This can be useful in order to determine whether the method was called or not (and therefore if the optional has a value).

VoidHere we're comparing the ? return value with nil in order to determine whether the method was called (and therefore whether foo is non-nil).
Section 13.5: Overview - Why Optionals?
Often when programming it is necessary to make some distinction between a variable that has a value and one that does not. For reference types, such as C Pointers, a special value such as null can be used to indicate that the variable has no value. For intrinsic types, such as an integer, it is more difficult. A nominated value, such as -1 can be used, but this relies on interpretation of the value. It also eliminates that "special" value from normal use.
To address this, Swift allows any variable to be declared as an optional. This is indicated by the use of a ? or ! after the type (See Types of optionals) For example,

declares a variable that may or may not contain an integer value.
The special value nil indicates that no value is currently assigned to this variable.

nil can also be used to test for an assigned value:

Note the use of ! in the print statement to unwrap the optional value.
As an example of a common use of optionals, consider a function that returns an integer from a string containing digits; It is possible that the string may contain non-digit characters, or may even be empty.
How can a function that returns a simple Int indicate failure? It cannot do so by returning any specific value as this would preclude that value from being parsed from the string.

In Swift, however, that function can simply return an optional Int. Then failure is indicated by return value of nil.


Chapter 14: Conditionals
Conditional expressions, involving keywords such as if, else if, and else, provide Swift programs with the ability to perform different actions depending on a Boolean condition: True or False. This section covers the use of Swift conditionals, Boolean logic, and ternary statements.
Section 14.1: Optional binding and "where" clauses
if letOptionals must be unwrapped before they can be used in most expressions.  is an optional binding, which succeeds if the optional value was not nil:

You can reuse the same name for the newly bound variable, shadowing the original:

Version ≥ 1.2 Version < 3.0

Apply further constraints after the optional binding using a where clause:
if let unwrappedNum = num e unwrappedNum % 2 == 0 { print("num is non-nil, and it's an even number") }
If you're feeling adventurous, interleave any number of optional bindings and where clauses:
if let num = num                           // num must be non-nil     where num % 2 == 1,                    // num must be odd     let str = str,                         // str must be non-nil     let firstChar = str.characters.first   // str must also be non-empty
    where firstChar != "x"                 // the first character must not be "x" {     // all bindings & conditions succeeded!
}
Version ≥ 3.0
In Swift 3, where clauses have been replaced (SE-0099): simply use another , to separate optional bindings and boolean conditions.
if let unwrappedNum = numwrappedNum % 2 == 0 { print("num is non-nil, and it's an even number") } if let num =
num, // num must be non-nil num % 2 == 1, // num must be odd let str = str, // str must be non-nil let firstChar = str.characters.first, // str must also be non-empty firstChar != "x" // the first character must not be "x" { // all bindings & conditions succeeded! }
Section 14.2: Using Guard
Version ≥ 2.0
Guard checks for a condition, and if it is false, it enters the branch. Guard check branches must leave its enclosing block either via return, break, or continue (if applicable); failing to do so results in a compiler error. This has the advantage that when a guard is written it's not possible to let the flow continue accidentally (as would be possible with an if).
Using guards can help keep nesting levels low, which usually improves the readability of the code.

Guard can also check if there is a value in an optional, and then unwrap it in the outer scope:

Guard can combine optional unwrapping and condition check using where keyword:

Section 14.3: Basic conditionals: if-statements
An if statement checks whether a Bool condition is true:


else ifif statements accept  and else blocks, which can test alternate conditions and provide a fallback:

Basic operators like && and || can be used for multiple conditions:
The logical AND operator

num == 10If  was false, the second value wouldn't be evaluated. This is known as short-circuit evaluation.

num == 10If  is true, the second value wouldn't be evaluated.

Section 14.4: Ternary operator
Conditions may also be evaluated in a single line using the ternary operator:
If you wanted to determine the minimum and maximum of two variables, you could use if statements, like so:


The ternary conditional operator takes a condition and returns one of two values, depending on whether the condition was true or false. The syntax is as follows: This is equivalent of having the expression:

The above code can be rewritten using ternary conditional operator as below:

In the first example, the condition is a < b. If this is true, the result assigned back to min will be of a; if it's false, the result will be the value of b.
Note: Because finding the greater or smaller of two numbers is such a common operation, the Swift standard library provides two functions for this purpose: max and min.
Section 14.5: Nil-Coalescing Operator
<OPTIONAL> ?? <DEFAULT VALUE> unwraps the <OPTIONALThe nil-coalescing operator > if it contains a value, or
<DEFAULT VALUE> if is nil. <OPTIONAL> is always of an optional type. <DEFAULT VALUE<OPTIONALreturns > must match the type that is stored inside >.
The nil-coalescing operator is shorthand for the code below that uses a ternary operator:

this can be verified by the code below:

Time For An Example

Chapter 15: Error Handling
Section 15.1: Error handling basics
Functions in Swift may return values, throw errors, or both:

nt // always returns a value func reticulateSplines() throws // no return value, but may throw an error func reticulateSplines() throws -> Int // may either return a value or throw an error
Any value which conforms to the ErrorType protocol (including NSError objects) can be thrown as an error. Enumerations provide a convenient way to define custom errors:


An error indicates a non-fatal failure during program execution, and is handled with the specialized control-flow constructs do/catch, throw, and try.


tryAny function which can throw an error must be called using try, try?, or !:


Section 15.2: Catching dierent error types
Let's create our own error type for this example.
Version = 2.2

Version = 3.0

The Do-Catch syntax allows to catch a thrown error, and automatically creates a constant named error available in the catch block:

You can also declare a variable yourself:


It's also possible to chain different catch statements. This is convenient if several types of errors can be thrown in the Do block.
Here the Do-Catch will first attempt to cast the error as a CustomError, then as an NSError if the custom type was not matched.
Version = 2.2

Version = 3.0
In Swift 3, no need to explicitly downcast to NSError.

Section 15.3: Catch and Switch Pattern for Explicit Error Handling

In the client class:


Section 15.4: Disabling Error Propagation
The creators of Swift have put a lot of attention into making the language expressive and error handling is exactly that, expressive. If you try to invoke a function that can throw an error, the function call needs to be preceded by the try keyword. The try keyword isn't magical. All it does, is make the developer aware of the throwing ability of the function.
For example, the following code uses a loadImage(atPath:) function, which loads the image resource at a given path or throws an error if the image can't be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation. let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
Section 15.5: Create custom Error with localized description

Create extension of RegistrationError to handle the Localized description.

Handle error:



Chapter 16: Loops
Section 16.1: For-in loop
The for-in loop allows you to iterate over any sequence.
Iterating over a range
You can iterate over both half-open and closed ranges:


Version = 2.1 Version = 2.2
enumerateIf you need the index for each element in the array, you can use the () method on SequenceType.

enumerate() returns a lazy sequence containing pairs of elements with consecutive Ints, starting from 0. Therefore
with arrays, these numbers will correspond to the given index of each element - however this may not be the case with other kinds of collections.
Version ≥ 3.0
enumerate() has been renamed to enumeratedIn Swift 3, ():


Version = 2.1 Version = 2.2
reverseYou can use the () method on SequenceType in order to iterate over any sequence in reverse:


Iterating over ranges with custom stride Version = 2.1 Version = 2.2
strideBy using the (_:_:) methods on Strideable you can iterate over a range with a custom stride:


Version = 1.2 Version ≥ 3.0
stride(_:_:) methods on Stridable have been replaced by the global strideIn Swift 3, the (_:_:_:) functions:

Section 16.2: Repeat-while loop
Similar to the while loop, only the control statement is evaluated after the loop. Therefore, the loop will always execute at least once.

Section 16.3: For-in loop with filtering
1. where clause
By adding a where clause you can restrict the iterations to ones that satisfy the given condition.

2. case clause
It's useful when you need to iterate only through the values that match some pattern:

Also you can filter optional values and unwrap them if appropriate by adding ? mark after binding constant:

Section 16.4: Sequence Type forEach block
A type that conforms to the SequenceType protocol can iterate through it's elements within a closure:

The same could also be done with a named parameter:

*Note: Control flow statements (such as break or continue) may not be used in these blocks. A return can be called, and if called, will immediately return the block for the current iteration (much like a continue would). The next iteration will then execute.

Section 16.5: while loop

Section 16.6: Breaking a loop
A loop will execute as long as its condition remains true, but you can stop it manually using the break keyword. For example:


Chapter 17: Protocols
Protocols are a way of specifying how to use an object. They describe a set of properties and methods which a class, structure, or enum should provide, although protocols pose no restrictions on the implementation.
Section 17.1: Protocol Basics
About Protocols
A Protocol specifies initialisers, properties, functions, subscripts and associated types required of a Swift object type (class, struct or enum) conforming to the protocol. In some languages similar ideas for requirement specifications of subsequent objects are known as 'interfaces'.
A declared and defined Protocol is a Type, in and of itself, with a signature of its stated requirements, somewhat similar to the manner in which Swift Functions are a Type based on their signature of parameters and returns.
Swift Protocol specifications can be optional, explicitly required and/or given default implementations via a facility known as Protocol Extensions. A Swift Object Type (class, struct or enum) desiring to conform to a Protocol that's fleshed out with Extensions for all its specified requirements needs only state its desire to conform to be in full conformance. The default implementations facility of Protocol Extensions can suffice to fulfil all obligations of conforming to a Protocol.
Protocols can be inherited by other Protocols. This, in conjunction with Protocol Extensions, means Protocols can and should be thought of as a significant feature of Swift.
Protocols and Extensions are important to realising Swift's broader objectives and approaches to program design flexibility and development processes. The primary stated purpose of Swift's Protocol and Extension capability is facilitation of compositional design in program architecture and development. This is referred to as Protocol Oriented Programming. Crusty old timers consider this superior to a focus on OOP design.
Protocols define interfaces which can be implemented by any struct, class, or enum:
protocol MyProtocol {     init(value: Int)                      // required initializer     func doSomething() -> Bool            // instance method     var message: String { get }           // instance read-only property     var value: Int { get set }            // read-write instance property     subscript(index: Int) -> Int { get }  // instance subscript     static func instructions() -> String  // static method     static var max: Int { get }           // static read-only property     static var total: Int { get set }     // read-write static property }
 get } or { get set }. { get Properties defined in protocols must either be annotated as {} means that the
 get set property must be gettable, and therefore it can be implemented as any kind of property. {} means that the property must be settable as well as gettable.
A struct, class, or enum may conform to a protocol:


A protocol may also define a default implementation for any of its requirements through an extension:

A protocol can be used as a type, provided it doesn't have associatedtype requirements:

You may also define an abstract type that conforms to multiple protocols:
Version ≥ 3.0
With Swift 3 or better, this is done by separating the list of protocols with an ampersand (&):

Version < 3.0
protocol<...>Older versions have syntax  where the protocols are a comma-separated list between the angle brackets <>.

Existing types can be extended to conform to a protocol:

Section 17.2: Delegate pattern
A delegate is a common design pattern used in Cocoa and CocoaTouch frameworks, where one class delegates responsibility for implementing some functionality to another. This follows a principle of separation of concerns, where the framework class implements generic functionality while a separate delegate instance implements the specific use case.
Another way to look into delegate pattern is in terms of object communication. Objects often needs to talks to each other and to do so an object need conform to a protocol in order to become a delegate of another Object. Once this setup has been done, the other object talks back to its delegates when interesting things happens.
For example, A view in userinterface to display a list of data should be responsible only for the logic of how data is displayed, not for deciding what data should be displayed.
Let's dive into a more concrete example. if you have two classes, a parent and a child:

And you want to notify the parent of a change from the child.
In Swift, delegates are implemented using a protocol declaration and so we will declare a protocol which the delegate will implement. Here delegate is the parent object.

The child needs to declare a property to store the reference to the delegate:

Notice the variable delegate is an optional and the protocol ChildDelegate is marked to be only implemented by class type (without this the delegate variable can't be declared as a weak reference avoiding any retain cycle. This means that if the delegate variable is no longer referenced anywhere else, it will be released). This is so the parent class only registers the delegate when it is needed and available.
Also in order to mark our delegate as weak we must constrain our ChildDelegate protocol to reference types by adding class keyword in protocol declaration.
In this example, when the child does something and needs to notify its parent, the child will call:

If the delegate has been defined, the delegate will be notified that the child has done something.
The parent class will need to extend the ChildDelegate protocol to be able to respond to its actions. This can be done directly on the parent class:

Or using an extension:

The parent also needs to tell the child that it is the child's delegate:

By default a Swift protocol does not allow an optional function be implemented. These can only be specified if your protocol is marked with the @objc attribute and the optional modifier.
For example UITableView implements the generic behavior of a table view in iOS, but the user must implement two delegate classes called UITableViewDelegate and UITableViewDataSource that implement how the specific cells look like and behave.
@objc public protocol UITableViewDelegate : NSObjectProtocol, UIScrollViewDelegate { // Display customization optional public func tableView(tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) optional public func tableView(tableView: UITableView, willDisplayHeaderView view:
UIView, forSection section: Int) optional public func tableView(tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) optional public func tableView(tableView: UITableView, didEndDisplayingCell cell:
UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) ... }
You can implement this protocol by changing your class definition, for example:

Any methods not marked optional in the protocol definition (UITableViewDelegate in this case) must be implemented.
Section 17.3: Associated type requirements
Protocols may define associated type requirements using the associatedtype keyword:

ciatedtype Element var count: Int { get } subscript(index: Int) -> Element { get set } }
Protocols with associated type requirements can only be used as generic constraints:
// These are allowed, because Container has associated type requirements: func displayValues(container:
Container) { ... } class MyClass { let container: Container } // > error: protocol 'Container' can only be used as a generic constraint // > because it has Self or associated type requirements // These are allowed: func displayValues<T: Container>(container: T) { ... } class MyClass<T: Container> { let container: T }
A type which conforms to the protocol may satisfy an associatedtype requirement implicitly, by providing a given type where the protocol expects the associatedtype to appear:

> { get { precondition(index == 0) return value } set { precondition(index == 0) value = newValue } } } let container = ContainerOfOne(value: "Hello")
(Note that to add clarity to this example, the generic placeholder type is named T - a more suitable name would be Element, which would shadow the protocol's associatedtype Element. The compiler will still infer that the generic placeholder Element is used to satisfy the associatedtype Element requirement.) An associatedtype may also be satisfied explicitly through the use of a typealias:

alias Element = T subscript(index: Int) -> Element { ... } // ... } The same goes for extensions:

If the conforming type already satisfies the requirement, no implementation is needed:
extension Array: Container {}  // Array satisfies all requirements, including Element
Section 17.4: Class-Only Protocols
A protocol may specify that only a class can implement it through using the class keyword in its inheritance list. This keyword must appear before any other inherited protocols in this list.
protocol ClassOnlyProtocol: s, SomeOtherProtocol { // Protocol requirements }
If a non-class type tries to implement ClassOnlyProtocol, a compiler error will be generated.

Other protocols may inherit from the ClassOnlyProtocol, but they will have the same class-only requirement.

Reference semantics of class-only protocols
Using a class-only protocol allows for reference semantics when the conforming type is unknown.

In this example, as Foo is a class-only protocol, the assignment to bar is valid as the compiler knows that foo is a class type, and therefore has reference semantics.
If Foo was not a class-only protocol, a compiler error would be yielded - as the conforming type could be a value type, which would require a var annotation in order to be mutable.


foo = foo // mutable copy of foo foo.bar = "new value" // no error - satisfies both reference and value semantics } Weak variables of protocol type
When applying the weak modifier to a variable of protocol type, that protocol type must be class-only, as weak can only be applied to reference types.

Section 17.5: Protocol extension for a specific conforming class
You can write the default protocol implementation for a specific class.

Section 17.6: Using the RawRepresentable protocol (Extensible Enum)

This struct can be extended elsewhere to add cases

And an interface can design around any RawRepresentable type or specifically your enum struct

At call site, you can use dot syntax shorthand for the typesafe NotificationName

Using generic RawRepresentable function

Section 17.7: Implementing Hashable protocol
Dictionaries(keyTypes used in Sets and ) must conform to Hashable protocol which inherits from Equatable protocol.
Custom type conforming to Hashable protocol must implement
A calculated property hashValue
Define one of the equality operators i.e. == or !=.
Following example implements Hashable protocol for a custom struct:


Note: It is not necessary that different values in custom type have different hash values, collisions are acceptable. If hash values are equal, equality operator will be used to determine real equality.

Chapter 18: Functions
Section 18.1: Basic Use
Functions can be declared without parameters or a return value. The only required information is a name (hello in this case).

Call a function with no parameters by writing its name followed by an empty pair of parenthesis.

Section 18.2: Functions with Parameters
Functions can take parameters so that their functionality can be modified. Parameters are given as a comma separated list with their types and names defined.

number1Note: The \() syntax is basic String Interpolation and is used to insert the integer into the String.
Functions with parameters are called by specifying the function by name and supplying an input value of the type used in the function declaration.

Any value of type Int could have been used.

When a function uses multiple parameters the name of the first parameter is not required for the first but is on subsequent parameters.

Use external parameter names to make function calls more readable.

Setting the default value in the function declaration allows you to call the function without giving any input values.

Section 18.3: Subscripts
Classes, structures, and enumerations can define subscripts, which are shortcuts for accessing the member elements of a collection, list, or sequence.
Example

Subscript Usage

Subscripts Options:
Subscripts can take any number of input parameters, and these input parameters can be of any type. Subscripts can also return any type. Subscripts can use variable parameters and variadic parameters, but cannot use in-out parameters or provide default parameter values.
Example:

Usage

Section 18.4: Methods
Instance methods are functions that belong to instances of a type in Swift (a class, struct, enumeration, or protocol). Type methods are called on a type itself.
Instance Methods
Instance methods are defined with a func declaration inside the definition of the type, or in an extension.

incrementThe () instance method is called on an instance of the Counter class:
let counter = Counter()  // create an instance of Counter class  counter.increment()      // call the instance method on this instance
Type Methods
static func keywords. (For classes, class funcType methods are defined with the  defines a type method that can be overridden by subclasses.)

SomeClass.someTypeMethod()  // type method is called on the SomeClass type itself
Section 18.5: Variadic Parameters
Sometimes, it's not possible to list the number of parameters a function could need. Consider a sum function:

This works fine for finding the sum of two numbers, but for finding the sum of three we'd have to write another function:

and one with four parameters would need another one, and so on. Swift makes it possible to define a function with a variable number of parameters using a sequence of three periods: .... For example,

Int...Notice how the numbers parameter, which is variadic, is coalesced into a single Array of type []. This is true in general, variadic parameters of type T are accessible as a [T].
This function can now be called like so:

A variadic parameter in Swift doesn't have to come at the end of the parameter list, but there can only be one in each function signature.
Sometimes, it's convenient to put a minimum size on the number of parameters. For example, it doesn't really make sense to take the sum of no values. An easy way to enforce this is by putting some non-variadic required parameters and then adding the variadic parameter after. To make sure that sum can only be called with at least two parameters, we can write

Section 18.6: Operators are Functions
Operators such as +, -, ?? are a kind of function named using symbols rather than letters. They are invoked differently from functions:
 Prefix: >x
Infix: x > y
Postfix: xb>
You can read more about basic operators and advanced operators in The Swift Programming Language.
Section 18.7: Passing and returning functions
The following function is returning another function as its result which can be later assigned to a variable and called:

Section 18.8: Function types
Every function has its own function type, made up of the parameter types and the return type of the function itself. For example the following function:

has a function type of:

Function types can thus be used as parameters types or as return types for nesting functions.
Section 18.9: Inout Parameters
Functions can modify the parameters passed to them if they are marked with the inout keyword. When passing an inout parameter to a function, the caller must add a & to the variable being passed.

This allows reference semantics to be applied to types which would normally have value semantics.
Section 18.10: Throwing Errors
If you want a function to be able to throw errors, you need to add the throws keyword after the parentheses that hold the arguments:

When you want to throw an error, use the throw keyword:

If you want to call a function that can throw an error, you need to use the try keyword in a do block:

For more on Swift errors: Errors
Section 18.11: Returning Values
Functions can return values by specifying the type after the list of parameters.

Functions can also return multiple values using tuples.

Section 18.12: Trailing Closure Syntax
When the last parameter of a function is a closure

the function can be invoked using the Trailing Closure Syntax


Section 18.13: Functions With Closures
Using functions that take in and execute closures can be extremely useful for sending a block of code to be executed elsewhere. We can start by allowing our function to take in an optional closure that will (in this case) return Void.

Now that our function has been defined, let's call it and pass in some code:

closedFuncBy using a trailing closure with our function call, we can pass in code (in this case, print) to be executed at some point within our () function.
The log should print:
Just beginning Over already
A more specific use case of this could include the execution of code between two classes:

The log should print:
1
2

Chapter 19: Extensions
Section 19.1: What are Extensions?
Extensions are used to extend the functionality of existing types in Swift. Extensions can add subscripts, functions, initializers, and computed properties. They can also make types conform to protocols.
Suppose you want to be able to compute the factorial of an Int. You can add a computed property in an extension:

Then you can access the property just as if it had been included in original Int API.

Section 19.2: Variables and functions
Extensions can contain functions and computed/constant get variables. They are in the format

To reference the instance of the extended object, self can be used, just as it could be used
lengthTo create an extension of String that adds a .() function which returns the length of the string, for example

lengthExtensions can also contain get variables. For example, adding a . variable to the string which returns the length of the string

Section 19.3: Initializers in Extensions
Extensions can contain convenience initializers. For example, a failable initializer for Int that accepts a NSString:

Section 19.4: Subscripts
Extensions can add new subscripts to an existing type.
This example gets the character inside a String using the given index:


Section 19.5: Protocol extensions
A very useful feature of Swift 2.2 is having the ability of extending protocols.
It works pretty much like abstract classes when regarding a functionality you want to be available in all the classes that implements some protocol (without having to inherit from a base common class).


This is also possible using generics.
Section 19.6: Restrictions
It is possible to write a method on a generic type that is more restrictive using where sentence.

Example of use

Section 19.7: What are extensions and when to use them
Extensions add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you do not have access to the original source code.
Extensions in Swift can:
Add computed properties and computed type properties
Define instance methods and type methods
Provide new initializers
Define subscripts
Define and use new nested types
Make an existing type conform to a protocol
When to use Swift Extensions:
Additional functionality to Swift
Additional functionality to UIKit / Foundation
Additional functionality without messing with other persons code
Breakdown classes into: Data / Functionality / Delegate
When not to use:
 Extend your own classes from another file
Simple example:

Source

Chapter 20: Classes
Section 20.1: Defining a Class
You define a class like this:

A class can also be a subclass of another class:

In this example, Animal could also be a protocol that Dog conforms to.
Section 20.2: Properties and Methods
Classes can define properties that instances of the class can use. In this example, Dog has two properties: name and dogYearAge:

You can access the properties with dot syntax:

Classes can also define methods that can be called on the instances, they are declared similar to normal functions, just inside the class:

Calling methods also uses dot syntax:

Section 20.3: Reference Semantics
Classes are reference types, meaning that multiple variables can refer to the same instance.

let otherDog = firstDog  // otherDog points to
same Dog instance otherDog.name = "Rover" // modifying otherDog also modifies firstDog print(firstDog.name) // prints "Rover"
Because classes are reference types, even if the class is a constant, its variable properties can still be modified.

Test whether two objects are identical (point to the exact same instance) using ===:

Section 20.4: Classes and Multiple Inheritance
Swift does not support multiple inheritance. That is, you cannot inherit from more than one class.

class Dog: Animal, Pet { ... } // This will result in a compiler error.
Instead you are encouraged to use composition when creating your types. This can be accomplished by using protocols.
Section 20.5: deinit


Chapter 21: Type Casting
Section 21.1: Downcasting
as?, and asA variable can be downcasted to a subtype using the type cast operators !.
asThe ? operator attempts to cast to a subtype. It can fail, therefore it returns an optional.

It does not return an optional, but crashes if the cast fails.

It is common to use type cast operators with conditional unwrapping:

Section 21.2: Type casting in Swift Language
Type Casting
Type casting is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.
Type casting in Swift is implemented with the is and as operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.
Downcasting
A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes.
Where you believe this is the case, you can try to downcast to the subclass type with a type cast operator (as? or as!).
Because downcasting can fail, the type cast operator comes in two different forms. The conditional form, as?, returns an optional value of the type you are trying to downcast to. The forced form, as!, attempts the downcast and force-unwraps the result as a single compound action.
Use the conditional form of the type cast operator (as?) when you are not sure if the downcast will succeed. This form of the operator will always return an optional value, and the value will be nil if the downcast was not possible. This enables you to check for a successful downcast.
Use the forced form of the type cast operator (as!) only when you are sure that the downcast will always succeed.
This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type. Know more.
String to Int & Float conversion : -






Downcasting values from JSON
    let json = ["name" : "john", "subjects": ["Maths", "Science", "English", "C Language"]] as [String : Any]     let name = json["name"] as? String ?? ""     print(name) // Output : john     let subjects = json["subjects"] as? [String] ?? []
    print(subjects) // Output : ["Maths", "Science", "English", "C Language"]
Downcasting values from Optional JSON
    let response: Any = ["name" : "john", "subjects": ["Maths", "Science", "English", "C Language"]]     let json = response as? [String: Any] ?? [:]     let name = json["name"] as? String ?? ""     print(name) // Output : john     let subjects = json["subjects"] as? [String] ?? []
    print(subjects) // Output : ["Maths", "Science", "English", "C Language"]
Manage JSON Response with conditions

Manage Nil Response with condition

Empty DictionaryOutput : 
Section 21.3: Upcasting
The as operator will cast to a supertype. As it cannot fail, it does not return an optional.

Section 21.4: Example of using a downcast on a function parameter involving subclassing
A downcast can be used to make use of a subclass's code and data inside of a function taking a parameter of its superclass.

Section 21.5: Casting with switch
The switch statement can also be used to attempt casting into different types:

Chapter 22: Generics
Section 22.1: The Basics of Generics
Generics are placeholders for types, allowing you to write flexible code that can be applied across multiple types. The advantage of using generics over Any is that they still allow the compiler to enforce strong type-safety.
A generic placeholder is defined within angle brackets <>.
Generic Functions
For functions, this placeholder is placed after the function name:

;T>(_ a:T, _ b:T) -> T { return arc4random_uniform(2) == 0 ? a : b }
In this case, the generic placeholder is T. When you come to call the function, Swift can infer the type of T for you (as it simply acts as a placeholder for an actual type). let randomOutput = pickRandom(5, 7) // returns an Int (that's either 5 or 7)
T == IntInt, Int) -> IntHere we're passing two integers to the function. Therefore Swift is inferring  - thus the function signature is inferred to be (.
Because of the strong type safety that generics offer - both the arguments and return of the function must be the same type. Therefore the following will not compile:

Generic Types
In order to use generics with classes, structs or enums, you can define the generic placeholder after the type name.
class Bar;T> { var baz : T init(baz:T) { self.baz = baz } }
init(bazThis generic placeholder will require a type when you come to use the class Bar. In this case, it can be inferred from the initialiser :T).

Bar<StringHere the generic placeholder T is inferred to be of type String, thus creating a > instance. You can also specify the type explicitly:
let bar = Bar;String>(baz: "a string")
When used with a type, the given generic placeholder will keep its type for the entire lifetime of the given instance, and cannot be changed after initialisation. Therefore when you access the property baz, it will always be of type String for this given instance.

Passing Around Generic Types
When you come to pass around generic types, in most cases you have to be explicit about the generic placeholder type you expect. For example, as a function input:
func takeABarInt(bar:Bar;Int>) { ... }
Bar<IntThis function will only accept a >. Attempting to pass in a Bar instance where the generic placeholder type is not Int will result in a compiler error.
Generic Placeholder Naming
Generic placeholder names are not just limited to single letters. If a given placeholder represents a meaningful concept, you should give it a descriptive name. For example, Swift's Array has a generic placeholder called Element, which defines the element type of a given Array instance.
public struct Array;Element> : RandomAccessCollection, MutableCollection { ... }
Section 22.2: Constraining Generic Placeholder Types
It is possible to force the type parameters of a generic class to implement a protocol, for example, Equatable

Whenever we create a new MyGenericClass, the type parameter has to implement the Equatable protocol
(ensuring the type parameter can be compared to another variable of the same type using ==)

Section 22.3: Generic Class Examples

We can now create new objects using a type parameter

Generics can also be created with multiple type parameters

And used in the same way


Section 22.4: Using Generics to Simplify Array Functions
A function that extends the functionality of the array by creating an object oriented remove function.
// Need to restrict the extension to elements that can be compared.
// The `Element` is the generics name defined by Array for its item types. // This restriction also gives us access to `index(of:_)` which is also // defined in an Array extension with `where Element: Equatable`.
public extension Array where Element: Equatable {
    /// Removes the given object from the array.     mutating func remove(_ element: Element) {         if let index = self.index(of: element ) {             self.remove(at: index)
        } else {             fatalError("Removal error, no such element:\"\(element)\" in array.\n")
        }
    }
}
Usage

Use the function to remove an element without need for an index. Just pass the object to remove.

Section 22.5: Advanced Type Constraints
It's possible to specify several type constraints for generics using the where clause:

It's also valid to write the where clause after the argument list:
func doSomething<T>(first: T, second: T) where T: Comparable, T: Hashable {

Extensions can be restricted to types that satisfy conditions. The function is only available to instances which satisfy the type conditions:
// "Element" is the generics type defined by "Array". For this example, we
// want to add a function that requires that "Element" can be compared, that
// is: it needs to adhere to the Equatable protocol. public extension Array where Element: Equatable {
    /// Removes the given object from the array.     mutating func remove(_ element: Element) {
        // We could also use "self.index(of: element)" here, as "index(of:_)"
        // is also defined in an extension with "where Element: Equatable".         // For the sake of this example, explicitly make use of the Equatable.         if let index = self.index(where: { $0 == element }) {             self.remove(at: index)
        } else {             fatalError("Removal error, no such element:\"\(element)\" in array.\n")
        }
    }
}
Section 22.6: Generic Class Inheritance
Generic classes can be inherited:

Section 22.7: Use generics to enhance type-safety
Let's take this example without using generics

The protocol declaration seems fine unless you actually use it.

Why do you have to cast the result to TestObject? Because of the Any return type in the protocol declaration.
By using generics you can avoid this problem that can cause runtime errors (and we don't want to have them!)


Chapter 23: OptionSet
Section 23.1: OptionSet Protocol
OptionSetType is a protocol designed to represent bit mask types where individual bits represent members of the set. A set of logical and/or functions enforce the proper syntax:

Chapter 24: Reading & Writing JSON
Section 24.1: JSON Serialization, Encoding, and Decoding with Apple Foundation and the Swift Standard Library
The JSONSerialization class is built into Apple's Foundation framework.
Version = 2.2
Read JSON
as?The JSONObjectWithData function takes NSData, and returns AnyObject. You can use  to convert the result to your expected type.

options: .AllowFragments instead of options: []You can pass  to allow reading JSON when the top-level object isn't an array or dictionary.
Write JSON
Calling dataWithJSONObject converts a JSON-compatible object (nested arrays or dictionaries with strings, numbers, and NSNull) to raw NSData encoded as UTF-8.

options: .PrettyPrinted instead of options: []You can pass  for pretty-printing.
Version = 3.0
Same behavior in Swift 3 but with a different syntax.


As of Swift 4.0, the Swift standard library includes the protocols Encodable and Decodable to define a standardized approach to data encoding and decoding. Adopting these protocols will allow implementations of the Encoder and Decoder protocols take your data and encode or decode it to and from an external representation such as JSON. Conformance to the Codable protocol combines both the Encodable and Decodable protocols. This is now the recommended means to handle JSON in your program.
Encode and Decode Automatically
The easiest way to make a type codable is to declare its properties as types that are already Codable. These types include standard library types such as String, Int, and Double; and Foundation types such as Date, Data, and URL. If a type's properties are codable, the type itself will automatically conform to Codable by simply declaring the conformance.
Consider the following example, in which the Book structure conforms to Codable.

By adopting Codable, the Book structure can now be encoded to and decoded from JSON using the Apple
Foundation classes JSONEncoder and JSONDecoder, even though Book itself contains no code to specifically handle JSON. Custom encoders and decoders can be written, as well, by conforming to the Encoder and Decoder protocols, respectively.

Encoding or Decoding Exclusively
Sometimes you may not need data to be both encodable and decodable, such as when you need only read JSON data from an API, or if your program only submits JSON data to an API.
If you intend only to write JSON data, conform your type to Encodable.

If you intend only to read JSON data, conform your type to Decodable.

Using Custom Key Names
APIs frequently use naming conventions other than the Swift-standard camel case, such as snake case. This can become an issue when it comes to decoding JSON, since by default the JSON keys must align exactly with your type's property names. To handle these scenarios you can create custom keys for your type using the CodingKey protocol.


CodingKeys are generated automatically for types which adopt the Codable protocol, but by creating our own implementation in the example above we're allow our decoder to match the local camel case publicationDate with the snake case publication_date as it's delivered by the API.
Section 24.2: SwiftyJSON
SwiftyJSON is a Swift framework built to remove the need for optional chaining in normal JSON serialization.
You can download it here: https://github.com/SwiftyJSON/SwiftyJSON
Without SwiftyJSON, your code would look like this to find the name of the first book in a JSON object:
if let jsonObject = try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments) as?
[[String: AnyObject]], let bookName = (jsonObject[0]["book"] as? [String: AnyObject])?["name"] as? String {     //We can now use the book name
}
In SwiftyJSON, this is hugely simplified:

It removes the need to check every field, as it will return nil if any of them are invalid.
To use SwiftyJSON, download the correct version from the Git repository - there is a branch for Swift 3. Simply drag the "SwiftyJSON.swift" into your project and import into your class:

You can create your JSON object using the following two initializers:

or
 let jsonObject = JSON(jsonObject) //This could be a string in a JSON format for example To access your data, use subscripts:

You can then parse your value to a certain data type, which will return an optional value:
let nameOfFirstObject = jsonObject[0]["name"].string //This will return the name as a string let nameOfFirstObject = jsonObject[0]["name"].double //This will return null
You can also compile your paths into a swift Array: let convolutedPath = jsonObject[0]["name"][2]["lastName"]["firstLetter"].string Is the same as: let convolutedPath = jsonObject[0, "name", 2, "lastName", "firstLetter"].string SwiftyJSON also has functionality to print its own errors:

If you need to write to your JSON object, you can use subscripts again:
var originalJSON:JSON = ["name": "Jack", "age": 18] originalJSON["age"] = 25 //This changes the age to 25 originalJSON["surname"] = "Smith" //This creates a new field called "surname" and adds the value to it
Should you need the original String for the JSON, for example if you need to write it to a file, you can get the raw value out:

Section 24.3: Freddy
Freddy is a JSON parsing library maintained by Big Nerd Ranch. It has three principal benefits:
1. Type Safety: Helps you work with sending and receiving JSON in a way that prevents runtime crashes.
2. Idiomatic: Takes advantage of Swift's generics, enumerations, and functional features, without complicated documentation or magical custom operators.
3. Error Handling: Provides informative error information for commonly occurring JSON errors.
Example JSON Data
Let's define some example JSON data for use with these examples.


Deserializing Raw Data
To deserialize the data, we initialize a JSON object then access a particular key.

We try here because accessing the json for the key "success" could fail--it might not exist, or the value might not be a boolean.
We can also specify a path to access elements nested in the JSON structure. The path is a comma-separated list of keys and indices that describe the path to a value of interest.

Deserializing Models Directly
JSON can be directly parsed to a model class that implements the JSONDecodable protocol.


Serializing Raw Data
Any JSON value can be serialized directly to NSData.

Serializing Models Directly
Any model class that implements the JSONEncodable protocol can be serialized directly to NSData.

Section 24.4: JSON Parsing Swift 3


Import your JSON File in your project
You can perform this simple function to print out your JSON file

If you want to put it in a table view, I would create a dictionary first with an NSObject.
Create a new swift file called ParsingObject and create your string variables.
		Make sure that the variable name is the same as the JSON File
. For example, in our project we have name and question so in our new swift file, we will use

Initialize the NSObject we made back into our ViewController.swift var array = ParsingObject Then we would perform the same method we had before with a minor modification.

Then we show it in our tableview by doing this,

Section 24.5: Simple JSON parsing into custom objects
Even if third-party libraries are good, a simple way to parse the JSON is provided by protocols You can imagine you have got an object Todo as


Whenever you receive the JSON, you can handle the plain NSData as shown in the other example using NSJSONSerialization object.

And making your Todo struct conforming to JSONDecodable does the trick

You can try it with this json code:

When you got it from the API, you can serialize it as the previous examples shown in an AnyObject instance. After that, you can check if the instance is a JSONDictionary instance
guard let jsonDictionary = dictionary as? JSONDictionary else { return }
The other thing to check, specific for this case because you have an array of Todo in the JSON, is the todos dictionary
guard let todosDictionary = jsonDictionary["todos"] as? [JSONDictionary] else { return }
Now that you got the array of dictionaries, you can convert each of them in a Todo object by using flatMap (it will automatically delete the nil values from the array)
let todos: [Todo] = todosDictionary.flatMap { Todo.from(json: $0) }
Section 24.6: Arrow
Arrow is an elegant JSON parsing library in Swift.
It allows to parse JSON and map it to custom model classes with help of an
<--
operator:

Example:
Swift model

JSON file

Mapping

Usage

Installation:
Carthage

CocoaPods

Manually
Simply Copy and Paste Arrow.swift in your Xcode Project https://github.com/s4cha/Arrow
As A Framework
Download Arrow from the GitHub repository and build the Framework target on the example project. Then Link against this framework.

Chapter 25: Advanced Operators
Section 25.1: Bitwise Operators
Swift Bitwise operators allow you to perform operations on the binary form of numbers. You can specify a binary literal by prefixing the number with 0b, so for example 0b110 is equivalent to the binary number 110 (the decimal number 6). Each 1 or 0 is a bit in the number.
Bitwise NOT ~:

Here, each bit get changed to its opposite. Declaring the number as explicitly UInt8 ensures that the number is positive (so that we don't have to deal with negatives in the example) and that it is only 8 bits. If 0b01101100 was a larger UInt, there would be leading 0s that would be converted to 1s and become significant upon inversion:

Bitwise AND &:

Here, a given bit will be 1 if and only if the binary numbers on both sides of the & operator contained a 1 at that bit location.
0 & 0 -> 0
0 & 1 -> 0
1 & 1 -> 1
Bitwise OR |:

Here, a given bit will be 1 if and only if the binary number on at least one side of the | operator contained a 1 at that bit location.
0 | 0 -> 0
0 | 1 -> 1
1 | 1 -> 1
Bitwise XOR (Exclusive OR) ^:

Here, a given bit will be 1 if and only if the bits in that position of the two operands are different.
0 ^ 0 -> 0
0 ^ 1 -> 1
1 ^ 1 -> 0
For all binary operations, the order of the operands makes no difference on the result.
Section 25.2: Custom Operators
Swift supports the creation of custom operators. New operators are declared at a global level using the operator keyword.
The operator's structure is defined by three parts: operand placement, precedence, and associativity.
++1. The prefix, infix and postfix modifiers are used to start an custom operator declaration. The prefix and postfix modifiers declare whether the operator must be before or after, respectively, the value on which it acts. Such operators are urnary, like 8 and 3 **, since they can only act on one target. The infix declares a binary operator, which acts on the two values it is between, such as 2+3.
2. Operators with higher precedence are calculated first. The default operator precedence is just higher than ?...: (a value of 100 in Swift 2.x). The precedence of standard Swift operators can be found here.
3. Associativity defines the order of operations between operators of the same precedence. Left associative operators are calculated from left to right (reading order, like most operators), while right associative operators calculate from right to left.
Version ≥ 3.0
Starting from Swift 3.0, one would define the precedence and associativity in a precedence group instead of the operator itself, so that multiple operators can easily share the same precedence without referring to the cryptic numbers. The list of standard precedence groups is shown below.
Operators return values based on the calculation code. This code acts as a normal function, with parameters specifying the type of input and the return keyword specifying the calculated value that the operator returns.
Here is the definition of a simple exponential operator, since standard Swift does not have an exponential operator.

**The infix says that the ** operator works in between two values, such as 92. Because the function has left
**3**2 is calculated as (3**3)****associativity, 32. The precedence of 170 is higher than all standard Swift operations, meaning that 3+24 calculates to 19, despite the left associativity of **.
Version ≥ 3.0

Instead of specifying the precedence and associativity explicitly, on Swift 3.0 we could use the built-in precedence group BitwiseShiftPrecedence that gives the correct values (same as <<, >>).
**: The increment and decrement are deprecated and will be removed in Swift 3.
Section 25.3: Overflow Operators
Overflow refers to what happens when an operation would result in a number that is either larger or smaller than the designated amount of bits for that number may hold.
Due to the way binary arithmetic works, after a number becomes too large for its bits, the number overflows down to the smallest possible number (for the bit size) and then continues counting up from there. Similarly, when a number becomes too small, it underflows up to the largest possible number (for its bit size) and continues counting down from there.
Because this behavior is not often desired and can lead to serious security issues, the Swift arithmetic operators +, -, and * will throw errors when an operation would cause an overflow or underflow. To explicitly allow overflow and underflow, use &+, &-, and &* instead.

Section 25.4: Commutative Operators
Let's add a custom operator to multiply a CGSize

Now this works
let sizeA = CGSize(height:100, width:200)    
let sizeB = 1.1 * sizeA         //=> (height: 110, width: 220)
But if we try to do the operation in reverse, we get an error

But it's simple enough to add:


Now the operator is commutative.
let sizeA = CGSize(height:100, width:200)    
let sizeB = sizeA * 1.1              //=> (height: 110, width: 220)
Section 25.5: Overloading + for Dictionaries
As there is currently no simple way of combining dictionaries in Swift, it can be useful to overload the + and += operators in order to add this functionality using generics.

Version ≥ 3.0
As of Swift 3, inout should be placed before the argument type.

Example usage:
let firstDict = ["hello" : "world"] let secondDict = ["world" : "hello"] var thirdDict = firstDict + secondDict // ["hello": "world", "world": "hello"] thirdDict += ["hello":"bar", "baz":"qux"] // ["hello": "bar", "baz": "qux", "world": "hello"]
Section 25.6: Precedence of standard Swift operators
Operators that bound tighter (higher precedence) are listed first.
OperatorsPrecedence group (≥3.0)PrecedenceAssociativity.∞left?, !, ++, --, [], (), {}(postfix)!, ~, +, -, ++, --(prefix)~> (swift ≤2.3)255left<<, >>BitwiseShiftPrecedence160none*, /, %, &, &*MultiplicationPrecedence150left+, -, |, ^, &+, &-AdditionPrecedence140leftas?, as..., ..<	RangeFormationPrecedence	135	none is, as, !	CastingPrecedence	132	left
??	NilCoalescingPrecedence	131right<, <=, >, >=, ==, !=, ===, !==, ~=	ComparisonPrecedence	130none&&	LogicalConjunctionPrecedence 120left||	LogicalDisjunctionPrecedence 110leftDefaultPrecedence*none?...:	TernaryPrecedence	100right=, +=, -=, *=, /=, %=, <<=, >>=, &=, |=, ^= AssignmentPrecedence	90right, assignment->	FunctionArrowPrecedence
Version ≥ 3.0right The DefaultPrecedence precedence group is higher than TernaryPrecedence, but is unordered with the rest of the operators. Other than this group, the rest of the precedences are linear.
This table can be also be found on Apple's API reference
The actual definition of the precedence groups can be found in the source code on GitHub

Chapter 26: Method Swizzling
Section 26.1: Extending UIViewController and Swizzling viewDidLoad
In Objective-C, method swizzling is the process of changing the implementation of an existing selector. This is possible due to the way Selectors are mapped on a dispatch table, or a table of pointers to functions or methods.
Pure Swift methods are not dynamically dispatched by the Objective-C runtime, but we can still take advantage of these tricks on any class that inherits from NSObject.
Here, we will extend UIViewController and swizzle viewDidLoad to add some custom logging:
extension UIViewController {    
    // We cannot override load like we could in Objective-C, so override initialize instead     public override static func initialize() {
       
        // Make a static struct for our dispatch token so only one exists in memory         struct Static {             static var token: dispatch_once_t = 0         }
               // Wrap this in a dispatch_once block so it is only run once         dispatch_once(&Static.token) {             // Get the original selectors and method implementations, and swap them with our new method             let originalSelector = #selector(UIViewController.viewDidLoad)             let swizzledSelector = #selector(UIViewController.myViewDidLoad)                        let originalMethod = class_getInstanceMethod(self, originalSelector)             let swizzledMethod = class_getInstanceMethod(self, swizzledSelector)
                       let didAddMethod = class_addMethod(self, originalSelector,
method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))            
            // class_addMethod can fail if used incorrectly or with invalid pointers, so check to make sure we were able to add the method to the lookup table successfully             if didAddMethod {                 class_replaceMethod(self, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))             } else {                 method_exchangeImplementations(originalMethod, swizzledMethod);             }
        }
    }
   
    // Our new viewDidLoad function
    // In this example, we are just logging the name of the function, but this can be used to run any custom code     func myViewDidLoad() {
        // This is not recursive since we swapped the Selectors in initialize().         // We cannot call super in an extension.         self.myViewDidLoad()         print(#function) // logs myViewDidLoad()
    }
}
Section 26.2: Basics of Swift Swizzling
methodOne() and methodTwo()Let's swap the implementation of  in our TestSwizzling class:

Section 26.3: Basics of Swizzling - Objective-C
initWithFrame:Objective-C example of swizzling UIView's  method



Chapter 27: Reflection
Section 27.1: Basic Usage for Mirror
Creating the class to be the subject of the Mirror

Creating an instance that will actually be the subject of the mirror. Also here you can add values to the properties of the Project class.

The code below shows the creating of Mirror instance. The children property of the mirror is a
AnyForwardCollection<Child> where Child is typealias tuple for subject's property and value. Child had a label:
Output in Playground or Console in Xcode for the for loop above.

Tested in Playground on Xcode 8 beta 2
Section 27.2: Getting type and names of properties for a class without having to instantiate it
type(of: value)value.dynamicTypeUsing the Swift class Mirror works if you want to extract name, value and type (Swift 3: , Swift 2: ) of properties for an instance of a certain class.
If you class inherits from NSObject, you can use the method class_copyPropertyList together with property_getAttributes to find out the name and types of properties for a class - without having an instance of it. I created a project on Github for this, but here is the code:

Where primitiveDataTypes is a Dictionary mapping a letter in the attribute string to a value type:

NSObject.Typeself on e.g. an Int - Int.selfDictionary<String, AnyIt can extract the  of all properties which class type inherits from NSObject such as NSDate (Swift3: Date), NSString(Swift3: String?) and NSNumber, however it is store in the type Any (as you can see as the type of the value of the Dictionary returned by the method). This is due to the limitations of value types such as Int, Int32, Bool. Since those types do not inherit from NSObject, calling . does not return NSObject.Type, but rather the type Any. Thus the method returns >? and not
Dictionary<String, NSObject.Type>?.
You can use this method like this:

NSObject.TypeYou can also try to cast the Any to , which will succeed for all properties inheriting from NSObject, then you can check the type using standard == operator:


You can then even check the type of value types like this:

var myOptionalInt: IntLIMITATIONS This solution does not work when value types are optionals. If you have declared a property in you NSObject subclass like this: ?, the code above won't find that property because the method class_copyPropertyList does not contain optional value types.

Chapter 28: Access Control
Section 28.1: Basic Example using a Struct
Version ≥ 3.0
In Swift 3 there are multiple access-levels. This example uses them all except for open:

Assume myCar was initialized like this:


This print will work everywhere, including targets that import Car.
Car.model (internal) print(myCar.model)
This will compile if the code is in the same target as Car.
Car.otherName (fileprivate) print(myCar.otherName)
This will only work if the code is in the same file as Car.
Car.fullName (private) print(myCar.fullName)
This won't work in Swift 3. private properties can only be accessed within the same struct/class.


If the entity has multiple associated access levels, Swift looks for the lowest level of access. If a private variable exists in a public class, the variable will still be considered private.
Section 28.2: Subclassing Example

Section 28.3: Getters and Setters Example

Chapter 29: Closures
Section 29.1: Closure basics
Closures (also known as blocks or lambdas) are pieces of code which can be stored and passed around within your program.

Like other functions, closures can accept arguments and return results or throw errors:

Closures can capture values from their scope:

Closures can be passed directly into functions:

Section 29.2: Syntax variations
The basic closure syntax is
 { [capture list] (parameters) throws-ness -> return type in body }.
Many of these parts can be omitted, so there are several equivalent ways to write simple closures:
let addOne = { [] (x: Int) -> Int in return x + 1 } let addOne = { [] (x: Int) -> Int in x + 1 } let addOne = { (x: Int) -> Int in x + 1 } let addOne = { x -> Int in x + 1 } let addOne = { x in x + 1 } let addOne = { $0 + 1 }
let addOneOrThrow = { [] (x: Int) throws -> Int in return x + 1 } let addOneOrThrow = { [] (x: Int) throws -> Int in x + 1 } let addOneOrThrow = { (x: Int) throws -> Int in x + 1 } let addOneOrThrow = { x throws -> Int in x + 1 } let addOneOrThrow = { x throws in x + 1 }
The capture list can be omitted if it's empty.
Parameters don't need type annotations if their types can be inferred.
The return type doesn't need to be specified if it can be inferred.
Parameters don't have to be named; instead they can be referred to with $0, $1, $2, etc.
If the closure contains a single expression, whose value is to be returned, the return keyword can be omitted.
If the closure is inferred to throw an error, is written in a context which expects a throwing closure, or doesn't throw an error, throws can be omitted.
// The closure's type is unknown, so we have to specify the type of x and y.
// The output type is inferred to be Int, because the + operator for Ints returns Int.
let addInts = { (x: Int, y: Int) in x + y }
// The closure's type is specified, so we can omit the parameters' type annotations. let addInts: (Int, Int) -> Int = { x, y in x + y } let addInts: (Int, Int) -> Int = { $0 + $1 }
Section 29.3: Passing closures into functions
Functions may accept closures (or other functions) as parameters:
func foo(value: Double, block: () -> Void) { ... } func foo(value: Double, block: Int -> Int) { ... } func foo(value: Double, block: (Int, Int) -> String) { ... }
Trailing closure syntax
If a function's last parameter is a closure, the closure braces {/} may be written after the function invocation:


If a function's only argument is a closure, you may also omit the pair of parentheses () when calling it with the trailing closure syntax:


@noescape parameters
selfClosure parameters marked @noescape are guaranteed to execute before the function call returns, so using . is not required inside the closure body:
func executeNow(scape block: () -> Void) { // Since `block` is @noescape, it's illegal to store it to an external
variable. // We can only call it right here. block() } func executeLater(block: () -> Void) { dispatch_async(dispatch_get_main_queue()) { // Some time in the future... block() } }

Swift 3 note:
Note that in Swift 3, you no longer mark blocks as @noescape. Blocks are now not escaping by default. In Swift 3, instead of marking a closure as non-escaping, you mark a function parameter that is an escaping closure as escaping using the "@escaping" keyword. throws and rethrows
Closures, like other functions, may throw errors:
func executeNowOrIgnoreError(block: () ws -> Void) { do { try block() } catch { print("error: \(error)") } }
The function may, of course, pass the error along to its caller:
func executeNowOrThrow(block: () ws -> Void) throws { try block() }
However, if the block passed in doesn't throw, the caller is still stuck with a throwing function:
// It's annoying that this requires "try", because "print()" can't throw! try executeNowOrThrow { print("Just printing, no errors here!") }
The solution is rethrows, which designates that the function can only throw if its closure parameter throws:
func executeNowOrRethrow(block: () ws -> Void) rethrows { try block() } // "try" is not required here, because the
block can't throw an error. executeNowOrRethrow { print("No errors are thrown from this closure") } // This block can throw an error, so "try" is required. try executeNowOrRethrow { throw MyError.Example }
map(), filter(), and indexOfMany standard library functions use rethrows, including ().
Section 29.4: Captures, strong/weak references, and retain cycles

When a closure captures a reference type (a class instance), it holds a strong reference by default:

The closure's capture list can be used to specify a weak or unowned reference:
let closure: () -> Void do {     let obj = MyClass()
    // Captures a weak reference to `obj`: the closure will not keep the object alive;
    // the object becomes optional inside the closure.
    closure = { [weak obj] in obj?.sayHi() }     closure()  // The object is still alive; prints "Hello" } // obj goes out of scope and is deallocated; prints "Goodbye" closure()  // `obj` is nil from inside the closure; this does not print anything.
let closure: () -> Void do {     let obj = MyClass()
    // Captures an unowned reference to `obj`: the closure will not keep the object alive;
    // the object is always assumed to be accessible while the closure is alive.     closure = { [unowned obj] in obj.sayHi() }     closure()  // The object is still alive; prints "Hello" } // obj goes out of scope and is deallocated; prints "Goodbye" closure()  // crash! obj is being accessed after it's deallocated.
For more information, see the Memory Management topic, and the Automatic Reference Counting section of The Swift Programming Language.
Retain cycles
If an object holds onto a closure, which also holds a strong reference to the object, this is a retain cycle. Unless the cycle is broken, the memory storing the object and closure will be leaked (never reclaimed).

Section 29.5: Using closures for asynchronous coding
Closures are often used for asynchronous tasks, for example when fetching data from a website.
Version < 3.0

This function is asynchronous, so will not block the thread it is being called on (it won't freeze the interface if called on the main thread of your GUI application).
Version < 3.0


Because the task is asynchronous, the output will usually look like this:

print("2. Fetched data"Because the code inside of the closure, ), will not be called until the data from the URL is fetched.
Section 29.6: Closures and Type Alias
A closure can be defined with a typealias. This provides a convenient type placeholder if the same closure signature is used in multiple places. For example, common network request callbacks or user interface event handlers make great candidates for being "named" with a type alias.
public typealias ureType = (x: Int, y: Int) -> Int
You can then define a function using the typealias:
public func closureFunction(closure: ureType) { let z = closure(1, 2) } closureFunction() { (x: Int, y: Int) -> Int in
return x + y }

Chapter 30: Initializers
Section 30.1: Convenience init
Swift classes supports having multiple ways of being initialized. Following Apple's specs this 3 rules must be respected:
1. A designated initializer must call a designated initializer from its immediate superclass.

2. A convenience initializer must call another initializer from the same class.
3. A convenience initializer must ultimately call a designated initializer.


Designated Initializer let c = Foo(someString: "Some string", someValue: 10, someBool: true)
Convenience init() let a = Foo()

Designated Initializer (will call the superclass Designated Initializer)

Convenience init() let e = Baz()
Image source: The Swift Programming Language
Section 30.2: Setting default property values
You can use an initializer to set default property values:


Or, specify default property values as a part of the property's declaration:

Classes and structs must set all stored properties to an appropriate initial value by the time an instance is created.
This example will not compile, because the initializer did not give an initial value for downvotes:

Section 30.3: Customizing initialization with parameters

Note that you cannot omit the parameter labels:

In order to allow omission of parameter labels, use an underscore _ as the label:

If your argument labels share names with one or more properties, use self to explicitly set the property values:


Section 30.4: Throwable Initilizer
Using Error Handling to make Struct(or class) initializer as throwable initializer:
Example Error Handling enum:

You can use Error Handling enum to check the parameter for the Struct(or class) meet expected requirement

Now, you can use throwable initializer by:

Chapter 31: Associated Objects
Section 31.1: Property, in a protocol extension, achieved using associated object
In Swift, protocol extensions cannot have true properties.
However, in practice you can use the "associated object" technique. The result is almost exactly like a "real" property.
Here is the exact technique for adding an "associated object" to a protocol extension:
Fundamentally, you use the objective-c "objc_getAssociatedObject" and _set calls.
The basic calls are:

Here's a full example. The two critical points are:
1. In the protocol, you must use ": class" to avoid the mutation problem.
2. In the extension, you must use "where Self:UIViewController" (or whatever appropriate class) to give the confirming type.
So, for an example property "p":


In any conforming class, you have now "added" the property "p":
You can use "p" just as you would use any ordinary property in the conforming class. Example:

Note. You MUST initialize the pseudo-property.
Xcode will not enforce you initializing "p" in the conforming class.
It is essential that you initialize "p", perhaps in viewDidLoad of the confirming class.
It is worth remembering that p is actually just a computed property. p is actually just two functions, with syntactic sugar. There is no p "variable" anywhere: the compiler does not "assign some memory for p" in any sense. For this reason, it is meaningless to expect Xcode to enforce "initializing p".
Indeed, to speak more accurately, you must remember to "use p for the first time, as if you were initializing it". (Again, that would very likely be in your viewDidLoad code.)
Regarding the getter as such.
Note that it will crash if the getter is called before a value for "p" is set.
To avoid that, consider code such as:

To repeat. Xcode will not enforce you initializing p in the conforming class. It is essential that you initialize p, say in viewDidLoad of the conforming class.
Making the code simpler...
You may wish to use these two global functions:

Note that they do nothing, whatsoever, other than save typing and make the code more readable. (They are essentially macros or inline functions.) Your code then becomes:

(In the example at _aoGet, P is initalizable: instead of P() you could use "", 0, or any default value.)
Chapter 32: Concurrency
Section 32.1: Obtaining a Grand Central Dispatch (GCD) queue
Grand Central Dispatch works on the concept of "Dispatch Queues". A dispatch queue executes tasks you designate in the order which they are passed. There are three types of dispatch queues:
Serial Dispatch Queues (aka private dispatch queues) execute one task at a time, in order. They are frequently used to synchronize access to a resource.
Concurrent Dispatch Queues (aka global dispatch queues) execute one or more tasks concurrently. The Main Dispatch Queue executes tasks on the main thread.
To access the main queue:
Version = 3.0

Version < 3.0

The system provides concurrent global dispatch queues (global to your application), with varying priorities. You can access these queues using the DispatchQueue class in Swift 3: Version = 3.0

equivalent to

Version < 3.0 let globalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
userInteractiveIn iOS 8 or later, the possible quality of service values which may be passed are .,
userInitiated, .default, .utility, and .background.. These replace the DISPATCH_QUEUE_PRIORITY_ constants.
You can also create your own queues with varying priorities:
Version = 3.0 let myConcurrentQueue = DispatchQueue(label: "my-concurrent-queue", qos: .userInitiated, attributes: [.concurrent], autoreleaseFrequency: .workItem, target: nil) let mySerialQueue = DispatchQueue(label: "my-serial-queue", qos: .background, attributes: [], autoreleaseFrequency: .workItem, target: nil)
Version < 3.0 let myConcurrentQueue = dispatch_queue_create("my-concurrent-queue", DISPATCH_QUEUE_CONCURRENT) let mySerialQueue = dispatch_queue_create("my-serial-queue", DISPATCH_QUEUE_SERIAL)
workItemneverinheritneverIn Swift 3, queues created with this initializer are serial by default, and passing . for autorelease frequency ensures an autorelease pool is created and drained for each work item. There is also ., which means you will be managing your own autorelease pools yourself, or . which inherits the setting from the environment. In most cases you probably won't use . except in cases of extreme customization.
Section 32.2: Concurrent Loops
GCD provides mechanism for performing a loop, whereby the loops happen concurrently with respect to each other. This is very useful when performing a series of computationally expensive calculations.
Consider this loop:

You can perform those calculations concurrently using concurrentPerform (in Swift 3) or dispatch_apply (in Swift
2):
Version = 3.0

Version < 3.0

The loop closure will be invoked for each index from 0 to, but not including, iterations. These iterations will be run concurrently with respect to each other, and thus the order that they run is not guaranteed. The actual number of iterations that happen concurrently at any given time is generally dictated by the capabilities of the device in question (e.g. how many cores does the device have).
A couple of special considerations:
 The concurrentPerform/dispatch_apply may run the loops concurrently with respect to each other, but this all happens synchronously with respect to the thread from which you call it. So, do not call this from the main thread, as this will block that thread until the loop is done.
 Because these loops happen concurrently with respect to each other, you are responsible for ensuring the thread-safety of the results. For example, if updating some dictionary with the results of these computationally expensive calculations, make sure to synchronize those updates yourself.
 Note, there is some overhead associated in running concurrent loops. Thus, if the calculations being performed inside the loop are not sufficiently computationally intensive, you may find that any performance gained by using concurrent loops may be diminished, if not be completely offset, by the overhead associated with the synchronizing all of these concurrent threads.
So, you are responsible determining the correct amount of work to be performed in each iteration of the loop. If the calculations are too simple, you may employ "striding" to include more work per loop. For example, rather than doing a concurrent loop with 1 million trivial calculations, you may do 100 iterations in your loop, doing 10,000 calculations per loop. That way there is enough work being performed on each thread, so the overhead associated with managing these concurrent loops becomes less significant.
Section 32.3: Running tasks in a Grand Central Dispatch (GCD) queue
Version = 3.0
To run tasks on a dispatch queue, use the sync, async, and after methods.
To dispatch a task to a queue asynchronously:

To dispatch a task to a queue synchronously:

To dispatch a task to a queue after a certain number of seconds:

Version = 2.0
Types of queue:
 let mainQueue = dispatch_get_main_queue() let highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) let backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0) To dispatch a task to a queue asynchronously:

To dispatch a task to a queue synchronously:

To dispatch a task to after a time interval (use NSEC_PER_SEC to convert seconds to nanoseconds): dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(2.5 * Double(NSEC_PER_SEC))),

To execute a task asynchronously and than update the UI:

Section 32.4: Running Tasks in an OperationQueue
You can think of an OperationQueue as a line of tasks waiting to be executed. Unlike dispatch queues in GCD, operation queues are not FIFO (first-in-first-out). Instead, they execute tasks as soon as they are ready to be executed, as long as there are enough system resources to allow for it.
Get the main OperationQueue: Version ≥ 3.0

Create a custom OperationQueue:
Version ≥ 3.0

Quality of Service specifies the importance of the work, or how much the user is likely to be counting on immediate results from the task.
Add an Operation to an OperationQueue:
Version ≥ 3.0


Add multiple Operations to an OperationQueue: Version ≥ 3.0

Adjust how many Operations may be run concurrently within the queue: myQueue.maxConcurrentOperationCount = 3 // 3 operations may execute at once
// Sets number of concurrent operations based on current system conditions
myQueue.maxConcurrentOperationCount = NSOperationQueueDefaultMaxConcurrentOperationCount
Suspending a queue will prevent it from starting the execution of any existing, unstarted operations or of any new operations added to the queue. The way to resume this queue is to set the isSuspended back to false:
Version ≥ 3.0

Suspending an OperationQueue does not stop or cancel operations that are already executing. One should only attempt suspending a queue that you created, not global queues or the main queue.
Section 32.5: Creating High-Level Operations
The Foundation framework provides the Operation type, which represents a high-level object that encapsulates a portion of work that may be executed on a queue. Not only does the queue coordinate the performance of those operations, but you can also establish dependencies between operations, create cancelable operations, constrain the degree of concurrency employed by the operation queue, etc.
Operations become ready to execute when all of its dependencies are finished executing. The isReady property then changes to true.
Create a simple non-concurrent Operation subclass:
Version ≥ 3.0

Version ≤ 2.3


Version ≥ 1.0

This will execute the operation concurrently on the queue.
Manage dependencies on an Operation.
Dependencies define other Operations that must execute on a queue before that Operation is considered ready to execute.
Version ≥ 1.0

Run an Operation without a queue:

Dependencies will be ignored. If this is a concurrent operation, the task may still be executed concurrently if its start method offloads work to background queues.
Concurrent Operations.
If the task that an Operation is to perform is, itself, asynchronous, (e.g. a URLSession data task), you should implement the Operation as a concurrent operation. In this case, your isAsynchronous implementation should return true, you'd generally have start method that performs some setup, then calls its main method which actually executes the task.
When implementing an asynchronous Operation begins you must implement isExecuting, isFinished methods and KVO. So, when execution starts, isExecuting property changes to true. When an Operation finishes its task, isExecuting is set to false, and isFinished is set to true. If the operation it is cancelled both isCancelled and isFinished change to true. All of these properties are key-value observable.
Cancel an Operation.
Calling cancel simply changes the isCancelled property to true. To respond to cancellation from within your own Operation subclass, you should check the value of isCancelled at least periodically within main and respond appropriately.

Chapter 33: Getting Started with Protocol Oriented Programming
Section 33.1: Using protocols as first class types
Protocol oriented programing can be used as a core Swift design pattern.
Different types are able to conform to the same protocol, value types can even conform to multiple protocols and even provide default method implementation.
Initially protocols are defined that can represent commonly used properties and/or methods with either specific or generic types.

A default implementation for the get method can be created, though if desired conforming types may override the implementation.


A value type that conforms to the ItemData protocol, this value type is also able to conform to other protocols.

Here the item struct is extended to conform to a display item.

An example call site for using the static get method.

Different use cases will require different implementations. The main idea here is to show conformance from varying types where the protocol is the main point of the focus in the design. In this example perhaps the API data is conditionally saved to a Core Data entity.

Here the Core Data backed class can also conform to the DisplayItem protocol.


Section 33.2: Leveraging Protocol Oriented Programming for Unit Testing
Protocol Oriented Programming is a useful tool in order to easily write better unit tests for our code.
Let's say we want to test a UIViewController that relies on a ViewModel class.
The needed steps on the production code are:
1. Define a protocol that exposes the public interface of the class ViewModel, with all the properties and methods needed by the UIViewController.
2. Implement the real ViewModel class, conforming to that protocol.
3. Use a dependency injection technique to let the view controller use the implementation we want, passing it as the protocol and not the concrete instance.

Then, on unit test:
1. Implement a mock ViewModel that conforms to the same protocol
2. Pass it to the UIViewController under test using dependency injection, instead of the real instance.
3. Test!

Chapter 34: Functional Programming in Swift
Section 34.1: Extracting a list of names from a list of Person(s)
Given a Person struct

Person(s)and an Array of 

we can retrieve an array of String containing the name property of each Person.

Section 34.2: Traversing

Section 34.3: Filtering
Create a stream by selecting the elements from a stream that pass a certain condition is called filtering


Section 34.4: Using Filter with Structs
Frequently you may want to filter structures and other complex data types. Searching an array of structs for entries that contain a particular value is a very common task, and easily achieved in Swift using functional programming features. What's more, the code is extremely succinct.

}
let painters = [
    Painter(firstName: "Claude", lastName: "Monet", type: .Impressionist),
    Painter(firstName: "Edgar", lastName: "Degas", type: .Impressionist),
    Painter(firstName: "Egon", lastName: "Schiele", type: .Expressionist),
    Painter(firstName: "George", lastName: "Grosz", type: .Expressionist),
    Painter(firstName: "Mark", lastName: "Rothko", type: .Abstract),
    Painter(firstName: "Jackson", lastName: "Pollock", type: .Abstract),
    Painter(firstName: "Pablo", lastName: "Picasso", type: .Surrealist),
    Painter(firstName: "Andy", lastName: "Warhol", type: .Pop)
]
// list the expressionists dump(painters.filter({$0.type == .Expressionist}))
// count the expressionists dump(painters.filter({$0.type == .Expressionist}).count)    // prints "2"
// combine filter and map for more complex operations, for example listing all // non-impressionist and non-expressionists by surname dump(painters.filter({$0.type != .Impressionist && $0.type != .Expressionist})
    .map({$0.lastName}).joinWithSeparator(", "))  
// prints "Rothko, Pollock, Picasso, Warhol"
Section 34.5: Projecting
Applying a function to a collection/stream and creating a new collection/stream is called a projection.



Chapter 35: Function as first class citizens in Swift
Functions as First-class members means, it can enjoy privileges just like Objects does. It can be assigned to a variable, passed on to a function as parameter or can be used as return type.
Section 35.1: Assigning function to a variable

Output:

Similarly the above could be achieved using a closure
// assigning the closure to a variable and then passing it to a function as param let add2 = {(item: Int)-> Int in return item + 2} print(math.performOperation(inputArray: arrayToBeProcessed, operation: add2))
Section 35.2: Passing function as an argument to another function, thus creating a Higher-Order Function

Output:

Similarly the above could be achieved using a closure
// passing the closure directly to the function as param
print(math.performOperation(inputArray: arrayToBeProcessed, operation: { $0 * 2 }))
Section 35.3: Function as return type from another function

Output:
9
Chapter 36: Blocks
From Swift Documentarion
A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter's type to indicate that the closure is allowed to escape.
Section 36.1: Non-escaping closure
In Swift 1 and 2, closure parameters were escaping by default. If you knew your closure wouldn't escape the function body, you could mark the parameter with the @noescape attribute.
In Swift 3, it's the other way around: closure parameters are non-escaping by default. If you intend for it to escape the function, you have to mark it with the @escaping attribute.

Section 36.2: Escaping closure


In the above example the completion block is saved to closure and will literally live beyond the function call. So complier will force to mark completion block as @escaping.

Chapter 37: The Defer Statement
Section 37.1: When to use a defer statement
A defer statement consists of a block of code, which will be executed when a function returns and should be used for cleanup.
As Swift's guard statements encourage a style of early return, many possible paths for a return may exist. A defer statement provides cleanup code, which then does not need to be repeated every time.
It can also save time during debugging and profiling, as memory leaks and unused open resources due to forgotten cleanup can be avoided.
It can be used to deallocate a buffer at the end of a function:

It can also be used to close resources at the end of a function:

Section 37.2: When NOT to use a defer statement
When using a defer-statement, make sure the code remains readable and the execution order remains clear. For example, the following use of the defer-statement makes the execution order and the function of the code hard to comprehend.

Chapter 38: Style Conventions
Section 38.1: Fluent Usage
Using natural language
Functions calls should be close to natural English language.
Example:

instead of

Naming Factory Methods
Factory methods should begin with the prefix `make`.
Example:

Naming Parameters in Initializers and Factory Methods
The name of the first argument should not be involved in naming a factory method or initializer.
Example:

Instead of:

Naming according to side effects
formFunctions with side effects (mutating functions) should be named using verbs or nouns prefixed with - . Functions without side effects (nonmutating functions) should be named using nouns or verbs with the suffix
ing or -ed-.
Example: Mutating functions:
print(value)
Nonmutating functions:
let sortedArray = array.sorted()     // out of place sorting
let union = set.union(anotherSet)    // union is now the union of set and another set
Boolean functions or variables
Statements involving booleans should read as assertions.
Example:

Naming Protocols
Protocols describing what something is should be named using nouns.
able, -ible or -ingProtocols describing capabilities should have - as suffix.
Example:
Collection        // describes that something is a collection
ProgressReporting // describes that something has the capability of reporting progress
Equatable         // describes that something has the capability of being equal to something
Types and Properties
Types, variables and properties should read as nouns.
Example:

Section 38.2: Clear Usage
Avoid Ambiguity
The name of classes, structures, functions and variables should avoid ambiguity.
Example:

The function call to this function will then look like this:

list.remove(42This way, ambiguity is avoided. If the function call would be just ) it would be unclear, if an Element equal to 42 would be removed or if the Element at Index 42 would be removed.
Avoid Redundancy
The name of functions should not contain redundant information.
A bad example would be:

list.removeElement(someObjectA call to the function may look like ). The variable someObject already indicates, that an Element is removed. It would be better for the function signature to look like this:

list.remove(someObjectThe call to this function looks like this: ).
Naming variables according to their role
Variables should be named by their role (e.g. supplier, greeting) instead of their type (e.g. factory, string, etc..)
High coupling between Protocol Name and Variable Names
If the name of the type describes its role in most cases (e.g. Iterator), the type should be named with the suffix `Type`. (e.g. IteratorType)
Provide additional details when using weakly typed parameters
If the type of an object does not indicate its usage in a function call clearly, the function should be named with a preceding noun for every weakly typed parameter, describing its usage. Example:

to which a call would look like `object.addObserver(self, forKeyPath: path) instead of

object.add(self, for: pathto which a call would look like )
Section 38.3: Capitalization
Types & Protocols
Type and protocol names should start with an uppercase letter.
Example:

Everything else...
Variables, constants, functions and enumeration cases should start with a lowercase letter.
Example:


Camel Case:
All naming should use the appropriate camel case. Upper camel case for type/protocol names and lower camel case for everything else.
Upper Camel Case:

Lower Camel Case: let inputView = ...
Abbreviations
Abbreviations should be avoided unless commonly used (e.g. URL, ID). If an abbreviation is used, all letters should have the same case.
Example:

Chapter 39: NSRegularExpression in Swift
Section 39.1: Extending String to do simple pattern matching

Below is another example which builds on the above to do something useful, which can't easily be done by any other method and lends itself well to a regex solution.


Section 39.2: Basic Usage
There are several considerations when implementing Regular Expressions in Swift.
let letters = "abcdefg" let pattern = "[a,b,c]" let regEx = try NSRegularExpression(pattern: pattern, options: []) let nsString = letters as NSString let matches = regEx.matches(in: letters, options: [], range: NSMakeRange(0, nsString.length)) let output = matches.map {nsString.substring(with: $0.range)} //output = ["a", "b", "c"]
In order to get an accurate range length that supports all character types the input string must be converted to a NSString.
For safety matching against a pattern should be enclosed in a do catch block to handle failure

Regular expression functionality is often put in an extension or helper to separate concerns.
Section 39.3: Replacing Substrings
Patterns can be used to replace part of an input string.
The example below replaces the cent symbol with the dollar symbol.


Section 39.4: Special Characters
\. becomes \\.To match special characters Double Backslash should be used 
Characters you'll have to escape include

The below example get three kinds of opening brackets

Section 39.5: Validation
Regular expressions can be used to validate inputs by counting the number of matches.

Section 39.6: NSRegularExpression for mail validation


or you could use String extension like this:


Chapter 40: RxSwift
Section 40.1: Disposing
After the subscription was created, it is important to manage its correct deallocation.
The docs told us that
If a sequence terminates in finite time, not calling dispose or not using addDisposableTo(disposeBag) won't cause any permanent resource leaks. However, those resources will be used until the sequence completes, either by finishing production of elements or returning an error.
There are two ways of deallocate resources.
1. Using disposeBags and addDisposableTo operator.
2. Using takeUntil operator.
In the first case you manually pass the subscription to the DisposeBag object, which correctly clears all taken memory.

You don't actually need to create DisposeBags in every class that you create, just take a look at RxSwift Community's project named NSObject+Rx. Using the framework the code above can be rewritten as follows:

takeUntil(rx_deallocatedIn the second case, if the subscription time coincides with the self object lifetime, it is possible to implement disposing using ):

Section 40.2: RxSwift basics
FRP, or Functional Reactive Programming, has some basic terms which you need to know.
Every piece of data can be represented as Observable, which is an asynchronous data stream. The power of FRP is in representation synchronous and asynchronous events as streams, Observables, and providing the same interface to work with it.
NextSuccess) or with an error (.ErrorUsually Observable holds several (or none) events that holds the date - . events, and then it can be terminated successfully (.).
Let's take a look at following marble diagram:

NextIn this example there is a stream of Int values. As time moves forward, three . events occurred, and then the stream terminated successfully.

ErrorThe diagram above shows a case where no data was emitted and . event terminates the Observable.
Before we move on, there are some useful resources:
1. RxSwift. Look at examples, read docs and getting started.
2. RxSwift Slack room has a few channels for education problem solving.
3. Play around with RxMarbles to know what operator does, and which is the most useful in your case.
4. Take a look on this example, explore the code by yourself.
  Section 40.3: Creating observables
RxSwift offers many ways to create an Observable, let's take a look:

So, the observables are created. They holds just one value and then terminates with success. Nevertheless, nothing happening after it was created. Why?
There are two steps in working with Observables: you observe something to create a stream and then you subscribe to the stream or bind it to something to interact with it.

The console will print:

NextAnd if I interested only in working with data, which take place in . events, I'd use subscribeNext operator:

If I want create an observable of many values, I use different operators:


Observable<SomeResultTypeAnd finally, maybe I want an Observable that does some work. For example, it is convenient to wrap a network operation into >. Let's take a look of do one can achieve this:
Observable.create { observer in    // create an Observable ...     MyNetworkService.doSomeWorkWithCompletion { (result, error) in         if let e = error {             observer.onError(e)    // ..that either holds an error         } else {             observer.onNext(result) // ..or emits the data             observer.onCompleted()  // ..and terminates successfully.
        }     }     return NopDisposable.instance // here you can manually free any resources                                 //in case if this observable is being disposed. }
Section 40.4: Bindings

"Greetings, \($0)"Using the combineLatest operator every time an item is emitted by either of two Observables, combine the latest item emitted by each Observable. So in this way we combine the result of the two UITextField's creating a new message with the text  using string interpolation to later bind to the text of a UILabel.
We can bind data to any UITableView and UICollectionView in an very easy way:

That's an Rx wrapper around the cellForRowAtIndexPath data source method. And also Rx takes care of the implementation of the numberOfRowsAtIndexPath, which is a required method in a traditional sense, but you don't have to implement it here, it's taken care of.
Section 40.5: RxCocoa and ControlEvents
RxSwift provides not only the ways to control your data, but to represent user actions in a reactive way also.
RxCocoa contains everything you need. It wraps most of the UI components' properties into Observables, but not really. There are some upgraded Observables called ControlEvents (which represent events) and ControlProperties (which represent properties, surprise!). These things holds Observable streams under the hood, but also have some nuances:
MainScheduler.instanceIt never fails, so no errors.
It will Complete sequence on control being deallocated.
It delivers events on the main thread ().
Basically, you can work with them as usual:

This is very important to use: as long as you use Rx, forget about the @IBAction stuff, everything you need you can bind and configure at once. For example, viewDidLoad method of your view controller is a good candidate to describe how the UI-components work.
Ok, another example: suppose we have a textfield, a button, and a label. We want to validate text in the textfield when we tap the button, and display the results in the label. Yep, seems like an another validate-email task, huh?
button.rx_tapFirst of all, we grab the  ControlEvent:

Here empty parenthesis show user taps. Next, we take what's written in the textField with withLatestFrom operator (take a look at it here, imagine that upper stream represents user taps, bottom one represents text in the text field).

Nice, we have a stream of strings to validate, emitted only when we need to validate.
Any Observable has such familiar operators as map or filter, we'll take map to validate the text. Create validateEmail function yourself, use any regex you want.
button.rx_tap                                // ControlEvent<Void>         .withLatestFrom(textField.rx_text)   // Observable<String>
        .map(validateEmail)                  // Observable<Bool>         .map { (isCorrect) in             return isCorrect ? "Email is correct" : "Input the correct one, please"         }                                    // Observable<String>
        .bindTo(label.rx_text)              
        .addDisposableTo(bag)
Done! If you need more custom logic (like showing error views in case of error, making a transition to another screen on success...), just subscribe to the final Bool stream and write it there.

Chapter 41: Swift Package Manager
Section 41.1: Creation and usage of a simple Swift package
To create a Swift Package, open a Terminal then create an empty folder:
mkdir AwesomeProject cd AwesomeProject
And init a Git repository: git init
Then create the package itself. One could create the package structure manually but there's a simple way using the CLI command.
If you want to make an executable: swift package init --type executable
Several files will be generated. Among them, main.swift will be the entry point for your application.
If you want to make a library: swift package init --type library
The generated AwesomeProject.swift file will be used as the main file for this library.
In both cases you can add other Swift files in the Sources folder (usual rules for access control apply).
The Package.swift file itself will be automatically populated with this content:

Versioning the package is done with Git tags: git tag '1.0.0'
Once pushed to a remote or local Git repository, your package will be available to other projects.
Your package is now ready to be compiled:
swift build
The compiled project will be available in the .build/debug folder.
Your own package can also resolve dependencies to other packages. For example, if you want to include "SomeOtherPackage" in your own project, change your Package.swift file to include the dependency:


Then build your project again: the Swift Package Manager will automatically resolve, download and build the dependencies.

Chapter 42: Working with C and ObjectiveC
Section 42.1: Use a module map to import C headers
import mymoduleA module map can simply  by configuring it to read C header files and make them appear as Swift functions.
module.modulemapPlace a file named  inside a directory named mymodule:

Inside the module map file:

Then import the module:

-I Use the ctory flag to tell swiftc where to find the module: swiftc -I . demo.swift   # "-I ." means "search for modules in the current directory"
For more information about the module map syntax, see the Clang documentation about module maps.
Section 42.2: Using Objective-C classes from Swift code
If MyFramework contains Objective-C classes in its public headers (and the umbrella header), then import MyFramework is all that's necessary to use them from Swift.
Bridging headers
A bridging header makes additional Objective-C and C declarations visible to Swift code. When adding project files, Xcode may offer to create a bridging header automatically:

To create one manually, modify the Objective-C Bridging Header build setting:

Inside the bridging header, import whichever files are necessary to use from code:

Generated Interface
Click the Related Items button (or press ⌃1), then select Generated Interface to see the Swift interface that will be generated from an Objective-C header.

Section 42.3: Specify a bridging header to swiftc
-import-objc-headerThe  flag specifies a header for swiftc to import:

$ swiftc demo.swift -import-objc-header defs.h && ./demo MAX_VALUE is: 255 The color is Color(red: 202, green:
202, blue: 208)
Section 42.4: Use the C standard library
Swift's C interoperability allows you to use functions and types from the C standard library.
On Linux, the C standard library is exposed via the Glibc module; on Apple platforms it's called Darwin.

Section 42.5: Fine-grained interoperation between ObjectiveC and Swift
When an API is marked with NS_REFINED_FOR_SWIFT, it will be prefixed with two underscores (__) when imported to Swift:

The generated interface looks like this:     public func
dexOfObject(obj: AnyObject) -> Int }
Now you can replace the API with a more "Swifty" extension. In this case, we can use an optional return value, filtering out NSNotFound:

xOfObject(obj: AnyObject) -> Int? { let idx = __indexOfObject(obj) if idx == NSNotFound { return nil } return idx } } // Swift code, using "if let" as it should be: let myobj = MyClass() if let idx = myobj.indexOfObject(something) { // do something with idx }
In most cases you might want to restrict whether or not an argument to an Objective-C function could be nil. This is done using _Nonnull keyword, which qualifies any pointer or block reference:

With that written, the compiler shall emit an error whenever we try to pass nil to that function from our Swift code:
doStuff(     nil,  // error: nil is not compatible with expected argument type 'UnsafeRawPointer'     nil)  // error: nil is not compatible with expected argument type '() -> Void'
The opposite of _Nonnull is _Nullable, which means that it is acceptable to pass nil in this argument. _Nullable is also the default; however, specifying it explicitly allows for more self-documented and future-proof code.
To further help the compiler with optimising your code, you also might want to specify if the block is escaping:

With this attribute we promise not to save the block reference and not to call the block after the function has finished execution.
Section 42.6: Using Swift classes from Objective-C code
In the same module
MyModule-Swift.Inside a module named "MyModule", Xcode generates a header named h which exposes public
Swift classes to Objective-C. Import this header in order to use the Swift classes:

ic class MySwiftClass: NSObject { // ... }
// MyViewController.m in MyApp
ort "MyApp-Swift.h" // import the generated interface #import <MyFramework/MyFramework-Swift.h> // or use angle brackets for a framework target @implementation MyViewController - (void)demo { [[MySwiftClass alloc] init]; // use the Swift class } @end
Relevant build settings:
Objective-C Generated Interface Header Name: controls the name of the generated Obj-C header. Install Objective-C Compatibility Header: whether the -Swift.h header should be a public header (for framework targets).

In another module
import MyFrameworkUsing @; imports the whole module, including Obj-C interfaces to Swift classes (if the aforementioned build setting is enabled).

Chapter 43: Documentation markup
Section 43.1: Class documentation
Here is a basic class documentation example:

Note that with Xcode 8, you can generate the documentation snippet with  command + option + / .
This will return:

Section 43.2: Documentation styles










Chapter 44: Typealias
Section 44.1: typealias for closures with parameters
typealias SuccessHandler = (NSURLSessionDataTask, AnyObject?) -> Void
var string = ""This code block creates a type alias named SuccessHandler, just in the same way  creates a variable with the name string.
Now whenever you use SuccessHandler, for example:

You are essentilly writing: func example(_ handler: (NSURLSessionDataTask, AnyObject?) -> Void) {}
Section 44.2: typealias for empty closures

This block creates a type alias that works as a Void to Void function (takes in no parameters and returns nothing).
Here is a usage example:

Section 44.3: typealias for other types

You can also use a type alias to give a type another name to make it easier to remember, or make your code more elegant. typealias for Tuples

And this can be used as:

Chapter 45: Dependency Injection
Section 45.1: Dependency Injection with View Controllers
Dependenct Injection Intro
An application is composed of many objects that collaborate with each other. Objects usually depend on other objects to perform some task. When an object is responsible for referencing its own dependencies it leads to a highly coupled, hard-to-test and hard-to-change code.
Dependency injection is a software design pattern that implements inversion of control for resolving dependencies. An injection is passing of dependency to a dependent object that would use it. This allows a separation of client's dependencies from the client's behaviour, which allows the application to be loosely coupled.
Not to be confused with the above definition - a dependency injection simply means giving an object its instance variables.
It's that simple, but it provides a lot of benefits:
easier to test your code (using automated tests like unit and UI tests) when used in tandem with protocol-oriented programming it makes it easy to change the implementation of a certain class - easier to refactor
it makes the code more modular and reusable
There are three most commonly used ways Dependency Injection (DI) can be implemented in an application:
1. Initializer injection
2. Property injection
3. Using third party DI frameworks (like Swinject, Cleanse, Dip or Typhoon)
There is an interesting article with links to more articles about Dependency Injection so check it out if you want to dig deeper into DI and Inversion of Control principle.
Let's show how to use DI with View Controllers - an every day task for an average iOS developer.
Example Without DI
We'll have two View Controllers: LoginViewController and TimelineViewController. LoginViewController is used to login and upon successful loign, it will switch to the TimelineViewController. Both view controllers are dependent on the FirebaseNetworkService.
LoginViewController

TimelineViewController


FirebaseNetworkService

This example is very simple, but let's assume you have 10 or 15 different view controller and some of them are also dependent on the FirebaseNetworkService. At some moment you want to change Firebase as your backend service with your company's in-house backend service. To do that you'll have to go through every view controller and change FirebaseNetworkService with CompanyNetworkService. And if some of the methods in the CompanyNetworkService have changed, you'll have a lot of work to do.
Unit and UI testing is not the scope of this example, but if you wanted to unit test view controllers with tightly coupled dependencies, you would have a really hard time doing so.
Let's rewrite this example and inject Network Service to our view controllers.
Example with Dependancy Injection
To make the best out of the Dependency Injection, let's define the functionality of the Network Service in a protocol. This way, view controllers dependent on a network service won't even have to know about the real implementation of it.

Add an implementation of the NetworkService protocol:

Let's change LoginViewController and TimelineViewController to use new NetworkService protocol instead of FirebaseNetworkService.
LoginViewController

TimelineViewController

Now, the question is: How do we inject the correct NetworkService implementation in the LoginViewController and TimelineViewController?
Since LoginViewController is the starting view controller and will show every time the application starts, we can inject all dependencies in the AppDelegate.
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions:
[UIApplicationLaunchOptionsKey: Any]?) -> Bool {
    // This logic will be different based on your project's structure or whether
    // you have a navigation controller or tab bar controller for your starting view controller     if let loginVC = window?.rootViewController as? LoginViewController {         loginVC.networkService = FirebaseNetworkServiceImpl()     }
    return true }
In the AppDelegate we are simply taking the reference to the first view controller (LoginViewController) and injecting the NetworkService implementation using the property injection method.
Now, the next task is to inject the NetworkService implementation in the TimelineViewController. The easiest way is to do that when LoginViewController is transitioning to the TimlineViewController.
We'll add the injection code in the prepareForSegue method in the LoginViewController (if you are using a different approach to navigate through view controllers, place the injection code there).
Our LoginViewController class looks like this now:

We are done and it's that easy.
Now imagine we want to switch our NetworkService implementation from Firebase to our custom company's backend implementation. All we would have to do is:
Add new NetworkService implementation class:

Switch the FirebaseNetworkServiceImpl with the new implementation in the AppDelegate:
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions:
[UIApplicationLaunchOptionsKey: Any]?) -> Bool {
        // This logic will be different based on your project's structure or whether
        // you have a navigation controller or tab bar controller for your starting view controller         if let loginVC = window?.rootViewController as? LoginViewController {             loginVC.networkService = CompanyNetworkServiceImpl()         }
        return true     }
That's it, we have switched the whole underlaying implementation of the NetworkService protocol without even touching LoginViewController or TimelineViewController.
As this is a simple example, you might not see all the benefits right now, but if you try to use DI in your projects, you'll see the benefits and will always use Dependency Injection.
Section 45.2: Dependency Injection Types
This example will demonstrate how to use Dependency Injection (DI) design pattern in Swift using these methods:
1. Initializer Injection (the proper term is Constructor Injection, but since Swift has initializers it's called initializer injection)
2. Property Injection

Initializer Dependency Injection
As the name says, all dependencies are injected through the class initializer. To inject dependencies through the initializer, we'll add the initializer to the Train class.
Train class now looks like this:


When we want to create an instance of the Train class we'll use initializer to inject a specific Engine implementation:

NOTE: The main advantage of the initializer injection versus the property injection is that we can set the variable as private variable or even make it a constant with the let keyword (as we did in our example). This way we can make sure that no one can access it or change it.
Properties Dependency Injection
DI using properties is even simpler that using an initializer. Let's inject a PassengerCar dependency to the train object we already created using the properties DI:

That's it. Our train's mainCar is now a PassengerCar instance.
Method Dependency Injection
This type of dependency injection is a little different that the previous two because it won't affect the whole object, but it will only inject a dependency to be used in the scope of one specific method. When a dependency is only used in a single method, it's usually not good to make the whole object dependent on it. Let's add a new method to the Train class:

Now, if we call the new Train's class method, we'll inject the TrainCar using the method dependency injection.

Chapter 46: Caching on disk space
Caching videos, images and audios using URLSession and FileManager
Section 46.1: Reading

Section 46.2: Saving
let url = "https://path-to-media" let request = URLRequest(url: url) let downloadTask = URLSession.shared.downloadTask(with: request) { (location, response, error) in   guard let location = location,         let response = response,         let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory,
.userDomainMask, true).first else {     return   }   let documentsDirectoryUrl = URL(fileURLWithPath: documentsPath)   let documentUrl = documentsDirectoryUrl.appendingPathComponent(response.suggestedFilename)   let _ = try? FileManager.default.moveItem(at: location, to: documentUrl)
  // documentUrl is the local URL which we just downloaded and saved to the FileManager
}.resume()
Chapter 47: Algorithms with Swift
Algorithms are a backbone to computing. Making a choice of which algorithm to use in which situation distinguishes an average from good programmer. With that in mind, here are definitions and code examples of some of the basic algorithms out there.
Section 47.1: Sorting
Bubble Sort
This is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed. Although the algorithm is simple, it is too slow and impractical for most problems. It has complexity of O(n2) but it is considered slower than insertion sort.

Insertion sort
Insertion sort is one of the more basic algorithms in computer science. The insertion sort ranks elements by iterating through a collection and positions elements based on their value. The set is divided into sorted and unsorted halves and repeats until all elements are sorted. Insertion sort has complexity of O(n2). You can put it in an extension, like in an example below, or you can create a method for it.


Selection sort
Selection sort is noted for its simplicity. It starts with the first element in the array, saving it's value as a minimum value (or maximum, depending on sorting order). It then itterates through the array, and replaces the min value with any other value lesser then min it finds on the way. That min value is then placed at the leftmost part of the array and the process is repeated, from the next index, until the end of the array. Selection sort has complexity of O(n2) but it is considered slower than it's counterpart - Selection sort.
func selectionSort() -> Array { //check for trivial case guard self.count > 1 else { return self }


Quick Sort - O(n log n) complexity time
Quicksort is one of the advanced algorithms. It features a time complexity of O(n log n) and applies a divide & conquer strategy. This combination results in advanced algorithmic performance. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.
The steps are:
Pick an element, called a pivot, from the array.
Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.
Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values. mutating func quickSort() -> Array {

Section 47.2: Insertion Sort
Insertion sort is one of the more basic algorithms in computer science. The insertion sort ranks elements by iterating through a collection and positions elements based on their value. The set is divided into sorted and unsorted halves and repeats until all elements are sorted. Insertion sort has complexity of O(n2). You can put it in an extension, like in an example below, or you can create a method for it.

Section 47.3: Selection sort
Selection sort is noted for its simplicity. It starts with the first element in the array, saving it's value as a minimum value (or maximum, depending on sorting order). It then itterates through the array, and replaces the min value with any other value lesser then min it finds on the way. That min value is then placed at the leftmost part of the array and the process is repeated, from the next index, until the end of the array. Selection sort has complexity of O(n2) but it is considered slower than it's counterpart - Selection sort.


Section 47.4: Asymptotic analysis
Since we have many different algorithms to choose from, when we want to sort an array, we need to know which one will do it's job. So we need some method of measuring algoritm's speed and reliability. That's where Asymptotic analysis kicks in. Asymptotic analysis is the process of describing the efficiency of algorithms as their input size (n) grows. In computer science, asymptotics are usually expressed in a common format known as Big O Notation.
 Linear time O(n): When each item in the array has to be evaluated in order for a function to achieve it's goal, that means that the function becomes less efficent as number of elements is increasing. A function like this is said to run in linear time because its speed is dependent on its input size.
 Polynominal time O(n2): If complexity of a function grows exponentialy (meaning that for n elements of an array complexity of a function is n squared) that function operates in polynominal time. These are usually functions with nested loops. Two nested loops result in O(n2) complexity, three nested loops result in O(n3) complexity, and so on...
     Logarithmic time O(log n): Logarithmic time functions's complexity is minimized when the size of its inputs (n) grows. These are the type of functions every programmer strives for.
  Section 47.5: Quick Sort - O(n log n) complexity time
Quicksort is one of the advanced algorithms. It features a time complexity of O(n log n) and applies a divide & conquer strategy. This combination results in advanced algorithmic performance. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.
The steps are:
1. Pick an element, called a pivot, from the array.
2. Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.
3. Recursively apply the above steps to the sub-array of elements with smaller values and separately to the subarray of elements with greater values.


} mutating func qPartition(start startIndex: Int, _ pivot: Int) -> Int {


Section 47.6: Graph, Trie, Stack
Graph
In computer science, a graph is an abstract data type that is meant to implement the undirected graph and directed graph concepts from mathematics. A graph data structure consists of a finite (and possibly mutable) set of vertices or nodes or points, together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges, arcs, or lines for an undirected graph and as arrows, directed edges, directed arcs, or directed lines for a directed graph. The vertices may be part of the graph structure, or may be external entities represented by integer indices or references. A graph data structure may also associate to each edge some edge value, such as a symbolic label or a numeric attribute (cost, capacity, length, etc.). (Wikipedia, source)


import Foundation
public class SwiftGraph {
   
   
    //declare a default directed graph canvas     private var canvas: Array<Vertex>     public var isDirected: Bool           init() {         canvas = Array<Vertex>()         isDirected = true     }
   
       //create a new vertex     func addVertex(key: String) -> Vertex {
       
               //set the key         let childVertex: Vertex = Vertex()         childVertex.key = key        
               //add the vertex to the graph canvas         canvas.append(childVertex)                       return childVertex     }
   
   
       //add edge to source vertex     func addEdge(source: Vertex, neighbor: Vertex, weight: Int) {
       
               //create a new edge         let newEdge = Edge()        
       
        //establish the default properties         newEdge.neighbor = neighbor         newEdge.weight = weight
        source.neighbors.append(newEdge)                       print("The neighbor of vertex: \(source.key as String!) is \(neighbor.key as String!)..")
       
       
        //check condition for an undirected graph         if isDirected == false {
           
                      //create a new reversed edge            let reverseEdge = Edge()            
                      //establish the reversed properties            reverseEdge.neighbor = source
           reverseEdge.weight = weight            neighbor.neighbors.append(reverseEdge)            
           print("The neighbor of vertex: \(neighbor.key as String!) is \(source.key as
String!)..")
           
        }
       
       
    }
   
   
   
   
    /* reverse the sequence of paths given the shortest path.        process analagous to reversing a linked list. */
    func reversePath(_ head: Path!, source: Vertex) -> Path! {
                      guard head != nil else {             return head         }
               //mutated copy         var output = head                       var current: Path! = output         var prev: Path!         var next: Path!                       while(current != nil) {             next = current.previous             current.previous = prev             prev = current             current = next         }
       
               //append the source path to the sequence         let sourcePath: Path = Path()                sourcePath.destination = source         sourcePath.previous = prev         sourcePath.total = nil                output = sourcePath                       return output        
    }
   
   
       //process Dijkstra's shortest path algorthim     func processDijkstra(_ source: Vertex, destination: Vertex) -> Path? {        
               var frontier: Array<Path> = Array<Path>()         var finalPaths: Array<Path> = Array<Path>()
       
       
        //use source edges to create the frontier         for e in source.neighbors {
                       let newPath: Path = Path()                                   newPath.destination = e.neighbor             newPath.previous = nil             newPath.total = e.weight            
           
            //add the new path to the frontier             frontier.append(newPath)
           
        }
       
        //construct the best path         var bestPath: Path = Path()                       while frontier.count != 0 {
                       //support path changes using the greedy approach             bestPath = Path()             var pathIndex: Int = 0
                       for x in 0..<frontier.count {
                               let itemPath: Path = frontier[x]
                               if  (bestPath.total == nil) || (itemPath.total < bestPath.total) {                     bestPath = itemPath                     pathIndex = x                 }
               
            }
           
           
                       //enumerate the bestPath edges             for e in bestPath.destination.neighbors {
                               let newPath: Path = Path()                                newPath.destination = e.neighbor                 newPath.previous = bestPath                 newPath.total = bestPath.total + e.weight                
               
                //add the new path to the frontier                 frontier.append(newPath)
               
            }
           
           
            //preserve the bestPath             finalPaths.append(bestPath)
           
           
            //remove the bestPath from the frontier             //frontier.removeAtIndex(pathIndex) - Swift2             frontier.remove(at: pathIndex)
           
           
           
        } //end while
       
       
           //establish the shortest path as an optional         var shortestPath: Path! = Path()                       for itemPath in finalPaths {
                       if (itemPath.destination.key == destination.key) {
                               if  (shortestPath.total == nil) || (itemPath.total < shortestPath.total) {                     shortestPath = itemPath                 }
               
            }
           
        }
                      return shortestPath        
    }
   
   
   
    ///an optimized version of Dijkstra's shortest path algorthim     func processDijkstraWithHeap(_ source: Vertex, destination: Vertex) -> Path! {
                      let frontier: PathHeap = PathHeap()         let finalPaths: PathHeap = PathHeap()
       
       
        //use source edges to create the frontier         for e in source.neighbors {
                       let newPath: Path = Path()                                   newPath.destination = e.neighbor             newPath.previous = nil             newPath.total = e.weight            
           
            //add the new path to the frontier             frontier.enQueue(newPath)
           
        }
       
       
        //construct the best path         var bestPath: Path = Path()                       while frontier.count != 0 {
                                   //use the greedy approach to obtain the best path             bestPath = Path()
            bestPath = frontier.peek()
           
                       //enumerate the bestPath edges             for e in bestPath.destination.neighbors {
                               let newPath: Path = Path()                                newPath.destination = e.neighbor                 newPath.previous = bestPath                 newPath.total = bestPath.total + e.weight                
               
                //add the new path to the frontier                 frontier.enQueue(newPath)
               
            }
           
                       //preserve the bestPaths that match destination             if (bestPath.destination.key == destination.key) {                 finalPaths.enQueue(bestPath)
            }
           
           
            //remove the bestPath from the frontier             frontier.deQueue()
           
           
        } //end while
       
       
       
        //obtain the shortest path from the heap         var shortestPath: Path! = Path()         shortestPath = finalPaths.peek()
                      return shortestPath        
    }
   
   
    //MARK: traversal algorithms
   
   
    //bfs traversal with inout closure function     func traverse(_ startingv: Vertex, formula: (_ node: inout Vertex) -> ()) {
               //establish a new queue         let graphQueue: Queue<Vertex> = Queue<Vertex>()        
       
        //queue a starting vertex         graphQueue.enQueue(startingv)                       while !graphQueue.isEmpty() {                        //traverse the next queued vertex             var vitem: Vertex = graphQueue.deQueue() as Vertex!            
                       //add unvisited vertices to the queue             for e in vitem.neighbors {                 if e.neighbor.visited == false {                     print("adding vertex: \(e.neighbor.key!) to queue..")                     graphQueue.enQueue(e.neighbor)                 }
            }
           
            /*             notes: this demonstrates how to invoke a closure with an inout parameter.             By passing by reference no return value is required.
            */
           
            //invoke formula             formula(&vitem)
           
           
        } //end while
                      print("graph traversal complete..")        
       
    }
   
   
   
    //breadth first search     func traverse(_ startingv: Vertex) {
       
               //establish a new queue         let graphQueue: Queue<Vertex> = Queue<Vertex>()        
               //queue a starting vertex         graphQueue.enQueue(startingv)                       while !graphQueue.isEmpty() {                        //traverse the next queued vertex             let vitem = graphQueue.deQueue() as Vertex!                        guard vitem != nil else {                 return             }
                       //add unvisited vertices to the queue             for e in vitem!.neighbors {
                if e.neighbor.visited == false {                     print("adding vertex: \(e.neighbor.key!) to queue..")                     graphQueue.enQueue(e.neighbor)                 }
            }
                                  vitem!.visited = true             print("traversed vertex: \(vitem!.key!)..")            
           
        } //end while
                      print("graph traversal complete..")        
       
    } //end function
   
   
   
    //use bfs with trailing closure to update all values
    func update(startingv: Vertex, formula:((Vertex) -> Bool)) {
       
               //establish a new queue         let graphQueue: Queue<Vertex> = Queue<Vertex>()        
               //queue a starting vertex         graphQueue.enQueue(startingv)                       while !graphQueue.isEmpty() {                        //traverse the next queued vertex             let vitem = graphQueue.deQueue() as Vertex!                                   guard vitem != nil else {                 return             }
                       //add unvisited vertices to the queue             for e in vitem!.neighbors {                 if e.neighbor.visited == false {                     print("adding vertex: \(e.neighbor.key!) to queue..")                     graphQueue.enQueue(e.neighbor)                 }
            }
           
           
            //apply formula..             if formula(vitem!) == false {                 print("formula unable to update: \(vitem!.key)")
            }             else {                 print("traversed vertex: \(vitem!.key!)..")             }                        vitem!.visited = true            
           
Trie
In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree (as they can be searched by prefixes), is a kind of search tree-an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. (Wikipedia, source)


           
                       //iterate through child nodes             for child in current.children {
                               if (child.key == searchKey) {                     childToUse = child                     break                 }
               
            }
           
                       //new node             if childToUse == nil {
                               childToUse = TrieNode()                 childToUse.key = searchKey                 childToUse.level = current.level + 1                 current.children.append(childToUse)             }
                                  current = childToUse            
           
        } //end while
       
       
        //final end of word check         if (keyword.length == current.level) {             current.isFinal = true             print("end of word reached!")             return         }
       
       
       
    } //end function
   
   
   
    //find words based on the prefix     func search(forWord keyword: String) -> Array<String>! {
       
               //trivial case         guard keyword.length > 0 else {             return nil         }
                      var current: TrieNode = root         var wordList = Array<String>()                       while keyword.length != current.level {                        var childToUse: TrieNode!
            let searchKey = keyword.substring(to: current.level + 1)
           
(GitHub, source)
Stack
In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the most recently added element that was not yet removed. The order in which elements come off a stack gives rise to its alternative name, LIFO (for last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.
(Wikipedia, source)
See license info below and original code source at (github)


The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Chapter 48: Swift Advance functions
Advance functions like map, flatMap, filter, and reduce are used to operate on various collection types like Array and Dictionary. Advance functions typically require little code and can be chained together in order to build up complex logic in a concise way.
Section 48.1: Flatten multidimensional array
To flatten multidimensional array into single dimension, flatMap advance functions is used. Other use case is to neglect nil value from array & mapping values. Let's check with example:
Suppose We have an multidimensional array of cities & we want to sorted city name list in ascending order. In that case we can use flatMap function like:
let arrStateName = [["Alaska", "Iowa", "Missouri", "New Mexico"], ["New York", "Texas", "Washington", "Maryland"], ["New Jersey", "Virginia", "Florida", "Colorado"]]
Preparing a single dimensional list from multidimensional array,
let arrFlatStateList = arrStateName.flatMap({ $0 }) // ["Alaska", "Iowa", "Missouri", "New Mexico",
"New York", "Texas", "Washington", "Maryland", "New Jersey", "Virginia", "Florida", "Colorado"]
For sorting array values, we can use chaining operation or sort flatten array. Here below example showing chaining operation,
// Swift 2.3 syntax let arrSortedStateList = arrStateName.flatMap({ $0 }).sort(<) // ["Alaska",     "Colorado", "Florida", "Iowa", "Maryland", "Missouri", "New Jersey", "New Mexico", "New York", "Texas",
"Virginia", "Washington"]
// Swift 3 syntax let arrSortedStateList = arrStateName.flatMap({ $0 }).sorted(by: <) // ["Alaska", "Colorado",
"Florida", "Iowa", "Maryland", "Missouri", "New Jersey", "New Mexico", "New York", "Texas",
"Virginia", "Washington"]
Section 48.2: Introduction with advance functions
Let's take an scenario to understand advance function in better way,

let arrUser = [user1, user2, user3, user4, user5, user6, user7]
Map Function:
Use map to loop over a collection and apply the same operation to each element in the collection. The map function returns an array containing the results of applying a mapping or transform function to each item.

Flat-Map Function:
The simplest use is as the name suggests to flatten a collection of collections.
// Fetch all user country name & ignore nil value. let arrCountry = arrUser.flatMap({ $0.country }) // ["USA", "UK", "USA", "USA"]
Filter Function:
Use filter to loop over a collection and return an Array containing only those elements that match an include condition.
// Filtering USA user from the array user list. let arrUSAUsers = arrUser.filter({ $0.country == "USA" }) // [user1, user5, user6]
// User chaining methods to fetch user's name who live in USA let arrUserList = arrUser.filter({ $0.country == "USA" }).map({ $0.name }) // ["John", "Katie", "David"]
Reduce:
Use reduce to combine all items in a collection to create a single new value.
Swift 2.3:
//Fetch user's total age. let arrUserAge = arrUser.map({ $0.age }).reduce(0, combine: { $0 + $1 }) //174
//Prepare all user name string with separated by comma
let strUserName = arrUserName.reduce("", combine: { $0 == "" ? $1 : $0 + ", " + $1 }) // John, Chan, Morgan, Rachel, Katie, David, Bob
Swift 3:
//Fetch user's total age. let arrUserAge = arrUser.map({ $0.age }).reduce(0, { $0 + $1 }) //174
//Prepare all user name string with separated by comma
let strUserName = arrUserName.reduce("", { $0 == "" ? $1 : $0 + ", " + $1 }) // John, Chan, Morgan,
Rachel, Katie, David, Bob
Chapter 49: Completion Handler
Virtually all apps are using asynchronous functions to keep the code from blocking the main thread.
Section 49.1: Completion handler with no input argument

Section 49.2: Completion handler with input argument



Chapter 50: Swift HTTP server by Kitura
Swift server with Kitura
Kitura is a web framework written in swift that is created for web services. It's very easy to set up for HTTP requests. For environment, it needs either OS X with XCode installed, or Linux running swift 3.0.
Section 50.1: Hello world application
Configuration
First, create a file called Package.swift. This is the file that tells swift compiler where the libraries are located. In this hello world example, we are using GitHub repos. We need Kitura and HeliumLogger. Put the following code inside Package.swift. It specified the name of the project as kitura-helloworld and also the dependency urls.

Next, create a folder called Sources. Inside, create a file called main.swift. This is the file that we implement all the logic for this application. Enter the following code into this main file.
Import libraries and enable logging

Adding a router. Router specifies a path, type, etc of the HTTP request. Here we are adding a GET request handler which prints Hello world, and then a post request that reads plain text from the request and then send it back.


Specify a port to run the service

Bind the router and port together and add them as HTTP service

Execute
Navigate to the root folder with Package.swift file and Resources folder. Run the following command. Swift compiler will automatically download the mentioned resources in Package.swift into Packages folder, and then compile these resources with main.swift

When the build is finished, executable will be placed at this location. Double click this executable to start the server.

Validate
localhost:8080/getOpen a browser, type in  as url and hit enter. The hello world page should come out.

localhost:8080/postOpen a HTTP request app, post plain text to . The respond string will show the entered text correctly.

Chapter 51: Generate UIImage of Initials from String
This is a class that will generate a UIImage of a person's initials. Harry Potter would generate an image of HP.
Section 51.1: InitialsImageFactory

Chapter 52: Design Patterns - Creational
Design patterns are general solutions to problems that frequently occur in software development. The following are templates of standardized best practices in structuring and designing code, as well as examples of common contexts in which these design patterns would be appropriate.
Creational design patterns abstract the instantiation of objects to make a system more independent of the process of creation, composition, and representation.
Section 52.1: Singleton
Singletons are a frequently used design pattern which consists of a single instance of a class that is shared throughout a program.
In the following example, we create a static property that holds an instance of the Foo class. Remember that a static property is shared between all objects of a class and can't be overwritten by subclassing.

Usage:

Be sure to remember the private initializer:
This makes sure your singletons are truly unique and prevents outside objects from creating their own instances of your class through virtue of access control. Since all objects come with a default public initializer in Swift, you need to override your init and make it private. KrakenDev
Section 52.2: Builder Pattern
The builder pattern is an object creation software design pattern. Unlike the abstract factory pattern and the factory method pattern whose intention is to enable polymorphism, the intention of the builder pattern is to find a solution to the telescoping constructor anti-pattern. The telescoping constructor antipattern occurs when the increase of object constructor parameter combination leads to an exponential list of constructors. Instead of using numerous constructors, the builder pattern uses another object, a builder, that receives each initialization parameter step by step and then returns the resulting constructed object at once.
-Wikipedia
The main goal of the builder pattern is to setup a default configuration for an object from its creation. It is an intermediary between the object will be built and all other objects related to building it.
Example:
To make it more clear, let's take a look at a Car Builder example.
Consider that we have a Car class contains many options to create an object, such as:


Creating a car object:

The problem arises when creating a car object is that the car requires many configuration data to be created.
For applying the Builder Pattern, the initializer parameters should have default values which are changeable if needed.
CarBuilder class:

The CarBuilder class defines properties that could be changed to to edit the values of the created car object.
Let's build new cars by using the CarBuilder:


The benefit of applying the Builder Pattern is the ease of creating objects that should contain much of configurations by setting default values, also, the ease of changing these default values.
Take it Further:
As a good practice, all properties that need default values should be in a separated protocol, which should be implemented by the class itself and its builder.
Backing to our example, let's create a new protocol called CarBluePrint:


    case        manual,     automatic }
struct Motor {     var id: String     var name: String     var model: String     var numberOfCylinders: UInt8
}
protocol CarBluePrint {     var color: UIColor { get set }     var numberOfSeats: UInt8 { get set }     var numberOfWheels: UInt8 { get set }     var type: CarType { get set }     var gearType: GearType { get set }     var motor: Motor { get set }
    var shouldHasAirbags: Bool { get set } }
class Car: CustomStringConvertible, CarBluePrint {     var color: UIColor     var numberOfSeats: UInt8     var numberOfWheels: UInt8     var type: CarType     var gearType: GearType     var motor: Motor
    var shouldHasAirbags: Bool        var description: String {         return "color: \(color)\nNumber of seats: \(numberOfSeats)\nNumber of Wheels:
\(numberOfWheels)\n Type: \(gearType)\nMotor: \(motor)\nAirbag Availability: \(shouldHasAirbags)"
    }        init(color: UIColor, numberOfSeats: UInt8, numberOfWheels: UInt8, type: CarType, gearType:
GearType, motor: Motor, shouldHasAirbags: Bool) {                self.color = color         self.numberOfSeats = numberOfSeats         self.numberOfWheels = numberOfWheels         self.type = type         self.gearType = gearType         self.motor = motor         self.shouldHasAirbags = shouldHasAirbags
       
    } }
class CarBuilder: CarBluePrint {     var color: UIColor = UIColor.black     var numberOfSeats: UInt8 = 5     var numberOfWheels: UInt8 = 4     var type: CarType = .saloon     var gearType: GearType = .automatic     var motor: Motor = Motor(id: "111", name: "Default Motor",                              model: "T9", numberOfCylinders: 4)     var shouldHasAirbags: Bool = false
       func buildCar() -> Car {        return Car(color: color, numberOfSeats: numberOfSeats, numberOfWheels: numberOfWheels, type: type, gearType: gearType, motor: motor, shouldHasAirbags: shouldHasAirbags)     }
}
The benefit of declaring the properties that need default value into a protocol is the forcing to implement any new added property; When a class conforms to a protocol, it has to declare all its properties/methods.
Consider that there is a required new feature that should be added to the blueprint of creating a car called "battery name":

After adding the new property, note that two compile-time errors will arise, notifying that conforming to
CarBluePrint protocol requires to declare 'batteryName' property. That guarantees that CarBuilder will declare and set a default value for batteryName property.
After adding batteryName new property to CarBluePrint protocol, the implementation of both Car and CarBuilder classes should be:



Section 52.3: Factory Method


senderBy doing that we don't depend on the real implementation of the class, making the () completely transparent to who is consuming it.
sendIn this case all we need to know is that a sender will handle the deliver and exposes a method called (). There are several other advantages: reduce classes coupling, easier to test, easier to add new behaviours without having to change who is consuming it.
Within object-oriented design, interfaces provide layers of abstraction that facilitate conceptual explanation of the code and create a barrier preventing dependencies.Wikipedia reference
Section 52.4: Observer
The observer pattern is where an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It is mainly used to implement distributed event handling systems. The Observer pattern is also a key part in the familiar model-view-controller (MVC) architectural pattern.Wikipedia reference
Basically the observer pattern is used when you have an object which can notify observers of certain behaviors or state changes.
First lets create a global reference (outside of a class) for the Notification Centre :

Great now we can call this from anywhere. We would then want to register a class as an observer...

This adds the class as an observer for "readForMyFunc". It also indicates that the function myFunc should be called when that notification is received. This function should be written in the same class:

The notification can now simply be sent(or posted if you prefer) from almost anywhere in the code with the line:

func myFunc(_ notification: Notification){     let userInfo = (notification as NSNotification).userInfo as! [String: AnyObject]     let passedInfo = userInfo["moreInfo"]     print("The notification \(moreInfo) has been received")     //prints - The notification pass this on has been received }
Section 52.5: Chain of responsibility
In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain. Wikipedia
Setting up the classes that made up the chain of responsibility.
First we create an interface for all the processing objects.


Finally, creating objects that made up the chain of responsibility.

Initiate and chaining it together :

manager.process(request: PurchaseRequest(amount: 2, purpose: "buying a pen"))  // Manager will approve $ 2.0 for buying a pen manager.process(request: PurchaseRequest(amount: 90, purpose: "buying a printer")) // Director will approve $ 90.0 for buying a printer
manager.process(request: PurchaseRequest(amount: 2000, purpose: "invest in stock")) // President will approve $ 2000.0 for invest in stock
Section 52.6: Iterator


Chapter 53: Design Patterns - Structural
Design patterns are general solutions to problems that frequently occur in software development. The following are templates of standardized best practices in structuring and designing code, as well as examples of common contexts in which these design patterns would be appropriate.
Structural design patterns focus on the composition of classes and objects to create interfaces and achieve greater functionality.
Section 53.1: Adapter
Adapters are used to convert the interface of a given class, known as an Adaptee, into another interface, called the Target. Operations on the Target are called by a Client, and those operations are adapted by the Adapter and passed on to the Adaptee.
In Swift, Adapters can often be formed through the use of protocols. In the following example, a Client able to communicate with the Target is provided with the ability to perform functions of the Adaptee class through the use of an adapter.

Client -> Target -> Adapter -> AdapteeExample flow of a one-way adapter: 
Adapters can also be bi-directional, and these are known as two-way adapters. A two-way adapter may be useful when two different clients need to view an object differently.
Section 53.2: Facade
A Facade provides a unified, high-level interface to subsystem interfaces. This allows for simpler, safer access to the more general facilities of a subsystem.
The following is an example of a Facade used to set and retrieve objects in UserDefaults.


Usage might look like the following.

The complexities of accessing the shared instance and synchronizing UserDefaults are hidden from the client, and this interface can be accessed from anywhere in the program.

Chapter 54: (Unsafe) Buer Pointers
"A buffer pointer is used for low-level access to a region of memory. For example, you can use a buffer pointer for efficent processing and communication of data between apps and services."
Excerpt From: Apple Inc. "Using Swift with Cocoa and Objective-C (Swift 3.1 Edition)." iBooks. https://itun.es/us/utTW7.l
You are responsible for handling the life cycle of any memory you work with through buffer pointers, to avoid leaks or undefined behavior.
Section 54.1: UnsafeMutablePointer

You use instances of the UnsafeMutablePointer type to access data of a specific type in memory. The type of data that a pointer can access is the pointer's Pointee type. UnsafeMutablePointer provides no automated memory management or alignment guarantees. You are responsible for handling the life cycle of any memory you work with through unsafe pointers to avoid leaks or undefined behavior.
Memory that you manually manage can be either untyped or bound to a specific type. You use the
UnsafeMutablePointer type to access and manage memory that has been bound to a specific type. (Source)


Converted to Swift 3.0 from original source
Section 54.2: Practical Use-Case for Buer Pointers
Deconstructing the use of an unsafe pointer in the Swift library method;

Purpose:
Creates a new string by copying and validating the null-terminated UTF-8 data referenced by the given pointer.
This initializer does not try to repair ill-formed UTF-8 code unit sequences. If any are found, the result of the initializer is nil. The following example calls this initializer with pointers to the contents of two different CChar arrays---the first with well-formed UTF-8 code unit sequences and the second with an ill-formed sequence at the end.

Chapter 55: Cryptographic Hashing
Section 55.1: HMAC with MD5, SHA1, SHA224, SHA256, SHA384, SHA512 (Swift 3)
		These functions will hash either String or Data input with one of eight cryptographic hash algorithms.
The name parameter specifies the hash function name as a String Supported functions are MD5, SHA1, SHA224,
SHA256, SHA384 and SHA512
This example requires Common Crypto
It is necessary to have a bridging header to the project:
#import <CommonCrypto/CommonCrypto.h>
Add the Security.framework to the project.
These functions takes a hash name, message to be hashed, a key and return a digest:
hashName: name of a hash function as String message: message as Data key: key as Data returns: digest as Data
func hmac(hashName:String, message:Data, key:Data) -> Data? {     let algos = ["SHA1":   (kCCHmacAlgSHA1,   CC_SHA1_DIGEST_LENGTH),                  "MD5":    (kCCHmacAlgMD5,    CC_MD5_DIGEST_LENGTH),
                 "SHA224": (kCCHmacAlgSHA224, CC_SHA224_DIGEST_LENGTH),
                 "SHA256": (kCCHmacAlgSHA256, CC_SHA256_DIGEST_LENGTH),
                 "SHA384": (kCCHmacAlgSHA384, CC_SHA384_DIGEST_LENGTH),                  "SHA512": (kCCHmacAlgSHA512, CC_SHA512_DIGEST_LENGTH)]     guard let (hashAlgorithm, length) = algos[hashName]  else { return nil }     var macData = Data(count: Int(length))
    macData.withUnsafeMutableBytes {macBytes in         message.withUnsafeBytes {messageBytes in             key.withUnsafeBytes {keyBytes in
                CCHmac(CCHmacAlgorithm(hashAlgorithm),                        keyBytes,     key.count,                        messageBytes, message.count,                        macBytes)             }
        }     }     return macData }
hashName: name of a hash function as String message: message as String key: key as String returns: digest as Data func hmac(hashName:String, message:String, key:String) -> Data? {
hashName: name of a hash function as String message: message as String key: key as Data returns: digest as Data func hmac(hashName:String, message:String, key:Data) -> Data? { // Examples

Output:

Section 55.2: MD2, MD4, MD5, SHA1, SHA224, SHA256, SHA384, SHA512 (Swift 3)
		These functions will hash either String or Data input with one of eight cryptographic hash algorithms.
The name parameter specifies the hash function name as a String
Supported functions are MD2, MD4, MD5, SHA1, SHA224, SHA256, SHA384 and SHA512
This example requires Common Crypto
It is necessary to have a bridging header to the project:
#import <CommonCrypto/CommonCrypto.h> Add the Security.framework to the project.
This function takes a hash name and Data to be hashed and returns a Data:
name: A name of a hash function as a String data: The Data to be hashed returns: the hashed result as Data
func hash(name:String, data:Data) -> Data? {     let algos = ["MD2":    (CC_MD2,    CC_MD2_DIGEST_LENGTH),                  "MD4":    (CC_MD4,    CC_MD4_DIGEST_LENGTH),
                 "MD5":    (CC_MD5,    CC_MD5_DIGEST_LENGTH),
                 "SHA1":   (CC_SHA1,   CC_SHA1_DIGEST_LENGTH),
                 "SHA224": (CC_SHA224, CC_SHA224_DIGEST_LENGTH),
                 "SHA256": (CC_SHA256, CC_SHA256_DIGEST_LENGTH),
                 "SHA384": (CC_SHA384, CC_SHA384_DIGEST_LENGTH),

This function takes a hash name and String to be hashed and returns a Data: name: A name of a hash function as a String string: The String to be hashed returns: the hashed result as Data

Examples:

Output:

Chapter 56: AES encryption
Section 56.1: AES encryption in CBC mode with a random IV (Swift 3.0)
The iv is prefixed to the encrypted data
aesCBC128Encrypt will create a random IV and prefixed to the encrypted code. aesCBC128Decrypt will use the prefixed IV during decryption.
Inputs are the data and key are Data objects. If an encoded form such as Base64 if required convert to and/or from in the calling method.
The key should be exactly 128-bits (16-bytes), 192-bits (24-bytes) or 256-bits (32-bytes) in length. If another key size is used an error will be thrown.
PKCS#7 padding is set by default.
This example requires Common Crypto
It is necessary to have a bridging header to the project:
#import <CommonCrypto/CommonCrypto.h>
Security.frameworkAdd the  to the project.
This is example, not production code.


Example usage:

Example Output:

Notes:
One typical problem with CBC mode example code is that it leaves the creation and sharing of the random IV to the user. This example includes generation of the IV, prefixed the encrypted data and uses the prefixed IV during decryption. This frees the casual user from the details that are necessary for CBC mode.
For security the encrypted data also should have authentication, this example code does not provide that in order to be small and allow better interoperability for other platforms.
Also missing is key derivation of the key from a password, it is suggested that PBKDF2 be used is text passwords are used as keying material.
For robust production ready multi-platform encryption code see RNCryptor.
		Updated to use throw/catch and multiple key sizes based on the provided key.
Section 56.2: AES encryption in CBC mode with a random IV (Swift 2.3)
The iv is prefixed to the encrypted data
aesCBC128Encrypt will create a random IV and prefixed to the encrypted code. aesCBC128Decrypt will use the prefixed IV during decryption.
Inputs are the data and key are Data objects. If an encoded form such as Base64 if required convert to and/or from in the calling method.
The key should be exactly 128-bits (16-bytes). For other key sizes see the Swift 3.0 example.
PKCS#7 padding is set by default.
This example requires Common Crypto It is necessary to have a bridging header to the project: #import <CommonCrypto/CommonCrypto.h> Add the Security.framework to the project.
See Swift 3 example for notes.
This is example, not production code.


Example usage:

Example Output:

Section 56.3: AES encryption in ECB mode with PKCS7 padding



Chapter 57: PBKDF2 Key Derivation
Section 57.1: Password Based Key Derivation 2 (Swift 3)
Password Based Key Derivation can be used both for deriving an encryption key from password text and saving a password for authentication purposes.
There are several hash algorithms that can be used including SHA1, SHA256, SHA512 which are provided by this example code.
The rounds parameter is used to make the calculation slow so that an attacker will have to spend substantial time on each attempt. Typical delay values fall in the 100ms to 500ms, shorter values can be used if there is unacceptable performance.
This example requires Common Crypto
It is necessary to have a bridging header to the project:
#import <CommonCrypto/CommonCrypto.h>
Security.frameworkAdd the  to the project.
Parameters:


Example usage:
let password     = "password"
//let salt       = "saltData".data(using: String.Encoding.utf8)! let salt         = Data(bytes: [0x73, 0x61, 0x6c, 0x74, 0x44, 0x61, 0x74, 0x61]) let keyByteCount = 16 let rounds       = 100000
 let derivedKey = pbkdf2SHA1(password:password, salt:salt, keyByteCount:keyByteCount, rounds:rounds) print("derivedKey (SHA1): \(derivedKey! as NSData)") Example Output:

Section 57.2: Password Based Key Derivation 2 (Swift 2.3)
See Swift 3 example for usage information and notes


Example usage:

Example Output:

Section 57.3: Password Based Key Derivation Calibration (Swift 2.3)
See Swift 3 example for usage information and notes

Example usage:

Example Output:
		For 100 msec delay, rounds: 94339
Section 57.4: Password Based Key Derivation Calibration (Swift 3)
Determine the number of PRF rounds to use for a specific delay on the current platform.
Several parameters are defaulted to representative values that should not materially affect the round count.

Example usage:
let saltData       = Data(bytes: [0x73, 0x61, 0x6c, 0x74, 0x44, 0x61, 0x74, 0x61]) let passwordString = "password" let delayMsec      = 100
let rounds = pbkdf2SHA1Calibrate(password:passwordString, salt:saltData, msec:delayMsec) print("For \(delayMsec) msec delay, rounds: \(rounds)")
Example Output:

Chapter 58: Logging in Swift
Section 58.1: dump
dump prints the contents of an object via reflection (mirroring).
Detailed view of an array:

Prints:
▿ 4 elements
  - [0]: Joe
  - [1]: Jane
  - [2]: Jim
  - [3]: JoyceFor a dictionary:

Prints:
▿ 3 key/value pairs
▿ [0]: (2 elements)
  - .0: bar
  - .1: 33
▿ [1]: (2 elements)
  - .0: baz
  - .1: 42
▿ [2]: (2 elements)
  - .0: foo
  - .1: 10
dump(_:name:indent:maxDepth:maxItemsdump is declared as :).
The first parameter has no label.
There's other parameters available, like name to set a label for the object being inspected:

Prints:
▿ mirroring: 3 key/value pairs
▿ [0]: (2 elements)
  - .0: bar
  - .1: 33
▿ [1]: (2 elements)
  - .0: baz
  - .1: 42
▿ [2]: (2 elements)
  - .0: foo
  - .1: 10
maxItemsmaxDepth:, and to change the indentation of printed objects with indentYou can also choose to print only a certain number of items with :, to parse the object up to a certain depth with :.
Section 58.2: Debug Print
Debug Print shows the instance representation that is most suitable for debugging.

Yields

This extra information can be very important, for example:

Yields

Notice how in the first output it appears that there are 4 elements in the array as opposed to 3. For reasons like this, it is preferable when debugging to use debugPrint
Updating a classes debug and print values


Section 58.3: print() vs dump()
printMany of us start debugging with simple (). Let's say we have such a class:

and we have an instance of Abc as so:

printWhen we run the () on the variable, the output is

dumpwhile () outputs

dump() outputs the whole class hierarchy, while printAs seen, () simply outputs the class name.
dumpTherefore, () is especially useful for UI debugging
let view = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 100))
dump(viewWith ) we get:

print(viewWhile ) we get:
<UIView: 0x108a0cde0; frame = (0 0; 100 100); layer = <CALayer: 0x159340cb0>>
dumpThere is more info on the class with (), and so it is more useful in debugging the class itself.
Section 58.4: print vs NSLog
print() and NSLogIn swift we can use both () functions to print something on Xcode console.
print() and NSLogBut there are lot of differences in () functions, such as:
NSLog() will print timestamp along with the string we passed to it, but print1 TimeStamp: () will not print timestamp.
e.g.

Output:
[1, 2, 3, 4, 5]
2017-05-31 13:14:38.582 ProjetName[2286:7473287] [1, 2, 3, 4, 5]
It'll also print ProjectName along with timestamp.
NSLog() only takes String as an input, but print2 Only String: () can print any type of input passed to it. e.g.
let array = [1, 2, 3, 4, 5]
print(array) //prints [1, 2, 3, 4, 5]
NSLog(array) //error: Cannot convert value of type [Int] to expected argument type 'String'
NSLog() function is very slow compare to print3 Performance: () function.
NSLogprint4 Synchronization: () handles simultaneous usage from multi-threading environment and prints output without overlapping it. But () will not handle such cases and jumbles while prating output.
NSLogprint5 Device Console: () outputs on device console also, we can see this output by connecting our device to Xcode. () will not print output to device's console.

Chapter 59: Memory Management
This topic outlines how and when the Swift runtime shall allocate memory for application data structures, and when that memory shall be reclaimed. By default, the memory backing class instances is managed through reference counting. The structures are always passed through copying. To opt out of the built-in memory management scheme, one could use [Unmanaged][1] structure. [1]: https://developer.apple.com/reference/swift/unmanaged
Section 59.1: Reference Cycles and Weak References
A reference cycle (or retain cycle) is so named because it indicates a cycle in the object graph:

Each arrow indicates one object retaining another (a strong reference). Unless the cycle is broken, the memory for these objects will never be freed.
A retain cycle is created when two instances of classes reference each other:

Both instances they will live on until the program terminates. This is a retain cycle. Weak References
To avoid retain cycles, use the keyword weak or unowned when creating references to break retain cycles.
class B { var a: A? = nil }
Weak or unowned references will not increase the reference count of an instance. These references don't contribute to retain cycles. The weak reference becomes nil when the object it references is deallocated.

When working with closures, you can also use weak and unowned in capture lists.
Section 59.2: Manual Memory Management
When interfacing with C APIs, one might want to back off Swift reference counter. Doing so is achieved with unmanaged objects.
If you need to supply a type-punned pointer to a C function, use toOpaque method of the Unmanaged structure to obtain a raw pointer, and fromOpaque to recover the original instance:

Note that, if using passUnretained and counterparts, it's necessary to take all precautions as with unowned references.
To interact with legacy Objective-C APIs, one might want to manually affect reference count of a certain object. For that Unmanaged has respective methods retain and release. Nonetheless, it is more desired to use passRetained and takeRetainedValue, which perform retaining before returning the result:

These solutions should always be the last resort, and language-native APIs sould always be preferred.
Chapter 60: Performance
Section 60.1: Allocation Performance
In Swift, memory management is done for you automatically using Automatic Reference Counting. (See Memory Management) Allocation is the process of reserving a spot in memory for an object, and in Swift understanding the performance of such requires some understanding of the heap and the stack. The heap is a memory location where most objects get placed, and you may think of it as a storage shed. The stack, on the other hand, is a call stack of functions that have led to the current execution. (Hence, a stack trace is a sort of printout of the functions on the call stack.)
Allocating and deallocating from the stack is a very efficient operation, however in comparison heap allocation is costly. When designing for performance, you should keep this in mind.
Classes:

Classes in Swift are reference types and therefore several things happen. First, the actual object will be allocated onto the heap. Then, any references to that object must be added to the stack. This makes classes a more expensive object for allocation.
Structs:

Because structs are value types and therefore copied when passed around, they are allocated on the stack. This makes structs more efficient than classes, however, if you do need a notion of identity and/or reference semantics, a struct cannot provide you with those things.
Warning about structs with Strings and properties that are classes
While structs are generally cheeper than classes, you should be careful about structs with properties that are classes:

Here, due to reference counting and other factors, the performance is now more similar to a class. Further, if more than one property in the struct is a class, the performance impact may be even more negative than if the struct were a class instead.
Also, while Strings are structs, they internally store their characters on the heap, so are more expensive than most structs.

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
4444Chapter 23Abdul YasinChapter 43Accepted AnswerChapters 7, 17, 42 and 59Adam BardonChapter 58Adda_25Chapter 32Ahmad FChapter 52Ajith R NayakChapter 18AjwhitewayChapter 12AK1Chapters 9, 12 and 14AlessandroChapter 23Alessandro OrrùChapter 33Alex PopovChapter 8Alexander OlferukChapter 40AMAN77Chapter 52Anand NimjeChapter 21Andrea AntonioniChapter 4AndreasChapter 5Andrey GordeevChapter 22Andy IbanezChapter 18andyvn22Chapter 21antonio081014Chapter 4AsdrubalChapters 27 and 28AstroCBChapter 4atxeChapter 14AviChapter 8avismaraChapter 25AxeChapter 4Bartłomiej SemańczykChapter 44Ben TrengroveChapter 6brducaChapters 14, 19, 30 and 52Caleb KleveterChapters 4, 7, 13, 16, 18 and 44Christopher OezbekChapter 2Cory WilhiteChapter 17ctietzeChapter 29Cyril Ivar GarciaChapter 24D31Chapter 16D4ttatrayaChapters 6, 44 and 58Dalija PrasnikarChapters 10 and 17DanHabibChapter 58DarkDustChapters 6, 14 and 22DavidChapter 19Diogo AntunesChapters 8, 9 and 11Duncan CChapters 12 and 29EchelonChapters 34 and 39egor.zhdanChapters 4 and 15elprlChapter 12EsqarrouthChapter 19
esthepikingChapters 1 and 17Fangming NingChapter 50FattieChapter 31FeldurChapter 4FelixSFDChapters 2, 28, 30 and 32Ferenc KissChapter 1Fred FaustChapters 16 and 33fredpiChapter 9Glenn R. FisherChapters 22 and 24godisgood4Chapter 21Govind RaiChapter 4Guilherme Torres CastroChapter 4Hady NourallahChapters 39 and 47HamishChapters 4, 6, 8, 13, 14, 16, 17, 22, 25 and 29HariKrishnan.PChapter 4HeMetChapter 4Ian RahmanChapters 24, 52 and 53iBelieveChapter 17IdanChapter 16IntentssChapter 25iOSDevCenterChapter 11Jack ChorleyChapter 24JALChapters 4, 25, 26, 31 and 32Jason BourneChapter 15Jeff LewisChapter 16JimChapter 1joanChapter 12JojodmoChapters 2, 4, 7, 13, 19, 22 and 29Josh BrownChapter 9JPetricChapter 45jtbandesChapters 1, 3, 4, 5, 6, 8, 14, 15, 17, 18, 19, 20, 24, 29 and 42juanjoChapters 8 and 13kabiroberaiChapters 4 and 33kennytmChapter 25KevinChapters 5, 6 and 9Kirit ModiChapter 11KoteChapter 18KoushikChapter 11Kumar Vivek MitraChapter 35Kyle KIMChapter 4LopeChapter 4LopSaeChapters 4, 21 and 29lostAtSeaJoshuaChapter 24Luca AngelettiChapters 1, 4, 6, 7, 9, 10, 12, 16, 18 and 34Luca AngioloniChapter 1Luca D'AlbertiChapters 22 and 24LukeChapter 2LukeSideWalkerChapters 4 and 32Mahmoud AdamChapter 4Marcus RosselChapter 9MarkChapter 42Martin DelilleChapter 43MattChapters 20, 36 and 56
matt.baranowskiChapter 17Matthew SeamanChapters 4, 8, 17, 25, 29, 32 and 60Max DesiatovChapter 4maxkonovalovChapter 24MaysamChapter 49Mehul SojitraChapter 15Michaël AzevedoChapter 13MoritzChapters 4, 6, 7, 13, 15, 19, 24, 41 and 58MoriyaChapter 6Mr. XcoderChapter 16M_GChapter 32Nate CookChapter 4Nathan KellertChapters 7, 8 and 13Nick PodratzChapters 8 and 21Nikolai RuheChapters 4 and 8NoamChapter 26noorChapter 18Oleg DanuChapter 17orccrusher99Chapter 25pableirosChapters 5 and 6PalleChapters 32, 37, 38 and 59PandaChapter 4Paulw11Chapter 13pixatlazakiChapter 4RahulChapter 17Rick PasveerChapter 7RobChapter 32Rob NapierChapter 9Ronald MartinChapter 7RubberDucky4444Chapter 51Ryan H.Chapters 20 and 38saagarjhaChapters 6, 11 and 18Sagar ThummarChapter 48SajjonChapter 27Santa ClausChapters 2, 12, 30 and 32sasquatchChapter 11sdasdadasChapter 4SeanRobinson159Chapters 8 and 17Seyyed Parsa NeshaeiChapter 1shannogaChapters 8 and 13Shijing LvChapter 34shimChapter 4SKOOPChapters 13 and 17solidcellChapter 4Sơn Đỗ Đình ThyChapter 52SteBraChapter 47Steve MoserChapter 10Suneet TipirneniChapters 11 and 22Sunil PrajapatiChapter 1Sunil SharmaChapter 4SuragchChapters 3 and 4TannerChapters 1 and 13taylor swiftChapter 4
ThaNerdChapter 14ThoraxChapter 52ThrowingSpoonChapters 6, 11, 12, 18 and 39Timothy RascherChapter 29tktsubotaChapters 2, 7, 13, 14 and 20Tom MagnussonChapter 15tomahhChapter 6Tommie C.Chapters 47 and 54torinpitchersChapter 14Umberto RaimondiChapter 26UndoChapter 17user3480295Chapters 4 and 8user5389107Chapter 4vacawamaChapter 6Victor SiglerChapters 4, 17 and 40Viktor GardartChapter 46Vinupriya ArivazhaganChapters 4 and 30Vladimir NulChapter 6WMiosChapter 4xoudiniChapter 16ZackChapter 20zaphChapters 55, 56 and 57ZGskiChapters 3 and 18	ʀ	ɴChapter 1
You may also like







GoalKicker.com - Swift(tm) Notes for Professionals	1

GoalKicker.com - Swift(tm) Notes for Professionals	1

GoalKicker.com - Swift(tm) Notes for Professionals	1







