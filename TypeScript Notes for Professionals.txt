

Contents
About	1
Chapter 1: Getting started with TypeScript	2
Section 1.1: Installation and setup	2
Section 1.2: Basic syntax	4
Section 1.3: Hello World	5
Section 1.4: Running TypeScript using ts-node	6
Section 1.5: TypeScript REPL in Node.js	6
Chapter 2: Why and when to use TypeScript	8
Section 2.1: Safety	8
Section 2.2: Readability	8
Section 2.3: Tooling	8
Chapter 3: TypeScript Core Types	9
Section 3.1: String Literal Types	9
Section 3.2: Tuple	12
Section 3.3: Boolean	12
Section 3.4: Intersection Types	13
Section 3.5: Types in function arguments and return value. Number	13
Section 3.6: Types in function arguments and return value. String	14
Section 3.7: const Enum	14
Section 3.8: Number	15
Section 3.9: String	15
Section 3.10: Array	16
Section 3.11: Enum	16
Section 3.12: Any	16
Section 3.13: Void	16
Chapter 4: Arrays	17
Section 4.1: Finding Object in Array	17
Chapter 5: Enums	18
Section 5.1: Enums with explicit values	18
Section 5.2: How to get all enum values	19
Section 5.3: Extending enums without custom enum implementation	19
Section 5.4: Custom enum implementation: extends for enums	19
Chapter 6: Functions	21
Section 6.1: Optional and Default Parameters	21
Section 6.2: Function as a parameter	21
Section 6.3: Functions with Union Types	23
Section 6.4: Types of Functions	23
Chapter 7: Classes	24
Section 7.1: Abstract Classes	24
Section 7.2: Simple class	24
Section 7.3: Basic Inheritance	25
Section 7.4: Constructors	25
Section 7.5: Accessors	26
Section 7.6: Transpilation	27
Section 7.7: Monkey patch a function into an existing class	28
Chapter 8: Class Decorator	29
Section 8.1: Generating metadata using a class decorator	29
Section 8.2: Passing arguments to a class decorator	29
Section 8.3: Basic class decorator	30
Chapter 9: Interfaces	32
Section 9.1: Extending Interface	32
Section 9.2: Class Interface	32
Section 9.3: Using Interfaces for Polymorphism	33
Section 9.4: Generic Interfaces	34
Section 9.5: Add functions or properties to an existing interface	35
Section 9.6: Implicit Implementation And Object Shape	35
Section 9.7: Using Interfaces to Enforce Types	36
Chapter 10: Generics	37
Section 10.1: Generic Interfaces	37
Section 10.2: Generic Class	37
Section 10.3: Type parameters as constraints	38
Section 10.4: Generics Constraints	38
Section 10.5: Generic Functions	39
Section 10.6: Using generic Classes and Functions:	39
Chapter 11: Strict null checks	40
Section 11.1: Strict null checks in action	40
Section 11.2: Non-null assertions	40
Chapter 12: User-defined Type Guards	42
Section 12.1: Type guarding functions	42
Section 12.2: Using instanceof	43
Section 12.3: Using typeof	43
Chapter 13: TypeScript basic examples	45
Section 13.1: 1 basic class inheritance example using extends and super keyword	45
Section 13.2: 2 static class variable example - count how many time method is being invoked	45
Chapter 14: Importing external libraries	46
Section 14.1: Finding definition files	46
Section 14.2: Importing a module from npm	47
Section 14.3: Using global external libraries without typings	47
Section 14.4: Finding definition files with TypeScript 2.x	47
Chapter 15: Modules - exporting and importing	49
Section 15.1: Hello world module	49
Section 15.2: Re-export	49
Section 15.3: Exporting/Importing declarations	51
Chapter 16: Publish TypeScript definition files	52
Section 16.1: Include definition file with library on npm	52
Chapter 17: Using TypeScript with webpack	53
Section 17.1: webpack.config.js	53
Chapter 18: Mixins	54
Section 18.1: Example of Mixins	54
Chapter 19: How to use a JavaScript library without a type definition file	55
Section 19.1: Make a module that exports a default any	55
Section 19.2: Declare an any global	55
Section 19.3: Use an ambient module	56
Chapter 20: TypeScript installing typescript and running the typescript compiler tsc	57
Section 20.1: Steps	57
Chapter 21: Configure typescript project to compile all files in typescript	59
Section 21.1: TypeScript Configuration file setup	59
Chapter 22: Integrating with Build Tools	61
Section 22.1: Browserify	61
Section 22.2: Webpack	61
Section 22.3: Grunt	62
Section 22.4: Gulp	62
Section 22.5: MSBuild	63
Section 22.6: NuGet	63
Section 22.7: Install and configure webpack + loaders	64
Chapter 23: Using TypeScript with RequireJS	65
Section 23.1: HTML example using RequireJS CDN to include an already compiled TypeScript file	65
Section 23.2: tsconfig.json example to compile to view folder using RequireJS import style	65
Chapter 24: TypeScript with AngularJS	66
Section 24.1: Directive	66
Section 24.2: Simple example	67
Section 24.3: Component	67
Chapter 25: TypeScript with SystemJS	69
Section 25.1: Hello World in the browser with SystemJS	69
Chapter 26: Using TypeScript with React (JS & native)	72
Section 26.1: ReactJS component written in TypeScript	72
Section 26.2: TypeScript & react & webpack	73
Chapter 27: TSLint - assuring code quality and consistency	75
Section 27.1: Configuration for fewer programming errors	75
Section 27.2: Installation and setup	75
Section 27.3: Sets of TSLint Rules	76
Section 27.4: Basic tslint.json setup	76
Section 27.5: Using a predefined ruleset as default	76
Chapter 28: tsconfig.json	78
Section 28.1: Create TypeScript project with tsconfig.json	78
Section 28.2: Configuration for fewer programming errors	79
Section 28.3: compileOnSave	80
Section 28.4: Comments	80
Section 28.5: preserveConstEnums	81
Chapter 29: Debugging	82
Section 29.1: TypeScript with ts-node in WebStorm	82
Section 29.2: TypeScript with ts-node in Visual Studio Code	83
Section 29.3: JavaScript with SourceMaps in Visual Studio Code	84
Section 29.4: JavaScript with SourceMaps in WebStorm	84
Chapter 30: Unit Testing	86
Section 30.1: tape	86
Section 30.2: jest (ts-jest)	87
Section 30.3: Alsatian	89
Section 30.4: chai-immutable plugin	89
Credits	91
You may also like	93


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from:
https://goalkicker.com/TypeScriptBook
This TypeScript Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official TypeScript group(s) or company(s) nor Stack Overflow. All
trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with TypeScript
Version Release Date
2.8.32018-04-202.82018-03-282.8 RC2018-03-162.7.22018-02-162.7.12018-02-012.7 beta2018-01-182.6.12017-11-012.5.22017-09-012.4.12017-06-282.3.22017-04-282.3.12017-04-252.3.0 beta 2017-04-04
2.2.22017-03-132.22017-02-172.1.62017-02-072.2 beta2017-02-022.1.52017-01-052.1.42016-12-052.0.82016-11-082.0.72016-11-032.0.62016-10-232.0.52016-09-222.0 Beta2016-07-081.8.102016-04-091.8.92016-03-161.8.52016-03-021.8.22016-02-171.7.52015-12-141.72015-11-201.62015-09-111.5.42015-07-151.52015-07-151.42015-01-131.32014-10-281.1.0.12014-09-23Section 1.1: Installation and setup
Background
tsTypeScript is a typed superset of JavaScript that compiles directly to JavaScript code. TypeScript files commonly use the . extension. Many IDEs support TypeScript without any other setup required, but TypeScript can also be compiled with the TypeScript Node.JS package from the command line.
IDEs
Visual Studio
Visual Studio 2015Visual Studio 2013 Update  includes TypeScript.
2 or later includes TypeScript, or you can download TypeScript for earlier
versions.
Visual Studio Code
 Visual Studio Code (vscode) provides contextual autocomplete as well as refactoring and debugging tools for TypeScript. vscode is itself implemented in TypeScript. Available for Mac OS X, Windows and Linux.
WebStorm
WebStorm 2016.2		 comes with TypeScript and a built-in compiler. [WebStorm is not free]
IntelliJ IDEA
IntelliJ IDEA 2016.2		 has support for TypeScript and a compiler via a plugin maintained by the JetBrains
team. [IntelliJ is not free]
Atom & atom-typescript
 Atom supports TypeScript with the atom-typescript package.
Sublime Text
 Sublime Text supports TypeScript with the TypeScript package.
Installing the command line interface
Install Node.js
Install the npm package globally
You can install TypeScript globally to have access to it from any directory.
npm install -g typescript
or
Install the npm package locally
npm install typescript --save-devYou can install TypeScript locally and save to package.json to restrict to a directory.  Installation channels
You can install from:
npm install typescriptnpm install typescript@betanpm install typescript@nextStable channel: 
Beta channel: Dev channel: 
Compiling TypeScript code
The tsc compilation command comes with typescript, which can be used to compile code.
tsc my-code.tsmy-code.jsThis creates a  file.
Compile using tsconfig.json
tsconfig.jsontsc --inittsconfig.jsonYou can also provide compilation options that travel with your code via a  file. To start a new TypeScript project, cd into your project's root directory in a terminal window and run . This command will generate a  file with minimal configuration options, similar to below.

tsconfig.jsonWith a  file placed at the root of your TypeScript project, you can use the tsc command to run the compilation.
Section 1.2: Basic syntax
TypeScript is a typed superset of JavaScript, which means that all JavaScript code is valid TypeScript code. TypeScript adds a lot of new features on top of that.
TypeScript makes JavaScript more like a strongly-typed, object-oriented language akin to C# and Java. This means that TypeScript code tends to be easier to use for large projects and that code tends to be easier to understand and maintain. The strong typing also means that the language can (and is) precompiled and that variables cannot be assigned values that are out of their declared range. For instance, when a TypeScript variable is declared as a number, you cannot assign a text value to it.
This strong typing and object orientation makes TypeScript easier to debug and maintain, and those were two of the weakest points of standard JavaScript.
Type declarations
var num: number You can add type declarations to variables, function parameters and function return types. The type is written after a colon following the variable name, like this: = 5; The compiler will then check the types (where possible) during compilation and report type errors.
var num: number = 5; num = "this is a string";  // error: Type 'string' is not assignable to type 'number'.
The basic types are :
number (both integers and floating point numbers) string boolean
Array. You can specify the types of an array's elements. There are two equivalent ways to define array types:
Array<T> and T[]. For example:
numberArray<stringboolean, stringnumber, number, number[] - array of numbers
> - array of strings
Tuples. Tuples have a fixed number of elements with specific types.
[] - tuple where the first element is a boolean and the second is a string.
[] - tuple of three numbers.
{} - object, you can define its properties or indexer
name: string, age: number{} - object with name and age attributes
key: string]: number{[} - a dictionary of numbers indexed by string
 Red  Blue, Green = 0,} - enumeration mapped to numbers
Function. You specify types for the parameters and return value:
param: number) => string => number( - function taking one number parameter returning string () - function with no parameters returning an number.
 string, b?: boolean) => void(a: - function taking a string and optionally a boolean with no return value.
any - Permits any type. Expressions involving any are not type checked.
void - represents "nothing", can be used as a function return value. Only null and undefined are part of the void type. never
let foo: never; -As the type of variables under type guards that are never true.
function error(message: string): never { throw new Error(message); } - As the return type of functions that never return.
 null - type for the value null. null is implicitly part of every type, unless strict null checks are enabled.
Casting
You can perform explicit casting through angle brackets, for instance:

someSpecificMethod<ImplementingClass>derivedThis example shows a derived class which is treated by the compiler as a MyInterface. Without the casting on the second line the compiler would throw an exception as it does not understand (), but casting through  suggests the compiler what to do.
Another way of casting in TypeScript is using the as keyword:

Since TypeScript 1.6, the default is using the as keyword, because using <> is ambiguous in .jsx files. This is mentioned in TypeScript official documentation.
Classes
Classes can be defined and used in TypeScript code. To learn more about classes, see the Classes documentation page.
Section 1.3: Hello World


Here we have a class, Greeter, that has a constructor and a greet method. We can construct an instance of the class using the new keyword and pass in a string we want the greet method to output to the console. The instance of our Greeter class is stored in the greeter variable which we then us to call the greet method.
Section 1.4: Running TypeScript using ts-node
ts-node is an npm package which allows the user to run typescript files directly, without the need for precompilation using tsc. It also provides REPL. Install ts-node globally using

ts-node does not bundle typescript compiler, so you might need to install it.

Executing script
To execute a script named main.ts, run

Example usage

Running REPL
ts-nodeTo run REPL run command 
Example usage

Section 1.5: TypeScript REPL in Node.js
For use TypeScript REPL in Node.js you can use tsun package
Install it globally with

and run in your terminal or command prompt with tsun command Usage example:


Chapter 2: Why and when to use TypeScript
If you find the arguments for type systems persuasive in general, then you'll be happy with TypeScript.
It brings many of the advantages of type system (safety, readability, improved tooling) to the JavaScript ecosystem. It also suffers from some of the drawbacks of type systems (added complexity and incompleteness).
Section 2.1: Safety
TypeScript catches type errors early through static analysis:

Section 2.2: Readability
TypeScript enables editors to provide contextual documentation:

String.prototype.slice takes (start, stop) or (start, lengthYou'll never forget whether ) again!
Section 2.3: Tooling
TypeScript allows editors to perform automated refactors which are aware of the rules of the languages.

Here, for instance, Visual Studio Code is able to rename references to the inner foo without altering the outer foo. This would be difficult to do with a simple find/replace.
Chapter 3: TypeScript Core Types
Section 3.1: String Literal Types
String literal types allow you to specify the exact value a string can have.

Any other string will give an error.

Together with Type Aliases and Union Types you get a enum-like behavior.

String Literal Types can be used to distinguish overloads.
function buyPet(pet: Species, name: string) : Pet; function buyPet(pet: "cat", name: string): Cat; function buyPet(pet: "dog", name: string): Dog; function buyPet(pet: "bird", name: string): Bird; function buyPet(pet: Species, name: string) : Pet { /*...*/ }
let dog = buyPet(myFavoritePet /* "dog" as defined above */, "Rocky");
// dog is from type Dog (dog: Dog)
They works well for User-Defined Type Guards.


Full example code


        return {             species: "cat",             name: name,             eat: function () {                 console.log(`${this.name} eats.`);             }, walk: function () {                 console.log(`${this.name} walks.`);             }, sleep: function () {                 console.log(`${this.name} sleeps.`);             }
        } as Cat;     } else if(pet === "dog") {         return {             species: "dog",             name: name,             eat: function () {                 console.log(`${this.name} eats.`);             }, walk: function () {                 console.log(`${this.name} walks.`);             }, sleep: function () {                 console.log(`${this.name} sleeps.`);             }
        } as Dog;     } else if(pet === "bird") {         return {             species: "bird",             name: name,             eat: function () {                 console.log(`${this.name} eats.`);             }, walk: function () {                 console.log(`${this.name} walks.`);             }, sleep: function () {                 console.log(`${this.name} sleeps.`);             }, sing: function () {                 console.log(`${this.name} sings.`);             }
        } as Bird;     } else {         throw `Sorry we do not have a ${pet}. Would you like to buy a dog?`;     } }
function petIsCat(pet: Pet): pet is Cat {     return pet.species === "cat"; }
function petIsDog(pet: Pet): pet is Dog {     return pet.species === "dog"; }
function petIsBird(pet: Pet): pet is Bird {     return pet.species === "bird"; }
function playWithPet(pet: Pet) {     console.log(`Hey ${pet.name}, lets play.`);        if(petIsCat(pet)) {
        // pet is now from type Cat (pet: Cat)
               pet.eat();         pet.sleep();
Section 3.2: Tuple
Array type with known and possibly different types:

Section 3.3: Boolean
A boolean represents the most basic datatype in TypeScript, with the purpose of assigning true/false values.


Section 3.4: Intersection Types
A Intersection Type combines the member of two or more types.

Section 3.5: Types in function arguments and return value. Number
When you create a function in TypeScript you can specify the data type of the function's arguments and the data type for the return value Example:

x: number, y: number(...): number {Here the syntax  means that the function can accept two argumentsx and y and they can only be numbers and  means that the return value can only be a number Usage:

Note:
You can not do so

or

it will receive the following errors:
error TS2322: Type 'string' is not assignable to type 'number' and error TS2322: Type 'number' isnot assignable to type 'string' respectively
Section 3.6: Types in function arguments and return value. String
Example:

name: string...): string Here the syntax  means that the function can accept one name argument and this argument can only be string and ({ means that the return value can only be a string Usage: hello('StackOverflow Documentation') // will be return Hello StackOverflow Documentation!
Section 3.7: const Enum
A const Enum is the same as a normal Enum. Except that no Object is generated at compile time. Instead, the literal values are substituted where the const Enum is used.

For comparison, a normal Enum

Section 3.8: Number
Like JavaScript, numbers are floating point values.
 let pi: number = 3.14;           // base 10 decimal by default let hexadecimal: number = 0xFF;  // 255 in decimal ECMAScript 2015 allows binary and octal.

Section 3.9: String
Textual data type:

Section 3.10: Array
An array of values:

Section 3.11: Enum
A type to name a set of numeric values:
Number values default to 0:
 enum Day { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday }; let bestDay: Day = Day.Saturday; Set a default starting number:

or assign values:

Section 3.12: Any
When unsure of a type, any is available:

Section 3.13: Void
If you have no type at all, commonly used for functions that do not return anything:

void types Can only be assigned null or undefined.
Chapter 4: Arrays
Section 4.1: Finding Object in Array
Using find()


Chapter 5: Enums
Section 5.1: Enums with explicit values
By default all enum values are resolved to numbers. Let's say if you have something like

MimeType.PDFthe real value behind e.g.  will be 2.
But some of the time it is important to have the enum resolve to a different type. E.g. you receive the value from backend / frontend / another system which is definitely a string. This could be a pain, but luckily there is this method:

MimeType.PDF to application/pdfThis resolves the .
Since TypeScript 2.4 it's possible to declare string enums:

You can explicitly provide numeric values using the same method

Fancier types also work, since non-const enums are real objects at runtime, for example

becomes

    FancyType[FancyType["ThreeArr"] = [3, 3, 3]] = "ThreeArr";
})(FancyType || (FancyType = {}));
Section 5.2: How to get all enum values

Section 5.3: Extending enums without custom enum implementation

Section 5.4: Custom enum implementation: extends for enums
Sometimes it is required to implement Enum on your own. E.g. there is no clear way to extend other enums. Custom implementation allows this:


Chapter 6: Functions
Section 6.1: Optional and Default Parameters
Optional Parameters
In TypeScript, every parameter is assumed to be required by the function. You can add a ? at the end of a parameter name to set it as optional.
For example, the lastName parameter of this function is optional:

Optional parameters must come after all non-optional parameters: function buildName(firstName?: string, lastName: string) // Invalid
Default Parameters
If the user passes undefined or doesn't specify an argument, the default value will be assigned. These are called default-initialized parameters.
For example, "Smith" is the default value for the lastName parameter.
function buildName(firstName: string, lastName = "Smith") {     // ...
} buildName('foo', 'bar');      // firstName == 'foo', lastName == 'bar' buildName('foo');             // firstName == 'foo', lastName == 'Smith' buildName('foo', undefined);  // firstName == 'foo', lastName == 'Smith'
Section 6.2: Function as a parameter
Suppose we want to receive a function as a parameter, we can do it like this:

If we want to receive a constructor as a parameter:

Or to make it easier to read we can define an interface describing the constructor:


Or with parameters:

Even with generics:

If we want to receive a simple function and not a constructor it's almost the same:

Or to make it easier to read we can define an interface describing the function:

Or with parameters:

Even with generics:

Section 6.3: Functions with Union Types
A TypeScript function can take in parameters of multiple, predefined types using union types.

TypeScript treats these parameters as a single type that is a union of the other types, so your function must be able to handle parameters of any type that is in the union.

Section 6.4: Types of Functions
Named functions

Anonymous functions

Lambda / arrow functions

Chapter 7: Classes
TypeScript, like ECMAScript 6, support object-oriented programming using classes. This contrasts with older JavaScript versions, which only supported prototype-based inheritance chain.
The class support in TypeScript is similar to that of languages like Java and C#, in that classes may inherit from other classes, while objects are instantiated as class instances.
Also similar to those languages, TypeScript classes may implement interfaces or make use of generics.
Section 7.1: Abstract Classes

new Machine("Konda"Abstract classes are base classes from which other classes can extend. They cannot be instantiated themselves (i.e. you cannot do )).
The two key characteristics of an abstract class in TypeScript are:
1. They can implement methods of their own.
2. They can define methods that inheriting classes must implement.
For this reason, abstract classes can conceptually be considered a combination of an interface and a class.
Section 7.2: Simple class


moveIn this example, we declare a simple class Car. The class has three members: a private property speed, a public property position and a public method move. Note that each member is public by default. That's why () is public, even if we didn't use the public keyword.
var car = new Car();        // create an instance of Car car.move();                 // call a method console.log(car.position);  // access a public property
Section 7.3: Basic Inheritance

moveThis examples shows how to create a very simple subclass of the Car class using the extends keyword. The SelfDrivingCar class overrides the () method and uses the base class implementation using super.
Section 7.4: Constructors
In this example we use the constructor to declare a public property position and a protected property speed in the base class. These properties are called Parameter properties. They let us declare a constructor parameter and a member in one place.
One of the best things in TypeScript, is automatic assignment of constructor parameters to the relevant property.


All this code can be resumed in one single constructor:

And both of them will be transpiled from TypeScript (design time and compile time) to JavaScript with same result, but writing significantly less code:

superConstructors of derived classes have to call the base class constructor with ().

Section 7.5: Accessors
In this example, we modify the "Simple class" example to allow access to the speed property. TypeScript accessors allow us to add additional code in getters or setters.


Section 7.6: Transpilation
Given a class SomeClass, let's see how the TypeScript is transpiled into JavaScript.

JavaScript source
When transpiled using TypeScript v2.2.2, the output is like so:


Observations
The modification of the class' prototype is wrapped inside an IIFE.
Member variables are defined inside the main class function.
 Static properties are added directly to the class object, whereas instance properties are added to the prototype.
 Section 7.7: Monkey patch a function into an existing class
Sometimes it's useful to be able to extend a class with new functions. For example let's suppose that a string should be converted to a camel case string. So we need to tell TypeScript, that String contains a function called toCamelCase, which returns a string.

Now we can patch this function into the String implementation.
String.prototype.toCamelCase = function() : string {     return this.replace(/[^a-z ]/ig, '')
        .replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, (match: any, index: number) => {             return +match === 0 ? "" : match[index === 0 ? 'toLowerCase' : 'toUpperCase']();         });
}
If this extension of String is loaded, it's usable like this:

Chapter 8: Class Decorator
Parameter	Details
target	The class being decorated
Section 8.1: Generating metadata using a class decorator
This time we are going to declare a class decorator that will add some metadata to a class when we applied to it:

We can then apply the class decorator:

The decorator is applied when the class is declared not when we create instances of the class. This means that the metadata is shared across all the instances of a class:

Section 8.2: Passing arguments to a class decorator
We can wrap a class decorator with another function to allow customization:

The addMetadata takes some arguments used as configuration and then returns an unnamed function which is the actual decorator. In the decorator we can access the arguments because there is a closure in place.
We can then invoke the decorator passing some configuration values:

We can use the following function to access the generated metadata:

If everything went right the console should display:

Section 8.3: Basic class decorator
A class decorator is just a function that takes the class as its only argument and returns it after doing something with it:

We can then apply the class decorator to a class:


Chapter 9: Interfaces
An interfaces specifies a list of fields and functions that may be expected on any class implementing the interface.
Conversely, a class cannot implement an interface unless it has every field and function specified on the interface.
The primary benefit of using interfaces, is that it allows one to use objects of different types in a polymorphic way. This is because any class implementing the interface has at least those fields and functions.
Section 9.1: Extending Interface
Suppose we have an interface:

And we want to create more specific interface that has the same properties of the person, we can do it using the extends keyword:

In addition it is possible to extend multiple interfaces.
Section 9.2: Class Interface
Declare public variables and methods type in the interface to define how other typescript code can interact with it.

Here we create a class that implements the interface.


The example shows how to create an interface ISampleClassInterface and a class SampleClass that implements the interface.
Section 9.3: Using Interfaces for Polymorphism
The primary reason to use interfaces to achieve polymorphism and provide developers to implement on their own way in future by implementing interface's methods.
Suppose we have an interface and three classes:

This is connector interface. Now we will implement that for Wifi communication.

Here we have developed our concrete class named WifiConnector that has its own implementation. This is now type Connector.
Now we are creating our System that has a component Connector. This is called dependency injection.

constructor(private connector: Connector) this line is very important here. Connector is an interface and must
doConnecthave (). As Connector is an interface this class System has much more flexibility. We can pass any Type which has implemented Connector interface. In future developer achieves more flexibility. For example, now developer want to add Bluetooth Connection module:


See that Wifi and Bluetooth have its own implementation. Their own different way to connect. However, hence both have implemented Type Connector the are now Type Connector. So that we can pass any of those to System class as the constructor parameter. This is called polymorphism. The class System is now not aware of whether it is Bluetooth / Wifi even we can add another Communication module like Infrared, Bluetooth5 and whatsoever by just implementing Connector interface.
doConnectThis is called Duck typing. Connector type is now dynamic as () is just a placeholder and developer implement this as his/her own.
constructor(private connector: WifiConnectorif at ) where WifiConnector is a concrete class what will
happen? Then System class will tightly couple only with WifiConnector nothing else. Here interface solved our problem by polymorphism.
Section 9.4: Generic Interfaces
Like classes, interfaces can receive polymorphic parameters (aka Generics) too.
Declaring Generic Parameters on Interfaces

Here, you can see that our two interfaces take some generic parameters, T and U.
Implementing Generic Interfaces
We will create a simple class in order to implements the interface IEvents.

Let's create some instances of our State class.
IStatusIn our example, the State class will handle a generic status by using <T>. In this way, the interface

IStatus<numberHere our State class is typed as >.

IStatus<CodeOur State class is typed as >. In this way, we are able to pass more complex type to our emit method.
As you can see, generic interfaces can be a very useful tool for statically typed code.
Section 9.5: Add functions or properties to an existing interface
Let's suppose we have a reference to the JQuery type definition and we want to extend it to have additional functions from a plugin we included and which doesn't have an official type definition. We can easily extend it by declaring functions added by plugin in a separate interface declaration with the same JQuery name:

The compiler will merge all declarations with the same name into one - see declaration merging for more details.
Section 9.6: Implicit Implementation And Object Shape
TypeScript supports interfaces, but the compiler outputs JavaScript, which doesn't. Therefore, interfaces are effectively lost in the compile step. This is why type checking on interfaces relies on the shape of the object meaning whether the object supports the fields and functions on the interface - and not on whether the interface is actually implemented or not.


So even if Ball doesn't explicitly implement IKickable, a Ball instance may be assigned to (and manipulated as) an IKickable, even when the type is specified.
Section 9.7: Using Interfaces to Enforce Types
One of the core benefits of TypeScript is that it enforces data types of values that you are passing around your code to help prevent mistakes.
Let's say you're making a pet dating application.
You have this simple function that checks if two pets are compatible with each other...

This is completely functional code, but it would be far too easy for someone, especially other people working on this application who didn't write this function, to be unaware that they are supposed to pass it objects with 'species'
checkCompatible(petOne.species, petTwo.speciesand 'age' properties. They may mistakenly try ) and then be left to figure out the errors thrown when the function tries to access petOne.species.species or petOne.species.age! One way we can prevent this from happening is to specify the properties we want on the pet parameters:

In this case, TypeScript will make sure everything passed to the function has 'species' and 'age' properties (it is okay if they have additional properties), but this is a bit of an unwieldy solution, even with only two properties specified.
With interfaces, there is a better way!
First we define our interface:

Now all we have to do is specify the type of our parameters as our new interface, like so...

... and TypeScript will make sure that the parameters passed to our function contain the properties specified in the Pet interface!
Chapter 10: Generics
Section 10.1: Generic Interfaces




Implement it with non generic class:

Section 10.2: Generic Class


Section 10.3: Type parameters as constraints
With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error.

Section 10.4: Generics Constraints
Simple constraint:

More complex constraint:

Even more complex:


Inline type constraints:

Section 10.5: Generic Functions
In interfaces:

In classes:

Simple functions:

Section 10.6: Using generic Classes and Functions:
Create generic class instance:

Run generic function:

Chapter 11: Strict null checks
Section 11.1: Strict null checks in action
By default, all types in TypeScript allow null:

--strictNullCheckstsconfig.jsonTypeScript 2.0 adds support for strict null checks. If you set  when running tsc (or set this flag in your ), then types no longer permit null:

You must permit null values explicitly:

With a proper guard, the code type checks and runs correctly:

Section 11.2: Non-null assertions
The non-null assertion operator, !, allows you to assert that an expression isn't null or undefined when the TypeScript compiler can't infer that automatically:



Chapter 12: User-defined Type Guards
Section 12.1: Type guarding functions
You can declare functions that serve as type guards using any logic you'd like.
They take the form:

If the function returns true, TypeScript will narrow the type to DesiredType in any block guarded by a call to the function.
For example (try it):

A guard's function type predicate (the foo is Bar in the function return type position) is used at compile time to narrow types, the function body is used at runtime. The type predicate and function must agree, or your code won't work.
Type guard functions don't have to use typeof or instanceof, they can use more complicated logic.
For example, this code determines if you've got a jQuery object by checking for its version string.

Section 12.2: Using instanceof
instanceof requires that the variable is of type any.
This code (try it):

prints

to the console.
Section 12.3: Using typeof
typeof is used when you need to distinguish between types number, string, boolean, and symbol. Other string constants will not error, but won't be used to narrow types either.
Unlike instanceof, typeof will work with a variable of any type. In the example below, foo could be typed as number
 string| without issue.
This code (try it):


prints


Chapter 13: TypeScript basic examples
Section 13.1: 1 basic class inheritance example using extends and super keyword
A generic Car class has some car property and a description method

HondaCar extends the existing generic car class and adds new property.

Section 13.2: 2 static class variable example - count how many time method is being invoked
here countInstance is a static class variable

Chapter 14: Importing external libraries
Section 14.1: Finding definition files
for typescript 2.x: definitions from DefinitelyTyped are available via @types npm package

but in case if you want use types from other repos then can be used old way: for typescript 1.x:
Typings is an npm package that can automatically install type definition files into a local project. I recommend that you read the quickstart.

Now we have access to the typings cli.
1. The first step is to search for the package used by the project
typings search lodash NAME              SOURCE HOMEPAGE                                        DESCRIPTION VERSIONS UPDATED lodash            dt     http://lodash.com/                                          2      
 2016-07-20T00:13:09.000Z lodash            global                                                             1      
 2016-07-01T20:51:07.000Z lodash            npm    https://www.npmjs.com/package/lodash                        1       2016-07-01T20:51:07.000Z
2. Then decide which source you should install from. I use dt which stands for DefinitelyTyped a GitHub repo where the community can edit typings, it's also normally the most recently updated.
3. Install the typings files

typings.jsonLet's break down the last command. We are installing the DefinitelyTyped version of lodash as a global typings file in our project and saving it as a dependency in the . Now wherever we import lodash, typescript will load the lodash typings file.
--save4. If we want to install typings that will be used for development environment only, we can supply the dev flag:

Section 14.2: Importing a module from npm
If you have a type definition file (d.ts) for the module, you can use an import statement.

If you don't have a definition file for the module, TypeScript will throw an error on compilation because it cannot find the module you are trying to import.
In this case, you can import the module with the normal runtime require function. This returns it as the any type, however.
// The _ variable is of type any, so TypeScript will not perform any type checking. const _: any = require('lodash');
As of TypeScript 2.0, you can also use a shorthand ambient module declaration in order to tell TypeScript that a module exists when you don't have a type definition file for the module. TypeScript won't be able to provide any meaningful typechecking in this case though.

--noImplicitAnyAs of TypeScript 2.1, the rules have been relaxed even further. Now, as long as a module exists in your node_modules directory, TypeScript will allow you to import it, even with no module declaration anywhere. (Note that if using the  compiler option, the below will still generate a warning.)
// Will work if `node_modules/someModule/index.js` exists, or if `node_modules/someModule/package.json` has a valid "main" entry point import { foo } from "someModule";
Section 14.3: Using global external libraries without typings
Although modules are ideal, if the library you are using is referenced by a global variable (like $ or _), because it was loaded by a script tag, you can create an ambient declaration in order to refer to it:
declare const _: any                        ; Section 14.4: Finding definition files with TypeScript 2.x
With the 2.x versions of TypeScript, typings are now available from the npm @types repository. These are automatically resolved by the TypeScript compiler and are much simpler to use.
To install a type definition you simply install it as a dev dependency in your projects package.json e.g.

after install you simply use the module as before


Chapter 15: Modules - exporting and importing
Section 15.1: Hello world module

Load using directory index
index.ts it can be loaded using only directory name (for index.tsIf directory contains file named  filename is optional).

Example usage of defined modules
import {hello, helloES} from "./hello";  // load specified elements import defaultHello from "./hello";      // load default export into name defaultHello import * as Bundle from "./hello";       // load all exports as Bundle import {welcome} from "./welcome";       // note index.ts is omitted
hello("World");                          // Hello World! helloES("Mundo");                        // Hola Mundo! defaultHello("World");                   // Hello World!
Bundle.hello("World");                   // Hello World! Bundle.helloES("Mundo");                 // Hola Mundo! welcome("Human");                        // Welcome Human!
Section 15.2: Re-export
TypeScript allow to re-export declarations.


You can bundle all operations in single library

Named declarations can be re-exported using shorter syntax

Default exports can also be exported, but no short syntax is available. Remember, only one default export per module is possible.

Possible is re-export of bundled import

When re-exporting bundle, declarations may be overridden when declared explicitly.

Usage example


Section 15.3: Exporting/Importing declarations
Any declaration (variable, const, function, class, etc.) can be exported from module to be imported in other module.
TypeScript offer two export types: named and default.
Named export

When importing named exports, you can specify which elements you want to import.
import {hello, answerToLifeTheUniverseAndEverything} from "./adams"; hello(answerToLifeTheUniverseAndEverything);   // Hello 42!
Default export
Each module can have one default export

which can be imported using

Bundled import
TypeScript offers method to import whole module into variable

Chapter 16: Publish TypeScript definition files
Section 16.1: Include definition file with library on npm
Add typings to your package.json

Now whenever that library is imported typescript will load the typings file

Chapter 17: Using TypeScript with webpack
Section 17.1: webpack.config.js
npm install --save-dev ts-loader source-map-loaderinstall loaders tsconfig.json

Chapter 18: Mixins
Parameter	Description
derivedCtor The class that you want to use as the composition class baseCtors	An array of classes to be added to the composition class
Section 18.1: Example of Mixins
To create mixins, simply declare lightweight classes that can be used as "behaviours".

You can then apply these behaviours to a composition class:

The applyMixins function is needed to do the work of composition.

Chapter 19: How to use a JavaScript library without a type definition file
While some existing JavaScript libraries have type definition files, there are many that don't.
TypeScript offers a couple patterns to handle missing declarations.
Section 19.1: Make a module that exports a default any
For more complicated projects, or in cases where you intend to gradually type a dependency, it may be cleaner to create a module.
Using JQuery (although it does have typings available) as an example:

And then in any file in your project, you can import this definition with:

After this import, $ will be typed as any.
If the library has multiple top-level variables, export and import by name instead:

You can then import and use both names:

Section 19.2: Declare an any global
It is sometimes easiest to just declare a global of type any, especially in simple projects.
If jQuery didn't have type declarations (it does), you could put

Now any use of $ will be typed any.
Section 19.3: Use an ambient module
If you just want to indicate the intent of an import (so you don't want to declare a global) but don't wish to bother with any explicit definitions, you can import an ambient module.
// in a declarations file (like declarations.d.ts)
 declare module "jquery";    // note that there are no defined exports You can then import from the ambient module.

Anything imported from the declared module (like $ and jQuery) above will be of type any

Chapter 20: TypeScript installing typescript and running the typescript compiler tsc
How to install TypeScript and run the TypeScript compiler against a .ts file from the command line.
Section 20.1: Steps
Installing TypeScript and running typescript compiler.
To install TypeScript Compiler

To check with the typescript version

Download Visual Studio Code for Linux/Windows
Visual Code Download Link
1. Open Visual Studio Code
2. Open Same Folder where you have installed TypeScript compiler 3. Add File by clicking on plus icon on left pane
4. Create a basic class.
5. Compile your type script file and generate output.

See the result in compiled javascript of written typescript code.

Thank you.
Chapter 21: Configure typescript project to compile all files in typescript.
creating your first .tsconfig configuration file which will tell the TypeScript compiler how to treat your .ts files
Section 21.1: TypeScript Configuration file setup
 Enter command "tsc --init" and hit enter.
Before that we need to compile ts file with command "tsc app.ts" now it is all defined in below config file automatically.

file.

be automatically created for typescript file.
Thank you,

Chapter 22: Integrating with Build Tools
Section 22.1: Browserify
Install npm install tsify
Using Command Line Interface

Using API

More details: smrq/tsify
Section 22.2: Webpack
Install



See more details on ts-loader here.
Alternatives:
     awesome-typescript-loader
  Section 22.3: Grunt
Install npm install grunt-ts
Basic Gruntfile.js

More details: TypeStrong/grunt-ts
Section 22.4: Gulp
Install

Basic gulpfile.js

gulpfile.js using an existing tsconfig.json var gulp = require("gulp");

More details: ivogabe/gulp-typescript
Section 22.5: MSBuild
Microsoft.TypeScript.Default.propsUpdate project file to include locally installed  (at the top) and
Microsoft.TypeScript.targets (at the bottom) files:

More details about defining MSBuild compiler options: Setting Compiler Options in MSBuild projects
Section 22.6: NuGet
Microsoft.TypeScript.MSBuildRight-Click -> Manage NuGet Packages
Search for 
Hit Install
When install is complete, rebuild!
More details can be found at Package Manager Dialog and using nightly builds with NuGet
Section 22.7: Install and configure webpack + loaders
Installation

webpack.config.js


Chapter 23: Using TypeScript with RequireJS
RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments, like Rhino and Node. Using a modular script loader like RequireJS will improve the speed and quality of your code.
Using TypeScript with RequireJS requires configuration of tsconfig.json, and including an snippet in any HTML file. Compiler will traduce imports from the syntax of TypeScript to RequireJS' format.
Section 23.1: HTML example using RequireJS CDN to include an already compiled TypeScript file

Section 23.2: tsconfig.json example to compile to view folder using RequireJS import style

Chapter 24: TypeScript with AngularJS
	Name	Description
is an alias name, to which variables or functions can be assigned to. @see:
controllerAs https://docs.angularjs.org/guide/directive
Dependency Injection list, it is resolved by angular and passing as an argument to constructor
$inject
functions.
Section 24.1: Directive

// Using slug naming across the projects simplifies change of the directive name myDirective.prototype.slug = "myDirective";
// You can place this in some bootstrap file, or have them at the same file angular.module("myApp").     directive(myDirective.prototype.slug, myDirective);
Section 24.2: Simple example

Section 24.3: Component
For an easier transition to Angular 2, it's recommended to use Component, available since Angular 1.5.8
myModule.ts

components/myModuleComponent.ts
import IComponentOptions = angular.IComponentOptions; import IControllerConstructor = angular.IControllerConstructor; import Injectable = angular.Injectable; import { MyModuleController } from "../controller/MyModuleController"; export class MyModuleComponent implements IComponentOptions {
     public templateUrl: string = "./app/myModule/templates/myComponentTemplate.html";     public controller: Injectable<IControllerConstructor> = MyModuleController;     public bindings: {[boundProperty: string]: string} = {}; } templates/myModuleComponent.html

controller/MyModuleController.ts

services/MyModuleService.ts

somewhere.html

Chapter 25: TypeScript with SystemJS
Section 25.1: Hello World in the browser with SystemJS
Install systemjs and plugin-typescript

NOTE: this will install typescript 2.0.0 compiler which is not released yet.
For TypeScript 1.8 you have to use plugin-typescript 4.0.16
hello.tsCreate  file

hello.htmlCreate  file

config.jsCreate  - SystemJS configuration file


loader: "plugin-typescript"NOTE: if you don't want type checking, remove  and typescriptOptions from
config.js. Also note that it will never check javascript code, in particular code in the <script> tag in html example.
Test it

Build it for production

build.jsCreate  file:

build hello.js from hello.ts

Use it in production
Just load hello.js with a script tag before first use
hello-production.html file:



Chapter 26: Using TypeScript with React (JS & native)
Section 26.1: ReactJS component written in TypeScript
You can use ReactJS's components easily in TypeScript. Just rename the 'jsx' file extension to 'tsx':

But in order to make full use of TypeScript's main feature (static type checking) you must do a couple things:
1) convert React.createClass to an ES6 Class:

For more info on converting to ES6 look here 2) Add Props and State interfaces:

Now TypeScript will display an error if the programmer forgets to pass props. Or if trying to pass in props that are not defined in the interface.
Section 26.2: TypeScript & react & webpack
Installing typescript, typings and webpack globally
npm install -g typescript typings webpack
Installing loaders and linking typescript
npm install --save-dev ts-loader source-map-loader npm link typescript
Linking TypeScript allows ts-loader to use your global installation of TypeScript instead of needing a separate local copy typescript doc
tsinstalling .d. files with typescript 2.x

tsinstalling .d. files with typescript 1.x

tsconfig.json configuration file

webpack.config.js configuration file


Note: React and ReactDOM are marked as external

Chapter 27: TSLint - assuring code quality and consistency
TSLint performs static analysis of code and detect errors and potential problems in code.
Section 27.1: Configuration for fewer programming errors
This tslint.json example contains a set of configuration to enforce more typings, catch common errors or otherwise confusing constructs that are prone to producing bugs and following more the Coding Guidelines for TypeScript Contributors.
To enforce this rules, include tslint in your build process and check your code before compiling it with tsc.
{
  "rules": {
     // TypeScript Specific
     "member-access": true, // Requires explicit visibility declarations for class members.
     "no-any": true, // Disallows usages of any as a type declaration.
     // Functionality
     "label-position": true, // Only allows labels in sensible locations.
     "no-bitwise": true, // Disallows bitwise operators.
     "no-eval": true, // Disallows eval function invocations.
     "no-null-keyword": true, // Disallows use of the null keyword literal.
     "no-unsafe-finally": true, // Disallows control flow statements, such as return, continue, break and throws in finally blocks.
     "no-var-keyword": true, // Disallows usage of the var keyword.
     "radix": true, // Requires the radix parameter to be specified when calling parseInt.
     "triple-equals": true, // Requires === and !== in place of == and !=.
     "use-isnan": true, // Enforces use of the isNaN() function to check for NaN references instead of a comparison to the NaN constant.
     // Style
     "class-name": true, // Enforces PascalCased class and interface names.
     "interface-name": [ true, "never-prefix" ], // Requires interface names to begin with a capital
'I'
     "no-angle-bracket-type-assertion": true, // Requires the use of as Type for type assertions instead of <Type>.
     "one-variable-per-declaration": true, // Disallows multiple variable definitions in the same declaration statement.
     "quotemark": [ true, "double", "avoid-escape" ], // Requires double quotes for string literals.      "semicolon": [ true, "always" ], // Enforces consistent semicolon usage at the end of every statement.
     "variable-name": [true, "ban-keywords", "check-format", "allow-leading-underscore"] // Checks variable names for various errors. Disallows the use of certain TypeScript keywords (any, Number, number, String, string, Boolean, boolean, undefined) as variable or parameter. Allows only camelCased or UPPER_CASED variable names. Allows underscores at the beginning (only has an effect if "checkformat" specified).
  }
}
Section 27.2: Installation and setup
To install tslint run command

tslint.jsonTslint is configured via file . To initialize default configuration run command

To check file for possible errors in file run command

Section 27.3: Sets of TSLint Rules
tslint-microsoft-contrib tslint-eslint-rules codelyzer
Yeoman generator supports all these presets and can be extends also:
 generator-tslint
Section 27.4: Basic tslint.json setup

Section 27.5: Using a predefined ruleset as default
tslint:recommended and tslint:latesttslint can extend an existing rule set and is shipped with the defaults .
tslint:recommendedtslint:latest is a stable, somewhat opinionated set of rules which we encourage for general TypeScript programming. This configuration follows semver, so it will not have breaking changes across minor or patch releases.
 extends tslint:recommended and is continuously updated to include configuration for the
latest rules in every TSLint release. Using this config may introduce breaking changes across minor releases as new rules are enabled which cause lint failures in your code. When TSLint reaches a major version bump, tslint:recommended will be updated to be identical to tslint:latest.
Docs and source code of predefined ruleset
So one can simply use:

to have a sensible starting configuration.
no-consoleOne can then overwrite rules from that preset via rules, e.g. for node developers it made sense to set 


Chapter 28: tsconfig.json
Section 28.1: Create TypeScript project with tsconfig.json
The presence of a tsconfig.json file indicates that the current directory is the root of a TypeScript enabled project.
Initializing a TypeScript project, or better put tsconfig.json file, can be done through the following command:

As of TypeScript v2.3.0 and higher this will create the following tsconfig.json by default:
{
  "compilerOptions": {
    /* Basic Options */                      
    "target": "es5",                          /* Specify ECMAScript target version: 'ES3' (default),
'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */
    "module": "commonjs",                     /* Specify module code generation: 'commonjs', 'amd', 'system', 'umd' or 'es2015'. */
    // "lib": [],                             /* Specify library files to be included in the compilation:  */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'reactnative', or 'react'. */
    // "declaration": true,                   /* Generates corresponding '.d.ts' file. */
    // "sourceMap": true,                     /* Generates corresponding '.map' file. */
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    // "outDir": "./",                        /* Redirect output structure to the directory. */     // "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "removeComments": true,                /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
                                             
    /* Strict Type-Checking Options */        
    "strict": true                            /* Enable all strict type-checking options. */     // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */
                                             
    /* Additional Checks */                  
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */
                                             
    /* Module Resolution Options */          
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names.
*/
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                       /* List of folders to include type definitions from. */
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
                                             
    /* Source Map Options */                  
    // "sourceRoot": "./",                    /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "./",                       /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
                                             
    /* Experimental Options */                
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */     // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */
  }
}
Most, if not all, options are generated automatically with only the bare necessities left uncommented.
Older versions of TypeScript, like for example v2.0.x and lower, would generate a tsconfig.json like this:

Section 28.2: Configuration for fewer programming errors
There are very good configurations to force typings and get more helpful errors which are not activated by default.
{
  "compilerOptions": {
    "alwaysStrict": true, // Parse in strict mode and emit "use strict" for each source file.
    // If you have wrong casing in referenced files e.g. the filename is Global.ts and you have a ///
<reference path="global.ts" /> to reference this file, then this can cause to unexpected errors.
Visite: http://stackoverflow.com/questions/36628612/typescript-transpiler-casing-issue
    "forceConsistentCasingInFileNames": true, // Disallow inconsistently-cased references to the same file.
    // "allowUnreachableCode": false, // Do not report errors on unreachable code. (Default: False)
    // "allowUnusedLabels": false, // Do not report errors on unused labels. (Default: False)     "noFallthroughCasesInSwitch": true, // Report errors for fall through cases in switch statement.     "noImplicitReturns": true, // Report error when not all code paths in function return a value.
    "noUnusedParameters": true, // Report errors on unused parameters.     "noUnusedLocals": true, // Report errors on unused locals.
    "noImplicitAny": true, // Raise error on expressions and declarations with an implied "any" type.
    "noImplicitThis": true, // Raise error on this expressions with an implied "any" type.
    "strictNullChecks": true, // The null and undefined values are not in the domain of every type and are only assignable to themselves and any.
    // To enforce this rules, add this configuration.
    "noEmitOnError": true     // Do not emit outputs if any errors were reported.
  }
}
Not enough? If you are a hard coder and want more, then you may be interested to check your TypeScript files with tslint before compiling it with tsc. Check how to configure tslint for even stricter code.
Section 28.3: compileOnSave
Setting a top-level property compileOnSave signals to the IDE to generate all files for a given tsconfig.json upon saving.

This feature is available since TypeScript 1.8.4 and onward, but needs to be directly supported by IDE's. Currently, examples of supported IDE's are:
Visual Studio 2015 with Update 3
JetBrains WebStorm
 Atom with atom-typescript
 Section 28.4: Comments
A tsconfig.json file can contain both line and block comments, using the same rules as ECMAScript.


Section 28.5: preserveConstEnums
const enumTypeScript supports constant enumerables, declared through .
This is usually just syntax sugar as the constant enums are inlined in compiled JavaScript. For instance the following code

compiles to

Although the performance benefit from inlining, you may prefer to keep enums even if constant (ie: you may wish readability on development code), to do this you have to set in tsconfig.json the preserveConstEnums clause into

By this way the previous example would be compiled as any other enums, as shown in following snippet.

Chapter 29: Debugging
There are two ways of running and debugging TypeScript:
Transpile to JavaScript, run in node and use mappings to link back to the TypeScript source files or
Run TypeScript directly using ts-node
This article describes both ways using Visual Studio Code and WebStorm. All examples presume that your main file is index.ts.
Section 29.1: TypeScript with ts-node in WebStorm
package.jsonAdd this script to your :
"start:idea": "ts-node %NODE_DEBUG_OPTION% --ignore false index.ts",
Right click on the script and select Create 'test:idea'... and confirm with 'OK' to create the debug configuration:


Start the debugger using this configuration:

Section 29.2: TypeScript with ts-node in Visual Studio Code
Add ts-node to your TypeScript project:

package.jsonAdd a script to your :
"start:debug": "ts-node --inspect=5858 --debug-brk --ignore false index.ts"
launch.json needs to be configured to use the node2 type and start npm running the start:debugThe  script:

Section 29.3: JavaScript with SourceMaps in Visual Studio Code
tsconfig.jsonIn the  set

to generate mappings alongside with js-files from the TypeScript sources using the tsc command. The launch.json file:

This starts node with the generated index.js (if your main file is index.ts) file and the debugger in Visual Studio Code which halts on breakpoints and resolves variable values within your TypeScript code.
Section 29.4: JavaScript with SourceMaps in WebStorm
index.jsCreate a Node.js debug configuration and use  as Node parameters.


Chapter 30: Unit Testing
Section 30.1: tape
tape is minimalistic JavaScript testing framework, it outputs TAP-compliant markup.
To install tape using npm run command

ts-nodeTo use tape with TypeScript you need to install  as global package, to do this run command

Now you are ready to write your first test

To execute test run command

In output you should see

Good job, you just ran your TypeScript test.
Run multiple test files
You can run multiple test files at once using path wildcards. To execute all TypeScript tests in tests directory run command

Section 30.2: jest (ts-jest)
jest is painless JavaScript testing framework by Facebook, with ts-jest can be used to test TypeScript code.
To install jest using npm run command

For ease of use install jest as global package

package.jsonTo make jest work with TypeScript you need to add configuration to 

Now jest is ready. Assume we have sample fizz buz to test

Example test could look like

To execute test run

In output you should see

Code coverage jest supports generation of code coverage reports.
package.jsonTo use code coverage with TypeScript you need to add another configuration line to .

To run tests with generation of coverage report run

If used with our sample fizz buzz you should see

coverage/lcov-report/index.htmljest also created folder coverage which contains coverage report in various formats, including user friendly html report in 

Section 30.3: Alsatian
Alsatian is a unit testing framework written in TypeScript. It allows for usage of Test Cases, and outputs TAPcompliant markup.
To use it, install it from npm:

Then set up a test file:

For a full documentation, see Alsatian's GitHub repo.
Section 30.4: chai-immutable plugin
1. Install from npm chai, chai-immutable, and ts-node

2. Install types for mocha and chai

3. Write simple test file:

4. Run it in the console:
mocha --compilers ts:ts-node/register,tsx:ts-node/register 'test/**/*.spec.@(ts|tsx)'

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
2426021684Chapters 1, 14 and 16ABabinChapter 9Alec HansenChapter 1Alex FilatovChapters 22 and 27AlmondChapter 14AminadavChapter 9AronChapter 9artemChapters 9, 14 and 25BlackusChapter 14bnielandChapter 28br4dChapter 6BrunoLMChapters 1, 17 and 22BrutusChapter 14ChanceMChapter 1Cobus KrugerChapter 9danvkChapters 1, 2 and 11dimitrisliChapter 5dublicatorChapter 14EquimanChapter 7FentonChapters 3 and 18Florian HämmerleChapter 5FylaxChapters 1, 3 and 28goenningChapter 28hansmaadChapters 7 and 10HarryChapter 14irakli khitarishviliChapters 17 and 26islandman93Chapters 1, 6, 9, 14 and 26James MongerChapters 7, 27 and 30JKillianChapters 11 and 14Joel DayChapter 14John RuddellChapter 22Joshua BreedenChapters 1 and 9JuliënChapters 3 and 28Justin NilesChapter 7k0pernikusChapters 1 and 27Kevin MontroseChapters 5, 12 and 19Kewin DousseChapter 22KnottytOmoChapters 1, 10 and 14Kuba BeránekChapter 1LekhnathChapter 1leonidvChapter 30lilezekChapter 23MaguChapters 3, 27 and 28Matt LishmanChapter 1Matthew HarwoodChapter 30MikhailChapters 1 and 3mlekoChapters 1, 15, 22, 27 and 30
muetzerichChapter 6Muhammad AwaisChapter 10Paul BoutesChapter 9PeoplewareChapter 29RahulChapters 20 and 21Rajab ShakirovChapters 14 and 26RationalDevChapters 1 and 3Remo H. JansenChapter 8RobinChapter 7Roman M. KossChapter 24Roy DictusChapter 1Saiful AzadChapters 1 and 9SamChapter 1samAlvinChapter 1SilentLupinChapter 6Slava ShpitalnyChapters 6, 9, 10 and 14smnbbrvChapter 5Stefan ReinChapter 24SunnyokChapter 9TaytayChapter 10Udlei NatiChapter 4user3893988Chapter 28vashishthChapter 13Wasabi FanChapter 1
You may also like







GoalKicker.com - TypeScript Notes for Professionals	1

GoalKicker.com - TypeScript Notes for Professionals	1

GoalKicker.com - TypeScript Notes for Professionals	1







