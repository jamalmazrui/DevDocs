

Contents
About	1
Chapter 1: Getting started with Ruby on Rails	2
Section 1.1: Creating a Ruby on Rails Application	2
Section 1.2: Create a new Rails app with your choice of database and including the RSpec Testing Tool 	4
Section 1.3: Generating A Controller	4
Section 1.4: Installing Rails	5
Section 1.5: Create a new Rails app with a non-standard database adapter	7
Section 1.6: Creating Rails APIs in JSON	7
Section 1.7: Generate a Resource with Scaolds	8
Chapter 2: Routing	10
Section 2.1: Resource Routing (Basic)	10
Section 2.2: Constraints	11
Section 2.3: Scoping routes	13
Section 2.4: Concerns	15
Section 2.5: Root route	16
Section 2.6: Split routes into multiple files	16
Section 2.7: Additional RESTful actions	17
Section 2.8: Member and Collection Routes	17
Section 2.9: Mount another application	18
Section 2.10: Nested Routes	18
Section 2.11: Redirection	19
Section 2.12: Redirects and Wildcard Routes	19
Section 2.13: Scope available locales	19
Section 2.14: URL params with a period	20
Chapter 3: ActiveRecord	21
Section 3.1: Creating a Model via generator	21
Section 3.2: Introduction to Callbacks	21
Section 3.3: Creating a Model manually	22
Section 3.4: Manually Testing Your Models	23
Section 3.5: Creating A Migration	23
Section 3.6: Create a Join Table using Migrations	24
Section 3.7: Using a model instance to update a row	25
Chapter 4: Views	26
Section 4.1: Structure	26
Section 4.2: Partials	26
Section 4.3: AssetTagHelper	27
Section 4.4: Replace HTML code in Views	28
Section 4.5: HAML - an alternative way to use in your views	29
Chapter 5: ActiveRecord Migrations	31
Section 5.1: Adding multiple columns to a table	31
Section 5.2: Add a reference column to a table	31
Section 5.3: Rollback migrations	32
Section 5.4: Add a new column with an index	32
Section 5.5: Run specific migration	33
Section 5.6: Redo migrations	33
Section 5.7: Add a new column to a table	33
Section 5.8: Remove an existing column from a table	34
Section 5.9: Add column with default value	34
Section 5.10: Running migrations in dierent environments	35
Section 5.11: Create a new table	35
Section 5.12: Running migrations	35
Section 5.13: Change an existing column's type	35
Section 5.14: Create a hstore column	36
Section 5.15: Create a join table	36
Section 5.16: Add a self reference	37
Section 5.17: Create an array column	37
Section 5.18: Add an unique column to a table	37
Section 5.19: Checking migration status	38
Section 5.20: Changing Tables	38
Section 5.21: Adding a NOT NULL constraint to existing data	38
Section 5.22: Forbid null values	39
Chapter 6: Rails Best Practices	40
Section 6.1: Fat Model, Skinny Controller	40
Section 6.2: Domain Objects (No More Fat Models)	40
Section 6.3: Beware of default_scope	42
Section 6.4: Convention Over Configuration	44
Section 6.5: Don't Repeat Yourself (DRY)	45
Section 6.6: You Ain't Gonna Need it (YAGNI)	45
Chapter 7: Naming Conventions	47
Section 7.1: Controllers	47
Section 7.2: Models	47
Section 7.3: Filenames and autoloading	47
Section 7.4: Views and Layouts	48
Section 7.5: Models class from Controller name	48
Chapter 8: ActionCable	49
Section 8.1: User Authentication	49
Section 8.2: [Basic] Server Side	49
Section 8.3: [Basic] Client Side (Coeescript)	49
Chapter 9: ActiveModel	51
Section 9.1: Using ActiveModel::Validations	51
Chapter 10: User Authentication in Rails	52
Section 10.1: Authentication using Devise	52
Section 10.2: Devise Controller Filters & Helpers	52
Section 10.3: Omniauth	53
Section 10.4: has_secure_password	53
Section 10.5: has_secure_token	53
Chapter 11: ActiveRecord Associations	55
Section 11.1: Polymorphic association	55
Section 11.2: Self-Referential Association	55
Section 11.3: belongs_to	56
Section 11.4: has_one	56
Section 11.5: has_many	56
Section 11.6: The has_many :through association	57
Section 11.7: The has_one :through association	57
Section 11.8: The has_and_belongs_to_many association	58
Chapter 12: ActiveRecord Validations	59
Section 12.1: Validating length of an attribute	59
Section 12.2: Validates format of an attribute	59
Section 12.3: Validating presence of an attribute	59
Section 12.4: Custom validations	60
Section 12.5: Validates inclusion of an attribute	60
Section 12.6: Grouping validation	61
Section 12.7: Validating numericality of an attribute	61
Section 12.8: Validate uniqueness of an attribute	62
Section 12.9: Skipping Validations	62
Section 12.10: Confirmation of attribute	62
Section 12.11: Using :on option	63
Section 12.12: Conditional validation	63
Chapter 13: ActiveRecord Query Interface	64
Section 13.1: .where	64
Section 13.2: .where with an array	64
Section 13.3: Scopes	65
Section 13.4: Get first and last record	66
Section 13.5: Ordering	67
Section 13.6: where.not	67
Section 13.7: Includes	68
Section 13.8: Joins	68
Section 13.9: Limit and Oset	69
Section 13.10: .find_by	69
Section 13.11: .delete_all	69
Section 13.12: ActiveRecord case insensitive search	69
Section 13.13: .group and .count	70
Section 13.14: .distinct (or .uniq)	70
Chapter 14: ActionMailer	71
Section 14.1: Basic Mailer	71
Section 14.2: Generating a new mailer	72
Section 14.3: ActionMailer Interceptor	72
Section 14.4: Adding Attachments	72
Section 14.5: ActionMailer Callbacks	73
Section 14.6: Generate a Scheduled Newsletter	73
Chapter 15: Rails generate commands	79
Section 15.1: Rails Generate Controller	79
Section 15.2: Rails Generate Migration	80
Section 15.3: Rails Generate Scaold	80
Section 15.4: Rails Generate Model	81
Chapter 16: Configuration	82
Section 16.1: Custom configuration	82
Chapter 17: I18n - Internationalization	84
Section 17.1: I18n with arguments	84
Section 17.2: Translating ActiveRecord model attributes	84
Section 17.3: Get locale from HTTP request	86
Section 17.4: Pluralization	87
Section 17.5: Set locale through requests	87
Section 17.6: Use I18n with HTML Tags and Symbols	89
Section 17.7: Use I18n in views	89
Chapter 18: Using GoogleMaps with Rails	91
Section 18.1: Add the google maps javascript tag to the layout header	91
Section 18.2: Geocode the model	91
Section 18.3: Show addresses on a google map in the profile view	92
Section 18.4: Set the markers on the map with javascript	93
Section 18.5: Initialize the map using a coee script class	94
Section 18.6: Initialize the map markers using a coee script class	94
Section 18.7: Auto-zoom a map using a coee script class	95
Section 18.8: Exposing the model properties as json	96
Chapter 19: File Uploads	98
Section 19.1: Single file upload using Carrierwave	98
Section 19.2: Nested model - multiple uploads	98
Chapter 20: Caching	100
Section 20.1: Russian Doll Caching	100
Section 20.2: SQL Caching	100
Section 20.3: Action caching	101
Section 20.4: Fragment caching	101
Section 20.5: Page caching	102
Section 20.6: HTTP caching	102
Chapter 21: ActionController	103
Section 21.1: Basic REST Controller	103
Section 21.2: Filters	104
Section 21.3: Generating a controller	106
Section 21.4: Rescuing ActiveRecord::RecordNotFound with redirect_to	107
Section 21.5: Display error pages for exceptions	107
Section 21.6: Output JSON instead of HTML	108
Section 21.7: Controllers (Basic)	108
Section 21.8: Parameters	109
Section 21.9: Filtering parameters (Basic)	109
Section 21.10: Redirecting	110
Section 21.11: Using Views	110
Chapter 22: Configuration	112
Section 22.1: Rails General Configuration	112
Section 22.2: Configuring assets	112
Section 22.3: Configuring generators	112
Section 22.4: Environments in Rails	113
Section 22.5: Database Configuration	113
Chapter 23: Safe Constantize	115
Section 23.1: Successful safe_constantize	115
Section 23.2: Unsuccessful safe_constantize	115
Chapter 24: Rails 5	116
Section 24.1: How to install Ruby on Rails 5 on RVM	116
Section 24.2: Creating a Ruby on Rails 5 API	116
Chapter 25: Authorization with CanCan	119
Section 25.1: Getting started with CanCan	119
Section 25.2: Handling large number of abilities	119
Section 25.3: Defining abilities	121
Section 25.4: Quickly test an ability	121
Chapter 26: Mongoid	123
Section 26.1: Fields	123
Section 26.2: Installation	123
Section 26.3: Creating a Model	123
Section 26.4: Classic Associations	124
Section 26.5: Embedded Associations	124
Section 26.6: Database Calls	125
Chapter 27: Gems	126
Section 27.1: Gemfiles	126
Section 27.2: What is a gem?	126
Section 27.3: Bundler	127
Section 27.4: Gemsets	127
Chapter 28: Change default timezone	130
Section 28.1: Change Rails timezone AND have Active Record store times in this timezone	130
Section 28.2: Change Rails timezone, but continue to have Active Record save in the database in UTC 	130
Chapter 29: Asset Pipeline	131
Section 29.1: Manifest Files and Directives	131
Section 29.2: Rake tasks	132
Section 29.3: Basic Usage	132
Chapter 30: Upgrading Rails	133
Section 30.1: Upgrading from Rails 4.2 to Rails 5.0	133
Chapter 31: ActiveRecord Locking	135
Section 31.1: Optimistic Locking	135
Section 31.2: Pessimistic Locking	135
Chapter 32: Debugging	136
Section 32.1: Debugging Rails Application	136
Section 32.2: Debugging Ruby on Rails Quickly + Beginner advice	136
Section 32.3: Debugging ruby-on-rails application with pry	138
Section 32.4: Debugging in your IDE	139
Chapter 33: Configure Angular with Rails	141
Section 33.1: Angular with Rails 101	141
Chapter 34: Rails logger	144
Section 34.1: Rails.logger	144
Chapter 35: Prawn PDF	145
Section 35.1: Advanced Example	145
Section 35.2: Basic Example	146
Chapter 36: Rails API	147
Section 36.1: Creating an API-only application	147
Chapter 37: Deploying a Rails app on Heroku	148
Section 37.1: Deploying your application	148
Section 37.2: Managing Production and staging environments for a Heroku	150
Chapter 38: ActiveSupport	152
Section 38.1: Core Extensions: String Access	152
Section 38.2: Core Extensions: String to Date/Time Conversion	153
Section 38.3: Core Extensions: String Exclusion	153
Section 38.4: Core Extensions: String Filters	153
Section 38.5: Core Extensions: String Inflection	155
Chapter 39: Form Helpers	158
Section 39.1: Creating a search form	158
Section 39.2: Dropdown	158
Section 39.3: Helpers for form elements	158
Chapter 40: ActiveRecord Transactions	161
Section 40.1: Basic example	161
Section 40.2: Dierent ActiveRecord classes in a single transaction	161
Section 40.3: Multiple database connections	161
Section 40.4: save and destroy are automatically wrapped in a transaction	161
Section 40.5: Callbacks	162
Section 40.6: Rolling back a transaction	162
Chapter 41: RSpec and Ruby on Rails	163
Section 41.1: Installing RSpec	163
Chapter 42: Decorator pattern	164
Section 42.1: Decorating a Model using Draper	164
Section 42.2: Decorating a Model using SimpleDelegator	164
Chapter 43: Elasticsearch	166
Section 43.1: Searchkick	166
Section 43.2: Installation and testing	166
Section 43.3: Setting up tools for development	167
Section 43.4: Introduction	167
Chapter 44: React with Rails using react-rails gem	168
Section 44.1: React installation for Rails using rails_react gem	168
Section 44.2: Using react_rails within your application	168
Section 44.3: Rendering & mounting	169
Chapter 45: Rails Cookbook - Advanced rails recipes/learnings and coding techniques 	170
Section 45.1: Playing with Tables using rails console	170
Section 45.2: Rails methods - returning boolean values	170
Section 45.3: Handling the error - undefined method `where' for #<Array:0x000000071923f8>	171
Chapter 46: Multipurpose ActiveRecord columns	172
Section 46.1: Saving an object	172
Section 46.2: How To	172
Chapter 47: Class Organization	173
Section 47.1: Service Class	173
Section 47.2: Model Class	175
Chapter 48: Shallow Routing	176
Section 48.1: Use of shallow	176
Chapter 49: Model states: AASM	177
Section 49.1: Basic state with AASM	177
Chapter 50: Rails 5 API Authetication	179
Section 50.1: Authentication with Rails authenticate_with_http_token	179
Chapter 51: Testing Rails Applications	180
Section 51.1: Unit Test	180
Section 51.2: Request Test	180
Chapter 52: Active Jobs	181
Section 52.1: Introduction	181
Section 52.2: Sample Job	181
Section 52.3: Creating an Active Job via the generator	181
Chapter 53: Rails frameworks over the years	182
Section 53.1: How to find what frameworks are available in the current version of Rails?	182
Section 53.2: Rails versions in Rails 1.x	182
Section 53.3: Rails frameworks in Rails 2.x	182
Section 53.4: Rails frameworks in Rails 3.x	182
Chapter 54: Nested form in Ruby on Rails	183
Section 54.1: How to setup a nested form in Ruby on Rails	183
Chapter 55: Factory Girl	184
Section 55.1: Defining Factories	184
Chapter 56: Import whole CSV files from specific folder	185
Section 56.1: Uploads CSV from console command	185
Chapter 57: Tools for Ruby on Rails code optimization and cleanup	186
Section 57.1: If you want to keep your code maintainable, secure and optimized, look at some gems forcode optimization and cleanup :	186
Chapter 58: ActiveJob	187
Section 58.1: Create the Job	187
Section 58.2: Enqueue the Job	187
Chapter 59: Active Model Serializers	188
Section 59.1: Using a serializer	188
Chapter 60: Rails Engine - Modular Rails	189
Section 60.1: Create a modular app	189
Chapter 61: Single Table Inheritance	192
Section 61.1: Basic example	192
Section 61.2: Custom inheritance column	192
Section 61.3: Rails model with type column and without STI	193
Chapter 62: ActiveRecord Transactions	194
Section 62.1: Getting Started with Active Record Transactions	194
Chapter 63: Turbolinks	195
Section 63.1: Binding to turbolink's concept of a page load	195
Section 63.2: Disable turbolinks on specific links	195
Section 63.3: Understanding Application Visits	196
Section 63.4: Cancelling visits before they begin	196
Section 63.5: Persisting elements across page loads	197
Chapter 64: Friendly ID	198
Section 64.1: Rails Quickstart	198
Chapter 65: Securely storing authentication keys	200
Section 65.1: Storing authentication keys with Figaro	200
Chapter 66: Authenticate Api using Devise	201
Section 66.1: Getting Started	201
Chapter 67: Integrating React.js with Rails Using Hyperloop	203
Section 67.1: Adding a simple react component (written in ruby) to your Rails app	203
Section 67.2: Callbacks	203
Section 67.3: Declaring component parameters (props)	203
Section 67.4: HTML Tags	204
Section 67.5: Event Handlers	204
Section 67.6: States	204
Chapter 68: Change a default Rails application enviornment	205
Section 68.1: Running on a local machine	205
Section 68.2: Running on a server	205
Chapter 69: Rails -Engines	206
Section 69.1: Famous examples are	206
Chapter 70: Adding an Amazon RDS to your rails application	207
Section 70.1: Consider we are connecting MYSQL RDS with your rails application	207
Chapter 71: Payment feature in rails	208
Section 71.1: How to integrate with Stripe	208
Chapter 72: Rails on docker	210
Section 72.1: Docker and docker-compose	210
Appendix A: Reserved Words	212
Section A.1: Reserved Word List	212
Credits	218
You may also like	222


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from:
https://goalkicker.com/RubyOnRailsBook
This Ruby(r) on Rails Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Ruby(r) on Rails group(s) or company(s) nor Stack Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Ruby on Rails
Version Release Date
5.1.5	2018-02-14
5.1.2	2017-06-26
5.0	2016-06-30
4.2	2014-12-19
4.1	2014-04-08
4.0	2013-06-25
3.2	2012-01-20
3.1	2011-08-31
3.0	2010-08-29
2.3	2009-03-16
2.0	2007-12-07
1.2	2007-01-19
1.1	2006-03-28
1.0	2005-12-13
Section 1.1: Creating a Ruby on Rails Application
This example assumes Ruby and Ruby on Rails have already been installed properly. If not, you can find how to do it in Section 1.4: Installing Rails.
Open up a command line or terminal. To generate a new rails application, use rails new command followed by the name of your application:

If you want to create your Rails application with a specific Rails version then you can specify it at the time of generating the application. To do that, use rails _version_ new followed by the application name:

This will create a Rails application called MyApp in a my_app directory and install the gem dependencies that are already mentioned in Gemfile using bundle install.
To switch to your newly created app's directory, use the cd command, which stands for change directory.

The my_app directory has a number of auto-generated files and folders that make up the structure of a Rails application. Following is a list of files and folders that are created by default:
	File/Folder	Purpose
app/	Contains the controllers, models, views, helpers, mailers and assets for your application.
                    Contains the rails script that starts your app and can contain other scripts you use to setup, bin/
update, deploy or run your application.
config/	Configure your application's routes, database, and more.
config.ruRack configuration for Rack based servers used to start the application.db/Contains your current database schema, as well as the database migrations.These files allow you to specify what gem dependencies are needed for your Rails
Gemfile Gemfile.lock
application. These files are used by the Bundler gem.
lib/Extended modules for your application.log/Application log files.public/The only folder seen by the world as-is. Contains static files and compiled assets.RakefileThis file locates and loads tasks that can be run from the command line. The task definitions are defined throughout the components of Rails.README.mdThis is a brief instruction manual for your application. You should edit this file to tell others what your application does, how to set it up etctest/Unit tests, fixtures, and other test apparatus.temp/Temporary files (like cache and pid files).vendor/A place for all third-party code. In a typical Rails application this includes vendored gems.database.ymlNow you need to create a database from your  file:

Now that we've created the database, we need to run migrations to set up the tables:

To start the application, we need to fire up the server:

By default, rails will start the application at port 3000. To start the application with different port number, we need to fire up the server like,

If you navigate to http://localhost:3000 in your browser, you will see a Rails welcome page, showing that your application is now running.
If it throws an error, there may be several possible problems:
config/database.ymlThere is a problem with the 
You have dependencies in your Gemfile that have not been installed.
You have pending migrations. Run rails db:migrate
In case you move to the previous migration rails db:rollback
config/database.ymlIf that still throws an error, then you should check your 
Section 1.2: Create a new Rails app with your choice of database and including the RSpec Testing Tool
Rails uses sqlite3 as the default database, but you can generate a new rails application with a database of your choice. Just add the -d option followed by the name of the database.

This is a (non-exhaustive) list of available database options:
mysql oracle postgresql sqlite3 frontbase ibm_db
sqlserver jdbcmysql jdbcsqlite3 jdbcpostgresql jdbc
The -T command indicate to skip the installation of minitest. To install an alternative test suite like RSpec, edit the Gemfile and add

Then launch the following command from the console:

Section 1.3: Generating A Controller
To generate a controller (for example Posts), navigate to your project directory from a command line or terminal, and run:

You can shorten this code by replacing generate with g, for example:

If you open up the newly generated app/controllers/posts_controller.rb you'll see a controller with no actions:

It's possible to create default methods for the controller by passing in controller name arguments.

parent_module/controller_nameTo create a controller within a module, specify the controller name as a path like .
For example:

This will generate the following files:
Controller: app/controllers/credit_cards_controller.rb
Test:       test/controllers/credit_cards_controller_test.rb
Views:      app/views/credit_cards/debit.html.erb [...etc]
Helper:     app/helpers/credit_cards_helper.rb
A controller is simply a class that is defined to inherit from ApplicationController.
It's inside this class that you'll define methods that will become the actions for this controller.
Section 1.4: Installing Rails
Installing Rails on Ubuntu
On a clean ubuntu, installation of Rails should be straight forward
Upgrading ubuntu packages

Install Ruby and Rails dependecies
sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyamldev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
Installing ruby version manager. In this case the easy one is using rbenv
git clone https://github.com/rbenv/rbenv.git ~/.rbenv echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bashrc echo 'eval "$(rbenv init -)"' >> ~/.bashrc
Installing Ruby Build
 git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bashrc Restart Shell

Install ruby


Installing rails

Installing Rails on Windows Step 1: Installing Ruby
We need Ruby programming language installed. We can use a precompiled version of Ruby called RubyInstaller.
Download and run Ruby Installer from rubyinstaller.org.
Run the installer. Check "Add Ruby executables to your PATH", then install.
ruby To access Ruby, go to the Windows menu, click All Programs, scroll down to Ruby, and click "Start Command Prompt with Ruby". A command prompt terminal will open. If you type -v and press Enter, you should see the Ruby version number that you installed.
Step 2: Ruby Development Kit
After installing Ruby, we can try to install Rails. But some of the libraries Rails depends on need some build tools in order to be compiled, and Windows lacks those tools by default. You can identify this if you see an error while attempting to install Rails Gem::InstallError: The '[gem name]' native gem requires installed build tools. To fix this, we need to install the Ruby Development Kit.
Download the DevKit Run the installer.
We need to specify a folder where we're going to permanently install the DevKit. I recommend installing it in the root of your hard drive, at C:\RubyDevKit. (Don't use spaces in the directory name.)
Now we need to make the DevKit tools available to Ruby.
cd C:\RubyDevKitruby dk.rb initIn your command prompt, change to the DevKit directory.  or whatever directory you installed it in.
ruby dk.rb installWe need to run a Ruby script to initialize the DevKit setup. Type . Now we'll tell that same script to add the DevKit to our Ruby installation. Type .
The DevKit should now be available for your Ruby tools to use when installing new libraries.
Step 3: Rails
Now we can install Rails. Rails comes as a Ruby gem. In your command prompt, type: gem install rails
Once you press Enter, the gem program will download and install that version of the Rails gem, along with all the other gems Rails depends on.
Step 4: Node.js
Some libraries that Rails depends on require a JavaScript runtime to be installed. Let's install Node.js so that those libraries work properly.
 Download the Node.js installer from here.
node-v4.4.7.pkgWhen the download completes, visit your downloads folder, and run the  installer.
Read the full license agreement, accept the terms, and click Next through the rest of the wizard, leaving everything at the default.
A window may pop up asking if you want to allow the app to make changes to your computer. Click "Yes". When the installation is complete, you'll need to restart your computer so Rails can access Node.js.
Once your computer restarts, don't forget to go to the Windows menu, click "All Programs", scroll down to Ruby, and click "Start Command Prompt with Ruby".
Section 1.5: Create a new Rails app with a non-standard database adapter
Rails is shipped by default with ActiveRecord, an ORM (Object Relational Mapping) derived from the pattern with the same name.
As an ORM, it is built to handle relational-mapping, and more precisely by handling SQL requests for you, hence the limitation to SQL databases only.
However, you can still create a Rails app with another database management system:
1. simply create your app without active-record

2. add your own database management system in Gemfile

3. bundle install and follow the installation steps from the desired database.
In this example, mongoid is an object mapping for MongoDB and - as many other database gems built for rails - it also inherits from ActiveModel the same way as ActiveRecord, which provides a common interface for many features such as validations, callbacks, translations, etc.
Other database adapters include, but are not limited to :
datamapper
sequel-rails
Section 1.6: Creating Rails APIs in JSON
This example assumes that you have experience in creating Rails applications.
To create an API-only app in Rails 5, run

Add active_model_serializers in Gemfile

install bundle in terminal

Set the ActiveModelSerializer adapter to use :json_api
# config/initializers/active_model_serializer.rb
ActiveModelSerializers.config.adapter = :json_api
Mime::Type.register "application/json", :json, %w( text/x-json application/jsonrequest application/vnd.api+json )
Generate a new scaffold for your resource

This will generate the following files:
Controller: app/controllers/tasks_controller.rb

Section 1.7: Generate a Resource with Scaolds
From guides.rubyonrails.org:
Instead of generating a model directly . . . let's set up a scaffold. A scaffold in Rails is a full set of model, database migration for that model, controller to manipulate it, views to view and manipulate the data, and a test suite for each of the above.
Here's an example of scaffolding a resource called Task with a string name and a text description:

This will generate the following files:

example to delete files generated by scaffold for the resource called Task


Chapter 2: Routing
The Rails router recognizes URLs and dispatches them to a controller's action. It can also generate paths and URLs, avoiding the need to hardcode strings in your views.
Section 2.1: Resource Routing (Basic)
config/routes.rbRoutes are defined in . They are often defined as a group of related routes, using the resources or resource methods.
resources :users creates the following seven routes, all mapping to actions of UsersController:
get       '/users',          to: 'users#index' post      '/users',          to: 'users#create' get       '/users/new',      to: 'users#new' get       '/users/:id/edit', to: 'users#edit' get       '/users/:id',      to: 'users#show' patch/put '/users/:id',      to: 'users#update' delete    '/users/:id',      to: 'users#destroy'
app/controllers/users_controller.rbAction names are shown after the # in the to parameter above. Methods with those same names must be defined in  as follows:

You can limit the actions that gets generated with only or except:

You can view all the routes of your application at any given time by running:
Version < 5.0
$ rake routes
Version ≥ 5.0
# OR
$ rails routes
To see only the routes that map to a particular controller:
Version < 5.0
$ rake routes -c static_pages static_pages_home    GET    /static_pages/home(.:format)    static_pages#home static_pages_help    GET    /static_pages/help(.:format)    static_pages#help
Version ≥ 5.0

You can search through routes using the -g option. This shows any route that partially matches the helper method name, the URL path or the HTTP verb:
Version < 5.0

Version ≥ 5.0

Additionally, when running rails server in development mode, you can access a web page that shows all your
<hostname>/rails/info/routesroutes with a search filter, matched in priority from top to bottom, at . It will look like this:
	Helper	HTTP Verb	Path	Controller#ActionPath / Url[ Path Match ]users_path	GET/users(.:format)	users#indexPOST/users(.:format)	users#createnew_user_path GET/users/new(.:format)	users#newedit_user_path GET/users/:id/edit(.:format) users#edituser_path	GET/users/:id(.:format)	users#showPATCH/users/:id(.:format)	users#updatePUT/users/:id(.:format)	users#updateDELETE/users/:id(.:format)	users#destroyroutes.rbRoutes can be declared available for only members (not collections) using the method resource instead of resources in . With resource, an index route is not created by default, but only when explicitly asking for one like this:

Section 2.2: Constraints
You can filter what routes are available using constraints.
There are several ways to use constraints including:
segment constraints, request based constraints advanced constraints
For example, a requested based constraint to only allow a specific IP address to access a route:

See other similar examples ActionDispatch::Routing::Mapper::Scoping.
If you want to do something more complex you can use more advanced constraints and create a class to wrap the logic:

One form, several submit buttons
You can also use the value of the submit tags of a form as a constraint to route to a different action. If you have a form with multiple submit buttons (eg "preview" and "submit"), you could capture this constraint directly in your routes.rb, instead of writing javascript to change the form destination URL. For example with the commit_param_routing gem you can take advantage of rails submit_tag
Rails submit_tag first parameter lets you change the value of your form commit parameter


Section 2.3: Scoping routes
Rails provides several ways to organize your routes.
Scope by URL:

This generates the following routes
get       '/admin/dashboard',          to: 'administration#dashboard' post      '/admin/employees',          to: 'employees#create' get       '/admin/employees/new',      to: 'employees#new' get       '/admin/employees/:id/edit', to: 'employees#edit' get       '/admin/employees/:id',      to: 'employees#show' patch/put '/admin/employees/:id',      to: 'employees#update' delete    '/admin/employees/:id',      to: 'employees#destroy'
It may make more sense, on the server side, to keep some views in a different subfolder, to separate admin views from user views. Scope by module

module looks for the controller files under the subfolder of the given name
get       '/dashboard',          to: 'admin/administration#dashboard'
You can rename the path helpers prefix by adding an as parameter


Rails provides a convenient way to do all the above, using the namespace method. The following declarations are equivalent

Scope by controller

This generate these routes
get       '/dashboard',          to: 'management#dashboard' get       '/performance',        to: 'management#performance'
Shallow Nesting
Resource routes accept a :shallow option that helps to shorten URLs where possible. Resources shouldn't be nested more than one level deep. One way to avoid this is by creating shallow routes. The goal is to leave off parent collection URL segments where they are not needed. The end result is that the only nested routes generated are for the :index , :create , and :new actions. The rest are kept in their own shallow URL context. There are two options for scope to custom shallow routes:



alternatively coded as follows (if you're block-happy):

The resulting routes are:
Prefix	Verb	URI Pattern
bid_comments	GET	/bids/:bid_id/comments(.:format)
	POST	/bids/:bid_id/comments(.:format)
new_bid_comment GET	/bids/:bid_id/comments/new(.:format)edit_commentGET	/comments/:id/edit(.:format)commentGET	/comments/:id(.:format)
PATCH /comments/:id(.:format)
PUT	/comments/:id(.:format)
DELETE /comments/:id(.:format)auction_bidsGET	/auctions/:auction_id/bids(.:format)
POST	/auctions/:auction_id/bids(.:format)new_auction_bidGET	/auctions/:auction_id/bids/new(.:format)edit_bidGET	/bids/:id/edit(.:format)bidGET	/bids/:id(.:format)
PATCH /bids/:id(.:format)
PUT	/bids/:id(.:format)
DELETE /bids/:id(.:format)auctionsGET	/auctions(.:format)
POST	/auctions(.:format)new_auctionGET	/auctions/new(.:format)edit_auctionGET	/auctions/:id/edit(.:format)auctionGET	/auctions/:id(.:format)
PATCH /auctions/:id(.:format)
PUT	/auctions/:id(.:format)DELETE /auctions/:id(.:format)
If you analyze the routes generated carefully, you'll notice that the nested parts of the URL are only included when they are needed to determine what data to display.
Section 2.4: Concerns
routes.rbTo avoid repetition in nested routes, concerns provide a great way of sharing common resources that are reusable. To create a concern use the method concern within the  file. The method expects a symbol and block:


While not creating any routes itself, this code allows using the :concerns attribute on a resource. The simplest example would be:

The equivalent nested resource would look like this:

This would build, for example, the following routes:

For concerns to be meaningful, there must be multiple resources that utilize the concern. Additional resources could use any of the following syntax to call the concern:

Section 2.5: Root route
You can add a home page route to your app with the root method.

And in terminal, rake routes (rails routes in Rails 5) will produce:

Because the homepage is usually the most important route, and routes are prioritized in the order they appear, the root route should usually be the first in your routes file.
Section 2.6: Split routes into multiple files
If your routes file is overwhelmingly big, you can put your routes in multiple files and include each of the files with Ruby's require_relative method:
config/routes.rb:

config/routes/api_routes.rb:

Section 2.7: Additional RESTful actions
resources :photos do member do get 'preview' end collection do get 'dashboard' end end This creates the following routes in addition to default 7 RESTful routes:
get       '/photos/:id/preview',          to: 'photos#preview' get       '/photos/dashboards',           to: 'photos#dashboard'
If you want to do this for single lines, you can use: resources :photos do get 'preview', on: :member get 'dashboard', on: :collection end
newYou can also add an action to the / path:
resources :photos do get 'preview', on: :new end Which will create:

Be mindful when adding actions to your RESTful routes, probably you are missing another resource!
Section 2.8: Member and Collection Routes
Defining a member block inside a resource creates a route that can act on an individual member of that resourcebased route:

This generates the following member route:

Collection routes allow for creating routes that can act on a collection of resource objects:

This generates the following collection route:

An alternate syntax:

Section 2.9: Mount another application
mount is used to mount another application (basically rack application) or rails engines to be used within the current application syntax:

Now you can access above mounted application using route helper some_rack_app_path or some_rack_app_url.
But if you want to rename this helper name you can do it as:

This will generate the myapp_path and myapp_url helpers which can be used to navigate to this mounted app.
Section 2.10: Nested Routes
routes.rbIf you want to add nested routes you can write the following code in  file.

This will generate following routes:
     admin_employees GET      /admins/:admin_id/employees(.:format)            employees#index                      POST     /admins/:admin_id/employees(.:format)            employees#create   new_admin_employee GET      /admins/:admin_id/employees/new(.:format)        employees#new  edit_admin_employee GET      /admins/:admin_id/employees/:id/edit(.:format)   employees#edit       admin_employee GET      /admins/:admin_id/employees/:id(.:format)        employees#show                      PATCH    /admins/:admin_id/employees/:id(.:format)        employees#update
                     PUT      /admins/:admin_id/employees/:id(.:format)        employees#update                      DELETE   /admins/:admin_id/employees/:id(.:format)        employees#destroy               admins GET      /admins(.:format)                                admins#index                      POST     /admins(.:format)                                admins#create            new_admin GET      /admins/new(.:format)                            admins#new           edit_admin GET      /admins/:id/edit(.:format)                       admins#edit                admin GET      /admins/:id(.:format)                            admins#show                      PATCH    /admins/:id(.:format)                            admins#update
                     PUT      /admins/:id(.:format)                            admins#update
                     DELETE   /admins/:id(.:format)                            admins#destroy
Section 2.11: Redirection
You can perform redirection in Rails routes as follows:
Version ≥ 4.0

Version < 4.0

You can also redirect all unknown routes to a given path:
Version ≥ 4.0

Version < 4.0

Section 2.12: Redirects and Wildcard Routes
If you want to provide a URL out of convenience for your user but map it directly to another one you're already using. Use a redirect:

hereWell, that got interesting fast. The basic principle here is to just use the #redirect method to send one route to another route. If your route is quite simple, it's a really straightforward method. But if you want to also send the original parameters, you need to do a bit of gymnastics by capturing the parameter inside %{}. Note the single quotes around everything.
In the example above, we've also renamed the route for convenience by using an alias with the :as parameter. This lets us use that name in methods like the #_path helpers. Again, test out your $ rake routes with questions.
Section 2.13: Scope available locales
If your application is available in different languages, you usually show the current locale in the URL.

I18n.available_localesYour root will be accessible via the locales defined in .
Section 2.14: URL params with a period
If you want to support a url parameter more complex than an id number, you may run into trouble with the parser if the value contains a period. Anything following a period will be assumed to be a format (i.e. json, xml).
You can work around this limitation by using a constraint to broaden the accepted input.
For example, if you want to reference a user record by email address in the url:


Chapter 3: ActiveRecord
Section 3.1: Creating a Model via generator
Ruby on Rails provides a model generator you can use to create ActiveRecord models. Simply use rails generate model and provide the model name.

app/modelsIn addition to the model file in , the generator will also create:
test/models/user_test.rbtest/fixtures/users.ymldb/migrate/XXX_create_users.rbthe Test in the Fixtures in the database Migration in 
You can also generate some fields for the model when generating it.
$ rails g model user email:string sign_in_count:integer birthday:date
This will create the columns email, sign_in_count and birthday in your database, with the appropriate types.
Section 3.2: Introduction to Callbacks
A callback is a method that gets called at specific moments of an object's lifecycle (right before or after creation, deletion, update, validation, saving or loading from the database).
For instance, say you have a listing that expires within 30 days of creation.
One way to do that is like this:

All of the available methods for callbacks are as follows, in the same order that they are called during the operation of each object:
Creating an Object
before_validation after_validation before_save around_save before_create around_create after_create after_save  after_commit/after_rollback
Updating an Object
before_validation after_validation before_save around_save before_update around_update after_update after_save
after_commit/after_rollback
Destroying an Object
before_destroy around_destroy after_destroy
after_commit/after_rollback
NOTE: after_save runs both on create and update, but always after the more specific callbacks after_create and after_update, no matter the order in which the macro calls were executed.
Section 3.3: Creating a Model manually
While using scaffolding is a fast and easy if you are new to Rails or you are creating a new application, later it can be useful just to do it on your own ato avoid the need to go through the scaffold-generated code to slim it down (remove unused parts, etc.).
app/modelsCreating a model can be as simple as creating a file under .
The most simple model, in ActiveRecord, is a class that extends ActiveRecord::Base.

app/modelsModel files are stored in /, and the file name corresponds to the singular name of the class:

The class will inherit all the ActiveRecord features: query methods, validations, callbacks, etc.

Note: Make sure that the table for the corresponding model exists. If not, you can create the table by creating a Migration
You can generate a model and it's migration by terminal from the following command
rails g model column_name1:data_type1, column_name2:data_type2, ... and can also assign foreign key(relationship) to the model by following command

Section 3.4: Manually Testing Your Models
Testing your Active Record models through your command line interface is simple. Navigate to the app directory in your terminal and type in rails console to start the Rails console. From here, you can run active record methods on your database.
name:string column and email:stringFor example, if you had a database schema with a Users table having a , you could run:

Then, to show that record, you could run:

Or if this is your first or only record, you could simply get the first record by running:

Section 3.5: Creating A Migration
Add/remove fields in existing tables Create a migration by running:

This will create a migration that adds a title column to a categories table:

Similarly, you can generate a migration to remove a column: rails generate migration
RemoveTitleFromCategories title:string
This will create a migration that removes a title column from the categories table:

stringWhile, strictly speaking, specifying type (: in this case) is not necessary for removing a column, it's helpful, since it provides the information necessary for rolling it back.
Create a table
Create a migration by running:

Rails recognizes the intent to create a table from the Create prefix, the rest of the migration name will be used as a table name. The given example generates the following:

Notice that the creation command didn't specify types of columns and the default string was used. Create a join table
Create a migration by running: rails g CreateJoinTableParticipation user:references group:references
Rails detects the intent to create a join table by finding JoinTable in migration name. Everything else is determined from the names of the fields you give after the name.

Uncomment the necessary index statements and delete the rest.
Precedence
Notice that the example migration name CreateJoinTableParticipation matches the rule for table creation: it has a Create prefix. But it did not generate a simple create_table. This is because migration generator (source code) uses a first match of the following list:
Add|Remove)<ignored>(To|From)<table_name<ignored>JoinTable<ignoredCreate<table_name(>
>
>
Section 3.6: Create a Join Table using Migrations
Specially useful for has_and_belongs_to_many relation, you can manually create a join table using the create_table method. Suppose you have two models Tags and Proyects, and you'd like to associate them using a has_and_belongs_to_many relation. You need a join table to associate instances of both classes.

The actual name of the table needs to follow this convention: the model which alphabetically precedes the other must go first. Project preceds Tags so the name of the table is projects_tags.
id: falseAlso since the purpose of this table is to route the association between the instances of two models, the actual id of every record in this table is not necessary. You specify this by passing 
Finally, as is convention in Rails, the table name must be the compound plural form of the individual models, but the column of the table must be in singular form.
Section 3.7: Using a model instance to update a row
Let's say you have a User model

id = Now to update the first_name and last_name of a user with 1, you can write the following code.

Calling update will attempt to update the given attributes in a single transaction, returning true if successful and false if not.
Chapter 4: Views
Section 4.1: Structure
As Rails follows the MVC pattern Views are where your "templates" are for your actions.
articles_controller.rbLet's say you have a controller . For this controller you would have a folder in views called
app/views/articles:

This structure allows you to have a folder for each controller. When calling an action in your controller the appropriate view will be rendered automatically.

Section 4.2: Partials
Partial templates (partials) are a way of breaking the rendering process into more manageable chunks. Partials allow you to extract pieces of code from your templates to separate files and also reuse them throughout your templates.
_form.html.erbTo create a partial, create a new file that begins with an underscore: 
<%= render "form" %To render a partial as part of a view, use the render method within the view: >
Note, the underscore is left out when rendering
A partial has to be rendered using its path if located in a different folder
To pass a variable into the partial as a local variable, use this notation:
<%= render :partial => 'form', locals: { post: @post } %>
Partials are also useful when you need to reuse exactly the same code (DRY philosophy).
<head> code, create a partial named _html_header.html.erb, enter your <head<%= render 'html_header' %For example, to reuse > code to be reused, and render the partial whenever needed by: >.
Object Partials
<%= render @post %posts/postviews/posts/_post.html.erbObjects that respond to to_partial_path can also be rendered, as in >. By default, for ActiveRecord models, this will be something like , so by actually rendering @post, the file  will be rendered.
<%= render @post %A local named post will be automatically assigned. In the end, > is a short hand for <%= render
'posts/post', post: @post %>.
<%= render @posts %Collections of objects that respond to to_partial_path can also be provided, such as >. Each item will be rendered consecutively.
Global Partials
views/applicationTo create a global partial that can be used anywhere without referencing its exact path, the partial has to be located in the  path. The previous example has been modified below to illustrate this feature.
app/views/application/_html_header.html.erbFor example, this is a path to a global partial :
<%= render 'html_header' %To render this global partial anywhere, use >
Section 4.3: AssetTagHelper
To let rails automatically and correctly link assets (css/js/images) in most cases you want to use built in helpers.
(Official documentation)
Image helpers image_path
app/assets/imagesThis returns the path to an image asset in .

image_url
app/assets/imagesThis returns the full URL to an image asset in .

image_tag
<img src="" />Use this helper if you want to include an -tag with the source set. image_tag("icon.png") # => <img src="/assets/icon.png" alt="Icon" />
JavaScript helpers javascript_include_tag
If you want to include a JavaScript-file in your view. javascript_include_tag "application" # => <script src="/assets/application.js"></script>
javascript_path
This returns the path of your JavaScript-file.

javascript_url
This returns the full URL of your JavaScript-file. javascript_url "application" # => http://www.example.com/assets/application.js
Stylesheet helpers stylesheet_link_tag
If you want to include a CSS-file in your view.
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
stylesheet_path
This returns the path of you stylesheet asset.

stylesheet_url
This returns the full URL of you stylesheet asset. stylesheet_url "application" # => http://www.example.com/assets/application.css
Example usage
When creating a new rails app you will automatically have two of these helpers in
app/views/layouts/application.html.erb <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %> <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %> This outputs:

Section 4.4: Replace HTML code in Views
If you ever wanted to determine the html content to be printed on a page during run time then, rails has a very good solution for that. It has something called the content_for which allows us to pass a block to a rails view. Please check the below example,
Declare content_for

Section 4.5: HAML - an alternative way to use in your views
HAML (HTML abstraction markup language) is a beautiful and elegant way to describe and design the HTML of your views. Instead of opening- and closing tags, HAML uses indentation for the structure of your pages. Basically, if something should be placed within another element, you just indent it by using one tab stop. Tabs and white space are important in HAML, so be sure that you always use the same amount of tabs.
Examples:

And in HAML:

You see, the structure of the layout is much clearer than using HTML and ERB.
Installation
Just install the gem using

and add the gem to the Gemfile

something.html.erbFor using HAML instead of HTML/ERB, just replace the file extensions of your views from  to
something.html.haml.
Quick tipps
Common elements like divs can be written in a short way
HTML

HAML

HAML, shorthand

Attributes
HTML

HAML

Inserting ruby code
You can insert ruby code with the = and - signs.

Code starting with = will be executed and embedded into the document.
Code starting with - will be executed, but not inserted into the document.
Full documentation
HAML is very easy to start with, but is also very complex, so that I'll recommend reading the documentation.
Chapter 5: ActiveRecord Migrations
Column type	Description
:primary_key Primary key
:string	Shorter string datatype. Allows limit option for maximum number of characters.
:text	Longer amount of text. Allows limit option for maximum number of bytes.
:integer	Integer. Allows limit option for maximum number of bytes.
:bigintLarger integer:float	Float
:decimalDecimal number with variable precision. Allows precision and scale options.:numericAllows precision and scale options.:datetimeDateTime object for dates/times.:timeTime object for times.:dateDate object for dates.:binaryBinary data. Allows limit option for maximum number of bytes.:booleanBooleanSection 5.1: Adding multiple columns to a table
To add multiple columns to a table, separate field:type pairs with spaces when using rails generate migration command.
The general syntax is: rails generate migration NAME [field[:type][:index] field[:type][:index]] [options] For example, the following will add name, salary and email fields to the users table: rails generate migration AddDetailsToUsers name:string salary:decimal email:string Which generates the following migration:

Section 5.2: Add a reference column to a table
To add a reference to a team to the users table, run this command:

This generates the following migration:


That migration will create a team_id column in the users table.
If you want to add an appropriate index and foreign_key on the added column, change the command to rails generate migration AddTeamRefToUsers team:references:index. This will generate the following migration:

If you want to name your reference column other than what Rails auto generates, add the following to your migration: (E.g.: You might want to call the User who created the Post as Author in the Post table)

Section 5.3: Rollback migrations
To rollback the latest migration, either by reverting the change method or by running the down method. Run command:
Version < 5.0 rake db:rollback
Version ≥ 5.0 rails db:rollback
Rollback the last 3 migrations
Version < 5.0 rake db:rollback STEP=3
Version ≥ 5.0

STEP provide the number of migrations to revert.
Rollback all migrations
Version < 5.0

Version ≥ 5.0

Section 5.4: Add a new column with an index
To add a new indexed column email to the users table, run the command:

This will generate the following migration:

Section 5.5: Run specific migration
To run a specific migration up or down, use db:migrate:up or db:migrate:down.
Up a specific migration:
Version < 5.0

Version ≥ 5.0

Down a specific migration:
Version < 5.0

Version ≥ 5.0

The version number in the above commands is the numeric prefix in the migration's filename. For example, to
20160515085959_add_name_to_users.rbmigrate to the migration , you would use 20160515085959 as the version number.
Section 5.6: Redo migrations
You can rollback and then migrate again using the redo command. This is basically a shortcut that combines rollback and migrate tasks.
Run command:


You can use the STEP parameter to go back more than one version.
For example, to go back 3 migrations:
Version < 5.0

Version ≥ 5.0

Section 5.7: Add a new column to a table
To add a new column name to the users table, run the command:

This generates the following migration:

When the migration name is of the form AddXXXToTABLE_NAME followed by list of columns with data types, the generated migration will contain the appropriate add_column statements.
Section 5.8: Remove an existing column from a table
To remove existing column name from users table, run the command:

This will generate the following migration:

When the migration name is of the form RemoveXXXFromYYY followed by list of columns with data types then the generated migration will contain the appropriate remove_column statements.
stringWhile it's not required to specify the data type (e.g. :) as a parameter to remove_column, it is highly recommended. If the data type is not specified, then the migration will not be reversible.
Section 5.9: Add column with default value
The following example adds a column admin to the users table, and gives that column the default value false.

Migrations with defaults might take a long time in large tables with for example PostgreSQL. This is because each row will have to be updated with the default value for the newly added column. To circumvent this (and reduce downtime during deployments), you can split your migration into three steps:
1. Add a add_column-migration similar to the one above, but set no default
2. Deploy and update the column in a rake task or on the console while your app is running. Make sure your application already writes data to that colum for new/updated rows.
3. Add another change_column migration, which then changes the default of that column to the desired default value
Section 5.10: Running migrations in dierent environments
To run migrations in the test environment, run this shell command:

Version ≥ 5.0
Starting in Rails 5.0, you can use rails instead of rake:

Section 5.11: Create a new table
To create a new users table with the columns name and salary, run the command:

This will generate the following migration:

When the migration name is of the form CreateXXX followed by list of columns with data types, then a migration will be generated that creates the table XXX with the listed columns.
Section 5.12: Running migrations
Run command:
Version < 5.0 rake db:migrate
Version ≥ 5.0 rails db:migrate
Specifying target version will run the required migrations (up, down, change) until it has reached the specified version. Here, version number is the numerical prefix on the migration's filename.
Version < 5.0

Version ≥ 5.0

Section 5.13: Change an existing column's type
To modify an existing column in Rails with a migration, run the following command:

db/migrationThis will create a new migration file in  directory (if it doesn't exist already), which will contain the file prefixed with timestamp and migration file name which contains the below content:

Rails Guide - Changing Columns
A longer but safer method
The above code prevents the user from ever rolling back the migration. You can avoid this problem by splitting the change method into separate up and down methods:

Section 5.14: Create a hstore column
Hstore columns can be useful to store settings. They are available in PostgreSQL databases after you enabled the extension.

Section 5.15: Create a join table
To create a join table between students and courses, run the command:

This will generate the following migration:

Section 5.16: Add a self reference
A self reference can be useful to build a hierarchical tree. This can be achieved with add_reference in a migration.

The foreign key column will be pages_id. If you want to decide about the foreign key column name, you have to create the column first and add the reference after.

Section 5.17: Create an array column
An array column is supported by PostgreSQL. Rails will automatically convert a PostgreSQL array to a Ruby array, and vice-versa.
Create a table with an array column:

Add an array column to an existing table:

Add an index for an array column:

Section 5.18: Add an unique column to a table
To add a new unique column email to users, run the following command:

This will create the following migration:

Section 5.19: Checking migration status
We can check the status of migrations by running
Version ≥ 3.0 Version < 5.0 rake db:migrate:status
Version ≥ 5.0 rails db:migrate:status
The output will look like this:

Under the status field, up means the migration has been run and down means that we need to run the migration.
Section 5.20: Changing Tables
If you have created a table with some wrong schema, then the easiest way to change the columns and their properties is change_table. Review the following example:

The above migration changes a table orders. Here is a line-by-line description of the changes:
t.remove :ordered_at1. removes the column ordered_at from the table orders.
t.string :skew_number2. adds a new string-type column named skew_number in the orders table.
t.index :skew_number3. adds an index on the skew_number column in the orders table.
t.rename :location, :state4. renames the location column in the orders table to state.
Section 5.21: Adding a NOT NULL constraint to existing data
NOT NULLSay you want to add a foreign key company_id to the users table, and you want to have a  constraint on it. If you already have data in users, you will have to do this in multiple steps.


Section 5.22: Forbid null values
To forbid null values in your table columns, add the :null parameter to your migration, like this:


Chapter 6: Rails Best Practices
Section 6.1: Fat Model, Skinny Controller
"Fat Model, Skinny Controller" refers to how the M and C parts of MVC ideally work together. Namely, any nonresponse-related logic should go in the model, ideally in a nice, testable method. Meanwhile, the "skinny" controller is simply a nice interface between the view and model.
In practice, this can require a range of different types of refactoring, but it all comes down to one idea: by moving any logic that isn't about the response to the model (instead of the controller), not only have you promoted reuse where possible but you've also made it possible to test your code outside of the context of a request.
Let's look at a simple example. Say you have code like this:

You can change it to this:

Then, you can move the logic to your post model, where it might look like this:
scope :published, ->(timestamp = Time.now) { where('published_at <= ?', timestamp) } scope :unpublished, ->(timestamp = Time.now) { where('published_at IS NULL OR published_at > ?', timestamp) }
Section 6.2: Domain Objects (No More Fat Models)
"Fat Model, Skinny Controller" is a very good first step, but it doesn't scale well once your codebase starts to grow.
Let's think on the Single Responsibility of models. What is the single responsibility of models? Is it to hold business logic? Is it to hold non-response-related logic?
No. Its responsibility is to handle the persistence layer and its abstraction.
Business logic, as well as any non-response-related logic and non-persistence-related logic, should go in domain objects.
Domain objects are classes designed to have only one responsibility in the domain of the problem. Let your classes "Scream Their Architecture" for the problems they solve.
In practice, you should strive towards skinny models, skinny views and skinny controllers. The architecture of your solution shouldn't be influenced by the framework you're choosing.
For example
Let's say you're a marketplace which charges a fixed 15% commission to your customers via Stripe. If you charge a fixed 15% commission, that means that your commission changes depending on the order's amount because Stripe charges 2.9% + 30¢.
amount*0.15 amount*0.029 + 0.30The amount you charge as commission should be: - ().
Don't write this logic in the model:

As soon as you integrate with a new payment method, you won't be able to scale this functionality inside this model.
Also, as soon as you start to integrate more business logic, your Order object will start to lose cohesion.
Prefer domain objects, with the calculation of the commission completely abstracted from the responsibility of persisting orders:


Using domain objects has the following architectural advantages:
it's extremely easy to unit test, as no fixtures or factories are required to instantiate the objects with the logic. works with everything that accepts the message amount. keeps each domain object small, with clearly defined responsibilities, and with higher cohesion. easily scales with new payment methods by addition, not modification. stops the tendency to have an ever-growing User object in each Ruby on Rails application.
I personally like to put domain objects in lib. If you do so, remember to add it to autoload_paths:

app/commandsYou may also prefer to create domain objects more action-oriented, following the Command/Query pattern. In such case, putting these objects in  might be a better place as all app subdirectories are automatically added to the autoload path.
Section 6.3: Beware of default_scope
ActiveRecord includes default_scope, to automatically scope a model by default.

The above code will serve posts which are already published when you perform any query on the model.

That scope, while innocuous-looking, has multiple hidden side-effect that you may not want. default_scope and order
Since you declared an order in the default_scope, calling order on Post will be added as additional orders instead of overriding the default.

This is probably not the behavior you wanted; you can override this by excluding the order from the scope first
Post.except(:order).order(updated_at: :desc)
 SELECT "posts".* FROM "posts" WHERE "posts"."published" = 't' ORDER BY "posts"."updated_at" DESC default_scope and model initialization
As with any other ActiveRecord::Relation, default_scope will alter the default state of models initialized from it.
where(published: trueIn the above example, Post has ) set by default, and so new models from Post will also have it set.

default_scope can nominally be cleared by calling unscoped first, but this also has side-effects. Take, for example, an STI model:

By default, queries against Post will be scoped to type columns containing 'Post'. But unscoped will clear this along with your own default_scope, so if you use unscoped you have to remember to account for this as well.

unscoped and Model Associations

By getting an individual User, you can see the posts related to it:

But you want to clear the default_scope from the posts relation, so you use unscoped

This wipes out the user_id condition as well as the default_scope.
An example use-case for default_scope
Despite all of that, there are situations where using default_scope is justifiable.
Consider a multi-tenant system where multiple subdomains are served from the same application but with isolated data. One way to achieve this isolation is through default_scope. The downsides in other cases become upsides here.

Tenant.current_idAll you need to do is set  to something early in the request, and any table that contains tenant_id will automatically become scoped without any additional code. Instantiating records will automatically inherit the tenant id they were created under.
The important thing about this use-case is that the scope is set once per request, and it doesn't change. The only cases you will need unscoped here are special cases like background workers that run outside of a request scope.
Section 6.4: Convention Over Configuration
In Rails, you find yourself looking at controllers, views, and models for your database.
To reduce the need for heavy configuration, Rails implements rules to ease up working with the application. You may define your own rules but for the beginning (and for later on) it's a good idea to stick to conventions that Rails offers.
These conventions will speed up development, keep your code concise and readable, and allow you an easy navigation inside your application.
Conventions also lower the barriers to entry for beginners. There are so many conventions in Rails that a beginner doesn't even need to know about, but can just benefit from in ignorance. It's possible to create great applications without knowing why everything is the way it is.
For Example
If you have a database table called orders with the primary key id, the matching model is called order and the controller that handles all the logic is named orders_controller. The view is split in different actions: if the controller has a new and edit action, there is also a new and edit view.
For Example
To create an app you simply run rails new app_name. This will generate roughly 70 files and folders that comprise the infrastructure and foundation for your Rails app.
It includes:
Folders to hold your models (database layer), controllers, and views
Folders to hold unit tests for your application
Folders to hold your web assets like Javascript and CSS files
Default files for HTTP 400 responses (i.e. file not found)
     Many others
  Section 6.5: Don't Repeat Yourself (DRY)
To help to maintain clean code, Rails follows the principle of DRY.
It involves whenever possible, re-using as much code as possible rather than duplicating similar code in multiple places (for example, using partials). This reduces errors, keeps your code clean and enforces the principle of writing code once and then reusing it. It is also easier and more efficient to update code in one place than to update multiple parts of the same code. Thus making your code more modular and robust.
Also Fat Model, Skinny Controller is DRY, because you write the code in your model and in the controller only do the call, like:

This also helps lead to an API driven structure where internal methods are hidden and changes are achieved through passing parameters in an API fashion.
Section 6.6: You Ain't Gonna Need it (YAGNI)
If you can say "YAGNI" (You ain't gonna need it) about a feature, you better not implement it. There can be a lot of development time saved through focussing onto simplicity. Implementing such features anyway can lead to problems:
Problems Overengineering
If a product is more complicated than it has to be, it is over engineered. Usually these "not yet used" features will never be used in the intended way they were written and have to be refactored if they ever get used. Premature optimisations, especially performance optimisations, often lead to design decisions which will be proved wrong in the future.
Code Bloat
Code Bloat means unnecessary complicated code. This can occur for example by abstraction, redundancy or incorrect application of design patterns. The code base becomes difficult to understand, confusing and expensive to maintain.
Feature Creep
Feature Creep refers to adding new features that go beyond the core functionality of the product and lead to an unnecessarily high complexity of the product.
Long development time
The time which could be used to develop necessary features is spent to develop unnecessary features. The product takes longer to deliver.
Solutions KISS - Keep it simple, stupid
According to KISS, most systems work the best if they are designed simple. Simplicity should be a primary design goal to reduce complexity. It can be achieved by following the "Single Responsibility Principle" for example.
YAGNI - You Ain't Gonna Need it
Less is more. Think about every feature, is it really needed? If you can think of any way that it's YAGNI, leave it away. It's better to develop it when it's needed.
Continuous Refactoring
The product is being improved steadily. With refactoring, we can make sure that the product is being done according to best practice and does not degenerate to a patch work.

Chapter 7: Naming Conventions
Section 7.1: Controllers
Controller class names are pluralized. The reason is the controller controls multiple instances of object instance.
orders_controller.rb in the /app/controllersFor Example: OrdersController would be the controller for an orders table. Rails will then look for the class definition in a file called  directory.
For Example: PostsController would be the controller for a posts table.
If the controller class name has multiple capitalized words, the table name is assumed to have underscores between these words.
For Example: If a controller is named PendingOrdersController then assumed file name for this controller will be
pending_orders_controller.rb. Section 7.2: Models
The model is named using the class naming convention of unbroken MixedCase and is always the singular of the table name.
For Example: If a table was named orders, the associated model would be named Order
For Example: If a table was named posts, the associated model would be named Post
order.rb in the /app/modelsRails will then look for the class definition in a file called  directory.
If the model class name has multiple capitalized words, the table name is assumed to have underscores between these words.
For Example: If a model is named BlogPost then assumed table name will be blog_posts.
Section 7.3: Filenames and autoloading
Rails files - and Ruby files in general - should be named with lower_snake_case filenames. E.g.

is the file that contains the ApplicationController class definition. Note that while PascalCase is used for class and module names, the files in which they reside should still be lower_snake_case.
Consistent naming is important since Rails makes use of auto-loading files as needed, and uses "inflection" to transform between different naming styles, such as transforming application_controller to ApplicationController and back again.
blog_post.rbE.g. if Rails sees that the BlogPost class doesn't exist (hasn't been loaded yet), it'll look for a file named  and attempt to load that file.
blog_post.rbIt is therefore also important to name files for what they contain, since the autoloader expects file names to match content. If, for instance, the  instead contains a class named just Post, you'll see a LoadError:
Expected [some path]/blog_post.rb to define BlogPost.
app/somethingIf you add a dir under / (e.g. /models/products/), and
 want to namespace modules and classes inside new dir then you don't need to do anything and it'll be
app/models/products/ you would need to wrap your class inloaded itself. For example, in module
Products`.
config.autoload_paths += %W( #{config.root}/app/models/products ) to your application.rb don't want to namespace modules and classes inside my new dir then you have to add  to autoload.
One more thing to pay attention to (especially if English is not your first language) is the fact that Rails accounts for irregular plural nouns in English. So if you have model named "Foot" the corresponding controller needs to be called "FeetController" rather than "FootsController" if you want rails "magic" routing (and many more such features) to work.
Section 7.4: Views and Layouts
When a controller action is rendered, Rails will attempt to find a matching layout and view based on the name of the controller.
app/viewsViews and layouts are placed in the  directory.
PeopleController#indexGiven a request to the  action, Rails will search for:
app/views/layoutsindex.html.erb in app/views/peopleindex_new.html.erbPeopleController#index action like render 'index_new'render 'index_new', layout:the layout called people in / (or application if no match is found)
a view called / by default
if you wish to render other file called  you have to write code for that in
we can set different layouts for every action by writing 
       'your_layout_name'
   Section 7.5: Models class from Controller name
You can get a Model class from a Controller name this way (context is Controller class):

Chapter 8: ActionCable
Section 8.1: User Authentication

Section 8.2: [Basic] Server Side

Section 8.3: [Basic] Client Side (Coeescript)


app/assets/javascripts/application.js # usually generated like this

app/assets/javascripts/cable.js # usually generated like this


Chapter 9: ActiveModel
Section 9.1: Using ActiveModel::Validations
You can validate any object, even plain ruby.


Chapter 10: User Authentication in Rails
Devise is a very powerful gem, it allows you to sign up, sign in and sign out options just after installing. Moreover user can add authentications and restrictions to its applications. Devise also come with its own views, if user wants to use. A user can also customize sign up and sign in forms according to its need and requirement. It should be noted that Devise recommends that you implement your own login if you're new to rails.
Section 10.1: Authentication using Devise
Add gem to the Gemfile:
gem 'devise'
Then run the bundle install command.
Use command $ rails generate devise:install to generate required configuration file.
Set up the default URL options for the Devise mailer in each environment In development environment add this line:
config/environments/development.rb config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } to your 
config/environments/production.rbsimilarly in production this edit  file and add
config.action_mailer.default_url_options = { host: 'your-site-url'}
Then create a model using:$ rails generate devise USER Where USER is the class name for which you want to implement authentication.
Finally, run: rake db:migrate and you are all set.
Custom views
If you need to configure your views, you can use the rails generate devise:views generator that will copy all views to your application. Then you can edit them as desired.
config.scoped_viewsIf you have more than one Devise model in your application (for example User and Admin), you will notice that Devise uses the same views for all models. Devise offers an easy way to customize views. Set 
= true inside the config/initializers/devise.rb file.
You can also use the generator to create scoped views: rails generate devise:views users
rails generate devise:views -v registrations confirmationsIf you would like to generate only a few sets of views, such as the ones for the registerable and confirmable module use the -v flag: 
Section 10.2: Devise Controller Filters & Helpers
To set up a controller with user authentication using devise, add this before_action: (assuming your devise model is 'User'):
before_action :authenticate_user!
To verify if a user is signed in, use the following helper: user_signed_in?
For the current signed-in user, use this helper: current_user
You can access the session for this scope: user_session
     Note that if your Devise model is called Member instead of User, replace user above with member
  Section 10.3: Omniauth
First choose your auth strategy and add it to your Gemfile. You can find a list of strategies here: https://github.com/intridea/omniauth/wiki/List-of-Strategies
 gem 'omniauth-github', :github => 'intridea/omniauth-github' gem 'omniauth-openid', :github => 'intridea/omniauth-openid' You can add this to your rails middleware like so:

auth/:providerBy default, OmniAuth will add / to your routes and you can start by using these paths.
auth/failureBy default, if there is a failure, omniauth will redirect to /
Section 10.4: has_secure_password
Create User Model
rails generate model User email:string password_digest:string
Add has_secure_password module to User model class User < ActiveRecord::Base has_secure_password end
Now you can create a new user with password
user = User.new email: 'bob@bob.com', password: 'Password1', password_confirmation: 'Password1'
Verify password with authenticate method

Section 10.5: has_secure_token
Create User Model


Now when you create a new user a token and auth_token are automatically generated

You can update the tokens using regenerate_token and regenerate_auth_token


Chapter 11: ActiveRecord Associations
Section 11.1: Polymorphic association
This type of association allows an ActiveRecord model to belong to more than one kind of model record. Common example:

Without this association, you'd have all these foreign keys in your Address table but you only would ever have a value for one of them because an address, in this scenario, can only belong to one entity (Human or Company). Here is what it would look like:

Section 11.2: Self-Referential Association
Self-referential association is used to associate a model with itself. The most frequent example would be, to manage association between a friend and his follower. ex.

now you can associate models like;

and the other model will look like;

Section 11.3: belongs_to
A belongs_to association sets up a one-to-one connection with another model, so each instance of the declaring model "belongs to" one instance of the other model.
For example, if your application includes users and posts, and each post can be assigned to exactly one user, you'd declare the post model this way:

In your table structure you might then have

Section 11.4: has_one
A has_one association sets up a one-to-one connection with another model, but with different semantics. This association indicates that each instance of a model contains or possesses one instance of another model.
For example, if each user in your application has only one account, you'd declare the user model like this:

In Active Record, when you have a has_one relation, active record ensures that the only one record exists with the foreign key.
Here in our example: In accounts table, there can only be one record with a particular user_id. If you try to associate one more account for the same user, it makes the previous entry's foreign key as null(making it orphan) and creates a new one automatically. It makes the previous entry null even if the save fails for the new entry to maintain consistency.
user = User.first user.build_account(name: "sample") user.save   [Saves it successfully, and creates an entry in accounts table with user_id 1] user.build_account(name: "sample1")  [automatically makes the previous entry's foreign key null] user.save  [creates the new account with name sample 1 and user_id 1]
Section 11.5: has_many
A has_many association indicates a one-to-many connection with another model. This association generally is located on the other side of a belongs_to association.
This association indicates that each instance of the model has zero or more instances of another model.
For example, in an application containing users and posts, the user model could be declared like this:


The table structure of Post would remain the same as in the belongs_to example; in contrast, User would not require any schema changes.
If you want to get the list of all the published posts for the User, then you can add the following (i.e. you can add scopes to your association objects):

Section 11.6: The has_many :through association
has_many :through association is often used to set up a many-to-manyA  connection with another model. This
association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model.
For example, consider a medical practice where patients make appointments to see physicians. The relevant association declarations could look like this:

Section 11.7: The has_one :through association
has_one :through association sets up a one-to-oneA  connection with another model. This association indicates
that the declaring model can be matched with one instance of another model by proceeding through a third model.
For example, if each supplier has one account, and each account is associated with one account history, then the supplier model could look like this:


Section 11.8: The has_and_belongs_to_many association
many-to-manyA has_and_belongs_to_many association creates a direct  connection with another model, with no intervening model.
For example, if your application includes assemblies and parts, with each assembly having many parts and each part appearing in many assemblies, you could declare the models this way:


Chapter 12: ActiveRecord Validations
Section 12.1: Validating length of an attribute

The possible length constraint options are:
in:minimum - The attribute cannot have less than the specified length.
:maximum - The attribute cannot have more than the specified length.
: (or :within) - The attribute length must be included in a given interval. The value for this option must be a range.
 :is - The attribute length must be equal to the given value.
 Section 12.2: Validates format of an attribute
Validate that an attribute's value matches a regular expression using format and the with option.

You can also define a constant and set its value to a regular expression and pass it to the with: option. This might be more convenient for really complex regular expressions

The default error message is is invalid. This can be changed with the :message option. validates :bio, format: { with: /\A\D+\z/, message: "Numbers are not allowed" }
The reverse also replies, and you can specify that a value should not match a regular expression with the without: option
Section 12.3: Validating presence of an attribute
This helper validates that the specified attributes are not empty.

You can use the absence helper to validate that the specified attributes are absent. It uses the present? method to check for nil or empty values.

Note: In case the attribute is a boolean one, you cannot make use of the usual presence validation (the attribute would not be valid for a false value). You can get this done by using an inclusion validation:

Section 12.4: Custom validations
You can add your own validations adding new classes inheriting from ActiveModel::Validator or from ActiveModel::EachValidator. Both methods are similar but they work in a slightly different ways:
ActiveModel::Validator and validates_with
Implement the validate method which takes a record as an argument and performs the validation on it. Then use validates_with with the class on the model.

If you prefer to use your new validator using the common validate method on a single param, create a class inheriting from ActiveModel::EachValidator and implement the validate_each method which takes three

Section 12.5: Validates inclusion of an attribute
inYou can check if a value is included in an array using the inclusion: helper. The : option and its alias, :within show the set of acceptable values.
class Country < ApplicationRecord
  validates :continent, inclusion: { in: %w(Africa Antartica Asia Australia                                             Europe North America South America) } end
To check if a value is not included in an array, use the exclusion: helper

Section 12.6: Grouping validation
Sometimes it is useful to have multiple validations use one condition. It can be easily achieved using with_options.

All validations inside of the with_options block will have automatically passed the condition if: :is_admin?
Section 12.7: Validating numericality of an attribute
This validation restricts the insertion of only numeric values.

Besides :only_integer, this helper also accepts the following options to add constraints to acceptable values:
:greater_than - Specifies the value must be greater than the supplied value. The default error message for this option is "must be greater than %{count}".
:greater_than_or_equal_to - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is "must be greater than or equal to %{count}".
:equal_to - Specifies the value must be equal to the supplied value. The default error message for this option is "must be equal to %{count}".
:less_than - Specifies the value must be less than the supplied value. The default error message for this option is "must be less than %{count}".
:less_than_or_equal_to - Specifies the value must be less than or equal to the supplied value. The default error message for this option is "must be less than or equal to %{count}".
:other_than - Specifies the value must be other than the supplied value. The default error message for this option is "must be other than %{count}".
:odd - Specifies the value must be an odd number if set to true. The default error message for this option is "must be odd".
:even - Specifies the value must be an even number if set to true. The default error message for this option is "must be even".
		By default, numericality doesn't allow nil values. You can use allow_nil: true option to permit it.
Section 12.8: Validate uniqueness of an attribute
This helper validates that the attribute's value is unique right before the object gets saved.

There is a :scope option that you can use to specify one or more attributes that are used to limit the uniqueness check:

There is also a :case_sensitive option that you can use to define whether the uniqueness constraint will be case sensitive or not. This option defaults to true.

Section 12.9: Skipping Validations
Use following methods if you want to skip the validations. These methods will save the object to the database even if it is invalid.
decrement!
decrement_counter increment!
increment_counter toggle! touch update_all update_attribute update_column update_columns update_counters
You can also skip validation while saving by passing validate as an argument to save

Section 12.10: Confirmation of attribute
You should use this when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with _confirmation appended.

Note This check is performed only if email_confirmation is not nil.
To require confirmation, make sure to add a presence check for the confirmation attribute.

Source
Section 12.11: Using :on option
The :on option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save (both when you're creating a new record and when you're updating it).

Section 12.12: Conditional validation
Sometimes you may need to validate record only under certain conditions.

If you conditional is really small, you can use a Proc:

For negative conditional you can use unless:

You can also pass a string, which will be executed via instance_eval:

Chapter 13: ActiveRecord Query Interface
ActiveRecord is the M in MVC which is the layer of the system responsible for representing business data and logic. The technique that connects the rich objects of an application to tables in a relational database management system is Object Relational Mapper(ORM).
ActiveRecord will perform queries on the database for you and is compatible with most database systems.
Regardless of which database system you're using, the ActiveRecord method format will always be the same.
Section 13.1: .where
The where method is available on any ActiveRecord model and allows querying the database for a set of records matching the given criteria.
The where method accepts a hash where the keys correspond to the column names on the table that the model represents.
As a simple example, we will use the following model:

To find all people with the first name of Sven:

To find all people with the first name of Sven and last name of Schrodinger:
people = Person.where(first_name: 'Sven', last_name: 'Schrodinger')
people.to_sql # "SELECT * FROM people WHERE first_name='Sven' AND last_name='Schrodinger'"
In the above example, the sql output shows that records will only be returned if both the first_name and the last_name match. query with OR condition
first_name == 'Bruce' OR last_name == 'Wayne'To find records with 
User.where('first_name = ? or last_name = ?', 'Bruce', 'Wayne')
# SELECT "users".* FROM "users" WHERE (first_name = 'Bruce' or last_name = 'Wayne')
Section 13.2: .where with an array
WHERE column_name INa, b, c, ...The where method on any ActiveRecord model can be used to generate SQL of the form (). This is achieved by passing an array as argument.
As a simple example, we will use the following model:


If the array contains a nil, the SQL will be modified to check if the column is null:
people = Person.where(first_name: ['Mark', 'Mary', nil])
people.to_sql # "SELECT * FROM people WHERE first_name IN ('Mark', 'Mary') OR first_name IS NULL"
Section 13.3: Scopes
Scopes act as predefined filters on ActiveRecord models.
A scope is defined using the scope class method.
As a simple example, we will use the following model:

Scopes can be called directly off the model class:

Scopes can be chained:

The where method and other query type methods can also be chained: mary_smith = Person.with_last_name('Smith').where(first_name: 'Mary')
Behind the scenes, scopes are simply syntactic sugar for a standard class method. For example, these methods are functionally identical:

Default Scope in your model to set a default scope for all operations on the model.
There is one notable difference between the scope method and a class method: scope-defined scopes will always return an ActiveRecord::Relation, even if the logic within returns nil. Class methods, however, have no such safety net and can break chainability if they return something else.
Section 13.4: Get first and last record
Rails have very easy way to get first and last record from database.
To get the first record from users table we need to type following command:

It will generate following sql query:

And will return following record:
#<User:0x007f8a6db09920 id: 1, first_name: foo, created_at: Thu, 16 Jun 2016 21:43:03 UTC +00:00, updated_at: Thu, 16 Jun 2016 21:43:03 UTC +00:00 >
To get the last record from users table we need to type following command:

It will generate following sql query:
 SELECT  `users`.* FROM `users`  ORDER BY `users`.`id` DESC LIMIT 1 And will return following record:
#<User:0x007f8a6db09920 id: 10, first_name: bar, created_at: Thu, 16 Jun 2016 21:43:03 UTC +00:00, updated_at: Thu, 16 Jun 2016 21:43:03 UTC +00:00 >
Passing an integer to first and last method creates a LIMIT query and returns array of objects.

It will generate following sql query.

And

It will generate following sql query.
SELECT  "users".* FROM "users"  ORDER BY "users"."id" DESC LIMIT 5
Section 13.5: Ordering
orderYou can order ActiveRecord query results by using .:

If not specified, ordering will be performed in ascending order. You can specify it by doing:

order. also accepts a string, so you could also do

As the string is raw SQL, you can also specify a table and not only an attribute. Assuming you want to order users according to their role name, you can do this:


Section 13.6: where.not
where.notwhere clauses can be negated using the  syntax:

Supported by ActiveRecord 4.0 and later.
Section 13.7: Includes
ActiveRecord with includes ensures that all of the specified associations are loaded using the minimum possible number of queries. So when querying a table for data with an associated table, both tables are loaded into memory.

Section 13.8: Joins
joins() allows you to join tables to your current model. For ex.

will produce the following SQL query:
 "SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id"" Having table joined, you will have access to it:

joinsPay attention on plural form. If your relation is :has_many, then the () argument should be pluralized. Otherwise, use singular.
Nested joins:
 User.joins(posts: :images).where(images: { caption: 'First post' }) which will produce:
"SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" INNER JOIN
"images" ON "images"."post_id" = "images"."id""
Section 13.9: Limit and Oset
You can use limit to tell the number of records to be fetched, and use offset to tell the number of records to skip before starting to return the records.
For Example

It will generate following sql query.

As offset is not mentioned in above query so it will return first three records.
 User.limit(5).offset(30) #returns 5 records starting from 31th i.e from 31 to 35 It will generate following sql query.

Section 13.10: .find_by
You can find records by any field in your table using find_by.
So, if you have a User model with a first_name attribute you can do:

Mind that find_by doesn't throw any exception by default. If the result is an empty set, it returns nil instead of find.
If the exception is needed may use find_by! that raises an ActiveRecord::RecordNotFound error like find.
Section 13.11: .delete_all
delete_alldelete_allbefore_If you need to delete a lot of records quickly, ActiveRecord gives . method. to be called directly on a model, to delete all records in that table, or a collection. Beware though, as . does not instantiate any object hence does not provide any callback (* and after_destroy don't get triggered).

Section 13.12: ActiveRecord case insensitive search
If you need to search an ActiveRecord model for similar values, you might be tempted to use LIKE or ILIKE but this isn't portable between database engines. Similarly, resorting to always downcasing or upcasing can create performance issues.
You can use ActiveRecord's underlying Arel matches method to do this in a safe way:

Arel will apply the appropriate LIKE or ILIKE construct for the database engine configured.
Section 13.13: .group and .count
We have a Product model and we want to group them by their category.

This will query the database as follows:
SELECT "product"."category" FROM "product" GROUP BY "product"."category"
Make sure that the grouped field is also selected. Grouping is especially useful for counting the occurrence - in this case - of categories.

As the query shows, it will use the database for counting, which is much more efficient, than retrieving all record first and do the counting in the code:
SELECT COUNT("products"."category") AS count_categories, "products"."category" AS products_category
FROM "products" GROUP BY "products"."category"
Section 13.14: .distinct (or .uniq)
distinctIf you want to remove duplicates from a result, you can use .():

This queries the database as follows:

uniq.() has the same effect. With Rails 5.0 it got deprecated and it will be removed from Rails with version 5.1. The reason is, that the word unique doesn't have the same meaning as distinct and it can be misleading. Furthermore distinct is closer to the SQL syntax.
Chapter 14: ActionMailer
Action Mailer allows you to send emails from your application using mailer classes and views. Mailers work very similarly to controllers. They inherit from ActionMailer::Base and live in app/mailers, and they have associated views that appear in app/views.
Section 14.1: Basic Mailer
This example uses four different files:
The User model The User mailer
The html template for the email
The plain-text template for the email
In this case, the user model calls the approved method in the mailer and passes the post that has been approved (the approved method in the model may be called by a callback, from a controller method, etc). Then, the mailer generates the email from either the html or plain-text template using the information from the passed-in post (e.g. the title). By default, the mailer uses the template with the same name as the method in the mailer (which is why both the mailer method and the templates have the name 'approved'). user_mailer.rb   end user.rb

approved.html.erb

approved.text.erb
Congrats <%= @user.name %>! Your post (#<%= @title %>) has been approved! We look forward to your future posts!
Section 14.2: Generating a new mailer
To generate a new mailer, enter the following command

app/mailers/post_mailer.rbThis will generate a blank template file in  named PostMailer

Two layout files will also be generated for the email view, one for the html format and one for the text format.
If you prefer not to use the generator, you can create your own mailers. Make sure they inherit from ActionMailer::Base
Section 14.3: ActionMailer Interceptor
Action Mailer provides hooks into the interceptor methods. These allow you to register classes that are called during the mail delivery life cycle.
An interceptor class must implement the :delivering_email(message) method which will be called before the email is sent, allowing you to make modifications to the email before it hits the delivery agents. Your class should make any needed modifications directly to the passed in Mail::Message instance.
It can be useful for developers to send email to themselves not real users.
Example of registering an actionmailer interceptor:

Section 14.4: Adding Attachments
ActionMailer also allows attaching files.

By default, attachments will be encoded with Base64. To change this, you can add a hash to the attachments method.


You can also add inline attachments

Section 14.5: ActionMailer Callbacks
ActionMailer supports three callbacks
before_action after_action around_action
Provide these in your Mailer class
class UserMailer < ApplicationMailer
  after_action :set_delivery_options, :prevent_delivery_to_guests, :set_business_headers

Section 14.6: Generate a Scheduled Newsletter
Create the Newsletter model:

Create the Newsletter controller:


After that, change the create.html.erb view to the nex name. We will convert this file to and partial view which will be stored inside the Footer. The name will be _form.html.erb.
Change name file from:	To:
app/views/newsletters/create.html.erb app/views/newsletters/_form.html.erb After that set the routes:

Later on, we need to set the form we will use to save each mail:

And after that, insert on the footer:

Now, install the -letter_opener- to can preview email in the default browser instead of sending it. This means you do not need to set up email delivery in your development environment, and you no longer need to worry about accidentally sending a test email to someone else's address.
First add the gem to your development environment and run the bundle command to install it.

Then set the delivery method in the Development Environment:

Now, create an Mailer Structure to manage the whole mailers which we will work. In terminal

And inside the UserMailer, we have to create a method called Newsletter Mailer which will be created to contain inside on the lastest blog post and will be fired with a rake action. We will assume that you had a blog structure created before.

After that, create the Mailer Template:


Since we want to send the email as a separate process, let's create a Rake task to fire off the email. Add a new file called email_tasks.rake to lib/tasks directory of your Rails application:

The send_digest_email: :environment means to load the Rails environment before running the task, so you can access the application classes (like UserMailer) within the task.
Now, running the command rake -T will list the newly created Rake task. Test everything works by running the task and checking whether the email is sent or not.
To test if the mailer method works, run the rake command:

At this point, we have a working rake task which can be scheduled using crontab. So we will install the Whenever Gem which is used to provide a clear syntax for writing and deploying cron jobs.

After that, run the next command to create an initial config/schedule.rb file for you (as long as the config folder is already present in your project).

Now, inside the schedule file, we have to create our CRON JOB and call the mailer method inside determining the CRON JOB to operate some tasks without assistance and in a selected range of time. You can use different types of syntax as is explained on this link.




Now to test the Cron Job was succesfully created we can use the next command to read since terminal, our scheduled job in CRON SYNTAX:

30 4 * * * /bin/bash -l -c 'cd /Users/your_mac_user/Desktop/your_project && RAILS_ENV=production bundle exec rake weekly_newsletter_email --silent'
Now, to run the test in Development Environment, is wise to set the next line on the application.rb principal file to let the application knows where are the models it will use.

Now to let Capistrano V3 save the new Cron Job inside the server and the trigger which will fired up the execution of this task, we have to add the next requirement:

And insert into the deploy file the identifier which CRON JOB will use about the environment and the name of the application.

And ready, after save changes on each file, run the capistrano deploy command:

And now your JOB was created and calendarize to run the Mailer Method which is what i want and in the range of time we set on this files.
Chapter 15: Rails generate commands
Parameter	Details
--help-h/Get help on any generator command
--pretend-p/Pretend Mode: Run generator but will not create or change any files
'field-name' is the name of the column to be created and 'type' is the data-type of column. The
field:type
possible values for 'type' in field:type are given in the Remarks section.
optionsrails generate GENERATOR_NAME [argsUsage: ] [].
Use rails generate to list available generators. Alias: rails g.
Section 15.1: Rails Generate Controller
we can create a new controller with rails g controller command.

The controller generator is expecting parameters in the form of generate controller ControllerName action1 action2.
The following creates a Greetings controller with an action of hello.

You will see the following output

This generates the following
	File	Example
greetings_controller.rbController File
hello.html.erbView File
greetings_controller_test.rbFunctional Test File
greetings_helper.rbView Helper
greetings.coffeeJavaScript File
It will also add routes for each action in routes.rb
Section 15.2: Rails Generate Migration
You can generate a rails migration file from the terminal using the following command: rails generate migration NAME [field[:type][:index] field[:type][:index]] [options]
For a list of all the options supported by the command, you could run the command without any arguments as in rails generate migration.
For example, if you want to add first_name and last_name fields to users table, you can do: rails generate migration AddNamesToUsers last_name:string first_name:string
Rails will create the following migration file:

Now, apply the pending migrations to the database by running the following in the terminal:
Version < 5.0 rake db:migrate
Version ≥ 5.0

Section 15.3: Rails Generate Scaold
DISCLAIMER: Scaffolding is not recommended unless it's for very conventional CRUD apps/testing. This may generate a lot of files(views/models/controllers) that are not needed in your web application thus causing headaches(bad :().
To generate a fully working scaffold for a new object, including model, controller, views, assets, and tests, use the


Then you can run rake db:migrate to set up the database table.
Then you can visit http://localhost:3000/widgets and you'll see a fully functional CRUD scaffold.
Section 15.4: Rails Generate Model
To generate an ActiveRecord model that automagically creates the correct db migrations & boilerplate test files for your model, enter this command

name:string'NAME' is the name of the model. 'field' is the name of the column in the DB table and 'type' is the column type (e.g.  or body:text). Check the Remarks section for a list of supported column types.
To setup foreign keys, add belongs_to:model_name.
So say you wanted to setup a User model that has a username, email and belongs to a School, you would type in the following
 rails generate model User username:string email:string school:belongs_to rails g is shorthand for rails generate. This would produce the same result

Chapter 16: Configuration
Section 16.1: Custom configuration
config/ directory, for example: config/neo4j.ymlCreate a YAML file in the 
neo4j.ymlThe content of  can be something like the below (for simplicity, default is used for all environments):

config/application.rbin :

Now, your custom config is accessible like below:

More info
Rails official API document describes the config_for method as:
		Convenience for loading config/foo.yml for the current Rails env.
If you do not want to use a yaml file
config.You can configure your own code through the Rails configuration object with custom configuration under the x property.
Example

These configuration points are then available through the configuration object:
Rails.configuration.x.payment_processing.schedule # => :daily
Rails.configuration.x.payment_processing.retries  # => 3
Rails.configuration.x.super_debugger              # => true
Rails.configuration.x.super_debugger.not_set      # => nil

Chapter 17: I18n - Internationalization
Section 17.1: I18n with arguments


Section 17.2: Translating ActiveRecord model attributes
globalize gem is a great solution to add translations to your ActiveRecord models. You can install it adding this to your Gemfile:

Rails 5 you will also need to add activemodel-serializers-xmlIf you're using 

Model translations allow you to translate your models' attribute values, for example:

After you defined your model attributes that need to be translated you have to create a translation table, through a migration. globalize provides create_translation_table! and drop_translation_table!.
For this migration you need to use up and down, and not change. Also, in order to run this migration successfully, you have to define the translated attributes in your model first, like shown above. A proper migration for the previous Post model is this:

You may also pass options for specific options, like:

In case you already have any existing data in your needing translation columns, you can easily migrate it to the translations table, by adjusting your migration:

Make sure you drop the translated columns from the parent table after all your data is safely migrated. To automatically remove the translated columns from the parent table after the data migration, add the option


You may also add new fields to a previously created translations table:

Section 17.3: Get locale from HTTP request
Sometimes it can be useful to set your application locale based upon the request IP. You can easily achieve this using Geocoder. Among the many things Geocoder does, it can also tell the location of a request.
First, add Geocoder to your Gemfile

Geocoder adds location and safe_location methods to the standard Rack::Request object so you can easily look up the location of any HTTP request by IP address. You can use this methods in a before_action in your

Beware that this will not work in development and test environments, as things like 0.0.0.0 and localhost are valid valid Internet IP addresses.
Limitations and alternatives
Geocoder is very powerful and flexible, but needs to be configured to work with a geocoding service (see more details); many of which place limits on usage. It's also worth bearing in mind that calling an external service on every request could impact performance.
To address these, it can also be worth considering:
1. An offline solution
Using a gem like GeoIP (see here) allows lookups to happen against a local datafile. There may be a trade-off in terms of accuracy, as these datafiles need to be kept up-to-date.
2. Use CloudFlare
Pages served through CloudFlare have the option of being geocoded transparently, with the country code being added to the header (HTTP_CF_IPCOUNTRY). More detail can be found here.
Section 17.4: Pluralization
You can let I18n handle pluralization for you, just use count argument.
You need to set up your locale file like this:

I18n.And then use the key you just created by passing the count argument to t helper:

Section 17.5: Set locale through requests
In most cases, you may want to set I18n locale. One might want to set the locale for the current session, the current user, or based on a URL parameter This is easily achievable by implementing a before_action in one of your controllers, or in ApplicationController to have it in all of your controllers.

    end
URL-based
The locale param could come from an URL like this

Or

To achieve the latter, you need to edit your routes, adding a scope:

http://yourapplication.com/en/productsBy doing this, visiting  will set your locale to :en. Instead, visiting
http://yourapplication.com/fr/products will set it to :fr. Furthermore, you won't get a routing error when
http://yourapplication.com/productsmissing the :locale param, as visiting  will load the default I18n locale.
Session-based or persistence-based
This assumes the user can click on a button/language flag to change the language. The action can route to a controller that sets the session to the current language (and eventually persist the changes to a database if the user is connected)

If you have very few languages, it may be worth defining them like this instead:


Note: don't forget to add some routes to your change_language actions
Default Locale
Remember that you need to set your application default locale. You can do it by either setting it in
config/application.rb:

config/initializersor by creating an initializer in the  folder:

Section 17.6: Use I18n with HTML Tags and Symbols

And in Views,

Section 17.7: Use I18n in views
Assuming you have this YAML locale file:

and you want to display your title string, you can do this


Chapter 18: Using GoogleMaps with Rails
Section 18.1: Add the google maps javascript tag to the layout header
In order to have google maps work properly with turbolinks, add the javascript tag directly to the layout header rather than including it in a view.

The google_maps_api_script_tag is best defined in a helper.

You can register your application with google and get your api key in the google api console. Google has a short guide how to request an api key for the google maps javascript api.
secrets.ymlThe api key is stored in the file:

config/secrets.yml to your .gitignoreDon't forget to add  file and makre sure you don't commit the api key to the repository.
Section 18.2: Geocode the model
Suppose, your users and/or groups have profiles and you want to display address profile fields on a google map.


A great way to geocode the addresses, i.e. provide longitude and latitude is the geocoder gem.
Add geocoder to your Gemfile and run bundle to install it.

Add database columns for latitude and longitude in order to save the location in the database. This is more efficient than querying the geocoding service every time you need the location. It's faster and you're not hitting the query limit so quickly.

Add the geocoding mechanism to your model. In this example, the address string is stored in the value attribute. Configure the geocoding to perform when the record has changed, and only whan a value is present:

By default, geocoder uses google as lookup service. It has lots of interesting features like distance calculations or proximity search. Fore more information, have a look at the geocoder README.
Section 18.3: Show addresses on a google map in the profile view
On the profile view, show the profile fields of a user or group in a list as well as the address fields on a google map.

The appropriate @profile_fields and @address_fields are set in the controller:

Initialize the map, place the markers, set the zoom and other map settings with javascript.

Section 18.4: Set the markers on the map with javascript
google_mapSuppose, there is a . div, which will become the map, and which has the address fields to show as markers as data attribute.
For example:

document).readyTo make use of the $( event with turbolinks without managing the turbolinks events by hand, use the jquery.turbolinks gem.
If you want to perform some other operations with the map, later, for example filtering or info windows, it's convenient to have the map managed by a coffee script class.

When using several coffee script files, which are namespaced by default, it's convenient to define a global App namespace, which is shared by all coffee script files.
.google_map divs and create one instance of the App.GoogleMapThen, loop through (possibly several)  class for each of them.

Section 18.5: Initialize the map using a coee script class
App.GoogleMapProvided an  coffee script class, the google map can be initialized like this:

To learn more about the possible map_configuration options, have a look at google's MapOptions documentation and their guide to adding control elements.
google.maps.MapFor reference, the class is extensively documented here.
Section 18.6: Initialize the map markers using a coee script class
App.GoogleMap coffee script class and the marker information being stored in the data-addressgoogle_mapProvided an fields attribute of the . div, the map markers can be initialized on the map like this:

To learn more about marker options, have a look at google's MarkerOptions documentation and their guide to markers.
Section 18.7: Auto-zoom a map using a coee script class
App.GoogleMap coffee script class with the google.maps.MapProvided an  stored as @map and the
google.maps.Markers stored as @markers, the map can be auto-zoomed, i.e. adjusted that all markers are visible,
like this: on the map like this:


To learn more about bounds, have a look at google's LatLngBounds documentation.
Section 18.8: Exposing the model properties as json
To display address profile fields as markers on a google map, the address field objects need to be passed as json objects to javascript.
Regular database attributes
When calling to_json on an ApplicationRecord object, the database attributes are automatically exposed.
address_field.as_jsonGiven a ProfileFields::Address model with label, value, longitude and latitude attributes,  results in a Hash, e.g. representation,

which is converted to a json string by to_json:

This is useful because it allows to use label and value later in javascript, for example to show tool tips for the map markers.
Other attributes
Other virtual attributes can be exposed by overriding the as_json method.
For example, to expose a title attribute, include it in the merged as_json hash:

The above example uses super to call the original as_json method, which returns the original attribute hash of the object, and merges it with the required position hash.
To understand the difference between as_json and to_json, have a look at this blog post by jjulian.
Position
To render markers, the google maps api, by default, requires a position hash which has longitude and latitude stored as lng and lat respectively.
This position hash can be created in javascript, later, or here when defining the json representation of the address field:
To provide this position as json attribute of the address field, just override the as_json method on the model.


Chapter 19: File Uploads
Section 19.1: Single file upload using Carrierwave
Start using File Uploads in Rails is quite simple, first thing you have to do is to choice plugin for managing uploads. The most common onces are Carrierwave and Paperclip. Both are similar in functionality and rich in documentation on
Let's have an look on example with simple avatar upload image with Carrierwave
After bundle install Carrierwave, type in console

This will create an config file located at /app/uploaders/profile_uploader.rb
Here you can set up storage (i.e local or cloud), apply extensions for image manipulations (i.e. generting thumbs via MiniMagick) and set server-side extension white list
Next, create new migration with string tipe for user_pic and mount uploader for it in user.rb model.

Next, display an form to upload avatar (may be an edit view for the user)

Make sure to include { multipart: true } in order form can process uploads. Accept is an optional to set client-side extension white-list.
To display an avatar, simply do

Section 19.2: Nested model - multiple uploads
If you want to create multiple uploads, first thing you might want to do is create new model and set up relations
Let's say you want an multiple images for the Product model. Create an new model and make it belongs_to your parent model

accepts_nested_attributes_for is must, because it allow us to create nested form, so we can upload new file, change product name and set price from an single form
Next, create form in a view (edit/create)

Controller is nothing special, if you don't want to create an new one, just make an new one inside your product controller

Display all images in a view

Chapter 20: Caching
Section 20.1: Russian Doll Caching
You may want to nest cached fragments inside other cached fragments. This is called Russian doll caching.
The advantage of Russian doll caching is that if a single product is updated, all the other inner fragments can be reused when regenerating the outer fragment.
As explained in the previous section, a cached file will expire if the value of updated_at changes for a record on which the cached file directly depends. However, this will not expire any cache the fragment is nested within.
For example, take the following view:

Which in turn renders this view:

If any attribute of game is changed, the updated_at value will be set to the current time, thereby expiring the cache.
However, because updated_at will not be changed for the product object, that cache will not be expired and your app will serve stale data. To fix this, we tie the models together with the touch method:

Section 20.2: SQL Caching
Query caching is a Rails feature that caches the result set returned by each query. If Rails encounters the same query again for that request, it will use the cached result set as opposed to running the query against the database again.
For example:


The second time the same query is run against the database, it's not actually going to hit the database. The first time the result is returned from the query it is stored in the query cache (in memory) and the second time it's pulled from memory.
However, it's important to note that query caches are created at the start of an action and destroyed at the end of that action and thus persist only for the duration of the action. If you'd like to store query results in a more persistent fashion, you can with low level caching.
Section 20.3: Action caching
Like page caching, action caching caches the whole page. The difference is that the request hits the Rails stack so before filters are run before the cache is served. It's extracted from Rails to actionpack-action_caching gem.
A common example is caching of an action that requires authentication:

if/:unlessOptions include :expires_in, a custom :cache_path (for actions with multiple routes that should be cached differently) and : to control when the action should be cached.

layout: falseWhen the layout has dynamic content, cache only the action content by passing .
Section 20.4: Fragment caching
Rails.cache, provided by ActiveSupport, can be used to cache any serializable Ruby object across requests.
cache.readTo fetch a value from the cache for a given key, use :

cache.writeUse  to write a value to the cache:

cache.fetchAlternatively, use  to read a value from the cache and optionally write a default if there is no value:


The return value of the passed block will be assigned to the cache under the given key, and then returned.
You can also specify a cache expiry:

Section 20.5: Page caching
You can use the ActionPack page_caching gem to cache individual pages. This stores the result of one dynamic request as a static HTML file, which is served in place of the dynamic request on subsequent requests. The README contains full setup instructions. Once set up, use the caches_page class method in a controller to cache the result of an action:

Use expire_page to force expiration of the cache by deleting the stored HTML file:

The syntax of expire_page mimics that of url_for and friends.
Section 20.6: HTTP caching
Cache-ControlRails >= 3 comes with HTTP caching abilities out of the box. This uses the  and ETag headers to control how long a client or intermediary (such as a CDN) can cache a page.
In a controller action, use expires_in to set the length of caching for that action:

Use expires_now to force immediate expiration of a cached resource on any visiting client or intermediary:

Chapter 21: ActionController
Action Controller is the C in MVC. After the router has determined which controller to use for a request, the controller is responsible for making sense of the request and producing the output.
The controller will receive the request, fetch or save data from a model and use a view to create output. A controller can be thought of as a middleman between models and views. It makes the model data available to the view so it can display to the user, and it saves or updates user data to the model.
Section 21.1: Basic REST Controller


Section 21.2: Filters
Filters are methods that are run "before", "after" or "around" a controller action. They are inherited, so if you set any in your ApplicationController they will be run for every request your application receives.
Before Filter
Before filters are executed before the controller action and can halt the request (and/or redirect). A common use is to verify if a user is logged in:

Before filters are run on requests before the request gets to the controller's action. It can return a response itself and completely bypass the action.
Other common uses of before filters is validating a user's authentication before granting them access to the action designated to handle their request. I've also seen them used to load a resource from the database, check permissions on a resource, or manage redirects under other circumstances.
After Filter
After filters are similar to "before" ones, but as they get executed after the action run they have access the response object that's about to be sent. So in short after filters are run after the action completes. It can modify the response. Most of the time if something is done in an after filter, it can be done in the action itself, but if there is some logic to be run after running any of a set of actions, then an after filter is a good place to do it.
Generally, I've seen after and around filters used for logging.
Around Filter
Around filters may have logic before and after the action being run. It simply yields to the action in whatever place is necessary. Note that it doesn't need to yield to the action and may run without doing so like a before filter.
Around filters are responsible for running their associated actions by yielding, similar to how Rack middlewares work.
Around callbacks wrap the execution of actions. You can write an around callback in two different styles. In the first, the callback is a single chunk of code. That code is called before the action is executed. If the callback code invokes yield, the action is executed. When the action completes, the callback code continues executing. Thus, the code before the yield is like a before action callback and the code after the yield is the after action callback. If the callback code never invokes yield. the action is not run-this is the same as having a before action callback return false.
Here's an example of the around filter:

This will catch exception of any action and put the message in your log. You can use around filters for exception handling, setup and teardown, and a myriad of other cases.
Only and Except
All filters can be applied to specific actions, using :only and :except:

Skipping Filter
All filters (inherited ones too) can also be skipped for some specific actions:

As they're inherited, filters can also be defined in a namespace "parent" controller. Say for example that you have an admin namespace, and you of course want only admin users to be able to access it. You could do something like this:

Beware that in Rails 4.x you could use before_filter along with before_action, but before_filter is currently deprecated in Rails 5.0.0 and will be removed in 5.1.
Section 21.3: Generating a controller
Rails provides a lot of generators, for controllers too of course.
You can generate a new controller by running this command in your app folder

Note: You can also use rails g alias to invoke rails generate
For example, to generate a controller for a Product model, with #index and #show actions you would run

app/controllers/products_controller.rbThis will create the controller in , with both the actions you specified

app/viewsIt will also create a products folder inside /, containing the two templates for your controller's actions
index.html.erb and show.html.erbindex.html.slim and show.html.slim(i.e. , note that the extension may vary according to your template engine, so if you're using slim, for example, generator will create  )
Furthermore, if you specified any actions they will also be added to your routes file

app/helpers/products_helper.rbRails creates a helper file for you, in , and also the assets files in
app/assets/javascripts/products.js and app/assets/stylesheets/products.cssproducts.coffee and products.sass. As for views, the generator changes this behaviour according to what's specified in your Gemfile: i.e., if you're using Coffeescript and Sass in your application, the controller generator will instead generator .
At last, but not least, Rails also generates test files for your controller, your helper and your views.
If you don't want any of these to be created for you can tell Rails to skip them, just prepend any option with
--skip--noor , like this:
rails generate controller products index show --no-assets --no-helper
And the generator will skip both assets and helper
If you need to create a controller for a specific namespace add it in front of NAME:

app/controllers/admin/products_controller.rbThis will create your controller inside 
Rails can also generate a complete RESTful controller for you:
rails generate scaffold_controller MODEL_NAME # available from Rails 4 rails generate scaffold_controller Product
Section 21.4: Rescuing ActiveRecord::RecordNotFound with redirect_to
You can rescue a RecordNotFound exception with a redirect instead of showing an error page:

Section 21.5: Display error pages for exceptions
If you want to display to your users meaningful errors instead of simple "sorry, something went wrong", Rails has a nice utility for the purpose.
app/controllers/application_controller.rbOpen the file  and you should find something like this:


We can now add a rescue_from to recover from specific errors:

It's recommended not to rescue from Exception or StandardError otherwise Rails won't be able to display helpful pages in case of errors.
Section 21.6: Output JSON instead of HTML

In addition you will need the route:

usersThis will respond in two different ways to requests on /:

format.html { render inline: "Hello World" You can omit } if you want to make sure that your route will answer only to JSON requests.
Section 21.7: Controllers (Basic)


This is a basic controller, with the addition of the following route (in routes.rb):

usersWill display the Hello World message in a webpage when you access the URL /
Section 21.8: Parameters
Controllers have access to HTTP parameters (you might know them as ?name=foo in URLs, but Ruby on Rails handle different formats too!) and output different responses based on them. There isn't a way to distinguish between GET and POST parameters, but you shouldn't do that in any case.

As usual our route:

users?name=john and the output will be Hello John, access /users?name=whateverAccess the URL / and the output will be Hello someone
Section 21.9: Filtering parameters (Basic)

You can allow (or reject) some params so that only what you want will pass through and you won't have bad surprises like user setting options not meant to be changed.
users?name=john&sentence=developerVisiting / will display Hello john developer, however visiting
users?name=smith&sentence=spy/ will display Hello smith only, because :sentence is only allowed when you access as john
Section 21.10: Redirecting
Assuming the route:

You can redirect to a different URL using:

You can go back to the previous page the user visited using:

Note that in Rails 5 the syntax for redirecting back is different:

Which will try to redirect to the previous page and in case not possible (the browser is blocking the HTTP_REFERRER header), it will redirect to :fallback_location
Section 21.11: Using Views
Assuming the route:

And the controller:

app/users/index.html.erbThe view  will be rendered. If the view is:

The output will be a webpage with the text: "Hello World"
If you want to render a different view, you can use:

app/views/pages/home.html.erbAnd the file  will be used instead.
You can pass variables to views using controller instance variables:

app/views/users/index.html.erbAnd in the file  you can use @name:

And the output will be: "Hello john"
An important note around the render syntax, you can omit the render syntax entirely, Rails assumes that if you omit it. So:

Can be written instead as:

app/views/users/index.html.erbRails is smart enough to figure out that it must render the file .
Chapter 22: Configuration
Section 22.1: Rails General Configuration
The following configuration options should be called on a Rails::Railtie object
config.action_controller.asset_hostconfig.cache_classesUTFconfig.after_initialize: Takes a block which will be run after rails has initialized the application.
config.asset_host: This sets the host for the assets. This is useful when using a Content Delivery Network. This is shorthand for config.autoload_once_paths: This option accepts an array of paths where Rails autoloads constants. The default value is an empty array config.autoload_paths: This accepts an array of paths where Rails autoloads constants. It defaults to all directories under app config.cache_classes: Determines if classes and modules should be reloaded on each request. In development mode, this defaults to false and in the production and test modes it defaults to true config.action_view.cache_template_loading: This determines if templates should be reloaded on each request. It defaults to the  setting
config.beginning_of_week: This sets the default beginning of week. It requires a valid week day symbol
(:monday) config.cache_store: Choose which cache store to use. Options include :file_store, :memory_store, mem_cache_store or null_store.
config.colorize_logging: This controls whether logging information is colorized config.eager_load: Eager-loads all registered config.encoding: Specifies the application encoding. The default value is -8 config.log_level: Sets the verbosity of the Rails Logger. It defaults to :debug in all environments.
 config.middleware: Use this to configure the application's middleware config.time_zone: This sets the application's default time zone.
 Section 22.2: Configuring assets
The following configuration options can be used for configuring assets
MDconfig.assets.enabled: Determines whether the asset pipeline is enabled. This defaults to true config.assets.raise_runtime_errors: This enables runtime error checking. It's useful for development mode config.assets.compress: Lets assets be compressed. In production mode, this defaults to true config.assets.js_compressor: Specifies which JS compressor to use. Options include :closure, :uglifier and :yui config.assets.paths: Specifies which paths to search for assets.
config.assets.precompile: Lets you choose additional assets to be precompiled when rake assets:precompile is run config.assets.digest: This option allows the use of -5 fingerprints in the asset names. It defaults to true in development mode
 config.assets.compile: Toggles live Sprockets compilation in production mode
 Section 22.3: Configuring generators
config.generatorsRails allows you to configure what generators are used when running rails generate commands. This method,  takes a block


Here are some of the options
	Option	Description	Default
assets	Creates assets when generating scaffold true force_plural	Allows pluralized model names	false helper	Determines whether to generate helpers true integration_tool	Specify integration tool	test_unit javascript_engine	Configures JS engine	:js resource_route	Generates resource route	true stylesheet_engine	Configures stylesheet engine	:cs scaffold_stylesheet Creates CSS upon scaffolding	true test_framework	Specify Test Framework	Minitest template_engine	Configures template engine	:erb
Section 22.4: Environments in Rails
config/environmentsConfiguration files for rails can be found in /. By default rails has 3 environments,
development, production and test. By editing each file you are editing the configuration for that environment only.
config/application.rbRails also has a configuration file in . This is a common configuration file as any settings defined here are overwritten by the config specified in each environment.
Rails.application.configure doYou add or modify configuration options within the  block and configuration options start with config.
Section 22.5: Database Configuration
config/database.ymldatabase.ymlDatabase configuration of a rails project lies in a file . If you create a project using rails new command and don't specify a database engine to be used then rails uses sqlite as the default database. A typical  file with default configuration will look similar to following.


If you want to change the default database while creating a new project you can specify database: rails new
hello_world --database=mysql

Chapter 23: Safe Constantize
Section 23.1: Successful safe_constantize
User is an ActiveRecord or Mongoid class. Replace User with any Rails class in your project (even something like

Section 23.2: Unsuccessful safe_constantize
This example will not work because the string passed in isn't recognized as a constant in the project. Even if you pass in "array", it won't work as it isn't capitalized.

Chapter 24: Rails 5
Section 24.1: How to install Ruby on Rails 5 on RVM
RVM is a great tool to manage your ruby versions and set up your working environment.
Assuming you already have RVM installed, to get the latest version of ruby, which is needed for these examples, open a terminal and run:

Check your ruby version by running:

To install Rails 5, first create a new gemset using the latest ruby version and then install rails:

To check your rails version, run:

Section 24.2: Creating a Ruby on Rails 5 API
To create a new Rails 5 API, open a terminal and run the following command:

The following file structure will be created:


This file structure will be created inside a new folder called app_name. It contains all the assets and code needed to start your project.
Enter the folder and install the dependencies:

You should also start your database. Rails uses SQLite as a default database. To create it, run:

Now run your appplication:

http://localhost:3000When you open your browser at , your shiny new (empty) API should be running!

Chapter 25: Authorization with CanCan
CanCan is a simple authorization strategy for Rails which is decoupled from user roles. All permissions are stored in a single location.
Section 25.1: Getting started with CanCan
CanCan is a a popular authorization library for Ruby on Rails which restricts user access to specific resources. The latest gem (CanCanCan) is a continuation of the dead project CanCan.
Permissions are defined in the Ability class and can be used from controllers, views, helpers, or any other place in the code.
To add authorization support to an app, add the CanCanCan gem to the Gemfile:

Then define the ability class:

Then check authorization using load_and_authorize_resource to load authorized models into the controller:

authorize! to check authorization or raise an exception

can? to check if an object is authorized against a particular action anywhere in the controllers, views, or helpers

Note: This assumes the signed user is provided by the current_user method.
Section 25.2: Handling large number of abilities
Once the number of abilities definitions start to grow in number, it becomes more and more difficult to handle the Ability file.
The first strategy to handle these issue is to move abilities into meaningful methods, as per this example:

Once this class grow large enough, you can try breaking it into different classes to handle the different responsibilities like this:


and then define those classes as:

and so on with Abilities::Authenticated, Abilities::Admin or any other else.
Section 25.3: Defining abilities
Abilities are defined in the Ability class using can and cannot methods. Consider the following commented example for basic reference:

Section 25.4: Quickly test an ability
If you'd like to quickly test if an ability class is giving the correct permissions, you can initialize an ability in the console or on another context with the rails environment loaded, just pass an user instance to test against:

More information: https://github.com/ryanb/cancan/wiki/Testing-Abilities

Chapter 26: Mongoid
Section 26.1: Fields
As per the Mongoid Documentation, there are 16 valid field types:
Array
BigDecimal
Boolean
Date
DateTime
Float
Hash
Integer
BSON::ObjectId
BSON::Binary
Range
Regexp
String
Symbol
Time
TimeWithZone
To add a field (let's call it name and have it be a String), add this to your model file:

To set a default value, just pass in the default option:

Section 26.2: Installation
First, add Mongoid to your Gemfile:

and then run bundle install. Or just run:

After installation, run the generator to create the config file:

(myapp)/config/mongoid.ymlwhich will create the file .
Section 26.3: Creating a Model
Create a model (lets call it User) by running:

app/models/user.rbwhich will generate the file :

This is all you need to have a model (albeit nothing but an id field). Unlike ActiveRecord, there is no migration files. All the database information for the model is contained in the model file.
Timestamps are not automatically included in your model when you generate it. To add created_at and updated_at to your model, add

include Mongoid::Documentto your model underneath  like so:

Section 26.4: Classic Associations
Mongoid allows the classic ActiveRecord associations:
One-to-one: has_one / belongs_to
One-to-many: has_many / belongs_to
Many-to-many: has_and_belongs_to_many
To add an association (lets say the User has_many posts), you can add this to your User model file:

and this to your Post model file:

This will add a user_id field in your Post model, add a user method to your Post class, and add a posts method to your User class.
Section 26.5: Embedded Associations
Mongoid allows Embedded Associations:
One-to-one: embeds_one / embedded_in
One-to-many: embeds_many / embedded_in
To add an association (lets say the User embeds_many addresses), add this to your User file:

and this to your Address model file:

This will embed Address in your User model, adding a addresses method to your User class.
Section 26.6: Database Calls
Mongoid tries to have similar syntax to ActiveRecord when it can. It supports these calls (and many more)
User.first #Gets first user from the database
User.count #Gets the count of all users from the database
User.find(params[:id]) #Returns the user with the id found in params[:id]
User.where(name: "Bob") #Returns a Mongoid::Criteria object that can be chained
                        #with other queries (like another 'where' or an 'any_in')
                        #Does NOT return any objects from database
User.where(name: "Bob").entries #Returns all objects with name "Bob" from database
User.where(:name.in => ['Bob', 'Alice']).entries #Returns all objects with name "Bob" or "Alice" from database
User.any_in(name: ["Bob", "Joe"]).first #Returns the first object with name "Bob" or "Joe"
User.where(:name => 'Bob').exists? # will return true if there is one or more users with name bob

Chapter 27: Gems
Section 27.1: Gemfiles
To start, gemfiles require at least one source, in the form of the URL for a RubyGems server.
Generate a Gemfile with the default rubygems.org source by running bundle init. Use https so your connection to the server will be verified with SSL.

Next, declare the gems that you need, including version numbers.

Most of the version specifiers, like >= 1.0, are self-explanatory. The specifier ~> has a special meaning. ~> 2.0.3 is identical to >= 2.0.3 and < 2.1. ~> 2.1 is identical to >= 2.1 and < 3.0. ~> 2.2.beta will match prerelease versions like
2.2.beta.12.
Git repositories are also valid gem sources, as long as the repo contains one or more valid gems. Specify what to check out with :tag, :branch, or :ref. The default is the master branch.
gem 'nokogiri', :git => 'https://github.com/sparklemotion/nokogiri', :branch => 'master'
If you would like to use an unpacked gem directly from the filesystem, simply set the :path option to the path containing the gem's files.

--withoutBundler.requireDependencies can be placed into groups. Groups can be ignored at install-time (using ) or required all at once (using ).

You can specify the required version of Ruby in the Gemfile with ruby. If the Gemfile is loaded on a different Ruby version, Bundler will raise an exception with an explanation.

Section 27.2: What is a gem?
A gem is the equivalent to a plugin or an extension for the programming language ruby.
To be exact even rails is nothing more than a gem. A lot of gems are built on rails or other gems (they are dependent of said gem) or are standalone.
In your Rails project Gemfile
For your Rails project you have a file called Gemfile. In here you can add gems you want to include and use in your project. Once added you need to install the gem by using bundler (See Bundler section).
Gemfile.lock
Gemfile.lockOnce you have done this, your  will be updated with your newly added gems and their dependencies.
This file locks your used gems so they use that specific version declared in that file.

Gemfile.lockThis example is for the gem devise. In the  the version 4.0.3 is declared, to tell when installing your project on an other machine or on your production server which specified version to use.
Development
Either a single person, a group or a whole community works on and maintains a gem. Work done is usually released after certain issues have been fixed or features have been added.
Usually the releases follow the Semantic Versioning 2.0.0 principle.
Section 27.3: Bundler
The easiest way to handle and manage gems is by using bundler. Bundler is a package manager comparable to bower.
To use bundler you first need to install it.

After you have bundler up and running all you need to do is add gems to your Gemfile and run

in your terminal. This installs your newly added gems to your project. Should an issue arise, you would get a prompt in your terminal.
If you are interested in more details, I suggest you have a look at the docs.
Section 27.4: Gemsets
RVM(Ruby Version ManagerIf you are using ) then using a gemset for each project is a good idea. A gemset is just a container you can use to keep gems separate from each other. Creating a gemset per project allows you to change gems (and gem versions) for one project without breaking all your other projects. Each project need only worry about its own gems.
@global gemset per ruby interpreter. Gems you install to the @global gemsetRVM provides (>= 0.1.8) a  for a given
ruby are available to all other gemsets you create in association with that ruby. This is a good way to allow all of your projects to share the same installed gem for a specific ruby interpreter installation.
Creating gemsets
ruby-2.3.1Suppose you already have  installed and you have selected it using this command:

Now to create gemset for this ruby version:

where the new_gemset is the name of gemset. To see the list of available gemsets for a ruby version:

to list the gems of all ruby versions:

to use a gemset from the list (suppose new_gemset is the gemset I want to use):

you can also specify the ruby version with the gemset if you want to shift to some other ruby version:

to specify a default gemset for a particular ruby version:

to remove all the installed gems from a gemset you can empty it by:

to copy a gemset from one ruby to another you can do it by:

to delete a gemset:

to see the current gemset name:

to install a gem in the global gemset:

Initializing Gemsets during Ruby Installs
When you install a new ruby, RVM not only creates two gemsets (the default, empty gemset and the global gemset), it also uses a set of user-editable files to determine which gems to install.
rvm/gemsets, rvm searchs for global.gems and default.gemsWorking in ~/. using a tree-hierachy based on the
ree-1.8.7-p2010.02ruby string being installed. Using the example of , rvm will check (and import from) the following files:

rvm/gemsets/global.gemsFor example, if you edited ~/. by adding these two lines:

default.gemsglobal.gemsevery time you install a new ruby, these two gems are installed into your global gemset.  and  files are usually overwritten during update of rvm.

Chapter 28: Change default timezone
Section 28.1: Change Rails timezone AND have Active Record store times in this timezone

Section 28.2: Change Rails timezone, but continue to have Active Record save in the database in UTC


Chapter 29: Asset Pipeline
The asset pipeline provides a framework to concatenate and minify or compress JavaScript and CSS assets. It also adds the ability to write these assets in other languages and pre-processors such as CoffeeScript, Sass and ERB. It allows assets in your application to be automatically combined with assets from other gems. For example, jqueryrails includes a copy of jquery.js and enables AJAX features in Rails.
Section 29.1: Manifest Files and Directives
config/initializers/assets.rbIn the assets initalizer () are a few files explicitly defined to be precompiled.
# Precompile additional assets.
# application.coffee, application.scss, and all non-JS/CSS in app/assets folder are already added.
# Rails.application.config.assets.precompile += %w( search.js )
application.coffee and application.scssIn this example the  are so called 'Manifest Files'. This files should be used to include other JavaScript or CSS assets. The following command are available:
require <pathrequire_directory <path>: requires all the files inside a single directory. It's similar to path/*require_tree <path>: requires all the nested files in a directory. Its glob equivalent is path/**/*>: The require directive functions similar to Ruby's own require. It provides a way to declare a dependency on a file in your path and ensures it's only loaded once before the source file.  since it does
not follow nested directories.
. require_self: causes the body of the current file to be inserted before any subsequent require directives. Useful in CSS files, where it's common for the index file to contain global styles that need to be defined before other dependencies are loaded.
stub <pathdepend_on <path>: remove a file from being included
>: Allows you to state a dependency on a file without including it. This is used for caching
purposes. Any changes made to the dependency file will invalidate the cache of the source file.
application.scssAn  file could look like:

application.coffeeAnother example is the  file. Here with including jquery and Turbolinks:

If you don't use CoffeeScript, but plain JavaScript, the syntax would be:

Section 29.2: Rake tasks
sprockets-railsBy default  is shipped with the following rake tasks:
assets:clean[keepconfig.assets.precompile]: Remove old compiled assets
 assets:clobber: Remove compiled assets assets:environment: Load asset compile environment assets:precompile: Compile all the assets named in 
 Section 29.3: Basic Usage
There are two basic ways that the asset pipeline is used:
1. When running a server in development mode, it automatically pre-processes and prepares your assets onthe-fly.
2. In production mode, you'll probably use it to pre-process, versionize, and compress and compile your assets. You can do so by running the following command:
bundle exec rake assets:precompile

Chapter 30: Upgrading Rails
Section 30.1: Upgrading from Rails 4.2 to Rails 5.0
Note: Before upgrading your Rails app, always make sure to save your code on a version control system, such as Git.
To upgrade from Rails 4.2 to Rails 5.0, you must be using Ruby 2.2.2 or newer. After upgrading your Ruby version if required, go to your Gemfile and change the line:

to:

and on the command line run:

Now run the update task using the command:

This will help you to update configuration files. You will be prompted to overwrite files and you have several options to input:
Y - yes, overwrite n - no, do not overwrite a - all, overwrite this and all others q - quit, abort d - diff, show the differences between the old and the new h - help
Typically, you should check the differences between the old and new files to make sure you aren't getting any unwanted changes.
Rails 5.0 ActiveRecord models inherit from ApplicationRecord, rather than ActiveRecord::Base.
app/modelsapplication_record.rbApplicationRecord is the superclass for all models, similar to how ApplicationController is the superclass for controllers. To account for this new way in which models are handled, you must create a file in your / folder called  and then edit that file's contents to be:

Rails 5.0 also handles callbacks slightly different. Callbacks that return false won't halt the callback chain, which means subsequent callbacks will still run, unlike Rails 4.2. When you upgrade, the Rails 4.2 behavior will remain, though you can switch to the Rails 5.0 behavior by adding:

config/application.rb file. You can explicitly halt the callback chain by calling throw(:abortto the ).
application_job.rb in the app/jobsIn Rails 5.0, ActiveJob will inherit from ApplicationJob, rather than ActiveJob::Base like in Rails 4.2. To upgrade to Rails 5.0, create a file called / folder. Edit that file's contents to be:

Then, you must change all of your jobs to inherit from ApplicationJob rather than ActiveJob::Base.
bin/rails$ bin/railsbin/railsOne of the other biggest changes of Rails 5.0 doesn't require any code changes, but will change the way you use the command line with your Rails apps. You will be able to use , or just rails, to run tasks and tests. For example, instead of using $ rake db:migrate, you can now do $ rails db:migrate. If you run , you can view all the available commands. Note that many of the tasks that can now be run with  still work using rake.

Chapter 31: ActiveRecord Locking
Section 31.1: Optimistic Locking

Section 31.2: Pessimistic Locking


Chapter 32: Debugging
Section 32.1: Debugging Rails Application
To be able to debug an application is very important to understand the flow of an application's logic and data. It helps solving logical bugs and adds value to the programming experience and code quality. Two popular gems for debugging are debugger (for ruby 1.9.2 and 1.9.3) and byebug (for ruby >= 2.x).
rbFor debugging . files, follow these steps:
1. Add debugger or byebug to the development group of Gemfile
2. Run bundle install
3. Add debugger or byebug as the breakpoint
4. Run the code or make request
5. See the rails server log stopped at the specified breakpoint
6. At this point you can use your server terminal just like rails console and check the values of variable and params
7. For moving to next instruction, type next and press enter
8. For stepping out type c and press enter
html.erb files, break point will be added as <% debugger %If you want to debug .>
Section 32.2: Debugging Ruby on Rails Quickly + Beginner advice
Debugging by raising exceptions is far easier than squinting through print log statements, and for most bugs, its generally much faster than opening up an irb debugger like pry or byebug. Those tools should not be your first step.
Debugging Ruby/Rails Quickly:
inspect1. Fast Method: Raise an Exception then and . its result
inspectThe fastest way to debug Ruby (especially Rails) code is to raise an exception along the execution path of your code while calling . on the method or object (e.g. foo):

inspectIn the above code, raise triggers an Exception that halts execution of your code, and returns an error message that conveniently contains . information about the object/method (i.e. foo) on the line that you're trying to debug.
This technique is useful for quickly examining an object or method (e.g. is it nil?) and for immediately confirming whether a line of code is even getting executed at all within a given context.
2. Fallback: Use a ruby IRB debugger like byebug or pry
Only after you have information about the state of your codes execution flow should you consider moving to a ruby gem irb debugger like pry or byebug where you can delve more deeply into the state of objects within your execution path.
To use the byebug gem for debugging in Rails:
gem 'byebug'1. Add  inside the development group in your Gemfile
2. Run bundle install
3. Then to use, insert the phrase byebug inside the execution path of the code you want examined.
This byebug variable when executed will open up an ruby IRB session of your code, giving you direct access to the state of objects as they are at that point in the code's execution.
IRB debuggers like Byebug are useful for deeply analyzing the state of your code as it executes. However, they are more time consuming procedure compared to raising errors, so in most situations they should not be your first step.
General Beginner Advice
When you are trying to debug a problem, good advice is to always: Read The !@#$ing Error Message (RTFM)
That means reading error messages carefully and completely before acting so that you understand what it's trying to tell you. When you debug, ask the following mental questions, in this order, when reading an error message:
1. What class does the error reference? (i.e. do I have the correct object class or is my object nil?)
2. What method does the error reference? (i.e. is their a type in the method; can I call this method on this type/class of object?)
3. Finally, using what I can infer from my last two questions, what lines of code should I investigate? (remember: the last line of code in the stack trace is not necessarily where the problem lies.)
app/...In the stack trace pay particular attention to lines of code that come from your project (e.g. lines starting with  if you are using Rails). 99% of the time the problem is with your own code.
To illustrate why interpreting in this order is important...
E.g. a Ruby error message that confuses many beginners:
You execute code that at some point executes as such:

and you get an error that states:
undefined method "bar" for Nil:nilClass
Beginners see this error and think the problem is that the method bar is undefined. It's not. In this error the real part that matters is:
for Nil:nilClass
for Nil:nilClass means that @foo is Nil! @foo is not a Foo instance variable! You have an object that is Nil. When
you see this error, it's simply ruby trying to tell you that the method bar doesn't exist for objects of the class Nil. (well duh! since we are trying to use a method for an object of the class Foo not Nil).
undefined method "bar" for Nil:nilClassUnfortunately, due to how this error is written () its easy to get tricked
into thinking this error has to do with bar being undefined. When not read carefully this error causes beginners to mistakenly go digging into the details of the bar method on Foo, entirely missing the part of the error that hints that the object is of the wrong class (in this case: nil). It's a mistake that's easily avoided by reading error messages in their entirety.
Summary:
Always carefully read the entire error message before beginning any debugging. That means: Always check the class type of an object in an error message first, then its methods, before you begin sleuthing into any stacktrace or line of code where you think the error may be occurring. Those 5 seconds can save you 5 hours of frustration.
tl;dr: Don't squint at print logs: raise exceptions instead. Avoid rabbit holes by reading errors carefully before debugging.
Section 32.3: Debugging ruby-on-rails application with pry
pry is a powerful tool that can be used to debug any ruby application. Setting up a ruby-on-rails application with this gem is very easy and straightforward.
Setup

Use
binding.prybinding.pryUsing pry in your application is just including  on the breakpoints you want to inspect while debugging. You can add  breakpoints anywhere in your application that is interpreted by ruby interpreter (any app/controllers, app/models, app/views files)
i) Debugging a Controllerapp/controllers/users_controller.rb

In this example, the rails server pauses with a pry console at the break-point when you try to visit a page routing to show action on UsersController. You can inspect params object and make ActiveRecord query on User model from that breakpoint
ii) Debugging a Viewapp/views/users/show.html.haml

users/show@user.logged_inIn this example, the break-point pauses with pry console when the  page is pre-compiled in the rails server before sending it back to the client's browser. This break-point allows to debug correctness of ? when it is misbehaving.
ii) Debugging a Model

In this example, the break-point can be used to debug User model's instance method full_name when this method is called from anywhere in the application.
In conclusion, pry is a powerful debugging tool for rails application with easy setup and straightforward debugging guideline. Give this a try.
Section 32.4: Debugging in your IDE
Every good IDE provides a GUI for interactively debugging Ruby (and thus Rails) applications where you can add breakpoints, watches, auto pausing on exception and allows you to follow the code execution even step by step, line by line.
For example, take a look at one of the best Ruby IDE's, RubyMine's debugging features on the picture

Chapter 33: Configure Angular with Rails
Section 33.1: Angular with Rails 101
Step 1: Create a new Rails app
 gem install rails -v 4.1 rails new angular_example Step 2: Remove Turbolinks
Removing turbolinks requires removing it from the Gemfile.

app/assets/javascripts/application.jsRemove the require from :
//= require turbolinks
Step 3: Add AngularJS to the asset pipeline
In order to get Angular to work with the Rails asset pipeline we need to add to the Gemfile:

Now run the command

Add bower so that we can install the AngularJS dependency:

bower.jsonAdd Angular to :

bower.jsonNow that  is setup with the right dependencies, let's install them: bundle exec rake bower:install Step 4: Organize the Angular app
app/assets/javascript/angular-app/Create the following folder structure in :


app/assets/javascripts/application.jsIn , add require for Angular, the template helper, and the Angular app file structure. Like this:

app/assets/javascripts/angular-app/app.js.coffeeCreate :
@app = angular.module('app', [ 'templates' ])
@app.config([ '$httpProvider', ($httpProvider)->
$httpProvider.defaults.headers.common['X-CSRF-Token'] = $('meta[name=csrftoken]').attr('content') ])  @app.run(->   console.log 'angular app running' )
app/assets/javascripts/angular-app/modules/example.js.coffee.erbCreate an Angular module at :
@exampleApp = angular.module('app.exampleApp', [     # additional dependencies here   ])   .run(->    console.log 'exampleApp running'   )
app/assets/javascripts/angularCreate an Angular controller for this app at -
app/controllers/exampleCtrl.js.coffee:
config/routes.rb angular.module('app.exampleApp').controller("ExampleCtrl", [   '$scope',   ($scope)->    console.log 'ExampleCtrl running'      $scope.exampleValue = "Hello angular and rails"  ]) Now add a route to Rails to pass control over to Angular. In:
 Rails.application.routes.draw do   get 'example' => 'example#index' end Generate the Rails controller to respond to that route:

app/controllers/example_controller.rbIn :


In the view, we need to specify which Angular app and which Angular controller will drive this page. So in
app/views/example/index.html.erb:

To view the app, start your Rails server and visit http://localhost:3000/example.

Chapter 34: Rails logger
Section 34.1: Rails.logger
Rails.logger.{debug|info|warn|error|fatallogdevelopment.log or production.log or staging.logAlways use } rather than puts. This allows your logs to fit into the standard log format, have a timestamp and have a level so you choose whether they are important enough to be shown in a specific environment. You can see the separate log files for your application under / directory with your rails app environment name. like: 
You can easily rotating rails production logs with LogRotate.You just have to do small configuration as below
etc/logrotate.confOpen / with your favourite linux editor vim or nano and add the below code in this file at bottom.

So, How It Works This is fantastically easy. Each bit of the configuration does the following:
daily - Rotate the log files each day. You can also use weekly or monthly here instead.
missingok - If the log file doesn't exist,ignore it rotate 7 - Only keep 7 days of logs around compress - GZip the log file on rotation delaycompress - Rotate the file one day, then compress it the next day so we can be sure that it won't interfere with the Rails server notifempty - Don't rotate the file if the logs are empty copytruncate - Copy the log file and then empties it. This makes sure that the log file Rails is writing to always exists so you won't get problems because the file does not actually change. If you don't use this, you would need to restart your Rails application each time.
Running Logrotate Since we just wrote this configuration, you want to test it.
sudo /usr/sbin/logrotate -f /etc/logrotate.confTo run logrotate manually, just do: 
That's it.
Chapter 35: Prawn PDF
Section 35.1: Advanced Example
This is the advanced approach with example

FundsPdf.new(@fund, view_context)I above code we have this line . Here we are initializing FundsPdf class with
@fund instance and view_context to use helper methods in FundsPdf. FundsPdf wuld look like this

This is one of the best approach to generate PDF with classes using Prawn gem.
Section 35.2: Basic Example
You need to add Gem and PDF MIME:Type inside mime_types.rb as we need to notify rails about PDF mime type.
After that we can generate Pdf with Prawn in following basic ways


With Explicit Block


Chapter 36: Rails API
Section 36.1: Creating an API-only application
To build a Rails application that will be an API server, you can start with a more limited subset of Rails in Rails 5.
To generate a new Rails API app:

--apiWhat  does is to remove functionality that is not needed when building an API. This includes sessions, cookies, assets, and anything that makes Rails work on a browser.
It will also configure the generators so that they don't generate views, helpers, and assets when generating a new resource.
When you compare the ApplicationController on a web app versus an API app, you will see that the web version extends from ActionController::Base, whereas the API version extends from ActionController::API, which includes a much smaller subset of functionality.

Chapter 37: Deploying a Rails app on Heroku
Section 37.1: Deploying your application
Make sure you are in the directory that contains your Rails app, then create an app on Heroku.

The first URL of the ouput, http://example.herokuapp.com, is the location the app is available at. The second URL, git@heroku.com:example.git, is the remote git repository URL.
This command should only be used on an initialized git repository. The heroku create command automatically adds a git remote named "heroku" pointing at this URL.
The app name argument ("example") is optional. If no app name is specified, a random name will be generated. Since Heroku app names are in a global namespace, you can expect that common names, like "blog" or "wiki", will already be taken. It's often easier to start with a default name and rename the app later.
Next, deploy your code:
$ git push heroku master remote: Compressing source files... done. remote: Building source: remote:
remote: -----> Ruby app detected remote: -----> Compiling Ruby/Rails remote: -----> Using Ruby version: ruby-2.3.1 remote: -----> Installing dependencies using bundler 1.11.2 remote:        Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment remote:        Warning: the running version of Bundler is older than the version that created the lockfile. We suggest you upgrade to the latest version of Bundler by running `gem install bundler`. remote:        Fetching gem metadata from https://rubygems.org/.......... remote:        Fetching version metadata from https://rubygems.org/... remote:        Fetching dependency metadata from https://rubygems.org/..
remote:        Installing concurrent-ruby 1.0.2 remote:        Installing i18n 0.7.0 remote:        Installing rake 11.2.2 remote:        Installing minitest 5.9.0 remote:        Installing thread_safe 0.3.5 remote:        Installing builder 3.2.2 remote:        Installing mini_portile2 2.1.0 remote:        Installing erubis 2.7.0 remote:        Installing pkg-config 1.1.7 remote:        Installing rack 2.0.1 remote:        Installing nio4r 1.2.1 with native extensions remote:        Installing websocket-extensions 0.1.2 remote:        Installing mime-types-data 3.2016.0521 remote:        Installing arel 7.0.0 remote:        Installing coffee-script-source 1.10.0 remote:        Installing execjs 2.7.0 remote:        Installing method_source 0.8.2 remote:        Installing thor 0.19.1 remote:        Installing multi_json 1.12.1

remote:        Installing puma 3.4.0 with native extensions remote:        Installing pg 0.18.4 with native extensions remote:        Using bundler 1.11.2 remote:        Installing sass 3.4.22 remote:        Installing tilt 2.0.5 remote:        Installing turbolinks-source 5.0.0 remote:        Installing tzinfo 1.2.2 remote:        Installing nokogiri 1.6.8 with native extensions remote:        Installing rack-test 0.6.3 remote:        Installing sprockets 3.6.3 remote:        Installing websocket-driver 0.6.4 with native extensions remote:        Installing mime-types 3.1 remote:        Installing coffee-script 2.4.1 remote:        Installing uglifier 3.0.0 remote:        Installing turbolinks 5.0.0 remote:        Installing activesupport 5.0.0 remote:        Installing mail 2.6.4 remote:        Installing globalid 0.3.6 remote:        Installing activemodel 5.0.0 remote:        Installing jbuilder 2.5.0 remote:        Installing activejob 5.0.0 remote:        Installing activerecord 5.0.0 remote:        Installing loofah 2.0.3 remote:        Installing rails-dom-testing 2.0.1 remote:        Installing rails-html-sanitizer 1.0.3 remote:        Installing actionview 5.0.0 remote:        Installing actionpack 5.0.0 remote:        Installing actionmailer 5.0.0 remote:        Installing railties 5.0.0 remote:        Installing actioncable 5.0.0 remote:        Installing sprockets-rails 3.1.1 remote:        Installing coffee-rails 4.2.1 remote:        Installing jquery-rails 4.1.1 remote:        Installing rails 5.0.0 remote:        Installing sass-rails 5.0.5 remote:        Bundle complete! 15 Gemfile dependencies, 54 gems now installed. remote:        Gems in the groups development and test were not installed. remote:        Bundled gems are installed into ./vendor/bundle.
remote:        Bundle completed (31.86s) remote:        Cleaning up the bundler cache.
remote:        Warning: the running version of Bundler is older than the version that created the lockfile. We suggest you upgrade to the latest version of Bundler by running `gem install bundler`.
remote: -----> Preparing app for Rails asset pipeline remote:        Running: rake assets:precompile remote:        I, [2016-07-08T17:08:57.046245 #1222]  INFO -- : Writing
/tmp/build_49ba6c877f5502cd4029406e981f90b4/public/assets/application-1bf5315c71171ad5f9cbef00193d56b 7e45263ddc64caf676ce988cfbb6570bd.js remote:        I, [2016-07-08T17:08:57.046951 #1222]  INFO -- : Writing
/tmp/build_49ba6c877f5502cd4029406e981f90b4/public/assets/application-1bf5315c71171ad5f9cbef00193d56b 7e45263ddc64caf676ce988cfbb6570bd.js.gz remote:        I, [2016-07-08T17:08:57.060208 #1222]  INFO -- : Writing /tmp/build_49ba6c877f5502cd4029406e981f90b4/public/assets/applicatione3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css remote:        I, [2016-07-08T17:08:57.060656 #1222]  INFO -- : Writing /tmp/build_49ba6c877f5502cd4029406e981f90b4/public/assets/applicatione3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css.gz remote:        Asset precompilation completed (4.06s) remote:        Cleaning assets remote:        Running: rake assets:clean remote: remote: ###### WARNING: remote:        No Procfile detected, using the default web server.
If you are using the database in your application you need to manually migrate the database by running:

Any commands after heroku run will be executed on a Heroku dyno. You can obtain an interactive shell session by running:

Ensure you have one dyno running the web process type:

The heroku ps command lists the running dynos of your application:

heroku openYou can now visit the app in our browser with .

herokuapp.comHeroku gives you a default web URL in the  domain. When you are ready to scale up for production, you can add your own custom domain.
Section 37.2: Managing Production and staging environments for a Heroku
Every Heroku app runs in at least two environments: on Heroku (we'll call that production) and on your local machine (development). If more than one person is working on the app, then you've got multiple development environments - one per machine, usually. Usually, each developer will also have a test environment for running tests. Unfortunately, this approach breaks down as the environments become less similar. Windows and Macs, for instance, both provide different environments than the Linux stack on Heroku, so you can't always be sure that code that works in your local development environment will work the same way when you deploy it to production.
The solution is to have a staging environment that is as similar to production as is possible. This can be achieved by creating a second Heroku application that hosts your staging application. With staging, you can check your code in a production-like setting before having it affect your actual users.
Starting from scratch
Assume you have an application running on your local machine, and you're ready to push it to Heroku. We'll need to create both remote environments, staging and production. To get in the habit of pushing to staging first, we'll start with this:

By default, the heroku CLI creates projects with a heroku git remote. Here, we're specifying a different name with the --remote flag, so pushing code to Heroku and running commands against the app look a little different than the normal git push heroku master:

Once your staging app is up and running properly, you can create your production app:

And with that, you've got the same codebase running as two separate Heroku apps - one staging and one production, set up identically. Just remember you will have to specify which app you are going to operate on your daily work. You can either use flag '--remote' or use your git config to specify a default app.
Chapter 38: ActiveSupport
Section 38.1: Core Extensions: String Access
String#at
String#[]Returns a substring of a string object. Same interface as .

Returns a substring from the given position to the end of the string.

String#to
Returns a substring from the beginning of the string to the given position. If the position is negative, it is counted from the end of the string.

from and to can be used in tandem.

String#first
Returns the first character, or a given number of characters up to the length of the string.

String#last
Returns the last character, or a given number of characters from the end of the string counting backwards.


Section 38.2: Core Extensions: String to Date/Time Conversion
String#to_time
Converts a string to a Time value. The form parameter can be either :utc or :local, defaults to :local.
"13-12-2012".to_time               # => 2012-12-13 00:00:00 +0100 "06:12".to_time                    # => 2012-12-13 06:12:00 +0100 "2012-12-13 06:12".to_time         # => 2012-12-13 06:12:00 +0100
"2012-12-13T06:12".to_time         # => 2012-12-13 06:12:00 +0100
"2012-12-13T06:12".to_time(:utc)   # => 2012-12-13 06:12:00 UTC
"12/13/2012".to_time               # => ArgumentError: argument out of range
String#to_date
Converts a string to a Date value.

String#to_datetime
Converts a string to a DateTime value.
"1-1-2012".to_datetime            # => Sun, 01 Jan 2012 00:00:00 +0000 "01/01/2012 23:59:59".to_datetime # => Sun, 01 Jan 2012 23:59:59 +0000 "2012-12-13 12:50".to_datetime    # => Thu, 13 Dec 2012 12:50:00 +0000
"12/13/2012".to_datetime          # => ArgumentError: invalid date
Section 38.3: Core Extensions: String Exclusion
String#exclude?
String#include?The inverse of 

Section 38.4: Core Extensions: String Filters
String#squish
Returns a version of the given string without leading or trailing whitespace, and combines all consecutive whitespace in the interior to single spaces. Destructive version squish! operates directly on the string instance.
Handles both ASCII and Unicode whitespace.

String#remove
Returns a new string with all occurrences of the patterns removed. Destructive version remove! operates directly on the given string.

String#truncate
Returns a copy of a given string truncated at a given length if the string is longer than the length.

Pass a string or regexp :separator to truncate at a natural break

String#truncate_words
Returns a string truncated after a given number of words.

Pass a string or regexp to specify a different separator of words
'Once<br>upon<br>a<br>time<br>in<br>a<br>world'.truncate_words(5, separator: '<br>') # => "Once<br>upon<br>a<br>time<br>in..."
The last characters will be replaced with the :omission string (defaults to "...")

String#strip_heredoc
Strips indentation in heredocs. Looks for the least-indented non-empty line and removes that amount of leading whitespace.

the user would see
NO_FORMAT]This command does such and such. Supported options are: -h This message ...
Section 38.5: Core Extensions: String Inflection
String#pluralize
count == Returns of plural form of the string. Optionally takes a count parameter and returns singular form if 1. Also accepts a locale parameter for language-specific pluralization.

Returns the singular form of the string. Accepts an optional locale parameter.
'posts'.singularize            # => "post"
'octopi'.singularize           # => "octopus"
'sheep'.singularize            # => "sheep"
'word'.singularize             # => "word"
'the blue mailmen'.singularize # => "the blue mailman"
'CamelOctopi'.singularize      # => "CamelOctopus"
'leyes'.singularize(:es)       # => "ley"
String#constantize
Tries to find a declared constant with the name specified in the string. It raises a NameError when the name is not in CamelCase or is not initialized.

String#safe_constantize
Performs a constantize but returns nil instead of raising NameError.

Converts strings to UpperCamelCase by default, if :lower is given as param converts to lowerCamelCase instead.
alias: camelcase
Note: will also convert / to :: which is useful for converting paths to namespaces.
'active_record'.camelize                # => "ActiveRecord"
'active_record'.camelize(:lower)        # => "activeRecord"
'active_record/errors'.camelize         # => "ActiveRecord::Errors" 'active_record/errors'.camelize(:lower) # => "activeRecord::Errors"
String#titleize
Capitalizes all the words and replaces some characters in the string to create a nicer looking title.
alias: titlecase
'man from the boondocks'.titleize # => "Man From The Boondocks"
'x-men: the last stand'.titleize  # => "X Men: The Last Stand"
String#underscore
Makes an underscored, lowercase form from the expression in the string. The reverse of camelize.
Note: underscore will also change :: to / to convert namespaces to paths.
'ActiveModel'.underscore         # => "active_model"
 'ActiveModel::Errors'.underscore # => "active_model/errors" String#dasherize
Replaces underscores with dashes in the string.

String#demodulize
Removes the module part from the constant expression in the string.
'ActiveRecord::CoreExtensions::String::Inflections'.demodulize # => "Inflections"
'Inflections'.demodulize                                       # => "Inflections"
'::Inflections'.demodulize                                     # => "Inflections"
''.demodulize                                                  # => ''
String#deconstantize
Removes the rightmost segment from the constant expression in the string.

Replaces special characters in a string so that it may be used as part of a 'pretty' URL.

Preserve the case of the characters in a string with the :preserve_case argument.
"Donald E. Knuth".parameterize(preserve_case: true) # => "Donald-E-Knuth"
A very common use-case for parameterize is to override the to_param method of an ActiveRecord model to support more descriptive url slugs.


String#tableize
Creates the name of a table like Rails does for models to table names. Pluralizes the last word in the string.

String#classify
Returns a class name string from a plural table name like Rails does for table names to models.

String#humanize
Capitalizes the first word, turns underscores into spaces, and strips a trailing _id if present.
'employee_salary'.humanize              # => "Employee salary"
'author_id'.humanize                    # => "Author"
'author_id'.humanize(capitalize: false) # => "author"
 '_id'.humanize                          # => "Id" String#upcase_first
Converts just the first character to uppercase.

String#foreign_key
Creates a foreign key name from a class name. Pass false param to disable adding _ between name and id.

Chapter 39: Form Helpers
Rails provides view helpers for generating form markup.
Section 39.1: Creating a search form
To create a search form, enter the following code
<%= form_tag("/search", method: "get") do %>
  <%= label_tag(:q, "Search for:") %>
  <%= text_field_tag(:q) %>
  <%= submit_tag("Search") %>
<% end %>
/search<label>form_tag: This is the default helper for creating a form. It's first parameter,  is the action and the second parameter specifies the HTTP method. For search forms, it is important to always use the method get label_tag: This helper creates an html  tag.
       text_field_tag: This will create an input element with type text submit_tag: This creates an input element with type submit
   Section 39.2: Dropdown
Standard example:

This will generate the following HTML: David
The last argument are options, which accepts the following:

More examples can be found: http://apidock.com/rails/ActionView/Helpers/FormTagHelper/select_tag
Section 39.3: Helpers for form elements
Checkboxes

This will generate the following html


Radio Buttons

This generates the following HTML
<input id="age_child" name="age" type="radio" value="child" /> <label for="age_child">I am younger than 18</label>
<input id="age_adult" name="age" type="radio" value="adult" /> <label for="age_adult">I'm over 18</label>
Text Area
To create a larger text box, it is recommended to use the text_area_tag
<%= text_area_tag(:message, "This is a longer text field", size: "25x6") %>
This will create the following HTML
<textarea id="message" name="message" cols="25" rows="6">This is a longer text field</textarea>
Number Field
input<type="number"This will create an > element

inTo specify a range of values, we can use the : option

Password Field
Sometimes you want the characters typed by the user to be masked. This will generate an <input
type="password">

Email Field
<input type="email"This will create an >

Telephone Field
<input type="tel"This will create an >.

Date Helpers


Chapter 40: ActiveRecord Transactions
Section 40.1: Basic example
For example:

This example will only take money from David and give it to Mary if neither withdrawal nor deposit raise an exception. Exceptions will force a ROLLBACK that returns the database to the state before the transaction began. Be aware, though, that the objects will not have their instance data returned to their pre-transactional state.
Section 40.2: Dierent ActiveRecord classes in a single transaction
Though the transaction class method is called on some ActiveRecord class, the objects within the transaction block need not all be instances of that class. This is because transactions are per-database connection, not per-model.
In this example a balance record is transactionally saved even though transaction is called on the Account class:

The transaction method is also available as a model instance method. For example, you can also do this:

Section 40.3: Multiple database connections
A transaction acts on a single database connection. If you have multiple class-specific databases, the transaction will not protect interaction among them. One workaround is to begin a transaction on each class whose models you alter:

This is a poor solution, but fully distributed transactions are beyond the scope of ActiveRecord.
Section 40.4: save and destroy are automatically wrapped in a transaction
after_Both #save and #destroy come wrapped in a transaction that ensures that whatever you do in validations or callbacks will happen under its protected cover. So you can use validations to check for values that the transaction depends on or you can raise exceptions in the callbacks to rollback, including * callbacks.
As a consequence changes to the database are not seen outside your connection until the operation is complete. For example, if you try to update the index of a search engine in after_save the indexer won't see the updated record. The after_commit callback is the only one that is triggered once the update is committed.
Section 40.5: Callbacks
There are two types of callbacks associated with committing and rolling back transactions: after_commit and after_rollback.
after_commit callbacks are called on every record saved or destroyed within a transaction immediately after the transaction is committed. after_rollback callbacks are called on every record saved or destroyed within a transaction immediately after the transaction or savepoint is rolled back.
These callbacks are useful for interacting with other systems since you will be guaranteed that the callback is only executed when the database is in a permanent state. For example, after_commit is a good spot to put in a hook to clearing a cache since clearing it from within a transaction could trigger the cache to be regenerated before the database is updated.
Section 40.6: Rolling back a transaction
ActiveRecord::Base.transaction uses the ActiveRecord::Rollback exception to distinguish a deliberate rollback
transactionfrom other exceptional situations. Normally, raising an exception will cause the . method to rollback the database transaction and pass on the exception. But if you raise an ActiveRecord::Rollback exception, then the database transaction will be rolled back, without passing on the exception.
For example, you could do this in your controller to rollback a transaction:

Chapter 41: RSpec and Ruby on Rails
Section 41.1: Installing RSpec
rspec-railsIf you want to use RSpec for a Rails project, you should use the  gem, which can generate helpers and spec files for you automatically (for example, when you create models, resources or scaffolds using rails generate).
rspec-railsAdd  to both the :development and :test groups in the Gemfile:

Run bundle to install the dependencies.
Initialize it with:

specThis will create a / folder for your tests, along with the following configuration files:
rspecspec/spec_helper.rbspec/rails_helper.rb. contains default options for the command-line rspec tool  includes basic RSpec configuration options  adds further configuration options that are more specific to use RSpec and Rails
together.
All these files are written with sensible defaults to get you started, but you can add features and change configurations to suit your needs as your test suite grows.
Chapter 42: Decorator pattern
Section 42.1: Decorating a Model using Draper
Draper automatically matches up models with their decorators by convention.

Given a @user variable containing an ActiveRecord object, you can access your decorator by calling #decorate on the @user, or by specifying the Draper class if you want to be specific.

Section 42.2: Decorating a Model using SimpleDelegator
Most Rails developers start by modifying their model information within the template itself:
<h1><%= "#{ @user.first_name } #{ @user.last_name }" %></h1>
<h3>joined: <%= @user.created_at.in_time_zone(current_user.timezone).strftime("%A, %d %b %Y %l:%M %p") %></h3>
For models with a lot of data, this can quickly become cumbersome and lead to copy-pasting logic from one template to another.
This example uses SimpleDelegator from the stdlib.
All requests to a SimpleDelegator object are passed to the parent object by default. You can override any method with presentation logic, or you can add new methods that are specific to this view.
SimpleDelegator provides two methods: __setobj__ to set what object is being delegated to, and __getobj__ to get that object.


Some decorators rely on magic to wire-up this behavior, but you can make it more obvious where the presentation logic is coming from by initializing the object on the page.

By passing a reference to the view object into the decorator, we can still access all of the rest of the view helpers while building the presentation logic without having to include it.
Now the view template is only concerned with inserting data into the page, and it is much more clear.

Chapter 43: Elasticsearch
Section 43.1: Searchkick
If you want to setup quickly elasticsearch you can use the searchkick gem :

Add searchkick to models you want to search.

Add data to the search index.

And to query, use:

Pretty quick, elasticsearch knowledge not required ;-)
More information here : https://github.com/ankane/searchkick
Section 43.2: Installation and testing
The first thing you want to do for local development is install ElasticSearch in your machine and test it to see if it is running. It requires Java to be installed. The installation is pretty straightforward:
sudo apt-get install elasticsearchMac OS X: brew install elasticsearch Ubuntu: 
Then start it:
sudo service elasticsearch startMac OS X: brew services start elasticsearch Ubuntu: 
For testing it, the easiest way is with curl. It might take a few seconds for it to start, so don't panic if you don't get any response at first.
curl localhost:9200
Example response:


Section 43.3: Setting up tools for development
elasticsearch-headWhen you are getting started with ElasticSearch (ES) it might be good to have a graphical tool that helps you explore your data. A plugin called  does just that. To install it, do the following:
ls -l $(which elasticsearchelasticsearch/bin/plugin -installmobz/elasticsearch-headhttp://localhost:9200/_plugin/headFind out in which folder ES is installed: ) cd into this folder and run the plugin installation binary: 
Open / in your browser
If everything worked as expected you should be seeing a nice GUI where you can explore your data.
Section 43.4: Introduction
ElasticSearch has a well-documented JSON API, but you'll probably want to use some libraries that handle that for you:
Elasticsearch-railsElasticsearch - the official low level wrapper for the HTTP API
 - the official high level Rails integration that helps you to connect your Rails models
with ElasticSearch using either ActiveRecord or Repository pattern
 Chewy - An alternative, non-official high level Rails integration that is very popular and arguably has better documentation
Let's use the first option for testing the connection: gem install elasticsearch
Then fire up the ruby terminal and try it out:

Chapter 44: React with Rails using reactrails gem
Section 44.1: React installation for Rails using rails_react gem
Add react-rails to your Gemfile:

And install:

Next, run the installation script:

This will:
create a components.js manifest file and a app/assets/javascripts/components/ directory, where you will put your components place the following in your application.js:

Section 44.2: Using react_rails within your application
React.js builds
You can pick which React.js build (development, production, with or without add-ons) to serve in each environment by adding a config. Here are the defaults:

To include add-ons, use this config:

After restarting your Rails server, //= require react will provide the build of React.js which was specified by the configurations.
react-rails offers a few other options for versions & builds of React.js. See VERSIONS.md for more info about using the react-source gem or dropping in your own copies of React.js.
JSX
After installing react-rails, restart your server. Now, .js.jsx files will be transformed in the asset pipeline.
BabelTransformer options
You can use babel's transformers and custom plugins, and pass options to the babel transpiler adding following configurations:
config.react.jsx_transform_options = {   blacklist: ['spec.functionName', 'validation.react', 'strict'], # default options   optional: ["transformerName"],  # pass extra babel options   whitelist: ["useStrict"] # even more options[enter link description here][1] }
Under the hood, react-rails uses ruby-babel-transpiler, for transformation.
Section 44.3: Rendering & mounting
react-rails includes a view helper (react_component) and an unobtrusive JavaScript driver (react_ujs) which work
together to put React components on the page. You should require the UJS driver in your manifest after react (and after turbolinks if you use Turbolinks).
The view helper puts a div on the page with the requested component class & props. For example:
<%= react_component('HelloMessage', name: 'John') %>
<!-- becomes: -->
<div data-react-class="HelloMessage" data-react-props="{&quot;name&quot;:&quot;John&quot;}"></div>
On page load, the react_ujs driver will scan the page and mount components using data-react-class and data-reactprops.
If Turbolinks is present components are mounted on the page:change event, and unmounted on page:beforeunload. Turbolinks >= 2.4.0 is recommended because it exposes better events.
In case of Ajax calls, the UJS mounting can be triggered manually by calling from javascript:
ReactRailsUJS.mountComponents() The view helper's signature is:

component_class_name is a string which names a globally-accessible component class. It may have dots (eg, "MyApp.Header.MenuItem").
   `props` is either an object that responds to `#to_json` or an    already-stringified JSON object (eg, made with Jbuilder, see note    below).
html_options may include: tag: to use an element other than a div to embed data-react-class and data-react-
prerender: true to render the component on the server. **otherprops.  Any other arguments (eg class:, id:) are passed through to content_tag.
Chapter 45: Rails Cookbook - Advanced rails recipes/learnings and coding techniques
Section 45.1: Playing with Tables using rails console
View tables

Delete any table.

Remove index from existing column
  ActiveRecord::Migration.remove_index(:users, :name => 'index_users_on_country') where country is a column name in the migration file with already added index in users table as shown below:

Remove foreign key constraint
 ActiveRecord::Base.connection.remove_foreign_key('food_items', 'menus') where menus has_many food_items and their respective migrations too. Add column

for example:
 ActiveRecord::Migration.add_column :profiles, :profile_likes, :integer, :default => 0
Section 45.2: Rails methods - returning boolean values
Any method in Rails model can return boolean value.
simple method-

Again simple method returning boolean value-
  ##this method return Boolean(NOTE THE !! signs before result)   def check_if_user_profile_is_complete
    !!User.includes( :profile_pictures,:address,:contact_detail).where("user.id = ?",self)   end
So,the same method will now return boolean instead of anything else :).
Section 45.3: Handling the error - undefined method `where' for #<Array:0x000000071923f8>
Sometimes we want to use a where query on a a collection of records returned which is not
ActiveRecord::Relation.Hence we get the above error as Where clause is know to ActiveRecord and not to Array.
There is a precise solution for this by using Joins.

So above query will fail after map as map will return an array which will not work with where clause.
But using joins,will make it work,

As joins will output similar records like map but they will be ActiveRecord and not an Array.
Chapter 46: Multipurpose ActiveRecord columns
Section 46.1: Saving an object
If you have an attribute that needs to be saved and retrieved to database as an object, then specify the name of that attribute using the serialize method and it will be handled automatically.
The attribute must be declared as a text field.
In the model you must declare the type of the field (Hash or Array)
More info at: serialize >> apidock.com
Section 46.2: How To
In your migration

In your model

Chapter 47: Class Organization
Section 47.1: Service Class
Controller is an entry point to our application. However, it's not the only possible entry point. I would like to have my logic accessible from:
Rake tasks background jobs console tests
If I throw my logic into a controller it won't be accessible from all these places. So let's try "skinny controller, fat model" approach and move the logic to a model. But which one? If a given piece of logic involves User, Cart and Product models - where should it live?
A class which inherits from ActiveRecord::Base already has a lot of responsibilities. It handles query interface, associations and validations. If you add even more code to your model it will quickly become an unmaintainable mess with hundreds of public methods.
A service is just a regular Ruby object. Its class does not have to inherit from any specific class. Its name is a verb phrase, for example CreateUserAccount rather than UserCreation or UserCreationService. It lives in app/services directory. You have to create this directory by yourself, but Rails will autoload classes inside for you.
A service object does one thing
A service object (aka method object) performs one action. It holds the business logic to perform that action. Here is an example:

The three conventions I follow are:
app/services directoryServices go under the . I encourage you to use subdirectories for business logic-heavy domains. For instance:
app/services/invite/accept.rb will define Invite::Accept while app/services/invite/create.rbThe file 
will define Invite::Create
Services start with a verb (and do not end with Service): ApproveTransaction, SendTestNewsletter, ImportUsersFromCsv
Services respond to the call method. I found using another verb makes it a bit redundant:
ApproveTransaction.approve() does not read well. Also, the call method is the de facto method for
lambda, procs, and method objects.
Benefits
Service objects show what my application does
I can just glance over the services directory to see what my application does: ApproveTransaction, CancelTransaction, BlockAccount, SendTransactionApprovalReminder...
A quick look into a service object and I know what business logic is involved. I don't have to go through the controllers, ActiveRecord model callbacks and observers to understand what "approving a transaction" involves.
Clean-up models and controllers
Controllers turn the request (params, session, cookies) into arguments, pass them down to the service and redirect or render according to the service response.

Models only deal with associations, scopes, validations and persistence.

This makes models and controllers much easier to test and maintain!
When to use Service Class
Reach for Service Objects when an action meets one or more of these criteria:
The action is complex (e.g. closing the books at the end of an accounting period)
The action reaches across multiple models (e.g. an e-commerce purchase using Order, CreditCard and Customer objects)
The action interacts with an external service (e.g. posting to social networks)
The action is not a core concern of the underlying model (e.g. sweeping up outdated data after a certain time period).
There are multiple ways of performing the action (e.g. authenticating with an access token or password).
Sources
Adam Niedzielski Blog
Brew House Blog
Code Climate Blog
Section 47.2: Model Class

Models are typically responsible for:
setting up relationships validating data
providing access to data via scopes and methods Performing actions around persistence of data.
At the highest level, models describe domain concepts and manages their persistence.
Chapter 48: Shallow Routing
Section 48.1: Use of shallow
One way to avoid deep nesting (as recommended above) is to generate the collection actions scoped under the parent, so as to get a sense of the hierarchy, but to not nest the member actions. In other words, to only build routes with the minimal amount of information to uniquely identify the resource, like this:

The shallow method of the DSL creates a scope inside of which every nesting is shallow. This generates the same routes as the previous example:

There exist two options for scope to customize shallow routes. :shallow_path prefixes member paths with the specified parameter:

Use Rake Command for get generated routes as define below:

Chapter 49: Model states: AASM
Section 49.1: Basic state with AASM
Usually you'll end up creating models which will contain a state, and that state will be changing during the lifespan of the object.
AASM is a finite state machine enabler library that can help you out with dealing with having an easy passing through the process design of your objects.
Having something like this in your model goes pretty aligned with the Fat Model, Skinny Controller idea, one of Rails best practices. The model is the sole responsible of managing its state, its changes and of generating the events triggered by those changes.
To install, in Gemfile

Consider an App where the user Quotes a product for a price.

The Quote class' states can go however it's best for your process.
You can think of the states as being past, like in the previous example or algo in other tense, for example: pricing, paying, delivering, etc. The naming of the states depends on you. From a personal point a view, past states work better because your end state will surely be a past action and links up better with the event names, which will be explained later.
NOTE: Be careful what names you use, you have to worry about not using Ruby or Ruby on Rails reserved keywords, like valid, end, being, etc.
Having defined the states and transitions we can now access some methods created by AASM.
For example:
Quote.priced  # Shows all Quotes with priced events quote.priced? # Indicates if that specific quote has been priced quote.price!  # Triggers the event the would transition from requested to priced.
As you can see the event has transitions, this transitions determine the way the state will change upon the event call. If the event is invalid due to the current state an Error will be raised.
The events and transitions also have some other callbacks, for example

Will call the product_delivered? method which will return a boolean. If it turns out false, the transition will not be applied and if the no other transitions are available, the state won't change.

If that translation successfully happens the :reverse_charges method will be invoked.
There are several other methods in AASM with more callbacks in the process but this will help you creating your first models with finite states.
Chapter 50: Rails 5 API Authetication
Section 50.1: Authentication with Rails authenticate_with_http_token

You can test this endpoint with curl by making a request like
curl -IH "Authorization: Token token=my-token" http://localhost:3000

Chapter 51: Testing Rails Applications
Section 51.1: Unit Test
Unit tests test parts of the application in isolation. usually a unit under test is a class or module.

source
This kind if test is as direct and specific as possible.
Section 51.2: Request Test
Request tests are end to end tests that imitate the behavior of a user.

source
This kind of test focuses on user flows and runs through all layers of the system sometimes even rendering javascript.
Chapter 52: Active Jobs
Section 52.1: Introduction
Available since Rails 4.2, Active Job is a framework for declaring jobs and making them run on a variety of queuing backends. Recurring or punctual tasks that are not blocking and can be run in parallel are good use cases for Active Jobs.
Section 52.2: Sample Job

Section 52.3: Creating an Active Job via the generator


Chapter 53: Rails frameworks over the years
When you're new to Rails and working on legacy Rails applications, it can be confusing to understand which framework was introduced when. This topic is designed to be the definitive list of all frameworks across Rails versions.
Section 53.1: How to find what frameworks are available in the current version of Rails?
Use the
		config.frameworks
option to get an array of Symbols that represent each framework.
Section 53.2: Rails versions in Rails 1.x
ActionMailer
ActionPack
ActionWebService
ActiveRecord
ActiveSupport
Railties
Section 53.3: Rails frameworks in Rails 2.x
ActionMailer
ActionPack
ActiveRecord
ActiveResource (ActiveWebService was replaced by ActiveResource, and with that, Rails moved from SOAP to REST by default) ActiveSupport
Railties
Section 53.4: Rails frameworks in Rails 3.x
ActionMailer
ActionPack
ActiveModel
ActiveRecord
ActiveResource
ActiveSupport
Railties
Chapter 54: Nested form in Ruby on Rails
Section 54.1: How to setup a nested form in Ruby on Rails
The first to thing to have: a model that contains a has_many relation with another model.


In a nested form, you can create child objects with a parent object at the same time.

Project.newAs we initialized @project with  to have something for creating a new Project object, same way for creating a Todo object, we have to have something like this, and there are multiple ways to do so:
@todo = @project.todos.build or @todo =1. In Projectscontroller, in new method, you can write: 
@project.todos.new to instantiate a new Todo object.
<%= f.fields_for :todos, @project.todos.build %2. You can also do this in view: >
For strong params, you can include them in the following way:

Since, the Todo objects will be created through the creation of a Project object, so you have to specify this thing in Project model by adding the following line:

Chapter 55: Factory Girl
Section 55.1: Defining Factories
If you have a ActiveRecord User class with name and email attributes, you could create a factory for it by making the FactoryGirl guess it:

Or you can make it explicit and even change its name:

Then in your spec you can use the FactoryGirl's methods with these, like this:

The most common methods are:

Chapter 56: Import whole CSV files from specific folder
In this example, lets say we have many product CSV files in a folder. Each CSV file need to upload our database from our console write a command. Run the following command in a new or existing project to create this model.
Section 56.1: Uploads CSV from console command
Terminal Commands:

Lates create controller.
Terminal Commands:

Controller Code:

Model:

routes.rb

app/config/application.rb

Now open your development console & run
=> ProductsController.new.create #=> Uploads your whole CSV files from your folder directory
Chapter 57: Tools for Ruby on Rails code optimization and cleanup
Keeping your code clean and organized while developing a large Rails application can be quite a challenge, even for an experienced developer. Fortunately, there is a whole category of gems that make this job much easier.
Section 57.1: If you want to keep your code maintainable, secure and optimized, look at some gems for code optimization and cleanup :
Bullet
This one particularly blew my mind. The bullet gem helps you kill all the N+1 queries, as well as unnecessarily eager loaded relations. Once you install it and start visiting various routes in development, alert boxes with warnings indicating database queries that need to be optimized will pop out. It works right out of the box and is extremely helpful for optimizing your application.
Rails Best Practices
Static code analyzer for finding Rails specific code smells. It offers a variety of suggestions; use scope access, restrict auto-generated routes, add database indexes, etc. Nevertheless, it contains lots of nice suggestions that will give you a better perspective on how to re-factor your code and learn some best practices.
Rubocop
A Ruby static code analyzer which you can use to check if your code complies with the Ruby community code guidelines. The gem reports style violations through the command line, with lots of useful code refactoring goodies such as useless variable assignment, redundant use of Object#to_s in interpolation or even unused method argument.
A good thing is that it's highly configurable, since the analyzer can be quite irritating if you're not following the Ruby style guide 100% (i.e. you have lots of trailing whitespaces or you double quote your strings even when not interpolating, etc.).
It's divided into 4 sub-analyzers (called cops): Style, Lint, Metrics and Rails.
Chapter 58: ActiveJob
Active Job is a framework for declaring jobs and making them run on a variety of queuing backends. These jobs can be everything from regularly scheduled clean-ups, to billing charges, to mailings. Anything that can be chopped up into small units of work and run in parallel, really.
Section 58.1: Create the Job

Section 58.2: Enqueue the Job


Chapter 59: Active Model Serializers
ActiveModelSerializers, or AMS for short, bring 'convention over configuration' to your JSON generation. ActiveModelSerializers work through two components: serializers and adapters. Serializers describe which attributes and relationships should be serialized. Adapters describe how attributes and relationships should be serialized.
Section 59.1: Using a serializer


Chapter 60: Rails Engine - Modular Rails
Quick overview of Rails engines
Engines are small Rails applications that can be used to add functionalities to the application hosting them. The class defining a Ruby on Rails application is Rails::Application which actually inherits a lot of its behavior from Rails::Engine, the class defining an engine. We can say that a regular Rails application is simply an engine with more features.
Section 60.1: Create a modular app
# Getting started
First, let's generate a new Ruby on Rails application:

The next step is to generate an engine!

We will also create an 'engines' folder to store the engines (even if we just have one!).

Engines, just like gems, come with a gemspec file. Let's put some real values to avoid warnings.

Now we need to add the Todo engine to the parent application Gemfile.

Let's run bundle install. You should see the following in the list of gems:

Great, our Todo engine is loaded correctly! Before we start coding, we have one last thing to do: mount the Todo engine. We can do that in the routes.rb file in the parent app.

todoWe are mounting it at / but we could also make it accessible at /. Since we have only one module, / is fine.
Now you can fire up your server and check it in your browser. You should see the default Rails view because we didn't define any controllers/views yet. Let's do that now!
Building the Todo list
engine.rbWe are going to scaffold a model named Task inside the Todo module but to correctly migrate the database from the parent application, we need to add a small initializer to the  file.

That's it, now when we run migrations from the parent application, the migrations in the Todo engine will be loaded too.
Let's create the Task model. The scaffold command needs to be run from the engine folder. cd engines/todo && rails g scaffold Task title:string content:text Run the migrations from the parent folder:

Now, we just need to define the root route inside the Todo engine:

application.jsYou can play with it, create tasks, delete them... Oh wait, the delete is not working! Why?! Well, it seems JQuery is not loaded, so let's add it to the  file inside the engine!

Yay, now we can destroy tasks!

Chapter 61: Single Table Inheritance
Single Table Inheritance (STI) is a design pattern which is based on the idea of saving the data of multiple models which are all inheriting from the same Base model, into a single table in the database.
Section 61.1: Basic example
First we need a table to hold our data

Then lets create some models

Guest.create(name: 'Bob'type: 'Guest'When you do a ) ActiveRecord will translate this to create an entry in the Users table with .
bob = User.where(name: 'Bob').firstbob.becomes(UserWhen you retrieve the record  the object returned will be an instance of Guest, which can be forcibly treated as a User with )
becomes is most useful when dealing with shared partials or routes/controllers of the superclass instead of the subclass.
Section 61.2: Custom inheritance column
By default STI model class name is stored in a column named type. But its name can be changed by overriding inheritance_column value in a base class. E.g.:


Migration in this case will look as follows:

Admin.create, this record will be saved in the users table with entity_type = "Admin"When you do 
Section 61.3: Rails model with type column and without STI
Having type column in a Rails model without invoking STI can be achieved by assigning :_type_disabled to inheritance_column:


Chapter 62: ActiveRecord Transactions
ActiveRecord Transactions are protective blocks where sequence of active record queries are only permanent if they can all succeed as one atomic action.
Section 62.1: Getting Started with Active Record Transactions
Active Record Transactions can be applied to Model classes as well as Model instances, the objects within the transaction block need not all be instances of same class. This is because transactions are per-database connection, not per-model. For example:

Using save with a bang ensures that transaction will be automatically rolled back when the exception is thrown and after the rollback, control goes to the rescue block for the exception. Make sure you rescue the exceptions thrown from the save! in Transaction Block.
raise ActiveRecord::RollbackIf you don't want to use save!, you can manually raise  when the save fails. You
need not handle this exception. It will then rollback the transaction and take the control to the next statement after transaction block.

Chapter 63: Turbolinks
Turbolinks is a javascript library that makes navigating your web application faster. When you follow a link, Turbolinks automatically fetches the page, swaps in its <body>, and merges its <head>, all without incurring the cost of a full page load.
Section 63.1: Binding to turbolink's concept of a page load
With turbolinks, the traditional approach to using:

document).readywon't work. While using turbolinks, the $(() event will only fire once: on the initial page load.
document.readyFrom that point on, whenever a user clicks a link on your website, turbolinks will intercept the link click event and make an ajax request to replace the <body> tag and to merge the <head> tags. The whole process triggers the notion of a "visit" in turbolinks land. Therefore, instead of using the traditional () syntax above, you'll have to bind to turbolink's visit event like so:

Section 63.2: Disable turbolinks on specific links
It is very easy to disable turbolinks on specific links. According to the official turbolinks documentation:

Section 63.3: Understanding Application Visits
Application visits are initiated by clicking a Turbolinks-enabled link, or programmatically by calling

history.pushStateBy default, the visit function uses the 'advance' action. More understandably, the default behavior for the visit function is to advance to the page indicated by the "location" parameter. Whenever a page is visited, turbolinks pushes a new entry onto the browser's history using . The history is important because
turbolinks will try to use the history to load pages from cache whenever possible. This allows for extremely fast page rendering for frequently visited pages.
However, if you want to visit a location without pushing any history onto the stack, you can use the 'replace' action on the visit function like so:

This will replace the top of the history stack with the new page so that the total number of items on the stack remains unchanged.
There is also a "restore" action that aids in restoration vists, the visits that occur as a result of the user clicking the forward button or back button on their browser. Turbolinks handles these types of events internally and recommends that users don't manually tamper with the default behavior.
Section 63.4: Cancelling visits before they begin
turbolinks:before-visitTurbolinks provides an event listener that can be used to stop visits from occurring. Listen to the  event to be notified when a visit is about to commence.
In the event handler, you can use:

or

to retrieve the location of the visit. The visit can then be cancelled by calling:

NOTE:
According to the official turbolinks docs:
		Restoration visits cannot be canceled and do not fire turbolinks:before-visit.
Section 63.5: Persisting elements across page loads
Consider the following situation: Imagine that you are the developer of a social media website that allows users to be friends with other users and that employs turbolinks to make page loading faster. In the top right of every page on the site, there is a number indicating the total number of friends that a user currently has. Imagine you are using your site and that you have 3 friends. Whenever a new friend is added, you have some javascript that runs which updates the friend counter. Imagine that you just added a new friend and that your javascript ran properly and updated the friend count in the top right of the page to now render 4. Now, imagine that you click the browser's back button. When the page loads, you notice that the friend counter says 3 even though you have four friends.
This is a relatively common problem and one that turbolinks has provided a solution for. The reason the problem occurs is because turbolinks automatically loads pages from the cache when a user clicks the back button. The cached page won't always be updated with the database.
To solve this issue, imagine that you render the friend count inside a <div> tag with an id of "friend-count":

data-turbolinks-permanentBy adding the  attribute, you're telling turbolinks to persist certain elements across page loads. The official docs say:
Designate permanent elements by giving them an HTML id and annotating them with data-turbolinkspermanent. Before each render, Turbolinks matches all permanent elements by id and transfers them from the original page to the new page, preserving their data and event listeners.

Chapter 64: Friendly ID
FriendlyId is the "Swiss Army bulldozer" of slugging and permalink plugins for Active Record. It lets you create pretty URLs and work with human-friendly strings as if they were numeric ids. With FriendlyId, it's easy to make your application use URLs like:
http://example.com/states/washington
Section 64.1: Rails Quickstart

Gemfile rake db:migrate
edit app/models/user.rb



A new "candidates" functionality which makes it easy to set up a list of alternate slugs that can be used to uniquely distinguish records, rather than appending a sequence. For example:


Set slug limit length using friendly_id gem?


Chapter 65: Securely storing authentication keys
Many third-party APIs require a key, allowing them to prevent abuse. If they issue you a key, it's very important that you not commit the key into a public repository, as this will allow others to steal your key.
Section 65.1: Storing authentication keys with Figaro
gem 'figaro' to your Gemfile and run bundle install. Then run bundle exec figaro installAdd ; this will
create config/application.yml and add it to your .gitignore file, preventing it from being added to version control.
You can store your keys in application.yml in this format:

where SECRET_NAME and secret_value are the name and value of your API key.
You also need to name these secrets in config/secrets.yml. You can have different secrets in each environment. The file should look like this:

How you use these keys varies, but say for example some_component in the development environment needs access to secret_name. In config/environments/development.rb, you'd put:

Finally, let's say you want to spin up a production environment on Heroku. This command will upload the values in config/environments/production.rb to Heroku:

Chapter 66: Authenticate Api using Devise
Devise is authentication solution for Rails. Before going any further i would like to add quick note on API. So API does not handle sessions (is stateless) which means one that provide response after you request, and then requires no further attention, which means no previous or future state is required for the system to work hence whenever we requesting to the server need to pass authentication details with all API and should tell Devise not to store authentication details.
Section 66.1: Getting Started
So first we will create rails project and setup device create a rails application

now add devise to gem list
		you can find a file named 'Gemfile' at the root of rails project
Then run bundle install
Next, you need to run the generator:

Now on console you can find few instructions just follow it.
Generate devise model

Then run rake db:migrate
For more details go to: Devise Gem
Authentication Token
Authentication token is used to authenticate a user with a unique token, So Before we proceed with the logic first we need to add auth_token field to a Devise model
Hence,

Then run rake db:migrate
app/controllers/application_controllers.rbNow we are all set to do authentication using auth_token In 
First this line to it

this will help rails application respond with both html and json Then

will change this :null as we are not dealing with sessions.
now we will add authentication method in application_controller
So, by default Devise uses email as unique field we can also use custom fields, for this case we will be authenticating using user_email and auth_token.

store: falseOn line 6 in the above code you can see that i have set  which will prevent from creating a session on each requests hence we achieved stateless re
Chapter 67: Integrating React.js with Rails Using Hyperloop
This topic covers integrating React.js with Rails using the Hyperloop gem
Other approaches not covered here are using the react-rails or react_on_rails gems.
Section 67.1: Adding a simple react component (written in ruby) to your Rails app
1. Add the hyperloop gem to your rails (4.0 - 5.1) Gemfile
2. bundle install
3. Add the hyperloop manifest to the application.js file: // app/assets/javascripts/application.js ... //= hyperlooploader
hyperloop/components4. Create your react components, and place them in the  directory #
app/hyperloop/components/hello_world.rb class HelloWorld < Hyperloop::Component after_mount do every(1.second) { mutate.current_time(Time.now) } end render do "Hello World! The time is now: #{state.current_time}" end end
5. Components act just like views. They are "mounted" using the render_component method in a controller: # somewhere in a controller: ... def hello_world render_component # renders HelloWorld based on method name end
Section 67.2: Callbacks

Section 67.3: Declaring component parameters (props)


Section 67.4: HTML Tags

Section 67.5: Event Handlers

Section 67.6: States

Note that states can be shared between components using Hyperloop::Stores
Chapter 68: Change a default Rails application enviornment
This will discuss how to change the environment so when someone types rails s they boot in not development but in the environment they want.
Section 68.1: Running on a local machine
Normally when rails environment is run by typing. This just runs the default environment which is usually development

The specific environment can be selected by using the flag -e for example:

Which will run the test environment.
~/.bashrcThe default environment can be changed in terminal by editing the  file, and adding the following line:

Section 68.2: Running on a server
If running on a remote server that is using Passenger change apache.conf to to the environment you want to use.
For example this case you see RailsEnv production.

Chapter 69: Rails -Engines
Parameters	Purpose
--mountable option tells the generator that you want to create a "mountable" and namespace-isolated engine
--full	option tells the generator that you want to create an engine, including a skeleton structure
Engines can be considered miniature applications that provide functionality to their host applications. A Rails application is actually just a "supercharged" engine, with the Rails::Application class inheriting a lot of its behavior from Rails::Engine.
Engines are the reusable rails applications/plugins. It works like a Gem. Famous engines are Device, Spree gems which can be integrated with rails applications easily.
Section 69.1: Famous examples are
Generating simple blog engine

Famous engines examples are
Device (authentication gem for rails)
Spree (Ecommerce)

Chapter 70: Adding an Amazon RDS to your rails application
Steps to create an AWS RDS instance and configure your database.yml file by installing the required connectors.
Section 70.1: Consider we are connecting MYSQL RDS with your rails application
Steps to create MYSQL database
1. Login to amazon account and select RDS service
2. Select Launch DB Instance from the instance tab
3. By defaul MYSQL Community Edition will be selected, hence click the SELECT button
next step4. Select the database purpose, say production and click 
mysql version, storage size, DB Instance Identifier, Master Username and Passwordnext step5. Provide the and click 
6. Enter Database Name and click Launch DB Instance
7. Please wait until all the instance gets created. Once the instance gets created you will find an Endpoint, copy this entry point (which is referred as hostname)
Installing connectors
Add the MySQL database adapter to your project's gemfile,

Install your added gems,

Some other database adapters are,
gem 'pg'gem 'activerecord-oracle_enhanced-adapter'gem 'sql_server' for PostgreSQL  for Oracle  for SQL Server
Configure your project's database.yml file Open your config/database.yml file

Chapter 71: Payment feature in rails
This document pretend to introduce you, with a complete example, how you can implement different payment methods with Ruby on Rails.
In the example, we will cover Stripe and Braintree two very well-known payment platforms.
Section 71.1: How to integrate with Stripe
Add Stripe gem to our Gemfile

initializers/stripe.rbAdd  file. This file contains the necessary keys for connecting with your stripe account.
Stripe.api_key = Rails.configuration.stripe[:secret_key]
How to create a new customer to Stripe
Stripe::Customer.create({email: email, source: payment_token})
This code creates a new customer on Stripe with given email address and source.
payment_token is the token given from the client-side that contains a payment method like a credit card or bank account. More info: Stripe.js client-side

This code retrieves a plan from Stripe by its id.
How to create a subscription
When we have a customer and a plan we can create a new subscription on Stripe.

It will create a new subscription and will charge our User. It's important to know what really happens on Stripe when we subscribe a user to a plan, you will find more info here: Stripe Subscription lifecycle.
How to charge a user with a single payment
Sometimes we want to charge our users just a single time, for do that we will do the next.
Stripe::Charge.create(amount:   amount, customer: customer, currency: currency)
In that case, we are charging our user one time for given amount.
Common errors:
The amount must be sent in integer form, that means, 2000 will be 20 units of currency. Check this example
You cannot charge a user in two currencies. If the user was charged in EUR at any moment in the past you cannot charge the user in USD.
 You cannot charge user without source (payment method).

Chapter 72: Rails on docker
This tutorial will start with Docker installed and with a Rails app
Section 72.1: Docker and docker-compose
First of all, we will need to create our Dockerfile. A good example can be found on this blog by Nick Janetakis.
This code contains the script that will be executed on our docker machine at the moment of start.For this reason, we are installing all the required libraries and ends with the start of Puma (RoR dev server)

docker-compose.ymlAlso, we will use docker-compose, for that, we will create . The explanation of this file will be more a docker-compose tutorial than an integration with Rails and I will not cover here.

docker-compose upJust with these two files you will have enough to run  and wake up your docker

Appendix A: Reserved Words
You should be careful using these words for variable, model name, method name or etc.
Section A.1: Reserved Word List
ADDITIONAL_LOAD_PATHS
ARGF
ARGV
ActionController
ActionView
ActiveRecord
ArgumentError
Array
BasicSocket
Benchmark
Bignum
Binding
CGI
CGIMethods
CROSS_COMPILING
Class
ClassInheritableAttributes
Comparable
ConditionVariable
Config
Continuation
DRb
DRbIdConv
DRbObject
DRbUndumped
Data Date
DateTime
Delegater
Delegator
Digest
Dir
ENV
EOFError
ERB
Enumerable
Errno
Exception
FALSE
FalseClass
Fcntl
File
FileList
FileTask

FileTest
FileUtils
Fixnum
Float
FloatDomainError
GC
Gem
GetoptLong
Hash
IO
IOError
IPSocket
IPsocket
IndexError
Inflector
Integer
Interrupt
Kernel
LN_SUPPORTED
LoadError
LocalJumpError
Logger
Marshal
MatchData
MatchingData
Math
Method
Module
Mutex
Mysql
MysqlError
MysqlField
MysqlRes
NIL
NameError
NilClass
NoMemoryError
NoMethodError
NoWrite
NotImplementedError
Numeric
OPT_TABLE
Object
ObjectSpace
Observable
Observer
PGError PGconn PGlarge
PGresult
PLATFORM
PStore
ParseDate
Precision
Proc
Process
Queue
RAKEVERSION
RELEASE_DATE
RUBY
RUBY_PLATFORM
RUBY_RELEASE_DATE
RUBY_VERSION
Rack
Rake
RakeApp
RakeFileUtils
Range
RangeError
Rational
Regexp
RegexpError
Request
RuntimeError
STDERR
STDIN
STDOUT
ScanError
ScriptError
SecurityError
Signal
SignalException
SimpleDelegater SimpleDelegator
Singleton
SizedQueue Socket
SocketError
StandardError String
StringScanner
Struct
Symbol
SyntaxError
SystemCallError
SystemExit
SystemStackError
TCPServer TCPSocket TCPserver
TCPsocket
TOPLEVEL_BINDING TRUE
Task
Text
Thread
ThreadError
ThreadGroup
Time
Transaction
TrueClass
TypeError
UDPSocket UDPsocket
UNIXServer UNIXSocket UNIXserver
UNIXsocket
UnboundMethod
Url
VERSION
Verbose
YAML
ZeroDivisionError @base_path accept Acces Axi action attributes application2 callback category connection database dispatcher display1 drive errors format host key layout load link new notify open public quote render request records responses save scope send session system template test timeout to_s type URI
visits
Observer
Database Field Names
created_at created_on updated_at updated_on deleted_at (paranoia gem)
lock_version type id
#{table_name}_count position parent_id
lft rgt quote_value
Ruby Reserved Words
alias
and BEGIN begin break case class def defined? do
else elsif
END end ensure false

for
if
module next
nil not or redo rescue retry return self super then true undef unless until when while yield _ FILE _
_ LINE _

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
AbdullahChapters 7, 12 and 13abhasChapter 40AbhinayChapter 10Adam LassekChapters 2, 5, 6, 9, 12, 13, 38, 40 and 42Ahsan MahmoodChapter 25Aigars CibuļskisChapter 5Ajay BarotChapters 1 and 13Akshay BoradeChapter 57Ali MasudianPourChapter 16Andy GaugeChapter 2AnoEChapter 3Antarr ByrdChapter 10Arslan AliChapter 54ArtOfCodeChapter 20Ashish BistaChapter 41AswathyChapter 1Atul KhanduriChapters 7 and 14AvdeptChapter 13Awais ShafqatChapter 35B LiuChapter 37B8vredeChapter 33Bijal GajjarChapter 3br3ntChapters 7 and 13BrianChapter 58burenChapter 5cl3mChapter 2Cuisine HackerChapter 20Cyril DuchonChapters 2 and 17DChapter 3Dénes PappChapter 32danirodChapter 4Darpan ChhatravalaChapters 1 and 48Darshan PatelChapter 1DawnPaladinChapter 65DeepChapters 21, 27 and 47Deepak KabburChapter 69Deepak MahakaleChapters 1, 2, 5 and 12dgilperezChapters 10, 12 and 25Dharam GollapudiChapters 2, 15 and 32dnshChapter 13dodo121Chapter 12Don GiovanniChapter 43elasticmanChapter 4Emre KurtChapter 73esthervillarsChapter 2Fabio RosChapters 2, 13 and 46fiedlChapter 18
FireChapters 2 and 21FlambinoChapter 7foolChapter 56Francesco Lupo RenziChapters 2, 5, 13, 17 and 21fybw idChapter 29GastonChapter 6GeoffroyChapter 1glapworthChapter 3gwcodesChapter 17hadeesChapter 47Hardik Kanjariya ツChapter 5Hardik UpadhyayChapters 6, 11, 12 and 15hgsongraChapters 7 and 34HizqeelChapter 2HParkerChapters 47, 50 and 51hschinChapters 5, 27, 36 and 37HungryCoderChapter 2IchChapter 8inyeChapter 6jackerman09Chapters 14, 15 and 21jeffdill2Chapters 5 and 13Jeremy GreenChapter 15jkdevChapter 2Joel DrapperChapter 3Jon WoodChapter 2Jorge Najera TChapter 17KelseydhChapter 32Kevin SylvestreChapter 2kfrzChapter 1Khanh PhamChapters 11 and 20Kieran AndrewsChapters 2, 10 and 22Kimmo HintikkaChapter 44Kirti ThoratChapters 1, 2 and 5KULKINGChapters 2, 5 and 22LahiruChapter 17LomefinChapter 49Lorenzo BaracchiChapter 1Luc BoissayeChapter 43Luka KerrChapters 1, 3, 4, 6, 7, 10 and 11maartenvanvlietChapters 3 and 5Manish AgarwalChapters 5 and 11marcamillionChapters 3 and 15Mario UherChapter 2MarkChapter 63Marko KacanskiChapter 7Mayur ShahChapter 60ma_ilChapters 6 and 27michaelpriChapters 1 and 30MihaiChapter 28MikeAndrChapter 13MilindChapters 2 and 45Milo PChapter 5Mitch VanDuynChapter 67
mlabarcaChapter 25MMachinegunChapters 4 and 27mmichaelChapter 12Muaaz RafiChapters 6 and 31nifCodyChapter 1NiyantaChapter 11nomatteusChapters 5 and 15nuclearpidgeonChapter 2olive_treeChapter 1Omar AliChapters 58 and 59pablofullanaChapter 12pastulloChapter 2powerup7Chapters 3, 6, 13 and 15ppascualvChapters 71 and 72PragashChapter 4RADanChapter 1Rafael CostaChapter 55Rahul SinghChapter 2Raynor KuangChapters 2 and 11rdnewmanChapter 13RebootChapters 5 and 13ReubChapter 15Richard HamiltonChapters 1, 2, 5, 12, 14, 15, 22 and 39riiChapter 5RobinChapters 2, 5, 13 and 29Rodrigo ArgumedoChapters 5 and 14rogerdpackChapter 2rony36Chapters 5 and 6Rory O'KaneChapters 2 and 5RuslanChapter 61Ryan HilbertChapter 2Ryan KChapters 2, 23 and 26sa77Chapters 1, 13 and 32saadluluChapter 1Sapna JindalChapters 11 and 62Sathishkumar JayarajChapters 1 and 70Scott MatthewmanChapter 41SebastialonsoChapter 3Sergey KhmelevskoyChapter 19Shivasubramanian AChapter 53Silviu SimeriaChapter 2Simon TsangChapter 39Simone CarlettiChapters 3 and 41SladeyChapter 8Slava.KChapter 61sohail khalilChapter 2Sven ReuterChapters 3, 7 and 21tesChapter 26tessiChapter 5Thang Le SyChapter 64theoretischChapter 1thiago araujoChapter 24tirdadcChapter 52
titanChapter 32toobulkehChapter 61Umar KhanChapter 33UndoChapters 2 and 8uzaifChapters 1 and 5Vishal Taj PMChapters 13 and 66Volodymyr BalytskyyChapters 1, 4 and 11WhitecatChapter 68William RomeroChapter 14Xinyang LiChapter 7YanaChapter 1ZoranChapter 2孙悟空Chapter 2
You may also like

















GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1

GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1



GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1





GoalKicker.com - Ruby(r) on Rails Notes for Professionals	213

GoalKicker.com - Ruby(r) on Rails Notes for Professionals	213



GoalKicker.com - Ruby(r) on Rails Notes for Professionals	213





GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1

GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1



GoalKicker.com - Ruby(r) on Rails Notes for Professionals	1













