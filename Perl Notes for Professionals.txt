

Contents
About  ................................................................................................................................................................................... 1
Chapter 1: Getting started with Perl Language  ............................................................................................ 2
Section 1.1: Getting started with Perl  ............................................................................................................................ 2
Chapter 2: Comments  ................................................................................................................................................. 4
Section 2.1: Single-line comments  ................................................................................................................................ 4
Section 2.2: Multi-line comments  ................................................................................................................................. 4
Chapter 3: Variables  .................................................................................................................................................... 5
Section 3.1: Scalars  ........................................................................................................................................................ 5 Section 3.2: Array References  ...................................................................................................................................... 5
Section 3.3: Scalar References  ..................................................................................................................................... 6
Section 3.4: Arrays  ......................................................................................................................................................... 7
Section 3.5: Typeglobs, typeglob refs, filehandles and constants  ........................................................................... 8
Section 3.6: Sigils  ............................................................................................................................................................ 9
Section 3.7: Hash References  ..................................................................................................................................... 11
Section 3.8: Hashes  ..................................................................................................................................................... 12
Chapter 4: Interpolation in Perl  .......................................................................................................................... 15
Section 4.1: What is interpolated  ................................................................................................................................ 15
Section 4.2: Basic interpolation  .................................................................................................................................. 16
Chapter 5: True and false  ...................................................................................................................................... 18
Section 5.1: List of true and false values  ................................................................................................................... 18
Chapter 6: Dates and Time  .................................................................................................................................... 19
Section 6.1: Date formatting  ....................................................................................................................................... 19 Section 6.2: Create new DateTime  ............................................................................................................................ 19
Section 6.3: Working with elements of datetime  ..................................................................................................... 19
Section 6.4: Calculate code execution time  .............................................................................................................. 20
Chapter 7: Control Statements  ........................................................................................................................... 21
Section 7.1: Conditionals  .............................................................................................................................................. 21
Section 7.2: Loops  ....................................................................................................................................................... 21
Chapter 8: Subroutines  ............................................................................................................................................ 23
Section 8.1: Creating subroutines  ............................................................................................................................... 23
Section 8.2: Subroutines  ............................................................................................................................................. 24
Section 8.3: Subroutine arguments are passed by reference (except those in signatures)  ............................... 25
Chapter 9: Debug Output  ....................................................................................................................................... 27
Section 9.1: Dumping with Style  ................................................................................................................................. 27
Section 9.2: Dumping data-structures  ...................................................................................................................... 28 Section 9.3: Data::Show  ............................................................................................................................................... 28
Section 9.4: Dumping array list  .................................................................................................................................. 29
Chapter 10: Lists  .......................................................................................................................................................... 31
Section 10.1: Array as list  ............................................................................................................................................. 31 Section 10.2: Assigning a list to a hash  ...................................................................................................................... 31
Section 10.3: Lists can be passed into subroutines  .................................................................................................. 31
Section 10.4: Return list from subroutine  .................................................................................................................. 32
Section 10.5: Hash as list  ............................................................................................................................................. 33
Section 10.6: Using arrayref to pass array to sub  ................................................................................................... 33
Chapter 11: Sorting  ..................................................................................................................................................... 34 Section 11.1: Basic Lexical Sort  .................................................................................................................................... 34 Section 11.2: The Schwartzian Transform  ................................................................................................................. 34
Section 11.3: Case Insensitive Sort  .............................................................................................................................. 35 Section 11.4: Numeric Sort  ........................................................................................................................................... 35
Section 11.5: Reverse Sort  ........................................................................................................................................... 35
Chapter 12: File I/O (reading and writing files)  ........................................................................................... 36
Section 12.1: Opening A FileHandle for Reading  ...................................................................................................... 36
Section 12.2: Reading from a file  ............................................................................................................................... 36
Section 12.3: Write to a file  .......................................................................................................................................... 37
Section 12.4: "use autodie" and you won't need to check file open/close failures  .............................................. 37
Section 12.5: Rewind a filehandle  ............................................................................................................................... 38
Section 12.6: Reading and Writing gzip compressed files  ....................................................................................... 38
Section 12.7: Setting the default Encoding for IO  ..................................................................................................... 39
Chapter 13: Reading a file's content into a variable  ................................................................................ 40
Section 13.1: Path::Tiny  ................................................................................................................................................. 40
Section 13.2: The manual way  .................................................................................................................................... 40 Section 13.3: File::Slurp  ................................................................................................................................................. 40 Section 13.4: File::Slurper  ............................................................................................................................................. 41
Section 13.5: Slurping a file into an array variable  ................................................................................................... 41
Section 13.6: Slurp file in one-liner  .............................................................................................................................. 41
Chapter 14: Strings and quoting methods  .................................................................................................... 42
Section 14.1: String Literal Quoting  ............................................................................................................................. 42
Section 14.2: Double-quoting  ...................................................................................................................................... 42 Section 14.3: Heredocs  ................................................................................................................................................ 43
Section 14.4: Removing trailing newlines  .................................................................................................................. 44
Chapter 15: Split a string on unquoted separators  ................................................................................... 46
Section 15.1: parse_line()  ............................................................................................................................................ 46
Section 15.2: Text::CSV or Text::CSV_XS  .................................................................................................................... 46
Chapter 16: Object-oriented Perl  ........................................................................................................................ 47
Section 16.1: Defining classes in modern Perl  ........................................................................................................... 47 Section 16.2: Creating Objects  .................................................................................................................................... 47
Section 16.3: Defining Classes  .................................................................................................................................... 48
Section 16.4: Inheritance and methods resolution  ................................................................................................... 49
Section 16.5: Class and Object Methods  .................................................................................................................... 51
Section 16.6: Roles  ....................................................................................................................................................... 52
Chapter 17: Exception handling  ........................................................................................................................... 54
Section 17.1: eval and die  ............................................................................................................................................ 54
Chapter 18: Regular Expressions  ........................................................................................................................ 55
Section 18.1: Replace a string using regular expressions  ........................................................................................ 55
Section 18.2: Matching strings  .................................................................................................................................... 55 Section 18.3: Parsing a string with a regex  ............................................................................................................... 55
Section 18.4: Usage of \Q and \E in pattern matching  ........................................................................................... 56
Chapter 19: XML Parsing  .......................................................................................................................................... 57
Section 19.1: Parsing with XML::Twig  .......................................................................................................................... 57
Section 19.2: Consuming XML with XML::Rabbit  ....................................................................................................... 58
Section 19.3: Parsing with XML::LibXML  ..................................................................................................................... 60
Chapter 20: Unicode  .................................................................................................................................................. 62
Section 20.1: The utf8 pragma: using Unicode in your sources  ............................................................................. 62
Section 20.2: Handling invalid UTF-8  ........................................................................................................................ 62
Section 20.3: Command line switches for one-liners  ............................................................................................... 63 Section 20.4: Standard I/O  ......................................................................................................................................... 64 Section 20.5: File handles  ........................................................................................................................................... 64 Section 20.6: Create filenames  .................................................................................................................................. 65
Section 20.7: Read filenames  ..................................................................................................................................... 66
Chapter 21: Perl one-liners  ..................................................................................................................................... 68
Section 21.1: Upload file into mojolicious  ................................................................................................................... 68 Section 21.2: Execute some Perl code from command line  .................................................................................... 68
Section 21.3: Using double-quoted strings in Windows one-liners  ......................................................................... 68 Section 21.4: Print lines matching a pattern (PCRE grep)  ....................................................................................... 68
Section 21.5: Replace a substring with another (PCRE sed)  ................................................................................... 69
Section 21.6: Print only certain fields  ......................................................................................................................... 69 Section 21.7: Print lines 5 to 10  .................................................................................................................................... 69
Section 21.8: Edit file in-place  ..................................................................................................................................... 69
Section 21.9: Reading the whole file as a string  ....................................................................................................... 69
Chapter 22: Randomness  ........................................................................................................................................ 70
Section 22.1: Accessing an array element at random  ............................................................................................. 70
Section 22.2: Generate a random integer between 0 and 9  .................................................................................. 70
Chapter 23: Special variables  ............................................................................................................................... 71
Section 23.1: Special variables in perl:  ....................................................................................................................... 71
Chapter 24: Packages and modules  ................................................................................................................. 72
Section 24.1: Using a module  ..................................................................................................................................... 72 Section 24.2: Using a module inside a directory  ...................................................................................................... 72
Section 24.3: Loading a module at runtime  .............................................................................................................. 73
Section 24.4: CPAN.pm  ................................................................................................................................................ 73 Section 24.5: List all installed modules  ...................................................................................................................... 74
Section 24.6: Executing the contents of another file  ............................................................................................... 74
Chapter 25: Install Perl modules via CPAN  .................................................................................................... 75
Section 25.1: cpanminus, the lightweight configuration-free replacement for cpan  ........................................... 75
Section 25.2: Installing modules manually  ............................................................................................................... 75
Section 25.3: Run Perl CPAN in your terminal (Mac and Linux) or command prompt (Windows)  .................... 76
Chapter 26: Easy way to check installed modules on Mac and Ubuntu  ......................................... 78
Section 26.1: Use perldoc to check the Perl package install path  .......................................................................... 78
Section 26.2: Check installed perl modules via terminal  ......................................................................................... 78
Section 26.3: How to check Perl corelist modules  .................................................................................................... 78
Chapter 27: Pack and unpack  .............................................................................................................................. 79
Section 27.1: Manually Converting C Structs to Pack Syntax  .................................................................................. 79
Section 27.2: Constructing an IPv4 header  ............................................................................................................... 80
Chapter 28: Perl commands for Windows Excel with Win32::OLE module  .................................... 82
Section 28.1: Opening and Saving Excel/Workbooks  .............................................................................................. 82
Section 28.2: Manipulation of Worksheets  ............................................................................................................... 82 Section 28.3: Manipulation of cells  ............................................................................................................................ 83
Section 28.4: Manipulation of Rows / Columns  ....................................................................................................... 84
Chapter 29: Simple interaction with database via DBI module  .......................................................... 85
Section 29.1: DBI module  ............................................................................................................................................ 85
Chapter 30: Perl Testing  ......................................................................................................................................... 87
Section 30.1: Perl Unit Testing Example  .................................................................................................................... 87
Chapter 31: Dancer  ..................................................................................................................................................... 89 Section 31.1: Easiest example  ...................................................................................................................................... 89 Chapter 32: Attributed Text  ................................................................................................................................... 90
Section 32.1: Printing colored Text  ............................................................................................................................. 90
Chapter 33: GUI Applications in Perl  .................................................................................................................. 91
Section 33.1: GTK Application  ..................................................................................................................................... 91
Chapter 34: Memory usage optimization  ...................................................................................................... 92
Section 34.1: Reading files: foreach vs. while  ............................................................................................................ 92
Section 34.2: Processing long lists  ............................................................................................................................. 92
Chapter 35: Perl script debugging  ..................................................................................................................... 93
Section 35.1: Run script in debug mode  .................................................................................................................... 93
Section 35.2: Use a nonstandard debugger  ............................................................................................................. 93
Chapter 36: Perlbrew  ................................................................................................................................................ 94
Section 36.1: Setup perlbrew for the first time  .......................................................................................................... 94
Chapter 37: Installation of Perl  ........................................................................................................................... 95
Section 37.1: Linux  ........................................................................................................................................................ 95 Section 37.2: OS X  ........................................................................................................................................................ 95
Section 37.3: Windows  ................................................................................................................................................. 96
Chapter 38: Compile Perl cpan module sapnwrfc from source code  .............................................. 97
Section 38.1: Simple example to test the RFC connection  ....................................................................................... 97
Chapter 39: Best Practices  ..................................................................................................................................... 98
Section 39.1: Using Perl::Critic  ..................................................................................................................................... 98
Credits  ............................................................................................................................................................................ 102
You may also like  ...................................................................................................................................................... 104

About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/PerlBook
This Perl(r) Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Perl(r) group(s) or company(s) nor Stack Overflow. All trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Perl Language
Version Release Notes Release Date
1.0001987-12-182.0001988-06-053.0001989-10-184.0001991-03-215.0001994-10-175.0011995-05-135.0021996-02-295.0031996-06-255.004perl5004delta	1997-05-155.005perl5005delta	1998-07-225.6.0perl56delta	2000-03-225.8.0perl58delta	2002-07-185.8.8perl581delta, perl582delta, perl583delta,
perl584delta,
               2006-02-01 perl585delta, perl586delta, perl587delta, perl588delta5.10.0perl5100delta	2007-12-185.12.0perl5120delta	2010-04-125.14.0perl5140delta	2011-05-145.16.0perl5160delta	2012-05-205.18.0perl5180delta	2013-05-185.20.0perl5200delta	2014-05-275.22.0perl5220delta	2015-06-015.24.0perl5240delta	2016-05-095.26.0perl5260delta	2017-05-30Section 1.1: Getting started with Perl
Perl tries to do what you mean:

The two tricky bits are the semicolon at the end of the line and the \n, which adds a newline (line feed). If you have a relatively new version of perl, you can use say instead of print to have the carriage return added automatically:

use v5.10The say feature is also enabled automatically with a  (or higher) declaration:


It's pretty common to just use perl on the command line using the -e option:

Adding the -l option is one way to print newlines automatically:
Hello World
Version ≥ 5.10.0
If you want to enable new features, use the -E option instead:

perl script.plYou can also, of course, save the script in a file. Just remove the -e command line option and use the filename of the script: . For programs longer than a line, it's wise to turn on a couple of options:

There's no real disadvantage other than making the code slightly longer. In exchange, the strict pragma prevents you from using code that is potentially unsafe and warnings notifies you of many common errors.
Notice the line-ending semicolon is optional for the last line, but is a good idea in case you later add to the end of your code.
For more options how to run Perl, see perlrun or type perldoc perlrun at a command prompt. For a more detailed introduction to Perl, see perlintro or type perldoc perlintro at a command prompt. For a quirky interactive tutorial, Try Perl.
Chapter 2: Comments
Section 2.1: Single-line comments
Single-line comments begin with a pound sign # and go to the end of the line:

Section 2.2: Multi-line comments
=cutMulti-line comments start with = and with the  statement. These are special comments called POD (Plain Old Documentation).
Any text between the markers will be commented out:


Chapter 3: Variables
Section 3.1: Scalars
Scalars are Perl's most basic data type. They're marked with the sigil $ and hold a single value of one of three types:

Perl converts between numbers and strings on the fly, based on what a particular operator expects.
my $number = '41';                    # string '41' my $meaning = $number + 1;            # number  42 my $sadness = '20 apples';            # string '20 apples' my $danger = $sadness * 2;            # number '40', raises warning
When converting a string into a number, Perl takes as many digits from the front of a string as it can - hence why 20 apples is converted into 20 in the last line.
Based on whether you want to treat the contents of a scalar as a string or a number, you need to use different operators. Do not mix them.

Attempting to use string operations on numbers will not raise warnings; attempting to use number operations on non-numeric strings will. Do be aware that some non-digit strings such as 'inf', 'nan', '0 but true' count as numbers.
Section 3.2: Array References
Array References are scalars ($) which refer to Arrays.

These can be created more short-hand as follows:

Modifying / Using array references require dereferencing them first.
my @contents = @{ $array_reference };               # Prefix notation my @contents = @$array_reference;                   # Braces can be left out
Version ≥ 5.24.0
New postfix dereference syntax, available by default from v5.24

When accessing an arrayref's contents by index you can use the -> syntactical sugar.
 my @array = qw(one two three);      my $arrayref = [ qw(one two three) ] my $one = $array[0];                my $one = $arrayref->[0]; Unlike arrays, arrayrefs can be nested:
my @array = ( (1, 0), (0, 1) )  # ONE array of FOUR elements: (1, 0, 0, 1) my @matrix = ( [1, 0], [0, 1] ) # an array of two arrayrefs my $matrix = [ [0, 1], [1, 0] ] # an arrayref of arrayrefs
# There is no namespace conflict between scalars, arrays and hashes # so @matrix and $matrix _both_ exist at this point and hold different values.
my @diagonal_1 = ($matrix[0]->[1], $matrix[1]->[0])     # uses @matrix my @diagonal_2 = ($matrix->[0]->[1], $matrix->[1]->[0]) # uses $matrix
# Since chained []- and {}-access can only happen on references, you can # omit some of those arrows.
my $corner_1 = $matrix[0][1];   # uses @matrix; my $corner_2 = $matrix->[0][1]; # uses $matrix;  
When used as Boolean, references are always true.
Section 3.3: Scalar References
A reference is a scalar variable (one prefixed by $ ) which "refers to" some other data.

To get the referred-to data, you de-reference it.
say ${$reference};                  # Explicit prefix syntax
say $$reference;                    # The braces can be left out (confusing)
Version ≥ 5.24.0
New postfix dereference syntax, available by default from v5.24

This "de-referenced value" can then be changed like it was the original variable.

A reference is always truthy - even if the value it refers to is falsy (like 0 or "").
You may want a Scalar Reference If:
You want to pass a string to a function, and have it modify that string for you without it being a return value.
You wish to explicitly avoid Perl implicitly copying the contents of a large string at some point in your function passing ( especially relevant on older Perls without copy-on-write strings )
 You wish to disambiguate string-like values with specific meaning, from strings that convey content, for example:
Disambiguate a file name from file content
Disambiguate returned content from a returned error string
 You wish to implement a lightweight inside out object model, where objects handed to calling code don't carry user visible metadata:

Section 3.4: Arrays
Arrays store an ordered sequence of values. You can access the contents by index, or iterate over them. The values will stay in the order you filled them in.
my @numbers_to_ten = (1,2,3,4,5,6,7,8,9,10); # More conveniently: (1..10) my @chars_of_hello = ('h','e','l','l','o'); my @word_list = ('Hello','World');
# Note the sigil: access an @array item with $array[index] my $second_char_of_hello = $chars_of_hello[1]; # 'e'
# Use negative indices to count from the end (with -1 being last) my $last_char_of_hello = $chars_of_hello[-1];
# Assign an array to a scalar to get the length of the array my $length_of_array = @chars_of_hello; # 5
# You can use $# to get the last index of an array, and confuse Stack Overflow my $last_index_of_array = $#chars_of_hello; # 4
# You can also access multiple elements of an array at the same time
# This is called "array slice" # Since this returns multiple values, the sigil to use here on the RHS is @ my @some_chars_of_hello = @chars_of_hello[1..3]; # ('H', 'e', 'l') my @out_of_order_chars = @chars_of_hello[1,4,2]; # ('e', 'o', 'l')
# In Python you can say array[1:-1] to get all elements but first and last # Not so in Perl: (1..-1) is an empty list. Use $# instead my @empty_list = @chars_of_hello[1..-1];                           # () my @inner_chars_of_hello = @chars_of_hello[1..$#chars_of_hello-1]; # ('e','l','l') # Access beyond the end of the array yields undef, not an error my $undef = $chars_of_hello[6]; # undef    Arrays are mutable:
use utf8; # necessary because this snippet is utf-8
$chars_of_hello[1] = 'u';              #     ('h','u','l','l','o') push @chars_of_hello, ('!', '!');      #     ('h','u','l','l','o','!','!') pop @chars_of_hello;                   #     ('h','u','l','l','o','!') shift @chars_of_hello;                 #         ('u','l','l','o','!') unshift @chars_of_hello, ('¡', 'H');   # ('¡','H','u','l','l','o','!')
@chars_of_hello[2..5] = ('O','L','A'); # ('¡','H','O','L','A',undef,'!') whoops! delete $chars_of_hello[-2];            # ('¡','H','O','L','A',      '!')
# Setting elements beyond the end of an array does not result in an error # The array is extended with undef's as necessary. This is "autovivification." my @array;           # ()
 my @array[3] = 'x';  # (undef, undef, undef, 'x') Finally, you can loop over the contents of an array:

When used as booleans, arrays are true if they are not empty.
Section 3.5: Typeglobs, typeglob refs, filehandles and constants
A typeglob *foo holds references to the contents of global variables with that name: $foo, @foo, $foo, &foo, etc. You can access it like an hash and assign to manipulate the symbol tables directly (evil!).

Typeglobs are more commonly handled when dealing with files. open, for example, produces a reference to a typeglob when asked to create a non-global filehandle:

use constantTypeglobs can also be used to make global read-only variables, though  is in broader use.

Section 3.6: Sigils
Perl has a number of sigils:

These look like sigils, but aren't:
\@array; # \ returns the reference of what's on the right (so, a reference to @array)
$#array; # this is the index of the last element of @array
You can use braces after the sigil if you should be so inclined. Occasionally, this improves readability.

While you use different sigils to define variables of different types, the same variable can be accessed in different ways based on what sigils you use.
%hash;            # we use % because we are looking at an entire hash
$hash{it};        # we want a single value, however, that's singular, so we use $
$array[0];        # likewise for an array. notice the change in brackets.
@array[0,3];      # we want multiple values of an array, so we instead use @
@hash{'it','en'}; # similarly for hashes (this gives the values: 'ciao', 'hello')
%hash{'it','fr'}; # we want an hash with just some of the keys, so we use %
                  # (this gives key-value pairs: 'it', 'ciao', 'fr', 'salut')
This is especially true of references. In order to use a referenced value you can combine sigils together.
my @array = 1..5;                    # This is an array my $reference_to_an_array = \@array; # A reference to an array is a singular value push @array, 6;                      # push expects an array push @$reference_to_an_array, 7;     # the @ sigil means what's on the right is an array                                      # and what's on the right is $reference_to_an_array                                      # hence: first a @, then a $
Here's a perhaps less confusing way to think about it. As we saw earlier, you can use braces to wrap what's on the right of a sigil. So you can think of @{} as something that takes an array reference and gives you the referenced array.

 my $values = undef; say pop @{ $values };       # ERROR: can't use undef as an array reference say pop @{ $values // [5] } # undef // [5] gives [5], so this prints 5 ...and the same trick works for other sigils, too.

...but if the "argument" to a sigil is simple, you can leave the braces away.

Things can get excessively extravagant. This works, but please Perl responsibly.
my %hash = (it => 'ciao', en => 'hi', fr => 'salut'); my $reference = \%hash; my $reference_to_a_reference = \$reference;
my $italian = $hash{it};                              # Direct access my @greets = @$reference{'it', 'en'};                 # Dereference, then access as array my %subhash = %$$reference_to_a_reference{'en', 'fr'} # Dereference ×2 then access as hash
For most normal use, you can just use subroutine names without a sigil. (Variables without a sigil are typically called "barewords".) The & sigil is only useful in a limited number of cases.

Section 3.7: Hash References
Hash references are scalars which contain a pointer to the memory location containing the data of a hash. Because the scalar points directly to the hash itself, when it is passed to a subroutine, changes made to the hash are not local to the subroutine as with a regular hash, but instead are global.
First, let's examine what happens when you pass a normal hash to a subroutine and modify it within there:

Which results in:

Notice that after we exit the subroutine, the hash remains unaltered; all changes to it were local to the modify subroutine, because we passed a copy of the hash, not the hash itself.
In comparison, when you pass a hashref, you are passing the address to the original hash, so any changes made within the subroutine will be made to the original hash:


This will result in:

Section 3.8: Hashes
Hashes can be understood as lookup-tables. You can access its contents by specifiying a key for each of them. Keys must be strings. If they're not, they will be converted to strings.
If you give the hash simply a known key, it will serve you its value.
# Elements are in (key, value, key, value) sequence my %inhabitants_of = ("London", 8674000, "Paris", 2244000);
# You can save some typing and gain in clarity by using the "fat comma" # syntactical sugar. It behaves like a comma and quotes what's on the left. my %translations_of_hello = (spanish => 'Hola', german => 'Hallo', swedish => 'Hej');
$hash{keyIn the following example, note the brackets and sigil: you access an element of %hash using } because the value you want is a scalar. Some consider it good practice to quote the key while others find this style visually noisy.
$hash{'some-key'Quoting is only required for keys that could be mistaken for expressions like }

While Perl by default will try to use barewords as strings, + modifier can also be used to indicate to Perl that key should not be interpolated but executed with result of execution being used as a key:


Like with arrays, you can access multiple hash elements at the same time. This is called a hash slice. The resulting value is a list, so use the @ sigil:
my @words = @translations_of_hello{'spanish', 'german'}; # ('Hola', 'Hallo')
Iterate over the keys of an hash with keys keys will return items in a random order. Combine with sort if you wish.

If you do not actually need the keys like in the previous example, values returns the hash's values directly:

You can also use a while loop with each to iterate over the hash. This way, you will get both the key and the value at the same time, without a separate value lookup. Its use is however discouraged, as each can break in mistifying ways.

Access to unset elements returns undef, not an error:

map and list flattening can be used to create hashes out of arrays. This is a popular way to create a 'set' of values, e.g. to quickly check whether a value is in @elems. This operation usually takes O(n) time (i.e. proportional to the number of elements) but can be done in constant time (O(1)) by turning the list into a hash:

This requires some explanation. The contents of @elems get read into a list, which is processed by map. map accepts a code block that gets called for each value of its input list; the value of the element is available for use in $_. Our code block returns two list elements for each input element: $_, the input element, and 1, just some value. Once you
 =>map { $_ =>  @elems turns qw(x y x z t) into (x => account for list flattening, the outcome is that 1 }1, y
 x => 1, z => 1, t => 1,1).
As those elements get assigned into the hash, odd elements become hash keys and even elements become hash values. When a key is specified multiple times in a list to be assigned to a hash, the last value wins. This effectively discards duplicates.
A faster way to turn a list into a hash uses assignment to a hash slice. It uses the x operator to multiply the singleelement list (1) by the size of @elems, so there is a 1 value for each of the keys in the slice on the left hand side:

The following application of hashes also exploits the fact that hashes and lists can often be used interchangeably to implement named function args:

When used as booleans, hashes are true if they are not empty.

Chapter 4: Interpolation in Perl
Section 4.1: What is interpolated
Perl interpolates variable names:

Arrays may be interpolated as a whole, their elements are separated by spaces:

Perl does not interpolate hashes as a whole:

and function calls (including constants):


Interpolation of \n depends on the system where program is working: it will produce a newline character(s) according to the current system conventions.
Perl does not interpolate \v, which means vertical tab in C and other languages.
Character may be addressed using their codes:

or Unicode names:

Character with codes from 0x00 to 0xFF in the native encoding may be addressed in a shorter form:

Control character may be addressed using special escape sequences:

\cA" == "\ca"Uppercase letters have the same meaning: ".
\N{...Interpretation of all escape sequences except for } may depend on the platform since they use platformand encoding-dependent codes.
Section 4.2: Basic interpolation
Interpolation means that Perl interpreter will substitute the values of variables for their name and some symbols (which are impossible or difficult to type in directly) for special sequences of characters (it is also known as escaping). The most important distinction is between single and double quotes: double quotes interpolate the enclosed string, but single quotes do not.

But:
print 'My name is $name.\nI am $age.\n'; # My name is $name.\nI am $age.\n
qq'm 64}You can use q{} (with any delimiter) instead of single quotes and {} instead of double quotes. For example, q{I allows to use an apostrophe within a non-interpolated string (otherwise it would terminate the string).
Statements:
 print qq{$name said: "I'm $age".}; # Paul said: "I'm 64". print "$name said: \"I'm $age\"."  # Paul said: "I'm 64". do the same thing, but in the first one you do not need to escape double quotes within the string.
varIf your variable name clashes with surrounding text, you can use the syntax ${} to disambiguate:



Chapter 5: True and false
Section 5.1: List of true and false values

Chapter 6: Dates and Time
Section 6.1: Date formatting
Time::Piece is available in perl 5 after version 10

Section 6.2: Create new DateTime
Install DateTime on your PC and then use it in perl script:
use DateTime;
Create new current datetime
$dt = DateTime->now( time_zone => 'Asia/Ho_Chi_Minh');
Then you can access elements's values of date and time:

To get only time:
my $time = $dt->hms; #return time with format hh:mm:ssTo get only date:
my $date = $dt->ymd; #return date with format yyyy-mm-ddSection 6.3: Working with elements of datetime
Set single element:
$dt->set( year => 2016 );
Set many elements:
$dt->set( year => 2016, 'month' => 8);
Add duration to datetime
$dt->add( hour => 1, month => 2)
Datetime subtraction:

You will get the result is 4 days
Section 6.4: Calculate code execution time

This will print execution time of Code in seconds
Chapter 7: Control Statements
Section 7.1: Conditionals
Perl supports many kinds of conditional statements (statements that are based on boolean results). The most common conditional statements are if-else, unless, and ternary statements. given statements are introduced as a switch-like construct from C-derived languages and are available in versions Perl 5.10 and above.
If-Else Statements
The basic structure of an if-statement is like this:

For simple if-statements, the if can precede or succeed the code to be executed.

Section 7.2: Loops
Perl supports many kinds of loop constructs: for/foreach, while/do-while, and until.

The while loop evaluates the conditional before executing the associated block. So, sometimes the block is never executed. For example, the following code would never be executed if the filehandle $fh was the filehandle for an empty file, or if was already exhausted before the conditional.

The do/while and do/until loops, on the other hand, evaluate the conditional after each time the block is executed. So, a do/while or a do/until loop is always executed at least once.



Chapter 8: Subroutines
Section 8.1: Creating subroutines
Subroutines are created by using the keyword sub followed by an identifier and a code block enclosed in braces.
You can access the arguments by using the special variable @_, which contains all arguments as an array.

Since the function shift defaults to shifting @_ when used inside a subroutine, it's a common pattern to extract the arguments sequentially into local variables at the beginning of a subroutine:
    # ...
Version ≥ 5.20.0
Alternatively, the experimental feature "signatures" can be used to unpack parameters, which are passed by value (not by reference).

Default values can be used for the parameters.

You can use any expression to give a default value to a parameter - including other parameters.


Note that you can't reference parameters which are defined after the current parameter - hence the following code doesn't work quite as expected.

Section 8.2: Subroutines
Subroutines hold code. Unless specified otherwise, they are globally defined.

saySome builtins such as print or say are keywords, not functions, so e.g. & is undefined. It also does mean that you can define them, but you will have to specify the package name to actually call them

Since Perl 5.18, you can also have non-global functions:


Since 5.20, you can also have named parameters.

This should not be confused with prototypes, a facility Perl has to let you define functions that behave like built-ins.
Function prototypes must be visible at compile time and its effects can be ignored by specifying the & sigil. Prototypes are generally considered to be an advanced feature that is best used with great care.

Section 8.3: Subroutine arguments are passed by reference (except those in signatures)
$_Subroutine arguments in Perl are passed by reference, unless they are in the signature. This means that the members of the @_ array inside the sub are just aliases to the actual arguments. In the following example, $text in the main program is left modified after the subroutine call because [0] inside the sub is actually just a different name for the same variable. The second invocation throws an error because a string literal is not a variable and therefore can't be modified.

my ...To avoid clobbering your caller's variables it is therefore important to copy @_ to locally scoped variables () as described under "Creating subroutines".

Chapter 9: Debug Output
Section 9.1: Dumping with Style
Sometimes Data::Dumper is not enough. Got a Moose object you want to inspect? Huge numbers of the same structure? Want stuff sorted? Colored? Data::Printer is your friend.

Data::Printer writes to STDERR, like warn. That makes it easier to find the output. By default, it sorts hash keys and looks at objects.

It will look at all the methods of the object, and also list the internals.
LWP::UserAgent  {     Parents       LWP::MemberMixin     public methods (45) : add_handler, agent, clone, conn_cache, cookie_jar, credentials, default_header, default_headers, delete, env_proxy, from, get, get_basic_credentials, get_my_handler, handlers, head, is_online, is_protocol_supported, local_address, max_redirect, max_size, mirror, new, no_proxy, parse_head, post, prepare_request, progress, protocols_allowed, protocols_forbidden, proxy, put, redirect_ok, remove_handler, request, requests_redirectable, run_handlers, send_request, set_my_handler, show_progress, simple_request, ssl_opts, timeout, use_alarm, use_eval     private methods (4) : _agent, _need_proxy, _new_response, _process_colonic_headers     internals: {         def_headers             HTTP::Headers,         handlers                {
            response_header   HTTP::Config
        },         local_address           undef,         max_redirect            7,         max_size                undef,         no_proxy                [],         protocols_allowed       undef,         protocols_forbidden     undef,         proxy                   {},         requests_redirectable   [             [0] "GET",
            [1] "HEAD"         ],         show_progress           undef,         ssl_opts                {             verify_hostname   1
        },         timeout                 180,         use_eval                1

You can configure it further, so it serializes certain objects in a certain way, or to include objects up to an arbitrary depth. The full configuration is available in the documentation.
Unfortunately Data::Printer does not ship with Perl, so you need to install it from CPAN or through your package management system.
Section 9.2: Dumping data-structures

Using Data::Dumper is an easy way to look at data structures or variable content at run time. It ships with Perl and you can load it easily. The Dumper function returns the data structure serialized in a way that looks like Perl code.

That makes it very useful to quickly look at some values in your code. It's one of the most handy tools you have in your arsenal. Read the full documentation on metacpan.
Section 9.3: Data::Show
use Data::ShowThe function show is automatically exported when ; is executed. This function takes a variable as its sole argument and it outputs:
1. the name of the variable
2. the contents of that variable (in a readable format)
3. the line of the file that show is run from
4. the file show is run from
example.plAssuming that the following is code from the file :

perl example.pl gives the following output:


Data::ShowSee the documentation for .
Section 9.4: Dumping array list

Using Data::Dumper gives an easy access to fetch list values. The Dumper returns the list values serialized in a way that looks like Perl code.
Output:

As suggested by user @dgw When dumping arrays or hashes it is better to use an array reference or a hash reference, those will be shown better fitting to the input.

Output:

You can also reference the array when printing.

Output:



Chapter 10: Lists
Section 10.1: Array as list
The array is one of Perl's basic variable types. It contains a list, which is an ordered sequence of zero or more scalars. The array is the variable holding (and providing access to) the list data, as is documented in perldata.
You can assign a list to an array:

You can use an array wherever a list is expected:

Some operators only work with arrays since they mutate the list an array contains:

Section 10.2: Assigning a list to a hash
Lists can also be assigned to hash variables. When creating a list that will be assigned to a hash variable, it is recommended to use the fat comma => between keys and values to show their relationship:

The => is really only a special comma that automatically quotes the operand to its left. So, you could use normal commas, but the relationship is not as clear:

You can also use quoted strings for the left hand operand of the fat comma =>, which is especially useful for keys containing spaces.

For details see Comma operator at perldoc perlop.
Section 10.3: Lists can be passed into subroutines
As to pass list into a subroutine, you specify the subroutine's name and then supply the list to it:

Internally Perl makes aliases to those arguments and put them into the array @_ which is available within the subroutine:

You access subroutine arguments like this:

Aliasing gives you the ability to change the original value of argument passed to subroutine:

To prevent inadvertent changes of original values passed into your subroutine, you should copy them:

To test how many arguments were passed into the subroutine, check the size of @_

If you pass array arguments into a subroutine they all will be flattened:

Section 10.4: Return list from subroutine
You can, of course, return lists from subs:


But it is not the recommended way to do that unless you know what you are doing.
While this is OK when the result is in LIST context, in SCALAR context things are unclear. Let's take a look at the next line:

Why 2? What is going on?
foo() evaluated in SCALAR context, this list ( @list1, @list2 1. Because ) also evaluated in SCALAR context
2. In SCALAR context, LIST returns its last element. Here it is @list2
3. Again in SCALAR context, array @list2 returns the number of its elements. Here it is 2.
In most cases the right strategy will return references to data structures. So in our case we should do the following instead:

Then the caller does something like this to receive the two returned arrayrefs:

Section 10.5: Hash as list
In list context hash is flattened.

The array @bar is initialized by list of two %hash hashes
both %hash are flattened new list is created from flattened items
@bar array is initialized by that list
It is guaranteed that key-value pairs goes together. Keys are always even indexed, values - odd. It is not guaranteed that key-value pairs are always flattened in same order:

Section 10.6: Using arrayref to pass array to sub
The arrayref for @foo is \@foo. This is handy if you need to pass an array and other things to a subroutine. Passing @foo is like passing multiple scalars. But passing \@foo is a single scalar. Inside the subroutine:

Chapter 11: Sorting
For sorting lists of things, Perl has only a single function, unsurprisingly called sort. It is flexible enough to sort all kinds of items: numbers, strings in any number of encodings, nested data structures or objects. However, due to its flexibility, there are quite a few tricks and idioms to be learned for its use.
Section 11.1: Basic Lexical Sort

<=The three examples above do exactly the same thing. If you don't supply any comparator function or block, sort assumes you want the list on its right sorted lexically. This is usually the form you want if you just need your data in some predictable order and don't care about linguistic correctness. sort passes pairs of items in @list to the comparator function, which tells sort which item is larger. The cmp operator does this for strings while > does the same thing for numbers. The comparator is called quite often, on average n * log(n) times with n being the number of elements to be sorted, so it's important it be fast. This is the reason sort uses predefined package global variables ($a and $b) to pass the elements to be compared to the block or function, instead of proper function parameters.
use localeIf you , cmp takes locale specific collation order into account, e.g. it will sort Å like A under a Danish locale but after Z under an English or German one. However, it doesn't take the more complex Unicode sorting rules into account nor does it offer any control over the order-for example phone books are often sorted differently from
Unicode::Collate and particularly Unicode::Collate::Localedictionaries. For those cases, the  modules are recommended.
Section 11.2: The Schwartzian Transform
This is probably the most famous example of a sort optimization making use of Perl's functional programming facilities, to be used where the sort order of items depend on an expensive function.

The trouble with the first example is that the comparator is called very often and keeps recalculating values using a slow function over and over. A typical example would be sorting file names by their file size:

This works, but at best it incurs the overhead of two system calls per comparison, at worst it has to go to the disk, twice, for every single comparison, and that disk may be in an overloaded file server on the other side of the planet.
Enter Randall Schwartz's trick.
slowsortThe Schwartzian Transform basically shoves @list through three functions, bottom-to-top. The first map turns each entry into a two-element list of the original item and the result of the slow function as a sort key, so at the end of this we have called () exactly once for each element. The following sort can then simply access the sort key by looking in the list. As we don't care about the sort keys but only need the original elements in sorted order, the final map throws away the two-element lists from the already-sorted list it receives from @ and returns a list of only their first members.
Section 11.3: Case Insensitive Sort
The traditional technique to make sort ignore case is to pass strings to lc or uc for comparison:

This works on all versions of Perl 5 and is completely sufficient for English; it doesn't matter whether you use uc or lc. However, it presents a problem for languages like Greek or Turkish where there is no 1:1 correspondence between upper- and lowercase letters so you get different results depending on whether you use uc or lc. Therefore, Perl 5.16 and higher have a case folding function called fc that avoids this problem, so modern multilingual sorting should use this:

Section 11.4: Numeric Sort

<=Comparing $a and $b with the > operator ensures they are compared numerically and not textually as per default.
Section 11.5: Reverse Sort

Sorting items in descending order can simply be achieved by swapping $a and $b in the comparator block. However, some people prefer the clarity of a separate reverse even though it is slightly slower.
Chapter 12: File I/O (reading and writing files)
Mode	Explaination
>	Write (trunc). Will overwrite existing files. Creates a new file if no file was found
Write (append). Will not overwrite files but append new content at the end of it. Will also create a file if used
>>
for opening a non existing file.
<	Read. Opens the file in read only mode.
+<	Read / Write. Will not create or truncate the file.
+>	Read / Write (trunc). Will create and truncate the file.
+>> Read / Write (append). Will create but not truncate the file.
Section 12.1: Opening A FileHandle for Reading
Opening Generic ASCII Text Files
Version ≥ 5.6.0 open my $filehandle, '<', $name_of_file or die "Can't open $name_of_file, $!";
This is the basic idiom for "default" File IO and makes $filehandle a readable input stream of bytes, filtered by a default system-specific decoder, which can be locally set with the open pragma
Perl itself does not handle errors in file opening, so you have to handle those yourself by checking the exit condition of open. $! is populated with the error message that caused open to fail.
On Windows, the default decoder is a "CRLF" filter, which maps any "\r\n" sequences in the input to "\n"
Opening Binary Files
Version ≥ 5.8.0 open my $filehandle, '<:raw', 'path/to/file' or die "Can't open $name_of_file, $!";
This specifies that Perl should not perform a CRLF translation on Windows.
Opening UTF8 Text Files
Version ≥ 5.8.0

This specifies that Perl should both avoid CRLF translation, and then decode the resulting bytes into strings of characters ( internally implemented as arrays of integers which can exceed 255 ), instead of strings of bytes
Section 12.2: Reading from a file


If you know that your input file is UTF-8, you can specify the encoding: open my $fh, '<:encoding(utf8)', $filename or die "Failed to open file: $filename"; After finished reading from the file, the filehandle should be closed:

See also: Reading a file into a variable
Another and faster way to read a file is to use File::Slurper Module. This is useful if you work with many files.

See also: [Reading a file with slurp]
Section 12.3: Write to a file
This code opens a file for writing. Returns an error if the file couldn't be opened. Also closes the file at the end.

Now we have an open file ready for writing which we access through $fh (this variable is called a filehandle). Next we can direct output to that file using the print operator:

The open operator has a scalar variable ($fh in this case) as its first parameter. Since it is defined in the open operator it is treated as a filehandle. Second parameter ">" (greater than) defines that the file is opened for writing. The last parameter is the path of the file to write the data to.
To write the data into the file, the print operator is used along with the filehandle. Notice that in the print operator there is no comma between the filehandle and the statement itself, just whitespace.
Section 12.4: "use autodie" and you won't need to check file open/close failures
autodie allows you to work with files without having to explicitly check for open/close failures.
Since Perl 5.10.1, the autodie pragma has been available in core Perl. When used, Perl will automatically check for errors when opening and closing files.
Here is an example in which all of the lines of one file are read and then written to the end of a log file.

By the way, you should technically always check print statements. Many people don't, but perl (the Perl interpreter) doesn't do this automatically and neither does autodie.
Section 12.5: Rewind a filehandle
Sometimes it is needful to backtrack after reading.

Section 12.6: Reading and Writing gzip compressed files
Writing a gzipped file
IO::Compress::GzipIO::Compress::GzipTo write a gzipped file, use the module  and create a filehandle by creating a new instance of  for the desired output file:

Reading from a gzipped file
IO::Uncompress::GunzipIO::Uncompress::GunzipTo read from a gzipped file, use the module  and then create a filehandle by creating a new instance of  for the input file:

Section 12.7: Setting the default Encoding for IO

This pragma changes the default mode of reading and writing text ( files, standard input, standard output, and standard error ) to UTF-8, which is typically what you want when writing new applications.
ASCII is a subset of UTF-8, so this is not expected to cause any problems with legacy ASCII files and will help protect you the accidental file corruption that can happen when treating UTF-8 files as ASCII.
However, it is important that you know what the encoding of your files is that you are dealing with and handle them accordingly. (Reasons that we should not ignore Unicode.) For more in depth treatment of Unicode, please see the Perl Unicode topic.
Chapter 13: Reading a file's content into a variable
Section 13.1: Path::Tiny
Using the idiom from The Manual Way several times in a script soon gets tedious so you might want to try a module.

You can pass a binmode option if you need control over file encodings, line endings etc. - see man perlio: my $contents = path($filename)->slurp( {binmode => ":encoding(UTF-8)"} );
Path::Tiny also has a lot of other functions for dealing with files so it may be a good choice.
Section 13.2: The manual way

<$fhAfter opening the file (read man perlio if you want to read specific file encodings instead of raw bytes), the trick is in the do block: >, the file handle in a diamond operator, returns a single record from the file. The "input record separator" variable $/ specifies what a "record" is-by default it is set to a newline character so "a record" means "a single line". As $/ is a global variable, local does two things: it creates a temporary local copy of $/ that will vanish at the end of the block, and gives it the (non-)value undef (the "value" which Perl gives to uninitialized variables). When the input record separator has that (non-)value, the diamond operator will return the entire file. (It considers the entire file to be a single line.)
Using do, you can even get around manually opening a file. For repeated reading of files,

ARGVcan be used. Here, another global variable(@) is localized to simulate the same process used when starting a perl script with parameters. $/ is still undef, since the array in front of it "eats" all incoming arguments. Next, the diamond operator <> again delivers one record defined by $/ (the whole file) and returns from the do block, which in turn return from the sub.
The sub has no explicit error handling, which is bad practice! If an error occurs while reading the file, you will receive undef as return value, as opposed to an empty string from an empty file.
Another disadvantage of the last code is the fact that you cannot use PerlIO for different file encodings-you always get raw bytes.
Section 13.3: File::Slurp
Don't use it. Although it has been around for a long time and is still the module most programmers will suggest, it is broken and not likely to be fixed.
Section 13.4: File::Slurper
This is a minimalist module that only slurps files into variables, nothing else.

read_text() takes two optional parameters to specify the file encoding and whether line endings should be
translated between the unixish LF or DOSish CRLF standards:

Section 13.5: Slurping a file into an array variable

When evaluated in list context, the diamond operator returns a list consisting of all the lines in the file (in this case, assigning the result to an array supplies list context). The line terminator is retained, and can be removed by chomping:

Section 13.6: Slurp file in one-liner
Input record separator can be specified with -0 switch (zero, not capital O). It takes an octal or hexadecimal number as value. Any value 0400 or above will cause Perl to slurp files, but by convention, the value used for this purpose is 0777.

Going further with minimalism, specifying -n switch causes Perl to automatically read each line (in our case - the whole file) into variable $_.

Chapter 14: Strings and quoting methods
Section 14.1: String Literal Quoting
String literals imply no escaping or interpolation ( with the exception of quoting string terminators )
 print 'This is a string literal\n'; # emits a literal \ and n to terminal print 'This literal contains a \'postraphe '; # emits the ' but not its preceding \ You can use alternative quoting mechanisms to avoid clashes:
print q/This is is a literal \' <-- 2 characters /;  # prints both \ and ' print q^This is is a literal \' <-- 2 characters ^;  # also
Certain chosen quote characters are "balanced"
print q{ This is a literal and I contain { parens! } }; # prints inner { }
Section 14.2: Double-quoting
Double-quoted strings use interpolation and escaping - unlike single-quoted strings. To double-quote a string, use either double quotes " or the qq operator.

The qq is useful here, to avoid having to escape the quotation marks. Without it, we would have to write...

... which just isn't as nice.
Perl doesn't limit you to using a slash / with qq; you can use any (visible) character.

You can also interpolate arrays into strings.


By default the values are space-separated - because the special variable $" defaults to a single space. This can, of course, be changed.

use EnglishIf you prefer, you have the option to  and change $LIST_SEPARATOR instead:

For anything more complex than this, you should use a loop instead.

Interpolation does not work with hashes.

Some code abuses interpolation of references - avoid it.
use feature 'say';
say "2 + 2 == @{[ 2 + 2 ]}";           # 2 + 2 = 4 (avoid this) say "2 + 2 == ${\( 2 + 2 )}";          # 2 + 2 = 4 (avoid this)
 ... } the array reference [ ... The so-called "cart operator" causes perl to dereference @{] that contains the
expression that you want to interpolate, 2 + 2. When you use this trick, Perl builds an anonymous array, then dereferences it and discards it.
 ... The ${\()} version is somewhat less wasteful, but it still requires allocating memory and it is even harder to read.
Instead, consider writing:
say "2 + 2 == "  say "2 + 2 == $result"my $result . 2 + 2;
= 2 + 2;
Section 14.3: Heredocs
Large Multi-Line strings are burdensome to write.

NB: Make sure you ignore stack-overflows syntax highlighter: It is very wrong.
And Interpolated Heredocs work the same way.

Pending in 5.26.0* is an "Indented Heredoc" Syntax which trims left-padding off for you Version ≥ 5.26.0

Section 14.4: Removing trailing newlines
The function chomp will remove one newline character, if present, from each scalar passed to it. chomp will mutate the original string and will return the number of characters removed



But usually, no one worries about how many newlines were removed, so chomp is usually seen in void context, and usually due to having read lines from a file:


Chapter 15: Split a string on unquoted separators
Section 15.1: parse_line()
parse_line()Using  of Text::ParseWords:

Output:

Section 15.2: Text::CSV or Text::CSV_XS

Output:

Text::ParseWordsallow_whitespace=>1 By default, Text::CSV does not strip whitespace around separator character, the way  does. However, adding  to constructor attributes achieves that effect. my $csv = Text::CSV_XS->new({sep_char => $sep_char, allow_whitespace=>1});  

Chapter 16: Object-oriented Perl
Section 16.1: Defining classes in modern Perl
Although available, defining a class from scratch is not recommended in modern Perl. Use one of helper OO systems which provide more features and convenience. Among these systems are:
Class::AccessorClass::TinyMoose - inspired by Perl 6 OO design
- a lightweight alternative to Moose
- truly minimal class builder
Moose

Class::Accessor (Moose syntax)

Class::Accessor (native syntax)

Class::Tiny

Section 16.2: Creating Objects
Unlike many other languages, Perl does not have constructors that allocate memory for your objects. Instead, one should write a class method that both create a data structure and populate it with data (you may know it as the Factory Method design pattern).


There is nothing special in the name new. You can call the factory methods as you prefer.
There is nothing special in hashes. You could do the same in the following way:

In general, any reference may be an object, even a scalar reference. But most often, hashes are the most convenient way to represent object data.
Section 16.3: Defining Classes
In general, classes in Perl are just packages. They can contain data and methods, as usual packages.

It is important to note that the variables declared in a package are class variables, not object (instance) variables. Changing of a package-level variable affects all objects of the class. How to store object-specific data, see in "Creating Objects".
What makes class packages specific, is the arrow operator ->. It may be used after a bare word:

or after a scalar variable (usually holding a reference):

What is to the left of the arrow is prepended to the given argument list of the method. For example, after call

Packages representing classes should take this convention into account and expect that all their methods will have one extra argument.
Section 16.4: Inheritance and methods resolution
To make a class a subclass of another class, use parent pragma:

Perl allows for multiple inheritance:

Inheritance is all about resolution which method is to be called in a particular situation. Since pure Perl does not prescribe any rules about the data structure used to store object data, inheritance has nothing to do with that.
Consider the following class hierarchy:


The method resolution works as follows:
1. The starting point is defined by the left operand of the arrow operator.

...or a scalar variable holding a string:

...then the starting point is the package with the corresponding name (Point2D in both examples).

then the starting point is the class of the reference (again, Point2D). The arrow operator cannot be used to call methods for unblessed references.
2. If the starting point contains the required method, it is simply called.
Point2D::newThus, since  exists,

will simply call it.
3. If the starting point does not contain the required method, depth-first search in the parent classes is performed. In the example above, the search order will be as follows:
Point2D
Point (first parent of Point2D)
GeometryObject (parent of Point)
PlanarObject (second parent of Point2D)
For example, in the following code:

GeometryObject::transposethe method that will be called is , even though it would be overridden in
PlanarObject::transpose.
4. You can set the starting point explicitly.
PlanarObject::transposeIn the previous example, you can explicitly call  like so:

SUPER::5. In a similar manner,  performs method search in parent classes of the current class. For example,

Point::new in the course of the Point2D::newwill call  execution.
Section 16.5: Class and Object Methods
In Perl, the difference between class (static) and object (instance) methods is not so strong as in some other languages, but it still exists.
The left operand of the arrow operator -> becomes the first argument of the method to be called. It may be either a string:


or an object reference:

Class methods are just the ones that expect their first argument to be a string, and object methods are the ones that expect their first argument to be an object reference.
Class methods typically do not do anything with their first argument, which is just a name of the class. Generally, it is only used by Perl itself for method resolution. Therefore, a typical class method can be called for an object as well:

Although this syntax is allowed, it is often misleading, so it is better to avoid it.
Object methods receive an object reference as the first argument, so they can address the object data (unlike class methods):

The same method can track both cases: when it is called as a class or an object method:

Section 16.6: Roles
A role in Perl is essentially
a set of methods and attributes which injected into a class directly.
A role provides a piece of functionality which can be composed into (or applied to) any class (which is said to consume the role). A role cannot be inherited but may be consumed by another role.
A role may also require consuming classes to implement some methods instead of implementing the methods itself (just like interfaces in Java or C#).
Perl does not have built-in support for roles but there are CPAN classes which provide such support.
Moose::Role

Role::Tiny
Class::Accessor or Class::TinyUse if your OO system does not provide support for roles (e.g. ). Does not support attributes.

Chapter 17: Exception handling
Section 17.1: eval and die
This is the built-in way to deal with "exceptions" without relying on third party libraries like Try::Tiny.

We "abuse" the fact that die has a false return value, and the return value of the overall code block is the value of the last expression in the code block:
or dosome_function_that_might_dieor door doif $ret is assigned to successfully, then the 1; expression is the last thing that happens in the eval code block. The eval code block thus has a true value, so the  block does not run.
if () does die, then the last thing that happens in the eval code block is the die. The eval code block thus has a false value and the  block does run.
|| "Zombie Error"The first thing you must do in the  block is read $@. This global variable will hold whatever argument was passed to die. The  guard is popular, but unnecessary in the general case.
This is important to understand because some not all code does fail by calling die, but the same structure can be used regardless. Consider a database function that returns:
the number of rows affected on success
'0 but true' if the query is successful but no rows were affected 0 if the query was not successful.
In that case you can still use the same idiom, but you have to skip the final 1;, and this function has to be the last thing in the eval. Something like this:

Chapter 18: Regular Expressions
Section 18.1: Replace a string using regular expressions
s/foo/bar/;         # replace "foo" with "bar" in $_ my $foo = "foo";
$foo =~ s/foo/bar/; # do the above on a different variable using the binding operator =~ s~ foo ~ bar ~;     # using ~ as a delimiter
$foo = s/foo/bar/r; # non-destructive r flag: returns the replacement string without modifying the variable it's bound to
s/foo/bar/g;        # replace all instances
Section 18.2: Matching strings
The =~ operator attempts to match a regular expression (set apart by /) to a string:

/^hello/ is the actual regular expression. The ^ is a special character that tells the regular expression to start with the beginning of the string and not match in the middle somewhere. Then the regex tries to find the following letters in order h, e, l, l, and o.
Regular expressions attempt to match the default variable ($_) if bare:

You can also use different delimiters is you precede the regular expression with the m operator:

This is useful when matching strings that include the / character:

Section 18.3: Parsing a string with a regex
Generally, it's not a good idea to use a regular expression to parse a complex structure. But it can be done. For instance, you might want to load data into hive table and fields are separated by comma but complex types like array are separated by a "|". Files contain records with all fields separated by comma and complex type are inside square bracket. In that case, this bit of disposable Perl might be sufficient:


You'll want to spot check the output:
		1,2,[3|4|5],5,6,[7|8],[1|2|34],5
Section 18.4: Usage of \Q and \E in pattern matching
What's between \Q and \E is treated as normal characters

}
Output

Chapter 19: XML Parsing
Section 19.1: Parsing with XML::Twig


Section 19.2: Consuming XML with XML::Rabbit
XML::RabbitXML::RabbitWith  it is possible to consume XML files easily. You define in a declarative way and with an XPath syntax what you are looking for in the XML and  will return objects according to the given definition.
Definition:

XML Consumption:


Notes:
Please be careful with the following:
XML::Rabbit::Root<catalog1. The first class has to be . It will place you inside the main tag of the XML document. In our case it will place us inside >
eval / $@2. Nested classes which are optional. Those classes need to be accessed via a try/catch (or  check) block. Optional fields will simply return null. For example, for purchase_data the loop would be:

sample.xml


Section 19.3: Parsing with XML::LibXML



Chapter 20: Unicode
Section 20.1: The utf8 pragma: using Unicode in your sources
The utf8 pragma indicates that the source code will be interpreted as UTF-8. Of course, this will only work if your text editor is also saving the source as UTF-8 encoded.
Now, string literals can contain arbitrary Unicode characters; identifiers can also contain Unicode but only word-like characters (see perldata and perlrecharclass for more information):
use utf8; my $var1 = '§?§(c)????';      # works fine my $? = 4;                # works since ? is a word (matches \w) character my $p§2 = 3;              # does not work since § is not a word character. say "ya" if $var1 =~ /?§/; # works fine (prints "ya")
Note: When printing text to the terminal, make sure it supports UTF-8.*
There may be complex and counter-intuitive relationships between output and source encoding. Running on a UTF-8 terminal, you may find that adding the utf8 pragma seems to break things:

In the first case, Perl treats the string as raw bytes and prints them like that. As these bytes happen to be valid
length("Møøse"Mutf8COUTF-8, they look correct even though Perl doesn't really know what characters they are (e.g. ) will return 7, not 5). Once you add -, Perl correctly decodes the UTF-8 source to characters, but output is in Latin-1 mode by default and printing Latin-1 to a UTF-8 terminal doesn't work. Only when you switch STDOUT to UTF-8 using - will the output be correct.
use utf8 doesn't affect standard I/O encoding nor file handles!
Section 20.2: Handling invalid UTF-8
Reading invalid UTF-8
When reading UTF-8 encoded data, it is important to be aware of the fact the UTF-8 encoded data can be invalid or malformed. Such data should usually not be accepted by your program (unless you know what you are doing). When unexpectedly encountering malformed data, different actions can be considered:
Print stacktrace or error message, and abort program gracefully, or
Insert a substitution character at the place where the malformed byte sequence appeared, print a warning message to STDERR and continue reading as nothing happened.
By default, Perl will warn you about encoding glitches, but it will not abort your program. You can make your program abort by making UTF-8 warnings fatal, but be aware of the caveats in Fatal Warnings.
The following example writes 3 bytes in encoding ISO 8859-1 to disk. It then tries to read the bytes back again as UTF-8 encoded data. One of the bytes, 0xE5, is an invalid UTF-8 one byte sequence:

The program will abort with a fatal warning:

<$fhLine 10 is here the second last line, and the error occurs in the part of the line with > when trying to read a line from the file.
If you don't make warnings fatal in the above program, Perl will still print the warning. However, in this case it will try to recover from the malformed byte 0xE5 by inserting the four characters \xE5 into the stream, and then continue with the next byte. As a result, the program will print:

Section 20.3: Command line switches for one-liners
Enable utf8 pragma
Mutf8In order to enable utf8 pragma in one-liner, perl interpreter should be called with - option: perl -Mutf8 -E 'my $人 = "human"; say $人'
Unicode handling with -C switch
The -C command line flag lets you control Unicode features. It can be followed by a list of option letters.
Standard I/O




Section 20.4: Standard I/O
The encoding to be used for the standard I/O filehandles (STDIN, STDOUT, and STDERR), can be set separately for each handle using binmode:

encoding(utf-8) over :utf8Note: when reading one would in general prefer :, see Remarks for more information.
Alternatively, you can use the open pragma.
# Setup such that all subsequently opened input streams will use ':encoding(utf-8)'
# and all subsequently opened output streams will use ':utf8' # by default use open (IN => ':encoding(utf-8)', OUT => ':utf8');
# Make the (already opened) standard file handles inherit the setting # given by the IO settings for the open pragma use open ( :std );
# Now, STDIN has been converted to ':encoding(utf-8)', and
# STDOUT and STDERR have ':utf8'
Alternatively, to set all filehandles (both those yet to be opened and also the standard ones) to use
encoding(utf:-8):

Section 20.5: File handles
Setting encoding with open()
openWhen opening a text file, you may specify it's encoding explicitly with a three-argument (). This en-/decoder attached to a file handle is called an "I/O layer":
my $filename = '/path/to/file';
open my $fh, '<:encoding(utf-8)', $filename or die "Failed to open $filename: $!";
utf8 and :encoding(utfSee Remarks for a discussion of the differences between :-8).
Setting encoding with binmode()
Alternatively, you may use binmode() to set the encoding for individual file handle:

open pragma
openTo avoid setting encoding for each file handle separately, you may use the open pragma to set a default I/O layer used by all subsequent calls to the () function and similar operators within the lexical scope of this pragma:
# Set input streams to ':encoding(utf-8)' and output streams to ':utf8' use open (IN => ':encoding(utf-8)', OUT => ':utf8');
# Or to set all input and output streams to ':encoding(utf-8)' use open ':encoding(utf-8)';
Setting encoding with command line -C flag
CDFinally, it is also possible to run the perl interpreter with a - flag that applies UTF-8 as the default I/O layer. However, this option should be avoided since it relies on specific user behaviour which cannot be predicted nor controlled.
Section 20.6: Create filenames
Encode::encode(...The following examples use the UTF-8 encoding to represent filenames (and directory names) on disk. If you want to use another encoding, you should use ).

Section 20.7: Read filenames
Perl does not attempt to decode filenames returned by builtin functions or modules. Such strings representing filenames should always be decoded explicitly, in order for Perl to recognize them as Unicode.

decode_utf8( ... Note: if you are concerned about invalid UTF-8 in the filenames, the use of ) in the above
decode( 'utf-8', ... ). This is because decode_utf8( ... examples should probably be replaced by ) is a
decode( 'utf8', ... ) and there is a difference between the encodings utfsynonym for -8 and utf8 (see
utfRemarks below for more information) where -8 is more strict on what is acceptable than utf8.

Chapter 21: Perl one-liners
Section 21.1: Upload file into mojolicious
perl -Mojo -E 'p("http://localhost:3000" => form => {Input_Type => "XML", Input_File => {file => "d:/xml/test.xml"}})'
d:/xml/test.xml will be uploaded to server which listen connections on localhost:3000File  (Source)
In this example:
-Mmodule executes use module; before executing your program
-E commandline is used to enter one line of program
If you have no ojo module you can use cpanm ojo command to install it
To read more about how to run perl use perldoc perlrun command or read here
Section 21.2: Execute some Perl code from command line
Simple one-liners may be specified as command line arguments to perl using the -e switch (think "execute"):

Due to Windows quoting rules you can't use single-quoted strings but have to use one of these variants:

-CONote that to avoid breaking old code, only syntax available up to Perl 5.8.x can be used with -e. To use anything newer your perl version may support, use -E instead. E.g. to use say available from 5.10.0 on plus Unicode 6.0 from >=v5.14.0 (also uses  to make sure STDOUT prints UTF-8):
Version ≥ 5.14.0

Section 21.3: Using double-quoted strings in Windows oneliners
Windows uses only double quotes to wrap command line parameters. In order to use double quotes in perl oneliner (i.e. to print a string with an interpolated variable), you have to escape them with backslashes:

qq()To improve readability, you may use a  operator:

Section 21.4: Print lines matching a pattern (PCRE grep)

Case-insensitive:

Section 21.5: Replace a substring with another (PCRE sed)

Or in-place:

On Windows:

Section 21.6: Print only certain fields

CSV example:

Section 21.7: Print lines 5 to 10

Section 21.8: Edit file in-place
Without a backup copy (not supported on Windows)

file.txt.bakWith a backup copy 

old_file.txt.origWith a backup copy  in the backup subdirectory (provided the latter exists):

Section 21.9: Reading the whole file as a string

-0777 is just a convention. Any -0400Note: The  and above would de the same.
Chapter 22: Randomness
Section 22.1: Accessing an array element at random

How it works
rand EXPR ≤ VALUE < 26rand 26$letters[rand @letters] ≡ $letters[int rand @letters]$array[rand @array]$array[$#array]$array[ expects a scalar value, so @letters is evaluated in scalar context
An array in scalar context returns the number of elements it contains (26 in this case)  returns a random fractional number in the interval 0. (It can never be 26)
Array indices are always integers, so 
Perl arrays are zero-indexed, so  returns 0],  or an element in between
(The same principle applies to hashes)

Section 22.2: Generate a random integer between 0 and 9
Cast your random floating-point number as an int.
Input:

Output:
A random integer, like...

See also the perldoc for rand.
Chapter 23: Special variables
Section 23.1: Special variables in perl:
1. $_ : The default input and pattern-searching space.
Example 1:

Example 2:

The following functions use $_ as a default argument:
abs, alarm, chomp, chop, chr, chroot, cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc, lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf, quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only), rmdir, say, sin, split (for its second argument), sqrt, stat, study, uc, ucfirst, unlink, unpack.
2. @_ : This array contains the arguments passed to subroutine.
Example 1:

Within a subroutine the array @_ contains the arguments passed to that subroutine. Inside a subroutine, @_ is the default array for the array operators pop and shift.
Chapter 24: Packages and modules
Section 24.1: Using a module

perldoc -f useThis will import the Cwd module at compile time and import its default symbols, i.e. make some of the module's variables and functions available to the code using it. (See also: .)
Generally this is will do the right thing. Sometimes, however, you will want to control which symbols are imported. Add a list of symbols after the module name to export:

If you do this, only the symbols you specify will be imported (ie, the default set will not be imported).
qwWhen importing multiple symbols, it is idiomatic to use the () list-building construct:

allSome modules export a subset of their symbols, but can be told to export everything with ::

all(Note that not all modules recognize or use the : tag).
Section 24.2: Using a module inside a directory

use lib 'includes'; adds the relative directory includes/ as another module search path in @INC. So assume
MySyperCoolModule.pm inside includesthat you have a module file /, which contains:

use libIf you want, you can group as many modules of your own inside a single directory and make them findable with one  statement.
At this point, using the subroutines in the module will require prefixing the subroutine name with the package name:

To be able to use the subroutines without the prefix, you need to export the subroutine names so that they are recognised by the program calling them. Exporting can be set up to be automatic, thus:

Then in the file that uses the module, those subroutines will be automatically available:

Or you can set up the module to conditionally export subroutines, thus:

In which case, you need to explicitly request the desired subroutines to be exported in the script that uses the module:

Section 24.3: Loading a module at runtime

This will ensure that the Exporter module is loaded at runtime if it hasn't already been imported. (See also: perldoc
f require-.)
N.B.: Most users should use modules rather than require them. Unlike use, require does not call the module's import method and is executed at runtime, not during the compile.
This way of loading modules is useful if you can't decide what modules you need before runtime, such as with a plugin system:

My::Package::Plugins::One and My::Package::Plugins::TwoThis would try to load . @plugins should of course
!::!/!come from some user input or a config file for this to make sense. Note the substitution operator sg that replaces each pair of colons with a slash. This is because you can load modules using the familiar module name syntax from use only if the module name is a bareword. If you pass a string or a variable, it must contain a file name.
Section 24.4: CPAN.pm
CPAN.pm is a Perl module which allows to query and install modules from CPAN sites.
It supports interactive mode invoked with

or

Querying modules By name:

By a regex against module name:

Note: to enable a pager or redirecting to a file use | or > shell redirection (spaces are mandatory around the | and >), e.g.:
 /^XML::/ | lessm.
By distribution:

Installing modules By name:

By distribution:

Section 24.5: List all installed modules
From command line:

From a Perl script:

Section 24.6: Executing the contents of another file

perldoc -f doThis will read in the contents of the config.pl file and execute it. (See also: .)
N.B.: Avoid do unless golfing or something as there is no error checking. For including library modules, use require or use.
Chapter 25: Install Perl modules via CPAN
Section 25.1: cpanminus, the lightweight configuration-free replacement for cpan
Usage
To install a module (assuming cpanm is already installed):

cpanm ("cpanminus") strives to be less verbose than cpan but still captures all of the installation information in a log file in case it is needed. It also handles many "interactive questions" for you, whereas cpan doesn't.
cpanm is also popular for installing dependencies of a project from, e.g., GitHub. Typical use is to first cd into the project's root, then run

--installdepsWith  it will:
1. Scan and install configure_requires dependencies from either
META.json
META.yml (if META.json is missing)
perl Build.PL2. Build the project (equivalent to ), generating MYMETA files
3. Scan and install requires dependencies from either
MYMETA.json
MYMETA.yml (if MYMETA.json is missing)
To specify the file 'some.cpanfile', containing the dependencies, run:

cpanm Installation
There are several ways to install it. Here's installation via cpan:

cpanm Configuration
There is no config file for cpanm. Rather, it relies on the following environment variables for its configuration:
PERL_CPANM_OPT (General cpanm command line options)
export PERL_CPANM_OPT="--prompt" # in .bashrc, to enable prompting, e.g.
setenv PERL_CPANM_OPT "--prompt" # in .tcshrc
     PERL_MM_OPT (ExtUtils::MakeMaker command line options, affects module install target) PERL_MB_OPT (Module::Build command line options, affects module install target)
   Section 25.2: Installing modules manually
If you don't have permissions to install perl modules, you may still install them manually, indicating a custom path where you've got writing permissions.
Fist, download and unzip module archive:

Makefile.PLThen, if the module distribution contains a  file, run:

Build.PL file instead of a Makefile.PLor if you have :

You also have to include the module path in PERL5LIB environment variable in order to use it in your code:

Section 25.3: Run Perl CPAN in your terminal (Mac and Linux) or command prompt (Windows)
Command line
You can use cpan to install modules directly from the command line:

This would be followed by possibly many pages of output describing exactly what it is doing to install the module. Depending on the modules being installed, it may pause and ask you questions.
Interactive Shell
You can also enter a "shell" thus:

It will produce output as below:

install <module>Then you can install the modules which you want by the easy command .
cpanExample: [1]> install DBI
After installing successfully, type exit to quit.

Chapter 26: Easy way to check installed modules on Mac and Ubuntu
Section 26.1: Use perldoc to check the Perl package install path

Section 26.2: Check installed perl modules via terminal
Type below command: instmodsh
It'll show you the guild as below:

m <module>Then type l to list all the installed modules, you can also use command  to select the module and get its information.
After finish, just type q to quit.
Section 26.3: How to check Perl corelist modules

Chapter 27: Pack and unpack
Section 27.1: Manually Converting C Structs to Pack Syntax
If you're ever dealing with C Binary API's from Perl Code, via the syscall, ioctl, or fcntl functions, you need to know how to construct memory in a C Compatible way.
/usr/include/time.hFor instance, if you were ever dealing with some function that expected a timespec, you'd look into  and find:


So its a (signed) int

And it takes 8 bytes. So 64bit signed int. And I'm on a 64Bit Processor. =)
Perldoc pack says

So to pack a timespec:

And to unpack a timespec:

Now you can just use those functions instead.


Section 27.2: Constructing an IPv4 header
pack() (and unpackSometimes you have to deal with structures defined in terms of C data types from Perl. One such application is the creation of raw network packets, in case you want to do something fancier than what the regular socket API has to offer. This is just what () of course) is there for.
The obligatory part of an IP header is 20 octets (AKA "bytes") long. As you can see behind this link, source and destination IP address make up the last two 32-bit values in the header. Among the other fields are some with 16 bits, some with 8 bits, and a few smaller chunks between 2 and 13 bits.
Assuming we have the following variables to stuff into our header:

Note that three fields from the header are missing:
The version is always 4 (it's IPv4 after all)
IHL is 5 in our example as we don't have an options field; length is specified in units of 4 octets so 20 octets gives a length of 5.
The checksum can be left at 0. Actually we'd have to calculate it but the code to do this doesn't concern us here.
We could try and use bit operations to construct e.g. the first 32 bits:

packThis approach only works up to the size of an integer though, which is usually 64 bits but can be as low as 32. Worse, it depends on the CPU's endianness so it will work on some CPUs and fail on others. Let's try (): my $hdr = pack('H2B8n', '45', sprintf("%06b%02b", $dscp, $ecn), $length);
sprintfThe template first specifies H2, a 2-character hex string, high nybble first. The corresponding argument to pack is "45"-version 4, length 5. The next template is B8, an 8-bit bit string, descending bit order inside each byte. We need to use bit strings to control layout down to chunks smaller than a nybble (4 bits), so the () is used to construct such a bit string from 6 bits from $dscp and 2 from $ecn. The last one is n, an unsigned 16-bit value in Network Byte Order, i.e. always big-endian no matter what your CPU's native integer format is, and it is filled from $length.
That's the first 32 bits of the header. The rest can be built similarly:
Template	Argument	Remarks n	$id
sprintf("%03b%013b"$frag_off) $flags,,
B16Same as DSCP/ECN
$ttl, $protoC2Two consecutive unsigned octets
x could be used to insert a null byte but n lets us specify an
n	0 / $checksum
argument should we choose to calculate a checksum
gethostbyname$src_ip, $dst_ipuse a4a4 to pack the result of two () calls as it
N2 is in Network Byte Order already!
So the complete call to pack an IPv4 header would be:


Chapter 28: Perl commands for Windows Excel with Win32::OLE module
Parameters	Details
The name of the range. This must be an A1-style reference in the language of the macro. It can
Cell1 (required) include the range operator (a colon), the intersection operator (a space), or the union operator (a comma).
If specified, Cell1 corresponds to the upper-left corner of the range and Cell2 corresponds to the
Cell2 (optional) lower-right corner of the range
These examples introduce the most used commands of Perl to manipulate Excel via Win32::OLE module.
Section 28.1: Opening and Saving Excel/Workbooks

Section 28.2: Manipulation of Worksheets


Section 28.3: Manipulation of cells
#Edit the value of a cell (2 methods)
$Sheet->Range("A1")->{Value} = 1234;
$Sheet->Cells(1,1)->{Value} = 1234;
#Edit the values in a range of cells
$Sheet->Range("A8:C9")->{Value} = [[ undef, 'Xyzzy', 'Plugh' ],
                               [ 42,    'Perl',  3.1415  ]];
#Edit the formula in a cell (2 types)
$Sheet->Range("A1")->{Formula} = "=A1*9.81";
$Sheet->Range("A3")->{FormulaR1C1} = "=SUM(R[-2]C:R[-1]C)";      # Sum of rows
$Sheet->Range("C1")->{FormulaR1C1} = "=SUM(RC[-2]:RC[-1])";      # Sum of columns
#Edit the format of the text (font)
$Sheet->Range("G7:H7")->Font->{Bold}       = "True";
$Sheet->Range("G7:H7")->Font->{Italic}     = "True";
$Sheet->Range("G7:H7")->Font->{Underline}  = xlUnderlineStyleSingle;
$Sheet->Range("G7:H7")->Font->{Size}       = 8;
$Sheet->Range("G7:H7")->Font->{Name}       = "Arial";
$Sheet->Range("G7:H7")->Font->{ColorIndex} = 4;
#Edit the number format
$Sheet -> Range("G7:H7") -> {NumberFormat} = "\@";                                 # Text
$Sheet -> Range("A1:H7") -> {NumberFormat} = "\$#,##0.00";                        # Currency $Sheet -> Range("G7:H7") -> {NumberFormat} = "\$#,##0.00_);[Red](\$#,##0.00)";     # Currency - red negatives
$Sheet -> Range("G7:H7") -> {NumberFormat} = "0.00_);[Red](0.00)";                 # Numbers with decimals
$Sheet -> Range("G7:H7") -> {NumberFormat} = "#,##0";                          #     Numbers with commas
$Sheet -> Range("G7:H7") -> {NumberFormat} = "#,##0_);[Red](#,##0)";               # Numbers with commas - red negatives
$Sheet -> Range("G7:H7") -> {NumberFormat} = "0.00%";                              # Percents
$Sheet -> Range("G7:H7") -> {NumberFormat} = "m/d/yyyy"                            # Dates
#Align text
$Sheet -> Range("G7:H7") -> {HorizontalAlignment} = xlHAlignCenter;                # Center text;
$Sheet -> Range("A1:A2") -> {Orientation} = 90;                                    # Rotate text
#Activate Cell
$Sheet -> Range("A2") -> Activate;
$Sheet->Hyperlinks->Add({  
   Anchor          =>  $range, #Range of cells with the hyperlink; e.g. $Sheet->Range("A1")    Address         =>  $adr, #File path, http address, etc.
   TextToDisplay   =>  $txt, #Text in the cell
   ScreenTip       =>  $tip, #Tip while hovering the mouse over the hyperlink

N.B: to retrieve the list of hyperlinks, have a look at the following post Getting list of hyperlinks from an Excel worksheet with Perl Win32::OLE
Section 28.4: Manipulation of Rows / Columns
#Insert a row before/after line 22
$Sheet->Rows("22:22")->Insert(xlUp, xlFormatFromRightOrBelow);
$Sheet->Rows("23:23")->Insert(-4121,0);     #xlDown is -4121 and that xlFormatFromLeftOrAbove is 0
#Delete a row
$Sheet->Rows("22:22")->Delete();
#Set column width and row height
$Sheet -> Range('A:A') -> {ColumnWidth} = 9.14;
$Sheet -> Range("8:8") -> {RowHeight}   = 30;
$Sheet -> Range("G:H") -> {Columns} -> Autofit;
# Get the last row/column my $last_row = $Sheet -> UsedRange -> Find({What => "*", SearchDirection => xlPrevious, SearchOrder
=> xlByRows})    -> {Row}; my $last_col = $Sheet -> UsedRange -> Find({What => "*", SearchDirection => xlPrevious, SearchOrder => xlByColumns}) -> {Column};
#Add borders (method 1)
$Sheet -> Range("A3:H3") -> Borders(xlEdgeBottom)       -> {LineStyle}  = xlDouble;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeBottom)       -> {Weight}     = xlThick;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeBottom)       -> {ColorIndex} = 1;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeLeft)         -> {LineStyle}  = xlContinuous; $Sheet -> Range("A3:H3") -> Borders(xlEdgeLeft)         -> {Weight}     = xlThin;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeTop)          -> {LineStyle}  = xlContinuous; $Sheet -> Range("A3:H3") -> Borders(xlEdgeTop)          -> {Weight}     = xlThin;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeBottom)       -> {LineStyle}  = xlContinuous; $Sheet -> Range("A3:H3") -> Borders(xlEdgeBottom)       -> {Weight}     = xlThin;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeRight)        -> {LineStyle}  = xlContinuous;
$Sheet -> Range("A3:H3") -> Borders(xlEdgeRight)        -> {Weight}     = xlThin;
$Sheet -> Range("A3:H3") -> Borders(xlInsideVertical)   -> {LineStyle}  = xlDashDot
$Sheet -> Range("A3:H3") -> Borders(xlInsideVertical)   -> {Weight}     = xlMedium;
$Sheet -> Range("A3:I3") -> Borders(xlInsideHorizontal) -> {LineStyle}  = xlContinuous;
$Sheet -> Range("A3:I3") -> Borders(xlInsideHorizontal) -> {Weight}     = xlThin;
#Add borders (method 2) my @edges = qw (xlInsideHorizontal xlInsideVertical xlEdgeBottom xlEdgeTop xlEdgeRight); foreach my $edge (@edges)
Chapter 29: Simple interaction with database via DBI module
Column	Column
$driver Driver for DB, "Pg" for Postgresql and "mysql" for MySQL
$database your database name
$userid your database id
$password your database password
$query	put your query here, ex: "select * from $your_table"
Section 29.1: DBI module
You should make sure that module DBI has been installed on your pc, then follow the bellow steps:
1. use DBI module in your perl script
use DBI;
2. Declare some primary parameters
my $driver = "MyDriver";
my $database = "DB_name";
my $dsn = "DBI:$driver:dbname=$database";
my $userid = "your_user_ID";
my $password = "your_password";
my $tablename = "your_table";
3. Connect to your database
my $dbh = DBI->connect($dsn, $userid, $password);
4. Prepare your query
my $query = $dbh->prepare("Your DB query");
Ex:
$my_query = qq/SELECT * FROM table WHERE column1 = 2/;
my $query = $dbh->prepare($my_query);
We can also use variable in the query, like below:
my $table_name = "table";
my $filter_value = 2;
$my_query = qq/SELECT * FROM $table_name WHERE column1 = $filter_value/;
5. Execute your query
$query->execute();
*Note: To avoid injection attack, you should use placeholders ? instead of put your variable in the query.
Ex: you want to show the all data from 'table' where column1=$value1 and column2=$value2:
my $query = $dbh->prepare("SELECT * FROM table WHERE column1 = ? AND column2 = ?;");
$query->execute($value1, $value2);
6. Fletch your data
my @row = $query->fetchrow_array(); store data as array
or
my $ref = $sth->fetchrow_hashref(); store data as hash reference
7. Finish and disconnect DB
$sth->finish;
$dbh->disconnect();

Chapter 30: Perl Testing
Section 30.1: Perl Unit Testing Example
The following is a simple example Perl test script, that gives some structure to allow for testing of other methods in the class/package under test. The script produces standard output with simple "ok" / "not ok" text, which is called TAP (Test Anything Protocol).
Typically the prove command runs the script(s) and summarises the test results.


Best Practice
A test script should only test one package/class, but there many scripts may be used to test a package/class.
Further Reading
Test::More - The basic test operations.
Test::Exception - Testing thrown exceptions.
Test::Differences - Comparing test results that have complex data structures.
Test::Class - Class based testing rather than script. Similarities to JUnit. Perl Testing Tutorials - Further reading.

Chapter 31: Dancer
About:
Dancer2 (the successor of Dancer) is a simple but powerful web application framework for Perl.
It is inspired by Sinatra and written by Alexis Sukrieh.
Key features: ••• Dead Simple - Intuitive, minimalist and very expressive syntax. ••• Flexible - PSGI support, plugins and modular design allow for strong scalability. ••• Few dependencies - Dancer depends on as few CPAN modules as possible making it easy to install.
Section 31.1: Easiest example


Chapter 32: Attributed Text
Section 32.1: Printing colored Text


Chapter 33: GUI Applications in Perl
Section 33.1: GTK Application


Chapter 34: Memory usage optimization
Section 34.1: Reading files: foreach vs. while
When reading a potentially large file, a while loop has a significant memory advantage over foreach. The following will read the file record by record (by default, "record" means "a line", as specified by $/), assigning each one to $_ as it is read:

The diamond operator does some magic here to make sure the loop only terminates at end-of-file and not e.g. on lines that contain only a "0" character.
The following loop seems to work just the same, however it evaluates the diamond operator in list context, causing the entire file to be read in one go:

If you are operating on one record at a time anyway, this can result in a huge waste of memory and should thus be avoided.
Section 34.2: Processing long lists
If you have a list in memory already, the straightforward and usually sufficient way to process it is a simple foreach loop:

This is fine e.g. for the common case of doing some processing on $item and then writing it out to a file without keeping the data around. However, if you build up some other data structure from the items, a while loop is more memory efficient:

Unless a reference to $item directly ends up in your result list, items you shifted off the @items array can be freed and the memory reused by the interpreter when you enter the next loop iteration.
Chapter 35: Perl script debugging
Section 35.1: Run script in debug mode
To run script in debug mode you should add -d option in the command line:

If t is specified, it indicates to the debugger that threads will be used in the code being debugged:

Additional info at perldocperlrun
Section 35.2: Use a nonstandard debugger
$perl -d:MOD script.plDevel::MOD runs the program under the control of a debugging, profiling, or tracing module installed as .
-d:NYTProf executes the program using the Devel::NYTProfFor example,  profiler.
See all available Devel modules here
Recommended modules:
Devel::NYTProfDevel::TrepanDevel::MATDevel::hdbDevel::DebugHooks::KillPrintDevel::REPLDevel::Cover -- Powerful fast feature-rich Perl source code profiler
 -- A modular gdb-like Perl debugger
 -- Perl Memory Analysis Tool
 -- Perl debugger as a web page and REST service
 -- Allows to forget about debugging by print statement
 -- A modern perl interactive shell
 -- Code coverage metrics for Perl
Chapter 36: Perlbrew
~/.perlbrew.shPerlbrew is a tool to manage multiple perl installations in your $HOME directory. Section 36.1: Setup perlbrew for the first time Create setup script :

install_perlbrew.shCreate installation script :

Run installation script:
./install_perlbrew.sh
~/.bashrcAdd to the end of your 

~/.bashrcSource :

Chapter 37: Installation of Perl
I'm going to begin this with the process in Ubuntu, then in OS X and finally in Windows. I haven't tested it on all perl versions, but it should be a similar process.
Use Perlbrew if you like to switch easily beween different versions of Perl.
I want to state that this tutorial is about Perl in it's open-source version. There are other versions like activeperl which its advantages and disadvantages, that are not part of this tutorial.
Section 37.1: Linux

Section 37.2: OS X

After the install of perlbrew, if you want to install Perl with thread support, just run:


Section 37.3: Windows
 As we said before, we go with the open-source version. For Windows you can choose strawberry or DWIM. Here we cover the strawberry version, since DWIM is based on it. The easy way here is installing from the official executable.
See also berrybrew - the perlbrew for Windows Strawberry Perl

Chapter 38: Compile Perl cpan module sapnwrfc from source code
I'd like to describe the prerequisites and the steps how to build the Perl CPAN module sapnwrfc with the Strawberry Perl environment under Windows 7 x64. It should work also for all later Windows versions like 8, 8.1 and 10.
I use Strawberry Perl 5.24.1.1 64 bit but it should also work with older versions.
It took me some hourse to succeed with several tries (32 vs. 64 bit installation of Perl, SAP NW RFC SDK, MinGW vs. Microsoft C compiler). So I hope some will benefit from my findings. Section 38.1: Simple example to test the RFC connection
Simple example from http://search.cpan.org/dist/sapnwrfc/sapnwrfc-cookbook.pod

Chapter 39: Best Practices
Section 39.1: Using Perl::Critic
If you'd like to start implementing best practices, for yourself or your team, then Perl::Critic is the best place to start. The module is based on the Perl Best Practices book by Damien Conway and does a fairly good job implementing the suggestions made therein.
Note: I should mention (and Conway himself says in the book) that these are suggestions. I've found the book provides solid reasoning in most cases, though I certainly don't agree with all of them. The important thing to remember is that, whatever practices you decide to adopt, you remain consistent. The more predictable your code is, the easier it will be to maintain.
You can also try out Perl::Critic through your browser at perlcritic.com.

This will install the basic ruleset and a perlcritic script that can be called from the command line.
Basic Usage
The CPAN doc for perlcritic contains full documentation, so I will only be going over the most common use cases to get you started. Basic usage is to simply call perlcritic on the file:

perlcritic works both on scripts and on modules. The -1 refers to the severity level of the rules you want to run against the script. There are five levels that correspond to how much Perl::Critic will pick apart your code.
-5 is the most gentle and will only warn about potentially dangerous problems that could cause unexpected results. -1 is the most brutal and will complain about things as small as your code being tidy or not. In my experience, keeping code compliant with level 3 is good enough to keep out of danger without getting too persnickety.
By default, any failures will list the reason and severity the rule triggers on:
perlcritic -3 --verbose 8 /path/to/script.pl
Debugging module loaded at line 16, column 1.  You've loaded Data::Dumper, which probably shouln't be loaded in production.  (Severity: 4) Private subroutine/method '_sub_name' declared but not used at line 58, column 1.  Eliminate dead code.  (Severity: 3) Backtick operator used at line 230, column 37.  Use IPC::Open3 instead.  (Severity: 3)
Backtick operator used at line 327, column 22.  Use IPC::Open3 instead.  (Severity: 3)
Viewing Policies
You can quickly see which rules are being triggered and why by utilizing perlcritic's --verbose option:
Setting the level to 8 will show you the rule that triggered a warning:
perlcritic -3 --verbose 8 /path/to/script.pl
[Bangs::ProhibitDebuggingModules] Debugging module loaded at line 16, column 1.  (Severity: 4) [Subroutines::ProhibitUnusedPrivateSubroutines] Private subroutine/method '_sub_name' declared but not used at line 58, column 1.  (Severity: 3) [InputOutput::ProhibitBacktickOperators] Backtick operator used at line 230, column 37.  (Severity:
3) [InputOutput::ProhibitBacktickOperators] Backtick operator used at line 327, column 22.  (Severity:
3)
While a level of 11 will show the specific reasons why the rule exists:
perlcritic -3 --verbose 11 /path/to/script.pl
Debugging module loaded at line 16, near 'use Data::Dumper;'.
  Bangs::ProhibitDebuggingModules (Severity: 4)
    This policy prohibits loading common debugging modules like the     Data::Dumper manpage.
    While such modules are incredibly useful during development and     debugging, they should probably not be loaded in production use. If this     policy is violated, it probably means you forgot to remove a `use
    Data::Dumper;' line that you had added when you were debugging.
Private subroutine/method '_svn_revisions_differ' declared but not used at line 58, near 'sub
_sub_name {'.
  Subroutines::ProhibitUnusedPrivateSubroutines (Severity: 3)     By convention Perl authors (like authors in many other languages)     indicate private methods and variables by inserting a leading underscore     before the identifier. This policy catches such subroutines which are     not used in the file which declares them.
    This module defines a 'use' of a subroutine as a subroutine or method     call to it (other than from inside the subroutine itself), a reference     to it (i.e. `my $foo = \&_foo'), a `goto' to it outside the subroutine     itself (i.e. `goto &_foo'), or the use of the subroutine's name as an     even-numbered argument to `use overload'.
Backtick operator used at line 230, near 'my $filesystem_diff = join q{}, `diff $trunk_checkout
$staging_checkout`;'.
  InputOutput::ProhibitBacktickOperators (Severity: 3)
    Backticks are super-convenient, especially for CGI programs, but I find     that they make a lot of noise by filling up STDERR with messages when     they fail. I think its better to use IPC::Open3 to trap all the output     and let the application decide what to do with it.
        use IPC::Open3 'open3';         $SIG{CHLD} = 'IGNORE';         @output = `some_command`;                      #not ok
        my ($writer, $reader, $err);         open3($writer, $reader, $err, 'some_command'); #ok;         @output = <$reader>;  #Output here
        @errors = <$err>;     #Errors here, instead of the console
Backtick operator used at line 327, near 'my $output = `$cmd`;'.
  InputOutput::ProhibitBacktickOperators (Severity: 3)
    Backticks are super-convenient, especially for CGI programs, but I find     that they make a lot of noise by filling up STDERR with messages when     they fail. I think its better to use IPC::Open3 to trap all the output     and let the application decide what to do with it.
        use IPC::Open3 'open3';

Ignoring Code
There will be times when you can't comply with a Perl::Critic policy. In those cases, you can wrap special comments, "## use critic()" and "## no critic", around your code to make Perl::Critic ignore them. Simply add the rules you want to ignore in the parentheses (multiples can be separated by a comma).

Make sure to wrap the entire code block or Critic may not recognize the ignore statement.

Note that there are certain policies that are run on the document level and cannot be exempted this way. However, they can be turned off...
Creating Permanent Exceptions
Using ## no critic() is nice, but as you start to adopt coding standards, you will likely want to make permanent exceptions to certain rules. You can do this by creating a .perlcriticrc configuration file.
This file will allow you to customize not only which policies are run, but how they are run. Using it is as simple as placing the file in your home directory (in Linux, unsure if it's the same place on Windows). Or, you can specify the config file when running the command using the --profile option:

Again, the perlcritic CPAN page has a full list of these options. I will list some examples from my own config file:
Apply basic settings:

Disable a rule (note the dash in front of the policy name):


Modifying a rule:

Conclusion
Properly utilized, Perl::Critic can be an invaluable tool to help teams keep their coding consistent and easily maintainable no matter what best practice policies you employ.

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
AbhiNickzChapter 23Al.G.Chapter 18Alien Life FormChapter 13AntonHChapter 24asthmanChapter 26Ataul HaqueChapter 9badpChapters 3, 5, 8, 14, 16 and 17Bill the LizardChapter 5brian d foyChapter 10callyalaterChapter 7Chankey PathakChapter 31Christopher BottomsChapters 1, 2, 5, 7, 8, 9, 10, 12, 14, 22, 24 and 25datageistChapter 1Denis IbaevChapter 1digitalis_Chapters 3, 8 and 14Dmitry EgorovChapters 16 and 21dmvrtxChapter 3Drav SloanChapter 19DVKChapters 10 and 15eballesChapter 19eddy85brChapter 1Eugen KonkovChapters 1, 3, 10, 21 and 35fanlimChapters 26 and 37flameyChapter 37flotuxChapter 38Håkon HæglandChapters 3, 12, 20 and 36ikegamiChapter 5interduoChapter 39Iván Rodríguez TorresChapter 37JeanChapter 28Jeff YChapter 13John HartChapter 24Jon EricsonChapters 1, 3, 18 and 24KemiChapters 12, 13, 20, 21 and 25Kent FredricChapters 3, 5, 12, 14, 20, 24 and 27Leon TimmermansChapter 1lepeChapter 24luistmChapters 25 and 37matt freakeChapter 12mbethkeChapters 3, 5, 8, 11, 13, 20, 21, 24, 27 and 34Michael CarmanChapter 8MikChapter 3msh210Chapters 5 and 8Muaaz RafiChapter 10NagarajuChapter 12nfantaChapter 3Ngoan TranChapters 6, 25, 26 and 29
nslntmnxChapter 30oalsChapters 3, 4 and 7oldtechaaChapter 33Ole TangeChapter 5OtterbeinChapter 3pwesChapters 10 and 13RandallChapter 25rbennett485Chapter 12Rebecca CloseChapters 2 and 22reflective_mindChapter 10Rick JamesChapter 10Ruslan BatdalovChapters 4 and 16SajithPChapters 12, 18 and 32Sarwesh SumanChapter 18SebiChapter 12serenesatChapter 15simbabqueChapter 9SobriqueChapter 19SREagleChapters 12 and 13Stephen LeppikChapter 18svarogChapter 14Tim HallyburtonChapter 12waghsoChapters 6 and 9WolfChapters 8 and 10xfixChapters 5 and 8xtreakChapter 8yonyon100Chapter 12ZaidChapter 22zb226Chapters 3 and 21
You may also like







GoalKicker.com - Perl(r) Notes for Professionals	1

GoalKicker.com - Perl(r) Notes for Professionals	1

GoalKicker.com - Perl(r) Notes for Professionals	1







