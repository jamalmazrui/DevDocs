
sqlite-utils documentation
Release 3.38-4-g0aefbb6
Simon Willison
Jan 11, 2025



CONTENTS
1 Contents	3
1.1 Installation	3
1.1.1 Using Homebrew	3
1.1.2 Using pip	3
1.1.3 Using pipx	3
1.1.4 Alternatives to sqlite3	4
1.1.5 Setting up shell completion	4
1.2 sqlite-utils command-line tool	4
1.2.1 Running SQL queries	7
1.2.2 Querying data directly using an in-memory database	13
1.2.3 Returning all rows in a table	16
1.2.4 Listing tables	17
1.2.5 Listing views	18
1.2.6 Listing indexes	19
1.2.7 Listing triggers	20
1.2.8 Showing the schema	20
1.2.9 Analyzing tables	21
1.2.10 Creating an empty database	23
1.2.11 Inserting JSON data	23
1.2.12 Inserting CSV or TSV data	26
1.2.13 Inserting unstructured data with --lines and --text	27
1.2.14 Applying conversions while inserting data	28
1.2.15 Insert-replacing data	29
1.2.16 Upserting data	30
1.2.17 Executing SQL in bulk	30
1.2.18 Inserting data from files	31
1.2.19 Converting data in columns	33
1.2.20 Creating tables	37
1.2.21 Renaming a table	38
1.2.22 Duplicating tables	38
1.2.23 Dropping tables	39
1.2.24 Transforming tables	39
1.2.25 Extracting columns into a separate table	41
1.2.26 Creating views	43
1.2.27 Dropping views	43
1.2.28 Adding columns	43
1.2.29 Adding columns automatically on insert/update	44
1.2.30 Adding foreign key constraints	44
1.2.31 Setting defaults and not null constraints	45
1.2.32 Creating indexes	45
1.2.33 Configuring full-text search	45
1.2.34 Executing searches	46
1.2.35 Enabling cached counts	47
1.2.36 Optimizing index usage with ANALYZE	47
1.2.37 Vacuum	48
1.2.38 Optimize	48
1.2.39 WAL mode	48
1.2.40 Dumping the database to SQL	48
1.2.41 Loading SQLite extensions	49
1.2.42 SpatiaLite helpers	49
1.2.43 Installing packages	50
1.2.44 Uninstalling packages	50
1.3 sqlite_utils Python library	50
1.3.1 Getting started	53
1.3.2 Connecting to or creating a database	54
1.3.3 Executing queries	56
1.3.4 Accessing tables	57
1.3.5 Listing tables	57
1.3.6 Listing views	57
1.3.7 Listing rows	58
1.3.8 Listing rows with their primary keys	59
1.3.9 Retrieving a specific record	60
1.3.10 Showing the schema	60
1.3.11 Creating tables	60
1.3.12 Renaming a table	65
1.3.13 Duplicating tables	65
1.3.14 Bulk inserts	65
1.3.15 Insert-replacing data	66
1.3.16 Updating a specific record	67
1.3.17 Deleting a specific record	68
1.3.18 Deleting multiple records	68
1.3.19 Upserting data	68
1.3.20 Converting data in columns	69
1.3.21 Working with lookup tables	69
1.3.22 Working with many-to-many relationships	71
1.3.23 Analyzing a column	73
1.3.24 Adding columns	74
1.3.25 Adding columns automatically on insert/update	75
1.3.26 Adding foreign key constraints	75
1.3.27 Dropping a table or view	76
1.3.28 Transforming a table	76
1.3.29 Extracting columns into a separate table	80
1.3.30 Setting an ID based on the hash of the row contents	82
1.3.31 Creating views	83
1.3.32 Storing JSON	83
1.3.33 Converting column values using SQL functions	84
1.3.34 Checking the SQLite version	85
1.3.35 Dumping the database to SQL	85
1.3.36 Introspecting tables and views	85
1.3.37 Full-text search	90
1.3.38 Rebuilding a full-text search table	94
1.3.39 Optimizing a full-text search table	94
1.3.40 Cached table counts using triggers	94
1.3.41 Creating indexes	95
1.3.42 Optimizing index usage with ANALYZE	96
1.3.43 Vacuum	96
1.3.44 WAL mode	96
1.3.45 Suggesting column types	97
1.3.46 Registering custom SQL functions	98
1.3.47 Quoting strings for use in SQL	99
1.3.48 Reading rows from a file	99
1.3.49 Setting the maximum CSV field size limit	100
1.3.50 Detecting column types using TypeTracker	101
1.3.51 SpatiaLite helpers	102
1.4 Plugins	104
1.4.1 Building a plugin	105
1.4.2 Plugin hooks	106
1.5 API reference	107
1.5.1 sqlite_utils.db.Database	107
1.5.2 sqlite_utils.db.Queryable	114
1.5.3 sqlite_utils.db.Table	116
1.5.4 sqlite_utils.db.View	129
1.5.5 Other	129
1.5.6 sqlite_utils.utils	130
1.6 CLI reference	133
1.6.1 query	134
1.6.2 memory	135
1.6.3 insert	136
1.6.4 upsert	138
1.6.5 bulk	139
1.6.6 search	140
1.6.7 transform	140
1.6.8 extract	141
1.6.9 schema	141
1.6.10 insert-files	142
1.6.11 analyze-tables	142
1.6.12 convert	143
1.6.13 tables	144
1.6.14 views	145
1.6.15 rows	146
1.6.16 triggers	146
1.6.17 indexes	147
1.6.18 create-database	148
1.6.19 create-table	148
1.6.20 create-index	149
1.6.21 enable-fts	149
1.6.22 populate-fts	150
1.6.23 rebuild-fts	150
1.6.24 disable-fts	150
1.6.25 tui	151
1.6.26 optimize	151
1.6.27 analyze	151
1.6.28 vacuum	152
1.6.29 dump	152
1.6.30 add-column	152
1.6.31 add-foreign-key	153
1.6.32 add-foreign-keys	153
1.6.33 index-foreign-keys	153
1.6.34 enable-wal	154
1.6.35 disable-wal	154
1.6.36 enable-counts	154
1.6.37 reset-counts	155
1.6.38 duplicate	155
1.6.39 rename-table	155
1.6.40 drop-table	156
1.6.41 create-view	156
1.6.42 drop-view	156
1.6.43 install	157
1.6.44 uninstall	157
1.6.45 add-geometry-column	157
1.6.46 create-spatial-index	158
1.6.47 plugins	158
1.7 Contributing	158
1.7.1 Obtaining the code	159
1.7.2 Running the tests	159
1.7.3 Building the documentation	159
1.7.4 Linting and formatting	159
1.7.5 Using Just and pipenv	160
1.7.6 Release process	161
1.8 Changelog	161
1.8.1 3.38 (2024-11-23)	161
1.8.2 3.37 (2024-07-18)	162
1.8.3 3.36 (2023-12-07)	162
1.8.4 3.35.2 (2023-11-03)	162
1.8.5 3.35.1 (2023-09-08)	162
1.8.6 3.35 (2023-08-17)	162
1.8.7 3.34 (2023-07-22)	163
1.8.8 3.33 (2023-06-25)	163
1.8.9 3.32.1 (2023-05-21)	164
1.8.10 3.32 (2023-05-21)	164
1.8.11 3.31 (2023-05-08)	164
1.8.12 3.30 (2022-10-25)	165
1.8.13 3.29 (2022-08-27)	165
1.8.14 3.28 (2022-07-15)	166
1.8.15 3.27 (2022-06-14)	166
1.8.16 3.26.1 (2022-05-02)	167
1.8.17 3.26 (2022-04-13)	167
1.8.18 3.25.1 (2022-03-11)	167
1.8.19 3.25 (2022-03-01)	167
1.8.20 3.24 (2022-02-15)	167
1.8.21 3.23 (2022-02-03)	168
1.8.22 3.22.1 (2022-01-25)	168
1.8.23 3.22 (2022-01-11)	168
1.8.24 3.21 (2022-01-10)	168
1.8.25 3.20 (2022-01-05)	169
1.8.26 3.19 (2021-11-20)	169
1.8.27 3.18 (2021-11-14)	169
1.8.28 3.17.1 (2021-09-22)	170
1.8.29 3.17 (2021-08-24)	170
1.8.30 3.16 (2021-08-18)	170
1.8.31 3.15.1 (2021-08-10)	170
1.8.32 3.15 (2021-08-09)	171
1.8.33 3.14 (2021-08-02)	171
1.8.34 3.13 (2021-07-24)	171
1.8.35 3.12 (2021-06-25)	172
1.8.36 3.11 (2021-06-20)	172
1.8.37 3.10 (2021-06-19)	172
1.8.38 3.9.1 (2021-06-12)	173
1.8.39 3.9 (2021-06-11)	174
1.8.40 3.8 (2021-06-02)	174
1.8.41 3.7 (2021-05-28)	174
1.8.42 3.6 (2021-02-18)	174
1.8.43 3.5 (2021-02-14)	174
1.8.44 3.4.1 (2021-02-05)	175
1.8.45 3.4 (2021-02-05)	175
1.8.46 3.3 (2021-01-17)	175
1.8.47 3.2.1 (2021-01-12)	175
1.8.48 3.2 (2021-01-03)	175
1.8.49 3.1.1 (2021-01-01)	176
1.8.50 3.1 (2020-12-12)	176
1.8.51 3.0 (2020-11-08)	176
1.8.52 2.23 (2020-10-28)	177
1.8.53 2.22 (2020-10-16)	177
1.8.54 2.21 (2020-09-24)	177
1.8.55 2.20 (2020-09-22)	177
1.8.56 2.19 (2020-09-20)	178
1.8.57 2.18 (2020-09-08)	178
1.8.58 2.17 (2020-09-07)	179
1.8.59 2.16.1 (2020-08-28)	179
1.8.60 2.16 (2020-08-21)	179
1.8.61 2.15.1 (2020-08-12)	179
1.8.62 2.15 (2020-08-10)	179
1.8.63 2.14.1 (2020-08-05)	179
1.8.64 2.14 (2020-08-01)	180
1.8.65 2.13 (2020-07-29)	180
1.8.66 2.12 (2020-07-27)	180
1.8.67 2.11 (2020-07-08)	180
1.8.68 2.10.1 (2020-06-23)	180
1.8.69 2.10 (2020-06-12)	181
1.8.70 2.9.1 (2020-05-11)	181
1.8.71 2.9 (2020-05-10)	181
1.8.72 2.8 (2020-05-03)	181
1.8.73 2.7.2 (2020-05-02)	181
1.8.74 2.7.1 (2020-05-01)	181
1.8.75 2.7 (2020-04-17)	181
1.8.76 2.6 (2020-04-15)	182
1.8.77 2.5 (2020-04-12)	182
1.8.78 2.4.4 (2020-03-23)	182
1.8.79 2.4.3 (2020-03-23)	182
1.8.80 2.4.2 (2020-03-14)	182
1.8.81 2.4.1 (2020-03-01)	182
1.8.82 2.4 (2020-02-26)	182
1.8.83 2.3.1 (2020-02-10)	183
1.8.84 2.3 (2020-02-08)	183
1.8.85 2.2.1 (2020-02-06)	183
1.8.86 2.2 (2020-02-01)	183
1.8.87 2.1 (2020-01-30)	183
1.8.88 2.0.1 (2020-01-05)	183
1.8.89 2.0 (2019-12-29)	183
1.8.90 1.12.1 (2019-11-06)	184
1.8.91 1.12 (2019-11-04)	184
1.8.92 1.11 (2019-09-02)	184
1.8.93 1.10 (2019-08-23)	184
1.8.94 1.9 (2019-08-04)	184
1.8.95 1.8 (2019-07-28)	184
1.8.96 1.7.1 (2019-07-28)	185
1.8.97 1.7 (2019-07-24)	185
1.8.98 1.6 (2019-07-18)	185
1.8.99 1.5 (2019-07-14)	185
1.8.100 1.4.1 (2019-07-14)	185
1.8.101 1.4 (2019-06-30)	185
1.8.102 1.3 (2019-06-28)	186
1.8.103 1.2.2 (2019-06-25)	186
1.8.104 1.2.1 (2019-06-20)	186
1.8.105 1.2 (2019-06-12)	186
1.8.106 1.1 (2019-05-28)	186
1.8.107 1.0.1 (2019-05-27)	186
1.8.108 1.0 (2019-05-24)	186
1.8.109 0.14 (2019-02-24)	187
1.8.110 0.13 (2019-02-23)	187
1.8.111 0.12 (2019-02-22)	187
1.8.112 0.11 (2019-02-07)	187
1.8.113 0.10 (2019-02-06)	188
1.8.114 0.9 (2019-01-27)	188
1.8.115 0.8 (2019-01-25)	188
1.8.116 0.7 (2019-01-24)	189
1.8.117 0.6 (2018-08-12)	189
1.8.118 0.5 (2018-08-05)	190
1.8.119 0.4 (2018-07-31)	190
1.8.120 0.3.1 (2018-07-31)	190
1.8.121 0.3 (2018-07-31)	190
1.8.122 0.2 (2018-07-28)	190
Index	191


sqlite-utils documentation, Release 3.38-4-g0aefbb6

CLI tool and Python library for manipulating SQLite databases
This library and command-line utility helps create SQLite databases from an existing collection of data.
Most of the functionality is available as either a Python API or through the sqlite-utils command-line tool.
sqlite-utils is not intended to be a full ORM: the focus is utility helpers to make creating the initial database and populating it with data as productive as possible. It is designed as a useful complement to Datasette.
Cleaning data with sqlite-utils and Datasette provides a tutorial introduction (and accompanying ten minute video) about using this tool.
CONTENTS
CONTENTS

CHAPTER
ONE

CONTENTS
1.1 Installation
sqlite-utils is tested on Linux, macOS and Windows.
1.1.1 Using Homebrew
The sqlite-utils command-line tool can be installed on macOS using Homebrew:

If you have it installed and want to upgrade to the most recent release, you can run:

Then run sqlite-utils --version to confirm the installed version.
1.1.2 Using pip
The sqlite-utils package on PyPI includes both the sqlite_utils Python library and the sqlite-utils command-line tool. You can install them using pip like so:

1.1.3 Using pipx
pipx is a tool for installing Python command-line applications in their own isolated environments. You can use pipx to install the sqlite-utils command-line tool like this:


1.1.4 Alternatives to sqlite3
By default, sqlite-utils uses the sqlite3 package bundled with the Python standard library. Depending on your operating system, this may come with some limitations.
On	some	platforms	the	ability	to	load	additional	extensions	(via conn.load_extension(...) or --load-extension=/path/to/extension) may be disabled.
You may also see the error sqlite3.OperationalError: table sqlite_master may not be modified when trying to alter an existing table.
You can work around these limitations by installing either the pysqlite3 package or the sqlean.py package, both of which provide drop-in replacements for the standard library sqlite3 module but with a recent version of SQLite and full support for loading extensions.
To install sqlean.py (which has compiled binary wheels available for all major platforms) run the following:

pysqlite3 and sqlean.py do not provide implementations of the .iterdump() method. To use that method (see Dumping the database to SQL) or the sqlite-utils dump command you should also install the sqlite-dump package:

1.1.5 Setting up shell completion
You can configure shell tab completion for the sqlite-utils command using these commands.
For bash:

For zsh:

Add this code to ~/.zshrc or ~/.bashrc to automatically run it when you start a new shell.
See the Click documentation for more details.
1.2 sqlite-utils command-line tool
The sqlite-utils command-line tool can be used to manipulate SQLite databases in a number of different ways.
Once installed the tool should be available as sqlite-utils. It can also be run using python -m sqlite_utils.
• Running SQL queries
- Returning JSON
∗ Newline-delimited JSON
∗ JSON arrays
∗ Binary data in JSON
∗ Nested JSON values
- Returning CSV or TSV
- Table-formatted output
- Returning raw data, such as binary content
- Using named parameters
- UPDATE, INSERT and DELETE
- Defining custom SQL functions - SQLite extensions
- Attaching additional databases
• Querying data directly using an in-memory database
- Running queries directly against CSV or JSON
- Explicitly specifying the format
- Joining in-memory data against existing databases using --attach
- --schema, --analyze, --dump and --save
• Returning all rows in a table
• Listing tables
• Listing views
• Listing indexes
• Listing triggers
• Showing the schema
• Analyzing tables
- Saving the analyzed table details
• Creating an empty database • Inserting JSON data
- Inserting binary data
- Inserting newline-delimited JSON
- Flattening nested JSON objects
• Inserting CSV or TSV data
- Alternative delimiters and quote characters
- CSV files without a header row
• Inserting unstructured data with --lines and --text
• Applying conversions while inserting data
- --convert with --lines
- --convert with --text
• Insert-replacing data
• Upserting data
• Executing SQL in bulk
• Inserting data from files
• Converting data in columns
- Importing additional modules
- Using the debugger
- Defining a convert() function
- sqlite-utils convert recipes
- Saving the result to a different column
- Converting a column into multiple columns
• Creating tables
• Renaming a table
• Duplicating tables
• Dropping tables
• Transforming tables
- Adding a primary key to a rowid table
• Extracting columns into a separate table
• Creating views
• Dropping views
• Adding columns
• Adding columns automatically on insert/update
• Adding foreign key constraints
- Adding multiple foreign keys at once
- Adding indexes for all foreign keys
• Setting defaults and not null constraints
• Creating indexes
• Configuring full-text search
• Executing searches
• Enabling cached counts
• Optimizing index usage with ANALYZE
• Vacuum
• Optimize
• WAL mode
• Dumping the database to SQL
1.2.1 Running SQL queries
The sqlite-utils query command lets you run queries directly against a SQLite database file. This is the default subcommand, so the following two examples work the same way:


Returning JSON
The default format returned for queries is JSON:

Newline-delimited JSON
Use --nl to get back newline-delimited JSON objects:

JSON arrays


If you want to pretty-print the output further, you can pipe it through python -mjson.tool:

Binary data in JSON
Binary strings are not valid JSON, so BLOB columns containing binary data will be returned as a JSON object containing base64 encoded data, that looks like this:

Nested JSON values
If one of your columns contains JSON, by default it will be returned as an escaped string:

You can use the --json-cols option to automatically detect these JSON columns and output them as nested JSON data:

Returning CSV or TSV

This will default to including the column names as a header row. To exclude the headers, use --no-headers:

Use --tsv instead of --csv to get back tab-separated values:

Table-formatted output
You can use the --table option (or -t shortcut) to output query results as a table:

You can use the --fmt option to specify different table formats, for example rst for reStructuredText:

• asciidoc
• double_grid
• double_outline
• fancy_grid
• fancy_outline
• github
• grid
• heavy_grid
• heavy_outline
• html
• jira
• latex
• latex_booktabs
• latex_longtable
• latex_raw
• mediawiki
• mixed_grid
• mixed_outline
• moinmoin
• orgtbl
• outline
• pipe
• plain
• presto
• pretty
• psql
• rounded_grid
• rounded_outline
• rst
• simple
• simple_grid
• simple_outline
• textile
• tsv
• unsafehtml
• youtrack
This list can also be found by running sqlite-utils query --help.
Returning raw data, such as binary content
If your table contains binary data in a BLOB you can use the --raw option to output specific columns directly to standard out.
For example, to retrieve a binary image from a BLOB column and store it in a file you can use the following: sqlite-utils photos.db "select contents from photos where id=1" --raw > myphoto.jpg
To return the first column of each result as raw data, separated by newlines, use --raw-lines:
sqlite-utils photos.db "select caption from photos" --raw-lines > captions.txt
Using named parameters
You can pass named parameters to the query using -p:

These will be correctly quoted and escaped in the SQL query, providing a safe way to combine other values with SQL.
UPDATE, INSERT and DELETE
If you execute an UPDATE, INSERT or DELETE query the command will return the number of affected rows:

Defining custom SQL functions
You can use the --functions option to pass a block of Python code that defines additional functions which can then be called by your SQL query.
This example defines a function which extracts the domain from a URL:

Every callable object defined in the block will be registered as a SQL function with the same name, with the exception of functions with names that begin with an underscore.
SQLite extensions
You can load SQLite extension modules using the --load-extension option, see Loading SQLite extensions.

Attaching additional databases
SQLite supports cross-database SQL queries, which can join data from tables in more than one database file. You can attach one or more additional databases using the --attach option, providing an alias to use for that database and the path to the SQLite file on disk.
This example attaches the books.db database under the alias books and then runs a query that combines data from that database with the default dogs.db database: sqlite-utils dogs.db --attach books books.db \
'select * from sqlite_master union all select * from books.sqlite_master'

1.2.2 Querying data directly using an in-memory database
The sqlite-utils memory command works similar to sqlite-utils query, but allows you to execute queries against an in-memory database.
You can also pass this command CSV or JSON files which will be loaded into a temporary in-memory table, allowing you to execute SQL against that data without a separate step to first convert it to SQLite.
Without any extra arguments, this command executes SQL against the in-memory database directly:

It takes all of the same output formatting options as sqlite-utils query: --csv and --csv and --table and --nl:

Running queries directly against CSV or JSON
If you have data in CSV or JSON format you can load it into an in-memory SQLite database and run queries against it directly in a single command using sqlite-utils memory like this:

You can pass multiple files to the command if you want to run joins between data from different files:

If your data is JSON it should be the same format supported by the sqlite-utils insert command - so either a single JSON object (treated as a single row) or a list of JSON objects.
CSV data can be comma- or tab- delimited.
The in-memory tables will be named after the files without their extensions. The tool also sets up aliases for those tables (using SQL views) as t1, t2 and so on, or you can use the alias t to refer to the first table:

If two files have the same name they will be assigned a numeric suffix: sqlite-utils memory foo/data.csv bar/data.csv "select * from data_2"
To read from standard input, use either - or stdin as the filename - then use stdin or t or t1 as the table name:

Incoming CSV data will be assumed to use utf-8. If your data uses a different character encoding you can specify that with --encoding: cat example.csv | sqlite-utils memory - "select * from stdin" --encoding=latin-1
If you are joining across multiple CSV files they must all use the same encoding.
Column types will be automatically detected in CSV or TSV data, using the same mechanism as --detect-types described in Inserting CSV or TSV data. You can pass the --no-detect-types option to disable this automatic type detection and treat all CSV and TSV columns as TEXT.
Explicitly specifying the format
By default, sqlite-utils memory will attempt to detect the incoming data format (JSON, TSV or CSV) automatically.
You can instead specify an explicit format by adding a :csv, :tsv, :json or :nl (for newline-delimited JSON) suffix to the filename. For example:

Here the contents of one.dat will be treated as CSV and the contents of two.dat will be treated as newline-delimited JSON.
To explicitly specify the format for data piped into the tool on standard input, use stdin:format - for example:

Joining in-memory data against existing databases using --attach
The attach option can be used to attach database files to the in-memory connection, enabling joins between in-memory data loaded from a file and tables in existing SQLite database files. An example:
echo "id\n1\n3\n5" | sqlite-utils memory - --attach trees trees.db \ "select * from trees.trees where rowid in (select id from stdin)"
Here the --attach trees trees.db option makes the trees.db database available with an alias of trees. select * from trees.trees where ... can then query the trees table in that database.
The CSV data that was piped into the script is available in the stdin table, so ... where rowid in (select id from stdin) can be used to return rows from the trees table that match IDs that were piped in as CSV content.
--schema, --analyze, --dump and --save
To see the in-memory database schema that would be used for a file or for multiple files, use --schema:

You can run the equivalent of the analyze-tables command using --analyze:


You can output SQL that will both create the tables and insert the full data used to populate the in-memory database using --dump:

Passing --save other.db will instead use that SQL to populate a new database file:

These features are mainly intended as debugging tools - for much more finely grained control over how data is inserted into a SQLite database file see Inserting JSON data and Inserting CSV or TSV data.
1.2.3 Returning all rows in a table
You can return every row in a specified table using the rows command:

This command accepts the same output options as query - so you can pass --nl, --csv, --tsv, --no-headers, --table and --fmt.
You can use the -c option to specify a subset of columns to return:

You can filter rows using a where clause with the --where option:

Or pass named parameters using --where in combination with -p:

You can define a sort order using --order column or --order 'column desc'.
Use --limit N to only return the first N rows. Use --offset N to return rows starting from the specified offset.

1.2.4 Listing tables
You can list the names of tables in a database using the tables command:

You can output this list in CSV using the --csv or --tsv options:

If you just want to see the FTS4 tables, you can use --fts4 (or --fts5 for FTS5 tables):

Use --counts to include a count of the number of rows in each table:

sqlite-utils tables dogs.db --counts --columns
[{"table": "Gosh", "count": 0, "columns": ["c1", "c2", "c3"]},
{"table": "Gosh2", "count": 0, "columns": ["c1", "c2", "c3"]},
 {"table": "dogs", "count": 2, "columns": ["id", "age", "name"]}] Use --schema to include the schema of each table:

The --nl, --csv, --tsv, --table and --fmt options are also available.

1.2.5 Listing views
The views command shows any views defined in the database: sqlite-utils views sf-trees.db --table --counts --columns --schema
view	count columns	schema
--------- ------- -------------------- -----------------------------------------------
,→---------------
demo_view	189144 ['qSpecies']	CREATE VIEW demo_view AS select qSpecies from␣
,→Street_Tree_List
hello	1 ['sqlite_version()'] CREATE VIEW hello as select sqlite_version()
It takes the same options as the tables command:
• --columns
• --schema
• --counts
• --nl
• --csv
• --tsv
• --table

1.2.6 Listing indexes
The indexes command lists any indexes configured for the database:
sqlite-utils indexes covid.db --table
table	index_name	␣
,→ seqno	cid name	desc coll	key
-------------------------------- ------------------------------------------------------␣
,→ ------- ----- ----------------- ------ ------ ----johns_hopkins_csse_daily_reports idx_johns_hopkins_csse_daily_reports_combined_key ␣
,→	0	12 combined_key	0 BINARY	1
johns_hopkins_csse_daily_reports idx_johns_hopkins_csse_daily_reports_country_or_region␣
,→	0	1 country_or_region	0 BINARY	1
johns_hopkins_csse_daily_reports idx_johns_hopkins_csse_daily_reports_province_or_state␣
,→	0	2 province_or_state	0 BINARY	1
johns_hopkins_csse_daily_reports idx_johns_hopkins_csse_daily_reports_day	␣
,→	0	0 day	0 BINARY	1
ny_times_us_counties	idx_ny_times_us_counties_date	␣
,→	0	0 date	1 BINARY	1
ny_times_us_counties	idx_ny_times_us_counties_fips	␣
,→	0	3 fips	0 BINARY	1
ny_times_us_counties	idx_ny_times_us_counties_county	␣
,→	0	1 county	0 BINARY	1
ny_times_us_counties	idx_ny_times_us_counties_state	␣
,→	0	2 state	0 BINARY	1
It shows indexes across all tables. To see indexes for specific tables, list those after the database: sqlite-utils indexes covid.db johns_hopkins_csse_daily_reports --table
The command defaults to only showing the columns that are explicitly part of the index. To also include auxiliary columns use the --aux option - these columns will be listed with a key of 0.
The command takes the same format options as the tables and views commands.

1.2.7 Listing triggers
The triggers command shows any triggers configured for the database:

It defaults to showing triggers for all tables. To see triggers for one or more specific tables pass their names as arguments:

The command takes the same format options as the tables and views commands.

1.2.8 Showing the schema
The sqlite-utils schema command shows the full SQL schema for the database:

This will show the schema for every table and index in the database. To view the schema just for a specified subset of tables pass those as additional arguments:


1.2.9 Analyzing tables
When working with a new database it can be useful to get an idea of the shape of the data. The sqlite-utils analyze-tables command inspects specified tables (or all tables) and calculates some useful details about each of the columns in those tables.
To inspect the tags table in the github.db database, run the following:

For each column this tool displays the number of null rows, the number of blank rows (rows that contain an empty string), the number of distinct values and, for columns that are not entirely distinct, the most common and least common values. If you do not specify any tables every table in the database will be analyzed:

If you wish to analyze one or more specific columns, use the -c option:

To show more than 10 common values, use --common-limit 20. To skip the most common or least common value analysis, use --no-most or --no-least:
sqlite-utils analyze-tables github.db tags --common-limit 20 --no-least
Saving the analyzed table details
analyze-tables can take quite a while to run for large database files. You can save the results of the analysis to a database table called _analyze_tables_ using the --save option:

The _analyze_tables_ table has the following schema:

The most_common and least_common columns will contain nested JSON arrays of the most common and least common values that look like this:

1.2.10 Creating an empty database
You can create a new empty database file using the create-database command:

To enable WAL mode on the newly created database add the --enable-wal option:

To enable SpatiaLite metadata on a newly created database, add the --init-spatialite flag:

That will look for SpatiaLite in a set of predictable locations. To load it from somewhere else, use the --load-extension option:

1.2.11 Inserting JSON data
If you have data as JSON, you can use sqlite-utils insert tablename to insert it into a database. The table will be created with the correct (automatically detected) columns if it does not already exist.
You can pass in a single JSON object or a list of JSON objects, either as a filename or piped directly to standard-in (by using - as the filename).
Here's the simplest possible example:
echo '{"name": "Cleo", "age": 4}' | sqlite-utils insert dogs.db dogs -
To specify a column as the primary key, use --pk=column_name.
To create a compound primary key across more than one column, use --pk multiple times.
If you feed it a JSON list it will insert multiple records. For example, if dogs.json looks like this:

You can import all three records into an automatically created dogs table and set the id column as the primary key like so:

Pass --pk multiple times to define a compound primary key.
You can skip inserting any records that have a primary key that already exists using --ignore:

You can delete all the existing rows in the table before inserting the new records using --truncate:

You can add the --analyze option to run ANALYZE against the table after the rows have been inserted.
Inserting binary data
You can insert binary data into a BLOB column by first encoding it using base64 and then structuring it like this:

Inserting newline-delimited JSON
You can also import newline-delimited JSON using the --nl option:
echo '{"id": 1, "name": "Cleo"}
{"id": 2, "name": "Suna"}' | sqlite-utils insert creatures.db creatures - --nl
Newline-delimited JSON consists of full JSON objects separated by newlines.
If you are processing data using jq you can use the jq -c option to output valid newline-delimited JSON.
Since Datasette can export newline-delimited JSON, you can combine the Datasette and sqlite-utils like so:
curl -L "https://latest.datasette.io/fixtures/facetable.json?_shape=array&_nl=on" \ | sqlite-utils insert nl-demo.db facetable - --pk=id --nl
You can also pipe sqlite-utils together to create a new SQLite database file containing the results of a SQL query against another database:


Flattening nested JSON objects
sqlite-utils insert and sqlite-utils memory both expect incoming JSON data to consist of an array of JSON objects, where the top-level keys of each object will become columns in the created database table.
If your data is nested you can use the --flatten option to create columns that are derived from the nested data. Consider this example document, in a file called log.json:

Inserting this into a table using sqlite-utils insert logs.db logs log.json will create a table with the following schema:

With the --flatten option columns will be created using topkey_nextkey column names - so running sqlite-utils insert logs.db logs log.json --flatten will create the following schema instead:

1.2.12 Inserting CSV or TSV data
If your data is in CSV format, you can insert it using the --csv option:

For tab-delimited data, use --tsv:

Data is expected to be encoded as Unicode UTF-8. If your data is an another character encoding you can specify it using the --encoding option:

To stop inserting after a specified number of records - useful for getting a faster preview of a large file - use the --stop-after option:

A progress bar is displayed when inserting data from a file. You can hide the progress bar using the --silent option. By default every column inserted from a CSV or TSV file will be of type TEXT. To automatically detect column types - resulting in a mix of TEXT, INTEGER and FLOAT columns, use the --detect-types option (or its shortcut -d). For example, given a creatures.csv file containing this:

The following command: sqlite-utils insert creatures.db creatures creatures.csv --csv --detect-types Will produce this schema:

You can set the SQLITE_UTILS_DETECT_TYPES environment variable if you want --detect-types to be the default behavior:

If a CSV or TSV file includes empty cells, like this one:

They will be imported into SQLite as empty string values, "".
To import them as NULL values instead, use the --empty-null option:
sqlite-utils insert creatures.db creatures creatures.csv --csv --empty-null
Alternative delimiters and quote characters
If your file uses a delimiter other than , or a quote character other than " you can attempt to detect delimiters or you can specify them explicitly.
The --sniff option can be used to attempt to detect the delimiters:

Alternatively, you can specify them using the --delimiter and --quotechar options. Here's a CSV file that uses ; for delimiters and the | symbol for quote characters:

You can import that using:
sqlite-utils insert dogs.db dogs dogs.csv --delimiter=";" --quotechar="|"
Passing --delimiter, --quotechar or --sniff implies --csv, so you can omit the --csv option.
CSV files without a header row
The first row of any CSV or TSV file is expected to contain the names of the columns in that file.
If your file does not include this row, you can use the --no-headers option to specify that the tool should not use that fist row as headers.
If you do this, the table will be created with column names called untitled_1 and untitled_2 and so on. You can then rename them using the sqlite-utils transform ... --rename command, see Transforming tables.
1.2.13 Inserting unstructured data with --lines and --text
If you have an unstructured file you can insert its contents into a table with a single line column containing each line from the file using --lines. This can be useful if you intend to further analyze those lines using SQL string functions or sqlite-utils convert:

This will produce the following schema:

You can also insert the entire contents of the file into a single column called text using --text:

The schema here will be:

1.2.14 Applying conversions while inserting data
The --convert option can be used to apply a Python conversion function to imported data before it is inserted into the database. It works in a similar way to sqlite-utils convert.
Your Python function will be passed a dictionary called row for each item that is being imported. You can modify that dictionary and return it - or return a fresh dictionary - to change the data that will be inserted.
Given a JSON file called dogs.json containing this:

The following command will insert that data and add an is_good column set to 1 for each dog:
sqlite-utils insert dogs.db dogs dogs.json --convert 'row["is_good"] = 1'
The --convert option also works with the --csv, --tsv and --nl insert options.
As with sqlite-utils convert you can use --import to import additional Python modules, see Importing additional modules for details.
You can also pass code that runs some initialization steps and defines a convert(value) function, see Defining a convert() function.
--convert with --lines
Things work slightly differently when combined with the --lines or --text options.
With --lines, instead of being passed a row dictionary your function will be passed a line string representing each line of the input. Given a file called access.log containing the following:
INFO:	127.0.0.1:60581 - GET / HTTP/1.1 200 OK
INFO:	127.0.0.1:60581 - GET /foo/-/static/app.css?cead5a HTTP/1.1 200 OK
You could convert it into structured data like so:

(continued from previous page)

The resulting table would look like this:
typesourceverbpathstatusINFO:127.0.0.1:60581GET/200INFO:127.0.0.1:60581GET/foo/-/static/app.css?cead5a200--convert with --text
With --text the entire input to the command will be made available to the function as a variable called text.
The function can return a single dictionary which will be inserted as a single row, or it can return a list or iterator of dictionaries, each of which will be inserted.
Here's how to use --convert and --text to insert one record per word in the input:
echo 'A bunch of words' | sqlite-utils insert words.db words - \ --text --convert '({"word": w} for w in text.split())'
The result looks like this:

1.2.15 Insert-replacing data
The --replace option to insert causes any existing records with the same primary key to be replaced entirely by the new records.
To replace a dog with in ID of 2 with a new record, run the following:

1.2.16 Upserting data
Upserting is update-or-insert. If a row exists with the specified primary key the provided columns will be updated. If no row exists that row will be created.
Unlike insert --replace, an upsert will ignore any column values that exist but are not present in the upsert document.
For example:

This will update the dog with an ID of 2 to have an age of 4, creating a new record (with a null name) if one does not exist. If a row DOES exist the name will be left as-is.
The command will fail if you reference columns that do not exist on the table. To automatically create missing columns, use the --alter option.

1.2.17 Executing SQL in bulk
If you have a JSON, newline-delimited JSON, CSV or TSV file you can execute a bulk SQL query using each of the records in that file using the sqlite-utils bulk command.
The command takes the database file, the SQL to be executed and the file containing records to be used when evaluating the SQL query.
The SQL query should include :named parameters that match the keys in the records. For example, given a chickens.csv CSV file containing the following:

You could insert those rows into a pre-created chickens table like so:

This command takes the same options as the sqlite-utils insert command - so it defaults to expecting JSON but can accept other formats using --csv or --tsv or --nl or other options described above.
By default all of the SQL queries will be executed in a single transaction.	To commit every 20 records, use
--batch-size 20.
1.2.18 Inserting data from files
The insert-files command can be used to insert the content of files, along with their metadata, into a SQLite table. Here's an example that inserts all of the GIF files in the current directory into a gifs.db database, placing the file contents in an images table:

You can also pass one or more directories, in which case every file in those directories will be added recursively:

By default this command will create a table with the following schema:

Content will be treated as binary by default and stored in a BLOB column. You can use the --text option to store that content in a TEXT column instead.
You can customize the schema using one or more -c options. For a table schema that includes just the path, MD5 hash and last modification time of the file, you would use this:
sqlite-utils insert-files gifs.db images *.gif -c path -c md5 -c mtime --pk=path
This will result in the following schema:

Note that there's no content column here at all - if you specify custom columns using -c you need to include -c content to create that column.
You can change the name of one of these columns using a -c colname:coldef parameter. To rename the mtime column to last_modified you would use this:

You can pass --replace or --upsert to indicate what should happen if you try to insert a file with an existing primary key. Pass --alter to cause any missing columns to be added to the table. The full list of column definitions you can use is as follows: name
The name of the file, e.g. cleo.jpg
path
The path to the file relative to the root folder, e.g. pictures/cleo.jpg
fullpath
The fully resolved path to the image, e.g. /home/simonw/pictures/cleo.jpg
sha256
The SHA256 hash of the file contents
md5
The MD5 hash of the file contents
mode
The permission bits of the file, as an integer - you may want to convert this to octal
content
The binary file contents, which will be stored as a BLOB
content_text
The text file contents, which will be stored as TEXT
mtime
The modification time of the file, as floating point seconds since the Unix epoch
ctime
The creation time of the file, as floating point seconds since the Unix epoch
mtime_int
The modification time as an integer rather than a float
ctime_int
The creation time as an integer rather than a float
mtime_iso
The modification time as an ISO timestamp, e.g. 2020-07-27T04:24:06.654246
ctime_iso
The creation time is an ISO timestamp
size
The integer size of the file in bytes
stem
The filename without the extension - for file.txt.gz this would be file.txt
suffix
     The file extension - for file.txt.gz this would be .gz You can insert data piped from standard input like this:
cat dog.jpg | sqlite-utils insert-files dogs.db pics - --name=dog.jpg
The - argument indicates data should be read from standard input. The string passed using the --name option will be used for the file name and path values.
When inserting data from standard input only the following column definitions are supported: name, path, content, content_text, sha256, md5 and size.
1.2.19 Converting data in columns
The convert command can be used to transform the data in a specified column - for example to parse a date string into an ISO timestamp, or to split a string of tags into a JSON array.
The command accepts a database, table, one or more columns and a string of Python code to be executed against the values from those columns. The following example would replace the values in the headline column in the articles table with an upper-case version:

The Python code is passed as a string. Within that Python code the value variable will be the value of the current column.
The code you provide will be compiled into a function that takes value as a single argument. If you break your function body into multiple lines the last line should be a return statement:

Your code will be automatically wrapped in a function, but you can also define a function called convert(value) which will be called, if available:

Use a CODE value of - to read from standard input:

Where mycode.py contains a fragment of Python code that looks like this:

The conversion will be applied to every row in the specified table. You can limit that to just rows that match a WHERE clause using --where:

You can include named parameters in your where clause and populate them using one or more --param options:

The --dry-run option will output a preview of the conversion against the first ten rows, without modifying the database.
By default any rows with a falsey value for the column - such as 0 or null - will be skipped. Use the --no-skip-false option to disable this behaviour.
Importing additional modules
You can specify Python modules that should be imported and made available to your code using one or more --import options. This example uses the textwrap module to wrap the content column at 100 characters:

This supports nested imports as well, for example to use ElementTree:

Using the debugger
If an error occurs while running your conversion operation you may see a message like this:

Add the --pdb option to catch the error and open the Python debugger at that point. The conversion operation will exit after you type q in the debugger.
Here's an example debugging session. First, create a articles table with invalid XML in the content column: echo '{"content": "This is not XML"}' | sqlite-utils insert content.db articles Now run the conversion with the --pdb option:


args here shows the arguments to the current function in the stack. The Python pdb documentation has full details on the other available commands.
Defining a convert() function
Instead of providing a single line of code to be executed against each value, you can define a function called convert(value).
This mechanism can be used to execute one-off initialization code that runs once at the start of the conversion run.
The following example adds a new score column, then updates it to list a random number - after first seeding the random number generator to ensure that multiple runs produce the same results:

sqlite-utils convert recipes
Various built-in recipe functions are available for common operations. These are:
r.jsonsplit(value, delimiter=',', type=<class 'str'>)
Convert a string like a,b,c into a JSON array ["a", "b", "c"] The delimiter parameter can be used to specify a different delimiter.
The type parameter can be set to float or int to produce a JSON array of different types, for example if the column's string value was 1.2,3,4.5 the following:

Would produce an array like this: [1.2, 3.0, 4.5]
r.parsedate(value, dayfirst=False, yearfirst=False, errors=None) Parse a date and convert it to ISO date format: yyyy-mm-dd
In the case of dates such as 03/04/05 U.S. MM/DD/YY format is assumed - you can use dayfirst=True or yearfirst=True to change how these ambiguous dates are interpreted.
Use the errors= parameter to specify what should happen if a value cannot be parsed.
By default, if any value cannot be parsed an error will be occurred and all values will be left as they were.
Set errors=r.IGNORE to ignore any values that cannot be parsed, leaving them unchanged. Set errors=r.SET_NULL to set any values that cannot be parsed to null.
r.parsedatetime(value, dayfirst=False, yearfirst=False, errors=None) Parse a datetime and convert it to ISO datetime format: yyyy-mm-ddTHH:MM:SS These recipes can be used in the code passed to sqlite-utils convert like this:

To use any of the documented parameters, do this:

Saving the result to a different column
The --output and --output-type options can be used to save the result of the conversion to a separate column, which will be created if that column does not already exist:

The type of the created column defaults to text, but a different column type can be specified using --output-type. This example will create a new floating point column called id_as_a_float with a copy of each item's ID increased by 0.5:

You can drop the original column at the end of the operation by adding --drop.
Converting a column into multiple columns
Sometimes you may wish to convert a single column into multiple derived columns. For example, you may have a location column containing latitude,longitude values which you wish to split out into separate latitude and longitude columns.
You can achieve this using the --multi option to sqlite-utils convert. This option expects your Python code to return a Python dictionary: new columns well be created and populated for each of the keys in that dictionary.
For the latitude,longitude example you would use the following:

The type of the returned values will be taken into account when creating the new columns. In this example, the resulting database schema will look like this:

The code function can also return None, in which case its output will be ignored. You can drop the original column at the end of the operation by adding --drop.
1.2.20 Creating tables
Most of the time creating tables by inserting example data is the quickest approach. If you need to create an empty table in advance of inserting data you can do so using the create-table command: sqlite-utils create-table mydb.db mytable id integer name text --pk=id
This will create a table called mytable with two columns - an integer id column and a text name column. It will set the id column to be the primary key.
You can pass as many column-name column-type pairs as you like. Valid types are integer, text, float and blob. Pass --pk more than once for a compound primary key that covers multiple columns.
You can specify columns that should be NOT NULL using --not-null colname. You can specify default values for columns using --default colname defaultvalue.

You can specify foreign key relationships between the tables you are creating using --fk colname othertable othercolumn:


You can create a table in SQLite STRICT mode using --strict:

If a table with the same name already exists, you will get an error. You can choose to silently ignore this error with --ignore, or you can replace the existing table with a new, empty table using --replace.
You can also pass --transform to transform the existing table to match the new schema. See Explicitly creating a table in the Python library documentation for details of how this option works.
1.2.21 Renaming a table
Yo ucan rename a table using the rename-table command:

Pass --ignore to ignore any errors caused by the table not existing, or the new name already being in use.
1.2.22 Duplicating tables
The duplicate command duplicates a table - creating a new table with the same schema and a copy of all of the rows:

1.2.23 Dropping tables
You can drop a table using the drop-table command:

Use --ignore to ignore the error if the table does not exist.
1.2.24 Transforming tables
The transform command allows you to apply complex transformations to a table that cannot be implemented using a regular SQLite ALTER TABLE command. See Transforming a table for details of how this works. The transform command preserves a table's STRICT mode.

Every option for this table (with the exception of --pk-none) can be specified multiple times. The options are as follows:
--type column-name new-type
Change the type of the specified column. Valid types are integer, text, float, blob.
--drop column-name Drop the specified column.
--rename column-name new-name Rename this column to a new name.
--column-order column
Use this multiple times to specify a new order for your columns. -o shortcut is also available.
--not-null column-name Set this column as NOT NULL.
--not-null-false column-name
For a column that is currently set as NOT NULL, remove the NOT NULL.
--pk column-name
Change the primary key column for this table. Pass --pk multiple times if you want to create a compound primary key.
--pk-none
Remove the primary key from this table, turning it into a rowid table.
--default column-name value Set the default value of this column.
--default-none column
Remove the default value for this column.
--drop-foreign-key column Drop the specified foreign key.
--add-foreign-key column other_table other_column
Add a foreign key constraint to column pointing to other_table.other_column.
If you want to see the SQL that will be executed to make the change without actually executing it, add the --sql flag. For example:

Adding a primary key to a rowid table
SQLite tables that are created without an explicit primary key are created as rowid tables. They still have a numeric primary key which is available in the rowid column, but that column is not included in the output of select *. Here's an example:

You can use sqlite-utils transform ... --pk id to add a primary key column called id to the table. The primary key will be created as an INTEGER PRIMARY KEY and the existing rowid values will be copied across to it.
It will automatically increment as new rows are added to the table:


1.2.25 Extracting columns into a separate table
The sqlite-utils extract command can be used to extract specified columns into a separate table.
Take a look at the Python API documentation for Extracting columns into a separate table for a detailed description of how this works, including examples of table schemas before and after running an extraction operation.
The command takes a database, table and one or more columns that should be extracted. To extract the species column from the trees table you would run:


--table TEXT
The name of the lookup to extract columns to. This defaults to using the name of the columns that are being extracted.
--fk-column TEXT
The name of the foreign key column to add to the table. Defaults to columnname_id.
--rename <TEXT TEXT>
Use this option to rename the columns created in the new lookup table.
--silent
Don't display the progress bar.
Here's a more complex example that makes use of these options. It converts this CSV file full of global power plants into SQLite, then extracts the country and country_long columns into a separate countries table:

After running the above, the command sqlite-utils schema global.db reveals the following schema:

(continued from previous page)

1.2.26 Creating views

Use --replace to replace an existing view of the same name, and --ignore to do nothing if a view already exists.
1.2.27 Dropping views
You can drop a view using the drop-view command:

Use --ignore to ignore the error if the view does not exist.
1.2.28 Adding columns
You can add a column using the add-column command:

The last argument here is the type of the column to be created. This can be one of:
• text or str
• integer or int
• float
• blob or bytes
This argument is optional and defaults to text.
You can add a column that is a foreign key reference to another table using the --fk option:

This will automatically detect the name of the primary key on the species table and use that (and its type) for the new column.
You can explicitly specify the column you wish to reference using --fk-col: sqlite-utils add-column mydb.db dogs species_id --fk species --fk-col ref
You can set a NOT NULL DEFAULT 'x' constraint on the new column using --not-null-default:
sqlite-utils add-column mydb.db dogs friends_count integer --not-null-default 0
1.2.29 Adding columns automatically on insert/update
You can use the --alter option to automatically add new columns if the data you are inserting or upserting is of a different shape:

1.2.30 Adding foreign key constraints
The add-foreign-key command can be used to add new foreign key references to an existing table - something which SQLite's ALTER TABLE command does not support.
To add a foreign key constraint pointing the books.author_id column to authors.id in another table, do this:

If you omit the other table and other column references sqlite-utils will attempt to guess them - so the above example could instead look like this:

Add --ignore to ignore an existing foreign key (as opposed to returning an error):

See Adding foreign key constraints in the Python API documentation for further details, including how the automatic table guessing mechanism works.
Adding multiple foreign keys at once
Adding a foreign key requires a VACUUM. On large databases this can be an expensive operation, so if you are adding multiple foreign keys you can combine them into one operation (and hence one VACUUM) using add-foreign-keys:

When you are using this command each foreign key needs to be defined in full, as four arguments - the table, column, other table and other column.
Adding indexes for all foreign keys
If you want to ensure that every foreign key column in your database has a corresponding index, you can do so like this:

1.2.31 Setting defaults and not null constraints
You can use the --not-null and --default options (to both insert and upsert) to specify columns that should be NOT NULL or to set database defaults for one or more specific columns:

1.2.32 Creating indexes
You can add an index to an existing table using the create-index command:

This can be used to create indexes against a single column or multiple columns.
The name of the index will be automatically derived from the table and columns. To specify a different name, use
--name=name_of_index.
Use the --unique option to create a unique index.
Use --if-not-exists to avoid attempting to create the index if one with that name already exists.
To add an index on a column in descending order, prefix the column with a hyphen. Since this can be confused for a command-line option you need to construct that like this:

This will create an index on that table on (col1, col2 desc, col3).
If your column names are already prefixed with a hyphen you'll need to manually execute a CREATE INDEX SQL statement to add indexes to them rather than using this tool.
Add the --analyze option to run ANALYZE against the index after it has been created.
1.2.33 Configuring full-text search
You can enable SQLite full-text search on a table and a set of columns like this:

This will use SQLite's FTS5 module by default. Use --fts4 if you want to use FTS4:

The enable-fts command will populate the new index with all existing documents. If you later add more documents you will need to use populate-fts to cause them to be indexed as well:

A better solution here is to use database triggers. You can set up database triggers to automatically update the full-text index using the --create-triggers option when you first run enable-fts:
sqlite-utils enable-fts mydb.db documents title summary --create-triggers To set a custom FTS tokenizer, e.g. to enable Porter stemming, use --tokenize=: sqlite-utils populate-fts mydb.db documents title summary --tokenize=porter To remove the FTS tables and triggers you created, use disable-fts:

To rebuild one or more FTS tables (see Rebuilding a full-text search table), use rebuild-fts:

You can rebuild every FTS table by running rebuild-fts without passing any table names:

1.2.34 Executing searches
Once you have configured full-text search for a table, you can search it using sqlite-utils search:

This command accepts the same output options as sqlite-utils query: --table, --csv, --tsv, --nl etc.
By default it shows the most relevant matches first. You can specify a different sort order using the -o option, which can take a column or a column followed by desc:

SQLite advanced search syntax is enabled by default. To run a search with automatic quoting applied to the terms to avoid them being potentially interpreted as advanced search syntax use the --quote option. You can specify a subset of columns to be returned using the -c option one or more times:

By default all search results will be returned. You can use --limit 20 to return just the first 20 results.
Use the --sql option to output the SQL that would be executed, rather than running the query:


1.2.35 Enabling cached counts
select count(*) queries can take a long time against large tables. sqlite-utils can speed these up by adding triggers to maintain a _counts table, see Cached table counts using triggers for details.
The sqlite-utils enable-counts command can be used to configure these triggers, either for every table in the database or for specific tables.

If the _counts table ever becomes out-of-sync with the actual table counts you can repair it using the reset-counts command:

1.2.36 Optimizing index usage with ANALYZE
The SQLite ANALYZE command builds a table of statistics which the query planner can use to make better decisions about which indexes to use for a given query.
You should run ANALYZE if your database is large and you do not think your indexes are being efficiently used. To run ANALYZE against every index in a database, use this:

You can run it against specific tables, or against specific named indexes, by passing them as optional arguments:

You can also run ANALYZE as part of another command using the --analyze option. This is supported by the create-index, insert and upsert commands.
1.2.37 Vacuum
You can run VACUUM to optimize your database like so:

1.2.38 Optimize
The optimize command can dramatically reduce the size of your database if you are using SQLite full-text search. It runs OPTIMIZE against all of your FTS4 and FTS5 tables, then runs VACUUM.
If you just want to run OPTIMIZE without the VACUUM, use the --no-vacuum flag.

To optimize specific tables rather than every FTS table, pass those tables as extra arguments:

1.2.39 WAL mode
You can enable Write-Ahead Logging for a database file using the enable-wal command:

You can disable WAL mode using disable-wal:

Both of these commands accept one or more database files as arguments.
1.2.40 Dumping the database to SQL
The dump command outputs a SQL dump of the schema and full contents of the specified database file:

1.2.41 Loading SQLite extensions
Many of these commands have the ability to load additional SQLite extensions using the --load-extension=/path/ to/extension option - use --help to check for support, e.g. sqlite-utils rows --help. This option can be applied multiple times to load multiple extensions.
Since SpatiaLite is commonly used with SQLite, the value spatialite is special: it will search for SpatiaLite in the most common installation locations, saving you from needing to remember exactly where that module is located:

1.2.42 SpatiaLite helpers
SpatiaLite adds geographic capability to SQLite (similar to how PostGIS builds on PostgreSQL). The SpatiaLite cookbook is a good resource for learning what's possible with it.
You can convert an existing table to a geographic table by adding a geometry column, use the sqlite-utils add-geometry-column command: sqlite-utils add-geometry-column spatial.db locations geometry --type POLYGON --srid 4326
The table (locations in the example above) must already exist before adding a geometry column. Use sqlite-utils create-table first, then add-geometry-column.
Use the --type option to specify a geometry type. By default, add-geometry-column uses a generic GEOMETRY, which will work with any type, though it may not be supported by some desktop GIS applications. Eight (case-insensitive) types are allowed:
• POINT
• LINESTRING
• POLYGON
• MULTIPOINT
• MULTILINESTRING
• MULTIPOLYGON
• GEOMETRYCOLLECTION
• GEOMETRY
Adding spatial indexes
Once you have a geometry column, you can speed up bounding box queries by adding a spatial index:

See this SpatiaLite Cookbook recipe for examples of how to use a spatial index.
1.2.43 Installing packages
The convert command and the insert -convert and query -functions options can be provided with a Python script that imports additional modules from the sqlite-utils environment.
You can install packages from PyPI directly into the correct environment using sqlite-utils install <package>.
This is a wrapper around pip install.

Use -U to upgrade an existing package.
1.2.44 Uninstalling packages
You can uninstall packages that were installed using sqlite-utils install with sqlite-utils uninstall <package>:

Use -y to skip the request for confirmation.
1.3 sqlite_utils Python library
• Getting started
• Connecting to or creating a database
- Attaching additional databases
- Tracing queries
• Executing queries
- db.query(sql, params)
- db.execute(sql, params)
- Passing parameters
• Accessing tables
• Listing tables
• Listing views
• Listing rows
- Counting rows
• Listing rows with their primary keys
• Retrieving a specific record
• Showing the schema
• Creating tables
- Custom column order and column types

- Explicitly creating a table
- Compound primary keys
- Specifying foreign keys
- Table configuration options
- Setting defaults and not null constraints
• Renaming a table
• Duplicating tables
• Bulk inserts
• Insert-replacing data
• Updating a specific record
• Deleting a specific record
• Deleting multiple records
• Upserting data
• Converting data in columns
• Working with lookup tables
- Creating lookup tables explicitly
- Populating lookup tables automatically during insert/upsert
• Working with many-to-many relationships
- Using m2m and lookup tables together
• Analyzing a column
• Adding columns
• Adding columns automatically on insert/update
• Adding foreign key constraints
- Adding multiple foreign key constraints at once
- Adding indexes for all foreign keys
• Dropping a table or view • Transforming a table
- Altering column types
- Renaming columns
- Dropping columns
- Changing primary keys
- Changing not null status - Altering column defaults
- Changing column order
- Adding foreign key constraints
- Replacing foreign key constraints
- Dropping foreign key constraints
- Custom transformations with .transform_sql()
• Extracting columns into a separate table
• Setting an ID based on the hash of the row contents
• Creating views
• Storing JSON
• Converting column values using SQL functions
• Checking the SQLite version
• Dumping the database to SQL
• Introspecting tables and views
- .exists()
- .count
- .columns
- .columns_dict
- .default_values
- .pks
- .use_rowid
- .foreign_keys
- .schema
- .strict
- .indexes
- .xindexes
- .triggers
- .triggers_dict
- .detect_fts()
- .virtual_table_using
- .has_counts_triggers
- db.supports_strict
• Full-text search
- Enabling full-text search for a table
- Quoting characters for use in search
- Searching with table.search()
- Building SQL queries with table.search_sql()
• Rebuilding a full-text search table
1.3.1 Getting started
Here's how to create a new SQLite database file containing a new chickens table, populated with four records:


Which outputs the following:



1.3.2 Connecting to or creating a database
Database objects are constructed by passing in either a path to a file on disk or an existing SQLite3 database connection:

This will create my_database.db if it does not already exist.
If you want to recreate a database from scratch (first removing the existing file from disk if it already exists) you can use the recreate=True argument:

Instead of a file path you can pass in an existing SQLite connection:

If you want to create an in-memory database, you can do so like this:

You can also create a named in-memory database. Unlike regular memory databases these can be accessed by multiple threads, provided at least one reference to the database still exists. del db will clear the database from memory.

Connections use PRAGMA recursive_triggers=on by default. If you don't want to use recursive triggers you can turn them off using:

By default, any sqlite-utils plugins that implement the prepare_connection(conn) hook will be executed against the connection when you create the Database object. You can opt out of executing plugins using execute_plugins=False like this:

You can pass strict=True to enable SQLite STRICT mode for all tables created using this database object:

Attaching additional databases
SQLite supports cross-database SQL queries, which can join data from tables in more than one database file. You can attach an additional database using the .attach() method, providing an alias to use for that database and the path to the SQLite file on disk.

You can reference tables in the attached database using the alias value you passed to db.attach(alias, filepath) as a prefix, for example the second.table_in_second reference in the SQL query above.
Tracing queries
You can use the tracer mechanism to see SQL queries that are being executed by SQLite. A tracer is a function that you provide which will be called with sql and params arguments every time SQL is executed, for example:

You can pass this function to the Database() constructor like so:

You can also turn on a tracer function temporarily for a block of code using the with db.tracer(...) context manager:

This example will print queries only for the duration of the with block.
1.3.3 Executing queries
The Database class offers several methods for directly executing SQL queries. db.query(sql, params)
The db.query(sql) function executes a SQL query and returns an iterator over Python dictionaries representing the resulting rows:

db.execute(sql, params)
The db.execute() and db.executescript() methods provide wrappers around .execute() and . executescript() on the underlying SQLite connection. These wrappers log to the tracer function if one has been registered. db.execute(sql) returns a sqlite3.Cursor that was used to execute the SQL.

Other cursor methods such as .fetchone() and .fetchall() are also available, see the standard library documentation.
Passing parameters
Both db.query() and db.execute() accept an optional second argument for parameters to be passed to the SQL query.
This can take the form of either a tuple/list or a dictionary, depending on the type of parameters used in the query. Values passed in this way will be correctly quoted and escaped, helping avoid SQL injection vulnerabilities.
? parameters in the SQL query can be filled in using a list:
db.execute("update dogs set name = ?", ["Cleopaws"]) # This will rename ALL dogs to be called "Cleopaws"
Named parameters using :name can be filled using a dictionary:

(continues on next page)
(continued from previous page)

In this example next() is used to retrieve the first result in the iterator returned by the db.query() method.
1.3.4 Accessing tables
Tables are accessed using the indexing operator, like so:

If the table does not yet exist, it will be created the first time you attempt to insert or upsert data into it. You can also access tables using the .table() method like so:

Using this factory function allows you to set Table configuration options.
1.3.5 Listing tables
You can list the names of tables in a database using the .table_names() method:

To see just the FTS4 tables, use .table_names(fts4=True). For FTS5, use .table_names(fts5=True). You can also iterate through the table objects themselves using the .tables property:

1.3.6 Listing views
.view_names() shows you a list of views in the database:

You can iterate through view objects using the .views property:

View objects are similar to Table objects, except that any attempts to insert or update data will throw an error. The full list of methods and properties available on a view object is as follows:
• columns
• columns_dict
• count
• schema
• rows
• rows_where(where, where_args, order_by, select)
• drop()
1.3.7 Listing rows
To iterate through dictionaries for each of the rows in a table, use .rows:

You can filter rows by a WHERE clause using .rows_where(where, where_args):

The first argument is a fragment of SQL. The second, optional argument is values to be passed to that fragment - you can use ? placeholders and pass an array, or you can use :named parameters and pass a dictionary, like this:

To return custom columns (instead of the default that uses select *) pass select="column1, column2":

To specify an order, use the order_by= argument:

You can use order_by="age desc" for descending order.
You can order all records in the table by excluding the where argument:

This method also accepts offset= and limit= arguments, for specifying an OFFSET and a LIMIT for the SQL query:

Counting rows
To count the number of rows that would be returned by a where filter, use .count_where(where, where_args):

1.3.8 Listing rows with their primary keys
Sometimes it can be useful to retrieve the primary key along with each row, in order to pass that key (or primary key tuple) to the .get() or .update() methods.
The .pks_and_rows_where() method takes the same signature as .rows_where() (with the exception of the select= parameter) but returns a generator that yields pairs of (primary key, row dictionary).
The primary key value will usually be a single value but can also be a tuple if the table has a compound primary key.
If the table is a rowid table (with no explicit primary key column) then that ID will be returned.

1.3.9 Retrieving a specific record
You can retrieve a record by its primary key using table.get():

If the table has a compound primary key you can pass in the primary key values as a tuple:

If the record does not exist a NotFoundError will be raised:

1.3.10 Showing the schema
The db.schema property returns the full SQL schema for the database as a string:

1.3.11 Creating tables
The easiest way to create a new table is to insert a record into it:

This will automatically create a new table called "dogs" with the following schema:

You can also specify a primary key by passing the pk= parameter to the .insert() call. This will only be obeyed if the record being inserted causes the table to be created:

After inserting a row like this, the dogs.last_rowid property will return the SQLite rowid assigned to the most recently inserted record.
The dogs.last_pk property will return the last inserted primary key value, if you specified one. This can be very useful when writing code that creates foreign keys or many-to-many relationships.
Custom column order and column types
The order of the columns in the table will be derived from the order of the keys in the dictionary, provided you are using Python 3.6 or later.
If you want to explicitly set the order of the columns you can do so using the column_order= parameter:

You don't need to pass all of the columns to the column_order parameter. If you only pass a subset of the columns the remaining columns will be ordered based on the key order of the dictionary.
Column types are detected based on the example data provided. Sometimes you may find you need to over-ride these detected types - to create an integer column for data that was provided as a string for example, or to ensure that a table where the first example was None is created as an INTEGER rather than a TEXT column. You can do this using the columns= parameter:


Explicitly creating a table
You can directly create a new table without inserting any data into it using the .create() method:

The first argument here is a dictionary specifying the columns you would like to create. Each column is paired with a Python type indicating the type of column. See Adding columns for full details on how these types work.
This	method	takes	optional	arguments pk=, column_order=, foreign_keys=, not_null=set() and defaults=dict() - explained below.
A sqlite_utils.utils.sqlite3.OperationalError will be raised if a table of that name already exists.
You can pass ignore=True to ignore that error. You can also use if_not_exists=True to use the SQL CREATE TABLE IF NOT EXISTS pattern to achieve the same effect:

To drop and replace any existing table of that name, pass replace=True. This is a dangerous operation that will result in loss of existing data in the table.
You can also pass transform=True to have any existing tables transformed to match your new table specification. This is a dangerous operation as it will drop columns that are no longer listed in your call to .create(), so be careful when running this.

The transform=True option will update the table schema if any of the following have changed:
• The specified columns or their types
• The specified primary key
• The order of the columns, defined using column_order=
• The not_null= or defaults= arguments
Changes to foreign_keys= are not currently detected and applied by transform=True. You can pass strict=True to create a table in STRICT mode:

Compound primary keys
If you want to create a table with a compound primary key that spans multiple columns, you can do so by passing a tuple of column names to any of the methods that accept a pk= parameter. For example:

This also works for the .insert(), .insert_all(), .upsert() and .upsert_all() methods.
Specifying foreign keys
Any operation that can create a table (.create(), .insert(), .insert_all(), .upsert() and .upsert_all()) accepts an optional foreign_keys= argument which can be used to set up foreign key constraints for the table that is being created.
If you are using your database with Datasette, Datasette will detect these constraints and use them to generate hyperlinks to associated records.
The foreign_keys argument takes a list that indicates which foreign keys should be created. The list can take several forms. The simplest is a list of columns:

The library will guess which tables you wish to reference based on the column names using the rules described in Adding foreign key constraints.
You can also be more explicit, by passing in a list of tuples:

This means that the author_id column should be a foreign key that references the id column in the authors table. You can leave off the third item in the tuple to have the referenced column automatically set to the primary key of that table. A full example:

(continues on next page)

Table configuration options
The .insert(), .upsert(), .insert_all() and .upsert_all() methods each take a number of keyword arguments, some of which influence what happens should they cause a table to be created and some of which affect the behavior of those methods.
You can set default values for these methods by accessing the table through the db.table(...) method (instead of using db["table_name"]), like so:

The configuration options that can be specified in this way are pk, foreign_keys, column_order, not_null, defaults, batch_size, hash_id, hash_id_columns, alter, ignore, replace, extracts, conversions, columns, strict. These are all documented below.
Setting defaults and not null constraints
Each of the methods that can cause a table to be created take optional arguments not_null=set() and defaults=dict(). The methods that take these optional arguments are:
• db.create_table(...)
• table.create(...)
• table.insert(...)
• table.insert_all(...) • table.upsert(...)
• table.upsert_all(...)
You can use not_null= to pass a set of column names that should have a NOT NULL constraint set on them when they are created.
You can use defaults= to pass a dictionary mapping columns to the default value that should be specified in the CREATE TABLE statement.
Here's an example that uses these features:

1.3.12 Renaming a table
The db.rename_table(old_name, new_name) method can be used to rename a table:

This executes the following SQL:

1.3.13 Duplicating tables
The table.duplicate() method creates a copy of the table, copying both the table schema and all of the rows in that table:

The new authors_copy table will now contain a duplicate copy of the data from authors. This method raises sqlite_utils.db.NoTable if the table does not exist.
1.3.14 Bulk inserts
If you have more than one record to insert, the insert_all() method is a much more efficient way of inserting them. Just like insert() it will automatically detect the columns that should be created, but it will inspect the first batch of 100 items to help decide what those column types should be.
Use it like this:

The column types used in the CREATE TABLE statement are automatically derived from the types of data in that first batch of rows. Any additional columns in subsequent batches will cause a sqlite3.OperationalError exception to be raised unless the alter=True argument is supplied, in which case the new columns will be created.
The function can accept an iterator or generator of rows and will commit them according to the batch size. The default batch size is 100, but you can specify a different size using the batch_size parameter:

You can skip inserting any records that have a primary key that already exists using ignore=True. This works with both .insert({...}, ignore=True) and .insert_all([...], ignore=True).
You can delete all the existing rows in the table before inserting the new records using truncate=True. This is useful if you want to replace the data in the table.
Pass analyze=True to run ANALYZE against the table after inserting the new records.
1.3.15 Insert-replacing data
If you try to insert data using a primary key that already exists, the .insert() or .insert_all() method will raise a sqlite3.IntegrityError exception.

Importing from sqlite_utils.utils.sqlite3 ensures your code continues to work even if you are using the pysqlite3 library instead of the Python standard library sqlite3 module. Use the ignore=True parameter to ignore this error:
# This fails silently if a record with id=1 already exists db["dogs"].insert({"id": 1, "name": "Cleo"}, pk="id", ignore=True) To replace any existing records that have a matching primary key, use the replace=True parameter to .insert() or .insert_all():

ò Note
Prior to sqlite-utils 2.0 the .upsert() and .upsert_all() methods worked the same way as . insert(replace=True) does today. See Upserting data for the new behaviour of those methods introduced in 2.0.
1.3.16 Updating a specific record
You can update a record by its primary key using table.update():

The first argument to update() is the primary key. This can be a single value, or a tuple if that table has a compound primary key:

The second argument is a dictionary of columns that should be updated, along with their new values.
You can cause any missing columns to be added automatically using alter=True:

1.3.17 Deleting a specific record
You can delete a record using table.delete():

The delete() method takes the primary key of the record. This can be a tuple of values if the row has a compound primary key:

1.3.18 Deleting multiple records
You can delete all records in a table that match a specific WHERE statement using table.delete_where():

Calling table.delete_where() with no other arguments will delete every row in the table. Pass analyze=True to run ANALYZE against the table after deleting the rows.
1.3.19 Upserting data
Upserting allows you to insert records if they do not exist and update them if they DO exist, based on matching against their primary key.
For example, given the dogs database you could upsert the record for Cleo like so:

If a record exists with id=1, it will be updated to match those fields. If it does not exist it will be created.
Any existing columns that are not referenced in the dictionary passed to .upsert() will be unchanged. If you want to replace a record entirely, use .insert(doc, replace=True) instead.
Note that the pk and column_order parameters here are optional if you are certain that the table has already been created. You should pass them if the table may not exist at the time the first upsert is performed.
An upsert_all() method is also available, which behaves like insert_all() but performs upserts instead.
ò Note
.upsert() and .upsert_all() in sqlite-utils 1.x worked like .insert(..., replace=True) and . insert_all(..., replace=True) do in 2.x. See issue #66 for details of this change.
1.3.20 Converting data in columns
The table.convert(...) method can be used to apply a conversion function to the values in a column, either to update that column or to populate new columns. It is the Python library equivalent of the sqlite-utils convert command. This feature works by registering a custom SQLite function that applies a Python transformation, then running a SQL
query equivalent to UPDATE table SET column = convert_value(column); To transform a specific column to uppercase, you would use the following:

You can pass a list of columns, in which case the transformation will be applied to each one: db["dogs"].convert(["name", "twitter"], lambda value: value.upper())
To save the output to of the transformation to a different column, use the output= parameter: db["dogs"].convert("name", lambda value: value.upper(), output="name_upper")
This will add the new column, if it does not already exist. You can pass output_type=int or some other type to control the type of the new column - otherwise it will default to text.
If you want to drop the original column after saving the results in a separate output column, pass drop=True.
By default any rows with a falsey value for the column - such as 0 or None - will be skipped. Pass skip_false=False to disable this behaviour.
You can create multiple new columns from a single input column by passing multi=True and a conversion function that returns a Python dictionary. This example creates new upper and lower columns populated from the single title column:

The .convert() method accepts optional where= and where_args= parameters which can be used to apply the conversion to a subset of rows specified by a where clause. Here's how to apply the conversion only to rows with an id that is higher than 20: table.convert("title", lambda v: v.upper(), where="id > :id", where_args={"id": 20})
These behave the same as the corresponding parameters to the .rows_where() method, so you can use ? placeholders and a list of values instead of :named placeholders with a dictionary.
1.3.21 Working with lookup tables
A useful pattern when populating large tables in to break common values out into lookup tables. Consider a table of Trees, where each tree has a species. Ideally these species would be split out into a separate Species table, with each one assigned an integer primary key that can be referenced from the Trees table species_id column.
Creating lookup tables explicitly
Calling db["Species"].lookup({"name": "Palm"}) creates a table called Species (if one does not already exist) with two columns: id and name. It sets up a unique constraint on the name column to guarantee it will not contain duplicate rows. It then inserts a new row with the name set to Palm and returns the new integer primary key value.
If the Species table already exists, it will insert the new row and return the primary key. If a row with that name already exists, it will return the corresponding primary key value directly.
If you call .lookup() against an existing table without the unique constraint it will attempt to add the constraint, raising an IntegrityError if the constraint cannot be created.
If you pass in a dictionary with multiple values, both values will be used to insert or retrieve the corresponding ID and any unique constraint that is created will cover all of those columns, for example:

The .lookup() method has an optional second argument which can be used to populate other columns in the table but only if the row does not exist yet. These columns will not be included in the unique index. To create a species record with a note on when it was first seen, you can use this: db["Species"].lookup({"name": "Palm"}, {"first_seen": "2021-03-04"})
The first time this is called the record will be created for name="Palm". Any subsequent calls with that name will ignore the second argument, even if it includes different values.
.lookup() also accepts keyword arguments, which are passed through to the insert() method and can be used to influence the shape of the created table. Supported parameters are:
• pk - which defaults to id
• foreign_keys
• column_order
• not_null • defaults
• extracts
• conversions
• columns
• strict
Populating lookup tables automatically during insert/upsert
A more efficient way to work with lookup tables is to define them using the extracts= parameter, which is accepted by .insert(), .upsert(), .insert_all(), .upsert_all() and by the .table(...) factory function.
extracts= specifies columns which should be "extracted" out into a separate lookup table during the data insertion.
It can be either a list of column names, in which case the extracted table names will match the column names exactly, or it can be a dictionary mapping column names to the desired name of the extracted table.
To extract the species column out to a separate Species table, you can do this:

1.3.22 Working with many-to-many relationships
sqlite-utils includes a shortcut for creating records using many-to-many relationships in the form of the table. m2m(...) method.
Here's how to create two new records and connect them via a many-to-many table in a single line of code:

Running this example actually creates three tables: dogs, humans and a many-to-many dogs_humans table. It will insert a record into each of those tables.
The .m2m() method executes against the last record that was affected by .insert() or .update() - the record identified by the table.last_pk property. To execute .m2m() against a specific record you can first select it by passing its primary key to .update():

The first argument to .m2m() can be either the name of a table as a string or it can be the table object itself. The second argument can be a single dictionary record or a list of dictionaries. These dictionaries will be passed to .upsert() against the specified table.
Here's alternative code that creates the dog record and adds two people to it:

The method will attempt to find an existing many-to-many table by looking for a table that has foreign key relationships against both of the tables in the relationship.
If it cannot find such a table, it will create a new one using the names of the two tables - dogs_humans in this example. You can customize the name of this table using the m2m_table= argument to .m2m().
It it finds multiple candidate tables with foreign keys to both of the specified tables it will raise a sqlite_utils.db. NoObviousTable exception. You can avoid this error by specifying the correct table using m2m_table=.
The .m2m() method also takes an optional pk= argument to specify the primary key that should be used if the table is created, and an optional alter=True argument to specify that any missing columns of an existing table should be added if they are needed.
Using m2m and lookup tables together
You can work with (or create) lookup tables as part of a call to .m2m() using the lookup= parameter. This accepts the same argument as table.lookup() does - a dictionary of values that should be used to lookup or create a row in the lookup table.
This example creates a dogs table, populates it, creates a characteristics table, populates that and sets up a many-to-many relationship between the two. It chains .m2m() twice to create two associated characteristics:


(continued from previous page)
[{'characteristics_id': 1, 'dogs_id': 1}, {'characteristics_id': 2, 'dogs_id': 1}]
>>> print(db["characteristics_dogs"].schema) CREATE TABLE [characteristics_dogs] (
[characteristics_id] INTEGER REFERENCES [characteristics]([id]),
[dogs_id] INTEGER REFERENCES [dogs]([id]),
PRIMARY KEY ([characteristics_id], [dogs_id])
)
1.3.23 Analyzing a column
The table.analyze_column(column) method is used by the analyze-tables CLI command. It takes the following arguments and options: column - required
The name of the column to analyze
common_limit
The number of most common values to return. Defaults to 10.
value_truncate
If set to an integer, values longer than this will be truncated to this length. Defaults to None.
most_common
If set to False, the most_common field of the returned ColumnDetails will be set to None. Defaults to True.
least_common
     If set to False, the least_common field of the returned ColumnDetails will be set to None. Defaults to True. And returns a ColumnDetails named tuple with the following fields: table
The name of the table
column
The name of the column
total_rows
The total number of rows in the table
num_null
The number of rows for which this column is null
num_blank
The number of rows for which this column is blank (the empty string)
num_distinct
The number of distinct values in this column
most_common
The N most common values as a list of (value, count) tuples`, or None if the table consists entirely of distinct values
least_common
The N least common values as a list of (value, count) tuples`, or None if the table is entirely distinct or if the number of distinct values is less than N (since they will already have been returned in most_common)
1.3.24 Adding columns
You can add a new column to a table using the .add_column(col_name, col_type) method:

You can specify the col_type argument either using a SQLite type as a string, or by directly passing a Python type e.g. str or float.
The col_type is optional - if you omit it the type of TEXT will be used.
SQLite types you can specify are "TEXT", "INTEGER", "FLOAT" or "BLOB". If you pass a Python type, it will be mapped to SQLite types as shown here:

ò Note
In sqlite-utils 3.x FLOAT is used for floating point columns when the correct column type is actually REAL. If you specify strict=True tables created in strict mode will use the correct column type of REAL instead. We plan to change this behavior in sqlite-utils 4.x to always use REAL, but this will represent a minor breaking change and so is being held for the next major release, see issue #645.
You can also add a column that is a foreign key reference to another table using the fk parameter:

This will automatically detect the name of the primary key on the species table and use that (and its type) for the new column.
You can explicitly specify the column you wish to reference using fk_col: db["dogs"].add_column("species_id", fk="species", fk_col="ref")
You can set a NOT NULL DEFAULT 'x' constraint on the new column using not_null_default:
db["dogs"].add_column("friends_count", int, not_null_default=0)
1.3.25 Adding columns automatically on insert/update
You can insert or update data that includes new columns and have the table automatically altered to fit the new schema using the alter=True argument. This can be passed to all four of .insert(), .upsert(), .insert_all() and
.upsert_all(), or it can be passed to db.table(table_name, alter=True) to enable it by default for all method calls against that table instance.

1.3.26 Adding foreign key constraints
The SQLite ALTER TABLE statement doesn't have the ability to add foreign key references to an existing column.
The add_foreign_key() method here is a convenient wrapper around table.transform().
It's also possible to add foreign keys by directly updating the sqlite_master table. The sqlite-utils-fast-fks plugin implements this pattern, using code that was included with sqlite-utils prior to version 3.35. Here's an example of this mechanism in action:

The table.add_foreign_key(column, other_table, other_column) method takes the name of the column, the table that is being referenced and the key column within that other table. If you omit the other_column argument the primary key from that table will be used automatically. If you omit the other_table argument the table will be guessed based on some simple rules:
• If the column is of format author_id, look for tables called author or authors
• If the column does not end in _id, try looking for a table with the exact name of the column or that name with an added s
This method first checks that the specified foreign key references tables and columns that exist and does not clash with an existing foreign key. It will raise a sqlite_utils.db.AlterError exception if these checks fail. To ignore the case where the key already exists, use ignore=True:
db["books"].add_foreign_key("author_id", "authors", "id", ignore=True)
Adding multiple foreign key constraints at once
You can use db.add_foreign_keys(...) to add multiple foreign keys in one go. This method takes a list of fourtuples, each one specifying a table, column, other_table and other_column. Here's an example adding two foreign keys at once:

This method runs the same checks as .add_foreign_keys() and will raise sqlite_utils.db.AlterError if those checks fail.
Adding indexes for all foreign keys
If you want to ensure that every foreign key column in your database has a corresponding index, you can do so like this:

1.3.27 Dropping a table or view
You can drop a table or view using the .drop() method:

Pass ignore=True if you want to ignore the error caused by the table or view not existing.

1.3.28 Transforming a table
The SQLite ALTER TABLE statement is limited. It can add and drop columns and rename tables, but it cannot change column types, change NOT NULL status or change the primary key for a table.
The table.transform() method can do all of these things, by implementing a multi-step pattern described in the SQLite documentation:
1. Start a transaction
2. CREATE TABLE tablename_new_x123 with the required changes
3. Copy the old data into the new table using INSERT INTO tablename_new_x123 SELECT * FROM tablename;
4. DROP TABLE tablename;
5. ALTER TABLE tablename_new_x123 RENAME TO tablename;
6. Commit the transaction
The .transform() method takes a number of parameters, all of which are optional.
As a bonus, calling .transform() will reformat the schema for the table that is stored in SQLite to make it more readable. This works even if you call it without any arguments.
To keep the original table around instead of dropping it, pass the keep_table= option and specify the name of the table you would like it to be renamed to: table.transform(types={"age": int}, keep_table="original_table")
This method raises a sqlite_utils.db.TransformError exception if the table cannot be transformed, usually because there are existing constraints or indexes that are incompatible with modifications to the columns.
Altering column types
To alter the type of a column, use the types= argument:
# Convert the 'age' column to an integer, and 'weight' to a float table.transform(types={"age": int, "weight": float}) See Adding columns for a list of available types.
Renaming columns
The rename= parameter can rename columns:

Dropping columns
To drop columns, pass them in the drop= set:

Changing primary keys
To change the primary key for a table, use pk=. This can be passed a single column for a regular primary key, or a tuple of columns to create a compound primary key. Passing pk=None will remove the primary key and convert the table into a rowid table.

Changing not null status
You can change the NOT NULL status of columns by using not_null=. You can pass this a set of columns to make those columns NOT NULL:

If you want to take existing NOT NULL columns and change them to allow null values, you can do so by passing a dictionary of true/false values instead:

Altering column defaults
The defaults= parameter can be used to set or change the defaults for different columns:

Changing column order
The column_order= parameter can be used to change the order of the columns. If you pass the names of a subset of the columns those will go first and columns you omitted will appear in their existing order after them.

Adding foreign key constraints
You can add one or more foreign key constraints to a table using the add_foreign_keys= parameter:

This accepts the same arguments described in specifying foreign keys - so you can specify them as a full tuple of
(column, other_table, other_column), or you can take a shortcut and pass just the name of the column, provided the table can be automatically derived from the column name:

Replacing foreign key constraints
The foreign_keys= parameter is similar to to add_foreign_keys= but can be be used to replace all foreign key constraints on a table, dropping any that are not explicitly mentioned:

Dropping foreign key constraints
You can use .transform() to remove foreign key constraints from a table.
This example drops two foreign keys - the one from places.country to country.id and the one from places. continent to continent.id:

Custom transformations with .transform_sql()
The .transform() method can handle most cases, but it does not automatically upgrade indexes, views or triggers associated with the table that is being transformed.
If you want to do something more advanced, you can call the table.transform_sql(...) method with the same arguments that you would have passed to table.transform(...).
This method will return a list of SQL statements that should be executed to implement the change. You can then make modifications to that SQL - or add additional SQL statements - before executing it yourself.
1.3.29 Extracting columns into a separate table
The table.extract() method can be used to extract specified columns into a separate table. Imagine a Trees table that looks like this:
idTreeAddressSpecies152 Vine StPalm212 Draft StOak351 Dark AvePalm41252 Left StPalmThe Species column contains duplicate values. This database could be improved by extracting that column out into a separate Species table and pointing to it using a foreign key column. The schema of the above table is:

Here's how to extract the Species column using .extract():

After running this code the table schema now looks like this:

A new Species table will have been created with the following schema:

The .extract() method defaults to creating a table with the same name as the column that was extracted, and adding a foreign key column called tablename_id.
You can specify a custom table name using table=, and a custom foreign key name using fk_column=. This example creates a table called tree_species and a foreign key column called tree_species_id: db["Trees"].extract("Species", table="tree_species", fk_column="tree_species_id") The resulting schema looks like this:

You can also extract multiple columns into the same external table. Say for example you have a table like this:
idTreeAddressCommonNameLatinName152 Vine StPalmArecaceae212 Draft StOakQuercus351 Dark AvePalmArecaceae41252 Left StPalmArecaceaeYou can pass ["CommonName", "LatinName"] to .extract() to extract both of those columns:

This produces the following schema:

The table name CommonName_LatinName is derived from the extract columns. You can use table= and fk_column= to specify custom names like this: db["Trees"].extract(["CommonName", "LatinName"], table="Species", fk_column="species_id") This produces the following schema:

(continued from previous page)

You can use the rename= argument to rename columns in the lookup table. To create a Species table with columns called name and latin you can do this:


1.3.30 Setting an ID based on the hash of the row contents
Sometimes you will find yourself working with a dataset that includes rows that do not have a provided obvious ID, but where you would like to assign one so that you can later upsert into that table without creating duplicate records. In these cases, a useful technique is to create an ID that is derived from the sha1 hash of the row contents. sqlite-utils can do this for you using the hash_id= option. For example:

Outputs:

If you are going to use that ID straight away, you can access it using last_pk:


The hash_id= parameter is optional if you specify hash_id_columns= - it will default to putting the hash in a column called id.
You can manually calculate these hashes using the hash_record(record, keys=...) utility function.
1.3.31 Creating views
The .create_view() method on the database class can be used to create a view:

This will raise a sqlite_utils.utils.OperationalError if a view with that name already exists.
You can pass ignore=True to silently ignore an existing view and do nothing, or replace=True to replace an existing view with a new definition if your select statement differs from the current view:

1.3.32 Storing JSON
SQLite has excellent JSON support, and sqlite-utils can help you take advantage of this: if you attempt to insert a value that can be represented as a JSON list or dictionary, sqlite-utils will create TEXT column and store your data as serialized JSON. This means you can quickly store even complex data structures in SQLite and query them using JSON features.


1.3.33 Converting column values using SQL functions
Sometimes it can be useful to run values through a SQL function prior to inserting them. A simple example might be converting a value to upper case while it is being inserted.
The conversions={...} parameter can be used to specify custom SQL to be used as part of a INSERT or UPDATE SQL statement.
You can specify an upper case conversion for a specific column like so:

The dictionary key is the column name to be converted. The value is the SQL fragment to use, with a ? placeholder for the original value.
A more useful example: if you are working with SpatiaLite you may find yourself wanting to create geometry values from a WKT value. Code to do that could look like this:


This example uses gographical data from Who's On First and depends on the Shapely and HTTPX Python libraries.
1.3.34 Checking the SQLite version
The db.sqlite_version property returns a tuple of integers representing the version of SQLite used for that database object:

1.3.35 Dumping the database to SQL
The db.iterdump() method returns a sequence of SQL strings representing a complete dump of the database. Use it like this:

This uses the sqlite3.Connection.iterdump() method.
If you are using pysqlite3 or sqlean.py the underlying method may be missing. If you install the sqlite-dump package then the db.iterdump() method will use that implementation instead:

1.3.36 Introspecting tables and views
If you have loaded an existing table or view, you can use introspection to find out more about it:

.exists()
The .exists() method can be used to find out if a table exists or not:

.count
The .count property shows the current number of rows (select count(*) from table):

This property will take advantage of Cached table counts using triggers if the use_counts_table property is set on the database. You can avoid that optimization entirely by calling table.count_where() instead of accessing the property.
.columns
The .columns property shows the columns in the table or view. It returns a list of Column(cid, name, type, notnull, default_value, is_pk) named tuples.
>>> db["PlantType"].columns
[Column(cid=0, name='id', type='INTEGER', notnull=0, default_value=None, is_pk=1),
Column(cid=1, name='value', type='TEXT', notnull=0, default_value=None, is_pk=0)]
.columns_dict
The .columns_dict property returns a dictionary version of the columns with just the names and Python types:

.default_values
The .default_values property returns a dictionary of default values for each column that has a default:

.pks
The .pks property returns a list of strings naming the primary key columns for the table:

If a table has no primary keys but is a rowid table, this property will return ['rowid'].
.use_rowid
Almost all SQLite tables have a rowid column, but a table with no explicitly defined primary keys must use that rowid as the primary key for identifying individual rows. The .use_rowid property checks to see if a table needs to use the rowid in this way - it returns True if the table has no explicitly defined primary keys and False otherwise.

.foreign_keys
The .foreign_keys property returns any foreign key relationships for the table, as a list of ForeignKey(table, column, other_table, other_column) named tuples. It is not available on views.
>>> db["Street_Tree_List"].foreign_keys
[ForeignKey(table='Street_Tree_List', column='qLegalStatus', other_table='qLegalStatus',␣
,→other_column='id'),
ForeignKey(table='Street_Tree_List', column='qCareAssistant', other_table=
,→'qCareAssistant', other_column='id'),
ForeignKey(table='Street_Tree_List', column='qSiteInfo', other_table='qSiteInfo', other_
,→column='id'),
ForeignKey(table='Street_Tree_List', column='qSpecies', other_table='qSpecies', other_
,→column='id'),
ForeignKey(table='Street_Tree_List', column='qCaretaker', other_table='qCaretaker',␣
,→other_column='id'),
ForeignKey(table='Street_Tree_List', column='PlantType', other_table='PlantType', other_
,→column='id')]
.schema
The .schema property outputs the table's schema as a SQL string:

(continued from previous page)
"Location" TEXT
,
FOREIGN KEY ("PlantType") REFERENCES [PlantType](id), FOREIGN KEY ("qCaretaker") REFERENCES [qCaretaker](id),
FOREIGN KEY ("qSpecies") REFERENCES [qSpecies](id),
FOREIGN KEY ("qSiteInfo") REFERENCES [qSiteInfo](id),
FOREIGN KEY ("qCareAssistant") REFERENCES [qCareAssistant](id),
FOREIGN KEY ("qLegalStatus") REFERENCES [qLegalStatus](id))
.strict
The .strict property identifies if the table is a SQLite STRICT table.

.indexes
The .indexes property returns all indexes created for a table, as a list of Index(seq, name, unique, origin, partial, columns) named tuples. It is not available on views.
>>> db["Street_Tree_List"].indexes
[Index(seq=0, name='"Street_Tree_List_qLegalStatus"', unique=0, origin='c', partial=0,␣
,→columns=['qLegalStatus']),
Index(seq=1, name='"Street_Tree_List_qCareAssistant"', unique=0, origin='c', partial=0,␣
,→columns=['qCareAssistant']),
Index(seq=2, name='"Street_Tree_List_qSiteInfo"', unique=0, origin='c', partial=0,␣
,→columns=['qSiteInfo']),
Index(seq=3, name='"Street_Tree_List_qSpecies"', unique=0, origin='c', partial=0,␣
,→columns=['qSpecies']),
Index(seq=4, name='"Street_Tree_List_qCaretaker"', unique=0, origin='c', partial=0,␣
,→columns=['qCaretaker']),
Index(seq=5, name='"Street_Tree_List_PlantType"', unique=0, origin='c', partial=0,␣
,→columns=['PlantType'])]
.xindexes
The .xindexes property returns more detailed information about the indexes on the table, using the SQLite PRAGMA index_xinfo() mechanism. It returns a list of XIndex(name, columns) named tuples, where columns is a list of XIndexColumn(seqno, cid, name, desc, coll, key) named tuples.


.triggers
The .triggers property lists database triggers. It can be used on both database and table objects. It returns a list of Trigger(name, table, sql) named tuples.
>>> db["authors"].triggers
[Trigger(name='authors_ai', table='authors', sql='CREATE TRIGGER [authors_ai] AFTER␣
,→INSERT...'),
Trigger(name='authors_ad', table='authors', sql="CREATE TRIGGER [authors_ad] AFTER␣
,→DELETE..."),
Trigger(name='authors_au', table='authors', sql="CREATE TRIGGER [authors_au] AFTER␣
,→UPDATE")]
>>> db.triggers
... similar output to db["authors"].triggers
.triggers_dict
The .triggers_dict property returns the triggers for that table as a dictionary mapping their names to their SQL definitions.
>>> db["authors"].triggers_dict
{'authors_ai': 'CREATE TRIGGER [authors_ai] AFTER INSERT...',
'authors_ad': 'CREATE TRIGGER [authors_ad] AFTER DELETE...',
'authors_au': 'CREATE TRIGGER [authors_au] AFTER UPDATE'}
The same property exists on the database, and will return all triggers across all tables:
>>> db.triggers_dict
{'authors_ai': 'CREATE TRIGGER [authors_ai] AFTER INSERT...',
'authors_ad': 'CREATE TRIGGER [authors_ad] AFTER DELETE...',
'authors_au': 'CREATE TRIGGER [authors_au] AFTER UPDATE'}
.detect_fts()
The detect_fts() method returns the associated SQLite FTS table name, if one exists for this table. If the table has not been configured for full-text search it returns None.

.virtual_table_using
The .virtual_table_using property reveals if a table is a virtual table. It returns None for regular tables and the upper case version of the type of virtual table otherwise. For example:

.has_counts_triggers
The .has_counts_triggers property shows if a table has been configured with triggers for updating a _counts table, as described in Cached table counts using triggers.

db.supports_strict
This property on the database object returns True if the available SQLite version supports STRICT mode, which was added in SQLite 3.37.0 (on 2021-11-27).

1.3.37 Full-text search
SQLite includes bundled extensions that implement powerful full-text search.
Enabling full-text search for a table
You can enable full-text search on a table using .enable_fts(columns):

You can then run searches using the .search() method:

This method returns a generator that can be looped over to get dictionaries for each row, similar to Listing rows. If you insert additional records into the table you will need to refresh the search index using populate_fts():

A better solution is to use database triggers. You can set up database triggers to automatically update the full-text index using create_triggers=True: db["dogs"].enable_fts(["name", "twitter"], create_triggers=True) .enable_fts() defaults to using FTS5. If you wish to use FTS4 instead, use the following: db["dogs"].enable_fts(["name", "twitter"], fts_version="FTS4")
You can customize the tokenizer configured for the table using the tokenize= parameter. For example, to enable Porter stemming, where English words like "running" will match stemmed alternatives such as "run", use tokenize="porter": db["articles"].enable_fts(["headline", "body"], tokenize="porter")
The SQLite documentation has more on FTS5 tokenizers and FTS4 tokenizers. porter is a valid option for both.
If you attempt to configure a FTS table where one already exists, a sqlite3.OperationalError exception will be raised.
You can replace the existing table with a new configuration using replace=True: db["articles"].enable_fts(["headline"], tokenize="porter", replace=True)
This will have no effect if the FTS table already exists, otherwise it will drop and recreate the table with the new settings.
This takes into consideration the columns, the tokenizer, the FTS version used and whether or not the table has triggers.
To remove the FTS tables and triggers you created, use the disable_fts() table method:

Quoting characters for use in search
SQLite supports advanced search query syntax. In some situations you may wish to disable this, since characters such as . may have special meaning that causes errors when searching for strings provided by your users.
The db.quote_fts(query) method returns the query with SQLite full-text search quoting applied such that the query should be safe to use in a search:

Searching with table.search()
The table.search(q) method returns a generator over Python dictionaries representing rows that match the search phrase q, ordered by relevance with the most relevant results first.

The .search() method also accepts the following optional parameters: order_by string
The column to sort by. Defaults to relevance score. Can optionally include a desc, e.g. rowid desc.
columns array of strings
Columns to return. Defaults to all columns.
limit integer
Number of results to return. Defaults to all results.
offset integer
Offset to use along side the limit parameter.
where string
Extra SQL fragment for the WHERE clause
where_args dictionary
Arguments to use for :param placeholders in the extra WHERE clause
include_rank bool
If set a rank column will be included with the BM25 ranking score - for FTS5 tables only.
quote bool
Apply FTS quoting rules to the search query, disabling advanced query syntax in a way that avoids surprising errors.
To return just the title and published columns for three matches for "dog" where the id is greater than 10 ordered by published with the most recent first, use the following:

Building SQL queries with table.search_sql()
You can generate the SQL query that would be used for a search using the table.search_sql() method. It takes the same arguments as table.search(), with the exception of the search query and the where_args parameter, since those should be provided when the returned SQL is executed.

Outputs:

This method detects if a SQLite table uses FTS4 or FTS5, and outputs the correct SQL for ordering by relevance depending on the search type.

This uses the rank_bm25() custom SQL function from sqlite-fts4. You can register that custom function against a Database connection using this method:

1.3.38 Rebuilding a full-text search table
You can rebuild a table using the table.rebuild_fts() method. This is useful for if the table configuration changes or the indexed data has become corrupted in some way.

This method can be called on a table that has been configured for full-text search - dogs in this instance - or directly on a _fts table:

This runs the following SQL:

1.3.39 Optimizing a full-text search table
Once you have populated a FTS table you can optimize it to dramatically reduce its size like so:

This runs the following SQL:

1.3.40 Cached table counts using triggers
The select count(*) query in SQLite requires a full scan of the primary key index, and can take an increasingly long time as the table grows larger.
The table.enable_counts() method can be used to configure triggers to continuously update a record in a _counts table. This value can then be used to quickly retrieve the count of rows in the associated table.

This will create the _counts table if it does not already exist, with the following schema:

You can enable cached counts for every table in a database (except for virtual tables and the _counts table itself) using the database enable_counts() method:

Once enabled, table counts will be stored in the _counts table. The count records will be automatically kept up-to-date by the triggers when rows are added or deleted to the table.
To access these counts you can query the _counts table directly or you can use the db.cached_counts() method. This method returns a dictionary mapping tables to their counts:

You can pass a list of table names to this method to retrieve just those counts:

The table.count property executes a select count(*) query by default, unless the db.use_counts_table property is set to True.
You can set use_counts_table to True when you instantiate the database object:

If the property is True any calls to the table.count property will first attempt to find the cached count in the _counts table, and fall back on a count(*) query if the value is not available or the table is missing.
Calling the .enable_counts() method on a database or table object will set use_counts_table to True for the lifetime of that database object.
If the _counts table ever becomes out-of-sync with the actual table counts you can repair it using the .
reset_counts() method:

1.3.41 Creating indexes
You can create an index on a table using the .create_index(columns) method. The method takes a list of columns:

By default the index will be named idx_{table-name}_{columns}. If you pass find_unique_name=True and the automatically derived name already exists, an available name will be found by incrementing a suffix number, for example idx_items_title_2.
You can customize the name of the created index by passing the index_name parameter:

To create an index in descending order for a column, wrap the column name in db.DescIndex() like this:

You can create a unique index by passing unique=True:

Use if_not_exists=True to do nothing if an index with that name already exists. Pass analyze=True to run ANALYZE against the new index after creating it.
1.3.42 Optimizing index usage with ANALYZE
The SQLite ANALYZE command builds a table of statistics which the query planner can use to make better decisions about which indexes to use for a given query.
You should run ANALYZE if your database is large and you do not think your indexes are being efficiently used. To run ANALYZE against every index in a database, use this:

To run it just against a specific named index, pass the name of the index to that method:

To run against all indexes attached to a specific table, you can either pass the table name to db.analyze(...) or you can call the method directly on the table, like this:

1.3.43 Vacuum
You can optimize your database by running VACUUM against it like so:

1.3.44 WAL mode
You can enable Write-Ahead Logging for a database with .enable_wal():

You can disable WAL mode using .disable_wal():

You can check the current journal mode for a database using the journal_mode property:

This will usually be wal or delete (meaning WAL is disabled), but can have other values - see the PRAGMA journal_mode documentation.
1.3.45 Suggesting column types
When you create a new table for a list of inserted or upserted Python dictionaries, those methods detect the correct types for the database columns based on the data you pass in.
In some situations you may need to intervene in this process, to customize the columns that are being created in some way - see Explicitly creating a table.
That table .create() method takes a dictionary mapping column names to the Python type they should store:

You can use the suggest_column_types() helper function to derive a dictionary of column names and types from a list of records, suitable to be passed to table.create().


1.3.46 Registering custom SQL functions
SQLite supports registering custom SQL functions written in Python. The db.register_function() method lets you register these functions, and keeps track of functions that have already been registered.
If you use it as a method it will automatically detect the name and number of arguments needed by the function:

You can also use the method as a function decorator like so:

By default, the name of the Python function will be used as the name of the SQL function. You can customize this with the name= keyword argument:

If a function will return the exact same result for any given inputs you can register it as a deterministic SQLite function allowing SQLite to apply some performance optimizations:

By default registering a function with the same name and number of arguments will have no effect - the Database instance keeps track of functions that have already been registered and skips registering them if @db.
register_function is called a second time.
If you want to deliberately replace the registered function with a new implementation, use the replace=True argument:

Exceptions that occur inside a user-defined function default to returning the following error:

You can cause sqlite3 to return more useful errors, including the traceback from the custom function, by executing the following before your custom functions are executed:

1.3.47 Quoting strings for use in SQL
In almost all cases you should pass values to your SQL queries using the optional parameters argument to db. query(), as described in Passing parameters.
If that option isn't relevant to your use-case you can to quote a string for use with SQLite using the db.quote() method, like so:

1.3.48 Reading rows from a file
The sqlite_utils.utils.rows_from_file() helper function can read rows (a sequence of dictionaries) from CSV, TSV, JSON or newline-delimited JSON files. sqlite_utils.utils.rows_from_file(fp, format=None, dialect=None, encoding=None, ignore_extras=False, extras_key=None)
Load a sequence of dictionaries from a file-like object containing one of four different formats.

(continues on next page)
(continued from previous page)

This defaults to attempting to automatically detect the format of the data, or you can pass in an explicit format using the format= option.
Returns a tuple of (rows_generator, format_used) where rows_generator can be iterated over to return dictionaries, while format_used is a value from the sqlite_utils.utils.Format enum:

If a CSV or TSV file includes rows with more fields than are declared in the header a sqlite_utils.utils. RowError exception will be raised when you loop over the generator.
You can instead ignore the extra data by passing ignore_extras=True.
Or pass extras_key="rest" to put those additional values in a list in a key called rest.
Parameters
• fp (BinaryIO) - a file-like object containing binary data
• format (Format | None) - the format to use - omit this to detect the format
• dialect (Type[Dialect] | None) - the CSV dialect to use - omit this to detect the dialect
• encoding (str | None) - the character encoding to use when reading CSV/TSV data
• ignore_extras (bool | None) - ignore any extra fields on rows
• extras_key (str | None) - put any extra fields in a list with this key
Return type
Tuple[Iterable[dict], Format]
1.3.49 Setting the maximum CSV field size limit
Sometimes when working with CSV files that include extremely long fields you may see an error that looks like this:

The Python standard library csv module enforces a field size limit.	You can increase that limit using the csv.
field_size_limit(new_limit) method (documented here) but if you don't want to pick a new level you may instead want to increase it to the maximum possible.
The maximum possible value for this is not documented, and varies between systems.
Calling sqlite_utils.utils.maximize_csv_field_size_limit() will set the value to the highest possible for the current system:

If you need to reset to the original value after calling this function you can do so like this:

1.3.50 Detecting column types using TypeTracker
Sometimes you may find yourself working with data that lacks type information - data from a CSV file for example. The TypeTracker class can be used to try to automatically identify the most likely types for data that is initially represented as strings.

If we insert this data directly into a table we will get a schema that is entirely TEXT columns:

We can detect the best column types using a TypeTracker instance:

We can then apply those types to our new table using the table.transform() method:

1.3.51 SpatiaLite helpers
SpatiaLite is a geographic extension to SQLite (similar to PostgreSQL + PostGIS). Using requires finding, loading and initializing the extension, adding geometry columns to existing tables and optionally creating spatial indexes. The utilities here help streamline that setup.
Initialize SpatiaLite
Database.init_spatialite(path=None)
The init_spatialite method will load and initialize the SpatiaLite extension. The path argument should be an absolute path to the compiled extension, which can be found using find_spatialite. Returns True if SpatiaLite was successfully initialized.

If you've installed SpatiaLite somewhere unexpected (for testing an alternate version, for example) you can pass in an absolute path:

path (str | None) - Path to SpatiaLite module on disk
Return type
bool
Finding SpatiaLite sqlite_utils.utils.find_spatialite()
The find_spatialite() function searches for the SpatiaLite SQLite extension in some common places. It returns a string path to the location, or None if SpatiaLite was not found.
You can use it in code like this:

(continued from previous page)

Return type
str | None
Adding geometry columns
Table.add_geometry_column(column_name, geometry_type, srid=4326, coord_dimension='XY', not_null=False)
In SpatiaLite, a geometry column can only be added to an existing table. To do so, use table. add_geometry_column, passing in a geometry type.
By default, this will add a nullable column using SRID 4326. This can be customized using the column_name, srid and not_null arguments.
Returns True if the column was successfully added, False if not.

• column_name (str) - Name of column to add
• geometry_type (str) - Type of geometry column, for example "GEOMETRY" or "POINT" or ``"POLYGON"
• srid (int) - Integer SRID, defaults to 4326 for WGS84
• coord_dimension (str) - Dimensions to use, defaults to "XY" - set to "XYZ" to work in three dimensions
• not_null (bool) - Should the column be NOT NULL
Return type bool Creating a spatial index
Table.create_spatial_index(column_name)
A spatial index allows for significantly faster bounding box queries. To create one, use create_spatial_index with the name of an existing geometry column.
Returns True if the index was successfully created, False if not. Calling this function if an index already exists is a no-op.

Parameters column_name - Geometry column to create the spatial index against
Return type
bool
1.4 Plugins
sqlite-utils supports plugins, which can be used to add extra features to the software.
Plugins can add new commands, for example sqlite-utils some-command ... Plugins can be installed using the sqlite-utils install command:

You can see a JSON list of plugins that have been installed by running this:

Plugin hooks such as prepare_connection(conn) affect each instance of the Database class. You can opt-out of these plugins by creating that class instance like so:


1.4.1 Building a plugin
Plugins are created in a directory named after the plugin. To create a "hello world" plugin, first create a hello-world directory:

In that folder create two files. The first is a pyproject.toml file describing the plugin:

The [project.entry-points.sqlite_utils] section tells sqlite-utils which module to load when executing the plugin.
Then create sqlite_utils_hello_world.py with the following content:

Install the plugin in "editable" mode - so you can make changes to the code and have them picked up instantly by sqlite-utils - like this:

Or pass the path to your plugin directory:

Now, running this should execute your new command:

Your command will also be listed in the output of sqlite-utils --help. See the LLM plugin documentation for tips on distributing your plugin.
1.4. Plugins
1.4.2 Plugin hooks
Plugin hooks allow sqlite-utils to be customized. register_commands(cli)
This hook can be used to register additional commands with the sqlite-utils CLI. It is called with the cli object, which is a click.Group instance.

New commands implemented by plugins can invoke existing commands using the context.invoke mechanism.
As a special niche feature, if your plugin needs to import some files and then act against an in-memory database containing those files you can forward to the sqlite-utils memory command and pass it return_db=True:

prepare_connection(conn)
This hook is called when a new SQLite database connection is created. You can use it to register custom SQL functions, aggregates and collations. For example:

This registers a SQL function called hello which takes a single argument and can be called like this:

1.5 API reference

1.5.1 sqlite_utils.db.Database
class sqlite_utils.db.Database(filename_or_conn=None, memory=False, memory_name=None,
                           recreate=False, recursive_triggers=True, tracer=None, use_counts_table=False, execute_plugins=True, strict=False) Wrapper for a SQLite database connection that adds a variety of useful utility methods. To create an instance:

Parameters
• filename_or_conn (str | Path | Connection | None) - String path to a file, or a pathlib.Path object, or a sqlite3 connection
• memory (bool) - set to True to create an in-memory database
• memory_name (str | None) - creates a named in-memory database that can be shared across multiple connections
• recreate (bool) - set to True to delete and recreate a file database (dangerous)
• recursive_triggers (bool) - defaults to True, which sets PRAGMA recursive_triggers=on; - set to False to avoid setting this pragma
• tracer (Callable | None) - set a tracer function (print works for this) which will be called with sql, parameters every time a SQL query is executed
• use_counts_table (bool) - set to True to use a cached counts table, if available. See Cached table counts using triggers
• strict (bool) - Apply STRICT mode to all created tables (unless overridden)
• execute_plugins (bool)
close()
Close the SQLite connection, and the underlying database file
ensure_autocommit_off()
Ensure autocommit is off for this database connection. Example usage:

This will reset to the previous autocommit state at the end of the block.
tracer(tracer=None)
Context manager to temporarily set a tracer function - all executed SQL queries will be passed to this.
The tracer function should accept two arguments: sql and parameters Example usage:

See Tracing queries.
Parameters tracer (Callable | None) - Callable accepting sql and parameters arguments
__getitem__(table_name) db[table_name] returns a Table object for the table with the specified name. If the table does not exist yet it will be created the first time data is inserted into it.
Parameters table_name (str) - The name of the table
Return type
Table | View
register_function(fn=None, deterministic=False, replace=False, name=None) fn will be made available as a function within SQL, with the same name and number of arguments. Can be used as a decorator:

The decorator can take arguments:

See Registering custom SQL functions.
Parameters
• fn (Callable | None) - Function to register
• deterministic (bool) - set True for functions that always returns the same output for a given input
• replace (bool) - set True to replace an existing function with the same name - otherwise throw an error
• name (str | None) - name of the SQLite function - if not specified, the Python function name will be used
register_fts4_bm25()
    Register the rank_bm25(match_info) function used for calculating relevance with SQLite FTS4. attach(alias, filepath)
Attach another SQLite database file to this connection with the specified alias, equivalent to:

Parameters
• alias (str) - Alias name to use
• filepath (str | Path) - Path to SQLite database file on disk
query(sql, params=None)
Execute sql and return an iterable of dictionaries representing each row.
Parameters
• sql (str) - SQL query to execute • params (Iterable | dict | None) - Parameters to use in that query - an iterable for where id = ? parameters, or a dictionary for where id = :id
Return type
Generator[dict, None, None]
execute(sql, parameters=None)
Execute SQL query and return a sqlite3.Cursor.
Parameters
• sql (str) - SQL query to execute
• parameters (Iterable | dict | None) - Parameters to use in that query - an iterable for where id = ? parameters, or a dictionary for where id = :id
Return type
Cursor
executescript(sql)
Execute multiple SQL statements separated by ; and return the sqlite3.Cursor.
Parameters sql (str) - SQL to execute
Return type Cursor
table(table_name, **kwargs)
Return a table object, optionally configured with default options. See sqlite_utils.db.Table for option details.
Parameters table_name (str) - Name of the table
Return type
Table | View
quote(value)
Apply SQLite string quoting to a value, including wrapping it in single quotes.
Parameters value (str) - String to quote
Return type str
quote_fts(query)
Escape special characters in a SQLite full-text search query.
This works by surrounding each token within the query with double quotes, in order to avoid words like NOT and OR having special meaning as defined by the FTS query syntax here: https://www.sqlite.org/fts5.html#full_text_query_syntax
If the query has unbalanced " characters, adds one at end.
Parameters query (str) - String to escape
Return type str
quote_default_value(value)
Parameters value (str) Return type str
table_names(fts4=False, fts5=False)
List of string table names in this database.
Parameters
• fts4 (bool) - Only return tables that are part of FTS4 indexes
• fts5 (bool) - Only return tables that are part of FTS5 indexes
Return type
List[str]
view_names()
List of string view names in this database.
Return type
List[str]
property tables: List[Table]
List of Table objects in this database.
property views: List[View]
List of View objects in this database.
property triggers: List[Trigger]
List of (name, table_name, sql) tuples representing triggers in this database.
property triggers_dict: Dict[str, str]
    A {trigger_name: sql} dictionary of triggers in this database. property schema: str
    SQL schema for this database. property supports_strict: bool
Does this database support STRICT mode?
property sqlite_version: Tuple[int, ...]
    Version of SQLite, as a tuple of integers for example (3, 36, 0). property journal_mode: str Current journal_mode of this database.
https://www.sqlite.org/pragma.html#pragma_journal_mode
enable_wal()
Sets journal_mode to 'wal' to enable Write-Ahead Log mode.
disable_wal()
Sets journal_mode back to 'delete' to disable Write-Ahead Log mode.
enable_counts()
Enable trigger-based count caching for every table in the database, see Cached table counts using triggers.
cached_counts(tables=None)
Return {table_name: count} dictionary of cached counts for specified tables, or all tables if tables not provided.
Parameters tables (Iterable[str] | None) - Subset list of tables to return counts for.
Return type
Dict[str, int]
reset_counts()
Re-calculate cached counts for tables.
create_table_sql(name, columns, pk=None, foreign_keys=None, column_order=None, not_null=None,
defaults=None, hash_id=None, hash_id_columns=None, extracts=None, if_not_exists=False, strict=False)
Returns the SQL CREATE TABLE statement for creating the specified table.
Parameters
• name (str) - Name of table
• columns (Dict[str, Any]) - Dictionary mapping column names to their types, for ex-
ample {"name": str, "age": int}
• pk (Any | None) - String name of column to use as a primary key, or a tuple of strings for a compound primary key covering multiple columns
• foreign_keys	(Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str,
str, str, str]] | None) - List of foreign key definitions for this table
• column_order (List[str] | None) - List specifying which columns should come first
• not_null (Iterable[str] | None) - List of columns that should be created as NOT NULL
• defaults (Dict[str, Any] | None)	-	Dictionary	specifying	default	values	for columns
• hash_id (str | None) - Name of column to be used as a primary key containing a hash of the other columns
• hash_id_columns (Iterable[str] | None) - List of columns to be used when calculating the hash ID for a row
• extracts (Dict[str, str] | List[str] | None) - List or dictionary of columns to be extracted during inserts, see Populating lookup tables automatically during insert/upsert
• if_not_exists (bool) - Use CREATE TABLE IF NOT EXISTS
• strict (bool) - Apply STRICT mode to table
Return type str
create_table(name, columns, pk=None, foreign_keys=None, column_order=None, not_null=None, defaults=None, hash_id=None, hash_id_columns=None, extracts=None, if_not_exists=False, replace=False, ignore=False, transform=False, strict=False)
Create a table with the specified name and the specified {column_name: type} columns. See Explicitly creating a table.
Parameters
• name (str) - Name of table
• columns (Dict[str, Any]) - Dictionary mapping column names to their types, for ex-
ample {"name": str, "age": int}
• pk (Any | None) - String name of column to use as a primary key, or a tuple of strings for a compound primary key covering multiple columns
• foreign_keys	(Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str,
str, str, str]] | None) - List of foreign key definitions for this table
• column_order (List[str] | None) - List specifying which columns should come first
• not_null (Iterable[str] | None) - List of columns that should be created as NOT
NULL
• defaults (Dict[str, Any] | None)	-	Dictionary	specifying	default	values	for columns
• hash_id (str | None) - Name of column to be used as a primary key containing a hash of the other columns
• hash_id_columns (Iterable[str] | None) - List of columns to be used when calculating the hash ID for a row
• extracts (Dict[str, str] | List[str] | None) - List or dictionary of columns to be extracted during inserts, see Populating lookup tables automatically during insert/upsert
• if_not_exists (bool) - Use CREATE TABLE IF NOT EXISTS
• replace (bool) - Drop and replace table if it already exists
• ignore (bool) - Silently do nothing if table already exists
• transform (bool) - If table already exists transform it to fit the specified schema
• strict (bool) - Apply STRICT mode to table
Return type Table
rename_table(name, new_name) Rename a table.
Parameters
• name (str) - Current table name
• new_name (str) - Name to rename it to
create_view(name, sql, ignore=False, replace=False)
Create a new SQL view with the specified name - sql should start with SELECT ....
Parameters
• name (str) - Name of the view
• sql (str) - SQL SELECT query to use for this view.
• ignore (bool) - Set to True to do nothing if a view with this name already exists
• replace (bool) - Set to True to replace the view if one with this name already exists
m2m_table_candidates(table, other_table)
Given two table names returns the name of tables that could define a many-to-many relationship between those two tables, based on having foreign keys to both of the provided tables.
Parameters
• table (str) - Table name
• other_table (str) - Other table name
Return type
List[str]
add_foreign_keys(foreign_keys)
See Adding multiple foreign key constraints at once.
Parameters foreign_keys (Iterable[Tuple[str, str, str, str]]) - A list of (table, column, other_table, other_column) tuples
index_foreign_keys()
Create indexes for every foreign key column on every table in the database.
vacuum()
Run a SQLite VACUUM against the database.
analyze(name=None)
Run ANALYZE against the entire database or a named table or index.
Parameters name - Run ANALYZE against this specific named table or index
iterdump()
A sequence of strings representing a SQL dump of the database
Return type
Generator[str, None, None]
init_spatialite(path=None)
The init_spatialite method will load and initialize the SpatiaLite extension. The path argument should be an absolute path to the compiled extension, which can be found using find_spatialite. Returns True if SpatiaLite was successfully initialized.

If you've installed SpatiaLite somewhere unexpected (for testing an alternate version, for example) you can pass in an absolute path:

path (str | None) - Path to SpatiaLite module on disk
Return type
bool
1.5.2 sqlite_utils.db.Queryable
Table and View are both subclasses of Queryable, providing access to the following methods:
class sqlite_utils.db.Queryable(db, name)
exists()
Does this table or view exist yet?
Return type bool count_where(where=None, where_args=None)
Executes SELECT count(*) FROM table WHERE ... and returns a count.
Parameters
• where (str | None) - SQL where fragment to use, for example id > ?
• where_args (Iterable | dict | None) - Parameters to use with that fragment - an iterable for id > ? parameters, or a dictionary for id > :id
Return type int
property count: int
    A count of the rows in this table or view. property rows: Generator[dict, None, None]
Iterate over every dictionaries for each row in this table or view.
rows_where(where=None, where_args=None, order_by=None, select='*', limit=None, offset=None) Iterate over every row in this table or view that matches the specified where clause. Returns each row as a dictionary. See Listing rows for more details.
Parameters
• where (str | None) - SQL where fragment to use, for example id > ?
• where_args (Iterable | dict | None) - Parameters to use with that fragment - an iterable for id > ? parameters, or a dictionary for id > :id
• order_by (str | None) - Column or fragment of SQL to order by
• select (str) - Comma-separated list of columns to select - defaults to *
• limit (int | None) - Integer number of rows to limit to
• offset (int | None) - Integer for SQL offset
Return type
Generator[dict, None, None]
pks_and_rows_where(where=None, where_args=None, order_by=None, limit=None, offset=None) Like .rows_where() but returns (pk, row) pairs - pk can be a single value or tuple.
Parameters
• where (str | None) - SQL where fragment to use, for example id > ?
• where_args (Iterable | dict | None) - Parameters to use with that fragment - an iterable for id > ? parameters, or a dictionary for id > :id
• order_by (str | None) - Column or fragment of SQL to order by
• select - Comma-separated list of columns to select - defaults to *
• limit (int | None) - Integer number of rows to limit to
• offset (int | None) - Integer for SQL offset
Return type
Generator[Tuple[Any, Dict], None, None]
property columns: List[Column]
List of Columns representing the columns in this table or view.
property columns_dict: Dict[str, Any]
    {column_name: python-type} dictionary representing columns in this table or view. property schema: str
SQL schema for this table or view.
1.5.3 sqlite_utils.db.Table
class sqlite_utils.db.Table(db, name, pk=None, foreign_keys=None, column_order=None, not_null=None,
defaults=None, batch_size=100, hash_id=None, hash_id_columns=None, alter=False, ignore=False, replace=False, extracts=None, conversions=None, columns=None, strict=False)
Bases: Queryable
Tables should usually be initialized using the db.table(table_name) or db[table_name] methods. The following optional parameters can be passed to db.table(table_name, ...):
Parameters
• db (Database) - Provided by db.table(table_name)
• name (str) - Provided by db.table(table_name)
• pk (Any | None) - Name of the primary key column, or tuple of columns
• foreign_keys (Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | None) - List of foreign key definitions
• column_order (List[str] | None) - List of column names in the order they should be in the table
• not_null (Iterable[str] | None) - List of columns that cannot be null
• defaults (Dict[str, Any] | None) - Dictionary of column names and default values
• batch_size (int) - Integer number of rows to insert at a time
• hash_id (str | None) - If True, use a hash of the row values as the primary key
• hash_id_columns (Iterable[str] | None) - List of columns to use for the hash_id
• alter (bool) - If True, automatically alter the table if it doesn't match the schema
• ignore (bool) - If True, ignore rows that already exist when inserting
• replace (bool) - If True, replace rows that already exist when inserting
• extracts (Dict[str, str] | List[str] | None) - Dictionary or list of column names to extract into a separate table on inserts
• conversions (dict | None) - Dictionary of column names and conversion functions
• columns (Dict[str, Any] | None) - Dictionary of column names to column types
• strict (bool) - If True, apply STRICT mode to table
last_rowid: int | None = None
The rowid of the last inserted, updated or selected row.
last_pk: Any | None = None
The primary key of the last inserted, updated or selected row.
property count: int
Count of the rows in this table - optionally from the table count cache, if configured.
exists()
Does this table or view exist yet?
Return type bool
property pks: List[str]
Primary key columns for this table.
property use_rowid: bool
Does this table use rowid for its primary key (no other primary keys are specified)?
get(pk_values)
Return row (as dictionary) for the specified primary key.
Raises sqlite_utils.db.NotFoundError if a matching row cannot be found.
Parameters pk_values (list | tuple | str | int) - A single value, or a tuple of values for tables that have a compound primary key
Return type dict
property foreign_keys: List[ForeignKey]
List of foreign keys defined on this table.
property virtual_table_using: str | None
Type of virtual table, or None if this is not a virtual table.
property indexes: List[Index]
List of indexes defined on this table.
property xindexes: List[XIndex]
    List of indexes defined on this table using the more detailed XIndex format. property triggers: List[Trigger]
List of triggers defined on this table.
property triggers_dict: Dict[str, str]
{trigger_name: sql} dictionary of triggers defined on this table.
property default_values: Dict[str, Any]
    {column_name: default_value} dictionary of default values for columns in this table. property strict: bool
Is this a STRICT table?
create(columns, pk=None, foreign_keys=None, column_order=None, not_null=None, defaults=None, hash_id=None, hash_id_columns=None, extracts=None, if_not_exists=False, replace=False, ignore=False, transform=False, strict=False) Create a table with the specified columns.
See Explicitly creating a table for full details.
Parameters
• columns (Dict[str, Any]) - Dictionary mapping column names to their types, for ex-
ample {"name": str, "age": int}
• pk (Any | None) - String name of column to use as a primary key, or a tuple of strings for a compound primary key covering multiple columns
• foreign_keys	(Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str,
str, str, str]] | None) - List of foreign key definitions for this table
• column_order (List[str] | None) - List specifying which columns should come first
• not_null (Iterable[str] | None) - List of columns that should be created as NOT NULL
• defaults (Dict[str, Any] | None)	-	Dictionary	specifying	default	values	for columns
• hash_id (str | None) - Name of column to be used as a primary key containing a hash of the other columns
• hash_id_columns (Iterable[str] | None) - List of columns to be used when calculating the hash ID for a row
• extracts (Dict[str, str] | List[str] | None) - List or dictionary of columns to be extracted during inserts, see Populating lookup tables automatically during insert/upsert
• if_not_exists (bool) - Use CREATE TABLE IF NOT EXISTS
• replace (bool) - Drop and replace table if it already exists
• ignore (bool) - Silently do nothing if table already exists
• transform (bool) - If table already exists transform it to fit the specified schema
• strict (bool) - Apply STRICT mode to table
Return type Table
duplicate(new_name)
Create a duplicate of this table, copying across the schema and all row data.
Parameters new_name (str) - Name of the new table
Return type Table
transform(*, types=None, rename=None, drop=None, pk=<sqlite_utils.db.Default object>, not_null=None,
defaults=None, drop_foreign_keys=None, add_foreign_keys=None, foreign_keys=None, column_order=None, keep_table=None)
Apply an advanced alter table, including operations that are not supported by ALTER TABLE in SQLite itself.
See Transforming a table for full details.
Parameters
• types (dict | None) - Columns that should have their type changed, for example
{"weight": float}
• rename (dict | None) - Columns to rename, for example {"headline": "title"}
• drop (Iterable | None) - Columns to drop
• pk (Any | None) - New primary key for the table
• not_null (Iterable[str] | None) - Columns to set as NOT NULL
• defaults (Dict[str, Any] | None) - Default values for columns
• drop_foreign_keys (Iterable[str] | None) - Names of columns that should have their foreign key constraints removed
• add_foreign_keys (Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | None) - List of foreign keys to add to the table
• foreign_keys (Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | None) - List of foreign keys to set for the table, replacing any existing foreign keys
• column_order (List[str] | None) - List of strings specifying a full or partial column order to use when creating the table
• keep_table (str | None) - If specified, the existing table will be renamed to this and will not be dropped
Return type Table
transform_sql(*, types=None, rename=None, drop=None, pk=<sqlite_utils.db.Default object>, not_null=None, defaults=None, drop_foreign_keys=None, add_foreign_keys=None, foreign_keys=None, column_order=None, tmp_suffix=None, keep_table=None) Return a list of SQL statements that should be executed in order to apply this transformation.
Parameters
• types (dict | None) - Columns that should have their type changed, for example
{"weight": float}
• rename (dict | None) - Columns to rename, for example {"headline": "title"}
• drop (Iterable | None) - Columns to drop
• pk (Any | None) - New primary key for the table
• not_null (Iterable[str] | None) - Columns to set as NOT NULL
• defaults (Dict[str, Any] | None) - Default values for columns
• drop_foreign_keys (Iterable | None) - Names of columns that should have their
foreign key constraints removed
• add_foreign_keys (Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | None) - List of foreign keys to add to the table
• foreign_keys	(Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str |
ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str,
str, str, str]] | None) - List of foreign keys to set for the table, replacing any existing foreign keys
• column_order (List[str] | None) - List of strings specifying a full or partial column order to use when creating the table
• tmp_suffix (str | None) - Suffix to use for the temporary table name
• keep_table (str | None) - If specified, the existing table will be renamed to this and will not be dropped
Return type
List[str]
extract(columns, table=None, fk_column=None, rename=None) Extract specified columns into a separate table.
See Extracting columns into a separate table for details.
Parameters
• columns (str | Iterable[str]) - Single column or list of columns that should be extracted
• table (str | None) - Name of table in which the new records should be created
• fk_column (str | None) - Name of the foreign key column to populate in the original table
• rename (Dict[str, str] | None) - Dictionary of columns that should be renamed
when populating the new table
Return type Table
create_index(columns, index_name=None, unique=False, if_not_exists=False, find_unique_name=False, analyze=False)
Create an index on this table.
Parameters
• columns (Iterable[str | DescIndex]) - A single columns or list of columns to index. These can be strings or, to create an index using the column in descending order, db.DescIndex(column_name) objects.
• index_name (str | None) - The name to use for the new index. Defaults to the column names joined on _.
• unique (bool) - Should the index be marked as unique, forcing unique values?
• if_not_exists (bool) - Only create the index if one with that name does not already exist.
• find_unique_name (bool) - If index_name is not provided and the automatically derived name already exists, keep incrementing a suffix number to find an available name.
• analyze (bool) - Run ANALYZE against this index after creating it. See Creating indexes.
add_column(col_name, col_type=None, fk=None, fk_col=None, not_null_default=None) Add a column to this table. See Adding columns.
Parameters
• col_name (str) - Name of the new column
• col_type (Any | None) - Column type - a Python type such as str or a SQLite type string such as "BLOB"
• fk (str | None) - Name of a table that this column should be a foreign key reference to • fk_col (str | None) - Column in the foreign key table that this should reference
• not_null_default (Any | None) - Set this column to not null and give it this default value
drop(ignore=False) Drop this table.
Parameters ignore (bool) - Set to True to ignore the error if the table does not exist
guess_foreign_table(column)
For a given column, suggest another table that might be referenced by this column should it be used as a foreign key.
For example, a column called tag_id or tag or tags might suggest a tag table, if one exists. If no candidates can be found, raises a NoObviousTable exception.
Parameters column (str) - Name of column
Return type str
add_foreign_key(column, other_table=None, other_column=None, ignore=False) Alter the schema to mark the specified column as a foreign key to another table.
Parameters
• column (str) - The column to mark as a foreign key.
• other_table (str | None) - The table it refers to - if omitted, will be guessed based on the column name.
• other_column (str | None) - The column on the other table it - if omitted, will be guessed.
• ignore (bool) - Set this to True to ignore an existing foreign key - otherwise a AlterError will be raised.
enable_counts()
    Set up triggers to update a cache of the count of rows in this table. See Cached table counts using triggers for details. property has_counts_triggers: bool
    Does this table have triggers setup to update cached counts? enable_fts(columns, fts_version='FTS5', create_triggers=False, tokenize=None, replace=False) Enable SQLite full-text search against the specified columns. See Full-text search for more details.
Parameters
• columns (Iterable[str]) - List of column names to include in the search index.
• fts_version (str) - FTS version to use - defaults to FTS5 but you may want FTS4 for older SQLite versions.
• create_triggers (bool) - Should triggers be created to keep the search index up-todate? Defaults to False.
• tokenize (str | None) - Custom SQLite tokenizer to use, for example "porter" to enable Porter stemming.
• replace (bool) - Should any existing FTS index for this table be replaced by the new one?
populate_fts(columns)
Update the associated SQLite full-text search index with the latest data from the table for the specified columns.
Parameters columns (Iterable[str]) - Columns to populate the data for
Return type Table
disable_fts()
Remove any full-text search index and related triggers configured for this table.
Return type Table
rebuild_fts()
Run the rebuild operation against the associated full-text search index table.
detect_fts()
Detect if table has a corresponding FTS virtual table and return it
Return type
str | None
optimize()
Run the optimize operation against the associated full-text search index table.
Return type Table
search_sql(columns=None, order_by=None, limit=None, offset=None, where=None, include_rank=False) " Return SQL string that can be used to execute searches against this table.
Parameters
• columns (Iterable[str] | None) - Columns to search against
• order_by (str | None) - Column or SQL expression to sort by
• limit (int | None) - SQL limit • offset (int | None) - SQL offset
• where (str | None) - Extra SQL fragment for the WHERE clause
• include_rank (bool) - Select the search rank column in the final query
Return type str search(q, order_by=None, columns=None, limit=None, offset=None, where=None, where_args=None, include_rank=False, quote=False)
Execute a search against this table using SQLite full-text search, returning a sequence of dictionaries for each row.
Parameters
• q (str) - Terms to search for
• order_by (str | None) - Defaults to order by rank, or specify a column here. • columns (Iterable[str] | None) - List of columns to return, defaults to all columns.
• limit (int | None) - Optional integer limit for returned rows.
• offset (int | None) - Optional integer SQL offset.
• where (str | None) - Extra SQL fragment for the WHERE clause
• where_args (Iterable | dict | None) - Arguments to use for :param placeholders in the extra WHERE clause
• include_rank (bool) - Select the search rank column in the final query
• quote (bool) - Apply quoting to disable any special characters in the search query
Return type
       Generator[dict, None, None] See Searching with table.search().
delete(pk_values)
Delete row matching the specified primary key.
Parameters
pk_values (list | tuple | str | int | float) - A single value, or a tuple of values for tables that have a compound primary key
Return type Table
delete_where(where=None, where_args=None, analyze=False)
Delete rows matching the specified where clause, or delete all rows in the table. See Deleting multiple records.
Parameters
• where (str | None) - SQL where fragment to use, for example id > ?
• where_args (Iterable | dict | None) - Parameters to use with that fragment - an iterable for id > ? parameters, or a dictionary for id > :id
• analyze (bool) - Set to True to run ANALYZE after the rows have been deleted.
Return type Table
update(pk_values, updates=None, alter=False, conversions=None) Execute a SQL UPDATE against the specified row. See Updating a specific record.
Parameters
• pk_values (list | tuple | str | int | float) - The primary key of an individual record - can be a tuple if the table has a compound primary key.
• updates (dict | None) - A dictionary mapping columns to their updated values.
• alter (bool) - Set to True to add any missing columns. • conversions (dict | None) - Optional dictionary of SQL functions to apply during the update, for example {"mycolumn": "upper(?)"}.
Return type Table
convert(columns, fn, output=None, output_type=None, drop=False, multi=False, where=None, where_args=None, show_progress=False, skip_false=True)
Apply conversion function fn to every value in the specified columns.
Parameters
• columns (str | List[str]) - A single column or list of string column names to convert.
• fn (Callable) - A callable that takes a single argument, value, and returns it converted.
• output (str | None) - Optional string column name to write the results to (defaults to the input column).
• output_type (Any | None) - If the output column needs to be created, this is the type that will be used for the new column.
• drop (bool) - Should the original column be dropped once the conversion is complete?
• multi (bool) - If True the return value of fn(value) will be expected to be a dictionary, and new columns will be created for each key of that dictionary.
• where (str | None) - SQL fragment to use as a WHERE clause to limit the rows to which the conversion is applied, for example age > ? or age > :age.
• where_args (Iterable | dict | None) - List of arguments (if using ?) or a dictionary (if using :age).
• show_progress (bool) - Should a progress bar be displayed?
• skip_false (bool)
See Converting data in columns.
insert(record, pk=<sqlite_utils.db.Default object>, foreign_keys=<sqlite_utils.db.Default object>, column_order=<sqlite_utils.db.Default object>, not_null=<sqlite_utils.db.Default object>, defaults=<sqlite_utils.db.Default object>, hash_id=<sqlite_utils.db.Default object>, hash_id_columns=<sqlite_utils.db.Default object>, alter=<sqlite_utils.db.Default object>, ignore=<sqlite_utils.db.Default object>, replace=<sqlite_utils.db.Default object>, extracts=<sqlite_utils.db.Default object>, conversions=<sqlite_utils.db.Default object>, columns=<sqlite_utils.db.Default object>, strict=<sqlite_utils.db.Default object>)
Insert a single record into the table. The table will be created with a schema that matches the inserted record if it does not already exist, see Creating tables.
• record - required: a dictionary representing the record to be inserted.
The other parameters are optional, and mostly influence how the new table will be created if that table does not exist yet.
Each of them defaults to DEFAULT, which indicates that the default setting for the current Table object (specified in the table constructor) should be used.
Parameters
• record (Dict[str, Any]) - Dictionary record to be inserted
• pk - If creating the table, which column should be the primary key.
• foreign_keys - See Specifying foreign keys.
• column_order (List[str] | Default | None) - List of strings specifying a full or partial column order to use when creating the table.
• not_null (Iterable[str] | Default | None) - Set of strings specifying columns that should be NOT NULL.
• defaults (Dict[str, Any] | Default | None) - Dictionary specifying default values for specific columns.
• hash_id (str | Default | None) - Name of a column to create and use as a primary key, where the value of thet primary key will be derived as a SHA1 hash of the other column values in the record. hash_id="id" is a common column name used for this.
• alter (bool | Default | None) - Boolean, should any missing columns be added automatically?
• ignore (bool | Default | None) - Boolean, if a record already exists with this primary key, ignore this insert.
• replace (bool | Default | None) - Boolean, if a record already exists with this primary key, replace it with this new record.
• extracts (Dict[str, str] | List[str] | Default | None) - A list of columns to extract to other tables, or a dictionary that maps {column_name:
other_table_name}. See Populating lookup tables automatically during insert/upsert.
• conversions (Dict[str, str] | Default | None) - Dictionary specifying SQL conversion functions to be applied to the data while it is being inserted, for example {"name": "upper(?)"}. See Converting column values using SQL functions. • columns (Dict[str, Any] | Default | None) - Dictionary over-riding the detected types used for the columns, for example {"age": int, "weight": float}.
• strict (bool | Default | None) - Boolean, apply STRICT mode if creating the table.
• hash_id_columns (Iterable[str] | Default | None)
Return type Table
insert_all(records, pk=<sqlite_utils.db.Default object>, foreign_keys=<sqlite_utils.db.Default object>,
column_order=<sqlite_utils.db.Default object>, not_null=<sqlite_utils.db.Default object>, defaults=<sqlite_utils.db.Default object>, batch_size=<sqlite_utils.db.Default object>, hash_id=<sqlite_utils.db.Default object>, hash_id_columns=<sqlite_utils.db.Default object>, alter=<sqlite_utils.db.Default object>, ignore=<sqlite_utils.db.Default object>, replace=<sqlite_utils.db.Default object>, truncate=False, extracts=<sqlite_utils.db.Default object>, conversions=<sqlite_utils.db.Default object>, columns=<sqlite_utils.db.Default object>, upsert=False, analyze=False, strict=<sqlite_utils.db.Default object>)
Like .insert() but takes a list of records and ensures that the table that it creates (if table does not exist) has columns for ALL of that data.
Use analyze=True to run ANALYZE after the insert has completed.
Return type
Table
upsert(record, pk=<sqlite_utils.db.Default object>, foreign_keys=<sqlite_utils.db.Default object>, column_order=<sqlite_utils.db.Default object>, not_null=<sqlite_utils.db.Default object>, defaults=<sqlite_utils.db.Default object>, hash_id=<sqlite_utils.db.Default object>, hash_id_columns=<sqlite_utils.db.Default object>, alter=<sqlite_utils.db.Default object>, extracts=<sqlite_utils.db.Default object>, conversions=<sqlite_utils.db.Default object>, columns=<sqlite_utils.db.Default object>, strict=<sqlite_utils.db.Default object>)
Like .insert() but performs an UPSERT, where records are inserted if they do not exist and updated if they DO exist, based on matching against their primary key. See Upserting data.
Return type Table
upsert_all(records, pk=<sqlite_utils.db.Default object>, foreign_keys=<sqlite_utils.db.Default object>,
column_order=<sqlite_utils.db.Default object>, not_null=<sqlite_utils.db.Default object>, defaults=<sqlite_utils.db.Default object>, batch_size=<sqlite_utils.db.Default object>, hash_id=<sqlite_utils.db.Default object>, hash_id_columns=<sqlite_utils.db.Default object>, alter=<sqlite_utils.db.Default object>, extracts=<sqlite_utils.db.Default object>, conversions=<sqlite_utils.db.Default object>, columns=<sqlite_utils.db.Default object>,
       analyze=False, strict=<sqlite_utils.db.Default object>) Like .upsert() but can be applied to a list of records.
Return type Table
lookup(lookup_values, extra_values=None, pk='id', foreign_keys=None, column_order=None, not_null=None, defaults=None, extracts=None, conversions=None, columns=None, strict=False) Create or populate a lookup table with the specified values.
db["Species"].lookup({"name": "Palm"}) will create a table called Species (if one does not already exist) with two columns: id and name. It will set up a unique constraint on the name column to guarantee it will not contain duplicate rows.
It will then insert a new row with the name set to Palm and return the new integer primary key value.
An optional second argument can be provided with more name: value pairs to be included only if the record is being created for the first time. These will be ignored on subsequent lookup calls for records that already exist.
All other keyword arguments are passed through to .insert(). See Working with lookup tables for more details.
Parameters
• lookup_values (Dict[str, Any]) - Dictionary specifying column names and values to use for the lookup
• extra_values (Dict[str, Any] | None) - Additional column values to be used only if creating a new record
• strict (bool | None) - Boolean, apply STRICT mode if creating the table.
• pk (str | None)
• foreign_keys	(Iterable[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | List[str | ForeignKey | Tuple[str, str] | Tuple[str, str, str] | Tuple[str, str, str, str]] | None)
• column_order (List[str] | None)
• not_null (Iterable[str] | None)
• defaults (Dict[str, Any] | None)
• extracts (Dict[str, str] | List[str] | None)
• conversions (Dict[str, str] | None)
• columns (Dict[str, Any] | None)
m2m(other_table, record_or_iterable=None, pk=<sqlite_utils.db.Default object>, lookup=None, m2m_table=None, alter=False)
After inserting a record in a table, create one or more records in some other table and then create many-tomany records linking the original record and the newly created records together. For example:

See Working with many-to-many relationships for details.
Parameters
• other_table (str | Table) - The name of the table to insert the new records into.
• record_or_iterable	(Iterable[Dict[str, Any]] | Dict[str, Any] |
None) - A single dictionary record to insert, or a list of records.
• pk (Any | Default | None) - The primary key to use if creating other_table.
• lookup (Dict[str, Any] | None) - Same dictionary as for .lookup(), to create a many-to-many lookup table.
• m2m_table (str | None) - The string name to use for the many-to-many table, defaults to creating this automatically based on the names of the two tables.
• alter (bool) - Set to True to add any missing columns on other_table if that table already exists.
analyze()
Run ANALYZE against this table
analyze_column(column, common_limit=10, value_truncate=None, total_rows=None, most_common=True, least_common=True) Return statistics about the specified column. See Analyzing a column.
Parameters
• column (str) - Column to analyze
• common_limit (int) - Show this many column values
• value_truncate - Truncate display of common values to this many characters
• total_rows - Optimization - pass the total number of rows in the table to save running a fresh count(*) query
• most_common (bool) - If True, calculate the most common values
• least_common (bool) - If True, calculate the least common values
Return type
ColumnDetails
add_geometry_column(column_name, geometry_type, srid=4326, coord_dimension='XY', not_null=False) In SpatiaLite, a geometry column can only be added to an existing table. To do so, use table. add_geometry_column, passing in a geometry type.
By default, this will add a nullable column using SRID 4326. This can be customized using the column_name, srid and not_null arguments.
Returns True if the column was successfully added, False if not.

• column_name (str) - Name of column to add
• geometry_type (str) - Type of geometry column, for example "GEOMETRY" or "POINT" or ``"POLYGON"
• srid (int) - Integer SRID, defaults to 4326 for WGS84
• coord_dimension (str) - Dimensions to use, defaults to "XY" - set to "XYZ" to work in three dimensions
• not_null (bool) - Should the column be NOT NULL
Return type
bool
create_spatial_index(column_name)
A spatial index allows for significantly faster bounding box queries. To create one, use create_spatial_index with the name of an existing geometry column.
Returns True if the index was successfully created, False if not. Calling this function if an index already exists is a no-op.

(continued from previous page)
# CREATE VIRTUAL TABLE "idx_locations_geometry" USING rtree(pkid, xmin, xmax,␣
,→ymin, ymax)
Parameters column_name - Geometry column to create the spatial index against
Return type
bool
1.5.4 sqlite_utils.db.View
class sqlite_utils.db.View(db, name)
Bases: Queryable exists()
Does this table or view exist yet?
drop(ignore=False) Drop this view.
Parameters ignore - Set to True to ignore the error if the view does not exist
enable_fts(*args, **kwargs) enable_fts() is supported on tables but not on views.
1.5.5 Other
sqlite_utils.db.Column class sqlite_utils.db.Column(cid, name, type, notnull, default_value, is_pk) Describes a SQLite column returned by the Table.columns property. cid
Column index
name
Column name
type
Column type
notnull
Does the column have a not null constraint
default_value
Default value for this column
is_pk
Is this column part of the primary key
sqlite_utils.db.ColumnDetails class sqlite_utils.db.ColumnDetails(table, column, total_rows, num_null, num_blank, num_distinct, most_common, least_common) Summary information about a column, see Analyzing a column. table
The name of the table
column
The name of the column
total_rows
The total number of rows in the table
num_null
The number of rows for which this column is null
num_blank
The number of rows for which this column is blank (the empty string)
num_distinct
The number of distinct values in this column
most_common
The N most common values as a list of (value, count) tuples, or None if the table consists entirely of distinct values
least_common
The N least common values as a list of (value, count) tuples, or None if the table is entirely distinct or if the number of distinct values is less than N (since they will already have been returned in most_common)
1.5.6 sqlite_utils.utils
sqlite_utils.utils.hash_record sqlite_utils.utils.hash_record(record, keys=None) record should be a Python dictionary. Returns a sha1 hash of the keys and values in that record.
If keys= is provided, uses just those keys to generate the hash. Example usage:

• record (Dict) - Record to generate a hash for
• keys (Iterable[str] | None) - Subset of keys to use for that hash
sqlite_utils.utils.rows_from_file sqlite_utils.utils.rows_from_file(fp, format=None, dialect=None, encoding=None, ignore_extras=False, extras_key=None)
Load a sequence of dictionaries from a file-like object containing one of four different formats.

This defaults to attempting to automatically detect the format of the data, or you can pass in an explicit format using the format= option.
Returns a tuple of (rows_generator, format_used) where rows_generator can be iterated over to return dictionaries, while format_used is a value from the sqlite_utils.utils.Format enum:

If a CSV or TSV file includes rows with more fields than are declared in the header a sqlite_utils.utils. RowError exception will be raised when you loop over the generator.
You can instead ignore the extra data by passing ignore_extras=True.
Or pass extras_key="rest" to put those additional values in a list in a key called rest.
Parameters
• fp (BinaryIO) - a file-like object containing binary data
• format (Format | None) - the format to use - omit this to detect the format
• dialect (Type[Dialect] | None) - the CSV dialect to use - omit this to detect the dialect
• encoding (str | None) - the character encoding to use when reading CSV/TSV data
• ignore_extras (bool | None) - ignore any extra fields on rows
• extras_key (str | None) - put any extra fields in a list with this key
Return type
Tuple[Iterable[dict], Format]
sqlite_utils.utils.TypeTracker class sqlite_utils.utils.TypeTracker
Wrap an iterator of dictionaries and keep track of which SQLite column types are the most likely fit for each of their keys.
Example usage:

wrap(iterator)
Use this to loop through an existing iterator, tracking the column types as part of the iteration.
Parameters iterator (Iterable[dict]) - The iterator to wrap
Return type
Iterable[dict]
property types: Dict[str, str]
A dictionary mapping column names to their detected types. This can be passed to the db[table_name]. transform(types=tracker.types) method.
sqlite_utils.utils.chunks sqlite_utils.utils.chunks(sequence, size)
Iterate over chunks of the sequence of the given size.
Parameters
• sequence (Iterable) - Any Python iterator
• size (int) - The size of each chunk
Return type
Iterable[Iterable]
sqlite_utils.utils.flatten
sqlite_utils.utils.flatten(row)
Turn a nested dict e.g. {"a": {"b": 1}} into a flat dict: {"a_b": 1}
Parameters row (dict) - A Python dictionary, optionally with nested dictionaries
Return type dict

1.6 CLI reference
This page lists the --help for every sqlite-utils CLI sub-command.
• query
• memory
• insert
• upsert
• bulk
• search
• transform
• extract
• schema
• insert-files
• analyze-tables
• convert
• tables
• views
• rows
• triggers
• indexes
• create-database
• create-table
• create-index
• enable-fts
• populate-fts
• rebuild-fts
• disable-fts
• tui
• optimize
• analyze
• vacuum
• dump
• add-column
• add-foreign-key
• add-foreign-keys

1.6.1 query


1.6.2 memory


	--flatten	Flatten nested JSON objects, so {"foo": {"bar":
1}} becomes {"foo_bar": 1}
	--nl	Output newline-delimited JSON
	--arrays	Output rows as arrays instead of objects
	--csv	Output CSV
	--tsv	Output TSV
	--no-headers	Omit CSV headers
	-t, --table	Output as a formatted table
--fmt TEXT	Table format - one of asciidoc, double_grid, double_outline, fancy_grid, fancy_outline, github, grid, heavy_grid, heavy_outline, html, jira, latex, latex_booktabs, latex_longtable, latex_raw, mediawiki, mixed_grid, mixed_outline, moinmoin, orgtbl, outline, pipe, plain, presto, pretty, psql, rounded_grid, rounded_outline, rst, simple, simple_grid, simple_outline, textile, tsv, unsafehtml, youtrack
	--json-cols	Detect JSON cols and output them as JSON, not
escaped strings
	-r, --raw	Raw output, first column of first row
	--raw-lines	Raw output, first column of each row
-p, --param <TEXT TEXT>... Named :parameters for SQL query
	--encoding TEXT	Character encoding for CSV input, defaults to
utf-8
	-n, --no-detect-types	Treat all CSV/TSV columns as TEXT
	--schema	Show SQL schema for in-memory database
	--dump	Dump SQL for in-memory database
	--save FILE	Save in-memory database to this file
--analyze	Analyze resulting tables and output results --load-extension TEXT	Path to SQLite extension, with optional
:entrypoint
	-h, --help	Show this message and exit.
1.6.3 insert
See Inserting JSON data, Inserting CSV or TSV data, Inserting unstructured data with --lines and --text, Applying conversions while inserting data.

- Use --lines to write each incoming line to a column called "line"
- Use --text to write the entire input to a column called "text"
You can also use --convert to pass a fragment of Python code that will be used to convert each input.
Your Python code will be passed a "row" variable representing the imported row, and can return a modified row.
This example uses just the name, latitude and longitude columns from a CSV file, converting name to upper case and latitude and longitude to floating point numbers:
sqlite-utils insert plants.db plants plants.csv --csv --convert ' return {
"name": row["name"].upper(),
"latitude": float(row["latitude"]),
  "longitude": float(row["longitude"]), }'
If you are using --lines your code will be passed a "line" variable, and for --text a "text" variable.
When using --text your function can return an iterator of rows to insert. This example inserts one record per word in the input:
echo 'A bunch of words' | sqlite-utils insert words.db words - \ --text --convert '({"word": w} for w in text.split())'
Options:
	--pk TEXT	Columns to use as the primary key, e.g. id
	--flatten	Flatten nested JSON objects, so {"a": {"b": 1}}
becomes {"a_b": 1}
	--nl	Expect newline-delimited JSON
-c, --csv	Expect CSV input --tsv	Expect TSV input
	--empty-null	Treat empty strings as NULL
	--lines	Treat each line as a single value called 'line'
	--text	Treat input as a single value called 'text'
	--convert TEXT	Python code to convert each item
	--import TEXT	Python modules to import
	--delimiter TEXT	Delimiter to use for CSV files
	--quotechar TEXT	Quote character to use for CSV/TSV
	--sniff	Detect delimiter and quote character
	--no-headers	CSV file has no header row
	--encoding TEXT	Character encoding for input, defaults to utf-8
	--batch-size INTEGER	Commit every X records
	--stop-after INTEGER	Stop after X records
	--alter	Alter existing table to add any missing columns
	--not-null TEXT	Columns that should be created as NOT NULL
--default <TEXT TEXT>... Default value that should be set for a column
	-d, --detect-types	Detect types for columns in CSV/TSV data	--analyze	Run ANALYZE at the end of this operation
	--load-extension TEXT	Path to SQLite extension, with optional :entrypoint
	--silent	Do not show progress bar
	--strict	Apply STRICT mode to created table
	--ignore	Ignore records if pk already exists
	--replace	Replace records if pk already exists
	--truncate	Truncate table before inserting records, if table
already exists
	-h, --help	Show this message and exit.
1.6.4 upsert


	--analyze	Run ANALYZE at the end of this operation
	--load-extension TEXT	Path to SQLite extension, with optional :entrypoint
	--silent	Do not show progress bar
--strict	Apply STRICT mode to created table -h, --help	Show this message and exit.
1.6.5 bulk

1.6.6 search

1.6.7 transform

	--type <TEXT CHOICE>...	Change column type to INTEGER, TEXT, FLOAT or
BLOB
	--drop TEXT	Drop this column
	--rename <TEXT TEXT>...	Rename this column to X
	-o, --column-order TEXT	Reorder columns
	--not-null TEXT	Set this column to NOT NULL
	--not-null-false TEXT	Remove NOT NULL from this column
	--pk TEXT	Make this column the primary key
	--pk-none	Remove primary key (convert to rowid table)
	--default <TEXT TEXT>...	Set default value for this column
	--default-none TEXT	Remove default from this column
--add-foreign-key <TEXT TEXT TEXT>...
Add a foreign key constraint from a column to another table with another column
	--drop-foreign-key TEXT	Drop foreign key constraint for this column
	--sql	Output SQL without executing it
	--load-extension TEXT	Path to SQLite extension, with optional
:entrypoint
	-h, --help	Show this message and exit.
1.6.8 extract

1.6.9 schema


1.6.10 insert-files

1.6.11 analyze-tables
	-c, --column TEXT	Specific columns to analyze
	--save	Save results to _analyze_tables table
--common-limit INTEGER How many common values
	--no-most	Skip most common values
	--no-least	Skip least common values
	--load-extension TEXT	Path to SQLite extension, with optional :entrypoint
	-h, --help	Show this message and exit.
1.6.12 convert


1.6.13 tables



1.6.14 views

1.6.15 rows

1.6.16 triggers
Options:
	--nl	Output newline-delimited JSON
	--arrays	Output rows as arrays instead of objects
	--csv	Output CSV
	--tsv	Output TSV
	--no-headers	Omit CSV headers
	-t, --table	Output as a formatted table
	--fmt TEXT	Table format - one of asciidoc, double_grid,
double_outline, fancy_grid, fancy_outline, github, grid, heavy_grid, heavy_outline, html, jira, latex, latex_booktabs, latex_longtable, latex_raw, mediawiki, mixed_grid, mixed_outline, moinmoin, orgtbl, outline, pipe, plain, presto, pretty, psql, rounded_grid, rounded_outline, rst, simple, simple_grid, simple_outline, textile, tsv, unsafehtml, youtrack
	--json-cols	Detect JSON cols and output them as JSON, not escaped
strings
--load-extension TEXT Path to SQLite extension, with optional :entrypoint
	-h, --help	Show this message and exit.
1.6.17 indexes


(continued from previous page)

1.6.18 create-database

1.6.19 create-table

1.6.20 create-index

1.6.21 enable-fts

1.6.22 populate-fts

1.6.23 rebuild-fts

1.6.24 disable-fts

1.6.25 tui

1.6.26 optimize

1.6.27 analyze

1.6.28 vacuum

1.6.29 dump

1.6.30 add-column

	--load-extension TEXT	Path to SQLite extension, with optional :entrypoint
	-h, --help	Show this message and exit.
1.6.31 add-foreign-key

1.6.32 add-foreign-keys

1.6.33 index-foreign-keys

1.6.34 enable-wal

1.6.35 disable-wal

1.6.36 enable-counts


1.6.37 reset-counts

1.6.38 duplicate

1.6.39 rename-table


1.6.40 drop-table

1.6.41 create-view

1.6.42 drop-view

(continued from previous page)
--load-extension TEXT Path to SQLite extension, with optional :entrypoint
	-h, --help	Show this message and exit.
1.6.43 install

1.6.44 uninstall

1.6.45 add-geometry-column


1.6.46 create-spatial-index
See Adding spatial indexes.
Usage: sqlite-utils create-spatial-index [OPTIONS] DB_PATH TABLE COLUMN_NAME
Create a spatial index on a SpatiaLite geometry column. The table and geometry column must already exist before trying to add a spatial index.
By default, this command will try to load the SpatiaLite extension from usual paths. To load it from a specific path, use --load-extension.
Options:
--load-extension TEXT Path to SQLite extension, with optional :entrypoint
	-h, --help	Show this message and exit.
1.6.47 plugins

1.7 Contributing
Development of sqlite-utils takes place in the sqlite-utils GitHub repository.
All improvements to the software should start with an issue. Read How I build a feature for a detailed description of the recommended process for building bug fixes or enhancements.

1.7.1 Obtaining the code
To work on this library locally, first checkout the code. Then create a new virtual environment:

Or if you are using pipenv:

Within the virtual environment running sqlite-utils should run your locally editable version of the tool. You can use which sqlite-utils to confirm that you are running the version that lives in your virtual environment.
1.7.2 Running the tests
To install the dependencies and test dependencies:

To run the tests:

1.7.3 Building the documentation
To build the documentation, first install the documentation dependencies:

Then run make livehtml from the docs/ directory to start a server on port 8000 that will serve the documentation and live-reload any time you make an edit to a .rst file:

The cog tool is used to maintain portions of the documentation. You can run it like so:

1.7.4 Linting and formatting
sqlite-utils uses Black for code formatting, and flake8 and mypy for linting and type checking.
Black is installed as part of pip install -e '.[test]' - you can then format your code by running it in the root of the project:

To install mypy and flake8 run the following:
1.7. Contributing

Both commands can then be run in the root of the project like this:

All three of these tools are run by our CI mechanism against every commit and pull request.
1.7.5 Using Just and pipenv
If you install Just and pipenv you can use them to manage your local development environment. To create a virtual environment and install all development dependencies, run:

To run all of the tests and linters:

To run tests, or run a specific test module or test by name:

To run just the linters:

To apply Black to your code:

To update documentation using Cog:

To run the live documentation server (this will run Cog first):

And to list all available commands:

1.7.6 Release process
Releases are performed using tags. When a new release is published on GitHub, a GitHub Actions workflow will perform the following:
   • Run the unit tests against all supported Python versions. If the tests pass...
   • Build a wheel bundle of the underlying Python source code
   • Push that new wheel up to PyPI: https://pypi.org/project/sqlite-utils/ To deploy new releases you will need to have push access to the GitHub repository. sqlite-utils follows Semantic Versioning:

We increment major for backwards-incompatible releases.
We increment minor for new features.
We increment patch for bugfix releass.
To release a new version, first create a commit that updates the version number in setup.py and the the changelog with highlights of the new version. An example commit can be seen here:

Referencing the issues that are part of the release in the commit message ensures the name of the release shows up on those issue pages, e.g. here.
You can generate the list of issue references for a specific release by copying and pasting text from the release notes or GitHub changes-since-last-release view into this Extract issue numbers from pasted text tool.
To create the tag for the release, create a new release on GitHub matching the new version number. You can convert the release notes to Markdown by copying and pasting the rendered HTML into this Paste to Markdown tool.
1.8 Changelog
1.8.1 3.38 (2024-11-23)
• Plugins can now reuse the implementation of the sqlite-utils memory CLI command with the new return_db=True parameter. (#643)
• table.transform() now recreates indexes after transforming a table. A new sqlite_utils.db. TransformError exception is raised if these indexes cannot be recreated due to conflicting changes to the table such as a column rename. Thanks, Mat Miller. (#633)
• table.search() now accepts a include_rank=True parameter, causing the resulting rows to have a rank column showing the calculated relevance score. Thanks, liunux4odoo. (#628)
• Fixed an error that occurred when creating a strict table with at least one floating point column. These FLOAT columns are now correctly created as REAL as well, but only for strict tables. (#644)
1.8. Changelog
1.8.2 3.37 (2024-07-18)
• The create-table and insert-files commands all now accept multiple --pk options for compound primary keys. (#620)
• Now tested against Python 3.13 pre-release. (#619)
• Fixed a crash that can occur in environments with a broken numpy installation, producing a module 'numpy' has no attribute 'int8'. (#632)
1.8.3 3.36 (2023-12-07)
• Support for creating tables in SQLite STRICT mode. Thanks, Taj Khattra. (#344)
- CLI commands create-table, insert and upsert all now accept a --strict option.
- Python methods that can create a table - table.create() and insert/upsert/insert_all/ upsert_all all now accept an optional strict=True parameter.
- The transform command and table.transform() method preserve strict mode when transforming a table.
• The sqlite-utils create-table command now accepts str, int and bytes as aliases for text, integer
and blob respectively. (#606)
1.8.4 3.35.2 (2023-11-03)
• The --load-extension=spatialite option and find_spatialite() utility function now both work correctly on arm64 Linux. Thanks, Mike Coats. (#599)
• Fix for bug where sqlite-utils insert could cause your terminal cursor to disappear. Thanks, Luke Plant. (#433)
• datetime.timedelta values are now stored as TEXT columns. Thanks, Harald Nezbeda. (#522)
• Test suite is now also run against Python 3.12.
1.8.5 3.35.1 (2023-09-08)
• Fixed a bug where table.transform() would sometimes re-assign the rowid values for a table rather than keeping them consistent across the operation. (#592)
1.8.6 3.35 (2023-08-17)
Adding foreign keys to a table no longer uses PRAGMA writable_schema = 1 to directly manipulate the sqlite_master table. This was resulting in errors in some Python installations where the SQLite library was compiled in a way that prevented this from working, in particular on macOS. Foreign keys are now added using the table transformation mechanism instead. (#577)
This new mechanism creates a full copy of the table, so it is likely to be significantly slower for large tables, but will no longer trigger table sqlite_master may not be modified errors on platforms that do not support PRAGMA writable_schema = 1.
A new plugin, sqlite-utils-fast-fks, is now available for developers who still want to use that faster but riskier implementation.
Other changes:
• The table.transform() method has two new parameters: foreign_keys= allows you to replace the foreign key constraints defined on a table, and add_foreign_keys= lets you specify new foreign keys to add. These complement the existing drop_foreign_keys= parameter. (#577)
• The sqlite-utils transform command has a new --add-foreign-key option which can be called multiple times to add foreign keys to a table that is being transformed. (#585)
• sqlite-utils convert now has a --pdb option for opening a debugger on the first encountered error in your conversion script. (#581)
• Fixed a bug where sqlite-utils install -e '.[test]' option did not work correctly.
1.8.7 3.34 (2023-07-22)
This release introduces a new plugin system. Read more about this in sqlite-utils now supports plugins. (#567)
• Documentation describing how to build a plugin.
• Plugin hook: register_commands(cli), for plugins to add extra commands to sqlite-utils. (#569)
• Plugin hook: prepare_connection(conn). Plugins can use this to help prepare the SQLite connection to do things like registering custom SQL functions. Thanks, Alex Garcia. (#574)
• sqlite_utils.Database(..., execute_plugins=False) option for disabling plugin execution. (#575)
• sqlite-utils install -e path-to-directory option for installing editable code. This option is useful during the development of a plugin. (#570)
• table.create(...) method now accepts replace=True to drop and replace an existing table with the same name, or ignore=True to silently do nothing if a table already exists with the same name. (#568)
• sqlite-utils insert ... --stop-after 10 option for stopping the insert after a specified number of records. Works for the upsert command as well. (#561)
• The --csv and --tsv modes for insert now accept a --empty-null option, which causes empty strings in the CSV file to be stored as null in the database. (#563)
• New db.rename_table(table_name, new_name) method for renaming tables. (#565)
• sqlite-utils rename-table my.db table_name new_name command for renaming tables. (#565)
• The table.transform(...) method now takes an optional keep_table=new_table_name parameter, which will cause the original table to be renamed to new_table_name rather than being dropped at the end of the transformation. (#571)
• Documentation now notes that calling table.transform() without any arguments will reformat the SQL schema stored by SQLite to be more aesthetically pleasing. (#564)
1.8.8 3.33 (2023-06-25)
• sqlite-utils will now use sqlean.py in place of sqlite3 if it is installed in the same virtual environment. This is useful for Python environments with either an outdated version of SQLite or with restrictions on SQLite such as disabled extension loading or restrictions resulting in the sqlite3.OperationalError: table sqlite_master may not be modified error. (#559)
• New with db.ensure_autocommit_off() context manager, which ensures that the database is in autocommit mode for the duration of a block of code. This is used by db.enable_wal() and db.disable_wal() to ensure they work correctly with pysqlite3 and sqlean.py.
1.8. Changelog

New db.iterdump() method, providing an iterator over SQL strings representing a dump of the database. This uses sqlite-dump if it is available, otherwise falling back on the conn.iterdump() method from sqlite3. Both pysqlite3 and sqlean.py omit support for iterdump() - this method helps paper over that difference.
1.8.9 3.32.1 (2023-05-21)
• Examples in the CLI documentation can now all be copied and pasted without needing to remove a leading $. (#551)
• Documentation now covers Setting up shell completion for bash and zsh. (#552)
1.8.10 3.32 (2023-05-21)
• New experimental sqlite-utils tui interface for interactively building command-line invocations, powered by Trogon. This requires an optional dependency, installed using sqlite-utils install trogon. There is a screenshot in the documentation. (#545)
• sqlite-utils analyze-tables command (documentation) now has a --common-limit 20 option for changing the number of common/least-common values shown for each column. (#544)
• sqlite-utils analyze-tables --no-most and --no-least options for disabling calculation of mostcommon and least-common values.
• If a column contains only null values, analyze-tables will no longer attempt to calculate the most common and least common values for that column. (#547)
• Calling sqlite-utils analyze-tables with non-existent columns in the -c/--column option now results in an error message. (#548)
• The table.analyze_column() method (documented here) now accepts most_common=False and least_common=False options for disabling calculation of those values.
1.8.11 3.31 (2023-05-08)
• Dropped support for Python 3.6. Tests now ensure compatibility with Python 3.11. (#517)
• Automatically locates the SpatiaLite extension on Apple Silicon. Thanks, Chris Amico. (#536)
• New --raw-lines option for the sqlite-utils query and sqlite-utils memory commands, which outputs just the raw value of the first column of every row. (#539)
• Fixed a bug where table.upsert_all() failed if the not_null= option was passed. (#538)
• Fixed a ResourceWarning when using sqlite-utils insert. (#534)
• Now shows a more detailed error message when sqlite-utils insert is called with invalid JSON. (#532)
• table.convert(..., skip_false=False) and sqlite-utils convert --no-skip-false options, for avoiding a misfeature where the convert() mechanism skips rows in the database with a falsey value for the specified column. Fixing this by default would be a backwards-incompatible change and is under consideration for a 4.0 release in the future. (#527)
• Tables can now be created with self-referential foreign keys. Thanks, Scott Perry. (#537)
• sqlite-utils transform no longer breaks if a table defines default values for columns. Thanks, Kenny Song. (#509)
• Fixed a bug where repeated calls to table.transform() did not work correctly. Thanks, Martin Carpenter. (#525)
• Improved error message if rows_from_file() is passed a non-binary-mode file-like object. (#520)
1.8.12 3.30 (2022-10-25)
• Now tested against Python 3.11. (#502)
• New table.search_sql(include_rank=True) option, which adds a rank column to the generated SQL. Thanks, Jacob Chapman. (#480)
• Progress bars now display for newline-delimited JSON files using the --nl option. Thanks, Mischa Untaga. (#485)
• New db.close() method. (#504)
• Conversion functions passed to table.convert(...) can now return lists or dictionaries, which will be inserted into the database as JSON strings. (#495)
• sqlite-utils install and sqlite-utils uninstall commands for installing packages into the same virtual environment as sqlite-utils, described here. (#483)
• New sqlite_utils.utils.flatten() utility function. (#500)
• Documentation on using Just to run tests, linters and build documentation.
• Documentation now covers the Release process for this package.
1.8.13 3.29 (2022-08-27)
• The sqlite-utils query, memory and bulk commands now all accept a new --functions option. This can be passed a string of Python code, and any callable objects defined in that code will be made available to SQL queries as custom SQL functions. See Defining custom SQL functions for details. (#471)
• db[table].create(...) method now accepts a new transform=True parameter. If the table already exists it will be transformed to match the schema configuration options passed to the function. This may result in columns being added or dropped, column types being changed, column order being updated or not null and default values for columns being set. (#467)
• Related to the above, the sqlite-utils create-table command now accepts a --transform option.
• New introspection property: table.default_values returns a dictionary mapping each column name with a default value to the configured default value. (#475)
• The --load-extension option can now be provided a path to a compiled SQLite extension module accompanied by the name of an entrypoint, separated by a colon - for example --load-extension ./ lines0:sqlite3_lines0_noread_init. This feature is modelled on code first contributed to Datasette by Alex Garcia. (#470)
• Functions registered using the db.register_function() method can now have a custom name specified using the new db.register_function(fn, name=...) parameter. (#458)
• sqlite-utils rows has a new --order option for specifying the sort order for the returned rows. (#469)
• All of the CLI options that accept Python code blocks can now all be used to define functions that can access modules imported in that same block of code without needing to use the global keyword. (#472)
• Fixed bug where table.extract() would not behave correctly for columns containing null values. Thanks, Forest Gregg. (#423)
• New tutorial: Cleaning data with sqlite-utils and Datasette shows how to use sqlite-utils to import and clean an example CSV file.
1.8. Changelog
Datasette and sqlite-utils now have a Discord community. Join the Discord here.
1.8.14 3.28 (2022-07-15)
• New table.duplicate(new_name) method for creating a copy of a table with a matching schema and row contents. Thanks, David. (#449)
• New sqlite-utils duplicate data.db table_name new_name CLI command for Duplicating tables.
(#454)
• sqlite_utils.utils.rows_from_file() is now a documented API. It can be used to read a sequence of dictionaries from a file-like object containing CSV, TSV, JSON or newline-delimited JSON. It can be passed an explicit format or can attempt to detect the format automatically. (#443)
• sqlite_utils.utils.TypeTracker is now a documented API for detecting the likely column types for a sequence of string rows, see Detecting column types using TypeTracker. (#445)
• sqlite_utils.utils.chunks() is now a documented API for splitting an iterator into chunks. (#451)
• sqlite-utils enable-fts now has a --replace option for replacing the existing FTS configuration for a table. (#450)
• The create-index, add-column and duplicate commands all now take a --ignore option for ignoring
errors should the database not be in the right state for them to operate. (#450)
1.8.15 3.27 (2022-06-14)
See also the annotated release notes for this release.
• Documentation now uses the Furo Sphinx theme. (#435)
• Code examples in documentation now have a "copy to clipboard" button. (#436)
• sqlite_utils.utils.utils.rows_from_file() is now a documented API, see Reading rows from a file. (#443)
• rows_from_file() has two new parameters to help handle CSV files with rows that contain more values than are listed in that CSV file's headings: ignore_extras=True and extras_key="name-of-key". (#440)
• sqlite_utils.utils.maximize_csv_field_size_limit() helper function for increasing the field size limit for reading CSV files to its maximum, see Setting the maximum CSV field size limit. (#442)
• table.search(where=, where_args=) parameters for adding additional WHERE clauses to a search query. The where= parameter is available on table.search_sql(...) as well. See Searching with table.search(). (#441)
• Fixed bug where table.detect_fts() and other search-related functions could fail if two FTS-enabled tables had names that were prefixes of each other. (#434)
1.8.16 3.26.1 (2022-05-02)
• Now depends on click-default-group-wheel, a pure Python wheel package. This means you can install and use this package with Pyodide, which can run Python entirely in your browser using WebAssembly. (#429) Try that out using the Pyodide REPL:

1.8.17 3.26 (2022-04-13)
• New errors=r.IGNORE/r.SET_NULL parameter for the r.parsedatetime() and r.parsedate() convert recipes. (#416)
• Fixed a bug where --multi could not be used in combination with --dry-run for the convert command. (#415)
• New documentation: Defining a convert() function. (#420)
• More robust detection for whether or not deterministic=True is supported. (#425)
1.8.18 3.25.1 (2022-03-11)
• Improved display of type information and parameters in the API reference documentation. (#413)
1.8.19 3.25 (2022-03-01)
• New hash_id_columns= parameter for creating a primary key that's a hash of the content of specific columns - see Setting an ID based on the hash of the row contents for details. (#343)
• New db.sqlite_version property, returning a tuple of integers representing the version of SQLite, for example (3,
38, 0).
• Fixed a bug where register_function(deterministic=True) caused errors on versions of SQLite prior to 3.8.3. (#408)
• New documented hash_record(record, keys=...) function.
1.8.20 3.24 (2022-02-15)
• SpatiaLite helpers for the sqlite-utils command-line tool - thanks, Chris Amico. (#398)
- sqlite-utils create-database --init-spatialite option for initializing SpatiaLite on a newly created database.
- sqlite-utils add-geometry-column command for adding geometry columns. - sqlite-utils create-spatial-index command for adding spatial indexes.
• db[table].create(..., if_not_exists=True) option for creating a table only if it does not already exist.
(#397)
1.8. Changelog
Database(memory_name="my_shared_database") parameter for creating a named in-memory database that can be shared between multiple connections. (#405)
• Documentation now describes how to add a primary key to a rowid table using sqlite-utils transform.
(#403)
1.8.21 3.23 (2022-02-03)
This release introduces four new utility methods for working with SpatiaLite. Thanks, Chris Amico. (#385)
• sqlite_utils.utils.find_spatialite() finds the location of the SpatiaLite module on disk.
• db.init_spatialite() initializes SpatiaLite for the given database.
• table.add_geometry_column(...) adds a geometry column to an existing table.
• table.create_spatial_index(...) creates a spatial index for a column.
• sqlite-utils batch now accepts a --batch-size option. (#392)
1.8.22 3.22.1 (2022-01-25)
• All commands now include example usage in their --help - see CLI reference. (#384)
• Python library documentation has a new Getting started section. (#387)
• Documentation now uses Plausible analytics. (#389)
1.8.23 3.22 (2022-01-11)
• New CLI reference documentation page, listing the output of --help for every one of the CLI commands. (#383)
• sqlite-utils rows now has --limit and --offset options for paginating through data. (#381)
• sqlite-utils rows now has --where and -p options for filtering the table using a WHERE query, see Returning
all rows in a table. (#382)
1.8.24 3.21 (2022-01-10)
CLI and Python library improvements to help run ANALYZE after creating indexes or inserting rows, to gain better performance from the SQLite query planner when it runs against indexes.
Three new CLI commands: create-database, analyze and bulk.
More details and examples can be found in the annotated release notes.
• New sqlite-utils create-database command for creating new empty database files. (#348)
• New Python methods for running ANALYZE against a database, table or index: db.analyze() and table. analyze(), see Optimizing index usage with ANALYZE. (#366)
• New sqlite-utils analyze command for running ANALYZE using the CLI. (#379)
• The create-index, insert and upsert commands now have a new --analyze option for running ANALYZE after the command has completed. (#379)
• New sqlite-utils bulk command which can import records in the same way as sqlite-utils insert (from JSON, CSV or TSV) and use them to bulk execute a parametrized SQL query. (#375)

The CLI tool can now also be run using python -m sqlite_utils. (#368)
• Using --fmt now implies --table, so you don't need to pass both options. (#374)
• The --convert function applied to rows can now modify the row in place. (#371)
• The insert-files command supports two new columns: stem and suffix. (#372)
• The --nl import option now ignores blank lines in the input. (#376)
• Fixed bug where streaming input to the insert command with --batch-size 1 would appear to only commit after several rows had been ingested, due to unnecessary input buffering. (#364)
1.8.25 3.20 (2022-01-05)
• sqlite-utils insert ... --lines to insert the lines from a file into a table with a single line column, see Inserting unstructured data with --lines and --text.
• sqlite-utils insert ... --text to insert the contents of the file into a table with a single text column and a single row.
• sqlite-utils insert ... --convert allows a Python function to be provided that will be used to convert each row that is being inserted into the database. See Applying conversions while inserting data, including details on special behavior when combined with --lines and --text. (#356)
• sqlite-utils convert now accepts a code value of - to read code from standard input. (#353)
• sqlite-utils convert also now accepts code that defines a named convert(value) function, see Converting data in columns.
• db.supports_strict property showing if the database connection supports SQLite strict tables.
• table.strict property (see .strict) indicating if the table uses strict mode. (#344)
• Fixed bug where sqlite-utils upsert ... --detect-types ignored the --detect-types option.
(#362)
1.8.26 3.19 (2021-11-20)
• The table.lookup() method now accepts keyword arguments that match those on the underlying table. insert() method: foreign_keys=, column_order=, not_null=, defaults=, extracts=, conversions= and columns=. You can also now pass pk= to specify a different column name to use for the primary key. (#342)
1.8.27 3.18 (2021-11-14)
• The table.lookup() method now has an optional second argument which can be used to populate columns only the first time the record is created, see Working with lookup tables. (#339)
• sqlite-utils memory now has a --flatten option for flattening nested JSON objects into separate columns, consistent with sqlite-utils insert. (#332)
• table.create_index(..., find_unique_name=True) parameter, which finds an available name for the created index even if the default name has already been taken. This means that index-foreign-keys will work even if one of the indexes it tries to create clashes with an existing index name. (#335)
• Added py.typed to the module, so mypy should now correctly pick up the type annotations. Thanks, Andreas Longo. (#331)
• Now depends on python-dateutil instead of depending on dateutils. Thanks, Denys Pavlov. (#324)
1.8. Changelog
table.create() (see Explicitly creating a table) now handles dict, list and tuple types, mapping them to TEXT columns in SQLite so that they can be stored encoded as JSON. (#338)
• Inserted data with square braces in the column names (for example a CSV file containing a item[price]) column now have the braces converted to underscores: item_price_. Previously such columns would be rejected with an error. (#329)
• Now also tested against Python 3.10. (#330)
1.8.28 3.17.1 (2021-09-22)
• sqlite-utils memory now works if files passed to it share the same file name. (#325)
• sqlite-utils query now returns [] in JSON mode if no rows are returned. (#328)
1.8.29 3.17 (2021-08-24)
• The sqlite-utils memory command has a new --analyze option, which runs the equivalent of the analyze-tables command directly against the in-memory database created from the incoming CSV or JSON data. (#320)
• sqlite-utils insert-files now has the ability to insert file contents in to TEXT columns in addition to the default BLOB. Pass the --text option or use content_text as a column specifier. (#319)
1.8.30 3.16 (2021-08-18)
• Type	signatures	added	to	more	methods,	including table.resolve_foreign_keys(), db. create_table_sql(), db.create_table() and table.create(). (#314)
• New db.quote_fts(value) method, see Quoting characters for use in search - thanks, Mark Neumann. (#246)
• table.search() now accepts an optional quote=True parameter. (#296)
• CLI command sqlite-utils search now accepts a --quote option. (#296)
• Fixed bug where --no-headers and --tsv options to sqlite-utils insert could not be used together. (#295)
• Various small improvements to API reference documentation.
1.8.31 3.15.1 (2021-08-10)
• Python library now includes type annotations on almost all of the methods, plus detailed docstrings describing each one. (#311)
• New API reference documentation page, powered by those docstrings.
• Fixed bug where .add_foreign_keys() failed to raise an error if called against a View. (#313)
• Fixed bug where .delete_where() returned a [] instead of returning self if called against a non-existent table. (#315)
1.8.32 3.15 (2021-08-09)
• sqlite-utils insert --flatten option for flattening nested JSON objects to create tables with column names like topkey_nestedkey. (#310)
• Fixed several spelling mistakes in the documentation, spotted using codespell.
• Errors that occur while using the sqlite-utils CLI tool now show the responsible SQL and query parameters, if possible. (#309)
1.8.33 3.14 (2021-08-02)
This release introduces the new sqlite-utils convert command (#251) and corresponding table.convert(...) Python method (#302). These tools can be used to apply a Python conversion function to one or more columns of a table, either updating the column in place or using transformed data from that column to populate one or more other columns.
This command-line example uses the Python standard library textwrap module to wrap the content of the content column in the articles table to 100 characters:

The same operation in Python code looks like this:

See the full documentation for the sqlite-utils convert command and the table.convert(...) Python method for more details.
Also in this release:
• The new table.count_where(...) method, for counting rows in a table that match a specific SQL WHERE clause. (#305)
• New --silent option for the sqlite-utils insert-files command to hide the terminal progress bar, consistent with the --silent option for sqlite-utils convert. (#301)
1.8.34 3.13 (2021-07-24)
• sqlite-utils schema my.db table1 table2 command now accepts optional table names. (#299)
• sqlite-utils memory --help now describes the --schema option.
1.8. Changelog

1.8.35 3.12 (2021-06-25)
• New db.query(sql, params) method, which executes a SQL query and returns the results as an iterator over Python dictionaries. (#290)
• This project now uses flake8 and has started to use mypy. (#291)
• New documentation on contributing to this project. (#292)
1.8.36 3.11 (2021-06-20)
• New sqlite-utils memory data.csv --schema option, for outputting the schema of the in-memory database generated from one or more files. See --schema, --analyze, --dump and --save. (#288)
• Added installation instructions. (#286)
1.8.37 3.10 (2021-06-19)
This release introduces the sqlite-utils memory command, which can be used to load CSV or JSON data into a temporary in-memory database and run SQL queries (including joins across multiple files) directly against that data.
Also new: sqlite-utils insert --detect-types, sqlite-utils dump, table.use_rowid plus some smaller fixes. sqlite-utils memory
This example of sqlite-utils memory retrieves information about the all of the repositories in the Dogsheep organization on GitHub using this JSON API, sorts them by their number of stars and outputs a table of the top five (using -t):

The tool works against files on disk as well. This example joins data from two CSV files:

(continued from previous page)
1,Dog
2,Chicken
$ sqlite-utils memory species.csv creatures.csv ' select * from creatures join species on creatures.species_id = species.id
'
[{"species_id": 1, "name": "Cleo", "id": 1, "species_name": "Dog"},
{"species_id": 2, "name": "Bants", "id": 2, "species_name": "Chicken"},
{"species_id": 2, "name": "Dori", "id": 2, "species_name": "Chicken"},
{"species_id": 2, "name": "Azi", "id": 2, "species_name": "Chicken"}]
Here the species.csv file becomes the species table, the creatures.csv file becomes the creatures table and the output is JSON, the default output format.
You can also use the --attach option to attach existing SQLite database files to the in-memory database, in order to join data from CSV or JSON directly against your existing tables.
Full documentation of this new feature is available in Querying data directly using an in-memory database. (#272) sqlite-utils insert --detect-types
The sqlite-utils insert command can be used to insert data from JSON, CSV or TSV files into a SQLite database file. The new --detect-types option (shortcut -d), when used in conjunction with a CSV or TSV import, will automatically detect if columns in the file are integers or floating point numbers as opposed to treating everything as a text column and create the new table with the corresponding schema. See Inserting CSV or TSV data for details. (#282)
Other changes
• Bug fix: table.transform(), when run against a table without explicit primary keys, would incorrectly create a new version of the table with an explicit primary key column called rowid. (#284)
• New table.use_rowid introspection property, see .use_rowid. (#285)
• The new sqlite-utils dump file.db command outputs a SQL dump that can be used to recreate a database. (#274)
• -h now works as a shortcut for --help, thanks Loren McIntyre. (#276)
• Now using pytest-cov and Codecov to track test coverage - currently at 96%. (#275)
• SQL errors that occur when using sqlite-utils query are now displayed as CLI errors.
1.8.38 3.9.1 (2021-06-12)
• Fixed bug when using table.upsert_all() to create a table with only a single column that is treated as the primary key. (#271)
1.8. Changelog
1.8.39 3.9 (2021-06-11)
• New sqlite-utils schema command showing the full SQL schema for a database, see Showing the schema (CLI). (#268)
• db.schema introspection property exposing the same feature to the Python library, see Showing the schema (Python library).
1.8.40 3.8 (2021-06-02)
• New sqlite-utils indexes command to list indexes in a database, see Listing indexes. (#263)
• table.xindexes introspection property returning more details about that table's indexes, see .xindexes. (#261)
1.8.41 3.7 (2021-05-28)
• New table.pks_and_rows_where() method returning (primary_key, row_dictionary) tuples - see Listing rows with their primary keys. (#240)
• Fixed bug with table.add_foreign_key() against columns containing spaces. (#238)
• table_or_view.drop(ignore=True) option for avoiding errors if the table or view does not exist. (#237)
• sqlite-utils drop-view --ignore and sqlite-utils drop-table --ignore options. (#237)
• Fixed a bug with inserts of nested JSON containing non-ascii strings - thanks, Dylan Wu. (#257)
• Suggest --alter if an error occurs caused by a missing column. (#259)
• Support creating indexes with columns in descending order, see API documentation and CLI documentation. (#260)
• Correctly handle CSV files that start with a UTF-8 BOM. (#250)
1.8.42 3.6 (2021-02-18)
This release adds the ability to execute queries joining data from more than one database file - similar to the cross database querying feature introduced in Datasette 0.55.
• The db.attach(alias, filepath) Python method can be used to attach extra databases to the same connection, see db.attach() in the Python API documentation. (#113)
• The --attach option attaches extra aliased databases to run SQL queries against directly on the command-line, see attaching additional databases in the CLI documentation. (#236)
1.8.43 3.5 (2021-02-14)
• sqlite-utils insert --sniff option for detecting the delimiter and quote character used by a CSV file, see Alternative delimiters and quote characters. (#230)
• The table.rows_where(), table.search() and table.search_sql() methods all now take optional offset= and limit= arguments. (#231)
• New --no-headers option for sqlite-utils insert --csv to handle CSV files that are missing the header row, see CSV files without a header row. (#228)
• Fixed bug where inserting data with extra columns in subsequent chunks would throw an error. Thanks @nieuwenhoven for the fix. (#234)
• Fixed bug importing CSV files with columns containing more than 128KB of data. (#229)
• Test suite now runs in CI against Ubuntu, macOS and Windows. Thanks @nieuwenhoven for the Windows test fixes. (#232)
1.8.44 3.4.1 (2021-02-05)
• Fixed a code import bug that slipped in to 3.4. (#226)
1.8.45 3.4 (2021-02-05)
• sqlite-utils insert --csv now accepts optional --delimiter and --quotechar options. See Alterna-
tive delimiters and quote characters. (#223)
1.8.46 3.3 (2021-01-17)
• The table.m2m() method now accepts an optional alter=True argument to specify that any missing columns should be added to the referenced table. See Working with many-to-many relationships. (#222)
1.8.47 3.2.1 (2021-01-12)
• Fixed a bug where .add_missing_columns() failed to take case insensitive column names into account. (#221)
1.8.48 3.2 (2021-01-03)
This release introduces a new mechanism for speeding up count(*) queries using cached table counts, stored in a _counts table and updated by triggers. This mechanism is described in Cached table counts using triggers, and can be enabled using Python API methods or the new enable-counts CLI command. (#212)
• table.enable_counts() method for enabling these triggers on a specific table.
• db.enable_counts() method for enabling triggers on every table in the database. (#213)
• New sqlite-utils enable-counts my.db command for enabling counts on all or specific tables, see Enabling cached counts. (#214)
• New sqlite-utils triggers command for listing the triggers defined for a database or specific tables, see Listing triggers. (#218)
• New db.use_counts_table property which, if True, causes table.count to read from the _counts table. (#215)
• table.has_counts_triggers property revealing if a table has been configured with the new _counts database triggers.
• db.reset_counts() method and sqlite-utils reset-counts command for resetting the values in the _counts table. (#219)
• The previously undocumented db.escape() method has been renamed to db.quote() and is now covered by the documentation: Quoting strings for use in SQL. (#217)
• New table.triggers_dict and db.triggers_dict introspection properties. (#211, #216)
1.8. Changelog
• sqlite-utils insert now shows a more useful error message for invalid JSON. (#206)
1.8.49 3.1.1 (2021-01-01)
• Fixed failing test caused by optimize sometimes creating larger database files. (#209)
• Documentation now lives on https://sqlite-utils.datasette.io/
• README now includes brew install sqlite-utils installation method.
1.8.50 3.1 (2020-12-12)
• New command: sqlite-utils analyze-tables my.db outputs useful information about the table columns in the database, such as the number of distinct values and how many rows are null. See Analyzing tables for documentation. (#207)
• New table.analyze_column(column) Python method used by the analyze-tables command - see Analyzing a column.
• The table.update() method now correctly handles values that should be stored as JSON. Thanks, Andreas
Madsack. (#204)
1.8.51 3.0 (2020-11-08)
This release introduces a new sqlite-utils search command for searching tables, see Executing searches. (#192) The table.search() method has been redesigned, see Searching with table.search(). (#197)
The release includes minor backwards-incompatible changes, hence the version bump to 3.0. Those changes, which should not affect most users, are:
• The -c shortcut option for outputting CSV is no longer available. The full --csv option is required instead.
• The -f shortcut for --fmt has also been removed - use --fmt.
• The table.search() method now defaults to sorting by relevance, not sorting by rowid. (#198)
• The table.search() method now returns a generator over a list of Python dictionaries. It previously returned a list of tuples. Also in this release:
• The query, tables, rows and search CLI commands now accept a new --tsv option which outputs the results in TSV. (#193)
• A new table.virtual_table_using property reveals if a table is a virtual table, and returns the upper case type of virtual table (e.g. FTS4 or FTS5) if it is. It returns None if the table is not a virtual table. (#196)
• The new table.search_sql() method returns the SQL for searching a table, see Building SQL queries with table.search_sql().
• sqlite-utils rows now accepts multiple optional -c parameters specifying the columns to return. (#200) Changes since the 3.0a0 alpha release:
• The sqlite-utils search command now defaults to returning every result, unless you add a --limit 20 option.
• The sqlite-utils search -c and table.search(columns=[]) options are now fully respected. (#201)
1.8.52 2.23 (2020-10-28)
• table.m2m(other_table, records) method now takes any iterable, not just a list or tuple. Thanks, Adam Wolf. (#189)
• sqlite-utils insert now displays a progress bar for CSV or TSV imports. (#173)
• New @db.register_function(deterministic=True) option for registering deterministic SQLite functions
in Python 3.8 or higher. (#191)
1.8.53 2.22 (2020-10-16)
• New --encoding option for processing CSV and TSV files that use a non-utf-8 encoding, for both the insert and update commands. (#182)
• The --load-extension option is now available to many more commands. (#137)
• --load-extension=spatialite can be used to load SpatiaLite from common installation locations, if it is available. (#136)
• Tests now also run against Python 3.9. (#184)
• Passing pk=["id"] now has the same effect as passing pk="id". (#181)
1.8.54 2.21 (2020-09-24)
• table.extract() and sqlite-utils extract now apply much, much faster - one example operation reduced from twelve minutes to just four seconds! (#172)
• sqlite-utils extract no longer shows a progress bar, because it's fast enough not to need one.
• New column_order= option for table.transform() which can be used to alter the order of columns in a table. (#175)
• sqlite-utils transform --column-order= option (with a -o shortcut) for changing column order. (#176)
• The table.transform(drop_foreign_keys=) parameter and the sqlite-utils transform --drop-foreign-key option have changed. They now accept just the name of the column rather than requiring all three of the column, other table and other column. This is technically a backwards-incompatible change but I chose not to bump the major version number because the transform feature is so new. (#177)
• The	table .disable_fts(),	.rebuild_fts(),	.delete(),	.delete_where() and . add_missing_columns() methods all now return self,	which means they can be chained together with other table operations.
1.8.55 2.20 (2020-09-22)
This release introduces two key new capabilities: transform (#114) and extract (#42).
1.8. Changelog
Transform
SQLite's ALTER TABLE has several documented limitations. The table.transform() Python method and sqlite-utils transform CLI command work around these limitations using a pattern where a new table with the desired structure is created, data is copied over to it and the old table is then dropped and replaced by the new one. You can use these tools to change column types, rename columns, drop columns, add and remove NOT NULL and defaults, remove foreign key constraints and more. See the transforming tables (CLI) and transforming tables (Python library) documentation for full details of how to use them.
Extract
Sometimes a database table - especially one imported from a CSV file - will contain duplicate data. A Trees table may include a Species column with only a few dozen unique values, when the table itself contains thousands of rows.
The table.extract() method and sqlite-utils extract commands can extract a column - or multiple columns - out into a separate lookup table, and set up a foreign key relationship from the original table.
The Python library extract() documentation describes how extraction works in detail, and Extracting columns into a separate table in the CLI documentation includes a detailed example.
Other changes
• The @db.register_function decorator can be used to quickly register Python functions as custom SQL functions, see Registering custom SQL functions. (#162)
• The table.rows_where() method now accepts an optional select= argument for specifying which columns should be selected, see Listing rows.
1.8.56 2.19 (2020-09-20)
• New sqlite-utils add-foreign-keys command for Adding multiple foreign keys at once. (#157)
• New table.enable_fts(..., replace=True) argument for replacing an existing FTS table with a new configuration. (#160)
• New table.add_foreign_key(..., ignore=True) argument for ignoring a foreign key if it already exists.
(#112)
1.8.57 2.18 (2020-09-08)
• table.rebuild_fts() method for rebuilding a FTS index, see Rebuilding a full-text search table. (#155)
• sqlite-utils rebuild-fts data.db command for rebuilding FTS indexes across all tables, or just specific tables. (#155)
• table.optimize() method no longer deletes junk rows from the *_fts_docsize table. This was added in
2.17 but it turns out running table.rebuild_fts() is a better solution to this problem.
• Fixed a bug where rows with additional columns that are inserted after the first batch of records could cause an error due to breaking SQLite's maximum number of parameters. Thanks, Simon Wiles. (#145)
1.8.58 2.17 (2020-09-07)
This release handles a bug where replacing rows in FTS tables could result in growing numbers of unnecessary rows in the associated *_fts_docsize table. (#149)
• PRAGMA recursive_triggers=on by default for all connections. You can turn it off with Database(recursive_triggers=False). (#152)
• table.optimize() method now deletes unnecessary rows from the *_fts_docsize table. (#153)
• New tracer method for tracking underlying SQL queries, see Tracing queries. (#150)
• Neater indentation for schema SQL. (#148)
• Documentation for sqlite_utils.AlterError exception thrown by in add_foreign_keys().
1.8.59 2.16.1 (2020-08-28)
• insert_all(..., alter=True) now works for columns introduced after the first 100 records. Thanks, Simon Wiles! (#139)
• Continuous Integration is now powered by GitHub Actions. (#143)
1.8.60 2.16 (2020-08-21)
• --load-extension option for sqlite-utils query for loading SQLite extensions. (#134)
• New sqlite_utils.utils.find_spatialite() function for finding SpatiaLite in common locations.
(#135)
1.8.61 2.15.1 (2020-08-12)
• Now available as a sdist package on PyPI in addition to a wheel. (#133)
1.8.62 2.15 (2020-08-10)
• New db.enable_wal() and db.disable_wal() methods for enabling and disabling Write-Ahead Logging for a database file - see WAL mode in the Python API documentation.
• Also sqlite-utils enable-wal file.db and sqlite-utils disable-wal file.db commands for do-
ing the same thing on the command-line, see WAL mode (CLI). (#132)
1.8.63 2.14.1 (2020-08-05)
• Documentation improvements.
1.8. Changelog
1.8.64 2.14 (2020-08-01)
• The insert-files command can now read from standard input: cat dog.jpg | sqlite-utils insert-files dogs.db pics - --name=dog.jpg. (#127)
• You can now specify a full-text search tokenizer using the new tokenize= parameter to enable_fts(). This means you can enable Porter stemming on a table by running db["articles"].enable_fts(["headline", "body"], tokenize="porter"). (#130)
• You can also set a custom tokenizer using the sqlite-utils enable-fts CLI command, via the new --tokenize option.
1.8.65 2.13 (2020-07-29)
• memoryview and uuid.UUID objects are now supported. memoryview objects will be stored using BLOB and uuid.UUID objects will be stored using TEXT. (#128)
1.8.66 2.12 (2020-07-27)
The theme of this release is better tools for working with binary data. The new insert-files command can be used to insert binary files directly into a database table, and other commands have been improved with better support for BLOB columns.
• sqlite-utils insert-files my.db gifs *.gif can now insert the contents of files into a specified table. The columns in the table can be customized to include different pieces of metadata derived from the files. See Inserting data from files. (#122)
• --raw option to sqlite-utils query - for outputting just a single raw column value - see Returning raw data, such as binary content. (#123)
• JSON output now encodes BLOB values as special base64 objects - see Returning JSON. (#125)
• The same format of JSON base64 objects can now be used to insert binary data - see Inserting JSON data. (#126)
• The sqlite-utils query command can now accept named parameters, e.g. sqlite-utils :memory:
"select :num * :num2" -p num 5 -p num2 6 - see Returning JSON. (#124)
1.8.67 2.11 (2020-07-08)
• New --truncate option to sqlite-utils insert, and truncate=True argument to .insert_all(). Thanks, Thomas Sibley. (#118)
• The sqlite-utils query command now runs updates in a transaction. Thanks, Thomas Sibley. (#120)
1.8.68 2.10.1 (2020-06-23)
• Added documentation for the table.pks introspection property. (#116)
1.8.69 2.10 (2020-06-12)
• The sqlite-utils command now supports UPDATE/INSERT/DELETE in addition to SELECT. (#115)
1.8.70 2.9.1 (2020-05-11)
• Added custom project links to the PyPI listing.
1.8.71 2.9 (2020-05-10)
• New sqlite-utils drop-table command, see Dropping tables. (#111)
• New sqlite-utils drop-view command, see Dropping views.
• Python decimal.Decimal objects are now stored as FLOAT. (#110)
1.8.72 2.8 (2020-05-03)
• New sqlite-utils create-table command, see Creating tables. (#27)
• New sqlite-utils create-view command, see Creating views. (#107)
1.8.73 2.7.2 (2020-05-02)
• db.create_view(...) now has additional parameters ignore=True or replace=True, see Creating views.
(#106)
1.8.74 2.7.1 (2020-05-01)
• New sqlite-utils views my.db command for listing views in a database, see Listing views. (#105)
• sqlite-utils tables (and views) has a new --schema option which outputs the table/view schema, see Listing tables. (#104)
• Nested structures containing invalid JSON values (e.g. Python bytestrings) are now serialized using repr() instead of throwing an error. (#102)
1.8.75 2.7 (2020-04-17)
• New columns= argument for the .insert(), .insert_all(), .upsert() and .upsert_all() methods, for over-riding the auto-detected types for columns and specifying additional columns that should be added when the table is created. See Custom column order and column types. (#100)
1.8. Changelog
1.8.76 2.6 (2020-04-15)
• New table.rows_where(..., order_by="age desc") argument, see Listing rows. (#76)
1.8.77 2.5 (2020-04-12)
• Panda's Timestamp is now stored as a SQLite TEXT column. Thanks, b0b5h4rp13! (#96)
• table.last_pk is now only available for inserts or upserts of a single record. (#98)
• New Database(filepath, recreate=True) parameter for deleting and recreating the database. (#97)
1.8.78 2.4.4 (2020-03-23)
• Fixed bug where columns with only null values were not correctly created. (#95)
1.8.79 2.4.3 (2020-03-23)
• Column type suggestion code is no longer confused by null values. (#94)
1.8.80 2.4.2 (2020-03-14)
• table.column_dicts now works with all column types - previously it would throw errors on types other than TEXT, BLOB, INTEGER or FLOAT. (#92)
• Documentation for NotFoundError thrown by table.get(pk) - see Retrieving a specific record.
1.8.81 2.4.1 (2020-03-01)
• table.enable_fts() now works with columns that contain spaces. (#90)
1.8.82 2.4 (2020-02-26)
• table.disable_fts() can now be used to remove FTS tables and triggers that were created using table. enable_fts(...). (#88)
• The sqlite-utils disable-fts command can be used to remove FTS tables and triggers from the commandline. (#88)
• Trying to create table columns with square braces ([ or ]) in the name now raises an error. (#86)
• Subclasses of dict, list and tuple are now detected as needing a JSON column. (#87)
1.8.83 2.3.1 (2020-02-10)
table.create_index() now works for columns that contain spaces. (#85)
1.8.84 2.3 (2020-02-08)
table.exists() is now a method, not a property. This was not a documented part of the API before so I'm considering this a non-breaking change. (#83)
1.8.85 2.2.1 (2020-02-06)
Fixed a bug where .upsert(..., hash_id="pk") threw an error (#84).
1.8.86 2.2 (2020-02-01)
New feature: sqlite_utils.suggest_column_types([records]) returns the suggested column types for a list of records. See Suggesting column types. (#81).
This replaces the undocumented table.detect_column_types() method.
1.8.87 2.1 (2020-01-30)
New feature: conversions={...} can be passed to the .insert() family of functions to specify SQL conversions that should be applied to values that are being inserted or updated. See Converting column values using SQL functions . (#77).
1.8.88 2.0.1 (2020-01-05)
The .upsert() and .upsert_all() methods now raise a sqlite_utils.db.PrimaryKeyRequired exception if you call them without specifying the primary key column using pk= (#73).
1.8.89 2.0 (2019-12-29)
This release changes the behaviour of upsert. It's a breaking change, hence 2.0.
The upsert command-line utility and the .upsert() and .upsert_all() Python API methods have had their behaviour altered. They used to completely replace the affected records: now, they update the specified values on existing records but leave other columns unaffected.
See Upserting data using the Python API and Upserting data using the CLI for full details. If you want the old behaviour - where records were completely replaced - you can use $ sqlite-utils insert ... --replace on the command-line and .insert(..., replace=True) and .insert_all(..., replace=True) in the Python API. See Insert-replacing data using the Python API and Insert-replacing data using the CLI for more. For full background on this change, see issue #66.
1.8. Changelog
1.8.90 1.12.1 (2019-11-06)
• Fixed error thrown when .insert_all() and .upsert_all() were called with empty lists (#52)
1.8.91 1.12 (2019-11-04)
Python library utilities for deleting records (#62)
• db["tablename"].delete(4) to delete by primary key, see Deleting a specific record
• db["tablename"].delete_where("id > ?", [3]) to delete by a where clause, see Deleting multiple records
1.8.92 1.11 (2019-09-02)
Option to create triggers to automatically keep FTS tables up-to-date with newly inserted, updated and deleted records.
Thanks, Amjith Ramanujam! (#57)
• sqlite-utils enable-fts ... --create-triggers - see Configuring full-text search using the CLI
• db["tablename"].enable_fts(..., create_triggers=True) - see Configuring full-text search using the Python library
• Support for introspecting triggers for a database or table - see Introspecting tables and views (#59)
1.8.93 1.10 (2019-08-23)
Ability to introspect and run queries against views (#54)
   • db.view_names() method and and db.views property
   • Separate View and Table classes, both subclassing new Queryable class
   • view.drop() method See Listing views.
1.8.94 1.9 (2019-08-04)
• table.m2m(...) method for creating many-to-many relationships: Working with many-to-many relationships
(#23)
1.8.95 1.8 (2019-07-28)
• table.update(pk, values) method: Updating a specific record (#35)
1.8.96 1.7.1 (2019-07-28)
• Fixed bug where inserting records with 11 columns in a batch of 100 triggered a "too many SQL variables" error (#50)
• Documentation and tests for table.drop() method: Dropping a table or view
1.8.97 1.7 (2019-07-24)
Support for lookup tables.
• New table.lookup({...}) utility method for building and querying lookup tables - see Working with lookup tables (#44)
• New extracts= table configuration option, see Populating lookup tables automatically during insert/upsert (#46)
• Use pysqlite3 if it is available, otherwise use sqlite3 from the standard library
• Table options can now be passed to the new db.table(name, **options) factory function in addition to being passed to insert_all(records, **options) and friends - see Table configuration options
• In-memory databases can now be created using db = Database(memory=True)
1.8.98 1.6 (2019-07-18)
• sqlite-utils insert can now accept TSV data via the new --tsv option (#41)
1.8.99 1.5 (2019-07-14)
• Support for compound primary keys (#36)
- Configure these using the CLI tool by passing --pk multiple times
- In Python, pass a tuple of columns to the pk=(..., ...) argument: Compound primary keys
• New table.get() method for retrieving a record by its primary key: Retrieving a specific record (#39)
1.8.100 1.4.1 (2019-07-14)
• Assorted minor documentation fixes: changes since 1.4
1.8.101 1.4 (2019-06-30)
• Added sqlite-utils index-foreign-keys command (docs) and db.index_foreign_keys() method
(docs) (#33)
1.8. Changelog
1.8.102 1.3 (2019-06-28)
• New mechanism for adding multiple foreign key constraints at once: db.add_foreign_keys() documentation (#31)
1.8.103 1.2.2 (2019-06-25)
• Fixed bug where datetime.time was not being handled correctly
1.8.104 1.2.1 (2019-06-20)
• Check the column exists before attempting to add a foreign key (#29)
1.8.105 1.2 (2019-06-12)
• Improved foreign key definitions: you no longer need to specify the column, other_table AND other_column to define a foreign key - if you omit the other_table or other_column the script will attempt to guess the correct values by introspecting the database. See Adding foreign key constraints for details. (#25)
• Ability to set NOT NULL constraints and DEFAULT values when creating tables (#24). Documentation: Setting defaults and not null constraints (Python API), Setting defaults and not null constraints (CLI)
• Support for not_null_default=X / --not-null-default for setting a NOT NULL DEFAULT 'x' when
adding a new column. Documentation: Adding columns (Python API), Adding columns (CLI)
1.8.106 1.1 (2019-05-28)
• Support for ignore=True / --ignore for ignoring inserted records if the primary key already exists (#21) documentation: Inserting data (Python API), Inserting data (CLI)
• Ability to add a column that is a foreign key reference using fk=... / --fk (#16) - documentation: Adding columns (Python API), Adding columns (CLI)
1.8.107 1.0.1 (2019-05-27)
• sqlite-utils rows data.db table --json-cols - fixed bug where --json-cols was not obeyed
1.8.108 1.0 (2019-05-24)
• Option to automatically add new columns if you attempt to insert or upsert data with extra fields: sqlite-utils insert ... --alter - see Adding columns automatically with the sqlite-utils CLI db["tablename"].insert(record, alter=True) - see Adding columns automatically using the Python API
• New --json-cols option for outputting nested JSON, see Nested JSON values
1.8.109 0.14 (2019-02-24)
• Ability to create unique indexes: db["mytable"].create_index(["name"], unique=True)
• db["mytable"].create_index(["name"], if_not_exists=True)
• $ sqlite-utils create-index mydb.db mytable col1 [col2...], see Creating indexes
• table.add_column(name, type) method, see Adding columns
• $ sqlite-utils add-column mydb.db mytable nameofcolumn, see Adding columns (CLI)
• db["books"].add_foreign_key("author_id", "authors", "id"), see Adding foreign key constraints
• $ sqlite-utils add-foreign-key books.db books author_id authors id, see Adding foreign key constraints (CLI)
• Improved (but backwards-incompatible) foreign_keys= argument to various methods, see Specifying foreign keys
1.8.110 0.13 (2019-02-23)
• New --table and --fmt options can be used to output query results in a variety of visual table formats, see Table-formatted output
• New hash_id= argument can now be used for Setting an ID based on the hash of the row contents
• Can now derive correct column types for numpy int, uint and float values
• table.last_id has been renamed to table.last_rowid
• table.last_pk now contains the last inserted primary key, if pk= was specified
• Prettier indentation in the CREATE TABLE generated schemas
1.8.111 0.12 (2019-02-22)
• Added db[table].rows iterator - see Listing rows
• Replaced sqlite-utils json and sqlite-utils csv with	a	new	default	subcommand	called sqlite-utils query which defaults to JSON and takes formatting options --nl, --csv and --no-headers - see Returning JSON and Returning CSV or TSV
• New sqlite-utils rows data.db name-of-table command, see Returning all rows in a table • sqlite-utils table command now takes options --counts and --columns plus the standard output format
options, see Listing tables
1.8.112 0.11 (2019-02-07)
New commands for enabling FTS against a table and columns:

See Configuring full-text search.
1.8. Changelog
1.8.113 0.10 (2019-02-06)
Handle datetime.date and datetime.time values. New option for efficiently inserting rows from a CSV:

1.8.114 0.9 (2019-01-27)
Improved support for newline-delimited JSON.
sqlite-utils insert has two new command-line options:
• --nl means "expect newline-delimited JSON". This is an extremely efficient way of loading in large amounts of data, especially if you pipe it into standard input.
• --batch-size=1000 lets you increase the batch size (default is 100). A commit will be issued every X records. This also control how many initial records are considered when detecting the desired SQL table schema for the data.
In the Python API, the table.insert_all(...) method can now accept a generator as well as a list of objects. This will be efficiently used to populate the table no matter how many records are produced by the generator.
The Database() constructor can now accept a pathlib.Path object in addition to a string or an existing SQLite connection object.
1.8.115 0.8 (2019-01-25)
Two new commands: sqlite-utils csv and sqlite-utils json
These commands execute a SQL query and return the results as CSV or JSON. See Returning CSV or TSV and Returning JSON for more details.

1.8.116 0.7 (2019-01-24)
This release implements the sqlite-utils command-line tool with a number of useful subcommands.
• sqlite-utils tables demo.db lists the tables in the database
• sqlite-utils tables demo.db --fts4 shows just the FTS4 tables
• sqlite-utils tables demo.db --fts5 shows just the FTS5 tables
• sqlite-utils vacuum demo.db runs VACUUM against the database
• sqlite-utils optimize demo.db runs OPTIMIZE against all FTS tables, then VACUUM
• sqlite-utils optimize demo.db --no-vacuum runs OPTIMIZE but skips VACUUM
The two most useful subcommands are upsert and insert, which allow you to ingest JSON files with one or more records in them, creating the corresponding table with the correct columns if it does not already exist. See Inserting JSON data for more details.
• sqlite-utils insert demo.db dogs dogs.json --pk=id inserts new records from dogs.json into the dogs table
• sqlite-utils upsert demo.db dogs dogs.json --pk=id upserts records, replacing any records with duplicate primary keys
One backwards incompatible change: the db["table"].table_names property is now a method:
• db["table"].table_names() returns a list of table names
• db["table"].table_names(fts4=True) returns a list of just the FTS4 tables
• db["table"].table_names(fts5=True) returns a list of just the FTS5 tables A few other changes:
• Plenty of updated documentation, including full coverage of the new command-line tool
• Allow column names to be reserved words (use correct SQL escaping)
• Added automatic column support for bytes and datetime.datetime
1.8.117 0.6 (2018-08-12)
• .enable_fts() now takes optional argument fts_version, defaults to FTS5. Use FTS4 if the version of SQLite bundled with your Python does not support FTS5
• New optional column_order= argument to .insert() and friends for providing a partial or full desired order of the columns when a database table is created
• New documentation for .insert_all() and .upsert() and .upsert_all()
1.8. Changelog
1.8.118 0.5 (2018-08-05)
• db.tables and db.table_names introspection properties
• db.indexes property for introspecting indexes
• table.create_index(columns, index_name) method
• db.create_view(name, sql) method
• Table methods can now be chained, plus added table.last_id for accessing the last inserted row ID
1.8.119 0.4 (2018-07-31)
• enable_fts(), populate_fts() and search() table methods
1.8.120 0.3.1 (2018-07-31)
• Documented related projects
• Added badges to the documentation
1.8.121 0.3 (2018-07-31)
• New Table class representing a table in the SQLite database
1.8.122 0.2 (2018-07-28)
• Initial release to PyPI

Symbols
__getitem__() (sqlite_utils.db.Database method), 108
A
add_column() (sqlite_utils.db.Table method), 120 add_foreign_key() (sqlite_utils.db.Table method), 121 add_foreign_keys()	(sqlite_utils.db.Database method), 113
add_geometry_column()	(sqlite_utils.db.Table method), 128
analyze() (sqlite_utils.db.Database method), 114 analyze() (sqlite_utils.db.Table method), 127 analyze_column() (sqlite_utils.db.Table method), 127 attach() (sqlite_utils.db.Database method), 109
C
cached_counts() (sqlite_utils.db.Database	method),
        111 chunks() (in module sqlite_utils.utils), 132 close() (sqlite_utils.db.Database method), 108 Column (class in sqlite_utils.db), 129
ColumnDetails (class in sqlite_utils.db), 130 columns (sqlite_utils.db.Queryable property), 115 columns_dict (sqlite_utils.db.Queryable property), 115 convert() (sqlite_utils.db.Table method), 124 count (sqlite_utils.db.Queryable property), 115 count (sqlite_utils.db.Table property), 117 count_where() (sqlite_utils.db.Queryable method), 114 create() (sqlite_utils.db.Table method), 117 create_index() (sqlite_utils.db.Table method), 120 create_spatial_index() (sqlite_utils.db.Table method), 128
create_table() (sqlite_utils.db.Database method), 112 create_table_sql()	(sqlite_utils.db.Database method), 111
create_view() (sqlite_utils.db.Database method), 113
D
Database (class in sqlite_utils.db), 107 default_values (sqlite_utils.db.Table property), 117 delete() (sqlite_utils.db.Table method), 123 delete_where() (sqlite_utils.db.Table method), 123
INDEX
detect_fts() (sqlite_utils.db.Table method), 122 disable_fts() (sqlite_utils.db.Table method), 122 disable_wal() (sqlite_utils.db.Database method), 111 drop() (sqlite_utils.db.Table method), 121 drop() (sqlite_utils.db.View method), 129 duplicate() (sqlite_utils.db.Table method), 118
E
enable_counts() (sqlite_utils.db.Database	method),
        111 enable_counts() (sqlite_utils.db.Table method), 121 enable_fts() (sqlite_utils.db.Table method), 121 enable_fts() (sqlite_utils.db.View method), 129 enable_wal() (sqlite_utils.db.Database method), 111 ensure_autocommit_off() (sqlite_utils.db.Database method), 108
execute() (sqlite_utils.db.Database method), 109 executescript() (sqlite_utils.db.Database method),
        109 exists() (sqlite_utils.db.Queryable method), 114 exists() (sqlite_utils.db.Table method), 117 exists() (sqlite_utils.db.View method), 129 extract() (sqlite_utils.db.Table method), 120
F
find_spatialite() (in module sqlite_utils.utils), 102 flatten() (in module sqlite_utils.utils), 132 foreign_keys (sqlite_utils.db.Table property), 117
G
get() (sqlite_utils.db.Table method), 117 guess_foreign_table()	(sqlite_utils.db.Table method), 121
H
has_counts_triggers (sqlite_utils.db.Table property),
        121 hash_record() (in module sqlite_utils.utils), 130
I
index_foreign_keys()	(sqlite_utils.db.Database method), 113
indexes (sqlite_utils.db.Table property), 117 init_spatialite() (sqlite_utils.db.Database method),
        114 insert() (sqlite_utils.db.Table method), 124 insert_all() (sqlite_utils.db.Table method), 125 iterdump() (sqlite_utils.db.Database method), 114
J
journal_mode (sqlite_utils.db.Database property), 111
L
last_pk (sqlite_utils.db.Table attribute), 116 last_rowid (sqlite_utils.db.Table attribute), 116 lookup() (sqlite_utils.db.Table method), 126
M
m2m() (sqlite_utils.db.Table method), 127 m2m_table_candidates() (sqlite_utils.db.Database method), 113
O
optimize() (sqlite_utils.db.Table method), 122
P
pks (sqlite_utils.db.Table property), 117 pks_and_rows_where()	(sqlite_utils.db.Queryable method), 115
populate_fts() (sqlite_utils.db.Table method), 122
Q
query() (sqlite_utils.db.Database method), 109 Queryable (class in sqlite_utils.db), 114 quote() (sqlite_utils.db.Database method), 110 quote_default_value()	(sqlite_utils.db.Database method), 110
quote_fts() (sqlite_utils.db.Database method), 110
R
rebuild_fts() (sqlite_utils.db.Table method), 122 register_fts4_bm25()	(sqlite_utils.db.Database method), 109
register_function()	(sqlite_utils.db.Database method), 108 rename_table() (sqlite_utils.db.Database method), 113 reset_counts() (sqlite_utils.db.Database method), 111 rows (sqlite_utils.db.Queryable property), 115 rows_from_file() (in module sqlite_utils.utils), 131 rows_where() (sqlite_utils.db.Queryable method), 115
S
schema (sqlite_utils.db.Database property), 111 schema (sqlite_utils.db.Queryable property), 116 search() (sqlite_utils.db.Table method), 122 search_sql() (sqlite_utils.db.Table method), 122 sqlite_version (sqlite_utils.db.Database	property),
        111 strict (sqlite_utils.db.Table property), 117 supports_strict (sqlite_utils.db.Database property), 111
T
Table (class in sqlite_utils.db), 116 table() (sqlite_utils.db.Database method), 110 table_names() (sqlite_utils.db.Database method), 110 tables (sqlite_utils.db.Database property), 111 tracer() (sqlite_utils.db.Database method), 108 transform() (sqlite_utils.db.Table method), 118 transform_sql() (sqlite_utils.db.Table method), 119 triggers (sqlite_utils.db.Database property), 111 triggers (sqlite_utils.db.Table property), 117 triggers_dict (sqlite_utils.db.Database property), 111 triggers_dict (sqlite_utils.db.Table property), 117 types (sqlite_utils.utils.TypeTracker property), 132 TypeTracker (class in sqlite_utils.utils), 131
U
update() (sqlite_utils.db.Table method), 123 upsert() (sqlite_utils.db.Table method), 125 upsert_all() (sqlite_utils.db.Table method), 126 use_rowid (sqlite_utils.db.Table property), 117
V
vacuum() (sqlite_utils.db.Database method), 114 View (class in sqlite_utils.db), 129 view_names() (sqlite_utils.db.Database method), 110 views (sqlite_utils.db.Database property), 111 virtual_table_using (sqlite_utils.db.Table property), 117
W
wrap() (sqlite_utils.utils.TypeTracker method), 132
X
xindexes (sqlite_utils.db.Table property), 117
Index




























ii

i



i

sqlite-utils documentation, Release 3.38-4-g0aefbb6



2

1



1

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

	1.2. sqlite-utils command-line tool	5

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

	1.3. sqlite_utils Python library	51

sqlite-utils documentation, Release 3.38-4-g0aefbb6

	1.3. sqlite_utils Python library	51

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1.5. API reference	107

sqlite-utils documentation, Release 3.38-4-g0aefbb6

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

4	Chapter 1. Contents

(continues on next page)
1.6. CLI reference	135

sqlite-utils documentation, Release 3.38-4-g0aefbb6

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

(continues on next page)
1.6. CLI reference	135

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

(continues on next page)
1.6. CLI reference	135

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

(continues on next page)
1.6. CLI reference	135

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

(continues on next page)
136	Chapter 1. Contents

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

4	Chapter 1. Contents

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6
(continued from previous page)

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1.6. CLI reference	133

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6
•

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6
•

4	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6
•

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6
•

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

1

sqlite-utils documentation, Release 3.38-4-g0aefbb6

4	Chapter 1. Contents

sqlite-utils documentation, Release 3.38-4-g0aefbb6



2

1



1

