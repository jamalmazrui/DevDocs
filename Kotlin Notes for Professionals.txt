

Contents
About	1
Chapter 1: Getting started with Kotlin	2
Section 1.1: Hello World	2
Section 1.2: Hello World using a Companion Object	2
Section 1.3: Hello World using an Object Declaration	3
Section 1.4: Main methods using varargs	4
Section 1.5: Compile and Run Kotlin Code in Command Line	4
Section 1.6: Reading input from Command Line	4
Chapter 2: Basics of Kotlin	6
Section 2.1: Basic examples	6
Chapter 3: Strings	7
Section 3.1: String Equality	7
Section 3.2: String Literals	7
Section 3.3: Elements of String	8
Section 3.4: String Templates	8
Chapter 4: Arrays	9
Section 4.1: Generic Arrays	9
Section 4.2: Arrays of Primitives	9
Section 4.3: Create an array	9
Section 4.4: Create an array using a closure	9
Section 4.5: Create an uninitialized array	9
Section 4.6: Extensions	10
Section 4.7: Iterate Array	10
Chapter 5: Collections	11
Section 5.1: Using list	11
Section 5.2: Using map	11
Section 5.3: Using set	11
Chapter 6: Enum	12
Section 6.1: Initialization	12
Section 6.2: Functions and Properties in enums	12
Section 6.3: Simple enum	12
Section 6.4: Mutability	12
Chapter 7: Functions	14
Section 7.1: Function References	14
Section 7.2: Basic Functions	15
Section 7.3: Inline Functions	16
Section 7.4: Lambda Functions	16
Section 7.5: Operator functions	16
Section 7.6: Functions Taking Other Functions	17
Section 7.7: Shorthand Functions	17
Chapter 8: Vararg Parameters in Functions	18
Section 8.1: Basics: Using the vararg keyword	18
Section 8.2: Spread Operator: Passing arrays into vararg functions	18
Chapter 9: Conditional Statements	19
Section 9.1: When-statement argument matching	19
Section 9.2: When-statement as expression	19
Section 9.3: Standard if-statement	19
Section 9.4: If-statement as an expression	19
Section 9.5: When-statement instead of if-else-if chains	20
Section 9.6: When-statement with enums	20
Chapter 10: Loops in Kotlin	22
Section 10.1: Looping over iterables	22
Section 10.2: Repeat an action x times	22
Section 10.3: Break and continue	22
Section 10.4: Iterating over a Map in kotlin	23
Section 10.5: Recursion	23
Section 10.6: While Loops	23
Section 10.7: Functional constructs for iteration	23
Chapter 11: Ranges	25
Section 11.1: Integral Type Ranges	25
Section 11.2: downTo() function	25
Section 11.3: step() function	25
Section 11.4: until function	25
Chapter 12: Regex	26
Section 12.1: Idioms for Regex Matching in When Expression	26
Section 12.2: Introduction to regular expressions in Kotlin	27
Chapter 13: Basic Lambdas	30
Section 13.1: Lambda as parameter to filter function	30
Section 13.2: Lambda for benchmarking a function call	30
Section 13.3: Lambda passed as a variable	30
Chapter 14: Null Safety	31
Section 14.1: Smart casts	31
Section 14.2: Assertion	31
Section 14.3: Eliminate nulls from an Iterable and array	31
Section 14.4: Null Coalescing / Elvis Operator	31
Section 14.5: Nullable and Non-Nullable types	32
Section 14.6: Elvis Operator (?:)	32
Section 14.7: Safe call operator	32
Chapter 15: Class Delegation	34
Section 15.1: Delegate a method to another class	34
Chapter 16: Class Inheritance	35
Section 16.1: Basics: the 'open' keyword	35
Section 16.2: Inheriting fields from a class	35
Section 16.3: Inheriting methods from a class	36
Section 16.4: Overriding properties and methods	36
Chapter 17: Visibility Modifiers	38
Section 17.1: Code Sample	38
Chapter 18: Generics	39
Section 18.1: Declaration-site variance	39
Section 18.2: Use-site variance	39
Chapter 19: Interfaces	41
Section 19.1: Interface with default implementations	41
Section 19.2: Properties in Interfaces	42
Section 19.3: super keyword	42
Section 19.4: Basic Interface	42
Section 19.5: Conflicts when Implementing Multiple Interfaces with Default Implementations	43
Chapter 20: Singleton objects	44
Section 20.1: Use as replacement of static methods/fields of java	44
Section 20.2: Use as a singleton	44
Chapter 21: coroutines	45
Section 21.1: Simple coroutine which delay's 1 second but not blocks	45
Chapter 22: Annotations	46
Section 22.1: Meta-annotations	46
Section 22.2: Declaring an annotation	46
Chapter 23: Type aliases	47
Section 23.1: Function type	47
Section 23.2: Generic type	47
Chapter 24: Type-Safe Builders	48
Section 24.1: Type-safe tree structure builder	48
Chapter 25: Delegated properties	49
Section 25.1: Observable properties	49
Section 25.2: Custom delegation	49
Section 25.3: Lazy initialization	49
Section 25.4: Map-backed properties	49
Section 25.5: Delegate Can be used as a layer to reduce boilerplate	49
Chapter 26: Reflection	51
Section 26.1: Referencing a class	51
Section 26.2: Inter-operating with Java reflection	51
Section 26.3: Referencing a function	51
Section 26.4: Getting values of all properties of a class	51
Section 26.5: Setting values of all properties of a class	52
Chapter 27: Extension Methods	54
Section 27.1: Potential Pitfall: Extensions are Resolved Statically	54
Section 27.2: Top-Level Extensions	54
Section 27.3: Lazy extension property workaround	54
Section 27.4: Sample extending Java 7+ Path class	55
Section 27.5: Sample extending long to render a human readable string	55
Section 27.6: Sample extending Java 8 Temporal classes to render an ISO formatted string	55
Section 27.7: Using extension functions to improve readability	55
Section 27.8: Extension functions to Companion Objects (appearance of Static functions)	56
Section 27.9: Extensions for easier reference View from code	57
Chapter 28: DSL Building	58
Section 28.1: Infix approach to build DSL	58
Section 28.2: Using operators with lambdas	58
Section 28.3: Overriding invoke method to build DSL	58
Section 28.4: Using extensions with lambdas	58
Chapter 29: Idioms	60
Section 29.1: Serializable and serialVersionUid in Kotlin	60
Section 29.2: Delegate to a class without providing it in the public constructor	60
Section 29.3: Use let or also to simplify working with nullable objects	61
Section 29.4: Use apply to initialize objects or to achieve method chaining	61
Section 29.5: Fluent methods in Kotlin	61
Section 29.6: Filtering a list	62
Section 29.7: Creating DTOs (POJOs/POCOs)	62
Chapter 30: RecyclerView in Kotlin	63
Section 30.1: Main class and Adapter	63
Chapter 31: logging in kotlin	65
Section 31.1: kotlin.logging	65
Chapter 32: Exceptions	66
Section 32.1: Catching exception with try-catch-finally	66
Chapter 33: JUnit	67
Section 33.1: Rules	67
Chapter 34: Kotlin Android Extensions	68
Section 34.1: Using Views	68
Section 34.2: Configuration	68
Section 34.3: Painful listener for getting notice, when the view is completely drawn now is so simple andawesome with Kotlin's extension	69
Section 34.4: Product flavors	69
Chapter 35: Kotlin for Java Developers	71
Section 35.1: Declaring Variables	71
Section 35.2: Quick Facts	71
Section 35.3: Equality & Identity	71
Section 35.4: IF, TRY and others are expressions, not statements	72
Chapter 36: Java 8 Stream Equivalents	73
Section 36.1: Accumulate names in a List	73
Section 36.2: Collect example #5 - find people of legal age, output formatted string	73
Section 36.3: Collect example #6 - group people by age, print age and names together	73
Section 36.4: Dierent Kinds of Streams #7 - lazily iterate Doubles, map to Int, map to String, print each 	74
Section 36.5: Counting items in a list after filter is applied	75
Section 36.6: Convert elements to strings and concatenate them, separated by commas	75
Section 36.7: Compute sum of salaries of employee	75
Section 36.8: Group employees by department	75
Section 36.9: Compute sum of salaries by department	75
Section 36.10: Partition students into passing and failing	75
Section 36.11: Names of male members	76
Section 36.12: Group names of members in roster by gender	76
Section 36.13: Filter a list to another list	76
Section 36.14: Finding shortest string a list	76
Section 36.15: Dierent Kinds of Streams #2 - lazily using first item if exists	76
Section 36.16: Dierent Kinds of Streams #3 - iterate a range of Integers	77
Section 36.17: Dierent Kinds of Streams #4 - iterate an array, map the values, calculate the average 	77
Section 36.18: Dierent Kinds of Streams #5 - lazily iterate a list of strings, map the values, convert to Int,find max	77
Section 36.19: Dierent Kinds of Streams #6 - lazily iterate a stream of Ints, map the values, print results 	77
Section 36.20: How streams work - filter, upper case, then sort a list	78
Section 36.21: Dierent Kinds of Streams #1 - eager using first item if it exists	78
Section 36.22: Collect example #7a - Map names, join together with delimiter	78
Section 36.23: Collect example #7b - Collect with SummarizingInt	79
Chapter 37: Kotlin Caveats	81
Section 37.1: Calling a toString() on a nullable type	81
Appendix A: Configuring Kotlin build	82
Section A.1: Gradle configuration	82
Section A.2: Using Android Studio	83
Section A.3: Migrating from Gradle using Groovy script to Kotlin script	84
Credits	86
You may also like	88


About
Please feel free to share this PDF with anyone for free, latest version of this book can be downloaded from: https://goalkicker.com/KotlinBook
This Kotlin(r) Notes for Professionals book is compiled from Stack Overflow
Documentation, the content is written by the beautiful people at Stack Overflow.
Text content is released under Creative Commons BY-SA, see credits at the end of this book whom contributed to the various chapters. Images may be copyright of their respective owners unless otherwise specified
This is an unofficial free book created for educational purposes and is not affiliated with official Kotlin(r) group(s) or company(s) nor Stack Overflow. All
trademarks and registered trademarks are the property of their respective company owners
The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk
Please send feedback and corrections to web@petercv.com
Chapter 1: Getting started with Kotlin
Version Release Date
1.0.02016-02-151.0.12016-03-161.0.22016-05-131.0.32016-06-301.0.42016-09-221.0.52016-11-081.0.62016-12-271.1.02017-03-011.1.12017-03-141.1.22017-04-251.1.32017-06-231.1.62017-11-131.2.22018-01-171.2.32018-03-011.2.42018-04-19Section 1.1: Hello World
All Kotlin programs start at the main function. Here is an example of a simple Kotlin "Hello World" program:

Main.ktPlace the above code into a file named  (this filename is entirely arbitrary)
my.program.MainKtWhen targeting the JVM, the function will be compiled as a static method in a class with a name derived from the filename. In the above example, the main class to run would be .
To change the name of the class that contains top-level functions for a particular file, place the following annotation at the top of the file above the package statement:

my.program.MyAppIn this example, the main class to run would now be .
See also:
 Package level functions including @JvmName annotation. Annotation use-site targets
 Section 1.2: Hello World using a Companion Object
Similar to using an Object Declaration, you can define the main function of a Kotlin program using a Companion Object of a class.

my.program.AppThe class name that you will run is the name of your class, in this case is .
Object DeclarationThe advantage to this method over a top-level function is that the class name to run is more self-evident, and any other functions you add are scoped into the class App. This is similar to the  example, other than you are in control of instantiating any classes to do further work.
A slight variation that instantiates the class to do the actual "hello":

See also:
     Static Methods including the @JvmStatic annotation
  Section 1.3: Hello World using an Object Declaration
You can alternatively use an Object Declaration that contains the main function for a Kotlin program.

my.program.AppThe class name that you will run is the name of your object, in this case is .
The advantage to this method over a top-level function is that the class name to run is more self-evident, and any other functions you add are scoped into the class App. You then also have a singleton instance of App to store state and do other work.
See also:
 Static Methods including the @JvmStatic annotation
Section 1.4: Main methods using varargs
All of these main method styles can also be used with varargs:

Section 1.5: Compile and Run Kotlin Code in Command Line
As java provide two different commands to compile and run Java code. Same as Kotlin also provide you different commands.
javac to compile java files. java to run java files.
Same as kotlinc to compile kotlin files kotlin to run kotlin files.
Section 1.6: Reading input from Command Line
The arguments passed from the console can be received in the Kotlin program and it can be used as an input. You can pass N (1 2 3 and so on) numbers of arguments from the command prompt.
A simple example of a command-line argument in Kotlin.

Here, Enter two number from the command line to find the maximum number. Output:


For !! Operator Please check Null Safety.
Note: Above example compile and run on Intellij.

Chapter 2: Basics of Kotlin
This topic covers the basics of Kotlin for beginners.
Section 2.1: Basic examples
1. The Unit return type declaration is optional for functions. The following codes are equivalent.

2. Single-Expression functions:When a function returns a single expression, the curly braces can be omitted and thebody is specified after = symbol

Explicitly declaring the return type is optional when this can be inferred by the compiler

3. String interpolation: Using string values is easy.

4. In Kotlin, the type system distinguishes between references that can hold null (nullable references) and thosethat can not (non-null references). For example, a regular variable of type String can not hold null:

To allow nulls, we can declare a variable as nullable string, written String?:

5. In Kotlin,== actually checks for equality of values. By convention, an expression like a == b is translated to

Chapter 3: Strings
Section 3.1: String Equality
In Kotlin strings are compared with == operator which check for their structural equality.

Referential equality is checked with === operator.

Section 3.2: String Literals
Kotlin has two types of string literals:
Escaped string
Raw string
Escaped string handles special characters by escaping them. Escaping is done with a backslash. The following escape sequences are supported: \t, \b, \n, \r, \', \", \\ and \$. To encode any other character, use the Unicode escape sequence syntax: \uFF00.

""Raw string delimited by a triple quote ", contains no escaping and can contain newlines and any other characters

Leading whitespace can be removed with trimMargin() function.

trimMargin(">"Default margin prefix is pipe character |, this can be set as a parameter to trimMargin; e.g. ).
Section 3.3: Elements of String
string[indexElements of String are characters that can be accessed by the indexing operation ].

String elements can be iterated with a for-loop.

Section 3.4: String Templates
Both escaped strings and raw strings can contain template expressions. Template expression is a piece of code which is evaluated and its result is concatenated into string. It starts with a dollar sign $ and consists of either a variable name:

Or an arbitrary expression in curly braces:

To include a literal dollar sign in a string, escape it using a backslash:

The exception is raw strings, which do not support escaping. In raw strings you can use the following syntax to represent a dollar sign.

Chapter 4: Arrays
Section 4.1: Generic Arrays
Array<T>Generic arrays in Kotlin are represented by .
emptyArray<T>()To create an empty array, use  factory function:

To create an array with given size and initial values, use the constructor:
var strings = Array<String>(size = 5, init = { index -> "Item #$index" }) print(Arrays.toString(a)) // prints "[Item #0, Item #1, Item #2, Item #3, Item #4]" print(a.size) // prints 5
get(index: Int): T and set(index: Int, value: T)Arrays have  functions:

Section 4.2: Arrays of Primitives
Array<T>These types do not inherit from  to avoid boxing, however, they have the same attributes and methods.
Kotlin type	Factory function	JVM type
booleanArrayOf(true, false)boolean[]BooleanArray
ByteArray	byteArrayOf(1, 2, 3)	byte[]
CharArray	charArrayOf('a', 'b', 'c') char[]
DoubleArray doubleArrayOf(1.2, 5.0)	double[]
FloatArray floatArrayOf(1.2, 5.0)	float[]
IntArray	intArrayOf(1, 2, 3)	int[]
LongArray longArrayOf(1, 2, 3) long[] ShortArray shortArrayOf(1, 2, 3) short[]
Section 4.3: Create an array
val a = arrayOf(1, 2, 3) // creates an Array<Int> of size 3 containing [1, 2, 3].
Section 4.4: Create an array using a closure
val a = Array(3) { i -> i * 2 } // creates an Array<Int> of size 3 containing [0, 2, 4]
Section 4.5: Create an uninitialized array
val a = arrayOfNulls<Int>(3) // creates an Array<Int?> of [null, null, null]
The returned array will always have a nullable type. Arrays of non-nullable items can't be created uninitialized.
Section 4.6: Extensions
average() is defined for Byte, Int, Long, Short, Double, Float and always returns Double:

component1(), component2(), ... component5() return an item of the array
getOrNull(index: Int) returns null if index is out of bounds, otherwise an item of the array
first(), last()
toHashSet() returns a HashSet<T> of all elements
sortedArray(), sortedArrayDescending() creates and returns a new array with sorted elements of current
sort(), sortDescending sort the array in-place
min(), max()
Section 4.7: Iterate Array
You can print the array elements using the loop same as the Java enhanced loop, but you need to change keyword from : to in.

You can also change data type in for loop.

Chapter 5: Collections
Unlike many languages, Kotlin distinguishes between mutable and immutable collections (lists, sets, maps, etc). Precise control over exactly when collections can be edited is useful for eliminating bugs, and for designing good APIs.
Section 5.1: Using list

Section 5.2: Using map
// Create a new read-only Map<Integer, String> val map = mapOf(Pair(1, "Item 1"), Pair(2, "Item 2"), Pair(3, "Item 3")) println(map) // prints "{1=Item 1, 2=Item 2, 3=Item 3}"
Section 5.3: Using set


Chapter 6: Enum
Section 6.1: Initialization
Enum classes as any other classes can have a constructor and be initialized

Section 6.2: Functions and Properties in enums
Enum classes can also declare members (i.e. properties and functions). A semicolon (;) must be placed between the last enum object and the first member declaration.
If a member is abstract, the enum objects must implement it.

Section 6.3: Simple enum

Each enum constant is an object. Enum constants are separated with commas.
Section 6.4: Mutability
Enums can be mutable, this is another way to obtain a singleton behavior:



Chapter 7: Functions
	Parameter	Details
Name	Name of the function
Name:TypeParams	Values given to the function with a name and type: 
Type	Return type of the function
Type Argument Type parameter used in generic programming (not necessarily return type)
ArgName	Name of value given to the function
ArgType	Type specifier for ArgName
ArgNames	List of ArgName separated by commas
Section 7.1: Function References
We can reference a function without actually calling it by prefixing the function's name with ::. This can then be passed to a function which accepts some other function as a parameter.

ParamTypeA, ParamTypeB, ...) -> ReturnTypeFunctions without a receiver will be converted to ( where
ParamTypeA, ParamTypeB ... are the type of the function parameters and `ReturnType1 is the type of function return value.

Functions with a receiver (be it an extension function or a member function) has a different syntax. You have to add the type name of the receiver before the double colon:

However, when a function's receiver is an object, the receiver is omitted from parameter list, because these is and only is one instance of such type.

Since kotlin 1.1, function reference can also be bounded to a variable, which is then called a bounded function reference.
Version ≥ 1.1.0

Note this example is given only to show how bounded function reference works. It's bad practice in all other senses.
There is a special case, though. An extension function declared as a member can't be referenced.

Section 7.2: Basic Functions
Functions are declared using the fun keyword, followed by a function name and any parameters. You can also specify the return type of a function, which defaults to Unit. The body of the function is enclosed in braces {}. If the return type is other than Unit, the body must issue a return statement for every terminating branch within the body.

A shorthand version of the same:

And the type can be omitted since it can be inferred:

Section 7.3: Inline Functions
Functions can be declared inline using the inline prefix, and in this case they act like macros in C - rather than being called, they are replaced by the function's body code at compile time. This can lead to performance benefits in some circumstances, mainly where lambdas are used as function parameters.

One difference from C macros is that inline functions can't access the scope from which they're called:

Section 7.4: Lambda Functions
Lambda functions are anonymous functions which are usually created during a function call to act as a function parameter. They are declared by surrounding expressions with {braces} - if arguments are needed, these are put before an arrow ->.

The last statement inside a lambda function is automatically the return value.
The type's are optional, if you put the lambda on a place where the compiler can infer the types.
Multiple arguments:

If the lambda function only needs one argument, then the argument list can be omitted and the single argument be referred to using it instead.

If the only argument to a function is a lambda function, then parentheses can be completely omitted from the function call.

Section 7.5: Operator functions
Kotlin allows us to provide implementations for a predefined set of operators with fixed symbolic representation (like + or *) and fixed precedence. To implement an operator, we provide a member function or an extension function with a fixed name, for the corresponding type. Functions that overload operators need to be marked with

Section 7.6: Functions Taking Other Functions
As seen in "Lambda Functions", functions can take other functions as a parameter. The "function type" which you'll need to declare functions which take other functions is as follows:

 -> AnyFor example, you could use the vaguest type, ()?, to declare a function which executes a lambda function twice:

Section 7.7: Shorthand Functions
If a function contains just one expression, we can omit the brace brackets and use an equals instead, like a variable assignment. The result of the expression is returned automatically.

Chapter 8: Vararg Parameters in Functions
Section 8.1: Basics: Using the vararg keyword
Define the function using the vararg keyword.

Now you can pass as many parameters (of the correct type) into the function as you want.

Section 8.2: Spread Operator: Passing arrays into vararg functions
Arrays can be passed into vararg functions using the Spread Operator, *.
Assuming the following function exists...

You can pass an array into the function like so...

The spread operator can also be used in the middle of the parameters...

Chapter 9: Conditional Statements
Section 9.1: When-statement argument matching
When given an argument, the when-statement matches the argument against the branches in sequence. The matching is done using the == operator which performs null checks and compares the operands using the equals function. The first matching one will be executed.

The when statement also knows some more advanced matching options:

Section 9.2: When-statement as expression
Like if, when can also be used as an expression:

To be used as an expression, the when-statement must be exhaustive, i.e. either have an else branch or cover all possibilities with the branches in another way.
Section 9.3: Standard if-statement

The else-branches are optional in normal if-statements.
Section 9.4: If-statement as an expression
If-statements can be expressions:
val str = if (condition) "Condition met!" else "Condition not met!"
Note that the else-branch is not optional if the if-statement is used as an expression.
else ifThis can also been done with a multi-line variant with curly brackets and multiple  statements.

Section 9.5: When-statement instead of if-else-if chains
The when-statement is an alternative to an if-statement with multiple else-if-branches:

Same code written using an if-else-if chain:

Just like with the if-statement, the else-branch is optional, and you can add as many or as few branches as you like. You can also have multiline-branches:

Section 9.6: When-statement with enums
when can be used to match enum values:


As you can see in second case line (Monday and Tuesday) it is also possible to combine two or more enum values.
If your cases are not exhaustive the compile will show an error. You can use else to handle default cases:

if-then-elseThough the same can be done using  construct, when takes care of missing enum values and makes it more natural.
Check here for more information about kotlin enum
Chapter 10: Loops in Kotlin
Section 10.1: Looping over iterables
You can loop over any iterable by using the standard for-loop:

Lots of things in Kotlin are iterable, like number ranges:

If you need an index while iterating:

There is also a functional approach to iterating included in the standard library, without apparent language constructs, using the forEach function:

it in this example implicitly holds the current element, see Lambda Functions
Section 10.2: Repeat an action x times

Section 10.3: Break and continue
Break and continue keywords work like they do in other languages.

If you have nested loops, you can label the loop statements and qualify the break and continue statements to specify which loop you want to continue or break:

This approach won't work for the functional forEach construct, though.
Section 10.4: Iterating over a Map in kotlin

Section 10.5: Recursion
Looping via recursion is also possible in Kotlin as in most programming languages.

In the example above, the factorial function will be called repeatedly by itself until the given condition is met.
Section 10.6: While Loops
While and do-while loops work like they do in other languages:

In the do-while loop, the condition block has access to values and variables declared in the loop body.
Section 10.7: Functional constructs for iteration
The Kotlin Standard Library also provides numerous useful functions to iteratively work upon collections. For example, the map function can be used to transform a list of items.

One of the many advantages of this style is it allows to chain operations in a similar fashion. Only a minor modification would be required if say, the list above were needed to be filtered for even numbers. The filter function can be used.
val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)
val numberStrings = numbers.filter { it % 2 == 0 }.map { "Number $it" }

Chapter 11: Ranges
Range expressions are formed with rangeTo functions that have the operator form .. which is complemented by in and !in. Range is defined for any comparable type, but for integral primitive types it has an optimized implementation
Section 11.1: Integral Type Ranges
Integral type ranges ( IntRange , LongRange , CharRange ) have an extra feature: they can be iterated over. The compiler takes care of converting this analogously to Java's indexed for-loop, without extra overhead

Section 11.2: downTo() function
if you want to iterate over numbers in reverse order? It's simple. You can use the downTo() function defined in the standard library

Section 11.3: step() function
Is it possible to iterate over numbers with arbitrary step, not equal to 1? Sure, the step() function will help you

Section 11.4: until function
To create a range which does not include its end element, you can use the until function:

Chapter 12: Regex
Section 12.1: Idioms for Regex Matching in When Expression
Using immutable locals:
Uses less horizontal space but more vertical space than the "anonymous temporaries" template. Preferable over the "anonymous temporaries" template if the when expression is in a loop--in that case, regex definitions should be placed outside the loop.

Using anonymous temporaries:
Uses less vertical space but more horizontal space than the "immutable locals" template. Should not be used if then when expression is in a loop.

Using the visitor pattern:
Has the benefit of closely emulating the "argument-ful" when syntax. This is beneficial because it more clearly indicates the argument of the when expression, and also precludes certain programmer mistakes that could arise from having to repeat the when argument in every whenEntry. Either the "immutable locals" or the "anonymous temporaries" template may be used with this implementation the visitor pattern.

And the minimal definition of the wrapper class for the when expression argument:
class RegexWhenArgument (val whenArgument: CharSequence) {     operator fun equals(whenEntry: Regex) = whenEntry.matches(whenArgument)     override operator fun equals(whenEntry: Any?) = (whenArgument == whenEntry) }
Section 12.2: Introduction to regular expressions in Kotlin
This post shows how to use most of the functions in the Regex class, work with null safely related to the Regex functions, and how raw strings makes it easier to write and read regex patterns.
The RegEx class
Regex(pattern: Stringfind(..) or replace(..To work with regular expressions in Kotlin, you need to use the ) class and invoke functions like ) on that regex object.
An example on how to use the Regex class that returns true if the input string contains c or d:

containsMatchIn(..The essential thing to understand with all the Regex functions is that the result is based on matching the regex pattern and the input string. Some of the functions requires a full match, while the rest requires only a partial match. The ) function used in the example requires a partial match and is explained later in this post.
Null safety with regular expressions
find(..) and matchEntire(..) will return a MatchResultBoth ? object. The ? character after MatchResult is necessary for Kotlin to handle null safely.
find(..An example that demonstrates how Kotlin handles null safely from a Regex function, when the ) function returns null:
val matchResult =
    Regex("c|d").find("efg")           // matchResult: null val a = matchResult?.value             // a: null val b = matchResult?.value.orEmpty()   // b: "" a?.toUpperCase()                       // Still needs question mark. => null    
b.toUpperCase()                        // Accesses the function directly. => ""
orEmptyWith the () function, b can't be null and the ? character is unnecessary when you call functions on b.
If you don't care about this safe handling of null values, Kotlin allows you to work with null values like in Java with the !! characters: a!!.toUpperCase()                      // => KotlinNullPointerException
Raw strings in regex patterns
Kotlin provides an improvement over Java with a raw string that makes it possible to write pure regex patterns without double backslashes, that are necessary with a Java string. A raw string is represented with a triple quote:

find(input: CharSequence, startIndex: Int): MatchResult?
MatchresultMatchResultThe input string will be matched against the pattern in the Regex object. It returns a ? object with the first matched text after the startIndex, or null if the pattern didn't match the input string. The result string is retrieved from the ? object's value property. The startIndex parameter is optional with the default value 0.
To extract the first valid phone number from a string with contact details:
val phoneNumber :String? = Regex(pattern = """\d{3}-\d{3}-\d{4}""")
    .find(input = "phone: 123-456-7890, e..")?.value // phoneNumber: 123-456-7890
With no valid phone number in the input string, the variable phoneNumber will be null. findAll(input: CharSequence, startIndex: Int): Sequence
Returns all the matches from the input string that matches the regex pattern.
To print out all numbers separated with space, from a text with letters and digits:

findAll(..The matchedResults variable is a sequence with MatchResult objects. With an input string without digits, the ) function will return an empty sequence.
matchEntire(input: CharSequence): MatchResult?
If all the characters in the input string matches the regex pattern, a string equal to the input will be returned. Else, null will be returned.
Returns the input string if the whole input string is a number:
val a = Regex("""\d+""").matchEntire("100")?.value             // a: 100 val b = Regex("""\d+""").matchEntire("100 dollars")?.value     // b: null
matches(input: CharSequence): Boolean
Returns true if the whole input string matches the regex pattern. False otherwise.
Tests if two strings contains only digits:

Returns true if part of the input string matches the regex pattern. False otherwise.
Test if two strings contains at least one digit:

 Regex("""\d+""").containsMatchIn("Fifty dollars")    // => false split(input: CharSequence, limit: Int): List Returns a new list without all the regex matches.
To return lists without digits:
val a = Regex("""\d+""").split("ab12cd34ef")     // a: [ab, cd, ef] val b = Regex("""\d+""").split("This is a test") // b: [This is a test]
There is one element in the list for each split. The first input string has three numbers. That results in a list with three elements.
replace(input: CharSequence, replacement: String): String
Replaces all matches of the regex pattern in the input string with the replacement string.
To replace all digits in a string with an x:
val result = Regex("""\d+""").replace("ab12cd34ef", "x") // result: abxcdxef

Chapter 13: Basic Lambdas
Section 13.1: Lambda as parameter to filter function

Section 13.2: Lambda for benchmarking a function call
General-purpose stopwatch for timing how long a function takes to run:

Usage:

Section 13.3: Lambda passed as a variable
val isOfAllowedAge = { user: User -> user.age > MINIMUM_AGE } val allowedUsers = users.filter(isOfAllowedAge)
Chapter 14: Null Safety
Section 14.1: Smart casts
If the compiler can infer that an object can't be null at a certain point, you don't have to use the special operators anymore:

Section 14.2: Assertion
!! suffixes ignore nullability and returns a non-null version of that type. KotlinNullPointerException will be thrown if the object is a null.

Section 14.3: Eliminate nulls from an Iterable and array
Collection<T?> to CollectionsSometimes we need to change type from <T>. In that case, filterNotNull is our solution.

Section 14.4: Null Coalescing / Elvis Operator
Sometimes it is desirable to evaluate a nullable expression in an if-else fashion. The elvis operator, ?:, can be used in Kotlin for such a situation.
For instance:

data?.firstdata?.firstThe expression above returns "Nothing here" if () or data itself yield a null value else the result of ().
It is also possible to throw exceptions using the same syntax to abort code execution.

Section 14.5: Nullable and Non-Nullable types
StringNormal types, like String, are not nullable. To make them able to hold null values, you have to explicitly denote that by putting a ? behind them: ?
var string : String = "Hello World!" var nullableString: String? = null string = nullableString // Compiler error: Can't assign nullable to non-nullable type. nullableString = string // This will work however!
Section 14.6: Elvis Operator (?:)
null referenceIn Kotlin, we can declare variable which can hold . Suppose we have a nullable reference a, we can say "if a is not null, use it, otherwise use some non-null value x"

if...elseNow, a can be null. So when we need to access value of a, then we need to perform safety check, whether it contains value or not. We can perform this safety check by conventional  statement.

if...elseBut here comes advance operator Elvis(Operator Elvis : ?:). Above  can be expressed with the Elvis operator as below:

lengthIf the expression to the left of ?: (here : a?.) is not null, the elvis operator returns it, otherwise it returns the expression to the right (here: -1). Right-hand side expression is evaluated only if the left-hand side is null.
Section 14.7: Safe call operator
To access functions and properties of nullable types, you have to use special operators.
The first one, ?., gives you the property or function you're trying to access, or it gives you null if the object is null:
 val string: String? = "Hello World!" print(string.length)   // Compile error: Can't directly access property of nullable type. print(string?.length)  // Will print the string's length, or "null" if the string is null. Idiom: calling multiple methods on the same, null-checked object
An elegant way to call multiple methods of a null-checked object is using Kotlin's apply like this:

This will call foo and bar on obj (which is this in the apply block) only if obj is non-null, skipping the entire block otherwise.
To bring a nullable variable into scope as a non-nullable reference without making it the implicit receiver of function and property calls, you can use let instead of apply:

notnull could be named anything, or even left out and used through the implicit lambda parameter it.

Chapter 15: Class Delegation
A Kotlin class may implement an interface by delegating its methods and properties to another object that implements that interface. This provides a way to compose behavior using association rather than inheritance.
Section 15.1: Delegate a method to another class

Hello, world!The example prints 

Chapter 16: Class Inheritance
	Parameter	Details
Base Class	Class that is inherited from
Derived Class	Class that inherits from Base Class
Init Arguments	Arguments passed to constructor of Base Class
Function Definition Function in Derived Class that has different code than the same in the Base Class DC-Object	"Derived Class-Object" Object that has the type of the Derived Class
Any object-oriented programming language has some form of class inheritance. Let me revise:
Imagine you had to program a bunch of fruit: Apples, Oranges and Pears. They all differ in size, shape and color, that's why we have different classes.
getFruitBut let's say their differences don't matter for a second and you just want a Fruit, no matter which exactly? What return type would () have?
The answer is class Fruit. We create a new class and make all fruits inherit from it!
Section 16.1: Basics: the 'open' keyword
In Kotlin, classes are final by default which means they cannot be inherited from.
To allow inheritance on a class, use the open keyword.

Section 16.2: Inheriting fields from a class



Section 16.3: Inheriting methods from a class


Section 16.4: Overriding properties and methods
Overriding properties (both read-only and mutable):




Chapter 17: Visibility Modifiers
In Kotlin, there are 4 types of visibility modifiers are available.
Public: This can be accessed from anywhere.
Private: This can only be accessed from the module code.
Protected: This can only be accessed from the class defining it and any derived classes.
Internal: This can only be accessed from the scope of the class defining it.
Section 17.1: Code Sample
public val name = "Avijit"Public: 
private val name = "Avijit"Private: 
protected val name = "Avijit"Protected: 
internal val name = "Avijit"Internal: 

Chapter 18: Generics
Parameter	Details
TypeName	Type Name of generic parameter
UpperBound Covariant Type
LowerBound Contravariant Type ClassName Name of the class
A List can hold numbers, words or really anything. That's why we call the List generic.
Generics are basically used to define which types a class can hold and which type an object currently holds.
Section 18.1: Declaration-site variance
Declaration-site variance can be thought of as declaration of use-site variance once and for all the use-sites.
  class Consumer<in T> { fun consume(t: T) { ... } }   fun charSequencesConsumer() : Consumer<CharSequence>() = ...
  val stringConsumer : Consumer<String> = charSequenceConsumer() // OK since in-projection   val anyConsumer : Consumer<Any> = charSequenceConsumer() // Error, Any cannot be passed
 
  val outConsumer : Consumer<out CharSequence> = ... // Error, T is `in`-parameter
List<out TComparator<in TWidespread examples of declaration-site variance are >, which is immutable so that T only appears as the return value type, and >, which only receives T as argument.
Section 18.2: Use-site variance
Use-site variance is similar to Java wildcards:
Out-projection:
   val takeList : MutableList<out SomeType> = ... // Java: List<? extends SomeType>   val takenValue : SomeType = takeList[0] // OK, since upper bound is SomeType   takeList.add(takenValue) // Error, lower bound for generic is not specified In-projection:

Star-projection

  starList.add(someValue) // Error, lower bound for generic is not specified
See also:
 Variant Generics interoperability when calling Kotlin from Java.

Chapter 19: Interfaces
Section 19.1: Interface with default implementations
An interface in Kotlin can have default implementations for functions:

Classes implementing such interfaces will be able to use those functions without reimplementing

Properties
Default implementations also work for property getters and setters:

Interface accessors implementations can't use backing fields

Multiple implementations
When multiple interfaces implement the same function, or all of them define with one or more implementing, the derived class needs to manually resolve proper call


Section 19.2: Properties in Interfaces
You can declare properties in interfaces. Since an interface cannot have state you can only declare a property as abstract or by providing default implementation for the accessors.

Section 19.3: super keyword

If the method in the interface has its own default implementation, we can use super keyword to access it.

Section 19.4: Basic Interface
A Kotlin interface contains declarations of abstract methods, and default method implementations although they cannot store state.


This interface can now be implemented by a class as follows:

Section 19.5: Conflicts when Implementing Multiple Interfaces with Default Implementations
When implementing more than one interface that have methods of the same name that include default implementations, it is ambiguous to the compiler which implementation should be used. In the case of a conflict, the developer must override the conflicting method and provide a custom implementation. That implementation may choose to delegate to the default implementations or not.

Chapter 20: Singleton objects
An object is a special kind of class, which can be declared using object keyword. Objects are similar to Singletons (a design pattern) in java. It also functions as the static part of java. Beginners who are switching from java to kotlin can vastly use this feature, in place of static, or singletons.
Section 20.1: Use as replacement of static methods/fields of java

From any other class, just invoke the variable and functions in this way:

Section 20.2: Use as a singleton
SomeSingleton.INSTANCEKotlin objects are actually just singletons. Its primary advantage is that you don't have to use  to get the instance of the singleton.
In java your singleton looks like this:

In kotlin, the equivalent code is

It's obviously less verbose to use.
Chapter 21: coroutines
Examples of Kotlin's experimental(yet) implementation of coroutines
Section 21.1: Simple coroutine which delay's 1 second but not blocks
(from official doc)
fun main(args: Array<String>) {     launch(CommonPool) { // create new coroutine in common thread pool         delay(1000L) // non-blocking delay for 1 second (default time unit is ms)         println("World!") // print after delay
    }
    println("Hello,") // main function continues while coroutine is delayed
    Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive }
result


Chapter 22: Annotations
Section 22.1: Meta-annotations
When declaring an annotation, meta-info can be included using the following meta-annotations:
 @Target: specifies the possible kinds of elements which can be annotated with the annotation (classes, functions, properties, expressions etc.)
 @Retention specifies whether the annotation is stored in the compiled class files and whether it's visible through reflection at runtime (by default, both are true.)
@Repeatable allows using the same annotation on a single element multiple times.
@MustBeDocumented specifies that the annotation is part of the public API and should be included in the class or method signature shown in the generated API documentation.
Example:

Section 22.2: Declaring an annotation
Annotations are means of attaching metadata to code. To declare an annotation, put the annotation modifier in front of a class:

Annotations can have meta-annotations:
    @Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)     annotation class Strippable
Annotations, like other classes, can have constructors:

But unlike other classes, is limited to the following types:
types that correspond to Java primitive types (Int, Long etc.); strings classes ( Foo:: class)
enums
other annotations arrays of the types listed above
Chapter 23: Type aliases
(String) ->With type aliases, we can give an alias to other type. It's ideal for giving a name to function types like 
Pair<Person, Person>Boolean or generic type like .
Type aliases support generics. An alias can replace a type with generics and an alias can be generics.
Section 23.1: Function type

Section 23.2: Generic type


Chapter 24: Type-Safe Builders
Section 24.1: Type-safe tree structure builder
Builders can be defined as a set of extension functions taking lambda expressions with receivers as arguments. In this example, a menu of a JFrame is being built:

These functions can then be used to build a tree structure of objects in an easy way:

Chapter 25: Delegated properties
Kotlin can delegate the implementation of a property to a handler object. Some standard handlers are included, such as lazy initialization or observable properties. Custom handlers can also be created.
Section 25.1: Observable properties

foo was changed from 1 to 2The example prints 
Section 25.2: Custom delegation

Section 25.3: Lazy initialization

The example prints 2.
Section 25.4: Map-backed properties

The example prints 1
Section 25.5: Delegate Can be used as a layer to reduce boilerplate
WeakReference<T>Consider Kotlin's Null Type system and .
So let's say we have to save some sort of reference and we wanted to avoid memory leaks, here is where WeakReference comes in. take for example this:


Now this is just with one WeakReference. To Reduce this boilerplate, we can use a custom property delegate to help us like so:

So Now we can use variables that are wrapped with WeakReference just like normal nullable variables !

Chapter 26: Reflection
Reflection is a language's ability to inspect code at runtime instead of compile time.
Section 26.1: Referencing a class
To obtain a reference to a KClass object representing some class use double colons:

Section 26.2: Inter-operating with Java reflection
.javaTo obtain a Java's Class object from Kotlin's KClass use the  extension property:

The latter example will be optimized by the compiler to not allocate an intermediate KClass instance.
Section 26.3: Referencing a function
Functions are first-class citizens in Kotlin. You can obtain a reference on it using double colons and then pass it to another function:

Section 26.4: Getting values of all properties of a class
Given Example class extending BaseExample class with some properties:

One can get hold of all properties of a class:


private val privateFieldmember.get(exampleRunning this code will cause an exception to be thrown. Property  is declared private and calling ) on it will not succeed. One way to handle this it to filter out private properties. To do that we have to check the visibility modifier of a property's Java getter. In case of private val the getter does not exist so we can assume private access.
The helper function and it's usage might look like this:

Another approach is to make private properties accessible using reflection:

Section 26.5: Setting values of all properties of a class
As an example we want to set all string properties of a sample class


Getting mutable properties builds on getting all properties, filtering mutable properties by type. We also need to check visibility, as reading private properties results in run time exception.

List<StringList<AnyTo set all String properties to "Our Value" we can additionally filter by the return type. Since Kotlin is based on Java VM, Type Erasure is in effect, and thus Properties returning generic types such as > will be the same as >. Sadly reflection is not a golden bullet and there is no sensible way to avoid this, so you need to watch out in your use-cases.


Chapter 27: Extension Methods
Section 27.1: Potential Pitfall: Extensions are Resolved Statically
The extension method to be called is determined at compile-time based on the reference-type of the variable being accessed. It doesn't matter what the variable's type is at runtime, the same extension method will always be called.

The above example will print "Defined for Super", because the declared type of the variable myVar is Super.
Section 27.2: Top-Level Extensions
Top-level extension methods are not contained within a class.

Above an extension method is defined for the type IntArray. Note that the object for which the extension method is defined (called the receiver) is accessed using the keyword this.
This extension can be called like so:

Section 27.3: Lazy extension property workaround
Assume you want to create an extension property that is expensive to compute. Thus you would like to cache the computation, by using the lazy property delegate and refer to current instance (this), but you cannot do it, as explained in the Kotlin issues KT-9686 and KT-13053. However, there is an official workaround provided here.
In the example, the extension property is color. It uses an explicit colorCache which can be used with this as no lazy is necessary:


Section 27.4: Sample extending Java 7+ Path class
A common use case for extension methods is to improve an existing API. Here are examples of adding exist, notExists and deleteRecursively to the Java 7+ Path class:
fun Path.exists(): Boolean = Files.exists(this) fun Path.notExists(): Boolean = !this.exists()
 fun Path.deleteRecursively(): Boolean = this.toFile().deleteRecursively() Which can now be invoked in this example:

Section 27.5: Sample extending long to render a human readable string
Given any value of type Int or Long to render a human readable string:

Then easily used as:

Section 27.6: Sample extending Java 8 Temporal classes to render an ISO formatted string
With this declaration: fun Temporal.toIsoString(): String = DateTimeFormatter.ISO_INSTANT.format(this) You can now simply:

Section 27.7: Using extension functions to improve readability
In Kotlin you could write code like:

But the use of apply is not that clear as to your intent. Sometimes it is clearer to create a similar extension function to in effect rename the action and make it more self-evident. This should not be allowed to get out of hand, but for very common actions such as verification:

You could now write the code as:

Which now let's people know what to expect within the lambda parameter.
 AnyNote that the type parameter T for verifiedBy is same as T:? meaning that even nullable types will be able to use that version of the extension. Although verifiedWith requires non-nullable.
Section 27.8: Extension functions to Companion Objects (appearance of Static functions)
If you want to extend a class as-if you are a static function, for example for class Something add static looking function fromString, this can only work if the class has a companion object and that the extension function has been declared upon the companion object:

Section 27.9: Extensions for easier reference View from code
You can use extensions for reference View, no more boilerplate after you created the views.
Original Idea is by Anko Library
Extensions
inline fun <reified T : View> View.find(id: Int): T = findViewById(id) as T inline fun <reified T : View> Activity.find(id: Int): T = findViewById(id) as T inline fun <reified T : View> Fragment.find(id: Int): T = view?.findViewById(id) as T inline fun <reified T : View> RecyclerView.ViewHolder.find(id: Int): T = itemView?.findViewById(id) as T
inline fun <reified T : View> View.findOptional(id: Int): T? = findViewById(id) as? T inline fun <reified T : View> Activity.findOptional(id: Int): T? = findViewById(id) as? T inline fun <reified T : View> Fragment.findOptional(id: Int): T? = view?.findViewById(id) as? T inline fun <reified T : View> RecyclerView.ViewHolder.findOptional(id: Int): T? = itemView?.findViewById(id) as? T
Usage
val yourButton by lazy { find<Button>(R.id.yourButtonId) } val yourText by lazy { find<TextView>(R.id.yourTextId) } val yourEdittextOptional by lazy { findOptional<EditText>(R.id.yourOptionEdittextId) }

Chapter 28: DSL Building
Focus on the syntax details to design internal DSLs in Kotlin.
Section 28.1: Infix approach to build DSL
If you have: infix fun <T> T?.shouldBe(expected: T?) = assertEquals(expected, this) you can write the following DSL-like code in your tests:

Section 28.2: Using operators with lambdas
If you have:

You can write the following DSL-like code:

Section 28.3: Overriding invoke method to build DSL
If you have:

you can write the following DSL-like code in your production code:

Section 28.4: Using extensions with lambdas
If you have:

You can write the following DSL-like code:

If you feel confused with shouldBe above, see the example Infix approach to build DSL.

Chapter 29: Idioms
Section 29.1: Serializable and serialVersionUid in Kotlin
To create the serialVersionUID for a class in Kotlin you have a few options all involving adding a member to the companion object of the class.
private const valThe most concise bytecode comes from a  which will become a private static variable on the containing class, in this case MySpecialCase:

You can also use these forms, each with a side effect of having getter/setter methods which are not necessary for serialization...

This creates the static field but also creates a getter as well getSerialVersionUID on the companion object which is unnecessary.

This creates the static field but also creates a static getter as well getSerialVersionUID on the containing class MySpecialCase which is unnecessary.
But all work as a method of adding the serialVersionUID to a Serializable class.
Section 29.2: Delegate to a class without providing it in the public constructor
Assume you want to delegate to a class but you do not want to provide the delegated-to class in the constructor parameter. Instead, you want to construct it privately, making the constructor caller unaware of it. At first this might seem impossible because class delegation allows to delegate only to constructor parameters. However, there is a way to do it, as given in this answer:

MyTable(). The Table<Int, Int, IntWith this, you can just call the constructor of MyTable like that: > to which MyTable delegates will be created privately. Constructor caller knows nothing about it.
This example is based on this SO question.
Section 29.3: Use let or also to simplify working with nullable objects
let in Kotlin creates a local binding from the object it was called upon. Example:

This will print "foo" and will return Unit.
The difference between let and also is that you can return any value from a let block. also in the other hand will always return Unit.
Now why this is useful, you ask? Because if you call a method which can return null and you want to run some code only when that return value is not null you can use let or also like this:

This piece of code will only run the let block when str is not null. Note the null safety operator (?).
Section 29.4: Use apply to initialize objects or to achieve method chaining
The documentation of apply says the following:
		calls the specified function block with this value as its receiver and returns this value.
While the kdoc is not so helpful apply is indeed an useful function. In layman's terms apply establishes a scope in which this is bound to the object you called apply on. This enables you to spare some code when you need to call multiple methods on an object which you will then return later. Example:

This is the same as writing this:

Section 29.5: Fluent methods in Kotlin
Fluent methods in Kotlin can be the same as Java:

But you can also make them more functional by creating an extension function such as:

Which then allows more obviously fluent functions:

Section 29.6: Filtering a list

Section 29.7: Creating DTOs (POJOs/POCOs)
Data classes in kotlin are classes created to do nothing but hold data. Such classes are marked as data: data class User(var firstname: String, var lastname: String, var age: Int)
The code above creates a User class with the following automatically generated:
equalshashcodetoStringcopycomponentNGetters and Setters for all properties (getters only for vals)
()
()
()
()
() (where N is the corresponding property in order of declaration)
Just as with a function, default values can also be specified: data class User(var firstname: String = "Joe", var lastname: String = "Bloggs", var age: Int = 20)
More details can be found here Data Classes.
Chapter 30: RecyclerView in Kotlin
I just want to share my little bit knowledge and code of RecyclerView using Kotlin.
Section 30.1: Main class and Adapter
I am assuming that you have aware about the some syntax of Kotlin and how to use, just add RecyclerView in activity_main.xml file and set with adapter class.

this one is your recycler view adapter class and create main_item.xml file what you want



Chapter 31: logging in kotlin
Section 31.1: kotlin.logging

Using kotlin.logging framework

Chapter 32: Exceptions
Section 32.1: Catching exception with try-catch-finally
Catching exceptions in Kotlin looks very similar to Java

You can also catch multiple exceptions

val s: String? = try { getString() } catch (e: Exception) { null }
Kotlin doesn't have checked exceptions, so you don't have to catch any exceptions.

Chapter 33: JUnit
Section 33.1: Rules
To add a JUnit rule to a test fixture:

The @JvmField annotation is necessary to expose the backing field with the same visibility (public) as the myRule property (see answer). JUnit rules require the annotated rule field to be public.

Chapter 34: Kotlin Android Extensions
Kotlin has a built-in view injection for Android, allowing to skip manual binding or need for frameworks such as ButterKnife. Some of the advantages are a nicer syntax, better static typing and thus being less error-prone.
Section 34.1: Using Views
activity_main.xmlAssuming we have an activity with an example layout called :

We can use Kotlin extensions to call the button without any additional binding like so:

You can also import all ids appearing in layout with a * notation

Synthetic views can't be used outside of Activities/Fragments/Views with that layout inflated:

Section 34.2: Configuration
Start with a properly configured gradle project.
build.gradleIn your project-local (not top-level)  append extensions plugin declaration below your Kotlin plugin, on top-level indentation level.

Section 34.3: Painful listener for getting notice, when the view is completely drawn now is so simple and awesome with Kotlin's extension

Under the hood

Section 34.4: Product flavors
build.gradleAndroid extensions also work with multiple Android Product Flavors. For example if we have flavors in  like so:

And for example, only the free flavor has a buy button:


We can bind to the flavor specifically:


Chapter 35: Kotlin for Java Developers
Most people coming to Kotlin do have a programming background in Java.
This topic collects examples comparing Java to Kotlin, highlighting the most important differences and those gems Kotlin offers over Java.
Section 35.1: Declaring Variables
In Kotlin, variable declarations look a bit different than Java's:

	Java	Kotlin
int i = 42;var i = 42 (or var i : Int = 42)
final int i = 42;val i = 42Section 35.2: Quick Facts
val a = someMap["key"Kotlin does not need ; to end statements
Kotlin is null-safe
Kotlin is 100% Java interoperable
Kotlin has no primitives (but optimizes their object counterparts for the JVM, if possible)
Kotlin classes have properties, not fields
Kotlin offers data classes with auto-generated equals/hashCode methods and field accessors
Kotlin only has runtime Exceptions, no checked Exceptions
Kotlin has no new keyword. Creating objects is done just by calling the constructor like any other method.
Kotlin supports (limited) operator overloading. For example, accessing a value of a map can be written like:
]
Kotlin can not only be compiled to byte code for the JVM, but also into Java Script, enabling you to write both backend and frontend code in Kotlin
Kotlin is fully compatible with Java 6, which is especially interesting in regards for support of (not so) old Android devices
Kotlin is an officially supported language for Android development
 Kotlin's collections have built-in distinction between mutable and immutable collections. Kotlin supports Coroutines (experimental)
 Section 35.3: Equality & Identity
Kotlin uses == for equality (that is, calls equals internally) and === for referential identity.
	Java	Kotlin
a.equals(b);a == ba === ba == b;
a !== ba != b;
See: https://kotlinlang.org/docs/reference/equality.html
Section 35.4: IF, TRY and others are expressions, not statements
In Kotlin, if, try and others are expressions (so they do return a value) rather than (void) statements.
So, for example, Kotlin does not have Java's ternary Elvis Operator, but you can write something like this:

Even more unfamiliar, but equally expressive, is the try expression:


Chapter 36: Java 8 Stream Equivalents
Kotlin provides many extension methods on collections and iterables for applying functional-style operations. A dedicated Sequence type allows for lazy composition of several such operations.
Section 36.1: Accumulate names in a List

Section 36.2: Collect example #5 - find people of legal age, output formatted string

And as a side note, in Kotlin we can create simple data classes and instantiate the test data as follows:

Section 36.3: Collect example #6 - group people by age, print age and names together


Ok, a more interest case here for Kotlin. First the wrong answers to explore variations of creating a Map from a collection/sequence:

And now for the correct answer:

Person.nameWe just needed to join the matching values to collapse the lists and provide a transformer to joinToString to move from Person instance to the .
Section 36.4: Dierent Kinds of Streams #7 - lazily iterate Doubles, map to Int, map to String, print each

sequenceOf(1.0, 2.0, 3.0).map(Double::toInt).map { "a$it" }.forEach(::println)
Section 36.5: Counting items in a list after filter is applied

Section 36.6: Convert elements to strings and concatenate them, separated by commas

Section 36.7: Compute sum of salaries of employee

Section 36.8: Group employees by department

Section 36.9: Compute sum of salaries by department

Section 36.10: Partition students into passing and failing


Section 36.11: Names of male members

Section 36.12: Group names of members in roster by gender

Section 36.13: Filter a list to another list

Section 36.14: Finding shortest string a list

Section 36.15: Dierent Kinds of Streams #2 - lazily using first item if exists


Section 36.16: Dierent Kinds of Streams #3 - iterate a range of Integers

Section 36.17: Dierent Kinds of Streams #4 - iterate an array, map the values, calculate the average

Section 36.18: Dierent Kinds of Streams #5 - lazily iterate a list of strings, map the values, convert to Int, find max

Section 36.19: Dierent Kinds of Streams #6 - lazily iterate a stream of Ints, map the values, print results

Section 36.20: How streams work - filter, upper case, then sort a list

Section 36.21: Dierent Kinds of Streams #1 - eager using first item if it exists

or, create an extension function on String called ifPresent:

apply()See also:  function
See also: Extension Functions
See also: ?. Safe Call operator, and in general nullability:
http://stackoverflow.com/questions/34498562/in-kotlin-what-is-the-idiomatic-way-to-deal-with-nullable-values-refer encing-o/34498563#34498563
Section 36.22: Collect example #7a - Map names, join together with delimiter
// Java (verbose):
Collector<Person, StringJoiner, String> personNameCollector =
Collector.of(
        () -> new StringJoiner(" | "),          // supplier
        (j, p) -> j.add(p.name.toUpperCase()),  // accumulator
        (j1, j2) -> j1.merge(j2),               // combiner         StringJoiner::toString);                // finisher

Section 36.23: Collect example #7b - Collect with SummarizingInt

But it is better to create an extension function, 2 actually to match styles in Kotlin stdlib:
// Kotlin: inline fun Collection<Int>.summarizingInt(): SummaryStatisticsInt
        = this.fold(SummaryStatisticsInt()) { stats, num -> stats.accumulate(num) }
inline fun <T: Any> Collection<T>.summarizingInt(transform: (T)->Int): SummaryStatisticsInt =         this.fold(SummaryStatisticsInt()) { stats, item -> stats.accumulate(transform(item)) }
Now you have two ways to use the new summarizingInt functions:


And all of these produce the same results. We can also create this extension to work on Sequence and for appropriate primitive types.

Chapter 37: Kotlin Caveats
Section 37.1: Calling a toString() on a nullable type
A thing to look out for when using the toString method in Kotlin is the handling of null in combination with the
String?.
For example you want to get text from an EditText in Android.
You would have a piece of code like:

You would expect that if the field did not exists the value would be empty string but in this case it is "null".


Appendix A: Configuring Kotlin build
Section A.1: Gradle configuration
kotlin-gradle-plugin is used to compile Kotlin code with Gradle. Basically, its version should correspond to the
kotlin-gradle-pluginKotlin version you want to use. E.g. if you want to use Kotlin 1.0.3, then you need to apply version 1.0.3 too.
gradle.propertiesIt's a good idea to externalize this version in  or in ExtraPropertiesExtension:

Then you need to apply this plugin to your project. The way you do this differs when targeting different platforms:

Targeting Android

Targeting JS

These are the default paths:
src/main/kotlinsrc/main/javasrc/test/kotlinsrc/test/javasrc/main/resourcessrc/test/resourceskotlin sources: java sources: kotlin tests: java tests: runtime resources: test resources: 
You may need to configure SourceSets if you're using custom project layout.
Finally, you'll need to add Kotlin standard library dependency to your project:

compile "org.jetbrains.kotlin:kotlin-If you want to use Kotlin Reflection you'll also need to add 
reflect:$kotlin_version"
Section A.2: Using Android Studio
Android Studio can configure Kotlin automatically in an Android project.
Install the plugin
To install the Kotlin plugin, go to File > Settings > Editor > Plugins > Install JetBrains Plugin... > Kotlin > Install, then restart Android Studio when prompted.
Configure a project
Create an Android Studio project as normal, then press  Ctrl  +  Shift  +  A . In the search box, type "Configure Kotlin in Project" and press Enter.

Android Studio will alter your Gradle files to add all the necessary dependencies. Converting Java
ktTo convert your Java files to Kotlin files, press  Ctrl  +  Shift  +  A  and find "Convert Java File to Kotlin File". This will change the current file's extension to . and convert the code to Kotlin.

Section A.3: Migrating from Gradle using Groovy script to Kotlin script
Steps:
clone the gradle-script-kotlin project copy/paste from the cloned project to your project:
build.gradle.ktsgradlew.batsettings.gradle gradlew
build.gradle.kts update the content of the 	 based on your needs, you can use as inspiration the scripts in the project just cloned or in one of its samples
 now open Intellij and open your project, in the explorer window, it should be recognized as a Gradle project, if not, expand it first.
build.gradle.kts after opening, let Intellij works, open 	 and check if there are any error. If the highlighting is not working and/or is everything marked red, then close and reopen Intellij  open the Gradle window and refresh it
If you are on Windows, you may encounter this bug, download the full Gradle 3.3 distribution and use that instead the one provided. Related.
OSX and Ubuntu work out of the box.
Small bonus, if you want to avoid all the hassle of publishing on Maven and similar, use Jitpack, the lines to add are almost identical compared to Groovy. You can take inspiration from this project of mine.

Credits
Thank you greatly to all the people from Stack Overflow Documentation who helped provide this content, more changes can be sent to web@petercv.com for new content to be published or updated
Aaron ChristiansenChapters 7, 29 and 38AbdullahChapter 9Adam AroldChapter 29Alex FacciorussoChapter 9AscensionChapter 5atokChapter 26Avijit KarmakarChapter 17bahaChapter 7BradChapter 36byxorChapters 8 and 16CaelumChapter 22cyberscientistChapter 1Dávid TímárChapter 27David SorokoChapter 6DivyaChapters 19 and 20egor.zhdanChapter 4electChapter 38EspenChapter 12GersonChapter 36glee8eChapters 7 and 20HéctorChapters 22 and 29hotkeyChapter 18ice1000Chapter 28Jan Vladimir MostertChapter 19JanusonChapter 3Jayson MinardChapters 1, 7, 18, 19, 27, 29 and 36Jemo MgebrishviliChapters 21 and 34jenglertChapter 33jerekselChapter 32KeksArmeeChapters 7, 14, 16 and 18Kevin RobatelChapter 23Kirill RakhmanChapters 6, 9 and 26Konrad JamrozikChapters 27, 29 and 31madheadChapters 7, 26 and 38mayojavaChapters 10 and 29memoizrChapter 13Mohit SutharChapter 30MoodChapter 22Nihal SaxenaChapter 11olivierlemasleChapter 31oshaiChapter 31Parker HoyesChapters 1 and 27razzledazzleChapters 10, 14, 27 and 29Rich KuzsmaChapter 13RitaveChapters 19, 26 and 34RobinChapters 9, 10, 14 and 19Ruckus TChapter 1Sach	Chapter 1
Sam	Chapters 3, 4, 15 and 25
Sean Reilly	Chapter 1
Seaskyways	Chapter 25
SerCe	Chapters 6 and 14
Shinoo Goyal	Chapter 2
Slav	Chapters 16 and 24
Spidfire	Chapters 7, 9, 14 and 37 technerd	Chapter 14
Thorsten Schleinzer	Chapters 14 and 35
Travis	Chapter 12
UnKnown	Chapters 1 and 4

You may also like







GoalKicker.com - Kotlin(r) Notes for Professionals	1

GoalKicker.com - Kotlin(r) Notes for Professionals	1

GoalKicker.com - Kotlin(r) Notes for Professionals	1







