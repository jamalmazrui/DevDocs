<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C Notes for Professionals</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h1 id="table-of-contents">Table of Contents</h1>
<p><a
href="#chapter-9-iterators-...................................................................................................................................................-35"><u>Chapter
9: Iterators
...................................................................................................................................................
35</u></a></p>
<p><a
href="#chapter-10-basic-inputoutput-in-c-.............................................................................................................-43"><u>Chapter
10: Basic input/output in c++
.............................................................................................................
43</u></a></p>
<p><a
href="#chapter-11-loops-........................................................................................................................................................-44"><u>Chapter
11: Loops
........................................................................................................................................................
44</u></a></p>
<p><a
href="#chapter-12-file-io-....................................................................................................................................................-54"><u>Chapter
12: File I/O
....................................................................................................................................................
54</u></a></p>
<p><a
href="#chapter-13-c-streams-.........................................................................................................................................-65"><u>Chapter
13: C++ Streams
.........................................................................................................................................
65</u></a></p>
<p><a
href="#chapter-14-stream-manipulators-.....................................................................................................................-68"><u>Chapter
14: Stream manipulators
.....................................................................................................................
68</u></a></p>
<p><a
href="#chapter-15-flow-control-.........................................................................................................................................-77"><u>Chapter
15: Flow Control
.........................................................................................................................................
77</u></a></p>
<p><a
href="#chapter-16-metaprogramming-...........................................................................................................................-86"><u>Chapter
16: Metaprogramming
...........................................................................................................................
86</u></a></p>
<p><a
href="#chapter-17-const-keyword-....................................................................................................................................-95"><u>Chapter
17: const keyword
....................................................................................................................................
95</u></a></p>
<p><a
href="#chapter-18-mutable-keyword-..............................................................................................................................-99"><u>Chapter
18: mutable keyword
..............................................................................................................................
99</u></a></p>
<p><a
href="#chapter-19-friend-keyword-................................................................................................................................-101"><u>Chapter
19: Friend keyword
................................................................................................................................
101</u></a></p>
<p><a
href="#chapter-20-type-keywords-...............................................................................................................................-104"><u>Chapter
20: Type Keywords
...............................................................................................................................
104</u></a></p>
<p><a
href="#chapter-21-basic-type-keywords-....................................................................................................................-108"><u>Chapter
21: Basic Type Keywords
....................................................................................................................
108</u></a></p>
<p><a
href="#chapter-22-variable-declaration-keywords-..............................................................................................-111"><u>Chapter
22: Variable Declaration Keywords
..............................................................................................
111</u></a></p>
<p><a
href="#chapter-23-keywords-............................................................................................................................................-114"><u>Chapter
23: Keywords
............................................................................................................................................
114</u></a></p>
<p><a
href="#chapter-24-returning-several-values-from-a-function-.......................................................................-122"><u>Chapter
24: Returning several values from a function
.......................................................................
122</u></a></p>
<p><a
href="#chapter-25-polymorphism-..................................................................................................................................-129"><u>Chapter
25: Polymorphism
..................................................................................................................................
129</u></a></p>
<p><a
href="#chapter-26-references-.........................................................................................................................................-133"><u>Chapter
26: References
.........................................................................................................................................
133</u></a></p>
<p><a
href="#chapter-27-value-and-reference-semantics-............................................................................................-134"><u>Chapter
27: Value and Reference Semantics
............................................................................................
134</u></a></p>
<p><a href="#Chapter_28__C___function__call_b"><u>Chapter 28: C++
function "call by value" vs. "call by reference"
.................................................... 138</u></a></p>
<p><a
href="#chapter-29-copying-vs-assignment-...............................................................................................................-140"><u>Chapter
29: Copying vs Assignment
...............................................................................................................
140</u></a></p>
<p><a
href="#chapter-30-pointers-...............................................................................................................................................-143"><u>Chapter
30: Pointers
...............................................................................................................................................
143</u></a></p>
<p><a
href="#chapter-31-pointers-to-members-.....................................................................................................................-147"><u>Chapter
31: Pointers to members
.....................................................................................................................
147</u></a></p>
<p><a
href="#chapter-32-the-this-pointer-..............................................................................................................................-150"><u>Chapter
32: The This Pointer
..............................................................................................................................
150</u></a></p>
<p><a
href="#chapter-33-smart-pointers-.................................................................................................................................-158"><u>Chapter
33: Smart Pointers
.................................................................................................................................
158</u></a></p>
<p><a
href="#chapter-34-classesstructures-.......................................................................................................................-170"><u>Chapter
34: Classes/Structures
.......................................................................................................................
170</u></a></p>
<p><a
href="#chapter-35-function-overloading-...................................................................................................................-195"><u>Chapter
35: Function Overloading
...................................................................................................................
195</u></a></p>
<p><a
href="#chapter-36-operator-overloading-.................................................................................................................-199"><u>Chapter
36: Operator Overloading
.................................................................................................................
199</u></a></p>
<p><a href="#Chapter_37__Function_Template_Ov"><u>Chapter 37: Function
Template Overloading
.............................................................................................
213</u></a></p>
<p><a
href="#chapter-38-virtual-member-functions-.........................................................................................................-214"><u>Chapter
38: Virtual Member Functions
.........................................................................................................
214</u></a></p>
<p><a href="#Chapter_39__Inline_functions"><u>Chapter 39: Inline
functions
.................................................................................................................................
220</u></a></p>
<p><a href="#Chapter_40__Special_Member_Funct"><u>Chapter 40: Special
Member Functions
........................................................................................................
222</u></a></p>
<p><a
href="#chapter-41-non-static-member-functions-.................................................................................................-228"><u>Chapter
41: Non-Static Member Functions
.................................................................................................
228</u></a></p>
<p><a
href="#chapter-42-constant-class-member-functions-........................................................................................-235"><u>Chapter
42: Constant class member functions
........................................................................................
235</u></a></p>
<p><a
href="#chapter-43-c-containers-................................................................................................................................-236"><u>Chapter
43: C++ Containers
................................................................................................................................
236</u></a></p>
<p><a
href="#chapter-44-namespaces-....................................................................................................................................-237"><u>Chapter
44: Namespaces
....................................................................................................................................
237</u></a></p>
<p><a
href="#chapter-45-header-files-.....................................................................................................................................-246"><u>Chapter
45: Header Files
.....................................................................................................................................
246</u></a></p>
<p><a
href="#chapter-46-using-declaration-..........................................................................................................................-248"><u>Chapter
46: Using declaration
..........................................................................................................................
248</u></a></p>
<p><a href="#Chapter_47__std__string"><u>Chapter 47: std::string
...........................................................................................................................................
250</u></a></p>
<p><a
href="#chapter-48-stdarray-...........................................................................................................................................-263"><u>Chapter
48: std::array
...........................................................................................................................................
263</u></a></p>
<p><a
href="#chapter-49-stdvector-.........................................................................................................................................-267"><u>Chapter
49: std::vector
.........................................................................................................................................
267</u></a></p>
<p><a
href="#chapter-50-stdmap-..............................................................................................................................................-287"><u>Chapter
50: std::map
..............................................................................................................................................
287</u></a></p>
<p><a
href="#chapter-51-stdoptional-.......................................................................................................................................-295"><u>Chapter
51: std::optional
.......................................................................................................................................
295</u></a></p>
<p><a href="#Chapter_52__std__function__To_wr"><u>Chapter 52:
std::function: To wrap any element that is callable
.................................................... 299</u></a></p>
<p><a
href="#chapter-53-stdforward_list-.............................................................................................................................-305"><u>Chapter
53: std::forward_list
.............................................................................................................................
305</u></a></p>
<p><a
href="#chapter-54-stdpair-..............................................................................................................................................-307"><u>Chapter
54: std::pair
..............................................................................................................................................
307</u></a></p>
<p><a href="#Chapter_55__std__atomics"><u>Chapter 55: std::atomics
.......................................................................................................................................
309</u></a></p>
<p><a
href="#chapter-56-stdvariant-........................................................................................................................................-311"><u>Chapter
56: std::variant
........................................................................................................................................
311</u></a></p>
<p><a
href="#chapter-57-stdiomanip-......................................................................................................................................-314"><u>Chapter
57: std::iomanip
......................................................................................................................................
314</u></a></p>
<p><a href="#Chapter_58__std__any"><u>Chapter 58: std::any
................................................................................................................................................
317</u></a></p>
<p><a href="#Chapter_59__std__set_and_std__mu"><u>Chapter 59: std::set
and std::multiset
............................................................................................................
318</u></a></p>
<p><a
href="#chapter-60-stdinteger_sequence-................................................................................................................-325"><u>Chapter
60: std::integer_sequence
................................................................................................................
325</u></a></p>
<p><a
href="#chapter-61-using-stdunordered_map-........................................................................................................-328"><u>Chapter
61: Using std::unordered_map
........................................................................................................
328</u></a></p>
<p><a
href="#chapter-62-standard-library-algorithms-...................................................................................................-329"><u>Chapter
62: Standard Library Algorithms
...................................................................................................
329</u></a></p>
<p><a
href="#chapter-63-the-iso-c-standard-..................................................................................................................-339"><u>Chapter
63: The ISO C++ Standard
..................................................................................................................
339</u></a></p>
<p><a
href="#chapter-64-inline-variables-................................................................................................................................-344"><u>Chapter
64: Inline variables
................................................................................................................................
344</u></a></p>
<p><a
href="#chapter-65-random-number-generation-...................................................................................................-345"><u>Chapter
65: Random number generation
...................................................................................................
345</u></a></p>
<p><a
href="#chapter-66-date-and-time-using-chrono-header-................................................................................-347"><u>Chapter
66: Date and time using &lt;chrono&gt; header
................................................................................
347</u></a></p>
<p><a
href="#chapter-67-sorting-.................................................................................................................................................-349"><u>Chapter
67: Sorting
.................................................................................................................................................
349</u></a></p>
<p><a
href="#chapter-68-enumeration-.....................................................................................................................................-355"><u>Chapter
68: Enumeration
.....................................................................................................................................
355</u></a></p>
<p><a
href="#chapter-69-iteration-..............................................................................................................................................-359"><u>Chapter
69: Iteration
..............................................................................................................................................
359</u></a></p>
<p><a
href="#chapter-70-regular-expressions-.....................................................................................................................-361"><u>Chapter
70: Regular expressions
.....................................................................................................................
361</u></a></p>
<p><a
href="#chapter-71-implementation-defined-behavior-.........................................................................................-366"><u>Chapter
71: Implementation-defined behavior
.........................................................................................
366</u></a></p>
<p><a
href="#chapter-72-exceptions-..........................................................................................................................................-372"><u>Chapter
72: Exceptions
..........................................................................................................................................
372</u></a></p>
<p><a
href="#chapter-73-lambdas-.............................................................................................................................................-382"><u>Chapter
73: Lambdas
.............................................................................................................................................
382</u></a></p>
<p><a
href="#chapter-74-value-categories-...........................................................................................................................-396"><u>Chapter
74: Value Categories
...........................................................................................................................
396</u></a></p>
<p><a
href="#chapter-75-preprocessor-....................................................................................................................................-399"><u>Chapter
75: Preprocessor
....................................................................................................................................
399</u></a></p>
<p><a
href="#chapter-76-data-structures-in-c-................................................................................................................-410"><u>Chapter
76: Data Structures in C++
................................................................................................................
410</u></a></p>
<p><a
href="#chapter-77-templates-..........................................................................................................................................-413"><u>Chapter
77: Templates
..........................................................................................................................................
413</u></a></p>
<p><a href="#Chapter_78__Expression_templates"><u>Chapter 78: Expression
templates
...................................................................................................................
425</u></a></p>
<p><a
href="#chapter-79-curiously-recurring-template-pattern-crtp-...............................................................-429"><u>Chapter
79: Curiously Recurring Template Pattern (CRTP)
...............................................................
429</u></a></p>
<p><a href="#Chapter_80__Threading"><u>Chapter 80: Threading
...........................................................................................................................................
432</u></a></p>
<p><a
href="#chapter-81-thread-synchronization-structures-.......................................................................................-443"><u>Chapter
81: Thread synchronization structures
.......................................................................................
443</u></a></p>
<p><a
href="#chapter-82-the-rule-of-three-five-and-zero-.........................................................................................-446"><u>Chapter
82: The Rule of Three, Five, And Zero
.........................................................................................
446</u></a></p>
<p><a
href="#chapter-83-raii-resource-acquisition-is-initialization-.........................................................................-451"><u>Chapter
83: RAII: Resource Acquisition Is Initialization
.........................................................................
451</u></a></p>
<p><a
href="#chapter-84-rtti-run-time-type-information-........................................................................................-455"><u>Chapter
84: RTTI: Run-Time Type Information
........................................................................................
455</u></a></p>
<p><a
href="#chapter-85-mutexes-...............................................................................................................................................-457"><u>Chapter
85: Mutexes
...............................................................................................................................................
457</u></a></p>
<p><a
href="#chapter-86-recursive-mutex-..............................................................................................................................-460"><u>Chapter
86: Recursive Mutex
..............................................................................................................................
460</u></a></p>
<p><a
href="#chapter-87-semaphore-........................................................................................................................................-461"><u>Chapter
87: Semaphore
........................................................................................................................................
461</u></a></p>
<p><a
href="#chapter-88-futures-and-promises-..................................................................................................................-463"><u>Chapter
88: Futures and Promises
..................................................................................................................
463</u></a></p>
<p><a
href="#chapter-89-atomic-types-....................................................................................................................................-468"><u>Chapter
89: Atomic Types
....................................................................................................................................
468</u></a></p>
<p><a
href="#chapter-90-type-erasure-....................................................................................................................................-470"><u>Chapter
90: Type Erasure
....................................................................................................................................
470</u></a></p>
<p><a
href="#chapter-91-explicit-type-conversions-.............................................................................................................-482"><u>Chapter
91: Explicit type conversions
.............................................................................................................
482</u></a></p>
<p><a
href="#chapter-92-unnamed-types-...............................................................................................................................-488"><u>Chapter
92: Unnamed types
...............................................................................................................................
488</u></a></p>
<p><a href="#Chapter_93__Type_Traits"><u>Chapter 93: Type Traits
.........................................................................................................................................
490</u></a></p>
<p><a
href="#chapter-94-return-type-covariance-............................................................................................................-495"><u>Chapter
94: Return Type Covariance
............................................................................................................
495</u></a></p>
<p><a
href="#chapter-95-layout-of-object-types-................................................................................................................-497"><u>Chapter
95: Layout of object types
................................................................................................................
497</u></a></p>
<p><a
href="#chapter-96-type-inference-................................................................................................................................-501"><u>Chapter
96: Type Inference
................................................................................................................................
501</u></a></p>
<p><a
href="#chapter-97-typedef-and-type-aliases-..........................................................................................................-503"><u>Chapter
97: Typedef and type aliases
..........................................................................................................
503</u></a></p>
<p><a
href="#chapter-98-type-deduction-................................................................................................................................-505"><u>Chapter
98: type deduction
................................................................................................................................
505</u></a></p>
<p><a href="#Chapter_99__Trailing_return_type"><u>Chapter 99: Trailing
return type
.......................................................................................................................
508</u></a></p>
<p><a
href="#chapter-100-alignment-.........................................................................................................................................-509"><u>Chapter
100: Alignment
.........................................................................................................................................
509</u></a></p>
<p><a
href="#chapter-101-perfect-forwarding-......................................................................................................................-511"><u>Chapter
101: Perfect Forwarding
......................................................................................................................
511</u></a></p>
<p><a
href="#chapter-102-decltype-............................................................................................................................................-512"><u>Chapter
102: decltype
............................................................................................................................................
512</u></a></p>
<p><a
href="#chapter-103-sfinae-substitution-failure-is-not-an-error-................................................................-513"><u>Chapter
103: SFINAE (Substitution Failure Is Not An Error)
................................................................
513</u></a></p>
<p><a href="#Chapter_104__Undefined_Behavior"><u>Chapter 104: Undefined
Behavior
....................................................................................................................
522</u></a></p>
<p><a
href="#chapter-105-overload-resolution-....................................................................................................................-534"><u>Chapter
105: Overload resolution
....................................................................................................................
534</u></a></p>
<p><a
href="#chapter-106-move-semantics-............................................................................................................................-541"><u>Chapter
106: Move Semantics
............................................................................................................................
541</u></a></p>
<p><a
href="#chapter-107-pimpl-idiom-......................................................................................................................................-549"><u>Chapter
107: Pimpl Idiom
......................................................................................................................................
549</u></a></p>
<p><a
href="#chapter-108-auto-.....................................................................................................................................................-551"><u>Chapter
108: auto
.....................................................................................................................................................
551</u></a></p>
<p><a
href="#chapter-109-copy-elision-.....................................................................................................................................-555"><u>Chapter
109: Copy Elision
.....................................................................................................................................
555</u></a></p>
<p><a
href="#chapter-110-fold-expressions-............................................................................................................................-559"><u>Chapter
110: Fold Expressions
............................................................................................................................
559</u></a></p>
<p><a
href="#chapter-111-unions-...................................................................................................................................................-561"><u>Chapter
111: Unions
...................................................................................................................................................
561</u></a></p>
<p><a
href="#chapter-112-design-pattern-implementation-in-c-..............................................................................-563"><u>Chapter
112: Design pattern implementation in C++
..............................................................................
563</u></a></p>
<p><a
href="#chapter-113-singleton-design-pattern-..........................................................................................................-572"><u>Chapter
113: Singleton Design Pattern
..........................................................................................................
572</u></a></p>
<p><a href="#Chapter_114__User_Defined_Litera"><u>Chapter 114:
User-Defined Literals
..................................................................................................................
575</u></a></p>
<p><a
href="#chapter-115-memory-management-................................................................................................................-578"><u>Chapter
115: Memory management
................................................................................................................
578</u></a></p>
<p><a
href="#chapter-116-c11-memory-model-....................................................................................................................-581"><u>Chapter
116: C++11 Memory Model
....................................................................................................................
581</u></a></p>
<p><a
href="#chapter-117-scopes-.................................................................................................................................................-585"><u>Chapter
117: Scopes
.................................................................................................................................................
585</u></a></p>
<p><a
href="#chapter-118-static_assert-...................................................................................................................................-587"><u>Chapter
118: static_assert
...................................................................................................................................
587</u></a></p>
<p><a
href="#chapter-119-constexpr-...........................................................................................................................................-588"><u>Chapter
119: constexpr
...........................................................................................................................................
588</u></a></p>
<p><a
href="#chapter-120-one-definition-rule-odr-.......................................................................................................-592"><u>Chapter
120: One Definition Rule (ODR)
.......................................................................................................
592</u></a></p>
<p><a
href="#chapter-121-unspecified-behavior-...................................................................................................................-595"><u>Chapter
121: Unspecified behavior
...................................................................................................................
595</u></a></p>
<p><a
href="#chapter-122-argument-dependent-name-lookup-.................................................................................-600"><u>Chapter
122: Argument Dependent Name Lookup
.................................................................................
600</u></a></p>
<p><a
href="#chapter-123-attributes-..........................................................................................................................................-601"><u>Chapter
123: Attributes
..........................................................................................................................................
601</u></a></p>
<p><a
href="#chapter-124-recursion-in-c-...........................................................................................................................-605"><u>Chapter
124: Recursion in C++
...........................................................................................................................
605</u></a></p>
<p><a
href="#chapter-125-arithmitic-metaprogramming-................................................................................................-607"><u>Chapter
125: Arithmitic Metaprogramming
................................................................................................
607</u></a></p>
<p><a
href="#chapter-126-callable-objects-............................................................................................................................-609"><u>Chapter
126: Callable Objects
............................................................................................................................
609</u></a></p>
<p><a
href="#chapter-127-client-server-examples-..............................................................................................................-611"><u>Chapter
127: Client server examples
..............................................................................................................
611</u></a></p>
<p><a
href="#chapter-128-const-correctness-........................................................................................................................-616"><u>Chapter
128: Const Correctness
........................................................................................................................
616</u></a></p>
<p><a
href="#chapter-129-parameter-packs-..........................................................................................................................-624"><u>Chapter
129: Parameter packs
..........................................................................................................................
624</u></a></p>
<p><a
href="#chapter-130-build-systems-.................................................................................................................................-625"><u>Chapter
130: Build Systems
.................................................................................................................................
625</u></a></p>
<p><a
href="#chapter-131-concurrency-with-openmp-.......................................................................................................-630"><u>Chapter
131: Concurrency With OpenMP
.......................................................................................................
630</u></a></p>
<p><a href="#Chapter_132__Resource_Management"><u>Chapter 132: Resource
Management
..............................................................................................................
633</u></a></p>
<p><a
href="#chapter-133-storage-class-specifiers-............................................................................................................-636"><u>Chapter
133: Storage class specifiers
............................................................................................................
636</u></a></p>
<p><a
href="#chapter-134-linkage-specifications-...............................................................................................................-640"><u>Chapter
134: Linkage specifications
...............................................................................................................
640</u></a></p>
<p><a
href="#chapter-135-digit-separators-............................................................................................................................-642"><u>Chapter
135: Digit separators
............................................................................................................................
642</u></a></p>
<p><a
href="#chapter-136-c-incompatibilities-........................................................................................................................-643"><u>Chapter
136: C incompatibilities
........................................................................................................................
643</u></a></p>
<p><a href="#Chapter_137__Side_by_Side_Compar"><u>Chapter 137: Side by
Side Comparisons of classic C++ examples solved via C++ vs
C++11</u></a></p>
<p><a
href="#chapter-138-compiling-and-building-..............................................................................................................-645"><u>Chapter
138: Compiling and Building
..............................................................................................................
645</u></a></p>
<p><a
href="#chapter-139-common-compilelinker-errors-gcc-...............................................................................-661"><u>Chapter
139: Common compile/linker errors (GCC)
...............................................................................
661</u></a></p>
<p><a href="#Chapter_140__More_undefined_beha"><u>Chapter 140: More
undefined behaviors in C++
........................................................................................
664</u></a></p>
<p><a
href="#chapter-141-unit-testing-in-c-.......................................................................................................................-665"><u>Chapter
141: Unit Testing in C++
.......................................................................................................................
665</u></a></p>
<p><a href="#Chapter_142__C___Debugging_and_D"><u>Chapter 142: C++
Debugging and Debug-prevention Tools &amp; Techniques
................................. 667</u></a></p>
<p><a
href="#chapter-143-optimization-in-c-.....................................................................................................................-671"><u>Chapter
143: Optimization in C++
.....................................................................................................................
671</u></a></p>
<p><a
href="#chapter-144-optimization-..................................................................................................................................-676"><u>Chapter
144: Optimization
..................................................................................................................................
676</u></a></p>
<p><a href="#Chapter_145__Profiling"><u>Chapter 145: Profiling
.............................................................................................................................................
678</u></a></p>
<p><a
href="#chapter-146-refactoring-techniques-...........................................................................................................-681"><u>Chapter
146: Refactoring Techniques
...........................................................................................................
681</u></a></p>
<p><a href="#Chapter_1__Getting_started_with"><u>Chapter 1: Getting
started with C++</u></a></p>
<p><a href="#Chapter_2__Literals"><u>Chapter 2: Literals</u></a></p>
<p><a href="#Chapter_3__operator_precedence"><u>Chapter 3: operator
precedence</u></a></p>
<p><a href="#Chapter_4__Floating_Point_Arithm"><u>Chapter 4: Floating
Point Arithmetic</u></a></p>
<p><a href="#Chapter_5__Bit_Operators"><u>Chapter 5: Bit
Operators</u></a></p>
<p><a href="#Chapter_6__Bit_Manipulation"><u>Chapter 6: Bit
Manipulation</u></a></p>
<p><a href="#Chapter_7__Bit_fields"><u>Chapter 7: Bit fields</u></a></p>
<p><a href="#Chapter_8__Arrays"><u>Chapter 8: Arrays</u></a></p>
<p><a href="#Chapter_9__Iterators_1"><u>Chapter 9: Iterators</u></a></p>
<p><a href="#Chapter_10__Basic_input_output_i_1"><u>Chapter 10: Basic
input/output in c++</u></a></p>
<p><a href="#Chapter_11__Loops_1"><u>Chapter 11: Loops</u></a></p>
<p><a href="#Chapter_12__File_I_O_1"><u>Chapter 12: File I/O</u></a></p>
<p><a href="#Chapter_13__C___Streams_1"><u>Chapter 13: C++
Streams</u></a></p>
<p><a href="#Chapter_14__Stream_manipulators_1"><u>Chapter 14: Stream
manipulators</u></a></p>
<p><a href="#Chapter_15__Flow_Control_1"><u>Chapter 15: Flow
Control</u></a></p>
<p><a href="#Chapter_16__Metaprogramming_1"><u>Chapter 16:
Metaprogramming</u></a></p>
<p><a href="#Chapter_17__const_keyword_1"><u>Chapter 17: const
keyword</u></a></p>
<p><a href="#Chapter_18__mutable_keyword_1"><u>Chapter 18: mutable
keyword</u></a></p>
<p><a href="#Chapter_19__Friend_keyword_1"><u>Chapter 19: Friend
keyword</u></a></p>
<p><a href="#Chapter_20__Type_Keywords_1"><u>Chapter 20: Type
Keywords</u></a></p>
<p><a href="#Chapter_21__Basic_Type_Keywords_1"><u>Chapter 21: Basic
Type Keywords</u></a></p>
<p><a href="#Chapter_22__Variable_Declaration_1"><u>Chapter 22: Variable
Declaration</u></a></p>
<p><a href="#Chapter_23__Keywords_1"><u>Chapter 23: Keywords</u></a></p>
<p><a href="#Chapter_24__Returning_several_va_1"><u>Chapter 24:
Returning several values from</u></a></p>
<p><a href="#Chapter_25__Polymorphism_1"><u>Chapter 25:
Polymorphism</u></a></p>
<p><a href="#Chapter_26__References_1"><u>Chapter 26:
References</u></a></p>
<p><a href="#Chapter_27__Value_and_Reference_1"><u>Chapter 27: Value and
Reference</u></a></p>
<p><a href="#Chapter_28__C___function__call_b_1"><u>Chapter 28: C++
function "call by value" vs.</u></a></p>
<p><a href="#Chapter_29__Copying_vs_Assignmen_1"><u>Chapter 29: Copying
vs Assignment</u></a></p>
<p><a href="#Chapter_30__Pointers_1"><u>Chapter 30: Pointers</u></a></p>
<p><a href="#Chapter_31__Pointers_to_members_1"><u>Chapter 31: Pointers
to members</u></a></p>
<p><a href="#Chapter_32__The_This_Pointer_1"><u>Chapter 32: The This
Pointer</u></a></p>
<p><a href="#Chapter_33__Smart_Pointers_1"><u>Chapter 33: Smart
Pointers</u></a></p>
<p><a href="#Chapter_34__Classes_Structures_1"><u>Chapter 34:
Classes/Structures</u></a></p>
<p><a href="#Chapter_35__Function_Overloading_1"><u>Chapter 35: Function
Overloading</u></a></p>
<p><a href="#Chapter_36__Operator_Overloading_1"><u>Chapter 36: Operator
Overloading</u></a></p>
<p><a href="#Chapter_37__Function_Template"><u>Chapter 37: Function
Template</u></a></p>
<p><a href="#Chapter_38__Virtual_Member_Funct_1"><u>Chapter 38: Virtual
Member Functions</u></a></p>
<p><a href="#Chapter_39__Inline_functions_1"><u>Chapter 39: Inline
functions</u></a></p>
<p><a href="#Chapter_40__Special_Member_Funct_1"><u>Chapter 40: Special
Member Functions</u></a></p>
<p><a href="#Chapter_41__Non_Static_Member_Fu_1"><u>Chapter 41:
Non-Static Member Functions</u></a></p>
<p><a href="#Chapter_42__Constant_class_membe_1"><u>Chapter 42: Constant
class member</u></a></p>
<p><a href="#Chapter_43__C___Containers_1"><u>Chapter 43: C++
Containers</u></a></p>
<p><a href="#Chapter_44__Namespaces_1"><u>Chapter 44:
Namespaces</u></a></p>
<p><a href="#Chapter_45__Header_Files_1"><u>Chapter 45: Header
Files</u></a></p>
<p><a href="#Chapter_46__Using_declaration_1"><u>Chapter 46: Using
declaration</u></a></p>
<p><a href="#Chapter_47__std__string_1"><u>Chapter 47:
std::string</u></a></p>
<p><a href="#Chapter_48__std__array_1"><u>Chapter 48:
std::array</u></a></p>
<p><a href="#Chapter_49__std__vector_1"><u>Chapter 49:
std::vector</u></a></p>
<p><a href="#Chapter_50__std__map_1"><u>Chapter 50: std::map</u></a></p>
<p><a href="#Chapter_51__std__optional_1"><u>Chapter 51:
std::optional</u></a></p>
<p><a href="#Chapter_52__std__function__To_wr_1"><u>Chapter 52:
std::function: To wrap any</u></a></p>
<p><a href="#Chapter_53__std__forward_list_1"><u>Chapter 53:
std::forward_list</u></a></p>
<p><a href="#Chapter_54__std__pair_1"><u>Chapter 54:
std::pair</u></a></p>
<p><a href="#Chapter_55__std__atomics_1"><u>Chapter 55:
std::atomics</u></a></p>
<p><a href="#Chapter_56__std__variant_1"><u>Chapter 56:
std::variant</u></a></p>
<p><a href="#Chapter_57__std__iomanip_1"><u>Chapter 57:
std::iomanip</u></a></p>
<p><a href="#Chapter_58__std__any_1"><u>Chapter 58: std::any</u></a></p>
<p><a href="#Chapter_59__std__set_and_std__mu_1"><u>Chapter 59: std::set
and std::multiset</u></a></p>
<p><a href="#Chapter_60__std__integer_sequenc_1"><u>Chapter 60:
std::integer_sequence</u></a></p>
<p><a href="#Chapter_61__Using_std__unordered_1"><u>Chapter 61: Using
std::unordered_map</u></a></p>
<p><a href="#Chapter_62__Standard_Library_Alg_1"><u>Chapter 62: Standard
Library Algorithms</u></a></p>
<p><a href="#Chapter_63__The_ISO_C___Standard_1"><u>Chapter 63: The ISO
C++ Standard</u></a></p>
<p><a href="#Chapter_64__Inline_variables_1"><u>Chapter 64: Inline
variables</u></a></p>
<p><a href="#Chapter_65__Random_number_genera_1"><u>Chapter 65: Random
number generation</u></a></p>
<p><a href="#Chapter_66__Date_and_time_using_1"><u>Chapter 66: Date and
time using &lt;chrono&gt;</u></a></p>
<p><a href="#Chapter_67__Sorting_1"><u>Chapter 67: Sorting</u></a></p>
<p><a href="#Chapter_68__Enumeration_1"><u>Chapter 68:
Enumeration</u></a></p>
<p><a href="#Chapter_69__Iteration_1"><u>Chapter 69:
Iteration</u></a></p>
<p><a href="#Chapter_70__Regular_expressions_1"><u>Chapter 70: Regular
expressions</u></a></p>
<p><a href="#Chapter_71__Implementation_defin_1"><u>Chapter 71:
Implementation-defined</u></a></p>
<p><a href="#Chapter_72__Exceptions_1"><u>Chapter 72:
Exceptions</u></a></p>
<p><a href="#Chapter_73__Lambdas_1"><u>Chapter 73: Lambdas</u></a></p>
<p><a href="#Chapter_74__Value_Categories_1"><u>Chapter 74: Value
Categories</u></a></p>
<p><a href="#Chapter_75__Preprocessor_1"><u>Chapter 75:
Preprocessor</u></a></p>
<p><a href="#Chapter_76__Data_Structures_in_C_1"><u>Chapter 76: Data
Structures in C++</u></a></p>
<p><a href="#Chapter_77__Templates_1"><u>Chapter 77:
Templates</u></a></p>
<p><a href="#Chapter_78__Expression_templates_1"><u>Chapter 78:
Expression templates</u></a></p>
<p><a href="#Chapter_79__Curiously_Recurring_1"><u>Chapter 79: Curiously
Recurring Template</u></a></p>
<p><a href="#Chapter_80__Threading_1"><u>Chapter 80:
Threading</u></a></p>
<p><a href="#Chapter_81__Thread_synchronizati_1"><u>Chapter 81: Thread
synchronization</u></a></p>
<p><a href="#Chapter_82__The_Rule_of_Three__F_1"><u>Chapter 82: The Rule
of Three, Five, And</u></a></p>
<p><a href="#Chapter_83__RAII__Resource_Acqui_1"><u>Chapter 83: RAII:
Resource Acquisition Is</u></a></p>
<p><a href="#Chapter_84__RTTI__Run_Time_Type_1"><u>Chapter 84: RTTI:
Run-Time Type</u></a></p>
<p><a href="#Chapter_85__Mutexes_1"><u>Chapter 85: Mutexes</u></a></p>
<p><a href="#Chapter_86__Recursive_Mutex_1"><u>Chapter 86: Recursive
Mutex</u></a></p>
<p><a href="#Chapter_87__Semaphore_1"><u>Chapter 87:
Semaphore</u></a></p>
<p><a href="#Chapter_88__Futures_and_Promises_1"><u>Chapter 88: Futures
and Promises</u></a></p>
<p><a href="#Chapter_89__Atomic_Types_1"><u>Chapter 89: Atomic
Types</u></a></p>
<p><a href="#Chapter_90__Type_Erasure_1"><u>Chapter 90: Type
Erasure</u></a></p>
<p><a href="#Chapter_91__Explicit_type_conver_1"><u>Chapter 91: Explicit
type conversions</u></a></p>
<p><a href="#Chapter_92__Unnamed_types_1"><u>Chapter 92: Unnamed
types</u></a></p>
<p><a href="#Chapter_93__Type_Traits_1"><u>Chapter 93: Type
Traits</u></a></p>
<p><a href="#Chapter_94__Return_Type_Covarian_1"><u>Chapter 94: Return
Type Covariance</u></a></p>
<p><a href="#Chapter_95__Layout_of_object_typ_1"><u>Chapter 95: Layout
of object types</u></a></p>
<p><a href="#Chapter_96__Type_Inference_1"><u>Chapter 96: Type
Inference</u></a></p>
<p><a href="#Chapter_97__Typedef_and_type_ali_1"><u>Chapter 97: Typedef
and type aliases</u></a></p>
<p><a href="#Chapter_98__type_deduction_1"><u>Chapter 98: type
deduction</u></a></p>
<p><a href="#Chapter_99__Trailing_return_type_1"><u>Chapter 99: Trailing
return type</u></a></p>
<p><a href="#Chapter_100__Alignment_1"><u>Chapter 100:
Alignment</u></a></p>
<p><a href="#Chapter_101__Perfect_Forwarding_1"><u>Chapter 101: Perfect
Forwarding</u></a></p>
<p><a href="#Chapter_102__decltype_1"><u>Chapter 102:
decltype</u></a></p>
<p><a href="#Chapter_103__SFINAE__Substitutio_1"><u>Chapter 103: SFINAE
(Substitution Failure Is</u></a></p>
<p><a href="#Chapter_104__Undefined_Behavior_1"><u>Chapter 104:
Undefined Behavior</u></a></p>
<p><a href="#Chapter_105__Overload_resolution_1"><u>Chapter 105:
Overload resolution</u></a></p>
<p><a href="#Chapter_106__Move_Semantics_1"><u>Chapter 106: Move
Semantics</u></a></p>
<p><a href="#Chapter_107__Pimpl_Idiom_1"><u>Chapter 107: Pimpl
Idiom</u></a></p>
<p><a href="#Chapter_108__auto_1"><u>Chapter 108: auto</u></a></p>
<p><a href="#Chapter_109__Copy_Elision_1"><u>Chapter 109: Copy
Elision</u></a></p>
<p><a href="#Chapter_110__Fold_Expressions_1"><u>Chapter 110: Fold
Expressions</u></a></p>
<p><a href="#Chapter_111__Unions_1"><u>Chapter 111: Unions</u></a></p>
<p><a href="#Chapter_112__Design_pattern"><u>Chapter 112: Design
pattern</u></a></p>
<p><a href="#Chapter_113__Singleton_Design_Pa_1"><u>Chapter 113:
Singleton Design Pattern</u></a></p>
<p><a href="#Chapter_114__User_Defined_Litera_1"><u>Chapter 114:
User-Defined Literals</u></a></p>
<p><a href="#Chapter_115__Memory_management_1"><u>Chapter 115: Memory
management</u></a></p>
<p><a href="#Chapter_116__C__11_Memory_Model_1"><u>Chapter 116: C++11
Memory Model</u></a></p>
<p><a href="#Chapter_117__Scopes_1"><u>Chapter 117: Scopes</u></a></p>
<p><a href="#Chapter_118__static_assert_1"><u>Chapter 118:
static_assert</u></a></p>
<p><a href="#Chapter_119__constexpr_1"><u>Chapter 119:
constexpr</u></a></p>
<p><a href="#Chapter_120__One_Definition_Rule_1"><u>Chapter 120: One
Definition Rule (ODR)</u></a></p>
<p><a href="#Chapter_121__Unspecified_behavio_1"><u>Chapter 121:
Unspecified behavior</u></a></p>
<p><a href="#Chapter_122__Argument_Dependent_1"><u>Chapter 122: Argument
Dependent Name</u></a></p>
<p><a href="#Chapter_123__Attributes_1"><u>Chapter 123:
Attributes</u></a></p>
<p><a href="#Chapter_124__Recursion_in_C_1"><u>Chapter 124: Recursion in
C++</u></a></p>
<p><a href="#Chapter_125__Arithmitic_Metaprog_1"><u>Chapter 125:
Arithmitic Metaprogramming</u></a></p>
<p><a href="#Chapter_126__Callable_Objects_1"><u>Chapter 126: Callable
Objects</u></a></p>
<p><a href="#Chapter_127__Client_server_examp_1"><u>Chapter 127: Client
server examples</u></a></p>
<p><a href="#Chapter_128__Const_Correctness_1"><u>Chapter 128: Const
Correctness</u></a></p>
<p><a href="#Chapter_129__Parameter_packs_1"><u>Chapter 129: Parameter
packs</u></a></p>
<p><a href="#Chapter_130__Build_Systems_1"><u>Chapter 130: Build
Systems</u></a></p>
<p><a href="#Chapter_131__Concurrency_With_Op_1"><u>Chapter 131:
Concurrency With OpenMP</u></a></p>
<p><a href="#Chapter_132__Resource_Management_1"><u>Chapter 132:
Resource Management</u></a></p>
<p><a href="#Chapter_133__Storage_class_speci_1"><u>Chapter 133: Storage
class specifiers</u></a></p>
<p><a href="#Chapter_134__Linkage_specificati_1"><u>Chapter 134: Linkage
specifications</u></a></p>
<p><a href="#Chapter_135__Digit_separators_1"><u>Chapter 135: Digit
separators</u></a></p>
<p><a href="#Chapter_136__C_incompatibilities_1"><u>Chapter 136: C
incompatibilities</u></a></p>
<p><a href="#Chapter_137__Side_by_Side_Compar_1"><u>Chapter 137: Side by
Side Comparisons of</u></a></p>
<p><a href="#Chapter_138__Compiling_and_Build_1"><u>Chapter 138:
Compiling and Building</u></a></p>
<p><a href="#Chapter_139__Common_compile_link_1"><u>Chapter 139: Common
compile/linker</u></a></p>
<p><a href="#Chapter_140__More_undefined_beha_1"><u>Chapter 140: More
undefined behaviors in</u></a></p>
<p><a href="#Chapter_141__Unit_Testing_in_C_1"><u>Chapter 141: Unit
Testing in C++</u></a></p>
<p><a href="#Chapter_142__C___Debugging_and_D_1"><u>Chapter 142: C++
Debugging and Debug-</u></a></p>
<p><a href="#Chapter_143__Optimization_in_C_1"><u>Chapter 143:
Optimization in C++</u></a></p>
<p><a href="#Chapter_144__Optimization_1"><u>Chapter 144:
Optimization</u></a></p>
<p><a href="#Chapter_145__Profiling_1"><u>Chapter 145:
Profiling</u></a></p>
<p><a href="#Chapter_146__Refactoring_Techniq_1"><u>Chapter 146:
Refactoring Techniques</u></a></p>
<p>Notes for Professionals C++ C++ <strong>Notes for
Professionals</strong></p>
<p><img src="media/index-1_1.jpeg" style="width:6.5in;height:4.02778in"
alt="index-1_1.jpg" /></p>
<p>600+ pages</p>
<p>of professional hints and tricks</p>
<p><a href="https://goalkicker.com">GoalKicker.com</a> Disclaimer</p>
<p>This is an unocial free book created for educational purposes and
is</p>
<p><a href="https://goalkicker.com">Free Programming Books</a> not
aliated with ocial C++ group(s) or company(s).</p>
<p>All trademarks and registered trademarks are</p>
<p>the property of their respective owners</p>
<p>Contents</p>
<p><a href="#About"><strong>About</strong></a>
...................................................................................................................................................................................
<a href="#About">1</a></p>
<p><a href="#Chapter_1__Getting_started_with"><strong>Chapter 1: Getting
started with C++</strong></a>
....................................................................................................................
<a href="#Chapter_1__Getting_started_with">2</a></p>
<p><a href="#Chapter_1__Getting_started_with">Section 1.1: Hello
World</a>
.................................................................................................................................................
<a href="#Chapter_1__Getting_started_with">2</a></p>
<p><a href="#std__cout_____Hello_World______s">Section 1.2: Comments</a>
..................................................................................................................................................
<a href="#std__cout_____Hello_World______s">3</a></p>
<p><a href="#Comment_markers_used_to_disable">Section 1.3: The standard
C++ compilation process</a>
..................................................................................................
<a href="#Comment_markers_used_to_disable">5</a></p>
<p><a href="#Comment_markers_used_to_disable">Section 1.4: Function</a>
......................................................................................................................................................
<a href="#Comment_markers_used_to_disable">5</a></p>
<p><a href="#aesthetics__e_g__the___character">Section 1.5: Visibility
of function prototypes and declarations</a>
.................................................................................
<a href="#aesthetics__e_g__the___character">8</a></p>
<p><a href="#The_prototype_must_specify_the_r">Section 1.6:
Preprocessor</a>
..............................................................................................................................................
<a href="#The_prototype_must_specify_the_r">9</a></p>
<p><a href="#Chapter_2__Literals"><strong>Chapter 2:
Literals</strong></a>
......................................................................................................................................................
<a href="#Chapter_2__Literals">11</a></p>
<p><a href="#Chapter_2__Literals">Section 2.1: this</a>
.............................................................................................................................................................
<a href="#Chapter_2__Literals">11</a></p>
<p><a href="#Chapter_2__Literals">Section 2.2: Integer literal</a>
...........................................................................................................................................
<a href="#Chapter_2__Literals">11</a></p>
<p><a href="#int_o___052">Section 2.3: true</a>
...........................................................................................................................................................
<a href="#int_o___052">12</a></p>
<p><a href="#Section_2_4__false">Section 2.4: false</a>
..........................................................................................................................................................
<a href="#Section_2_4__false">13</a></p>
<p><a href="#Section_2_4__false">Section 2.5: nullptr</a>
.......................................................................................................................................................
<a href="#Section_2_4__false">13</a></p>
<p><a href="#Chapter_3__operator_precedence"><strong>Chapter 3: operator
precedence</strong></a>
........................................................................................................................
<a href="#Chapter_3__operator_precedence">14</a></p>
<p><a href="#Chapter_3__operator_precedence">Section 3.1: Logical
&amp;&amp; and || operators: short-circuit</a>
..............................................................................................
<a href="#Chapter_3__operator_precedence">14</a></p>
<p><a href="#">Section 3.2: Unary Operators</a>
.....................................................................................................................................
<a href="#">15</a></p>
<p><a href="#">Section 3.3: Arithmetic operators</a>
..............................................................................................................................
<a href="#">15</a></p>
<p><a href="#int_i___3_3_1_3_____________equa">Section 3.4: Logical AND
and OR operators</a>
............................................................................................................
<a href="#int_i___3_3_1_3_____________equa">16</a></p>
<p><a href="#Chapter_4__Floating_Point_Arithm"><strong>Chapter 4:
Floating Point Arithmetic</strong></a>
...............................................................................................................
<a href="#Chapter_4__Floating_Point_Arithm">17</a></p>
<p><a href="#Chapter_4__Floating_Point_Arithm">Section 4.1: Floating
Point Numbers are Weird</a>
........................................................................................................
<a href="#Chapter_4__Floating_Point_Arithm">17</a></p>
<p><a href="#Chapter_5__Bit_Operators"><strong>Chapter 5: Bit
Operators</strong></a>
........................................................................................................................................
<a href="#Chapter_5__Bit_Operators">18</a></p>
<p><a href="#Chapter_5__Bit_Operators">Section 5.1: | - bitwise OR</a>
............................................................................................................................................
<a href="#Chapter_5__Bit_Operators">18</a></p>
<p><a href="#Chapter_5__Bit_Operators">Section 5.2: ^ - bitwise XOR
(exclusive OR)</a>
..............................................................................................................
<a href="#Chapter_5__Bit_Operators">18</a></p>
<p><a href="#Section_5_3______bitwise_AND">Section 5.3: &amp; - bitwise
AND</a>
.......................................................................................................................................
<a href="#Section_5_3______bitwise_AND">20</a></p>
<p><a href="#Section_5_3______bitwise_AND">Section 5.4: &lt;&lt; - left
shift</a>
.............................................................................................................................................
<a href="#Section_5_3______bitwise_AND">20</a></p>
<p><a href="#_1">Section 5.5: &gt;&gt; - right shift</a>
..........................................................................................................................................
<a href="#_1">21</a></p>
<p><a href="#Chapter_6__Bit_Manipulation"><strong>Chapter 6: Bit
Manipulation</strong></a>
...................................................................................................................................
<a href="#Chapter_6__Bit_Manipulation">23</a></p>
<p><a href="#Chapter_6__Bit_Manipulation">Section 6.1: Remove rightmost
set bit</a>
.......................................................................................................................
<a href="#Chapter_6__Bit_Manipulation">23</a></p>
<p><a href="#Chapter_6__Bit_Manipulation">Section 6.2: Set all bits</a>
................................................................................................................................................
<a href="#Chapter_6__Bit_Manipulation">23</a></p>
<p><a href="#Chapter_6__Bit_Manipulation">Section 6.3: Toggling a
bit</a>
..........................................................................................................................................
<a href="#Chapter_6__Bit_Manipulation">23</a></p>
<p><a href="#Chapter_6__Bit_Manipulation">Section 6.4: Checking a
bit</a>
.........................................................................................................................................
<a href="#Chapter_6__Bit_Manipulation">23</a></p>
<p><a href="#number_in_the_expression_number">Section 6.5: Counting bits
set</a>
.....................................................................................................................................
<a href="#number_in_the_expression_number">24</a></p>
<p><a href="#built_in_function__E_g__with_g">Section 6.6: Check if an
integer is a power of 2</a>
.......................................................................................................
<a href="#built_in_function__E_g__with_g">25</a></p>
<p><a href="#built_in_function__E_g__with_g">Section 6.7: Setting a
bit</a>
.............................................................................................................................................
<a href="#built_in_function__E_g__with_g">25</a></p>
<p><a href="#built_in_function__E_g__with_g">Section 6.8: Clearing a
bit</a>
...........................................................................................................................................
<a href="#built_in_function__E_g__with_g">25</a></p>
<p><a href="#built_in_function__E_g__with_g">Section 6.9: Changing the
nth bit to x</a>
.......................................................................................................................
<a href="#built_in_function__E_g__with_g">25</a></p>
<p><a href="#std__bitset_5__num_std__string">Section 6.10: Bit
Manipulation Application: Small to Capital Letter</a>
........................................................................
<a href="#std__bitset_5__num_std__string">26</a></p>
<p><a href="#Chapter_7__Bit_fields"><strong>Chapter 7: Bit
fields</strong></a>
...................................................................................................................................................
<a href="#Chapter_7__Bit_fields">27</a></p>
<p><a href="#Chapter_7__Bit_fields">Section 7.1: Declaration and
Usage</a>
...........................................................................................................................
<a href="#Chapter_7__Bit_fields">27</a></p>
<p><a href="#Chapter_8__Arrays"><strong>Chapter 8: Arrays</strong></a>
.......................................................................................................................................................
<a href="#Chapter_8__Arrays">28</a></p>
<p><a href="#Chapter_8__Arrays">Section 8.1: Array initialization</a>
....................................................................................................................................
<a href="#Chapter_8__Arrays">28</a></p>
<p><a href="#Section_8_2__A_fixed_size_raw_ar">Section 8.2: A fixed size
raw array matrix (that is, a 2D raw array)</a>
......................................................................
<a href="#Section_8_2__A_fixed_size_raw_ar">29</a></p>
<p><a href="#Section_8_2__A_fixed_size_raw_ar">Section 8.3: Dynamically
sized raw array</a>
.................................................................................................................
<a href="#Section_8_2__A_fixed_size_raw_ar">29</a></p>
<p><a href="#auto_main">Section 8.4: Array size: type safe at compile
time</a>
...................................................................................................
<a href="#auto_main">30</a></p>
<p><a href="#___int">Section 8.5: Expanding dynamic size array by using
std::vector</a>
...........................................................................
<a href="#___int">31</a></p>
<p><a href="#int_const_n___a_size">Section 8.6: A dynamic size matrix
using std::vector for storage</a>
..........................................................................
<a href="#int_const_n___a_size">32</a></p>
<h1
id="chapter-9-iterators-...................................................................................................................................................-35"><a
href="#Chapter_9__Iterators_1">Chapter 9: Iterators</a>
...................................................................................................................................................
<a href="#Chapter_9__Iterators_1">35</a></h1>
<p><a href="#Chapter_9__Iterators_1">Section 9.1: Overview</a>
...................................................................................................................................................
<a href="#Chapter_9__Iterators_1">35</a></p>
<p><a href="#void_test_BidirIt_a__std__bidire">Section 9.2: Vector
Iterator</a>
........................................................................................................................................
<a href="#void_test_BidirIt_a__std__bidire">38</a></p>
<p><a href="#void_test_BidirIt_a__std__bidire">Section 9.3: Map
Iterator</a>
............................................................................................................................................
<a href="#void_test_BidirIt_a__std__bidire">38</a></p>
<p><a href="#___Iterate_over_all_tuples">Section 9.4: Reverse
Iterators</a>
....................................................................................................................................
<a href="#___Iterate_over_all_tuples">39</a></p>
<p><a href="#Section_9_5__Stream_Iterators">Section 9.5: Stream
Iterators</a>
......................................................................................................................................
<a href="#Section_9_5__Stream_Iterators">40</a></p>
<p><a href="#Section_9_5__Stream_Iterators">Section 9.6: C Iterators
(Pointers)</a>
..............................................................................................................................
<a href="#Section_9_5__Stream_Iterators">40</a></p>
<p><a href="#5">Section 9.7: Write your own generator-backed
iterator</a>
.........................................................................................
<a href="#5">41</a></p>
<h1
id="chapter-10-basic-inputoutput-in-c-.............................................................................................................-43"><a
href="#Chapter_10__Basic_input_output_i_1">Chapter 10: Basic
input/output in c++</a>
.............................................................................................................
<a href="#Chapter_10__Basic_input_output_i_1">43</a></h1>
<p><a href="#Chapter_10__Basic_input_output_i_1">Section 10.1: user
input and standard output</a>
...........................................................................................................
<a href="#Chapter_10__Basic_input_output_i_1">43</a></p>
<h1
id="chapter-11-loops-........................................................................................................................................................-44"><a
href="#Chapter_11__Loops_1">Chapter 11: Loops</a>
........................................................................................................................................................
<a href="#Chapter_11__Loops_1">44</a></h1>
<p><a href="#Chapter_11__Loops_1">Section 11.1: Range-Based For</a>
....................................................................................................................................
<a href="#Chapter_11__Loops_1">44</a></p>
<p><a href="#Any_type_which_has_member_functi">Section 11.2: For
loop</a>
...................................................................................................................................................
<a href="#Any_type_which_has_member_functi">46</a></p>
<p><a href="#The_initialization_and_increment">Section 11.3: While
loop</a>
...............................................................................................................................................
<a href="#The_initialization_and_increment">48</a></p>
<p><a href="#while__i___10">Section 11.4: Do-while loop</a>
..........................................................................................................................................
<a href="#while__i___10">49</a></p>
<p><a href="#std__cout____i">Section 11.5: Loop Control statements :
Break and Continue</a>
..................................................................................
<a href="#std__cout____i">50</a></p>
<p><a href="#1_is_an_odd_number">Section 11.6: Declaration of variables
in conditions</a>
.................................................................................................
<a href="#1_is_an_odd_number">51</a></p>
<p><a href="#This_is_because_the_statement_po">Section 11.7: Range-for
over a sub-range</a>
.................................................................................................................
<a href="#This_is_because_the_statement_po">52</a></p>
<h1
id="chapter-12-file-io-....................................................................................................................................................-54"><a
href="#Chapter_12__File_I_O_1">Chapter 12: File I/O</a>
....................................................................................................................................................
<a href="#Chapter_12__File_I_O_1">54</a></h1>
<p><a href="#Chapter_12__File_I_O_1">Section 12.1: Writing to a file</a>
.......................................................................................................................................
<a href="#Chapter_12__File_I_O_1">54</a></p>
<p><a href="#Chapter_12__File_I_O_1">Section 12.2: Opening a file</a>
........................................................................................................................................
<a href="#Chapter_12__File_I_O_1">54</a></p>
<p><a href="#std__fstream_iofs__foo_txt">Section 12.3: Reading from a
file</a>
...............................................................................................................................
<a href="#std__fstream_iofs__foo_txt">55</a></p>
<p><a href="#___Sets_contents_of__whole_file">Section 12.4: Opening
modes</a>
.....................................................................................................................................
<a href="#___Sets_contents_of__whole_file">57</a></p>
<p><a href="#Mode_Meaning____For">Section 12.5: Reading an ASCII file
into a std::string</a>
................................................................................................
<a href="#Mode_Meaning____For">58</a></p>
<p><a href="#const_auto_size___f_tellg">Section 12.6: Writing files with
non-standard locale settings</a>
..................................................................................
<a href="#const_auto_size___f_tellg">59</a></p>
<p><a href="#ensure_a_fixed_standard_for_read">Section 12.7: Checking
end of file inside a loop condition, bad practice?</a>
............................................................. <a
href="#ensure_a_fixed_standard_for_read">60</a></p>
<p><a href="#Section_12_8__Flushing_a_stream">Section 12.8: Flushing a
stream</a>
..................................................................................................................................
<a href="#Section_12_8__Flushing_a_stream">61</a></p>
<p><a href="#Section_12_8__Flushing_a_stream">Section 12.9: Reading a
file into a container</a>
.............................................................................................................
<a href="#Section_12_8__Flushing_a_stream">61</a></p>
<p><a href="#_4">Section 12.10: Copying a file</a>
.......................................................................................................................................
<a href="#_4">62</a></p>
<p><a href="#_4">Section 12.11: Closing a file</a>
..........................................................................................................................................
<a href="#_4">62</a></p>
<p><a href="#___Write_data_to_the_file__foo_t">Section 12.12: Reading a
`struct` from a formatted text file</a>
....................................................................................
<a href="#___Write_data_to_the_file__foo_t">63</a></p>
<h1
id="chapter-13-c-streams-.........................................................................................................................................-65"><a
href="#Chapter_13__C___Streams_1">Chapter 13: C++ Streams</a>
.........................................................................................................................................
<a href="#Chapter_13__C___Streams_1">65</a></h1>
<p><a href="#Chapter_13__C___Streams_1">Section 13.1: String streams</a>
........................................................................................................................................
<a href="#Chapter_13__C___Streams_1">65</a></p>
<p><a href="#Then_result_contains_the_string">Section 13.2: Printing
collections with iostream</a>
........................................................................................................
<a href="#Then_result_contains_the_string">66</a></p>
<h1
id="chapter-14-stream-manipulators-.....................................................................................................................-68"><a
href="#Chapter_14__Stream_manipulators_1">Chapter 14: Stream
manipulators</a>
.....................................................................................................................
<a href="#Chapter_14__Stream_manipulators_1">68</a></h1>
<p><a href="#Chapter_14__Stream_manipulators_1">Section 14.1: Stream
manipulators</a>
.............................................................................................................................
<a href="#Chapter_14__Stream_manipulators_1">68</a></p>
<p><a href="#_6">Section 14.2: Output stream manipulators</a>
...............................................................................................................
<a href="#_6">73</a></p>
<p><a href="#Section_14_3__Input_stream_manip">Section 14.3: Input
stream manipulators</a>
...................................................................................................................
<a href="#Section_14_3__Input_stream_manip">75</a></p>
<h1
id="chapter-15-flow-control-.........................................................................................................................................-77"><a
href="#Chapter_15__Flow_Control_1">Chapter 15: Flow Control</a>
.........................................................................................................................................
<a href="#Chapter_15__Flow_Control_1">77</a></h1>
<p><a href="#Chapter_15__Flow_Control_1">Section 15.1: case</a>
.........................................................................................................................................................
<a href="#Chapter_15__Flow_Control_1">77</a></p>
<p><a href="#Chapter_15__Flow_Control_1">Section 15.2: switch</a>
......................................................................................................................................................
<a href="#Chapter_15__Flow_Control_1">77</a></p>
<p><a href="#Chapter_15__Flow_Control_1">Section 15.3: catch</a>
.......................................................................................................................................................
<a href="#Chapter_15__Flow_Control_1">77</a></p>
<p><a href="#which_is_similar_in_form_to_a_fu">Section 15.4: throw</a>
.......................................................................................................................................................
<a href="#which_is_similar_in_form_to_a_fu">78</a></p>
<p><a href="#unsigned_int_predecessor_unsigne">Section 15.5: default</a>
....................................................................................................................................................
<a href="#unsigned_int_predecessor_unsigne">79</a></p>
<p><a href="#unsigned_int_predecessor_unsigne">Section 15.6: try</a>
............................................................................................................................................................
<a href="#unsigned_int_predecessor_unsigne">79</a></p>
<p><a href="#unsigned_int_predecessor_unsigne">Section 15.7: if</a>
...............................................................................................................................................................
<a href="#unsigned_int_predecessor_unsigne">79</a></p>
<p><a href="#std__cout_____Please_enter_a_pos">Section 15.8: else</a>
..........................................................................................................................................................
<a href="#std__cout_____Please_enter_a_pos">80</a></p>
<p><a href="#std__cout_____Please_enter_a_pos">Section 15.9: Conditional
Structures: if, if..else</a>
...........................................................................................................
<a href="#std__cout_____Please_enter_a_pos">80</a></p>
<p><a href="#__will_execute_if_a_is_a_string">Section 15.10: goto</a>
.......................................................................................................................................................
<a href="#__will_execute_if_a_is_a_string">81</a></p>
<p><a href="#__will_execute_if_a_is_a_string">Section 15.11: Jump
statements : break, continue, goto, exit</a>
...................................................................................
<a href="#__will_execute_if_a_is_a_string">81</a></p>
<p><a href="#goto_STEP">Section 15.12: return</a>
.....................................................................................................................................................
<a href="#goto_STEP">84</a></p>
<h1
id="chapter-16-metaprogramming-...........................................................................................................................-86"><a
href="#Chapter_16__Metaprogramming_1">Chapter 16: Metaprogramming</a>
...........................................................................................................................
<a href="#Chapter_16__Metaprogramming_1">86</a></h1>
<p><a href="#Chapter_16__Metaprogramming_1">Section 16.1: Calculating
Factorials</a>
............................................................................................................................
<a href="#Chapter_16__Metaprogramming_1">86</a></p>
<p><a href="#for__int_i___1__i____n____i">Section 16.2: Iterating over a
parameter pack</a>
.........................................................................................................
<a href="#for__int_i___1__i____n____i">88</a></p>
<p><a href="#template">Section 16.3: Iterating with
std::integer_sequence</a>
...................................................................................................
<a href="#template">89</a></p>
<p><a href="#auto_some_args___std__make_tuple">Section 16.4: Tag
Dispatching</a>
....................................................................................................................................
<a href="#auto_some_args___std__make_tuple">90</a></p>
<p><a href="#auto_some_args___std__make_tuple">Section 16.5: Detect
Whether Expression is Valid</a>
.....................................................................................................
<a href="#auto_some_args___std__make_tuple">90</a></p>
<p><a href="#Section_16_6__If_then_else">Section 16.6: If-then-else</a>
.............................................................................................................................................
<a href="#Section_16_6__If_then_else">92</a></p>
<p><a href="#Section_16_6__If_then_else">Section 16.7: Manual
distinction of types when given any type T</a>
..........................................................................
<a href="#Section_16_6__If_then_else">92</a></p>
<p><a href="#It_is_a_good_habit_to_provides">Section 16.8: Calculating
power with C++11 (and higher)</a>
.........................................................................................
<a href="#It_is_a_good_habit_to_provides">93</a></p>
<p><a href="#int_main">Section 16.9: Generic Min/Max with variable
argument count</a>
...............................................................................
<a href="#int_main">94</a></p>
<h1
id="chapter-17-const-keyword-....................................................................................................................................-95"><a
href="#Chapter_17__const_keyword_1">Chapter 17: const keyword</a>
....................................................................................................................................
<a href="#Chapter_17__const_keyword_1">95</a></h1>
<p><a href="#Chapter_17__const_keyword_1">Section 17.1: Avoiding
duplication of code in const and non-const getter methods</a>
............................................ <a
href="#Chapter_17__const_keyword_1">95</a></p>
<p><a href="#Examine_the_following_more_compl">Section 17.2: Const
member functions</a>
......................................................................................................................
<a href="#Examine_the_following_more_compl">96</a></p>
<p><a href="#could_not_be_declared_const">Section 17.3: Const local
variables</a>
.............................................................................................................................
<a href="#could_not_be_declared_const">97</a></p>
<p><a href="#could_not_be_declared_const">Section 17.4: Const
pointers</a>
........................................................................................................................................
<a href="#could_not_be_declared_const">97</a></p>
<h1
id="chapter-18-mutable-keyword-..............................................................................................................................-99"><a
href="#Chapter_18__mutable_keyword_1">Chapter 18: mutable keyword</a>
..............................................................................................................................
<a href="#Chapter_18__mutable_keyword_1">99</a></h1>
<p><a href="#Chapter_18__mutable_keyword_1">Section 18.1: mutable
lambdas</a>
...................................................................................................................................
<a href="#Chapter_18__mutable_keyword_1">99</a></p>
<p><a href="#Chapter_18__mutable_keyword_1">Section 18.2: non-static
class member modifier</a>
......................................................................................................
<a href="#Chapter_18__mutable_keyword_1">99</a></p>
<h1
id="chapter-19-friend-keyword-................................................................................................................................-101"><a
href="#Chapter_19__Friend_keyword_1">Chapter 19: Friend keyword</a>
................................................................................................................................
<a href="#Chapter_19__Friend_keyword_1">101</a></h1>
<p><a href="#Chapter_19__Friend_keyword_1">Section 19.1: Friend
function</a>
.....................................................................................................................................
<a href="#Chapter_19__Friend_keyword_1">101</a></p>
<p><a href="#std__cout____pd_derived_private">Section 19.2: Friend
method</a>
.....................................................................................................................................
<a href="#std__cout____pd_derived_private">102</a></p>
<p><a href="#std__cout____pd_derived_private">Section 19.3: Friend
class</a>
..........................................................................................................................................
<a href="#std__cout____pd_derived_private">102</a></p>
<h1
id="chapter-20-type-keywords-...............................................................................................................................-104"><a
href="#Chapter_20__Type_Keywords_1">Chapter 20: Type Keywords</a>
...............................................................................................................................
<a href="#Chapter_20__Type_Keywords_1">104</a></h1>
<p><a href="#Chapter_20__Type_Keywords_1">Section 20.1: class</a>
......................................................................................................................................................
<a href="#Chapter_20__Type_Keywords_1">104</a></p>
<p><a href="#_8">Section 20.2: enum
....................................................................................................................................................
105</a></p>
<p><a href="#enum_can_be_named_in_this_way_ev">Section 20.3: struct</a>
....................................................................................................................................................
<a href="#enum_can_be_named_in_this_way_ev">106</a></p>
<p><a href="#enum_can_be_named_in_this_way_ev">Section 20.4: union</a>
....................................................................................................................................................
<a href="#enum_can_be_named_in_this_way_ev">106</a></p>
<h1
id="chapter-21-basic-type-keywords-....................................................................................................................-108"><a
href="#Chapter_21__Basic_Type_Keywords_1">Chapter 21: Basic Type
Keywords</a>
....................................................................................................................
<a href="#Chapter_21__Basic_Type_Keywords_1">108</a></h1>
<p><a href="#Chapter_21__Basic_Type_Keywords_1">Section 21.1: char</a>
.......................................................................................................................................................
<a href="#Chapter_21__Basic_Type_Keywords_1">108</a></p>
<p><a href="#Chapter_21__Basic_Type_Keywords_1">Section 21.2: char16_t
................................................................................................................................................
108</a></p>
<p><a href="#Chapter_21__Basic_Type_Keywords_1">Section 21.3:
char32_t</a>
...............................................................................................................................................
<a href="#Chapter_21__Basic_Type_Keywords_1">108</a></p>
<p><a href="#Chapter_21__Basic_Type_Keywords_1">Section 21.4: int</a>
..........................................................................................................................................................
<a href="#Chapter_21__Basic_Type_Keywords_1">108</a></p>
<p><a href="#Chapter_21__Basic_Type_Keywords_1">Section 21.5: void</a>
.......................................................................................................................................................
<a href="#Chapter_21__Basic_Type_Keywords_1">108</a></p>
<p><a href="#The_type_void____pointer_to_void">Section 21.6: wchar_t</a>
................................................................................................................................................
<a href="#The_type_void____pointer_to_void">109</a></p>
<p><a href="#The_type_void____pointer_to_void">Section 21.7: float
.......................................................................................................................................................
109</a></p>
<p><a href="#The_type_void____pointer_to_void">Section 21.8: double
...................................................................................................................................................
109</a></p>
<p><a href="#The_type_void____pointer_to_void">Section 21.9: long</a>
.......................................................................................................................................................
<a href="#The_type_void____pointer_to_void">109</a></p>
<p><a href="#point_types">Section 21.10: short</a>
....................................................................................................................................................
<a href="#point_types">110</a></p>
<p><a href="#point_types">Section 21.11: bool</a>
......................................................................................................................................................
<a href="#point_types">110</a></p>
<h1
id="chapter-22-variable-declaration-keywords-..............................................................................................-111"><a
href="#Chapter_22__Variable_Declaration_1">Chapter 22: Variable
Declaration Keywords</a>
..............................................................................................
<a href="#Chapter_22__Variable_Declaration_1">111</a></h1>
<p><a href="#Chapter_22__Variable_Declaration_1">Section 22.1:
decltype</a>
...............................................................................................................................................
<a href="#Chapter_22__Variable_Declaration_1">111</a></p>
<p><a href="#Chapter_22__Variable_Declaration_1">Section 22.2: const</a>
....................................................................................................................................................
<a href="#Chapter_22__Variable_Declaration_1">111</a></p>
<p><a href="#int__r___x_____error">Section 22.3: volatile</a>
.................................................................................................................................................
<a href="#int__r___x_____error">112</a></p>
<p><a href="#int__r___x_____error">Section 22.4: signed</a>
..................................................................................................................................................
<a href="#int__r___x_____error">112</a></p>
<p><a href="#int__r___x_____error">Section 22.5: unsigned</a>
..............................................................................................................................................
<a href="#int__r___x_____error">112</a></p>
<h1
id="chapter-23-keywords-............................................................................................................................................-114"><a
href="#Chapter_23__Keywords_1">Chapter 23: Keywords</a>
............................................................................................................................................
<a href="#Chapter_23__Keywords_1">114</a></h1>
<p><a href="#Chapter_23__Keywords_1">Section 23.1: asm</a>
.......................................................................................................................................................
<a href="#Chapter_23__Keywords_1">114</a></p>
<p><a href="#Chapter_23__Keywords_1">Section 23.2: Dierent keywords</a>
.............................................................................................................................
<a href="#Chapter_23__Keywords_1">114</a></p>
<p><a href="#Class_members_as_friends">Section 23.3: typename</a>
............................................................................................................................................
<a href="#Class_members_as_friends">118</a></p>
<p><a href="#Section_23_4__explicit">Section 23.4: explicit</a>
..................................................................................................................................................
<a href="#Section_23_4__explicit">119</a></p>
<p><a href="#Section_23_4__explicit">Section 23.5: sizeof</a>
....................................................................................................................................................
<a href="#Section_23_4__explicit">119</a></p>
<p><a href="#The_char__signed_char__and_unsig">Section 23.6:
noexcept</a>
..............................................................................................................................................
<a href="#The_char__signed_char__and_unsig">120</a></p>
<h1
id="chapter-24-returning-several-values-from-a-function-.......................................................................-122"><a
href="#Chapter_24__Returning_several_va_1">Chapter 24: Returning several
values from a function</a>
.......................................................................
<a href="#Chapter_24__Returning_several_va_1">122</a></h1>
<p><a href="#Chapter_24__Returning_several_va_1">Section 24.1: Using
std::tuple</a>
....................................................................................................................................
<a href="#Chapter_24__Returning_several_va_1">122</a></p>
<p><a href="#if__b">Section 24.2: Structured Bindings</a>
............................................................................................................................
<a href="#if__b">123</a></p>
<p><a href="#double_d">Section 24.3: Using struct</a>
.........................................................................................................................................
<a href="#double_d">124</a></p>
<p><a href="#auto_calc___foo_5__12">Section 24.4: Using Output
Parameters
..................................................................................................................
125</a></p>
<p><a href="#e___a___b">Section 24.5: Using a Function Object Consumer
..................................................................................................
126</a></p>
<p><a href="#Section_24_6__Using_std__pair">Section 24.6: Using
std::pair</a>
.....................................................................................................................................
<a href="#Section_24_6__Using_std__pair">127</a></p>
<p><a href="#Section_24_6__Using_std__pair">Section 24.7: Using
std::array</a>
...................................................................................................................................
<a href="#Section_24_6__Using_std__pair">127</a></p>
<p><a href="#Section_24_6__Using_std__pair">Section 24.8: Using Output
Iterator</a>
.........................................................................................................................
<a href="#Section_24_6__Using_std__pair">127</a></p>
<p><a href="#_9">Section 24.9: Using std::vector</a>
.................................................................................................................................
<a href="#_9">128</a></p>
<h1
id="chapter-25-polymorphism-..................................................................................................................................-129"><a
href="#Chapter_25__Polymorphism_1">Chapter 25: Polymorphism</a>
..................................................................................................................................
<a href="#Chapter_25__Polymorphism_1">129</a></h1>
<p><a href="#Chapter_25__Polymorphism_1">Section 25.1: Define
polymorphic classes</a>
...............................................................................................................
<a href="#Chapter_25__Polymorphism_1">129</a></p>
<p><a href="#Some_explanations">Section 25.2: Safe downcasting</a>
...............................................................................................................................
<a href="#Some_explanations">130</a></p>
<p><a href="#Circle__const_Point__center__dou">Section 25.3:
Polymorphism &amp; Destructors</a>
............................................................................................................
<a href="#Circle__const_Point__center__dou">131</a></p>
<h1
id="chapter-26-references-.........................................................................................................................................-133"><a
href="#Chapter_26__References_1">Chapter 26: References</a>
.........................................................................................................................................
<a href="#Chapter_26__References_1">133</a></h1>
<p><a href="#Chapter_26__References_1">Section 26.1: Defining a
reference</a>
...........................................................................................................................
<a href="#Chapter_26__References_1">133</a></p>
<h1
id="chapter-27-value-and-reference-semantics-............................................................................................-134"><a
href="#Chapter_27__Value_and_Reference_1">Chapter 27: Value and
Reference Semantics</a>
............................................................................................
<a href="#Chapter_27__Value_and_Reference_1">134</a></h1>
<p><a href="#Chapter_27__Value_and_Reference_1">Section 27.1:
Definitions</a>
............................................................................................................................................
<a href="#Chapter_27__Value_and_Reference_1">134</a></p>
<p><a href="#Chapter_27__Value_and_Reference_1">Section 27.2: Deep
copying and move support</a>
.....................................................................................................
<a href="#Chapter_27__Value_and_Reference_1">134</a></p>
<p><span id="Chapter_28__C___function__call_b" class="anchor"></span><a
href="#Chapter_28__C___function__call_b_1">Chapter 28: C++ function
"call by value" vs. "call by reference"</a>
.................................................... <a
href="#Chapter_28__C___function__call_b_1">138</a></p>
<p><a href="#Chapter_28__C___function__call_b_1">Section 28.1: Call by
value</a>
........................................................................................................................................
<a href="#Chapter_28__C___function__call_b_1">138</a></p>
<h1
id="chapter-29-copying-vs-assignment-...............................................................................................................-140"><a
href="#Chapter_29__Copying_vs_Assignmen_1">Chapter 29: Copying vs
Assignment</a>
...............................................................................................................
<a href="#Chapter_29__Copying_vs_Assignmen_1">140</a></h1>
<p><a href="#Chapter_29__Copying_vs_Assignmen_1">Section 29.1:
Assignment Operator</a>
.........................................................................................................................
<a href="#Chapter_29__Copying_vs_Assignmen_1">140</a></p>
<p><a href="#Chapter_29__Copying_vs_Assignmen_1">Section 29.2: Copy
Constructor</a>
...............................................................................................................................
<a href="#Chapter_29__Copying_vs_Assignmen_1">140</a></p>
<p><a href="#using_std__cout">Section 29.3: Copy Constructor Vs
Assignment Constructor</a>
...............................................................................
<a href="#using_std__cout">141</a></p>
<h1
id="chapter-30-pointers-...............................................................................................................................................-143"><a
href="#Chapter_30__Pointers_1">Chapter 30: Pointers</a>
...............................................................................................................................................
<a href="#Chapter_30__Pointers_1">143</a></h1>
<p><a href="#Chapter_30__Pointers_1">Section 30.1: Pointer
Operations</a>
..............................................................................................................................
<a href="#Chapter_30__Pointers_1">143</a></p>
<p><a href="#Chapter_30__Pointers_1">Section 30.2: Pointer basics
......................................................................................................................................
143</a></p>
<p><a href="#std__cout_____bar_foo1________ba">Section 30.3: Pointer
Arithmetic</a>
...............................................................................................................................
<a href="#std__cout_____bar_foo1________ba">145</a></p>
<h1
id="chapter-31-pointers-to-members-.....................................................................................................................-147"><a
href="#Chapter_31__Pointers_to_members_1">Chapter 31: Pointers to
members</a>
.....................................................................................................................
<a href="#Chapter_31__Pointers_to_members_1">147</a></h1>
<p><a href="#Chapter_31__Pointers_to_members_1">Section 31.1: Pointers
to static member functions</a>
..................................................................................................
<a href="#Chapter_31__Pointers_to_members_1">147</a></p>
<p><a href="#Chapter_31__Pointers_to_members_1">Section 31.2: Pointers
to member functions</a>
...........................................................................................................
<a href="#Chapter_31__Pointers_to_members_1">147</a></p>
<p><a href="#fn____Class__B_______fn_now_poin">Section 31.3: Pointers to
member variables
............................................................................................................
148</a></p>
<p><a href="#fn____Class__B_______fn_now_poin">Section 31.4: Pointers to
static member variables</a>
.................................................................................................
<a href="#fn____Class__B_______fn_now_poin">148</a></p>
<h1
id="chapter-32-the-this-pointer-..............................................................................................................................-150"><a
href="#Chapter_32__The_This_Pointer_1">Chapter 32: The This Pointer</a>
..............................................................................................................................
<a href="#Chapter_32__The_This_Pointer_1">150</a></h1>
<p><a href="#Chapter_32__The_This_Pointer_1">Section 32.1: this
Pointer</a>
...........................................................................................................................................
<a href="#Chapter_32__The_This_Pointer_1">150</a></p>
<p><a href="#CtorThisDerived__s_vtable_until">Section 32.2: Using the
this Pointer to Access Member Data</a>
...............................................................................
<a href="#CtorThisDerived__s_vtable_until">152</a></p>
<p><a href="#CtorThisDerived__s_vtable_until">Section 32.3: Using the
this Pointer to Dierentiate Between Member Data and Parameters</a>
........................ <a
href="#CtorThisDerived__s_vtable_until">152</a></p>
<p><a href="#________Dog_Barks">Section 32.4: this Pointer CV-Qualifiers
...................................................................................................................
153</a></p>
<p><a href="#_10">Section 32.5: this Pointer Ref-Qualifiers
..................................................................................................................
156</a></p>
<h1
id="chapter-33-smart-pointers-.................................................................................................................................-158"><a
href="#Chapter_33__Smart_Pointers_1">Chapter 33: Smart Pointers</a>
.................................................................................................................................
<a href="#Chapter_33__Smart_Pointers_1">158</a></h1>
<p><a href="#Chapter_33__Smart_Pointers_1">Section 33.1: Unique
ownership (std::unique_ptr)</a>
..................................................................................................
<a href="#Chapter_33__Smart_Pointers_1">158</a></p>
<p><a href="#conveys_the_ownership_semantics">Section 33.2: Sharing
ownership (std::shared_ptr)</a>
................................................................................................
<a href="#conveys_the_ownership_semantics">159</a></p>
<p><a href="#auto_r___std__make_shared">Section 33.3: Sharing with
temporary ownership (std::weak_ptr)</a>
.......................................................................
<a href="#auto_r___std__make_shared">161</a></p>
<p><a href="#_11">Section 33.4: Using custom deleters to create a
wrapper to a C interface</a>
........................................................ <a
href="#_11">163</a></p>
<p><a href="#std__unique_ptr_a_pointer__Surfa">Section 33.5: Unique
ownership without move semantics (auto_ptr)</a>
................................................................. <a
href="#std__unique_ptr_a_pointer__Surfa">164</a></p>
<p><a href="#___other_functions">Section 33.6: Casting std::shared_ptr
pointers</a>
.......................................................................................................
<a href="#___other_functions">166</a></p>
<p><a href="#___other_functions">Section 33.7: Writing a smart pointer:
value_ptr</a>
...................................................................................................
<a href="#___other_functions">166</a></p>
<p><a href="#return__this_1">Section 33.8: Getting a shared_ptr
referring to this</a>
..............................................................................................
<a href="#return__this_1">168</a></p>
<h1
id="chapter-34-classesstructures-.......................................................................................................................-170"><a
href="#Chapter_34__Classes_Structures_1">Chapter 34:
Classes/Structures</a>
.......................................................................................................................
<a href="#Chapter_34__Classes_Structures_1">170</a></h1>
<p><a href="#Chapter_34__Classes_Structures_1">Section 34.1: Class
basics</a>
..........................................................................................................................................
<a href="#Chapter_34__Classes_Structures_1">170</a></p>
<p><a href="#Chapter_34__Classes_Structures_1">Section 34.2: Final
classes and structs</a>
....................................................................................................................
<a href="#Chapter_34__Classes_Structures_1">170</a></p>
<p><a href="#___Compilation_error__cannot_der">Section 34.3: Access
specifiers</a>
.................................................................................................................................
<a href="#___Compilation_error__cannot_der">171</a></p>
<p><a href="#base_class_Plus2Base__such_as_Fo">Section 34.4:
Inheritance</a>
..........................................................................................................................................
<a href="#base_class_Plus2Base__such_as_Fo">172</a></p>
<p><a href="#_sometimes_called_a__HAS_A__rela">Section 34.5:
Friendship</a>
............................................................................................................................................
<a href="#_sometimes_called_a__HAS_A__rela">174</a></p>
<p><a href="#Section_34_6__Virtual_Inheritanc">Section 34.6: Virtual
Inheritance</a>
..............................................................................................................................
<a href="#Section_34_6__Virtual_Inheritanc">175</a></p>
<p><a href="#_12">Section 34.7: Private inheritance: restricting base
class interface</a>
.......................................................................
<a href="#_12">176</a></p>
<p><a href="#A__a___static_cast_b______OK_for">Section 34.8: Accessing
class members</a>
.................................................................................................................
<a href="#A__a___static_cast_b______OK_for">177</a></p>
<p><a href="#SomeStruct__c___5">Section 34.9: Member Types and
Aliases</a>
...............................................................................................................
<a href="#SomeStruct__c___5">178</a></p>
<p><a href="#Section_34_10__Nested_Classes_St">Section 34.10: Nested
Classes/Structures
...............................................................................................................
182</a></p>
<p><a href="#___Calls_BaseOuter__BaseInner">Section 34.11: Unnamed
struct/class</a>
.......................................................................................................................
<a href="#___Calls_BaseOuter__BaseInner">186</a></p>
<p><a href="#Version_____C__11">Section 34.12: Static class members</a>
........................................................................................................................
<a href="#Version_____C__11">187</a></p>
<p><a href="#class_ExInstanceRequired">Section 34.13: Multiple
Inheritance</a>
...........................................................................................................................
<a href="#class_ExInstanceRequired">191</a></p>
<p><a href="#class_B">Section 34.14: Non-static member functions</a>
..........................................................................................................
<a href="#class_B">192</a></p>
<h1
id="chapter-35-function-overloading-...................................................................................................................-195"><a
href="#Chapter_35__Function_Overloading_1">Chapter 35: Function
Overloading</a>
...................................................................................................................
<a href="#Chapter_35__Function_Overloading_1">195</a></h1>
<p><a href="#Chapter_35__Function_Overloading_1">Section 35.1: What is
Function Overloading?</a>
..........................................................................................................
<a href="#Chapter_35__Function_Overloading_1">195</a></p>
<p><a href="#print_5">Section 35.2: Return Type in Function
Overloading</a>
..............................................................................................
<a href="#print_5">196</a></p>
<p><a href="#print_5">Section 35.3: Member Function cv-qualifier
Overloading</a>
.....................................................................................
<a href="#print_5">196</a></p>
<h1
id="chapter-36-operator-overloading-.................................................................................................................-199"><a
href="#Chapter_36__Operator_Overloading_1">Chapter 36: Operator
Overloading</a>
.................................................................................................................
<a href="#Chapter_36__Operator_Overloading_1">199</a></h1>
<p><a href="#Chapter_36__Operator_Overloading_1">Section 36.1:
Arithmetic operators</a>
...........................................................................................................................
<a href="#Chapter_36__Operator_Overloading_1">199</a></p>
<p><a href="#by_value__why__Because">Section 36.2: Array subscript
operator</a>
...................................................................................................................
<a href="#by_value__why__Because">200</a></p>
<p><a href="#class_matrix">Section 36.3: Conversion operators
.........................................................................................................................
201</a></p>
<p><a href="#_16">Section 36.4: Complex Numbers Revisited</a>
.............................................................................................................
<a href="#_16">202</a></p>
<p><a href="#auto_d7___1___a">Section 36.5: Named operators</a>
...............................................................................................................................
<a href="#auto_d7___1___a">206</a></p>
<p><a href="#named_operator______append">Section 36.6: Unary
operators</a>
.................................................................................................................................
<a href="#named_operator______append">208</a></p>
<p><a href="#The_postfix_operator_returns_by">Section 36.7: Comparison
operators</a>
.......................................................................................................................
<a href="#The_postfix_operator_returns_by">209</a></p>
<p><a href="#The_operators_obviously_return_a">Section 36.8: Assignment
operator</a>
.........................................................................................................................
<a href="#The_operators_obviously_return_a">210</a></p>
<p><a href="#Section_36_9__Function_call_oper">Section 36.9: Function
call operator</a>
........................................................................................................................
<a href="#Section_36_9__Function_call_oper">211</a></p>
<p><a href="#Section_36_9__Function_call_oper">Section 36.10: Bitwise
NOT operator</a>
.......................................................................................................................
<a href="#Section_36_9__Function_call_oper">211</a></p>
<p><a href="#Inside_the_class_struct_you_have">Section 36.11: Bit shift
operators for I/O</a>
..................................................................................................................
<a href="#Inside_the_class_struct_you_have">212</a></p>
<p><span id="Chapter_37__Function_Template_Ov" class="anchor"></span><a
href="#Chapter_37__Function_Template">Chapter 37: Function Template
Overloading
.............................................................................................
213</a></p>
<p><a href="#Chapter_37__Function_Template">Section 37.1: What is a
valid function template overloading?</a>
..............................................................................
<a href="#Chapter_37__Function_Template">213</a></p>
<h1
id="chapter-38-virtual-member-functions-.........................................................................................................-214"><a
href="#Chapter_38__Virtual_Member_Funct_1">Chapter 38: Virtual Member
Functions</a>
.........................................................................................................
<a href="#Chapter_38__Virtual_Member_Funct_1">214</a></h1>
<p><a href="#Chapter_38__Virtual_Member_Funct_1">Section 38.1: Final
virtual functions</a>
..........................................................................................................................
<a href="#Chapter_38__Virtual_Member_Funct_1">214</a></p>
<p><a href="#Chapter_38__Virtual_Member_Funct_1">Section 38.2: Using
override with virtual in C++11 and later</a>
..................................................................................
<a href="#Chapter_38__Virtual_Member_Funct_1">214</a></p>
<p><a href="#_include">Section 38.3: Virtual vs non-virtual member
functions</a>
.........................................................................................
<a href="#_include">215</a></p>
<p><a href="#_17">Section 38.4: Behaviour of virtual functions in
constructors and destructors</a>
.................................................... <a
href="#_17">216</a></p>
<p><a href="#When_called_from_base_constructo">Section 38.5: Pure
virtual functions</a>
.........................................................................................................................
<a href="#When_called_from_base_constructo">217</a></p>
<p><span id="Chapter_39__Inline_functions" class="anchor"></span><a
href="#Chapter_39__Inline_functions_1">Chapter 39: Inline functions
.................................................................................................................................
220</a></p>
<p><a href="#Chapter_39__Inline_functions_1">Section 39.1: Non-member
inline function definition</a>
.............................................................................................
<a href="#Chapter_39__Inline_functions_1">220</a></p>
<p><a href="#Chapter_39__Inline_functions_1">Section 39.2: Member inline
functions
.....................................................................................................................
220</a></p>
<p><a href="#Chapter_39__Inline_functions_1">Section 39.3: What is
function inlining?</a>
...................................................................................................................
<a href="#Chapter_39__Inline_functions_1">220</a></p>
<p><a href="#function_would_be_called__The_ov">Section 39.4: Non-member
inline function declaration</a>
.........................................................................................
<a href="#function_would_be_called__The_ov">221</a></p>
<p><span id="Chapter_40__Special_Member_Funct" class="anchor"></span><a
href="#Chapter_40__Special_Member_Funct_1">Chapter 40: Special Member
Functions
........................................................................................................
222</a></p>
<p><a href="#Chapter_40__Special_Member_Funct_1">Section 40.1: Default
Constructor</a>
............................................................................................................................
<a href="#Chapter_40__Special_Member_Funct_1">222</a></p>
<p><a href="#Section_40_2__Destructor">Section 40.2: Destructor</a>
...........................................................................................................................................
<a href="#Section_40_2__Destructor">224</a></p>
<p><a href="#C_container__c_cont___new_C_cont">Section 40.3: Copy and
swap</a>
...................................................................................................................................
<a href="#C_container__c_cont___new_C_cont">225</a></p>
<p><a href="#Section_40_4__Implicit_Move_and">Section 40.4: Implicit
Move and Copy</a>
.....................................................................................................................
<a href="#Section_40_4__Implicit_Move_and">227</a></p>
<h1
id="chapter-41-non-static-member-functions-.................................................................................................-228"><a
href="#Chapter_41__Non_Static_Member_Fu_1">Chapter 41: Non-Static Member
Functions</a>
.................................................................................................
<a href="#Chapter_41__Non_Static_Member_Fu_1">228</a></h1>
<p><a href="#Chapter_41__Non_Static_Member_Fu_1">Section 41.1:
Non-static Member Functions</a>
............................................................................................................
<a href="#Chapter_41__Non_Static_Member_Fu_1">228</a></p>
<p><a href="#Section_41_2__Encapsulation">Section 41.2:
Encapsulation</a>
......................................................................................................................................
<a href="#Section_41_2__Encapsulation">229</a></p>
<p><a href="#Section_41_2__Encapsulation">Section 41.3: Name Hiding
&amp; Importing</a>
..................................................................................................................
<a href="#Section_41_2__Encapsulation">229</a></p>
<p><a href="#virtual_void_f_____std__cout">Section 41.4: Virtual Member
Functions</a>
..................................................................................................................
<a href="#virtual_void_f_____std__cout">231</a></p>
<p><a href="#This_also_holds_true_for_overrid">Section 41.5: Const
Correctness</a>
...............................................................................................................................
<a href="#This_also_holds_true_for_overrid">233</a></p>
<h1
id="chapter-42-constant-class-member-functions-........................................................................................-235"><a
href="#Chapter_42__Constant_class_membe_1">Chapter 42: Constant class
member functions</a>
........................................................................................
<a href="#Chapter_42__Constant_class_membe_1">235</a></h1>
<p><a href="#Chapter_42__Constant_class_membe_1">Section 42.1: constant
member function</a>
................................................................................................................
<a href="#Chapter_42__Constant_class_membe_1">235</a></p>
<h1
id="chapter-43-c-containers-................................................................................................................................-236"><a
href="#Chapter_43__C___Containers_1">Chapter 43: C++ Containers</a>
................................................................................................................................
<a href="#Chapter_43__C___Containers_1">236</a></h1>
<p><a href="#Chapter_43__C___Containers_1">Section 43.1: C++ Containers
Flowchart</a>
..................................................................................................................
<a href="#Chapter_43__C___Containers_1">236</a></p>
<h1
id="chapter-44-namespaces-....................................................................................................................................-237"><a
href="#Chapter_44__Namespaces_1">Chapter 44: Namespaces</a>
....................................................................................................................................
<a href="#Chapter_44__Namespaces_1">237</a></h1>
<p><a href="#Chapter_44__Namespaces_1">Section 44.1: What are
namespaces?</a>
.....................................................................................................................
<a href="#Chapter_44__Namespaces_1">237</a></p>
<p><a href="#void_bar">Section 44.2: Argument Dependent Lookup</a>
..........................................................................................................
<a href="#void_bar">238</a></p>
<p><a href="#_18">Section 44.3: Extending namespaces</a>
......................................................................................................................
<a href="#_18">239</a></p>
<p><a href="#_18">Section 44.4: Using directive</a>
....................................................................................................................................
<a href="#_18">239</a></p>
<p><a href="#namespace_Foo">Section 44.5: Making namespaces</a>
..........................................................................................................................
<a href="#namespace_Foo">240</a></p>
<p><a href="#_19">Section 44.6: Unnamed/anonymous namespaces</a>
...............................................................................................
<a href="#_19">241</a></p>
<p><a href="#_19">Section 44.7: Compact nested namespaces</a>
..........................................................................................................
<a href="#_19">241</a></p>
<p><a href="#_19">Section 44.8: Namespace alias</a>
................................................................................................................................
<a href="#_19">241</a></p>
<p><a href="#following_example__the_nested_na">Section 44.9: Inline
namespace</a>
...............................................................................................................................
<a href="#following_example__the_nested_na">242</a></p>
<p><a href="#Section_44_10__Aliasing_a_long_n">Section 44.10: Aliasing a
long namespace
..............................................................................................................
244</a></p>
<p><a href="#Section_44_10__Aliasing_a_long_n">Section 44.11: Alias
Declaration scope</a>
.....................................................................................................................
<a href="#Section_44_10__Aliasing_a_long_n">244</a></p>
<h1
id="chapter-45-header-files-.....................................................................................................................................-246"><a
href="#Chapter_45__Header_Files_1">Chapter 45: Header Files</a>
.....................................................................................................................................
<a href="#Chapter_45__Header_Files_1">246</a></h1>
<p><a href="#Chapter_45__Header_Files_1">Section 45.1: Basic Example</a>
.....................................................................................................................................
<a href="#Chapter_45__Header_Files_1">246</a></p>
<p><a href="#return_0">Section 45.2: Templates in Header Files</a>
.................................................................................................................
<a href="#return_0">247</a></p>
<h1
id="chapter-46-using-declaration-..........................................................................................................................-248"><a
href="#Chapter_46__Using_declaration_1">Chapter 46: Using
declaration</a>
..........................................................................................................................
<a href="#Chapter_46__Using_declaration_1">248</a></h1>
<p><a href="#Chapter_46__Using_declaration_1">Section 46.1: Importing
names individually from a namespace</a>
..........................................................................
<a href="#Chapter_46__Using_declaration_1">248</a></p>
<p><a href="#Chapter_46__Using_declaration_1">Section 46.2: Redeclaring
members from a base class to avoid name hiding</a>
.................................................. <a
href="#Chapter_46__Using_declaration_1">248</a></p>
<p><a href="#Chapter_46__Using_declaration_1">Section 46.3: Inheriting
constructors</a>
.......................................................................................................................
<a href="#Chapter_46__Using_declaration_1">248</a></p>
<p><span id="Chapter_47__std__string" class="anchor"></span><a
href="#Chapter_47__std__string_1">Chapter 47: std::string
...........................................................................................................................................
250</a></p>
<p><a href="#Chapter_47__std__string_1">Section 47.1: Tokenize</a>
...............................................................................................................................................
<a href="#Chapter_47__std__string_1">250</a></p>
<p><a href="#Version_____C__11_1">Section 47.2: Conversion to (const)
char*</a>
...............................................................................................................
<a href="#Version_____C__11_1">251</a></p>
<p><a href="#Version_____C__11_1">Section 47.3: Using the
std::string_view class</a>
........................................................................................................
<a href="#Version_____C__11_1">251</a></p>
<p><a href="#___allocation_if_caller_s_data_w">Section 47.4: Conversion
to std::wstring
..................................................................................................................
252</a></p>
<p><a href="#std__string_wstr_turned_to_str">Section 47.5:
Lexicographical comparison</a>
.............................................................................................................
<a href="#std__string_wstr_turned_to_str">253</a></p>
<p><a href="#false">Section 47.6: Trimming characters at start/end</a>
...................................................................................................
<a href="#false">254</a></p>
<p><a href="#Trimming_the_trailing_elements_i">Section 47.7: String
replacement</a>
.............................................................................................................................
<a href="#Trimming_the_trailing_elements_i">255</a></p>
<p><a href="#__Define_string">Section 47.8: Converting to
std::string</a>
.....................................................................................................................
<a href="#__Define_string">256</a></p>
<p><a href="#into_a_std__ostringstream_object">Section 47.9:
Splitting</a>
................................................................................................................................................
<a href="#into_a_std__ostringstream_object">257</a></p>
<p><a href="#std__string_newstr___str_substr">Section 47.10: Accessing a
character</a>
......................................................................................................................
<a href="#std__string_newstr___str_substr">258</a></p>
<p><a href="#std__string_newstr___str_substr">Section 47.11: Checking if
a string is a prefix of another</a>
.......................................................................................
<a href="#std__string_newstr___str_substr">258</a></p>
<p><a href="#std__string_string____foobar">Section 47.12: Looping
through each character</a>
....................................................................................................
<a href="#std__string_string____foobar">259</a></p>
<p><a href="#std__string_string____foobar">Section 47.13: Conversion to
integers/floating point types</a>
..................................................................................
<a href="#std__string_string____foobar">259</a></p>
<p><a href="#int_num2___std__atoi_ten_c_str">Section 47.14:
Concatenation</a>
...................................................................................................................................
<a href="#int_num2___std__atoi_ten_c_str">260</a></p>
<p><a href="#const_char__comma">Section 47.15: Converting between
character encodings</a>
.....................................................................................
<a href="#const_char__comma">261</a></p>
<p><a href="#void_strings__utf8_to_utf16_cons">Section 47.16: Finding
character(s) in a string</a>
.......................................................................................................
<a href="#void_strings__utf8_to_utf16_cons">262</a></p>
<h1
id="chapter-48-stdarray-...........................................................................................................................................-263"><a
href="#Chapter_48__std__array_1">Chapter 48: std::array</a>
...........................................................................................................................................
<a href="#Chapter_48__std__array_1">263</a></h1>
<p><a href="#Chapter_48__std__array_1">Section 48.1: Initializing an
std::array</a>
.......................................................................................................................
<a href="#Chapter_48__std__array_1">263</a></p>
<p><a href="#Section_48_2__Element_access">Section 48.2: Element
access</a>
...................................................................................................................................
<a href="#Section_48_2__Element_access">264</a></p>
<p><a href="#6__data">Section 48.3: Iterating through the Array</a>
...............................................................................................................
<a href="#6__data">266</a></p>
<p><a href="#6__data">Section 48.4: Checking size of the Array</a>
................................................................................................................
<a href="#6__data">266</a></p>
<p><a href="#6__data">Section 48.5: Changing all array elements at once
...............................................................................................
266</a></p>
<h1
id="chapter-49-stdvector-.........................................................................................................................................-267"><a
href="#Chapter_49__std__vector_1">Chapter 49: std::vector</a>
.........................................................................................................................................
<a href="#Chapter_49__std__vector_1">267</a></h1>
<p><a href="#Chapter_49__std__vector_1">Section 49.1: Accessing
Elements</a>
............................................................................................................................
<a href="#Chapter_49__std__vector_1">267</a></p>
<p><a href="#assuming_the_contents_of_the_vec">Section 49.2:
Initializing a std::vector
.......................................................................................................................
269</a></p>
<p><a href="#Copy_construction__from_another">Section 49.3: Deleting
Elements
...............................................................................................................................
270</a></p>
<p><a href="#___See_explanation_below_for_the">Section 49.4: Iterating
Over std::vector</a>
...................................................................................................................
<a href="#___See_explanation_below_for_the">272</a></p>
<p><a href="#Since_C__11_the_cbegin___and_cen">Section 49.5:
vector&lt;bool&gt;: The Exception To So Many, So Many Rules</a>
............................................................ <a
href="#Since_C__11_the_cbegin___and_cen">274</a></p>
<p><a href="#proxy_object_that__imperfectly">Section 49.6: Inserting
Elements</a>
..............................................................................................................................
<a href="#proxy_object_that__imperfectly">275</a></p>
<p><a href="#Point_double_x__double_y____x_x">Section 49.7: Using
std::vector as a C array</a>
...........................................................................................................
<a href="#Point_double_x__double_y____x_x">276</a></p>
<p><a href="#Version_____C__11_2">Section 49.8: Finding an Element in
std::vector</a>
......................................................................................................
<a href="#Version_____C__11_2">277</a></p>
<p><a href="#before_using_the_binary_search_a">Section 49.9:
Concatenating Vectors</a>
......................................................................................................................
<a href="#before_using_the_binary_search_a">278</a></p>
<p><a href="#allow_you_to_append_a_vector_to">Section 49.10: Matrices
Using Vectors
.....................................................................................................................
279</a></p>
<p><a href="#Section_49_11__Using_a_Sorted_Ve">Section 49.11: Using a
Sorted Vector for Fast Element Lookup</a>
............................................................................
<a href="#Section_49_11__Using_a_Sorted_Ve">280</a></p>
<p><a href="#Section_49_12__Reducing_the_Capa">Section 49.12: Reducing
the Capacity of a Vector</a>
.................................................................................................
<a href="#Section_49_12__Reducing_the_Capa">281</a></p>
<p><a href="#Section_49_12__Reducing_the_Capa">Section 49.13: Vector
size and capacity</a>
..................................................................................................................
<a href="#Section_49_12__Reducing_the_Capa">281</a></p>
<p><a href="#v_____1__2__3__4_______size_is_4">Section 49.14:
Iterator/Pointer Invalidation</a>
............................................................................................................
<a href="#v_____1__2__3__4_______size_is_4">283</a></p>
<p><a href="#Section_49_15__Find_max_and_min">Section 49.15: Find max
and min Element and Respective Index in a Vector
..................................................... 284</a></p>
<p><a href="#Section_49_15__Find_max_and_min">Section 49.16: Converting
an array to std::vector</a>
..................................................................................................
<a href="#Section_49_15__Find_max_and_min">284</a></p>
<p><a href="#1_2_3_4_5">Section 49.17: Functions Returning Large Vectors
.................................................................................................
285</a></p>
<h1
id="chapter-50-stdmap-..............................................................................................................................................-287"><a
href="#Chapter_50__std__map_1">Chapter 50: std::map</a>
..............................................................................................................................................
<a href="#Chapter_50__std__map_1">287</a></h1>
<p><a href="#Chapter_50__std__map_1">Section 50.1: Accessing
elements</a>
............................................................................................................................
<a href="#Chapter_50__std__map_1">287</a></p>
<p><a href="#std__multimap___int__std__string">Section 50.2: Inserting
elements</a>
..............................................................................................................................
<a href="#std__multimap___int__std__string">288</a></p>
<p><a href="#insert___can_be_used_to_add_seve">Section 50.3: Searching
in std::map or in std::multimap</a>
........................................................................................
<a href="#insert___can_be_used_to_add_seve">289</a></p>
<p><a href="#std__cout_____Value_does_not_exi">Section 50.4:
Initializing a std::map or std::multimap
.............................................................................................
290</a></p>
<p><a href="#Both_could_be_initialized_with_i">Section 50.5: Checking
number of elements</a>
..........................................................................................................
<a href="#Both_could_be_initialized_with_i">291</a></p>
<p><a href="#Both_could_be_initialized_with_i">Section 50.6: Types of
Maps</a>
....................................................................................................................................
<a href="#Both_could_be_initialized_with_i">291</a></p>
<p><a href="#_include_1">Section 50.7: Deleting elements
...............................................................................................................................
292</a></p>
<p><a href="#it______moved_first_cursor_on_fi">Section 50.8: Iterating
over std::map or std::multimap</a>
.........................................................................................
<a href="#it______moved_first_cursor_on_fi">293</a></p>
<p><a href="#it______moved_first_cursor_on_fi">Section 50.9: Creating
std::map with user-defined types as key</a>
.........................................................................
<a href="#it______moved_first_cursor_on_fi">293</a></p>
<h1
id="chapter-51-stdoptional-.......................................................................................................................................-295"><a
href="#Chapter_51__std__optional_1">Chapter 51: std::optional</a>
.......................................................................................................................................
<a href="#Chapter_51__std__optional_1">295</a></h1>
<p><a href="#Chapter_51__std__optional_1">Section 51.1: Using optionals
to represent the absence of a value</a>
......................................................................
<a href="#Chapter_51__std__optional_1">295</a></p>
<p><a href="#Chapter_51__std__optional_1">Section 51.2: optional as
return value</a>
.....................................................................................................................
<a href="#Chapter_51__std__optional_1">295</a></p>
<p><a href="#if__r__e">Section 51.3: value_or</a>
...............................................................................................................................................
<a href="#if__r__e">296</a></p>
<p><a href="#if__r__e">Section 51.4: Introduction
..........................................................................................................................................
296</a></p>
<p><a href="#In_some_cases__we_can_provide_a">Section 51.5: Using
optionals to represent the failure of a function</a>
.................................................................... <a
href="#In_some_cases__we_can_provide_a">297</a></p>
<p><span id="Chapter_52__std__function__To_wr" class="anchor"></span><a
href="#Chapter_52__std__function__To_wr_1">Chapter 52: std::function: To
wrap any element that is callable</a>
.................................................... <a
href="#Chapter_52__std__function__To_wr_1">299</a></p>
<p><a href="#Chapter_52__std__function__To_wr_1">Section 52.1: Simple
usage</a>
.......................................................................................................................................
<a href="#Chapter_52__std__function__To_wr_1">299</a></p>
<p><a href="#Chapter_52__std__function__To_wr_1">Section 52.2:
std::function used with std::bind</a>
........................................................................................................
<a href="#Chapter_52__std__function__To_wr_1">299</a></p>
<p><a href="#int_main_int_argc__char__argv">Section 52.3: Binding
std::function to a dierent callable types</a>
..........................................................................
<a href="#int_main_int_argc__char__argv">300</a></p>
<p><a href="#f_1__2__3">Section 52.4: Storing function arguments in
std::tuple</a>
..........................................................................................
<a href="#f_1__2__3">302</a></p>
<p><a href="#std__function_fn___foo_fn">Section 52.5: std::function with
lambda and std::bind</a>
...........................................................................................
<a href="#std__function_fn___foo_fn">303</a></p>
<p><a href="#Section_52_6___function__overhea">Section 52.6: `function`
overhead</a>
............................................................................................................................
<a href="#Section_52_6___function__overhea">304</a></p>
<h1
id="chapter-53-stdforward_list-.............................................................................................................................-305"><a
href="#Chapter_53__std__forward_list_1">Chapter 53:
std::forward_list</a>
.............................................................................................................................
<a href="#Chapter_53__std__forward_list_1">305</a></h1>
<p><a href="#Chapter_53__std__forward_list_1">Section 53.1: Example</a>
................................................................................................................................................
<a href="#Chapter_53__std__forward_list_1">305</a></p>
<p><a href="#Chapter_53__std__forward_list_1">Section 53.2: Methods</a>
...............................................................................................................................................
<a href="#Chapter_53__std__forward_list_1">305</a></p>
<h1
id="chapter-54-stdpair-..............................................................................................................................................-307"><a
href="#Chapter_54__std__pair_1">Chapter 54: std::pair</a>
..............................................................................................................................................
<a href="#Chapter_54__std__pair_1">307</a></h1>
<p><a href="#Chapter_54__std__pair_1">Section 54.1: Compare
operators</a>
............................................................................................................................
<a href="#Chapter_54__std__pair_1">307</a></p>
<p><a href="#Chapter_54__std__pair_1">Section 54.2: Creating a Pair and
accessing the elements
...................................................................................
307</a></p>
<p><span id="Chapter_55__std__atomics" class="anchor"></span><a
href="#Chapter_55__std__atomics_1">Chapter 55: std::atomics
.......................................................................................................................................
309</a></p>
<p><a href="#Chapter_55__std__atomics_1">Section 55.1: atomic types</a>
........................................................................................................................................
<a href="#Chapter_55__std__atomics_1">309</a></p>
<h1
id="chapter-56-stdvariant-........................................................................................................................................-311"><a
href="#Chapter_56__std__variant_1">Chapter 56: std::variant</a>
........................................................................................................................................
<a href="#Chapter_56__std__variant_1">311</a></h1>
<p><a href="#Chapter_56__std__variant_1">Section 56.1: Create
pseudo-method pointers</a>
.......................................................................................................
<a href="#Chapter_56__std__variant_1">311</a></p>
<p><a href="#_var___print__std__cout">Section 56.2: Basic std::variant
use
..........................................................................................................................
312</a></p>
<p><a href="#unions">Section 56.3: Constructing a `std::variant`</a>
...............................................................................................................
<a href="#unions">313</a></p>
<h1
id="chapter-57-stdiomanip-......................................................................................................................................-314"><a
href="#Chapter_57__std__iomanip_1">Chapter 57: std::iomanip</a>
......................................................................................................................................
<a href="#Chapter_57__std__iomanip_1">314</a></h1>
<p><a href="#Chapter_57__std__iomanip_1">Section 57.1:
std::setprecision</a>
...................................................................................................................................
<a href="#Chapter_57__std__iomanip_1">314</a></p>
<p><a href="#Chapter_57__std__iomanip_1">Section 57.2: std::setfill</a>
..............................................................................................................................................
<a href="#Chapter_57__std__iomanip_1">314</a></p>
<p><a href="#Chapter_57__std__iomanip_1">Section 57.3:
std::setiosflags</a>
.....................................................................................................................................
<a href="#Chapter_57__std__iomanip_1">314</a></p>
<p><a href="#std__cout">Section 57.4: std::setw</a>
...............................................................................................................................................
<a href="#std__cout">316</a></p>
<p><span id="Chapter_58__std__any" class="anchor"></span><a
href="#Chapter_58__std__any_1">Chapter 58: std::any
................................................................................................................................................
317</a></p>
<p><a href="#Chapter_58__std__any_1">Section 58.1: Basic usage</a>
..........................................................................................................................................
<a href="#Chapter_58__std__any_1">317</a></p>
<p><span id="Chapter_59__std__set_and_std__mu" class="anchor"></span><a
href="#Chapter_59__std__set_and_std__mu_1">Chapter 59: std::set and
std::multiset
............................................................................................................
318</a></p>
<p><a href="#Chapter_59__std__set_and_std__mu_1">Section 59.1: Changing
the default sort of a set</a>
....................................................................................................
<a href="#Chapter_59__std__set_and_std__mu_1">318</a></p>
<p><a href="#the_overall_code_more_readable">Section 59.2: Deleting
values from a set</a>
................................................................................................................
<a href="#the_overall_code_more_readable">320</a></p>
<p><a href="#_22">Section 59.3: Inserting values in a set</a>
.....................................................................................................................
<a href="#_22">321</a></p>
<p><a href="#45">Section 59.4: Inserting values in a multiset
.............................................................................................................
323</a></p>
<p><a href="#45">Section 59.5: Searching values in set and multiset</a>
................................................................................................
<a href="#45">323</a></p>
<h1
id="chapter-60-stdinteger_sequence-................................................................................................................-325"><a
href="#Chapter_60__std__integer_sequenc_1">Chapter 60:
std::integer_sequence</a>
................................................................................................................
<a href="#Chapter_60__std__integer_sequenc_1">325</a></h1>
<p><a href="#Chapter_60__std__integer_sequenc_1">Section 60.1: Turn a
std::tuple&lt;T...&gt; into function parameters</a>
..............................................................................
<a href="#Chapter_60__std__integer_sequenc_1">325</a></p>
<p><a href="#Section_60_2__Create_a_parameter">Section 60.2: Create a
parameter pack consisting of integers</a>
............................................................................
<a href="#Section_60_2__Create_a_parameter">326</a></p>
<p><a href="#Section_60_2__Create_a_parameter">Section 60.3: Turn a
sequence of indices into copies of an element
...................................................................
326</a></p>
<h1
id="chapter-61-using-stdunordered_map-........................................................................................................-328"><a
href="#Chapter_61__Using_std__unordered_1">Chapter 61: Using
std::unordered_map</a>
........................................................................................................
<a href="#Chapter_61__Using_std__unordered_1">328</a></h1>
<p><a href="#Chapter_61__Using_std__unordered_1">Section 61.1:
Declaration and Usage</a>
.......................................................................................................................
<a href="#Chapter_61__Using_std__unordered_1">328</a></p>
<p><a href="#Chapter_61__Using_std__unordered_1">Section 61.2: Some
Basic Functions</a>
.........................................................................................................................
<a href="#Chapter_61__Using_std__unordered_1">328</a></p>
<h1
id="chapter-62-standard-library-algorithms-...................................................................................................-329"><a
href="#Chapter_62__Standard_Library_Alg_1">Chapter 62: Standard Library
Algorithms</a>
...................................................................................................
<a href="#Chapter_62__Standard_Library_Alg_1">329</a></h1>
<p><a href="#Chapter_62__Standard_Library_Alg_1">Section 62.1:
std::next_permutation
.........................................................................................................................
329</a></p>
<p><a href="#Chapter_62__Standard_Library_Alg_1">Section 62.2:
std::for_each</a>
.......................................................................................................................................
<a href="#Chapter_62__Standard_Library_Alg_1">329</a></p>
<p><a href="#proceeding_to_last__1">Section 62.3: std::accumulate</a>
...................................................................................................................................
<a href="#proceeding_to_last__1">330</a></p>
<p><a href="#Accumulated_value_of_f_applicati">Section 62.4:
std::find</a>
................................................................................................................................................
<a href="#Accumulated_value_of_f_applicati">331</a></p>
<p><a href="#Section_62_5__std__min_element">Section 62.5:
std::min_element</a>
................................................................................................................................
<a href="#Section_62_5__std__min_element">333</a></p>
<p><a href="#__print_minimum_of_pairVector">Section 62.6:
std::find_if</a>
............................................................................................................................................
<a href="#__print_minimum_of_pairVector">334</a></p>
<p><a href="#_23">Section 62.7: Using std::nth_element To Find The
Median (Or Other Quantiles)</a>
............................................... <a
href="#_23">335</a></p>
<p><a href="#For_the_sake_of_this_example__le">Section 62.8:
std::count</a>
.............................................................................................................................................
<a href="#For_the_sake_of_this_example__le">336</a></p>
<p><a href="#__create_vector">Section 62.9: std::count_if
.........................................................................................................................................
337</a></p>
<h1
id="chapter-63-the-iso-c-standard-..................................................................................................................-339"><a
href="#Chapter_63__The_ISO_C___Standard_1">Chapter 63: The ISO C++
Standard</a>
..................................................................................................................
<a href="#Chapter_63__The_ISO_C___Standard_1">339</a></h1>
<p><a href="#Chapter_63__The_ISO_C___Standard_1">Section 63.1: Current
Working Drafts</a>
......................................................................................................................
<a href="#Chapter_63__The_ISO_C___Standard_1">339</a></p>
<p><a href="#Chapter_63__The_ISO_C___Standard_1">Section 63.2: C++17</a>
....................................................................................................................................................
<a href="#Chapter_63__The_ISO_C___Standard_1">339</a></p>
<p><a href="#Section_63_3__C__11">Section 63.3: C++11</a>
.....................................................................................................................................................
<a href="#Section_63_3__C__11">340</a></p>
<p><a href="#What_is_the_value_of___cplusplus">Section 63.4: C++14</a>
....................................................................................................................................................
<a href="#What_is_the_value_of___cplusplus">341</a></p>
<p><a href="#decltype_auto">Section 63.5: C++98</a>
...................................................................................................................................................
<a href="#decltype_auto">342</a></p>
<p><a href="#decltype_auto">Section 63.6: C++03</a>
...................................................................................................................................................
<a href="#decltype_auto">342</a></p>
<p><a href="#Section_63_7__C__20">Section 63.7: C++20</a>
...................................................................................................................................................
<a href="#Section_63_7__C__20">343</a></p>
<h1
id="chapter-64-inline-variables-................................................................................................................................-344"><a
href="#Chapter_64__Inline_variables_1">Chapter 64: Inline variables</a>
................................................................................................................................
<a href="#Chapter_64__Inline_variables_1">344</a></h1>
<p><a href="#Chapter_64__Inline_variables_1">Section 64.1: Defining a
static data member in the class definition
.....................................................................
344</a></p>
<h1
id="chapter-65-random-number-generation-...................................................................................................-345"><a
href="#Chapter_65__Random_number_genera_1">Chapter 65: Random number
generation</a>
...................................................................................................
<a href="#Chapter_65__Random_number_genera_1">345</a></h1>
<p><a href="#Chapter_65__Random_number_genera_1">Section 65.1: True
random value generator</a>
...........................................................................................................
<a href="#Chapter_65__Random_number_genera_1">345</a></p>
<p><a href="#Chapter_65__Random_number_genera_1">Section 65.2:
Generating a pseudo-random number
............................................................................................
345</a></p>
<p><a href="#_25">Section 65.3: Using the generator for multiple
distributions</a>
................................................................................
<a href="#_25">346</a></p>
<h1
id="chapter-66-date-and-time-using-chrono-header-................................................................................-347"><a
href="#Chapter_66__Date_and_time_using_1">Chapter 66: Date and time
using &lt;chrono&gt; header</a>
................................................................................
<a href="#Chapter_66__Date_and_time_using_1">347</a></h1>
<p><a href="#Chapter_66__Date_and_time_using_1">Section 66.1: Measuring
time using &lt;chrono&gt;</a>
........................................................................................................
<a href="#Chapter_66__Date_and_time_using_1">347</a></p>
<p><a href="#Chapter_66__Date_and_time_using_1">Section 66.2: Find
number of days between two dates</a>
........................................................................................
<a href="#Chapter_66__Date_and_time_using_1">347</a></p>
<h1
id="chapter-67-sorting-.................................................................................................................................................-349"><a
href="#Chapter_67__Sorting_1">Chapter 67: Sorting</a>
.................................................................................................................................................
<a href="#Chapter_67__Sorting_1">349</a></h1>
<p><a href="#Chapter_67__Sorting_1">Section 67.1: Sorting and sequence
containers</a>
......................................................................................................
<a href="#Chapter_67__Sorting_1">349</a></p>
<p><a href="#Chapter_67__Sorting_1">Section 67.2: sorting with std::map
(ascending and descending)</a>
........................................................................
<a href="#Chapter_67__Sorting_1">349</a></p>
<p><a href="#_26">Section 67.3: Sorting sequence containers by
overloaded less operator</a>
........................................................... <a
href="#_26">351</a></p>
<p><a href="#deque_push_back_a">Section 67.4: Sorting sequence
containers using compare function</a>
................................................................... <a
href="#deque_push_back_a">352</a></p>
<p><a href="#std__sort_vector_begin____vector">Section 67.5: Sorting
sequence containers using lambda expressions (C++11)</a>
.................................................. <a
href="#std__sort_vector_begin____vector">353</a></p>
<p><a href="#Section_67_6__Sorting_built_in_a">Section 67.6: Sorting
built-in arrays</a>
........................................................................................................................
<a href="#Section_67_6__Sorting_built_in_a">354</a></p>
<p><a href="#Section_67_6__Sorting_built_in_a">Section 67.7: Sorting
sequence containers with specifed ordering</a>
..................................................................... <a
href="#Section_67_6__Sorting_built_in_a">354</a></p>
<h1
id="chapter-68-enumeration-.....................................................................................................................................-355"><a
href="#Chapter_68__Enumeration_1">Chapter 68: Enumeration</a>
.....................................................................................................................................
<a href="#Chapter_68__Enumeration_1">355</a></h1>
<p><a href="#Chapter_68__Enumeration_1">Section 68.1: Iteration over an
enum</a>
.......................................................................................................................
<a href="#Chapter_68__Enumeration_1">355</a></p>
<p><a href="#E_e____it">Section 68.2: Scoped enums</a>
....................................................................................................................................
<a href="#E_e____it">356</a></p>
<p><a href="#Section_68_3__Enum_forward_decla">Section 68.3: Enum
forward declaration in C++11</a>
..................................................................................................
<a href="#Section_68_3__Enum_forward_decla">357</a></p>
<p><a href="#Section_68_3__Enum_forward_decla">Section 68.4: Basic
Enumeration Declaration</a>
........................................................................................................
<a href="#Section_68_3__Enum_forward_decla">357</a></p>
<p><a href="#_27">Section 68.5: Enumeration in switch statements</a>
...................................................................................................
<a href="#_27">358</a></p>
<h1
id="chapter-69-iteration-..............................................................................................................................................-359"><a
href="#Chapter_69__Iteration_1">Chapter 69: Iteration</a>
..............................................................................................................................................
<a href="#Chapter_69__Iteration_1">359</a></h1>
<p><a href="#Chapter_69__Iteration_1">Section 69.1: break</a>
....................................................................................................................................................
<a href="#Chapter_69__Iteration_1">359</a></p>
<p><a href="#Chapter_69__Iteration_1">Section 69.2: continue</a>
...............................................................................................................................................
<a href="#Chapter_69__Iteration_1">359</a></p>
<p><a href="#Chapter_69__Iteration_1">Section 69.3: do</a>
.........................................................................................................................................................
<a href="#Chapter_69__Iteration_1">359</a></p>
<p><a href="#Chapter_69__Iteration_1">Section 69.4: while</a>
.....................................................................................................................................................
<a href="#Chapter_69__Iteration_1">359</a></p>
<p><a href="#Section_69_5__range_based_for_lo">Section 69.5: range-based
for loop</a>
.........................................................................................................................
<a href="#Section_69_5__range_based_for_lo">360</a></p>
<p><a href="#Section_69_5__range_based_for_lo">Section 69.6: for</a>
.........................................................................................................................................................
<a href="#Section_69_5__range_based_for_lo">360</a></p>
<h1
id="chapter-70-regular-expressions-.....................................................................................................................-361"><a
href="#Chapter_70__Regular_expressions_1">Chapter 70: Regular
expressions</a>
.....................................................................................................................
<a href="#Chapter_70__Regular_expressions_1">361</a></h1>
<p><a href="#Chapter_70__Regular_expressions_1">Section 70.1: Basic
regex_match and regex_search Examples
...........................................................................
361</a></p>
<p><a href="#Chapter_70__Regular_expressions_1">Section 70.2:
regex_iterator Example
.....................................................................................................................
361</a></p>
<p><a href="#interdependence__Let_s_say_that">Section 70.3: Anchors</a>
................................................................................................................................................
<a href="#interdependence__Let_s_say_that">362</a></p>
<p><a href="#_B_which_asserts_a__w_character">Section 70.4:
regex_replace Example
.....................................................................................................................
363</a></p>
<p><a href="#_B_which_asserts_a__w_character">Section 70.5:
regex_token_iterator Example</a>
........................................................................................................
<a href="#_B_which_asserts_a__w_character">363</a></p>
<p><a href="#_B_which_asserts_a__w_character">Section 70.6:
Quantifiers</a>
...........................................................................................................................................
<a href="#_B_which_asserts_a__w_character">363</a></p>
<p><a href="#Without_the_possessive_quantifie">Section 70.7: Splitting a
string</a>
..................................................................................................................................
<a href="#Without_the_possessive_quantifie">365</a></p>
<h1
id="chapter-71-implementation-defined-behavior-.........................................................................................-366"><a
href="#Chapter_71__Implementation_defin_1">Chapter 71:
Implementation-defined behavior</a>
.........................................................................................
<a href="#Chapter_71__Implementation_defin_1">366</a></h1>
<p><a href="#Chapter_71__Implementation_defin_1">Section 71.1: Size of
integral types</a>
...........................................................................................................................
<a href="#Chapter_71__Implementation_defin_1">366</a></p>
<p><a href="#specified_in_SS_5_3_3_1__and_may">Section 71.2: Char might
be unsigned or signed</a>
....................................................................................................
<a href="#specified_in_SS_5_3_3_1__and_may">368</a></p>
<p><a href="#specified_in_SS_5_3_3_1__and_may">Section 71.3: Ranges of
numeric types</a>
...................................................................................................................
<a href="#specified_in_SS_5_3_3_1__and_may">368</a></p>
<p><a href="#std__numeric_limits__max___equal">Section 71.4: Value
representation of floating point types</a>
...................................................................................
<a href="#std__numeric_limits__max___equal">369</a></p>
<p><a href="#std__numeric_limits__max___equal">Section 71.5: Overflow
when converting from integer to signed integer</a>
............................................................ <a
href="#std__numeric_limits__max___equal">369</a></p>
<p><a href="#the_destination_type__the_value">Section 71.6: Underlying
type (and hence size) of an enum
.................................................................................
370</a></p>
<p><a href="#the_destination_type__the_value">Section 71.7: Numeric
value of a pointer
.................................................................................................................
370</a></p>
<p><a href="#While__for_the_majority_of_moder">Section 71.8: Number of
bits in a byte</a>
.....................................................................................................................
<a href="#While__for_the_majority_of_moder">371</a></p>
<h1
id="chapter-72-exceptions-..........................................................................................................................................-372"><a
href="#Chapter_72__Exceptions_1">Chapter 72: Exceptions</a>
..........................................................................................................................................
<a href="#Chapter_72__Exceptions_1">372</a></h1>
<p><a href="#Chapter_72__Exceptions_1">Section 72.1: Catching
exceptions</a>
............................................................................................................................
<a href="#Chapter_72__Exceptions_1">372</a></p>
<p><a href="#___This_block_of_code_will_never">Section 72.2: Rethrow
(propagate) exception</a>
.......................................................................................................
<a href="#___This_block_of_code_will_never">373</a></p>
<p><a href="#Section_72_3__Best_practice__thr">Section 72.3: Best
practice: throw by value, catch by const reference</a>
............................................................... <a
href="#Section_72_3__Best_practice__thr">374</a></p>
<p><a href="#due_to_memory_running_out_when_c">Section 72.4: Custom
exception</a>
...............................................................................................................................
<a href="#due_to_memory_running_out_when_c">375</a></p>
<p><a href="#___return__error_offset">Section 72.5:
std::uncaught_exceptions</a>
..................................................................................................................
<a href="#___return__error_offset">377</a></p>
<p><a href="#_28">Section 72.6: Function Try Block for regular
function</a>
...........................................................................................
<a href="#_28">378</a></p>
<p><a href="#_28">Section 72.7: Nested exception</a>
................................................................................................................................
<a href="#_28">378</a></p>
<p><a href="#_29">Section 72.8: Function Try Blocks In constructor</a>
...................................................................................................
<a href="#_29">380</a></p>
<p><a href="#Section_72_9__Function_Try_Block">Section 72.9: Function
Try Blocks In destructor</a>
.....................................................................................................
<a href="#Section_72_9__Function_Try_Block">381</a></p>
<h1
id="chapter-73-lambdas-.............................................................................................................................................-382"><a
href="#Chapter_73__Lambdas_1">Chapter 73: Lambdas</a>
.............................................................................................................................................
<a href="#Chapter_73__Lambdas_1">382</a></h1>
<p><a href="#Chapter_73__Lambdas_1">Section 73.1: What is a lambda
expression?</a>
...........................................................................................................
<a href="#Chapter_73__Lambdas_1">382</a></p>
<p><a href="#___the_lambda">Section 73.2: Specifying the return type</a>
.................................................................................................................
<a href="#___the_lambda">384</a></p>
<p><a href="#___error__return_types_must_matc">Section 73.3: Capture by
value</a>
................................................................................................................................
<a href="#___error__return_types_must_matc">385</a></p>
<p><a href="#The_const_applies_to_accesses_to">Section 73.4: Recursive
lambdas</a>
.............................................................................................................................
<a href="#The_const_applies_to_accesses_to">386</a></p>
<p><a href="#_30">Section 73.5: Default capture</a>
...................................................................................................................................
<a href="#_30">388</a></p>
<p><a href="#_30">Section 73.6: Class lambdas and capture of this</a>
...................................................................................................
<a href="#_30">388</a></p>
<p><a href="#Section_73_7__Capture_by_referen">Section 73.7: Capture by
reference</a>
.........................................................................................................................
<a href="#Section_73_7__Capture_by_referen">390</a></p>
<p><a href="#Section_73_7__Capture_by_referen">Section 73.8: Generic
lambdas
.................................................................................................................................
390</a></p>
<p><a href="#lamb1_x______Illegal__must_use">Section 73.9: Using lambdas
for inline parameter pack unpacking</a>
.................................................................... <a
href="#lamb1_x______Illegal__must_use">391</a></p>
<p><a href="#template_3">Section 73.10: Generalized capture
..........................................................................................................................
393</a></p>
<p><a href="#lamb_20______a__becomes_20">Section 73.11: Conversion to
function pointer</a>
.........................................................................................................
<a href="#lamb_20______a__becomes_20">394</a></p>
<p><a href="#lamb_20______a__becomes_20">Section 73.12: Porting lambda
functions to C++03 using functors</a>
.......................................................................
<a href="#lamb_20______a__becomes_20">394</a></p>
<h1
id="chapter-74-value-categories-...........................................................................................................................-396"><a
href="#Chapter_74__Value_Categories_1">Chapter 74: Value Categories</a>
...........................................................................................................................
<a href="#Chapter_74__Value_Categories_1">396</a></h1>
<p><a href="#Chapter_74__Value_Categories_1">Section 74.1: Value
Category Meanings</a>
..................................................................................................................
<a href="#Chapter_74__Value_Categories_1">396</a></p>
<p><a href="#Chapter_74__Value_Categories_1">Section 74.2: rvalue</a>
...................................................................................................................................................
<a href="#Chapter_74__Value_Categories_1">396</a></p>
<p><a href="#Consider_the_following">Section 74.3: xvalue</a>
...................................................................................................................................................
<a href="#Consider_the_following">397</a></p>
<p><a href="#Consider_the_following">Section 74.4: prvalue</a>
.................................................................................................................................................
<a href="#Consider_the_following">397</a></p>
<p><a href="#initialize_an_object__and_which">Section 74.5: lvalue
....................................................................................................................................................
398</a></p>
<p><a href="#initialize_an_object__and_which">Section 74.6: glvalue</a>
.................................................................................................................................................
<a href="#initialize_an_object__and_which">398</a></p>
<h1
id="chapter-75-preprocessor-....................................................................................................................................-399"><a
href="#Chapter_75__Preprocessor_1">Chapter 75: Preprocessor</a>
....................................................................................................................................
<a href="#Chapter_75__Preprocessor_1">399</a></h1>
<p><a href="#Chapter_75__Preprocessor_1">Section 75.1: Include
Guards</a>
.....................................................................................................................................
<a href="#Chapter_75__Preprocessor_1">399</a></p>
<p><a href="#_31">Section 75.2: Conditional logic and cross-platform
handling
...............................................................................
400</a></p>
<p><a href="#____________END_DUMP">Section 75.3: X-macros</a>
.............................................................................................................................................
<a href="#____________END_DUMP">401</a></p>
<p><a href="#_define_LIST_MACRO">Section 75.4: Macros</a>
.................................................................................................................................................
<a href="#_define_LIST_MACRO">403</a></p>
<p><a href="#printf___d___8">Section 75.5: Predefined macros</a>
.............................................................................................................................
<a href="#printf___d___8">406</a></p>
<p><a href="#Section_75_6__Preprocessor_Opera">Section 75.6:
Preprocessor Operators</a>
....................................................................................................................
<a href="#Section_75_6__Preprocessor_Opera">408</a></p>
<p><a href="#Section_75_6__Preprocessor_Opera">Section 75.7: #pragma
once</a>
....................................................................................................................................
<a href="#Section_75_6__Preprocessor_Opera">408</a></p>
<p><a href="#Projects_which_use__pragma_once">Section 75.8: Preprocessor
error messages
...........................................................................................................
409</a></p>
<h1
id="chapter-76-data-structures-in-c-................................................................................................................-410"><a
href="#Chapter_76__Data_Structures_in_C_1">Chapter 76: Data Structures
in C++</a>
................................................................................................................
<a href="#Chapter_76__Data_Structures_in_C_1">410</a></h1>
<p><a href="#Chapter_76__Data_Structures_in_C_1">Section 76.1: Linked
List implementation in C++
.....................................................................................................
410</a></p>
<h1
id="chapter-77-templates-..........................................................................................................................................-413"><a
href="#Chapter_77__Templates_1">Chapter 77: Templates</a>
..........................................................................................................................................
<a href="#Chapter_77__Templates_1">413</a></h1>
<p><a href="#Chapter_77__Templates_1">Section 77.1: Basic Class
Template</a>
..........................................................................................................................
<a href="#Chapter_77__Templates_1">413</a></p>
<p><a href="#Chapter_77__Templates_1">Section 77.2: Function
Templates</a>
............................................................................................................................
<a href="#Chapter_77__Templates_1">413</a></p>
<p><a href="#Section_77_3__Variadic_template">Section 77.3: Variadic
template data structures</a>
....................................................................................................
<a href="#Section_77_3__Variadic_template">415</a></p>
<p><a href="#_include_3">Section 77.4: Argument forwarding</a>
........................................................................................................................
<a href="#_include_3">417</a></p>
<p><a href="#template_5">Section 77.5: Partial template
specialization</a>
..........................................................................................................
<a href="#template_5">418</a></p>
<p><a href="#___Compilation_error__partial_fu">Section 77.6: Template
Specialization</a>
.....................................................................................................................
<a href="#___Compilation_error__partial_fu">420</a></p>
<p><a href="#___Compilation_error__partial_fu">Section 77.7: Alias
template</a>
.....................................................................................................................................
<a href="#___Compilation_error__partial_fu">420</a></p>
<p><a href="#___Compilation_error__partial_fu">Section 77.8: Explicit
instantiation</a>
............................................................................................................................
<a href="#___Compilation_error__partial_fu">420</a></p>
<p><a href="#___print_string_cpp">Section 77.9: Non-type template
parameter</a>
.........................................................................................................
<a href="#___print_string_cpp">421</a></p>
<p><a href="#Like_all_template_parameters__no">Section 77.10: Declaring
non-type template arguments with auto
......................................................................
422</a></p>
<p><a href="#using_five___integral_constant_5">Section 77.11: Template
template parameters</a>
.......................................................................................................
<a href="#using_five___integral_constant_5">423</a></p>
<p><a href="#_34">Section 77.12: Default template parameter value</a>
.................................................................................................
<a href="#_34">424</a></p>
<p><span id="Chapter_78__Expression_templates" class="anchor"></span><a
href="#Chapter_78__Expression_templates_1">Chapter 78: Expression
templates
...................................................................................................................
425</a></p>
<p><a href="#Chapter_78__Expression_templates_1">Section 78.1: A basic
example illustrating expression templates</a>
.........................................................................
<a href="#Chapter_78__Expression_templates_1">425</a></p>
<h1
id="chapter-79-curiously-recurring-template-pattern-crtp-...............................................................-429"><a
href="#Chapter_79__Curiously_Recurring_1">Chapter 79: Curiously
Recurring Template Pattern (CRTP)</a>
............................................................... <a
href="#Chapter_79__Curiously_Recurring_1">429</a></h1>
<p><a href="#Chapter_79__Curiously_Recurring_1">Section 79.1: The
Curiously Recurring Template Pattern (CRTP)
.........................................................................
429</a></p>
<p><a href="#using_Base___Container">Section 79.2: CRTP to avoid code
duplication
........................................................................................................
430</a></p>
<p><span id="Chapter_80__Threading" class="anchor"></span><a
href="#Chapter_80__Threading_1">Chapter 80: Threading
...........................................................................................................................................
432</a></p>
<p><a href="#Chapter_80__Threading_1">Section 80.1: Creating a
std::thread</a>
.........................................................................................................................
<a href="#Chapter_80__Threading_1">432</a></p>
<p><a href="#return_0_1">Section 80.2: Passing a reference to a
thread</a>
.......................................................................................................
<a href="#return_0_1">434</a></p>
<p><a href="#return_0_1">Section 80.3: Using std::async instead of
std::thread</a>
............................................................................................
<a href="#return_0_1">434</a></p>
<p><a href="#std__async_std__launch__async__s">Section 80.4: Basic
Synchronization
........................................................................................................................
435</a></p>
<p><a href="#std__async_std__launch__async__s">Section 80.5: Create a
simple thread pool</a>
.............................................................................................................
<a href="#std__async_std__launch__async__s">435</a></p>
<p><a href="#private">Section 80.6: Ensuring a thread is always joined
...................................................................................................
437</a></p>
<p><a href="#_35">Section 80.7: Operations on the current thread</a>
....................................................................................................
<a href="#_35">438</a></p>
<p><a href="#std__thread_thread__foo">Section 80.8: Using Condition
Variables</a>
.................................................................................................................
<a href="#std__thread_thread__foo">439</a></p>
<p><a href="#std__cout_____Consumer_is_done">Section 80.9: Thread
operations</a>
.............................................................................................................................
<a href="#std__cout_____Consumer_is_done">441</a></p>
<p><a href="#std__cout_____Consumer_is_done">Section 80.10: Thread-local
storage
........................................................................................................................
441</a></p>
<p><a href="#Example_1">Section 80.11: Reassigning thread objects</a>
..............................................................................................................
<a href="#Example_1">442</a></p>
<h1
id="chapter-81-thread-synchronization-structures-.......................................................................................-443"><a
href="#Chapter_81__Thread_synchronizati_1">Chapter 81: Thread
synchronization structures</a>
.......................................................................................
<a href="#Chapter_81__Thread_synchronizati_1">443</a></h1>
<p><a href="#Chapter_81__Thread_synchronizati_1">Section 81.1:
std::condition_variable_any, std::cv_status</a>
......................................................................................
<a href="#Chapter_81__Thread_synchronizati_1">443</a></p>
<p><a href="#Chapter_81__Thread_synchronizati_1">Section 81.2:
std::shared_lock</a>
..................................................................................................................................
<a href="#Chapter_81__Thread_synchronizati_1">443</a></p>
<p><a href="#Chapter_81__Thread_synchronizati_1">Section 81.3:
std::call_once, std::once_flag</a>
.............................................................................................................
<a href="#Chapter_81__Thread_synchronizati_1">443</a></p>
<p><a href="#_include_4">Section 81.4: Object locking for ecient
access</a>
....................................................................................................
<a href="#_include_4">444</a></p>
<h1
id="chapter-82-the-rule-of-three-five-and-zero-.........................................................................................-446"><a
href="#Chapter_82__The_Rule_of_Three__F_1">Chapter 82: The Rule of
Three, Five, And Zero</a>
.........................................................................................
<a href="#Chapter_82__The_Rule_of_Three__F_1">446</a></h1>
<p><a href="#Chapter_82__The_Rule_of_Three__F_1">Section 82.1: Rule of
Zero</a>
.........................................................................................................................................
<a href="#Chapter_82__The_Rule_of_Three__F_1">446</a></p>
<p><a href="#The_term_rule_of_zero_was_introd">Section 82.2: Rule of
Five</a>
.........................................................................................................................................
<a href="#The_term_rule_of_zero_was_introd">447</a></p>
<p><a href="#swap__this__that">Section 82.3: Rule of Three</a>
......................................................................................................................................
<a href="#swap__this__that">448</a></p>
<p><a href="#Since_name_was_allocated_in_the">Section 82.4:
Self-assignment Protection</a>
...............................................................................................................
<a href="#Since_name_was_allocated_in_the">449</a></p>
<h1
id="chapter-83-raii-resource-acquisition-is-initialization-.........................................................................-451"><a
href="#Chapter_83__RAII__Resource_Acqui_1">Chapter 83: RAII: Resource
Acquisition Is Initialization</a>
.........................................................................
<a href="#Chapter_83__RAII__Resource_Acqui_1">451</a></h1>
<p><a href="#Chapter_83__RAII__Resource_Acqui_1">Section 83.1:
Locking</a>
.................................................................................................................................................
<a href="#Chapter_83__RAII__Resource_Acqui_1">451</a></p>
<p><a href="#Section_83_2__ScopeSuccess__c__1">Section 83.2:
ScopeSuccess (c++17)</a>
........................................................................................................................
<a href="#Section_83_2__ScopeSuccess__c__1">452</a></p>
<p><a href="#Output">Section 83.3: ScopeFail (c++17)</a>
................................................................................................................................
<a href="#Output">453</a></p>
<p><a href="#throw_std__runtime_error__Failed">Section 83.4:
Finally/ScopeExit</a>
................................................................................................................................
<a href="#throw_std__runtime_error__Failed">454</a></p>
<h1
id="chapter-84-rtti-run-time-type-information-........................................................................................-455"><a
href="#Chapter_84__RTTI__Run_Time_Type_1">Chapter 84: RTTI: Run-Time
Type Information</a>
........................................................................................
<a href="#Chapter_84__RTTI__Run_Time_Type_1">455</a></h1>
<p><a href="#Chapter_84__RTTI__Run_Time_Type_1">Section 84.1:
dynamic_cast</a>
......................................................................................................................................
<a href="#Chapter_84__RTTI__Run_Time_Type_1">455</a></p>
<p><a href="#Chapter_84__RTTI__Run_Time_Type_1">Section 84.2: The typeid
keyword</a>
...........................................................................................................................
<a href="#Chapter_84__RTTI__Run_Time_Type_1">455</a></p>
<p><a href="#assert_typeid_b_____typeid_Base">Section 84.3: Name of a
type
...................................................................................................................................
456</a></p>
<p><a href="#assert_typeid_b_____typeid_Base">Section 84.4: When to use
which cast in c++</a>
..........................................................................................................
<a href="#assert_typeid_b_____typeid_Base">456</a></p>
<h1
id="chapter-85-mutexes-...............................................................................................................................................-457"><a
href="#Chapter_85__Mutexes_1">Chapter 85: Mutexes</a>
...............................................................................................................................................
<a href="#Chapter_85__Mutexes_1">457</a></h1>
<p><a href="#Chapter_85__Mutexes_1">Section 85.1: Mutex Types</a>
........................................................................................................................................
<a href="#Chapter_85__Mutexes_1">457</a></p>
<p><a href="#Chapter_85__Mutexes_1">Section 85.2: std::lock</a>
................................................................................................................................................
<a href="#Chapter_85__Mutexes_1">457</a></p>
<p><a href="#Chapter_85__Mutexes_1">Section 85.3: std::unique_lock,
std::shared_lock, std::lock_guard</a>
.......................................................................
<a href="#Chapter_85__Mutexes_1">457</a></p>
<p><a href="#_36">Section 85.4: Strategies for lock classes:
std::try_to_lock, std::adopt_lock, std::defer_lock</a>
............................ <a href="#_36">458</a></p>
<p><a href="#std__lock_lock1_lock2______no_de">Section 85.5:
std::mutex</a>
............................................................................................................................................
<a href="#std__lock_lock1_lock2______no_de">459</a></p>
<p><a href="#std__lock_lock1_lock2______no_de">Section 85.6:
std::scoped_lock (C++ 17)</a>
..................................................................................................................
<a href="#std__lock_lock1_lock2______no_de">459</a></p>
<h1
id="chapter-86-recursive-mutex-..............................................................................................................................-460"><a
href="#Chapter_86__Recursive_Mutex_1">Chapter 86: Recursive Mutex</a>
..............................................................................................................................
<a href="#Chapter_86__Recursive_Mutex_1">460</a></h1>
<p><a href="#Chapter_86__Recursive_Mutex_1">Section 86.1:
std::recursive_mutex</a>
...........................................................................................................................
<a href="#Chapter_86__Recursive_Mutex_1">460</a></p>
<h1
id="chapter-87-semaphore-........................................................................................................................................-461"><a
href="#Chapter_87__Semaphore_1">Chapter 87: Semaphore</a>
........................................................................................................................................
<a href="#Chapter_87__Semaphore_1">461</a></h1>
<p><a href="#Chapter_87__Semaphore_1">Section 87.1: Semaphore C++ 11</a>
...............................................................................................................................
<a href="#Chapter_87__Semaphore_1">461</a></p>
<p><a href="#Chapter_87__Semaphore_1">Section 87.2: Semaphore class in
action</a>
................................................................................................................
<a href="#Chapter_87__Semaphore_1">461</a></p>
<h1
id="chapter-88-futures-and-promises-..................................................................................................................-463"><a
href="#Chapter_88__Futures_and_Promises_1">Chapter 88: Futures and
Promises</a>
..................................................................................................................
<a href="#Chapter_88__Futures_and_Promises_1">463</a></h1>
<p><a href="#Chapter_88__Futures_and_Promises_1">Section 88.1: Async
operation classes</a>
.....................................................................................................................
<a href="#Chapter_88__Futures_and_Promises_1">463</a></p>
<p><a href="#Chapter_88__Futures_and_Promises_1">Section 88.2:
std::future and std::promise</a>
...............................................................................................................
<a href="#Chapter_88__Futures_and_Promises_1">463</a></p>
<p><a href="#Chapter_88__Futures_and_Promises_1">Section 88.3: Deferred
async example</a>
...................................................................................................................
<a href="#Chapter_88__Futures_and_Promises_1">463</a></p>
<p><a href="#_37">Section 88.4: std::packaged_task and std::future</a>
..................................................................................................
<a href="#_37">464</a></p>
<p><a href="#_37">Section 88.5: std::future_error and
std::future_errc</a>
..............................................................................................
<a href="#_37">464</a></p>
<p><a href="#Active_promise__unused">Section 88.6: std::future and
std::async</a>
...................................................................................................................
<a href="#Active_promise__unused">465</a></p>
<h1
id="chapter-89-atomic-types-....................................................................................................................................-468"><a
href="#Chapter_89__Atomic_Types_1">Chapter 89: Atomic Types</a>
....................................................................................................................................
<a href="#Chapter_89__Atomic_Types_1">468</a></h1>
<p><a href="#Chapter_89__Atomic_Types_1">Section 89.1: Multi-threaded
Access</a>
........................................................................................................................
<a href="#Chapter_89__Atomic_Types_1">468</a></p>
<h1
id="chapter-90-type-erasure-....................................................................................................................................-470"><a
href="#Chapter_90__Type_Erasure_1">Chapter 90: Type Erasure</a>
....................................................................................................................................
<a href="#Chapter_90__Type_Erasure_1">470</a></h1>
<p><a href="#Chapter_90__Type_Erasure_1">Section 90.1: A move-only
`std::function`</a>
.................................................................................................................
<a href="#Chapter_90__Type_Erasure_1">470</a></p>
<p><a href="#friend_bool_operator____task_con">Section 90.2: Erasing
down to a Regular type with manual vtable</a>
..................................................................... <a
href="#friend_bool_operator____task_con">472</a></p>
<p><a href="#Small_object_optimization_requir">Section 90.3: Basic
mechanism</a>
...............................................................................................................................
<a href="#Small_object_optimization_requir">475</a></p>
<p><a href="#interface__as_with_templates">Section 90.4: Erasing down to
a contiguous buer of T</a>
.......................................................................................
<a href="#interface__as_with_templates">476</a></p>
<p><a href="#___array_view_is_plain_old_data">Section 90.5: Type erasing
type erasure with std::any</a>
.........................................................................................
<a href="#___array_view_is_plain_old_data">477</a></p>
<h1
id="chapter-91-explicit-type-conversions-.............................................................................................................-482"><a
href="#Chapter_91__Explicit_type_conver_1">Chapter 91: Explicit type
conversions</a>
.............................................................................................................
<a href="#Chapter_91__Explicit_type_conver_1">482</a></h1>
<p><a href="#Chapter_91__Explicit_type_conver_1">Section 91.1: C-style
casting</a>
......................................................................................................................................
<a href="#Chapter_91__Explicit_type_conver_1">482</a></p>
<p><a href="#Chapter_91__Explicit_type_conver_1">Section 91.2: Casting
away constness</a>
.....................................................................................................................
<a href="#Chapter_91__Explicit_type_conver_1">482</a></p>
<p><a href="#Chapter_91__Explicit_type_conver_1">Section 91.3: Base to
derived conversion</a>
................................................................................................................
<a href="#Chapter_91__Explicit_type_conver_1">482</a></p>
<p><a href="#struct_Base">Section 91.4: Conversion between pointer and
integer</a>
.........................................................................................
<a href="#struct_Base">483</a></p>
<p><a href="#register_callback_my_callback">Section 91.5: Conversion by
explicit constructor or explicit conversion function</a>
............................................... <a
href="#register_callback_my_callback">484</a></p>
<p><a href="#register_callback_my_callback">Section 91.6: Implicit
conversion</a>
..............................................................................................................................
<a href="#register_callback_my_callback">484</a></p>
<p><a href="#register_callback_my_callback">Section 91.7: Enum
conversions</a>
...............................................................................................................................
<a href="#register_callback_my_callback">484</a></p>
<p><a href="#Direction_d___static_cast_3_14">Section 91.8: Derived to
base conversion for pointers to members</a>
.................................................................... <a
href="#Direction_d___static_cast_3_14">486</a></p>
<p><a href="#Direction_d___static_cast_3_14">Section 91.9: void* to
T*</a>
.............................................................................................................................................
<a href="#Direction_d___static_cast_3_14">486</a></p>
<p><a href="#Section_91_10__Type_punning_conv">Section 91.10: Type
punning conversion</a>
.................................................................................................................
<a href="#Section_91_10__Type_punning_conv">487</a></p>
<h1
id="chapter-92-unnamed-types-...............................................................................................................................-488"><a
href="#Chapter_92__Unnamed_types_1">Chapter 92: Unnamed types</a>
...............................................................................................................................
<a href="#Chapter_92__Unnamed_types_1">488</a></h1>
<p><a href="#Chapter_92__Unnamed_types_1">Section 92.1: Unnamed
classes</a>
................................................................................................................................
<a href="#Chapter_92__Unnamed_types_1">488</a></p>
<p><a href="#Chapter_92__Unnamed_types_1">Section 92.2: As a type
alias</a>
....................................................................................................................................
<a href="#Chapter_92__Unnamed_types_1">488</a></p>
<p><a href="#Chapter_92__Unnamed_types_1">Section 92.3: Anonymous
members</a>
.......................................................................................................................
<a href="#Chapter_92__Unnamed_types_1">488</a></p>
<p><a href="#__The_anonymous_struct_s_members">Section 92.4: Anonymous
Union</a>
..............................................................................................................................
<a href="#__The_anonymous_struct_s_members">489</a></p>
<p><span id="Chapter_93__Type_Traits" class="anchor"></span><a
href="#Chapter_93__Type_Traits_1">Chapter 93: Type Traits
.........................................................................................................................................
490</a></p>
<p><a href="#Chapter_93__Type_Traits_1">Section 93.1: Type
Properties</a>
...................................................................................................................................
<a href="#Chapter_93__Type_Traits_1">490</a></p>
<p><a href="#Section_93_2__Standard_type_trai">Section 93.2: Standard
type traits</a>
...........................................................................................................................
<a href="#Section_93_2__Standard_type_trai">491</a></p>
<p><a href="#typename_std__enable_if__value">Section 93.3: Type
relations with std::is_same&lt;T, T&gt;</a>
............................................................................................
<a href="#typename_std__enable_if__value">492</a></p>
<p><a href="#return_var1_member___var2">Section 93.4: Fundamental type
traits</a>
....................................................................................................................
<a href="#return_var1_member___var2">493</a></p>
<h1
id="chapter-94-return-type-covariance-............................................................................................................-495"><a
href="#Chapter_94__Return_Type_Covarian_1">Chapter 94: Return Type
Covariance</a>
............................................................................................................
<a href="#Chapter_94__Return_Type_Covarian_1">495</a></h1>
<p><a href="#Chapter_94__Return_Type_Covarian_1">Section 94.1: Covariant
result version of the base example, static type checking</a>
............................................. <a
href="#Chapter_94__Return_Type_Covarian_1">495</a></p>
<p><a href="#Chapter_94__Return_Type_Covarian_1">Section 94.2: Covariant
smart pointer result (automated cleanup)</a>
.................................................................... <a
href="#Chapter_94__Return_Type_Covarian_1">495</a></p>
<h1
id="chapter-95-layout-of-object-types-................................................................................................................-497"><a
href="#Chapter_95__Layout_of_object_typ_1">Chapter 95: Layout of object
types</a>
................................................................................................................
<a href="#Chapter_95__Layout_of_object_typ_1">497</a></h1>
<p><a href="#Chapter_95__Layout_of_object_typ_1">Section 95.1: Class
types</a>
...........................................................................................................................................
<a href="#Chapter_95__Layout_of_object_typ_1">497</a></p>
<p><a href="#float_f">Section 95.2: Arithmetic types</a>
.................................................................................................................................
<a href="#float_f">499</a></p>
<p><a href="#It_is_implementation_defined_whe">Section 95.3: Arrays</a>
..................................................................................................................................................
<a href="#It_is_implementation_defined_whe">500</a></p>
<h1
id="chapter-96-type-inference-................................................................................................................................-501"><a
href="#Chapter_96__Type_Inference_1">Chapter 96: Type Inference</a>
................................................................................................................................
<a href="#Chapter_96__Type_Inference_1">501</a></h1>
<p><a href="#Chapter_96__Type_Inference_1">Section 96.1: Data Type:
Auto</a>
..................................................................................................................................
<a href="#Chapter_96__Type_Inference_1">501</a></p>
<p><a href="#Chapter_96__Type_Inference_1">Section 96.2: Lambda auto</a>
......................................................................................................................................
<a href="#Chapter_96__Type_Inference_1">501</a></p>
<p><a href="#Chapter_96__Type_Inference_1">Section 96.3: Loops and
auto</a>
...................................................................................................................................
<a href="#Chapter_96__Type_Inference_1">501</a></p>
<h1
id="chapter-97-typedef-and-type-aliases-..........................................................................................................-503"><a
href="#Chapter_97__Typedef_and_type_ali_1">Chapter 97: Typedef and type
aliases</a>
..........................................................................................................
<a href="#Chapter_97__Typedef_and_type_ali_1">503</a></h1>
<p><a href="#Chapter_97__Typedef_and_type_ali_1">Section 97.1: Basic
typedef syntax</a>
..........................................................................................................................
<a href="#Chapter_97__Typedef_and_type_ali_1">503</a></p>
<p><a href="#Chapter_97__Typedef_and_type_ali_1">Section 97.2: More
complex uses of typedef</a>
.........................................................................................................
<a href="#Chapter_97__Typedef_and_type_ali_1">503</a></p>
<p><a href="#pmf_Foo__f_const_char">Section 97.3: Declaring multiple
types with typedef</a>
.............................................................................................
<a href="#pmf_Foo__f_const_char">504</a></p>
<p><a href="#pmf_Foo__f_const_char">Section 97.4: Alias declaration with
"using"</a>
............................................................................................................
<a href="#pmf_Foo__f_const_char">504</a></p>
<h1
id="chapter-98-type-deduction-................................................................................................................................-505"><a
href="#Chapter_98__type_deduction_1">Chapter 98: type deduction</a>
................................................................................................................................
<a href="#Chapter_98__type_deduction_1">505</a></h1>
<p><a href="#Chapter_98__type_deduction_1">Section 98.1: Template
parameter deduction for constructors</a>
...........................................................................
<a href="#Chapter_98__type_deduction_1">505</a></p>
<p><a href="#Chapter_98__type_deduction_1">Section 98.2: Auto Type
Deduction</a>
.........................................................................................................................
<a href="#Chapter_98__type_deduction_1">505</a></p>
<p><a href="#When_auto_is_used_as_the_return">Section 98.3: Template
Type Deduction</a>
.................................................................................................................
<a href="#When_auto_is_used_as_the_return">506</a></p>
<p><span id="Chapter_99__Trailing_return_type" class="anchor"></span><a
href="#Chapter_99__Trailing_return_type_1">Chapter 99: Trailing return
type
.......................................................................................................................
508</a></p>
<p><a href="#Chapter_99__Trailing_return_type_1">Section 99.1: Avoid
qualifying a nested type name</a>
...............................................................................................
<a href="#Chapter_99__Trailing_return_type_1">508</a></p>
<p><a href="#Chapter_99__Trailing_return_type_1">Section 99.2: Lambda
expressions</a>
..........................................................................................................................
<a href="#Chapter_99__Trailing_return_type_1">508</a></p>
<h1
id="chapter-100-alignment-.........................................................................................................................................-509"><a
href="#Chapter_100__Alignment_1">Chapter 100: Alignment</a>
.........................................................................................................................................
<a href="#Chapter_100__Alignment_1">509</a></h1>
<p><a href="#Chapter_100__Alignment_1">Section 100.1: Controlling
alignment
........................................................................................................................
509</a></p>
<p><a href="#Chapter_100__Alignment_1">Section 100.2: Querying the
alignment of a type</a>
..................................................................................................
<a href="#Chapter_100__Alignment_1">509</a></p>
<h1
id="chapter-101-perfect-forwarding-......................................................................................................................-511"><a
href="#Chapter_101__Perfect_Forwarding_1">Chapter 101: Perfect
Forwarding</a>
......................................................................................................................
<a href="#Chapter_101__Perfect_Forwarding_1">511</a></h1>
<p><a href="#Chapter_101__Perfect_Forwarding_1">Section 101.1: Factory
functions</a>
................................................................................................................................
<a href="#Chapter_101__Perfect_Forwarding_1">511</a></p>
<h1
id="chapter-102-decltype-............................................................................................................................................-512"><a
href="#Chapter_102__decltype_1">Chapter 102: decltype</a>
............................................................................................................................................
<a href="#Chapter_102__decltype_1">512</a></h1>
<p><a href="#Chapter_102__decltype_1">Section 102.1: Basic Example</a>
....................................................................................................................................
<a href="#Chapter_102__decltype_1">512</a></p>
<p><a href="#Chapter_102__decltype_1">Section 102.2: Another example
...............................................................................................................................
512</a></p>
<h1
id="chapter-103-sfinae-substitution-failure-is-not-an-error-................................................................-513"><a
href="#Chapter_103__SFINAE__Substitutio_1">Chapter 103: SFINAE
(Substitution Failure Is Not An Error)</a>
................................................................ <a
href="#Chapter_103__SFINAE__Substitutio_1">513</a></h1>
<p><a href="#Chapter_103__SFINAE__Substitutio_1">Section 103.1: What is
SFINAE</a>
...................................................................................................................................
<a href="#Chapter_103__SFINAE__Substitutio_1">513</a></p>
<p><a href="#Chapter_103__SFINAE__Substitutio_1">Section 103.2:
void_t</a>
.................................................................................................................................................
<a href="#Chapter_103__SFINAE__Substitutio_1">513</a></p>
<p><a href="#template_6">Section 103.3: enable_if</a>
............................................................................................................................................
<a href="#template_6">515</a></p>
<p><a href="#___for_arrays">Section 103.4: is_detected</a>
........................................................................................................................................
<a href="#___for_arrays">516</a></p>
<p><a href="#static_assert_std__is_same">Section 103.5: Overload
resolution with a large number of options</a>
.................................................................... <a
href="#static_assert_std__is_same">518</a></p>
<p><a href="#_41">Section 103.6: trailing decltype in function
templates</a>
...........................................................................................
<a href="#_41">519</a></p>
<p><a href="#Section_103_7__enable_if_all___e">Section 103.7:
enable_if_all / enable_if_any</a>
........................................................................................................
<a href="#Section_103_7__enable_if_all___e">520</a></p>
<p><span id="Chapter_104__Undefined_Behavior" class="anchor"></span><a
href="#Chapter_104__Undefined_Behavior_1">Chapter 104: Undefined
Behavior
....................................................................................................................
522</a></p>
<p><a href="#Chapter_104__Undefined_Behavior_1">Section 104.1: Reading
or writing through a null pointer</a>
.......................................................................................
<a href="#Chapter_104__Undefined_Behavior_1">522</a></p>
<p><a href="#Chapter_104__Undefined_Behavior_1">Section 104.2: Using an
uninitialized local variable</a>
...............................................................................................
<a href="#Chapter_104__Undefined_Behavior_1">522</a></p>
<p><a href="#static_int_a">Section 104.3: Accessing an out-of-bounds
index
..................................................................................................
523</a></p>
<p><a href="#static_int_a">Section 104.4: Deleting a derived object via
a pointer to a base class that doesn't have a virtual destructor</a></p>
<p>.............................................................................................................................................................................
<a href="#static_int_a">523</a></p>
<p><a href="#static_int_a">Section 104.5: Extending the `std` or `posix`
Namespace</a>
......................................................................................
<a href="#static_int_a">523</a></p>
<p><a href="#The_behavior_of_a_C___program_is">Section 104.6: Invalid
pointer arithmetic</a>
.................................................................................................................
<a href="#The_behavior_of_a_C___program_is">524</a></p>
<p><a href="#int_a_10">Section 104.7: No return statement for a function
with a non-void return type
................................................. 525</a></p>
<p><a href="#int_a_10">Section 104.8: Accessing a dangling reference</a>
......................................................................................................
<a href="#int_a_10">525</a></p>
<p><a href="#int_main_2">Section 104.9: Integer division by zero</a>
....................................................................................................................
<a href="#int_main_2">526</a></p>
<p><a href="#int_main_2">Section 104.10: Shifting by an invalid number
of positions</a>
...................................................................................
<a href="#int_main_2">526</a></p>
<p><a href="#int_main_2">Section 104.11: Incorrect pairing of memory
allocation and deallocation</a>
........................................................... <a
href="#int_main_2">526</a></p>
<p><a href="#int__p3___static_cast_malloc_siz">Section 104.12: Signed
Integer Overflow</a>
.................................................................................................................
<a href="#int__p3___static_cast_malloc_siz">527</a></p>
<p><a href="#int__p3___static_cast_malloc_siz">Section 104.13: Multiple
non-identical definitions (the One Definition Rule)</a>
........................................................ <a
href="#int__p3___static_cast_malloc_siz">527</a></p>
<p><a href="#_ODR">Section 104.14: Modifying a const object</a>
................................................................................................................
<a href="#_ODR">528</a></p>
<p><a href="#class_Foo">Section 104.15: Returning from a [[noreturn]]
function</a>
........................................................................................
<a href="#class_Foo">529</a></p>
<p><a href="#class_Foo">Section 104.16: Infinite template recursion</a>
..............................................................................................................
<a href="#class_Foo">529</a></p>
<p><a href="#___the_implicit_instantiation_of">Section 104.17: Overflow
during conversion to or from floating point type</a>
........................................................ <a
href="#___the_implicit_instantiation_of">530</a></p>
<p><a href="#___the_implicit_instantiation_of">Section 104.18: Modifying
a string literal</a>
.................................................................................................................
<a href="#___the_implicit_instantiation_of">530</a></p>
<p><a href="#___the_implicit_instantiation_of">Section 104.19: Accessing
an object as the wrong type</a>
........................................................................................
<a href="#___the_implicit_instantiation_of">530</a></p>
<p><a href="#A_related_rule_is_that_if_a_non">Section 104.20: Invalid
derived-to-base conversion for pointers to members</a>
................................................... <a
href="#A_related_rule_is_that_if_a_non">531</a></p>
<p><a href="#A_related_rule_is_that_if_a_non">Section 104.21: Destroying
an object that has already been destroyed</a>
............................................................. <a
href="#A_related_rule_is_that_if_a_non">531</a></p>
<p><a href="#___NB__this_is_correct">Section 104.22: Access to
nonexistent member through pointer to member
..................................................... 532</a></p>
<p><a href="#___NB__this_is_correct">Section 104.23: Invalid
base-to-derived static cast
................................................................................................
532</a></p>
<p><a href="#___NB__this_is_correct">Section 104.24: Floating point
overflow</a>
..................................................................................................................
<a href="#___NB__this_is_correct">532</a></p>
<p><a href="#___NB__this_is_correct">Section 104.25: Calling (Pure)
Virtual Members From Constructor Or Destructor</a>
............................................. <a
href="#___NB__this_is_correct">532</a></p>
<p><a href="#_42">Section 104.26: Function call through mismatched
function pointer type</a>
.......................................................... <a
href="#_42">533</a></p>
<h1
id="chapter-105-overload-resolution-....................................................................................................................-534"><a
href="#Chapter_105__Overload_resolution_1">Chapter 105: Overload
resolution</a>
....................................................................................................................
<a href="#Chapter_105__Overload_resolution_1">534</a></h1>
<p><a href="#Chapter_105__Overload_resolution_1">Section 105.1:
Categorization of argument to parameter cost
.............................................................................
534</a></p>
<p><a href="#Chapter_105__Overload_resolution_1">Section 105.2:
Arithmetic promotions and conversions</a>
........................................................................................
<a href="#Chapter_105__Overload_resolution_1">534</a></p>
<p><a href="#void_g_long_x">Section 105.3: Overloading on Forwarding
Reference</a>
..........................................................................................
<a href="#void_g_long_x">535</a></p>
<p><a href="#Section_105_4__Exact_match">Section 105.4: Exact match</a>
.......................................................................................................................................
<a href="#Section_105_4__Exact_match">536</a></p>
<p><a href="#Section_105_4__Exact_match">Section 105.5: Overloading on
constness and volatility</a>
........................................................................................
<a href="#Section_105_4__Exact_match">536</a></p>
<p><a href="#int_x">Section 105.6: Name lookup and access checking</a>
................................................................................................
<a href="#int_x">537</a></p>
<p><a href="#private_1">Section 105.7: Overloading within a class
hierarchy</a>
..............................................................................................
<a href="#private_1">538</a></p>
<p><a href="#void_f_int_B___p">Section 105.8: Steps of Overload
Resolution</a>
..........................................................................................................
<a href="#void_f_int_B___p">539</a></p>
<h1
id="chapter-106-move-semantics-............................................................................................................................-541"><a
href="#Chapter_106__Move_Semantics_1">Chapter 106: Move Semantics</a>
............................................................................................................................
<a href="#Chapter_106__Move_Semantics_1">541</a></h1>
<p><a href="#Chapter_106__Move_Semantics_1">Section 106.1: Move
semantics</a>
.................................................................................................................................
<a href="#Chapter_106__Move_Semantics_1">541</a></p>
<p><a href="#Chapter_106__Move_Semantics_1">Section 106.2: Using
std::move to reduce complexity from O(n²) to O(n)</a>
........................................................... <a
href="#Chapter_106__Move_Semantics_1">541</a></p>
<p><a href="#Summing_up__the_C___language_and">Section 106.3: Move
constructor</a>
..............................................................................................................................
<a href="#Summing_up__the_C___language_and">544</a></p>
<p><a href="#_44">Section 106.4: Re-use a moved object</a>
....................................................................................................................
<a href="#_44">546</a></p>
<p><a href="#_44">Section 106.5: Move assignment</a>
..............................................................................................................................
<a href="#_44">546</a></p>
<p><a href="#one_object_to_another_existing_o">Section 106.6: Using move
semantics on containers</a>
.............................................................................................
<a href="#one_object_to_another_existing_o">547</a></p>
<h1
id="chapter-107-pimpl-idiom-......................................................................................................................................-549"><a
href="#Chapter_107__Pimpl_Idiom_1">Chapter 107: Pimpl Idiom</a>
......................................................................................................................................
<a href="#Chapter_107__Pimpl_Idiom_1">549</a></h1>
<p><a href="#Chapter_107__Pimpl_Idiom_1">Section 107.1: Basic Pimpl
idiom</a>
...............................................................................................................................
<a href="#Chapter_107__Pimpl_Idiom_1">549</a></p>
<h1
id="chapter-108-auto-.....................................................................................................................................................-551"><a
href="#Chapter_108__auto_1">Chapter 108: auto</a>
.....................................................................................................................................................
<a href="#Chapter_108__auto_1">551</a></h1>
<p><a href="#Chapter_108__auto_1">Section 108.1: Basic auto sample</a>
.............................................................................................................................
<a href="#Chapter_108__auto_1">551</a></p>
<p><a href="#Chapter_108__auto_1">Section 108.2: Generic lambda
(C++14)</a>
...................................................................................................................
<a href="#Chapter_108__auto_1">551</a></p>
<p><a href="#std__cout____arg____std__endl">Section 108.3: auto and
proxy objects</a>
....................................................................................................................
<a href="#std__cout____arg____std__endl">552</a></p>
<p><a href="#std__cout____arg____std__endl">Section 108.4: auto and
Expression Templates</a>
......................................................................................................
<a href="#std__cout____arg____std__endl">552</a></p>
<p><a href="#_46">Section 108.5: auto, const, and references</a>
.............................................................................................................
<a href="#_46">553</a></p>
<p><a href="#_46">Section 108.6: Trailing return type</a>
...........................................................................................................................
<a href="#_46">553</a></p>
<h1
id="chapter-109-copy-elision-.....................................................................................................................................-555"><a
href="#Chapter_109__Copy_Elision_1">Chapter 109: Copy Elision</a>
.....................................................................................................................................
<a href="#Chapter_109__Copy_Elision_1">555</a></h1>
<p><a href="#Chapter_109__Copy_Elision_1">Section 109.1: Purpose of copy
elision</a>
.....................................................................................................................
<a href="#Chapter_109__Copy_Elision_1">555</a></p>
<p><a href="#construction_is_elided__the_type">Section 109.2: Guaranteed
copy elision</a>
..................................................................................................................
<a href="#construction_is_elided__the_type">556</a></p>
<p><a href="#__Do_stuff">Section 109.3: Parameter elision</a>
..............................................................................................................................
<a href="#__Do_stuff">557</a></p>
<p><a href="#__Do_stuff">Section 109.4: Return value elision</a>
..........................................................................................................................
<a href="#__Do_stuff">557</a></p>
<p><a href="#__Do_stuff">Section 109.5: Named return value elision</a>
..............................................................................................................
<a href="#__Do_stuff">557</a></p>
<p><a href="#If_all_of_these_are_the_case__th">Section 109.6: Copy
initialization elision</a>
..................................................................................................................
<a href="#If_all_of_these_are_the_case__th">558</a></p>
<h1
id="chapter-110-fold-expressions-............................................................................................................................-559"><a
href="#Chapter_110__Fold_Expressions_1">Chapter 110: Fold
Expressions</a>
............................................................................................................................
<a href="#Chapter_110__Fold_Expressions_1">559</a></h1>
<p><a href="#Chapter_110__Fold_Expressions_1">Section 110.1: Unary
Folds</a>
.........................................................................................................................................
<a href="#Chapter_110__Fold_Expressions_1">559</a></p>
<p><a href="#Chapter_110__Fold_Expressions_1">Section 110.2: Binary
Folds</a>
.......................................................................................................................................
<a href="#Chapter_110__Fold_Expressions_1">559</a></p>
<p><a href="#int_result___removeFrom_1000__5">Section 110.3: Folding
over a comma</a>
......................................................................................................................
<a href="#int_result___removeFrom_1000__5">560</a></p>
<h1
id="chapter-111-unions-...................................................................................................................................................-561"><a
href="#Chapter_111__Unions_1">Chapter 111: Unions</a>
...................................................................................................................................................
<a href="#Chapter_111__Unions_1">561</a></h1>
<p><a href="#Chapter_111__Unions_1">Section 111.1: Undefined Behavior
.............................................................................................................................
561</a></p>
<p><a href="#Chapter_111__Unions_1">Section 111.2: Basic Union
Features</a>
.........................................................................................................................
<a href="#Chapter_111__Unions_1">561</a></p>
<p><a href="#Chapter_111__Unions_1">Section 111.3: Typical Use</a>
..........................................................................................................................................
<a href="#Chapter_111__Unions_1">561</a></p>
<h1
id="chapter-112-design-pattern-implementation-in-c-..............................................................................-563"><a
href="#Chapter_112__Design_pattern">Chapter 112: Design pattern
implementation in C++</a>
..............................................................................
<a href="#Chapter_112__Design_pattern">563</a></h1>
<p><a href="#Chapter_112__Design_pattern">Section 112.1: Adapter
Pattern</a>
..................................................................................................................................
<a href="#Chapter_112__Design_pattern">563</a></p>
<p><a href="#original_class_may_be_different">Section 112.2: Observer
pattern</a>
...............................................................................................................................
<a href="#original_class_may_be_different">565</a></p>
<p><a href="#The_C__language_also_supports_a">Section 112.3: Factory
Pattern</a>
..................................................................................................................................
<a href="#The_C__language_also_supports_a">568</a></p>
<p><a href="#The_C__language_also_supports_a">Section 112.4: Builder
Pattern with Fluent API</a>
.........................................................................................................
<a href="#The_C__language_also_supports_a">568</a></p>
<h1
id="chapter-113-singleton-design-pattern-..........................................................................................................-572"><a
href="#Chapter_113__Singleton_Design_Pa_1">Chapter 113: Singleton Design
Pattern</a>
..........................................................................................................
<a href="#Chapter_113__Singleton_Design_Pa_1">572</a></h1>
<p><a href="#Chapter_113__Singleton_Design_Pa_1">Section 113.1: Lazy
Initialization</a>
................................................................................................................................
<a href="#Chapter_113__Singleton_Design_Pa_1">572</a></p>
<p><a href="#See_this_article_that_explains_w">Section 113.2: Static
deinitialization-safe singleton</a>
................................................................................................
<a href="#See_this_article_that_explains_w">573</a></p>
<p><a href="#See_this_article_that_explains_w">Section 113.3:
Thread-safe Singeton</a>
........................................................................................................................
<a href="#See_this_article_that_explains_w">573</a></p>
<p><a href="#See_this_article_that_explains_w">Section 113.4:
Subclasses</a>
..........................................................................................................................................
<a href="#See_this_article_that_explains_w">573</a></p>
<p><span id="Chapter_114__User_Defined_Litera" class="anchor"></span><a
href="#Chapter_114__User_Defined_Litera_1">Chapter 114: User-Defined
Literals
..................................................................................................................
575</a></p>
<p><a href="#Chapter_114__User_Defined_Litera_1">Section 114.1:
Self-made user-defined literal for binary</a>
........................................................................................
<a href="#Chapter_114__User_Defined_Litera_1">575</a></p>
<p><a href="#Chapter_114__User_Defined_Litera_1">Section 114.2: Standard
user-defined literals for duration</a>
....................................................................................
<a href="#Chapter_114__User_Defined_Litera_1">575</a></p>
<p><a href="#auto_t6___2___0_5h">Section 114.3: User-defined literals
with long double values</a>
.................................................................................
<a href="#auto_t6___2___0_5h">576</a></p>
<p><a href="#auto_t6___2___0_5h">Section 114.4: Standard user-defined
literals for strings</a>
.......................................................................................
<a href="#auto_t6___2___0_5h">576</a></p>
<p><a href="#std__cout____s____std__endl">Section 114.5: Standard
user-defined literals for complex</a>
....................................................................................
<a href="#std__cout____s____std__endl">577</a></p>
<h1
id="chapter-115-memory-management-................................................................................................................-578"><a
href="#Chapter_115__Memory_management_1">Chapter 115: Memory
management</a>
................................................................................................................
<a href="#Chapter_115__Memory_management_1">578</a></h1>
<p><a href="#Chapter_115__Memory_management_1">Section 115.1: Free
Storage (Heap, Dynamic Allocation ...)</a>
....................................................................................
<a href="#Chapter_115__Memory_management_1">578</a></p>
<p><a href="#Section_115_2__Placement_new">Section 115.2: Placement
new</a>
...................................................................................................................................
<a href="#Section_115_2__Placement_new">579</a></p>
<p><a href="#Section_115_3__Stack">Section 115.3: Stack</a>
....................................................................................................................................................
<a href="#Section_115_3__Stack">580</a></p>
<h1
id="chapter-116-c11-memory-model-....................................................................................................................-581"><a
href="#Chapter_116__C__11_Memory_Model_1">Chapter 116: C++11 Memory
Model</a>
....................................................................................................................
<a href="#Chapter_116__C__11_Memory_Model_1">581</a></h1>
<p><a href="#With_this_order_no_memory_operat">Section 116.1: Need for
Memory Model</a>
....................................................................................................................
<a href="#With_this_order_no_memory_operat">582</a></p>
<p><a href="#Here_init___performs_atomic_stor">Section 116.2: Fence
example</a>
...................................................................................................................................
<a href="#Here_init___performs_atomic_stor">584</a></p>
<h1
id="chapter-117-scopes-.................................................................................................................................................-585"><a
href="#Chapter_117__Scopes_1">Chapter 117: Scopes</a>
.................................................................................................................................................
<a href="#Chapter_117__Scopes_1">585</a></h1>
<p><a href="#Chapter_117__Scopes_1">Section 117.1: Global variables</a>
..................................................................................................................................
<a href="#Chapter_117__Scopes_1">585</a></p>
<p><a href="#Chapter_117__Scopes_1">Section 117.2: Simple block
scope</a>
............................................................................................................................
<a href="#Chapter_117__Scopes_1">585</a></p>
<h1
id="chapter-118-static_assert-...................................................................................................................................-587"><a
href="#Chapter_118__static_assert_1">Chapter 118: static_assert</a>
...................................................................................................................................
<a href="#Chapter_118__static_assert_1">587</a></h1>
<p><a href="#Chapter_118__static_assert_1">Section 118.1: static_assert
........................................................................................................................................
587</a></p>
<h1
id="chapter-119-constexpr-...........................................................................................................................................-588"><a
href="#Chapter_119__constexpr_1">Chapter 119: constexpr</a>
...........................................................................................................................................
<a href="#Chapter_119__constexpr_1">588</a></h1>
<p><a href="#Chapter_119__constexpr_1">Section 119.1: constexpr
variables</a>
............................................................................................................................
<a href="#Chapter_119__constexpr_1">588</a></p>
<p><a href="#A_const_variable_is_a_variable_w">Section 119.2: Static if
statement</a>
..............................................................................................................................
<a href="#A_const_variable_is_a_variable_w">589</a></p>
<p><a href="#example">Section 119.3: constexpr functions
............................................................................................................................
590</a></p>
<h1
id="chapter-120-one-definition-rule-odr-.......................................................................................................-592"><a
href="#Chapter_120__One_Definition_Rule_1">Chapter 120: One Definition
Rule (ODR)</a>
.......................................................................................................
<a href="#Chapter_120__One_Definition_Rule_1">592</a></h1>
<p><a href="#Chapter_120__One_Definition_Rule_1">Section 120.1: ODR
violation via overload resolution</a>
.............................................................................................
<a href="#Chapter_120__One_Definition_Rule_1">592</a></p>
<p><a href="#Chapter_120__One_Definition_Rule_1">Section 120.2: Multiply
defined function
..................................................................................................................
592</a></p>
<p><a href="#_include__foo_h">Section 120.3: Inline functions</a>
..................................................................................................................................
<a href="#_include__foo_h">593</a></p>
<h1
id="chapter-121-unspecified-behavior-...................................................................................................................-595"><a
href="#Chapter_121__Unspecified_behavio_1">Chapter 121: Unspecified
behavior</a>
...................................................................................................................
<a href="#Chapter_121__Unspecified_behavio_1">595</a></h1>
<p><a href="#Chapter_121__Unspecified_behavio_1">Section 121.1: Value of
an out-of-range enum</a>
........................................................................................................
<a href="#Chapter_121__Unspecified_behavio_1">595</a></p>
<p><a href="#Chapter_121__Unspecified_behavio_1">Section 121.2:
Evaluation order of function arguments</a>
.........................................................................................
<a href="#Chapter_121__Unspecified_behavio_1">595</a></p>
<p><a href="#However__each_function_argument">Section 121.3: Result of
some reinterpret_cast conversions</a>
.................................................................................
<a href="#However__each_function_argument">596</a></p>
<p><a href="#auto_fp___reinterpret_cast__f">Section 121.4: Space
occupied by a reference</a>
.......................................................................................................
<a href="#auto_fp___reinterpret_cast__f">597</a></p>
<p><a href="#auto_fp___reinterpret_cast__f">Section 121.5: Moved-from
state of most standard library classes</a>
..................................................................... <a
href="#auto_fp___reinterpret_cast__f">597</a></p>
<p><a href="#_47">Section 121.6: Result of some pointer comparisons</a>
...............................................................................................
<a href="#_47">598</a></p>
<p><a href="#_47">Section 121.7: Static cast from bogus void* value</a>
..................................................................................................
<a href="#_47">598</a></p>
<p><a href="#_47">Section 121.8: Order of initialization of globals
across TU</a>
....................................................................................
<a href="#_47">598</a></p>
<h1
id="chapter-122-argument-dependent-name-lookup-.................................................................................-600"><a
href="#Chapter_122__Argument_Dependent_1">Chapter 122: Argument
Dependent Name Lookup</a>
.................................................................................
<a href="#Chapter_122__Argument_Dependent_1">600</a></h1>
<p><a href="#Chapter_122__Argument_Dependent_1">Section 122.1: What
functions are found</a>
.................................................................................................................
<a href="#Chapter_122__Argument_Dependent_1">600</a></p>
<h1
id="chapter-123-attributes-..........................................................................................................................................-601"><a
href="#Chapter_123__Attributes_1">Chapter 123: Attributes</a>
..........................................................................................................................................
<a href="#Chapter_123__Attributes_1">601</a></h1>
<p><a href="#Chapter_123__Attributes_1">Section 123.1:
[[fallthrough]]</a>
....................................................................................................................................
<a href="#Chapter_123__Attributes_1">601</a></p>
<p><a href="#Chapter_123__Attributes_1">Section 123.2: [[nodiscard]]</a>
.....................................................................................................................................
<a href="#Chapter_123__Attributes_1">601</a></p>
<p><a href="#Note__The_implementation_details">Section 123.3:
[[deprecated]] and [[deprecated("reason")]]</a>
..............................................................................
<a href="#Note__The_implementation_details">602</a></p>
<p><a href="#Note__The_implementation_details">Section 123.4:
[[maybe_unused]]</a>
...........................................................................................................................
<a href="#Note__The_implementation_details">602</a></p>
<p><a href="#___TODO__Reuse_this_on_BSD__MAC">Section 123.5:
[[noreturn]]
........................................................................................................................................
603</a></p>
<h1
id="chapter-124-recursion-in-c-...........................................................................................................................-605"><a
href="#Chapter_124__Recursion_in_C_1">Chapter 124: Recursion in C++</a>
...........................................................................................................................
<a href="#Chapter_124__Recursion_in_C_1">605</a></h1>
<p><a href="#Chapter_124__Recursion_in_C_1">Section 124.1: Using tail
recursion and Fibonnaci-style recursion to solve the Fibonnaci sequence
................ 605</a></p>
<p><a href="#Chapter_124__Recursion_in_C_1">Section 124.2: Recursion
with memoization
............................................................................................................
605</a></p>
<h1
id="chapter-125-arithmitic-metaprogramming-................................................................................................-607"><a
href="#Chapter_125__Arithmitic_Metaprog_1">Chapter 125: Arithmitic
Metaprogramming</a>
................................................................................................
<a href="#Chapter_125__Arithmitic_Metaprog_1">607</a></h1>
<p><a href="#Chapter_125__Arithmitic_Metaprog_1">Section 125.1:
Calculating power in O(log n)
...........................................................................................................
607</a></p>
<h1
id="chapter-126-callable-objects-............................................................................................................................-609"><a
href="#Chapter_126__Callable_Objects_1">Chapter 126: Callable
Objects</a>
............................................................................................................................
<a href="#Chapter_126__Callable_Objects_1">609</a></h1>
<p><a href="#Chapter_126__Callable_Objects_1">Section 126.1: Function
Pointers</a>
...............................................................................................................................
<a href="#Chapter_126__Callable_Objects_1">609</a></p>
<p><a href="#Chapter_126__Callable_Objects_1">Section 126.2: Classes
with operator() (Functors)</a>
.................................................................................................
<a href="#Chapter_126__Callable_Objects_1">609</a></p>
<h1
id="chapter-127-client-server-examples-..............................................................................................................-611"><a
href="#Chapter_127__Client_server_examp_1">Chapter 127: Client server
examples</a>
..............................................................................................................
<a href="#Chapter_127__Client_server_examp_1">611</a></h1>
<p><a href="#Chapter_127__Client_server_examp_1">Section 127.1: Hello
TCP Client</a>
..................................................................................................................................
<a href="#Chapter_127__Client_server_examp_1">611</a></p>
<p><a href="#___connect___call_tries_to_estab">Section 127.2: Hello TCP
Server</a>
...............................................................................................................................
<a href="#___connect___call_tries_to_estab">612</a></p>
<h1
id="chapter-128-const-correctness-........................................................................................................................-616"><a
href="#Chapter_128__Const_Correctness_1">Chapter 128: Const
Correctness</a>
........................................................................................................................
<a href="#Chapter_128__Const_Correctness_1">616</a></h1>
<p><a href="#Chapter_128__Const_Correctness_1">Section 128.1: The
Basics</a>
...........................................................................................................................................
<a href="#Chapter_128__Const_Correctness_1">616</a></p>
<p><a href="#Chapter_128__Const_Correctness_1">Section 128.2: Const
Correct Class Design</a>
.............................................................................................................
<a href="#Chapter_128__Const_Correctness_1">616</a></p>
<p><a href="#___getField___and_doNothing___ca">Section 128.3: Const
Correct Function Parameters</a>
...............................................................................................
<a href="#___getField___and_doNothing___ca">618</a></p>
<p><a href="#return_vals_vals_ind">Section 128.4: Const Correctness as
Documentation</a>
............................................................................................
<a href="#return_vals_vals_ind">620</a></p>
<h1
id="chapter-129-parameter-packs-..........................................................................................................................-624"><a
href="#Chapter_129__Parameter_packs_1">Chapter 129: Parameter packs</a>
..........................................................................................................................
<a href="#Chapter_129__Parameter_packs_1">624</a></h1>
<p><a href="#Chapter_129__Parameter_packs_1">Section 129.1: A template
with a parameter pack</a>
..................................................................................................
<a href="#Chapter_129__Parameter_packs_1">624</a></p>
<p><a href="#Chapter_129__Parameter_packs_1">Section 129.2: Expansion of
a parameter pack</a>
......................................................................................................
<a href="#Chapter_129__Parameter_packs_1">624</a></p>
<h1
id="chapter-130-build-systems-.................................................................................................................................-625"><a
href="#Chapter_130__Build_Systems_1">Chapter 130: Build Systems</a>
.................................................................................................................................
<a href="#Chapter_130__Build_Systems_1">625</a></h1>
<p><a href="#Chapter_130__Build_Systems_1">Section 130.1: Generating
Build Environment with CMake</a>
....................................................................................
<a href="#Chapter_130__Build_Systems_1">625</a></p>
<p><a href="#Section_130_2__Compiling_with_GN">Section 130.2: Compiling
with GNU make</a>
...............................................................................................................
<a href="#Section_130_2__Compiling_with_GN">626</a></p>
<p><a href="#Again_watch_the_tabs__This_new_M">Section 130.3: Building
with SCons</a>
...........................................................................................................................
<a href="#Again_watch_the_tabs__This_new_M">628</a></p>
<p><a href="#Again_watch_the_tabs__This_new_M">Section 130.4: Autotools
(GNU)</a>
................................................................................................................................
<a href="#Again_watch_the_tabs__This_new_M">628</a></p>
<p><a href="#to_build__as_well_as_install__mo">Section 130.5: Ninja
....................................................................................................................................................
629</a></p>
<p><a href="#to_build__as_well_as_install__mo">Section 130.6: NMAKE
(Microsoft Program Maintenance Utility)</a>
.........................................................................
<a href="#to_build__as_well_as_install__mo">629</a></p>
<h1
id="chapter-131-concurrency-with-openmp-.......................................................................................................-630"><a
href="#Chapter_131__Concurrency_With_Op_1">Chapter 131: Concurrency With
OpenMP</a>
.......................................................................................................
<a href="#Chapter_131__Concurrency_With_Op_1">630</a></h1>
<p><a href="#Chapter_131__Concurrency_With_Op_1">Section 131.1: OpenMP:
Parallel Sections</a>
.................................................................................................................
<a href="#Chapter_131__Concurrency_With_Op_1">630</a></p>
<p><a href="#Chapter_131__Concurrency_With_Op_1">Section 131.2: OpenMP:
Parallel Sections
.................................................................................................................
630</a></p>
<p><a href="#_pragma_omp_parallel_sections">Section 131.3: OpenMP:
Parallel For Loop
................................................................................................................
631</a></p>
<p><a href="#_pragma_omp_parallel_sections">Section 131.4: OpenMP:
Parallel Gathering / Reduction</a>
........................................................................................
<a href="#_pragma_omp_parallel_sections">631</a></p>
<p><span id="Chapter_132__Resource_Management" class="anchor"></span><a
href="#Chapter_132__Resource_Management_1">Chapter 132: Resource
Management
..............................................................................................................
633</a></p>
<p><a href="#Chapter_132__Resource_Management_1">Section 132.1: Resource
Acquisition Is Initialization</a>
................................................................................................
<a href="#Chapter_132__Resource_Management_1">633</a></p>
<p><a href="#cout_____sp1____endl_____prints">Section 132.2: Mutexes
&amp; Thread Safety</a>
.................................................................................................................
<a href="#cout_____sp1____endl_____prints">634</a></p>
<h1
id="chapter-133-storage-class-specifiers-............................................................................................................-636"><a
href="#Chapter_133__Storage_class_speci_1">Chapter 133: Storage class
specifiers</a>
............................................................................................................
<a href="#Chapter_133__Storage_class_speci_1">636</a></h1>
<p><a href="#Chapter_133__Storage_class_speci_1">Section 133.1: extern
...................................................................................................................................................
636</a></p>
<p><a href="#In_the_above_code__if_f_were_cha">Section 133.2:
register</a>
...............................................................................................................................................
<a href="#In_the_above_code__if_f_were_cha">637</a></p>
<p><a href="#In_the_above_code__if_f_were_cha">Section 133.3: static</a>
...................................................................................................................................................
<a href="#In_the_above_code__if_f_were_cha">637</a></p>
<p><a href="#return_new_S">Section 133.4: auto</a>
.....................................................................................................................................................
<a href="#return_new_S">638</a></p>
<p><a href="#return_new_S">Section 133.5: mutable</a>
..............................................................................................................................................
<a href="#return_new_S">638</a></p>
<h1
id="chapter-134-linkage-specifications-...............................................................................................................-640"><a
href="#Chapter_134__Linkage_specificati_1">Chapter 134: Linkage
specifications</a>
...............................................................................................................
<a href="#Chapter_134__Linkage_specificati_1">640</a></h1>
<p><a href="#Chapter_134__Linkage_specificati_1">Section 134.1: Signal
handler for Unix-like operating system</a>
...............................................................................
<a href="#Chapter_134__Linkage_specificati_1">640</a></p>
<p><a href="#Chapter_134__Linkage_specificati_1">Section 134.2: Making a
C library header compatible with C++</a>
...........................................................................
<a href="#Chapter_134__Linkage_specificati_1">640</a></p>
<h1
id="chapter-135-digit-separators-............................................................................................................................-642"><a
href="#Chapter_135__Digit_separators_1">Chapter 135: Digit
separators</a>
............................................................................................................................
<a href="#Chapter_135__Digit_separators_1">642</a></h1>
<p><a href="#Chapter_135__Digit_separators_1">Section 135.1: Digit
Separator</a>
...................................................................................................................................
<a href="#Chapter_135__Digit_separators_1">642</a></p>
<h1
id="chapter-136-c-incompatibilities-........................................................................................................................-643"><a
href="#Chapter_136__C_incompatibilities_1">Chapter 136: C
incompatibilities</a>
........................................................................................................................
<a href="#Chapter_136__C_incompatibilities_1">643</a></h1>
<p><a href="#Chapter_136__C_incompatibilities_1">Section 136.1: Reserved
Keywords</a>
...........................................................................................................................
<a href="#Chapter_136__C_incompatibilities_1">643</a></p>
<p><a href="#Chapter_136__C_incompatibilities_1">Section 136.2: Weakly
typed pointers</a>
.....................................................................................................................
<a href="#Chapter_136__C_incompatibilities_1">643</a></p>
<p><a href="#Chapter_136__C_incompatibilities_1">Section 136.3: goto or
switch</a>
....................................................................................................................................
<a href="#Chapter_136__C_incompatibilities_1">643</a></p>
<p><span id="Chapter_137__Side_by_Side_Compar" class="anchor"></span><a
href="#Chapter_137__Side_by_Side_Compar_1">Chapter 137: Side by Side
Comparisons of classic C++ examples solved via C++ vs C++11</a></p>
<p><a href="#Chapter_137__Side_by_Side_Compar_1"><strong>vs C++14 vs
C++17</strong></a>
.....................................................................................................................................................
<a href="#Chapter_137__Side_by_Side_Compar_1">644</a></p>
<p><a href="#Chapter_137__Side_by_Side_Compar_1">Section 137.1: Looping
through a container</a>
............................................................................................................
<a href="#Chapter_137__Side_by_Side_Compar_1">644</a></p>
<h1
id="chapter-138-compiling-and-building-..............................................................................................................-645"><a
href="#Chapter_138__Compiling_and_Build_1">Chapter 138: Compiling and
Building</a>
..............................................................................................................
<a href="#Chapter_138__Compiling_and_Build_1">645</a></h1>
<p><a href="#Chapter_138__Compiling_and_Build_1">Section 138.1:
Compiling with GCC</a>
...........................................................................................................................
<a href="#Chapter_138__Compiling_and_Build_1">645</a></p>
<p><a href="#values_correspond_to_the_year_of">Section 138.2: Compiling
with Visual Studio (Graphical Interface) - Hello World</a>
............................................... <a
href="#values_correspond_to_the_year_of">646</a></p>
<p><a href="#page_669">Section 138.3: Online Compilers</a>
...............................................................................................................................
<a href="#page_669">651</a></p>
<p><a href="#RiSE4fun">Section 138.4: Compiling with Visual C++ (Command
Line)</a>
..................................................................................
<a href="#RiSE4fun">653</a></p>
<p><a href="#___Replace___LINKER_OPTION__with">Section 138.5: Compiling
with Clang</a>
........................................................................................................................
<a href="#___Replace___LINKER_OPTION__with">656</a></p>
<p><a href="#___Replace___LINKER_OPTION__with">Section 138.6: The C++
compilation process
...........................................................................................................
656</a></p>
<p><a href="#The_produced_object_files_can_be">Section 138.7: Compiling
with Code::Blocks (Graphical interface)
........................................................................
658</a></p>
<h1
id="chapter-139-common-compilelinker-errors-gcc-...............................................................................-661"><a
href="#Chapter_139__Common_compile_link_1">Chapter 139: Common
compile/linker errors (GCC)</a>
...............................................................................
<a href="#Chapter_139__Common_compile_link_1">661</a></h1>
<p><a href="#Chapter_139__Common_compile_link_1">Section 139.1:
undefined reference to `***'</a>
................................................................................................................
<a href="#Chapter_139__Common_compile_link_1">661</a></p>
<p><a href="#Chapter_139__Common_compile_link_1">Section 139.2: error:
'***' was not declared in this scope</a>
........................................................................................
<a href="#Chapter_139__Common_compile_link_1">661</a></p>
<p><a href="#_50">Section 139.3: fatal error: ***: No such file or
directory
...........................................................................................
663</a></p>
<p><span id="Chapter_140__More_undefined_beha" class="anchor"></span><a
href="#Chapter_140__More_undefined_beha_1">Chapter 140: More undefined
behaviors in C++
........................................................................................
664</a></p>
<p><a href="#Chapter_140__More_undefined_beha_1">Section 140.1:
Referring to non-static members in initializer lists</a>
.........................................................................
<a href="#Chapter_140__More_undefined_beha_1">664</a></p>
<h1
id="chapter-141-unit-testing-in-c-.......................................................................................................................-665"><a
href="#Chapter_141__Unit_Testing_in_C_1">Chapter 141: Unit Testing in
C++</a>
.......................................................................................................................
<a href="#Chapter_141__Unit_Testing_in_C_1">665</a></h1>
<p><a href="#Chapter_141__Unit_Testing_in_C_1">Section 141.1: Google
Test</a>
.........................................................................................................................................
<a href="#Chapter_141__Unit_Testing_in_C_1">665</a></p>
<p><a href="#Chapter_141__Unit_Testing_in_C_1">Section 141.2: Catch</a>
...................................................................................................................................................
<a href="#Chapter_141__Unit_Testing_in_C_1">665</a></p>
<p><span id="Chapter_142__C___Debugging_and_D" class="anchor"></span><a
href="#Chapter_142__C___Debugging_and_D_1">Chapter 142: C++ Debugging
and Debug-prevention Tools &amp; Techniques
................................. 667</a></p>
<p><a href="#Chapter_142__C___Debugging_and_D_1">Section 142.1: Static
analysis</a>
....................................................................................................................................
<a href="#Chapter_142__C___Debugging_and_D_1">667</a></p>
<p><a href="#Use_make_unique">Section 142.2: Segfault analysis with
GDB</a>
..............................................................................................................
<a href="#Use_make_unique">668</a></p>
<p><a href="#11_______std__cout_____p2____std">Section 142.3: Clean
code</a>
.........................................................................................................................................
<a href="#11_______std__cout_____p2____std">669</a></p>
<h1
id="chapter-143-optimization-in-c-.....................................................................................................................-671"><a
href="#Chapter_143__Optimization_in_C_1">Chapter 143: Optimization in
C++</a>
.....................................................................................................................
<a href="#Chapter_143__Optimization_in_C_1">671</a></h1>
<p><a href="#Chapter_143__Optimization_in_C_1">Section 143.1:
Introduction to performance</a>
............................................................................................................
<a href="#Chapter_143__Optimization_in_C_1">671</a></p>
<p><a href="#Chapter_143__Optimization_in_C_1">Section 143.2: Empty Base
Class Optimization</a>
......................................................................................................
<a href="#Chapter_143__Optimization_in_C_1">671</a></p>
<p><a href="#Section_143_3__Optimizing_by_exe">Section 143.3: Optimizing
by executing less code</a>
..................................................................................................
<a href="#Section_143_3__Optimizing_by_exe">672</a></p>
<p><a href="#Preventing_useless_reallocating">Section 143.4: Using
ecient containers</a>
.................................................................................................................
<a href="#Preventing_useless_reallocating">673</a></p>
<p><a href="#_52">Section 143.5: Small Object Optimization
................................................................................................................
674</a></p>
<h1
id="chapter-144-optimization-..................................................................................................................................-676"><a
href="#Chapter_144__Optimization_1">Chapter 144: Optimization</a>
..................................................................................................................................
<a href="#Chapter_144__Optimization_1">676</a></h1>
<p><a href="#Chapter_144__Optimization_1">Section 144.1: Inline
Expansion/Inlining</a>
...................................................................................................................
<a href="#Chapter_144__Optimization_1">676</a></p>
<p><a href="#Chapter_144__Optimization_1">Section 144.2: Empty base
optimization</a>
.................................................................................................................
<a href="#Chapter_144__Optimization_1">676</a></p>
<p><span id="Chapter_145__Profiling" class="anchor"></span><a
href="#Chapter_145__Profiling_1">Chapter 145: Profiling
.............................................................................................................................................
678</a></p>
<p><a href="#Chapter_145__Profiling_1">Section 145.1: Profiling with gcc
and gprof</a>
.............................................................................................................
<a href="#Chapter_145__Profiling_1">678</a></p>
<p><a href="#Chapter_145__Profiling_1">Section 145.2: Generating
callgraph diagrams with gperf2dot</a>
............................................................................
<a href="#Chapter_145__Profiling_1">678</a></p>
<p><a href="#__run_to_generate_profiling_data">Section 145.3: Profiling
CPU Usage with gcc and Google Perf Tools</a>
................................................................... <a
href="#__run_to_generate_profiling_data">679</a></p>
<h1
id="chapter-146-refactoring-techniques-...........................................................................................................-681"><a
href="#Chapter_146__Refactoring_Techniq_1">Chapter 146: Refactoring
Techniques</a>
...........................................................................................................
<a href="#Chapter_146__Refactoring_Techniq_1">681</a></h1>
<p><a href="#Chapter_146__Refactoring_Techniq_1">Section 146.1: Goto
Cleanup</a>
......................................................................................................................................
<a href="#Chapter_146__Refactoring_Techniq_1">681</a></p>
<p><a href="#Credits"><strong>Credits</strong></a>
............................................................................................................................................................................
<a href="#Credits">682</a></p>
<p><a href="#You_may_also_like"><strong>You may also like</strong>
......................................................................................................................................................
690</a></p>
<p><span id="About" class="anchor"></span>About</p>
<p>Please feel free to share this PDF with anyone for free,</p>
<p>latest version of this book can be downloaded from:</p>
<p><a
href="https://goalkicker.com/CPlusPlusBook">https://goalkicker.com/CPlusPlusBook</a></p>
<p>This <em>C++ Notes for Professionals</em> <a
href="https://archive.org/details/documentation-dump.7z">book is
compiled from Stack Overflow</a></p>
<p><a
href="https://archive.org/details/documentation-dump.7z">Documentation</a>,
the content is written by the beautiful people at Stack Overflow.</p>
<p>Text content is released under Creative Commons BY-SA, see credits at
the end</p>
<p>of this book whom contributed to the various chapters. Images may be
copyright</p>
<p>of their respective owners unless otherwise specified</p>
<p>This is an unofficial free book created for educational purposes and
is not</p>
<p>affiliated with official C++ group(s) or company(s) nor Stack
Overflow. All</p>
<p>trademarks and registered trademarks are the property of their
respective</p>
<p>company owners</p>
<p>The information presented in this book is not guaranteed to be
correct nor</p>
<p>accurate, use at your own risk</p>
<p>Please send feedback and corrections to web@petercv.com</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 1</p>
<p><span id="Chapter_1__Getting_started_with"
class="anchor"></span>Chapter 1: Getting started with C++</p>
<p>Version Standard Release Date</p>
<p>C++98 ISO/IEC 14882:1998 1998-09-01</p>
<p>C++03 ISO/IEC 14882:2003 2003-10-16</p>
<p>C++11 ISO/IEC 14882:2011 2011-09-01</p>
<p>C++14 ISO/IEC 14882:2014 2014-12-15</p>
<p>C++17 TBD 2017-01-01</p>
<p>C++20 TBD 2020-01-01</p>
<p>Section 1.1: Hello World</p>
<p>This program prints Hello World! to the standard output stream:</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;</p>
<p>}</p>
<p><a href="http://coliru.stacked-crooked.com/a/ba766ad8ca2fae56">See it
live on Coliru.</a></p>
<p>Analysis</p>
<p>Let's examine each part of this code in detail:</p>
<p>#include is a <strong>preprocessor directive</strong> that includes
the content of the standard C++ header file</p>
<p>iostream .</p>
<p>iostream is a <strong>standard library header file</strong> that
contains definitions of the standard input and output</p>
<p>streams. These definitions are included in the std namespace,
explained below.</p>
<p>The <strong>standard input/output (I/O) streams</strong> provide ways
for programs to get input from and output to an</p>
<p>external system -- usually the terminal.</p>
<p>int main() { ... } defines a new function named main. By convention,
the main function is called upon</p>
<p>execution of the program. There must be only one main function in a
C++ program, and it must always return a number of the int type.</p>
<p>Here, the int is what is called the function's return type. The value
returned by the main function is an <strong>exit</strong></p>
<p>code.</p>
<p>By convention, a program exit code of 0 or EXIT_SUCCESS is
interpreted as success by a system that executes</p>
<p>the program. Any other return code is associated with an error.</p>
<p>If no return statement is present, the main function (and thus, the
program itself) returns 0 by default. In this</p>
<p>example, we don't need to explicitly write return 0;.</p>
<p>All other functions, except those that return the void type, must
explicitly return a value according to their</p>
<p>return type, or else must not return at all.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 2</p>
<p><span id="std__cout_____Hello_World______s"
class="anchor"></span>std::cout &lt;&lt; "Hello World!" &lt;&lt;
std::endl; prints "Hello World!" to the standard output stream:</p>
<p>std is a namespace, and :: is the <strong>scope resolution
operator</strong> that allows look-ups for objects by name within a
namespace.</p>
<p>There are many namespaces. Here, we use :: to show we want to use
cout from the std namespace.</p>
<p>For more information refer to <a
href="https://msdn.microsoft.com/en-us/library/b451xz31.aspx/">Scope
Resolution Operator - Microsoft Documentation.</a></p>
<p>std::cout is the <strong>standard output stream</strong> object,
defined in iostream, and it prints to the standard</p>
<p>output (stdout).</p>
<p>&lt;&lt; is, <em>in this context</em>, the <strong>stream insertion
operator</strong>, so called because it <em>inserts</em> an object into
the</p>
<p><em>stream</em> object.</p>
<p>The standard library defines the &lt;&lt; operator to perform data
insertion for certain data types into</p>
<p>output streams. stream &lt;&lt; content inserts content into the
stream and returns the same, but updated stream. This allows stream
insertions to be chained: std::cout &lt;&lt; "Foo" &lt;&lt; " Bar";
prints</p>
<p>"FooBar" to the console.</p>
<p>"Hello World!" is a <strong>character string literal</strong>, or a
"text literal." The stream insertion operator for</p>
<p>character string literals is defined in file iostream.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/endl">std::endl</a> is a
special <strong>I/O stream manipulator</strong> object, also defined in
file iostream. Inserting a</p>
<p>manipulator into a stream changes the state of the stream.</p>
<p>The stream manipulator std::endl does two things: first it inserts
the end-of-line character and then it</p>
<p>flushes the stream buffer to force the text to show up on the
console. This ensures that the data inserted into the stream actually
appear on your console. (Stream data is usually stored in a buffer
and</p>
<p>then "flushed" in batches unless you force a flush immediately.)</p>
<p>An alternate method that avoids the flush is:</p>
<p>std::cout &lt;&lt; "Hello World!<strong>\n</strong>";</p>
<p>where \n is the <strong>character escape sequence</strong> for the
newline character.</p>
<p>The semicolon (;) notifies the compiler that a statement has ended.
All C++ statements and class</p>
<p>definitions require an ending/terminating semicolon.</p>
<p>Section 1.2: Comments</p>
<p>A <strong>comment</strong> is a way to put arbitrary text inside
source code without having the C++ compiler interpret it with any</p>
<p>functional meaning. Comments are used to give insight into the design
or method of a program.</p>
<p>There are two types of comments in C++:</p>
<p>Single-Line Comments</p>
<p>The double forward-slash sequence // will mark all text until a
newline as a comment:</p>
<p>int main()</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 3</p>
<p>// This is a single-line comment.</p>
<p>int a; // this also is a single-line comment</p>
<p>int i; // this is another single-line comment</p>
<p>}</p>
<p>C-Style/Block Comments</p>
<p>The sequence /* is used to declare the start of the comment block and
the sequence */ is used to declare the end</p>
<p>of comment. All text between the start and end sequences is
interpreted as a comment, even if the text is</p>
<p>otherwise valid C++ syntax. These are sometimes called "C-style"
comments, as this comment syntax is inherited from C++'s predecessor
language, C:</p>
<p>int main()</p>
<p>{</p>
<p>/*</p>
<p>* This is a block comment.</p>
<p>*/</p>
<p>int a;</p>
<p>}</p>
<p>In any block comment, you can write anything you want. When the
compiler encounters the symbol */, it terminates the block comment:</p>
<p>int main()</p>
<p>{</p>
<p>/* A block comment with the symbol /*</p>
<p>Note that the compiler is not affected by the second /*</p>
<p>however, once the end-block-comment symbol is reached,</p>
<p>the comment ends.</p>
<p>*/</p>
<p>int a;</p>
<p>}</p>
<p>The above example is valid C++ (and C) code. However, having
additional /* inside a block comment might result in</p>
<p>a warning on some compilers.</p>
<p>Block comments can also start and end <em>within</em> a single line.
For example:</p>
<p>void SomeFunction(<em>/* argument 1 */</em> int a, <em>/* argument 2
*/</em> int b);</p>
<p>Importance of Comments</p>
<p>As with all programming languages, comments provide several
benefits:</p>
<p>Explicit documentation of code to make it easier to read/maintain</p>
<p>Explanation of the purpose and functionality of code</p>
<p>Details on the history or reasoning behind the code</p>
<p>Placement of copyright/licenses, project notes, special thanks,
contributor credits, etc. directly in the source</p>
<p>code.</p>
<p>However, comments also have their downsides:</p>
<p>They must be maintained to reflect any changes in the code</p>
<p>Excessive comments tend to make the code <em>less</em> readable</p>
<p>The need for comments can be reduced by writing clear,
self-documenting code. A simple example is the use of</p>
<p>explanatory names for variables, functions, and types. Factoring out
logically related tasks into discrete functions goes hand-in-hand with
this.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 4</p>
<p><span id="Comment_markers_used_to_disable"
class="anchor"></span>Comment markers used to disable code</p>
<p>During development, comments can also be used to quickly disable
portions of code without deleting it. This is</p>
<p>often useful for testing or debugging purposes, but is not good style
for anything other than temporary edits. This is often referred to as
“commenting out”.</p>
<p>Similarly, keeping old versions of a piece of code in a comment for
reference purposes is frowned upon, as it clutters files while offering
little value compared to exploring the code's history via a versioning
system.</p>
<p>Section 1.3: The standard C++ compilation process</p>
<p>Executable C++ program code is usually produced by a compiler.</p>
<p>A <strong>compiler</strong> is a program that translates code from a
programming language into another form which is (more)</p>
<p>directly executable for a computer. Using a compiler to translate
code is called <strong>compilation.</strong></p>
<p>C++ inherits the form of its compilation process from its "parent"
language, C. Below is a list showing the four major</p>
<p>steps of compilation in C++:</p>
<p>1. The C++ preprocessor copies the contents of any included header
files into the source code file, generates</p>
<p>macro code, and replaces symbolic constants defined using #define
with their values.</p>
<p>2. The expanded source code file produced by the C++ preprocessor is
compiled into assembly language</p>
<p>appropriate for the platform.</p>
<p>3. The assembler code generated by the compiler is assembled into
appropriate object code for the platform. 4. The object code file
generated by the assembler is linked together with the object code files
for any library</p>
<p>functions used to produce an executable file.</p>
<p>Note: some compiled code is linked together, but not to create a
final program. Usually, this "linked" code can also be packaged into a
format that can be used by other programs. This "bundle of packaged,
usable</p>
<p>code" is what C++ programmers refer to as a
<strong>library.</strong></p>
<p>Many C++ compilers may also merge or un-merge certain parts of the
compilation process for ease or for additional analysis. Many C++
programmers will use different tools, but all of the tools will
generally follow this generalized</p>
<p>process when they are involved in the production of a program.</p>
<p>The link below extends this discussion and provides a nice graphic to
help. [1]:</p>
<p><a
href="http://faculty.cs.niu.edu/%7Emcmahon/CS241/Notes/compile.html">http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/compile.html</a></p>
<p>Section 1.4: Function</p>
<p>A <strong>function</strong> is a unit of code that represents a
sequence of statements.</p>
<p>Functions can accept <strong>arguments</strong> or values and
<strong>return</strong> a single value (or not). To use a function, a
<strong>function call</strong> is</p>
<p>used on argument values and the use of the function call itself is
replaced with its return value.</p>
<p>Every function has a <strong>type signature</strong> -- the types of
its arguments and the type of its return type.</p>
<p>Functions are inspired by the concepts of the procedure and the
mathematical function.</p>
<p>Note: C++ functions are essentially procedures and do not follow the
exact definition or rules of</p>
<p>mathematical functions.</p>
<p>Functions are often meant to perform a specific task. and can be
called from other parts of a program. A function</p>
<p>must be declared and defined before it is called elsewhere in a
program.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 5</p>
<p>Note: popular function definitions may be hidden in other included
files (often for convenience and reuse across many files). This is a
common use of header files.</p>
<p>Function Declaration</p>
<p>A <strong>function declaration</strong> is declares the existence of
a function with its name and type signature to the compiler.</p>
<p>The syntax is as the following:</p>
<p>int add2(int i); // The function is of the type (int) -&gt; (int)</p>
<p>In the example above, the int add2(int i) function declares the
following to the compiler:</p>
<p>The <strong>return type</strong> is int.</p>
<p>The <strong>name</strong> of the function is add2.</p>
<p>The <strong>number of arguments</strong> to the function is 1:</p>
<p>The first argument is of the type int.</p>
<p>The first argument will be referred to in the function's contents by
the name i.</p>
<p>The argument name is optional; the declaration for the function could
also be the following:</p>
<p>int add2(int); // Omitting the function arguments' name is also
permitted.</p>
<p>Per the <strong>one-definition rule</strong>, a function with a
certain type signature can only be declared or defined once in an</p>
<p>entire C++ code base visible to the C++ compiler. In other words,
functions with a specific type signature cannot be</p>
<p>re-defined -- they must only be defined once. Thus, the following is
not valid C++:</p>
<p>int add2(int i); // The compiler will note that add2 is a function
(int) -&gt; int int add2(int j); // As add2 already has a definition of
(int) -&gt; int, the compiler</p>
<p>// will regard this as an error.</p>
<p>If a function returns nothing, its return type is written as void. If
it takes no parameters, the parameter list should</p>
<p>be empty.</p>
<p>void do_something(); // The function takes no parameters, and does
not return anything.</p>
<p>// Note that it can still affect variables it has access to.</p>
<p>Function Call</p>
<p>A function can be called after it has been declared. For example, the
following program calls add2 with the value of 2 within the function of
main:</p>
<p>#include</p>
<p>int add2(int i); // Declaration of add2</p>
<p>// Note: add2 is still missing a DEFINITION.</p>
<p>// Even though it doesn't appear directly in code, // add2's
definition may be LINKED in from another object file.</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; add2(2) &lt;&lt; "<strong>\n</strong>"; // add2(2)
will be evaluated at this point,</p>
<p>// and the result is printed.</p>
<p>return 0;</p>
<p>}</p>
<p>Here, add2(2) is the syntax for a function call.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 6</p>
<p>Function Definition</p>
<p>A <em>function definition</em>* is similar to a declaration, except
it also contains the code that is executed when the function</p>
<p>is called within its body.</p>
<p>An example of a function definition for add2 might be:</p>
<p>int add2(int i) // Data that is passed into (int i) will be referred
to by the name i { // while in the function's curly brackets or
"scope."</p>
<p>int j = i + 2; // Definition of a variable j as the value of i+2.
return j; // Returning or, in essence, substitution of j for a function
call to</p>
<p>// add2.</p>
<p>}</p>
<p>Function Overloading</p>
<p>You can create multiple functions with the same name but different
parameters.</p>
<p>int add2(int i) // Code contained in this definition will be
evaluated { // when add2() is called with one parameter.</p>
<p>int j = i + 2;</p>
<p>return j;</p>
<p>}</p>
<p>int add2(int i, int j) // However, when add2() is called with two
parameters, the { // code from the initial declaration will be
overloaded,</p>
<p>int k = i + j + 2 ; // and the code in this declaration will be
evaluated return k; // instead.</p>
<p>}</p>
<p>Both functions are called by the same name add2, but the actual
function that is called depends directly on the</p>
<p>amount and type of the parameters in the call. In most cases, the C++
compiler can compute which function to call.</p>
<p>In some cases, the type must be explicitly stated.</p>
<p>Default Parameters</p>
<p>Default values for function parameters can only be specified in
function declarations.</p>
<p>int multiply(int a, int b = 7); // b has default value of 7. int
multiply(int a, int b)</p>
<p>{</p>
<p>return a * b; // If multiply() is called with one parameter, the</p>
<p>} // value will be multiplied by the default, 7.</p>
<p>In this example, multiply() can be called with one or two parameters.
If only one parameter is given, b will have default value of 7. Default
arguments must be placed in the latter arguments of the function. For
example:</p>
<p>int multiply(int a = 10, int b = 20); // This is legal int
multiply(int a = 10, int b); // This is illegal since int a is in the
former</p>
<p>Special Function Calls - Operators</p>
<p>There exist special function calls in C++ which have different syntax
than name_of_function(value1, value2, value3). The most common example
is that of operators.</p>
<p>Certain special character sequences that will be reduced to function
calls by the compiler, such as !, +, -, *, %, and &lt;&lt; and many
more. These special characters are normally associated with
non-programming usage or are used for</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 7</p>
<p><span id="aesthetics__e_g__the___character"
class="anchor"></span>aesthetics (e.g. the + character is commonly
recognized as the addition symbol both within C++ programming as well as
in elementary math).</p>
<p>C++ handles these character sequences with a special syntax; but, in
essence, each occurrence of an operator is reduced to a function call.
For example, the following C++ expression:</p>
<p>3+3</p>
<p>is equivalent to the following function call:</p>
<p>operator+(3, 3)</p>
<p>All operator function names start with operator.</p>
<p>While in C++'s immediate predecessor, C, operator function names
cannot be assigned different meanings by</p>
<p>providing additional definitions with different type signatures, in
C++, this is valid. "Hiding" additional function</p>
<p>definitions under one unique function name is referred to as
<strong>operator overloading</strong> in C++, and is a relatively</p>
<p>common, but not universal, convention in C++.</p>
<p>Section 1.5: Visibility of function prototypes and declarations</p>
<p>In C++, code must be declared or defined before usage. For example,
the following produces a compile time error:</p>
<p>int main()</p>
<p>{</p>
<p>foo(2); // error: foo is called, but has not yet been declared }</p>
<p>void foo(int x) // this later definition is not known in main {</p>
<p>}</p>
<p>There are two ways to resolve this: putting either the definition or
declaration of foo() before its usage in main().</p>
<p>Here is one example:</p>
<p>void foo(int x) {} //Declare the foo function and body first</p>
<p>int main()</p>
<p>{</p>
<p>foo(2); // OK: foo is completely defined beforehand, so it can be
called here. }</p>
<p>However it is also possible to "forward-declare" the function by
putting only a "prototype" declaration before its</p>
<p>usage and then defining the function body later:</p>
<p>void foo(int); // Prototype declaration of foo, seen by main</p>
<p>// Must specify return type, name, and argument list types</p>
<p>int main()</p>
<p>{</p>
<p>foo(2); // OK: foo is known, called even though its body is not yet
defined }</p>
<p>void foo(int x) //Must match the prototype</p>
<p>{</p>
<p>// Define body of foo here</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 8</p>
<p><span id="The_prototype_must_specify_the_r" class="anchor"></span>The
prototype must specify the return type (void), the name of the function
(foo), and the argument list variable</p>
<p>types (int<a
href="https://stackoverflow.com/questions/5234169/why-do-function-prototypes-include-parameter-names-when-theyre-not-required">),
but the names of the arguments are NOT required</a>.</p>
<p>One common way to integrate this into the organization of source
files is to make a header file containing all of the prototype
declarations:</p>
<p>// foo.h</p>
<p>void foo(int); // prototype declaration</p>
<p>and then provide the full definition elsewhere:</p>
<p>// foo.cpp --&gt; foo.o</p>
<p>#include "foo.h" // foo's prototype declaration is "hidden" in here
void foo(int x) { } // foo's body definition</p>
<p>and then, once compiled, link the corresponding object file foo.o
into the compiled object file where it is used in the linking phase,
main.o:</p>
<p>// main.cpp --&gt; main.o</p>
<p>#include "foo.h" // foo's prototype declaration is "hidden" in here
int main() { foo(2); } // foo is valid to call because its prototype
declaration was beforehand. // the prototype and body definitions of foo
are linked through the object files</p>
<p>An “unresolved external symbol” error occurs when the function
<em>prototype</em> and <em>call</em> exist, but the function
<em>body</em> is not defined. These can be trickier to resolve as the
compiler won't report the error until the final linking stage, and</p>
<p>it doesn't know which line to jump to in the code to show the
error.</p>
<p>Section 1.6: Preprocessor</p>
<p>The preprocessor is an important part of the compiler.</p>
<p>It edits the source code, cutting some bits out, changing others, and
adding other things.</p>
<p>In source files, we can include preprocessor directives. These
directives tells the preprocessor to perform specific actions. A
directive starts with a # on a new line. Example:</p>
<p>#define ZERO 0</p>
<p>The first preprocessor directive you will meet is probably the</p>
<p>#include</p>
<p>directive. What it does is takes all of something and inserts it in
your file where the directive was. The hello world</p>
<p>program starts with the line</p>
<p>#include</p>
<p>This line adds the functions and objects that let you use the
standard input and output.</p>
<p>The C language, which also uses the preprocessor, does not have as
many header files as the C++ language, but in</p>
<p>C++ you can use all the C header files.</p>
<p>The next important directive is probably the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 9</p>
<p>#define something something_else</p>
<p>directive. This tells the preprocessor that as it goes along the
file, it should replace every occurrence of something</p>
<p>with something_else. It can also make things similar to functions,
but that probably counts as advanced C++.</p>
<p>The something_else is not needed, but if you define something as
nothing, then outside preprocessor directives, all</p>
<p>occurrences of something will vanish.</p>
<p>This actually is useful, because of the #if,#else and #ifdef
directives. The format for these would be the following:</p>
<p>#if something==true</p>
<p>//code</p>
<p>#else</p>
<p>//more code</p>
<p>#endif</p>
<p>#ifdef thing_that_you_want_to_know_if_is_defined</p>
<p>//code</p>
<p>#endif</p>
<p>These directives insert the code that is in the true bit, and deletes
the false bits. this can be used to have bits of code that are only
included on certain operating systems, without having to rewrite the
whole code.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 10</p>
<p><span id="Chapter_2__Literals" class="anchor"></span>Chapter 2:
Literals</p>
<p>Traditionally, a literal is an expression denoting a constant whose
type and value are evident from its spelling. For</p>
<p>example, 42 is a literal, while x is not since one must see its
declaration to know its type and read previous lines of code to know its
value.</p>
<p>However, C++11 also added user-defined literals, which are not
literals in the traditional sense but can be used as a shorthand for
function calls.</p>
<p>Section 2.1: this</p>
<p>Within a member function of a class, the keyword this is a pointer to
the instance of the class on which the function was called. this cannot
be used in a static member function.</p>
<p>struct S {</p>
<p>int x;</p>
<p>S&amp; operator=(const S&amp; other) {</p>
<p>x = other.x;</p>
<p>// return a reference to the object being assigned to return
*this;</p>
<p>}</p>
<p>};</p>
<p>The type of this depends on the cv-qualification of the member
function: if X::f is const, then the type of this</p>
<p>within f is const X*, so this cannot be used to modify non-static
data members from within a const member function. Likewise, this
inherits volatile qualification from the function it appears in.</p>
<p>Version ≥ C++11</p>
<p>this can also be used in a <em>brace-or-equal-initializer</em> for a
non-static data member.</p>
<p>struct S;</p>
<p>struct T {</p>
<p>T(const S* s);</p>
<p>// ...</p>
<p>};</p>
<p>struct S {</p>
<p>// ...</p>
<p>T t{this};</p>
<p>};</p>
<p>this is an rvalue, so it cannot be assigned to.</p>
<p>Section 2.2: Integer literal</p>
<p>An integer literal is a primary expression of the form</p>
<p>decimal-literal</p>
<p>It is a non-zero decimal digit (1, 2, 3, 4, 5, 6, 7, 8, 9), followed
by zero or more decimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</p>
<p>int d = 42;</p>
<p>octal-literal</p>
<p>It is the digit zero (0) followed by zero or more octal digits (0, 1,
2, 3, 4, 5, 6, 7)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 11</p>
<p><span id="int_o___052" class="anchor"></span>int o = 052</p>
<p>hex-literal</p>
<p>It is the character sequence 0x or the character sequence 0X followed
by one or more hexadecimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A,
b, B, c, C, d, D, e, E, f, F)</p>
<p>int x = 0x2a; int X = 0X2A;</p>
<p>binary-literal (since C++14)</p>
<p>It is the character sequence 0b or the character sequence 0B followed
by one or more binary digits (0, 1)</p>
<p>int b = 0b101010; // C++14</p>
<p>Integer-suffix, if provided, may contain one or both of the following
(if both are provided, they may appear in any order:</p>
<p>unsigned-suffix (the character u or the character U)</p>
<p>unsigned int u_1 = 42u;</p>
<p>long-suffix (the character l or the character L) or the
long-long-suffix (the character sequence ll or the</p>
<p>character sequence LL) (since C++11)</p>
<p>The following variables are also initialized to the same value:</p>
<p>unsigned long long l1 = 18446744073709550592ull; // C++11 unsigned
long long l2 = 18'446'744'073'709'550'592llu; // C++14 unsigned long
long l3 = 1844'6744'0737'0955'0592uLL; // C++14 unsigned long long l4 =
184467'440737'0'95505'92LLU; // C++14</p>
<p>Notes</p>
<p>Letters in the integer literals are case-insensitive: 0xDeAdBaBeU and
0XdeadBABEu represent the same number (one exception is the
long-long-suffix, which is either ll or LL, never lL or Ll)</p>
<p>There are no negative integer literals. Expressions such as -1 apply
the unary minus operator to the value</p>
<p>represented by the literal, which may involve implicit type
conversions.</p>
<p>In C prior to C99 (but not in C++), unsuffixed decimal values that do
not fit in long int are allowed to have the type</p>
<p>unsigned long int.</p>
<p>When used in a controlling expression of #if or #elif, all signed
integer constants act as if they have type</p>
<p>std::intmax_t and all unsigned integer constants act as if they have
type std::uintmax_t.</p>
<p>Section 2.3: true</p>
<p>A keyword denoting one of the two possible values of type bool.</p>
<p>bool ok = true;</p>
<p>if (!f()) {</p>
<p>ok = false;</p>
<p>goto end;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 12</p>
<p><span id="Section_2_4__false" class="anchor"></span>Section 2.4:
false</p>
<p>A keyword denoting one of the two possible values of type bool.</p>
<p>bool ok = true;</p>
<p>if (!f()) {</p>
<p>ok = false;</p>
<p>goto end;</p>
<p>}</p>
<p>Section 2.5: nullptr</p>
<p>Version ≥ C++11</p>
<p>A keyword denoting a null pointer constant. It can be converted to
any pointer or pointer-to-member type, yielding a null pointer of the
resulting type.</p>
<p>Widget* p = new Widget();</p>
<p>delete p;</p>
<p>p = nullptr; // set the pointer to null after deletion</p>
<p>Note that nullptr is not itself a pointer. The type of nullptr is a
fundamental type known as std::nullptr_t.</p>
<p>void f(int* p);</p>
<p>template</p>
<p>void g(T* p);</p>
<p>void h(std::nullptr_t p);</p>
<p>int main() {</p>
<p>f(nullptr); // ok</p>
<p>g(nullptr); // error</p>
<p>h(nullptr); // ok</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 13</p>
<p><span id="Chapter_3__operator_precedence"
class="anchor"></span>Chapter 3: operator precedence</p>
<p>Section 3.1: Logical &amp;&amp; and || operators: short-circuit</p>
<p>&amp;&amp; has precedence over ||, this means that parentheses are
placed to evaluate what would be evaluated together.</p>
<p>c++ uses short-circuit evaluation in &amp;&amp; and || to not do
unnecessary executions.</p>
<p>If the left hand side of || returns true the right hand side does not
need to be evaluated anymore.</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>bool True(string id){</p>
<p>cout &lt;&lt; "True" &lt;&lt; id &lt;&lt; endl;</p>
<p>return true;</p>
<p>}</p>
<p>bool False(string id){</p>
<p>cout &lt;&lt; "False" &lt;&lt; id &lt;&lt; endl;</p>
<p>return false;</p>
<p>}</p>
<p>int main(){</p>
<p>bool result;</p>
<p>//let's evaluate 3 booleans with || and &amp;&amp; to illustrate
operator precedence //precedence does not mean that &amp;&amp; will be
evaluated first but rather where //parentheses would be added</p>
<p>//example 1</p>
<p>result =</p>
<p>False("A") || False("B") &amp;&amp; False("C");</p>
<p>// eq. False("A") || (False("B") &amp;&amp; False("C"))</p>
<p>//FalseA</p>
<p>//FalseB</p>
<p>//"Short-circuit evaluation skip of C"</p>
<p>//A is false so we have to evaluate the right of ||, //B being false
we do not have to evaluate C to know that the result is false</p>
<p>result =</p>
<p>True("A") || False("B") &amp;&amp; False("C");</p>
<p>// eq. True("A") || (False("B") &amp;&amp; False("C"))</p>
<p>cout &lt;&lt; result &lt;&lt; " :=====================" &lt;&lt;
endl;</p>
<p>//TrueA</p>
<p>//"Short-circuit evaluation skip of B"</p>
<p>//"Short-circuit evaluation skip of C"</p>
<p>//A is true so we do not have to evaluate</p>
<p>// the right of || to know that the result is true //If || had
precedence over &amp;&amp; the equivalent evaluation would be: //
(True("A") || False("B")) &amp;&amp; False("C")</p>
<p>//What would print</p>
<p>//TrueA</p>
<p>//"Short-circuit evaluation skip of B"</p>
<p>//FalseC</p>
<p>//Because the parentheses are placed differently</p>
<p>//the parts that get evaluated are differently</p>
<p>//which makes that the end result in this case would be False because
C is false</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 14</p>
<p><span class="anchor"></span>}</p>
<p>Section 3.2: Unary Operators</p>
<p>Unary operators act on the object upon which they are called and have
high precedence. (See Remarks)</p>
<p>When used postfix, the action occurs only after the entire operation
is evaluated, leading to some interesting</p>
<p>arithmetics:</p>
<p>int a = 1;</p>
<p>++a; // result: 2</p>
<p>a--; // result: 1</p>
<p>int minusa=-a; // result: -1</p>
<p>bool b = true;</p>
<p>!b; // result: true</p>
<p>a=4;</p>
<p>int c = a++/2; // equal to: (a==4) 4 / 2 result: 2 ('a' incremented
postfix) cout &lt;&lt; a &lt;&lt; endl; // prints 5!</p>
<p>int d = ++a/2; // equal to: (a+1) == 6 / 2 result: 3</p>
<p>int arr[4] = {1,2,3,4};</p>
<p>int *ptr1 = &amp;arr[0]; // points to arr[0] which is 1</p>
<p>int *ptr2 = ptr1++; // ptr2 points to arr[0] which is still 1; ptr1
incremented std::cout &lt;&lt; *ptr1++ &lt;&lt; std::endl; // prints
2</p>
<p>int e = arr[0]++; // receives the value of arr[0] before it is
incremented std::cout &lt;&lt; e &lt;&lt; std::endl; // prints 1</p>
<p>std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl; // prints arr[0] which
is now 2</p>
<p>Section 3.3: Arithmetic operators</p>
<p>Arithmetic operators in C++ have the same precedence as they do in
mathematics:</p>
<p>Multiplication and division have left associativity(meaning that they
will be evaluated from left to right) and they have higher precedence
than addition and subtraction, which also have left associativity.</p>
<p>We can also force the precedence of expression using parentheses ( ).
Just the same way as you would do that in normal mathematics.</p>
<p>// volume of a spherical shell = 4 pi R^3 - 4 pi r^3 double vol =
4.0*pi*R*R*R/3.0-4.0*pi*r*r*r/3.0;</p>
<p>//Addition:</p>
<p>int a = 2+4/2; // equal to: 2+(4/2) result: 4 int b = (3+3)/2; //
equal to: (3+3)/2 result: 3</p>
<p>//With Multiplication</p>
<p>int c = 3+4/2*6; // equal to: 3+((4/2)*6) result: 15 int d =
3*(3+6)/9; // equal to: (3*(3+6))/9 result: 3</p>
<p>//Division and Modulo</p>
<p>int g = 3-3%1; // equal to: 3 % 1 = 0 3 - 0 = 3</p>
<p>int h = 3-(3%1); // equal to: 3 % 1 = 0 3 - 0 = 3</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 15</p>
<p><span id="int_i___3_3_1_3_____________equa" class="anchor"></span>int
i = 3-3/1%3; // equal to: 3 / 1 = 3 3 % 3 = 0 3 - 0 = 3 int l =
3-(3/1)%3; // equal to: 3 / 1 = 3 3 % 3 = 0 3 - 0 = 3 int m =
3-(3/(1%3)); // equal to: 1 % 3 = 1 3 / 1 = 3 3 - 3 = 0</p>
<p>Section 3.4: Logical AND and OR operators</p>
<p>These operators have the usual precedence in C++: AND before OR.</p>
<p>// You can drive with a foreign license for up to 60 days bool
can_drive = has_domestic_license || has_foreign_license &amp;&amp;
num_days &lt;= 60;</p>
<p>This code is equivalent to the following:</p>
<p>// You can drive with a foreign license for up to 60 days bool
can_drive = has_domestic_license || (has_foreign_license &amp;&amp;
num_days &lt;= 60);</p>
<p>Adding the parenthesis does not change the behavior, though, it does
make it easier to read. By adding these</p>
<p>parentheses, no confusion exist about the intent of the writer.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 16</p>
<p><span id="Chapter_4__Floating_Point_Arithm"
class="anchor"></span>Chapter 4: Floating Point Arithmetic</p>
<p>Section 4.1: Floating Point Numbers are Weird</p>
<p>The first mistake that nearly every single programmer makes is
presuming that this code will work as intended:</p>
<p>float total = 0;</p>
<p>for(float a = 0; a != 2; a += 0.01f) {</p>
<p>total += a;</p>
<p>}</p>
<p>The novice programmer assumes that this will sum up every single
number in the range 0, 0.01, 0.02, 0.03,</p>
<p>..., 1.97, 1.98, 1.99 , to yield the result 199—the mathematically
correct answer.</p>
<p>Two things happen that make this untrue:</p>
<p>1. The program as written never concludes. a never becomes equal to
2, and the loop never terminates. 2. If we rewrite the loop logic to
check a &lt; 2 instead, the loop terminates, but the total ends up
being</p>
<p>something different from 199. On IEEE754-compliant machines, it will
often sum up to about 201 instead.</p>
<p><strong>The reason that this happens is that</strong> Floating Point
Numbers represent Approximations of their assigned</p>
<p>values<strong>.</strong></p>
<p>The classical example is the following computation:</p>
<p>double a = 0.1;</p>
<p>double b = 0.2;</p>
<p>double c = 0.3;</p>
<p>if(a + b == c)</p>
<p>//This never prints on IEEE754-compliant machines</p>
<p>std::cout &lt;&lt; "This Computer is Magic!" &lt;&lt; std::endl;
else</p>
<p>std::cout &lt;&lt; "This Computer is pretty normal, all things
considered." &lt;&lt; std::endl;</p>
<p>Though what we the programmer see is three numbers written in base10,
what the compiler (and the underlying hardware) see are binary numbers.
Because 0.1, 0.2, and 0.3 require perfect division by 10—which is quite
easy in</p>
<p>a base-10 system, but impossible in a base-2 system—these numbers
have to be stored in imprecise formats,</p>
<p>similar to how the number 1/3 has to be stored in the imprecise form
0.333333333333333... in base-10.</p>
<p>//64-bit floats have 53 digits of precision, including the
whole-number-part. double a =
0011111110111001100110011001100110011001100110011001100110011010;
//imperfect representation of 0.1</p>
<p>double b =
0011111111001001100110011001100110011001100110011001100110011010;
//imperfect representation of 0.2</p>
<p>double c =
0011111111010011001100110011001100110011001100110011001100110011;
//imperfect representation of 0.3</p>
<p>double a + b =
0011111111010011001100110011001100110011001100110011001100110100; //Note
that this is not quite equal to the "canonical" 0.3!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 17</p>
<p><span id="Chapter_5__Bit_Operators" class="anchor"></span>Chapter 5:
Bit Operators</p>
<p>Section 5.1: | - bitwise OR</p>
<p>int a = 5; // 0101b (0x05)</p>
<p>int b = 12; // 1100b (0x0C)</p>
<p>int c = a | b; // 1101b (0x0D)</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; ", c = " &lt;&lt; c &lt;&lt; std::endl;</p>
<p>Output</p>
<p>a = 5, b = 12, c = 13</p>
<p>Why</p>
<p>A bit wise OR operates on the bit level and uses the following
Boolean truth table:</p>
<p>true OR true = true</p>
<p>true OR false = true</p>
<p>false OR false = false</p>
<p>When the binary value for a (0101) and the binary value for b (1100)
are OR'ed together we get the binary value of</p>
<p>1101:</p>
<p>int a = 0 1 0 1</p>
<p>int b = 1 1 0 0 |</p>
<p>---------</p>
<p>int c = 1 1 0 1</p>
<p>The bit wise OR does not change the value of the original values
unless specifically assigned to using the bit wise</p>
<p>assignment compound operator |=:</p>
<p>int a = 5; // 0101b (0x05)</p>
<p>a |= 12; // a = 0101b | 1101b</p>
<p>Section 5.2: ^ - bitwise XOR (exclusive OR)</p>
<p>int a = 5; // 0101b (0x05)</p>
<p>int b = 9; // 1001b (0x09)</p>
<p>int c = a ^ b; // 1100b (0x0C)</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; ", c = " &lt;&lt; c &lt;&lt; std::endl;</p>
<p>Output</p>
<p>a = 5, b = 9, c = 12</p>
<p>Why</p>
<p>A bit wise XOR (exclusive or) operates on the bit level and uses the
following Boolean truth table:</p>
<p>true OR true = false</p>
<p>true OR false = true</p>
<p>false OR false = false</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 18</p>
<p>Notice that with an XOR operation true OR true = false where as with
operations true AND/OR true = true, hence the exclusive nature of the
XOR operation.</p>
<p>Using this, when the binary value for a (0101) and the binary value
for b (1001) are XOR'ed together we get the binary value of 1100:</p>
<p>int a = 0 1 0 1</p>
<p>int b = 1 0 0 1 ^</p>
<p>---------</p>
<p>int c = 1 1 0 0</p>
<p>The bit wise XOR does not change the value of the original values
unless specifically assigned to using the bit wise assignment compound
operator ^=:</p>
<p>int a = 5; // 0101b (0x05)</p>
<p>a ^= 9; // a = 0101b ^ 1001b</p>
<p>The bit wise XOR can be utilized in many ways and is often utilized
in bit mask operations for encryption and compression.</p>
<p><strong>Note:</strong> The following example is often shown as an
example of a nice trick. But should not be used in production</p>
<p>code (there are better ways std::swap() to achieve the same
result).</p>
<p>You can also utilize an XOR operation to swap two variables without a
temporary:</p>
<p>int a = 42;</p>
<p>int b = 64;</p>
<p>// XOR swap</p>
<p>a ^= b;</p>
<p>b ^= a;</p>
<p>a ^= b;</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; "<strong>\n</strong>";</p>
<p>To productionalize this you need to add a check to make sure it can
be used.</p>
<p>void doXORSwap(int&amp; a, int&amp; b)</p>
<p>{</p>
<p>// Need to add a check to make sure you are not swapping the same //
variable with itself. Otherwise it will zero the value. if (&amp;a !=
&amp;b)</p>
<p>{</p>
<p>// XOR swap</p>
<p>a ^= b;</p>
<p>b ^= a;</p>
<p>a ^= b;</p>
<p>}</p>
<p>}</p>
<p>So though it looks like a nice trick in isolation it is not useful in
real code. xor is not a base logical operation,but a combination of
others: a^c=~(a&amp;c)&amp;(a|c)</p>
<p>also in 2015+ compilers variables may be assigned as binary:</p>
<p>int cn=0b0111;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 19</p>
<p><span id="Section_5_3______bitwise_AND" class="anchor"></span>Section
5.3: &amp; - bitwise AND</p>
<p>int a = 6; // 0110b (0x06)</p>
<p>int b = 10; // 1010b (0x0A)</p>
<p>int c = a &amp; b; // 0010b (0x02)</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; ", c = " &lt;&lt; c &lt;&lt; std::endl;</p>
<p>Output</p>
<p>a = 6, b = 10, c = 2</p>
<p>Why</p>
<p>A bit wise AND operates on the bit level and uses the following
Boolean truth table:</p>
<p>TRUE AND TRUE = TRUE</p>
<p>TRUE AND FALSE = FALSE</p>
<p>FALSE AND FALSE = FALSE</p>
<p>When the binary value for a (0110) and the binary value for b (1010)
are AND'ed together we get the binary value of</p>
<p>0010:</p>
<p>int a = 0 1 1 0</p>
<p>int b = 1 0 1 0 &amp;</p>
<p>---------</p>
<p>int c = 0 0 1 0</p>
<p>The bit wise AND does not change the value of the original values
unless specifically assigned to using the bit wise assignment compound
operator &amp;=:</p>
<p>int a = 5; // 0101b (0x05)</p>
<p>a &amp;= 10; // a = 0101b &amp; 1010b</p>
<p>Section 5.4: &lt;&lt; - left shift</p>
<p>int a = 1; // 0001b</p>
<p>int b = a &lt;&lt; 1; // 0010b</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; std::endl;</p>
<p>Output</p>
<p>a = 1, b = 2</p>
<p>Why</p>
<p>The left bit wise shift will shift the bits of the left hand value
(a) the number specified on the right (1), essentially</p>
<p>padding the least significant bits with 0's, so shifting the value of
5 (binary 0000 0101) to the left 4 times (e.g. 5 &lt;&lt; 4) will yield
the value of 80 (binary 0101 0000). You might note that shifting a value
to the left 1 time is also the same</p>
<p>as multiplying the value by 2, example:</p>
<p>int a = 7;</p>
<p>while (a &lt; 200) {</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;</p>
<p>a &lt;&lt;= 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 20</p>
<p><span id="_1" class="anchor"></span>}</p>
<p>a = 7;</p>
<p>while (a &lt; 200) {</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; std::endl;</p>
<p>a *= 2;</p>
<p>}</p>
<p>But it should be noted that the left shift operation will shift
<em>all</em> bits to the left, including the sign bit, example:</p>
<p>int a = 2147483647; // 0111 1111 1111 1111 1111 1111 1111 1111 int b
= a &lt;&lt; 1; // 1111 1111 1111 1111 1111 1111 1111 1110</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; std::endl;</p>
<p>Possible output: a = 2147483647, b =-2</p>
<p>While some compilers will yield results that seem expected, it should
be noted that if you left shift a signed number</p>
<p>so that the sign bit is affected, the result is
<strong>undefined</strong>. It is also <strong>undefined</strong> if the
number of bits you wish to shift by</p>
<p>is a negative number or is larger than the number of bits the type on
the left can hold, example:</p>
<p>int a = 1;</p>
<p>int b = a &lt;&lt;-1; // undefined behavior</p>
<p>char c = a &lt;&lt; 20; // undefined behavior</p>
<p>The bit wise left shift does not change the value of the original
values unless specifically assigned to using the bit wise assignment
compound operator &lt;&lt;=:</p>
<p>int a = 5; // 0101b</p>
<p>a &lt;&lt;= 1; // a = a &lt;&lt; 1;</p>
<p>Section 5.5: &gt;&gt; - right shift</p>
<p>int a = 2; // 0010b</p>
<p>int b = a &gt;&gt; 1; // 0001b</p>
<p>std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&lt;&lt; std::endl;</p>
<p>Output</p>
<p>a = 2, b = 1</p>
<p>Why</p>
<p>The right bit wise shift will shift the bits of the left hand value
(a) the number specified on the right (1); it should be</p>
<p>noted that while the operation of a right shift is standard, what
happens to the bits of a right shift on a <em>signed</em>
<em>negative</em> number is <em>implementation defined</em> and thus
cannot be guaranteed to be portable, example:</p>
<p>int a =-2;</p>
<p>int b = a &gt;&gt; 1; // the value of b will be depend on the
compiler</p>
<p>It is also undefined if the number of bits you wish to shift by is a
negative number, example:</p>
<p>int a = 1;</p>
<p>int b = a &gt;&gt;-1; // undefined behavior</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 21</p>
<p>The bit wise right shift does not change the value of the original
values unless specifically assigned to using the bit wise assignment
compound operator &gt;&gt;=:</p>
<p>int a = 2; // 0010b</p>
<p>a &gt;&gt;= 1; // a = a &gt;&gt; 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 22</p>
<p><span id="Chapter_6__Bit_Manipulation" class="anchor"></span>Chapter
6: Bit Manipulation</p>
<p>Section 6.1: Remove rightmost set bit</p>
<p>C-style bit-manipulation</p>
<p>template</p>
<p>T rightmostSetBitRemoved(T n)</p>
<p>{</p>
<p>// static_assert(std::is_integral::value &amp;&amp;
!std::is_signed::value, "type should be</p>
<p>unsigned"); // For c++11 and later</p>
<p>return n &amp; (n -1);</p>
<p>}</p>
<p>Explanation</p>
<p>if n is zero, we have 0 &amp; 0xFF..FF which is zero</p>
<p>else n can be written 0bxxxxxx10..00 and n -1 is 0bxxxxxx011..11, so
n &amp; (n -1) is 0bxxxxxx000..00.</p>
<p>Section 6.2: Set all bits</p>
<p>C-style bit-manipulation</p>
<p>x =-1; // -1 == 1111 1111 ... 1111b</p>
<p>(See <a href="http://stackoverflow.com/a/809341/">here</a> for an
explanation of why this works and is actually the best approach.)</p>
<p>Using std::bitset</p>
<p>std::bitset&lt;10&gt; x;</p>
<p>x.set(); // Sets all bits to '1'</p>
<p>Section 6.3: Toggling a bit</p>
<p>C-style bit-manipulation</p>
<p>A bit can be toggled using the XOR operator (^).</p>
<p>// Bit x will be the opposite value of what it is currently number ^=
1LL &lt;&lt; x;</p>
<p>Using std::bitset</p>
<p>std::bitset&lt;4&gt; num(std::string("0100"));</p>
<p>num.flip(2); // num is now 0000</p>
<p>num.flip(0); // num is now 0001</p>
<p>num.flip(); // num is now 1110 (flips all bits)</p>
<p>Section 6.4: Checking a bit</p>
<p>C-style bit-manipulation</p>
<p>The value of the bit can be obtained by shifting the number to the
right x times and then performing bitwise AND (&amp;) on it:</p>
<p>(number &gt;&gt; x) &amp; 1LL; // 1 if the 'x'th bit of 'number' is
set, 0 otherwise</p>
<p>The right-shift operation may be implemented as either an arithmetic
(signed) shift or a logical (unsigned) shift. If</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 23</p>
<p><span id="number_in_the_expression_number"
class="anchor"></span>number in the expression number &gt;&gt; x has a
signed type and a negative value, the resulting value is
implementation-defined.</p>
<p>If we need the value of that bit directly in-place, we could instead
left shift the mask:</p>
<p>(number &amp; (1LL &lt;&lt; x)); // (1 &lt;&lt; x) if the 'x'th bit
of 'number' is set, 0 otherwise</p>
<p>Either can be used as a conditional, since all non-zero values are
considered true.</p>
<p>Using std::bitset</p>
<p>std::bitset&lt;4&gt; num(std::string("0010"));</p>
<p>bool bit_val = num.test(1); // bit_val value is set to true;</p>
<p>Section 6.5: Counting bits set</p>
<p>The population count of a bitstring is often needed in cryptography
and other applications and the problem has</p>
<p>been widely studied.</p>
<p>The naive way requires one iteration per bit:</p>
<p>unsigned value = 1234;</p>
<p>unsigned bits = 0; // accumulates the total number of bits set in
`n`</p>
<p>for (bits = 0; value; value &gt;&gt;= 1)</p>
<p>bits += value &amp; 1;</p>
<p>A nice trick (based on Remove rightmost set bit ) is:</p>
<p>unsigned bits = 0; // accumulates the total number of bits set in
`n`</p>
<p>for (; value; ++bits)</p>
<p>value &amp;= value -1;</p>
<p>It goes through as many iterations as there are set bits, so it's
good when value is expected to have few nonzero</p>
<p>bits.</p>
<p><a href="http://cacm.acm.org/">The method was first proposed by Peter
Wegner (in CACM</a> 3 / 322 - 1960) and it's well known since it appears
in <em>C</em></p>
<p><em>Programming Language</em> by Brian W. Kernighan and Dennis M.
Ritchie.</p>
<p>This requires 12 arithmetic operations, one of which is a
multication:</p>
<p>unsigned popcount(std::uint64_t x)</p>
<p>{</p>
<p>const std::uint64_t m1 = 0x5555555555555555; // binary: 0101... const
std::uint64_t m2 = 0x3333333333333333; // binary: 00110011.. const
std::uint64_t m4 = 0x0f0f0f0f0f0f0f0f; // binary: 0000111100001111</p>
<p>x -= (x &gt;&gt; 1) &amp; m1; // put count of each 2 bits into those
2 bits x = (x &amp; m2) + ((x &gt;&gt; 2) &amp; m2); // put count of
each 4 bits into those 4 bits x = (x + (x &gt;&gt; 4)) &amp; m4; // put
count of each 8 bits into those 8 bits</p>
<p>return (x * h01) &gt;&gt; 56; // left 8 bits of x + (x&lt;&lt;8) +
(x&lt;&lt;16) + (x&lt;&lt;24) + ...</p>
<p>}</p>
<p>This kind of implementation has the best worst-case behavior (see <a
href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weight for
further details).</a></p>
<p>Many CPUs have a specific instruction (like x86's popcnt) and the
compiler could offer a specific (<strong>non standard</strong>)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 24</p>
<p><span id="built_in_function__E_g__with_g" class="anchor"></span>built
in function. E.g. with g++ there is:</p>
<p>int __builtin_popcount (unsigned x);</p>
<p>Section 6.6: Check if an integer is a power of 2</p>
<p>The n &amp; (n -1) trick (see Remove rightmost set bit) is also
useful to determine if an integer is a power of 2:</p>
<p>bool power_of_2 = n &amp;&amp; !(n &amp; (n -1));</p>
<p>Note that without the first part of the check (n &amp;&amp;), 0 is
incorrectly considered a power of 2.</p>
<p>Section 6.7: Setting a bit</p>
<p>C-style bit manipulation</p>
<p>A bit can be set using the bitwise OR operator (|).</p>
<p>// Bit x will be set</p>
<p>number |= 1LL &lt;&lt; x;</p>
<p>Using std::bitset</p>
<p>set(x) or set(x,true) - sets bit at position x to 1.</p>
<p>std::bitset&lt;5&gt; num(std::string("01100"));</p>
<p>num.set(0); // num is now 01101</p>
<p>num.set(2); // num is still 01101</p>
<p>num.set(4,true); // num is now 11110</p>
<p>Section 6.8: Clearing a bit</p>
<p>C-style bit-manipulation</p>
<p>A bit can be cleared using the bitwise AND operator (&amp;).</p>
<p>// Bit x will be cleared</p>
<p>number &amp;= ~(1LL &lt;&lt; x);</p>
<p>Using std::bitset</p>
<p>reset(x) or set(x,false) - clears the bit at position x.</p>
<p>std::bitset&lt;5&gt; num(std::string("01100"));</p>
<p>num.reset(2); // num is now 01000</p>
<p>num.reset(0); // num is still 01000</p>
<p>num.set(3,false); // num is now 00000</p>
<p>Section 6.9: Changing the nth bit to x</p>
<p>C-style bit-manipulation</p>
<p>// Bit n will be set if x is 1 and cleared if x is 0. number ^= (-x ^
number) &amp; (1LL &lt;&lt; n);</p>
<p>Using std::bitset</p>
<p>set(n,val) - sets bit n to the value val.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 25</p>
<p><span id="std__bitset_5__num_std__string"
class="anchor"></span>std::bitset&lt;5&gt;
num(std::string("00100"));</p>
<p>num.set(0,true); // num is now 00101</p>
<p>num.set(2,false); // num is now 00001</p>
<p>Section 6.10: Bit Manipulation Application: Small to Capital</p>
<p>Letter</p>
<p>One of several applications of bit manipulation is converting a
letter from small to capital or vice versa by choosing</p>
<p>a <strong>mask</strong> and a proper <strong>bit operation</strong>.
For example, the <strong>a</strong> letter has this binary
representation 01(1)00001 while its</p>
<p>capital counterpart has 01(0)00001. They differ solely in the bit in
parenthesis. In this case, converting the <strong>a</strong> letter</p>
<p>from small to capital is basically setting the bit in parenthesis to
one. To do so, we do the following:</p>
<p>/****************************************</p>
<p>convert small letter to captial letter.</p>
<p>========================================</p>
<p>a: 01100001</p>
<p>mask: 11011111 &lt;-- (0xDF) 11(0)11111</p>
<p>:---------</p>
<p>a&amp;mask: 01000001 &lt;-- A letter</p>
<p>*****************************************/</p>
<p>The code for converting a letter to A letter is</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>char op1 = 'a'; // "a" letter (i.e. small case)</p>
<p>int mask = 0xDF; // choosing a proper mask</p>
<p>printf("a (AND) mask = A<strong>\n</strong>");</p>
<p>printf("%c &amp; 0xDF = %c<strong>\n</strong>", op1, op1 &amp;
mask);</p>
<p>return 0;</p>
<p>}</p>
<p>The result is</p>
<p>$ g++ main.cpp-o test1</p>
<p>$ ./test1</p>
<p>a (AND) mask = A</p>
<p>a &amp; 0xDF = A</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 26</p>
<p><span id="Chapter_7__Bit_fields" class="anchor"></span>Chapter 7: Bit
fields</p>
<p>Bit fields tightly pack C and C++ structures to reduce size. This
appears painless: specify the number of bits for</p>
<p>members, and compiler does the work of co-mingling bits. The
restriction is inability to take the address of a bit field member,
since it is stored co-mingled. sizeof() is also disallowed.</p>
<p>The cost of bit fields is slower access, as memory must be retrieved
and bitwise operations applied to extract or modify member values. These
operations also add to executable size.</p>
<p>Section 7.1: Declaration and Usage</p>
<p>struct FileAttributes</p>
<p>{</p>
<p>unsigned int ReadOnly: 1;</p>
<p>unsigned int Hidden: 1;</p>
<p>};</p>
<p>Here, each of these two fields will occupy 1 bit in memory. It is
specified by <strong>: 1</strong> expression after the variable names.
Base type of bit field could be any integral type (8-bit int to 64-bit
int). Using unsigned type is recommended,</p>
<p>otherwise surprises may come.</p>
<p>If more bits are required, replace "1" with number of bits required.
For example:</p>
<p>struct Date</p>
<p>{</p>
<p>unsigned int Year : 13; // 2^13 = 8192, enough for "year"
representation for long time unsigned int Month: 4; // 2^4 = 16, enough
to represent 1-12 month values. unsigned int Day: 5; // 32</p>
<p>};</p>
<p>The whole structure is using just 22 bits, and with normal compiler
settings, sizeof this structure would be 4 bytes.</p>
<p>Usage is pretty simple. Just declare the variable, and use it like
ordinary structure.</p>
<p>Date d;</p>
<p>d.Year = 2016;</p>
<p>d.Month = 7;</p>
<p>d.Day = 22;</p>
<p>std::cout &lt;&lt; "Year:" &lt;&lt; d.Year &lt;&lt; std::endl
&lt;&lt;</p>
<p>"Month:" &lt;&lt; d.Month &lt;&lt; std::endl &lt;&lt;</p>
<p>"Day:" &lt;&lt; d.Day &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 27</p>
<p><span id="Chapter_8__Arrays" class="anchor"></span>Chapter 8:
Arrays</p>
<p>Arrays are elements of the same type placed in adjoining memory
locations. The elements can be individually</p>
<p>referenced by a unique identifier with an added index.</p>
<p>This allows you to declare multiple variable values of a specific
type and access them individually without needing</p>
<p>to declare a variable for each value.</p>
<p>Section 8.1: Array initialization</p>
<p>An array is just a block of sequential memory locations for a
specific type of variable. Arrays are allocated the same</p>
<p>way as normal variables, but with square brackets appended to its
name [] that contain the number of elements that fit into the array
memory.</p>
<p>The following example of an array uses the typ int, the variable name
arrayOfInts, and the number of elements</p>
<p>[5] that the array has space for:</p>
<p>int arrayOfInts[5];</p>
<p>An array can be declared and initialized at the same time like
this</p>
<p>int arrayOfInts[5] = {10, 20, 30, 40, 50};</p>
<p>When initializing an array by listing all of its members, it is not
necessary to include the number of elements inside the square brackets.
It will be automatically calculated by the compiler. In the following
example, it's 5:</p>
<p>int arrayOfInts[] = {10, 20, 30, 40, 50};</p>
<p>It is also possible to initialize only the first elements while
allocating more space. In this case, defining the length in</p>
<p>brackets is mandatory. The following will allocate an array of length
5 with partial initialization, the compiler initializes all remaining
elements with the standard value of the element type, in this case
zero.</p>
<p>int arrayOfInts[5] = {10,20}; // means 10, 20, 0, 0, 0</p>
<p>Arrays of other basic data types may be initialized in the same
way.</p>
<p>char arrayOfChars[5]; // declare the array and allocate the memory,
don't initialize</p>
<p>char arrayOfChars[5] = { 'a', 'b', 'c', 'd', 'e' } ; //declare and
initialize</p>
<p>double arrayOfDoubles[5] = {1.14159, 2.14159, 3.14159, 4.14159,
5.14159};</p>
<p>string arrayOfStrings[5] = { "C++", "is", "super", "duper",
"great!"};</p>
<p>It is also important to take note that when accessing array elements,
the array's element index(or position) starts from 0.</p>
<p>int array[5] = { 10<em>/*Element no.0*/</em>, 20<em>/*Element
no.1*/</em>, 30, 40, 50<em>/*Element no.4*/</em>}; std::cout &lt;&lt;
array[4]; //outputs 50</p>
<p>std::cout &lt;&lt; array[0]; //outputs 10</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 28</p>
<p><span id="Section_8_2__A_fixed_size_raw_ar"
class="anchor"></span>Section 8.2: A fixed size raw array matrix (that
is, a 2D raw</p>
<p>array)</p>
<p>// A fixed size raw array matrix (that is, a 2D raw array).
#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>auto main()-&gt; int</p>
<p>{</p>
<p>int const n_rows = 3;</p>
<p>int const n_cols = 7;</p>
<p>int const m[n_rows][n_cols] = // A raw array matrix.</p>
<p>{</p>
<p>{ 1, 2, 3, 4, 5, 6, 7 },</p>
<p>{ 8, 9, 10, 11, 12, 13, 14 },</p>
<p>{ 15, 16, 17, 18, 19, 20, 21 }</p>
<p>};</p>
<p>for( int y = 0; y &lt; n_rows; ++y )</p>
<p>{</p>
<p>for( int x = 0; x &lt; n_cols; ++x )</p>
<p>{</p>
<p>cout &lt;&lt; setw( 4 ) &lt;&lt; m[y][x]; // Note: do NOT use
m[y,x]!</p>
<p>}</p>
<p>cout &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</p>
<p>C++ doesn't support special syntax for indexing a multi-dimensional
array. Instead such an array is viewed as an</p>
<p>array of arrays (possibly of arrays, and so on), and the ordinary
single index notation [<em>i</em>] is used for each level. In the
example above m[y] refers to row y of m, where y is a zero-based index.
Then this row can be indexed in turn,</p>
<p>e.g. m[y][x], which refers to the xth item – or column – of row
y.</p>
<p>I.e. the last index varies fastest, and in the declaration the range
of this index, which here is the number of columns per row, is the last
and “innermost” size specified.</p>
<p>Since C++ doesn't provide built-in support for dynamic size arrays,
other than dynamic allocation, a dynamic size matrix is often
implemented as a class. Then the raw array matrix indexing notation
m[y][x] has some cost, either</p>
<p>by exposing the implementation (so that e.g. a view of a transposed
matrix becomes practically impossible) or by</p>
<p>adding some overhead and slight inconvenience when it's done by
returning a proxy object from operator[]. And so the indexing notation
for such an abstraction can and will usually be different, both in
look-and-feel and in the</p>
<p>order of indices, e.g. m(x,y) or m.at(x,y) or m.item(x,y).</p>
<p>Section 8.3: Dynamically sized raw array</p>
<p>// Example of raw dynamic size array. It's generally better to use
std::vector. #include // std::sort</p>
<p>#include</p>
<p>using namespace std;</p>
<p>auto int_from( istream&amp; in )-&gt; int { int x; in &gt;&gt; x;
return x; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 29</p>
<p><span id="auto_main" class="anchor"></span>auto main()</p>
<p>-&gt; int</p>
<p>{</p>
<p>cout &lt;&lt; "Sorting n integers provided by
you.<strong>\\</strong>n";</p>
<p>cout &lt;&lt; "n? ";</p>
<p>int const n = int_from( cin );</p>
<p>int* a = new int[n]; // ← Allocation of array of n items.</p>
<p>for( int i = 1; i &lt;= n; ++i )</p>
<p>{</p>
<p>cout &lt;&lt; "The #" &lt;&lt; i &lt;&lt; " number, please: ";</p>
<p>a[i-1] = int_from( cin );</p>
<p>}</p>
<p>sort( a, a + n );</p>
<p>for( int i = 0; i &lt; n; ++i ) { cout &lt;&lt; a[i] &lt;&lt; ' ';
}</p>
<p>cout &lt;&lt; '<strong>\\</strong>n';</p>
<p>delete[] a;</p>
<p>}</p>
<p>A program that declares an array T a[n]; where n is determined a
run-time, can compile with certain compilers that support C99
<em>variadic length arrays</em> (VLAs) as a language extension. But VLAs
are not supported by standard C++.</p>
<p>This example shows how to manually allocate a dynamic size array via
a new[]-expression,</p>
<p>int* a = new int[n]; // ← Allocation of array of n items.</p>
<p>… then use it, and finally deallocate it via a
delete[]-expression:</p>
<p>delete[] a;</p>
<p>The array allocated here has indeterminate values, but it can be
zero-initialized by just adding an empty</p>
<p>parenthesis (), like this: new int[n](). More generally, for
arbitrary item type, this performs a <em>value-initialization</em>.</p>
<p>As part of a function down in a call hierarchy this code would not be
exception safe, since an exception before the</p>
<p>delete[] expression (and after the new[]) would cause a memory leak.
One way to address that issue is to automate the cleanup via e.g. a
std::unique_ptr smart pointer. But a generally better way to address it
is to just</p>
<p>use a std::vector: that's what std::vector is there for.</p>
<p>Section 8.4: Array size: type safe at compile time</p>
<p>#include // size_t, ptrdiff_t</p>
<p>//----------------------------------- Machinery:</p>
<p>using Size = ptrdiff_t;</p>
<p>template&lt; class Item, size_t n &gt;</p>
<p>constexpr auto n_items( Item (&amp;)[n] ) noexcept</p>
<p>-&gt; Size</p>
<p>{ return n; }</p>
<p>//----------------------------------- Usage:</p>
<p>#include</p>
<p>using namespace std;</p>
<p>auto main()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 30</p>
<p><span id="___int" class="anchor"></span>-&gt; int</p>
<p>{</p>
<p>int const a[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4}; Size const n =
n_items( a );</p>
<p>int b[n] = {}; // An array of the same size as a.</p>
<p>(void) b;</p>
<p>cout &lt;}</p>
<p>The C idiom for array size, sizeof(a)/sizeof(a[0]), will accept a
pointer as argument and will then generally yield an incorrect
result.</p>
<p>For C++11</p>
<p>using C++11 you can do:</p>
<p>std::extent::value;</p>
<p>Example:</p>
<p>char MyArray[] = { 'X','o','c','e' };</p>
<p>const auto n = std::extent::value; std::cout &lt;&lt; n &lt;&lt;
"<strong>\n</strong>"; // Prints 4</p>
<p>Up till C++17 (forthcoming as of this writing) C++ had no built-in
core language or standard library utility to obtain the size of an
array, but this can be implemented by passing the array <em>by
reference</em> to a function template, as shown</p>
<p>above. Fine but important point: the template size parameter is a
size_t, somewhat inconsistent with the signed Size function result type,
in order to accommodate the g++ compiler which sometimes insists on
size_t for</p>
<p>template matching.</p>
<p><a href="http://en.cppreference.com/w/cpp/iterator/size">With C++17
and later one may instead use std::size</a>, which is specialized for
arrays.</p>
<p>Section 8.5: Expanding dynamic size array by using</p>
<p>std::vector</p>
<p>// Example of std::vector as an expanding dynamic size array.
#include // std::sort</p>
<p>#include</p>
<p>#include // std::vector</p>
<p>using namespace std;</p>
<p>int int_from( std::istream&amp; in ) { int x = 0; in &gt;&gt; x;
return x; }</p>
<p>int main()</p>
<p>{</p>
<p>cout &lt;&lt; "Sorting integers provided by
you.<strong>\n</strong>";</p>
<p>cout &lt;&lt; "You can indicate EOF via F6 in Windows or Ctrl+D in
Unix-land.<strong>\n</strong>";</p>
<p>vector a; // ← Zero size by default.</p>
<p>while( cin )</p>
<p>{</p>
<p>cout &lt;&lt; "One number, please, or indicate EOF: ";</p>
<p>int const x = int_from( cin );</p>
<p>if( !cin.fail() ) { a.push_back( x ); } // Expands as necessary.</p>
<p>}</p>
<p>sort( a.begin(), a.end() );</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 31</p>
<p><span id="int_const_n___a_size" class="anchor"></span>int const n =
a.size();</p>
<p>for( int i = 0; i &lt; n; ++i ) { cout &lt;&lt; a[i] &lt;&lt; ' ';
}</p>
<p>cout &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>std::vector is a standard library class template that provides the
notion of a variable size array. It takes care of all</p>
<p>the memory management, and the buffer is contiguous so a pointer to
the buffer (e.g. &amp;v[0] or v.data()) can be passed to API functions
requiring a raw array. A vector can even be expanded at run time, via
e.g. the push_back</p>
<p>member function that appends an item.</p>
<p>The complexity of the sequence of <em>n</em> push_back operations,
including the copying or moving involved in the vector</p>
<p>expansions, is amortized O(<em>n</em>). “Amortized”: on average.</p>
<p>Internally this is usually achieved by the vector <em>doubling</em>
its buffer size, its capacity, when a larger buffer is needed.</p>
<p>E.g. for a buffer starting out as size 1, and being repeatedly
doubled as needed for <em>n</em>=17 push_back calls, this</p>
<p>involves 1 + 2 + 4 + 8 + 16 = 31 copy operations, which is less than
2×<em>n</em> = 34. And more generally the sum of this</p>
<p>sequence can't exceed 2×<em>n</em>.</p>
<p>Compared to the dynamic size raw array example, this vector-based
code does not require the user to supply (and</p>
<p>know) the number of items up front. Instead the vector is just
expanded as necessary, for each new item value specified by the
user.</p>
<p>Section 8.6: A dynamic size matrix using std::vector for</p>
<p>storage</p>
<p>Unfortunately as of C++14 there's no dynamic size matrix class in the
C++ standard library. Matrix classes that</p>
<p>support dynamic size are however available from a number of 3rd party
libraries, including the Boost Matrix library (a sub-library within the
Boost library).</p>
<p>If you don't want a dependency on Boost or some other library, then
one poor man's dynamic size matrix in C++ is</p>
<p>just like</p>
<p>vector&gt; m( 3, vector( 7 ) );</p>
<p>… where vector is std::vector. The matrix is here created by copying
a row vector <em>n</em> times where <em>n</em> is the number</p>
<p>of rows, here 3. It has the advantage of providing the same m[y][x]
indexing notation as for a fixed size raw array matrix, but it's a bit
inefficient because it involves a dynamic allocation for each row, and
it's a bit unsafe because</p>
<p>it's possible to inadvertently resize a row.</p>
<p>A more safe and efficient approach is to use a single vector as
<em>storage</em> for the matrix, and map the client code's (<em>x</em>,
<em>y</em>)</p>
<p>to a corresponding index in that vector:</p>
<p>// A dynamic size matrix using std::vector for storage.</p>
<p>//--------------------------------------------- Machinery: #include
// std::copy</p>
<p>#include // assert</p>
<p>#include // std::initializer_list</p>
<p>#include // std::vector</p>
<p>#include // ptrdiff_t</p>
<p>namespace my {</p>
<p>using Size = ptrdiff_t;</p>
<p>using std::initializer_list;</p>
<p>using std::vector;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 32</p>
<p>template&lt; class Item &gt;</p>
<p>class Matrix</p>
<p>{</p>
<p>private:</p>
<p>vector items_;</p>
<p>Size n_cols_;</p>
<p>auto index_for( Size const x, Size const y ) const-&gt; Size</p>
<p>{ return y*n_cols_ + x; }</p>
<p>public:</p>
<p>auto n_rows() const -&gt; Size { return items_.size()/n_cols_; } auto
n_cols() const -&gt; Size { return n_cols_; }</p>
<p>auto item( Size const x, Size const y )</p>
<p>-&gt; Item&amp;</p>
<p>{ return items_[index_for(x, y)]; }</p>
<p>auto item( Size const x, Size const y ) const</p>
<p>-&gt; Item const&amp;</p>
<p>{ return items_[index_for(x, y)]; }</p>
<p>Matrix(): n_cols_( 0 ) {}</p>
<p>Matrix( Size const n_cols, Size const n_rows )</p>
<p>: items_( n_cols*n_rows )</p>
<p>, n_cols_( n_cols )</p>
<p>{}</p>
<p>Matrix( initializer_list&lt; initializer_list &gt; const&amp; values
) : items_()</p>
<p>, n_cols_( values.size() == 0? 0 : values.begin()-&gt;size() ) {</p>
<p>for( auto const&amp; row : values )</p>
<p>{</p>
<p>assert( Size( row.size() ) == n_cols_ );</p>
<p>items_.insert( items_.end(), row.begin(), row.end() ); }</p>
<p>}</p>
<p>};</p>
<p>} // namespace my</p>
<p>//--------------------------------------------- Usage: using
my::Matrix;</p>
<p>auto some_matrix()</p>
<p>-&gt; Matrix</p>
<p>{</p>
<p>return</p>
<p>{</p>
<p>{ 1, 2, 3, 4, 5, 6, 7 },</p>
<p>{ 8, 9, 10, 11, 12, 13, 14 },</p>
<p>{ 15, 16, 17, 18, 19, 20, 21 }</p>
<p>};</p>
<p>}</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>auto main() -&gt; int</p>
<p>{</p>
<p>Matrix const m = some_matrix();</p>
<p>assert( m.n_cols() == 7 );</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 33</p>
<p>assert( m.n_rows() == 3 );</p>
<p>for( int y = 0, y_end = m.n_rows(); y &lt; y_end; ++y ) {</p>
<p>for( int x = 0, x_end = m.n_cols(); x &lt; x_end; ++x ) {</p>
<p>cout &lt;← Note: not `m[y][x]`!</p>
<p>}</p>
<p>cout &lt;}</p>
<p>}</p>
<p>Output:</p>
<p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</p>
<p>The above code is not industrial grade: it's designed to show the
basic principles, and serve the needs of students</p>
<p>learning C++.</p>
<p>For example, one may define operator() overloads to simplify the
indexing notation.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 34</p>
<p><span id="Chapter_9__Iterators_1" class="anchor"></span>Chapter 9:
Iterators</p>
<p>Section 9.1: Overview</p>
<p>Iterators are Positions</p>
<p>Iterators are a means of navigating and operating on a sequence of
elements and are a generalized extension of pointers. Conceptually it is
important to remember that iterators are positions, not elements. For
example, take the</p>
<p>following sequence:</p>
<p>A B C</p>
<p>The sequence contains three elements and four positions</p>
<p>+---+---+---+---+</p>
<p>| A | B | C | |</p>
<p>+---+---+---+---+</p>
<p>Elements are things within a sequence. Positions are places where
meaningful operations can happen to the</p>
<p>sequence. For example, one inserts into a position, <em>before</em>
or <em>after</em> element A, not into an element. Even deletion of an
element (erase(A)) is done by first finding its position, then deleting
it.</p>
<p>From Iterators to Values</p>
<p>To convert from a position to a value, an iterator is
<em>dereferenced</em>:</p>
<p>auto my_iterator = my_vector.begin(); // position</p>
<p>auto my_value = *my_iterator; // value</p>
<p>One can think of an iterator as dereferencing to the value it refers
to in the sequence. This is especially useful in</p>
<p>understanding why you should never dereference the end() iterator in
a sequence:</p>
<p>+---+---+---+---+</p>
<p>| A | B | C | |</p>
<p>+---+---+---+---+</p>
<p>↑ ↑</p>
<p>| +-- An iterator here has no value. Do not dereference it!
+-------------- An iterator here dereferences to the value A.</p>
<p>In all the sequences and containers found in the C++ standard
library, begin() will return an iterator to the first position, and
end() will return an iterator to one past the last position
(<em>not</em> the last position!). Consequently, the</p>
<p>names of these iterators in algorithms are oftentimes labelled first
and last:</p>
<p>+---+---+---+---+</p>
<p>| A | B | C | |</p>
<p>+---+---+---+---+</p>
<p>↑ ↑</p>
<p>| |</p>
<p>+- first +- last</p>
<p>It is also possible to obtain an iterator to <em>any sequence</em>,
because even an empty sequence contains at least one</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 35</p>
<p>position:</p>
<p>+---+</p>
<p>| |</p>
<p>+---+</p>
<p>In an empty sequence, begin() and end() will be the same position,
and <em>neither</em> can be dereferenced:</p>
<p>+---+</p>
<p>| |</p>
<p>+---+</p>
<p>↑</p>
<p>|</p>
<p>+- empty_sequence.begin()</p>
<p>|</p>
<p>+- empty_sequence.end()</p>
<p>The alternative visualization of iterators is that they mark the
positions <em>between</em> elements:</p>
<p>+---+---+---+</p>
<p>| A | B | C |</p>
<p>+---+---+---+</p>
<p>↑ ^ ^ ↑</p>
<p>| |</p>
<p>+- first +- last</p>
<p>and dereferencing an iterator returns a reference to the element
coming after the iterator. Some situations where this view is
particularly useful are:</p>
<p>insert operations will insert elements into the position indicated by
the iterator, erase operations will return an iterator corresponding to
the same position as the one passed in,</p>
<p>an iterator and its corresponding reverse iterator are located in the
same .position between elements</p>
<p>Invalid Iterators</p>
<p>An iterator becomes <em>invalidated</em> if (say, in the course of an
operation) its position is no longer a part of a sequence. An
invalidated iterator cannot be dereferenced until it has been reassigned
to a valid position. For example:</p>
<p>std::vector::iterator first;</p>
<p>{</p>
<p>std::vector foo;</p>
<p>first = foo.begin(); // first is now valid</p>
<p>} // foo falls out of scope and is destroyed</p>
<p>// At this point first is now invalid</p>
<p>The many algorithms and sequence member functions in the C++ standard
library have rules governing when iterators are invalidated. Each
algorithm is different in the way they treat (and invalidate)
iterators.</p>
<p>Navigating with Iterators</p>
<p>As we know, iterators are for navigating sequences. In order to do
that an iterator must migrate its position throughout the sequence.
Iterators can advance forward in the sequence and some can advance
backwards:</p>
<p>auto first = my_vector.begin();</p>
<p>++first; // advance the iterator 1 position</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 36</p>
<p>std::advance(first, 1); // advance the iterator 1 position first =
std::next(first); // returns iterator to the next element
std::advance(first, -1); // advance the iterator 1 position
backwards</p>
<p>first = std::next(first, 20); // returns iterator to the element 20
position</p>
<p>forward</p>
<p>first = std::prev(first, 5); // returns iterator to the element 5
position</p>
<p>backward</p>
<p>auto dist = std::distance(my_vector.begin(), first); // returns
distance between two iterators.</p>
<p>Note, second argument of std::distance should be reachable from the
first one(or, in other words first should be</p>
<p>less or equal than second).</p>
<p>Even though you can perform arithmetic operators with iterators, not
all operations are defined for all types of</p>
<p>iterators. a = b + 3; would work for Random Access Iterators, but
wouldn't work for Forward or Bidirectional Iterators, which still can be
advanced by 3 position with something like b = a; ++b; ++b; ++b;. So it
is</p>
<p>recommended to use special functions in case you are not sure what is
iterator type (for example, in a template function accepting
iterator).</p>
<p>Iterator Concepts</p>
<p>The C++ standard describes several different iterator concepts. These
are grouped according to how they behave in the sequences they refer to.
If you know the concept an iterator <em>models</em> (behaves like), you
can be assured of the</p>
<p>behavior of that iterator <em>regardless of the sequence to which it
belongs</em>. They are often described in order from the most to least
restrictive (because the next iterator concept is a step better than its
predecessor):</p>
<p>Input Iterators : Can be dereferenced <em>only once</em> per
position. Can only advance, and only one position at a time.</p>
<p>Forward Iterators : An input iterator that can be dereferenced any
number of times. Bidirectional Iterators : A forward iterator that can
also advance <em>backwards</em> one position at a time.</p>
<p>Random Access Iterators : A bidirectional iterator that can advance
forwards or backwards any number of positions at a time.</p>
<p>Contiguous Iterators (since C++17) : A random access iterator that
guaranties that underlying data is</p>
<p>contiguous in memory.</p>
<p>Algorithms can vary depending on the concept modeled by the iterators
they are given. For example, although random_shuffle can be implemented
for forward iterators, a more efficient variant that requires random
access</p>
<p>iterators could be provided.</p>
<p>Iterator traits</p>
<p>Iterator traits provide uniform interface to the properties of
iterators. They allow you to retrieve value, difference,</p>
<p>pointer, reference types and also category of iterator:</p>
<p>template</p>
<p>Iter find(Iter first, Iter last, typename
std::iterator_traits::value_type val) {</p>
<p>while (first != last) {</p>
<p>if (*first == val)</p>
<p>return first;</p>
<p>++first;</p>
<p>}</p>
<p>return last;</p>
<p>}</p>
<p>Category of iterator can be used to specialize algorithms:</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 37</p>
<p><span id="void_test_BidirIt_a__std__bidire"
class="anchor"></span>void test(BidirIt a,
std::bidirectional_iterator_tag) {</p>
<p>std::cout &lt;&lt; "Bidirectional iterator is used" &lt;&lt;
std::endl; }</p>
<p>template</p>
<p>void test(ForwIt a, std::forward_iterator_tag) {</p>
<p>std::cout &lt;&lt; "Forward iterator is used" &lt;&lt; std::endl;
}</p>
<p>template</p>
<p>void test(Iter a) {</p>
<p>test(a, typename std::iterator_traits::iterator_category()); }</p>
<p>Categories of iterators are basically iterators concepts, except
Contiguous Iterators don't have their own tag, since it</p>
<p>was found to break code.</p>
<p>Section 9.2: Vector Iterator</p>
<p>begin returns an iterator to the first element in the sequence
container.</p>
<p>end returns an iterator to the first element past the end.</p>
<p>If the vector object is const, both begin and end return a
const_iterator. If you want a const_iterator to be</p>
<p>returned even if your vector is not const, you can use cbegin and
cend.</p>
<p>Example:</p>
<p>#include</p>
<p>#include</p>
<p>int main() {</p>
<p>std::vector v = { 1, 2, 3, 4, 5 }; //intialize vector using an
initializer_list</p>
<p>for (std::vector::iterator it = v.begin(); it != v.end(); ++it) {
std::cout &lt;&lt; *it &lt;&lt; " ";</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>Output:</p>
<p>1 2 3 4 5</p>
<p>Section 9.3: Map Iterator</p>
<p>An iterator to the first element in the container.</p>
<p>If a map object is const-qualified, the function returns a
const_iterator. Otherwise, it returns an iterator.</p>
<p>// Create a map and insert some values</p>
<p>std::map mymap;</p>
<p>mymap['b'] = 100;</p>
<p>mymap['a'] = 200;</p>
<p>mymap['c'] = 300;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 38</p>
<p><span id="___Iterate_over_all_tuples" class="anchor"></span>//
Iterate over all tuples</p>
<p>for (std::map::iterator it = mymap.begin(); it != mymap.end();
++it)</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt;
it-&gt;second &lt;&lt; '<strong>\n</strong>';</p>
<p>Output:</p>
<p>a =&gt; 200</p>
<p>b =&gt; 100</p>
<p>c =&gt; 300</p>
<p>Section 9.4: Reverse Iterators</p>
<p>If we want to iterate backwards through a list or vector we can use a
reverse_iterator. A reverse iterator is made</p>
<p>from a bidirectional, or random access iterator which it keeps as a
member which can be accessed through base().</p>
<p>To iterate backwards use rbegin() and rend() as the iterators for the
end of the collection, and the start of the</p>
<p>collection respectively.</p>
<p>For instance, to iterate backwards use:</p>
<p>std::vector v{1, 2, 3, 4, 5};</p>
<p>for (std::vector::reverse_iterator it = v.rbegin(); it != v.rend();
++it) {</p>
<p>cout &lt;&lt; *it;</p>
<p>} // prints 54321</p>
<p>A reverse iterator can be converted to a forward iterator via the
base() member function. The relationship is that the reverse iterator
references one element past the base() iterator:</p>
<p>std::vector::reverse_iterator r = v.rbegin(); std::vector::iterator i
= r.base();</p>
<p>assert(&amp;*r == &amp;*(i-1)); // always true if r, (i-1) are
dereferenceable</p>
<p>// and are not proxy iterators</p>
<p>+---+---+---+---+---+---+---+</p>
<p>| | 1 | 2 | 3 | 4 | 5 | |</p>
<p>+---+---+---+---+---+---+---+</p>
<p>↑ ↑ ↑ ↑</p>
<p>| | | |</p>
<p>rend() | rbegin() end()</p>
<p>| rbegin().base()</p>
<p>begin()</p>
<p>rend().base()</p>
<p>In the visualization where iterators mark positions between elements,
the relationship is simpler:</p>
<p>+---+---+---+---+---+</p>
<p>| 1 | 2 | 3 | 4 | 5 |</p>
<p>+---+---+---+---+---+</p>
<p>↑ ↑</p>
<p>| |</p>
<p>| end()</p>
<p>| rbegin()</p>
<p>begin() rbegin().base()</p>
<p>rend()</p>
<p>rend().base()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 39</p>
<p><span id="Section_9_5__Stream_Iterators"
class="anchor"></span>Section 9.5: Stream Iterators</p>
<p>Stream iterators are useful when we need to read a sequence or print
formatted data from a container:</p>
<p>// Data stream. Any number of various whitespace characters will be
OK. std::istringstream istr("1<strong>\t</strong> 2 3 4");</p>
<p>std::vector v;</p>
<p>// Constructing stream iterators and copying data from stream into
vector. std::copy(</p>
<p>// Iterator which will read stream data as integers.</p>
<p>std::istream_iterator(istr),</p>
<p>// Default constructor produces end-of-stream iterator.</p>
<p>std::istream_iterator(),</p>
<p>std::back_inserter(v));</p>
<p>// Print vector contents.</p>
<p>std::copy(v.begin(), v.end(),</p>
<p>//Will print values to standard output as integers delimeted by " --
".</p>
<p>std::ostream_iterator(std::cout, " -- "));</p>
<p>The example program will print 1--2--3--4-- to standard output.</p>
<p>Section 9.6: C Iterators (Pointers)</p>
<p>// This creates an array with 5 values.</p>
<p>const int array[] = { 1, 2, 3, 4, 5 };</p>
<p>#ifdef BEFORE_CPP11</p>
<p>// You can use `sizeof` to determine how many elements are in an
array. const int* first = array;</p>
<p>const int* afterLast = first + sizeof(array) / sizeof(array[0]);</p>
<p>// Then you can iterate over the array by incrementing a pointer
until // it reaches past the end of our array.</p>
<p>for (const int* i = first; i &lt; afterLast; ++i) {</p>
<p>std::cout &lt;&lt; *i &lt;&lt; std::endl;</p>
<p>}</p>
<p>#else</p>
<p>// With C++11, you can let the STL compute the start and end
iterators: for (auto i = std::begin(array); i != std::end(array); ++i)
{</p>
<p>std::cout &lt;&lt; *i &lt;&lt; std::endl;</p>
<p>}</p>
<p>#endif</p>
<p>This code would output the numbers 1 through 5, one on each line like
this:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 40</p>
<p><span id="5" class="anchor"></span>5</p>
<p>Breaking It Down</p>
<p>const int array[] = { 1, 2, 3, 4, 5 };</p>
<p>This line creates a new integer array with 5 values. C arrays are
just pointers to memory where each value is stored together in a
contiguous block.</p>
<p>const int* first = array;</p>
<p>const int* afterLast = first + sizeof(array) / sizeof(array[0]);</p>
<p>These lines create two pointers. The first pointer is given the value
of the array pointer, which is the address of the first element in the
array. The sizeof operator when used on a C array returns the size of
the array in bytes.</p>
<p>Divided by the size of an element this gives the number of elements
in the array. We can use this to find the address of the block
<em>after</em> the array.</p>
<p>for (const int* i = first; i &lt; afterLast; ++i) {</p>
<p>Here we create a pointer which we will use as an iterator. It is
initialized with the address of the first element we</p>
<p>want to iterate over, and we'll continue to iterate as long as i is
less than afterLast, which means as long as i is pointing to an address
within array.</p>
<p>std::cout &lt;&lt; *i &lt;&lt; std::endl;</p>
<p>Finally, within the loop we can access the value our iterator i is
pointing to by dereferencing it. Here the</p>
<p>dereference operator * returns the value at the address in i.</p>
<p>Section 9.7: Write your own generator-backed iterator</p>
<p>A common pattern in other languages is having a function that
produces a "stream" of objects, and being able to</p>
<p>use loop-code to loop over it.</p>
<p>We can model this in C++ as</p>
<p>template</p>
<p>struct generator_iterator {</p>
<p>using difference_type=std::ptrdiff_t;</p>
<p>using value_type=T;</p>
<p>using pointer=T*;</p>
<p>using reference=T;</p>
<p>using iterator_category=std::input_iterator_tag;</p>
<p>std::optional state;</p>
<p>std::function&lt; std::optional() &gt; operation;</p>
<p>// we store the current element in "state" if we have one:</p>
<p>T operator*() const {</p>
<p>return *state;</p>
<p>}</p>
<p>// to advance, we invoke our operation. If it returns a nullopt // we
have reached the end:</p>
<p>generator_iterator&amp; operator++() {</p>
<p>state = operation();</p>
<p>return *this;</p>
<p>}</p>
<p>generator_iterator operator++(int) {</p>
<p>auto r = *this;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 41</p>
<p>++(*this);</p>
<p>return r;</p>
<p>}</p>
<p>// generator iterators are only equal if they are both in the "end"
state: friend bool operator==( generator_iterator const&amp; lhs,
generator_iterator const&amp; rhs ) {</p>
<p>if (!lhs.state &amp;&amp; !rhs.state) return true;</p>
<p>return false;</p>
<p>}</p>
<p>friend bool operator!=( generator_iterator const&amp; lhs,
generator_iterator const&amp; rhs ) {</p>
<p>return !(lhs==rhs);</p>
<p>}</p>
<p>// We implicitly construct from a std::function with the right
signature:</p>
<p>generator_iterator( std::function&lt; std::optional() &gt; f
):operation(std::move(f))</p>
<p>{</p>
<p>if (operation)</p>
<p>state = operation();</p>
<p>}</p>
<p>// default all special member functions:</p>
<p>generator_iterator( generator_iterator &amp;&amp; ) =default;
generator_iterator( generator_iterator const&amp; ) =default;
generator_iterator&amp; operator=( generator_iterator &amp;&amp; )
=default; generator_iterator&amp; operator=( generator_iterator
const&amp; ) =default; generator_iterator() =default;</p>
<p>};</p>
<p><a href="http://coliru.stacked-crooked.com/a/cbb93f9ff193cdba">live
example.</a></p>
<p>We store the generated element early so we can more easily detect if
we are already at the end.</p>
<p>As the function of an end generator iterator is never used, we can
create a range of generator iterators by only</p>
<p>copying the std::function once. A default constructed generator
iterator compares equal to itself, and to all other
end-generator-iterators.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 42</p>
<p><span id="Chapter_10__Basic_input_output_i_1"
class="anchor"></span>Chapter 10: Basic input/output in c++</p>
<p>Section 10.1: user input and standard output</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>int value;</p>
<p>std::cout &lt;&lt; "Enter a value: " &lt;&lt; std::endl;</p>
<p>std::cin &gt;&gt; value;</p>
<p>std::cout &lt;&lt; "The square of entered value is: " &lt;&lt; value
* value &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 43</p>
<p><span id="Chapter_11__Loops_1" class="anchor"></span>Chapter 11:
Loops</p>
<p>A loop statement executes a group of statements repeatedly until a
condition is met. There are 3 types of primitive</p>
<p>loops in C++: for, while, and do...while.</p>
<p>Section 11.1: Range-Based For</p>
<p>Version ≥ C++11</p>
<p>for loops can be used to iterate over the elements of a
iterator-based range, without using a numeric index or directly
accessing the iterators:</p>
<p>vector v = {0.4f, 12.5f, 16.234f};</p>
<p>for(auto val: v)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>This will iterate over every element in v, with val getting the value
of the current element. The following statement:</p>
<p>for (for-range-declaration : for-range-initializer ) statement</p>
<p>is equivalent to:</p>
<p>{</p>
<p>auto&amp;&amp; __range = for-range-initializer;</p>
<p>auto __begin = begin-expr, __end = end-expr;</p>
<p>for (; __begin != __end; ++__begin) {</p>
<p>for-range-declaration = *__begin;</p>
<p>statement</p>
<p>}</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>{</p>
<p>auto&amp;&amp; __range = for-range-initializer;</p>
<p>auto __begin = begin-expr;</p>
<p>auto __end = end-expr; // end is allowed to be a different type than
begin in C++17 for (; __begin != __end; ++__begin) {</p>
<p>for-range-declaration = *__begin;</p>
<p>statement</p>
<p>}</p>
<p>}</p>
<p>This change was introduced for the planned support of Ranges TS in
C++20.</p>
<p>In this case, our loop is equivalent to:</p>
<p>{</p>
<p>auto&amp;&amp; __range = v;</p>
<p>auto __begin = v.begin(), __end = v.end();</p>
<p>for (; __begin != __end; ++__begin) {</p>
<p>auto val = *__begin;</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 44</p>
<p>}</p>
<p>}</p>
<p>Note that auto val declares a value type, which will be a copy of a
value stored in the range (we are copy-initializing</p>
<p>it from the iterator as we go). If the values stored in the range are
expensive to copy, you may want to use const auto &amp;val. You are also
not required to use auto; you can use an appropriate typename, so long
as it is implicitly</p>
<p>convertible from the range's value type.</p>
<p>If you need access to the iterator, range-based for cannot help you
(not without some effort, at least).</p>
<p>If you wish to reference it, you may do so:</p>
<p>vector v = {0.4f, 12.5f, 16.234f};</p>
<p>for(float &amp;val: v)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>You could iterate on const reference if you have const container:</p>
<p>const vector v = {0.4f, 12.5f, 16.234f};</p>
<p>for(const float &amp;val: v)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>One would use forwarding references when the sequence iterator
returns a proxy object and you need to operate</p>
<p>on that object in a non-const way. Note: it will most likely confuse
readers of your code.</p>
<p>vector v(10);</p>
<p>for(auto&amp;&amp; val: v)</p>
<p>{</p>
<p>val = true;</p>
<p>}</p>
<p>The "range" type provided to range-based for can be one of the
following:</p>
<p>Language arrays:</p>
<p>float arr[] = {0.4f, 12.5f, 16.234f};</p>
<p>for(auto val: arr)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>Note that allocating a dynamic array does not count:</p>
<p>float *arr = new float[3]{0.4f, 12.5f, 16.234f};</p>
<p>for(auto val: arr) //Compile error.</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 45</p>
<p><span id="Any_type_which_has_member_functi" class="anchor"></span>Any
type which has member functions begin() and end(), which return
iterators to the elements of the type. The standard library containers
qualify, but user-defined types can be used as well:</p>
<p>struct Rng</p>
<p>{</p>
<p>float arr[3];</p>
<p>// pointers are iterators</p>
<p>const float* begin() const {return &amp;arr[0];}</p>
<p>const float* end() const {return &amp;arr[3];}</p>
<p>float* begin() {return &amp;arr[0];}</p>
<p>float* end() {return &amp;arr[3];}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Rng rng = {{0.4f, 12.5f, 16.234f}};</p>
<p>for(auto val: rng)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>}</p>
<p>Any type which has non-member begin(type) and end(type) functions
which can found via argument dependent lookup, based on type. This is
useful for creating a range type without having to modify class type</p>
<p>itself:</p>
<p>namespace Mine</p>
<p>{</p>
<p>struct Rng {float arr[3];};</p>
<p>// pointers are iterators</p>
<p>const float* begin(const Rng &amp;rng) {return &amp;rng.arr[0];}
const float* end(const Rng &amp;rng) {return &amp;rng.arr[3];} float*
begin(Rng &amp;rng) {return &amp;rng.arr[0];}</p>
<p>float* end(Rng &amp;rng) {return &amp;rng.arr[3];}</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>Mine::Rng rng = {{0.4f, 12.5f, 16.234f}};</p>
<p>for(auto val: rng)</p>
<p>{</p>
<p>std::cout &lt;&lt; val &lt;&lt; " ";</p>
<p>}</p>
<p>}</p>
<p>Section 11.2: For loop</p>
<p>A for loop executes statements in the loop body, while the loop
condition is true. Before the loop initialization</p>
<p>statement is executed exactly once. After each cycle, the iteration
execution part is executed.</p>
<p>A for loop is defined as follows:</p>
<p><em>for (</em>/*initialization statement*/<em>;</em>
/*condition*/<em>;</em> /*iteration execution*/<em>)</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 46</p>
<p>{</p>
<p>// body of the loop</p>
<p>}</p>
<p>Explanation of the placeholder statements:</p>
<p>initialization statement: This statement gets executed only once, at
the beginning of the for loop. You</p>
<p>can enter a declaration of multiple variables of one type, such as
int i = 0, a = 2, b = 3. These variables are only valid in the scope of
the loop. Variables defined before the loop with the same name are
hidden</p>
<p>during execution of the loop.</p>
<p>condition : This statement gets evaluated ahead of each <em>loop
body</em> execution, and aborts the loop if it</p>
<p>evaluates to false.</p>
<p>iteration execution : This statement gets executed after the loop
<em>body</em>, ahead of the next <em>condition</em></p>
<p>evaluation, unless the for loop is aborted in the <em>body</em> (by
break, goto, return or an exception being thrown).</p>
<p>You can enter multiple statements in the iteration execution part,
such as a++, b+=10, c=b+a.</p>
<p>The rough equivalent of a for loop, rewritten as a while loop is:</p>
<p>/*initialization*/</p>
<p><em>while (</em>/*condition*/<em>)</em></p>
<p>{</p>
<p>// body of the loop; using 'continue' will skip to increment part
below <em>/*iteration execution*/</em></p>
<p>}</p>
<p>The most common case for using a for loop is to execute statements a
specific number of times. For example,</p>
<p>consider the following:</p>
<p>for(int i = 0; i &lt; 10; i++) {</p>
<p>std::cout &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p>A valid loop is also:</p>
<p>for(int a = 0, b = 10, c = 20; (a+b+c &lt; 100); c--, b++, a+=c)
{</p>
<p>std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c
&lt;&lt; std::endl;</p>
<p>}</p>
<p>An example of hiding declared variables before a loop is:</p>
<p>int i = 99; //i = 99</p>
<p>for(int i = 0; i &lt; 10; i++) { //we declare a new variable i</p>
<p>//some operations, the value of i ranges from 0 to 9 during loop
execution</p>
<p>}</p>
<p>//after the loop is executed, we can access i with value of 99</p>
<p>But if you want to use the already declared variable and not hide it,
then omit the declaration part:</p>
<p>int i = 99; //i = 99</p>
<p>for(i = 0; i &lt; 10; i++) { //we are using already declared variable
i</p>
<p>//some operations, the value of i ranges from 0 to 9 during loop
execution</p>
<p>}</p>
<p>//after the loop is executed, we can access i with value of 10</p>
<p>Notes:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 47</p>
<p><span id="The_initialization_and_increment" class="anchor"></span>The
initialization and increment statements can perform operations unrelated
to the condition statement, or nothing at all - if you wish to do so.
But for readability reasons, it is best practice to only perform
operations</p>
<p>directly relevant to the loop.</p>
<p>A variable declared in the initialization statement is visible only
inside the scope of the for loop and is released upon termination of the
loop.</p>
<p>Don't forget that the variable which was declared in the
initialization statement can be modified during the loop, as well as the
variable checked in the condition.</p>
<p>Example of a loop which counts from 0 to 10:</p>
<p>for (int counter = 0; counter &lt;= 10; ++counter)</p>
<p>{</p>
<p>std::cout &lt;&lt; counter &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>// counter is not accessible here (had value 11 at the end)</p>
<p>Explanation of the code fragments:</p>
<p>int counter = 0 initializes the variable counter to 0. (This variable
can only be used inside of the for loop.) counter &lt;= 10 is a Boolean
condition that checks whether counter is less than or equal to 10. If it
is true,</p>
<p>the loop executes. If it is false, the loop ends.</p>
<p>++counter is an increment operation that increments the value of
counter by 1 ahead of the next condition</p>
<p>check.</p>
<p>By leaving all statements empty, you can create an infinite loop:</p>
<p>// infinite loop</p>
<p>for (;;)</p>
<p>std::cout &lt;&lt; "Never ending!<strong>\n</strong>";</p>
<p>The while loop equivalent of the above is:</p>
<p>// infinite loop</p>
<p>while (true)</p>
<p>std::cout &lt;&lt; "Never ending!<strong>\n</strong>";</p>
<p>However, an infinite loop can still be left by using the statements
break, goto, or return or by throwing an exception.</p>
<p>The next common example of iterating over all elements from an STL
collection (e.g., a vector) without using the
<strong>&lt;algorithm&gt;</strong> header is:</p>
<p>std::vector names = {"Albert Einstein", "Stephen Hawking", "Michael
Ellis"}; for(std::vector::iterator it = names.begin(); it !=
names.end(); ++it) {</p>
<p>std::cout &lt;&lt; *it &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 11.3: While loop</p>
<p>A while loop executes statements repeatedly until the given condition
evaluates to false. This control statement is used when it is not known,
in advance, how many times a block of code is to be executed.</p>
<p>For example, to print all the numbers from 0 up to 9, the following
code can be used:</p>
<p>int i = 0;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 48</p>
<p><span id="while__i___10" class="anchor"></span>while (i &lt; 10)</p>
<p>{</p>
<p>std::cout &lt;&lt; i &lt;&lt; " ";</p>
<p>++i; // Increment counter</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl; // End of line; "0 1 2 3 4 5 6 7 8 9"
is printed to the console</p>
<p>Version ≥ C++17</p>
<p>Note that since C++17, the first 2 statements can be combined</p>
<p>while (int i = 0; i &lt; 10)</p>
<p>//... The rest is the same</p>
<p>To create an infinite loop, the following construct can be used:</p>
<p>while (true)</p>
<p>{</p>
<p>// Do something forever (however, you can exit the loop by calling
'break'</p>
<p>}</p>
<p>There is another variant of while loops, namely the do...while
construct. See the do-while loop example for more information.</p>
<p>Section 11.4: Do-while loop</p>
<p>A <em>do-while</em> loop is very similar to a <em>while</em> loop,
except that the condition is checked at the end of each cycle, not at
the start. The loop is therefore guaranteed to execute at least
once.</p>
<p>The following code will print 0, as the condition will evaluate to
false at the end of the first iteration:</p>
<p>int i =0;</p>
<p>do</p>
<p>{</p>
<p>std::cout &lt;&lt; i;</p>
<p>++i; // Increment counter</p>
<p>}</p>
<p>while (i &lt; 0);</p>
<p>std::cout &lt;&lt; std::endl; // End of line; 0 is printed to the
console</p>
<p>Note: Do not forget the semicolon at the end of while(condition);,
which is needed in the <em>do-while</em> construct.</p>
<p>In contrast to the <em>do-while</em> loop, the following will not
print anything, because the condition evaluates to false at</p>
<p>the beginning of the first iteration:</p>
<p>int i =0;</p>
<p>while (i &lt; 0)</p>
<p>{</p>
<p>std::cout &lt;&lt; i;</p>
<p>++i; // Increment counter</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl; // End of line; nothing is printed to
the console</p>
<p>Note: A <em>while</em> loop can be exited without the condition
becoming false by using a break, goto, or return statement.</p>
<p>int i = 0;</p>
<p>do</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 49</p>
<p><span id="std__cout____i" class="anchor"></span>std::cout &lt;&lt;
i;</p>
<p>++i; // Increment counter</p>
<p>if (i &gt; 5)</p>
<p>{</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>while (true);</p>
<p>std::cout &lt;&lt; std::endl; // End of line; 0 1 2 3 4 5 is printed
to the console</p>
<p>A trivial <em>do-while</em> loop is also occasionally used to write
macros that require their own scope (in which case the trailing
semicolon is omitted from the macro definition and required to be
provided by the user):</p>
<p>#define BAD_MACRO(x) f1(x); f2(x); f3(x);</p>
<p>// Only the call to f1 is protected by the condition here if (cond)
BAD_MACRO(var);</p>
<p>#define GOOD_MACRO(x) do { f1(x); f2(x); f3(x); } while(0)</p>
<p>// All calls are protected here</p>
<p>if (cond) GOOD_MACRO(var);</p>
<p>Section 11.5: Loop Control statements : Break and Continue</p>
<p>Loop control statements are used to change the flow of execution from
its normal sequence. When execution leaves a scope, all automatic
objects that were created in that scope are destroyed. The break and
continue are</p>
<p>loop control statements.</p>
<p>The break statement terminates a loop without any further
consideration.</p>
<p>for (int i = 0; i &lt; 10; i++)</p>
<p>{</p>
<p>if (i == 4)</p>
<p>break; // this will immediately exit our loop</p>
<p>std::cout &lt;&lt; i &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>The above code will print out:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>The continue statement does not immediately exit the loop, but rather
skips the rest of the loop body and goes to</p>
<p>the top of the loop (including checking the condition).</p>
<p>for (int i = 0; i &lt; 6; i++)</p>
<p>{</p>
<p>if (i % 2 == 0) // evaluates to true if i is even</p>
<p>continue; // this will immediately go back to the start of the
loop</p>
<p>/* the next line will only be reached if the above "continue"
statement</p>
<p>does not execute */</p>
<p>std::cout &lt;&lt; i &lt;&lt; " is an odd
number<strong>\n</strong>";</p>
<p>}</p>
<p>The above code will print out:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 50</p>
<p><span id="1_is_an_odd_number" class="anchor"></span>1 is an odd
number</p>
<p>3 is an odd number</p>
<p>5 is an odd number</p>
<p>Because such control flow changes are sometimes difficult for humans
to easily understand, break and continue</p>
<p>are used sparingly. More straightforward implementation are usually
easier to read and understand. For example, the first for loop with the
break above might be rewritten as:</p>
<p>for (int i = 0; i &lt; 4; i++)</p>
<p>{</p>
<p>std::cout &lt;&lt; i &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>The second example with continue might be rewritten as:</p>
<p>for (int i = 0; i &lt; 6; i++)</p>
<p>{</p>
<p>if (i % 2 != 0) {</p>
<p>std::cout &lt;&lt; i &lt;&lt; " is an odd
number<strong>\n</strong>";</p>
<p>}</p>
<p>}</p>
<p>Section 11.6: Declaration of variables in conditions</p>
<p>In the condition of the for and while loops, it's also permitted to
declare an object. This object will be considered to</p>
<p>be in scope until the end of the loop, and will persist through each
iteration of the loop:</p>
<p>for (int i = 0; i &lt; 5; ++i) {</p>
<p>do_something(i);</p>
<p>}</p>
<p>// i is no longer in scope.</p>
<p>for (auto&amp; a : some_container) {</p>
<p>a.do_something();</p>
<p>}</p>
<p>// a is no longer in scope.</p>
<p>while(std::shared_ptr p = get_object()) {</p>
<p>p-&gt;do_something();</p>
<p>}</p>
<p>// p is no longer in scope.</p>
<p>However, it is not permitted to do the same with a do...while loop;
instead, declare the variable before the loop,</p>
<p>and (optionally) enclose both the variable and the loop within a
local scope if you want the variable to go out of</p>
<p>scope after the loop ends:</p>
<p>//This doesn't compile</p>
<p>do {</p>
<p>s = do_something();</p>
<p>} while (short s &gt; 0);</p>
<p>// Good</p>
<p>short s;</p>
<p>do {</p>
<p>s = do_something();</p>
<p>} while (s &gt; 0);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 51</p>
<p><span id="This_is_because_the_statement_po"
class="anchor"></span>This is because the <em>statement</em> portion of
a do...while loop (the loop's body) is evaluated before the
<em>expression</em> portion (the while) is reached, and thus, any
declaration in the <em>expression</em> will not be visible during the
first iteration</p>
<p>of the loop.</p>
<p>Section 11.7: Range-for over a sub-range</p>
<p>Using range-base loops, you can loop over a sub-part of a given
container or other range by generating a proxy</p>
<p>object that qualifies for range-based for loops.</p>
<p>template</p>
<p>struct range_t {</p>
<p>Iterator b;</p>
<p>Sentinel e;</p>
<p>Iterator begin() const { return b; }</p>
<p>Sentinel end() const { return e; }</p>
<p>bool empty() const { return begin()==end(); }</p>
<p>range_t without_front( std::size_t count=1 ) const {</p>
<p>if (std::is_same&lt; std::random_access_iterator_tag, typename</p>
<p>std::iterator_traits::iterator_category &gt;{} ) {</p>
<p>count = (std::min)(std::size_t(std::distance(b,e)), count);</p>
<p>}</p>
<p>return {std::next(b, count), e};</p>
<p>}</p>
<p>range_t without_back( std::size_t count=1 ) const {</p>
<p>if (std::is_same&lt; std::random_access_iterator_tag, typename</p>
<p>std::iterator_traits::iterator_category &gt;{} ) {</p>
<p>count = (std::min)(std::size_t(std::distance(b,e)), count);</p>
<p>}</p>
<p>return {b, std::prev(e, count)};</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>range_t range( Iterator b, Sentinal e ) {</p>
<p>return {b,e};</p>
<p>}</p>
<p>template</p>
<p>auto range( Iterable&amp; r ) {</p>
<p>using std::begin; using std::end;</p>
<p>return range(begin(r),end(r));</p>
<p>}</p>
<p>template</p>
<p>auto except_first( C&amp; c ) {</p>
<p>auto r = range(c);</p>
<p>if (r.empty()) return r;</p>
<p>return r.without_front();</p>
<p>}</p>
<p>now we can do:</p>
<p>std::vector v = {1,2,3,4};</p>
<p>for (auto i : except_first(v))</p>
<p>std::cout &lt;&lt; i &lt;&lt; '<strong>\n</strong>';</p>
<p>and print out</p>
<p>2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 52</p>
<p>3</p>
<p>4</p>
<p>Be aware that intermediate objects generated in the
for(:range_expression) part of the for loop will have</p>
<p>expired by the time the for loop starts.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 53</p>
<p><span id="Chapter_12__File_I_O_1" class="anchor"></span>Chapter 12:
File I/O</p>
<p>C++ file I/O is done via <em>streams</em>. The key abstractions
are:</p>
<p>std::istream for reading text.</p>
<p>std::ostream for writing text.</p>
<p>std::streambuf for reading or writing characters.</p>
<p><em>Formatted input</em> uses operator&gt;&gt;.</p>
<p><em>Formatted output</em> uses operator&lt;&lt;.</p>
<p>Streams use std::locale, e.g., for details of the formatting and for
translation between external encodings and the</p>
<p>internal encoding.</p>
<p>More on streams: Library</p>
<p>Section 12.1: Writing to a file</p>
<p>There are several ways to write to a file. The easiest way is to use
an output file stream (ofstream) together with the stream insertion
operator (&lt;&lt;):</p>
<p>std::ofstream os("foo.txt");</p>
<p>if(os.is_open()){</p>
<p>os &lt;&lt; "Hello World!";</p>
<p>}</p>
<p>Instead of &lt;&lt;, you can also use the output file stream's member
function write():</p>
<p>std::ofstream os("foo.txt");</p>
<p>if(os.is_open()){</p>
<p>char data[] = "Foo";</p>
<p>// Writes 3 characters from data -&gt; "Foo".</p>
<p>os.write(data, 3);</p>
<p>}</p>
<p>After writing to a stream, you should always check if error state
flag badbit has been set, as it indicates whether the</p>
<p>operation failed or not. This can be done by calling the output file
stream's member function bad():</p>
<p>os &lt;&lt; "Hello Badbit!"; // This operation might fail for any
reason. if (os.bad())</p>
<p>// Failed to write!</p>
<p>Section 12.2: Opening a file</p>
<p>Opening a file is done in the same way for all 3 file streams
(ifstream, ofstream, and fstream).</p>
<p>You can open the file directly in the constructor:</p>
<p>std::ifstream ifs("foo.txt"); // ifstream: Opens file "foo.txt" for
reading only.</p>
<p>std::ofstream ofs("foo.txt"); // ofstream: Opens file "foo.txt" for
writing only.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 54</p>
<p><span id="std__fstream_iofs__foo_txt"
class="anchor"></span>std::fstream iofs("foo.txt"); // fstream: Opens
file "foo.txt" for reading and writing.</p>
<p>Alternatively, you can use the file stream's member function
open():</p>
<p>std::ifstream ifs;</p>
<p>ifs.open("bar.txt"); // ifstream: Opens file "bar.txt" for reading
only.</p>
<p>std::ofstream ofs;</p>
<p>ofs.open("bar.txt"); // ofstream: Opens file "bar.txt" for writing
only.</p>
<p>std::fstream iofs;</p>
<p>iofs.open("bar.txt"); // fstream: Opens file "bar.txt" for reading
and writing.</p>
<p>You should <strong>always</strong> check if a file has been opened
successfully (even when writing). Failures can include: the file</p>
<p>doesn't exist, file hasn't the right access rights, file is already
in use, disk errors occurred, drive disconnected ...</p>
<p>Checking can be done as follows:</p>
<p>// Try to read the file 'foo.txt'.</p>
<p>std::ifstream ifs("fooo.txt"); // Note the typo; the file can't be
opened.</p>
<p>// Check if the file has been opened successfully. if
(!ifs.is_open()) {</p>
<p>// The file hasn't been opened; take appropriate actions here. throw
CustomException(ifs, "File could not be opened");</p>
<p>}</p>
<p>When file path contains backslashes (for example, on Windows system)
you should properly escape them:</p>
<p>// Open the file 'c:\\folder\\foo.txt' on Windows. std::ifstream
ifs("c:<strong>\\\\</strong>folder<strong>\\\\</strong>foo.txt"); //
using escaped backslashes</p>
<p>Version ≥ C++11</p>
<p>or use raw literal:</p>
<p>// Open the file 'c:\\folder\\foo.txt' on Windows. std::ifstream
ifs(R"(c:\\folder\\foo.txt)"); // using raw literal</p>
<p>or use forward slashes instead:</p>
<p>// Open the file 'c:\\folder\\foo.txt' on Windows. std::ifstream
ifs("c:/folder/foo.txt");</p>
<p>Version ≥ C++11</p>
<p>If you want to open file with non-ASCII characters in path on Windows
currently you can use <strong>non-standard</strong> wide</p>
<p>character path argument:</p>
<p>// Open the file 'пример\\foo.txt' on Windows.</p>
<p>std::ifstream ifs(LR"(пример\\foo.txt)"); // using wide characters
with raw literal</p>
<p>Section 12.3: Reading from a file</p>
<p>There are several ways to read data from a file.</p>
<p>If you know how the data is formatted, you can use the stream
extraction operator (&gt;&gt;). Let's assume you have a file</p>
<p>named <em>foo.txt</em> which contains the following data:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 55</p>
<p>John Doe 25 4 6 1987</p>
<p>Jane Doe 15 5 24 1976</p>
<p>Then you can use the following code to read that data from the
file:</p>
<p>// Define variables.</p>
<p>std::ifstream is("foo.txt");</p>
<p>std::string firstname, lastname;</p>
<p>int age, bmonth, bday, byear;</p>
<p>// Extract firstname, lastname, age, bday month, bday day, and bday
year in that order. // Note: '&gt;&gt;' returns false if it reached EOF
(end of file) or if the input data doesn't // correspond to the type of
the input variable (for example, the string "foo" can't be // extracted
into an 'int' variable).</p>
<p>while (is &gt;&gt; firstname &gt;&gt; lastname &gt;&gt; age &gt;&gt;
bmonth &gt;&gt; bday &gt;&gt; byear)</p>
<p>// Process the data that has been read.</p>
<p>The stream extraction operator &gt;&gt; extracts every character and
stops if it finds a character that can't be stored or if</p>
<p>it is a special character:</p>
<p>For string types, the operator stops at a whitespace () or at a
newline (\n).</p>
<p>For numbers, the operator stops at a non-number character.</p>
<p>This means that the following version of the file <em>foo.txt</em>
will also be successfully read by the previous code:</p>
<p>John</p>
<p>Doe 25</p>
<p>4 6 1987</p>
<p>Jane</p>
<p>Doe</p>
<p>15 5</p>
<p>24</p>
<p>1976</p>
<p>The stream extraction operator &gt;&gt; always returns the stream
given to it. Therefore, multiple operators can be</p>
<p>chained together in order to read data consecutively. However, a
stream can also be used as a Boolean expression (as shown in the while
loop in the previous code). This is because the stream classes have a
conversion operator</p>
<p>for the type bool. This bool() operator will return true as long as
the stream has no errors. If a stream goes into an</p>
<p>error state (for example, because no more data can be extracted),
then the bool() operator will return false. Therefore, the while loop in
the previous code will be exited after the input file has been read to
its end.</p>
<p>If you wish to read an entire file as a string, you may use the
following code:</p>
<p>// Opens 'foo.txt'.</p>
<p>std::ifstream is("foo.txt");</p>
<p>std::string whole_file;</p>
<p>// Sets position to the end of the file.</p>
<p>is.seekg(0, std::ios::end);</p>
<p>// Reserves memory for the file.</p>
<p>whole_file.reserve(is.tellg());</p>
<p>// Sets position to the start of the file.</p>
<p>is.seekg(0, std::ios::beg);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 56</p>
<p><span id="___Sets_contents_of__whole_file" class="anchor"></span>//
Sets contents of 'whole_file' to all characters in the file.
whole_file.assign(std::istreambuf_iterator(is),
std::istreambuf_iterator());</p>
<p>This code reserves space for the string in order to cut down on
unneeded memory allocations.</p>
<p>If you want to read a file line by line, you can use the function <a
href="http://en.cppreference.com/w/cpp/string/basic_string/getline">getline()</a>:</p>
<p>std::ifstream is("foo.txt");</p>
<p>// The function getline returns false if there are no more lines. for
(std::string str; std::getline(is, str);) {</p>
<p>// Process the line that has been read.</p>
<p>}</p>
<p>If you want to read a fixed number of characters, you can use the
stream's member function read():</p>
<p>std::ifstream is("foo.txt");</p>
<p>char str[4];</p>
<p>// Read 4 characters from the file.</p>
<p>is.read(str, 4);</p>
<p>After executing a read command, you should always check if the error
state flag failbit has been set, as it</p>
<p>indicates whether the operation failed or not. This can be done by
calling the file stream's member function fail():</p>
<p>is.read(str, 4); // This operation might fail for any reason.</p>
<p>if (is.fail())</p>
<p>// Failed to read!</p>
<p>Section 12.4: Opening modes</p>
<p>When creating a file stream, you can specify an opening mode. An
opening mode is basically a setting to control how the stream opens the
file.</p>
<p>(All modes can be found in the std::ios namespace.)</p>
<p>An opening mode can be provided as second parameter to the
constructor of a file stream or to its open() member</p>
<p>function:</p>
<p>std::ofstream os("foo.txt", std::ios::out | std::ios::trunc);</p>
<p>std::ifstream is;</p>
<p>is.open("foo.txt", std::ios::in | std::ios::binary);</p>
<p>It is to be noted that you have to set ios::in or ios::out if you
want to set other flags as they are not implicitly set</p>
<p>by the iostream members although they have a correct default
value.</p>
<p>If you don't specify an opening mode, then the following default
modes are used:</p>
<p>ifstream - in</p>
<p>ofstream - out</p>
<p>fstream - in and out</p>
<p>The file opening modes that you may specify by design are:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 57</p>
<p><span id="Mode_Meaning____For" class="anchor"></span>Mode Meaning For
Description</p>
<p>app append Output Appends data at the end of the file.</p>
<p>binary binary Input/Output Input and output is done in binary.</p>
<p>in input Input Opens the file for reading.</p>
<p>out output Output Opens the file for writing.</p>
<p>trunc truncate Input/Output Removes contents of the file when
opening.</p>
<p>ate at end Input Goes to the end of the file when opening.</p>
<p><strong>Note:</strong> Setting the binary mode lets the data be
read/written exactly as-is; not setting it enables the translation
of</p>
<p>the newline '<strong>\n</strong>' character to/from a platform
specific end of line sequence.</p>
<p>For example on Windows the end of line sequence is CRLF
("<strong>\r\n</strong>").</p>
<p>Write: "<strong>\n</strong>" =&gt; "<strong>\r\n</strong>"</p>
<p>Read: "<strong>\r\n</strong>" =&gt; "<strong>\n</strong>"</p>
<p>Section 12.5: Reading an ASCII file into a std::string</p>
<p>std::ifstream f("file.txt");</p>
<p>if (f)</p>
<p>{</p>
<p>std::stringstream buffer;</p>
<p>buffer &lt;&lt; f.rdbuf();</p>
<p>f.close();</p>
<p>// The content of "file.txt" is available in the string
`buffer.str()`</p>
<p>}</p>
<p><a href="http://en.cppreference.com/w/cpp/io/basic_ios/rdbuf">The
rdbuf()</a> <a
href="http://en.cppreference.com/w/cpp/io/basic_streambuf">method
returns a pointer to a streambuf</a> that can be pushed into buffer via
the</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt">stringstream::operator&lt;&lt;
member function.</a></p>
<p>Another possibility (popularized in <a
href="http://rads.stackoverflow.com/amzn/click/0201749629">Effective STL
by</a> <a href="http://www.aristeia.com/">Scott Meyers</a>) is:</p>
<p>std::ifstream f("file.txt");</p>
<p>if (f)</p>
<p>{</p>
<p>std::string str((std::istreambuf_iterator(f)),</p>
<p>std::istreambuf_iterator());</p>
<p>// Operations on `str`...</p>
<p>}</p>
<p>This is nice because requires little code (and allows reading a file
directly into any STL container, not only strings) but can be slow for
big files.</p>
<p><strong>NOTE</strong>: the extra parentheses around the first
argument to the string constructor are essential to prevent the
<em>most</em></p>
<p>vexing parse <em>problem.</em></p>
<p>Last but not least:</p>
<p>std::ifstream f("file.txt");</p>
<p>if (f)</p>
<p>{</p>
<p>f.seekg(0, std::ios::end);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 58</p>
<p><span id="const_auto_size___f_tellg" class="anchor"></span>const auto
size = f.tellg();</p>
<p>std::string str(size, ' ');</p>
<p>f.seekg(0);</p>
<p>f.read(&amp;str[0], size);</p>
<p>f.close();</p>
<p>// Operations on `str`...</p>
<p>}</p>
<p>which is probably the fastest option (among the three proposed).</p>
<p>Section 12.6: Writing files with non-standard locale settings</p>
<p><a href="http://en.cppreference.com/w/cpp/locale/locale">If you need
to write a file using different locale settings to the default, you can
use std::locale</a> and</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/basic_ios/imbue">std::basic_ios::imbue()
to do that for a specific file stream:</a></p>
<p>Guidance for use:</p>
<p>You should always apply a local to a stream before opening the file.
Once the stream has been imbued you should not change the locale.</p>
<p><strong>Reasons for Restrictions:</strong> Imbuing a file stream with
a locale has undefined behavior if the current locale is not</p>
<p>state independent or not pointing at the beginning of the file.</p>
<p>UTF-8 streams (and others) are not state independent. Also a file
stream with a UTF-8 locale may try and read the</p>
<p>BOM marker from the file when it is opened; so just opening the file
may read characters from the file and it will</p>
<p>not be at the beginning.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "User-preferred locale setting is "</p>
<p>&lt;&lt; std::locale("").name().c_str() &lt;&lt; std::endl;</p>
<p>// Write a floating-point value using the user's preferred
locale.</p>
<p>std::ofstream ofs1;</p>
<p>ofs1.imbue(std::locale(""));</p>
<p>ofs1.open("file1.txt");</p>
<p>ofs1 &lt;&lt; 78123.456 &lt;&lt; std::endl;</p>
<p>// Use a specific locale (names are system-dependent)</p>
<p>std::ofstream ofs2;</p>
<p>ofs2.imbue(std::locale("en_US.UTF-8"));</p>
<p>ofs2.open("file2.txt");</p>
<p>ofs2 &lt;&lt; 78123.456 &lt;&lt; std::endl;</p>
<p>// Switch to the classic "C" locale</p>
<p>std::ofstream ofs3;</p>
<p>ofs3.imbue(std::locale::classic());</p>
<p>ofs3.open("file3.txt");</p>
<p>ofs3 &lt;&lt; 78123.456 &lt;&lt; std::endl;</p>
<p>}</p>
<p>Explicitly switching to the classic "C" locale is useful if your
program uses a different default locale and you want to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 59</p>
<p><span id="ensure_a_fixed_standard_for_read"
class="anchor"></span>ensure a fixed standard for reading and writing
files. With a "C" preferred locale, the example writes</p>
<p>78,123.456</p>
<p>78,123.456</p>
<p>78123.456</p>
<p>If, for example, the preferred locale is German and hence uses a
different number format, the example writes</p>
<p>78 123,456</p>
<p>78,123.456</p>
<p>78123.456</p>
<p>(note the decimal comma in the first line).</p>
<p>Section 12.7: Checking end of file inside a loop condition, bad</p>
<p>practice?</p>
<p><a href="http://en.cppreference.com/w/cpp/io/basic_ios/eof">eof
returns</a> true only <strong>after</strong> reading the end of file. It
does NOT indicate that the next read will be the end of stream.</p>
<p>while (!f.eof())</p>
<p>{</p>
<p>// Everything is OK</p>
<p>f &gt;&gt; buffer;</p>
<p>// What if *only* now the eof / fail bit is set?</p>
<p>/* Use `buffer` */</p>
<p>}</p>
<p>You could correctly write:</p>
<p>while (!f.eof())</p>
<p>{</p>
<p>f &gt;&gt; buffer &gt;&gt; std::ws;</p>
<p>if (f.fail())</p>
<p>break;</p>
<p>/* Use `buffer` */</p>
<p>}</p>
<p>but</p>
<p>while (f &gt;&gt; buffer)</p>
<p>{</p>
<p>/* Use `buffer` */</p>
<p>}</p>
<p>is simpler and less error prone.</p>
<p>Further references:</p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/ws">std::ws</a>:
discards leading whitespace from an input stream</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/basic_ios/fail">std::basic_ios::fail
: returns</a> true if an error has occurred on the associated stream</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 60</p>
<p><span id="Section_12_8__Flushing_a_stream"
class="anchor"></span>Section 12.8: Flushing a stream</p>
<p>File streams are buffered by default, as are many other types of
streams. This means that writes to the stream may</p>
<p>not cause the underlying file to change immediately. In oder to force
all buffered writes to take place immediately,</p>
<p>you can <em>flush</em> the stream. You can do this either directly by
invoking the flush() method or through the std::flush stream
manipulator:</p>
<p>std::ofstream os("foo.txt");</p>
<p>os &lt;&lt; "Hello World!" &lt;&lt; std::flush;</p>
<p>char data[3] = "Foo";</p>
<p>os.write(data, 3);</p>
<p>os.flush();</p>
<p>There is a stream manipulator std::endl that combines writing a
newline with flushing the stream:</p>
<p>// Both following lines do the same thing</p>
<p>os &lt;&lt; "Hello World!<strong>\n</strong>" &lt;&lt;
std::flush;</p>
<p>os &lt;&lt; "Hello world!" &lt;&lt; std::endl;</p>
<p>Buffering can improve the performance of writing to a stream.
Therefore, applications that do a lot of writing</p>
<p>should avoid flushing unnecessarily. Contrary, if I/O is done
infrequently, applications should consider flushing frequently in order
to avoid data getting stuck in the stream object.</p>
<p>Section 12.9: Reading a file into a container</p>
<p>In the example below we use std::string and operator&gt;&gt; to read
items from the file.</p>
<p>std::ifstream file("file3.txt");</p>
<p>std::vector v;</p>
<p>std::string s;</p>
<p>while(file &gt;&gt; s) // keep reading until we run out</p>
<p>{</p>
<p>v.push_back(s);</p>
<p>}</p>
<p>In the above example we are simply iterating through the file reading
one "item" at a time using operator&gt;&gt;. This</p>
<p>same affect can be achieved using the std::istream_iterator which is
an input iterator that reads one "item" at a time from the stream. Also
most containers can be constructed using two iterators so we can
simplify the above</p>
<p>code to:</p>
<p>std::ifstream file("file3.txt");</p>
<p>std::vector v(std::istream_iterator{file},</p>
<p>std::istream_iterator{});</p>
<p>We can extend this to read any object types we like by simply
specifying the object we want to read as the template</p>
<p>parameter to the std::istream_iterator. Thus we can simply extend the
above to read lines (rather than words) like this:</p>
<p>// Unfortunately there is no built in type that reads line using
&gt;&gt; // So here we build a simple helper class to do it. That will
convert // back to a string when used in string context.</p>
<p>struct Line</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 61</p>
<p><span id="_4" class="anchor"></span>{</p>
<p>// Store data here</p>
<p>std::string data;</p>
<p>// Convert object to string</p>
<p>operator std::string const&amp;() const {return data;}</p>
<p>// Read a line from a stream.</p>
<p>friend std::istream&amp; operator&gt;&gt;(std::istream&amp; stream,
Line&amp; line) {</p>
<p>return std::getline(stream, line.data);</p>
<p>}</p>
<p>};</p>
<p>std::ifstream file("file3.txt");</p>
<p>// Read the lines of a file into a container.</p>
<p>std::vector v(std::istream_iterator{file},</p>
<p>std::istream_iterator{});</p>
<p>Section 12.10: Copying a file</p>
<p>std::ifstream src("source_filename", std::ios::binary); std::ofstream
dst("dest_filename", std::ios::binary); dst &lt;&lt; src.rdbuf();</p>
<p>Version ≥ C++17</p>
<p>With C++17 the standard way to copy a file is including the <a
href="http://en.cppreference.com/w/cpp/filesystem"><strong>&lt;filesystem&gt;</strong></a>
header and using <a
href="http://en.cppreference.com/w/cpp/filesystem/copy_file">copy_file:</a></p>
<p>std::fileystem::copy_file("source_filename", "dest_filename");</p>
<p>The filesystem library was originally developed as boost.filesystem
and finally merged to ISO C++ as of C++17.</p>
<p>Section 12.11: Closing a file</p>
<p>Explicitly closing a file is rarely necessary in C++, as a file
stream will automatically close its associated file in its</p>
<p>destructor. However, you should try to limit the lifetime of a file
stream object, so that it does not keep the file handle open longer than
necessary. For example, this can be done by putting all file operations
into an own scope</p>
<p>({}):</p>
<p>std::string const prepared_data = prepare_data();</p>
<p>{</p>
<p>// Open a file for writing.</p>
<p>std::ofstream output("foo.txt");</p>
<p>// Write data.</p>
<p>output &lt;&lt; prepared_data;</p>
<p>} // The ofstream will go out of scope here.</p>
<p>// Its destructor will take care of closing the file properly.</p>
<p>Calling close() explicitly is only necessary if you want to reuse the
same fstream object later, but don't want to</p>
<p>keep the file open in between:</p>
<p>// Open the file "foo.txt" for the first time.</p>
<p>std::ofstream output("foo.txt");</p>
<p>// Get some data to write from somewhere.</p>
<p>std::string const prepared_data = prepare_data();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 62</p>
<p><span id="___Write_data_to_the_file__foo_t" class="anchor"></span>//
Write data to the file "foo.txt".</p>
<p>output &lt;&lt; prepared_data;</p>
<p>// Close the file "foo.txt".</p>
<p>output.close();</p>
<p>// Preparing data might take a long time. Therefore, we don't open
the output file stream // before we actually can write some data to
it.</p>
<p>std::string const more_prepared_data = prepare_complex_data();</p>
<p>// Open the file "foo.txt" for the second time once we are ready for
writing. output.open("foo.txt");</p>
<p>// Write the data to the file "foo.txt".</p>
<p>output &lt;&lt; more_prepared_data;</p>
<p>// Close the file "foo.txt" once again.</p>
<p>output.close();</p>
<p>Section 12.12: Reading a `struct` from a formatted text file</p>
<p>Version ≥ C++11</p>
<p>struct info_type</p>
<p>{</p>
<p>std::string name;</p>
<p>int age;</p>
<p>float height;</p>
<p>// we define an overload of operator&gt;&gt; as a friend function
which // gives in privileged access to private data members friend
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, info_type&amp;
info) {</p>
<p>// skip whitespace</p>
<p>is &gt;&gt; std::ws;</p>
<p>std::getline(is, info.name);</p>
<p>is &gt;&gt; info.age;</p>
<p>is &gt;&gt; info.height;</p>
<p>return is;</p>
<p>}</p>
<p>};</p>
<p>void func4()</p>
<p>{</p>
<p>auto file = std::ifstream("file4.txt");</p>
<p>std::vector v;</p>
<p>for(info_type info; file &gt;&gt; info;) // keep reading until we run
out {</p>
<p>// we only get here if the read succeeded</p>
<p>v.push_back(info);</p>
<p>}</p>
<p>for(auto const&amp; info: v)</p>
<p>{</p>
<p>std::cout &lt;&lt; " name: " &lt;&lt; info.name &lt;&lt;
'<strong>\n</strong>';</p>
<p>std::cout &lt;&lt; " age: " &lt;&lt; info.age &lt;&lt; " years"
&lt;&lt; '<strong>\n</strong>';</p>
<p>std::cout &lt;&lt; "height: " &lt;&lt; info.height &lt;&lt; "lbs"
&lt;&lt; '<strong>\n</strong>';</p>
<p>std::cout &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 63</p>
<p>file4.txt</p>
<p>Wogger Wabbit</p>
<p>2</p>
<p>6.2</p>
<p>Bilbo Baggins</p>
<p>111</p>
<p>81.3</p>
<p>Mary Poppins</p>
<p>29</p>
<p>154.8</p>
<p>Output:</p>
<p>name: Wogger Wabbit</p>
<p>age: 2 years</p>
<p>height: 6.2lbs</p>
<p>name: Bilbo Baggins</p>
<p>age: 111 years</p>
<p>height: 81.3lbs</p>
<p>name: Mary Poppins</p>
<p>age: 29 years</p>
<p>height: 154.8lbs</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 64</p>
<p><span id="Chapter_13__C___Streams_1" class="anchor"></span>Chapter
13: C++ Streams</p>
<p>Section 13.1: String streams</p>
<p><a
href="http://www.cplusplus.com/reference/sstream/ostringstream/">std::ostringstream</a>
is a class whose objects look like an output stream (that is, you can
write to them via operator&lt;&lt; ), but actually store the writing
results, and provide them in the form of a stream.</p>
<p>Consider the following short code:</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main()</p>
<p>{</p>
<p>ostringstream ss;</p>
<p>ss &lt;&lt; "the answer to everything is " &lt;&lt; 42;</p>
<p>const string result = ss.str();</p>
<p>}</p>
<p>The line</p>
<p>ostringstream ss;</p>
<p>creates such an object. This object is first manipulated like a
regular stream:</p>
<p>ss &lt;&lt; "the answer to everything is " &lt;&lt; 42;</p>
<p>Following that, though, the resulting stream can be obtained like
this:</p>
<p>const string result = ss.str();</p>
<p>(the string result will be equal to "the answer to everything is
42").</p>
<p>This is mainly useful when we have a class for which stream
serialization has been defined, and for which we want a string form. For
example, suppose we have some class</p>
<p>class foo</p>
<p>{</p>
<p>// All sort of stuff here.</p>
<p>};</p>
<p>ostream &amp;operator&lt;&lt;(ostream &amp;os, const foo &amp;f);</p>
<p>To get the string representation of a foo object,</p>
<p>foo f;</p>
<p>we could use</p>
<p>ostringstream ss;</p>
<p>ss &lt;&lt; f;</p>
<p>const string result = ss.str();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 65</p>
<p><span id="Then_result_contains_the_string" class="anchor"></span>Then
result contains the string representation of the foo object.</p>
<p>Section 13.2: Printing collections with iostream</p>
<p>Basic printing</p>
<p>std::ostream_iterator allows to print contents of an STL container to
any output stream without explicit loops.</p>
<p>The second argument of std::ostream_iterator constructor sets the
delimiter. For example, the following code:</p>
<p>std::vector v = {1,2,3,4};</p>
<p>std::copy(v.begin(), v.end(), std::ostream_iterator(std::cout, " !
"));</p>
<p>will print</p>
<p>1 ! 2 ! 3 ! 4 !</p>
<p>Implicit type cast</p>
<p>std::ostream_iterator allows to cast container's content type
implicitly. For example, let's tune std::cout to print</p>
<p>floating-point values with 3 digits after decimal point:</p>
<p>std::cout &lt;&lt; std::setprecision(3);</p>
<p>std::fixed(std::cout);</p>
<p>and instantiate std::ostream_iterator with float, while the contained
values remain int:</p>
<p>std::vector v = {1,2,3,4};</p>
<p>std::copy(v.begin(), v.end(), std::ostream_iterator(std::cout, " !
"));</p>
<p>so the code above yields</p>
<p>1.000 ! 2.000 ! 3.000 ! 4.000 !</p>
<p>despite std::vector holds ints.</p>
<p>Generation and transformation</p>
<p>std::generate, std::generate_n and std::transform functions provide a
very powerful tool for on-the-fly data</p>
<p>manipulation. For example, having a vector:</p>
<p>std::vector v = {1,2,3,4,8,16};</p>
<p>we can easily print boolean value of "x is even" statement for each
element:</p>
<p>std::boolalpha(std::cout); // print booleans alphabetically
std::transform(v.begin(), v.end(), std::ostream_iterator(std::cout, "
"), [](int val) {</p>
<p>return (val % 2) == 0;</p>
<p>});</p>
<p>or print the squared element:</p>
<p>std::transform(v.begin(), v.end(), std::ostream_iterator(std::cout, "
"), [](int val) {</p>
<p>return val * val;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 66</p>
<p>});</p>
<p>Printing N space-delimited random numbers:</p>
<p>const int N = 10;</p>
<p>std::generate_n(std::ostream_iterator(std::cout, " "), N,
std::rand);</p>
<p>Arrays</p>
<p>As in the section about reading text files, almost all these
considerations may be applied to native arrays. For</p>
<p>example, let's print squared values from a native array:</p>
<p>int v[] = {1,2,3,4,8,16};</p>
<p>std::transform(v, std::end(v), std::ostream_iterator(std::cout, " "),
[](int val) {</p>
<p>return val * val;</p>
<p>});</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 67</p>
<p><span id="Chapter_14__Stream_manipulators_1"
class="anchor"></span>Chapter 14: Stream manipulators</p>
<p>Manipulators are special helper functions that help controlling input
and output streams using operator &gt;&gt; or</p>
<p>operator &lt;&lt; .</p>
<p>They all can be included by #include .</p>
<p>Section 14.1: Stream manipulators</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/booalpha">std::boolalpha
and std::noboolalpha</a> - switch between textual and numeric
representation of booleans.</p>
<p>std::cout &lt;&lt; std::boolalpha &lt;&lt; 1;</p>
<p>// Output: true</p>
<p>std::cout &lt;&lt; std::noboolalpha &lt;&lt; false;</p>
<p>// Output: 0</p>
<p>bool boolValue;</p>
<p>std::cin &gt;&gt; std::boolalpha &gt;&gt; boolValue;</p>
<p>std::cout &lt;&lt; "Value <strong>\"</strong>" &lt;&lt;
std::boolalpha &lt;&lt; boolValue</p>
<p>&lt;&lt; "<strong>\"</strong> was parsed as " &lt;&lt;
std::noboolalpha &lt;&lt; boolValue;</p>
<p>// Input: true</p>
<p>// Output: Value "true" was parsed as 0</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/showbase">std::showbase
and std::noshowbase - control whether prefix indicating numeric base is
used.</a></p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/hex">std::dec
(decimal), std::hex</a> (hexadecimal) and <a
href="http://en.cppreference.com/w/cpp/io/manip/hex">std::oct (octal) -
are used for changing base for integers.</a></p>
<p>#include</p>
<p>std::cout &lt;&lt; std::dec &lt;&lt; 29 &lt;&lt; ' - '</p>
<p>&lt;&lt; std::hex &lt;&lt; 29 &lt;&lt; ' - '</p>
<p>&lt;&lt; std::showbase &lt;&lt; std::oct &lt;&lt; 29 &lt;&lt; ' -
'</p>
<p>&lt;&lt; std::noshowbase &lt;&lt; 29 '<strong>\n</strong>';</p>
<p>int number;</p>
<p>std::istringstream("3B") &gt;&gt; std::hex &gt;&gt; number;</p>
<p>std::cout &lt;&lt; std::dec &lt;&lt; 10;</p>
<p>// Output: 22 - 1D - 35 - 035</p>
<p>// 59</p>
<p>Default values are <a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">std::ios_base::noshowbase</a>
and <a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">std::ios_base::dec</a>.</p>
<p>If you want to see more about std::istringstream check out the &lt;<a
href="http://en.cppreference.com/w/cpp/header/sstream">sstream</a>&gt;
header.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/uppercase">std::uppercase
and std::nouppercase</a> - control whether uppercase characters are used
in floating-point and</p>
<p>hexadecimal integer output. Have no effect on input streams.</p>
<p>std::cout &lt;&lt; std::hex &lt;&lt; std::showbase</p>
<p>&lt;&lt; "0x2a with nouppercase: " &lt;&lt; std::nouppercase &lt;&lt;
0x2a &lt;&lt; '<strong>\n</strong>' &lt;&lt; "1e-10 with uppercase: "
&lt;&lt; std::uppercase &lt;&lt; 1e-10 &lt;&lt;
'<strong>\n</strong>'</p>
<p>}</p>
<p>// Output: 0x2a with nouppercase: 0x2a</p>
<p>// 1e-10 with uppercase: 1E-10</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 68</p>
<p>Default is std::nouppercase.</p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/setw">std::setw(n)
- changes the width of the next input/output field to exactly</a> n.</p>
<p>The width property n is resetting to 0 when some functions are called
(full list is <a
href="http://en.cppreference.com/w/cpp/io/manip/setw">here).</a></p>
<p>std::cout &lt;&lt; "no setw:" &lt;&lt; 51 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "setw(7): " &lt;&lt; std::setw(7) &lt;&lt; 51 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "setw(7), more output: " &lt;&lt; 13</p>
<p>&lt;&lt; std::setw(7) &lt;&lt; std::setfill('*') &lt;&lt; 67 &lt;&lt;
' ' &lt;&lt; 94 &lt;&lt; '<strong>\n</strong>';</p>
<p>char* input = "Hello, world!";</p>
<p>char arr[10];</p>
<p>std::cin &gt;&gt; std::setw(6) &gt;&gt; arr;</p>
<p>std::cout &lt;&lt; "Input from <strong>\"</strong>Hello,
world!<strong>\"</strong> with setw(6) gave <strong>\"</strong>"
&lt;&lt; arr &lt;&lt; "<strong>\"\n</strong>";</p>
<p>// Output: 51</p>
<p>// setw(7): 51</p>
<p>// setw(7), more output: 13*****67 94</p>
<p>// Input: Hello, world!</p>
<p>// Output: Input from "Hello, world!" with setw(6) gave "Hello"</p>
<p>Default is std::setw(0).</p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/left">std::left,
std::right</a> and <a
href="http://en.cppreference.com/w/cpp/io/manip/left">std::internal -
modify the default position of the fill characters by setting</a></p>
<p><a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">std::ios_base::adjustfield
to std::ios_base::left</a>, <a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">std::ios_base::right
and std::ios_base::internal</a></p>
<p>correspondingly. std::left and std::right apply to any output,
std::internal - for integer, floating-point and monetary output. Have no
effect on input streams.</p>
<p>#include</p>
<p>...</p>
<p>std::cout.imbue(std::locale("en_US.utf8"));</p>
<p>std::cout &lt;&lt; std::left &lt;&lt; std::showbase &lt;&lt;
std::setfill('*')</p>
<p>&lt;&lt; "flt: " &lt;&lt; std::setw(15) &lt;&lt;-9.87 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "hex: " &lt;&lt; std::setw(15) &lt;&lt; 41 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; " $: " &lt;&lt; std::setw(15) &lt;&lt; std::put_money(367,
false) &lt;&lt; '<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt;
std::setw(15) &lt;&lt; std::put_money(367, true) &lt;&lt;
'<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt; std::setw(15)</p>
<p>&lt;&lt; std::setfill(' ') &lt;&lt; std::put_money(367, false)
&lt;&lt; '<strong>\n</strong>';</p>
<p>// Output:</p>
<p>// flt: -9.87**********</p>
<p>// hex: 41*************</p>
<p>// $: $3.67**********</p>
<p>// usd: USD *3.67******</p>
<p>// usd: $3.67</p>
<p>std::cout &lt;&lt; std::internal &lt;&lt; std::showbase &lt;&lt;
std::setfill('*')</p>
<p>&lt;&lt; "flt: " &lt;&lt; std::setw(15) &lt;&lt;-9.87 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "hex: " &lt;&lt; std::setw(15) &lt;&lt; 41 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; " $: " &lt;&lt; std::setw(15) &lt;&lt; std::put_money(367,
false) &lt;&lt; '<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt;
std::setw(15) &lt;&lt; std::put_money(367, true) &lt;&lt;
'<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt; std::setw(15)</p>
<p>&lt;&lt; std::setfill(' ') &lt;&lt; std::put_money(367, true)
&lt;&lt; '<strong>\n</strong>';</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 69</p>
<p>// Output:</p>
<p>// flt: -**********9.87</p>
<p>// hex: *************41</p>
<p>// $: $3.67**********</p>
<p>// usd: USD *******3.67</p>
<p>// usd: USD 3.67</p>
<p>std::cout &lt;&lt; std::right &lt;&lt; std::showbase &lt;&lt;
std::setfill('*')</p>
<p>&lt;&lt; "flt: " &lt;&lt; std::setw(15) &lt;&lt;-9.87 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "hex: " &lt;&lt; std::setw(15) &lt;&lt; 41 &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; " $: " &lt;&lt; std::setw(15) &lt;&lt; std::put_money(367,
false) &lt;&lt; '<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt;
std::setw(15) &lt;&lt; std::put_money(367, true) &lt;&lt;
'<strong>\n</strong>' &lt;&lt; "usd: " &lt;&lt; std::setw(15)</p>
<p>&lt;&lt; std::setfill(' ') &lt;&lt; std::put_money(367, true)
&lt;&lt; '<strong>\n</strong>';</p>
<p>// Output:</p>
<p>// flt: **********-9.87</p>
<p>// hex: *************41</p>
<p>// $: **********$3.67</p>
<p>// usd: ******USD *3.67</p>
<p>// usd: USD 3.67</p>
<p>Default is std::left.</p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/fixed">std::fixed,
std::scientific, std::hexfloat [C++11] and std::defaultfloat</a> [C++11]
- change formatting for</p>
<p>floating-point input/output.</p>
<p>std::fixed <a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">sets the
std::ios_base::floatfield to std::ios_base::fixed,</a></p>
<p>std::scientific - to <a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">std::ios_base::scientific</a>,</p>
<p>std::hexfloat - to std::ios_base::fixed | std::ios_base::scientific
and</p>
<p>std::defaultfloat - to std::ios_base::fmtflags(0).</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">fmtflags</a></p>
<p>#include</p>
<p>...</p>
<p>std::cout &lt;&lt; '<strong>\n</strong>'</p>
<p>&lt;&lt; "The number 0.07 in fixed: " &lt;&lt; std::fixed &lt;&lt;
0.01 &lt;&lt; '<strong>\n</strong>' &lt;&lt; "The number 0.07 in
scientific: " &lt;&lt; std::scientific &lt;&lt; 0.01 &lt;&lt;
'<strong>\n</strong>' &lt;&lt; "The number 0.07 in hexfloat: " &lt;&lt;
std::hexfloat &lt;&lt; 0.01 &lt;&lt; '<strong>\n</strong>' &lt;&lt; "The
number 0.07 in default: " &lt;&lt; std::defaultfloat &lt;&lt; 0.01
&lt;&lt; '<strong>\n</strong>';</p>
<p>double f;</p>
<p>std::istringstream is("0x1P-1022");</p>
<p>double f = std::strtod(is.str().c_str(), NULL);</p>
<p>std::cout &lt;&lt; "Parsing 0x1P-1022 as hex gives " &lt;&lt; f
&lt;&lt; '<strong>\n</strong>';</p>
<p>// Output:</p>
<p>// The number 0.01 in fixed: 0.070000</p>
<p>// The number 0.01 in scientific: 7.000000e-02</p>
<p>// The number 0.01 in hexfloat: 0x1.1eb851eb851ecp-4 // The number
0.01 in default: 0.07</p>
<p>// Parsing 0x1P-1022 as hex gives 2.22507e-308</p>
<p>Default is std::ios_base::fmtflags(0).</p>
<p>There is a <strong>bug</strong> on some compilers which causes</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 70</p>
<p>double f;</p>
<p>std::istringstream("0x1P-1022") &gt;&gt; std::hexfloat &gt;&gt; f;
std::cout &lt;&lt; "Parsing 0x1P-1022 as hex gives " &lt;&lt; f &lt;&lt;
'<strong>\n</strong>'; // Output: Parsing 0x1P-1022 as hex gives 0</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/showpoint">std::showpoint
and std::noshowpoint</a> - control whether decimal point is always
included in floating-point</p>
<p>representation. Have no effect on input streams.</p>
<p>std::cout &lt;&lt; "7.0 with showpoint: " &lt;&lt; std::showpoint
&lt;&lt; 7.0 &lt;&lt; '<strong>\n</strong>'</p>
<p>&lt;&lt; "7.0 with noshowpoint: " &lt;&lt; std::noshowpoint &lt;&lt;
7.0 &lt;&lt; '<strong>\n</strong>';</p>
<p>// Output: 1.0 with showpoint: 7.00000</p>
<p>// 1.0 with noshowpoint: 7</p>
<p>Default is std::showpoint.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/showpos">std::showpos
and std::noshowpos - control displaying of the</a> + sign in
<em>non-negative</em> output. Have no effect on input streams.</p>
<p>std::cout &lt;&lt; "With showpos: " &lt;&lt; std::showpos</p>
<p>&lt;&lt; 0 &lt;&lt; ' ' &lt;&lt;-2.718 &lt;&lt; ' ' &lt;&lt; 17
&lt;&lt; '<strong>\n</strong>'</p>
<p>&lt;&lt; "Without showpos: " &lt;&lt; std::noshowpos</p>
<p>&lt;&lt; 0 &lt;&lt; ' ' &lt;&lt;-2.718 &lt;&lt; ' ' &lt;&lt; 17
&lt;&lt; '<strong>\n</strong>';</p>
<p>// Output: With showpos: +0 -2.718 +17</p>
<p>// Without showpos: 0 -2.718 17</p>
<p>Default if std::noshowpos.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/unitbuf">std::unitbuf,
std::nounitbuf - control flushing output stream after every operation.
Have no effect on input</a></p>
<p>stream. std::unitbuf causes flushing.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/setbase">std::setbase(base)</a>
- sets the numeric base of the stream.</p>
<p>std::setbase(8) equals to setting std::ios_base::basefield to
std::ios_base::oct, std::setbase(16) - to std::ios_base::hex,</p>
<p>std::setbase(10) - to std::ios_base::dec.</p>
<p>If base is other then 8, 10 or 16 then std::ios_base::basefield is
setting to std::ios_base::fmtflags(0). It</p>
<p>means decimal output and prefix-dependent input.</p>
<p>As default std::ios_base::basefield is std::ios_base::dec then by
default std::setbase(10).</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/setprecision">std::setprecision(n)
- changes floating-point precision.</a></p>
<p>#include</p>
<p>#include</p>
<p>...</p>
<p>typedef std::numeric_limits ld;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 71</p>
<p>const long double pi = std::acos(-1.L);</p>
<p>std::cout &lt;&lt; '<strong>\n</strong>'</p>
<p>&lt;&lt; "default precision (6): pi: " &lt;&lt; pi &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; " 10pi: " &lt;&lt; 10 * pi &lt;&lt;
'<strong>\n</strong>'</p>
<p>&lt;&lt; "std::setprecision(4): 10pi: " &lt;&lt; std::setprecision(4)
&lt;&lt; 10 * pi &lt;&lt; '<strong>\n</strong>' &lt;&lt; " 10000pi: "
&lt;&lt; 10000 * pi &lt;&lt; '<strong>\n</strong>' &lt;&lt; "std::fixed:
10000pi: " &lt;&lt; std::fixed &lt;&lt; 10000 * pi &lt;&lt;
std::defaultfloat &lt;&lt;</p>
<p>'<strong>\n</strong>'</p>
<p>&lt;&lt; "std::setprecision(10): pi: " &lt;&lt; std::setprecision(10)
&lt;&lt; pi &lt;&lt; '<strong>\n</strong>' &lt;&lt; "max-1 radix
precicion: pi: " &lt;&lt; std::setprecision(ld::digits-1) &lt;&lt; pi
&lt;&lt; '<strong>\n</strong>' &lt;&lt; "max+1 radix precision: pi: "
&lt;&lt; std::setprecision(ld::digits + 1) &lt;&lt; pi &lt;&lt;
'<strong>\n</strong>' &lt;&lt; "significant digits prec: pi: " &lt;&lt;
std::setprecision(ld::digits10) &lt;&lt; pi &lt;&lt;
'<strong>\n</strong>';</p>
<p>// Output:</p>
<p>// default precision (6): pi: 3.14159</p>
<p>// 10pi: 31.4159</p>
<p>// std::setprecision(4): 10pi: 31.42</p>
<p>// 10000pi: 3.142e+04</p>
<p>// std::fixed: 10000pi: 31415.9265</p>
<p>// std::setprecision(10): pi: 3.141592654</p>
<p>// max-1 radix precicion: pi:
3.14159265358979323851280895940618620443274267017841339111328125 //
max+1 radix precision: pi:
3.14159265358979323851280895940618620443274267017841339111328125 //
significant digits prec: pi: 3.14159265358979324</p>
<p>Default is std::setprecision(6).</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/setiosflags">std::setiosflags(mask)
and</a> <a
href="http://en.cppreference.com/w/cpp/io/manip/resetiosflags">std::resetiosflags(mask)
- set and clear flags specified in</a> mask of</p>
<p>std::ios_base::fmtflags type.</p>
<p>#include</p>
<p>...</p>
<p>std::istringstream in("10 010 10 010 10 010");</p>
<p>int num1, num2;</p>
<p>in &gt;&gt; std::oct &gt;&gt; num1 &gt;&gt; num2;</p>
<p>std::cout &lt;&lt; "Parsing <strong>\"</strong>10
010<strong>\"</strong> with std::oct gives: " &lt;&lt; num1 &lt;&lt; ' '
&lt;&lt; num2 &lt;&lt; '<strong>\n</strong>'; // Output: Parsing "10
010" with std::oct gives: 8 8</p>
<p>in &gt;&gt; std::dec &gt;&gt; num1 &gt;&gt; num2;</p>
<p>std::cout &lt;&lt; "Parsing <strong>\"</strong>10
010<strong>\"</strong> with std::dec gives: " &lt;&lt; num1 &lt;&lt; ' '
&lt;&lt; num2 &lt;&lt; '<strong>\n</strong>'; // Output: Parsing "10
010" with std::oct gives: 10 10</p>
<p>in &gt;&gt; std::resetiosflags(std::ios_base::basefield) &gt;&gt;
num1 &gt;&gt; num2; std::cout &lt;&lt; "Parsing <strong>\"</strong>10
010<strong>\"</strong> with autodetect gives: " &lt;&lt; num1 &lt;&lt; '
' &lt;&lt; num2 &lt;&lt; '<strong>\n</strong>'; // Parsing "10 010" with
autodetect gives: 10 8</p>
<p>std::cout &lt;&lt; std::setiosflags(std::ios_base::hex |</p>
<p>std::ios_base::uppercase |</p>
<p>std::ios_base::showbase) &lt;&lt; 42 &lt;&lt; '<strong>\n</strong>';
// Output: OX2A</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/skipws">std::skipws and
std::noskipws</a> - control skipping of leading whitespace by the
formatted input functions. Have no</p>
<p>effect on output streams.</p>
<p>#include</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 72</p>
<p><span id="_6" class="anchor"></span>...</p>
<p>char c1, c2, c3;</p>
<p>std::istringstream("a b c") &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; c3;</p>
<p>std::cout &lt;&lt; "Default behavior: c1 = " &lt;&lt; c1 &lt;&lt; "
c2 = " &lt;&lt; c2 &lt;&lt; " c3 = " &lt;&lt; c3 &lt;&lt;
'<strong>\n</strong>';</p>
<p>std::istringstream("a b c") &gt;&gt; std::noskipws &gt;&gt; c1
&gt;&gt; c2 &gt;&gt; c3; std::cout &lt;&lt; "noskipws behavior: c1 = "
&lt;&lt; c1 &lt;&lt; " c2 = " &lt;&lt; c2 &lt;&lt; " c3 = " &lt;&lt; c3
&lt;&lt; '<strong>\n</strong>'; // Output: Default behavior: c1 = a c2 =
b c3 = c // noskipws behavior: c1 = a c2 = c3 = b</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/ios_base/fmtflags">Default is
std::ios_base::skipws</a>.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted(s[,
delim[, escape]]) [C++14] - inserts or extracts quoted strings with
embedded spaces.</a></p>
<p>s - the string to insert or extract.</p>
<p>delim - the character to use as the delimiter, " by default.</p>
<p>escape - the character to use as the escape character, \ by
default.</p>
<p>#include</p>
<p>...</p>
<p>std::stringstream ss;</p>
<p>std::string in = "String with spaces, and embedded
<strong>\"</strong>quotes<strong>\"</strong> too"; std::string out;</p>
<p>ss &lt;&lt; std::quoted(in);</p>
<p>std::cout &lt;&lt; "read in [" &lt;&lt; in &lt;&lt;
"]<strong>\n</strong>"</p>
<p>&lt;&lt; "stored as [" &lt;&lt; ss.str() &lt;&lt;
"]<strong>\n</strong>";</p>
<p>ss &gt;&gt; std::quoted(out);</p>
<p>std::cout &lt;&lt; "written out [" &lt;&lt; out &lt;&lt;
"]<strong>\n</strong>";</p>
<p>// Output:</p>
<p>// read in [String with spaces, and embedded "quotes" too] // stored
as ["String with spaces, and embedded \"quotes\" too"] // written out
[String with spaces, and embedded "quotes" too]</p>
<p>For more information see the link above.</p>
<p>Section 14.2: Output stream manipulators</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/ends">std::ends</a> -
inserts a null character '<strong>\0</strong>' to output stream. More
formally this manipulator's declaration looks like</p>
<p>template</p>
<p>std::basic_ostream&amp; ends(std::basic_ostream&amp; os);</p>
<p>and this manipulator places character by calling os.put(charT()) when
used in an expression os &lt;&lt; std::ends;</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/endl">std::endl</a> and
<a href="http://en.cppreference.com/w/cpp/io/manip/flush">std::flush
both flush output stream</a> out by calling out.flush(). It causes
immediately producing</p>
<p>output. But std::endl inserts end of line '<strong>\n</strong>'
symbol before flushing.</p>
<p>std::cout &lt;&lt; "First line." &lt;&lt; std::endl &lt;&lt; "Second
line. " &lt;&lt; std::flush</p>
<p>&lt;&lt; "Still second line.";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 73</p>
<p>// Output: First line.</p>
<p>// Second line. Still second line.</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/setfill">std::setfill(c)</a>
- changes the fill character to c. Often used with std::setw.</p>
<p>std::cout &lt;&lt; "<strong>\n</strong>Default fill: " &lt;&lt;
std::setw(10) &lt;&lt; 79 &lt;&lt; '<strong>\n</strong>'</p>
<p>&lt;&lt; "setfill('#'): " &lt;&lt; std::setfill('#')</p>
<p>&lt;&lt; std::setw(10) &lt;&lt; 42 &lt;&lt;
'<strong>\n</strong>';</p>
<p>// Output:</p>
<p>// Default fill: 79</p>
<p>// setfill('#'): ########79</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/put_money">std::put_money(mon[,
intl])</a> [C++11]. In an expression out &lt;&lt; std::put_money(mon,
intl), converts the monetary value mon (of long double or
std::basic_string type) to its character representation as specified by
the</p>
<p><a
href="http://en.cppreference.com/w/cpp/locale/money_put">std::money_put
facet of the locale currently imbued in</a> out. Use international
currency strings if intl is true, use currency symbols otherwise.</p>
<p>long double money = 123.45;</p>
<p>// or std::string money = "123.45";</p>
<p>std::cout.imbue(std::locale("en_US.utf8"));</p>
<p>std::cout &lt;&lt; std::showbase &lt;&lt; "en_US: " &lt;&lt;
std::put_money(money)</p>
<p>&lt;&lt; " or " &lt;&lt; std::put_money(money, true) &lt;&lt;
'<strong>\n</strong>';</p>
<p>// Output: en_US: $1.23 or USD 1.23</p>
<p>std::cout.imbue(std::locale("ru_RU.utf8"));</p>
<p>std::cout &lt;&lt; "ru_RU: " &lt;&lt; std::put_money(money)</p>
<p>&lt;&lt; " or " &lt;&lt; std::put_money(money, true) &lt;&lt;
'<strong>\n</strong>';</p>
<p>// Output: ru_RU: 1.23 руб or 1.23 RUB</p>
<p>std::cout.imbue(std::locale("ja_JP.utf8"));</p>
<p>std::cout &lt;&lt; "ja_JP: " &lt;&lt; std::put_money(money)</p>
<p>&lt;&lt; " or " &lt;&lt; std::put_money(money, true) &lt;&lt;
'<strong>\n</strong>';</p>
<p>// Output: ja_JP: ￥123 or JPY 123</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/put_time">std::put_time(tmb,
fmt) [C++11] - formats and outputs a date/time value to</a> std::tm
according to the specified</p>
<p>format fmt.</p>
<p>tmb - pointer to the calendar time structure const std::tm* as
obtained from localtime() or gmtime().</p>
<p>fmt - pointer to a null-terminated string const CharT* specifying the
format of conversion.</p>
<p>#include</p>
<p>...</p>
<p>std::time_t t = std::time(nullptr);</p>
<p>std::tm tm = *std::localtime(&amp;t);</p>
<p>std::cout.imbue(std::locale("ru_RU.utf8"));</p>
<p>std::cout &lt;&lt; "<strong>\n</strong>ru_RU: " &lt;&lt;
std::put_time(&amp;tm, "%c %Z") &lt;&lt; '<strong>\n</strong>'; //
Possible output:</p>
<p>// ru_RU: Вт 04 июл 2017 15:08:35 UTC</p>
<p>For more information see the link above.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 74</p>
<p><span id="Section_14_3__Input_stream_manip"
class="anchor"></span>Section 14.3: Input stream manipulators</p>
<p><a href="http://en.cppreference.com/w/cpp/io/manip/ws">std::ws</a> -
consumes leading whitespaces in input stream. It different from
std::skipws.</p>
<p>#include</p>
<p>...</p>
<p>std::string str;</p>
<p>std::istringstream(" <strong>\v\n\r\t</strong> Wow!There is no
whitespaces!") &gt;&gt; std::ws &gt;&gt; str; std::cout &lt;&lt;
str;</p>
<p>// Output: Wow!There is no whitespaces!</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/get_money">std::get_money(mon[,
intl])</a> [C++11]. In an expression in &gt;&gt; std::get_money(mon,
intl) parses the character</p>
<p><a href="http://en.cppreference.com/w/cpp/locale/money_get">input as
a monetary value, as specified by the std::money_get facet of the locale
currently imbued in</a> in, and stores</p>
<p>the value in mon (of long double or std::basic_string type).
Manipulator expects <em>required</em> international currency strings if
intl is true, expects <em>optional</em> currency symbols otherwise.</p>
<p>#include</p>
<p>#include</p>
<p>...</p>
<p>std::istringstream in("$1,234.56 2.22 USD 3.33"); long double v1,
v2;</p>
<p>std::string v3;</p>
<p>in.imbue(std::locale("en_US.UTF-8"));</p>
<p>in &gt;&gt; std::get_money(v1) &gt;&gt; std::get_money(v2) &gt;&gt;
std::get_money(v3, true); if (in) {</p>
<p>std::cout &lt;&lt; std::quoted(in.str()) &lt;&lt; " parsed as: "</p>
<p>&lt;&lt; v1 &lt;&lt; ", " &lt;&lt; v2 &lt;&lt; ", " &lt;&lt; v3
&lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>// Output:</p>
<p>// "$1,234.56 2.22 USD 3.33" parsed as: 123456, 222, 333</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/get_time">std::get_time(tmb,
fmt) [C++11] - parses a date/time value stored in</a> tmb of specified
format fmt.</p>
<p>tmb - valid pointer to the const std::tm* object where the result
will be stored. fmt - pointer to a null-terminated string const CharT*
specifying the conversion format.</p>
<p>#include</p>
<p>#include</p>
<p>...</p>
<p>std::tm t = {};</p>
<p>std::istringstream ss("2011-Februar-18 23:12:34");</p>
<p>ss.imbue(std::locale("de_DE.utf-8"));</p>
<p>ss &gt;&gt; std::get_time(&amp;t, "%Y-%b-%d %H:%M:%S");</p>
<p>if (ss.fail()) {</p>
<p>std::cout &lt;&lt; "Parse failed<strong>\n</strong>";</p>
<p>}</p>
<p>else {</p>
<p>std::cout &lt;&lt; std::put_time(&amp;t, "%c") &lt;&lt;
'<strong>\n</strong>';</p>
<p>}</p>
<p>// Possible output:</p>
<p>// Sun Feb 18 23:12:34 2011</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 75</p>
<p>For more information see the link above.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 76</p>
<p><span id="Chapter_15__Flow_Control_1" class="anchor"></span>Chapter
15: Flow Control</p>
<p>Section 15.1: case</p>
<p>Introduces a case label of a switch statement. The operand must be a
constant expression and match the switch condition in type. When the
switch statement is executed, it will jump to the case label with
operand equal to the</p>
<p>condition, if any.</p>
<p>char c = getchar();</p>
<p>bool confirmed;</p>
<p>switch (c) {</p>
<p>case 'y':</p>
<p>confirmed = true;</p>
<p>break;</p>
<p>case 'n':</p>
<p>confirmed = false;</p>
<p>break;</p>
<p>default:</p>
<p>std::cout &lt;&lt; "invalid response!<strong>\n</strong>";</p>
<p>abort();</p>
<p>}</p>
<p>Section 15.2: switch</p>
<p>According to the C++ standard,</p>
<p>The switch statement causes control to be transferred to one of
several statements depending on the</p>
<p>value of a condition.</p>
<p>The keyword switch is followed by a parenthesized condition and a
block, which may contain case labels and an</p>
<p>optional default label. When the switch statement is executed,
control will be transferred either to a case label with a value matching
that of the condition, if any, or to the default label, if any.</p>
<p>The condition must be an expression or a declaration, which has
either integer or enumeration type, or a class type with a conversion
function to integer or enumeration type.</p>
<p>char c = getchar();</p>
<p>bool confirmed;</p>
<p>switch (c) {</p>
<p>case 'y':</p>
<p>confirmed = true;</p>
<p>break;</p>
<p>case 'n':</p>
<p>confirmed = false;</p>
<p>break;</p>
<p>default:</p>
<p>std::cout &lt;&lt; "invalid response!<strong>\n</strong>";</p>
<p>abort();</p>
<p>}</p>
<p>Section 15.3: catch</p>
<p>The catch keyword introduces an exception handler, that is, a block
into which control will be transferred when an exception of compatible
type is thrown. The catch keyword is followed by a parenthesized
<em>exception declaration</em>,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 77</p>
<p><span id="which_is_similar_in_form_to_a_fu"
class="anchor"></span>which is similar in form to a function parameter
declaration: the parameter name may be omitted, and the ellipsis ... is
allowed, which matches any type. The exception handler will only handle
the exception if its declaration is</p>
<p>compatible with the type of the exception. For more details, see
catching exceptions.</p>
<p>try {</p>
<p>std::vector v(N);</p>
<p>// do something</p>
<p>} catch (const std::bad_alloc&amp;) {</p>
<p>std::cout &lt;&lt; "failed to allocate memory for vector!" &lt;&lt;
std::endl; } catch (const std::runtime_error&amp; e) {</p>
<p>std::cout &lt;&lt; "runtime error: " &lt;&lt; e.what() &lt;&lt;
std::endl; } catch (...) {</p>
<p>std::cout &lt;&lt; "unexpected exception!" &lt;&lt; std::endl;</p>
<p>throw;</p>
<p>}</p>
<p>Section 15.4: throw</p>
<p>1. When throw occurs in an expression with an operand, its effect is
to throw an exception, which is a copy of</p>
<p>the operand.</p>
<p>void print_asterisks(int count) {</p>
<p>if (count &lt; 0) {</p>
<p>throw std::invalid_argument("count cannot be negative!");</p>
<p>}</p>
<p>while (count--) { putchar('*'); }</p>
<p>}</p>
<p>2. When throw occurs in an expression without an operand, its effect
is to rethrow the current exception. If</p>
<p>there is no current exception, std::terminate is called.</p>
<p>try {</p>
<p>// something risky</p>
<p>} catch (const std::bad_alloc&amp;) {</p>
<p>std::cerr &lt;&lt; "out of memory" &lt;&lt; std::endl;</p>
<p>} catch (...) {</p>
<p>std::cerr &lt;&lt; "unexpected exception" &lt;&lt; std::endl;</p>
<p>// hope the caller knows how to handle this exception throw;</p>
<p>}</p>
<p>3. When throw occurs in a function declarator, it introduces a
dynamic exception specification, which lists the</p>
<p>types of exceptions that the function is allowed to propagate.</p>
<p>// this function might propagate a std::runtime_error, // but not,
say, a std::logic_error</p>
<p>void risky() throw(std::runtime_error);</p>
<p>// this function can't propagate any exceptions</p>
<p>void safe() throw();</p>
<p>Dynamic exception specifications are deprecated as of C++11.</p>
<p>Note that the first two uses of throw listed above constitute
expressions rather than statements. (The type of a</p>
<p>throw expression is void.) This makes it possible to nest them within
expressions, like so:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 78</p>
<p><span id="unsigned_int_predecessor_unsigne"
class="anchor"></span>unsigned int predecessor(unsigned int x) {</p>
<p>return (x &gt; 0) ? (x -1) : (throw std::invalid_argument("0 has no
predecessor"));</p>
<p>}</p>
<p>Section 15.5: default</p>
<p>In a switch statement, introduces a label that will be jumped to if
the condition's value is not equal to any of the</p>
<p>case labels' values.</p>
<p>char c = getchar();</p>
<p>bool confirmed;</p>
<p>switch (c) {</p>
<p>case 'y':</p>
<p>confirmed = true;</p>
<p>break;</p>
<p>case 'n':</p>
<p>confirmed = false;</p>
<p>break;</p>
<p>default:</p>
<p>std::cout &lt;&lt; "invalid response!<strong>\n</strong>";</p>
<p>abort();</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>Defines a default constructor, copy constructor, move constructor,
destructor, copy assignment operator, or move</p>
<p>assignment operator to have its default behaviour.</p>
<p>class Base {</p>
<p>// ...</p>
<p>// we want to be able to delete derived classes through Base*, // but
have the usual behaviour for Base's destructor. virtual ~Base() =
default;</p>
<p>};</p>
<p>Section 15.6: try</p>
<p>The keyword try is followed by a block, or by a constructor
initializer list and then a block (see here). The try block is</p>
<p>followed by one or more catch blocks. If an exception propagates out
of the try block, each of the corresponding catch blocks after the try
block has the opportunity to handle the exception, if the types
match.</p>
<p>std::vector v(N); // if an exception is thrown here,</p>
<p>// it will not be caught by the following catch block</p>
<p>try {</p>
<p>std::vector v(N); // if an exception is thrown here,</p>
<p>// it will be caught by the following catch block</p>
<p>// do something with v</p>
<p>} catch (const std::bad_alloc&amp;) {</p>
<p>// handle bad_alloc exceptions from the try block</p>
<p>}</p>
<p>Section 15.7: if</p>
<p>Introduces an if statement. The keyword if must be followed by a
parenthesized condition, which can be either an expression or a
declaration. If the condition is truthy, the substatement after the
condition will be executed.</p>
<p>int x;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 79</p>
<p><span id="std__cout_____Please_enter_a_pos"
class="anchor"></span>std::cout &lt;&lt; "Please enter a positive
number." &lt;&lt; std::endl; std::cin &gt;&gt; x;</p>
<p>if (x &lt;= 0) {</p>
<p>std::cout &lt;&lt; "You didn't enter a positive number!" &lt;&lt;
std::endl;</p>
<p>abort();</p>
<p>}</p>
<p>Section 15.8: else</p>
<p>The first substatement of an if statement may be followed by the
keyword else. The substatement after the else</p>
<p>keyword will be executed when the condition is falsey (that is, when
the first substatement is not executed).</p>
<p>int x;</p>
<p>std::cin &gt;&gt; x;</p>
<p>if (x%2 == 0) {</p>
<p>std::cout &lt;&lt; "The number is even<strong>\n</strong>";</p>
<p>} else {</p>
<p>std::cout &lt;&lt; "The number is odd<strong>\n</strong>";</p>
<p>}</p>
<p>Section 15.9: Conditional Structures: if, if..else</p>
<p>if and else:</p>
<p>it used to check whether the given expression returns true or false
and acts as such:</p>
<p>if (condition) statement</p>
<p>the condition can be any valid C++ expression that returns something
that be checked against truth/falsehood for</p>
<p>example:</p>
<p>if (true) { <em>/* code here */</em> } // evaluate that true is true
and execute the code in the brackets</p>
<p>if (false) { <em>/* code here */</em> } // always skip the code since
false is always false</p>
<p>the condition can be anything, a function, a variable, or a
comparison for example</p>
<p>if(istrue()) { } // evaluate the function, if it returns true, the if
will execute the code if(isTrue(var)) { } //evaluate the return of the
function after passing the argument var if(a == b) { } // this will
evaluate the return of the experssion (a==b) which will be true if equal
and false if unequal</p>
<p>if(a) { } //if a is a boolean type, it will evaluate for its value,
if it's an integer, any non zero value will be true,</p>
<p>if we want to check for a multiple expressions we can do it in two
ways :</p>
<p>using binary operators <strong>:</strong></p>
<p>if (a &amp;&amp; b) { } // will be true only if both a and b are true
(binary operators are outside the scope here</p>
<p>if (a || b ) { } //true if a or b is true</p>
<p>using if/ifelse/else<strong>:</strong></p>
<p>for a simple switch either if or else</p>
<p>if (a== "test") {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 80</p>
<p><span id="__will_execute_if_a_is_a_string"
class="anchor"></span>//will execute if a is a string "test"</p>
<p>} else {</p>
<p>// only if the first failed, will execute</p>
<p>}</p>
<p>for multiple choices :</p>
<p>if (a=='a') {</p>
<p>// if a is a char valued 'a'</p>
<p>} else if (a=='b') {</p>
<p>// if a is a char valued 'b'</p>
<p>} else if (a=='c') {</p>
<p>// if a is a char valued 'c'</p>
<p>} else {</p>
<p>//if a is none of the above</p>
<p>}</p>
<p>however it must be noted that you should use
'<strong>switch</strong>' instead if your code checks for the same
variable's value</p>
<p>Section 15.10: goto</p>
<p>Jumps to a labelled statement, which must be located in the current
function.</p>
<p>bool f(int arg) {</p>
<p>bool result = false;</p>
<p>hWidget widget = get_widget(arg);</p>
<p>if (!g()) {</p>
<p>// we can't continue, but must do cleanup still</p>
<p>goto end;</p>
<p>}</p>
<p>// ...</p>
<p>result = true;</p>
<p>end:</p>
<p>release_widget(widget);</p>
<p>return result;</p>
<p>}</p>
<p>Section 15.11: Jump statements : break, continue, goto, exit</p>
<p>The break instruction:</p>
<p>Using break we can leave a loop even if the condition for its end is
not fulfilled. It can be used to end an infinite</p>
<p>loop, or to force it to end before its natural end</p>
<p>The syntax is</p>
<p>break;</p>
<p><strong>Example</strong>: we often use break in switch cases,ie once
a case i switch is satisfied then the code block of that</p>
<p>condition is executed .</p>
<p>switch(conditon){</p>
<p>case 1: block1;</p>
<p>case 2: block2;</p>
<p>case 3: block3;</p>
<p>default: blockdefault;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 81</p>
<p>in this case if case 1 is satisfied then block 1 is executed , what
we really want is only the block1 to be processed but instead once the
block1 is processed remaining blocks,block2,block3 and blockdefault are
also processed even</p>
<p>though only case 1 was satified.To avoid this we use break at the end
of each block like :</p>
<p>switch(condition){</p>
<p>case 1: block1;</p>
<p>break;</p>
<p>case 2: block2;</p>
<p>break;</p>
<p>case 3: block3;</p>
<p>break;</p>
<p>default: blockdefault;</p>
<p>break;</p>
<p>}</p>
<p>so only one block is processed and the control moves out of the
switch loop.</p>
<p>break can also be used in other conditional and non conditional loops
like if,while,for etc;</p>
<p>example:</p>
<p>if(condition1){</p>
<p>....</p>
<p>if(condition2){</p>
<p>.......</p>
<p>break;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>The continue instruction:</p>
<p>The continue instruction causes the program to skip the rest of the
loop in the present iteration as if the end of the</p>
<p>statement block would have been reached, causing it to jump to the
following iteration.</p>
<p>The syntax is</p>
<p>continue;</p>
<p><strong>Example</strong> consider the following :</p>
<p>for(int i=0;i&lt;10;i++){</p>
<p>if(i%2==0)</p>
<p>continue;</p>
<p>cout&lt;&lt;"<strong>\n</strong> @"&lt;</p>
<p>}</p>
<p>which produces the output:</p>
<p>@1</p>
<p>@3</p>
<p>@5</p>
<p>@7</p>
<p>@9</p>
<p>i this code whenever the condition i%2==0 is satisfied continue is
processed,this causes the compiler to skip all the</p>
<p>remaining code( printing @ and i) and increment/decrement statement
of the loop gets executed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 82</p>
<p><img src="media/index-101_1.jpeg"
style="width:5.13889in;height:1.95833in" alt="index-101_1.jpg" /></p>
<p>The goto instruction:</p>
<p>It allows making an absolute jump to another point in the program.
You should use this feature carefully since its execution ignores any
type of nesting limitation. The destination point is identified by a
label, which is then used as</p>
<p>an argument for the goto instruction. A label is made of a valid
identifier followed by a colon (:)</p>
<p>The syntax is</p>
<p>goto label;</p>
<p>..</p>
<p>.</p>
<p>label: statement;</p>
<p><em><strong>Note:</strong></em> Use of goto statement is highly
discouraged because it makes difficult to trace the control flow of a
program,</p>
<p>making the program hard to understand and hard to modify.</p>
<p><img src="media/index-101_2.jpeg"
style="width:5.66667in;height:4.09722in" alt="index-101_2.jpg" /></p>
<p>Example :</p>
<p>int num = 1;</p>
<p>STEP:</p>
<p>do{</p>
<p>if( num%2==0 )</p>
<p>{</p>
<p>num = num + 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 83</p>
<p><span id="goto_STEP" class="anchor"></span>goto STEP;</p>
<p>}</p>
<p>cout &lt;&lt; "value of num : " &lt;&lt; num &lt;&lt; endl;</p>
<p>num = num + 1;</p>
<p>}while( num &lt; 10 );</p>
<p>output :</p>
<p>value of num : 1</p>
<p>value of num : 3</p>
<p>value of num : 5</p>
<p>value of num : 7</p>
<p>value of num : 9</p>
<p>whenever the condition num%2==0 is satisfied the goto sends the
execution control to the beginning of the do-while loop.</p>
<p>The exit function:</p>
<p>exit is a function defined in cstdlib. The purpose of exit is to
terminate the running program with an specific exit code. Its prototype
is:</p>
<p>void exit (int exit code);</p>
<p>cstdlib defines the standard exit codes EXIT_SUCCESS and
EXIT_FAILURE.</p>
<p>Section 15.12: return</p>
<p>Returns control from a function to its caller.</p>
<p>If return has an operand, the operand is converted to the function's
return type, and the converted value is</p>
<p>returned to the caller.</p>
<p>int f() {</p>
<p>return 42;</p>
<p>}</p>
<p>int x = f(); // x is 42</p>
<p>int g() {</p>
<p>return 3.14;</p>
<p>}</p>
<p>int y = g(); // y is 3</p>
<p>If return does not have an operand, the function must have void
return type. As a special case, a void-returning function can also
return an expression if the expression has type void.</p>
<p>void f(int x) {</p>
<p>if (x &lt; 0) return;</p>
<p>std::cout &lt;&lt; sqrt(x);</p>
<p>}</p>
<p>int g() { return 42; }</p>
<p>void h() {</p>
<p>return f(); // calls f, then returns</p>
<p>return g(); // ill-formed</p>
<p>}</p>
<p>When main returns, std::exit is implicitly called with the return
value, and the value is thus returned to the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 84</p>
<p>execution environment. (However, returning from main destroys
automatic local variables, while calling std::exit directly does
not.)</p>
<p>int main(int argc, char** argv) {</p>
<p>if (argc &lt; 2) {</p>
<p>std::cout &lt;&lt; "Missing argument<strong>\n</strong>";</p>
<p>return EXIT_FAILURE; // equivalent to: exit(EXIT_FAILURE);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 85</p>
<p><span id="Chapter_16__Metaprogramming_1"
class="anchor"></span>Chapter 16: Metaprogramming</p>
<p>In C++ Metaprogramming refers to the use of macros or templates to
generate code at compile-time.</p>
<p>In general, macros are frowned upon in this role and templates are
preferred, although they are not as generic.</p>
<p>Template metaprogramming often makes use of compile-time
computations, whether via templates or constexpr functions, to achieve
its goals of generating code, however compile-time computations are not
metaprogramming</p>
<p>per se.</p>
<p>Section 16.1: Calculating Factorials</p>
<p>Factorials can be computed at compile-time using template
metaprogramming techniques.</p>
<p>#include</p>
<p>template</p>
<p>struct factorial</p>
<p>{</p>
<p>enum</p>
<p>{</p>
<p>value = n * factorial::value</p>
<p>};</p>
<p>};</p>
<p>template&lt;&gt;</p>
<p>struct factorial&lt;0&gt;</p>
<p>{</p>
<p>enum { value = 1 };</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; factorial&lt;7&gt;::value &lt;&lt; std::endl; //
prints "5040" }</p>
<p>factorial is a struct, but in template metaprogramming it is treated
as a template metafunction. By convention, template metafunctions are
evaluated by checking a particular member, either ::type for
metafunctions that result</p>
<p>in types, or ::value for metafunctions that generate values.</p>
<p>In the above code, we evaluate the factorial metafunction by
instantiating the template with the parameters we</p>
<p>want to pass, and using ::value to get the result of the
evaluation.</p>
<p>The metafunction itself relies on recursively instantiating the same
metafunction with smaller values. The factorial&lt; 0&gt; specialization
represents the terminating condition. Template metaprogramming has most
of the</p>
<p><a
href="https://en.wikipedia.org/wiki/Functional_programming">restrictions
of a functional programming language</a>, so recursion is the primary
"looping" construct.</p>
<p>Since template metafunctions execute at compile time, their results
can be used in contexts that require compile-</p>
<p>time values. For example:</p>
<p>int my_array[factorial&lt;5&gt;::value];</p>
<p>Automatic arrays must have a compile-time defined size. And the
result of a metafunction is a compile-time constant, so it can be used
here.</p>
<p><strong>Limitation</strong>: Most of the compilers won't allow
recursion depth beyond a limit. For example, g++ compiler by default</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 86</p>
<p>limits recursion depeth to 256 levels. In case of g++, programmer can
set recursion depth using -ftemplate-depth-X option.</p>
<p>Version ≥ C++11</p>
<p>Since C++11, the std::integral_constant template can be used for this
kind of template computation:</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>struct factorial :</p>
<p>std::integral_constant::value&gt; {};</p>
<p>template&lt;&gt;</p>
<p>struct factorial&lt;0&gt; :</p>
<p>std::integral_constant {};</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; factorial&lt;7&gt;::value &lt;&lt; std::endl; //
prints "5040" }</p>
<p>Additionally, constexpr functions become a cleaner alternative.</p>
<p>#include</p>
<p>constexpr long long factorial(long long n)</p>
<p>{</p>
<p>return (n == 0) ? 1 : n * factorial(n -1);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>char test[factorial(3)];</p>
<p>std::cout &lt;&lt; factorial(7) &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>The body of factorial() is written as a single statement because in
C++11 constexpr functions can only use a</p>
<p>quite limited subset of the language.</p>
<p>Version ≥ C++14</p>
<p>Since C++14, many restrictions for constexpr functions have been
dropped and they can now be written much more conveniently:</p>
<p>constexpr long long factorial(long long n)</p>
<p>{</p>
<p>if (n == 0)</p>
<p>return 1;</p>
<p>else</p>
<p>return n * factorial(n -1);</p>
<p>}</p>
<p>Or even:</p>
<p>constexpr long long factorial(int n)</p>
<p>{</p>
<p>long long result = 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 87</p>
<p><span id="for__int_i___1__i____n____i" class="anchor"></span>for (int
i = 1; i &lt;= n; ++i) {</p>
<p>result *= i;</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>Since c++17 one can use fold expression to calculate factorial:</p>
<p>#include</p>
<p>#include</p>
<p>template &gt; struct factorial;</p>
<p>template</p>
<p>struct factorial&gt; {</p>
<p>static constexpr T value = (static_cast(1) * ... * (Is + 1));</p>
<p>};</p>
<p>int main() {</p>
<p>std::cout &lt;&lt; factorial::value &lt;&lt; std::endl; }</p>
<p>Section 16.2: Iterating over a parameter pack</p>
<p>Often, we need to perform an operation over every element in a
variadic template parameter pack. There are many ways to do this, and
the solutions get easier to read and write with C++17. Suppose we simply
want to print every</p>
<p>element in a pack. The simplest solution is to recurse:</p>
<p>Version ≥ C++11</p>
<p>void print_all(std::ostream&amp; os) {</p>
<p>// base case</p>
<p>}</p>
<p>template</p>
<p>void print_all(std::ostream&amp; os, T const&amp; first, Ts
const&amp;... rest) {</p>
<p>os &lt;&lt; first;</p>
<p>print_all(os, rest...);</p>
<p>}</p>
<p>We could instead use the expander trick, to perform all the streaming
in a single function. This has the advantage of not needing a second
overload, but has the disadvantage of less than stellar readability:</p>
<p>Version ≥ C++11</p>
<p>template</p>
<p>void print_all(std::ostream&amp; os, Ts const&amp;... args) {</p>
<p>using expander = int[];</p>
<p>(void)expander{0,</p>
<p>(void(os &lt;&lt; args), 0)...</p>
<p>};</p>
<p>}</p>
<p>For an explanation of how this works, see <a
href="http://stackoverflow.com/a/25683817/2069064">T.C's excellent
answer</a>.</p>
<p>Version ≥ C++17</p>
<p>With C++17, we get two powerful new tools in our arsenal for solving
this problem. The first is a fold-expression:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 88</p>
<p><span id="template" class="anchor"></span>template</p>
<p>void print_all(std::ostream&amp; os, Ts const&amp;... args) {</p>
<p>((os &lt;&lt; args), ...);</p>
<p>}</p>
<p>And the second is if constexpr, which allows us to write our original
recursive solution in a single function:</p>
<p>template</p>
<p>void print_all(std::ostream&amp; os, T const&amp; first, Ts
const&amp;... rest) {</p>
<p>os &lt;&lt; first;</p>
<p>if constexpr (sizeof...(rest) &gt; 0) {</p>
<p>// this line will only be instantiated if there are further //
arguments. if rest... is empty, there will be no call to //
print_all(os).</p>
<p>print_all(os, rest...);</p>
<p>}</p>
<p>}</p>
<p>Section 16.3: Iterating with std::integer_sequence</p>
<p>Since C++14, the standard provides the class template</p>
<p>template</p>
<p>class integer_sequence;</p>
<p>template</p>
<p>using index_sequence = std::integer_sequence;</p>
<p>and a generating metafunction for it:</p>
<p>template</p>
<p>using make_integer_sequence = std::integer_sequence/* a sequence 0,
1, 2, ..., N-1 */ &gt;;</p>
<p>template</p>
<p>using make_index_sequence = make_integer_sequence;</p>
<p>While this comes standard in C++14, this can be implemented using
C++11 tools.</p>
<p>We can use this tool to call a function with a std::tuple of
arguments (standardized in C++17 as std::apply):</p>
<p>namespace detail {</p>
<p>template</p>
<p>decltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; tpl,
std::index_sequence ) {</p>
<p>return std::forward(f)(std::get(std::forward(tpl))...);</p>
<p>}</p>
<p>}</p>
<p>template</p>
<p>decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; tpl) {</p>
<p>return detail::apply_impl(std::forward(f),</p>
<p>std::forward(tpl),</p>
<p>std::make_index_sequence&gt;::value&gt;{}); }</p>
<p>// this will print 3</p>
<p>int f(int, char, double);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 89</p>
<p><span id="auto_some_args___std__make_tuple"
class="anchor"></span>auto some_args = std::make_tuple(42, 'x',
3.14);</p>
<p>int r = apply(f, some_args); // calls f(42, 'x', 3.14)</p>
<p>Section 16.4: Tag Dispatching</p>
<p>A simple way of selecting between functions at compile time is to
dispatch a function to an overloaded pair of</p>
<p>functions that take a tag as one (usually the last) argument. For
example, to implement std::advance(), we can dispatch on the iterator
category:</p>
<p>namespace details {</p>
<p>template</p>
<p>void advance(RAIter&amp; it, Distance n,
std::random_access_iterator_tag) { it += n;</p>
<p>}</p>
<p>template</p>
<p>void advance(BidirIter&amp; it, Distance n,
std::bidirectional_iterator_tag) {</p>
<p>if (n &gt; 0) {</p>
<p>while (n--) ++it;</p>
<p>}</p>
<p>else {</p>
<p>while (n++)--it;</p>
<p>}</p>
<p>}</p>
<p>template</p>
<p>void advance(InputIter&amp; it, Distance n, std::input_iterator_tag)
{</p>
<p>while (n--) {</p>
<p>++it;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>template</p>
<p>void advance(Iter&amp; it, Distance n) {</p>
<p>details::advance(it, n,</p>
<p>typename std::iterator_traits::iterator_category{} );</p>
<p>}</p>
<p>The std::XY_iterator_tag arguments of the overloaded details::advance
functions are unused function</p>
<p>parameters. The actual implementation does not matter (actually it is
completely empty). Their only purpose is to allow the compiler to select
an overload based on which tag class details::advance is called
with.</p>
<p>In this example, advance uses the iterator_traits::iterator_category
metafunction which returns one of the iterator_tag classes, depending on
the actual type of Iter. A default-constructed object of the</p>
<p>iterator_category::type then lets the compiler select one of the
different overloads of details::advance. (This function parameter is
likely to be completely optimized away, as it is a default-constructed
object of an empty</p>
<p>struct and never used.)</p>
<p>Tag dispatching can give you code that's much easier to read than the
equivalents using SFINAE and enable_if.</p>
<p>Note: while C++17's if constexpr may simplify the implementation of
advance in particular, it is not suitable for open implementations
unlike tag dispatching.</p>
<p>Section 16.5: Detect Whether Expression is Valid</p>
<p>It is possible to detect whether an operator or function can be
called on a type. To test if a class has an overload of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 90</p>
<p>std::hash, one can do this:</p>
<p>#include // for std::hash</p>
<p>#include // for std::false_type and std::true_type #include // for
std::declval</p>
<p>template</p>
<p>struct has_hash</p>
<p>: std::false_type</p>
<p>{};</p>
<p>template</p>
<p>struct has_hash()(std::declval()), void())&gt;</p>
<p>: std::true_type</p>
<p>{};</p>
<p>Version ≥ C++17</p>
<p>Since C++17, std::void_t can be used to simplify this type of
construct</p>
<p>#include // for std::hash</p>
<p>#include // for std::false_type, std::true_type, std::void_t #include
// for std::declval</p>
<p>template &gt;</p>
<p>struct has_hash</p>
<p>: std::false_type</p>
<p>{};</p>
<p>template</p>
<p>struct has_hash()(std::declval())) &gt; &gt;</p>
<p>: std::true_type</p>
<p>{};</p>
<p>where std::void_t is defined as:</p>
<p>template&lt; class... &gt; using void_t = void;</p>
<p>For detecting if an operator, such as operator&lt; is defined, the
syntax is almost the same:</p>
<p>template</p>
<p>struct has_less_than</p>
<p>: std::false_type</p>
<p>{};</p>
<p>template</p>
<p>struct has_less_than() &lt; std::declval(), void())&gt;</p>
<p>: std::true_type</p>
<p>{};</p>
<p>These can be used to use a std::unordered_map if T has an overload
for std::hash, but otherwise attempt to</p>
<p>use a std::map:</p>
<p>template</p>
<p>using hash_invariant_map = std::conditional_t&lt;</p>
<p>has_hash::value,</p>
<p>std::unordered_map,</p>
<p>std::map&gt;;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 91</p>
<p><span id="Section_16_6__If_then_else" class="anchor"></span>Section
16.6: If-then-else</p>
<p>Version ≥ C++11</p>
<p>The type std::conditional in the standard library header
<strong>&lt;type_traits&gt;</strong> can select one type or the other,
based</p>
<p>on a compile-time boolean value:</p>
<p>template</p>
<p>struct ValueOrPointer</p>
<p>{</p>
<p>typename std::conditional&lt;(sizeof(T) &gt; sizeof(void*)), T*,
T&gt;::type vop;</p>
<p>};</p>
<p>This struct contains a pointer to T if T is larger than the size of a
pointer, or T itself if it is smaller or equal to a</p>
<p>pointer's size. Therefore sizeof(ValueOrPointer) will always be &lt;=
sizeof(void*).</p>
<p>Section 16.7: Manual distinction of types when given any type</p>
<p>T</p>
<p>When implementing SFINAE using std::enable_if, it is often useful to
have access to helper templates that</p>
<p>determines if a given type T matches a set of criteria.</p>
<p>To help us with that, the standard already provides two types analog
to true and false which are std::true_type</p>
<p>and std::false_type.</p>
<p>The following example show how to detect if a type T is a pointer or
not, the is_pointer template mimic the</p>
<p>behavior of the standard std::is_pointer helper:</p>
<p>template</p>
<p>struct is_pointer_: std::false_type {};</p>
<p>template</p>
<p>struct is_pointer_: std::true_type {};</p>
<p>template</p>
<p>struct is_pointer: is_pointer_::type&gt; { }</p>
<p>There are three steps in the above code (sometimes you only need
two):</p>
<p>1. The first declaration of is_pointer_ is the <em>default case</em>,
and inherits from std::false_type. The <em>default</em> case</p>
<p>should always inherit from std::false_type since it is analogous to a
"false condition".</p>
<p>2. The second declaration specialize the is_pointer_ template for
pointer T* without caring about what T is</p>
<p>really. This version inherits from std::true_type.</p>
<p>3. The third declaration (the real one) simply remove any unnecessary
information from T (in this case we</p>
<p>remove const and volatile qualifiers) and then fall backs to one of
the two previous declarations.</p>
<p>Since is_pointer is a class, to access its value you need to
either:</p>
<p>Use ::value, e.g. is_pointer::value – value is a static class member
of type bool inherited from</p>
<p>std::true_type or std::false_type;</p>
<p>Construct an object of this type, e.g. is_pointer{} – This works
because std::is_pointer inherits its</p>
<p>default constructor from std::true_type or std::false_type (which
have constexpr constructors) and both</p>
<p>std::true_type and std::false_type have constexpr conversion
operators to bool.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 92</p>
<p><span id="It_is_a_good_habit_to_provides" class="anchor"></span>It is
a good habit to provides "helper helper templates" that let you directly
access the value:</p>
<p>template</p>
<p>constexpr bool is_pointer_v = is_pointer::value;</p>
<p>Version ≥ C++17</p>
<p>In C++17 and above, most helper templates already provide a _v
version, e.g.:</p>
<p>template&lt; class T &gt; constexpr bool is_pointer_v =
is_pointer::value; template&lt; class T &gt; constexpr bool
is_reference_v = is_reference::value;</p>
<p>Section 16.8: Calculating power with C++11 (and higher)</p>
<p>With C++11 and higher calculations at compile time can be much
easier. For example calculating the power of a given number at compile
time will be following:</p>
<p>template</p>
<p>constexpr T calculatePower(T value, unsigned power) {</p>
<p>return power == 0 ? 1 : value * calculatePower(value, power-1);</p>
<p>}</p>
<p>Keyword constexpr is responsible for calculating function in
compilation time, then and only then, when all the</p>
<p>requirements for this will be met (see more at constexpr keyword
reference) for example all the arguments must be known at compile
time.</p>
<p>Note: In C++11 constexpr function must compose only from one return
statement.</p>
<p>Advantages: Comparing this to the standard way of compile time
calculation, this method is also useful for runtime</p>
<p>calculations. It means, that if the arguments of the function are not
known at the compilation time (e.g. value and power are given as input
via user), then function is run in a compilation time, so there's no
need to duplicate a code</p>
<p>(as we would be forced in older standards of C++).</p>
<p>E.g.</p>
<p>void useExample() {</p>
<p>constexpr int compileTimeCalculated = calculatePower(3, 3); //
computes at compile time,</p>
<p>// as both arguments are known at compilation time // and used for a
constant expression.</p>
<p>int value;</p>
<p>std::cin &gt;&gt; value;</p>
<p>int runtimeCalculated = calculatePower(value, 3); // runtime
calculated,</p>
<p>// because value is known only at runtime.</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>Another way to calculate power at compile time can make use of fold
expression as follows:</p>
<p>#include</p>
<p>#include</p>
<p>template &gt; struct power;</p>
<p>template</p>
<p>struct power&gt; {</p>
<p>static constexpr T value = (static_cast(1) * ... * (V *
static_cast(Is + 1)));</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 93</p>
<p><span id="int_main" class="anchor"></span>int main() {</p>
<p>std::cout &lt;&lt; power::value &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 16.9: Generic Min/Max with variable argument count</p>
<p>Version &gt; C++11</p>
<p>It's possible to write a generic function (for example min) which
accepts various numerical types and arbitrary</p>
<p>argument count by template meta-programming. This function declares a
min for two arguments and recursively</p>
<p>for more.</p>
<p>template</p>
<p>auto min(const T1 &amp;a, const T2 &amp;b)</p>
<p>-&gt; typename std::common_type::type {</p>
<p>return a &lt; b ? a : b;</p>
<p>}</p>
<p>template auto min(const T1 &amp;a, const T2 &amp;b, const Args&amp;
... args)-&gt; typename std::common_type::type {</p>
<p>return min(min(a, b), args...);</p>
<p>}</p>
<p>auto minimum = min(4, 5.8f, 3, 1.8, 3, 1.1, 9);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 94</p>
<p><span id="Chapter_17__const_keyword_1" class="anchor"></span>Chapter
17: const keyword</p>
<p>Section 17.1: Avoiding duplication of code in const and non-</p>
<p>const getter methods</p>
<p>In C++ methods that differs only by const qualifier can be
overloaded. Sometimes there may be a need of two</p>
<p>versions of getter that return a reference to some member.</p>
<p>Let Foo be a class, that has two methods that perform identical
operations and returns a reference to an object of type Bar:</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p><em>Bar&amp; GetBar(</em>/* some arguments */<em>)</em></p>
<p>{</p>
<p>/* some calculations */</p>
<p>return bar;</p>
<p>}</p>
<p>const Bar&amp; GetBar(<em>/* some arguments */</em>) const</p>
<p>{</p>
<p>/* some calculations */</p>
<p>return bar;</p>
<p>}</p>
<p>// ...</p>
<p>};</p>
<p>The only difference between them is that one method is non-const and
return a non-const reference (that can be use to modify object) and the
second is const and returns const reference.</p>
<p>To avoid the code duplication, there is a temptation to call one
method from another. However, we can not call non-const method from the
const one. But we can call const method from non-const one. That will
require as to</p>
<p>use 'const_cast' to remove the const qualifier.</p>
<p>The solution is:</p>
<p>struct Foo</p>
<p>{</p>
<p>Bar&amp; GetBar(<em>/*arguments*/</em>)</p>
<p>{</p>
<p>return
const_cast(const_cast(this)-&gt;GetBar(<em>/*arguments*/</em>));</p>
<p>}</p>
<p>const Bar&amp; GetBar(<em>/*arguments*/</em>) const</p>
<p>{</p>
<p>/* some calculations */</p>
<p>return foo;</p>
<p>}</p>
<p>};</p>
<p>In code above, we call const version of GetBar from the non-const
GetBar by casting this to const type: const_cast(this). Since we call
const method from non-const, the object itself is non-const, and</p>
<p>casting away the const is allowed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 95</p>
<p><span id="Examine_the_following_more_compl"
class="anchor"></span>Examine the following more complete example:</p>
<p>#include</p>
<p>class Student</p>
<p>{</p>
<p>public:</p>
<p>char&amp; GetScore(bool midterm)</p>
<p>{</p>
<p>return const_cast(const_cast(this)-&gt;GetScore(midterm));</p>
<p>}</p>
<p>const char&amp; GetScore(bool midterm) const</p>
<p>{</p>
<p>if (midterm)</p>
<p>{</p>
<p>return midtermScore;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>return finalScore;</p>
<p>}</p>
<p>}</p>
<p>private:</p>
<p>char midtermScore;</p>
<p>char finalScore;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>// non-const object</p>
<p>Student a;</p>
<p>// We can assign to the reference. Non-const version of GetScore is
called</p>
<p>a.GetScore(true) = 'B';</p>
<p>a.GetScore(false) = 'A';</p>
<p>// const object</p>
<p>const Student b(a);</p>
<p>// We still can call GetScore method of const object, // because we
have overloaded const version of GetScore</p>
<p>std::cout &lt;&lt; b.GetScore(true) &lt;&lt; b.GetScore(false)
&lt;&lt; '<strong>\n</strong>'; }</p>
<p>Section 17.2: Const member functions</p>
<p>Member functions of a class can be declared const, which tells the
compiler and future readers that this function</p>
<p>will not modify the object:</p>
<p>class MyClass</p>
<p>{</p>
<p>private:</p>
<p>int myInt_;</p>
<p>public:</p>
<p>int myInt() const { return myInt_; }</p>
<p>void setMyInt(int myInt) { myInt_ = myInt; }</p>
<p>};</p>
<p>In a const member function, the this pointer is effectively a const
MyClass * instead of a MyClass *. This means</p>
<p>that you cannot change any member variables within the function; the
compiler will emit a warning. So setMyInt</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 96</p>
<p><span id="could_not_be_declared_const" class="anchor"></span>could
not be declared const.</p>
<p>You should almost always mark member functions as const when
possible. Only const member functions can be</p>
<p>called on a const MyClass.</p>
<p>static methods cannot be declared as const. This is because a static
method belongs to a class and is not called</p>
<p>on object; therefore it can never modify object's internal variables.
So declaring static methods as const would be redundant.</p>
<p>Section 17.3: Const local variables</p>
<p>Declaration and usage.</p>
<p>// a is const int, so it can't be changed</p>
<p>const int a = 15;</p>
<p>a = 12; // Error: can't assign new value to const variable a += 1; //
Error: can't assign new value to const variable</p>
<p>Binding of references and pointers</p>
<p>int &amp;b = a; // Error: can't bind non-const reference to const
variable const int &amp;c = a; // OK; c is a const reference</p>
<p>int *d = &amp;a; // Error: can't bind pointer-to-non-const to const
variable const int *e = &amp;a // OK; e is a pointer-to-const</p>
<p>int f = 0;</p>
<p>e = &amp;f; // OK; e is a non-const pointer-to-const,</p>
<p>// which means that it can be rebound to new int* or const int*</p>
<p>*e = 1 // Error: e is a pointer-to-const which means that</p>
<p>// the value it points to can't be changed through dereferencing
e</p>
<p>int *g = &amp;f;</p>
<p>*g = 1; // OK; this value still can be changed through
dereferencing</p>
<p>// a pointer-not-to-const</p>
<p>Section 17.4: Const pointers</p>
<p>int a = 0, b = 2;</p>
<p>const int* pA = &amp;a; // pointer-to-const. `a` can't be changed
through this int* const pB = &amp;a; // const pointer. `a` can be
changed, but this pointer can't. const int* const pC = &amp;a; // const
pointer-to-const.</p>
<p>//Error: Cannot assign to a const reference</p>
<p>*pA = b;</p>
<p>pA = &amp;b;</p>
<p>*pB = b;</p>
<p>//Error: Cannot assign to const pointer</p>
<p>pB = &amp;b;</p>
<p>//Error: Cannot assign to a const reference</p>
<p>*pC = b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 97</p>
<p>//Error: Cannot assign to const pointer</p>
<p>pC = &amp;b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 98</p>
<p><span id="Chapter_18__mutable_keyword_1"
class="anchor"></span>Chapter 18: mutable keyword</p>
<p>Section 18.1: mutable lambdas</p>
<p>By default, the implicit operator() of a lambda is const. This
disallows performing non-const operations on the lambda. In order to
allow modifying members, a lambda may be marked mutable, which makes the
implicit</p>
<p>operator() non-const:</p>
<p>int a = 0;</p>
<p>auto bad_counter = [a] {</p>
<p>return a++; // error: operator() is const</p>
<p>// cannot modify members</p>
<p>};</p>
<p>auto good_counter = [a]() mutable {</p>
<p>return a++; // OK</p>
<p>}</p>
<p>good_counter(); // 0</p>
<p>good_counter(); // 1</p>
<p>good_counter(); // 2</p>
<p>Section 18.2: non-static class member modifier</p>
<p>mutable modifier in this context is used to indicate that a data
field of a const object may be modified without affecting the
externally-visible state of the object.</p>
<p>If you are thinking about caching a result of expensive computation,
you should probably use this keyword.</p>
<p>If you have a lock (for example, std::unique_lock) data field which
is locked and unlocked inside a const method,</p>
<p>this keyword is also what you could use.</p>
<p>You should not use this keyword to break logical const-ness of an
object.</p>
<p>Example with caching:</p>
<p>class pi_calculator {</p>
<p>public:</p>
<p>double get_pi() const {</p>
<p>if (pi_calculated) {</p>
<p>return pi;</p>
<p>} else {</p>
<p>double new_pi = 0;</p>
<p>for (int i = 0; i &lt; 1000000000; ++i) {</p>
<p>// some calculation to refine new_pi</p>
<p>}</p>
<p>// note: if pi and pi_calculated were not mutable, we would get an
error from a</p>
<p>compiler</p>
<p>// because in a const method we can not change a non-mutable
field</p>
<p>pi = new_pi;</p>
<p>pi_calculated = true;</p>
<p>return pi;</p>
<p>}</p>
<p>}</p>
<p>private:</p>
<p>mutable bool pi_calculated = false;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 99</p>
<p>mutable double pi = 0;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 100</p>
<p><span id="Chapter_19__Friend_keyword_1" class="anchor"></span>Chapter
19: Friend keyword</p>
<p>Well-designed classes encapsulate their functionality, hiding their
implementation while providing a clean,</p>
<p>documented interface. This allows redesign or change so long as the
interface is unchanged.</p>
<p>In a more complex scenario, multiple classes that rely on each
others' implementation details may be required.</p>
<p>Friend classes and functions allow these peers access to each others'
details, without compromising the encapsulation and information hiding
of the documented interface.</p>
<p>Section 19.1: Friend function</p>
<p>A class or a structure may declare any function it's friend. If a
function is a friend of a class, it may access all it's protected and
private members:</p>
<p>// Forward declaration of functions.</p>
<p>void friend_function();</p>
<p>void non_friend_function();</p>
<p>class PrivateHolder {</p>
<p>public:</p>
<p>PrivateHolder(int val) : private_value(val) {}</p>
<p>private:</p>
<p>int private_value;</p>
<p>// Declare one of the function as a friend.</p>
<p>friend void friend_function();</p>
<p>};</p>
<p>void non_friend_function() {</p>
<p>PrivateHolder ph(10);</p>
<p>// Compilation error: private_value is private.</p>
<p>std::cout &lt;&lt; ph.private_value &lt;&lt; std::endl;</p>
<p>}</p>
<p>void friend_function() {</p>
<p>// OK: friends may access private values.</p>
<p>PrivateHolder ph(10);</p>
<p>std::cout &lt;&lt; ph.private_value &lt;&lt; std::endl;</p>
<p>}</p>
<p>Access modifiers do not alter friend semantics. Public, protected and
private declarations of a friend are equivalent.</p>
<p>Friend declarations are not inherited. For example, if we subclass
PrivateHolder:</p>
<p>class PrivateHolderDerived : public PrivateHolder { public:</p>
<p>PrivateHolderDerived(int val) : PrivateHolder(val) {} private:</p>
<p>int derived_private_value = 0;</p>
<p>};</p>
<p>and try to access it's members, we'll get the following:</p>
<p>void friend_function() {</p>
<p>PrivateHolderDerived pd(20);</p>
<p>// OK.</p>
<p>std::cout &lt;&lt; pd.private_value &lt;&lt; std::endl;</p>
<p>// Compilation error: derived_private_value is private.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 101</p>
<p><span id="std__cout____pd_derived_private"
class="anchor"></span>std::cout &lt;&lt; pd.derived_private_value
&lt;&lt; std::endl; }</p>
<p>Note that PrivateHolderDerived member function cannot access
PrivateHolder::private_value, while friend</p>
<p>function can do it.</p>
<p>Section 19.2: Friend method</p>
<p>Methods may declared as friends as well as functions:</p>
<p>class Accesser {</p>
<p>public:</p>
<p>void private_accesser();</p>
<p>};</p>
<p>class PrivateHolder {</p>
<p>public:</p>
<p>PrivateHolder(int val) : private_value(val) {}</p>
<p>friend void Accesser::private_accesser();</p>
<p>private:</p>
<p>int private_value;</p>
<p>};</p>
<p>void Accesser::private_accesser() {</p>
<p>PrivateHolder ph(10);</p>
<p>// OK: this method is declares as friend.</p>
<p>std::cout &lt;&lt; ph.private_value &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 19.3: Friend class</p>
<p>A whole class may be declared as friend. Friend class declaration
means that any member of the friend may access</p>
<p>private and protected members of the declaring class:</p>
<p>class Accesser {</p>
<p>public:</p>
<p>void private_accesser1();</p>
<p>void private_accesser2();</p>
<p>};</p>
<p>class PrivateHolder {</p>
<p>public:</p>
<p>PrivateHolder(int val) : private_value(val) {}</p>
<p>friend class Accesser;</p>
<p>private:</p>
<p>int private_value;</p>
<p>};</p>
<p>void Accesser::private_accesser1() {</p>
<p>PrivateHolder ph(10);</p>
<p>// OK.</p>
<p>std::cout &lt;&lt; ph.private_value &lt;&lt; std::endl;</p>
<p>}</p>
<p>void Accesser::private_accesser2() {</p>
<p>PrivateHolder ph(10);</p>
<p>// OK.</p>
<p>std::cout &lt;&lt; ph.private_value + 1 &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 102</p>
<p>}</p>
<p>Friend class declaration is not reflexive. If classes need private
access in both directions, both of them need friend declarations.</p>
<p>class Accesser {</p>
<p>public:</p>
<p>void private_accesser1();</p>
<p>void private_accesser2();</p>
<p>private:</p>
<p>int private_value = 0;</p>
<p>};</p>
<p>class PrivateHolder {</p>
<p>public:</p>
<p>PrivateHolder(int val) : private_value(val) {}</p>
<p>// Accesser is a friend of PrivateHolder</p>
<p>friend class Accesser;</p>
<p>void reverse_accesse() {</p>
<p>// but PrivateHolder cannot access Accesser's members.</p>
<p>Accesser a;</p>
<p>std::cout &lt;&lt; a.private_value;</p>
<p>}</p>
<p>private:</p>
<p>int private_value;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 103</p>
<p><span id="Chapter_20__Type_Keywords_1" class="anchor"></span>Chapter
20: Type Keywords</p>
<p>Section 20.1: class</p>
<p>1. Introduces the definition of a class type.</p>
<p>class foo {</p>
<p>int x;</p>
<p>public:</p>
<p>int get_x();</p>
<p>void set_x(int new_x);</p>
<p>};</p>
<p>2. Introduces an <em>elaborated type specifier,</em> which specifies
that the following name is the name of a class type. If</p>
<p>the class name has been declared already, it can be found even if
hidden by another name. If the class name</p>
<p>has not been declared already, it is forward-declared.</p>
<p>class foo; // elaborated type specifier -&gt; forward declaration
class bar {</p>
<p>public:</p>
<p>bar(foo&amp; f);</p>
<p>};</p>
<p>void baz();</p>
<p>class baz; // another elaborated type specifer; another forward
declaration</p>
<p>// note: the class has the same name as the function void baz()</p>
<p>class foo {</p>
<p>bar b;</p>
<p>friend class baz; // elaborated type specifier refers to the
class,</p>
<p>// not the function of the same name</p>
<p>public:</p>
<p>foo();</p>
<p>};</p>
<p>3. Introduces a type parameter in the declaration of a template.</p>
<p>template</p>
<p>const T&amp; min(const T&amp; x, const T&amp; y) {</p>
<p>return b &lt; a ? b : a;</p>
<p>}</p>
<p>4. In the declaration of a template template parameter, the keyword
class precedes the name of the</p>
<p>parameter. Since the argument for a template template parameter can
only be a class template, the use of class here is redundant. However,
the grammar of C++ requires it.</p>
<p>template class U&gt;</p>
<p>// ^^^^^ "class" used in this sense here; // U is a template template
parameter void f() {</p>
<p>U::do_it();</p>
<p>U::do_it();</p>
<p>}</p>
<p>5. Note that sense 2 and sense 3 may be combined in the same
declaration. For example:</p>
<p>template</p>
<p>class foo {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 104</p>
<p><span id="_8" class="anchor"></span>};</p>
<p>foo x; // &lt;- bar does not have to have previously appeared.</p>
<p>Version ≥ C++11</p>
<p>6. In the declaration or definition of an enum, declares the enum to
be a scoped enum.</p>
<p>enum class Format {</p>
<p>TEXT,</p>
<p>PDF,</p>
<p>OTHER,</p>
<p>};</p>
<p>Format f = F::TEXT;</p>
<p>Section 20.2: enum</p>
<p>1. Introduces the definition of an enumeration type.</p>
<p>enum Direction {</p>
<p>UP,</p>
<p>LEFT,</p>
<p>DOWN,</p>
<p>RIGHT</p>
<p>};</p>
<p>Direction d = UP;</p>
<p>Version ≥ C++11</p>
<p>In C++11, enum may optionally be followed by class or struct to
define a scoped enum. Furthermore, both scoped and unscoped enums can
have their underlying type explicitly specified by : T following the
enum name, where T</p>
<p>refers to an integer type.</p>
<p>enum class Format : char {</p>
<p>TEXT,</p>
<p>PDF,</p>
<p>OTHER</p>
<p>};</p>
<p>Format f = Format::TEXT;</p>
<p>enum Language : int {</p>
<p>ENGLISH,</p>
<p>FRENCH,</p>
<p>OTHER</p>
<p>};</p>
<p>Enumerators in normal enums may also be preceded by the scope
operator, although they are still considered to be in the scope the enum
was defined in.</p>
<p>Language l1, l2;</p>
<p>l1 = ENGLISH;</p>
<p>l2 = Language::OTHER;</p>
<p>2. Introduces an <em>elaborated type specifier,</em> which specifies
that the following name is the name of a previously</p>
<p>declared enum type. (An elaborated type specifier cannot be used to
forward-declare an enum type.) An</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 105</p>
<p><span id="enum_can_be_named_in_this_way_ev"
class="anchor"></span>enum can be named in this way even if hidden by
another name.</p>
<p>enum Foo { FOO };</p>
<p>void Foo() {}</p>
<p>Foo foo = FOO; // ill-formed; Foo refers to the function enum Foo foo
= FOO; // ok; Foo refers to the enum type</p>
<p>Version ≥ C++11</p>
<p>3. Introduces an <em>opaque enum declaration,</em> which declares an
enum without defining it. It can either redeclare a</p>
<p>previously declared enum, or forward-declare an enum that has not
been previously declared.</p>
<p>An enum first declared as scoped cannot later be declared as
unscoped, or <em>vice versa.</em> All declarations of an enum must agree
in underlying type.</p>
<p>When forward-declaring an unscoped enum, the underlying type must be
explicitly specified, since it cannot be inferred until the values of
the enumerators are known.</p>
<p>enum class Format; // underlying type is implicitly int void f(Format
f);</p>
<p>enum class Format {</p>
<p>TEXT,</p>
<p>PDF,</p>
<p>OTHER,</p>
<p>};</p>
<p>enum Direction; // ill-formed; must specify underlying type</p>
<p>Section 20.3: struct</p>
<p>Interchangeable with class, except for the following differences:</p>
<p>If a class type is defined using the keyword struct, then the default
accessibility of bases and members is</p>
<p>public rather than private.</p>
<p>struct cannot be used to declare a template type parameter or
template template parameter; only class</p>
<p>can.</p>
<p>Section 20.4: union</p>
<p>1. Introduces the definition of a union type.</p>
<p>// Example is from POSIX</p>
<p>union sigval {</p>
<p>int sival_int;</p>
<p>void *sival_ptr;</p>
<p>};</p>
<p>2. Introduces an <em>elaborated type specifier,</em> which specifies
that the following name is the name of a union type. If</p>
<p>the union name has been declared already, it can be found even if
hidden by another name. If the union name has not been declared already,
it is forward-declared.</p>
<p>union foo; // elaborated type specifier -&gt; forward declaration
class bar {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 106</p>
<p>public:</p>
<p>bar(foo&amp; f);</p>
<p>};</p>
<p>void baz();</p>
<p>union baz; // another elaborated type specifer; another forward
declaration</p>
<p>// note: the class has the same name as the function void baz()</p>
<p>union foo {</p>
<p>long l;</p>
<p>union baz* b; // elaborated type specifier refers to the class,</p>
<p>// not the function of the same name</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 107</p>
<p><span id="Chapter_21__Basic_Type_Keywords_1"
class="anchor"></span>Chapter 21: Basic Type Keywords</p>
<p>Section 21.1: char</p>
<p>An integer type which is "large enough to store any member of the
implementation’s basic character set". It is</p>
<p>implementation-defined whether char is signed (and has a range of at
least -127 to +127, inclusive) or unsigned (and has a range of at least
0 to 255, inclusive).</p>
<p>const char zero = '0';</p>
<p>const char one = zero + 1;</p>
<p>const char newline = '<strong>\n</strong>';</p>
<p>std::cout &lt;&lt; one &lt;&lt; newline; // prints 1 followed by a
newline</p>
<p>Section 21.2: char16_t</p>
<p>Version ≥ C++11</p>
<p>An unsigned integer type with the same size and alignment as
uint_least16_t, which is therefore large enough to</p>
<p>hold a UTF-16 code unit.</p>
<p>const char16_t message[] = u"你好，世界<strong>\\</strong>n"; //
Chinese for "hello, world\\n" std::cout &lt;&lt;
sizeof(message)/sizeof(char16_t) &lt;&lt; "<strong>\\</strong>n"; //
prints 7</p>
<p>Section 21.3: char32_t</p>
<p>Version ≥ C++11</p>
<p>An unsigned integer type with the same size and alignment as
uint_least32_t, which is therefore large enough to hold a UTF-32 code
unit.</p>
<p>const char32_t full_house[] = U" "; // non-BMP characters std::cout
&lt;&lt; sizeof(full_house)/sizeof(char32_t) &lt;&lt;
"<strong>\\</strong>n"; // prints 6</p>
<p>Section 21.4: int</p>
<p>Denotes a signed integer type with "the natural size suggested by the
architecture of the execution environment",</p>
<p>whose range includes at least -32767 to +32767, inclusive.</p>
<p>int x = 2;</p>
<p>int y = 3;</p>
<p>int z = x + y;</p>
<p>Can be combined with unsigned, short, long, and long long (q.v.) in
order to yield other integer types.</p>
<p>Section 21.5: void</p>
<p>An incomplete type; it is not possible for an object to have type
void, nor are there arrays of void or references to void. It is used as
the return type of functions that do not return anything.</p>
<p>Moreover, a function may redundantly be declared with a single
parameter of type void; this is equivalent to declaring a function with
no parameters (e.g. int main() and int main(void) declare the same
function). This</p>
<p>syntax is allowed for compatibility with C (where function
declarations have a different meaning than in C++).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 108</p>
<p><span id="The_type_void____pointer_to_void" class="anchor"></span>The
type void* ("pointer to void") has the property that any object pointer
can be converted to it and back and result in the same pointer. This
feature makes the type void* suitable for certain kinds of (type-unsafe)
type-erasing</p>
<p>interfaces, for example for generic contexts in C-style APIs (e.g.
qsort, pthread_create).</p>
<p>Any expression may be converted to an expression of type void; this
is called a <em>discarded-value expression</em>:</p>
<p>static_cast(std::printf("Hello, %s!<strong>\n</strong>", name)); //
discard return value</p>
<p>This may be useful to signal explicitly that the value of an
expression is not of interest and that the expression is to</p>
<p>be evaluated for its side effects only.</p>
<p>Section 21.6: wchar_t</p>
<p>An integer type large enough to represent all characters of the
largest supported extended character set, also</p>
<p>known as the wide-character set. (It is not portable to make the
assumption that wchar_t uses any particular encoding, such as
UTF-16.)</p>
<p>It is normally used when you need to store characters over ASCII 255
, as it has a greater size than the character type char.</p>
<p>const wchar_t message_ahmaric[] = L" <strong>\\</strong>n"; //Ahmaric
for "hello, world\\n" const wchar_t message_chinese[] =
L"你好，世界<strong>\\</strong>n";// Chinese for "hello, world\\n" const
wchar_t message_hebrew[] = L"םלוע םולש<strong>\\</strong>n"; //Hebrew
for "hello, world\\n" const wchar_t message_russian[] = L"Привет
мир<strong>\\</strong>n"; //Russian for "hello, world\\n" const wchar_t
message_tamil[] = L"ஹலே◌◌ா உலகம◌்<strong>\\</strong>n"; //Tamil for
"hello, world\\n"</p>
<p>Section 21.7: float</p>
<p>A floating point type. Has the narrowest range out of the three
floating point types in C++.</p>
<p>float area(float radius) {</p>
<p>const float pi = 3.14159f;</p>
<p>return pi*radius*radius;</p>
<p>}</p>
<p>Section 21.8: double</p>
<p>A floating point type. Its range includes that of float. When
combined with long, denotes the long double floating</p>
<p>point type, whose range includes that of double.</p>
<p>double area(double radius) {</p>
<p>const double pi = 3.141592653589793;</p>
<p>return pi*radius*radius;</p>
<p>}</p>
<p>Section 21.9: long</p>
<p>Denotes a signed integer type that is at least as long as int, and
whose range includes at least -2147483647 to +2147483647, inclusive
(that is, -(2^31 - 1) to +(2^31 - 1)). This type can also be written as
long int.</p>
<p>const long approx_seconds_per_year = 60L*60L*24L*365L;</p>
<p>The combination long double denotes a floating point type, which has
the widest range out of the three floating</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 109</p>
<p><span id="point_types" class="anchor"></span>point types.</p>
<p>long double area(long double radius) {</p>
<p>const long double pi = 3.1415926535897932385L;</p>
<p>return pi*radius*radius;</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>When the long specifier occurs twice, as in long long, it denotes a
signed integer type that is at least as long as</p>
<p>long, and whose range includes at least -9223372036854775807 to
+9223372036854775807, inclusive (that is, -(2^63 - 1) to +(2^63 -
1)).</p>
<p>// support files up to 2 TiB</p>
<p>const long long max_file_size = 2LL &lt;&lt; 40;</p>
<p>Section 21.10: short</p>
<p>Denotes a signed integer type that is at least as long as char, and
whose range includes at least -32767 to +32767, inclusive. This type can
also be written as short int.</p>
<p>// (during the last year)</p>
<p>short hours_worked(short days_worked) {</p>
<p>return 8*days_worked;</p>
<p>}</p>
<p>Section 21.11: bool</p>
<p>An integer type whose value can be either true or false.</p>
<p>bool is_even(int x) {</p>
<p>return x%2 == 0;</p>
<p>}</p>
<p>const bool b = is_even(47); // false</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 110</p>
<p><span id="Chapter_22__Variable_Declaration_1"
class="anchor"></span>Chapter 22: Variable Declaration</p>
<p>Keywords</p>
<p>Section 22.1: decltype</p>
<p>Version ≥ C++11</p>
<p>Yields the type of its operand, which is not evaluated.</p>
<p>If the operand e is a name without any additional parentheses, then
decltype(e) is the <em>declared type</em> of e.</p>
<p>int x = 42;</p>
<p>std::vector v(100, x); // v is a vector</p>
<p>If the operand e is a class member access without any additional
parentheses, then decltype(e) is the <em>declared type</em> of the
member accessed.</p>
<p>struct S {</p>
<p>int x = 42;</p>
<p>};</p>
<p>const S s;</p>
<p>decltype(s.x) y; // y has type int, even though s.x is const</p>
<p>In all other cases, decltype(e) yields both the type and the value
category of the expression e, as follows:</p>
<p>If e is an lvalue of type T, then decltype(e) is T&amp;.</p>
<p>If e is an xvalue of type T, then decltype(e) is T&amp;&amp;.</p>
<p>If e is a prvalue of type T, then decltype(e) is T.</p>
<p>This includes the case with extraneous parentheses.</p>
<p>int f() { return 42; }</p>
<p>int&amp; g() { static int x = 42; return x; }</p>
<p>int x = 42;</p>
<p>decltype(f()) a = f(); // a has type int</p>
<p>decltype(g()) b = g(); // b has type int&amp;</p>
<p>decltype((x)) c = x; // c has type int&amp;, since x is an lvalue</p>
<p>Version ≥ C++14</p>
<p>The special form decltype(auto) deduces the type of a variable from
its initializer or the return type of a function</p>
<p>from the return statements in its definition, using the type
deduction rules of decltype rather than those of auto.</p>
<p>const int x = 123;</p>
<p>auto y = x; // y has type int</p>
<p>decltype(auto) z = x; // z has type const int, the declared type of
x</p>
<p>Section 22.2: const</p>
<p>A type specifier; when applied to a type, produces the
const-qualified version of the type. See const keyword for details on
the meaning of const.</p>
<p>const int x = 123;</p>
<p>x = 456; // error</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 111</p>
<p><span id="int__r___x_____error" class="anchor"></span>int&amp; r = x;
// error</p>
<p>struct S {</p>
<p>void f();</p>
<p>void g() const;</p>
<p>};</p>
<p>const S s;</p>
<p>s.f(); // error</p>
<p>s.g(); // OK</p>
<p>Section 22.3: volatile</p>
<p>A type qualifier; when applied to a type, produces the
volatile-qualified version of the type. Volatile qualification plays the
same role as const qualification in the type system, but volatile does
not prevent objects from being</p>
<p>modified; instead, it forces the compiler to treat all accesses to
such objects as side effects.</p>
<p>In the example below, if memory_mapped_port were not volatile, the
compiler could optimize the function so that it</p>
<p>performs only the final write, which would be incorrect if
sizeof(int) is greater than 1. The volatile qualification forces it to
treat all sizeof(int) writes as different side effects and hence perform
all of them (in order).</p>
<p>extern volatile char memory_mapped_port;</p>
<p>void write_to_device(int x) {</p>
<p>const char* p = reinterpret_cast(&amp;x);</p>
<p>for (int i = 0; i &lt; sizeof(int); i++) {</p>
<p>memory_mapped_port = p[i];</p>
<p>}</p>
<p>}</p>
<p>Section 22.4: signed</p>
<p>A keyword that is part of certain integer type names.</p>
<p>When used alone, int is implied, so that signed, signed int, and int
are the same type.</p>
<p>When combined with char, yields the type signed char, which is a
different type from char, even if char is also signed. signed char has a
range that includes at least -127 to +127, inclusive.</p>
<p>When combined with short, long, or long long, it is redundant, since
those types are already signed. signed cannot be combined with bool,
wchar_t, char16_t, or char32_t.</p>
<p>Example:</p>
<p>signed char celsius_temperature;</p>
<p>std::cin &gt;&gt; celsius_temperature;</p>
<p>if (celsius_temperature &lt;-35) {</p>
<p>std::cout &lt;&lt; "cold day, eh?<strong>\n</strong>";</p>
<p>}</p>
<p>Section 22.5: unsigned</p>
<p>A type specifier that requests the unsigned version of an integer
type.</p>
<p>When used alone, int is implied, so unsigned is the same type as
unsigned int. The type unsigned char is different from the type char,
even if char is unsigned. It can hold integers up to at</p>
<p>least 255.</p>
<p>unsigned can also be combined with short, long, or long long. It
cannot be combined with bool, wchar_t,</p>
<p>char16_t , or char32_t.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 112</p>
<p>Example:</p>
<p>char invert_case_table[256] = { ..., 'a', 'b', 'c', ..., 'A', 'B',
'C', ... }; char invert_case(char c) {</p>
<p>unsigned char index = c;</p>
<p>return invert_case_table[index];</p>
<p>// note: returning invert_case_table[c] directly does the // wrong
thing on implementations where char is a signed type</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 113</p>
<p><span id="Chapter_23__Keywords_1" class="anchor"></span>Chapter 23:
Keywords</p>
<p>Keywords have fixed meaning defined by the C++ standard and cannot be
used as identifiers. It is illegal to redefine</p>
<p>keywords using the preprocessor in any translation unit that includes
a standard library header. However, keywords lose their special meaning
inside attributes.</p>
<p>Section 23.1: asm</p>
<p>The asm keyword takes a single operand, which must be a string
literal. It has an implementation-defined meaning, but is typically
passed to the implementation's assembler, with the assembler's output
being incorporated into the</p>
<p>translation unit.</p>
<p>The asm statement is a <em>definition</em>, not an
<em>expression</em>, so it may appear either at block scope or namespace
scope</p>
<p>(including global scope). However, since inline assembly cannot be
constrained by the rules of the C++ language, asm may not appear inside
a constexpr function.</p>
<p>Example:</p>
<p>[[noreturn]] void halt_system() {</p>
<p>asm("hlt");</p>
<p>}</p>
<p>Section 23.2: Dierent keywords</p>
<p>void C++</p>
<p>1. When used as a function return type, the void keyword specifies
that the function does not return a value.</p>
<p>When used for a function's parameter list, void specifies that the
function takes no parameters. When used in the declaration of a pointer,
void specifies that the pointer is "universal."</p>
<p>2. If a pointer's type is void *, the pointer can point to any
variable that is not declared with the const or volatile</p>
<p>keyword. A void pointer cannot be dereferenced unless it is cast to
another type. A void pointer can be</p>
<p>converted into any other type of data pointer.</p>
<p>3. A void pointer can point to a function, but not to a class member
in C++.</p>
<p>void vobject; // C2182</p>
<p>void *pv; // okay</p>
<p>int *pint; int i;</p>
<p>int main() {</p>
<p>pv = &amp;i;</p>
<p>// Cast optional in C required in C++</p>
<p>pint = (int *)pv;</p>
<p>Volatile C++</p>
<p>1. A type qualifier that you can use to declare that an object can be
modified in the program by the hardware.</p>
<p>volatile declarator ;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 114</p>
<p>virtual C++</p>
<p>1. The virtual keyword declares a virtual function or a virtual base
class.</p>
<p>virtual [type-specifiers] member-function-declarator virtual
[access-specifier] base-class-name</p>
<p>Parameters</p>
<p>1. <strong>type-specifiers</strong> Specifies the return type of the
virtual member function.</p>
<p>2. <strong>member-function-declarator</strong> Declares a member
function.</p>
<p>3. <strong>access-specifier</strong> Defines the level of access to
the base class, public, protected or private. Can appear before</p>
<p>or after the virtual keyword.</p>
<p>4. <strong>base-class-name</strong> Identifies a previously declared
class type</p>
<p>this pointer</p>
<p>1. The this pointer is a pointer accessible only within the nonstatic
member functions of a class, struct, or union</p>
<p>type. It points to the object for which the member function is
called. Static member functions do not have a</p>
<p>this pointer.</p>
<p>this-&gt;member-identifier</p>
<p>An object's this pointer is not part of the object itself; it is not
reflected in the result of a sizeof statement on the</p>
<p>object. Instead, when a nonstatic member function is called for an
object, the address of the object is passed by the compiler as a hidden
argument to the function. For example, the following function call:</p>
<p>myDate.setMonth( 3 );</p>
<p>can be interpreted this way:</p>
<p>setMonth( &amp;myDate, 3 );</p>
<p>The object's address is available from within the member function as
the this pointer. Most uses of this are implicit.</p>
<p>It is legal, though unnecessary, to explicitly use this when
referring to members of the class. For example:</p>
<p>void Date::setMonth( int mn )</p>
<p>{</p>
<p>month = mn; // These three statements</p>
<p>this-&gt;month = mn; // are equivalent</p>
<p>(*this).month = mn;</p>
<p>}</p>
<p>The expression *this is commonly used to return the current object
from a member function: return *this; The this</p>
<p>pointer is also used to guard against self-reference:</p>
<p>if (&amp;Object != this) {</p>
<p>// do not execute in cases of self-reference</p>
<p>try, throw, and catch Statements (C++)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 115</p>
<p>1. To implement exception handling in C++, you use try, throw, and
catch expressions. 2. First, use a try block to enclose one or more
statements that might throw an exception.</p>
<p>3. A throw expression signals that an exceptional condition—often, an
error—has occurred in a try block. You</p>
<p>can use an object of any type as the operand of a throw expression.
Typically, this object is used to communicate information about the
error. In most cases, we recommend that you use the std::exception</p>
<p>class or one of the derived classes that are defined in the standard
library. If one of those is not appropriate,</p>
<p>we recommend that you derive your own exception class from
std::exception.</p>
<p>4. To handle exceptions that may be thrown, implement one or more
catch blocks immediately following a try</p>
<p>block. Each catch block specifies the type of exception it can
handle.</p>
<p>MyData md;</p>
<p>try {</p>
<p>// Code that could throw an exception</p>
<p>md = GetNetworkResource();</p>
<p>}</p>
<p>catch (const networkIOException&amp; e) {</p>
<p>// Code that executes when an exception of type</p>
<p>// networkIOException is thrown in the try block // ...</p>
<p>// Log error message in the exception object</p>
<p>cerr &lt;&lt; e.what();</p>
<p>}</p>
<p>catch (const myDataFormatException&amp; e) {</p>
<p>// Code that handles another exception type</p>
<p>// ...</p>
<p>cerr &lt;&lt; e.what();</p>
<p>}</p>
<p>// The following syntax shows a throw expression MyData
GetNetworkResource()</p>
<p>{</p>
<p>// ...</p>
<p>if (IOSuccess == false)</p>
<p>throw networkIOException("Unable to connect");</p>
<p>// ...</p>
<p>if (readError)</p>
<p>throw myDataFormatException("Format error");</p>
<p>// ...</p>
<p>}</p>
<p>The code after the try clause is the guarded section of code. The
throw expression throws—that is,</p>
<p>raises—an exception. The code block after the catch clause is the
exception handler. This is the handler</p>
<p>that catches the exception that's thrown if the types in the throw
and catch expressions are compatible.</p>
<p>try {</p>
<p>throw CSomeOtherException();</p>
<p>}</p>
<p>catch(...) {</p>
<p>// Catch all exceptions – dangerous!!!</p>
<p>// Respond (perhaps only partially) to the exception, then //
re-throw to pass the exception to some other handler // ...</p>
<p>throw;</p>
<p>}</p>
<p>friend (C++)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 116</p>
<p>1. In some circumstances, it is more convenient to grant member-level
access to functions that are not</p>
<p>members of a class or to all members in a separate class. Only the
class implementer can declare who its</p>
<p>friends are. A function or class cannot declare itself as a friend of
any class. In a class definition, use the</p>
<p>friend keyword and the name of a non-member function or other class
to grant it access to the private and protected members of your class.
In a template definition, a type parameter can be declared as a
friend.</p>
<p>2. If you declare a friend function that was not previously declared,
that function is exported to the enclosing</p>
<p>nonclass scope.</p>
<p>class friend F</p>
<p>friend F;</p>
<p>class ForwardDeclared;// Class name is known.</p>
<p>class HasFriends</p>
<p>{</p>
<p>friend int ForwardDeclared::IsAFriend();// C2039 error expected</p>
<p>};</p>
<p>friend functions</p>
<p>1. A friend function is a function that is not a member of a class
but has access to the class's private and</p>
<p>protected members.Friend functions are not considered class members;
they are normal external functions that are given special access
privileges.</p>
<p>2. Friends are not in the class's scope, and they are not called
using the member-selection operators (. and –&gt;)</p>
<p>unless they are members of another class.</p>
<p>3. A friend function is declared by the class that is granting
access. The friend declaration can be placed</p>
<p>anywhere in the class declaration. It is not affected by the access
control keywords.</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class Point</p>
<p>{</p>
<p>friend void ChangePrivate( Point &amp; );</p>
<p>public:</p>
<p>Point( void ) : m_i(0) {}</p>
<p>void PrintPrivate( void ){cout &lt;&lt; m_i &lt;&lt; endl; }</p>
<p>private:</p>
<p>int m_i;</p>
<p>};</p>
<p>void ChangePrivate ( Point &amp;i ) { i.m_i++; }</p>
<p>int main()</p>
<p>{</p>
<p>Point sPoint;</p>
<p>sPoint.PrintPrivate();</p>
<p>ChangePrivate(sPoint);</p>
<p>sPoint.PrintPrivate();</p>
<p>// Output: 0</p>
<p>1</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 117</p>
<p><span id="Class_members_as_friends" class="anchor"></span>Class
members as friends</p>
<p>class B;</p>
<p>class A {</p>
<p>public:</p>
<p>int Func1( B&amp; b );</p>
<p>private:</p>
<p>int Func2( B&amp; b );</p>
<p>};</p>
<p>class B {</p>
<p>private:</p>
<p>int _b;</p>
<p>// A::Func1 is a friend function to class B</p>
<p>// so A::Func1 has access to all members of B</p>
<p>friend int A::Func1( B&amp; );</p>
<p>};</p>
<p>int A::Func1( B&amp; b ) { return b._b; } // OK</p>
<p>int A::Func2( B&amp; b ) { return b._b; } // C2248</p>
<p>Section 23.3: typename</p>
<p>1. When followed by a qualified name, typename specifies that it is
the name of a type. This is often required in</p>
<p>templates, in particular, when the nested name specifier is a
dependent type other than the current</p>
<p>instantiation. In this example, std::decay depends on the template
parameter T, so in order to name the</p>
<p>nested type type, we need to prefix the entire qualified name with
typename. For more deatils, see <a
href="http://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">Where</a></p>
<p><a
href="http://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">and
why do I have to put the "template" and "typename" keywords?</a></p>
<p>template</p>
<p>auto decay_copy(T&amp;&amp; r)-&gt; typename std::decay::type;</p>
<p>2. Introduces a type parameter in the declaration of a template. In
this context, it is interchangeable with class.</p>
<p>template</p>
<p>const T&amp; min(const T&amp; x, const T&amp; y) {</p>
<p>return b &lt; a ? b : a;</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>3. typename can also be used when declaring a template template
parameter, preceding the name of the</p>
<p>parameter, just like class.</p>
<p>template typename U&gt;</p>
<p>void f() {</p>
<p>U::do_it();</p>
<p>U::do_it();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 118</p>
<p><span id="Section_23_4__explicit" class="anchor"></span>Section 23.4:
explicit</p>
<p>1. When applied to a single-argument constructor, prevents that
constructor from being used to perform</p>
<p>implicit conversions.</p>
<p>class MyVector {</p>
<p>public:</p>
<p>explicit MyVector(uint64_t size);</p>
<p>};</p>
<p>MyVector v1(100); // ok</p>
<p>uint64_t len1 = 100;</p>
<p>MyVector v2{len1}; // ok, len1 is uint64_t</p>
<p>int len2 = 100;</p>
<p>MyVector v3{len2}; // ill-formed, implicit conversion from int to
uint64_t</p>
<p>Since C++11 introduced initializer lists, in C++11 and later,
explicit can be applied to a constructor with any number of arguments,
with the same meaning as in the single-argument case.</p>
<p>struct S {</p>
<p>explicit S(int x, int y);</p>
<p>};</p>
<p>S f() {</p>
<p>return {12, 34}; // ill-formed</p>
<p>return S{12, 34}; // ok</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>2. When applied to a conversion function, prevents that conversion
function from being used to perform</p>
<p>implicit conversions.</p>
<p>class C {</p>
<p>const int x;</p>
<p>public:</p>
<p>C(int x) : x(x) {}</p>
<p>explicit operator int() { return x; }</p>
<p>};</p>
<p>C c(42);</p>
<p>int x = c; // ill-formed</p>
<p>int y = static_cast(c); // ok; explicit conversion</p>
<p>Section 23.5: sizeof</p>
<p>A unary operator that yields the size in bytes of its operand, which
may be either an expression or a type. If the</p>
<p>operand is an expression, it is not evaluated. The size is a constant
expression of type std::size_t.</p>
<p>If the operand is a type, it must be parenthesized.</p>
<p>It is illegal to apply sizeof to a function type.</p>
<p>It is illegal to apply sizeof to an incomplete type, including
void.</p>
<p>If sizeof is applied to a reference type T&amp; or T&amp;&amp;, it is
equivalent to sizeof(T). When sizeof is applied to a class type, it
yields the number of bytes in a complete object of that type,</p>
<p>including any padding bytes in the middle or at the end. Therefore, a
sizeof expression can never have a value of 0. See layout of object
types for more details.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 119</p>
<p><span id="The_char__signed_char__and_unsig" class="anchor"></span>The
char, signed char, and unsigned char types have a size of 1. Conversely,
a byte is defined to be the amount of memory required to store a char
object. It does not necessarily mean 8 bits, as some systems</p>
<p>have char objects longer than 8 bits.</p>
<p>If <em>expr</em> is an expression, sizeof(<em>expr</em>) is
equivalent to sizeof(T) where T is the type of <em>expr.</em></p>
<p>int a[100];</p>
<p>std::cout &lt;&lt; "The number of bytes in `a` is: " &lt;&lt; sizeof
a; memset(a, 0, sizeof a); // zeroes out the array</p>
<p>Version ≥ C++11</p>
<p>The sizeof... operator yields the number of elements in a parameter
pack.</p>
<p>template</p>
<p>void f(T&amp;&amp;...) {</p>
<p>std::cout &lt;&lt; "f was called with " &lt;&lt; sizeof...(T)
&lt;&lt; " arguments<strong>\n</strong>"; }</p>
<p>Section 23.6: noexcept</p>
<p>Version ≥ C++11</p>
<p>1. A unary operator that determines whether the evaluation of its
operand can propagate an exception. Note</p>
<p>that the bodies of called functions are not examined, so noexcept can
yield false negatives. The operand is</p>
<p>not evaluated.</p>
<p>#include</p>
<p>#include</p>
<p>void foo() { throw std::runtime_error("oops"); }</p>
<p>void bar() {}</p>
<p>struct S {};</p>
<p>int main() {</p>
<p>std::cout &lt;&lt; noexcept(foo()) &lt;&lt; '<strong>\n</strong>'; //
prints 0</p>
<p>std::cout &lt;&lt; noexcept(bar()) &lt;&lt; '<strong>\n</strong>'; //
prints 0</p>
<p>std::cout &lt;&lt; noexcept(1 + 1) &lt;&lt; '<strong>\n</strong>'; //
prints 1</p>
<p>std::cout &lt;&lt; noexcept(S()) &lt;&lt; '<strong>\n</strong>'; //
prints 1</p>
<p>}</p>
<p>In this example, even though bar() can never throw an exception,
noexcept(bar()) is still false because the</p>
<p>fact that bar() cannot propagate an exception has not been explicitly
specified.</p>
<p>2. When declaring a function, specifies whether or not the function
can propagate an exception. Alone, it</p>
<p>declares that the function cannot propagate an exception. With a
parenthesized argument, it declares that</p>
<p>the function can or cannot propagate an exception depending on the
truth value of the argument.</p>
<p>void f1() { throw std::runtime_error("oops"); }</p>
<p>void f2() noexcept(false) { throw std::runtime_error("oops"); } void
f3() {}</p>
<p>void f4() noexcept {}</p>
<p>void f5() noexcept(true) {}</p>
<p>void f6() noexcept {</p>
<p>try {</p>
<p>f1();</p>
<p>} catch (const std::runtime_error&amp;) {}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 120</p>
<p>In this example, we have declared that f4, f5, and f6 cannot
propagate exceptions. (Although an exception can be thrown during
execution of f6, it is caught and not allowed to propagate out of the
function.) We have</p>
<p>declared that f2 may propagate an exception. When the noexcept
specifier is omitted, it is equivalent to</p>
<p>noexcept(false), so we have implicitly declared that f1 and f3 may
propagate exceptions, even though exceptions cannot actually be thrown
during the execution of f3.</p>
<p>Version ≥ C++17</p>
<p>Whether or not a function is noexcept is part of the function's type:
that is, in the example above, f1, f2, and f3</p>
<p>have different types from f4, f5, and f6. Therefore, noexcept is also
significant in function pointers, template arguments, and so on.</p>
<p>void g1() {}</p>
<p>void g2() noexcept {}</p>
<p>void (*p1)() noexcept = &amp;g1; // ill-formed, since g1 is not
noexcept void (*p2)() noexcept = &amp;g2; // ok; types match</p>
<p>void (*p3)() = &amp;g1; // ok; types match</p>
<p>void (*p4)() = &amp;g2; // ok; implicit conversion</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 121</p>
<p><span id="Chapter_24__Returning_several_va_1"
class="anchor"></span>Chapter 24: Returning several values from</p>
<p>a function</p>
<p>There are many situations where it is useful to return several values
from a function: for example, if you want to</p>
<p>input an item and return the price and number in stock, this
functionality could be useful. There are many ways to do this in C++,
and most involve the STL. However, if you wish to avoid the STL for some
reason, there are still</p>
<p>several ways to do this, including structs/classes and arrays.</p>
<p>Section 24.1: Using std::tuple</p>
<p>Version ≥ C++11</p>
<p>The type <a
href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple can
bundle any number of values, potentially including values of different
types, into a single</a></p>
<p>return object:</p>
<p>std::tuple foo(int a, int b) { // or auto (C++14)</p>
<p>return std::make_tuple(a + b, a - b, a * b, a / b);</p>
<p>}</p>
<p>In C++17, a braced initializer list can be used:</p>
<p>Version ≥ C++17</p>
<p>std::tuple foo(int a, int b) {</p>
<p>return {a + b, a - b, a * b, a / b};</p>
<p>}</p>
<p>Retrieving values from the returned tuple can be cumbersome,
requiring the use of the <a
href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>
template</p>
<p>function:</p>
<p>auto mrvs = foo(5, 12);</p>
<p>auto add = std::get&lt;0&gt;(mrvs);</p>
<p>auto sub = std::get&lt;1&gt;(mrvs);</p>
<p>auto mul = std::get&lt;2&gt;(mrvs);</p>
<p>auto div = std::get&lt;3&gt;(mrvs);</p>
<p>If the types can be declared before the function returns, then <a
href="http://en.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a>
can be employed to unpack a tuple into</p>
<p>existing variables:</p>
<p>int add, sub, mul, div;</p>
<p>std::tie(add, sub, mul, div) = foo(5, 12);</p>
<p><a href="http://en.cppreference.com/w/cpp/utility/tuple/ignore">If
one of the returned values is not needed, std::ignore</a> can be
used:</p>
<p>std::tie(add, sub, std::ignore, div) = foo(5, 12);</p>
<p>Version ≥ C++17</p>
<p>Structured bindings can be used to avoid std::tie:</p>
<p>auto [add, sub, mul, div] = foo(5,12);</p>
<p>If you want to return a tuple of lvalue references instead of a tuple
of values, use std::tie in place of</p>
<p><a
href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple">std::make_tuple</a>.</p>
<p>std::tuple minmax( int&amp; a, int&amp; b ) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 122</p>
<p><span id="if__b" class="anchor"></span>if (b</p>
<p>return std::tie(b,a);</p>
<p>else</p>
<p>return std::tie(a,b);</p>
<p>}</p>
<p>which permits</p>
<p>void increase_least(int&amp; a, int&amp; b) {</p>
<p>std::get&lt;0&gt;(minmax(a,b))++;</p>
<p>}</p>
<p>In some rare cases you'll use <a
href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple">std::forward_as_tuple
instead of</a> std::tie; be careful if you do so, as temporaries</p>
<p>may not last long enough to be consumed.</p>
<p>Section 24.2: Structured Bindings</p>
<p>Version ≥ C++17</p>
<p>C++17 introduces structured bindings, which makes it even easier to
deal with multiple return types, as you do not</p>
<p><a href="http://en.cppreference.com/w/cpp/utility/tuple/tie">need to
rely upon std::tie()</a> or do any manual tuple unpacking:</p>
<p>std::map m;</p>
<p>// insert an element into the map and check if insertion succeeded
auto [iterator, success] = m.insert({"Hello", 42});</p>
<p>if (success) {</p>
<p>// your code goes here</p>
<p>}</p>
<p>// iterate over all elements without having to use the cryptic
'first' and 'second' names for (auto const&amp; [key, value] : m) {</p>
<p>std::cout &lt;&lt; "The value for " &lt;&lt; key &lt;&lt; " is "
&lt;&lt; value &lt;&lt; '<strong>\n</strong>'; }</p>
<p>Structured bindings can be used by default with std::pair,
std::tuple, and any type whose non-static data</p>
<p>members are all either public direct members or members of an
unambiguous base class:</p>
<p>struct A { int x; };</p>
<p>struct B : A { int y; };</p>
<p>B foo();</p>
<p>// with structured bindings</p>
<p>const auto [x, y] = foo();</p>
<p>// equivalent code without structured bindings</p>
<p>const auto result = foo();</p>
<p>auto&amp; x = result.x;</p>
<p>auto&amp; y = result.y;</p>
<p>If you make your type "tuple-like" it will also automatically work
with your type. A tuple-like is a type with</p>
<p>appropriate tuple_size, tuple_element and get written:</p>
<p>namespace my_ns {</p>
<p>struct my_type {</p>
<p>int x;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 123</p>
<p><span id="double_d" class="anchor"></span>double d;</p>
<p>std::string s;</p>
<p>};</p>
<p>struct my_type_view {</p>
<p>my_type* ptr;</p>
<p>};</p>
<p>}</p>
<p>namespace std {</p>
<p>template&lt;&gt;</p>
<p>struct tuple_size : std::integral_constant {};</p>
<p>template&lt;&gt; struct tuple_element{ using type = int; };
template&lt;&gt; struct tuple_element{ using type = double; };
template&lt;&gt; struct tuple_element{ using type = std::string; };</p>
<p>}</p>
<p>namespace my_ns {</p>
<p>template</p>
<p>decltype(auto) get(my_type_view const&amp; v) {</p>
<p>if constexpr (I == 0)</p>
<p>return v.ptr-&gt;x;</p>
<p>else if constexpr (I == 1)</p>
<p>return v.ptr-&gt;d;</p>
<p>else if constexpr (I == 2)</p>
<p>return v.ptr-&gt;s;</p>
<p>static_assert(I &lt; 3, "Only 3 elements");</p>
<p>}</p>
<p>}</p>
<p>now this works:</p>
<p>my_ns::my_type t{1, 3.14, "hello world"};</p>
<p>my_ns::my_type_view foo() {</p>
<p>return {&amp;t};</p>
<p>}</p>
<p>int main() {</p>
<p>auto[x, d, s] = foo();</p>
<p>std::cout &lt;&lt; x &lt;&lt; ',' &lt;&lt; d &lt;&lt; ',' &lt;&lt; s
&lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>Section 24.3: Using struct</p>
<p>A <a href="http://en.cppreference.com/w/cpp/language/class">struct
can be used to bundle multiple return values:</a></p>
<p>Version ≥ C++11</p>
<p>struct foo_return_type {</p>
<p>int add;</p>
<p>int sub;</p>
<p>int mul;</p>
<p>int div;</p>
<p>};</p>
<p>foo_return_type foo(int a, int b) {</p>
<p>return {a + b, a - b, a * b, a / b};</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 124</p>
<p><span id="auto_calc___foo_5__12" class="anchor"></span>auto calc =
foo(5, 12);</p>
<p>Version &lt; C++11</p>
<p>Instead of assignment to individual fields, a constructor can be used
to simplify the constructing of returned values:</p>
<p>struct foo_return_type {</p>
<p>int add;</p>
<p>int sub;</p>
<p>int mul;</p>
<p>int div;</p>
<p>foo_return_type(int add, int sub, int mul, int div)</p>
<p>: add(add), sub(sub), mul(mul), div(div) {}</p>
<p>};</p>
<p>foo_return_type foo(int a, int b) {</p>
<p>return foo_return_type(a + b, a - b, a * b, a / b);</p>
<p>}</p>
<p>foo_return_type calc = foo(5, 12);</p>
<p>The individual results returned by the function foo() can be
retrieved by accessing the member variables of the struct calc:</p>
<p>std::cout &lt;&lt; calc.add &lt;&lt; ' ' &lt;&lt; calc.sub &lt;&lt; '
' &lt;&lt; calc.mul &lt;&lt; ' ' &lt;&lt; calc.div &lt;&lt;
'<strong>\n</strong>';</p>
<p>Output:</p>
<p>17 -7 60 0</p>
<p>Note: When using a struct, the returned values are grouped together
in a single object and accessible using</p>
<p>meaningful names. This also helps to reduce the number of extraneous
variables created in the scope of the returned values.</p>
<p>Version ≥ C++17</p>
<p>In order to unpack a struct returned from a function, structured
bindings can be used. This places the out-</p>
<p>parameters on an even footing with the in-parameters:</p>
<p>int a=5, b=12;</p>
<p>auto[add, sub, mul, div] = foo(a, b);</p>
<p>std::cout &lt;&lt; add &lt;&lt; ' ' &lt;&lt; sub &lt;&lt; ' '
&lt;&lt; mul &lt;&lt; ' ' &lt;&lt; div &lt;&lt;
'<strong>\n</strong>';</p>
<p>The output of this code is identical to that above. The struct is
still used to return the values from the function. This permits you do
deal with the fields individually.</p>
<p>Section 24.4: Using Output Parameters</p>
<p>Parameters can be used for returning one or more values; those
parameters are required to be non-const pointers</p>
<p>or references.</p>
<p>References:</p>
<p>void calculate(int a, int b, int&amp; c, int&amp; d, int&amp; e,
int&amp; f) {</p>
<p>c = a + b;</p>
<p>d = a - b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 125</p>
<p><span id="e___a___b" class="anchor"></span>e = a * b;</p>
<p>f = a / b;</p>
<p>}</p>
<p>Pointers:</p>
<p>void calculate(int a, int b, int* c, int* d, int* e, int* f) {</p>
<p>*c = a + b;</p>
<p>*d = a - b;</p>
<p>*e = a * b;</p>
<p>*f = a / b;</p>
<p>}</p>
<p>Some libraries or frameworks use an empty 'OUT' #define to make it
abundantly obvious which parameters are</p>
<p>output parameters in the function signature. This has no functional
impact, and will be compiled out, but makes the function signature a bit
clearer;</p>
<p>#define OUT</p>
<p>void calculate(int a, int b, OUT int&amp; c) {</p>
<p>c = a + b;</p>
<p>}</p>
<p>Section 24.5: Using a Function Object Consumer</p>
<p>We can provide a consumer that will be called with the multiple
relevant values:</p>
<p>Version ≥ C++11</p>
<p>template</p>
<p>void foo(int a, int b, F consumer) {</p>
<p>consumer(a + b, a - b, a * b, a / b);</p>
<p>}</p>
<p>// use is simple... ignoring some results is possible as well foo(5,
12, [](int sum, int , int , int ){</p>
<p>std::cout &lt;&lt; "sum is " &lt;&lt; sum &lt;&lt;
'<strong>\n</strong>';</p>
<p>});</p>
<p><a
href="https://en.wikipedia.org/wiki/Continuation-passing_style">This is
known as "continuation passing style".</a></p>
<p>You can adapt a function returning a tuple into a continuation
passing style function via:</p>
<p>Version ≥ C++17</p>
<p>template</p>
<p>struct continuation {</p>
<p>Tuple t;</p>
<p>template</p>
<p>decltype(auto) operator-&gt;*(F&amp;&amp; f)&amp;&amp;{</p>
<p>return std::apply( std::forward(f), std::move(t) );</p>
<p>}</p>
<p>};</p>
<p>std::tuple foo(int a, int b);</p>
<p>continuation(foo(5,12))-&gt;*[](int sum, auto&amp;&amp;...) {</p>
<p>std::cout &lt;&lt; "sum is " &lt;&lt; sum &lt;&lt;
'<strong>\n</strong>';</p>
<p>};</p>
<p>with more complex versions being writable in C++14 or C++11.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 126</p>
<p><span id="Section_24_6__Using_std__pair"
class="anchor"></span>Section 24.6: Using std::pair</p>
<p><a href="http://en.cppreference.com/w/cpp/utility/pair">The struct
template std::pair can bundle together</a> <em>exactly</em> two return
values, of any two types:</p>
<p>#include</p>
<p>std::pair foo(int a, int b) {</p>
<p>return std::make_pair(a+b, a-b);</p>
<p>}</p>
<p>With C++11 or later, an initializer list can be used instead of
std::make_pair:</p>
<p>Version ≥ C++11</p>
<p>#include</p>
<p>std::pair foo(int a, int b) {</p>
<p>return {a+b, a-b};</p>
<p>}</p>
<p>The individual values of the returned std::pair can be retrieved by
using the pair's first and second member objects:</p>
<p>std::pair mrvs = foo(5, 12);</p>
<p>std::cout &lt;&lt; mrvs.first + mrvs.second &lt;&lt; std::endl;</p>
<p>Output:</p>
<p>10</p>
<p>Section 24.7: Using std::array</p>
<p>Version ≥ C++11</p>
<p>The container std::array can bundle together a fixed number of return
values. This number has to be known at compile-time and all return
values have to be of the same type:</p>
<p>std::array bar(int a, int b) {</p>
<p>return { a + b, a - b, a * b, a / b };</p>
<p>}</p>
<p>This replaces c style arrays of the form int bar[4]. The advantage
being that various c++ std functions can now be</p>
<p>used on it. It also provides useful member functions like at which is
a safe member access function with bound checking, and size which allows
you to return the size of the array without calculation.</p>
<p>Section 24.8: Using Output Iterator</p>
<p>Several values of the same type can be returned by passing an output
iterator to the function. This is particularly</p>
<p>common for generic functions (like the algorithms of the standard
library).</p>
<p>Example:</p>
<p>template void generate_sequence(Incrementable from, Incrementable to,
OutputIterator output) {</p>
<p>for (Incrementable k = from; k != to; ++k)</p>
<p>*output++ = k;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 127</p>
<p><span id="_9" class="anchor"></span>}</p>
<p>Example usage:</p>
<p>std::vector digits;</p>
<p>generate_sequence(0, 10, std::back_inserter(digits)); // digits now
contains {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</p>
<p>Section 24.9: Using std::vector</p>
<p>A std::vector can be useful for returning a dynamic number of
variables of the same type. The following example uses int as data type,
but a std::vector can hold any type that is trivially copyable:</p>
<p>#include</p>
<p>#include</p>
<p>// the following function returns all integers between and including
'a' and 'b' in a vector // (the function can return up to
std::vector::max_size elements with the vector, given that // the
system's main memory can hold that many items) std::vector
fillVectorFrom(int a, int b) {</p>
<p>std::vector temp;</p>
<p>for (int i = a; i &lt;= b; i++) {</p>
<p>temp.push_back(i);</p>
<p>}</p>
<p>return temp;</p>
<p>}</p>
<p>int main() {</p>
<p>// assigns the filled vector created inside the function to the new
vector 'v'</p>
<p>std::vector v = fillVectorFrom(1, 10);</p>
<p>// prints "1 2 3 4 5 6 7 8 9 10 "</p>
<p>for (int i = 0; i &lt; v.size(); i++) {</p>
<p>std::cout &lt;&lt; v[i] &lt;&lt; " ";</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 128</p>
<p><span id="Chapter_25__Polymorphism_1" class="anchor"></span>Chapter
25: Polymorphism</p>
<p>Section 25.1: Define polymorphic classes</p>
<p>The typical example is an abstract shape class, that can then be
derived into squares, circles, and other concrete shapes.</p>
<p>The parent class:</p>
<p>Let's start with the polymorphic class:</p>
<p>class Shape {</p>
<p>public:</p>
<p>virtual ~Shape() = default;</p>
<p>virtual double get_surface() const = 0;</p>
<p>virtual void describe_object() const { std::cout &lt;&lt; "this is a
shape" &lt;&lt; std::endl; }</p>
<p>double get_doubled_surface() const { return 2 * get_surface(); }</p>
<p>};</p>
<p>How to read this definition ?</p>
<p>You can define polymorphic behavior by introduced member functions
with the keyword virtual. Here</p>
<p>get_surface() and describe_object() will obviously be implemented
differently for a square than for a circle. When the function is invoked
on an object, function corresponding to the real class of the object
will be</p>
<p>determined at runtime.</p>
<p>It makes no sense to define get_surface() for an abstract shape. This
is why the function is followed by = 0. This means that the function is
<em>pure virtual function</em>.</p>
<p>A polymorphic class should always define a virtual destructor.</p>
<p>You may define non virtual member functions. When these function will
be invoked for an object, the function will be chosen depending on the
class used at compile-time. Here get_double_surface() is defined</p>
<p>in this way.</p>
<p>A class that contains at least one pure virtual function is an
abstract class. Abstract classes cannot be instantiated. You may only
have pointers or references of an abstract class type.</p>
<p>Derived classes</p>
<p>Once a polymorphic base class is defined you can derive it. For
example:</p>
<p>class Square : public Shape {</p>
<p>Point top_left;</p>
<p>double side_length;</p>
<p>public:</p>
<p>Square (const Point&amp; top_left, double side)</p>
<p>: top_left(top_left), side_length(side_length) {}</p>
<p>double get_surface() override { return side_length * side_length; }
void describe_object() override {</p>
<p>std::cout &lt;&lt; "this is a square starting at " &lt;&lt;
top_left.x &lt;&lt; ", " &lt;&lt; top_left.y</p>
<p>&lt;&lt; " with a length of " &lt;&lt; side_length &lt;&lt;
std::endl;</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 129</p>
<p><span id="Some_explanations" class="anchor"></span>Some
explanations:</p>
<p>You can define or override any of the virtual functions of the parent
class. The fact that a function was virtual</p>
<p>in the parent class makes it virtual in the derived class. No need to
tell the compiler the keyword virtual again. But it's recommended to add
the keyword override at the end of the function declaration, in order
to</p>
<p>prevent subtle bugs caused by unnoticed variations in the function
signature. If all the pure virtual functions of the parent class are
defined you can instantiate objects for this class, else it</p>
<p>will also become an abstract class.</p>
<p>You are not obliged to override all the virtual functions. You can
keep the version of the parent if it suits your need.</p>
<p>Example of instantiation</p>
<p>int main() {</p>
<p>Square square(Point(10.0, 0.0), 6); // we know it's a square, the
compiler also</p>
<p>square.describe_object();</p>
<p>std::cout &lt;&lt; "Surface: " &lt;&lt; square.get_surface() &lt;&lt;
std::endl;</p>
<p>Circle circle(Point(0.0, 0.0), 5);</p>
<p>Shape *ps = nullptr; // we don't know yet the real type of the
object</p>
<p>ps = &amp;circle; // it's a circle, but it could as well be a
square</p>
<p>ps-&gt;describe_object();</p>
<p>std::cout &lt;&lt; "Surface: " &lt;&lt; ps-&gt;get_surface() &lt;&lt;
std::endl; }</p>
<p>Section 25.2: Safe downcasting</p>
<p>Suppose that you have a pointer to an object of a polymorphic
class:</p>
<p>Shape *ps; // see example on defining a polymorphic class ps =
get_a_new_random_shape(); // if you don't have such a function yet,
you</p>
<p>// could just write ps = new Square(0.0,0.0, 5);</p>
<p>a downcast would be to cast from a general polymorphic Shape down to
one of its derived and more specific shape like Square or Circle.</p>
<p>Why to downcast ?</p>
<p>Most of the time, you would not need to know which is the real type
of the object, as the virtual functions allow you to manipulate your
object independently of its type:</p>
<p>std::cout &lt;&lt; "Surface: " &lt;&lt; ps-&gt;get_surface() &lt;&lt;
std::endl;</p>
<p>If you don't need any downcast, your design would be perfect.</p>
<p>However, you may need sometimes to downcast. A typical example is
when you want to invoke a non virtual</p>
<p>function that exist only for the child class.</p>
<p>Consider for example circles. Only circles have a diameter. So the
class would be defined as :</p>
<p>class Circle: public Shape { // for Shape, see example on defining a
polymorphic class</p>
<p>Point center;</p>
<p>double radius;</p>
<p>public:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 130</p>
<p><span id="Circle__const_Point__center__dou"
class="anchor"></span>Circle (const Point&amp; center, double
radius)</p>
<p>: center(center), radius(radius) {}</p>
<p>double get_surface() const override { return r * r * M_PI; }</p>
<p>// this is only for circles. Makes no sense for other shapes double
get_diameter() const { return 2 * r; }</p>
<p>};</p>
<p>The get_diameter() member function only exist for circles. It was not
defined for a Shape object:</p>
<p>Shape* ps = get_any_shape();</p>
<p>ps-&gt;get_diameter(); // OUCH !!! Compilation error</p>
<p>How to downcast ?</p>
<p>If you'd know for sure that ps points to a circle you could opt for a
static_cast:</p>
<p>std::cout &lt;&lt; "Diameter: " &lt;&lt;
static_cast(ps)-&gt;get_diameter() &lt;&lt; std::endl;</p>
<p>This will do the trick. But it's very risky: if ps appears to by
anything else than a Circle the behavior of your code</p>
<p>will be undefined.</p>
<p>So rather than playing Russian roulette, you should safely use a
dynamic_cast. This is specifically for polymorphic</p>
<p>classes :</p>
<p>int main() {</p>
<p>Circle circle(Point(0.0, 0.0), 10);</p>
<p>Shape &amp;shape = circle;</p>
<p>std::cout &lt;&lt; "The shape has a surface of " &lt;&lt;
shape.get_surface() &lt;&lt; std::endl;</p>
<p>//shape.get_diameter(); // OUCH !!! Compilation error</p>
<p>Circle *pc = dynamic_cast(&amp;shape); // will be nullptr if ps
wasn't a circle</p>
<p>if (pc)</p>
<p>std::cout &lt;&lt; "The shape is a circle of diameter " &lt;&lt;
pc-&gt;get_diameter() &lt;&lt; std::endl;</p>
<p>else</p>
<p>std::cout &lt;&lt; "The shape isn't a circle !" &lt;&lt; std::endl;
}</p>
<p>Note that dynamic_cast is not possible on a class that is not
polymorphic. You'd need at least one virtual function in the class or
its parents to be able to use it.</p>
<p>Section 25.3: Polymorphism &amp; Destructors</p>
<p>If a class is intended to be used polymorphically, with derived
instances being stored as base pointers/references, its base class'
destructor should be either virtual or protected. In the former case,
this will cause object</p>
<p>destruction to check the vtable, automatically calling the correct
destructor based on the dynamic type. In the latter case, destroying the
object through a base class pointer/reference is disabled, and the
object can only be</p>
<p>deleted when explicitly treated as its actual type.</p>
<p>struct VirtualDestructor {</p>
<p>virtual ~VirtualDestructor() = default;</p>
<p>};</p>
<p>struct VirtualDerived : VirtualDestructor {};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 131</p>
<p>struct ProtectedDestructor {</p>
<p>protected:</p>
<p>~ProtectedDestructor() = default;</p>
<p>};</p>
<p>struct ProtectedDerived : ProtectedDestructor {</p>
<p>~ProtectedDerived() = default;</p>
<p>};</p>
<p>// ...</p>
<p>VirtualDestructor* vd = new VirtualDerived;</p>
<p>delete vd; // Looks up VirtualDestructor::~VirtualDestructor() in
vtable, sees it's</p>
<p>// VirtualDerived::~VirtualDerived(), calls that.</p>
<p>ProtectedDestructor* pd = new ProtectedDerived;</p>
<p>delete pd; // Error: ProtectedDestructor::~ProtectedDestructor() is
protected. delete static_cast(pd); // Good.</p>
<p>Both of these practices guarantee that the derived class' destructor
will always be called on derived class instances, preventing memory
leaks.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 132</p>
<p><span id="Chapter_26__References_1" class="anchor"></span>Chapter 26:
References</p>
<p>Section 26.1: Defining a reference</p>
<p>References behaves similarly, but not entirely like const pointers. A
reference is defined by suffixing an ampersand &amp; to a type name.</p>
<p>int i = 10;</p>
<p>int &amp;refi = i;</p>
<p>Here, refi is a reference bound to i.</p>
<p>References abstracts the semantics of pointers, acting like an alias
to the underlying object:</p>
<p>refi = 20; // i = 20;</p>
<p>You can also define multiple references in a single definition:</p>
<p>int i = 10, j = 20;</p>
<p>int &amp;refi = i, &amp;refj = j;</p>
<p>// Common pitfall :</p>
<p>// int&amp; refi = i, k = j;</p>
<p>// refi will be of type int&amp;.</p>
<p>// though, k will be of type int, not int&amp;!</p>
<p>References <strong>must</strong> be initialized correctly at the time
of definition, and cannot be modified afterwards. The following</p>
<p>piece of codes causes a compile error:</p>
<p>int &amp;i; // error: declaration of reference variable 'i' requires
an initializer</p>
<p>You also cannot bind directly a reference to nullptr, unlike
pointers:</p>
<p>int *const ptri = nullptr;</p>
<p>int &amp;refi = nullptr; // error: non-const lvalue reference to type
'int' cannot bind to a temporary of type 'nullptr_t'</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 133</p>
<p><span id="Chapter_27__Value_and_Reference_1"
class="anchor"></span>Chapter 27: Value and Reference</p>
<p>Semantics</p>
<p>Section 27.1: Definitions</p>
<p>A type has value semantics if the object's observable state is
functionally distinct from all other objects of that type. This means
that if you copy an object, you have a new object, and modifications of
the new object will not be in any</p>
<p>way visible from the old object.</p>
<p>Most basic C++ types have value semantics:</p>
<p>int i = 5;</p>
<p>int j = i; //Copied</p>
<p>j += 20;</p>
<p>std::cout &lt;&lt; i; //Prints 5; i is unaffected by changes to
j.</p>
<p>Most standard-library defined types have value semantics too:</p>
<p>std::vector v1(5, 12); //array of 5 values, 12 in each. std::vector
v2 = v1; //Copies the vector.</p>
<p>v2[3] = 6; v2[4] = 9;</p>
<p>std::cout &lt;&lt; v1[3] &lt;&lt; " " &lt;&lt; v1[4]; //Writes "12
12", since v1 is unchanged.</p>
<p>A type is said to have reference semantics if an instance of that
type can share its observable state with another object (external to
it), such that manipulating one object will cause the state to change
within another object.</p>
<p>C++ pointers have value semantics with regard to which object they
point to, but they have reference semantics with regard to the
<em>state</em> of the object they point to:</p>
<p>int *pi = new int(4);</p>
<p>int *pi2 = pi;</p>
<p>pi = new int(16);</p>
<p>assert(pi2 != pi); //Will always pass.</p>
<p>int *pj = pi;</p>
<p>*pj += 5;</p>
<p>std::cout &lt;&lt; *pi; //Writes 9, since `pi` and `pj` reference the
same object.</p>
<p>C++ references have reference semantics as well.</p>
<p>Section 27.2: Deep copying and move support</p>
<p>If a type wishes to have value semantics, and it needs to store
objects that are dynamically allocated, then on copy operations, the
type will need to allocate new copies of those objects. It must also do
this for copy assignment.</p>
<p>This kind of copying is called a "deep copy". It effectively takes
what would have otherwise been reference semantics and turns it into
value semantics:</p>
<p>struct Inner {int i;};</p>
<p>const int NUM_INNER = 5;</p>
<p>class Value</p>
<p>{</p>
<p>private:</p>
<p>Inner *array_; //Normally has reference semantics.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 134</p>
<p>public:</p>
<p>Value() : array_(new Inner[NUM_INNER]){}</p>
<p>~Value() {delete[] array_;}</p>
<p>Value(const Value &amp;val) : array_(new Inner[NUM_INNER])</p>
<p>{</p>
<p>for(int i = 0; i &lt; NUM_INNER; ++i)</p>
<p>array_[i] = val.array_[i];</p>
<p>}</p>
<p>Value &amp;operator=(const Value &amp;val)</p>
<p>{</p>
<p>for(int i = 0; i &lt; NUM_INNER; ++i)</p>
<p>array_[i] = val.array_[i];</p>
<p>return *this;</p>
<p>}</p>
<p>};</p>
<p>Version ≥ C++11</p>
<p>Move semantics allow a type like Value to avoid truly copying its
referenced data. If the user uses the value in a way that provokes a
move, the "copied" from object can be left empty of the data it
referenced:</p>
<p>struct Inner {int i;};</p>
<p>constexpr auto NUM_INNER = 5;</p>
<p>class Value</p>
<p>{</p>
<p>private:</p>
<p>Inner *array_; //Normally has reference semantics.</p>
<p>public:</p>
<p>Value() : array_(new Inner[NUM_INNER]){}</p>
<p>//OK to delete even if nullptr</p>
<p>~Value() {delete[] array_;}</p>
<p>Value(const Value &amp;val) : array_(new Inner[NUM_INNER])</p>
<p>{</p>
<p>for(int i = 0; i &lt; NUM_INNER; ++i)</p>
<p>array_[i] = val.array_[i];</p>
<p>}</p>
<p>Value &amp;operator=(const Value &amp;val)</p>
<p>{</p>
<p>for(int i = 0; i &lt; NUM_INNER; ++i)</p>
<p>array_[i] = val.array_[i];</p>
<p>return *this;</p>
<p>}</p>
<p>//Movement means no memory allocation.</p>
<p>//Cannot throw exceptions.</p>
<p>Value(Value &amp;&amp;val) noexcept : array_(val.array_)</p>
<p>{</p>
<p>//We've stolen the old value.</p>
<p>val.array_ = nullptr;</p>
<p>}</p>
<p>//Cannot throw exceptions.</p>
<p>Value &amp;operator=(Value &amp;&amp;val) noexcept</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 135</p>
<p>//Clever trick. Since `val` is going to be destroyed soon anyway,
//we swap his data with ours. His destructor will destroy our data.</p>
<p>std::swap(array_, val.array_);</p>
<p>}</p>
<p>};</p>
<p>Indeed, we can even make such a type non-copyable, if we want to
forbid deep copies while still allowing the object to be moved
around.</p>
<p>struct Inner {int i;};</p>
<p>constexpr auto NUM_INNER = 5;</p>
<p>class Value</p>
<p>{</p>
<p>private:</p>
<p>Inner *array_; //Normally has reference semantics.</p>
<p>public:</p>
<p>Value() : array_(new Inner[NUM_INNER]){}</p>
<p>//OK to delete even if nullptr</p>
<p>~Value() {delete[] array_;}</p>
<p>Value(const Value &amp;val) = delete;</p>
<p>Value &amp;operator=(const Value &amp;val) = delete;</p>
<p>//Movement means no memory allocation.</p>
<p>//Cannot throw exceptions.</p>
<p>Value(Value &amp;&amp;val) noexcept : array_(val.array_)</p>
<p>{</p>
<p>//We've stolen the old value.</p>
<p>val.array_ = nullptr;</p>
<p>}</p>
<p>//Cannot throw exceptions.</p>
<p>Value &amp;operator=(Value &amp;&amp;val) noexcept</p>
<p>{</p>
<p>//Clever trick. Since `val` is going to be destroyed soon anyway,
//we swap his data with ours. His destructor will destroy our data.</p>
<p>std::swap(array_, val.array_);</p>
<p>}</p>
<p>};</p>
<p>We can even apply the Rule of Zero, through the use of
unique_ptr:</p>
<p>struct Inner {int i;};</p>
<p>constexpr auto NUM_INNER = 5;</p>
<p>class Value</p>
<p>{</p>
<p>private:</p>
<p>unique_ptrarray_; //Move-only type.</p>
<p>public:</p>
<p>Value() : array_(new Inner[NUM_INNER]){}</p>
<p>//No need to explicitly delete. Or even declare.</p>
<p>~Value() = default; {delete[] array_;}</p>
<p>//No need to explicitly delete. Or even declare.</p>
<p>Value(const Value &amp;val) = default;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 136</p>
<p>Value &amp;operator=(const Value &amp;val) = default;</p>
<p>//Will perform an element-wise move.</p>
<p>Value(Value &amp;&amp;val) noexcept = default;</p>
<p>//Will perform an element-wise move.</p>
<p>Value &amp;operator=(Value &amp;&amp;val) noexcept = default;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 137</p>
<p><span id="Chapter_28__C___function__call_b_1"
class="anchor"></span>Chapter 28: C++ function "call by value" vs.</p>
<p>"call by reference"</p>
<p>The scope of this section is to explain the differences in theory and
implementation for what happens with the</p>
<p>parameters of a function upon calling.</p>
<p>In detail the parameters can be seen as variables before the function
call and inside the function, where the visible</p>
<p>behaviour and accessibility to these variables differs with the
method used to hand them over.</p>
<p>Additionally, the reusability of variables and their respective
values after the function call also is explained by this</p>
<p>topic.</p>
<p>Section 28.1: Call by value</p>
<p>Upon calling a function there are new elements created on the program
stack. These include some information</p>
<p>about the function and also space (memory locations) for the
parameters and the return value.</p>
<p>When handing over a parameter to a function the value of the used
variable (or literal) is copied into the memory location of the function
parameter. This implies that now there a two memory locations with the
same value. Inside</p>
<p>of the function we only work on the parameter memory location.</p>
<p>After leaving the function the memory on the program stack is popped
(removed) which erases all data of the</p>
<p>function call, including the memory location of the parameters we
used inside. Thus, the values changed inside the function do not affect
the outside variables values.</p>
<p>int func(int f, int b) {</p>
<p>//new variables are created and values from the outside copied //f
has a value of 0</p>
<p>//inner_b has a value of 1</p>
<p>f = 1;</p>
<p>//f has a value of 1</p>
<p>b = 2;</p>
<p>//inner_b has a value of 2</p>
<p>return f+b;</p>
<p>}</p>
<p>int main(void) {</p>
<p>int a = 0;</p>
<p>int b = 1; //outer_b</p>
<p>int c;</p>
<p>c = func(a,b);</p>
<p>//the return value is copied to c</p>
<p>//a has a value of 0</p>
<p>//outer_b has a value of 1 &lt;--- outer_b and inner_b are different
variables //c has a value of 3</p>
<p>}</p>
<p>In this code we create variables inside the main function. These get
assigned values. Upon calling the functions there are two new variables
created: f and inner_b where b shares the name with the outer variable
it does not</p>
<p>share the memory location. The behaviour of a&lt;-&gt;f and
b&lt;-&gt;b is identical.</p>
<p>The following graphic symbolizes what is happening on the stack and
why there is no change in varibale b. The</p>
<p>graphic is not fully accurate but emphazises the example.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 138</p>
<p><img src="media/index-157_1.jpeg"
style="width:6.5in;height:1.54167in" alt="index-157_1.jpg" /></p>
<p>It is called "call by value" because we do not hand over the
variables but only the values of these variables.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 139</p>
<p><span id="Chapter_29__Copying_vs_Assignmen_1"
class="anchor"></span>Chapter 29: Copying vs Assignment</p>
<p>rhs Right Hand Side of the equality for both copy and assignment
constructors. For example the assignment constructor : MyClass
operator=( MyClass&amp; rhs );</p>
<p>Placeholder Placeholder</p>
<p>Section 29.1: Assignment Operator</p>
<p>The Assignment Operator is when you replace the data with an already
existing(previously initialized) object with</p>
<p>some other object's data. Lets take this as an example:</p>
<p>// Assignment Operator</p>
<p>#include</p>
<p>#include</p>
<p>using std::cout;</p>
<p>using std::endl;</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p>Foo(int data)</p>
<p>{</p>
<p>this-&gt;data = data;</p>
<p>}</p>
<p>~Foo(){};</p>
<p>Foo&amp; operator=(const Foo&amp; rhs)</p>
<p>{</p>
<p>data = rhs.data;</p>
<p>return *this;</p>
<p>}</p>
<p>int data;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Foo foo(2); //Foo(int data) called</p>
<p>Foo foo2(42);</p>
<p>foo = foo2; // Assignment Operator Called</p>
<p>cout &lt;&lt; foo.data &lt;&lt; endl; //Prints 42</p>
<p>}</p>
<p>You can see here I call the assignment operator when I already
initialized the foo object. Then later I assign foo2 to foo . All the
changes to appear when you call that equal sign operator is defined in
your operator= function. You</p>
<p>can see a runnable output here: <a
href="http://cpp.sh/3qtbm">http://cpp.sh/3qtbm</a></p>
<p>Section 29.2: Copy Constructor</p>
<p>Copy constructor on the other hand , is the complete opposite of the
Assignment Constructor. This time, it is used</p>
<p>to initialize an already nonexistent(or non-previously initialized)
object. This means it copies all the data from the object you are
assigning it to , without actually initializing the object that is being
copied onto. Now Let's take a look</p>
<p>at the same code as before but modify the assignment constructor to
be a copy constructor :</p>
<p>// Copy Constructor</p>
<p>#include</p>
<p>#include</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 140</p>
<p><span id="using_std__cout" class="anchor"></span>using std::cout;</p>
<p>using std::endl;</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p>Foo(int data)</p>
<p>{</p>
<p>this-&gt;data = data;</p>
<p>}</p>
<p>~Foo(){};</p>
<p>Foo(const Foo&amp; rhs)</p>
<p>{</p>
<p>data = rhs.data;</p>
<p>}</p>
<p>int data;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Foo foo(2); //Foo(int data) called</p>
<p>Foo foo2 = foo; // Copy Constructor called</p>
<p>cout &lt;&lt; foo2.data &lt;&lt; endl;</p>
<p>}</p>
<p>You can see here Foo foo2 = foo; in the main function I immediately
assign the object before actually initializing it,</p>
<p>which as said before means it's a copy constructor. And notice that I
didn't need to pass the parameter int for the foo2 object since I
automatically pulled the previous data from the object foo. Here is an
example output :</p>
<p><a href="http://cpp.sh/5iu7">http://cpp.sh/5iu7</a></p>
<p>Section 29.3: Copy Constructor Vs Assignment Constructor</p>
<p>Ok we have briefly looked over what the copy constructor and
assignment constructor are above and gave</p>
<p>examples of each now let's see both of them in the same code. This
code will be similar as above two. Let's take this :</p>
<p>// Copy vs Assignment Constructor</p>
<p>#include</p>
<p>#include</p>
<p>using std::cout;</p>
<p>using std::endl;</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p>Foo(int data)</p>
<p>{</p>
<p>this-&gt;data = data;</p>
<p>}</p>
<p>~Foo(){};</p>
<p>Foo(const Foo&amp; rhs)</p>
<p>{</p>
<p>data = rhs.data;</p>
<p>}</p>
<p>Foo&amp; operator=(const Foo&amp; rhs)</p>
<p>{</p>
<p>data = rhs.data;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 141</p>
<p>return *this;</p>
<p>}</p>
<p>int data;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Foo foo(2); //Foo(int data) / Normal Constructor called</p>
<p>Foo foo2 = foo; //Copy Constructor Called</p>
<p>cout &lt;&lt; foo2.data &lt;&lt; endl;</p>
<p>Foo foo3(42);</p>
<p>foo3=foo; //Assignment Constructor Called</p>
<p>cout &lt;&lt; foo3.data &lt;&lt; endl;</p>
<p>}</p>
<p>Output:</p>
<p>2</p>
<p>2</p>
<p>Here you can see we first call the copy constructor by executing the
line Foo foo2 = foo; . Since we didn't initialize</p>
<p>it previously. And then next we call the assignment operator on foo3
since it was already initialized foo3=foo;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 142</p>
<p><span id="Chapter_30__Pointers_1" class="anchor"></span>Chapter 30:
Pointers</p>
<p>A pointer is an address that refers to a location in memory. They're
commonly used to allow functions or data</p>
<p>structures to know of and modify memory without having to copy the
memory referred to. Pointers are usable with both primitive (built-in)
or user-defined types.</p>
<p>Pointers make use of the "dereference" * , "address of" &amp; , and
"arrow" -&gt; operators. The '*' and '-&gt;' operators are used to
access the memory being pointed at, and the &amp; operator is used to
get an address in memory.</p>
<p>Section 30.1: Pointer Operations</p>
<p>There are two operators for pointers: Address-of operator (&amp;):
Returns the memory address of its operand. Contents-of (Dereference)
operator(*): Returns the value of the variable located at the address
specified by its</p>
<p>operator.</p>
<p>int var = 20;</p>
<p>int *ptr;</p>
<p>ptr = &amp;var;</p>
<p>cout &lt;&lt; var &lt;&lt; endl;</p>
<p>//Outputs 20 (The value of var)</p>
<p>cout &lt;&lt; ptr &lt;&lt; endl;</p>
<p>//Outputs 0x234f119 (var's memory location)</p>
<p>cout &lt;&lt; *ptr &lt;&lt; endl;</p>
<p>//Outputs 20(The value of the variable stored in the pointer ptr</p>
<p>The asterisk (*) is used in declaring a pointer for simple purpose of
indicating that it is a pointer. Don't confuse this</p>
<p>with the <strong>dereference</strong> operator, which is used to
obtain the value located at the specified address. They are simply two
different things represented with the same sign.</p>
<p>Section 30.2: Pointer basics</p>
<p>Version &lt; C++11</p>
<p><strong>Note:</strong> in all the following, the existence of the
C++11 constant nullptr is assumed. For earlier versions, replace</p>
<p>nullptr with NULL, the constant that used to play a similar role.</p>
<p>Creating a pointer variable</p>
<p>A pointer variable can be created using the specific * syntax, e.g.
int *pointer_to_int;.</p>
<p>When a variable is of a <em>pointer type</em> (int *), it just
contains a memory address. The memory address is the location at which
data of the <em>underlying type</em> (int) is stored.</p>
<p>The difference is clear when comparing the size of a variable with
the size of a pointer to the same type:</p>
<p>// Declare a struct type `big_struct` that contains // three long
long ints.</p>
<p>typedef struct {</p>
<p>long long int foo1;</p>
<p>long long int foo2;</p>
<p>long long int foo3;</p>
<p>} big_struct;</p>
<p>// Create a variable `bar` of type `big_struct`</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 143</p>
<p>big_struct bar;</p>
<p>// Create a variable `p_bar` of type `pointer to big_struct`. //
Initialize it to `nullptr` (a null pointer).</p>
<p>big_struct *p_bar0 = nullptr;</p>
<p>// Print the size of `bar`</p>
<p>std::cout &lt;&lt; "sizeof(bar) = " &lt;&lt; sizeof(bar) &lt;&lt;
std::endl; // Print the size of `p_bar`.</p>
<p>std::cout &lt;&lt; "sizeof(p_bar0) = " &lt;&lt; sizeof(p_bar0)
&lt;&lt; std::endl;</p>
<p>/* Produces:</p>
<p>sizeof(bar) = 24</p>
<p>sizeof(p_bar0) = 8</p>
<p>*/</p>
<p>Taking the address of another variable</p>
<p>Pointers can be assigned between each other just as normal variables;
in this case, it is the <strong>memory address</strong> that is</p>
<p>copied from one pointer to another, <strong>not the actual
data</strong> that a pointer points to.</p>
<p>Moreover, they can take the value nullptr which represents a null
memory location. A pointer equal to nullptr contains an invalid memory
location and hence it does not refer to valid data.</p>
<p>You can get the memory address of a variable of a given type by
prefixing the variable with the <em>address of</em> operator &amp;. The
value returned by &amp; is a pointer to the underlying type which
contains the memory address of the variable</p>
<p><strong>(which is valid data</strong> as long as the variable does
not go out of scope<strong>).</strong></p>
<p>// Copy `p_bar0` into `p_bar_1`.</p>
<p>big_struct *p_bar1 = p_bar0;</p>
<p>// Take the address of `bar` into `p_bar_2`</p>
<p>big_struct *p_bar2 = &amp;bar;</p>
<p>// p_bar1 is now nullptr, p_bar2 is &amp;bar.</p>
<p>p_bar0 = p_bar2;</p>
<p>// p_bar0 is now &amp;bar.</p>
<p>p_bar2 = nullptr;</p>
<p>// p_bar0 == &amp;bar</p>
<p>// p_bar1 == nullptr</p>
<p>// p_bar2 == nullptr</p>
<p>In contrast with references:</p>
<p>assigning two pointers does not overwrite the memory that the
assigned pointer refers to;</p>
<p>pointers can be null.</p>
<p>the <em>address of</em> operator is required explicitly.</p>
<p>Accessing the content of a pointer</p>
<p>As taking an address requires &amp;, as well accessing the content
requires the usage of the <em>dereference operator</em> *, as a</p>
<p>prefix. When a pointer is dereferenced, it becomes a variable of the
underlying type (actually, a reference to it). It</p>
<p>can then be read and modified, if not const.</p>
<p>(*p_bar0).foo1 = 5;</p>
<p>// `p_bar0` points to `bar`. This prints 5.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 144</p>
<p><span id="std__cout_____bar_foo1________ba"
class="anchor"></span>std::cout &lt;&lt; "bar.foo1 = " &lt;&lt; bar.foo1
&lt;&lt; std::endl;</p>
<p>// Assign the value pointed to by `p_bar0` to `baz`. big_struct
baz;</p>
<p>baz = *p_bar0;</p>
<p>// Now `baz` contains a copy of the data pointed to by `p_bar0`. //
Indeed, it contains a copy of `bar`.</p>
<p>// Prints 5 as well</p>
<p>std::cout &lt;&lt; "baz.foo1 = " &lt;&lt; baz.foo1 &lt;&lt;
std::endl;</p>
<p>The combination of * and the operator . is abbreviated by -&gt;:</p>
<p>std::cout &lt;&lt; "bar.foo1 = " &lt;&lt; (*p_bar0).foo1 &lt;&lt;
std::endl; // Prints 5 std::cout &lt;&lt; "bar.foo1 = " &lt;&lt;
p_bar0-&gt;foo1 &lt;&lt; std::endl; // Prints 5</p>
<p>Dereferencing invalid pointers</p>
<p>When dereferencing a pointer, you should make sure it points to valid
data. Dereferencing an invalid pointer (or a null pointer) can lead to
memory access violation, or to read or write garbage data.</p>
<p>big_struct *never_do_this() {</p>
<p>// This is a local variable. Outside `never_do_this` it doesn't
exist.</p>
<p>big_struct retval;</p>
<p>retval.foo1 = 11;</p>
<p>// This returns the address of `retval`.</p>
<p>return &amp;retval;</p>
<p>// `retval` is destroyed and any code using the value returned // by
`never_do_this` has a pointer to a memory location that // contains
garbage data (or is inaccessible).</p>
<p>}</p>
<p>In such scenario, g++ and clang++ correctly issue the warnings:</p>
<p>(Clang) warning: address of stack memory associated with local
variable 'retval' returned [-Wreturn-stack-address]</p>
<p>(Gcc) warning: address of local variable ‘retval’ returned
[-Wreturn-local-addr]</p>
<p>Hence, care must be taken when pointers are arguments of functions,
as they could be null:</p>
<p>void naive_code(big_struct *ptr_big_struct) {</p>
<p>// ... some code which doesn't check if `ptr_big_struct` is
valid.</p>
<p>ptr_big_struct-&gt;foo1 = 12;</p>
<p>}</p>
<p>// Segmentation fault.</p>
<p>naive_code(nullptr);</p>
<p>Section 30.3: Pointer Arithmetic</p>
<p>Increment / Decrement</p>
<p>A pointer can be incremented or decremented (prefix and postfix).
Incrementing a pointer advances the pointer</p>
<p>value to the element in the array one element past the currently
pointed to element. Decrementing a pointer moves it to the previous
element in the array.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 145</p>
<p>Pointer arithmetic is not permitted if the type that the pointer
points to is not complete. void is always an incomplete type.</p>
<p>char* str = new char[10]; // str = 0x010</p>
<p>++str; // str = 0x011 in this case sizeof(char) = 1 byte</p>
<p>int* arr = new int[10]; // arr = 0x00100</p>
<p>++arr; // arr = 0x00104 if sizeof(int) = 4 bytes</p>
<p>void* ptr = (void*)new char[10];</p>
<p>++ptr; // void is incomplete.</p>
<p>If a pointer to the end element is incremented, then the pointer
points to one element past the end of the array. Such a pointer cannot
be dereferenced, but it can be decremented.</p>
<p>Incrementing a pointer to the one-past-the-end element in the array,
or decrementing a pointer to the first element in an array yields
undefined behavior.</p>
<p>A pointer to a non-array object can be treated, for the purposes of
pointer arithmetic, as though it were an array of</p>
<p>size 1.</p>
<p>Addition / Subtraction</p>
<p>Integer values can be added to pointers; they act as incrementing,
but by a specific number rather than by 1.</p>
<p>Integer values can be subtracted from pointers as well, acting as
pointer decrementing. As with</p>
<p>incrementing/decrementing, the pointer must point to a complete
type.</p>
<p>char* str = new char[10]; // str = 0x010</p>
<p>str += 2; // str = 0x010 + 2 * sizeof(char) = 0x012</p>
<p>int* arr = new int[10]; // arr = 0x100</p>
<p>arr += 2; // arr = 0x100 + 2 * sizeof(int) = 0x108, assuming
sizeof(int) == 4.</p>
<p>Pointer Differencing</p>
<p>The difference between two pointers to the same type can be computed.
The two pointers must be within the same array object; otherwise
undefined behavior results.</p>
<p>Given two pointers P and Q in the same array, if P is the ith element
in the array, and Q is the jth element, then P -</p>
<p>Q shall be i - j. The type of the result is std::ptrdiff_t, from
<strong>&lt;cstddef&gt;</strong>.</p>
<p>char* start = new char[10]; // str = 0x010</p>
<p>char* test = &amp;start[5];</p>
<p>std::ptrdiff_t diff = test - start; //Equal to 5.</p>
<p>std::ptrdiff_t diff = start - test; //Equal to -5; ptrdiff_t is
signed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 146</p>
<p><span id="Chapter_31__Pointers_to_members_1"
class="anchor"></span>Chapter 31: Pointers to members</p>
<p>Section 31.1: Pointers to static member functions</p>
<p>A static member function is just like an ordinary C/C++ function,
except with scope:</p>
<p>It is inside a class, so it needs its name decorated with the class
name;</p>
<p>It has accessibility, with public, protected or private.</p>
<p>So, if you have access to the static member function and decorate it
correctly, then you can point to the function</p>
<p>like any normal function outside a class:</p>
<p>typedef int Fn(int); // Fn is a type-of function that accepts an int
and returns an int</p>
<p>// Note that MyFn() is of type 'Fn'</p>
<p>int MyFn(int i) { return 2*i; }</p>
<p>class Class {</p>
<p>public:</p>
<p>// Note that Static() is of type 'Fn'</p>
<p>static int Static(int i) { return 3*i; }</p>
<p>}; // Class</p>
<p>int main() {</p>
<p>Fn *fn; // fn is a pointer to a type-of Fn</p>
<p>fn = &amp;MyFn; // Point to one function</p>
<p>fn(3); // Call it</p>
<p>fn = &amp;Class::Static; // Point to the other function</p>
<p>fn(4); // Call it</p>
<p>} // main()</p>
<p>Section 31.2: Pointers to member functions</p>
<p>To access a member function of a class, you need to have a "handle"
to the particular instance, as either the instance itself, or a pointer
or reference to it. Given a class instance, you can point to various of
its members with a</p>
<p>pointer-to-member, IF you get the syntax correct! Of course, the
pointer has to be declared to be of the same type as what you are
pointing to...</p>
<p>typedef int Fn(int); // Fn is a type-of function that accepts an int
and returns an int</p>
<p>class Class {</p>
<p>public:</p>
<p>// Note that A() is of type 'Fn'</p>
<p>int A(int a) { return 2*a; }</p>
<p>// Note that B() is of type 'Fn'</p>
<p>int B(int b) { return 3*b; }</p>
<p>}; // Class</p>
<p>int main() {</p>
<p>Class c; // Need a Class instance to play with</p>
<p>Class *p = &amp;c; // Need a Class pointer to play with</p>
<p>Fn Class::*fn; // fn is a pointer to a type-of Fn within Class</p>
<p>fn = &amp;Class::A; // fn now points to A within any Class</p>
<p>(c.*fn)(5); // Pass 5 to c's function A (via fn)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 147</p>
<p><span id="fn____Class__B_______fn_now_poin" class="anchor"></span>fn
= &amp;Class::B; // fn now points to B within any Class</p>
<p>(p-&gt;*fn)(6); // Pass 6 to c's (via p) function B (via fn)</p>
<p>} // main()</p>
<p>Unlike pointers to member variables (in the previous example), the
association between the class instance and the member pointer need to be
bound tightly together with parentheses, which looks a little strange
(as though the .*</p>
<p>and -&gt;* aren't strange enough!)</p>
<p>Section 31.3: Pointers to member variables</p>
<p>To access a member of a class, you need to have a "handle" to the
particular instance, as either the instance itself,</p>
<p>or a pointer or reference to it. Given a class instance, you can
point to various of its members with a pointer-to-member, IF you get the
syntax correct! Of course, the pointer has to be declared to be of the
same type as what you</p>
<p>are pointing to...</p>
<p>class Class {</p>
<p>public:</p>
<p>int x, y, z;</p>
<p>char m, n, o;</p>
<p>}; // Class</p>
<p>int x; // Global variable</p>
<p>int main() {</p>
<p>Class c; // Need a Class instance to play with</p>
<p>Class *p = &amp;c; // Need a Class pointer to play with</p>
<p>int *p_i; // Pointer to an int</p>
<p>p_i = &amp;x; // Now pointing to x</p>
<p>p_i = &amp;c.x; // Now pointing to c's x</p>
<p>int Class::*p_C_i; // Pointer to an int within Class</p>
<p>p_C_i = &amp;Class::x; // Point to x within any Class</p>
<p>int i = c.*p_C_i; // Use p_c_i to fetch x from c's instance</p>
<p>p_C_i = &amp;Class::y; // Point to y within any Class</p>
<p>i = c.*p_C_i; // Use p_c_i to fetch y from c's instance</p>
<p>p_C_i = &amp;Class::m; // ERROR! m is a char, not an int!</p>
<p>char Class::*p_C_c = &amp;Class::m; // That's better...</p>
<p>} // main()</p>
<p>The syntax of pointer-to-member requires some extra syntactic
elements:</p>
<p>To define the type of the pointer, you need to mention the base type,
as well as the fact that it is inside a class: int Class::*ptr;.</p>
<p>If you have a class or reference and want to use it with a
pointer-to-member, you need to use the .* operator (akin to the .
operator).</p>
<p>If you have a pointer to a class and want to use it with a
pointer-to-member, you need to use the -&gt;*</p>
<p>operator (akin to the -&gt; operator).</p>
<p>Section 31.4: Pointers to static member variables</p>
<p>A static member variable is just like an ordinary C/C++ variable,
except with scope:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 148</p>
<p>It is inside a class, so it needs its name decorated with the class
name; It has accessibility, with public, protected or private.</p>
<p>So, if you have access to the static member variable and decorate it
correctly, then you can point to the variable like any normal variable
outside a class:</p>
<p>class Class {</p>
<p>public:</p>
<p>static int i;</p>
<p>}; // Class</p>
<p>int Class::i = 1; // Define the value of i (and where it's
stored!)</p>
<p>int j = 2; // Just another global variable</p>
<p>int main() {</p>
<p>int k = 3; // Local variable</p>
<p>int *p;</p>
<p>p = &amp;k; // Point to k</p>
<p>*p = 2; // Modify it</p>
<p>p = &amp;j; // Point to j</p>
<p>*p = 3; // Modify it</p>
<p>p = &amp;Class::i; // Point to Class::i</p>
<p>*p = 4; // Modify it</p>
<p>} // main()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 149</p>
<p><span id="Chapter_32__The_This_Pointer_1"
class="anchor"></span>Chapter 32: The This Pointer</p>
<p>Section 32.1: this Pointer</p>
<p>All non-static member functions have a hidden parameter, a pointer to
an instance of the class, named this; this parameter is silently
inserted at the beginning of the parameter list, and handled entirely by
the compiler. When a</p>
<p>member of the class is accessed inside a member function, it is
silently accessed through this; this allows the compiler to use a single
non-static member function for all instances, and allows a member
function to call other</p>
<p>member functions polymorphically.</p>
<p>struct ThisPointer {</p>
<p>int i;</p>
<p>ThisPointer(int ii);</p>
<p>virtual void func();</p>
<p>int get_i() const;</p>
<p>void set_i(int ii);</p>
<p>};</p>
<p>ThisPointer::ThisPointer(int ii) : i(ii) {}</p>
<p>// Compiler rewrites as:</p>
<p>ThisPointer::ThisPointer(int ii) : this-&gt;i(ii) {}</p>
<p>// Constructor is responsible for turning allocated memory into
'this'. // As the constructor is responsible for creating the object,
'this' will not be "fully" // valid until the instance is fully
constructed.</p>
<p><em>/* virtual */</em> void ThisPointer::func() {</p>
<p>if (some_external_condition) {</p>
<p>set_i(182);</p>
<p>} else {</p>
<p>i = 218;</p>
<p>}</p>
<p>}</p>
<p>// Compiler rewrites as:</p>
<p><em>/* virtual */</em> void ThisPointer::func(ThisPointer* this)
{</p>
<p>if (some_external_condition) {</p>
<p>this-&gt;set_i(182);</p>
<p>} else {</p>
<p>this-&gt;i = 218;</p>
<p>}</p>
<p>}</p>
<p>int ThisPointer::get_i() const { return i; }</p>
<p>// Compiler rewrites as:</p>
<p>int ThisPointer::get_i(const ThisPointer* this) { return this-&gt;i;
}</p>
<p>void ThisPointer::set_i(int ii) { i = ii; }</p>
<p>// Compiler rewrites as:</p>
<p>void ThisPointer::set_i(ThisPointer* this, int ii) { this-&gt;i = ii;
}</p>
<p>In a constructor, this can safely be used to (implicitly or
explicitly) access any field that has already been initialised,</p>
<p>or any field in a parent class; conversely, (implicitly or
explicitly) accessing any fields that haven't yet been initialised, or
any fields in a derived class, is unsafe (due to the derived class not
yet being constructed, and thus its fields</p>
<p>neither being initialised nor existing). It is also unsafe to call
virtual member functions through this in the constructor, as any derived
class functions will not be considered (due to the derived class not yet
being</p>
<p>constructed, and thus its constructor not yet updating the
vtable).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 150</p>
<p>Also note that while in a constructor, the type of the object is the
type which that constructor constructs. This holds true even if the
object is declared as a derived type. For example, in the below example,
ctd_good and ctd_bad are</p>
<p>type CtorThisBase inside CtorThisBase(), and type CtorThis inside
CtorThis(), even though their canonical type</p>
<p>is CtorThisDerived. As the more-derived classes are constructed
around the base class, the instance gradually goes through the class
hierarchy until it is a fully-constructed instance of its intended
type.</p>
<p>class CtorThisBase {</p>
<p>short s;</p>
<p>public:</p>
<p>CtorThisBase() : s(516) {}</p>
<p>};</p>
<p>class CtorThis : public CtorThisBase {</p>
<p>int i, j, k;</p>
<p>public:</p>
<p>// Good constructor.</p>
<p>CtorThis() : i(s + 42), j(this-&gt;i), k(j) {}</p>
<p>// Bad constructor.</p>
<p>CtorThis(int ii) : i(ii), j(this-&gt;k), k(b ? 51 :-51) {</p>
<p>virt_func();</p>
<p>}</p>
<p>virtual void virt_func() { i += 2; }</p>
<p>};</p>
<p>class CtorThisDerived : public CtorThis {</p>
<p>bool b;</p>
<p>public:</p>
<p>CtorThisDerived() : b(true) {}</p>
<p>CtorThisDerived(int ii) : CtorThis(ii), b(false) {}</p>
<p>void virt_func() override { k += (2 * i); }</p>
<p>};</p>
<p>// ...</p>
<p>CtorThisDerived ctd_good;</p>
<p>CtorThisDerived ctd_bad(3);</p>
<p>With these classes and member functions:</p>
<p>In the good constructor, for ctd_good:</p>
<p>CtorThisBase is fully constructed by the time the CtorThis
constructor is entered. Therefore, s is in a</p>
<p>valid state while initialising i, and can thus be accessed.</p>
<p>i is initialised before j(this-&gt;i) is reached. Therefore, i is in
a valid state while initialising j, and can</p>
<p>thus be accessed.</p>
<p>j is initialised before k(j) is reached. Therefore, j is in a valid
state while initialising k, and can thus be accessed.</p>
<p>In the bad constructor, for ctd_bad:</p>
<p>k is initialised after j(this-&gt;k) is reached. Therefore, k is in
an invalid state while initialising j, and</p>
<p>accessing it causes undefined behaviour.</p>
<p>CtorThisDerived is not constructed until after CtorThis is
constructed. Therefore, b is in an invalid</p>
<p>state while initialising k, and accessing it causes undefined
behaviour. The object ctd_bad is still a CtorThis until it leaves
CtorThis(), and will not be updated to use</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 151</p>
<p><span id="CtorThisDerived__s_vtable_until"
class="anchor"></span>CtorThisDerived 's vtable until CtorThisDerived().
Therefore, virt_func() will call CtorThis::virt_func() , regardless of
whether it is intended to call that or</p>
<p>CtorThisDerived::virt_func().</p>
<p>Section 32.2: Using the this Pointer to Access Member Data</p>
<p>In this context, using the this pointer isn't entirely necessary, but
it will make your code clearer to the reader, by</p>
<p>indicating that a given function or variable is a member of the
class. An example in this situation:</p>
<p>// Example for this pointer</p>
<p>#include</p>
<p>#include</p>
<p>using std::cout;</p>
<p>using std::endl;</p>
<p>class Class</p>
<p>{</p>
<p>public:</p>
<p>Class();</p>
<p>~Class();</p>
<p>int getPrivateNumber () const;</p>
<p>private:</p>
<p>int private_number = 42;</p>
<p>};</p>
<p>Class::Class(){}</p>
<p>Class::~Class(){}</p>
<p>int Class::getPrivateNumber() const</p>
<p>{</p>
<p>return this-&gt;private_number;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>Class class_example;</p>
<p>cout &lt;&lt; class_example.getPrivateNumber() &lt;&lt; endl;</p>
<p>}</p>
<p><a href="http://cpp.sh/9flka">See it in action here</a>.</p>
<p>Section 32.3: Using the this Pointer to Dierentiate Between</p>
<p>Member Data and Parameters</p>
<p>This is an actual useful strategy to differentiate member data from
parameters... Lets take this example :</p>
<p>// Dog Class Example</p>
<p>#include</p>
<p>#include</p>
<p>using std::cout;</p>
<p>using std::endl;</p>
<p>/*</p>
<p>* @class Dog</p>
<p>* @member name</p>
<p>* Dog's name</p>
<p>* @function bark</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 152</p>
<p><span id="________Dog_Barks" class="anchor"></span>* Dog Barks!</p>
<p>* @function getName</p>
<p>* To Get Private</p>
<p>* Name Variable</p>
<p>*/</p>
<p>class Dog</p>
<p>{</p>
<p>public:</p>
<p>Dog(std::string name);</p>
<p>~Dog();</p>
<p>void bark() const;</p>
<p>std::string getName() const;</p>
<p>private:</p>
<p>std::string name;</p>
<p>};</p>
<p>Dog::Dog(std::string name)</p>
<p>{</p>
<p>/*</p>
<p>* this-&gt;name is the</p>
<p>* name variable from</p>
<p>* the class dog . and</p>
<p>* name is from the</p>
<p>* parameter of the function</p>
<p>*/</p>
<p>this-&gt;name = name;</p>
<p>}</p>
<p>Dog::~Dog(){}</p>
<p>void Dog::bark() const</p>
<p>{</p>
<p>cout &lt;&lt; "BARK" &lt;&lt; endl;</p>
<p>}</p>
<p>std::string Dog::getName() const</p>
<p>{</p>
<p>return this-&gt;name;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>Dog dog("Max");</p>
<p>cout &lt;&lt; dog.getName() &lt;&lt; endl;</p>
<p>dog.bark();</p>
<p>}</p>
<p>You can see here in the constructor we execute the following:</p>
<p>this-&gt;name = name;</p>
<p>Here , you can see we are assinging the parameter name to the name of
the private variable from the class</p>
<p>Dog(this-&gt;name) .</p>
<p>To see the output of above code : <a
href="http://cpp.sh/75r7">http://cpp.sh/75r7</a></p>
<p>Section 32.4: this Pointer CV-Qualifiers</p>
<p>this can also be cv-qualified, the same as any other pointer.
However, due to the this parameter not being listed</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 153</p>
<p>in the parameter list, special syntax is required for this; the
cv-qualifiers are listed after the parameter list, but before the
function's body.</p>
<p>struct ThisCVQ {</p>
<p>void no_qualifier() {} // "this" is: ThisCVQ*</p>
<p>void c_qualifier() const {} // "this" is: const ThisCVQ* void
v_qualifier() volatile {} // "this" is: volatile ThisCVQ* void
cv_qualifier() const volatile {} // "this" is: const volatile
ThisCVQ*</p>
<p>};</p>
<p>As this is a parameter, a function can be overloaded based on its
this cv-qualifier(s).</p>
<p>struct CVOverload {</p>
<p>int func() { return 3; }</p>
<p>int func() const { return 33; }</p>
<p>int func() volatile { return 333; }</p>
<p>int func() const volatile { return 3333; }</p>
<p>};</p>
<p>When this is const (including const volatile), the function is unable
to write to member variables through it, whether implicitly or
explicitly. The sole exception to this is mutable member variables,
which can be written</p>
<p>regardless of const-ness. Due to this, const is used to indicate that
the member function doesn't change the</p>
<p>object's logical state (the way the object appears to the outside
world), even if it does modify the physical state (the way the object
looks under the hood).</p>
<p>Logical state is the way the object appears to outside observers. It
isn't directly tied to physical state, and</p>
<p>indeed, might not even be stored as physical state. As long as
outside observers can't see any changes, the logical state is constant,
even if you flip every single bit in the object.</p>
<p>Physical state, also known as bitwise state, is how the object is
stored in memory. This is the object's nitty-</p>
<p>gritty, the raw 1s and 0s that make up its data. An object is only
physically constant if its representation in memory never changes.</p>
<p>Note that C++ bases constness on logical state, not physical
state.</p>
<p>class DoSomethingComplexAndOrExpensive {</p>
<p>mutable ResultType cached_result;</p>
<p>mutable bool state_changed;</p>
<p>ResultType calculate_result();</p>
<p>void modify_somehow(const Param&amp; p);</p>
<p>// ...</p>
<p>public:</p>
<p>DoSomethingComplexAndOrExpensive(Param p) : state_changed(true) {</p>
<p>modify_somehow(p);</p>
<p>}</p>
<p>void change_state(Param p) {</p>
<p>modify_somehow(p);</p>
<p>state_changed = true;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 154</p>
<p>// Return some complex and/or expensive-to-calculate result. // As
this has no reason to modify logical state, it is marked as "const".</p>
<p>ResultType get_result() const;</p>
<p>};</p>
<p>ResultType DoSomethingComplexAndOrExpensive::get_result() const {</p>
<p>// cached_result and state_changed can be modified, even with a const
"this" pointer. // Even though the function doesn't modify logical
state, it does modify physical state // by caching the result, so it
doesn't need to be recalculated every time the function // is called.
This is indicated by cached_result and state_changed being mutable.</p>
<p>if (state_changed) {</p>
<p>cached_result = calculate_result();</p>
<p>state_changed = false;</p>
<p>}</p>
<p>return cached_result;</p>
<p>}</p>
<p>Note that while you technically <em>could</em> use const_cast on this
to make it non-cv-qualified, you really,
<em><strong>REALLY</strong></em></p>
<p>shouldn't, and should use mutable instead. A const_cast is liable to
invoke undefined behaviour when used on an object that actually
<em>is</em> const, while mutable is designed to be safe to use. It is,
however, possible that you may run</p>
<p>into this in extremely old code.</p>
<p>An exception to this rule is defining non-cv-qualified accessors in
terms of const accessors; as the object is</p>
<p>guaranteed to not be const if the non-cv-qualified version is called,
there's no risk of UB.</p>
<p>class CVAccessor {</p>
<p>int arr[5];</p>
<p>public:</p>
<p>const int&amp; get_arr_element(size_t i) const { return arr[i]; }</p>
<p>int&amp; get_arr_element(size_t i) {</p>
<p>return const_cast(const_cast(this)-&gt;get_arr_element(i));</p>
<p>}</p>
<p>};</p>
<p>This prevents unnecessary duplication of code.</p>
<p>As with regular pointers, if this is volatile (including const
volatile), it is loaded from memory each time it is</p>
<p>accessed, instead of being cached. This has the same effects on
optimisation as declaring any other pointer volatile would, so care
should be taken.</p>
<p>Note that if an instance is cv-qualified, the only member functions
it is allowed to access are member functions whose this pointer is at
least as cv-qualified as the instance itself:</p>
<p>Non-cv instances can access any member functions.</p>
<p>const instances can access const and const volatile functions.</p>
<p>volatile instances can access volatile and const volatile functions.
const volatile instances can access const volatile functions.</p>
<p>This is one of the key tenets of const correctness.</p>
<p>struct CVAccess {</p>
<p>void func() {}</p>
<p>void func_c() const {}</p>
<p>void func_v() volatile {}</p>
<p>void func_cv() const volatile {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 155</p>
<p><span id="_10" class="anchor"></span>};</p>
<p>CVAccess cva;</p>
<p>cva.func(); // Good.</p>
<p>cva.func_c(); // Good.</p>
<p>cva.func_v(); // Good.</p>
<p>cva.func_cv(); // Good.</p>
<p>const CVAccess c_cva;</p>
<p>c_cva.func(); // Error.</p>
<p>c_cva.func_c(); // Good.</p>
<p>c_cva.func_v(); // Error.</p>
<p>c_cva.func_cv(); // Good.</p>
<p>volatile CVAccess v_cva;</p>
<p>v_cva.func(); // Error.</p>
<p>v_cva.func_c(); // Error.</p>
<p>v_cva.func_v(); // Good.</p>
<p>v_cva.func_cv(); // Good.</p>
<p>const volatile CVAccess cv_cva;</p>
<p>cv_cva.func(); // Error.</p>
<p>cv_cva.func_c(); // Error.</p>
<p>cv_cva.func_v(); // Error.</p>
<p>cv_cva.func_cv(); // Good.</p>
<p>Section 32.5: this Pointer Ref-Qualifiers</p>
<p>Version ≥ C++11</p>
<p>Similarly to this cv-qualifiers, we can also apply
<em>ref-qualifiers</em> to *this. Ref-qualifiers are used to choose
between normal and rvalue reference semantics, allowing the compiler to
use either copy or move semantics depending on</p>
<p>which are more appropriate, and are applied to *this instead of
this.</p>
<p>Note that despite ref-qualifiers using reference syntax, this itself
is still a pointer. Also note that ref-qualifiers don't</p>
<p>actually change the type of *this; it's just easier to describe and
understand their effects by looking at them as if they did.</p>
<p>struct RefQualifiers {</p>
<p>std::string s;</p>
<p>RefQualifiers(const std::string&amp; ss = "The nameless one.") :
s(ss) {}</p>
<p>// Normal version.</p>
<p>void func() &amp; { std::cout &lt;&lt; "Accessed on normal instance "
&lt;&lt; s &lt;&lt; std::endl; } // Rvalue version.</p>
<p>void func() &amp;&amp; { std::cout &lt;&lt; "Accessed on temporary
instance " &lt;&lt; s &lt;&lt; std::endl; }</p>
<p>const std::string&amp; still_a_pointer() &amp; { return this-&gt;s; }
const std::string&amp; still_a_pointer() &amp;&amp; { this-&gt;s =
"Bob"; return this-&gt;s; }</p>
<p>};</p>
<p>// ...</p>
<p>RefQualifiers rf("Fred");</p>
<p>rf.func(); // Output: Accessed on normal instance Fred
RefQualifiers{}.func(); // Output: Accessed on temporary instance The
nameless one</p>
<p>A member function cannot have overloads both with and without
ref-qualifiers; the programmer has to choose</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 156</p>
<p>between one or the other. Thankfully, cv-qualifiers can be used in
conjunction with ref-qualifiers, allowing const correctness rules to be
followed.</p>
<p>struct RefCV {</p>
<p>void func() &amp; {}</p>
<p>void func() &amp;&amp; {}</p>
<p>void func() const&amp; {}</p>
<p>void func() const&amp;&amp; {}</p>
<p>void func() volatile&amp; {}</p>
<p>void func() volatile&amp;&amp; {}</p>
<p>void func() const volatile&amp; {}</p>
<p>void func() const volatile&amp;&amp; {}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 157</p>
<p><span id="Chapter_33__Smart_Pointers_1" class="anchor"></span>Chapter
33: Smart Pointers</p>
<p>Section 33.1: Unique ownership (std::unique_ptr)</p>
<p>Version ≥ C++11</p>
<p>A <a
href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>
is a class template that manages the lifetime of a dynamically stored
object. Unlike for</p>
<p><a
href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>,
the dynamic object is owned by only <em>one instance</em> of a
std::unique_ptr at any time,</p>
<p>// Creates a dynamic int with value of 20 owned by a unique pointer
std::unique_ptr ptr = std::make_unique(20);</p>
<p>(Note: std::unique_ptr is available since C++11 and std::make_unique
since C++14.)</p>
<p>Only the variable ptr holds a pointer to a dynamically allocated int.
When a unique pointer that owns an object</p>
<p>goes out of scope, the owned object is deleted, i.e. its destructor
is called if the object is of class type, and the memory for that object
is released.</p>
<p>To use std::unique_ptr and std::make_unique with array-types, use
their array specializations:</p>
<p>// Creates a unique_ptr to an int with value 59</p>
<p>std::unique_ptr ptr = std::make_unique(59);</p>
<p>// Creates a unique_ptr to an array of 15 ints</p>
<p>std::unique_ptr ptr = std::make_unique(15);</p>
<p>You can access the std::unique_ptr just like a raw pointer, because
it overloads those operators.</p>
<p>You can transfer ownership of the contents of a smart pointer to
another pointer by using std::move, which will cause the original smart
pointer to point to nullptr.</p>
<p>// 1. std::unique_ptr</p>
<p>std::unique_ptr ptr = std::make_unique();</p>
<p>// Change value to 1</p>
<p>*ptr = 1;</p>
<p>// 2. std::unique_ptr (by moving 'ptr' to 'ptr2', 'ptr' doesn't own
the object anymore) std::unique_ptr ptr2 = std::move(ptr);</p>
<p>int a = *ptr2; // 'a' is 1</p>
<p>int b = *ptr; // undefined behavior! 'ptr' is 'nullptr'</p>
<p>// (because of the move command above)</p>
<p>Passing unique_ptr to functions as parameter:</p>
<p>void foo(std::unique_ptr ptr)</p>
<p>{</p>
<p>// Your code goes here</p>
<p>}</p>
<p>std::unique_ptr ptr = std::make_unique(59); foo(std::move(ptr))</p>
<p>Returning unique_ptr from functions. This is the preferred C++11 way
of writing factory functions, as it clearly</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 158</p>
<p><span id="conveys_the_ownership_semantics"
class="anchor"></span>conveys the ownership semantics of the return: the
caller owns the resulting unique_ptr and is responsible for it.</p>
<p>std::unique_ptr foo()</p>
<p>{</p>
<p>std::unique_ptr ptr = std::make_unique(59);</p>
<p>return ptr;</p>
<p>}</p>
<p>std::unique_ptr ptr = foo();</p>
<p>Compare this to:</p>
<p>int* foo_cpp03();</p>
<p>int* p = foo_cpp03(); // do I own p? do I have to delete it at some
point?</p>
<p>// it's not readily apparent what the answer is.</p>
<p>Version &lt; C++14</p>
<p>The class template make_unique is provided since C++14. It's easy to
add it manually to C++11 code:</p>
<p>template</p>
<p>typename std::enable_if::value, std::unique_ptr&gt;::type
make_unique(Args&amp;&amp;... args)</p>
<p>{ return std::unique_ptr(new T(std::forward(args)...)); }</p>
<p>// Use make_unique for arrays</p>
<p>template</p>
<p>typename std::enable_if::value, std::unique_ptr&gt;::type
make_unique(size_t n)</p>
<p>{ return std::unique_ptr(new typename std::remove_extent::type[n]());
}</p>
<p>Version ≥ C++11</p>
<p>Unlike the <em>dumb</em> smart pointer (std::auto_ptr), unique_ptr
can also be instantiated with vector allocation (<em>not</em>
std::vector). Earlier examples were for <em>scalar</em> allocations. For
example to have a dynamically allocated integer</p>
<p>array for 10 elements, you would specify int[] as the template type
(and not just int):</p>
<p>std::unique_ptr arr_ptr = std::make_unique(10);</p>
<p>Which can be simplified with:</p>
<p>auto arr_ptr = std::make_unique(10);</p>
<p>Now, you use arr_ptr as if it is an array:</p>
<p>arr_ptr[2] = 10; // Modify third element</p>
<p>You need not to worry about de-allocation. This template specialized
version calls constructors and destructors appropriately. Using vectored
version of unique_ptr or a vector itself - is a personal choice.</p>
<p>In versions prior to C++11, std::auto_ptr was available. Unlike
unique_ptr it is allowed to copy auto_ptrs, upon</p>
<p>which the source ptr will lose the ownership of the contained pointer
and the target receives it.</p>
<p>Section 33.2: Sharing ownership (std::shared_ptr)</p>
<p><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">The
class template std::shared_ptr defines a shared pointer that is able to
share ownership of an object with</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 159</p>
<p><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">other
shared pointers. This contrasts to std::unique_ptr which represents
exclusive ownership.</a></p>
<p>The sharing behavior is implemented through a technique known as
reference counting, where the number of</p>
<p>shared pointers that point to the object is stored alongside it. When
this count reaches zero, either through the destruction or reassignment
of the last std::shared_ptr instance, the object is automatically
destroyed.</p>
<p>// Creation: 'firstShared' is a shared pointer for a new instance of
'Foo' std::shared_ptr firstShared =
std::make_shared(<em>/*args*/</em>);</p>
<p>To create multiple smart pointers that share the same object, we need
to create another shared_ptr that aliases</p>
<p>the first shared pointer. Here are 2 ways of doing it:</p>
<p>std::shared_ptr secondShared(firstShared); // 1st way: Copy
constructing std::shared_ptr secondShared;</p>
<p>secondShared = firstShared; // 2nd way: Assigning</p>
<p>Either of the above ways makes secondShared a shared pointer that
shares ownership of our instance of Foo with firstShared.</p>
<p>The smart pointer works just like a raw pointer. This means, you can
use * to dereference them. The regular -&gt; operator works as well:</p>
<p>secondShared-&gt;test(); // Calls Foo::test()</p>
<p>Finally, when the last aliased shared_ptr goes out of scope, the
destructor of our Foo instance is called.</p>
<p><strong>Warning:</strong> Constructing a shared_ptr might throw a
bad_alloc exception when extra data for shared ownership</p>
<p>semantics needs to be allocated. If the constructor is passed a
regular pointer it assumes to own the object pointed to and calls the
deleter if an exception is thrown. This means shared_ptr(new T(args))
will not leak a T object if</p>
<p>allocation of shared_ptr fails. However, it is advisable to use
make_shared(args) or allocate_shared(alloc, args), which enable the
implementation to optimize the memory allocation.</p>
<p>Allocating Arrays([]) using shared_ptr</p>
<p>Version ≥ C++11 Version &lt; C++17</p>
<p>Unfortunately, there is no direct way to allocate Arrays using
make_shared&lt;&gt;.</p>
<p>It is possible to create arrays for shared_ptr&lt;&gt; using new and
std::default_delete.</p>
<p>For example, to allocate an array of 10 integers, we can write the
code as</p>
<p>shared_ptr sh(new int[10], std::default_delete());</p>
<p>Specifying std::default_delete is mandatory here to make sure that
the allocated memory is correctly cleaned up using delete[].</p>
<p>If we know the size at compile time, we can do it this way:</p>
<p>template</p>
<p>struct shared_array_maker {};</p>
<p>template</p>
<p>struct shared_array_maker {</p>
<p>std::shared_ptr operator()const{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 160</p>
<p><span id="auto_r___std__make_shared" class="anchor"></span>auto r =
std::make_shared&gt;();</p>
<p>if (!r) return {};</p>
<p>return {r.data(), r};</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>auto make_shared_array()</p>
<p>-&gt; decltype( shared_array_maker{}() )</p>
<p>{ return shared_array_maker{}(); }</p>
<p>then make_shared_array returns a shared_ptr pointing to 10 ints all
default constructed.</p>
<p>Version ≥ C++17</p>
<p>With C++17, shared_ptr <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0414r2.html">gained
special support for array types. It is no longer necessary to specify
the array-deleter</a> explicitly, and the shared pointer can be
dereferenced using the [] array index operator:</p>
<p>std::shared_ptr sh(new int[10]);</p>
<p>sh[0] = 42;</p>
<p>Shared pointers can point to a sub-object of the object it owns:</p>
<p>struct Foo { int x; };</p>
<p>std::shared_ptr p1 = std::make_shared(); std::shared_ptr p2(p1,
&amp;p1-&gt;x);</p>
<p>Both p2 and p1 own the object of type Foo, but p2 points to its int
member x. This means that if p1 goes out of</p>
<p>scope or is reassigned, the underlying Foo object will still be
alive, ensuring that p2 does not dangle.</p>
<p><strong>Important:</strong> A shared_ptr only knows about itself and
all other shared_ptr that were created with the alias</p>
<p>constructor. It does not know about any other pointers, including all
other shared_ptrs created with a reference to the same Foo instance:</p>
<p>Foo *foo = new Foo;</p>
<p>std::shared_ptr shared1(foo);</p>
<p>std::shared_ptr shared2(foo); // don't do this</p>
<p>shared1.reset(); // this will delete foo, since shared1</p>
<p>// was the only shared_ptr that owned it</p>
<p>shared2-&gt;test(); // UNDEFINED BEHAVIOR: shared2's foo has been</p>
<p>// deleted already!!</p>
<p>Ownership Transfer of shared_ptr</p>
<p>By default, shared_ptr increments the reference count and doesn't
transfer the ownership. However, it can be made to transfer the
ownership using std::move:</p>
<p>shared_ptr up = make_shared();</p>
<p>// Transferring the ownership</p>
<p>shared_ptr up2 = move(up);</p>
<p>// At this point, the reference count of up = 0 and the // ownership
of the pointer is solely with up2 with reference count = 1</p>
<p>Section 33.3: Sharing with temporary ownership</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 161</p>
<p>(std::weak_ptr)</p>
<p>Instances of <a
href="http://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr
can point to objects owned by instances of</a> <a
href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>
while only becoming</p>
<p>temporary owners themselves. This means that weak pointers do not
alter the object's reference count and</p>
<p>therefore do not prevent an object's deletion if all of the object's
shared pointers are reassigned or destroyed.</p>
<p>In the following example instances of std::weak_ptr are used so that
the destruction of a tree object is not inhibited:</p>
<p>#include</p>
<p>#include</p>
<p>struct TreeNode {</p>
<p>std::weak_ptr parent;</p>
<p>std::vector&lt; std::shared_ptr &gt; children; };</p>
<p>int main() {</p>
<p>// Create a TreeNode to serve as the root/parent.</p>
<p>std::shared_ptr root(new TreeNode);</p>
<p>// Give the parent 100 child nodes.</p>
<p>for (size_t i = 0; i &lt; 100; ++i) {</p>
<p>std::shared_ptr child(new TreeNode);</p>
<p>root-&gt;children.push_back(child);</p>
<p>child-&gt;parent = root;</p>
<p>}</p>
<p>// Reset the root shared pointer, destroying the root object, and //
subsequently its child nodes.</p>
<p>root.reset();</p>
<p>}</p>
<p>As child nodes are added to the root node's children, their
std::weak_ptr member parent is set to the root node. The member parent
is declared as a weak pointer as opposed to a shared pointer such that
the root node's</p>
<p>reference count is not incremented. When the root node is reset at
the end of main(), the root is destroyed. Since the only remaining
std::shared_ptr references to the child nodes were contained in the
root's collection children,</p>
<p>all child nodes are subsequently destroyed as well.</p>
<p>Due to control block implementation details, shared_ptr allocated
memory may not be released until shared_ptr</p>
<p>reference counter and weak_ptr reference counter both reach zero.</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>{</p>
<p>std::weak_ptr wk;</p>
<p>{</p>
<p>// std::make_shared is optimized by allocating only once // while
std::shared_ptr(new int(42)) allocates twice. // Drawback of
std::make_shared is that control block is tied to our integer</p>
<p>std::shared_ptr sh = std::make_shared(42);</p>
<p>wk = sh;</p>
<p>// sh memory should be released at this point...</p>
<p>}</p>
<p>// ... but wk is still alive and needs access to control block</p>
<p>}</p>
<p>// now memory is released (sh and wk)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 162</p>
<p><span id="_11" class="anchor"></span>}</p>
<p>Since std::weak_ptr does not keep its referenced object alive, direct
data access through a std::weak_ptr is not possible. Instead it provides
a lock() member function that attempts to retrieve a std::shared_ptr to
the</p>
<p>referenced object:</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>{</p>
<p>std::weak_ptr wk;</p>
<p>std::shared_ptr sp;</p>
<p>{</p>
<p>std::shared_ptr sh = std::make_shared(42);</p>
<p>wk = sh;</p>
<p>// calling lock will create a shared_ptr to the object referenced by
wk</p>
<p>sp = wk.lock();</p>
<p>// sh will be destroyed after this point, but sp is still alive</p>
<p>}</p>
<p>// sp still keeps the data alive.</p>
<p>// At this point we could even call lock() again</p>
<p>// to retrieve another shared_ptr to the same data from wk assert(*sp
== 42);</p>
<p>assert(!wk.expired());</p>
<p>// resetting sp will delete the data,</p>
<p>// as it is currently the last shared_ptr with ownership</p>
<p>sp.reset();</p>
<p>// attempting to lock wk now will return an empty shared_ptr, // as
the data has already been deleted</p>
<p>sp = wk.lock();</p>
<p>assert(!sp);</p>
<p>assert(wk.expired());</p>
<p>}</p>
<p>}</p>
<p>Section 33.4: Using custom deleters to create a wrapper to a</p>
<p>C interface</p>
<p><a href="https://www.libsdl.org/">Many C interfaces such as SDL2 have
their own deletion functions. This means that you cannot use smart
pointers</a></p>
<p>directly:</p>
<p>std::unique_ptr a; // won't work, UNSAFE!</p>
<p>Instead, you need to define your own deleter. The examples here use
the <a href="https://wiki.libsdl.org/SDL_Surface">SDL_Surface structure
which should be</a></p>
<p>freed using the <a
href="https://wiki.libsdl.org/SDL_FreeSurface">SDL_FreeSurface()
function, but they should be adaptable to many other C
interfaces.</a></p>
<p>The deleter must be callable with a pointer argument, and therefore
can be e.g. a simple function pointer:</p>
<p>std::unique_ptr a(pointer, SDL_FreeSurface);</p>
<p>Any other callable object will work, too, for example a class with an
operator():</p>
<p>struct SurfaceDeleter {</p>
<p>void operator()(SDL_Surface* surf) {</p>
<p>SDL_FreeSurface(surf);</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 163</p>
<p><span id="std__unique_ptr_a_pointer__Surfa"
class="anchor"></span>std::unique_ptr a(pointer, SurfaceDeleter{}); //
safe std::unique_ptr b(pointer); // equivalent to the above</p>
<p>// as the deleter is value-initialized</p>
<p>This not only provides you with safe, zero overhead (if you use <a
href="http://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr)
automatic memory management, you</a> also get exception safety.</p>
<p>Note that the deleter is part of the type for unique_ptr, and the
implementation can use the empty base optimization to avoid any change
in size for empty custom deleters. So while std::unique_ptr</p>
<p>SurfaceDeleter&gt; and std::unique_ptr solve the same problem in a
similar way, the former type is still only the size of a pointer while
the latter type has to hold <em>two</em> pointers: both the</p>
<p>SDL_Surface* and the function pointer! When having free function
custom deleters, it is preferable to wrap the function in an empty
type.</p>
<p><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">In cases
where reference counting is important, one could use a shared_ptr</a>
instead of an unique_ptr. The shared_ptr always stores a deleter, this
erases the type of the deleter, which might be useful in APIs. The</p>
<p>disadvantages of using shared_ptr over unique_ptr include a higher
memory cost for storing the deleter and a performance cost for
maintaining the reference count.</p>
<p>// deleter required at construction time and is part of the type
std::unique_ptr a(pointer, SDL_FreeSurface);</p>
<p>// deleter is only required at construction time, not part of the
type std::shared_ptr b(pointer, SDL_FreeSurface);</p>
<p>Version ≥ C++17</p>
<p>With template auto, we can make it even easier to wrap our custom
deleters:</p>
<p>template</p>
<p>struct FunctionDeleter {</p>
<p>template</p>
<p>void operator()(T* ptr) {</p>
<p>DeleteFn(ptr);</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>using unique_ptr_deleter = std::unique_ptr&gt;;</p>
<p>With which the above example is simply:</p>
<p>unique_ptr_deleter c(pointer);</p>
<p>Here, the purpose of auto is to handle all free functions, whether
they return void (e.g. SDL_FreeSurface) or not</p>
<p>(e.g. fclose).</p>
<p>Section 33.5: Unique ownership without move semantics</p>
<p>(auto_ptr)</p>
<p>Version &lt; C++11</p>
<p><strong>NOTE:</strong> std::auto_ptr has been deprecated in C++11 and
will be removed in C++17. You should only use this if you</p>
<p>are forced to use C++03 or earlier and are willing to be careful. It
is recommended to move to unique_ptr in</p>
<p>combination with std::move to replace std::auto_ptr behavior.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 164</p>
<p>Before we had std::unique_ptr, before we had move semantics, we had
std::auto_ptr. std::auto_ptr provides unique ownership but transfers
ownership upon copy.</p>
<p>As with all smart pointers, std::auto_ptr automatically cleans up
resources (see RAII):</p>
<p>{</p>
<p>std::auto_ptr p(new int(42));</p>
<p>std::cout &lt;&lt; *p;</p>
<p>} // p is deleted here, no memory leaked</p>
<p>but allows only one owner:</p>
<p>std::auto_ptr px = ...;</p>
<p>std::auto_ptr py = px;</p>
<p>// px is now empty</p>
<p>This allows to use std::auto_ptr to keep ownership explicit and
unique at the danger of losing ownership unintended:</p>
<p>void f(std::auto_ptr ) {</p>
<p>// assumes ownership of X</p>
<p>// deletes it at end of scope</p>
<p>};</p>
<p>std::auto_ptr px = ...;</p>
<p>f(px); // f acquires ownership of underlying X</p>
<p>// px is now empty</p>
<p>px-&gt;foo(); // NPE!</p>
<p>// px.~auto_ptr() does NOT delete</p>
<p>The transfer of ownership happened in the "copy" constructor.
auto_ptr's copy constructor and copy assignment operator take their
operands by non-const reference so that they could be modified. An
example implementation</p>
<p>might be:</p>
<p>template</p>
<p>class auto_ptr {</p>
<p>T* ptr;</p>
<p>public:</p>
<p>auto_ptr(auto_ptr&amp; rhs)</p>
<p>: ptr(rhs.release())</p>
<p>{ }</p>
<p>auto_ptr&amp; operator=(auto_ptr&amp; rhs) {</p>
<p>reset(rhs.release());</p>
<p>return *this;</p>
<p>}</p>
<p>T* release() {</p>
<p>T* tmp = ptr;</p>
<p>ptr = nullptr;</p>
<p>return tmp;</p>
<p>}</p>
<p>void reset(T* tmp = nullptr) {</p>
<p>if (ptr != tmp) {</p>
<p>delete ptr;</p>
<p>ptr = tmp;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 165</p>
<p><span id="___other_functions" class="anchor"></span>/* other
functions ... */</p>
<p>};</p>
<p>This breaks copy semantics, which require that copying an object
leaves you with two equivalent versions of it. For</p>
<p>any copyable type, T, I should be able to write:</p>
<p>T a = ...;</p>
<p>T b(a);</p>
<p>assert(b == a);</p>
<p>But for auto_ptr, this is not the case. As a result, it is not safe
to put auto_ptrs in containers.</p>
<p>Section 33.6: Casting std::shared_ptr pointers</p>
<p>It is not possible to directly use static_cast, const_cast,
dynamic_cast and reinterpret_cast on std::shared_ptr to retrieve a
pointer sharing ownership with the pointer being passed as argument.
Instead, the</p>
<p>functions std::static_pointer_cast, std::const_pointer_cast,
std::dynamic_pointer_cast and std::reinterpret_pointer_cast should be
used:</p>
<p>struct Base { virtual ~Base() noexcept {}; };</p>
<p>struct Derived: Base {};</p>
<p>auto derivedPtr(std::make_shared());</p>
<p>auto basePtr(std::static_pointer_cast(derivedPtr)); auto
constBasePtr(std::const_pointer_cast(basePtr)); auto
constDerivedPtr(std::dynamic_pointer_cast(constBasePtr));</p>
<p>Note that std::reinterpret_pointer_cast is not available in C++11 and
C++14, as it was only proposed by <a
href="https://isocpp.org/files/papers/N3920.html">N3920</a></p>
<p><a href="https://isocpp.org/blog/2014/02/trip-report">and adopted
into Library Fundamentals TS in February 2014. However, it can be
implemented as follows:</a></p>
<p>template</p>
<p>inline std::shared_ptr reinterpret_pointer_cast(</p>
<p>std::shared_ptr const &amp; ptr) noexcept</p>
<p>{ return std::shared_ptr(ptr, reinterpret_cast(ptr.get())); }</p>
<p>Section 33.7: Writing a smart pointer: value_ptr</p>
<p>A value_ptr is a smart pointer that behaves like a value. When
copied, it copies its contents. When created, it</p>
<p>creates its contents.</p>
<p>// Like std::default_delete:</p>
<p>template</p>
<p>struct default_copier {</p>
<p>// a copier must handle a null T const* in and return null:</p>
<p>T* operator()(T const* tin)const {</p>
<p>if (!tin) return nullptr;</p>
<p>return new T(*tin);</p>
<p>}</p>
<p>void operator()(void* dest, T const* tin)const {</p>
<p>if (!tin) return;</p>
<p>return new(dest) T(*tin);</p>
<p>}</p>
<p>};</p>
<p>// tag class to handle empty case:</p>
<p>struct empty_ptr_t {};</p>
<p>constexpr empty_ptr_t empty_ptr{};</p>
<p>// the value pointer type itself:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 166</p>
<p>template, class Deleter=std::default_delete,</p>
<p>class Base=std::unique_ptr</p>
<p>&gt;</p>
<p>struct value_ptr:Base, private Copier {</p>
<p>using copier_type=Copier;</p>
<p>// also typedefs from unique_ptr</p>
<p>using Base::Base;</p>
<p>value_ptr( T const&amp; t ):</p>
<p>Base( std::make_unique(t) ),</p>
<p>Copier()</p>
<p>{}</p>
<p>value_ptr( T &amp;&amp; t ):</p>
<p>Base( std::make_unique(std::move(t)) ),</p>
<p>Copier()</p>
<p>{}</p>
<p>// almost-never-empty:</p>
<p>value_ptr():</p>
<p>Base( std::make_unique() ),</p>
<p>Copier()</p>
<p>{}</p>
<p>value_ptr( empty_ptr_t ) {}</p>
<p>value_ptr( Base b, Copier c={} ):</p>
<p>Base(std::move(b)),</p>
<p>Copier(std::move(c))</p>
<p>{}</p>
<p>Copier const&amp; get_copier() const {</p>
<p>return *this;</p>
<p>}</p>
<p>value_ptr clone() const {</p>
<p>return {</p>
<p>Base(</p>
<p>get_copier()(this-&gt;get()),</p>
<p>this-&gt;get_deleter()</p>
<p>),</p>
<p>get_copier()</p>
<p>};</p>
<p>}</p>
<p>value_ptr(value_ptr&amp;&amp;)=default;</p>
<p>value_ptr&amp; operator=(value_ptr&amp;&amp;)=default;</p>
<p>value_ptr(value_ptr const&amp; o):value_ptr(o.clone()) {}
value_ptr&amp; operator=(value_ptr const&amp;o) {</p>
<p>if (o &amp;&amp; *this) {</p>
<p>// if we are both non-null, assign contents:</p>
<p>**this = *o;</p>
<p>} else {</p>
<p>// otherwise, assign a clone (which could itself be null): *this =
o.clone();</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p>value_ptr&amp; operator=( T const&amp; t ) {</p>
<p>if (*this) {</p>
<p>**this = t;</p>
<p>} else {</p>
<p>*this = value_ptr(t);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 167</p>
<p><span id="return__this_1" class="anchor"></span>return *this;</p>
<p>}</p>
<p>value_ptr&amp; operator=( T &amp;&amp; t ) {</p>
<p>if (*this) {</p>
<p>**this = std::move(t);</p>
<p>} else {</p>
<p>*this = value_ptr(std::move(t));</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p>T&amp; get() { return **this; }</p>
<p>T const&amp; get() const { return **this; }</p>
<p>T* get_pointer() {</p>
<p>if (!*this) return nullptr;</p>
<p>return std::addressof(get());</p>
<p>}</p>
<p>T const* get_pointer() const {</p>
<p>if (!*this) return nullptr;</p>
<p>return std::addressof(get());</p>
<p>}</p>
<p>// operator-&gt; from unique_ptr</p>
<p>};</p>
<p>template</p>
<p>value_ptr make_value_ptr( Args&amp;&amp;... args ) {</p>
<p>return {std::make_unique(std::forward(args)...)};</p>
<p>}</p>
<p>This particular value_ptr is only empty if you construct it with
empty_ptr_t or if you move from it. It exposes the fact</p>
<p>it is a unique_ptr, so explicit operator bool() const works on it.
.get() has been changed to return a</p>
<p>reference (as it is almost never empty), and .get_pointer() returns a
pointer instead.</p>
<p>This smart pointer can be useful for pImpl cases, where we want
value-semantics but we also don't want to expose</p>
<p>the contents of the pImpl outside of the implementation file.</p>
<p>With a non-default Copier, it can even handle virtual base classes
that know how to produce instances of their derived and turn them into
value-types.</p>
<p>Section 33.8: Getting a shared_ptr referring to this</p>
<p>enable_shared_from_this enables you to get a valid shared_ptr
instance to this.</p>
<p>By deriving your class from the class template
enable_shared_from_this, you inherit a method shared_from_this</p>
<p>that returns a shared_ptr instance to this.</p>
<p><strong>Note</strong> that the object must be created as a shared_ptr
in first place:</p>
<p>#include</p>
<p>class A: public enable_shared_from_this {</p>
<p>};</p>
<p>A* ap1 =new A();</p>
<p>shared_ptr ap2(ap1); // First prepare a shared pointer to the object
and hold it! // Then get a shared pointer to the object from the object
itself shared_ptr ap3 = ap1-&gt;shared_from_this();</p>
<p>int c3 =ap3.use_count(); // =2: pointing to the same object</p>
<p><strong>Note</strong>(2) you cannot call enable_shared_from_this
inside the constructor.</p>
<p>#include // enable_shared_from_this</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 168</p>
<p>class Widget : public std::enable_shared_from_this&lt; Widget &gt;
{</p>
<p>public:</p>
<p>void DoSomething()</p>
<p>{</p>
<p>std::shared_ptr&lt; Widget &gt; self = shared_from_this();</p>
<p>someEvent -&gt; Register( self );</p>
<p>}</p>
<p>private:</p>
<p>...</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>...</p>
<p>auto w = std::make_shared&lt; Widget &gt;();</p>
<p>w -&gt; DoSomething();</p>
<p>...</p>
<p>}</p>
<p>If you use shared_from_this() on an object not owned by a shared_ptr,
such as a local automatic object or a</p>
<p>global object, then the behavior is undefined. Since C++17 it throws
std::bad_alloc instead.</p>
<p>Using shared_from_this() from a constructor is equivalent to using it
on an object not owned by a shared_ptr,</p>
<p>because the objects is possessed by the shared_ptr after the
constructor returns.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 169</p>
<p><span id="Chapter_34__Classes_Structures_1"
class="anchor"></span>Chapter 34: Classes/Structures</p>
<p>Section 34.1: Class basics</p>
<p>A <em>class</em> is a user-defined type. A class is introduced with
the class, struct or union keyword. In colloquial usage, the term
"class" usually refers only to non-union classes.</p>
<p>A class is a collection of <em>class members</em>, which can be:</p>
<p>member variables (also called "fields"),</p>
<p>member functions (also called "methods"),</p>
<p>member types or typedefs (e.g. "nested classes"),</p>
<p>member templates (of any kind: variable, function, class or alias
template)</p>
<p>The class and struct keywords, called <em>class keys</em>, are
largely interchangeable, except that the default access</p>
<p>specifier for members and bases is "private" for a class declared
with the class key and "public" for a class declared with the struct or
union key (cf. Access modifiers).</p>
<p>For example, the following code snippets are identical:</p>
<p>struct Vector</p>
<p>{</p>
<p>int x;</p>
<p>int y;</p>
<p>int z;</p>
<p>};</p>
<p>// are equivalent to</p>
<p>class Vector</p>
<p>{</p>
<p>public:</p>
<p>int x;</p>
<p>int y;</p>
<p>int z;</p>
<p>};</p>
<p>By declaring a class` a new type is added to your program, and it is
possible to instantiate objects of that class by</p>
<p>Vector my_vector;</p>
<p>Members of a class are accessed using dot-syntax.</p>
<p>my_vector.x = 10;</p>
<p>my_vector.y = my_vector.x + 1; // my_vector.y = 11;</p>
<p>my_vector.z = my_vector.y-4; // my:vector.z = 7;</p>
<p>Section 34.2: Final classes and structs</p>
<p>Version ≥ C++11</p>
<p>Deriving a class may be forbidden with final specifier. Let's declare
a final class:</p>
<p>class A final {</p>
<p>};</p>
<p>Now any attempt to subclass it will cause a compilation error:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 170</p>
<p><span id="___Compilation_error__cannot_der" class="anchor"></span>//
Compilation error: cannot derive from final class: class B : public A
{</p>
<p>};</p>
<p>Final class may appear anywhere in class hierarchy:</p>
<p>class A {</p>
<p>};</p>
<p>// OK.</p>
<p>class B final : public A {</p>
<p>};</p>
<p>// Compilation error: cannot derive from final class B. class C :
public B {</p>
<p>};</p>
<p>Section 34.3: Access specifiers</p>
<p>There are three keywords that act as <strong>access
specifiers</strong>. These limit the access to class members following
the</p>
<p>specifier, until another specifier changes the access level
again:</p>
<p>Keyword Description</p>
<p>public Everyone has access</p>
<p>protected Only the class itself, derived classes and friends have
access</p>
<p>private Only the class itself and friends have access</p>
<p>When the type is defined using the class keyword, the default access
specifier is private, but if the type is defined</p>
<p>using the struct keyword, the default access specifier is public:</p>
<p>struct MyStruct { int x; };</p>
<p>class MyClass { int x; };</p>
<p>MyStruct s;</p>
<p>s.x = 9; // well formed, because x is public</p>
<p>MyClass c;</p>
<p>c.x = 9; // ill-formed, because x is private</p>
<p>Access specifiers are mostly used to limit access to internal fields
and methods, and force the programmer to use a</p>
<p>specific interface, for example to force use of getters and setters
instead of referencing a variable directly:</p>
<p>class MyClass {</p>
<p><em>public:</em> /* Methods: */</p>
<p>int x() const noexcept { return m_x; }</p>
<p>void setX(int const x) noexcept { m_x = x; }</p>
<p><em>private:</em> /* Fields: */</p>
<p>int m_x;</p>
<p>};</p>
<p>Using protected is useful for allowing certain functionality of the
type to be only accessible to the derived classes, for example, in the
following code, the method calculateValue() is only accessible to
classes deriving from the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 171</p>
<p><span id="base_class_Plus2Base__such_as_Fo"
class="anchor"></span>base class Plus2Base, such as FortyTwo:</p>
<p>struct Plus2Base {</p>
<p>int value() noexcept { return calculateValue() + 2; }</p>
<p><em>protected:</em> /* Methods: */</p>
<p>virtual int calculateValue() noexcept = 0;</p>
<p>};</p>
<p>struct FortyTwo: Plus2Base {</p>
<p><em>protected:</em> /* Methods: */</p>
<p>int calculateValue() noexcept final override { return 40; }</p>
<p>};</p>
<p>Note that the friend keyword can be used to add access exceptions to
functions or types for accessing protected and private members.</p>
<p>The public, protected, and private keywords can also be used to grant
or limit access to base class subobjects.</p>
<p>See the Inheritance example.</p>
<p>Section 34.4: Inheritance</p>
<p>Classes/structs can have inheritance relations.</p>
<p>If a class/struct B inherits from a class/struct A, this means that B
has as a parent A. We say that B is a derived class/struct from A, and A
is the base class/struct.</p>
<p>struct A</p>
<p>{</p>
<p>public:</p>
<p>int p1;</p>
<p>protected:</p>
<p>int p2;</p>
<p>private:</p>
<p>int p3;</p>
<p>};</p>
<p>//Make B inherit publicly (default) from A</p>
<p>struct B : A</p>
<p>{</p>
<p>};</p>
<p>There are 3 forms of inheritance for a class/struct:</p>
<p>public</p>
<p>private</p>
<p>protected</p>
<p>Note that the default inheritance is the same as the default
visibility of members: public if you use the struct</p>
<p>keyword, and private for the class keyword.</p>
<p>It's even possible to have a class derive from a struct (or vice
versa). In this case, the default inheritance is controlled by the
child, so a struct that derives from a class will default to public
inheritance, and a class that</p>
<p>derives from a struct will have private inheritance by default.</p>
<p>public inheritance:</p>
<p>struct B : public A // or just `struct B : A`</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 172</p>
<p>void foo()</p>
<p>{</p>
<p>p1 = 0; //well formed, p1 is public in B</p>
<p>p2 = 0; //well formed, p2 is protected in B</p>
<p>p3 = 0; //ill formed, p3 is private in A</p>
<p>}</p>
<p>};</p>
<p>B b;</p>
<p>b.p1 = 1; //well formed, p1 is public</p>
<p>b.p2 = 1; //ill formed, p2 is protected</p>
<p>b.p3 = 1; //ill formed, p3 is inaccessible</p>
<p>private inheritance:</p>
<p>struct B : private A</p>
<p>{</p>
<p>void foo()</p>
<p>{</p>
<p>p1 = 0; //well formed, p1 is private in B</p>
<p>p2 = 0; //well formed, p2 is private in B</p>
<p>p3 = 0; //ill formed, p3 is private in A</p>
<p>}</p>
<p>};</p>
<p>B b;</p>
<p>b.p1 = 1; //ill formed, p1 is private</p>
<p>b.p2 = 1; //ill formed, p2 is private</p>
<p>b.p3 = 1; //ill formed, p3 is inaccessible</p>
<p>protected inheritance:</p>
<p>struct B : protected A</p>
<p>{</p>
<p>void foo()</p>
<p>{</p>
<p>p1 = 0; //well formed, p1 is protected in B</p>
<p>p2 = 0; //well formed, p2 is protected in B</p>
<p>p3 = 0; //ill formed, p3 is private in A</p>
<p>}</p>
<p>};</p>
<p>B b;</p>
<p>b.p1 = 1; //ill formed, p1 is protected</p>
<p>b.p2 = 1; //ill formed, p2 is protected</p>
<p>b.p3 = 1; //ill formed, p3 is inaccessible</p>
<p>Note that although protected inheritance is allowed, the actual use
of it is rare. One instance of how protected inheritance is used in
application is in partial base class specialization (usually referred to
as "controlled</p>
<p>polymorphism").</p>
<p>When OOP was relatively new, (public) inheritance was frequently said
to model an "IS-A" relationship. That is,</p>
<p>public inheritance is correct only if an instance of the derived
class <em>is also an</em> instance of the base class.</p>
<p><a
href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">This
was later refined into the Liskov Substitution Principle</a>: public
inheritance should only be used when/if an</p>
<p>instance of the derived class can be substituted for an instance of
the base class under any possible circumstance (and still make
sense).</p>
<p>Private inheritance is typically said to embody a completely
different relationship: "is implemented in terms of"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 173</p>
<p><span id="_sometimes_called_a__HAS_A__rela"
class="anchor"></span>(sometimes called a "HAS-A" relationship). For
example, a Stack class could inherit privately from a Vector class.
Private inheritance bears a much greater similarity to aggregation than
to public inheritance.</p>
<p>Protected inheritance is almost never used, and there's no general
agreement on what sort of relationship it embodies.</p>
<p>Section 34.5: Friendship</p>
<p>The friend keyword is used to give other classes and functions access
to private and protected members of the class, even through they are
defined outside the class`s scope.</p>
<p>class Animal{</p>
<p>private:</p>
<p>double weight;</p>
<p>double height;</p>
<p>public:</p>
<p>friend void printWeight(Animal animal);</p>
<p>friend class AnimalPrinter;</p>
<p>// A common use for a friend function is to overload the
operator&lt;&lt; for streaming. friend std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, Animal animal);</p>
<p>};</p>
<p>void printWeight(Animal animal)</p>
<p>{</p>
<p>std::cout &lt;&lt; animal.weight &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>class AnimalPrinter</p>
<p>{</p>
<p>public:</p>
<p>void print(const Animal&amp; animal)</p>
<p>{</p>
<p>// Because of the `friend class AnimalPrinter;" declaration, we are
// allowed to access private members here.</p>
<p>std::cout &lt;&lt; animal.weight &lt;&lt; ", " &lt;&lt; animal.height
&lt;&lt; std::endl;</p>
<p>}</p>
<p>}</p>
<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Animal
animal) {</p>
<p>os &lt;&lt; "Animal height: " &lt;&lt; animal.height &lt;&lt;
"<strong>\n</strong>";</p>
<p>return os;</p>
<p>}</p>
<p>int main() {</p>
<p>Animal animal = {10, 5};</p>
<p>printWeight(animal);</p>
<p>AnimalPrinter aPrinter;</p>
<p>aPrinter.print(animal);</p>
<p>std::cout &lt;&lt; animal;</p>
<p>}</p>
<p>10</p>
<p>10, 5</p>
<p>Animal height: 5</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 174</p>
<p><span id="Section_34_6__Virtual_Inheritanc"
class="anchor"></span>Section 34.6: Virtual Inheritance</p>
<p>When using inheritance, you can specify the virtual keyword:</p>
<p>struct A{};</p>
<p>struct B: public virtual A{};</p>
<p>When class B has virtual base A it means that A <strong>will reside
in most derived class</strong> of inheritance tree, and thus that</p>
<p>most derived class is also responsible for initializing that virtual
base:</p>
<p>struct A</p>
<p>{</p>
<p>int member;</p>
<p>A(int param)</p>
<p>{</p>
<p>member = param;</p>
<p>}</p>
<p>};</p>
<p>struct B: virtual A</p>
<p>{</p>
<p>B(): A(5){}</p>
<p>};</p>
<p>struct C: B</p>
<p>{</p>
<p><em>C():</em> /*A(88)*/ <em>{}</em></p>
<p>};</p>
<p>void f()</p>
<p>{</p>
<p>C object; //error since C is not initializing it's indirect virtual
base `A` }</p>
<p>If we un-comment <em>/*A(88)*/</em> we won't get any error since C is
now initializing it's indirect virtual base A.</p>
<p>Also note that when we're creating variable object, most derived
class is C, so C is responsible for creating(calling constructor of) A
and thus value of A::member is 88, not 5 (as it would be if we were
creating object of type B).</p>
<p><a
href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">It
is useful when solving the diamond problem.:</a></p>
<p>A A A</p>
<p>/ \ | |</p>
<p>B C B C</p>
<p>\ / \ /</p>
<p>D D</p>
<p>virtual inheritance normal inheritance</p>
<p>B and C both inherit from A, and D inherits from B and C, so
<strong>there are 2 instances of A in D!</strong> This results in
ambiguity</p>
<p>when you're accessing member of A through D, as the compiler has no
way of knowing from which class do you</p>
<p>want to access that member (the one which B inherits, or the one that
is inherited byC?).</p>
<p>Virtual inheritance solves this problem: Since virtual base resides
only in most derived object, there will be only one instance of A in
D.</p>
<p>struct A</p>
<p>{</p>
<p>void foo() {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 175</p>
<p><span id="_12" class="anchor"></span>};</p>
<p>struct B : public <em>/*virtual*/</em> A {};</p>
<p>struct C : public <em>/*virtual*/</em> A {};</p>
<p>struct D : public B, public C</p>
<p>{</p>
<p>void bar()</p>
<p>{</p>
<p>foo(); //Error, which foo? B::foo() or C::foo()? - Ambiguous</p>
<p>}</p>
<p>};</p>
<p>Removing the comments resolves the ambiguity.</p>
<p>Section 34.7: Private inheritance: restricting base class</p>
<p>interface</p>
<p>Private inheritance is useful when it is required to restrict the
public interface of the class:</p>
<p>class A {</p>
<p>public:</p>
<p>int move();</p>
<p>int turn();</p>
<p>};</p>
<p>class B : private A {</p>
<p>public:</p>
<p>using A::turn;</p>
<p>};</p>
<p>B b;</p>
<p>b.move(); // compile error</p>
<p>b.turn(); // OK</p>
<p>This approach efficiently prevents an access to the A public methods
by casting to the A pointer or reference:</p>
<p>B b;</p>
<p>A&amp; a = static_cast(b); // compile error</p>
<p>In the case of public inheritance such casting will provide access to
all the A public methods despite on alternative ways to prevent this in
derived B, like hiding:</p>
<p>class B : public A {</p>
<p>private:</p>
<p>int move();</p>
<p>};</p>
<p>or private using:</p>
<p>class B : public A {</p>
<p>private:</p>
<p>using A::move;</p>
<p>};</p>
<p>then for both cases it is possible:</p>
<p>B b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 176</p>
<p><span id="A__a___static_cast_b______OK_for"
class="anchor"></span>A&amp; a = static_cast(b); // OK for public
inheritance a.move(); // OK</p>
<p>Section 34.8: Accessing class members</p>
<p>To access member variables and member functions of an object of a
class, the . operator is used:</p>
<p>struct SomeStruct {</p>
<p>int a;</p>
<p>int b;</p>
<p>void foo() {}</p>
<p>};</p>
<p>SomeStruct var;</p>
<p>// Accessing member variable a in var.</p>
<p>std::cout &lt;&lt; var.a &lt;&lt; std::endl;</p>
<p>// Assigning member variable b in var.</p>
<p>var.b = 1;</p>
<p>// Calling a member function.</p>
<p>var.foo();</p>
<p>When accessing the members of a class via a pointer, the -&gt;
operator is commonly used. Alternatively, the instance can be
dereferenced and the . operator used, although this is less common:</p>
<p>struct SomeStruct {</p>
<p>int a;</p>
<p>int b;</p>
<p>void foo() {}</p>
<p>};</p>
<p>SomeStruct var;</p>
<p>SomeStruct *p = &amp;var;</p>
<p>// Accessing member variable a in var via pointer. std::cout &lt;&lt;
p-&gt;a &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; (*p).a &lt;&lt; std::endl;</p>
<p>// Assigning member variable b in var via pointer. p-&gt;b = 1;</p>
<p>(*p).b = 1;</p>
<p>// Calling a member function via a pointer.</p>
<p>p-&gt;foo();</p>
<p>(*p).foo();</p>
<p>When accessing static class members, the :: operator is used, but on
the name of the class instead of an instance of it. Alternatively, the
static member can be accessed from an instance or a pointer to an
instance using the . or -&gt;</p>
<p>operator, respectively, with the same syntax as accessing non-static
members.</p>
<p>struct SomeStruct {</p>
<p>int a;</p>
<p>int b;</p>
<p>void foo() {}</p>
<p>static int c;</p>
<p>static void bar() {}</p>
<p>};</p>
<p>int SomeStruct::c;</p>
<p>SomeStruct var;</p>
<p>SomeStruct* p = &amp;var;</p>
<p>// Assigning static member variable c in struct SomeStruct.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 177</p>
<p><span id="SomeStruct__c___5" class="anchor"></span>SomeStruct::c =
5;</p>
<p>// Accessing static member variable c in struct SomeStruct, through
var and p. var.a = var.c;</p>
<p>var.b = p-&gt;c;</p>
<p>// Calling a static member function.</p>
<p>SomeStruct::bar();</p>
<p>var.bar();</p>
<p>p-&gt;bar();</p>
<p>Background</p>
<p>The -&gt; operator is needed because the member access operator . has
precedence over the dereferencing operator *.</p>
<p>One would expect that *p.a would dereference p (resulting in a
reference to the object p is pointing to) and then accessing its member
a. But in fact, it tries to access the member a of p and then
dereference it. I.e. *p.a is</p>
<p>equivalent to *(p.a). In the example above, this would result in a
compiler error because of two facts: First, p is a pointer and does not
have a member a. Second, a is an integer and, thus, can't be
dereferenced.</p>
<p>The uncommonly used solution to this problem would be to explicitly
control the precedence: (*p).a</p>
<p>Instead, the -&gt; operator is almost always used. It is a short-hand
for first dereferencing the pointer and then</p>
<p>accessing it. I.e. (*p).a is exactly the same as p-&gt;a.</p>
<p>The :: operator is the scope operator, used in the same manner as
accessing a member of a namespace. This is</p>
<p>because a static class member is considered to be in that class'
scope, but isn't considered a member of instances of that class. The use
of normal . and -&gt; is also allowed for static members, despite them
not being instance</p>
<p>members, for historical reasons; this is of use for writing generic
code in templates, as the caller doesn't need to be concerned with
whether a given member function is static or non-static.</p>
<p>Section 34.9: Member Types and Aliases</p>
<p>A class or struct can also define member type aliases, which are type
aliases contained within, and treated as members of, the class
itself.</p>
<p>struct IHaveATypedef {</p>
<p>typedef int MyTypedef;</p>
<p>};</p>
<p>struct IHaveATemplateTypedef {</p>
<p>template</p>
<p>using MyTemplateTypedef = std::vector;</p>
<p>};</p>
<p>Like static members, these typedefs are accessed using the scope
operator, ::.</p>
<p>IHaveATypedef::MyTypedef i = 5; // i is an int.</p>
<p>IHaveATemplateTypedef::MyTemplateTypedef v; // v is a
std::vector.</p>
<p>As with normal type aliases, each member type alias is allowed to
refer to any type defined or aliased before, but</p>
<p>not after, its definition. Likewise, a typedef outside the class
definition can refer to any accessible typedefs within the class
definition, provided it comes after the class definition.</p>
<p>template</p>
<p>struct Helper {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 178</p>
<p>T get() const { return static_cast(42); }</p>
<p>};</p>
<p>struct IHaveTypedefs {</p>
<p>// typedef MyTypedef NonLinearTypedef; // Error if uncommented.</p>
<p>typedef int MyTypedef;</p>
<p>typedef Helper MyTypedefHelper;</p>
<p>};</p>
<p>IHaveTypedefs::MyTypedef i; // x_i is an int.</p>
<p>IHaveTypedefs::MyTypedefHelper hi; // x_hi is a Helper.</p>
<p>typedef IHaveTypedefs::MyTypedef TypedefBeFree;</p>
<p>TypedefBeFree ii; // ii is an int.</p>
<p>Member type aliases can be declared with any access level, and will
respect the appropriate access modifier.</p>
<p>class TypedefAccessLevels {</p>
<p>typedef int PrvInt;</p>
<p>protected:</p>
<p>typedef int ProInt;</p>
<p>public:</p>
<p>typedef int PubInt;</p>
<p>};</p>
<p>TypedefAccessLevels::PrvInt prv_i; // Error:
TypedefAccessLevels::PrvInt is private. TypedefAccessLevels::ProInt
pro_i; // Error: TypedefAccessLevels::ProInt is protected.
TypedefAccessLevels::PubInt pub_i; // Good.</p>
<p>class Derived : public TypedefAccessLevels {</p>
<p>PrvInt prv_i; // Error: TypedefAccessLevels::PrvInt is private.</p>
<p>ProInt pro_i; // Good.</p>
<p>PubInt pub_i; // Good.</p>
<p>};</p>
<p>This can be used to provide a level of abstraction, allowing a class'
designer to change its internal workings without</p>
<p>breaking code that relies on it.</p>
<p>class Something {</p>
<p>friend class SomeComplexType;</p>
<p>short s;</p>
<p>// ...</p>
<p>public:</p>
<p>typedef SomeComplexType MyHelper;</p>
<p>MyHelper get_helper() const { return MyHelper(8, s, 19.5, "shoe",
false); }</p>
<p>// ...</p>
<p>};</p>
<p>// ...</p>
<p>Something s;</p>
<p>Something::MyHelper hlp = s.get_helper();</p>
<p>In this situation, if the helper class is changed from
SomeComplexType to some other type, only the typedef and the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 179</p>
<p>friend declaration would need to be modified; as long as the helper
class provides the same functionality, any code that uses it as
Something::MyHelper instead of specifying it by name will usually still
work without any</p>
<p>modifications. In this manner, we minimise the amount of code that
needs to be modified when the underlying</p>
<p>implementation is changed, such that the type name only needs to be
changed in one location.</p>
<p>This can also be combined with decltype, if one so desires.</p>
<p>class SomethingElse {</p>
<p>AnotherComplexType helper;</p>
<p>public:</p>
<p>typedef decltype(helper) MyHelper;</p>
<p>private:</p>
<p>InternalVariable ivh;</p>
<p>// ...</p>
<p>public:</p>
<p>MyHelper&amp; get_helper() const { return helper; }</p>
<p>// ...</p>
<p>};</p>
<p>In this situation, changing the implementation of
SomethingElse::helper will automatically change the typedef for us, due
to decltype. This minimises the number of modifications necessary when
we want to change helper, which</p>
<p>minimises the risk of human error.</p>
<p>As with everything, however, this can be taken too far. If the
typename is only used once or twice internally and</p>
<p>zero times externally, for example, there's no need to provide an
alias for it. If it's used hundreds or thousands of times throughout a
project, or if it has a long enough name, then it can be useful to
provide it as a typedef instead</p>
<p>of always using it in absolute terms. One must balance forwards
compatibility and convenience with the amount of</p>
<p>unnecessary noise created.</p>
<p>This can also be used with template classes, to provide access to the
template parameters from outside the class.</p>
<p>template</p>
<p>class SomeClass {</p>
<p>// ...</p>
<p>public:</p>
<p>typedef T MyParam;</p>
<p>MyParam getParam() { return static_cast(42); }</p>
<p>};</p>
<p>template</p>
<p>typename T::MyParam some_func(T&amp; t) {</p>
<p>return t.getParam();</p>
<p>}</p>
<p>SomeClass si;</p>
<p>int i = some_func(si);</p>
<p>This is commonly used with containers, which will usually provide
their element type, and other helper types, as member type aliases. Most
of the containers in the C++ standard library, for example, provide the
following 12</p>
<p>helper types, along with any other special types they might need.</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 180</p>
<p>class SomeContainer {</p>
<p>// ...</p>
<p>public:</p>
<p>// Let's provide the same helper types as most standard containers.
typedef T value_type; typedef std::allocator allocator_type; typedef
value_type&amp; reference;</p>
<p>typedef const value_type&amp; const_reference; typedef value_type*
pointer;</p>
<p>typedef const value_type* const_pointer;</p>
<p>typedef MyIterator iterator;</p>
<p>typedef MyConstIterator const_iterator; typedef std::reverse_iterator
reverse_iterator; typedef std::reverse_iterator const_reverse_iterator;
typedef size_t size_type;</p>
<p>typedef ptrdiff_t difference_type;</p>
<p>};</p>
<p>Prior to C++11, it was also commonly used to provide a "template
typedef" of sorts, as the feature wasn't yet available; these have
become a bit less common with the introduction of alias templates, but
are still useful in some</p>
<p>situations (and are combined with alias templates in other
situations, which can be very useful for obtaining individual components
of a complex type such as a function pointer). They commonly use the
name type for their</p>
<p>type alias.</p>
<p>template</p>
<p>struct TemplateTypedef {</p>
<p>typedef T type;</p>
<p>}</p>
<p>TemplateTypedef::type i; // i is an int.</p>
<p>This was often used with types with multiple template parameters, to
provide an alias that defines one or more of</p>
<p>the parameters.</p>
<p>template</p>
<p>class Array { <em>/* ... */</em> };</p>
<p>template</p>
<p>struct OneDArray {</p>
<p>typedef Array type;</p>
<p>};</p>
<p>template</p>
<p>struct TwoDArray {</p>
<p>typedef Array type;</p>
<p>};</p>
<p>template</p>
<p>struct MonoDisplayLine {</p>
<p>typedef Array type;</p>
<p>};</p>
<p>OneDArray::type arr1i; // arr1i is an Array. TwoDArray::type arr2s;
// arr2s is an Array. MonoDisplayLine::type arr3c; // arr3c is an
Array.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 181</p>
<p><span id="Section_34_10__Nested_Classes_St"
class="anchor"></span>Section 34.10: Nested Classes/Structures</p>
<p>A class or struct can also contain another class/struct definition
inside itself, which is called a "nested class"; in</p>
<p>this situation, the containing class is referred to as the "enclosing
class". The nested class definition is considered to</p>
<p>be a member of the enclosing class, but is otherwise separate.</p>
<p>struct Outer {</p>
<p>struct Inner { };</p>
<p>};</p>
<p>From outside of the enclosing class, nested classes are accessed
using the scope operator. From inside the</p>
<p>enclosing class, however, nested classes can be used without
qualifiers:</p>
<p>struct Outer {</p>
<p>struct Inner { };</p>
<p>Inner in;</p>
<p>};</p>
<p>// ...</p>
<p>Outer o;</p>
<p>Outer::Inner i = o.in;</p>
<p>As with a non-nested class/struct, member functions and static
variables can be defined either within a nested</p>
<p>class, or in the enclosing namespace. However, they cannot be defined
within the enclosing class, due to it being considered to be a different
class than the nested class.</p>
<p>// Bad.</p>
<p>struct Outer {</p>
<p>struct Inner {</p>
<p>void do_something();</p>
<p>};</p>
<p>void Inner::do_something() {}</p>
<p>};</p>
<p>// Good.</p>
<p>struct Outer {</p>
<p>struct Inner {</p>
<p>void do_something();</p>
<p>};</p>
<p>};</p>
<p>void Outer::Inner::do_something() {}</p>
<p>As with non-nested classes, nested classes can be forward declared
and defined later, provided they are defined</p>
<p>before being used directly.</p>
<p>class Outer {</p>
<p>class Inner1;</p>
<p>class Inner2;</p>
<p>class Inner1 {};</p>
<p>Inner1 in1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 182</p>
<p>Inner2* in2p;</p>
<p>public:</p>
<p>Outer();</p>
<p>~Outer();</p>
<p>};</p>
<p>class Outer::Inner2 {};</p>
<p>Outer::Outer() : in1(Inner1()), in2p(new Inner2) {}</p>
<p>Outer::~Outer() {</p>
<p>if (in2p) { delete in2p; }</p>
<p>}</p>
<p>Version &lt; C++11</p>
<p>Prior to C++11, nested classes only had access to type names, static
members, and enumerators from the enclosing class; all other members
defined in the enclosing class were off-limits.</p>
<p>Version ≥ C++11</p>
<p>As of C++11, nested classes, and members thereof, are treated as if
they were friends of the enclosing class, and can access all of its
members, according to the usual access rules; if members of the nested
class require the ability</p>
<p>to evaluate one or more non-static members of the enclosing class,
they must therefore be passed an instance:</p>
<p>class Outer {</p>
<p>struct Inner {</p>
<p>int get_sizeof_x() {</p>
<p>return sizeof(x); // Legal (C++11): x is unevaluated, so no instance
is required.</p>
<p>}</p>
<p>int get_x() {</p>
<p>return x; // Illegal: Can't access non-static member without an
instance.</p>
<p>}</p>
<p>int get_x(Outer&amp; o) {</p>
<p>return o.x; // Legal (C++11): As a member of Outer, Inner can access
private members.</p>
<p>}</p>
<p>};</p>
<p>int x;</p>
<p>};</p>
<p>Conversely, the enclosing class is <em>not</em> treated as a friend
of the nested class, and thus cannot access its private</p>
<p>members without explicitly being granted permission.</p>
<p>class Outer {</p>
<p>class Inner {</p>
<p>// friend class Outer;</p>
<p>int x;</p>
<p>};</p>
<p>Inner in;</p>
<p>public:</p>
<p>int get_x() {</p>
<p>return in.x; // Error: int Outer::Inner::x is private. // Uncomment
"friend" line above to fix.</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 183</p>
<p>};</p>
<p>Friends of a nested class are not automatically considered friends of
the enclosing class; if they need to be friends of the enclosing class
as well, this must be declared separately. Conversely, as the enclosing
class is not</p>
<p>automatically considered a friend of the nested class, neither will
friends of the enclosing class be considered friends of the nested
class.</p>
<p>class Outer {</p>
<p>friend void barge_out(Outer&amp; out, Inner&amp; in);</p>
<p>class Inner {</p>
<p>friend void barge_in(Outer&amp; out, Inner&amp; in);</p>
<p>int i;</p>
<p>};</p>
<p>int o;</p>
<p>};</p>
<p>void barge_in(Outer&amp; out, Outer::Inner&amp; in) {</p>
<p>int i = in.i; // Good.</p>
<p>int o = out.o; // Error: int Outer::o is private.</p>
<p>}</p>
<p>void barge_out(Outer&amp; out, Outer::Inner&amp; in) {</p>
<p>int i = in.i; // Error: int Outer::Inner::i is private. int o =
out.o; // Good.</p>
<p>}</p>
<p>As with all other class members, nested classes can only be named
from outside the class if they have public access. However, you are
allowed to access them regardless of access modifier, as long as you
don't explicitly name</p>
<p>them.</p>
<p>class Outer {</p>
<p>struct Inner {</p>
<p>void func() { std::cout &lt;&lt; "I have no private
taboo.<strong>\n</strong>"; }</p>
<p>};</p>
<p>public:</p>
<p>static Inner make_Inner() { return Inner(); }</p>
<p>};</p>
<p>// ...</p>
<p>Outer::Inner oi; // Error: Outer::Inner is private.</p>
<p>auto oi = Outer::make_Inner(); // Good.</p>
<p>oi.func(); // Good.</p>
<p>Outer::make_Inner().func(); // Good.</p>
<p>You can also create a type alias for a nested class. If a type alias
is contained in the enclosing class, the nested type and the type alias
can have different access modifiers. If the type alias is outside the
enclosing class, it requires that</p>
<p>either the nested class, or a typedef thereof, be public.</p>
<p>class Outer {</p>
<p>class Inner_ {};</p>
<p>public:</p>
<p>typedef Inner_ Inner;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 184</p>
<p>};</p>
<p>typedef Outer::Inner ImOut; // Good.</p>
<p>typedef Outer::Inner_ ImBad; // Error.</p>
<p>// ...</p>
<p>Outer::Inner oi; // Good.</p>
<p>Outer::Inner_ oi; // Error.</p>
<p>ImOut oi; // Good.</p>
<p>As with other classes, nested classes can both derive from or be
derived from by other classes.</p>
<p>struct Base {};</p>
<p>struct Outer {</p>
<p>struct Inner : Base {};</p>
<p>};</p>
<p>struct Derived : Outer::Inner {};</p>
<p>This can be useful in situations where the enclosing class is derived
from by another class, by allowing the programmer to update the nested
class as necessary. This can be combined with a typedef to provide a
consistent</p>
<p>name for each enclosing class' nested class:</p>
<p>class BaseOuter {</p>
<p>struct BaseInner_ {</p>
<p>virtual void do_something() {}</p>
<p>virtual void do_something_else();</p>
<p>} b_in;</p>
<p>public:</p>
<p>typedef BaseInner_ Inner;</p>
<p>virtual ~BaseOuter() = default;</p>
<p>virtual Inner&amp; getInner() { return b_in; }</p>
<p>};</p>
<p>void BaseOuter::BaseInner_::do_something_else() {}</p>
<p>// ---</p>
<p>class DerivedOuter : public BaseOuter {</p>
<p>// Note the use of the qualified typedef; BaseOuter::BaseInner_ is
private. struct DerivedInner_ : BaseOuter::Inner {</p>
<p>void do_something() override {}</p>
<p>void do_something_else() override;</p>
<p>} d_in;</p>
<p>public:</p>
<p>typedef DerivedInner_ Inner;</p>
<p>BaseOuter::Inner&amp; getInner() override { return d_in; } };</p>
<p>void DerivedOuter::DerivedInner_::do_something_else() {}</p>
<p>// ...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 185</p>
<p><span id="___Calls_BaseOuter__BaseInner" class="anchor"></span>//
Calls BaseOuter::BaseInner_::do_something();</p>
<p>BaseOuter* b = new BaseOuter;</p>
<p>BaseOuter::Inner&amp; bin = b-&gt;getInner();</p>
<p>bin.do_something();</p>
<p>b-&gt;getInner().do_something();</p>
<p>// Calls DerivedOuter::DerivedInner_::do_something(); BaseOuter* d =
new DerivedOuter;</p>
<p>BaseOuter::Inner&amp; din = d-&gt;getInner();</p>
<p>din.do_something();</p>
<p>d-&gt;getInner().do_something();</p>
<p>In the above case, both BaseOuter and DerivedOuter supply the member
type Inner, as BaseInner_ and</p>
<p>DerivedInner_, respectively. This allows nested types to be derived
without breaking the enclosing class' interface,</p>
<p>and allows the nested type to be used polymorphically.</p>
<p>Section 34.11: Unnamed struct/class</p>
<p><em>Unnamed struct</em> is allowed (type has no name)</p>
<p>void foo()</p>
<p>{</p>
<p><em>struct</em> /* No name */ <em>{</em></p>
<p>float x;</p>
<p>float y;</p>
<p>} point;</p>
<p>point.x = 42;</p>
<p>}</p>
<p>or</p>
<p>struct Circle</p>
<p>{</p>
<p><em>struct</em> /* No name */ <em>{</em></p>
<p>float x;</p>
<p>float y;</p>
<p>} center; // but a member name</p>
<p>float radius;</p>
<p>};</p>
<p>and later</p>
<p>Circle circle;</p>
<p>circle.center.x = 42.f;</p>
<p>but NOT <em>anonymous struct</em> (unnamed type and unnamed
object)</p>
<p>struct InvalidCircle</p>
<p>{</p>
<p><em>struct</em> /* No name */ <em>{</em></p>
<p>float centerX;</p>
<p>float centerY;</p>
<p>}; // No member either.</p>
<p>float radius;</p>
<p>};</p>
<p>Note: Some compilers allow <em>anonymous struct</em> as
<em>extension</em>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 186</p>
<p><span id="Version_____C__11" class="anchor"></span>Version ≥
C++11</p>
<p><em>lamdba</em> can be seen as a special <em>unnamed struct</em>.</p>
<p>decltype allows to retrieve the type of <em>unnamed struct</em>:</p>
<p>decltype(circle.point) otherPoint;</p>
<p><em>unnamed struct</em> instance can be parameter of template
method:</p>
<p>void print_square_coordinates()</p>
<p>{</p>
<p>const struct {float x; float y;} points[] = {</p>
<p>{-1, -1}, {-1, 1}, {1, -1}, {1, 1}</p>
<p>};</p>
<p>// for range relies on `template std::begin(T (&amp;)[N])` for (const
auto&amp; point : points) {</p>
<p>std::cout &lt;&lt; "{" &lt;&lt; point.x &lt;&lt; ", " &lt;&lt;
point.y &lt;&lt; "}<strong>\n</strong>";</p>
<p>}</p>
<p>decltype(points[0]) topRightCorner{1, 1};</p>
<p>auto it = std::find(points, points + 4, topRightCorner);</p>
<p>std::cout &lt;&lt; "top right corner is the "</p>
<p>&lt;&lt; 1 + std::distance(points, it) &lt;&lt;
"th<strong>\n</strong>";</p>
<p>}</p>
<p>Section 34.12: Static class members</p>
<p>A class is also allowed to have static members, which can be either
variables or functions. These are considered to</p>
<p>be in the class' scope, but aren't treated as normal members; they
have static storage duration (they exist from the start of the program
to the end), aren't tied to a particular instance of the class, and only
one copy exists for the</p>
<p>entire class.</p>
<p>class Example {</p>
<p>static int num_instances; // Static data member (static member
variable). int i; // Non-static member variable.</p>
<p>public:</p>
<p>static std::string static_str; // Static data member (static member
variable). static int static_func(); // Static member function.</p>
<p>// Non-static member functions can modify static member
variables.</p>
<p>Example() { ++num_instances; }</p>
<p>void set_str(const std::string&amp; str);</p>
<p>};</p>
<p>int Example::num_instances;</p>
<p>std::string Example::static_str = "Hello.";</p>
<p>// ...</p>
<p>Example one, two, three;</p>
<p>// Each Example has its own "i", such that:</p>
<p>// (&amp;one.i != &amp;two.i)</p>
<p>// (&amp;one.i != &amp;three.i)</p>
<p>// (&amp;two.i != &amp;three.i).</p>
<p>// All three Examples share "num_instances", such that:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 187</p>
<p>// (&amp;one.num_instances == &amp;two.num_instances)</p>
<p>// (&amp;one.num_instances == &amp;three.num_instances)</p>
<p>// (&amp;two.num_instances == &amp;three.num_instances)</p>
<p>Static member variables are not considered to be defined inside the
class, only declared, and thus have their definition outside the class
definition; the programmer is allowed, but not required, to initialise
static variables in</p>
<p>their definition. When defining the member variables, the keyword
static is omitted.</p>
<p>class Example {</p>
<p>static int num_instances; // Declaration.</p>
<p>public:</p>
<p>static std::string static_str; // Declaration.</p>
<p>// ...</p>
<p>};</p>
<p>int Example::num_instances; // Definition. Zero-initialised.
std::string Example::static_str = "Hello."; // Definition.</p>
<p>Due to this, static variables can be incomplete types (apart from
void), as long as they're later defined as a</p>
<p>complete type.</p>
<p>struct ForwardDeclared;</p>
<p>class ExIncomplete {</p>
<p>static ForwardDeclared fd;</p>
<p>static ExIncomplete i_contain_myself;</p>
<p>static int an_array[];</p>
<p>};</p>
<p>struct ForwardDeclared {};</p>
<p>ForwardDeclared ExIncomplete::fd;</p>
<p>ExIncomplete ExIncomplete::i_contain_myself;</p>
<p>int ExIncomplete::an_array[5];</p>
<p>Static member functions can be defined inside or outside the class
definition, as with normal member functions. As</p>
<p>with static member variables, the keyword static is omitted when
defining static member functions outside the</p>
<p>class definition.</p>
<p>// For Example above, either...</p>
<p>class Example {</p>
<p>// ...</p>
<p>public:</p>
<p>static int static_func() { return num_instances; }</p>
<p>// ...</p>
<p>void set_str(const std::string&amp; str) { static_str = str; }</p>
<p>};</p>
<p>// Or...</p>
<p>class Example { <em>/* ... */</em> };</p>
<p>int Example::static_func() { return num_instances; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 188</p>
<p>void Example::set_str(const std::string&amp; str) { static_str = str;
}</p>
<p>If a static member variable is declared const but not volatile, and
is of an integral or enumeration type, it can be initialised at
declaration, inside the class definition.</p>
<p>enum E <strong>{</strong> VAL = 5 <strong>}</strong>;</p>
<p>struct ExConst <strong>{</strong></p>
<p>const static int ci = 5; <strong>//</strong> Good.</p>
<p>static const E ce = VAL; <strong>//</strong> Good.</p>
<p>const static double <strong>cd</strong> = 5; <strong>//</strong>
Error.</p>
<p>static const volatile int cvi = 5; <strong>//</strong> Error.</p>
<p>const static double good_cd;</p>
<p>static const volatile int good_cvi;</p>
<p>}<strong>;</strong></p>
<p>const double ExConst::good_cd = 5; <strong>//</strong> Good. const
volatile int ExConst::good_cvi = 5; <strong>//</strong> Good.</p>
<p>Version ≥ C++11</p>
<p>As of C++11, static member variables of LiteralType types (types that
can be constructed at compile time,</p>
<p>according to constexpr rules) can also be declared as constexpr; if
so, they must be initialised within the class definition.</p>
<p>struct ExConstexpr <strong>{</strong></p>
<p>constexpr static int ci = 5; <strong>//</strong> Good.</p>
<p>static constexpr double <strong>cd</strong> = 5; <strong>//</strong>
Good.</p>
<p>constexpr static int carr<strong>[]</strong> = <strong>{</strong> 1,
1, 2 <strong>}</strong>; <strong>//</strong> Good.</p>
<p>static constexpr ConstexprConstructibleClass c<strong>{}</strong>;
<strong>//</strong> Good.</p>
<p>constexpr static int bad_ci; <strong>//</strong> Error.
<strong>}</strong>;</p>
<p>constexpr int ExConstexpr::bad_ci = 5; <strong>//</strong> Still an
error.</p>
<p>If a const or constexpr static member variable is <em>odr-used</em>
(informally, if it has its address taken or is assigned to a</p>
<p>reference), then it must still have a separate definition, outside
the class definition. This definition is not allowed to contain an
initialiser.</p>
<p>struct ExODR {</p>
<p>static const int odr_used = 5;</p>
<p>};</p>
<p>// const int ExODR::odr_used;</p>
<p>const int* odr_user = &amp; ExODR::odr_used; // Error; uncomment
above line to resolve.</p>
<p>As static members aren't tied to a given instance, they can be
accessed using the scope operator, ::.</p>
<p>std::string str = Example::static_str;</p>
<p>They can also be accessed as if they were normal, non-static members.
This is of historical significance, but is used less commonly than the
scope operator to prevent confusion over whether a member is static or
non-static.</p>
<p>Example ex;</p>
<p>std::string rts = ex.static_str;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 189</p>
<p>Class members are able to access static members without qualifying
their scope, as with non-static class members.</p>
<p>class ExTwo {</p>
<p>static int num_instances;</p>
<p>int my_num;</p>
<p>public:</p>
<p>ExTwo() : my_num(num_instances++) {}</p>
<p>static int get_total_instances() { return num_instances; } int
get_instance_number() const { return my_num; }</p>
<p>};</p>
<p>int ExTwo::num_instances;</p>
<p>They cannot be mutable, nor would they need to be; as they aren't
tied to any given instance, whether an instance is or isn't const
doesn't affect static members.</p>
<p>struct ExDontNeedMutable {</p>
<p>int immuta;</p>
<p>mutable int muta;</p>
<p>static int i;</p>
<p>ExDontNeedMutable() : immuta(-5), muta(-5) {}</p>
<p>};</p>
<p>int ExDontNeedMutable::i;</p>
<p>// ...</p>
<p>const ExDontNeedMutable dnm;</p>
<p>dnm.immuta = 5; // Error: Can't modify read-only object. dnm.muta =
5; // Good. Mutable fields of const objects can be written. dnm.i = 5;
// Good. Static members can be written regardless of an instance's
const-ness.</p>
<p>Static members respect access modifiers, just like non-static
members.</p>
<p>class ExAccess {</p>
<p>static int prv_int;</p>
<p>protected:</p>
<p>static int pro_int;</p>
<p>public:</p>
<p>static int pub_int;</p>
<p>};</p>
<p>int ExAccess::prv_int;</p>
<p>int ExAccess::pro_int;</p>
<p>int ExAccess::pub_int;</p>
<p>// ...</p>
<p>int x1 = ExAccess::prv_int; // Error: int ExAccess::prv_int is
private. int x2 = ExAccess::pro_int; // Error: int ExAccess::pro_int is
protected. int x3 = ExAccess::pub_int; // Good.</p>
<p>As they aren't tied to a given instance, static member functions have
no this pointer; due to this, they can't access non-static member
variables unless passed an instance.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 190</p>
<p><span id="class_ExInstanceRequired" class="anchor"></span>class
ExInstanceRequired {</p>
<p>int i;</p>
<p>public:</p>
<p>ExInstanceRequired() : i(0) {}</p>
<p>static void bad_mutate() { ++i *= 5; } // Error.</p>
<p>static void good_mutate(ExInstanceRequired&amp; e) { ++e.i *= 5; } //
Good.</p>
<p>};</p>
<p>Due to not having a this pointer, their addresses can't be stored in
pointers-to-member-functions, and are instead</p>
<p>stored in normal pointers-to-functions.</p>
<p>struct ExPointer {</p>
<p>void nsfunc() {}</p>
<p>static void sfunc() {}</p>
<p>};</p>
<p>typedef void (ExPointer::* mem_f_ptr)();</p>
<p>typedef void (*f_ptr)();</p>
<p>mem_f_ptr p_sf = &amp;ExPointer::sfunc; // Error.</p>
<p>f_ptr p_sf = &amp;ExPointer::sfunc; // Good.</p>
<p>Due to not having a this pointer, they also cannot be const or
volatile, nor can they have ref-qualifiers. They also cannot be
virtual.</p>
<p>struct ExCVQualifiersAndVirtual {</p>
<p>static void func() {} // Good.</p>
<p>static void cfunc() const {} // Error.</p>
<p>static void vfunc() volatile {} // Error.</p>
<p>static void cvfunc() const volatile {} // Error.</p>
<p>static void rfunc() &amp; {} // Error.</p>
<p>static void rvfunc() &amp;&amp; {} // Error.</p>
<p>virtual static void vsfunc() {} // Error.</p>
<p>static virtual void svfunc() {} // Error.</p>
<p>};</p>
<p>As they aren't tied to a given instance, static member variables are
effectively treated as special global variables; they're created when
the program starts, and destroyed when it exits, regardless of whether
any instances of the</p>
<p>class actually exist. Only a single copy of each static member
variable exists (unless the variable is declared</p>
<p>thread_local (C++11 or later), in which case there's one copy per
thread).</p>
<p>Static member variables have the same linkage as the class, whether
the class has external or internal linkage. Local classes and unnamed
classes aren't allowed to have static members.</p>
<p>Section 34.13: Multiple Inheritance</p>
<p>Aside from single inheritance:</p>
<p>class A {};</p>
<p>class B : public A {};</p>
<p>You can also have multiple inheritance:</p>
<p>class A {};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 191</p>
<p><span id="class_B" class="anchor"></span>class B {};</p>
<p>class C : public A, public B {};</p>
<p>C will now have inherit from A and B at the same time.</p>
<p>Note: this can lead to ambiguity if the same names are used in
multiple inherited classs or structs. Be careful!</p>
<p>Ambiguity in Multiple Inheritance</p>
<p>Multiple inheritance may be helpful in certain cases but, sometimes
odd sort of problem encounters while using</p>
<p>multiple inheritance.</p>
<p>For example: Two base classes have functions with same name which is
not overridden in derived class and if you write code to access that
function using object of derived class, compiler shows error because, it
cannot determine</p>
<p>which function to call. Here is a code for this type of ambiguity in
multiple inheritance.</p>
<p>class base1</p>
<p>{</p>
<p>public:</p>
<p>void funtion( )</p>
<p>{ //code for base1 function }</p>
<p>};</p>
<p>class base2</p>
<p>{</p>
<p>void function( )</p>
<p>{ // code for base2 function }</p>
<p>};</p>
<p>class derived : public base1, public base2</p>
<p>{</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>derived obj;</p>
<p>// Error because compiler can't figure out which function to call
//either function( ) of base1 or base2 .</p>
<p>obj.function( )</p>
<p>}</p>
<p>But, this problem can be solved using scope resolution function to
specify which function to class either base1 or</p>
<p>base2:</p>
<p>int main()</p>
<p>{</p>
<p>obj.base1::function( ); // Function of class base1 is called.</p>
<p>obj.base2::function( ); // Function of class base2 is called. }</p>
<p>Section 34.14: Non-static member functions</p>
<p>A class can have non-static member functions, which operate on
individual instances of the class.</p>
<p>class CL {</p>
<p>public:</p>
<p>void member_function() {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 192</p>
<p>};</p>
<p>These functions are called on an instance of the class, like so:</p>
<p>CL instance;</p>
<p>instance.member_function();</p>
<p>They can be defined either inside or outside the class definition; if
defined outside, they are specified as being in</p>
<p>the class' scope.</p>
<p>struct ST {</p>
<p>void defined_inside() {}</p>
<p>void defined_outside();</p>
<p>};</p>
<p>void ST::defined_outside() {}</p>
<p>They can be CV-qualified and/or ref-qualified, affecting how they see
the instance they're called upon; the function</p>
<p>will see the instance as having the specified cv-qualifier(s), if
any. Which version is called will be based on the</p>
<p>instance's cv-qualifiers. If there is no version with the same
cv-qualifiers as the instance, then a more-cv-qualified version will be
called if available.</p>
<p>struct CVQualifiers {</p>
<p>void func() {} // 1: Instance is non-cv-qualified.</p>
<p>void func() const {} // 2: Instance is const.</p>
<p>void cv_only() const volatile {}</p>
<p>};</p>
<p>CVQualifiers non_cv_instance;</p>
<p>const CVQualifiers c_instance;</p>
<p>non_cv_instance.func(); // Calls #1.</p>
<p>c_instance.func(); // Calls #2.</p>
<p>non_cv_instance.cv_only(); // Calls const volatile version.
c_instance.cv_only(); // Calls const volatile version.</p>
<p>Version ≥ C++11</p>
<p>Member function ref-qualifiers indicate whether or not the function
is intended to be called on rvalue instances,</p>
<p>and use the same syntax as function cv-qualifiers.</p>
<p>struct RefQualifiers {</p>
<p>void func() &amp; {} // 1: Called on normal instances.</p>
<p>void func() &amp;&amp; {} // 2: Called on rvalue (temporary)
instances.</p>
<p>};</p>
<p>RefQualifiers rf;</p>
<p>rf.func(); // Calls #1.</p>
<p>RefQualifiers{}.func(); // Calls #2.</p>
<p>CV-qualifiers and ref-qualifiers can also be combined if
necessary.</p>
<p>struct BothCVAndRef {</p>
<p>void func() const&amp; {} // Called on normal instances. Sees
instance as const. void func() &amp;&amp; {} // Called on temporary
instances.</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 193</p>
<p>They can also be virtual; this is fundamental to polymorphism, and
allows a child class(es) to provide the same interface as the parent
class, while supplying their own functionality.</p>
<p>struct Base {</p>
<p>virtual void func() {}</p>
<p>};</p>
<p>struct Derived {</p>
<p>virtual void func() {}</p>
<p>};</p>
<p>Base* bp = new Base;</p>
<p>Base* dp = new Derived;</p>
<p>bp.func(); // Calls Base::func().</p>
<p>dp.func(); // Calls Derived::func().</p>
<p>For more information, see here.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 194</p>
<p><span id="Chapter_35__Function_Overloading_1"
class="anchor"></span>Chapter 35: Function Overloading</p>
<p>See also separate topic on Overload Resolution</p>
<p>Section 35.1: What is Function Overloading?</p>
<p>Function overloading is having multiple functions declared in the
same scope with the exact same name exist in the</p>
<p>same place (known as <em>scope</em>) differing only in their
<em>signature</em>, meaning the arguments they accept.</p>
<p>Suppose you are writing a series of functions for generalized
printing capabilities, beginning with std::string:</p>
<p>void print(const std::string &amp;str)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is a string: " &lt;&lt; str &lt;&lt;
std::endl; }</p>
<p>This works fine, but suppose you want a function that also accepts an
int and prints that too. You could write:</p>
<p>void print_int(int num)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is an int: " &lt;&lt; num &lt;&lt;
std::endl; }</p>
<p>But because the two functions accept different parameters, you can
simply write:</p>
<p>void print(int num)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is an int: " &lt;&lt; num &lt;&lt;
std::endl; }</p>
<p>Now you have 2 functions, both named print, but with different
signatures. One accepts std::string, the other</p>
<p>one an int. Now you can call them without worrying about different
names:</p>
<p>print("Hello world!"); //prints "This is a string: Hello world!"
print(1337); //prints "This is an int: 1337"</p>
<p>Instead of:</p>
<p>print("Hello world!");</p>
<p>print_int(1337);</p>
<p>When you have overloaded functions, the compiler infers which of the
functions to call from the parameters you</p>
<p>provide it. Care must be taken when writing function overloads. For
example, with implicit type conversions:</p>
<p>void print(int num)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is an int: " &lt;&lt; num &lt;&lt;
std::endl; }</p>
<p>void print(double num)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is a double: " &lt;&lt; num &lt;&lt;
std::endl; }</p>
<p>Now it's not immediately clear which overload of print is called when
you write:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 195</p>
<p><span id="print_5" class="anchor"></span>print(5);</p>
<p>And you might need to give your compiler some clues, like:</p>
<p>print(static_cast(5));</p>
<p>print(static_cast(5));</p>
<p>print(5.0);</p>
<p>Some care also needs to be taken when writing overloads that accept
optional parameters:</p>
<p>// WRONG CODE</p>
<p>void print(int num1, int num2 = 0) //num2 defaults to 0 if not
included {</p>
<p>std::cout &lt;&lt; "These are ints: &lt;&lt; num1 &lt;&lt; " and "
&lt;&lt; num2 &lt;&lt; std::endl; }</p>
<p>void print(int num)</p>
<p>{</p>
<p>std::cout &lt;&lt; "This is an int: " &lt;&lt; num &lt;&lt;
std::endl; }</p>
<p>Because there's no way for the compiler to tell if a call like
print(17) is meant for the first or second function because of the
optional second parameter, this will fail to compile.</p>
<p>Section 35.2: Return Type in Function Overloading</p>
<p>Note that you cannot overload a function based on its return type.
For example:</p>
<p>// WRONG CODE</p>
<p>std::string getValue()</p>
<p>{</p>
<p>return "hello";</p>
<p>}</p>
<p>int getValue()</p>
<p>{</p>
<p>return 0;</p>
<p>}</p>
<p>int x = getValue();</p>
<p>This will cause a compilation error as the compiler will not be able
to work out which version of getValue to call, even though the return
type is assigned to an int.</p>
<p>Section 35.3: Member Function cv-qualifier Overloading</p>
<p>Functions within a class can be overloaded for when they are accessed
through a cv-qualified reference to that class; this is most commonly
used to overload for const, but can be used to overload for volatile and
const</p>
<p>volatile , too. This is because all non-static member functions take
this as a hidden parameter, which the cv-qualifiers are applied to. This
is most commonly used to overload for const, but can also be used for
volatile and</p>
<p>const volatile.</p>
<p>This is necessary because a member function can only be called if it
is at least as cv-qualified as the instance it's</p>
<p>called on. While a non-const instance can call both const and
non-const members, a const instance can only call const members. This
allows a function to have different behaviour depending on the calling
instance's cv-qualifiers,</p>
<p>and allows the programmer to disallow functions for an undesired
cv-qualifier(s) by not providing a version with that qualifier(s).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 196</p>
<p>A class with some basic print method could be const overloaded like
so:</p>
<p>#include</p>
<p>class Integer</p>
<p>{</p>
<p>public:</p>
<p>Integer(int i_): i{i_}{}</p>
<p>void print()</p>
<p>{</p>
<p>std::cout &lt;&lt; "int: " &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p>void print() const</p>
<p>{</p>
<p>std::cout &lt;&lt; "const int: " &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p>protected:</p>
<p>int i;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Integer i{5};</p>
<p>const Integer &amp;ic = i;</p>
<p>i.print(); // prints "int: 5"</p>
<p>ic.print(); // prints "const int: 5"</p>
<p>}</p>
<p>This is a key tenet of const correctness: By marking member functions
as const, they are allowed to be called on const instances, which in
turn allows functions to take instances as const pointers/references if
they don't need to</p>
<p>modify them. This allows code to specify whether it modifies state by
taking unmodified parameters as const and</p>
<p>modified parameters without cv-qualifiers, making code both safer and
more readable.</p>
<p>class ConstCorrect</p>
<p>{</p>
<p>public:</p>
<p>void good_func() const</p>
<p>{</p>
<p>std::cout &lt;&lt; "I care not whether the instance is const."
&lt;&lt; std::endl;</p>
<p>}</p>
<p>void bad_func()</p>
<p>{</p>
<p>std::cout &lt;&lt; "I can only be called on non-const, non-volatile
instances." &lt;&lt; std::endl;</p>
<p>}</p>
<p>};</p>
<p>void i_change_no_state(const ConstCorrect&amp; cc)</p>
<p>{</p>
<p>std::cout &lt;&lt; "I can take either a const or a non-const
ConstCorrect." &lt;&lt; std::endl;</p>
<p>cc.good_func(); // Good. Can be called from const or non-const
instance.</p>
<p>cc.bad_func(); // Error. Can only be called from non-const instance.
}</p>
<p>void const_incorrect_func(ConstCorrect&amp; cc)</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 197</p>
<p>cc.good_func(); // Good. Can be called from const or non-const
instance.</p>
<p>cc.bad_func(); // Good. Can only be called from non-const instance.
}</p>
<p>A common usage of this is declaring accessors as const, and mutators
as non-const.</p>
<p>No class members can be modified within a const member function. If
there is some member that you really need</p>
<p>to modify, such as locking a std::mutex, you can declare it as
mutable:</p>
<p>class Integer</p>
<p>{</p>
<p>public:</p>
<p>Integer(int i_): i{i_}{}</p>
<p>int get() const</p>
<p>{</p>
<p>std::lock_guard lock{mut};</p>
<p>return i;</p>
<p>}</p>
<p>void set(int i_)</p>
<p>{</p>
<p>std::lock_guard lock{mut};</p>
<p>i = i_;</p>
<p>}</p>
<p>protected:</p>
<p>int i;</p>
<p>mutable std::mutex mut;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 198</p>
<p><span id="Chapter_36__Operator_Overloading_1"
class="anchor"></span>Chapter 36: Operator Overloading</p>
<p>In C++, it is possible to define operators such as + and -&gt; for
user-defined types. For example, the <strong>&lt;string&gt;</strong>
header</p>
<p>defines a + operator to concatenate strings. This is done by defining
an <em>operator function</em> using the operator keyword.</p>
<p>Section 36.1: Arithmetic operators</p>
<p>You can overload all basic arithmetic operators:</p>
<p>+ and +=</p>
<p>- and -=</p>
<p>* and *=</p>
<p>/ and /=</p>
<p>&amp; and &amp;=</p>
<p>| and |=</p>
<p>^ and ^=</p>
<p>&gt;&gt; and &gt;&gt;=</p>
<p>&lt;&lt; and &lt;&lt;=</p>
<p>Overloading for all operators is the same. <em>Scroll down for
explanation</em></p>
<p>Overloading outside of class/struct:</p>
<p>//operator+ should be implemented in terms of operator+= T
operator+(T lhs, const T&amp; rhs)</p>
<p>{</p>
<p>lhs += rhs;</p>
<p>return lhs;</p>
<p>}</p>
<p>T&amp; operator+=(T&amp; lhs, const T&amp; rhs)</p>
<p>{</p>
<p>//Perform addition</p>
<p>return lhs;</p>
<p>}</p>
<p>Overloading inside of class/struct:</p>
<p>//operator+ should be implemented in terms of operator+= T
operator+(const T&amp; rhs)</p>
<p>{</p>
<p>*this += rhs;</p>
<p>return *this;</p>
<p>}</p>
<p>T&amp; operator+=(const T&amp; rhs)</p>
<p>{</p>
<p>//Perform addition</p>
<p>return *this;</p>
<p>}</p>
<p>Note: operator+ should return by non-const value, as returning a
reference wouldn't make sense (it returns a <em>new</em> object) nor
would returning a const value (you should generally not return by
const). The first argument is passed</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 199</p>
<p><span id="by_value__why__Because" class="anchor"></span>by value,
why? Because</p>
<p>1. You can't modify the original object (Object foobar = foo + bar;
shouldn't modify foo after all, it wouldn't</p>
<p>make sense)</p>
<p>2. You can't make it const, because you will have to be able to
modify the object (because operator+ is</p>
<p>implemented in terms of operator+=, which modifies the object)</p>
<p>Passing by const&amp; would be an option, but then you will have to
make a temporary copy of the passed object. By</p>
<p>passing by value, the compiler does it for you.</p>
<p>operator+= returns a reference to the itself, because it is then
possible to chain them (don't use the same variable though, that would
be undefined behavior due to sequence points).</p>
<p>The first argument is a reference (we want to modify it), but not
const, because then you wouldn't be able to</p>
<p>modify it. The second argument should not be modified, and so for
performance reason is passed by const&amp;</p>
<p>(passing by const reference is faster than by value).</p>
<p>Section 36.2: Array subscript operator</p>
<p>You can even overload the array subscript operator [].</p>
<p>You should <strong>always</strong> (99.98% of the time) implement 2
versions, a const and a not-const version, because if the</p>
<p>object is const, it should not be able to modify the object returned
by [].</p>
<p>The arguments are passed by const&amp; instead of by value because
passing by reference is faster than by value, and const so that the
operator doesn't change the index accidentally.</p>
<p>The operators return by reference, because by design you can modify
the object [] return, i.e:</p>
<p>std::vector v{ 1 };</p>
<p>v[0] = 2; //Changes value of 1 to 2</p>
<p>//wouldn't be possible if not returned by reference</p>
<p>You can <strong>only</strong> overload inside a class/struct:</p>
<p>//I is the index type, normally an int</p>
<p>T&amp; operator[](const I&amp; index)</p>
<p>{</p>
<p>//Do something</p>
<p>//return something</p>
<p>}</p>
<p>//I is the index type, normally an int</p>
<p>const T&amp; operator[](const I&amp; index) const</p>
<p>{</p>
<p>//Do something</p>
<p>//return something</p>
<p>}</p>
<p>Multiple subscript operators, [][]..., can be achieved via proxy
objects. The following example of a simple row-</p>
<p>major matrix class demonstrates this:</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 200</p>
<p><span id="class_matrix" class="anchor"></span>class matrix {</p>
<p>// class enabling [][] overload to access matrix elements
template</p>
<p>class proxy_row_vector {</p>
<p>using reference = decltype(std::declval()[0]);</p>
<p>using const_reference = decltype(std::declval()[0]);</p>
<p>public:</p>
<p>proxy_row_vector(C&amp; _vec, std::size_t _r_ind, std::size_t
_cols)</p>
<p>: vec(_vec), row_index(_r_ind), cols(_cols) {}</p>
<p>const_reference operator[](std::size_t _col_index) const {</p>
<p>return vec[row_index*cols + _col_index];</p>
<p>}</p>
<p>reference operator[](std::size_t _col_index) {</p>
<p>return vec[row_index*cols + _col_index];</p>
<p>}</p>
<p>private:</p>
<p>C&amp; vec;</p>
<p>std::size_t row_index; // row index to access</p>
<p>std::size_t cols; // number of columns in matrix</p>
<p>};</p>
<p>using const_proxy = proxy_row_vector&gt;; using proxy =
proxy_row_vector&gt;;</p>
<p>public:</p>
<p>matrix() : mtx(), rows(0), cols(0) {}</p>
<p>matrix(std::size_t _rows, std::size_t _cols)</p>
<p>: mtx(_rows*_cols), rows(_rows), cols(_cols) {}</p>
<p>// call operator[] followed by another [] call to access matrix
elements</p>
<p>const_proxy operator[](std::size_t _row_index) const {</p>
<p>return const_proxy(mtx, _row_index, cols);</p>
<p>}</p>
<p>proxy operator[](std::size_t _row_index) {</p>
<p>return proxy(mtx, _row_index, cols);</p>
<p>}</p>
<p>private:</p>
<p>std::vector mtx;</p>
<p>std::size_t rows;</p>
<p>std::size_t cols;</p>
<p>};</p>
<p>Section 36.3: Conversion operators</p>
<p>You can overload type operators, so that your type can be implicitly
converted into the specified type.</p>
<p>The conversion operator <strong>must</strong> be defined in a
class/struct:</p>
<p>operator T() const { <em>/* return something */</em> }</p>
<p>Note: the operator is const to allow const objects to be
converted.</p>
<p>Example:</p>
<p>struct Text</p>
<p>{</p>
<p>std::string text;</p>
<p>// Now Text can be implicitly converted into a const char*
<em>/*explicit*/</em> operator const char*() const { return text.data();
}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 201</p>
<p><span id="_16" class="anchor"></span>// ^^^^^^^</p>
<p>// to disable implicit conversion</p>
<p>};</p>
<p>Text t;</p>
<p>t.text = "Hello world!";</p>
<p>//Ok</p>
<p>const char* copyoftext = t;</p>
<p>Section 36.4: Complex Numbers Revisited</p>
<p>The code below implements a very simple complex number type for which
the underlying field is automatically promoted, following the language's
type promotion rules, under application of the four basic operators (+,
-, *, and</p>
<p>/) with a member of a different field (be it another complex or some
scalar type).</p>
<p>This is intended to be a holistic example covering operator
overloading alongside basic use of templates.</p>
<p>#include</p>
<p>namespace not_std{</p>
<p>using std::decay_t;</p>
<p>//----------------------------------------------------------------//
complex&lt; value_t &gt;</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>struct complex</p>
<p>{</p>
<p>value_t x;</p>
<p>value_t y;</p>
<p>complex &amp;operator += (const value_t &amp;x)</p>
<p>{</p>
<p>this-&gt;x += x;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator += (const complex &amp;other)</p>
<p>{</p>
<p>this-&gt;x += other.x;</p>
<p>this-&gt;y += other.y;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator -= (const value_t &amp;x)</p>
<p>{</p>
<p>this-&gt;x -= x;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator -= (const complex &amp;other)</p>
<p>{</p>
<p>this-&gt;x -= other.x;</p>
<p>this-&gt;y -= other.y;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator *= (const value_t &amp;s)</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 202</p>
<p>this-&gt;x *= s;</p>
<p>this-&gt;y *= s;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator *= (const complex &amp;other)</p>
<p>{</p>
<p>(*this) = (*this) * other;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator /= (const value_t &amp;s)</p>
<p>{</p>
<p>this-&gt;x /= s;</p>
<p>this-&gt;y /= s;</p>
<p>return *this;</p>
<p>}</p>
<p>complex &amp;operator /= (const complex &amp;other)</p>
<p>{</p>
<p>(*this) = (*this) / other;</p>
<p>return *this;</p>
<p>}</p>
<p>complex(const value_t &amp;x, const value_t &amp;y)</p>
<p>: x{x}</p>
<p>, y{y}</p>
<p>{}</p>
<p>template</p>
<p>explicit complex(const complex &amp;other) :
x{static_cast(other.x)}</p>
<p>, y{static_cast(other.y)}</p>
<p>{}</p>
<p>complex &amp;operator = (const complex &amp;) = default;</p>
<p>complex &amp;operator = (complex &amp;&amp;) = default;</p>
<p>complex(const complex &amp;) = default;</p>
<p>complex(complex &amp;&amp;) = default;</p>
<p>complex() = default;</p>
<p>};</p>
<p>// Absolute value squared</p>
<p>template</p>
<p>value_t absqr(const complex &amp;z)</p>
<p>{ return z.x*z.x + z.y*z.y; }</p>
<p>//----------------------------------------------------------------//
operator - (negation)</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>complex operator -(const complex &amp;z) { return {-z.x, -z.y}; }</p>
<p>//----------------------------------------------------------------//
operator +</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>auto operator + (const complex &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a.x + b.x, a.y + b.y}; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 203</p>
<p>template</p>
<p>auto operator + (const left_t &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a + b.x, b.y}; }</p>
<p>template</p>
<p>auto operator + (const complex &amp;a, const right_t &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a.x + b, a.y}; }</p>
<p>//----------------------------------------------------------------//
operator -</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>auto operator -(const complex &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a.x- b.x, a.y- b.y}; }</p>
<p>template</p>
<p>auto operator -(const left_t &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a - b.x, - b.y}; }</p>
<p>template</p>
<p>auto operator -(const complex &amp;a, const right_t &amp;b)-&gt;
complex&gt;</p>
<p>{ return{a.x- b, a.y}; }</p>
<p>//----------------------------------------------------------------//
operator *</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>auto operator * (const complex &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{</p>
<p>return {</p>
<p>a.x*b.x- a.y*b.y,</p>
<p>a.x*b.y + a.y*b.x</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>auto operator * (const left_t &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{ return {a * b.x, a * b.y}; }</p>
<p>template</p>
<p>auto operator * (const complex &amp;a, const right_t &amp;b)-&gt;
complex&gt;</p>
<p>{ return {a.x * b, a.y * b}; }</p>
<p>//----------------------------------------------------------------//
operator /</p>
<p>//----------------------------------------------------------------</p>
<p>template</p>
<p>auto operator / (const complex &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{</p>
<p>const auto r = absqr(b);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 204</p>
<p>return {</p>
<p>( a.x*b.x + a.y*b.y) / r,</p>
<p>(-a.x*b.y + a.y*b.x) / r</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>auto operator / (const left_t &amp;a, const complex &amp;b)-&gt;
complex&gt;</p>
<p>{</p>
<p>const auto s = a/absqr(b);</p>
<p>return {</p>
<p>b.x * s,</p>
<p>-b.y * s</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>auto operator / (const complex &amp;a, const right_t &amp;b)-&gt;
complex&gt;</p>
<p>{ return {a.x / b, a.y / b}; }</p>
<p>}// namespace not_std</p>
<p>int main(int argc, char **argv)</p>
<p>{</p>
<p>using namespace not_std;</p>
<p>complex fz{4.0f, 1.0f};</p>
<p>// makes a complex</p>
<p>auto dz = fz * 1.0;</p>
<p>// still a complex</p>
<p>auto idz = 1.0f/dz;</p>
<p>// also a complex</p>
<p>auto one = dz * idz;</p>
<p>// a complex again</p>
<p>auto one_again = fz * idz;</p>
<p>// Operator tests, just to make sure everything compiles.</p>
<p>complex a{1.0f, -2.0f};</p>
<p>complex b{3.0, -4.0};</p>
<p>// All of these are complex</p>
<p>auto c0 = a + b;</p>
<p>auto c1 = a - b;</p>
<p>auto c2 = a * b;</p>
<p>auto c3 = a / b;</p>
<p>// All of these are complex</p>
<p>auto d0 = a + 1;</p>
<p>auto d1 = 1 + a;</p>
<p>auto d2 = a -1;</p>
<p>auto d3 = 1- a;</p>
<p>auto d4 = a * 1;</p>
<p>auto d5 = 1 * a;</p>
<p>auto d6 = a / 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 205</p>
<p><span id="auto_d7___1___a" class="anchor"></span>auto d7 = 1 / a;</p>
<p>// All of these are complex</p>
<p>auto e0 = b + 1;</p>
<p>auto e1 = 1 + b;</p>
<p>auto e2 = b -1;</p>
<p>auto e3 = 1- b;</p>
<p>auto e4 = b * 1;</p>
<p>auto e5 = 1 * b;</p>
<p>auto e6 = b / 1;</p>
<p>auto e7 = 1 / b;</p>
<p>return 0;</p>
<p>}</p>
<p>Section 36.5: Named operators</p>
<p>You can extend C++ with named operators that are "quoted" by standard
C++ operators.</p>
<p>First we start with a dozen-line library:</p>
<p>namespace named_operator {</p>
<p>templatestruct make_operator{constexpr make_operator(){}};</p>
<p>template struct half_apply { T&amp;&amp; lhs; };</p>
<p>template</p>
<p>half_apply operator*( Lhs&amp;&amp; lhs, make_operator ) {</p>
<p>return {std::forward(lhs)};</p>
<p>}</p>
<p>template</p>
<p>auto operator*( half_apply&amp;&amp; lhs, Rhs&amp;&amp; rhs )-&gt;
decltype( named_invoke( std::forward(lhs.lhs), Op{}, std::forward(rhs) )
) {</p>
<p>return named_invoke( std::forward(lhs.lhs), Op{}, std::forward(rhs)
);</p>
<p>}</p>
<p>}</p>
<p>this doesn't do anything yet.</p>
<p>First, appending vectors</p>
<p>namespace my_ns {</p>
<p>struct append_t : named_operator::make_operator {}; constexpr
append_t append{};</p>
<p>template</p>
<p>std::vector named_invoke( std::vector lhs, append_t, std::vector
const&amp; rhs ) {</p>
<p>lhs.insert( lhs.end(), rhs.begin(), rhs.end() );</p>
<p>return std::move(lhs);</p>
<p>}</p>
<p>}</p>
<p>using my_ns::append;</p>
<p>std::vector a {1,2,3};</p>
<p>std::vector b {4,5,6};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 206</p>
<p>auto c = a *append* b;</p>
<p>The core here is that we define an append object of type
append_t:named_operator::make_operator.</p>
<p>We then overload named_invoke( lhs, append_t, rhs ) for the types we
want on the right and left.</p>
<p>The library overloads lhs*append_t, returning a temporary half_apply
object. It also overloads half_apply*rhs to call named_invoke( lhs,
append_t, rhs ).</p>
<p>We simply have to create the proper append_t token and do an
ADL-friendly named_invoke of the proper signature,</p>
<p>and everything hooks up and works.</p>
<p>For a more complex example, suppose you want to have element-wise
multiplication of elements of a std::array:</p>
<p>template</p>
<p>auto indexer( std::index_sequence ) {</p>
<p>return [](auto&amp;&amp; f) {</p>
<p>return f( std::integral_constant{}... );</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>auto indexer() { return indexer( std::make_index_sequence{} ); }</p>
<p>namespace my_ns {</p>
<p>struct e_times_t : named_operator::make_operator {}; constexpr
e_times_t e_times{};</p>
<p>template</p>
<p>class Out=std::decay_t()*std::declval() )&gt;</p>
<p>&gt;</p>
<p>std::array named_invoke( std::array const&amp; lhs, e_times_t,
std::array const&amp; rhs ) {</p>
<p>using result_type = std::array;</p>
<p>auto index_over_N = indexer();</p>
<p>return index_over_N([&amp;](auto...is)-&gt;result_type {</p>
<p>return {{</p>
<p>(lhs[is] * rhs[is])...</p>
<p>}};</p>
<p>});</p>
<p>}</p>
<p>}</p>
<p><a href="http://coliru.stacked-crooked.com/a/c071a0662834c838">live
example.</a></p>
<p>This element-wise array code can be extended to work on tuples or
pairs or C-style arrays, or even variable length containers if you
decide what to do if the lengths don't match.</p>
<p>You could also an element-wise operator type and get lhs
*element_wise&lt;'+'&gt;* rhs.</p>
<p>Writing a *dot* and *cross* product operators are also obvious
uses.</p>
<p>The use of * can be extended to support other delimiters, like +. The
delimeter precidence determines the</p>
<p>precidence of the named operator, which may be important when
translating physics equations over to C++ with minimal use of extra
()s.</p>
<p>With a slight change in the library above, we can support -&gt;*then*
operators and extend std::function prior to the standard being updated,
or write monadic -&gt;*bind*. It could also have a stateful named
operator, where we</p>
<p>carefully pass the Op down to the final invoke function,
permitting:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 207</p>
<p><span id="named_operator______append"
class="anchor"></span>named_operator&lt;'*'&gt; append = [](auto lhs,
auto&amp;&amp; rhs) {</p>
<p>using std::begin; using std::end;</p>
<p>lhs.insert( end(lhs), begin(rhs), end(rhs) );</p>
<p>return std::move(lhs);</p>
<p>};</p>
<p>generating a named container-appending operator in C++17.</p>
<p>Section 36.6: Unary operators</p>
<p>You can overload the 2 unary operators:</p>
<p>++foo and foo++</p>
<p>--foo and foo--</p>
<p>Overloading is the same for both types (++ and --). <em>Scroll down
for explanation</em></p>
<p>Overloading outside of class/struct:</p>
<p>//Prefix operator ++foo</p>
<p>T&amp; operator++(T&amp; lhs)</p>
<p>{</p>
<p>//Perform addition</p>
<p>return lhs;</p>
<p>}</p>
<p>//Postfix operator foo++ (int argument is used to separate pre- and
postfix) //Should be implemented in terms of ++foo (prefix operator) T
operator++(T&amp; lhs, int)</p>
<p>{</p>
<p>T t(lhs);</p>
<p>++lhs;</p>
<p>return t;</p>
<p>}</p>
<p>Overloading inside of class/struct:</p>
<p>//Prefix operator ++foo</p>
<p>T&amp; operator++()</p>
<p>{</p>
<p>//Perform addition</p>
<p>return *this;</p>
<p>}</p>
<p>//Postfix operator foo++ (int argument is used to separate pre- and
postfix) //Should be implemented in terms of ++foo (prefix operator) T
operator++(int)</p>
<p>{</p>
<p>T t(*this);</p>
<p>++(*this);</p>
<p>return t;</p>
<p>}</p>
<p>Note: The prefix operator returns a reference to itself, so that you
can continue operations on it. The first argument is a reference, as the
prefix operator changes the object, that's also the reason why it isn't
const (you wouldn't be</p>
<p>able to modify it otherwise).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 208</p>
<p><span id="The_postfix_operator_returns_by" class="anchor"></span>The
postfix operator returns by value a temporary (the previous value), and
so it cannot be a reference, as it would be a reference to a temporary,
which would be garbage value at the end of the function, because the
temporary</p>
<p>variable goes out of scope). It also cannot be const, because you
should be able to modify it directly.</p>
<p>The first argument is a non-const reference to the "calling" object,
because if it were const, you wouldn't be able to</p>
<p>modify it, and if it weren't a reference, you wouldn't change the
original value.</p>
<p>It is because of the copying needed in postfix operator overloads
that it's better to make it a habit to use prefix ++</p>
<p>instead of postfix ++ in for loops. From the for loop perspective,
they're usually functionally equivalent, but there might be a slight
performance advantage to using prefix ++, especially with "fat" classes
with a lot of members to</p>
<p>copy. Example of using prefix ++ in a for loop:</p>
<p>for (list::const_iterator it = tokens.begin();</p>
<p>it != tokens.end();</p>
<p>++it) { // Don't use it++</p>
<p>...</p>
<p>}</p>
<p>Section 36.7: Comparison operators</p>
<p>You can overload all comparison operators:</p>
<p>== and !=</p>
<p>&gt; and &lt;</p>
<p>&gt;= and &lt;=</p>
<p>The recommended way to overload all those operators is by
implementing only 2 operators (== and &lt;) and then using those to
define the rest. <em>Scroll down for explanation</em></p>
<p>Overloading outside of class/struct:</p>
<p>//Only implement those 2</p>
<p>bool operator==(const T&amp; lhs, const T&amp; rhs) { <em>/* Compare
*/</em> } bool operator&lt;(const T&amp; lhs, const T&amp; rhs) { <em>/*
Compare */</em> }</p>
<p>//Now you can define the rest</p>
<p>bool operator!=(const T&amp; lhs, const T&amp; rhs) { return !(lhs ==
rhs); } bool operator&gt;(const T&amp; lhs, const T&amp; rhs) { return
rhs &lt; lhs; } bool operator&lt;=(const T&amp; lhs, const T&amp; rhs) {
return !(lhs &gt; rhs); } bool operator&gt;=(const T&amp; lhs, const
T&amp; rhs) { return !(lhs &lt; rhs); }</p>
<p>Overloading inside of class/struct:</p>
<p>//Note that the functions are const, because if they are not const,
you wouldn't be able //to call them if the object is const</p>
<p>//Only implement those 2</p>
<p>bool operator==(const T&amp; rhs) const { <em>/* Compare */</em>
}</p>
<p>bool operator&lt;(const T&amp; rhs) const { <em>/* Compare */</em>
}</p>
<p>//Now you can define the rest</p>
<p>bool operator!=(const T&amp; rhs) const { return !(*this == rhs); }
bool operator&gt;(const T&amp; rhs) const { return rhs &lt; *this; }
bool operator&lt;=(const T&amp; rhs) const { return !(*this &gt; rhs); }
bool operator&gt;=(const T&amp; rhs) const { return !(*this &lt; rhs);
}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 209</p>
<p><span id="The_operators_obviously_return_a" class="anchor"></span>The
operators obviously return a bool, indicating true or false for the
corresponding operation.</p>
<p>All of the operators take their arguments by const&amp;, because the
only thing that does operators do is compare, so</p>
<p>they shouldn't modify the objects. Passing by &amp; (reference) is
faster than by value, and to make sure that the operators don't modify
it, it is a const-reference.</p>
<p>Note that the operators inside the class/struct are defined as const,
the reason for this is that without the functions being const, comparing
const objects would not be possible, as the compiler doesn't know that
the</p>
<p>operators don't modify anything.</p>
<p>Section 36.8: Assignment operator</p>
<p>The assignment operator is one of the most important operators
because it allows you to change the status of a</p>
<p>variable.</p>
<p>If you do not overload the assignment operator for your class/struct,
it is automatically generated by the</p>
<p>compiler: the automatically-generated assignment operator performs a
"memberwise assignment", ie by invoking assignment operators on all
members, so that one object is copied to the other, a member at time.
The assignment</p>
<p>operator should be overloaded when the simple memberwise assignment
is not suitable for your class/struct, for</p>
<p>example if you need to perform a <strong>deep copy</strong> of an
object.</p>
<p>Overloading the assignment operator = is easy, but you should follow
some simple steps.</p>
<p>1. <strong>Test for self-assignment.</strong> This check is important
for two reasons:</p>
<p>a self-assignment is a needless copy, so it does not make sense to
perform it;</p>
<p>the next step will not work in the case of a self-assignment.</p>
<p>2. <strong>Clean the old data.</strong> The old data must be replaced
with new ones. Now, you can understand the second</p>
<p>reason of the previous step: if the content of the object was
destroyed, a self-assignment will fail to perform</p>
<p>the copy.</p>
<p>3. <strong>Copy all members.</strong> If you overload the assignment
operator for your class or your struct, it is not</p>
<p>automatically generated by the compiler, so you will need to take
charge of copying all members from the other object.</p>
<p>4. <strong>Return</strong> *this. The operator returns by itself by
reference, because it allows chaining (i.e. int b = (a = 6) +</p>
<p>4; //b == 10).</p>
<p>//T is some type</p>
<p>T&amp; operator=(const T&amp; other)</p>
<p>{</p>
<p>//Do something (like copying values)</p>
<p>return *this;</p>
<p>}</p>
<p><strong>Note:</strong> other is passed by const&amp;, because the
object being assigned should not be changed, and passing by</p>
<p>reference is faster than by value, and to make sure than operator=
doesn't modify it accidentally, it is const.</p>
<p>The assignment operator can <strong>only</strong> to be overloaded in
the class/struct, because the left value of = is <strong>always</strong>
the</p>
<p>class/struct itself. Defining it as a free function doesn't have this
guarantee, and is disallowed because of that.</p>
<p>When you declare it in the class/struct, the left value is implicitly
the class/struct itself, so there is no problem</p>
<p>with that.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 210</p>
<p><span id="Section_36_9__Function_call_oper"
class="anchor"></span>Section 36.9: Function call operator</p>
<p>You can overload the function call operator ():</p>
<p>Overloading must be done inside of a class/struct:</p>
<p>//R -&gt; Return type</p>
<p>//Types -&gt; any different type</p>
<p>R operator()(Type name, Type2 name2, ...)</p>
<p>{</p>
<p>//Do something</p>
<p>//return something</p>
<p>}</p>
<p>//Use it like this (R is return type, a and b are variables) R foo =
object(a, b, ...);</p>
<p>For example:</p>
<p>struct Sum</p>
<p>{</p>
<p>int operator()(int a, int b)</p>
<p>{</p>
<p>return a + b;</p>
<p>}</p>
<p>};</p>
<p>//Create instance of struct</p>
<p>Sum sum;</p>
<p>int result = sum(1, 1); //result == 2</p>
<p>Section 36.10: Bitwise NOT operator</p>
<p>Overloading the bitwise NOT (~) is fairly simple. <em>Scroll down for
explanation</em></p>
<p>Overloading outside of class/struct:</p>
<p>T operator~(T lhs)</p>
<p>{</p>
<p>//Do operation</p>
<p>return lhs;</p>
<p>}</p>
<p>Overloading inside of class/struct:</p>
<p>T operator~()</p>
<p>{</p>
<p>T t(*this);</p>
<p>//Do operation</p>
<p>return t;</p>
<p>}</p>
<p>Note: operator~ returns by value, because it has to return a new
value (the modified value), and not a reference to</p>
<p>the value (it would be a reference to the temporary object, which
would have garbage value in it as soon as the operator is done). Not
const either because the calling code should be able to modify it
afterwards (i.e. int a = ~a</p>
<p>+ 1; should be possible).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 211</p>
<p><span id="Inside_the_class_struct_you_have"
class="anchor"></span>Inside the class/struct you have to make a
temporary object, because you can't modify this, as it would modify the
original object, which shouldn't be the case.</p>
<p>Section 36.11: Bit shift operators for I/O</p>
<p>The operators &lt;&lt; and &gt;&gt; are commonly used as "write" and
"read" operators:</p>
<p>std::ostream overloads &lt;&lt; to write variables to the underlying
stream (example: std::cout)</p>
<p>std::istream overloads &gt;&gt; to read from the underlying stream to
a variable (example: std::cin)</p>
<p>The way they do this is similar if you wanted to overload them
"normally" outside of the class/struct, except that</p>
<p>specifying the arguments are not of the same type:</p>
<p>Return type is the stream you want to overload from (for example,
std::ostream) passed by reference, to</p>
<p>allow chaining (Chaining: std::cout &lt;&lt; a &lt;&lt; b;). Example:
std::ostream&amp; lhs would be the same as the return type</p>
<p>rhs is the type you want to allow overloading from (i.e. T), passed
by const&amp; instead of value for performance reason (rhs shouldn't be
changed anyway). Example: const Vector&amp;.</p>
<p>Example:</p>
<p>//Overload std::ostream operator&lt;&lt; to allow output from
Vector's std::ostream&amp; operator&lt;&lt;(std::ostream&amp; lhs, const
Vector&amp; rhs) {</p>
<p>lhs &lt;&lt; "x: " &lt;&lt; rhs.x &lt;&lt; " y: " &lt;&lt; rhs.y
&lt;&lt; " z: " &lt;&lt; rhs.z &lt;&lt; '<strong>\n</strong>';</p>
<p>return lhs;</p>
<p>}</p>
<p>Vector v = { 1, 2, 3};</p>
<p>//Now you can do</p>
<p>std::cout &lt;&lt; v;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 212</p>
<p><span id="Chapter_37__Function_Template"
class="anchor"></span>Chapter 37: Function Template</p>
<p>Overloading</p>
<p>Section 37.1: What is a valid function template overloading?</p>
<p>A function template can be overloaded under the rules for
non-template function overloading (same name, but different parameter
types) and in addition to that, the overloading is valid if</p>
<p>The return type is different, or</p>
<p>The template parameter list is different, except for the naming of
parameters and the presence of default</p>
<p>arguments (they are not part of the signature)</p>
<p>For a normal function, comparing two parameter types is is easy for
the compiler, since it has all informat. But a</p>
<p>type within a template may not be determined yet. Therefore, the rule
for when two parameter types are equal is approximative here and says
that the non-depependend types and values need to match and the spelling
of</p>
<p>dependent types and expressions needs to be the same (more precisely,
they need to conform to the so-called ODR-rules), except that template
parameters may be renamed. However, if under such different spellings,
two</p>
<p>values within the types are deemed different, but will always
instantiate to the same values, the overloading is invalid, but no
diagnostic is required from the compiler.</p>
<p>template</p>
<p>void f(T*) { }</p>
<p>template</p>
<p>void f(T) { }</p>
<p>This is a valid overload, as "T" and "T*" are different spellings.
But the following is invalid, with no diagnostic</p>
<p>required</p>
<p>template</p>
<p>void f(T (*x)[sizeof(T) + sizeof(T)]) { }</p>
<p>template</p>
<p>void f(T (*x)[2 * sizeof(T)]) { }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 213</p>
<p><span id="Chapter_38__Virtual_Member_Funct_1"
class="anchor"></span>Chapter 38: Virtual Member Functions</p>
<p>Section 38.1: Final virtual functions</p>
<p>C++11 introduced final specifier which forbids method overriding if
appeared in method signature:</p>
<p>class Base {</p>
<p>public:</p>
<p>virtual void foo() {</p>
<p>std::cout &lt;&lt; "Base::Foo<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>class Derived1 : public Base {</p>
<p>public:</p>
<p>// Overriding Base::foo</p>
<p>void foo() final {</p>
<p>std::cout &lt;&lt; "Derived1::Foo<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>class Derived2 : public Derived1 {</p>
<p>public:</p>
<p>// Compilation error: cannot override final method virtual void foo()
{</p>
<p>std::cout &lt;&lt; "Derived2::Foo<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>The specifier final can only be used with `virtual' member function
and can't be applied to non-virtual member</p>
<p>functions</p>
<p>Like final, there is also an specifier caller 'override' which
prevent overriding of virtual functions in the derived</p>
<p>class.</p>
<p>The specifiers override and final may be combined together to have
desired effect:</p>
<p>class Derived1 : public Base {</p>
<p>public:</p>
<p>void foo() final override {</p>
<p>std::cout &lt;&lt; "Derived1::Foo<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>Section 38.2: Using override with virtual in C++11 and later</p>
<p>The specifier override has a special meaning in C++11 onwards, if
appended at the end of function signature. This</p>
<p>signifies that a function is</p>
<p>Overriding the function present in base class &amp;</p>
<p>The Base class function is virtual</p>
<p>There is no run time significance of this specifier as is mainly
meant as an indication for compilers</p>
<p>The example below will demonstrate the change in behaviour with our
without using override.</p>
<p>Without override:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 214</p>
<p><span id="_include" class="anchor"></span>#include</p>
<p>struct X {</p>
<p>virtual void f() { std::cout &lt;&lt; "X::f()<strong>\n</strong>";
}</p>
<p>};</p>
<p>struct Y : X {</p>
<p>// Y::f() will not override X::f() because it has a different
signature, // but the compiler will accept the code (and silently ignore
Y::f()). virtual void f(int a) { std::cout &lt;&lt; a &lt;&lt;
"<strong>\n</strong>"; }</p>
<p>};</p>
<p>With override:</p>
<p>#include</p>
<p>struct X {</p>
<p>virtual void f() { std::cout &lt;&lt; "X::f()<strong>\n</strong>";
}</p>
<p>};</p>
<p>struct Y : X {</p>
<p>// The compiler will alert you to the fact that Y::f() does not //
actually override anything.</p>
<p>virtual void f(int a) override { std::cout &lt;&lt; a &lt;&lt;
"<strong>\n</strong>"; }</p>
<p>};</p>
<p>Note that override is not a keyword, but a special identifier which
only may appear in function signatures. In all other contexts override
still may be used as an identifier:</p>
<p>void foo() {</p>
<p>int override = 1; // OK.</p>
<p>int virtual = 2; // Compilation error: keywords can't be used as
identifiers.</p>
<p>}</p>
<p>Section 38.3: Virtual vs non-virtual member functions</p>
<p>With virtual member functions:</p>
<p>#include</p>
<p>struct X {</p>
<p>virtual void f() { std::cout &lt;&lt; "X::f()<strong>\n</strong>";
}</p>
<p>};</p>
<p>struct Y : X {</p>
<p>// Specifying virtual again here is optional</p>
<p>// because it can be inferred from X::f().</p>
<p>virtual void f() { std::cout &lt;&lt; "Y::f()<strong>\n</strong>";
}</p>
<p>};</p>
<p>void call(X&amp; a) {</p>
<p>a.f();</p>
<p>}</p>
<p>int main() {</p>
<p>X x;</p>
<p>Y y;</p>
<p>call(x); // outputs "X::f()"</p>
<p>call(y); // outputs "Y::f()"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 215</p>
<p><span id="_17" class="anchor"></span>}</p>
<p>Without virtual member functions:</p>
<p>#include</p>
<p>struct X {</p>
<p>void f() { std::cout &lt;&lt; "X::f()<strong>\n</strong>"; }</p>
<p>};</p>
<p>struct Y : X {</p>
<p>void f() { std::cout &lt;&lt; "Y::f()<strong>\n</strong>"; }</p>
<p>};</p>
<p>void call(X&amp; a) {</p>
<p>a.f();</p>
<p>}</p>
<p>int main() {</p>
<p>X x;</p>
<p>Y y;</p>
<p>call(x); // outputs "X::f()"</p>
<p>call(y); // outputs "X::f()"</p>
<p>}</p>
<p>Section 38.4: Behaviour of virtual functions in constructors</p>
<p>and destructors</p>
<p>The behaviour of virtual functions in constructors and destructors is
often confusing when first encountered.</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>base() { f("base constructor"); }</p>
<p>~base() { f("base destructor"); }</p>
<p>virtual const char* v() { return "base::v()"; }</p>
<p>void f(const char* caller) {</p>
<p>cout &lt;&lt; "When called from " &lt;&lt; caller &lt;&lt; ", "
&lt;&lt; v() &lt;&lt; " gets called.<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>class derived : public base {</p>
<p>public:</p>
<p>derived() { f("derived constructor"); }</p>
<p>~derived() { f("derived destructor"); }</p>
<p>const char* v() override { return "derived::v()"; }</p>
<p>};</p>
<p>int main() {</p>
<p>derived d;</p>
<p>}</p>
<p>Output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 216</p>
<p><span id="When_called_from_base_constructo"
class="anchor"></span>When called from base constructor, base::v() gets
called.</p>
<p>When called from derived constructor, derived::v() gets called.</p>
<p>When called from derived destructor, derived::v() gets called.</p>
<p>When called from base destructor, base::v() gets called.</p>
<p>The reasoning behind this is that the derived class may define
additional members which are not yet initialized (in the constructor
case) or already destroyed (in the destructor case), and calling its
member functions would be</p>
<p>unsafe. Therefore during construction and destruction of C++ objects,
the <em>dynamic</em> type of *this is considered to be the constructor's
or destructor's class and not a more-derived class.</p>
<p>Example:</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class base {</p>
<p>public:</p>
<p>base()</p>
<p>{</p>
<p>std::cout &lt;&lt; "foo is " &lt;&lt; foo() &lt;&lt; std::endl;</p>
<p>}</p>
<p>virtual int foo() { return 42; }</p>
<p>};</p>
<p>class derived : public base {</p>
<p>unique_ptr ptr_;</p>
<p>public:</p>
<p>derived(int i) : ptr_(new int(i*i)) { }</p>
<p>// The following cannot be called before derived::derived due to how
C++ behaves, // if it was possible... Kaboom!</p>
<p>int foo() override { return *ptr_; }</p>
<p>};</p>
<p>int main() {</p>
<p>derived d(4);</p>
<p>}</p>
<p>Section 38.5: Pure virtual functions</p>
<p>We can also specify that a virtual function is <em>pure virtual</em>
(abstract), by appending = 0 to the declaration. Classes with one or
more pure virtual functions are considered to be abstract, and cannot be
instantiated; only derived</p>
<p>classes which define, or inherit definitions for, all pure virtual
functions can be instantiated.</p>
<p>struct Abstract {</p>
<p>virtual void f() = 0;</p>
<p>};</p>
<p>struct Concrete {</p>
<p>void f() override {}</p>
<p>};</p>
<p>Abstract a; // Error.</p>
<p>Concrete c; // Good.</p>
<p>Even if a function is specified as pure virtual, it can be given a
default implementation. Despite this, the function will still be
considered abstract, and derived classes will have to define it before
they can be instantiated. In this case,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 217</p>
<p>the derived class' version of the function is even allowed to call
the base class' version.</p>
<p>struct DefaultAbstract {</p>
<p>virtual void f() = 0;</p>
<p>};</p>
<p>void DefaultAbstract::f() {}</p>
<p>struct WhyWouldWeDoThis : DefaultAbstract {</p>
<p>void f() override { DefaultAbstract::f(); }</p>
<p>};</p>
<p>There are a couple of reasons why we might want to do this:</p>
<p>If we want to create a class that can't itself be instantiated, but
doesn't prevent its derived classes from being</p>
<p>instantiated, we can declare the destructor as pure virtual. Being
the destructor, it must be defined anyways,</p>
<p>if we want to be able to deallocate the instance. And as the
destructor is most likely already virtual to prevent memory leaks during
polymorphic use, we won't incur an unnecessary performance hit from
declaring</p>
<p>another function virtual. This can be useful when making
interfaces.</p>
<p>struct Interface {</p>
<p>virtual ~Interface() = 0;</p>
<p>};</p>
<p>Interface::~Interface() = default;</p>
<p>struct Implementation : Interface {};</p>
<p>// ~Implementation() is automatically defined by the compiler if not
explicitly // specified, meeting the "must be defined before
instantiation" requirement.</p>
<p>If most or all implementations of the pure virtual function will
contain duplicate code, that code can instead</p>
<p>be moved to the base class version, making the code easier to
maintain.</p>
<p>class SharedBase {</p>
<p>State my_state;</p>
<p>std::unique_ptr my_helper;</p>
<p>// ...</p>
<p>public:</p>
<p>virtual void config(const Context&amp; cont) = 0;</p>
<p>// ...</p>
<p>};</p>
<p><em>/* virtual */</em> void SharedBase::config(const Context&amp;
cont) {</p>
<p>my_helper = new Helper(my_state, cont.relevant_field);</p>
<p>do_this();</p>
<p>and_that();</p>
<p>}</p>
<p>class OneImplementation : public SharedBase {</p>
<p>int i;</p>
<p>// ...</p>
<p>public:</p>
<p>void config(const Context&amp; cont) override;</p>
<p>// ...</p>
<p>};</p>
<p>void OneImplementation::config(const Context&amp; cont) <em>/*
override */</em> {</p>
<p>my_state = { cont.some_field, cont.another_field, i };</p>
<p>SharedBase::config(cont);</p>
<p>my_unique_setup();</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 218</p>
<p>// And so on, for other classes derived from SharedBase.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 219</p>
<p><span id="Chapter_39__Inline_functions_1"
class="anchor"></span>Chapter 39: Inline functions</p>
<p>A function defined with the inline specifier is an inline function.
An inline function can be multiply defined without</p>
<p>violating the One Definition Rule, and can therefore be defined in a
header with external linkage. Declaring a function inline hints to the
compiler that the function should be inlined during code generation, but
does not</p>
<p>provide a guarantee.</p>
<p>Section 39.1: Non-member inline function definition</p>
<p>inline int add(int x, int y)</p>
<p>{</p>
<p>return x + y;</p>
<p>}</p>
<p>Section 39.2: Member inline functions</p>
<p>// header (.hpp)</p>
<p>struct A</p>
<p>{</p>
<p>void i_am_inlined()</p>
<p>{</p>
<p>}</p>
<p>};</p>
<p>struct B</p>
<p>{</p>
<p>void i_am_NOT_inlined();</p>
<p>};</p>
<p>// source (.cpp)</p>
<p>void B::i_am_NOT_inlined()</p>
<p>{</p>
<p>}</p>
<p>Section 39.3: What is function inlining?</p>
<p>inline int add(int x, int y)</p>
<p>{</p>
<p>return x + y;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>int a = 1, b = 2;</p>
<p>int c = add(a, b);</p>
<p>}</p>
<p>In the above code, when add is inlined, the resulting code would
become something like this</p>
<p>int main()</p>
<p>{</p>
<p>int a = 1, b = 2;</p>
<p>int c = a + b;</p>
<p>}</p>
<p>The inline function is nowhere to be seen, its body gets
<em>inlined</em> into the caller's body. Had add not been inlined, a</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 220</p>
<p><span id="function_would_be_called__The_ov" class="anchor"></span><a
href="http://stackoverflow.com/q/10057443/183120">function would be
called. The overhead of calling a function -- such as creating a new
stack frame, copying</a> arguments, making local variables, jump (losing
locality of reference and there by cache misses), etc. -- has to be</p>
<p>incurred.</p>
<p>Section 39.4: Non-member inline function declaration</p>
<p>inline int add(int x, int y);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 221</p>
<p><span id="Chapter_40__Special_Member_Funct_1"
class="anchor"></span>Chapter 40: Special Member Functions</p>
<p>Section 40.1: Default Constructor</p>
<p>A <em>default constructor</em> is a type of constructor that requires
no parameters when called. It is named after the type it constructs and
is a member function of it (as all constructors are).</p>
<p>class C{</p>
<p>int i;</p>
<p>public:</p>
<p>// the default constructor definition</p>
<p>C()</p>
<p>: i(0){ // member initializer list -- initialize i to 0</p>
<p>// constructor function body -- can do more complex things here</p>
<p>}</p>
<p>};</p>
<p>C c1; // calls default constructor of C to create object c1 C c2 =
C(); // calls default constructor explicitly C c3(); // ERROR: this
intuitive version is not possible due to "most vexing parse" C c4{}; //
but in C++11 {} CAN be used in a similar way</p>
<p>C c5[2]; // calls default constructor for both array elements C* c6 =
new C[2]; // calls default constructor for both array elements</p>
<p>Another way to satisfy the "no parameters" requirement is for the
developer to provide default values for all parameters:</p>
<p>class D{</p>
<p>int i;</p>
<p>int j;</p>
<p>public:</p>
<p>// also a default constructor (can be called with no parameters)</p>
<p>D( int i = 0, int j = 42 )</p>
<p>: i(i), j(j){</p>
<p>}</p>
<p>};</p>
<p>D d; // calls constructor of D with the provided default values for
the parameters</p>
<p>Under some circumstances (i.e., the developer provides no
constructors and there are no other disqualifying</p>
<p>conditions), the compiler implicitly provides an empty default
constructor:</p>
<p>class C{</p>
<p>std::string s; // note: members need to be default constructible
themselves };</p>
<p>C c1; // will succeed -- C has an implicitly defined default
constructor</p>
<p>Having some other type of constructor is one of the disqualifying
conditions mentioned earlier:</p>
<p>class C{</p>
<p>int i;</p>
<p>public:</p>
<p>C( int i ) : i(i){}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 222</p>
<p>C c1; // Compile ERROR: C has no (implicitly defined) default
constructor</p>
<p>Version &lt; c++11</p>
<p>To prevent implicit default constructor creation, a common technique
is to declare it as private (with no definition). The intention is to
cause a compile error when someone tries to use the constructor (this
either results in an <em>Access</em></p>
<p><em>to private</em> error or a linker error, depending on the
compiler).</p>
<p>To be sure a default constructor (functionally similar to the
implicit one) is defined, a developer could write an</p>
<p>empty one explicitly.</p>
<p>Version ≥ c++11</p>
<p>In C++11, a developer can also use the delete keyword to prevent the
compiler from providing a default constructor.</p>
<p>class C{</p>
<p>int i;</p>
<p>public:</p>
<p>// default constructor is explicitly deleted</p>
<p>C() = delete;</p>
<p>};</p>
<p>C c1; // Compile ERROR: C has its default constructor deleted</p>
<p>Furthermore, a developer may also be explicit about wanting the
compiler to provide a default constructor.</p>
<p>class C{</p>
<p>int i;</p>
<p>public:</p>
<p>// does have automatically generated default constructor (same as
implicit one)</p>
<p>C() = default;</p>
<p>C( int i ) : i(i){}</p>
<p>};</p>
<p>C c1; // default constructed</p>
<p>C c2( 1 ); // constructed with the int taking constructor</p>
<p>Version ≥ c++14</p>
<p>You can determine whether a type has a default constructor (or is a
primitive type) using</p>
<p>std::is_default_constructible from
<strong>&lt;type_traits&gt;</strong>:</p>
<p>class C1{ };</p>
<p>class C2{ public: C2(){} };</p>
<p>class C3{ public: C3(int){} };</p>
<p>using std::cout; using std::boolalpha; using std::endl; using
std::is_default_constructible;</p>
<p>cout &lt;&lt; boolalpha &lt;&lt; is_default_constructible() &lt;&lt;
endl; // prints true cout &lt;&lt; boolalpha &lt;&lt;
is_default_constructible() &lt;&lt; endl; // prints true cout &lt;&lt;
boolalpha &lt;&lt; is_default_constructible() &lt;&lt; endl; // prints
true cout &lt;&lt; boolalpha &lt;&lt; is_default_constructible()
&lt;&lt; endl; // prints false</p>
<p>Version = c++11</p>
<p>In C++11, it is still possible to use the non-functor version of
std::is_default_constructible:</p>
<p>cout &lt;&lt; boolalpha &lt;&lt; is_default_constructible::value
&lt;&lt; endl; // prints true</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 223</p>
<p><span id="Section_40_2__Destructor" class="anchor"></span>Section
40.2: Destructor</p>
<p>A <em>destructor</em> is a function without arguments that is called
when a user-defined object is about to be destroyed. It is</p>
<p>named after the type it destructs with a ~ prefix.</p>
<p>class C{</p>
<p>int* is;</p>
<p>string s;</p>
<p>public:</p>
<p>C()</p>
<p>: is( new int[10] ){</p>
<p>}</p>
<p>~C(){ // destructor definition</p>
<p>delete[] is;</p>
<p>}</p>
<p>};</p>
<p>class C_child : public C{</p>
<p>string s_ch;</p>
<p>public:</p>
<p>C_child(){}</p>
<p>~C_child(){} // child destructor</p>
<p>};</p>
<p>void f(){</p>
<p>C c1; // calls default constructor</p>
<p>C c2[2]; // calls default constructor for both elements</p>
<p>C* c3 = new C[2]; // calls default constructor for both array
elements</p>
<p>C_child c_ch; // when destructed calls destructor of s_ch and of C
base (and in turn s)</p>
<p>delete[] c3; // calls destructors on c3[0] and c3[1]</p>
<p>} // automatic variables are destroyed here -- i.e. c1, c2 and
c_ch</p>
<p>Under most circumstances (i.e., a user provides no destructor, and
there are no other disqualifying conditions), the</p>
<p>compiler provides a default destructor implicitly:</p>
<p>class C{</p>
<p>int i;</p>
<p>string s;</p>
<p>};</p>
<p>void f(){</p>
<p>C* c1 = new C;</p>
<p>delete c1; // C has a destructor</p>
<p>}</p>
<p>class C{</p>
<p>int m;</p>
<p>private:</p>
<p>~C(){} // not public destructor!</p>
<p>};</p>
<p>class C_container{</p>
<p>C c;</p>
<p>};</p>
<p>void f(){</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 224</p>
<p><span id="C_container__c_cont___new_C_cont"
class="anchor"></span>C_container* c_cont = new C_container;</p>
<p>delete c_cont; // Compile ERROR: C has no accessible destructor</p>
<p>}</p>
<p>Version &gt; c++11</p>
<p>In C++11, a developer can override this behavior by preventing the
compiler from providing a default destructor.</p>
<p>class C{</p>
<p>int m;</p>
<p>public:</p>
<p>~C() = delete; // does NOT have implicit destructor };</p>
<p>void f{</p>
<p>C c1;</p>
<p>} // Compile ERROR: C has no destructor</p>
<p>Furthermore, a developer may also be explicit about wanting the
compiler to provide a default destructor.</p>
<p>class C{</p>
<p>int m;</p>
<p>public:</p>
<p>~C() = default; // saying explicitly it does have implicit/empty
destructor };</p>
<p>void f(){</p>
<p>C c1;</p>
<p>} // C has a destructor -- c1 properly destroyed</p>
<p>Version &gt; c++11</p>
<p>You can determine whether a type has a destructor (or is a primitive
type) using std::is_destructible from
<strong>&lt;type_traits&gt;</strong>:</p>
<p>class C1{ };</p>
<p>class C2{ public: ~C2() = delete };</p>
<p>class C3 : public C2{ };</p>
<p>using std::cout; using std::boolalpha; using std::endl; using
std::is_destructible;</p>
<p>cout &lt;&lt; boolalpha &lt;&lt; is_destructible() &lt;&lt; endl; //
prints true cout &lt;&lt; boolalpha &lt;&lt; is_destructible() &lt;&lt;
endl; // prints true cout &lt;&lt; boolalpha &lt;&lt; is_destructible()
&lt;&lt; endl; // prints false cout &lt;&lt; boolalpha &lt;&lt;
is_destructible() &lt;&lt; endl; // prints false</p>
<p>Section 40.3: Copy and swap</p>
<p>If you're writing a class that manages resources, you need to
implement all the special member functions (see Rule</p>
<p>of Three/Five/Zero). The most direct approach to writing the copy
constructor and assignment operator would be:</p>
<p>person(const person &amp;other)</p>
<p>: name(new char[std::strlen(other.name) + 1])</p>
<p>, age(other.age)</p>
<p>{</p>
<p>std::strcpy(name, other.name);</p>
<p>}</p>
<p>person&amp; operator=(person const&amp; rhs) {</p>
<p>if (this != &amp;other) {</p>
<p>delete [] name;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 225</p>
<p>name = new char[std::strlen(other.name) + 1];</p>
<p>std::strcpy(name, other.name);</p>
<p>age = other.age;</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p>But this approach has some problems. It fails the strong exception
guarantee - if new[] throws, we've already cleared the resources owned
by this and cannot recover. We're duplicating a lot of the logic of copy
construction in</p>
<p>copy assignment. And we have to remember the self-assignment check,
which usually just adds overhead to the copy operation, but is still
critical.</p>
<p>To satisfy the strong exception guarantee and avoid code duplication
(double so with the subsequent move assignment operator), we can use the
copy-and-swap idiom:</p>
<p>class person {</p>
<p>char* name;</p>
<p>int age;</p>
<p>public:</p>
<p>/* all the other functions ... */</p>
<p>friend void swap(person&amp; lhs, person&amp; rhs) {</p>
<p>using std::swap; // enable ADL</p>
<p>swap(lhs.name, rhs.name);</p>
<p>swap(lhs.age, rhs.age);</p>
<p>}</p>
<p>person&amp; operator=(person rhs) {</p>
<p>swap(*this, rhs);</p>
<p>return *this;</p>
<p>}</p>
<p>};</p>
<p>Why does this work? Consider what happens when we have</p>
<p>person p1 = ...;</p>
<p>person p2 = ...;</p>
<p>p1 = p2;</p>
<p>First, we copy-construct rhs from p2 (which we didn't have to
duplicate here). If that operation throws, we don't do anything in
operator= and p1 remains untouched. Next, we swap the members between
*this and rhs, and then</p>
<p>rhs goes out of scope. When operator=, that implicitly cleans the
original resources of this (via the destructor, which we didn't have to
duplicate). Self-assignment works too - it's less efficient with
copy-and-swap (involves an</p>
<p>extra allocation and deallocation), but if that's the unlikely
scenario, we don't slow down the typical use case to</p>
<p>account for it.</p>
<p>Version ≥ C++11</p>
<p>The above formulation works as-is already for move assignment.</p>
<p>p1 = std::move(p2);</p>
<p>Here, we move-construct rhs from p2, and all the rest is just as
valid. If a class is movable but not copyable, there is no need to
delete the copy-assignment, since this assignment operator will simply
be ill-formed due to the deleted</p>
<p>copy constructor.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 226</p>
<p><span id="Section_40_4__Implicit_Move_and"
class="anchor"></span>Section 40.4: Implicit Move and Copy</p>
<p>Bear in mind that declaring a destructor inhibits the compiler from
generating implicit move constructors and move</p>
<p>assignment operators. If you declare a destructor, remember to also
add appropriate definitions for the move</p>
<p>operations.</p>
<p>Furthermore, declaring move operations will suppress the generation
of copy operations, so these should also be added (if the objects of
this class are required to have copy semantics).</p>
<p>class Movable {</p>
<p>public:</p>
<p>virtual ~Movable() noexcept = default;</p>
<p>// compiler won't generate these unless we tell it to // because we
declared a destructor</p>
<p>Movable(Movable&amp;&amp;) noexcept = default;</p>
<p>Movable&amp; operator=(Movable&amp;&amp;) noexcept = default;</p>
<p>// declaring move operations will suppress generation // of copy
operations unless we explicitly re-enable them</p>
<p>Movable(const Movable&amp;) = default;</p>
<p>Movable&amp; operator=(const Movable&amp;) = default;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 227</p>
<p><span id="Chapter_41__Non_Static_Member_Fu_1"
class="anchor"></span>Chapter 41: Non-Static Member Functions</p>
<p>Section 41.1: Non-static Member Functions</p>
<p>A class or struct can have member functions as well as member
variables. These functions have syntax mostly similar to standalone
functions, and can be defined either inside or outside the class
definition; if defined outside</p>
<p>the class definition, the function's name is prefixed with the class'
name and the scope (::) operator.</p>
<p>class CL {</p>
<p>public:</p>
<p>void definedInside() {}</p>
<p>void definedOutside();</p>
<p>};</p>
<p>void CL::definedOutside() {}</p>
<p>These functions are called on an instance (or reference to an
instance) of the class with the dot (.) operator, or a</p>
<p>pointer to an instance with the arrow (-&gt;) operator, and each call
is tied to the instance the function was called on; when a member
function is called on an instance, it has access to all of that
instance's fields (through the this</p>
<p>pointer), but can only access other instances' fields if those
instances are supplied as parameters.</p>
<p>struct ST {</p>
<p>ST(const std::string&amp; ss = "Wolf", int ii = 359) : s(ss), i(ii) {
}</p>
<p>int get_i() const { return i; }</p>
<p>bool compare_i(const ST&amp; other) const { return (i == other.i);
}</p>
<p>private:</p>
<p>std::string s;</p>
<p>int i;</p>
<p>};</p>
<p>ST st1;</p>
<p>ST st2("Species", 8472);</p>
<p>int i = st1.get_i(); // Can access st1.i, but not st2.i. bool b =
st1.compare_i(st2); // Can access st1 &amp; st2.</p>
<p>These functions are allowed to access member variables and/or other
member functions, regardless of either the</p>
<p>variable or function's access modifiers. They can also be written
out-of-order, accessing member variables and/or calling member functions
declared before them, as the entire class definition must be parsed
before the compiler</p>
<p>can begin to compile a class.</p>
<p>class Access {</p>
<p>public:</p>
<p>Access(int i_ = 8088, int j_ = 8086, int k_ = 6502) : i(i_), j(j_),
k(k_) {}</p>
<p>int i;</p>
<p>int get_k() const { return k; }</p>
<p>bool private_no_more() const { return i_be_private(); }</p>
<p>protected:</p>
<p>int j;</p>
<p>int get_i() const { return i; }</p>
<p>private:</p>
<p>int k;</p>
<p>int get_j() const { return j; }</p>
<p>bool i_be_private() const { return ((i &gt; j) &amp;&amp; (k &lt;
j)); }</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 228</p>
<p><span id="Section_41_2__Encapsulation" class="anchor"></span>Section
41.2: Encapsulation</p>
<p>A common use of member functions is for encapsulation, using an
<em>accessor</em> (commonly known as a getter) and a</p>
<p><em>mutator</em> (commonly known as a setter) instead of accessing
fields directly.</p>
<p>class Encapsulator {</p>
<p>int encapsulated;</p>
<p>public:</p>
<p>int get_encapsulated() const { return encapsulated; } void
set_encapsulated(int e) { encapsulated = e; }</p>
<p>void some_func() {</p>
<p>do_something_with(encapsulated);</p>
<p>}</p>
<p>};</p>
<p>Inside the class, encapsulated can be freely accessed by any
non-static member function; outside the class, access to it is regulated
by member functions, using get_encapsulated() to read it and
set_encapsulated() to modify it.</p>
<p>This prevents unintentional modifications to the variable, as
separate functions are used to read and write it. [There are many
discussions on whether getters and setters provide or break
encapsulation, with good arguments for</p>
<p>both claims; such heated debate is outside the scope of this
example.]</p>
<p>Section 41.3: Name Hiding &amp; Importing</p>
<p>When a base class provides a set of overloaded functions, and a
derived class adds another overload to the set, this</p>
<p>hides all of the overloads provided by the base class.</p>
<p>struct HiddenBase {</p>
<p>void f(int) { std::cout &lt;&lt; "int" &lt;&lt; std::endl; }</p>
<p>void f(bool) { std::cout &lt;&lt; "bool" &lt;&lt; std::endl; }</p>
<p>void f(std::string) { std::cout &lt;&lt; "std::string" &lt;&lt;
std::endl; }</p>
<p>};</p>
<p>struct HidingDerived : HiddenBase {</p>
<p>void f(float) { std::cout &lt;&lt; "float" &lt;&lt; std::endl; }</p>
<p>};</p>
<p>// ...</p>
<p>HiddenBase hb;</p>
<p>HidingDerived hd;</p>
<p>std::string s;</p>
<p>hb.f(1); // Output: int</p>
<p>hb.f(true); // Output: bool</p>
<p>hb.f(s); // Output: std::string;</p>
<p>hd.f(1.f); // Output: float</p>
<p>hd.f(3); // Output: float</p>
<p>hd.f(true); // Output: float</p>
<p>hd.f(s); // Error: Can't convert from std::string to float.</p>
<p>This is due to name resolution rules: During name lookup, once the
correct name is found, we stop looking, even if</p>
<p>we clearly haven't found the correct <em>version</em> of the entity
with that name (such as with hd.f(s)); due to this, overloading the
function in the derived class prevents name lookup from discovering the
overloads in the base</p>
<p>class. To avoid this, a using-declaration can be used to "import"
names from the base class into the derived class, so</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 229</p>
<p>that they will be available during name lookup.</p>
<p>struct HidingDerived : HiddenBase {</p>
<p>// All members named HiddenBase::f shall be considered members of
HidingDerived for lookup.</p>
<p>using HiddenBase::f;</p>
<p>void f(float) { std::cout &lt;&lt; "float" &lt;&lt; std::endl; }</p>
<p>};</p>
<p>// ...</p>
<p>HidingDerived hd;</p>
<p>hd.f(1.f); // Output: float</p>
<p>hd.f(3); // Output: int</p>
<p>hd.f(true); // Output: bool</p>
<p>hd.f(s); // Output: std::string</p>
<p>If a derived class imports names with a using-declaration, but also
declares functions with the same signature as</p>
<p>functions in the base class, the base class functions will silently
be overridden or hidden.</p>
<p>struct NamesHidden {</p>
<p>virtual void hide_me() {}</p>
<p>virtual void hide_me(float) {}</p>
<p>void hide_me(int) {}</p>
<p>void hide_me(bool) {}</p>
<p>};</p>
<p>struct NameHider : NamesHidden {</p>
<p>using NamesHidden::hide_me;</p>
<p>void hide_me() {} // Overrides NamesHidden::hide_me(). void
hide_me(int) {} // Hides NamesHidden::hide_me(int).</p>
<p>};</p>
<p>A using-declaration can also be used to change access modifiers,
provided the imported entity was public or</p>
<p>protected in the base class.</p>
<p>struct ProMem {</p>
<p>protected:</p>
<p>void func() {}</p>
<p>};</p>
<p>struct BecomesPub : ProMem {</p>
<p>using ProMem::func;</p>
<p>};</p>
<p>// ...</p>
<p>ProMem pm;</p>
<p>BecomesPub bp;</p>
<p>pm.func(); // Error: protected.</p>
<p>bp.func(); // Good.</p>
<p>Similarly, if we explicitly want to call a member function from a
specific class in the inheritance hierarchy, we can qualify the function
name when calling the function, specifying that class by name.</p>
<p>struct One {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 230</p>
<p><span id="virtual_void_f_____std__cout" class="anchor"></span>virtual
void f() { std::cout &lt;&lt; "One." &lt;&lt; std::endl; }</p>
<p>};</p>
<p>struct Two : One {</p>
<p>void f() override {</p>
<p>One::f(); // this-&gt;One::f();</p>
<p>std::cout &lt;&lt; "Two." &lt;&lt; std::endl;</p>
<p>}</p>
<p>};</p>
<p>struct Three : Two {</p>
<p>void f() override {</p>
<p>Two::f(); // this-&gt;Two::f();</p>
<p>std::cout &lt;&lt; "Three." &lt;&lt; std::endl;</p>
<p>}</p>
<p>};</p>
<p>// ...</p>
<p>Three t;</p>
<p>t.f(); // Normal syntax.</p>
<p>t.Two::f(); // Calls version of f() defined in Two. t.One::f(); //
Calls version of f() defined in One.</p>
<p>Section 41.4: Virtual Member Functions</p>
<p>Member functions can also be declared virtual. In this case, if
called on a pointer or reference to an instance, they will not be
accessed directly; rather, they will look up the function in the virtual
function table (a list of pointers-to-</p>
<p>member-functions for virtual functions, more commonly known as the
vtable or vftable), and use that to call the version appropriate for the
instance's dynamic (actual) type. If the function is called directly,
from a variable of a</p>
<p>class, no lookup is performed.</p>
<p>struct Base {</p>
<p>virtual void func() { std::cout &lt;&lt; "In Base." &lt;&lt;
std::endl; }</p>
<p>};</p>
<p>struct Derived : Base {</p>
<p>void func() override { std::cout &lt;&lt; "In Derived." &lt;&lt;
std::endl; }</p>
<p>};</p>
<p>void slicer(Base x) { x.func(); }</p>
<p>// ...</p>
<p>Base b;</p>
<p>Derived d;</p>
<p>Base *pb = &amp;b, *pd = &amp;d; // Pointers.</p>
<p>Base &amp;rb = b, &amp;rd = d; // References.</p>
<p>b.func(); // Output: In Base.</p>
<p>d.func(); // Output: In Derived.</p>
<p>pb-&gt;func(); // Output: In Base.</p>
<p>pd-&gt;func(); // Output: In Derived.</p>
<p>rb.func(); // Output: In Base.</p>
<p>rd.func(); // Output: In Derived.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 231</p>
<p>slicer(b); // Output: In Base.</p>
<p>slicer(d); // Output: In Base.</p>
<p>Note that while pd is Base*, and rd is a Base&amp;, calling func() on
either of the two calls Derived::func() instead of</p>
<p>Base::func(); this is because the vtable for Derived updates the
Base::func() entry to instead point to Derived::func(). Conversely, note
how passing an instance to slicer() always results in Base::func()
being</p>
<p>called, even when the passed instance is a Derived; this is because
of something known as <em>data slicing</em>, where passing a Derived
instance into a Base parameter by value renders the portion of the
Derived instance that isn't a</p>
<p>Base instance inaccessible.</p>
<p>When a member function is defined as virtual, all derived class
member functions with the same signature override</p>
<p>it, regardless of whether the overriding function is specified as
virtual or not. This can make derived classes</p>
<p>harder for programmers to parse, however, as there's no indication as
to which function(s) is/are virtual.</p>
<p>struct B {</p>
<p>virtual void f() {}</p>
<p>};</p>
<p>struct D : B {</p>
<p>void f() {} // Implicitly virtual, overrides B::f.</p>
<p>// You'd have to check B to know that, though.</p>
<p>};</p>
<p>Note, however, that a derived function only overrides a base function
if their signatures match; even if a derived function is explicitly
declared virtual, it will instead create a new virtual function if the
signatures are mismatched.</p>
<p>struct BadB {</p>
<p>virtual void f() {}</p>
<p>};</p>
<p>struct BadD : BadB {</p>
<p>virtual void f(int i) {} // Does NOT override BadB::f.</p>
<p>};</p>
<p>Version ≥ C++11</p>
<p>As of C++11, intent to override can be made explicit with the
context-sensitive keyword override. This tells the compiler that the
programmer expects it to override a base class function, which causes
the compiler to omit an</p>
<p>error if it <em>doesn't</em> override anything.</p>
<p>struct CPP11B {</p>
<p>virtual void f() {}</p>
<p>};</p>
<p>struct CPP11D : CPP11B {</p>
<p>void f() override {}</p>
<p>void f(int i) override {} // Error: Doesn't actually override
anything.</p>
<p>};</p>
<p>This also has the benefit of telling programmers that the function is
both virtual, and also declared in at least one</p>
<p>base class, which can make complex classes easier to parse.</p>
<p>When a function is declared virtual, and defined outside the class
definition, the virtual specifier must be included in the function
declaration, and not repeated in the definition.</p>
<p>Version ≥ C++11</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 232</p>
<p><span id="This_also_holds_true_for_overrid"
class="anchor"></span>This also holds true for override.</p>
<p>struct VB {</p>
<p>virtual void f(); // "virtual" goes here.</p>
<p>void g();</p>
<p>};</p>
<p><em>/* virtual */</em> void VB::f() {} // Not here.</p>
<p>virtual void VB::g() {} // Error.</p>
<p>If a base class overloads a virtual function, only overloads that are
explicitly specified as virtual will be virtual.</p>
<p>struct BOverload {</p>
<p>virtual void func() {}</p>
<p>void func(int) {}</p>
<p>};</p>
<p>struct DOverload : BOverload {</p>
<p>void func() override {}</p>
<p>void func(int) {}</p>
<p>};</p>
<p>// ...</p>
<p>BOverload* bo = new DOverload;</p>
<p>bo-&gt;func(); // Calls DOverload::func().</p>
<p>bo-&gt;func(1); // Calls BOverload::func(int).</p>
<p>For more information, see the relevant topic.</p>
<p>Section 41.5: Const Correctness</p>
<p>One of the primary uses for this cv-qualifiers is <em>const
correctness</em>. This is the practice of guaranteeing that only
accesses that <em>need</em> to modify an object are <em>able</em> to
modify the object, and that any (member or non-member)</p>
<p>function that doesn't need to modify an object doesn't have write
access to that object (whether directly or</p>
<p>indirectly). This prevents unintentional modifications, making code
less errorprone. It also allows any function that doesn't need to modify
state to be able to take either a const or non-const object, without
needing to rewrite or</p>
<p>overload the function.</p>
<p>const correctness, due to its nature, starts at the bottom up: Any
class member function that doesn't need to</p>
<p>change state is declared as const, so that it can be called on const
instances. This, in turn, allows passed-by-reference parameters to be
declared const when they don't need to be modified, which allows
functions to take</p>
<p>either const or non-const objects without complaining, and const-ness
can propagate outwards in this manner. Due to this, getters are
frequently const, as are any other functions that don't need to modify
logical state.</p>
<p>class ConstIncorrect {</p>
<p>Field fld;</p>
<p>public:</p>
<p>ConstIncorrect(const Field&amp; f) : fld(f) {} // Modifies.</p>
<p>const Field&amp; get_field() { return fld; } // Doesn't modify;
should be const. void set_field(const Field&amp; f) { fld = f; } //
Modifies.</p>
<p>void do_something(int i) { // Modifies.</p>
<p>fld.insert_value(i);</p>
<p>}</p>
<p>void do_nothing() { } // Doesn't modify; should be const.</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 233</p>
<p>class ConstCorrect {</p>
<p>Field fld;</p>
<p>public:</p>
<p>ConstCorrect(const Field&amp; f) : fld(f) {} // Not const:
Modifies.</p>
<p>const Field&amp; get_field() const { return fld; } // const: Doesn't
modify. void set_field(const Field&amp; f) { fld = f; } // Not const:
Modifies.</p>
<p>void do_something(int i) { // Not const: Modifies.</p>
<p>fld.insert_value(i);</p>
<p>}</p>
<p>void do_nothing() const { } // const: Doesn't modify.</p>
<p>};</p>
<p>// ...</p>
<p>const ConstIncorrect i_cant_do_anything(make_me_a_field()); // Now,
let's read it...</p>
<p>Field f = i_cant_do_anything.get_field();</p>
<p>// Error: Loses cv-qualifiers, get_field() isn't const.</p>
<p>i_cant_do_anything.do_nothing();</p>
<p>// Error: Same as above.</p>
<p>// Oops.</p>
<p>const ConstCorrect but_i_can(make_me_a_field());</p>
<p>// Now, let's read it...</p>
<p>Field f = but_i_can.get_field(); // Good.</p>
<p>but_i_can.do_nothing(); // Good.</p>
<p>As illustrated by the comments on ConstIncorrect and ConstCorrect,
properly cv-qualifying functions also serves as documentation. If a
class is const correct, any function that isn't const can safely be
assumed to change state,</p>
<p>and any function that is const can safely be assumed not to change
state.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 234</p>
<p><span id="Chapter_42__Constant_class_membe_1"
class="anchor"></span>Chapter 42: Constant class member</p>
<p>functions</p>
<p>Section 42.1: constant member function</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class A {</p>
<p>public:</p>
<p>map * mapOfStrings;</p>
<p>public:</p>
<p>A() {</p>
<p>mapOfStrings = new map();</p>
<p>}</p>
<p>void insertEntry(string const &amp; key, string const &amp; value)
const {</p>
<p>(*mapOfStrings)[key] = value; // This works? Yes it does. delete
mapOfStrings; // This also works</p>
<p>mapOfStrings = new map(); // This * does * not work</p>
<p>}</p>
<p>void refresh() {</p>
<p>delete mapOfStrings;</p>
<p>mapOfStrings = new map(); // Works as refresh is non const
function</p>
<p>}</p>
<p>void getEntry(string const &amp; key) const {</p>
<p>cout &lt;&lt; mapOfStrings-&gt;at(key);</p>
<p>}</p>
<p>};</p>
<p>int main(int argc, char* argv[]) {</p>
<p>A var;</p>
<p>var.insertEntry("abc", "abcValue");</p>
<p>var.getEntry("abc");</p>
<p>getchar();</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 235</p>
<p><span id="Chapter_43__C___Containers_1" class="anchor"></span>Chapter
43: C++ Containers</p>
<p>C++ containers store a collection of elements. Containers include
vectors, lists, maps, etc. Using Templates, C++</p>
<p>containers contain collections of primitives (e.g. ints) or custom
classes (e.g. MyClass).</p>
<p>Section 43.1: C++ Containers Flowchart</p>
<p>Choosing which C++ Container to use can be tricky, so here's a simple
flowchart to help decide which Container is</p>
<p>right for the job.</p>
<p><img src="media/index-254_1.jpeg"
style="width:6.5in;height:3.61111in" alt="index-254_1.jpg" /></p>
<p>This flowchart was based on <a
href="https://stackoverflow.com/a/22671607">Mikael Persson's post. This
little graphic in the flowchart is from</a> <a
href="https://dribbble.com/shots/1673636-Pushpop">Megan Hopkins</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 236</p>
<p><span id="Chapter_44__Namespaces_1" class="anchor"></span>Chapter 44:
Namespaces</p>
<p>Used to prevent name collisions when using multiple libraries, a
namespace is a declarative prefix for functions,</p>
<p>classes, types, etc.</p>
<p>Section 44.1: What are namespaces?</p>
<p>A C++ namespace is a collection of C++ entities (functions, classes,
variables), whose names are prefixed by the</p>
<p>name of the namespace. When writing code within a namespace, named
entities belonging to that namespace need not be prefixed with the
namespace name, but entities outside of it must use the fully qualified
name. The</p>
<p>fully qualified name has the format
<strong>&lt;namespace&gt;</strong>::<strong>&lt;entity&gt;</strong>.
Example:</p>
<p>namespace Example</p>
<p>{</p>
<p>const int test = 5;</p>
<p>const int test2 = test + 12; //Works within `Example` namespace</p>
<p>}</p>
<p>const int test3 = test + 3; //Fails; `test` not found outside of
namespace.</p>
<p>const int test3 = Example::test + 3; //Works; fully qualified name
used.</p>
<p>Namespaces are useful for grouping related definitions together. Take
the analogy of a shopping mall. Generally a shopping mall is split up
into several stores, each store selling items from a specific category.
One store might sell</p>
<p>electronics, while another store might sell shoes. These logical
separations in store types help the shoppers find the items they're
looking for. Namespaces help c++ programmers, like shoppers, find the
functions, classes, and</p>
<p>variables they're looking for by organizing them in a logical manner.
Example:</p>
<p>namespace Electronics</p>
<p>{</p>
<p>int TotalStock;</p>
<p>class Headphones</p>
<p>{</p>
<p>// Description of a Headphone (color, brand, model number, etc.)</p>
<p>};</p>
<p>class Television</p>
<p>{</p>
<p>// Description of a Television (color, brand, model number, etc.)</p>
<p>};</p>
<p>}</p>
<p>namespace Shoes</p>
<p>{</p>
<p>int TotalStock;</p>
<p>class Sandal</p>
<p>{</p>
<p>// Description of a Sandal (color, brand, model number, etc.)</p>
<p>};</p>
<p>class Slipper</p>
<p>{</p>
<p>// Description of a Slipper (color, brand, model number, etc.)</p>
<p>};</p>
<p>}</p>
<p>There is a single namespace predefined, which is the global namespace
that has no name, but can be denoted by</p>
<p>::. Example:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 237</p>
<p><span id="void_bar" class="anchor"></span>void bar() {</p>
<p>// defined in global namespace</p>
<p>}</p>
<p>namespace foo {</p>
<p>void bar() {</p>
<p>// defined in namespace foo</p>
<p>}</p>
<p>void barbar() {</p>
<p>bar(); // calls foo::bar()</p>
<p>::bar(); // calls bar() defined in global namespace</p>
<p>}</p>
<p>}</p>
<p>Section 44.2: Argument Dependent Lookup</p>
<p>When calling a function without an explicit namespace qualifier, the
compiler can choose to call a function within a namespace if one of the
parameter types to that function is also in that namespace. This is
called "Argument</p>
<p>Dependent Lookup", or ADL:</p>
<p>namespace Test</p>
<p>{</p>
<p>int call(int i);</p>
<p>class SomeClass {...};</p>
<p>int call_too(const SomeClass &amp;data);</p>
<p>}</p>
<p>call(5); //Fails. Not a qualified function name.</p>
<p>Test::SomeClass data;</p>
<p>call_too(data); //Succeeds</p>
<p>call fails because none of its parameter types come from the Test
namespace. call_too works because SomeClass is a member of Test and
therefore it qualifies for ADL rules.</p>
<p>When does ADL not occur</p>
<p>ADL does not occur if normal unqualified lookup finds a class member,
a function that has been declared at block scope, or something that is
not of function type. For example:</p>
<p>void foo();</p>
<p>namespace N {</p>
<p>struct X {};</p>
<p>void foo(X ) { std::cout &lt;&lt; '1'; }</p>
<p>void qux(X ) { std::cout &lt;&lt; '2'; }</p>
<p>}</p>
<p>struct C {</p>
<p>void foo() {}</p>
<p>void bar() {</p>
<p>foo(N::X{}); // error: ADL is disabled and C::foo() takes no
arguments</p>
<p>}</p>
<p>};</p>
<p>void bar() {</p>
<p>extern void foo(); // redeclares ::foo</p>
<p>foo(N::X{}); // error: ADL is disabled and ::foo() doesn't take any
arguments</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 238</p>
<p><span id="_18" class="anchor"></span>}</p>
<p>int qux;</p>
<p>void baz() {</p>
<p>qux(N::X{}); // error: variable declaration disables ADL for "qux"
}</p>
<p>Section 44.3: Extending namespaces</p>
<p>A useful feature of namespaces is that you can expand them (add
members to it).</p>
<p>namespace Foo</p>
<p>{</p>
<p>void bar() {}</p>
<p>}</p>
<p>//some other stuff</p>
<p>namespace Foo</p>
<p>{</p>
<p>void bar2() {}</p>
<p>}</p>
<p>Section 44.4: Using directive</p>
<p>The keyword 'using' has three flavors. Combined with keyword
'namespace' you write a 'using directive':</p>
<p>If you don't want to write Foo:: in front of every stuff in the
namespace Foo, you can use using namespace Foo; to import every single
thing out of Foo.</p>
<p>namespace Foo</p>
<p>{</p>
<p>void bar() {}</p>
<p>void baz() {}</p>
<p>}</p>
<p>//Have to use Foo::bar()</p>
<p>Foo::bar();</p>
<p>//Import Foo</p>
<p>using namespace Foo;</p>
<p>bar(); //OK</p>
<p>baz(); //OK</p>
<p>It is also possible to import selected entities in a namespace rather
than the whole namespace:</p>
<p>using Foo::bar;</p>
<p>bar(); //OK, was specifically imported</p>
<p>baz(); // Not OK, was not imported</p>
<p>A word of caution: using namespaces in header files is seen as bad
style in most cases. If this is done, the</p>
<p>namespace is imported in <em>every</em> file that includes the
header. Since there is no way of "un-using" a namespace, this can lead
to namespace pollution (more or unexpected symbols in the global
namespace) or, worse, conflicts. See</p>
<p>this example for an illustration of the problem:</p>
<p>/***** foo.h *****/</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 239</p>
<p><span id="namespace_Foo" class="anchor"></span>namespace Foo</p>
<p>{</p>
<p>class C;</p>
<p>}</p>
<p>/***** bar.h *****/</p>
<p>namespace Bar</p>
<p>{</p>
<p>class C;</p>
<p>}</p>
<p>/***** baz.h *****/</p>
<p>#include "foo.h"</p>
<p>using namespace Foo;</p>
<p>/***** main.cpp *****/</p>
<p>#include "bar.h"</p>
<p>#include "baz.h"</p>
<p>using namespace Bar;</p>
<p>C c; // error: Ambiguity between Bar::C and Foo::C</p>
<p>A <em>using-directive</em> cannot occur at class scope.</p>
<p>Section 44.5: Making namespaces</p>
<p>Creating a namespace is really easy:</p>
<p>//Creates namespace foo</p>
<p>namespace Foo</p>
<p>{</p>
<p>//Declares function bar in namespace foo</p>
<p>void bar() {}</p>
<p>}</p>
<p>To call bar, you have to specify the namespace first, followed by the
scope resolution operator :::</p>
<p>Foo::bar();</p>
<p>It is allowed to create one namespace in another, for example:</p>
<p>namespace A</p>
<p>{</p>
<p>namespace B</p>
<p>{</p>
<p>namespace C</p>
<p>{</p>
<p>void bar() {}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>The above code could be simplified to the following:</p>
<p>namespace A::B::C</p>
<p>{</p>
<p>void bar() {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 240</p>
<p><span id="_19" class="anchor"></span>}</p>
<p>Section 44.6: Unnamed/anonymous namespaces</p>
<p>An unnamed namespace can be used to ensure names have internal
linkage (can only be referred to by the current translation unit). Such
a namespace is defined in the same way as any other namespace, but
without the name:</p>
<p>namespace {</p>
<p>int foo = 42;</p>
<p>}</p>
<p>foo is only visible in the translation unit in which it appears.</p>
<p>It is recommended to never use unnamed namespaces in header files as
this gives a version of the content for every translation unit it is
included in. This is especially important if you define non-const
globals.</p>
<p>// foo.h</p>
<p>namespace {</p>
<p>std::string globalString;</p>
<p>}</p>
<p>// 1.cpp</p>
<p>#include "foo.h" //&lt; Generates
unnamed_namespace{1.cpp}::globalString ...</p>
<p>globalString = "Initialize";</p>
<p>// 2.cpp</p>
<p>#include "foo.h" //&lt; Generates
unnamed_namespace{2.cpp}::globalString ...</p>
<p>std::cout &lt;&lt; globalString; //&lt; Will always print the empty
string</p>
<p>Section 44.7: Compact nested namespaces</p>
<p>Version ≥ C++17</p>
<p>namespace a {</p>
<p>namespace b {</p>
<p>template</p>
<p>struct qualifies : std::false_type {};</p>
<p>}</p>
<p>}</p>
<p>namespace other {</p>
<p>struct bob {};</p>
<p>}</p>
<p>namespace a::b {</p>
<p>template&lt;&gt;</p>
<p>struct qualifies&lt;::other::bob&gt; : std::true_type {};</p>
<p>}</p>
<p>You can enter both the a and b namespaces in one step with namespace
a::b starting in C++17.</p>
<p>Section 44.8: Namespace alias</p>
<p>A namespace can be given an alias (<em>i.e.,</em> another name for
the same namespace) using the namespace <em>identifier</em> =</p>
<p>syntax. Members of the aliased namespace can be accessed by
qualifying them with the name of the alias. In the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 241</p>
<p><span id="following_example__the_nested_na"
class="anchor"></span>following example, the nested namespace
AReallyLongName::AnotherReallyLongName is inconvenient to type, so the
function qux locally declares an alias N. Members of that namespace can
then be accessed simply using N::.</p>
<p>namespace AReallyLongName {</p>
<p>namespace AnotherReallyLongName {</p>
<p>int foo();</p>
<p>int bar();</p>
<p>void baz(int x, int y);</p>
<p>}</p>
<p>}</p>
<p>void qux() {</p>
<p>namespace N = AReallyLongName::AnotherReallyLongName;</p>
<p>N::baz(N::foo(), N::bar());</p>
<p>}</p>
<p>Section 44.9: Inline namespace</p>
<p>Version ≥ C++11</p>
<p>inline namespace includes the content of the inlined namespace in the
enclosing namespace, so</p>
<p>namespace Outer</p>
<p>{</p>
<p>inline namespace Inner</p>
<p>{</p>
<p>void foo();</p>
<p>}</p>
<p>}</p>
<p>is mostly equivalent to</p>
<p>namespace Outer</p>
<p>{</p>
<p>namespace Inner</p>
<p>{</p>
<p>void foo();</p>
<p>}</p>
<p>using Inner::foo;</p>
<p>}</p>
<p>but element from Outer::Inner:: and those associated into Outer:: are
identical.</p>
<p>So following is equivalent</p>
<p>Outer::foo();</p>
<p>Outer::Inner::foo();</p>
<p>The alternative using namespace Inner; would not be equivalent for
some tricky parts as template specialization:</p>
<p>For</p>
<p>#include // See below</p>
<p>class MyCustomType;</p>
<p>namespace Outer</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 242</p>
<p>template &lt;&gt;</p>
<p>void foo() { std::cout &lt;&lt; "Specialization"; }</p>
<p>}</p>
<p>The inline namespace allows the specialization of Outer::foo</p>
<p>// outer.h</p>
<p>// include guard omitted for simplification</p>
<p>namespace Outer</p>
<p>{</p>
<p>inline namespace Inner</p>
<p>{</p>
<p>template</p>
<p>void foo() { std::cout &lt;&lt; "Generic"; }</p>
<p>}</p>
<p>}</p>
<p>Whereas the using namespace doesn't allow the specialization of
Outer::foo</p>
<p>// outer.h</p>
<p>// include guard omitted for simplification</p>
<p>namespace Outer</p>
<p>{</p>
<p>namespace Inner</p>
<p>{</p>
<p>template</p>
<p>void foo() { std::cout &lt;&lt; "Generic"; }</p>
<p>}</p>
<p>using namespace Inner;</p>
<p>// Specialization of `Outer::foo` is not possible</p>
<p>// it should be `Outer::Inner::foo`.</p>
<p>}</p>
<p>Inline namespace is a way to allow several version to cohabit and
defaulting to the inline one</p>
<p>namespace MyNamespace</p>
<p>{</p>
<p>// Inline the last version</p>
<p>inline namespace Version2</p>
<p>{</p>
<p>void foo(); // New version</p>
<p>void bar();</p>
<p>}</p>
<p>namespace Version1 // The old one</p>
<p>{</p>
<p>void foo();</p>
<p>}</p>
<p>}</p>
<p>And with usage</p>
<p>MyNamespace::Version1::foo(); // old version</p>
<p>MyNamespace::Version2::foo(); // new version</p>
<p>MyNamespace::foo(); // default version :
MyNamespace::Version1::foo();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 243</p>
<p><span id="Section_44_10__Aliasing_a_long_n"
class="anchor"></span>Section 44.10: Aliasing a long namespace</p>
<p>This is usually used for renaming or shortening long namespace
references such referring to components of a</p>
<p>library.</p>
<p>namespace boost</p>
<p>{</p>
<p>namespace multiprecision</p>
<p>{</p>
<p>class Number ...</p>
<p>}</p>
<p>}</p>
<p>namespace Name1 = boost::multiprecision;</p>
<p>// Both Type declarations are equivalent</p>
<p>boost::multiprecision::Number X // Writing the full namespace path,
longer Name1::Number Y // using the name alias, shorter</p>
<p>Section 44.11: Alias Declaration scope</p>
<p>Alias Declaration are affected by preceding <em>using</em>
statements</p>
<p>namespace boost</p>
<p>{</p>
<p>namespace multiprecision</p>
<p>{</p>
<p>class Number ...</p>
<p>}</p>
<p>}</p>
<p>using namespace boost;</p>
<p>// Both Namespace are equivalent</p>
<p>namespace Name1 = boost::multiprecision;</p>
<p>namespace Name2 = multiprecision;</p>
<p>However, it is easier to get confused over which namespace you are
aliasing when you have something like this:</p>
<p>namespace boost</p>
<p>{</p>
<p>namespace multiprecision</p>
<p>{</p>
<p>class Number ...</p>
<p>}</p>
<p>}</p>
<p>namespace numeric</p>
<p>{</p>
<p>namespace multiprecision</p>
<p>{</p>
<p>class Number ...</p>
<p>}</p>
<p>}</p>
<p>using namespace numeric;</p>
<p>using namespace boost;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 244</p>
<p>// Not recommended as</p>
<p>// its not explicitly clear whether Name1 refers to //
numeric::multiprecision or boost::multiprecision namespace Name1 =
multiprecision;</p>
<p>// For clarity, its recommended to use absolute paths // instead</p>
<p>namespace Name2 = numeric::multiprecision;</p>
<p>namespace Name3 = boost::multiprecision;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 245</p>
<p><span id="Chapter_45__Header_Files_1" class="anchor"></span>Chapter
45: Header Files</p>
<p>Section 45.1: Basic Example</p>
<p>The following example will contain a block of code that is meant to
be split into several source files, as denoted by // filename
comments.</p>
<p>Source Files</p>
<p>// my_function.h</p>
<p>/* Note how this header contains only a declaration of a function. *
Header functions usually do not define implementations for declarations
* unless code must be further processed at compile time, as in
templates. */</p>
<p>/* Also, usually header files include preprocessor guards so that
every header * is never included twice.</p>
<p>*</p>
<p>* The guard is implemented by checking if a header-file unique
preprocessor * token is defined, and only including the header if it
hasn't been included * once before.</p>
<p>*/</p>
<p>#ifndef MY_FUNCTION_H</p>
<p>#define MY_FUNCTION_H</p>
<p>// global_value and my_function() will be</p>
<p>// recognized as the same constructs if this header is included by
different files. const int global_value = 42;</p>
<p>int my_function();</p>
<p>#endif // MY_FUNCTION_H</p>
<p>// my_function.cpp</p>
<p>/* Note how the corresponding source file for the header includes the
interface * defined in the header so that the compiler is aware of what
the source file is * implementing.</p>
<p>*</p>
<p>* In this case, the source file requires knowledge of the global
constant * global_value only defined in my_function.h. Without inclusion
of the header * file, this source file would not compile.</p>
<p>*/</p>
<p>#include "my_function.h" // or #include "my_function.hpp" int
my_function() {</p>
<p>return global_value; // return 42;</p>
<p>}</p>
<p>Header files are then included by other source files that want to use
the functionality defined by the header</p>
<p>interface, but don't require knowledge of its implementation (thus,
reducing code coupling). The following program makes use of the header
my_function.h as defined above:</p>
<p>// main.cpp</p>
<p>#include // A C++ Standard Library header. #include "my_function.h"
// A personal header</p>
<p>int main(int argc, char** argv) {</p>
<p>std::cout &lt;&lt; my_function() &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 246</p>
<p><span id="return_0" class="anchor"></span>return 0;</p>
<p>}</p>
<p>The Compilation Process</p>
<p>Since header files are often part of a compilation process workflow,
a typical compilation process making use of the</p>
<p>header/source file convention will usually do the following.</p>
<p>Assuming that the header file and source code file is already in the
same directory, a programmer would execute</p>
<p>the following commands:</p>
<p>g++-c my_function.cpp # Compiles the source file my_function.cpp</p>
<p># --&gt; object file my_function.o</p>
<p>g++ main.cpp my_function.o # Links the object file containing the</p>
<p># implementation of int my_function()</p>
<p># to the compiled, object version of main.cpp</p>
<p># and then produces the final executable a.out</p>
<p>Alternatively, if one wishes to compile main.cpp to an object file
first, and then link only object files together as the</p>
<p>final step:</p>
<p>g++-c my_function.cpp</p>
<p>g++-c main.cpp</p>
<p>g++ main.o my_function.o</p>
<p>Section 45.2: Templates in Header Files</p>
<p>Templates require compile-time generation of code: a templated
function, for example, will be effectively turned</p>
<p>into multiple distinct functions once a templated function is
parameterized by use in source code.</p>
<p>This means that template function, member function, and class
definitions cannot be delegated to a separate</p>
<p>source code file, as any code that will use any templated construct
requires knowledge of its definition to generally generate any
derivative code.</p>
<p>Thus, templated code, if put in headers, must also contain its
definition. An example of this is below:</p>
<p>// templated_function.h</p>
<p>template</p>
<p>T* null_T_pointer() {</p>
<p>T* type_point = NULL; // or, alternatively, nullptr instead of
NULL</p>
<p>// for C++11 or later</p>
<p>return type_point;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 247</p>
<p><span id="Chapter_46__Using_declaration_1"
class="anchor"></span>Chapter 46: Using declaration</p>
<p>A using declaration introduces a single name into the current scope
that was previously declared elsewhere.</p>
<p>Section 46.1: Importing names individually from a namespace</p>
<p>Once using is used to introduce the name cout from the namespace std
into the scope of the main function, the</p>
<p>std::cout object can be referred to as cout alone.</p>
<p>#include</p>
<p>int main() {</p>
<p>using std::cout;</p>
<p>cout &lt;&lt; "Hello, world!<strong>\n</strong>";</p>
<p>}</p>
<p>Section 46.2: Redeclaring members from a base class to</p>
<p>avoid name hiding</p>
<p>If a <em>using-declaration</em> occurs at class scope, it is only
allowed to redeclare a member of a base class. For example,</p>
<p>using std::cout is not allowed at class scope.</p>
<p>Often, the name redeclared is one that would otherwise be hidden. For
example, in the below code, d1.foo only</p>
<p>refers to Derived1::foo(const char*) and a compilation error will
occur. The function Base::foo(int) is hidden not considered at all.
However, d2.foo(42) is fine because the <em>using-declaration</em>
brings Base::foo(int) into the set</p>
<p>of entities named foo in Derived2. Name lookup then finds both foos
and overload resolution selects Base::foo.</p>
<p>struct Base {</p>
<p>void foo(int);</p>
<p>};</p>
<p>struct Derived1 : Base {</p>
<p>void foo(const char*);</p>
<p>};</p>
<p>struct Derived2 : Base {</p>
<p>using Base::foo;</p>
<p>void foo(const char*);</p>
<p>};</p>
<p>int main() {</p>
<p>Derived1 d1;</p>
<p>d1.foo(42); // error</p>
<p>Derived2 d2;</p>
<p>d2.foo(42); // OK</p>
<p>}</p>
<p>Section 46.3: Inheriting constructors</p>
<p>Version ≥ C++11</p>
<p>As a special case, a <em>using-declaration</em> at class scope can
refer to the constructors of a direct base class. Those</p>
<p>constructors are then <em>inherited</em> by the derived class and can
be used to initialize the derived class.</p>
<p>struct Base {</p>
<p>Base(int x, const char* s);</p>
<p>};</p>
<p>struct Derived1 : Base {</p>
<p>Derived1(int x, const char* s) : Base(x, s) {}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 248</p>
<p>struct Derived2 : Base {</p>
<p>using Base::Base;</p>
<p>};</p>
<p>int main() {</p>
<p>Derived1 d1(42, "Hello, world");</p>
<p>Derived2 d2(42, "Hello, world");</p>
<p>}</p>
<p>In the above code, both Derived1 and Derived2 have constructors that
forward the arguments directly to the corresponding constructor of Base.
Derived1 performs the forwarding explicitly, while Derived2, using the
C++11</p>
<p>feature of inheriting constructors, does so implicitly.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 249</p>
<p><span id="Chapter_47__std__string_1" class="anchor"></span>Chapter
47: std::string</p>
<p>Strings are objects that represent sequences of characters. The
standard string class provides a simple, safe and</p>
<p>versatile alternative to using explicit arrays of chars when dealing
with text and other sequences of characters. The C++ string class is
part of the std namespace and was standardized in 1998.</p>
<p>Section 47.1: Tokenize</p>
<p>Listed from least expensive to most expensive at run-time:</p>
<p>1. std::strtok is the cheapest standard provided tokenization method,
it also allows the delimiter to be</p>
<p>modified between tokens, but it incurs 3 difficulties with modern
C++:</p>
<p>std::strtok cannot be used on multiple strings at the same time
(though some implementations do</p>
<p><a
href="https://msdn.microsoft.com/en-us/library/ftsafwz3.aspx">extend to
support this, such as: strtok_s</a>)</p>
<p>For the same reason std::strtok cannot be used on multiple threads
simultaneously (this may</p>
<p>however be implementation defined, for example: <a
href="https://msdn.microsoft.com/en-us/library/2c8d19sb.aspx#Anchor_3">Visual
Studio's implementation is thread safe</a>)</p>
<p>Calling std::strtok modifies the std::string it is operating on, so
it cannot be used on const</p>
<p>string s, const char*s, or literal strings, to tokenize any of these
with std::strtok or to operate on a std::string who's contents need to
be preserved, the input would have to be copied, then the copy</p>
<p>could be operated on</p>
<p>Generally any of these options cost will be hidden in the allocation
cost of the tokens, but if the cheapest</p>
<p>algorithm is required and std::strtok's difficulties are not
overcomable consider a <a
href="http://stackoverflow.com/a/38595708/2642059">hand-spun
solution.</a></p>
<p>// String to tokenize</p>
<p>std::string str{ "The quick brown fox" };</p>
<p>// Vector to store tokens</p>
<p>vector tokens;</p>
<p>for (auto i = strtok(&amp;str[0], " "); i != NULL; i = strtok(NULL, "
"))</p>
<p>tokens.push_back(i);</p>
<p><a href="http://ideone.com/8kAGoa">Live Example</a></p>
<p>2. The std::istream_iterator uses the stream's extraction operator
iteratively. If the input std::string is</p>
<p>white-space delimited this is able to expand on the std::strtok
option by eliminating its difficulties, allowing</p>
<p>inline tokenization thereby supporting the generation of a const
vector, and by adding support for multiple delimiting white-space
character:</p>
<p>// String to tokenize</p>
<p>const std::string str("The quick <strong>\t</strong>brown
<strong>\n</strong>fox"); std::istringstream is(str);</p>
<p>// Vector to store tokens</p>
<p>const std::vector tokens = std::vector(</p>
<p>std::istream_iterator(is),</p>
<p>std::istream_iterator());</p>
<p><a href="http://ideone.com/gWmfV9">Live Example</a></p>
<p>3. The std::regex_token_iterator uses a std::regex to iteratively
tokenize. It provides for a more flexible</p>
<p>delimiter definition. For example, non-delimited commas and
white-space:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 250</p>
<p><span id="Version_____C__11_1" class="anchor"></span>Version ≥
C++11</p>
<p>// String to tokenize</p>
<p>const std::string str{ "The ,qu<strong>\\</strong>,ick
,<strong>\t</strong>brown, fox" }; const std::regex re{
"<strong>\\</strong>s*((?:[^<strong>\\\\</strong>,]|<strong>\\\\</strong>.)*?)<strong>\\</strong>s*(?:,|$)"
}; // Vector to store tokens</p>
<p>const std::vector tokens{</p>
<p>std::sregex_token_iterator(str.begin(), str.end(), re, 1),</p>
<p>std::sregex_token_iterator()</p>
<p>};</p>
<p><a href="http://ideone.com/q58zoX">Live Example</a></p>
<p>See the regex_token_iterator Example for more details.</p>
<p>Section 47.2: Conversion to (const) char*</p>
<p>In order to get const char* access to the data of a std::string you
can use the string's c_str() member function.</p>
<p>Keep in mind that the pointer is only valid as long as the
std::string object is within scope and remains unchanged, that means
that only const methods may be called on the object.</p>
<p>Version ≥ C++17</p>
<p>The data() member function can be used to obtain a modifiable char*,
which can be used to manipulate the std::string object's data.</p>
<p>Version ≥ C++11</p>
<p>A modifiable char* can also be obtained by taking the address of the
first character: &amp;s[0]. Within C++11, this is</p>
<p>guaranteed to yield a well-formed, null-terminated string. Note that
&amp;s[0] is well-formed even if s is empty, whereas &amp;s.front() is
undefined if s is empty.</p>
<p>Version ≥ C++11</p>
<p>std::string str("This is a string.");</p>
<p>const char* cstr = str.c_str(); // cstr points to: "This is a
string.\0" const char* data = str.data(); // data points to: "This is a
string.\0"</p>
<p>std::string str("This is a string.");</p>
<p>// Copy the contents of str to untie lifetime from the std::string
object std::unique_ptr cstr = std::make_unique(str.size() + 1);</p>
<p>// Alternative to the line above (no exception safety): // char*
cstr_unsafe = new char[str.size() + 1];</p>
<p>std::copy(str.data(), str.data() + str.size(), cstr);
cstr[str.size()] = '<strong>\0</strong>'; // A null-terminator needs to
be added</p>
<p>// delete[] cstr_unsafe;</p>
<p>std::cout &lt;&lt; cstr.get();</p>
<p>Section 47.3: Using the std::string_view class</p>
<p>Version ≥ C++17</p>
<p>C++17 introduces std::string_view, which is simply a non-owning range
of const chars, implementable as either</p>
<p>a pair of pointers or a pointer and a length. It is a superior
parameter type for functions that requires non-modifiable string data.
Before C++17, there were three options for this:</p>
<p>void foo(std::string const&amp; s); // pre-C++17, single argument,
could incur</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 251</p>
<p><span id="___allocation_if_caller_s_data_w" class="anchor"></span>//
allocation if caller's data was not in a string // (e.g. string literal
or vector )</p>
<p>void foo(const char* s, size_t len); // pre-C++17, two arguments,
have to pass them</p>
<p>// both everywhere</p>
<p>void foo(const char* s); // pre-C++17, single argument, but need to
call</p>
<p>// strlen()</p>
<p>template</p>
<p>void foo(StringT const&amp; s); // pre-C++17, caller can pass
arbitrary char data</p>
<p>// provider, but now foo() has to live in a header</p>
<p>All of these can be replaced with:</p>
<p>void foo(std::string_view s); // post-C++17, single argument, tighter
coupling</p>
<p>// zero copies regardless of how caller is storing // the data</p>
<p>Note that std::string_view <strong>cannot</strong> modify its
underlying data<em>.</em></p>
<p>string_view is useful when you want to avoid unnecessary copies.</p>
<p>It offers a useful subset of the functionality that std::string does,
although some of the functions behave</p>
<p>differently:</p>
<p>std::string str = "lllloooonnnngggg sssstttrrriiinnnggg"; //A really
long string</p>
<p>//Bad way - 'string::substr' returns a new string (expensive if the
string is long) std::cout &lt;&lt; str.substr(15, 10) &lt;&lt;
'<strong>\n</strong>';</p>
<p>//Good way - No copies are created!</p>
<p>std::string_view view = str;</p>
<p>// string_view::substr returns a new string_view</p>
<p>std::cout &lt;&lt; view.substr(15, 10) &lt;&lt;
'<strong>\n</strong>';</p>
<p>Section 47.4: Conversion to std::wstring</p>
<p>In C++, sequences of characters are represented by specializing the
std::basic_string class with a native character type. The two major
collections defined by the standard library are std::string and
std::wstring:</p>
<p>std::string is built with elements of type char</p>
<p>std::wstring is built with elements of type wchar_t</p>
<p>To convert between the two types, use wstring_convert:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>std::string input_str = "this is a -string-, which is a sequence
based on the -char- type."; std::wstring input_wstr = L"this is a -wide-
string, which is based on the -wchar_t- type.";</p>
<p>// conversion</p>
<p>std::wstring str_turned_to_wstr =</p>
<p>std::wstring_convert&gt;().from_bytes(input_str);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 252</p>
<p><span id="std__string_wstr_turned_to_str"
class="anchor"></span>std::string wstr_turned_to_str =</p>
<p>std::wstring_convert&gt;().to_bytes(input_wstr);</p>
<p>In order to improve usability and/or readability, you can define
functions to perform the conversion:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using convert_t = std::codecvt_utf8;</p>
<p>std::wstring_convert strconverter;</p>
<p>std::string to_string(std::wstring wstr)</p>
<p>{</p>
<p>return strconverter.to_bytes(wstr);</p>
<p>}</p>
<p>std::wstring to_wstring(std::string str)</p>
<p>{</p>
<p>return strconverter.from_bytes(str);</p>
<p>}</p>
<p>Sample usage:</p>
<p>std::wstring a_wide_string = to_wstring("Hello World!");</p>
<p>That's certainly more readable than
std::wstring_convert&gt;().from_bytes("Hello</p>
<p>World!").</p>
<p>Please note that char and wchar_t do not imply encoding, and gives no
indication of size in bytes. For instance, wchar_t is commonly
implemented as a 2-bytes data type and typically contains UTF-16 encoded
data under</p>
<p>Windows (or UCS-2 in versions prior to Windows 2000) and as a 4-bytes
data type encoded using UTF-32 under</p>
<p>Linux. This is in contrast with the newer types char16_t and
char32_t, which were introduced in C++11 and are guaranteed to be large
enough to hold any UTF16 or UTF32 "character" (or more precisely,
<em>code point</em>) respectively.</p>
<p>Section 47.5: Lexicographical comparison</p>
<p>Two std::strings can be compared lexicographically using the
operators ==, !=, &lt;, &lt;=, &gt;, and &gt;=:</p>
<p>std::string str1 = "Foo";</p>
<p>std::string str2 = "Bar";</p>
<p>assert(!(str1 &lt; str2));</p>
<p>assert(str &gt; str2);</p>
<p>assert(!(str1 &lt;= str2));</p>
<p>assert(str1 &gt;= str2);</p>
<p>assert(!(str1 == str2));</p>
<p>assert(str1 != str2);</p>
<p>All these functions use the underlying std::string::compare() method
to perform the comparison, and return for</p>
<p>convenience boolean values. The operation of these functions may be
interpreted as follows, regardless of the actual implementation:</p>
<p>operator==:</p>
<p>If str1.length() == str2.length() and each character pair matches,
then returns true, otherwise returns</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 253</p>
<p><span id="false" class="anchor"></span>false .</p>
<p>operator!=:</p>
<p>If str1.length() != str2.length() or one character pair doesn't
match, returns true, otherwise it returns</p>
<p>false .</p>
<p>operator&lt; or operator&gt;:</p>
<p>Finds the first different character pair, compares them then returns
the boolean result.</p>
<p>operator&lt;= or operator&gt;=:</p>
<p>Finds the first different character pair, compares them then returns
the boolean result.</p>
<p><em><strong>Note:</strong></em> The term <strong>character
pair</strong> means the corresponding characters in both strings of the
same positions. For</p>
<p>better understanding, if two example strings are str1 and str2, and
their lengths are n and m respectively, then character pairs of both
strings means each str1[i] and str2[i] pairs where <em>i = 0, 1, 2, ...,
max(n,m)</em>. If for any <em>i</em></p>
<p>where the corresponding character does not exist, that is, when
<em>i</em> is greater than or equal to n or m, it would be considered as
the lowest value.</p>
<p>Here is an example of using &lt;:</p>
<p>std::string str1 = "Barr";</p>
<p>std::string str2 = "Bar";</p>
<p>assert(str2 &lt; str1);</p>
<p>The steps are as follows:</p>
<p>1. Compare the first characters, 'B' == 'B' - move on.</p>
<p>2. Compare the second characters, 'a' == 'a' - move on.</p>
<p>3. Compare the third characters, 'r' == 'r' - move on.</p>
<p>4. The str2 range is now exhausted, while the str1 range still has
characters. Thus, str2 &lt; str1.</p>
<p>Section 47.6: Trimming characters at start/end</p>
<p>This example requires the headers <a
href="http://en.cppreference.com/w/cpp/header/algorithm"><strong>&lt;algorithm&gt;</strong>,</a>
<a
href="http://en.cppreference.com/w/cpp/header/locale"><strong>&lt;locale&gt;</strong></a><a
href="http://en.cppreference.com/w/cpp/header/utility">, and
<strong>&lt;utility&gt;</strong></a>.</p>
<p>Version ≥ C++11</p>
<p>To <em>trim</em> a sequence or string means to remove all leading and
trailing elements (or characters) matching a certain</p>
<p>predicate. We first trim the trailing elements, because it doesn't
involve moving any elements, and then trim the leading elements. Note
that the generalizations below work for all types of std::basic_string
(e.g. std::string</p>
<p>and std::wstring), and accidentally also for sequence containers
(e.g. std::vector and std::list).</p>
<p>template</p>
<p>typename Pred&gt; // a predicate on the element (character) type</p>
<p>Sequence&amp; trim(Sequence&amp; seq, Pred pred) {</p>
<p>return trim_start(trim_end(seq, pred), pred);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 254</p>
<p><span id="Trimming_the_trailing_elements_i"
class="anchor"></span>Trimming the trailing elements involves finding
the <em>last</em> element not matching the predicate, and erasing from
there on:</p>
<p>template</p>
<p>Sequence&amp; trim_end(Sequence&amp; seq, Pred pred) {</p>
<p>auto last = std::find_if_not(seq.rbegin(),</p>
<p>seq.rend(),</p>
<p>pred);</p>
<p>seq.erase(last.base(), seq.end());</p>
<p>return seq;</p>
<p>}</p>
<p>Trimming the leading elements involves finding the <em>first</em>
element not matching the predicate and erasing up to there:</p>
<p>template</p>
<p>Sequence&amp; trim_start(Sequence&amp; seq, Pred pred) {</p>
<p>auto first = std::find_if_not(seq.begin(),</p>
<p>seq.end(),</p>
<p>pred);</p>
<p>seq.erase(seq.begin(), first);</p>
<p>return seq;</p>
<p>}</p>
<p>To specialize the above for trimming whitespace in a std::string <a
href="http://en.cppreference.com/w/cpp/locale/isspace">we can use the
std::isspace() function as a</a></p>
<p>predicate:</p>
<p>std::string&amp; trim(std::string&amp; str, const std::locale&amp;
loc = std::locale()) {</p>
<p>return trim(str, [&amp;loc](const char c){ return std::isspace(c,
loc); });</p>
<p>}</p>
<p>std::string&amp; trim_start(std::string&amp; str, const
std::locale&amp; loc = std::locale()) {</p>
<p>return trim_start(str, [&amp;loc](const char c){ return
std::isspace(c, loc); });</p>
<p>}</p>
<p>std::string&amp; trim_end(std::string&amp; str, const
std::locale&amp; loc = std::locale()) {</p>
<p>return trim_end(str, [&amp;loc](const char c){ return std::isspace(c,
loc); });</p>
<p>}</p>
<p>Similarly, we can use the <a
href="http://en.cppreference.com/w/cpp/string/wide/iswspace">std::iswspace()</a>
function for std::wstring etc.</p>
<p>If you wish to create a <em>new</em> sequence that is a trimmed copy,
then you can use a separate function:</p>
<p>template</p>
<p>Sequence trim_copy(Sequence seq, Pred pred) { // NOTE: passing seq by
value</p>
<p>trim(seq, pred);</p>
<p>return seq;</p>
<p>}</p>
<p>Section 47.7: String replacement</p>
<p>Replace by position</p>
<p>To replace a portion of a std::string you can use the method replace
from std::string.</p>
<p>replace has a lot of useful overloads:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 255</p>
<p><span id="__Define_string" class="anchor"></span>//Define string</p>
<p>std::string str = "Hello foo, bar and world!";</p>
<p>std::string alternate = "Hello foobar";</p>
<p>//1)</p>
<p>str.replace(6, 3, "bar"); //"Hello bar, bar and world!"</p>
<p>//2)</p>
<p>str.replace(str.begin() + 6, str.end(), "nobody!"); //"Hello
nobody!"</p>
<p>//3)</p>
<p>str.replace(19, 5, alternate, 6, 6); //"Hello foo, bar and
foobar!"</p>
<p>Version ≥ C++14</p>
<p>//4)</p>
<p>str.replace(19, 5, alternate, 6); //"Hello foo, bar and foobar!"</p>
<p>//5)</p>
<p>str.replace(str.begin(), str.begin() + 5, str.begin() + 6,
str.begin() + 9); //"foo foo, bar and world!"</p>
<p>//6)</p>
<p>str.replace(0, 5, 3, 'z'); //"zzz foo, bar and world!"</p>
<p>//7)</p>
<p>str.replace(str.begin() + 6, str.begin() + 9, 3, 'x'); //"Hello xxx,
bar and world!"</p>
<p>Version ≥ C++11</p>
<p>//8)</p>
<p>str.replace(str.begin(), str.begin() + 5, { 'x', 'y', 'z' }); //"xyz
foo, bar and world!"</p>
<p>Replace occurrences of a string with another string</p>
<p>Replace only the first occurrence of replace with with in str:</p>
<p>std::string replaceString(std::string str,</p>
<p>const std::string&amp; replace,</p>
<p>const std::string&amp; with){</p>
<p>std::size_t pos = str.find(replace);</p>
<p>if (pos != std::string::npos)</p>
<p>str.replace(pos, replace.length(), with);</p>
<p>return str;</p>
<p>}</p>
<p>Replace all occurrence of replace with with in str:</p>
<p>std::string replaceStringAll(std::string str,</p>
<p>const std::string&amp; replace,</p>
<p>const std::string&amp; with) {</p>
<p>if(!replace.empty()) {</p>
<p>std::size_t pos = 0;</p>
<p>while ((pos = str.find(replace, pos)) != std::string::npos) {</p>
<p>str.replace(pos, replace.length(), with);</p>
<p>pos += with.length();</p>
<p>}</p>
<p>}</p>
<p>return str;</p>
<p>}</p>
<p>Section 47.8: Converting to std::string</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/basic_ostringstream">std::ostringstream</a>
can be used to convert any streamable type to a string representation,
by inserting the object</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 256</p>
<p><span id="into_a_std__ostringstream_object"
class="anchor"></span>into a std::ostringstream object (with the stream
insertion operator &lt;&lt;) and then converting the whole
std::ostringstream to a std::string.</p>
<p>For int for instance:</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>int val = 4;</p>
<p>std::ostringstream str;</p>
<p>str &lt;&lt; val;</p>
<p>std::string converted = str.str();</p>
<p>return 0;</p>
<p>}</p>
<p>Writing your own conversion function, the simple:</p>
<p>template</p>
<p>std::string toString(const T&amp; x)</p>
<p>{</p>
<p>std::ostringstream ss;</p>
<p>ss &lt;&lt; x;</p>
<p>return ss.str();</p>
<p>}</p>
<p>works but isn't suitable for performance critical code.</p>
<p>User-defined classes may implement the stream insertion operator if
desired:</p>
<p>std::ostream operator&lt;&lt;( std::ostream&amp; out, const A&amp; a
) {</p>
<p>// write a string representation of a to out</p>
<p>return out;</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>Aside from streams, since C++11 you can also use the <a
href="http://en.cppreference.com/w/cpp/string/basic_string/to_string">std::to_string</a>
<a
href="http://en.cppreference.com/w/cpp/string/basic_string/to_wstring">(and
std::to_wstring) function which is</a> overloaded for all fundamental
types and returns the string representation of its parameter.</p>
<p>std::string s = to_string(0x12f3); // after this the string s
contains "4851"</p>
<p>Section 47.9: Splitting</p>
<p>Use <a
href="http://en.cppreference.com/w/cpp/string/basic_string/substr">std::string::substr
to split a string. There are two variants of this member
function.</a></p>
<p>The first takes a <em>starting position</em> from which the returned
substring should begin. The starting position must be</p>
<p>valid in the range (0, str.length()]:</p>
<p>std::string str = "Hello foo, bar and world!";</p>
<p>std::string newstr = str.substr(11); // "bar and world!"</p>
<p>The second takes a starting position and a total <em>length</em> of
the new substring. Regardless of the <em>length</em>, the substring</p>
<p>will never go past the end of the source string:</p>
<p>std::string str = "Hello foo, bar and world!";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 257</p>
<p><span id="std__string_newstr___str_substr"
class="anchor"></span>std::string newstr = str.substr(15, 3); //
"and"</p>
<p><em><strong>Note that</strong></em> you can also call substr with no
arguments, in this case an exact copy of the string is returned</p>
<p>std::string str = "Hello foo, bar and world!";</p>
<p>std::string newstr = str.substr(); // "Hello foo, bar and world!"</p>
<p>Section 47.10: Accessing a character</p>
<p>There are several ways to extract characters from a std::string and
each is subtly different.</p>
<p>std::string str("Hello world!");</p>
<p>operator[](n)</p>
<p>Returns a reference to the character at index n.</p>
<p>std::string::operator[] is not bounds-checked and does not throw an
exception. The caller is responsible for</p>
<p>asserting that the index is within the range of the string:</p>
<p>char c = str[6]; // 'w'</p>
<p>at(n)</p>
<p>Returns a reference to the character at index n.</p>
<p>std::string::at <em>is</em> bounds checked, and will throw
std::out_of_range if the index is not within the range of the
string:</p>
<p>char c = str.at(7); // 'o'</p>
<p>Version ≥ C++11</p>
<p>Note: Both of these examples will result in undefined behavior if the
string is empty.</p>
<p>front()</p>
<p>Returns a reference to the first character:</p>
<p>char c = str.front(); // 'H'</p>
<p>back()</p>
<p>Returns a reference to the last character:</p>
<p>char c = str.back(); // '!'</p>
<p>Section 47.11: Checking if a string is a prefix of another</p>
<p>Version ≥ C++14</p>
<p>In C++14, this is easily done by <a
href="http://en.cppreference.com/w/cpp/algorithm/mismatch">std::mismatch</a>
which returns the first mismatching pair from two ranges:</p>
<p>std::string prefix = "foo";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 258</p>
<p><span id="std__string_string____foobar"
class="anchor"></span>std::string string = "foobar";</p>
<p>bool isPrefix = std::mismatch(prefix.begin(), prefix.end(),</p>
<p>string.begin(), string.end()).first == prefix.end();</p>
<p>Note that a range-and-a-half version of mismatch() existed prior to
C++14, but this is unsafe in the case that the</p>
<p>second string is the shorter of the two.</p>
<p>Version &lt; C++14</p>
<p>We can still use the range-and-a-half version of std::mismatch(), but
we need to first check that the first string is at most as big as the
second:</p>
<p>bool isPrefix = prefix.size() &lt;= string.size() &amp;&amp;</p>
<p>std::mismatch(prefix.begin(), prefix.end(),</p>
<p>string.begin(), string.end()).first == prefix.end(); Version ≥
C++17</p>
<p>With std::string_view, we can write the direct comparison we want
without having to worry about allocation</p>
<p>overhead or making copies:</p>
<p>bool isPrefix(std::string_view prefix, std::string_view full) {</p>
<p>return prefix == full.substr(0, prefix.size());</p>
<p>}</p>
<p>Section 47.12: Looping through each character</p>
<p>Version ≥ C++11</p>
<p>std::string supports iterators, and so you can use a <em>ranged
based</em> loop to iterate through each character:</p>
<p>std::string str = "Hello World!";</p>
<p>for (auto c : str)</p>
<p>std::cout &lt;&lt; c;</p>
<p>You can use a "traditional" for loop to loop through every
character:</p>
<p>std::string str = "Hello World!";</p>
<p>for (std::size_t i = 0; i &lt; str.length(); ++i)</p>
<p>std::cout &lt;&lt; str[i];</p>
<p>Section 47.13: Conversion to integers/floating point types</p>
<p>A std::string containing a number can be converted into an integer
type, or a floating point type, using</p>
<p>conversion functions.</p>
<p><em><strong>Note that</strong></em> all of these functions stop
parsing the input string as soon as they encounter a non-numeric
character, so "123abc" will be converted into 123.</p>
<p>The std::ato* family of functions converts C-style strings (character
arrays) to integer or floating-point types:</p>
<p>std::string ten = "10";</p>
<p>double num1 = std::atof(ten.c_str());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 259</p>
<p><span id="int_num2___std__atoi_ten_c_str" class="anchor"></span>int
num2 = std::atoi(ten.c_str());</p>
<p>long num3 = std::atol(ten.c_str());</p>
<p>Version ≥ C++11</p>
<p>long long num4 = std::atoll(ten.c_str());</p>
<p>However, use of these functions is discouraged because they return 0
if they fail to parse the string. This is bad because 0 could also be a
valid result, if for example the input string was "0", so it is
impossible to determine if the</p>
<p>conversion actually failed.</p>
<p>The newer std::sto* family of functions convert std::strings to
integer or floating-point types, and throw</p>
<p>exceptions if they could not parse their input. <em>You should use
these functions if possible</em>:</p>
<p>Version ≥ C++11</p>
<p>std::string ten = "10";</p>
<p>int num1 = std::stoi(ten);</p>
<p>long num2 = std::stol(ten);</p>
<p>long long num3 = std::stoll(ten);</p>
<p>float num4 = std::stof(ten);</p>
<p>double num5 = std::stod(ten);</p>
<p>long double num6 = std::stold(ten);</p>
<p>Furthermore, these functions also handle octal and hex strings unlike
the std::ato* family. The second parameter</p>
<p>is a pointer to the first unconverted character in the input string
(not illustrated here), and the third parameter is</p>
<p>the base to use. 0 is automatic detection of octal (starting with 0)
and hex (starting with 0x or 0X), and any other value is the base to
use</p>
<p>std::string ten = "10";</p>
<p>std::string ten_octal = "12";</p>
<p>std::string ten_hex = "0xA";</p>
<p>int num1 = std::stoi(ten, 0, 2); // Returns 2</p>
<p>int num2 = std::stoi(ten_octal, 0, 8); // Returns 10 long num3 =
std::stol(ten_hex, 0, 16); // Returns 10 long num4 = std::stol(ten_hex);
// Returns 0</p>
<p>long num5 = std::stol(ten_hex, 0, 0); // Returns 10 as it detects the
leading 0x</p>
<p>Section 47.14: Concatenation</p>
<p>You can concatenate std::strings using the overloaded + and +=
operators. Using the + operator:</p>
<p>std::string hello = "Hello";</p>
<p>std::string world = "world";</p>
<p>std::string helloworld = hello + world; // "Helloworld"</p>
<p>Using the += operator:</p>
<p>std::string hello = "Hello";</p>
<p>std::string world = "world";</p>
<p>hello += world; // "Helloworld"</p>
<p>You can also append C strings, including string literals:</p>
<p>std::string hello = "Hello";</p>
<p>std::string world = "world";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 260</p>
<p><span id="const_char__comma" class="anchor"></span>const char *comma
= ", ";</p>
<p>std::string newhelloworld = hello + comma + world + "!"; // "Hello,
world!"</p>
<p>You can also use push_back() to push back individual chars:</p>
<p>std::string s = "a, b, ";</p>
<p>s.push_back('c'); // "a, b, c"</p>
<p>There is also append(), which is pretty much like +=:</p>
<p>std::string app = "test and ";</p>
<p>app.append("test"); // "test and test"</p>
<p>Section 47.15: Converting between character encodings</p>
<p>Converting between encodings is easy with C++11 and most compilers
are able to deal with it in a cross-platform</p>
<p>manner through <strong>&lt;codecvt&gt;</strong> and
<strong>&lt;locale&gt;</strong> headers.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>// converts between wstring and utf8 string</p>
<p>wstring_convert&gt; wchar_to_utf8;</p>
<p>// converts between u16string and utf8 string</p>
<p>wstring_convert, char16_t&gt; utf16_to_utf8;</p>
<p>wstring wstr = L"foobar";</p>
<p>string utf8str = wchar_to_utf8.to_bytes(wstr);</p>
<p>wstring wstr2 = wchar_to_utf8.from_bytes(utf8str);</p>
<p>wcout &lt;&lt; wstr &lt;&lt; endl;</p>
<p>cout &lt;&lt; utf8str &lt;&lt; endl;</p>
<p>wcout &lt;&lt; wstr2 &lt;&lt; endl;</p>
<p>u16string u16str = u"foobar";</p>
<p>string utf8str2 = utf16_to_utf8.to_bytes(u16str);</p>
<p>u16string u16str2 = utf16_to_utf8.from_bytes(utf8str2);</p>
<p>return 0;</p>
<p>}</p>
<p>Mind that Visual Studio 2015 provides supports for these conversion
but a <a
href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/8f40dcd8-c67f-4eba-9134-a19b9178e481/vs-2015-rc-linker-stdcodecvt-error?forum=vcgeneral">bug</a>
in their library implementation</p>
<p>requires to use a different template for wstring_convert when dealing
with char16_t:</p>
<p>using utf16_char = unsigned short;</p>
<p>wstring_convert, utf16_char&gt; conv_utf8_utf16;</p>
<p>void strings::utf16_to_utf8(const std::u16string&amp; utf16,
std::string&amp; utf8) {</p>
<p>std::basic_string tmp;</p>
<p>tmp.resize(utf16.length());</p>
<p>std::copy(utf16.begin(), utf16.end(), tmp.begin()); utf8 =
conv_utf8_utf16.to_bytes(tmp);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 261</p>
<p><span id="void_strings__utf8_to_utf16_cons"
class="anchor"></span>void strings::utf8_to_utf16(const std::string&amp;
utf8, std::u16string&amp; utf16) {</p>
<p>std::basic_string tmp = conv_utf8_utf16.from_bytes(utf8);
utf16.clear();</p>
<p>utf16.resize(tmp.length());</p>
<p>std::copy(tmp.begin(), tmp.end(), utf16.begin()); }</p>
<p>Section 47.16: Finding character(s) in a string</p>
<p><a
href="http://en.cppreference.com/w/cpp/string/basic_string/find">To find
a character or another string, you can use std::string::find. It returns
the position of the first character</a></p>
<p><a
href="http://en.cppreference.com/w/cpp/string/basic_string/npos">of the
first match. If no matches were found, the function returns
std::string::npos</a></p>
<p>std::string str = "Curiosity killed the cat";</p>
<p>auto it = str.find("cat");</p>
<p>if (it != std::string::npos)</p>
<p>std::cout &lt;&lt; "Found at position: " &lt;&lt; it &lt;&lt;
'<strong>\n</strong>';</p>
<p>else</p>
<p>std::cout &lt;&lt; "Not found!<strong>\n</strong>";</p>
<p>Found at position: 21</p>
<p>The search opportunities are further expanded by the following
functions:</p>
<p>find_first_of // Find first occurrence of characters
find_first_not_of // Find first absence of characters find_last_of //
Find last occurrence of characters find_last_not_of // Find last absence
of characters</p>
<p>These functions can allow you to search for characters from the end
of the string, as well as find the negative case</p>
<p>(ie. characters that are not in the string). Here is an example:</p>
<p>std::string str = "dog dog cat cat";</p>
<p>std::cout &lt;&lt; "Found at position: " &lt;&lt;
str.find_last_of("gzx") &lt;&lt; '<strong>\n</strong>';</p>
<p>Found at position: 6</p>
<p><em><strong>Note:</strong></em> Be aware that the above functions do
not search for substrings, but rather for characters contained in
the</p>
<p>search string. In this case, the last occurrence of 'g' was found at
position 6 (the other characters weren't found).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 262</p>
<p><span id="Chapter_48__std__array_1" class="anchor"></span>Chapter 48:
std::array</p>
<p>Parameter Definition</p>
<p>class T Specifies the data type of array members</p>
<p>std::size_t N Specifies the number of members in the array</p>
<p>Section 48.1: Initializing an std::array</p>
<p>Initializing std::array&lt;T, N&gt;, where T is a scalar type and N
is the number of elements of type T</p>
<p>If T is a scalar type, std::array can be initialized in the following
ways:</p>
<p>// 1) Using aggregate-initialization</p>
<p>std::array a{ 0, 1, 2 };</p>
<p>// or equivalently</p>
<p>std::array a = { 0, 1, 2 };</p>
<p>// 2) Using the copy constructor</p>
<p>std::array a{ 0, 1, 2 };</p>
<p>std::array a2(a);</p>
<p>// or equivalently</p>
<p>std::array a2 = a;</p>
<p>// 3) Using the move constructor</p>
<p>std::array a = std::array{ 0, 1, 2 };</p>
<p>Initializing std::array&lt;T, N&gt;, where T is a non-scalar type and
N is the number of elements of type T</p>
<p>If T is a non-scalar type std::array can be initialized in the
following ways:</p>
<p>struct A { int values[3]; }; // An aggregate type</p>
<p>// 1) Using aggregate initialization with brace elision // It works
only if T is an aggregate type!</p>
<p>std::array a{ 0, 1, 2, 3, 4, 5 };</p>
<p>// or equivalently</p>
<p>std::array a = { 0, 1, 2, 3, 4, 5 };</p>
<p>// 2) Using aggregate initialization with brace initialization of
sub-elements std::array a{ A{ 0, 1, 2 }, A{ 3, 4, 5 } };</p>
<p>// or equivalently</p>
<p>std::array a = { A{ 0, 1, 2 }, A{ 3, 4, 5 } };</p>
<p>// 3)</p>
<p>std::array a{{ { 0, 1, 2 }, { 3, 4, 5 } }};</p>
<p>// or equivalently</p>
<p>std::array a = {{ { 0, 1, 2 }, { 3, 4, 5 } }};</p>
<p>// 4) Using the copy constructor</p>
<p>std::array a{ 1, 2, 3 };</p>
<p>std::array a2(a);</p>
<p>// or equivalently</p>
<p>std::array a2 = a;</p>
<p>// 5) Using the move constructor</p>
<p>std::array a = std::array{ 0, 1, 2, 3, 4, 5 };</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 263</p>
<p><span id="Section_48_2__Element_access" class="anchor"></span>Section
48.2: Element access</p>
<p>1. at(pos)</p>
<p>Returns a reference to the element at position pos with bounds
checking. If pos is not within the range of the container, an exception
of type std::out_of_range is thrown.</p>
<p>The complexity is constant O(1).</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::array arr;</p>
<p>// write values</p>
<p>arr.at(0) = 2;</p>
<p>arr.at(1) = 4;</p>
<p>arr.at(2) = 6;</p>
<p>// read values</p>
<p>int a = arr.at(0); // a is now 2</p>
<p>int b = arr.at(1); // b is now 4</p>
<p>int c = arr.at(2); // c is now 6</p>
<p>return 0;</p>
<p>}</p>
<p>2) operator[pos]</p>
<p>Returns a reference to the element at position pos without bounds
checking. If pos is not within the range of the</p>
<p>container, a runtime <em>segmentation violation</em> error can occur.
This method provides element access equivalent to classic arrays and
thereof more efficient than at(pos).</p>
<p>The complexity is constant O(1).</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::array arr;</p>
<p>// write values</p>
<p>arr[0] = 2;</p>
<p>arr[1] = 4;</p>
<p>arr[2] = 6;</p>
<p>// read values</p>
<p>int a = arr[0]; // a is now 2</p>
<p>int b = arr[1]; // b is now 4</p>
<p>int c = arr[2]; // c is now 6</p>
<p>return 0;</p>
<p>}</p>
<p>3) std::get&lt;pos&gt;</p>
<p>This <strong>non-member</strong> function returns a reference to the
element at <strong>compile-time constant</strong> position pos
without</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 264</p>
<p>bounds checking. If pos is not within the range of the container, a
runtime <em>segmentation violation</em> error can occur.</p>
<p>The complexity is constant O(1).</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::array arr;</p>
<p>// write values</p>
<p>std::get&lt;0&gt;(arr) = 2;</p>
<p>std::get&lt;1&gt;(arr) = 4;</p>
<p>std::get&lt;2&gt;(arr) = 6;</p>
<p>// read values</p>
<p>int a = std::get&lt;0&gt;(arr); // a is now 2</p>
<p>int b = std::get&lt;1&gt;(arr); // b is now 4</p>
<p>int c = std::get&lt;2&gt;(arr); // c is now 6</p>
<p>return 0;</p>
<p>}</p>
<p>4) front()</p>
<p>Returns a reference to the first element in container. Calling
front() on an empty container is undefined.</p>
<p>The complexity is constant O(1).</p>
<p><strong>Note:</strong> For a container c, the expression c.front() is
equivalent to *c.begin().</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::array arr{ 2, 4, 6 };</p>
<p>int a = arr.front(); // a is now 2</p>
<p>return 0;</p>
<p>}</p>
<p>5) back()</p>
<p>Returns reference to the last element in the container. Calling
back() on an empty container is undefined.</p>
<p>The complexity is constant O(1).</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::array arr{ 2, 4, 6 };</p>
<p>int a = arr.back(); // a is now 6</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 265</p>
<p><span id="6__data" class="anchor"></span>6) data()</p>
<p>Returns pointer to the underlying array serving as element storage.
The pointer is such that range [data();</p>
<p>data() + size()) is always a valid range, even if the container is
empty (data() is not dereferenceable in that case).</p>
<p>The complexity is constant O(1).</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main ()</p>
<p>{</p>
<p>const char* cstr = "Test string";</p>
<p>std::array arr;</p>
<p>std::memcpy(arr.data(), cstr, 12); // copy cstr to arr</p>
<p>std::cout &lt;&lt; arr.data(); // outputs: Test string</p>
<p>return 0;</p>
<p>}</p>
<p>Section 48.3: Iterating through the Array</p>
<p>std::array being a STL container, can use range-based for loop
similar to other containers like vector</p>
<p>int main() {</p>
<p>std::array arr = { 1, 2, 3 };</p>
<p>for (auto i : arr)</p>
<p>cout &lt;&lt; i &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>Section 48.4: Checking size of the Array</p>
<p>One of the main advantage of std::array as compared to C style array
is that we can check the size of the array using size() member
function</p>
<p>int main() {</p>
<p>std::array arr = { 1, 2, 3 };</p>
<p>cout &lt;&lt; arr.size() &lt;&lt; endl;</p>
<p>}</p>
<p>Section 48.5: Changing all array elements at once</p>
<p>The member function fill() can be used on std::array for changing the
values at once post initialization</p>
<p>int main() {</p>
<p>std::array arr = { 1, 2, 3 };</p>
<p>// change all elements of the array to 100</p>
<p>arr.fill(100);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 266</p>
<p><span id="Chapter_49__std__vector_1" class="anchor"></span>Chapter
49: std::vector</p>
<p>A vector is a dynamic array with automatically handled storage. The
elements in a vector can be accessed just as</p>
<p>efficiently as those in an array with the advantage being that
vectors can dynamically change in size.</p>
<p>In terms of storage the vector data is (usually) placed in
dynamically allocated memory thus requiring some minor</p>
<p>overhead; conversely C-arrays and std::array use automatic storage
relative to the declared location and thus do not have any overhead.</p>
<p>Section 49.1: Accessing Elements</p>
<p><a href="http://en.cppreference.com/w/cpp/container/vector">There are
two primary ways of accessing elements in a std::vector</a></p>
<p>index-based access</p>
<p>iterators</p>
<p>Index-based access:</p>
<p><a
href="http://en.cppreference.com/w/cpp/container/vector/operator_at">This
can be done either with the subscript operator []</a>, or the member
function <a
href="http://en.cppreference.com/w/cpp/container/vector/at">at()</a>.</p>
<p>Both return a reference to the element at the respective position in
the std::vector (unless it's a vector), so that it can be read as well
as modified (if the vector is not const).</p>
<p>[] and at() differ in that [] is not guaranteed to perform any bounds
checking, while at() does. Accessing</p>
<p>elements where index &lt; 0 or index &gt;= size is undefined behavior
for [], while at() throws a <a
href="http://en.cppreference.com/w/cpp/error/out_of_range">std::out_of_range</a></p>
<p>exception.</p>
<p><em><strong>Note:</strong></em> The examples below use C++11-style
initialization for clarity, but the operators can be used with all
versions</p>
<p>(unless marked C++11).</p>
<p>Version ≥ C++11</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>// using []</p>
<p>int a = v[1]; // a is 2</p>
<p>v[1] = 4; // v now contains { 1, 4, 3 }</p>
<p>// using at()</p>
<p>int b = v.at(2); // b is 3</p>
<p>v.at(2) = 5; // v now contains { 1, 4, 5 }</p>
<p>int c = v.at(3); // throws std::out_of_range exception</p>
<p>Because the at() method performs bounds checking and can throw
exceptions, it is slower than []. This makes []</p>
<p>preferred code where the semantics of the operation guarantee that
the index is in bounds. In any case, accesses to elements of vectors are
done in constant time. That means accessing to the first element of the
vector has the</p>
<p>same cost (in time) of accessing the second element, the third
element and so on.</p>
<p>For example, consider this loop</p>
<p>for (std::size_t i = 0; i &lt; v.size(); ++i) {</p>
<p>v[i] = 1;</p>
<p>}</p>
<p>Here we know that the index variable i is always in bounds, so it
would be a waste of CPU cycles to check that i is</p>
<p>in bounds for every call to operator[].</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 267</p>
<p><a href="http://en.cppreference.com/w/cpp/container/vector/front">The
front()</a> and <a
href="http://en.cppreference.com/w/cpp/container/vector/back">back()</a>
member functions allow easy reference access to the first and last
element of the vector, respectively. These positions are frequently
used, and the special accessors can be more readable than their</p>
<p>alternatives using []:</p>
<p>std::vector v{ 4, 5, 6 }; // In pre-C++11 this is more verbose</p>
<p>int a = v.front(); // a is 4, v.front() is equivalent to v[0]
v.front() = 3; // v now contains {3, 5, 6}</p>
<p>int b = v.back(); // b is 6, v.back() is equivalent to v[v.size() -
1] v.back() = 7; // v now contains {3, 5, 7}</p>
<p><em><strong>Note</strong></em>: It is undefined behavior to invoke
front() or back() on an empty vector. You need to check that the</p>
<p>container is not empty using the <a
href="http://en.cppreference.com/w/cpp/container/vector/empty">empty()
member function (which checks if the container is empty) before
calling</a> front() or back(). A simple example of the use of 'empty()'
to test for an empty vector follows:</p>
<p>int main ()</p>
<p>{</p>
<p>std::vector v;</p>
<p>int sum (0);</p>
<p>for (int i=1;i&lt;=10;i++) v.push_back(i);//create and initialize the
vector</p>
<p>while (!v.empty())//loop through until the vector tests to be empty
{</p>
<p>sum += v.back();//keep a running total</p>
<p>v.pop_back();//pop out the element which removes it from the
vector</p>
<p>}</p>
<p>std::cout &lt;&lt; "total: " &lt;&lt; sum &lt;&lt;
'<strong>\n</strong>';//output the total to the user</p>
<p>return 0;</p>
<p>}</p>
<p>The example above creates a vector with a sequence of numbers from 1
to 10. Then it pops the elements of the</p>
<p>vector out until the vector is empty (using 'empty()') to prevent
undefined behavior. Then the sum of the numbers</p>
<p>in the vector is calculated and displayed to the user.</p>
<p>Version ≥ C++11</p>
<p><a href="http://en.cppreference.com/w/cpp/container/vector/data">The
data() method returns a pointer to the raw memory used by the</a>
std::vector to internally store its elements. This is most often used
when passing the vector data to legacy code that expects a C-style
array.</p>
<p>std::vector v{ 1, 2, 3, 4 }; // v contains {1, 2, 3, 4} int* p =
v.data(); // p points to 1</p>
<p>*p = 4; // v now contains {4, 2, 3, 4}</p>
<p>++p; // p points to 2</p>
<p>*p = 3; // v now contains {4, 3, 3, 4}</p>
<p>p[1] = 2; // v now contains {4, 3, 2, 4}</p>
<p>*(p + 2) = 1; // v now contains {4, 3, 2, 1}</p>
<p>Version &lt; C++11</p>
<p>Before C++11, the data() method can be simulated by calling front()
and taking the address of the returned value:</p>
<p>std::vector v(4);</p>
<p>int* ptr = &amp;(v.front()); // or &amp;v[0]</p>
<p>This works because vectors are always guaranteed to store their
elements in contiguous memory locations,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 268</p>
<p><span id="assuming_the_contents_of_the_vec"
class="anchor"></span>assuming the contents of the vector doesn't
override unary operator&amp;. If it does, you'll have to
re-implement</p>
<p><a
href="http://en.cppreference.com/w/cpp/memory/addressof">std::addressof
in pre-C++11. It also assumes that the vector isn't empty.</a></p>
<p>Iterators:</p>
<p>Iterators are explained in more detail in the example "Iterating over
std::vector" and the article Iterators. In short, they act similarly to
pointers to the elements of the vector:</p>
<p>Version ≥ C++11</p>
<p>std::vector v{ 4, 5, 6 };</p>
<p>auto it = v.begin();</p>
<p>int i = *it; // i is 4</p>
<p>++it;</p>
<p>i = *it; // i is 5</p>
<p>*it = 6; // v contains { 4, 6, 6 }</p>
<p>auto e = v.end(); // e points to the element after the end of v. It
can be</p>
<p>// used to check whether an iterator reached the end of the
vector:</p>
<p>++it;</p>
<p>it == v.end(); // false, it points to the element at position 2 (with
value 6) ++it;</p>
<p>it == v.end(); // true</p>
<p>It is consistent with the standard that a std::vector's iterators
actually <em>be</em> T*s, but most standard libraries do not do this.
Not doing this both improves error messages, catches non-portable code,
and can be used to</p>
<p>instrument the iterators with debugging checks in non-release builds.
Then, in release builds, the class wrapping</p>
<p>around the underlying pointer is optimized away.</p>
<p>You can persist a reference or a pointer to an element of a vector
for indirect access. These references or pointers to elements in the
vector remain stable and access remains defined unless you add/remove
elements at or before</p>
<p>the element in the vector, or you cause the vector capacity to
change. This is the same as the rule for invalidating</p>
<p>iterators.</p>
<p>Version ≥ C++11</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>int* p = v.data() + 1; // p points to 2</p>
<p>v.insert(v.begin(), 0); // p is now invalid, accessing *p is a
undefined behavior. p = v.data() + 1; // p points to 1</p>
<p>v.reserve(10); // p is now invalid, accessing *p is a undefined
behavior. p = v.data() + 1; // p points to 1</p>
<p>v.erase(v.begin()); // p is now invalid, accessing *p is a undefined
behavior.</p>
<p>Section 49.2: Initializing a std::vector</p>
<p>A <a
href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>
<a href="http://en.cppreference.com/w/cpp/container/vector/vector">can
be initialized</a> in several ways while declaring it:</p>
<p>Version ≥ C++11</p>
<p>std::vector v{ 1, 2, 3 }; // v becomes {1, 2, 3}</p>
<p>// Different from std::vector v(3, 6)</p>
<p>std::vector v{ 3, 6 }; // v becomes {3, 6}</p>
<p>// Different from std::vector v{3, 6} in C++11 std::vector v(3, 6);
// v becomes {6, 6, 6}</p>
<p>std::vector v(4); // v becomes {0, 0, 0, 0}</p>
<p>A vector can be initialized from another container in several
ways:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 269</p>
<p><span id="Copy_construction__from_another" class="anchor"></span>Copy
construction (from another vector only), which copies data from v2:</p>
<p>std::vector v(v2);</p>
<p>std::vector v = v2;</p>
<p>Version ≥ C++11</p>
<p>Move construction (from another vector only), which moves data from
v2:</p>
<p>std::vector v(std::move(v2));</p>
<p>std::vector v = std::move(v2);</p>
<p>Iterator (range) copy-construction, which copies elements into v:</p>
<p>// from another vector</p>
<p>std::vector v(v2.begin(), v2.begin() + 3); // v becomes {v2[0],
v2[1], v2[2]}</p>
<p>// from an array</p>
<p>int z[] = { 1, 2, 3, 4 };</p>
<p>std::vector v(z, z + 3); // v becomes {1, 2, 3}</p>
<p>// from a list</p>
<p>std::list list1{ 1, 2, 3 };</p>
<p>std::vector v(list1.begin(), list1.end()); // v becomes {1, 2, 3}</p>
<p>Version ≥ C++11</p>
<p>Iterator move-construction, using <a
href="http://en.cppreference.com/w/cpp/iterator/make_move_iterator">std::make_move_iterator</a>,
which moves elements into v:</p>
<p>// from another vector</p>
<p>std::vector v(std::make_move_iterator(v2.begin()),</p>
<p>std::make_move_iterator(v2.end());</p>
<p>// from a list</p>
<p>std::list list1{ 1, 2, 3 };</p>
<p>std::vector v(std::make_move_iterator(list1.begin()),</p>
<p>std::make_move_iterator(list1.end()));</p>
<p>With the help of the <a
href="http://en.cppreference.com/w/cpp/container/vector/assign">assign()
member function, a</a> std::vector can be reinitialized after its
construction:</p>
<p>v.assign(4, 100); // v becomes {100, 100, 100, 100}</p>
<p>v.assign(v2.begin(), v2.begin() + 3); // v becomes {v2[0], v2[1],
v2[2]}</p>
<p>int z[] = { 1, 2, 3, 4 };</p>
<p>v.assign(z + 1, z + 4); // v becomes {2, 3, 4}</p>
<p>Section 49.3: Deleting Elements</p>
<p>Deleting the last element:</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>v.pop_back(); // v becomes {1, 2}</p>
<p>Deleting all elements:</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>v.clear(); // v becomes an empty vector</p>
<p>Deleting element by index:</p>
<p>std::vector v{ 1, 2, 3, 4, 5, 6 };</p>
<p>v.erase(v.begin() + 3); // v becomes {1, 2, 3, 5, 6}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 270</p>
<p><em>Note:</em> For a vector deleting an element which is not the last
element, all elements beyond the deleted element have to be copied or
moved to fill the gap, see the note below and std::list.</p>
<p>Deleting all elements in a range:</p>
<p>std::vector v{ 1, 2, 3, 4, 5, 6 };</p>
<p>v.erase(v.begin() + 1, v.begin() + 5); // v becomes {1, 6}</p>
<p><em><strong>Note:</strong></em> The above methods do not change the
capacity of the vector, only the size. See Vector Size and Capacity.</p>
<p><a href="http://en.cppreference.com/w/cpp/container/vector/erase">The
erase method, which removes a range of elements, is often used as a part
of the</a> <a
href="https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom"><strong>erase-remove</strong>
idiom. That is,</a></p>
<p>first <a
href="http://en.cppreference.com/w/cpp/algorithm/remove">std::remove
moves some elements to the end of the vector, and then</a> erase chops
them off. This is a relatively</p>
<p>inefficient operation for any indices less than the last index of the
vector because all elements after the erased</p>
<p>segments must be relocated to new positions. For speed critical
applications that require efficient removal of arbitrary elements in a
container, see std::list.</p>
<p>Deleting elements by value:</p>
<p>std::vector v{ 1, 1, 2, 2, 3, 3 };</p>
<p>int value_to_remove = 2;</p>
<p>v.erase(std::remove(v.begin(), v.end(), value_to_remove), v.end());
// v becomes {1, 1, 3, 3}</p>
<p>Deleting elements by condition:</p>
<p>// std::remove_if needs a function, that takes a vector element as
argument and returns true, // if the element shall be removed</p>
<p>bool _predicate(const int&amp; element) {</p>
<p>return (element &gt; 3); // This will cause all elements to be
deleted that are larger than 3</p>
<p>}</p>
<p>...</p>
<p>std::vector v{ 1, 2, 3, 4, 5, 6 };</p>
<p>v.erase(std::remove_if(v.begin(), v.end(), _predicate), v.end()); //
v becomes {1, 2, 3}</p>
<p>Deleting elements by lambda, without creating additional predicate
function <strong>Version ≥ C++11</strong></p>
<p>std::vector v{ 1, 2, 3, 4, 5, 6 };</p>
<p>v.erase(std::remove_if(v.begin(), v.end(),</p>
<p>[](auto&amp; element){return element &gt; 3;} ), v.end()</p>
<p>);</p>
<p>Deleting elements by condition from a loop:</p>
<p>std::vector v{ 1, 2, 3, 4, 5, 6 };</p>
<p>std::vector::iterator it = v.begin();</p>
<p>while (it != v.end()) {</p>
<p>if (condition)</p>
<p>it = v.erase(it); // after erasing, 'it' will be set to the next
element in v</p>
<p>else</p>
<p>++it; // manually set 'it' to the next element in v</p>
<p>}</p>
<p>While it is important <em>not</em> to increment it in case of a
deletion, you should consider using a different method when</p>
<p>then erasing repeatedly in a loop. Consider remove_if for a more
efficient way.</p>
<p>Deleting elements by condition from a reverse loop:</p>
<p>std::vector v{-1, 0, 1, 2, 3, 4, 5, 6 };</p>
<p>typedef std::vector::reverse_iterator rev_itr; rev_itr it =
v.rbegin();</p>
<p>while (it != v.rend()) { // after the loop only '0' will be in v</p>
<p>int value = *it;</p>
<p>if (value) {</p>
<p>++it;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 271</p>
<p><span id="___See_explanation_below_for_the" class="anchor"></span>//
See explanation below for the following line.</p>
<p>it = rev_itr(v.erase(it.base()));</p>
<p>} else</p>
<p>++it;</p>
<p>}</p>
<p>Note some points for the preceding loop:</p>
<p>Given a reverse iterator it <a
href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator/base">pointing
to some element, the method base gives the regular (non-reverse)</a></p>
<p>iterator pointing to the same element.</p>
<p>vector::erase(iterator) erases the element pointed to by an iterator,
and returns an iterator to the</p>
<p>element that followed the given element.</p>
<p>reverse_iterator::reverse_iterator(iterator) constructs a reverse
iterator from an iterator.</p>
<p>Put altogether, the line it = rev_itr(v.erase(it.base())) says: take
the reverse iterator it, have v erase the</p>
<p>element pointed by its regular iterator; take the resulting iterator,
construct a reverse iterator from it, and assign it to the reverse
iterator it.</p>
<p>Deleting all elements using v.clear() does not free up memory (<a
href="http://en.cppreference.com/w/cpp/container/vector/capacity">capacity()
of the vector remains unchanged). To</a></p>
<p>reclaim space, use:</p>
<p>std::vector().swap(v);</p>
<p>Version ≥ C++11</p>
<p><a
href="http://en.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit()</a>
frees up unused vector capacity:</p>
<p>v.shrink_to_fit();</p>
<p>The shrink_to_fit does not guarantee to really reclaim space, but
most current implementations do.</p>
<p>Section 49.4: Iterating Over std::vector</p>
<p>You can iterate over a <a
href="http://en.cppreference.com/w/cpp/container/vector">std::vector in
several ways. For each of the following sections,</a> v is defined as
follows:</p>
<p>std::vector v;</p>
<p>Iterating in the Forward Direction</p>
<p>Version ≥ C++11</p>
<p>// Range based for</p>
<p>for(const auto&amp; value: v) {</p>
<p>std::cout &lt;&lt; value &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>// Using a for loop with iterator</p>
<p>for(auto it = std::begin(v); it != std::end(v); ++it) {</p>
<p>std::cout &lt;&lt; *it &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>// Using for_each algorithm, using a function or functor: void
fun(int const&amp; value) {</p>
<p>std::cout &lt;&lt; value &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>std::for_each(std::begin(v), std::end(v), fun);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 272</p>
<p>// Using for_each algorithm. Using a lambda:</p>
<p>std::for_each(std::begin(v), std::end(v), [](int const&amp; value)
{</p>
<p>std::cout &lt;&lt; value &lt;&lt; "<strong>\n</strong>";</p>
<p>});</p>
<p>Version &lt; C++11</p>
<p>// Using a for loop with iterator</p>
<p>for(std::vector::iterator it = std::begin(v); it != std::end(v);
++it) {</p>
<p>std::cout &lt;&lt; *it &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>// Using a for loop with index</p>
<p>for(std::size_t i = 0; i &lt; v.size(); ++i) {</p>
<p>std::cout &lt;&lt; v[i] &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>Iterating in the Reverse Direction</p>
<p>Version ≥ C++14</p>
<p>// There is no standard way to use range based for for this. // See
below for alternatives.</p>
<p>// Using for_each algorithm</p>
<p>// Note: Using a lambda for clarity. But a function or functor will
work std::for_each(std::rbegin(v), std::rend(v), [](auto const&amp;
value) {</p>
<p>std::cout &lt;&lt; value &lt;&lt; "<strong>\n</strong>";</p>
<p>});</p>
<p>// Using a for loop with iterator</p>
<p>for(auto rit = std::rbegin(v); rit != std::rend(v); ++rit) {</p>
<p>std::cout &lt;&lt; *rit &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>// Using a for loop with index</p>
<p>for(std::size_t i = 0; i &lt; v.size(); ++i) {</p>
<p>std::cout &lt;&lt; v[v.size()-1- i] &lt;&lt;
"<strong>\n</strong>";</p>
<p>}</p>
<p>Though there is no built-in way to use the range based for to reverse
iterate; it is relatively simple to fix this. The</p>
<p>range based for uses begin() and end() to get iterators and thus
simulating this with a wrapper object can achieve the results we
require.</p>
<p>Version ≥ C++14</p>
<p>template</p>
<p>struct ReverseRange {</p>
<p>C c; // could be a reference or a copy, if the original was a
temporary ReverseRange(C&amp;&amp; cin): c(std::forward(cin)) {}</p>
<p>ReverseRange(ReverseRange&amp;&amp;)=default;</p>
<p>ReverseRange&amp; operator=(ReverseRange&amp;&amp;)=delete;</p>
<p>auto begin() const {return std::rbegin(c);}</p>
<p>auto end() const {return std::rend(c);}</p>
<p>};</p>
<p>// C is meant to be deduced, and perfect forwarded into template</p>
<p>ReverseRange make_ReverseRange(C&amp;&amp; c) {return
{std::forward(c)};}</p>
<p>int main() {</p>
<p>std::vector v { 1,2,3,4};</p>
<p>for(auto const&amp; value: make_ReverseRange(v)) {</p>
<p>std::cout &lt;&lt; value &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p>}</p>
<p>Enforcing const elements</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 273</p>
<p><span id="Since_C__11_the_cbegin___and_cen"
class="anchor"></span>Since C++11 the cbegin() and cend() methods allow
you to obtain a <em>constant iterator</em> for a vector, even if the
vector is non-const. A constant iterator allows you to read but not
modify the contents of the vector which is useful to</p>
<p>enforce const correctness:</p>
<p>Version ≥ C++11</p>
<p>// forward iteration</p>
<p>for (auto pos = v.cbegin(); pos != v.cend(); ++pos) {</p>
<p>// type of pos is vector::const_iterator</p>
<p>// *pos = 5; // Compile error - can't write via const iterator</p>
<p>}</p>
<p>// reverse iteration</p>
<p>for (auto pos = v.crbegin(); pos != v.crend(); ++pos) {</p>
<p>// type of pos is vector::const_iterator</p>
<p>// *pos = 5; // Compile error - can't write via const iterator</p>
<p>}</p>
<p>// expects Functor::operand()(T&amp;)</p>
<p>for_each(v.begin(), v.end(), Functor());</p>
<p>// expects Functor::operand()(const T&amp;)</p>
<p>for_each(v.cbegin(), v.cend(), Functor())</p>
<p>Version ≥ C++17</p>
<p><a href="http://en.cppreference.com/w/cpp/utility/as_const">as_const
extends this to range iteration:</a></p>
<p>for (auto const&amp; e : std::as_const(v)) {</p>
<p>std::cout &lt;&lt; e &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>This is easy to implement in earlier versions of C++:</p>
<p>Version ≥ C++14</p>
<p>template</p>
<p>constexpr std::add_const_t&amp; as_const(T&amp; t) noexcept {</p>
<p>return t;</p>
<p>}</p>
<p>A Note on Efficiency</p>
<p>Since the class std::vector is basically a class that manages a
dynamically allocated contiguous array, the same principle explained
here applies to C++ vectors. Accessing the vector's content by index is
much more efficient</p>
<p>when following the row-major order principle. Of course, each access
to the vector also puts its management</p>
<p>content into the cache as well, but as has been debated many times
(notably <a
href="http://stackoverflow.com/questions/381621/using-arrays-or-stdvectors-in-c-whats-the-performance-gap">here</a>
and <a
href="http://stackoverflow.com/questions/3664272/is-stdvector-so-much-slower-than-plain-arrays">here),
the difference in</a></p>
<p>performance for iterating over a std::vector compared to a raw array
is negligible. So the same principle of efficiency for raw arrays in C
also applies for C++'s std::vector.</p>
<p>Section 49.5: vector&lt;bool&gt;: The Exception To So Many, So</p>
<p>Many Rules</p>
<p>The standard (section 23.3.7) specifies that a specialization of
vector is provided, which optimizes space by</p>
<p>packing the bool values, so that each takes up only one bit. Since
bits aren't addressable in C++, this means that several requirements on
vector are not placed on vector:</p>
<p>The data stored is not required to be contiguous, so a vector can't
be passed to a C API which expects</p>
<p>a bool array.</p>
<p>at(), operator [], and dereferencing of iterators do not return a
reference to bool. Rather they return a</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 274</p>
<p><span id="proxy_object_that__imperfectly" class="anchor"></span>proxy
object that (imperfectly) simulates a reference to a bool by overloading
its assignment operators. As an example, the following code may not be
valid for std::vector, because dereferencing an iterator</p>
<p>does not return a reference:</p>
<p>Version ≥ C++11</p>
<p>std::vector v = {true, false};</p>
<p>for (auto &amp;b: v) { } // error</p>
<p>Similarly, functions expecting a bool&amp; argument cannot be used
with the result of operator [] or at() applied to vector, or with the
result of dereferencing its iterator:</p>
<p>void f(bool&amp; b);</p>
<p>f(v[0]); // error</p>
<p>f(*v.begin()); // error</p>
<p>The implementation of std::vector is dependent on both the compiler
and architecture. The specialisation</p>
<p>is implemented by packing n Booleans into the lowest addressable
section of memory. Here, n is the size in bits of the lowest addressable
memory. In most modern systems this is 1 byte or 8 bits. This means that
one byte can</p>
<p>store 8 Boolean values. This is an improvement over the traditional
implementation where 1 Boolean value is</p>
<p>stored in 1 byte of memory.</p>
<p><em><strong>Note:</strong></em> The below example shows possible
bitwise values of individual bytes in a traditional vs. optimized</p>
<p>vector. This will not always hold true in all architectures. It is,
however, a good way of visualising the</p>
<p>optimization. In the below examples a byte is represented as [x, x,
x, x, x, x, x, x].</p>
<p><strong>Traditional</strong> std::vector&lt;char&gt; storing 8
Boolean values:</p>
<p>Version ≥ C++11</p>
<p>std::vector trad_vect = {true, false, false, false, true, false,
true, true};</p>
<p>Bitwise representation:</p>
<p>[0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,1]</p>
<p><strong>Specialized</strong> std::vector&lt;bool&gt; storing 8
Boolean values:</p>
<p>Version ≥ C++11</p>
<p>std::vector optimized_vect = {true, false, false, false, true, false,
true, true};</p>
<p>Bitwise representation:</p>
<p>[1,0,0,0,1,0,1,1]</p>
<p>Notice in the above example, that in the traditional version of
std::vector, 8 Boolean values take up 8 bytes</p>
<p>of memory, whereas in the optimized version of std::vector, they only
use 1 byte of memory. This is a significant improvement on memory usage.
If you need to pass a vector to an C-style API, you may need to</p>
<p>copy the values to an array, or find a better way to use the API, if
memory and performance are at risk.</p>
<p>Section 49.6: Inserting Elements</p>
<p>Appending an element at the end of a vector (by copying/moving):</p>
<p>struct Point {</p>
<p>double x, y;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 275</p>
<p><span id="Point_double_x__double_y____x_x"
class="anchor"></span>Point(double x, double y) : x(x), y(y) {}</p>
<p>};</p>
<p>std::vector v;</p>
<p>Point p(10.0, 2.0);</p>
<p>v.push_back(p); // p is copied into the vector.</p>
<p>Version ≥ C++11</p>
<p>Appending an element at the end of a vector by constructing the
element in place:</p>
<p>std::vector v;</p>
<p>v.emplace_back(10.0, 2.0); // The arguments are passed to the
constructor of the</p>
<p>// given type (here Point). The object is constructed // in the
vector, avoiding a copy.</p>
<p>Note that std::vector does <em>not</em> have a push_front() member
function due to performance reasons. Adding an element at the beginning
causes all existing elements in the vector to be moved. If you want to
frequently insert</p>
<p>elements at the beginning of your container, then you might want to
use std::list or std::deque instead.</p>
<p>Inserting an element at any position of a vector:</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>v.insert(v.begin(), 9); // v now contains {9, 1, 2, 3}</p>
<p>Version ≥ C++11</p>
<p>Inserting an element at any position of a vector by constructing the
element in place:</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>v.emplace(v.begin()+1, 9); // v now contains {1, 9, 2, 3}</p>
<p>Inserting another vector at any position of the vector:</p>
<p>std::vector v(4); // contains: 0, 0, 0, 0</p>
<p>std::vector v2(2, 10); // contains: 10, 10</p>
<p>v.insert(v.begin()+2, v2.begin(), v2.end()); // contains: 0, 0, 10,
10, 0, 0</p>
<p>Inserting an array at any position of a vector:</p>
<p>std::vector v(4); // contains: 0, 0, 0, 0</p>
<p>int a [] = {1, 2, 3}; // contains: 1, 2, 3</p>
<p>v.insert(v.begin()+1, a, a+sizeof(a)/sizeof(a[0])); // contains: 0,
1, 2, 3, 0, 0, 0</p>
<p>Use <a
href="http://www.cplusplus.com/reference/vector/vector/reserve/">reserve()
before inserting multiple elements if resulting vector size is known
beforehand to avoid multiple</a> reallocations (see vector size and
capacity):</p>
<p>std::vector v;</p>
<p>v.reserve(100);</p>
<p>for(int i = 0; i &lt; 100; ++i)</p>
<p>v.emplace_back(i);</p>
<p><a href="http://www.cplusplus.com/reference/vector/vector/resize/">Be
sure to not make the mistake of calling resize()</a> in this case, or
you will inadvertently create a vector with 200</p>
<p>elements where only the latter one hundred will have the value you
intended.</p>
<p>Section 49.7: Using std::vector as a C array</p>
<p>There are several ways to use a std::vector as a C array (for
example, for compatibility with C libraries). This is</p>
<p>possible because the elements in a vector are stored
contiguously.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 276</p>
<p><span id="Version_____C__11_2" class="anchor"></span>Version ≥
C++11</p>
<p>std::vector v{ 1, 2, 3 };</p>
<p>int* p = v.data();</p>
<p>In contrast to solutions based on previous C++ standards (see below),
the member function .data() may also be applied to empty vectors,
because it doesn't cause undefined behavior in this case.</p>
<p>Before C++11, you would take the address of the vector's first
element to get an equivalent pointer, if the vector isn't empty, these
both methods are interchangeable:</p>
<p>int* p = &amp;v[0]; // combine subscript operator and 0 literal</p>
<p>int* p = &amp;v.front(); // explicitly reference the first
element</p>
<p><em><strong>Note:</strong></em> If the vector is empty, v[0] and
v.front() are undefined and cannot be used.</p>
<p>When storing the base address of the vector's data, note that many
operations (such as push_back, resize, etc.) can</p>
<p>change the data memory location of the vector, thus invalidating
previous data pointers. For example:</p>
<p>std::vector v;</p>
<p>int* p = v.data();</p>
<p>v.resize(42); // internal memory location changed; value of p is now
invalid</p>
<p>Section 49.8: Finding an Element in std::vector</p>
<p><a href="http://en.cppreference.com/w/cpp/algorithm/find">The
function std::find</a>, defined in the <a
href="http://en.cppreference.com/w/cpp/algorithm"><strong>&lt;algorithm&gt;</strong>
header, can be used to find an element in a</a> std::vector.</p>
<p>std::find uses the operator== to compare elements for equality. It
returns an iterator to the first element in the range that compares
equal to the value.</p>
<p>If the element in question is not found, std::find returns
std::vector::end (or std::vector::cend if the vector is const).</p>
<p>Version &lt; C++11</p>
<p>static const int arr[] = {5, 4, 3, 2, 1};</p>
<p>std::vector v (arr, arr + sizeof(arr) / sizeof(arr[0]) );</p>
<p>std::vector::iterator it = std::find(v.begin(), v.end(), 4);
std::vector::difference_type index = std::distance(v.begin(), it); //
`it` points to the second element of the vector, `index` is 1</p>
<p>std::vector::iterator missing = std::find(v.begin(), v.end(), 10);
std::vector::difference_type index_missing = std::distance(v.begin(),
missing); // `missing` is v.end(), `index_missing` is 5 (ie. size of the
vector)</p>
<p>Version ≥ C++11</p>
<p>std::vector v { 5, 4, 3, 2, 1 };</p>
<p>auto it = std::find(v.begin(), v.end(), 4);</p>
<p>auto index = std::distance(v.begin(), it);</p>
<p>// `it` points to the second element of the vector, `index` is 1</p>
<p>auto missing = std::find(v.begin(), v.end(), 10);</p>
<p>auto index_missing = std::distance(v.begin(), missing); // `missing`
is v.end(), `index_missing` is 5 (ie. size of the vector)</p>
<p>If you need to perform many searches in a large vector, then you may
want to consider sorting the vector first,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 277</p>
<p><span id="before_using_the_binary_search_a" class="anchor"></span><a
href="http://en.cppreference.com/w/cpp/algorithm/binary_search">before
using the binary_search</a> algorithm.</p>
<p>To find the first element in a vector that satisfies a condition,
std::find_if can be used. In addition to the two</p>
<p>parameters given to std::find, std::find_if accepts a third argument
which is a function object or function pointer to a predicate function.
The predicate should accept an element from the container as an argument
and</p>
<p>return a value convertible to bool, without modifying the
container:</p>
<p>Version &lt; C++11</p>
<p>bool isEven(int val) {</p>
<p>return (val % 2 == 0);</p>
<p>}</p>
<p>struct moreThan {</p>
<p>moreThan(int limit) : _limit(limit) {}</p>
<p>bool operator()(int val) {</p>
<p>return val &gt; _limit;</p>
<p>}</p>
<p>int _limit;</p>
<p>};</p>
<p>static const int arr[] = {1, 3, 7, 8};</p>
<p>std::vector v (arr, arr + sizeof(arr) / sizeof(arr[0]) );</p>
<p>std::vector::iterator it = std::find_if(v.begin(), v.end(), isEven);
// `it` points to 8, the first even element</p>
<p>std::vector::iterator missing = std::find_if(v.begin(), v.end(),
moreThan(10)); // `missing` is v.end(), as no element is greater than
10</p>
<p>Version ≥ C++11</p>
<p>// find the first value that is even</p>
<p>std::vector v = {1, 3, 7, 8};</p>
<p>auto it = std::find_if(v.begin(), v.end(), [](int val){return val % 2
== 0;}); // `it` points to 8, the first even element</p>
<p>auto missing = std::find_if(v.begin(), v.end(), [](int val){return
val &gt; 10;}); // `missing` is v.end(), as no element is greater than
10</p>
<p>Section 49.9: Concatenating Vectors</p>
<p>One std::vector can be append to another by using the member function
<a
href="http://en.cppreference.com/w/cpp/container/vector/insert">insert():</a></p>
<p>std::vector a = {0, 1, 2, 3, 4};</p>
<p>std::vector b = {5, 6, 7, 8, 9};</p>
<p>a.insert(a.end(), b.begin(), b.end());</p>
<p>However, this solution fails if you try to append a vector to itself,
because the standard specifies that iterators given</p>
<p>to insert() must not be from the same range as the receiver object's
elements.</p>
<p>Version ≥ c++11</p>
<p><a href="http://en.cppreference.com/w/cpp/iterator/begin">Instead of
using the vector's member functions, the functions std::begin()</a> and
<a href="http://en.cppreference.com/w/cpp/iterator/end">std::end() can
be used:</a></p>
<p>a.insert(std::end(a), std::begin(b), std::end(b));</p>
<p>This is a more general solution, for example, because b can also be
an array. However, also this solution doesn't</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 278</p>
<p><span id="allow_you_to_append_a_vector_to"
class="anchor"></span>allow you to append a vector to itself.</p>
<p>If the order of the elements in the receiving vector doesn't matter,
considering the number of elements in each</p>
<p>vector can avoid unnecessary copy operations:</p>
<p>if (b.size() &lt; a.size())</p>
<p>a.insert(a.end(), b.begin(), b.end());</p>
<p>else</p>
<p>b.insert(b.end(), a.begin(), a.end());</p>
<p>Section 49.10: Matrices Using Vectors</p>
<p>Vectors can be used as a 2D matrix by defining them as a vector of
vectors.</p>
<p>A matrix with 3 rows and 4 columns with each cell initialised as 0
can be defined as:</p>
<p>std::vector &gt; matrix(3, std::vector(4));</p>
<p>Version ≥ C++11</p>
<p>The syntax for initializing them using initialiser lists or otherwise
are similar to that of a normal vector.</p>
<p>std::vector&gt; matrix = { {0,1,2,3},</p>
<p>{4,5,6,7},</p>
<p>{8,9,10,11}</p>
<p>};</p>
<p>Values in such a vector can be accessed similar to a 2D array</p>
<p>int var = matrix[0][2];</p>
<p>Iterating over the entire matrix is similar to that of a normal
vector but with an extra dimension.</p>
<p>for(int i = 0; i &lt; 3; ++i)</p>
<p>{</p>
<p>for(int j = 0; j &lt; 4; ++j)</p>
<p>{</p>
<p>std::cout &lt;&lt; matrix[i][j] &lt;&lt; std::endl;</p>
<p>}</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>for(auto&amp; row: matrix)</p>
<p>{</p>
<p>for(auto&amp; col : row)</p>
<p>{</p>
<p>std::cout &lt;&lt; col &lt;&lt; std::endl;</p>
<p>}</p>
<p>}</p>
<p>A vector of vectors is a convenient way to represent a matrix but
it's not the most efficient: individual vectors are</p>
<p>scattered around memory and the data structure isn't cache
friendly.</p>
<p>Also, in a proper matrix, the length of every row must be the same
(this isn't the case for a vector of vectors). The</p>
<p>additional flexibility can be a source of errors.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 279</p>
<p><span id="Section_49_11__Using_a_Sorted_Ve"
class="anchor"></span>Section 49.11: Using a Sorted Vector for Fast
Element Lookup</p>
<p><a href="http://en.cppreference.com/w/cpp/header/algorithm">The
<strong>&lt;algorithm&gt;</strong></a> header provides a number of
useful functions for working with sorted vectors.</p>
<p>An important prerequisite for working with sorted vectors is that the
stored values are comparable with &lt;.</p>
<p><a href="http://en.cppreference.com/w/cpp/algorithm/sort">An unsorted
vector can be sorted by using the function std::sort()</a>:</p>
<p>std::vector v;</p>
<p>// add some code here to fill v with some elements
std::sort(v.begin(), v.end());</p>
<p>Sorted vectors allow efficient element lookup using the function <a
href="http://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound().
Unlike</a> <a
href="http://en.cppreference.com/w/cpp/algorithm/find">std::find()</a>,
this</p>
<p>performs an efficient binary search on the vector. The downside is
that it only gives valid results for sorted input ranges:</p>
<p>// search the vector for the first element with value 42
std::vector::iterator it = std::lower_bound(v.begin(), v.end(), 42); if
(it != v.end() &amp;&amp; *it == 42) {</p>
<p>// we found the element!</p>
<p>}</p>
<p><em><strong>Note:</strong></em> If the requested value is not part of
the vector, std::lower_bound() will return an iterator to the first
element</p>
<p>that is <em>greater</em> than the requested value. This behavior
allows us to insert a new element at its right place in an</p>
<p>already sorted vector:</p>
<p>int const new_element = 33;</p>
<p>v.insert(std::lower_bound(v.begin(), v.end(), new_element),
new_element);</p>
<p>If you need to insert a lot of elements at once, it might be more
efficient to call push_back() for all them first and</p>
<p>then call std::sort() once all elements have been inserted. In this
case, the increased cost of the sorting can pay off against the reduced
cost of inserting new elements at the end of the vector and not in the
middle.</p>
<p>If your vector contains multiple elements of the same value,
std::lower_bound() will try to return an iterator to the</p>
<p>first element of the searched value. However, if you need to insert a
new element <em>after</em> the last element of the</p>
<p>searched value, you should use the function <a
href="http://en.cppreference.com/w/cpp/algorithm/upper_bound">std::upper_bound()
as this will cause less shifting around of</a> elements:</p>
<p>v.insert(std::upper_bound(v.begin(), v.end(), new_element),
new_element);</p>
<p>If you need both the upper bound and the lower bound iterators, you
can use the function <a
href="http://en.cppreference.com/w/cpp/algorithm/equal_range">std::equal_range()
to</a></p>
<p>retrieve both of them efficiently with one call:</p>
<p>std::pair::iterator,</p>
<p>std::vector::iterator&gt; rg = std::equal_range(v.begin(), v.end(),
42); std::vector::iterator lower_bound = rg.first; std::vector::iterator
upper_bound = rg.second;</p>
<p>In order to test whether an element exists in a sorted vector
(although not specific to vectors), you can use the</p>
<p><a
href="http://en.cppreference.com/w/cpp/algorithm/binary_search">function
std::binary_search()</a>:</p>
<p>bool exists = std::binary_search(v.begin(), v.end(),
value_to_find);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 280</p>
<p><span id="Section_49_12__Reducing_the_Capa"
class="anchor"></span>Section 49.12: Reducing the Capacity of a
Vector</p>
<p>A std::vector automatically increases its capacity upon insertion as
needed, but it never reduces its capacity after</p>
<p>element removal.</p>
<p>// Initialize a vector with 100 elements</p>
<p>std::vector v(100);</p>
<p>// The vector's capacity is always at least as large as its size auto
const old_capacity = v.capacity();</p>
<p>// old_capacity &gt;= 100</p>
<p>// Remove half of the elements</p>
<p>v.erase(v.begin() + 50, v.end()); // Reduces the size from 100 to 50
(v.size() == 50),</p>
<p>// but not the capacity (v.capacity() == old_capacity)</p>
<p>To reduce its capacity, we can copy the contents of a vector to a new
temporary vector. The new vector will have the</p>
<p>minimum capacity that is needed to store all elements of the original
vector. If the size reduction of the original vector was significant,
then the capacity reduction for the new vector is likely to be
significant. We can then swap</p>
<p>the original vector with the temporary one to retain its minimized
capacity:</p>
<p>std::vector(v).swap(v);</p>
<p>Version ≥ C++11</p>
<p>In C++11 we can use the shrink_to_fit() member function for a similar
effect:</p>
<p>v.shrink_to_fit();</p>
<p>Note: The shrink_to_fit() member function is a request and doesn't
guarantee to reduce capacity.</p>
<p>Section 49.13: Vector size and capacity</p>
<p><strong>Vector size</strong> is simply the number of elements in the
vector:</p>
<p>1. Current vector <strong>size</strong> is queried by size() member
function. Convenience empty() function returns true if size</p>
<p>is 0:</p>
<p>vector v = { 1, 2, 3 }; // size is 3</p>
<p>const vector::size_type size = v.size();</p>
<p>cout &lt;&lt; size &lt;&lt; endl; // prints 3</p>
<p>cout &lt;&lt; boolalpha &lt;&lt; v.empty() &lt;&lt; endl; // prints
false</p>
<p>2. Default constructed vector starts with a size of 0:</p>
<p>vector v; // size is 0</p>
<p>cout &lt;&lt; v.size() &lt;&lt; endl; // prints 0</p>
<p>3. Adding N elements to vector increases <strong>size</strong> by N
(e.g. by push_back(), insert() or resize() functions).</p>
<p>4. Removing N elements from vector decreases <strong>size</strong> by
N (e.g. by pop_back(), erase() or clear() functions).</p>
<p>5. Vector has an implementation-specific upper limit on its size, but
you are likely to run out of RAM before</p>
<p>reaching it:</p>
<p>vector v;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 281</p>
<p>const vector::size_type max_size = v.max_size(); cout &lt;&lt;
max_size &lt;&lt; endl; // prints some large number v.resize( max_size
); // probably won't work</p>
<p>v.push_back( 1 ); // definitely won't work</p>
<p>Common mistake: <strong>size</strong> is not necessarily (or even
usually) int:</p>
<p>// !!!bad!!!evil!!!</p>
<p>vector v_bad( N, 1 ); // constructs large N size vector for( int i =
0; i &lt; v_bad.size(); ++i ) { // size is not supposed to be int!</p>
<p>do_something( v_bad[i] );</p>
<p>}</p>
<p><strong>Vector capacity</strong> differs from <strong>size</strong>.
While <strong>size</strong> is simply how many elements the vector
currently has, <strong>capacity</strong> is for</p>
<p>how many elements it allocated/reserved memory for. That is useful,
because too frequent (re)allocations of too</p>
<p>large sizes can be expensive.</p>
<p>1. Current vector <strong>capacity</strong> is queried by capacity()
member function. <strong>Capacity</strong> is always greater or equal
to</p>
<p>size<strong>:</strong></p>
<p>vector v = { 1, 2, 3 }; // size is 3, capacity is &gt;= 3 const
vector::size_type capacity = v.capacity(); cout &lt;&lt; capacity
&lt;&lt; endl; // prints number &gt;= 3</p>
<p>2. You can manually reserve capacity by reserve( N ) function (it
changes vector capacity to N):</p>
<p>// !!!bad!!!evil!!!</p>
<p>vector v_bad;</p>
<p>for( int i = 0; i &lt; 10000; ++i ) {</p>
<p>v_bad.push_back( i ); // possibly lot of reallocations</p>
<p>}</p>
<p>// good</p>
<p>vector v_good;</p>
<p>v_good.reserve( 10000 ); // good! only one allocation for( int i = 0;
i &lt; 10000; ++i ) {</p>
<p>v_good.push_back( i ); // no allocations needed anymore</p>
<p>}</p>
<p>3. You can request for the excess capacity to be released by
shrink_to_fit() (but the implementation doesn't</p>
<p>have to obey you). This is useful to conserve used memory:</p>
<p>vector v = { 1, 2, 3, 4, 5 }; // size is 5, assume capacity is 6
v.shrink_to_fit(); // capacity is 5 (or possibly still 6) cout &lt;&lt;
boolalpha &lt;&lt; v.capacity() == v.size() &lt;&lt; endl; // prints
likely true (but possibly false)</p>
<p>Vector partly manages capacity automatically, when you add elements
it may decide to grow. Implementers like to</p>
<p>use 2 or 1.5 for the grow factor (golden ratio would be the ideal
value - but is impractical due to being rational</p>
<p>number). On the other hand vector usually do not automatically
shrink. For example:</p>
<p>vector v; // capacity is possibly (but not guaranteed) to be 0
v.push_back( 1 ); // capacity is some starter value, likely 1 v.clear();
// size is 0 but capacity is still same as before!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 282</p>
<p><span id="v_____1__2__3__4_______size_is_4" class="anchor"></span>v =
{ 1, 2, 3, 4 }; // size is 4, and lets assume capacity is 4.
v.push_back( 5 ); // capacity grows - let's assume it grows to 6 (1.5
factor) v.push_back( 6 ); // no change in capacity</p>
<p>v.push_back( 7 ); // capacity grows - let's assume it grows to 9 (1.5
factor) // and so on</p>
<p>v.pop_back(); v.pop_back(); v.pop_back(); v.pop_back(); // capacity
stays the same</p>
<p>Section 49.14: Iterator/Pointer Invalidation</p>
<p>Iterators and pointers pointing into an std::vector can become
invalid, but only when performing certain</p>
<p>operations. Using invalid iterators/pointers will result in undefined
behavior.</p>
<p>Operations which invalidate iterators/pointers include:</p>
<p>Any insertion operation which changes the capacity of the vector will
invalidate <em>all</em> iterators/pointers:</p>
<p>vector v(5); // Vector has a size of 5; capacity is unknown. int *p1
= &amp;v[0];</p>
<p>v.push_back(2); // p1 may have been invalidated, since the capacity
was unknown.</p>
<p>v.reserve(20); // Capacity is now at least 20.</p>
<p>int *p2 = &amp;v[0];</p>
<p>v.push_back(4); // p2 is *not* invalidated, since the size of `v` is
now 7. v.insert(v.end(), 30, 9); // Inserts 30 elements at the end. The
size exceeds the</p>
<p>// requested capacity of 20, so `p2` is (probably) invalidated.</p>
<p>int *p3 = &amp;v[0];</p>
<p>v.reserve(v.capacity() + 20); // Capacity exceeded, thus `p3` is
invalid.</p>
<p>Version ≥ C++11</p>
<p>auto old_cap = v.capacity();</p>
<p>v.shrink_to_fit();</p>
<p>if(old_cap != v.capacity())</p>
<p>// Iterators were invalidated.</p>
<p>Any insertion operation, which does not increase the capacity, will
still invalidate iterators/pointers pointing</p>
<p>to elements at the insertion position and past it. This includes the
end iterator:</p>
<p>vector v(5);</p>
<p>v.reserve(20); // Capacity is at least 20.</p>
<p>int *p1 = &amp;v[0];</p>
<p>int *p2 = &amp;v[3];</p>
<p>v.insert(v.begin() + 2, 5, 0); // `p2` is invalidated, but since the
capacity</p>
<p>// did not change, `p1` remains valid.</p>
<p>int *p3 = &amp;v[v.size()-1];</p>
<p>v.push_back(10); // The capacity did not change, so `p3` and `p1`
remain valid.</p>
<p>Any removal operation will invalidate iterators/pointers pointing to
the removed elements and to any elements past the removed elements. This
includes the end iterator:</p>
<p>vector v(10);</p>
<p>int *p1 = &amp;v[0];</p>
<p>int *p2 = &amp;v[5];</p>
<p>v.erase(v.begin() + 3, v.end()); // `p2` is invalid, but `p1` remains
valid.</p>
<p>operator= (copy, move, or otherwise) and clear() will invalidate all
iterators/pointers pointing into the</p>
<p>vector.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 283</p>
<p><span id="Section_49_15__Find_max_and_min"
class="anchor"></span>Section 49.15: Find max and min Element and
Respective</p>
<p>Index in a Vector</p>
<p>To find the largest or smallest element stored in a vector, you can
use the methods <a
href="http://en.cppreference.com/w/cpp/algorithm/max_element">std::max_element</a>
and</p>
<p><a
href="http://en.cppreference.com/w/cpp/algorithm/min_element">std::min_element</a>,
respectively. These methods are defined in <a
href="http://en.cppreference.com/w/cpp/algorithm"><strong>&lt;algorithm&gt;</strong>
header. If several elements are</a></p>
<p>equivalent to the greatest (smallest) element, the methods return the
iterator to the first such element. Return v.end() for empty
vectors.</p>
<p>std::vector v = {5, 2, 8, 10, 9};</p>
<p>int maxElementIndex = std::max_element(v.begin(),v.end())- v.begin();
int maxElement = *std::max_element(v.begin(), v.end());</p>
<p>int minElementIndex = std::min_element(v.begin(),v.end())- v.begin();
int minElement = *std::min_element(v.begin(), v.end());</p>
<p>std::cout &lt;&lt; "maxElementIndex:" &lt;&lt; maxElementIndex
&lt;&lt; ", maxElement:" &lt;&lt; maxElement &lt;&lt;
'<strong>\n</strong>'; std::cout &lt;&lt; "minElementIndex:" &lt;&lt;
minElementIndex &lt;&lt; ", minElement:" &lt;&lt; minElement &lt;&lt;
'<strong>\n</strong>';</p>
<p>Output:</p>
<p>maxElementIndex:3, maxElement:10</p>
<p>minElementIndex:1, minElement:2</p>
<p>Version ≥ C++11</p>
<p>The minimum and maximum element in a vector can be retrieved at the
same time by using the method</p>
<p><a
href="http://en.cppreference.com/w/cpp/minmax_element">std::minmax_element</a><a
href="http://en.cppreference.com/w/cpp/algorithm">, which is also
defined in <strong>&lt;algorithm&gt;</strong></a> header:</p>
<p>std::vector v = {5, 2, 8, 10, 9};</p>
<p>auto minmax = std::minmax_element(v.begin(), v.end());</p>
<p>std::cout &lt;&lt; "minimum element: " &lt;&lt; *minmax.first
&lt;&lt; '<strong>\n</strong>'; std::cout &lt;&lt; "maximum element: "
&lt;&lt; *minmax.second &lt;&lt; '<strong>\n</strong>';</p>
<p>Output:</p>
<p>minimum element: 2</p>
<p>maximum element: 10</p>
<p>Section 49.16: Converting an array to std::vector</p>
<p>An array can easily be converted into a std::vector <a
href="http://en.cppreference.com/w/cpp/iterator/begin">by using
std::begin</a> <a
href="http://en.cppreference.com/w/cpp/iterator/end">and
std::end:</a></p>
<p>Version ≥ C++11</p>
<p>int values[5] = { 1, 2, 3, 4, 5 }; // source array</p>
<p>std::vector v(std::begin(values), std::end(values)); // copy array to
new vector</p>
<p>for(auto &amp;x: v)</p>
<p>std::cout &lt;&lt; x &lt;&lt; " ";</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 284</p>
<p><span id="1_2_3_4_5" class="anchor"></span>1 2 3 4 5</p>
<p>int main(int argc, char* argv[]) {</p>
<p>// convert main arguments into a vector of strings.</p>
<p>std::vector args(argv, argv + argc); }</p>
<p>A C++11 initializer_list&lt;&gt; can also be used to initialize the
vector at once</p>
<p>initializer_list arr = { 1,2,3,4,5 };</p>
<p>vector vec1 {arr};</p>
<p>for (auto &amp; i : vec1)</p>
<p>cout &lt;&lt; i &lt;&lt; endl;</p>
<p>Section 49.17: Functions Returning Large Vectors</p>
<p>Version ≥ C++11</p>
<p>In C++11, compilers are required to implicitly move from a local
variable that is being returned. Moreover, most</p>
<p>compilers can perform copy elision in many cases and elide the move
altogether. As a result of this, returning large</p>
<p>objects that can be moved cheaply no longer requires special
handling:</p>
<p>#include</p>
<p>#include</p>
<p>// If the compiler is unable to perform named return value
optimization (NRVO) // and elide the move altogether, it is required to
move from v into the return value. std::vector fillVector(int a, int b)
{</p>
<p>std::vector v;</p>
<p>v.reserve(b-a+1);</p>
<p>for (int i = a; i &lt;= b; i++) {</p>
<p>v.push_back(i);</p>
<p>}</p>
<p>return v; // implicit move</p>
<p>}</p>
<p>int main() { // declare and fill vector</p>
<p>std::vector vec = fillVector(1, 10);</p>
<p>// print vector</p>
<p>for (auto value : vec)</p>
<p>std::cout &lt;&lt; value &lt;&lt; " "; // this will print "1 2 3 4 5
6 7 8 9 10 "</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Version &lt; C++11</p>
<p>Before C++11, copy elision was already allowed and implemented by
most compilers. However, due to the absence of move semantics, in legacy
code or code that has to be compiled with older compiler versions which
don't</p>
<p>implement this optimization, you can find vectors being passed as
output arguments to prevent the unneeded copy:</p>
<p>#include</p>
<p>#include</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 285</p>
<p>// passing a std::vector by reference</p>
<p>void fillVectorFrom_By_Ref(int a, int b, std::vector &amp;v) {</p>
<p>assert(v.empty());</p>
<p>v.reserve(b-a+1);</p>
<p>for (int i = a; i &lt;= b; i++) {</p>
<p>v.push_back(i);</p>
<p>}</p>
<p>}</p>
<p>int main() {// declare vector</p>
<p>std::vector vec;</p>
<p>// fill vector</p>
<p>fillVectorFrom_By_Ref(1, 10, vec);</p>
<p>// print vector</p>
<p>for (std::vector::const_iterator it = vec.begin(); it != vec.end();
++it) std::cout &lt;&lt; *it &lt;&lt; " "; // this will print "1 2 3 4 5
6 7 8 9 10 "</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 286</p>
<p><span id="Chapter_50__std__map_1" class="anchor"></span>Chapter 50:
std::map</p>
<p>To use any of std::map or std::multimap the header file
<strong>&lt;map&gt;</strong> should be included.</p>
<p>std::map and std::multimap both keep their elements sorted according
to the ascending order of keys. In case of std::multimap, no sorting
occurs for the values of the same key.</p>
<p>The basic difference between std::map and std::multimap is that the
std::map one does not allow duplicate</p>
<p>values for the same key where std::multimap does.</p>
<p>Maps are implemented as binary search trees. So search(), insert(),
erase() takes Θ(log n) time in</p>
<p>average. For constant time operation use std::unordered_map.</p>
<p>size() and empty() functions have Θ(1) time complexity, number of
nodes is cached to avoid walking through tree each time these functions
are called.</p>
<p>Section 50.1: Accessing elements</p>
<p><a href="http://en.cppreference.com/w/cpp/container/map">An std::map
takes</a> (key, value) pairs as input.</p>
<p><a href="http://en.cppreference.com/w/cpp/container/map">Consider the
following example of std::map initialization:</a></p>
<p>std::map &lt; std::string, int &gt; ranking {
std::make_pair("stackoverflow", 2),</p>
<p>std::make_pair("docs-beta", 1) };</p>
<p><a href="http://en.cppreference.com/w/cpp/container/map">In an
std::map</a> , elements can be inserted as follows:</p>
<p>ranking["stackoverflow"]=2;</p>
<p>ranking["docs-beta"]=1;</p>
<p>In the above example, if the key stackoverflow is already present,
its value will be updated to 2. If it isn't already present, a new entry
will be created.</p>
<p><a href="http://en.cppreference.com/w/cpp/container/map">In an
std::map</a>, elements can be accessed directly by giving the key as an
index:</p>
<p>std::cout &lt;&lt; ranking[ "stackoverflow" ] &lt;&lt; std::endl;</p>
<p>Note that using the operator[] on the map will actually <em>insert a
new value</em> with the queried key into the map. This means that you
cannot use it on a const std::map, even if the key is already stored in
the map. To prevent this</p>
<p>insertion, check if the element exists (for example by using find())
or use at() as described below.</p>
<p>Version ≥ C++11</p>
<p>Elements of a std::map can be accessed with at():</p>
<p>std::cout &lt;&lt; ranking.at("stackoverflow") &lt;&lt;
std::endl;</p>
<p>Note that at() will throw an std::out_of_range exception if the
container does not contain the requested element.</p>
<p>In both containers std::map <a
href="http://en.cppreference.com/w/cpp/container/multimap">and
std::multimap, elements can be accessed using iterators:</a></p>
<p>Version ≥ C++11</p>
<p>// Example using begin()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 287</p>
<p><span id="std__multimap___int__std__string"
class="anchor"></span>std::multimap &lt; int, std::string &gt; mmp {
std::make_pair(2, "stackoverflow"),</p>
<p>std::make_pair(1, "docs-beta"),</p>
<p>std::make_pair(2, "stackexchange") }; auto it = mmp.begin();</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; " : " &lt;&lt; it-&gt;second
&lt;&lt; std::endl; // Output: "1 : docs-beta" it++;</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; " : " &lt;&lt; it-&gt;second
&lt;&lt; std::endl; // Output: "2 : stackoverflow" it++;</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; " : " &lt;&lt; it-&gt;second
&lt;&lt; std::endl; // Output: "2 : stackexchange"</p>
<p>// Example using rbegin()</p>
<p>std::map &lt; int, std::string &gt; mp { std::make_pair(2,
"stackoverflow"),</p>
<p>std::make_pair(1, "docs-beta"),</p>
<p>std::make_pair(2, "stackexchange") }; auto it2 = mp.rbegin();</p>
<p>std::cout &lt;&lt; it2-&gt;first &lt;&lt; " : " &lt;&lt;
it2-&gt;second &lt;&lt; std::endl; // Output: "2 : stackoverflow"
it2++;</p>
<p>std::cout &lt;&lt; it2-&gt;first &lt;&lt; " : " &lt;&lt;
it2-&gt;second &lt;&lt; std::endl; // Output: "1 : docs-beta"</p>
<p>Section 50.2: Inserting elements</p>
<p>An element can be inserted into a std::map only if its key is not
already present in the map. Given for example:</p>
<p>std::map&lt; std::string, size_t &gt; fruits_count;</p>
<p>A key-value pair is inserted into a std::map through the insert()
member function. It requires a pair as an</p>
<p>argument:</p>
<p>fruits_count.insert({"grapes", 20});</p>
<p>fruits_count.insert(make_pair("orange", 30));</p>
<p>fruits_count.insert(pair("banana", 40));
fruits_count.insert(map::value_type("cherry", 50));</p>
<p>The insert() function returns a pair consisting of an iterator and a
bool value:</p>
<p>If the insertion was successful, the iterator points to the newly
inserted element, and the bool value is</p>
<p>true.</p>
<p>If there was already an element with the same key, the insertion
fails. When that happens, the iterator</p>
<p>points to the element causing the conflict, and the bool is value is
false.</p>
<p>The following method can be used to combine insertion and searching
operation:</p>
<p>auto success = fruits_count.insert({"grapes", 20}); if
(!success.second) { // we already have 'grapes' in the map</p>
<p>success.first-&gt;second += 20; // access the iterator to update the
value</p>
<p>}</p>
<p>For convenience, the std::map container provides the subscript
operator to access elements in the map and</p>
<p>to insert new ones if they don't exist:</p>
<p>fruits_count["apple"] = 10;</p>
<p>While simpler, it prevents the user from checking if the element
already exists. If an element is missing, std::map::operator[]
implicitly creates it, initializing it with the default constructor
before overwriting it</p>
<p>with the supplied value.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 288</p>
<p><span id="insert___can_be_used_to_add_seve"
class="anchor"></span>insert() can be used to add several elements at
once using a braced list of pairs. This version of insert() returns
void:</p>
<p>fruits_count.insert({{"apricot", 1}, {"jackfruit", 1}, {"lime", 1},
{"mango", 7}});</p>
<p>insert() can also be used to add elements by using iterators denoting
the begin and end of value_type values:</p>
<p>std::map&lt; std::string, size_t &gt; fruit_list{ {"lemon", 0},
{"olive", 0}, {"plum", 0}}; fruits_count.insert(fruit_list.begin(),
fruit_list.end());</p>
<p>Example:</p>
<p>std::map fruits_count;</p>
<p>std::string fruit;</p>
<p>while(std::cin &gt;&gt; fruit){</p>
<p>// insert an element with 'fruit' as key and '1' as value // (if the
key is already stored in fruits_count, insert does nothing) auto ret =
fruits_count.insert({fruit, 1});</p>
<p>if(!ret.second){ // 'fruit' is already in the map</p>
<p>++ret.first-&gt;second; // increment the counter</p>
<p>}</p>
<p>}</p>
<p>Time complexity for an insertion operation is O(log n) because
std::map are implemented as trees.</p>
<p>Version ≥ C++11</p>
<p>A pair can be constructed explicitly using make_pair() and
emplace():</p>
<p>std::map&lt; std::string , int &gt; runs;</p>
<p>runs.emplace("Babe Ruth", 714);</p>
<p>runs.insert(make_pair("Barry Bonds", 762));</p>
<p>If we know where the new element will be inserted, then we can use
emplace_hint() to specify an iterator hint. If</p>
<p>the new element can be inserted just before hint, then the insertion
can be done in constant time. Otherwise it behaves in the same way as
emplace():</p>
<p>std::map&lt; std::string , int &gt; runs;</p>
<p>auto it = runs.emplace("Barry Bonds", 762); // get iterator to the
inserted element // the next element will be before "Barry Bonds", so it
is inserted before 'it' runs.emplace_hint(it, "Babe Ruth", 714);</p>
<p>Section 50.3: Searching in std::map or in std::multimap</p>
<p>There are several ways to search a key in std::map or in
std::multimap.</p>
<p>To get the iterator of the first occurrence of a key, the find()
function can be used. It returns end() if the key does not exist.</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} };</p>
<p>auto it = mmp.find(6);</p>
<p>if(it!=mmp.end())</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second
&lt;&lt; std::endl; //prints: 6, 5</p>
<p>else</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 289</p>
<p><span id="std__cout_____Value_does_not_exi"
class="anchor"></span>std::cout &lt;&lt; "Value does not exist!"
&lt;&lt; std::endl;</p>
<p>it = mmp.find(66);</p>
<p>if(it!=mmp.end())</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second
&lt;&lt; std::endl;</p>
<p>else</p>
<p>std::cout &lt;&lt; "Value does not exist!" &lt;&lt; std::endl; //
This line would be executed.</p>
<p>Another way to find whether an entry exists in std::map or in
std::multimap is using the count() function,</p>
<p>which counts how many values are associated with a given key. Since
std::map associates only one value with each key, its count() function
can only return 0 (if the key is not present) or 1 (if it is). For</p>
<p>std::multimap, count() can return values greater than 1 since there
can be several values associated with the same key.</p>
<p>std::map&lt; int , int &gt; mp{ {1, 2}, {3, 4}, {6, 5}, {8, 9}, {3,
4}, {6, 7} };</p>
<p>if(mp.count(3) &gt; 0) // 3 exists as a key in map</p>
<p>std::cout &lt;&lt; "The key exists!" &lt;&lt; std::endl; // This line
would be executed.</p>
<p>else</p>
<p>std::cout &lt;&lt; "The key does not exist!" &lt;&lt; std::endl;</p>
<p>If you only care whether some element exists, find is strictly
better: it documents your intent and, for</p>
<p>multimaps , it can stop once the first matching element has been
found.</p>
<p>In the case of std::multimap, there could be several elements having
the same key. To get this range, the</p>
<p>equal_range() function is used which returns std::pair having
iterator lower bound (inclusive) and upper</p>
<p>bound (exclusive) respectively. If the key does not exist, both
iterators would point to end().</p>
<p>auto eqr = mmp.equal_range(6);</p>
<p>auto st = eqr.first, en = eqr.second;</p>
<p>for(auto it = st; it != en; ++it){</p>
<p>std::cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second
&lt;&lt; std::endl;</p>
<p>}</p>
<p>// prints: 6, 5</p>
<p>// 6, 7</p>
<p>Section 50.4: Initializing a std::map or std::multimap</p>
<p>std::map and std::multimap both can be initialized by providing
key-value pairs separated by comma. Key-value pairs could be provided by
either {key, value} or can be explicitly created by std::make_pair(key,
value). As</p>
<p>std::map does not allow duplicate keys and comma operator performs
right to left, the pair on right would be overwritten with the pair with
same key on the left.</p>
<p>std::multimap &lt; int, std::string &gt; mmp { std::make_pair(2,
"stackoverflow"),</p>
<p>std::make_pair(1, "docs-beta"),</p>
<p>std::make_pair(2, "stackexchange") }; // 1 docs-beta</p>
<p>// 2 stackoverflow</p>
<p>// 2 stackexchange</p>
<p>std::map &lt; int, std::string &gt; mp { std::make_pair(2,
"stackoverflow"),</p>
<p>std::make_pair(1, "docs-beta"),</p>
<p>std::make_pair(2, "stackexchange") }; // 1 docs-beta</p>
<p>// 2 stackoverflow</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 290</p>
<p><span id="Both_could_be_initialized_with_i"
class="anchor"></span>Both could be initialized with iterator.</p>
<p>// From std::map or std::multimap iterator</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{6, 8}, {3, 4},</p>
<p>{6, 7} };</p>
<p>// {1, 2}, {3, 4}, {3, 4}, {6, 5}, {6, 8}, {6, 7}, {8, 9}</p>
<p>auto it = mmp.begin();</p>
<p>std::advance(it,3); //moved cursor on first {6, 5}</p>
<p>std::map&lt; int, int &gt; mp(it, mmp.end()); // {6, 5}, {8, 9}</p>
<p>//From std::pair array</p>
<p>std::pair&lt; int, int &gt; arr[10];</p>
<p>arr[0] = {1, 3};</p>
<p>arr[1] = {1, 5};</p>
<p>arr[2] = {2, 5};</p>
<p>arr[3] = {0, 1};</p>
<p>std::map&lt; int, int &gt; mp(arr,arr+4); //{0 , 1}, {1, 3}, {2,
5}</p>
<p>//From std::vector of std::pair</p>
<p>std::vector&lt; std::pair &gt; v{ {1, 5}, {5, 1}, {3, 6}, {3, 2} };
std::multimap&lt; int, int &gt; mp(v.begin(), v.end());</p>
<p>// {1, 5}, {3, 6}, {3, 2}, {5, 1}</p>
<p>Section 50.5: Checking number of elements</p>
<p>The container std::map has a member function empty(), which returns
true or false, depending on whether the map is empty or not. The member
function size() returns the number of element stored in a std::map
container:</p>
<p>std::map rank {{"facebook.com", 1} ,{"google.com", 2},
{"youtube.com", 3}}; if(!rank.empty()){</p>
<p>std::cout &lt;&lt; "Number of elements in the rank map: " &lt;&lt;
rank.size() &lt;&lt; std::endl; }</p>
<p>else{</p>
<p>std::cout &lt;&lt; "The rank map is empty" &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 50.6: Types of Maps</p>
<p>Regular Map</p>
<p>A map is an associative container, containing key-value pairs.</p>
<p>#include</p>
<p>#include</p>
<p>std::map fruits_count;</p>
<p>In the above example, std::string is the <em>key</em> type, and
size_t is a <em>value</em>.</p>
<p>The key acts as an index in the map. Each key must be unique, and
must be ordered.</p>
<p>If you need mutliple elements with the same key, consider using
multimap (explained below)</p>
<p>If your value type does not specify any ordering, or you want to
override the default ordering, you may</p>
<p>provide one:</p>
<p>#include</p>
<p>#include</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 291</p>
<p><span id="_include_1" class="anchor"></span>#include</p>
<p>struct StrLess {</p>
<p>bool operator()(const std::string&amp; a, const std::string&amp; b)
{</p>
<p>return strncmp(a.c_str(), b.c_str(), 8)&lt;0;</p>
<p>//compare only up to 8 first characters</p>
<p>}</p>
<p>}</p>
<p>std::map fruits_count2;</p>
<p>If StrLess comparator returns false for two keys, they are considered
the same even if their actual contents</p>
<p>differ.</p>
<p>Multi-Map</p>
<p>Multimap allows multiple key-value pairs with the same key to be
stored in the map. Otherwise, its interface and</p>
<p>creation is very similar to the regular map.</p>
<p>#include</p>
<p>#include</p>
<p>std::multimap fruits_count;</p>
<p>std::multimap fruits_count2;</p>
<p>Hash-Map (Unordered Map)</p>
<p>A hash map stores key-value pairs similar to a regular map. It does
not order the elements with respect to the key</p>
<p><a href="https://en.wikipedia.org/wiki/Hash_function">though.
Instead, a hash</a> value for the key is used to quickly access the
needed key-value pairs.</p>
<p>#include</p>
<p>#include</p>
<p>std::unordered_map fruits_count;</p>
<p>Unordered maps are usually faster, but the elements are not stored in
any predictable order. For example, iterating</p>
<p>over all elements in an unordered_map gives the elements in a
seemingly random order.</p>
<p>Section 50.7: Deleting elements</p>
<p>Removing all elements:</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} }; mmp.clear(); //empty multimap</p>
<p>Removing element from somewhere with the help of iterator:</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} };</p>
<p>// {1, 2}, {3, 4}, {3, 4}, {6, 5}, {6, 7}, {8, 9}</p>
<p>auto it = mmp.begin();</p>
<p>std::advance(it,3); // moved cursor on first {6, 5} mmp.erase(it); //
{1, 2}, {3, 4}, {3, 4}, {6, 7}, {8, 9}</p>
<p>Removing all elements in a range:</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} };</p>
<p>// {1, 2}, {3, 4}, {3, 4}, {6, 5}, {6, 7}, {8, 9}</p>
<p>auto it = mmp.begin();</p>
<p>auto it2 = it;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 292</p>
<p><span id="it______moved_first_cursor_on_fi"
class="anchor"></span>it++; //moved first cursor on first {3, 4}</p>
<p>std::advance(it2,3); //moved second cursor on first {6, 5}
mmp.erase(it,it2); // {1, 2}, {6, 5}, {6, 7}, {8, 9}</p>
<p>Removing all elements having a provided value as key:</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} };</p>
<p>// {1, 2}, {3, 4}, {3, 4}, {6, 5}, {6, 7}, {8, 9}</p>
<p>mmp.erase(6); // {1, 2}, {3, 4}, {3, 4}, {8, 9}</p>
<p>Removing elements that satisfy a predicate pred:</p>
<p>std::map m;</p>
<p>auto it = m.begin();</p>
<p>while (it != m.end())</p>
<p>{</p>
<p>if (pred(*it))</p>
<p>it = m.erase(it);</p>
<p>else</p>
<p>++it;</p>
<p>}</p>
<p>Section 50.8: Iterating over std::map or std::multimap</p>
<p>std::map or std::multimap could be traversed by the following
ways:</p>
<p>std::multimap&lt; int , int &gt; mmp{ {1, 2}, {3, 4}, {6, 5}, {8, 9},
{3, 4}, {6, 7} };</p>
<p>//Range based loop - since C++11</p>
<p>for(const auto &amp;x: mmp)</p>
<p>std::cout&lt;&lt; x.first &lt;&lt;":"&lt;&lt; x.second &lt;&lt;
std::endl;</p>
<p>//Forward iterator for loop: it would loop through first element to
last element //it will be a std::map&lt; int, int &gt;::iterator</p>
<p>for (auto it = mmp.begin(); it != mmp.end(); ++it)</p>
<p>std::cout&lt;&lt; it-&gt;first &lt;&lt;":"&lt;&lt; it-&gt;second
&lt;&lt; std::endl; //Do something with iterator</p>
<p>//Backward iterator for loop: it would loop through last element to
first element //it will be a std::map&lt; int, int
&gt;::reverse_iterator for (auto it = mmp.rbegin(); it != mmp.rend();
++it) std::cout&lt;&lt; it-&gt;first &lt;&lt;" "&lt;&lt; it-&gt;second
&lt;&lt; std::endl; //Do something with iterator</p>
<p>While iterating over a std::map or a std::multimap, the use of auto
is preferred to avoid useless implicit</p>
<p>conversions (see <a
href="http://stackoverflow.com/questions/32510183/can-the-use-of-c11s-auto-improve-performance">this
SO answer for more details).</a></p>
<p>Section 50.9: Creating std::map with user-defined types as</p>
<p>key</p>
<p>In order to be able to use a class as the key in a map, all that is
required of the key is that it be copiable and assignable. The ordering
within the map is defined by the third argument to the template (and the
argument to</p>
<p>the constructor, if used). This <em>defaults</em> to std::less, which
defaults to the &lt; operator, but there's no requirement to use the
defaults. Just write a comparison operator (preferably as a functional
object):</p>
<p>struct CmpMyType</p>
<p>{</p>
<p>bool operator()( MyType const&amp; lhs, MyType const&amp; rhs ) const
{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 293</p>
<p>// ...</p>
<p>}</p>
<p>};</p>
<p><a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">In C++,
the "compare" predicate must be a strict weak ordering</a>. In
particular, compare(X,X) must return false for any X. i.e. if
CmpMyType()(a, b) returns true, then CmpMyType()(b, a) must return
false, and if both return false,</p>
<p>the elements are considered equal (members of the same equivalence
class).</p>
<p>Strict Weak Ordering</p>
<p>This is a mathematical term to define a relationship between two
objects.</p>
<p>Its definition is:</p>
<p>Two objects x and y are equivalent if both f(x, y) and f(y, x) are
false. Note that an object is always (by the</p>
<p>irreflexivity invariant) equivalent to itself.</p>
<p>In terms of C++ this means if you have two objects of a given type,
you should return the following values when compared with the operator
&lt;.</p>
<p>X a;</p>
<p>X b;</p>
<p>Condition: Test: Result</p>
<p>a is equivalent to b: a &lt; b false</p>
<p>a is equivalent to b b &lt; a false</p>
<p>a is less than b a &lt; b true</p>
<p>a is less than b b &lt; a false</p>
<p>b is less than a a &lt; b false</p>
<p>b is less than a b &lt; a true</p>
<p>How you define equivalent/less is totally dependent on the type of
your object.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 294</p>
<p><span id="Chapter_51__std__optional_1" class="anchor"></span>Chapter
51: std::optional</p>
<p>Section 51.1: Using optionals to represent the absence of a</p>
<p>value</p>
<p>Before C++17, having pointers with a value of nullptr commonly
represented the absence of a value. This is a good</p>
<p>solution for large objects that have been dynamically allocated and
are already managed by pointers. However, this solution does not work
well for small or primitive types such as int, which are rarely ever
dynamically allocated or</p>
<p>managed by pointers. std::optional provides a viable solution to this
common problem.</p>
<p>In this example, struct Person is defined. It is possible for a
person to have a pet, but not necessary. Therefore,</p>
<p>the pet member of Person is declared with an std::optional
wrapper.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct Animal {</p>
<p>std::string name;</p>
<p>};</p>
<p>struct Person {</p>
<p>std::string name;</p>
<p>std::optional pet;</p>
<p>};</p>
<p>int main() {</p>
<p>Person person;</p>
<p>person.name = "John";</p>
<p>if (person.pet) {</p>
<p>std::cout &lt;&lt; person.name &lt;&lt; "'s pet's name is "
&lt;&lt;</p>
<p>person.pet-&gt;name &lt;&lt; std::endl;</p>
<p>}</p>
<p>else {</p>
<p>std::cout &lt;&lt; person.name &lt;&lt; " is alone." &lt;&lt;
std::endl;</p>
<p>}</p>
<p>}</p>
<p>Section 51.2: optional as return value</p>
<p>std::optional divide(float a, float b) {</p>
<p>if (b!=0.f) return a/b;</p>
<p>return {};</p>
<p>}</p>
<p>Here we return either the fraction a/b, but if it is not defined
(would be infinity) we instead return the empty optional.</p>
<p>A more complex case:</p>
<p>template</p>
<p>auto find_if( Range&amp;&amp; r, Pred&amp;&amp; p ) {</p>
<p>using std::begin; using std::end;</p>
<p>auto b = begin(r), e = end(r);</p>
<p>auto r = std::find_if(b, e , p );</p>
<p>using iterator = decltype(r);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 295</p>
<p><span id="if__r__e" class="anchor"></span>if (r==e)</p>
<p>return std::optional();</p>
<p>return std::optional(r);</p>
<p>}</p>
<p>template</p>
<p>auto find( Range&amp;&amp; r, T const&amp; t ) {</p>
<p>return find_if( std::forward(r), [&amp;t](auto&amp;&amp; x){return
x==t;} );</p>
<p>}</p>
<p>find( some_range, 7 ) searches the container or range some_range for
something equal to the number 7.</p>
<p>find_if does it with a predicate.</p>
<p>It returns either an empty optional if it was not found, or an
optional containing an iterator tothe element if it was.</p>
<p>This allows you to do:</p>
<p>if (find( vec, 7 )) {</p>
<p>// code</p>
<p>}</p>
<p>or even</p>
<p>if (auto oit = find( vec, 7 )) {</p>
<p>vec.erase(*oit);</p>
<p>}</p>
<p>without having to mess around with begin/end iterators and tests.</p>
<p>Section 51.3: value_or</p>
<p>void print_name( std::ostream&amp; os, std::optional const&amp; name
) { std::cout "Name is: " &lt;&lt; name.value_or("") &lt;&lt;
'<strong>\n</strong>'; }</p>
<p>value_or either returns the value stored in the optional, or the
argument if there is nothing store there.</p>
<p>This lets you take the maybe-null optional and give a default
behavior when you actually need a value. By doing it</p>
<p>this way, the "default behavior" decision can be pushed back to the
point where it is best made and immediately needed, instead of
generating some default value deep in the guts of some engine.</p>
<p>Section 51.4: Introduction</p>
<p>Optionals (also known as Maybe types) are used to represent a type
whose contents may or may not be present. They are implemented in C++17
as the std::optional class. For example, an object of type
std::optional</p>
<p>may contain some value of type int, or it may contain no value.</p>
<p>Optionals are commonly used either to represent a value that may not
exist or as a return type from a function that</p>
<p>can fail to return a meaningful result.</p>
<p>Other approaches to optional</p>
<p>There are many other approach to solving the problem that
std::optional solves, but none of them are quite</p>
<p>complete: using a pointer, using a sentinel, or using a pair.</p>
<p>Optional vs Pointer</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 296</p>
<p><span id="In_some_cases__we_can_provide_a" class="anchor"></span>In
some cases, we can provide a pointer to an existing object or nullptr to
indicate failure. But this is limited to those cases where objects
already exist - optional, as a value type, can also be used to return
new objects without</p>
<p>resorting to memory allocation.</p>
<p>Optional vs Sentinel</p>
<p>A common idiom is to use a special value to indicate that the value
is meaningless. This may be 0 or -1 for integral</p>
<p>types, or nullptr for pointers. However, this reduces the space of
valid values (you cannot differentiate between a</p>
<p>valid 0 and a meaningless 0) and many types do not have a natural
choice for the sentinel value.</p>
<p>Optional vs std::pair&lt;bool, T&gt;</p>
<p>Another common idiom is to provide a pair, where one of the elements
is a bool indicating whether or not the</p>
<p>value is meaningful.</p>
<p>This relies upon the value type being default-constructible in the
case of error, which is not possible for some types and possible but
undesirable for others. An optional, in the case of error, does not need
to construct anything.</p>
<p>Section 51.5: Using optionals to represent the failure of a</p>
<p>function</p>
<p>Before C++17, a function typically represented failure in one of
several ways:</p>
<p>A null pointer was returned.</p>
<p>e.g. Calling a function Delegate *App::get_delegate() on an App
instance that did not have a</p>
<p>delegate would return nullptr.</p>
<p>This is a good solution for objects that have been dynamically
allocated or are large and managed by</p>
<p>pointers, but isn't a good solution for small objects that are
typically stack-allocated and passed by copying.</p>
<p>A specific value of the return type was reserved to indicate
failure.</p>
<p>e.g. Calling a function unsigned shortest_path_distance(Vertex a,
Vertex b) on two vertices that</p>
<p>are not connected may return zero to indicate this fact.</p>
<p>The value was paired together with a bool to indicate is the returned
value was meaningful.</p>
<p>e.g. Calling a function std::pair parse(const std::string &amp;str)
with a string</p>
<p>argument that is not an integer would return a pair with an undefined
int and a bool set to false.</p>
<p>In this example, John is given two pets, Fluffy and Furball. The
function Person::pet_with_name() is then called to</p>
<p>retrieve John's pet Whiskers. Since John does not have a pet named
Whiskers, the function fails and std::nullopt is returned instead.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct Animal {</p>
<p>std::string name;</p>
<p>};</p>
<p>struct Person {</p>
<p>std::string name;</p>
<p>std::vector pets;</p>
<p>std::optional pet_with_name(const std::string &amp;name) {</p>
<p>for (const Animal &amp;pet : pets) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 297</p>
<p>if (pet.name == name) {</p>
<p>return pet;</p>
<p>}</p>
<p>}</p>
<p>return std::nullopt;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>Person john;</p>
<p>john.name = "John";</p>
<p>Animal fluffy;</p>
<p>fluffy.name = "Fluffy";</p>
<p>john.pets.push_back(fluffy);</p>
<p>Animal furball;</p>
<p>furball.name = "Furball";</p>
<p>john.pets.push_back(furball);</p>
<p>std::optional whiskers = john.pet_with_name("Whiskers");</p>
<p>if (whiskers) {</p>
<p>std::cout &lt;&lt; "John has a pet named Whiskers." &lt;&lt;
std::endl;</p>
<p>}</p>
<p>else {</p>
<p>std::cout &lt;&lt; "Whiskers must not belong to John." &lt;&lt;
std::endl;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 298</p>
<p><span id="Chapter_52__std__function__To_wr_1"
class="anchor"></span>Chapter 52: std::function: To wrap any</p>
<p>element that is callable</p>
<p>Section 52.1: Simple usage</p>
<p>#include</p>
<p>#include</p>
<p>std::function myFuncObj; void theFunc(int i, const std::string&amp;
s)</p>
<p>{</p>
<p>std::cout &lt;&lt; s &lt;&lt; ": " &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>myFuncObj = theFunc;</p>
<p>myFuncObj(10, "hello world");</p>
<p>}</p>
<p>Section 52.2: std::function used with std::bind</p>
<p>Think about a situation where we need to callback a function with
arguments. std::function used with std::bind</p>
<p>gives a very powerful design construct as shown below.</p>
<p>class A</p>
<p>{</p>
<p>public:</p>
<p>std::function m_CbFunc = nullptr;</p>
<p>void foo()</p>
<p>{</p>
<p>if (m_CbFunc)</p>
<p>{</p>
<p>m_CbFunc(100, "event fired");</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>class B</p>
<p>{</p>
<p>public:</p>
<p>B()</p>
<p>{</p>
<p>auto aFunc = std::bind(&amp;B::eventHandler, this,
std::placeholders::_1,</p>
<p>std::placeholders::_2);</p>
<p>anObjA.m_CbFunc = aFunc;</p>
<p>}</p>
<p>void eventHandler(int i, const std::string&amp; s)</p>
<p>{</p>
<p>std::cout &lt;&lt; s &lt;&lt; ": " &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p>void DoSomethingOnA()</p>
<p>{</p>
<p>anObjA.foo();</p>
<p>}</p>
<p>A anObjA;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 299</p>
<p><span id="int_main_int_argc__char__argv" class="anchor"></span>int
main(int argc, char *argv[])</p>
<p>{</p>
<p>B anObjB;</p>
<p>anObjB.DoSomethingOnA();</p>
<p>}</p>
<p>Section 52.3: Binding std::function to a dierent callable</p>
<p>types</p>
<p>/*</p>
<p>* This example show some ways of using std::function to call * a)
C-like function</p>
<p>* b) class-member function</p>
<p>* c) operator()</p>
<p>* d) lambda function</p>
<p>*</p>
<p>* Function call can be made:</p>
<p>* a) with right arguments</p>
<p>* b) argumens with different order, types and count */</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using std::cout;</p>
<p>using std::endl;</p>
<p>using namespace std::placeholders;</p>
<p>// simple function to be called</p>
<p>double foo_fn(int x, float y, double z)</p>
<p>{</p>
<p>double res = x + y + z;</p>
<p>std::cout &lt;&lt; "foo_fn called with arguments: "</p>
<p>&lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z</p>
<p>&lt;&lt; " result is : " &lt;&lt; res</p>
<p>&lt;&lt; std::endl;</p>
<p>return res;</p>
<p>}</p>
<p>// structure with member function to call</p>
<p>struct foo_struct</p>
<p>{</p>
<p>// member function to call</p>
<p>double foo_fn(int x, float y, double z)</p>
<p>{</p>
<p>double res = x + y + z;</p>
<p>std::cout &lt;&lt; "foo_struct::foo_fn called with arguments: "</p>
<p>&lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z</p>
<p>&lt;&lt; " result is : " &lt;&lt; res</p>
<p>&lt;&lt; std::endl;</p>
<p>return res;</p>
<p>}</p>
<p>// this member function has different signature - but it can be used
too // please not that argument order is changed too</p>
<p>double foo_fn_4(int x, double z, float y, long xx) {</p>
<p>double res = x + y + z + xx;</p>
<p>std::cout &lt;&lt; "foo_struct::foo_fn_4 called with arguments: "</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 300</p>
<p>&lt;&lt; x &lt;&lt; ", " &lt;&lt; z &lt;&lt; ", " &lt;&lt; y &lt;&lt;
", " &lt;&lt; xx</p>
<p>&lt;&lt; " result is : " &lt;&lt; res</p>
<p>&lt;&lt; std::endl;</p>
<p>return res;</p>
<p>}</p>
<p>// overloaded operator() makes whole object to be callable double
operator()(int x, float y, double z)</p>
<p>{</p>
<p>double res = x + y + z;</p>
<p>std::cout &lt;&lt; "foo_struct::operator() called with arguments:
"</p>
<p>&lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z</p>
<p>&lt;&lt; " result is : " &lt;&lt; res</p>
<p>&lt;&lt; std::endl;</p>
<p>return res;</p>
<p>}</p>
<p>};</p>
<p>int main(void)</p>
<p>{</p>
<p>// typedefs</p>
<p>using function_type = std::function;</p>
<p>// foo_struct instance</p>
<p>foo_struct fs;</p>
<p>// here we will store all binded functions</p>
<p>std::vector bindings;</p>
<p>// var #1 - you can use simple function</p>
<p>function_type var1 = foo_fn;</p>
<p>bindings.push_back(var1);</p>
<p>// var #2 - you can use member function</p>
<p>function_type var2 = std::bind(&amp;foo_struct::foo_fn, fs, _1, _2,
_3); bindings.push_back(var2);</p>
<p>// var #3 - you can use member function with different signature //
foo_fn_4 has different count of arguments and types</p>
<p>function_type var3 = std::bind(&amp;foo_struct::foo_fn_4, fs, _1, _3,
_2, 0l); bindings.push_back(var3);</p>
<p>// var #4 - you can use object with overloaded operator()</p>
<p>function_type var4 = fs;</p>
<p>bindings.push_back(var4);</p>
<p>// var #5 - you can use lambda function</p>
<p>function_type var5 = [](int x, float y, double z)</p>
<p>{</p>
<p>double res = x + y + z;</p>
<p>std::cout &lt;&lt; "lambda called with arguments: "</p>
<p>&lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z</p>
<p>&lt;&lt; " result is : " &lt;&lt; res</p>
<p>&lt;&lt; std::endl;</p>
<p>return res;</p>
<p>};</p>
<p>bindings.push_back(var5);</p>
<p>std::cout &lt;&lt; "Test stored functions with arguments: x = 1, y =
2, z = 3"</p>
<p>&lt;&lt; std::endl;</p>
<p>for (auto f : bindings)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 301</p>
<p><span id="f_1__2__3" class="anchor"></span>f(1, 2, 3);</p>
<p>}</p>
<p><a href="http://ideone.com/VIbkkZ">Live</a></p>
<p>Output:</p>
<p>Test stored functions with arguments: x = 1, y = 2, z = 3 foo_fn
called with arguments: 1, 2, 3 result is : 6</p>
<p>foo_struct::foo_fn called with arguments: 1, 2, 3 result is : 6
foo_struct::foo_fn_4 called with arguments: 1, 3, 2, 0 result is : 6
foo_struct::operator() called with arguments: 1, 2, 3 result is : 6
lambda called with arguments: 1, 2, 3 result is : 6</p>
<p>Section 52.4: Storing function arguments in std::tuple</p>
<p>Some programs need so store arguments for future calling of some
function.</p>
<p>This example shows how to call any function with arguments stored in
std::tuple</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>// simple function to be called</p>
<p>double foo_fn(int x, float y, double z)</p>
<p>{</p>
<p>double res = x + y + z;</p>
<p>std::cout &lt;&lt; "foo_fn called. x = " &lt;&lt; x &lt;&lt; " y = "
&lt;&lt; y &lt;&lt; " z = " &lt;&lt; z</p>
<p>&lt;&lt; " res=" &lt;&lt; res;</p>
<p>return res;</p>
<p>}</p>
<p>// helpers for tuple unrolling</p>
<p>template struct seq {};</p>
<p>template struct gens : gens {}; template struct gens&lt;0, S...&gt;{
typedef seq type; };</p>
<p>// invocation helper</p>
<p>template</p>
<p>double call_fn_internal(const FN&amp; fn, const P&amp; params, const
seq) {</p>
<p>return fn(std::get<del>(params) ...);</del></p>
<p>}</p>
<p>// call function with arguments stored in std::tuple template</p>
<p>Ret call_fn(const std::function<del>&amp; fn,</del></p>
<p>const std::tuple<del>&amp; params)</del></p>
<p>{</p>
<p>return call_fn_internal(fn, params, typename
gens<del>::type());</del></p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>// arguments</p>
<p><del>std::tuple</del> t = std::make_tuple(1, 5, 10);</p>
<p>// function to call</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 302</p>
<p><span id="std__function_fn___foo_fn"
class="anchor"></span>std::function <del>fn = foo_fn;</del></p>
<p>// invoke a function with stored arguments</p>
<p>call_fn(fn, t);</p>
<p>}</p>
<p><a href="http://ideone.com/FZKALn">Live</a></p>
<p>Output:</p>
<p>foo_fn called. x = 1 y = 5 z = 10 res=16</p>
<p>Section 52.5: std::function with lambda and std::bind</p>
<p>#include</p>
<p>#include</p>
<p>using std::placeholders::_1; // to be used in std::bind example</p>
<p>int stdf_foobar (int x, std::function <del>moo) {</del></p>
<p>return x + moo(x); // std::function moo called</p>
<p>}</p>
<p>int foo (int x) { return 2+x; }</p>
<p>int foo_2 (int x, int y) { return 9*x + y; }</p>
<p>int main()</p>
<p>{</p>
<p>int a = 2;</p>
<p>/* Function pointers */</p>
<p>std::cout &lt;&lt; stdf_foobar(a, &amp;foo) &lt;&lt; std::endl; // 6
( 2 + (2+2) )</p>
<p>// can also be: stdf_foobar(2, foo)</p>
<p>/* Lambda expressions */</p>
<p>/* An unnamed closure from a lambda expression can be</p>
<p>* stored in a std::function object:</p>
<p>*/</p>
<p>int capture_value = 3;</p>
<p>std::cout &lt;&lt; stdf_foobar(a,</p>
<p>[capture_value](int param)-&gt; int { return 7 + capture_value *
param;</p>
<p>})</p>
<p>&lt;&lt; std::endl;</p>
<p>// result: 15 == value + (7 * capture_value * value) == 2 + (7 + 3 *
2)</p>
<p>/* std::bind expressions */</p>
<p>/* The result of a std::bind expression can be passed.</p>
<p>* For example by binding parameters to a function pointer call:</p>
<p>*/</p>
<p>int b = stdf_foobar(a, std::bind(foo_2, _1, 3));</p>
<p>std::cout &lt;&lt; b &lt;&lt; std::endl;</p>
<p>// b == 23 == 2 + ( 9*2 + 3 )</p>
<p>int c = stdf_foobar(a, std::bind(foo_2, 5, _1));</p>
<p>std::cout &lt;&lt; c &lt;&lt; std::endl;</p>
<p>// c == 49 == 2 + ( 9*5 + 2 )</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 303</p>
<p><span id="Section_52_6___function__overhea"
class="anchor"></span>Section 52.6: `function` overhead</p>
<p>std::function can cause significant overhead. Because
<del>std::function</del> has [value semantics][1], it must copy or</p>
<p>move the given callable into itself. But since it can take callables
of an arbitrary type, it will frequently have to</p>
<p>allocate memory dynamically to do this.</p>
<p>Some <del>function</del> implementations have so-called "small object
optimization", where small types (like function pointers, member
pointers, or functors with very little state) will be stored directly in
the <del>function</del> object. But even</p>
<p>this only works if the type is <del>noexcept</del> move
constructible. Furthermore, the C++ standard does not require that
all</p>
<p>implementations provide one.</p>
<p>Consider the following:</p>
<p>//Header file</p>
<p>using MyPredicate = std::function<del>;</del></p>
<p>void SortMyContainer(MyContainer &amp;C, const MyPredicate
&amp;pred);</p>
<p>//Source file</p>
<p>void SortMyContainer(MyContainer &amp;C, const MyPredicate &amp;pred)
{</p>
<p>std::sort(C.begin(), C.end(), pred);</p>
<p>}</p>
<p>A template parameter would be the preferred solution for
<del>SortMyContainer</del>, but let us assume that this is not</p>
<p>possible or desirable for whatever reason. <del>SortMyContainer</del>
does not need to store <del>pred</del> beyond its own call. And yet,
<del>pred</del> may well allocate memory if the functor given to it is
of some non-trivial size.</p>
<p>function allocates memory because it needs something to copy/move
into; <del>function</del> takes ownership of the</p>
<p>callable it is given. But <del>SortMyContainer</del> does not need to
<em>own</em> the callable; it's just referencing it. So using
<del>function</del></p>
<p>here is overkill; it may be efficient, but it may not.</p>
<p>There is no standard library function type that merely references a
callable. So an alternate solution will have to be</p>
<p>found, or you can choose to live with the overhead.</p>
<p>Also, <del>function</del> has no effective means to control where the
memory allocations for the object come from. Yes, it has constructors
that take an <del>allocator</del>, but [many implementations do not
implement them correctly... or even <em>at</em></p>
<p><em>all</em>][2].</p>
<p>Version ≥ C++17</p>
<p>The <del>function</del> constructors that take an
<del>allocator</del> no longer are part of the type. Therefore, there is
no way to</p>
<p>manage the allocation.</p>
<p>Calling a <del>function</del> is also slower than calling the
contents directly. Since any <del>function</del> instance could hold any
callable, the call through a <del>function</del> must be indirect. The
overhead of calling <del>function</del> is on the order of a virtual</p>
<p>function call.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 304</p>
<p><span id="Chapter_53__std__forward_list_1"
class="anchor"></span>Chapter 53: std::forward_list</p>
<p><del>std::forward_list</del> is a container that supports fast
insertion and removal of elements from anywhere in the</p>
<p>container. Fast random access is not supported. It is implemented as
a singly-linked list and essentially does not have any overhead compared
to its implementation in C. Compared to <del>std::list</del> this
container provides more</p>
<p>space efficient storage when bidirectional iteration is not
needed.</p>
<p>Section 53.1: Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const
std::forward_list<del>&amp; v) {</del></p>
<p>s.put('[');</p>
<p>char comma[3] = {'<strong><del>\0</del></strong>', ' ',
'<strong><del>\0</del></strong>'};</p>
<p>for (const auto&amp; e : v) {</p>
<p>s &lt;&lt; comma &lt;&lt; e;</p>
<p>comma[0] = ',';</p>
<p>}</p>
<p>return s &lt;&lt; ']';</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>// c++11 initializer list syntax:</p>
<p><del>std::forward_list</del> words1 {"the", "frogurt", "is", "also",
"cursed"};</p>
<p>std::cout &lt;&lt; "words1: " &lt;&lt; words1 &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>// words2 == words1</p>
<p><del>std::forward_list</del> words2(words1.begin(),
words1.end());</p>
<p>std::cout &lt;&lt; "words2: " &lt;&lt; words2 &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>// words3 == words1</p>
<p>std::forward_list <del>words3(words1);</del></p>
<p>std::cout &lt;&lt; "words3: " &lt;&lt; words3 &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>// words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}</p>
<p>std::forward_list <del>words4(5, "Mo");</del></p>
<p>std::cout &lt;&lt; "words4: " &lt;&lt; words4 &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>}</p>
<p>Output:</p>
<p>words1: [the, frogurt, is, also, cursed]</p>
<p>words2: [the, frogurt, is, also, cursed]</p>
<p>words3: [the, frogurt, is, also, cursed]</p>
<p>words4: [Mo, Mo, Mo, Mo, Mo]</p>
<p>Section 53.2: Methods</p>
<p>Method name Definition</p>
<p><del>operator=</del> assigns values to the container</p>
<p><del>assign</del> assigns values to the container</p>
<p><del>get_allocator</del> returns the associated allocator</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 305</p>
<h1 id="section">------ ------</h1>
<p>Element access</p>
<p><del>front</del> access the first element</p>
<p>------ ------</p>
<p>Iterators</p>
<p><del>before_begi</del>n returns an iterator to the element before
beginning</p>
<p><del>cbefore_begin</del> returns a constant iterator to the element
before beginning</p>
<p><del>begin</del> returns an iterator to the beginning</p>
<p><del>cbegin</del> returns a const iterator to the beginning</p>
<p><del>end</del> returns an iterator to the end</p>
<p><del>cend</del> returns a iterator to the end</p>
<p>Capacity</p>
<p><del>empty</del> checks whether the container is empty</p>
<p><del>max_size</del> returns the maximum possible number of
elements</p>
<p>Modifiers</p>
<p><del>clear</del> clears the contents</p>
<p><del>insert_after</del> inserts elements after an element</p>
<p><del>emplace_after</del> constructs elements in-place after an
element</p>
<p><del>erase_after</del> erases an element after an element</p>
<p><del>push_front</del> inserts an element to the beginning</p>
<p><del>emplace_front</del> constructs an element in-place at the
beginning</p>
<p><del>pop_front</del> removes the first element</p>
<p><del>resize</del> changes the number of elements stored</p>
<p><del>swap</del> swaps the contents</p>
<p>Operations</p>
<p><del>merge</del> merges two sorted lists</p>
<p><del>splice_after</del> moves elements from another forward_list</p>
<p><del>remove</del> removes elements satisfying specific criteria</p>
<p><del>remove_if</del> removes elements satisfying specific
criteria</p>
<p><del>reverse</del> reverses the order of the elements</p>
<p><del>unique</del> removes consecutive duplicate elements</p>
<p><del>sort</del> sorts the elements</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 306</p>
<p><span id="Chapter_54__std__pair_1" class="anchor"></span>Chapter 54:
std::pair</p>
<p>Section 54.1: Compare operators</p>
<p>Parameters of these operators are <del>lhs</del> and
<del>rhs</del></p>
<p>operator== tests if both elements on <del>lhs</del> and
<del>rhs</del> pair are equal. The return value is <del>true</del> if
both <del>lhs.first</del></p>
<p><del>== rhs.first AND</del> lhs.second == rhs.second<del>,
otherwise</del> false</p>
<p><del>std::pair</del> p1 = std::make_pair(1, 2);</p>
<p><del>std::pair</del> p2 = std::make_pair(2, 2);</p>
<p>if (p1 == p2)</p>
<p>std::cout &lt;&lt; "equals";</p>
<p>else</p>
<p>std::cout &lt;&lt; "not equal"//statement will show this, because
they are not identical</p>
<p>operator!= tests if any elements on <del>lhs</del> and <del>rhs</del>
pair are not equal. The return value is <del>true</del> if either
lhs.first != rhs.first OR <del>lhs.second != rhs.second</del>, otherwise
return <del>false</del>.</p>
<p>operator&lt; tests if <del>lhs.first</del>, returns true. Otherwise,
if rhs.first returns false. Otherwise, if lhs.second returns true,
otherwise, returns false.</p>
<p>operator&lt;= returns <del>!(rhs</del></p>
<p>operator&gt; returns <del>rhs</del></p>
<p>operator&gt;= returns <del>!(lhs</del></p>
<p>Another example with containers of pairs. It uses
<del>operator&lt;</del> because it needs to sort container.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p><del>std::vector</del>&gt; v = { {2, "baz"},</p>
<p>{2, "bar"},</p>
<p>{1, "foo"} };</p>
<p>std::sort(v.begin(), v.end());</p>
<p>for(const auto&amp; p: v) {</p>
<p>std::cout &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; "," &lt;&lt;
p.second &lt;&lt; ") ";</p>
<p>//output: (1,foo) (2,bar) (2,baz)</p>
<p>}</p>
<p>}</p>
<p>Section 54.2: Creating a Pair and accessing the elements</p>
<p>Pair allows us to treat two objects as one object. Pairs can be
easily constructed with the help of template function</p>
<p>std::make_pair<del>.</del></p>
<p>Alternative way is to create pair and assign its elements
(<del>first</del> and <del>second</del>) later.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 307</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p><del>std::pair</del> p = std::make_pair(1,2); //Creating the pair</p>
<p>std::cout &lt;&lt; p.first &lt;&lt; " " &lt;&lt; p.second &lt;&lt;
std::endl; //Accessing the elements</p>
<p>//We can also create a pair and assign the elements later</p>
<p>std::pair <del>p1;</del></p>
<p>p1.first = 3;</p>
<p>p1.second = 4;</p>
<p>std::cout &lt;&lt; p1.first &lt;&lt; " " &lt;&lt; p1.second &lt;&lt;
std::endl;</p>
<p>//We can also create a pair using a constructor</p>
<p><del>std::pair</del> p2 = std::pair(5, 6);</p>
<p>std::cout &lt;&lt; p2.first &lt;&lt; " " &lt;&lt; p2.second &lt;&lt;
std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 308</p>
<p><span id="Chapter_55__std__atomics_1" class="anchor"></span>Chapter
55: std::atomics</p>
<p>Section 55.1: atomic types</p>
<p>Each instantiation and full specialization of the
<del>std::atomic</del> template defines an atomic type. If one thread
writes to an atomic object while another thread reads from it, the
behavior is well-defined (see memory model for details</p>
<p>on data races)</p>
<p>In addition, accesses to atomic objects may establish inter-thread
synchronization and order non-atomic memory</p>
<p>accesses as specified by <del>std::memory_order</del>.</p>
<p>std::atomic may be instantiated with any <del>TriviallyCopyable type
T. std::atomic</del> is neither copyable nor</p>
<p>movable.</p>
<p>The standard library provides specializations of the std::atomic
template for the following types:</p>
<p>1. One full specialization for the type <del>bool</del> and its
typedef name is defined that is treated as a non-specialized</p>
<p><del>std::atomic</del> except that it has standard layout, trivial
default constructor, trivial destructors, and supports aggregate
initialization syntax:</p>
<p>Typedef name Full specialization</p>
<p>std::atomic_bool std::atomic</p>
<p>2)Full specializations and typedefs for integral types, as
follows:</p>
<p>Typedef name Full specialization</p>
<p>std::atomic_char std::atomic</p>
<p>std::atomic_char std::atomic</p>
<p>std::atomic_schar std::atomic</p>
<p>std::atomic_uchar std::atomic</p>
<p>std::atomic_short std::atomic</p>
<p>std::atomic_ushort std::atomic</p>
<p>std::atomic_int std::atomic</p>
<p>std::atomic_uint std::atomic</p>
<p>std::atomic_long std::atomic</p>
<p>std::atomic_ulong std::atomic</p>
<p>std::atomic_llong std::atomic</p>
<p>std::atomic_ullong std::atomic</p>
<p>std::atomic_char16_t std::atomic</p>
<p>std::atomic_char32_t std::atomic</p>
<p>std::atomic_wchar_t std::atomic</p>
<p>std::atomic_int8_t std::atomic</p>
<p>std::atomic_uint8_t std::atomic</p>
<p>std::atomic_int16_t std::atomic</p>
<p>std::atomic_uint16_t std::atomic</p>
<p>std::atomic_int32_t std::atomic</p>
<p>std::atomic_uint32_t std::atomic</p>
<p>std::atomic_int64_t std::atomic</p>
<p>std::atomic_uint64_t std::atomic</p>
<p>std::atomic_int_least8_t std::atomic</p>
<p>std::atomic_uint_least8_t std::atomic</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 309</p>
<p>std::atomic_int_least16_t std::atomic</p>
<p>std::atomic_uint_least16_t std::atomic</p>
<p>std::atomic_int_least32_t std::atomic</p>
<p>std::atomic_uint_least32_t std::atomic</p>
<p>std::atomic_int_least64_t std::atomic</p>
<p>std::atomic_uint_least64_t std::atomic</p>
<p>std::atomic_int_fast8_t std::atomic</p>
<p>std::atomic_uint_fast8_t std::atomic</p>
<p>std::atomic_int_fast16_t std::atomic</p>
<p>std::atomic_uint_fast16_t std::atomic</p>
<p>std::atomic_int_fast32_t std::atomic</p>
<p>std::atomic_uint_fast32_t std::atomic</p>
<p>std::atomic_int_fast64_t std::atomic</p>
<p>std::atomic_uint_fast64_t std::atomic</p>
<p>std::atomic_intptr_t std::atomic</p>
<p>std::atomic_uintptr_t std::atomic</p>
<p>std::atomic_size_t std::atomic</p>
<p>std::atomic_ptrdiff_t std::atomic</p>
<p>std::atomic_intmax_t std::atomic</p>
<p>std::atomic_uintmax_t std::atomic</p>
<p>Simple example of using std::atomic_int</p>
<p><del>#include</del> // std::cout</p>
<p><del>#include</del> // std::atomic, std::memory_order_relaxed
#include // std::thread</p>
<p>std::atomic_int foo (0);</p>
<p>void set_foo(int x) {</p>
<p>foo.store(x,std::memory_order_relaxed); // set value atomically }</p>
<p>void print_foo() {</p>
<p>int x;</p>
<p>do {</p>
<p>x = foo.load(std::memory_order_relaxed); // get value atomically</p>
<p>} while (x==0);</p>
<p>std::cout &lt;&lt; "foo: " &lt;&lt; x &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>}</p>
<p>int main ()</p>
<p>{</p>
<p>std::thread first (print_foo);</p>
<p>std::thread second (set_foo,10);</p>
<p>first.join();</p>
<p>//second.join();</p>
<p>return 0;</p>
<p>}</p>
<p>//output: foo: 10</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 310</p>
<p><span id="Chapter_56__std__variant_1" class="anchor"></span>Chapter
56: std::variant</p>
<p>Section 56.1: Create pseudo-method pointers</p>
<p>This is an advanced example.</p>
<p>You can use variant for light weight type erasure.</p>
<p>template</p>
<p>struct pseudo_method {</p>
<p>F f;</p>
<p>// enable C++17 class type deduction:</p>
<p>pseudo_method( F&amp;&amp; fin ):f(std::move(fin)) {}</p>
<p><del>// Koenig lookup operator-&gt;*, as this is a pseudo-method it
is appropriate: template</del> // maybe add SFINAE test that LHS is
actually a variant. friend decltype(auto) operator-&gt;*(
Variant&amp;&amp; var, pseudo_method const&amp; method ) {</p>
<p>// var-&gt;*method returns a lambda that perfect forwards a function
call, // behaving like a method pointer basically:</p>
<p>return [&amp;](auto&amp;&amp;...args)-&gt;decltype(auto) {</p>
<p>// use visit to get the type of the variant:</p>
<p>return std::visit(</p>
<p>[&amp;](auto&amp;&amp; self)-&gt;decltype(auto) {</p>
<p>// decltype(x)(x) is perfect forwarding in a lambda: return method.f(
decltype(self)(self), decltype(args)(args)... );</p>
<p>},</p>
<p>std::forward<em><del>(var)</del></em></p>
<p>);</p>
<p>};</p>
<p>}</p>
<p>};</p>
<p>this creates a type that overloads <del>operator-&gt;*</del> with a
<del>Variant</del> on the left hand side.</p>
<p>// C++17 class type deduction to find template argument of `print`
here. // a pseudo-method lambda should take `self` as its first
argument, then // the rest of the arguments afterwards, and invoke the
action: pseudo_method print = [](auto&amp;&amp; self,
auto&amp;&amp;...args)-&gt;decltype(auto) {</p>
<p>return decltype(self)(self).print( decltype(args)(args)... );</p>
<p>};</p>
<p>Now if we have 2 types each with a <del>print</del> method:</p>
<p>struct A {</p>
<p>void print( std::ostream&amp; os ) const {</p>
<p>os &lt;&lt; "A";</p>
<p>}</p>
<p>};</p>
<p>struct B {</p>
<p>void print( std::ostream&amp; os ) const {</p>
<p>os &lt;&lt; "B";</p>
<p>}</p>
<p>};</p>
<p>note that they are unrelated types. We can:</p>
<p>std::variant <del>var = A{};</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 311</p>
<p><span id="_var___print__std__cout"
class="anchor"></span>(var-&gt;*print)(std::cout);</p>
<p>and it will dispatch the call directly to
<del>A::print(std::cout)</del> for us. If we instead initialized the
<del>var</del> with <del>B{}</del>, it would dispatch to
<del>B::print(std::cout)</del>.</p>
<p>If we created a new type C:</p>
<p>struct C {};</p>
<p>then:</p>
<p>std::variant <del>var = A{};</del></p>
<p>(var-&gt;*print)(std::cout);</p>
<p>will fail to compile, because there is no
<del>C.print(std::cout)</del> method.</p>
<p>Extending the above would permit free function <del>print</del>s to
be detected and used, possibly with use of <del>if constexpr</del></p>
<p>within the <del>print</del> pseudo-method.</p>
<p><a href="http://coliru.stacked-crooked.com/a/57f29d8406ad7b51">live
example currently using</a> <del>boost::variant</del> in place of
<del>std::variant</del>.</p>
<p>Section 56.2: Basic std::variant use</p>
<p>This creates a variant (a tagged union) that can store either an
<del>int</del> or a <del>string</del>.</p>
<p>std::variant&lt; int, std::string &gt; var;</p>
<p>We can store one of either type in it:</p>
<p>var = "hello"s;</p>
<p>And we can access the contents via <del>std::visit</del>:</p>
<p>// Prints "hello\n":</p>
<p>visit( [](auto&amp;&amp; e) {</p>
<p>std::cout &lt;&lt; e &lt;&lt; '<strong><del>\n</del></strong>';</p>
<p>}, var );</p>
<p>by passing in a polymorphic lambda or similar function object.</p>
<p>If we are certain we know what type it is, we can get it:</p>
<p>auto str = std::get<del>(var);</del></p>
<p>but this will throw if we get it wrong. <del>get_if</del>:</p>
<p>auto* str = std::get_if<del>(&amp;var);</del></p>
<p>returns <del>nullptr</del> if you guess wrong.</p>
<p>Variants guarantee no dynamic memory allocation (other than which is
allocated by their contained types). Only</p>
<p>one of the types in a variant is stored there, and in rare cases
(involving exceptions while assigning and no safe way to back out) the
variant can become empty.</p>
<p>Variants let you store multiple value types in one variable safely
and efficiently. They are basically smart, type-safe</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 312</p>
<p><span id="unions" class="anchor"></span>union<del>s.</del></p>
<p>Section 56.3: Constructing a `std::variant`</p>
<p>This does not cover allocators.</p>
<p>struct A {};</p>
<p>struct B { B()=default; B(B const&amp;)=default; B(int){}; }; struct
C { C()=delete; C(int) {}; C(C const&amp;)=default; }; struct D { D(
std::initializer_list <del>) {}; D(D const&amp;)=default; D()=default;
};</del></p>
<p><del>std::variant</del> var_ab0; // contains a A()</p>
<p><del>std::variant</del> var_ab1 = 7; // contains a B(7)</p>
<p><del>std::variant</del> var_ab2 = var_ab1; // contains a B(7)
std::variant var_abc0{ std::in_place_type, 7 }; // contains a C(7)
std::variant var_c0; // illegal, no default ctor for C std::variant
var_ad0( std::in_place_type, {1,3,3,4} ); // contains D{1,3,3,4}
std::variant var_ad1( std::in_place_index&lt;0&gt; ); // contains A{}
std::variant var_ad2( std::in_place_index&lt;1&gt;, {1,3,3,4} ); //
contains D{1,3,3,4}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 313</p>
<p><span id="Chapter_57__std__iomanip_1" class="anchor"></span>Chapter
57: std::iomanip</p>
<p>Section 57.1: std::setprecision</p>
<p>When used in an expression <del>out &lt;&lt; setprecision(n)</del> or
<del>in &gt;&gt; setprecision(n)</del>, sets the precision parameter of
the stream out or in to exactly n. Parameter of this function is
integer, which is new value for precision.</p>
<p>Example:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>const long double pi = std::acos(-1.L);</p>
<p>std::cout &lt;&lt; "default precision (6): " &lt;&lt; pi &lt;&lt;
'<strong><del>\n</del></strong>'</p>
<p>&lt;&lt; "std::precision(10): " &lt;&lt; std::setprecision(10)
&lt;&lt; pi &lt;&lt; '<strong><del>\n</del></strong>' &lt;&lt; "max
precision: "</p>
<p>&lt;&lt; std::setprecision(std::numeric_limits<del>::digits10 + 1)
&lt;&lt; pi &lt;&lt; '<strong>\n</strong>';</del></p>
<p>}</p>
<p>//Output</p>
<p>//default precision (6): 3.14159</p>
<p>//std::precision(10): 3.141592654</p>
<p>//max precision: 3.141592653589793239</p>
<p>Section 57.2: std::setfill</p>
<p>When used in an expression <del>out &lt;&lt; setfill(c)</del> sets
the fill character of the stream out to <del>c</del>.</p>
<p>Note: The current fill character may be obtained with
<del>std::ostream::fill</del>.</p>
<p>Example:</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "default fill: " &lt;&lt; std::setw(10) &lt;&lt;
42 &lt;&lt; '<strong><del>\n</del></strong>'</p>
<p>&lt;&lt; "setfill('*'): " &lt;&lt; std::setfill('*')</p>
<p>&lt;&lt; std::setw(10) &lt;&lt; 42 &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>}</p>
<p>//output::</p>
<p>//default fill: 42</p>
<p>//setfill('*'): ********42</p>
<p>Section 57.3: std::setiosflags</p>
<p>When used in an expression <del>out &lt;&lt; setiosflags(mask)</del>
or <del>in &gt;&gt; setiosflags(mask)</del>, sets all format flags of
the</p>
<p>stream out or in as specified by the mask.</p>
<p><del>List of all</del> std::ios_base::fmtflags <del>:</del></p>
<p><del>dec</del> - use decimal base for integer I/O</p>
<p><del>oct</del> - use octal base for integer I/O</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 314</p>
<p><del>hex</del> - use hexadecimal base for integer I/O</p>
<p>basefield - <del>dec|oct|hex|0</del> useful for masking
operations</p>
<p><del>left</del> - left adjustment(add fill characters to the
right)</p>
<p><del>right</del> - right adjustment (adds fill characters to the
left)</p>
<p><del>internal</del> - internal adjustment (adds fill characters to
the internal designated point)</p>
<p>adjustfield - <del>left|right|internal</del>. Useful for masking
operations <del>scientific</del> - generate floating point types using
scientific notation, or hex notation if combined with fixed</p>
<p><del>fixed</del> - generate floating point types using fixed
notation, or hex notation if combined with scientific floatfield -
<del>scientific|fixed|(scientific|fixed)|0</del>. Useful for masking
operations</p>
<p>boolalpha - insert and extract <del>bool</del> type in alphanumeric
format <del>showbase</del> - generate a prefix indicating the numeric
base for integer output, require the currency indicator in</p>
<p>monetary I/O</p>
<p><del>showpoint</del> - generate a decimal-point character
unconditionally for floating-point number output showpos - generate a
<del>+</del> character for non-negative numeric output</p>
<p><del>skipws</del> - skip leading whitespace before certain input
operations <del>unitbuf</del> flush the output after each output
operation</p>
<p><del>uppercase</del> - replace certain lowercase letters with their
uppercase equivalents in certain output output operations</p>
<p>Example of manipulators:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>int l_iTemp = 47;</p>
<p>std::cout&lt;&lt; std::resetiosflags(std::ios_base::basefield);</p>
<p>std::cout&lt;</p>
<p>//output: 57</p>
<p>std::cout&lt;&lt; std::resetiosflags(std::ios_base::basefield);</p>
<p>std::cout&lt;</p>
<p>//output: 2f</p>
<p>std::cout&lt;</p>
<p>//output 2F</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>//output: 00000000002f</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>//output: 47........</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>//output +#######47</p>
<p>double l_dTemp =-1.2;</p>
<p>double pi = 3.14159265359;</p>
<p>std::cout&lt;</p>
<p>//output +3.14159 -1.2</p>
<p>std::cout&lt;</p>
<p>//output -1.20000</p>
<p>std::cout&lt;</p>
<p>//output: +3.141593e+00</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 315</p>
<p><span id="std__cout" class="anchor"></span>std::cout&lt;</p>
<p>std::cout&lt;</p>
<p>//output: +3.141593</p>
<p>bool b = true;</p>
<p>std::cout&lt;</p>
<p>//output: true</p>
<p>return 0;</p>
<p>}</p>
<p>Section 57.4: std::setw</p>
<p>int val = 10;</p>
<p>// val will be printed to the extreme left end of the output console:
std::cout &lt;&lt; val &lt;&lt; std::endl;</p>
<p>// val will be printed in an output field of length 10 starting from
right end of the field:</p>
<p>std::cout &lt;&lt; std::setw(10) &lt;&lt; val &lt;&lt; std::endl;</p>
<p>This outputs:</p>
<p>10</p>
<p>10</p>
<p>1234567890</p>
<p>(where the last line is there to aid in seeing the character
offsets).</p>
<p>Sometimes we need to set the width of the output field, usually when
we need to get the output in some structured</p>
<p>and proper layout. That can be done using <strong>std::setw</strong>
of <strong>std::iomanip</strong>.</p>
<p>The syntax for <del>std::setw</del> is:</p>
<p>std::setw(int n)</p>
<p>where n is the length of the output field to be set</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 316</p>
<p><span id="Chapter_58__std__any_1" class="anchor"></span>Chapter 58:
std::any</p>
<p>Section 58.1: Basic usage</p>
<p>std::any an_object{ std::string("hello world") };</p>
<p>if (an_object.has_value()) {</p>
<p>std::cout &lt;&lt; std::any_cast<del>(an_object) &lt;&lt;
'<strong>\n</strong>'; }</del></p>
<p>try {</p>
<p>std::any_cast<del>(an_object);</del></p>
<p>} catch(std::bad_any_cast&amp;) {</p>
<p>std::cout &lt;&lt; "Wrong type<strong><del>\n</del></strong>";</p>
<p>}</p>
<p><del>std::any_cast</del>(an_object) = "42";</p>
<p>std::cout &lt;&lt; std::any_cast<del>(an_object) &lt;&lt;
'<strong>\n</strong>';</del></p>
<p>Output</p>
<p>hello world</p>
<p>Wrong type</p>
<p>42</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 317</p>
<p><span id="Chapter_59__std__set_and_std__mu_1"
class="anchor"></span>Chapter 59: std::set and std::multiset</p>
<p>set is a type of container whose elements are sorted and unique.
<del>multiset</del> is similar, but, in the case of
<del>multiset</del>,</p>
<p>multiple elements can have the same value.</p>
<p>Section 59.1: Changing the default sort of a set</p>
<p>set and <del>multiset</del> have default compare methods, but in some
cases you may need to overload them.</p>
<p>Let's imagine we are storing string values in a set, but we know
those strings contain only numeric values. By default the sort will be a
lexicographical string comparison, so the order won't match the
numerical sort. If you</p>
<p>want to apply a sort equivalent to what you would have with
<del>int</del> values, you need a functor to overload the compare
method:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct custom_compare final</p>
<p>{</p>
<p>bool operator() (const std::string&amp; left, const std::string&amp;
right) const {</p>
<p>int nLeft = atoi(left.c_str());</p>
<p>int nRight = atoi(right.c_str());</p>
<p>return nLeft &lt; nRight;</p>
<p>}</p>
<p>};</p>
<p>int main ()</p>
<p>{</p>
<p><del>std::set</del> sut({"1", "2", "5", "23", "6", "290"});</p>
<p>std::cout &lt;&lt; "### Default sort on std::set <del>:" &lt;&lt;
std::endl;</del></p>
<p>for (auto &amp;&amp;data: sut)</p>
<p>std::cout &lt;&lt; data &lt;&lt; std::endl;</p>
<p><del>std::set</del> sut_custom({"1", "2", "5", "23", "6", "290"},</p>
<p>custom_compare{}); //&lt; Compare object optional as its default
constructible.</p>
<p>std::cout &lt;&lt; std::endl &lt;&lt; "### Custom sort on set :"
&lt;&lt; std::endl;</p>
<p>for (auto &amp;&amp;data : sut_custom)</p>
<p>std::cout &lt;&lt; data &lt;&lt; std::endl;</p>
<p>auto compare_via_lambda = [](auto &amp;&amp;lhs, auto &amp;&amp;rhs){
return lhs &gt; rhs; }; using set_via_lambda = std::set<del>;</del></p>
<p>set_via_lambda sut_reverse_via_lambda({"1", "2", "5", "23", "6",
"290"},</p>
<p>compare_via_lambda);</p>
<p>std::cout &lt;&lt; std::endl &lt;&lt; "### Lambda sort on set :"
&lt;&lt; std::endl;</p>
<p>for (auto &amp;&amp;data : sut_reverse_via_lambda)</p>
<p>std::cout &lt;&lt; data &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output will be:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 318</p>
<p>### Default sort on std::set <del>:</del></p>
<p>1</p>
<p>2</p>
<p>23</p>
<p>290</p>
<p>5</p>
<p>6</p>
<p>### Custom sort on set :</p>
<p>1</p>
<p>2</p>
<p>5</p>
<p>6</p>
<p>23</p>
<p>290</p>
<p>### Lambda sort on set :</p>
<p>6</p>
<p>5</p>
<p>290</p>
<p>23</p>
<p>2</p>
<p>1</p>
<p>In the example above, one can find 3 different ways of adding compare
operations to the <del>std::set</del>, each of them is</p>
<p>useful in its own context.</p>
<p>Default sort</p>
<p>This will use the compare operator of the key (first template
argument). Often, the key will already provide a good</p>
<p>default for the <del>std::less</del> function. Unless this function
is specialized, it uses the operator&lt; of the object. This is
especially useful when other code also tries to use some ordering, as
this allows consistency over the whole code</p>
<p>base.</p>
<p>Writing the code this way, will reduce the effort to update your code
when the key changes is API, like: a class</p>
<p>containing 2 members which changes to a class containing 3 members.
By updating the <del>operator&lt;</del> in the class, all occurrences
will get updated.</p>
<p>As you might expect, using the default sort is a reasonable
default.</p>
<p>Custom sort</p>
<p>Adding a custom sort via an object with a compare operator is often
used when the default comparison doesn't</p>
<p>comply. In the example above this is because the strings are
referring to integers. In other cases, it's often used when you want to
compare (smart) pointers based upon the object they refer to or because
you need different</p>
<p>constraints for comparing (example: comparing <del>std::pair</del> by
the value of <del>first</del>).</p>
<p>When creating a compare operator, this should be a stable sorting. If
the result of the compare operator changes</p>
<p>after insert, you will have undefined behavior. As a good practice,
your compare operator should only use the constant data (const members,
const functions ...).</p>
<p>As in the example above, you will often encounter classes without
members as compare operators. This results in default constructors and
copy constructors. The default constructor allows you to omit the
instance at construction</p>
<p>time and the copy constructor is required as the set takes a copy of
the compare operator.</p>
<p>Lambda sort</p>
<p>Lambdas are a shorter way to write function objects. This allows
writing the compare operator on less lines, making</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 319</p>
<p><span id="the_overall_code_more_readable" class="anchor"></span>the
overall code more readable.</p>
<p>The disadvantage of the use of lambdas is that each lambda gets a
specific type at compile time, so</p>
<p><del>decltype(lambda)</del> will be different for each compilation of
the same compilation unit (cpp file) as over multiple compilation units
(when included via header file). For this reason, its recommended to use
function objects as</p>
<p>compare operator when used within header files.</p>
<p>This construction is often encountered when a <del>std::set</del> is
used within the local scope of a function instead, while</p>
<p>the function object is preferred when used as function arguments or
class members.</p>
<p>Other sort options</p>
<p>As the compare operator of <del>std::set</del> is a template
argument, all callable objects can be used as compare operator</p>
<p>and the examples above are only specific cases. The only restrictions
these callable objects have are:</p>
<p>They must be copy constructable</p>
<p>They must be callable with 2 arguments of the type of the key.
(implicit conversions are allowed, though not recommended as it can hurt
performance)</p>
<p>Section 59.2: Deleting values from a set</p>
<p>The most obvious method, if you just want to reset your set/multiset
to an empty one, is to use <del>clear</del>:</p>
<p>std::set <del>sut;</del></p>
<p>sut.insert(10);</p>
<p>sut.insert(15);</p>
<p>sut.insert(22);</p>
<p>sut.insert(3);</p>
<p>sut.clear(); //size of sut is 0</p>
<p>Then the <del>erase</del> method can be used. It offers some
possibilities looking somewhat equivalent to the insertion:</p>
<p>std::set <del>sut;</del></p>
<p><del>std::set</del>::iterator it;</p>
<p>sut.insert(10);</p>
<p>sut.insert(15);</p>
<p>sut.insert(22);</p>
<p>sut.insert(3);</p>
<p>sut.insert(30);</p>
<p>sut.insert(33);</p>
<p>sut.insert(45);</p>
<p>// Basic deletion</p>
<p>sut.erase(3);</p>
<p>// Using iterator</p>
<p>it = sut.find(22);</p>
<p>sut.erase(it);</p>
<p>// Deleting a range of values</p>
<p>it = sut.find(33);</p>
<p>sut.erase(it, sut.end());</p>
<p>std::cout &lt;&lt; std::endl &lt;&lt; "Set under test contains:"
&lt;&lt; std::endl; for (it = sut.begin(); it != sut.end(); ++it)</p>
<p>{</p>
<p>std::cout &lt;&lt; *it &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 320</p>
<p><span id="_22" class="anchor"></span>}</p>
<p>Output will be:</p>
<p>Set under test contains:</p>
<p>10</p>
<p>15</p>
<p>30</p>
<p>All those methods also apply to <del>multiset</del>. Please note that
if you ask to delete an element from a <del>multiset</del>, and it</p>
<p><strong>is present multiple times,</strong> all the equivalent values
will be deleted<strong>.</strong></p>
<p>Section 59.3: Inserting values in a set</p>
<p>Three different methods of insertion can used with sets.</p>
<p>First, a simple insert of the value. This method returns a pair
allowing the caller to check whether the insert</p>
<p>really occurred.</p>
<p>Second, an insert by giving a hint of where the value will be
inserted. The objective is to optimize the</p>
<p>insertion time in such a case, but knowing where a value should be
inserted is not the common case. <strong>Be</strong></p>
<p>careful in that case; the way to give a hint differs with compiler
versions<strong>.</strong></p>
<p>Finally you can insert a range of values by giving a starting and an
ending pointer. The starting one will be included in the insertion, the
ending one is excluded.</p>
<p>#include</p>
<p>#include</p>
<p>int main ()</p>
<p>{</p>
<p>std::set <del>sut;</del></p>
<p><del>std::set</del>::iterator it;</p>
<p><del>std::pair</del>::iterator,bool&gt; ret;</p>
<p>// Basic insert</p>
<p>sut.insert(7);</p>
<p>sut.insert(5);</p>
<p>sut.insert(12);</p>
<p>ret = sut.insert(23);</p>
<p>if (ret.second==true)</p>
<p>std::cout &lt;&lt; "# 23 has been inserted!" &lt;&lt; std::endl;</p>
<p>ret = sut.insert(23); // since it's a set and 23 is already present
in it, this insert should fail</p>
<p>if (ret.second==false)</p>
<p>std::cout &lt;&lt; "# 23 already present in set!" &lt;&lt;
std::endl;</p>
<p>// Insert with hint for optimization</p>
<p>it = sut.end();</p>
<p>// This case is optimized for C++11 and above</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 321</p>
<p>// For earlier version, point to the element preceding your
insertion</p>
<p>sut.insert(it, 30);</p>
<p>// inserting a range of values</p>
<p>std::set <del>sut2;</del></p>
<p>sut2.insert(20);</p>
<p>sut2.insert(30);</p>
<p>sut2.insert(45);</p>
<p><del>std::set</del>::iterator itStart = sut2.begin();</p>
<p><del>std::set</del>::iterator itEnd = sut2.end();</p>
<p>sut.insert (itStart, itEnd); // second iterator is excluded from
insertion</p>
<p>std::cout &lt;&lt; std::endl &lt;&lt; "Set under test contains:"
&lt;&lt; std::endl;</p>
<p>for (it = sut.begin(); it != sut.end(); ++it)</p>
<p>{</p>
<p>std::cout &lt;&lt; *it &lt;&lt; std::endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>Output will be:</p>
<p># 23 has been inserted!</p>
<p># 23 already present in set!</p>
<p>Set under test contains:</p>
<p>5</p>
<p>7</p>
<p>12</p>
<p>20</p>
<p>23</p>
<p>30</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 322</p>
<p><span id="45" class="anchor"></span>45</p>
<p>Section 59.4: Inserting values in a multiset</p>
<p>All the insertion methods from sets also apply to multisets.
Nevertheless, another possibility exists, which is</p>
<p>providing an initializer_list:</p>
<p>auto il = { 7, 5, 12 };</p>
<p>std::multiset <del>msut;</del></p>
<p>msut.insert(il);</p>
<p>Section 59.5: Searching values in set and multiset</p>
<p>There are several ways to search a given value in <del>std::set</del>
or in <del>std::multiset</del>:</p>
<p>To get the iterator of the first occurrence of a key, the
<del>find()</del> function can be used. It returns <del>end()</del> if
the key does not exist.</p>
<p>std::set <del>sut;</del></p>
<p>sut.insert(10);</p>
<p>sut.insert(15);</p>
<p>sut.insert(22);</p>
<p>sut.insert(3); // contains 3, 10, 15, 22</p>
<p>auto itS = sut.find(10); // the value is found, so *itS == 10</p>
<p>itS = sut.find(555); // the value is not found, so itS ==
sut.end()</p>
<p>std::multiset <del>msut;</del></p>
<p>sut.insert(10);</p>
<p>sut.insert(15);</p>
<p>sut.insert(22);</p>
<p>sut.insert(15);</p>
<p>sut.insert(3); // contains 3, 10, 15, 15, 22</p>
<p>auto itMS = msut.find(10);</p>
<p>Another way is using the <del>count()</del> function, which counts
how many corresponding values have been found in the
set/<del>multiset</del> (in case of a <del>set</del>, the return value
can be only 0 or 1). Using the same values as above, we will have:</p>
<p>int result = sut.count(10); // result == 1</p>
<p>result = sut.count(555); // result == 0</p>
<p>result = msut.count(10); // result == 1</p>
<p>result = msut.count(15); // result == 2</p>
<p>In the case of <del>std::multiset</del>, there could be several
elements having the same value. To get this range, the</p>
<p>equal_range() function can be used. It returns <del>std::pair</del>
having iterator lower bound (inclusive) and upper bound (exclusive)
respectively. If the key does not exist, both iterators would point to
the nearest superior value (based on</p>
<p>compare method used to sort the given <del>multiset</del>).</p>
<p>auto eqr = msut.equal_range(15);</p>
<p>auto st = eqr.first; // point to first element '15' auto en =
eqr.second; // point to element '22'</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 323</p>
<p>eqr = msut.equal_range(9); // both eqr.first and eqr.second point to
element '10'</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 324</p>
<p><span id="Chapter_60__std__integer_sequenc_1"
class="anchor"></span>Chapter 60: std::integer_sequence</p>
<p>The class template <del>std::integer_sequence</del> represents a
sequence of values of type Type where</p>
<p><del>Type</del> is one of the built-in integer types. These sequences
are used when implementing class or function templates which benefit
from positional access. The standard library also contains "factory"
types which create ascending</p>
<p>sequences of integer values just from the number of elements.</p>
<p>Section 60.1: Turn a std::tuple&lt;T...&gt; into function
parameters</p>
<p>A <del>std::tuple</del> can be used to pass multiple values around.
For example, it could be used to store a sequence</p>
<p>of parameters into some form of a queue. When processing such a tuple
its elements need to be turned into function call arguments:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>//
----------------------------------------------------------------------------//
Example functions to be called:</p>
<p>void f(int i, std::string const&amp; s) {</p>
<p>std::cout &lt;&lt; "f(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; s &lt;&lt;
")<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>void f(int i, double d, std::string const&amp; s) {</p>
<p>std::cout &lt;&lt; "f(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; d &lt;&lt;
", " &lt;&lt; s &lt;&lt; ")<strong><del>\n</del></strong>"; }</p>
<p>void f(char c, int i, double d, std::string const&amp; s) {</p>
<p>std::cout &lt;&lt; "f(" &lt;&lt; c &lt;&lt; ", " &lt;&lt; i &lt;&lt;
", " &lt;&lt; d &lt;&lt; ", " &lt;&lt; s &lt;&lt;
")<strong><del>\n</del></strong>"; }</p>
<p>void f(int i, int j, int k) {</p>
<p>std::cout &lt;&lt; "f(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt;
", " &lt;&lt; k &lt;&lt; ")<strong><del>\n</del></strong>"; }</p>
<p>//
----------------------------------------------------------------------------//
The actual function expanding the tuple:</p>
<p>template</p>
<p>void process(Tuple const&amp; tuple, std::index_sequence<del>)
{</del></p>
<p><em><del>f(std::get</del></em>(tuple)...);</p>
<p>}</p>
<p>// The interface to call. Sadly, it needs to dispatch to another
function // to deduce the sequence of indices created from
std::make_index_sequence template</p>
<p>void process(Tuple const&amp; tuple) {</p>
<p>process(tuple, std::make_index_sequence::value&gt;()); }</p>
<p>//
----------------------------------------------------------------------------int
main() {</p>
<p>process(std::make_tuple(1, 3.14, std::string("foo")));</p>
<p>process(std::make_tuple('a', 2, 2.71, std::string("bar")));</p>
<p>process(std::make_pair(3, std::string("pair")));</p>
<p>process(std::array{ 1, 2, 3 });</p>
<p>}</p>
<p>As long as a class supports std::get(object) and
std::tuple_size::value it can be expanded with the</p>
<p>above process() function. The function itself is entirely independent
of the number of arguments.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 325</p>
<p><span id="Section_60_2__Create_a_parameter"
class="anchor"></span>Section 60.2: Create a parameter pack consisting
of integers</p>
<p>std::integer_sequence itself is about holding a sequence of integers
which can be turned into a parameter pack.</p>
<p>Its primary value is the possibility to create "factory" class
templates creating these sequences:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>void print_sequence(std::integer_sequence) {</p>
<p>std::initializer_list{ bool(std::cout &lt;&lt; I &lt;&lt; ' ')...
};</p>
<p>std::cout &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>template</p>
<p>void print_offset_sequence(std::integer_sequence) {</p>
<p>print_sequence(std::integer_sequence()); }</p>
<p>int main() {</p>
<p>// explicitly specify sequences:</p>
<p>print_sequence(std::integer_sequence());</p>
<p>print_sequence(std::integer_sequence());</p>
<p>// generate sequences:</p>
<p>print_sequence(std::make_index_sequence&lt;10&gt;());</p>
<p>print_sequence(std::make_integer_sequence());</p>
<p>print_offset_sequence&lt;'A'&gt;(std::make_integer_sequence()); }</p>
<p>The print_sequence() function template uses an std::initializer_list
when expanding the integer</p>
<p>sequence to guarantee the order of evaluation and not creating an
unused [array] variable.</p>
<p>Section 60.3: Turn a sequence of indices into copies of an</p>
<p>element</p>
<p>Expanding the parameter pack of indices in a comma expression with a
value creates a copy of the value for each of</p>
<p>the indices. Sadly, <a href="http://gcc.gnu.org/">gcc and</a> <a
href="http://clang.llvm.org/">clang think the index has no effect and
warn about it (</a><a href="http://gcc.gnu.org/">gcc</a> can be silenced
by casting the index to void):</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>std::array make_array(T const&amp; value, std::index_sequence) {</p>
<p>return std::array{ (I, value)... };</p>
<p>}</p>
<p>template</p>
<p>std::array make_array(T const&amp; value) {</p>
<p>return make_array(value, std::make_index_sequence());</p>
<p>}</p>
<p>int main() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 326</p>
<p>auto array = make_array&lt;20&gt;(std::string("value"));</p>
<p>std::copy(array.begin(), array.end(),</p>
<p>std::ostream_iterator(std::cout, " "));</p>
<p>std::cout &lt;&lt; "<strong>\n</strong>";</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 327</p>
<p><span id="Chapter_61__Using_std__unordered_1"
class="anchor"></span>Chapter 61: Using std::unordered_map</p>
<p>std::unordered_map is just an associative container. It works on keys
and their maps. Key as the names goes, helps</p>
<p>to have uniqueness in the map. While the mapped value is just a
content that is associated with the key. The data types of this key and
map can be any of the predefined data type or user-defined.</p>
<p>Section 61.1: Declaration and Usage</p>
<p>As already mentioned you can declare an unordered map of any type.
Let's have a unordered map named first with string and integer type.</p>
<p>unordered_map first; //declaration of the map first["One"] = 1; // []
operator used to insert the value first["Two"] = 2;</p>
<p>first["Three"] = 3;</p>
<p>first["Four"] = 4;</p>
<p>first["Five"] = 5;</p>
<p>pair bar = make_pair("Nine", 9); //make a pair of same type
first.insert(bar); //can also use insert to feed the values</p>
<p>Section 61.2: Some Basic Functions</p>
<p>unordered_map variable_name; //declaration</p>
<p>variable_name[key_value] = mapped_value; //inserting values</p>
<p>variable_name.find(key_value); //returns iterator to the key
value</p>
<p>variable_name.begin(); // iterator to the first element</p>
<p>variable_name.end(); // iterator to the last + 1 element</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 328</p>
<p><span id="Chapter_62__Standard_Library_Alg_1"
class="anchor"></span>Chapter 62: Standard Library Algorithms</p>
<p>Section 62.1: std::next_permutation</p>
<p>template&lt; class Iterator &gt;</p>
<p>bool next_permutation( Iterator first, Iterator last ); template&lt;
class Iterator, class Compare &gt;</p>
<p>bool next_permutation( Iterator first, Iterator last, Compare cmpFun
);</p>
<p>Effects:</p>
<p>Sift the data sequence of the range [first, last) into the next
lexicographically higher permutation. If cmpFun is provided, the
permutation rule is customized.</p>
<p>Parameters:</p>
<p>first- the beginning of the range to be permutated, inclusive</p>
<p>last - the end of the range to be permutated, exclusive</p>
<p>Return Value:</p>
<p>Returns true if such permutation exists.</p>
<p>Otherwise the range is swaped to the lexicographically smallest
permutation and return false.</p>
<p>Complexity:</p>
<p>O(n), n is the distance from first to last.</p>
<p>Example<strong>:</strong></p>
<p>std::vector&lt; int &gt; v { 1, 2, 3 };</p>
<p>do</p>
<p>{</p>
<p>for( int i = 0; i &lt; v.size(); i += 1 )</p>
<p>{</p>
<p>std::cout &lt;&lt; v[i];</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>}while( std::next_permutation( v.begin(), v.end() ) );</p>
<p>print all the permutation cases of 1,2,3 in
lexicographically-increasing order.</p>
<p>output:</p>
<p>123</p>
<p>132</p>
<p>213</p>
<p>231</p>
<p>312</p>
<p>321</p>
<p>Section 62.2: std::for_each</p>
<p>template</p>
<p>Function for_each(InputIterator first, InputIterator last, Function
f);</p>
<p>Effects:</p>
<p>Applies f to the result of dereferencing every iterator in the range
[first, last) starting from first and</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 329</p>
<p><span id="proceeding_to_last__1" class="anchor"></span>proceeding to
last -1.</p>
<p>Parameters:</p>
<p>first, last - the range to apply f to.</p>
<p>f - callable object which is applied to the result of dereferencing
every iterator in the range [first, last).</p>
<p>Return value:</p>
<p>f (until C++11) and std::move(f) (since C++11).</p>
<p>Complexity:</p>
<p>Applies f exactly last - first times.</p>
<p>Example:</p>
<p>Version ≥ c++11</p>
<p>std::vector v { 1, 2, 4, 8, 16 };</p>
<p>std::for_each(v.begin(), v.end(), [](int elem) { std::cout &lt;&lt;
elem &lt;&lt; " "; });</p>
<p>Applies the given function for every element of the vector v printing
this element to stdout.</p>
<p>Section 62.3: std::accumulate</p>
<p>Defined in header <strong>&lt;numeric&gt;</strong></p>
<p>template</p>
<p>T accumulate(InputIterator first, InputIterator last, T init); //
(1)</p>
<p>template T accumulate(InputIterator first, InputIterator last, T
init, BinaryOperation f); // (2)</p>
<p>Effects:</p>
<p><a
href="http://en.cppreference.com/w/cpp/algorithm/accumulate">std::accumulate
performs</a> <a
href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold</a>
operation using f function on range [first, last) starting with init
as</p>
<p>accumulator value.</p>
<p>Effectively it's equivalent of:</p>
<p>T acc = init;</p>
<p>for (auto it = first; first != last; ++it)</p>
<p>acc = f(acc, *it);</p>
<p>return acc;</p>
<p>In version (1) operator+ is used in place of f, so accumulate over
container is equivalent of sum of container</p>
<p>elements.</p>
<p>Parameters:</p>
<p>first, last - the range to apply f to.</p>
<p>init - initial value of accumulator.</p>
<p>f - binary folding function.</p>
<p>Return value:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 330</p>
<p><span id="Accumulated_value_of_f_applicati"
class="anchor"></span>Accumulated value of f applications.</p>
<p>Complexity:</p>
<p>O(n×k), where n is the distance from first to last, O(k) is
complexity of f function.</p>
<p>Example:</p>
<p>Simple sum example:</p>
<p>std::vector v { 2, 3, 4 };</p>
<p>auto sum = std::accumulate(v.begin(), v.end(), 1); std::cout &lt;&lt;
sum &lt;&lt; std::endl;</p>
<p>Output:</p>
<p>10</p>
<p>Convert digits to number:</p>
<p>Version &lt; c++11</p>
<p>class Converter {</p>
<p>public:</p>
<p>int operator()(int a, int d) const { return a * 10 + d; }</p>
<p>};</p>
<p>and later</p>
<p>const int ds[3] = {1, 2, 3};</p>
<p>int n = std::accumulate(ds, ds + 3, 0, Converter()); std::cout
&lt;&lt; n &lt;&lt; std::endl;</p>
<p>Version ≥ c++11</p>
<p>const std::vector ds = {1, 2, 3};</p>
<p>int n = std::accumulate(ds.begin(), ds.end(),</p>
<p>0,</p>
<p>[](int a, int d) { return a * 10 + d; });</p>
<p>std::cout &lt;&lt; n &lt;&lt; std::endl;</p>
<p>Output:</p>
<p>123</p>
<p>Section 62.4: std::find</p>
<p>template</p>
<p>InputIterator find (InputIterator first, InputIterator last, const
T&amp; val);</p>
<p>Effects</p>
<p>Finds the first occurrence of val within the range [first, last)</p>
<p>Parameters</p>
<p>first =&gt; iterator pointing to the beginning of the range last
=&gt; iterator pointing to the end of the range val =&gt; The value to
find within the range</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 331</p>
<p>Return</p>
<p>An iterator that points to the first element within the range that is
equal(==) to val, the iterator points to last if val is</p>
<p>not found.</p>
<p>Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main(int argc, const char * argv[]) {</p>
<p>//create a vector</p>
<p>vector intVec {4, 6, 8, 9, 10, 30, 55,100, 45, 2, 4, 7, 9, 43,
48};</p>
<p>//define iterators</p>
<p>vector::iterator itr_9;</p>
<p>vector::iterator itr_43;</p>
<p>vector::iterator itr_50;</p>
<p>//calling find</p>
<p>itr_9 = find(intVec.begin(), intVec.end(), 9); //occurs twice itr_43
= find(intVec.begin(), intVec.end(), 43); //occurs once</p>
<p>//a value not in the vector</p>
<p>itr_50 = find(intVec.begin(), intVec.end(), 50); //does not occur</p>
<p>cout &lt;&lt; "first occurrence of: " &lt;&lt; *itr_9 &lt;&lt;
endl;</p>
<p>cout &lt;&lt; "only occurrence of: " &lt;&lt; *itr_43 &lt;&lt;
Lendl;</p>
<p>/*</p>
<p>let's prove that itr_9 is pointing to the first occurrence</p>
<p>of 9 by looking at the element after 9, which should be 10</p>
<p>not 43</p>
<p>*/</p>
<p>cout &lt;&lt; "element after first 9: " &lt;&lt; *(itr_9 + 1)
&lt;&lt; ends;</p>
<p>/*</p>
<p>to avoid dereferencing intVec.end(), lets look at the</p>
<p>element right before the end</p>
<p>*/</p>
<p>cout &lt;&lt; "last element: " &lt;&lt; *(itr_50 -1) &lt;&lt;
endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output</p>
<p>first occurrence of: 9</p>
<p>only occurrence of: 43</p>
<p>element after first 9: 10</p>
<p>last element: 48</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 332</p>
<p><span id="Section_62_5__std__min_element"
class="anchor"></span>Section 62.5: std::min_element</p>
<p>template</p>
<p>ForwardIterator min_element (ForwardIterator first, ForwardIterator
last);</p>
<p>template</p>
<p>ForwardIterator min_element (ForwardIterator first, ForwardIterator
last,Compare comp);</p>
<p>Effects</p>
<p>Finds the minimum element in a range</p>
<p>Parameters</p>
<p>first - iterator pointing to the beginning of the range</p>
<p>last - iterator pointing to the end of the range comp - a function
pointer or function object that takes two arguments and returns true or
false indicating whether argument is less than argument 2. This function
should not</p>
<p>modify inputs</p>
<p>Return</p>
<p>Iterator to the minimum element in the range</p>
<p>Complexity</p>
<p>Linear in one less than the number of elements compared.</p>
<p>Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include //to use make_pair</p>
<p>using namespace std;</p>
<p>//function compare two pairs</p>
<p>bool pairLessThanFunction(const pair &amp;p1, const pair &amp;p2)
{</p>
<p>return p1.second &lt; p2.second;</p>
<p>}</p>
<p>int main(int argc, const char * argv[]) {</p>
<p>vector intVec {30,200,167,56,75,94,10,73,52,6,39,43};</p>
<p>vector&gt; pairVector = {make_pair("y", 25), make_pair("b", 2),
make_pair("z", 26), make_pair("e", 5) };</p>
<p>// default using &lt; operator</p>
<p>auto minInt = min_element(intVec.begin(), intVec.end());</p>
<p>//Using pairLessThanFunction</p>
<p>auto minPairFunction = min_element(pairVector.begin(),
pairVector.end(), pairLessThanFunction);</p>
<p>//print minimum of intVector</p>
<p>cout &lt;&lt; "min int from default: " &lt;&lt; *minInt &lt;&lt;
endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 333</p>
<p><span id="__print_minimum_of_pairVector"
class="anchor"></span>//print minimum of pairVector</p>
<p>cout &lt;&lt; "min pair from PairLessThanFunction: " &lt;&lt;
(*minPairFunction).second &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output</p>
<p>min int from default: 6</p>
<p>min pair from PairLessThanFunction: 2</p>
<p>Section 62.6: std::find_if</p>
<p>template InputIterator find_if (InputIterator first, InputIterator
last, UnaryPredicate pred);</p>
<p>Effects</p>
<p>Finds the first element in a range for which the predicate function
pred returns true.</p>
<p>Parameters</p>
<p>first =&gt; iterator pointing to the beginning of the range last
=&gt; iterator pointing to the end of the range pred =&gt; predicate
function(returns true or false)</p>
<p>Return</p>
<p>An iterator that points to the first element within the range the
predicate function pred returns true for. The iterator points to last if
val is not found</p>
<p>Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>/*</p>
<p>define some functions to use as predicates</p>
<p>*/</p>
<p>//Returns true if x is multiple of 10</p>
<p>bool multOf10(int x) {</p>
<p>return x % 10 == 0;</p>
<p>}</p>
<p>//returns true if item greater than passed in parameter class Greater
{</p>
<p>int _than;</p>
<p>public:</p>
<p>Greater(int th):_than(th){</p>
<p>}</p>
<p>bool operator()(int data) const</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 334</p>
<p><span id="_23" class="anchor"></span>{</p>
<p>return data &gt; _than;</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>vector myvec {2, 5, 6, 10, 56, 7, 48, 89, 850, 7, 456};</p>
<p>//with a lambda function</p>
<p>vector::iterator gt10 = find_if(myvec.begin(), myvec.end(), [](int
x){return x&gt;10;}); // &gt;= C++11</p>
<p>//with a function pointer</p>
<p>vector::iterator pow10 = find_if(myvec.begin(), myvec.end(),
multOf10);</p>
<p>//with functor</p>
<p>vector::iterator gt5 = find_if(myvec.begin(), myvec.end(),
Greater(5));</p>
<p>//not Found</p>
<p>vector::iterator nf = find_if(myvec.begin(), myvec.end(),
Greater(1000)); // nf points to myvec.end()</p>
<p>//check if pointer points to myvec.end()</p>
<p>if(nf != myvec.end()) {</p>
<p>cout &lt;&lt; "nf points to: " &lt;&lt; *nf &lt;&lt; endl;</p>
<p>}</p>
<p>else {</p>
<p>cout &lt;&lt; "item not found" &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; "First item &gt; 10: " &lt;&lt; *gt10 &lt;&lt;
endl;</p>
<p>cout &lt;&lt; "First Item n * 10: " &lt;&lt; *pow10 &lt;&lt;
endl;</p>
<p>cout &lt;&lt; "First Item &gt; 5: " &lt;&lt; *gt5 &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output</p>
<p>item not found</p>
<p>First item &gt; 10: 56</p>
<p>First Item n * 10: 10</p>
<p>First Item &gt; 5: 6</p>
<p>Section 62.7: Using std::nth_element To Find The Median (Or</p>
<p>Other Quantiles)</p>
<p><a href="http://en.cppreference.com/w/cpp/algorithm/nth_element">The
std::nth_element algorithm takes three iterators: an iterator to the
beginning,</a> nth position, and end. Once the</p>
<p>function returns, the nth element (by order) will be the nth smallest
element. (The function has more elaborate overloads, e.g., some taking
comparison functors; see the above link for all the variations.)</p>
<p><strong>Note</strong> This function is very efficient - it has linear
complexity.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 335</p>
<p><span id="For_the_sake_of_this_example__le" class="anchor"></span>For
the sake of this example, let's define the median of a sequence of
length n as the element that would be in</p>
<p>position ⌈n / 2⌉. For example, the median of a sequence of length 5
is the 3rd smallest element, and so is the median of a sequence of
length 6.</p>
<p>To use this function to find the median, we can use the following.
Say we start with</p>
<p>std::vector v{5, 1, 2, 3, 4};</p>
<p>std::vector::iterator b = v.begin();</p>
<p>std::vector::iterator e = v.end();</p>
<p>std::vector::iterator med = b;</p>
<p>std::advance(med, v.size() / 2);</p>
<p>// This makes the 2nd position hold the median.</p>
<p>std::nth_element(b, med, e);</p>
<p>// The median is now at v[2].</p>
<p>To find the pth <a
href="https://en.wikipedia.org/wiki/Quantile">quantile</a>, we would
change some of the lines above:</p>
<p>const std::size_t pos = p * std::distance(b, e);</p>
<p>std::advance(nth, pos);</p>
<p>and look for the quantile at position pos.</p>
<p>Section 62.8: std::count</p>
<p>template</p>
<p>typename iterator_traits::difference_type count (InputIterator first,
InputIterator last, const T&amp; val);</p>
<p>Effects</p>
<p>Counts the number of elements that are equal to val</p>
<p>Parameters</p>
<p>first =&gt; iterator pointing to the beginning of the range</p>
<p>last =&gt; iterator pointing to the end of the range</p>
<p>val =&gt; The occurrence of this value in the range will be
counted</p>
<p>Return</p>
<p>The number of elements in the range that are equal(==) to val.</p>
<p>Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main(int argc, const char * argv[]) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 336</p>
<p><span id="__create_vector" class="anchor"></span>//create vector</p>
<p>vector intVec{4,6,8,9,10,30,55,100,45,2,4,7,9,43,48};</p>
<p>//count occurrences of 9, 55, and 101</p>
<p>size_t count_9 = count(intVec.begin(), intVec.end(), 9); //occurs
twice size_t count_55 = count(intVec.begin(), intVec.end(), 55);
//occurs once size_t count_101 = count(intVec.begin(), intVec.end(),
101); //occurs once</p>
<p>//print result</p>
<p>cout &lt;&lt; "There are " &lt;&lt; count_9 &lt;&lt; " 9s"&lt;&lt;
endl;</p>
<p>cout &lt;&lt; "There is " &lt;&lt; count_55 &lt;&lt; " 55"&lt;&lt;
endl;</p>
<p>cout &lt;&lt; "There is " &lt;&lt; count_101 &lt;&lt; " 101"&lt;&lt;
ends;</p>
<p>//find the first element == 4 in the vector</p>
<p>vector::iterator itr_4 = find(intVec.begin(), intVec.end(), 4);</p>
<p>//count its occurrences in the vector starting from the first one
size_t count_4 = count(itr_4, intVec.end(), *itr_4); // should be 2</p>
<p>cout &lt;&lt; "There are " &lt;&lt; count_4 &lt;&lt; " " &lt;&lt;
*itr_4 &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output</p>
<p>There are 2 9s</p>
<p>There is 1 55</p>
<p>There is 0 101</p>
<p>There are 2 4</p>
<p>Section 62.9: std::count_if</p>
<p>template typename iterator_traits::difference_type count_if
(InputIterator first, InputIterator last, UnaryPredicate red);</p>
<p>Effects</p>
<p>Counts the number of elements in a range for which a specified
predicate function is true</p>
<p>Parameters</p>
<p>first =&gt; iterator pointing to the beginning of the range last
=&gt; iterator pointing to the end of the range red =&gt;</p>
<p>predicate function(returns true or false)</p>
<p>Return</p>
<p>The number of elements within the specified range for which the
predicate function returned true.</p>
<p>Example</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 337</p>
<p>/*</p>
<p>Define a few functions to use as predicates</p>
<p>*/</p>
<p>//return true if number is odd</p>
<p>bool isOdd(int i){</p>
<p>return i%2 == 1;</p>
<p>}</p>
<p>//functor that returns true if number is greater than the value of
the constructor parameter provided</p>
<p>class Greater {</p>
<p>int _than;</p>
<p>public:</p>
<p>Greater(int th): _than(th){}</p>
<p>bool operator()(int i){</p>
<p>return i &gt; _than;</p>
<p>}</p>
<p>};</p>
<p>int main(int argc, const char * argv[]) {</p>
<p>//create a vector</p>
<p>vector myvec = {1,5,8,0,7,6,4,5,2,1,5,0,6,9,7};</p>
<p>//using a lambda function to count even numbers</p>
<p>size_t evenCount = count_if(myvec.begin(), myvec.end(), [](int
i){return i % 2 == 0;}); // &gt;=</p>
<p>C++11</p>
<p>//using function pointer to count odd number in the first half of the
vector size_t oddCount = count_if(myvec.begin(), myvec.end()-
myvec.size()/2, isOdd);</p>
<p>//using a functor to count numbers greater than 5</p>
<p>size_t greaterCount = count_if(myvec.begin(), myvec.end(),
Greater(5));</p>
<p>cout &lt;&lt; "vector size: " &lt;&lt; myvec.size() &lt;&lt;
endl;</p>
<p>cout &lt;&lt; "even numbers: " &lt;&lt; evenCount &lt;&lt; " found"
&lt;&lt; endl; cout &lt;&lt; "odd numbers: " &lt;&lt; oddCount &lt;&lt;
" found" &lt;&lt; endl; cout &lt;&lt; "numbers &gt; 5: " &lt;&lt;
greaterCount &lt;&lt; " found"&lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Output</p>
<p>vector size: 15</p>
<p>even numbers: 7 found</p>
<p>odd numbers: 4 found</p>
<p>numbers &gt; 5: 6 found</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 338</p>
<p><span id="Chapter_63__The_ISO_C___Standard_1"
class="anchor"></span>Chapter 63: The ISO C++ Standard</p>
<p>In 1998, the there was a first publication of the standard making C++
an internally standardized language. From</p>
<p>that time, C++ has evolved resulting in different dialects of C++. On
this page, you can find an overview of all different standards and their
changes compared to the previous version. The details on how to use
these features</p>
<p>is described on more specialized pages.</p>
<p>Section 63.1: Current Working Drafts</p>
<p>All published ISO standards are available for sale from the ISO store
( <a href="http://www.iso.org">http://www.iso.org</a> ). The working
drafts of the</p>
<p>C++ standards are publicly available for free though.</p>
<p>The different versions of the standard:</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">Upcoming
(Sometimes referred as C++20 or C++2a): Current working draft (</a><a
href="http://eel.is/c++draft/">HTML-version</a>)</p>
<p>Proposed (Sometimes referred as C++17 or C++1z): <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">March
2017 working draft N4659.</a></p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">C++14
(Sometimes referred as C++1y): November 2014 working draft N4296</a></p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++11
(Sometimes referred as C++0x): February 2011 working draft N3242</a></p>
<p>C++03</p>
<p>C++98</p>
<p>Section 63.2: C++17</p>
<p>The C++17 standard is feature complete and has been proposed for
standardization. In compilers with experimental support for these
features, it is usually referred to as C++1z.</p>
<p>Language Extensions</p>
<p>Fold Expressions</p>
<p>declaring non-type template arguments with auto</p>
<p>Guaranteed copy elision</p>
<p>Template parameter deduction for constructors</p>
<p>Structured bindings</p>
<p>Compact nested namespaces</p>
<p>New attributes: [[fallthrough]], [[nodiscard]], [[maybe_unused]]
Default message for static_assert</p>
<p>Initializers in if and switch</p>
<p>Inline variables</p>
<p>if constexpr</p>
<p>Order of expression evaluation guarantees</p>
<p>Dynamic memory allocation for over-aligned data</p>
<p>Library Extensions</p>
<p>std::optional</p>
<p>std::variant</p>
<p>std::string_view</p>
<p>merge() and extract() for associative containers</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3505.html">A
file system library</a> <a
href="http://en.cppreference.com/w/cpp/filesystem">with the
<strong>&lt;filesystem&gt;</strong> header.</a></p>
<p><a href="https://isocpp.org/files/papers/P0024R2.html">Parallel
versions of most of the standard algorithms</a> (in <a
href="http://en.cppreference.com/w/cpp/algorithm">the
<strong>&lt;algorithm&gt;</strong> header</a>).</p>
<p><a href="https://isocpp.org/files/papers/P0226R1.pdf">Addition of
mathematical special functions</a> in <a
href="http://en.cppreference.com/w/cpp/numeric/special_math">the
<strong>&lt;cmath&gt;</strong> header</a>. Moving nodes between
map&lt;&gt;, unordered_map&lt;&gt;, set&lt;&gt;, and
unordered_set&lt;&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 339</p>
<p><span id="Section_63_3__C__11" class="anchor"></span>Section 63.3:
C++11</p>
<p>The C++11 standard is a major extension to the C++ standard. Below
you can find an overview of the changes as</p>
<p>they have been grouped on <a href="https://isocpp.org/faq">the isocpp
FAQ</a> with links to more detailed documentation.</p>
<p>Language Extensions</p>
<p><a href="https://isocpp.org/wiki/faq/cpp11-language">General
Features</a></p>
<p>auto</p>
<p>decltype</p>
<p>Range-for statement</p>
<p>Initializer lists</p>
<p>Uniform initialization syntax and semantics</p>
<p>Rvalue references and move semantics</p>
<p>Lambdas</p>
<p>noexcept to prevent exception propagation</p>
<p>constexpr</p>
<p>nullptr – a null pointer literal</p>
<p>Copying and rethrowing exceptions</p>
<p>Inline namespaces</p>
<p>User-defined literals</p>
<p><a
href="https://isocpp.org/wiki/faq/cpp11-language-classes">Classes</a></p>
<p>=default and =delete</p>
<p>Control of default move and copy</p>
<p>Delegating constructors</p>
<p>In-class member initializers</p>
<p>Inherited constructors</p>
<p>Override controls: override</p>
<p>Override controls: final</p>
<p>Explicit conversion operators</p>
<p><a href="https://isocpp.org/wiki/faq/cpp11-language-types">Other
Types</a></p>
<p>enum class</p>
<p>long long – a longer integer</p>
<p>Extended integer types</p>
<p>Generalized unions</p>
<p>Generalized PODs</p>
<p><a
href="https://isocpp.org/wiki/faq/cpp11-language-templates">Templates</a></p>
<p>Extern templates</p>
<p>Template aliases</p>
<p>Variadic templates</p>
<p>Local types as template arguments</p>
<p><a
href="https://isocpp.org/wiki/faq/cpp11-language-concurrency">Concurrency</a></p>
<p>Concurrency memory model</p>
<p>Dynamic initialization and destruction with concurrency</p>
<p>Thread-local storage</p>
<p><a
href="https://isocpp.org/wiki/faq/cpp11-language-misc">Miscellaneous
Language Features</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 340</p>
<p><span id="What_is_the_value_of___cplusplus"
class="anchor"></span>What is the value of __cplusplus for C++11?</p>
<p>Suffix return type syntax</p>
<p>Preventing narrowing</p>
<p>Right-angle brackets</p>
<p>static_assert compile-time assertions</p>
<p>Raw string literals</p>
<p>Attributes</p>
<p>Alignment</p>
<p>C99 features</p>
<p>Library Extensions</p>
<p><a href="https://isocpp.org/wiki/faq/cpp11-library">General</a></p>
<p>unique_ptr</p>
<p>shared_ptr</p>
<p>weak_ptr</p>
<p>Garbage collection ABI</p>
<p>tuple</p>
<p>Type traits</p>
<p>function and bind</p>
<p>Regular Expressions</p>
<p>Time utilities</p>
<p>Random number generation</p>
<p>Scoped allocators</p>
<p><a href="https://isocpp.org/wiki/faq/cpp11-library-stl">Containers
and Algorithms</a></p>
<p>Algorithms improvements</p>
<p>Container improvements</p>
<p>unordered_* containers</p>
<p>std::array</p>
<p>forward_list</p>
<p><a
href="https://isocpp.org/wiki/faq/cpp11-library-concurrency">Concurrency</a></p>
<p>Threads</p>
<p>Mutual exclusion</p>
<p>Locks</p>
<p>Condition variables</p>
<p>Atomics</p>
<p>Futures and promises</p>
<p>async</p>
<p>Abandoning a process</p>
<p>Section 63.4: C++14</p>
<p>The C++14 standard is often referred to as a bugfix for C++11. It
contains only a limited list of changes of which most are extensions to
the new features in C++11. Below you can find an overview of the changes
as they have</p>
<p><a href="https://isocpp.org/faq">been grouped on the isocpp FAQ</a>
with links to more detailed documentation.</p>
<p><a href="https://isocpp.org/wiki/faq/cpp14-language">Language
Extensions</a></p>
<p>Binary literals</p>
<p>Generalized return type deduction</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 341</p>
<p><span id="decltype_auto" class="anchor"></span>decltype(auto)</p>
<p>Generalized lambda captures</p>
<p>Generic lambdas</p>
<p>Variable templates</p>
<p>Extended constexpr</p>
<p>The [[deprecated]] attribute</p>
<p>Digit separators</p>
<p><a href="https://isocpp.org/wiki/faq/cpp14-library">Library
Extensions</a></p>
<p>Shared locking</p>
<p>User-defined literals for std:: types</p>
<p><a
href="http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a></p>
<p>Type transformation _t aliases</p>
<p><a href="http://stackoverflow.com/q/29719558/3235496">Addressing
tuples by type</a> (e.g. get(t))</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421">Transparent
Operator Functors</a> (e.g. greater&lt;&gt;(x))</p>
<p><a
href="http://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted</a></p>
<p>Deprecated / Removed</p>
<p><a href="http://en.cppreference.com/w/cpp/io/c/gets">std::gets</a>
was deprecated in C++11 and removed from C++14</p>
<p><a
href="http://en.cppreference.com/w/cpp/algorithm/random_shuffle">std::random_shuffle</a>
is deprecated</p>
<p>Section 63.5: C++98</p>
<p>C++98 is the first standardized version of C++. As it was developed
as an extension to C, many of the features which</p>
<p>set apart C++ from C are added.</p>
<p>Language Extensions (in respect to C89/C90)</p>
<p>Classes, Derived classes, virtual member functions, const member
functions Function overloading, Operator overloading</p>
<p>Single line comments (Has been introduced in the C-languague with C99
standard) References</p>
<p>new and delete</p>
<p>boolean type (Has been introduced in the C-languague with C99
standard)</p>
<p>templates</p>
<p>namespaces</p>
<p>exceptions</p>
<p>specific casts</p>
<p>Library Extensions</p>
<p>The Standard Template Library</p>
<p>Section 63.6: C++03</p>
<p>The C++03 standard mainly addresses defect reports of the C++98
standard. Apart from these defects, it only adds one new feature.</p>
<p>Language Extensions</p>
<p><a href="http://stackoverflow.com/a/620402/2466431">Value
initalization</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 342</p>
<p><span id="Section_63_7__C__20" class="anchor"></span>Section 63.7:
C++20</p>
<p>C++20 is the upcoming standard of C++, currently in development,
based upon the C++17 standard. It's progress</p>
<p>can be tracked on the <a
href="https://isocpp.org/std/status">official ISO cpp website</a>.</p>
<p>The following features are simply what has been accepted for the next
release of the C++ standard, targeted for</p>
<p>2020.</p>
<p>Language Extensions</p>
<p>No language extensions have been accepted for now.</p>
<p>Library Extensions</p>
<p>No library extensions have been accepted for now.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 343</p>
<p><span id="Chapter_64__Inline_variables_1"
class="anchor"></span>Chapter 64: Inline variables</p>
<p>An inline variable is allowed to be defined in multiple translation
units without violating the One Definition Rule. If it</p>
<p>is multiply defined, the linker will merge all definitions into a
single object in the final program.</p>
<p>Section 64.1: Defining a static data member in the class</p>
<p>definition</p>
<p>A static data member of the class may be fully defined within the
class definition if it is declared inline. For</p>
<p>example, the following class may be defined in a header. Prior to
C++17, it would have been necessary to provide a .cpp file to contain
the definition of Foo::num_instances so that it would be defined only
once, but in C++17 the</p>
<p>multiple definitions of the inline variable Foo::num_instances all
refer to the same int object.</p>
<p>// warning: not thread-safe...</p>
<p>class Foo {</p>
<p>public:</p>
<p>Foo() { ++num_instances; }</p>
<p>~Foo() {--num_instances; }</p>
<p>inline static int num_instances = 0;</p>
<p>};</p>
<p>As a special case, a constexpr static data member is implicitly
inline.</p>
<p>class MyString {</p>
<p>public:</p>
<p>MyString() { /* ... */ }</p>
<p>// ...</p>
<p>static constexpr int max_size = INT_MAX / 2;</p>
<p>};</p>
<p>// in C++14, this definition was required in a single translation
unit: // constexpr int MyString::max_size;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 344</p>
<p><span id="Chapter_65__Random_number_genera_1"
class="anchor"></span>Chapter 65: Random number generation</p>
<p>Section 65.1: True random value generator</p>
<p>To generate true random values that can be used for cryptography
std::random_device has to be used as generator.</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::random_device crypto_random_generator;</p>
<p>std::uniform_int_distribution int_distribution(0,9);</p>
<p>int actual_distribution[10] = {0,0,0,0,0,0,0,0,0,0};</p>
<p>for(int i = 0; i &lt; 10000; i++) {</p>
<p>int result = int_distribution(crypto_random_generator);</p>
<p>actual_distribution[result]++;</p>
<p>}</p>
<p>for(int i = 0; i &lt; 10; i++) {</p>
<p>std::cout &lt;&lt; actual_distribution[i] &lt;&lt; " ";</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>std::random_device is used in the same way as a pseudo random value
generator is used.</p>
<p><strong>However std::random_device</strong> may be implemented in
terms of an implementation-defined pseudo-random</p>
<p><strong>number engine</strong> if a non-deterministic source (e.g. a
hardware device) isn't available to the implementation.</p>
<p>Detecting such implementations should be possible via the <a
href="http://en.cppreference.com/w/cpp/numeric/random/random_device/entropy">entropy
member function</a> (which return zero when the</p>
<p>generator is completely deterministic), but many popular libraries
(both GCC's libstdc++ and LLVM's libc++) always return zero, even when
they're using high-quality external randomness.</p>
<p>Section 65.2: Generating a pseudo-random number</p>
<p>A pseudo-random number generator generates values that can be guessed
based on previously generated values. In other words: it is
deterministic. Do not use a pseudo-random number generator in situations
where a true</p>
<p>random number is required.</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::default_random_engine pseudo_random_generator;</p>
<p>std::uniform_int_distribution int_distribution(0, 9);</p>
<p>int actual_distribution[10] = {0,0,0,0,0,0,0,0,0,0};</p>
<p>for(int i = 0; i &lt; 10000; i++) {</p>
<p>int result = int_distribution(pseudo_random_generator);</p>
<p>actual_distribution[result]++;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 345</p>
<p><span id="_25" class="anchor"></span>}</p>
<p>for(int i = 0; i &lt;= 9; i++) {</p>
<p>std::cout &lt;&lt; actual_distribution[i] &lt;&lt; " ";</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>This code creates a random number generator, and a distribution that
generates integers in the range [0,9] with</p>
<p>equal likelihood. It then counts how many times each result was
generated.</p>
<p><a
href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">The
template parameter of std::uniform_int_distribution&lt;T&gt;</a>
specifies the type of integer that should be</p>
<p><a
href="http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution">generated.
Use std::uniform_real_distribution&lt;T&gt; to generate floats or
doubles.</a></p>
<p>Section 65.3: Using the generator for multiple distributions</p>
<p>The random number generator can (and should) be used for multiple
distributions.</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::default_random_engine pseudo_random_generator;</p>
<p>std::uniform_int_distribution int_distribution(0, 9);</p>
<p>std::uniform_real_distribution float_distribution(0.0, 1.0);</p>
<p>std::discrete_distribution rigged_dice({1,1,1,1,1,100});</p>
<p>std::cout &lt;&lt; int_distribution(pseudo_random_generator) &lt;&lt;
std::endl;</p>
<p>std::cout &lt;&lt; float_distribution(pseudo_random_generator)
&lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; (rigged_dice(pseudo_random_generator) + 1)
&lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>In this example, only one generator is defined. It is subsequently
used to generate a random value in three different distributions. The
rigged_dice distribution will generate a value between 0 and 5, but
almost always</p>
<p>generates a 5, because the chance to generate a 5 is 100 / 105.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 346</p>
<p><span id="Chapter_66__Date_and_time_using_1"
class="anchor"></span>Chapter 66: Date and time using &lt;chrono&gt;</p>
<p>header</p>
<p>Section 66.1: Measuring time using &lt;chrono&gt;</p>
<p>The system_clock can be used to measure the time elapsed during some
part of a program's execution.</p>
<p>Version = c++11</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main() {</p>
<p>auto start = std::chrono::system_clock::now(); // This and "end"'s
type is</p>
<p>std::chrono::time_point</p>
<p>{ // The code to test</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(2));</p>
<p>}</p>
<p>auto end = std::chrono::system_clock::now();</p>
<p>std::chrono::duration elapsed = end - start;</p>
<p>std::cout &lt;&lt; "Elapsed time: " &lt;&lt; elapsed.count() &lt;&lt;
"s"; }</p>
<p>In this example, sleep_for was used to make the active thread sleep
for a time period measured in</p>
<p>std::chrono::seconds, but the code between braces could be any
function call that takes some time to execute.</p>
<p>Section 66.2: Find number of days between two dates</p>
<p>This example shows how to find number of days between two dates. A
date is specified by year/month/day of</p>
<p>month, and additionally hour/minute/second.</p>
<p>Program calculates number of days in years since 2000.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>/***</p>
<p>* Creates a std::tm structure from raw date.</p>
<p>*</p>
<p>* \param year (must be 1900 or greater)</p>
<p>* \param month months since January – [1, 12]</p>
<p>* \param day day of the month – [1, 31]</p>
<p>* \param minutes minutes after the hour – [0, 59]</p>
<p>* \param seconds seconds after the minute – [0, 61](until C++11) /
[0, 60] (since C++11) *</p>
<p>* Based on http://en.cppreference.com/w/cpp/chrono/c/tm */</p>
<p>std::tm CreateTmStruct(int year, int month, int day, int hour, int
minutes, int seconds) {</p>
<p>struct tm tm_ret = {0};</p>
<p>tm_ret.tm_sec = seconds;</p>
<p>tm_ret.tm_min = minutes;</p>
<p>tm_ret.tm_hour = hour;</p>
<p>tm_ret.tm_mday = day;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 347</p>
<p>tm_ret.tm_mon = month -1;</p>
<p>tm_ret.tm_year = year -1900;</p>
<p>return tm_ret;</p>
<p>}</p>
<p>int get_days_in_year(int year) {</p>
<p>using namespace std;</p>
<p>using namespace std::chrono;</p>
<p>// We want results to be in days</p>
<p>typedef duration &gt;::type&gt; days;</p>
<p>// Create start time span</p>
<p>std::tm tm_start = CreateTmStruct(year, 1, 1, 0, 0, 0);</p>
<p>auto tms = system_clock::from_time_t(std::mktime(&amp;tm_start));</p>
<p>// Create end time span</p>
<p>std::tm tm_end = CreateTmStruct(year + 1, 1, 1, 0, 0, 0);</p>
<p>auto tme = system_clock::from_time_t(std::mktime(&amp;tm_end));</p>
<p>// Calculate time duration between those two dates auto diff_in_days
= std::chrono::duration_cast(tme - tms);</p>
<p>return diff_in_days.count();</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>for ( int year = 2000; year &lt;= 2016; ++year )</p>
<p>std::cout &lt;&lt; "There are " &lt;&lt; get_days_in_year(year)
&lt;&lt; " days in " &lt;&lt; year &lt;&lt; "<strong>\n</strong>"; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 348</p>
<p><span id="Chapter_67__Sorting_1" class="anchor"></span>Chapter 67:
Sorting</p>
<p>Section 67.1: Sorting and sequence containers</p>
<p>std::sort, found in the standard library header algorithm, is a
standard library algorithm for sorting a range of values, defined by a
pair of iterators. std::sort takes as the last parameter a functor used
to compare two values;</p>
<p>this is how it determines the order. Note that std::sort <a
href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">is not
stable</a>.</p>
<p>The comparison function must impose a <a
href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">Strict,
Weak Ordering</a> on the elements. A simple less-than (or
greater-than)</p>
<p>comparison will suffice.</p>
<p>A container with random-access iterators can be sorted using the
std::sort algorithm:</p>
<p>Version ≥ C++11</p>
<p>#include</p>
<p>#include</p>
<p>std::vector MyVector = {3, 1, 2}</p>
<p>//Default comparison of &lt;</p>
<p>std::sort(MyVector.begin(), MyVector.end());</p>
<p>std::sort requires that its iterators are random access iterators.
The sequence containers std::list and std::forward_list (requiring
C++11) do not provide random access iterators, so they cannot be used
with</p>
<p>std::sort. However, they do have sort member functions which
implement a sorting algorithm that works with their own iterator
types.</p>
<p>Version ≥ C++11</p>
<p>#include</p>
<p>#include</p>
<p>std::list MyList = {3, 1, 2}</p>
<p>//Default comparison of &lt;</p>
<p>//Whole list only.</p>
<p>MyList.sort();</p>
<p>Their member sort functions always sort the entire list, so they
cannot sort a sub-range of elements. However,</p>
<p>since list and forward_list have fast splicing operations, you could
extract the elements to be sorted from the</p>
<p>list, sort them, then stuff them back where they were quite
efficiently like this:</p>
<p>void sort_sublist(std::list&amp; mylist, std::list::const_iterator
start, std::list::const_iterator end) {</p>
<p>//extract and sort half-open sub range denoted by start and end
iterator</p>
<p>std::list tmp;</p>
<p>tmp.splice(tmp.begin(), list, start, end);</p>
<p>tmp.sort();</p>
<p>//re-insert range at the point we extracted it from</p>
<p>list.splice(end, tmp);</p>
<p>}</p>
<p>Section 67.2: sorting with std::map (ascending and</p>
<p>descending)</p>
<p>This example sorts elements in <strong>ascending</strong> order of a
<strong>key</strong> using a map. You can use any type, including
class,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 349</p>
<p>instead of std::string, in the example below.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::map sorted_map;</p>
<p>// Sort the names of the planets according to their size</p>
<p>sorted_map.insert(std::make_pair(0.3829, "Mercury"));</p>
<p>sorted_map.insert(std::make_pair(0.9499, "Venus"));</p>
<p>sorted_map.insert(std::make_pair(1, "Earth"));</p>
<p>sorted_map.insert(std::make_pair(0.532, "Mars"));</p>
<p>sorted_map.insert(std::make_pair(10.97, "Jupiter"));</p>
<p>sorted_map.insert(std::make_pair(9.14, "Saturn"));</p>
<p>sorted_map.insert(std::make_pair(3.981, "Uranus"));</p>
<p>sorted_map.insert(std::make_pair(3.865, "Neptune"));</p>
<p>for (auto const&amp; entry: sorted_map)</p>
<p>{</p>
<p>std::cout &lt;&lt; entry.second &lt;&lt; " (" &lt;&lt; entry.first
&lt;&lt; " of Earth's radius)" &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Mercury (0.3829 of Earth's radius)</p>
<p>Mars (0.532 of Earth's radius)</p>
<p>Venus (0.9499 of Earth's radius)</p>
<p>Earth (1 of Earth's radius)</p>
<p>Neptune (3.865 of Earth's radius)</p>
<p>Uranus (3.981 of Earth's radius)</p>
<p>Saturn (9.14 of Earth's radius)</p>
<p>Jupiter (10.97 of Earth's radius)</p>
<p>If entries with equal keys are possible, use multimap instead of map
(like in the following example).</p>
<p>To sort elements in <strong>descending</strong> manner, declare the
map with a proper comparison functor (std::greater&lt;&gt;):</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::multimap&gt; sorted_map;</p>
<p>// Sort the names of animals in descending order of the number of
legs</p>
<p>sorted_map.insert(std::make_pair(6, "bug"));</p>
<p>sorted_map.insert(std::make_pair(4, "cat"));</p>
<p>sorted_map.insert(std::make_pair(100, "centipede"));</p>
<p>sorted_map.insert(std::make_pair(2, "chicken"));</p>
<p>sorted_map.insert(std::make_pair(0, "fish"));</p>
<p>sorted_map.insert(std::make_pair(4, "horse"));</p>
<p>sorted_map.insert(std::make_pair(8, "spider"));</p>
<p>for (auto const&amp; entry: sorted_map)</p>
<p>{</p>
<p>std::cout &lt;&lt; entry.second &lt;&lt; " (has " &lt;&lt;
entry.first &lt;&lt; " legs)" &lt;&lt; '<strong>\n</strong>';</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 350</p>
<p><span id="_26" class="anchor"></span>}</p>
<p>}</p>
<p>Output</p>
<p>centipede (has 100 legs)</p>
<p>spider (has 8 legs)</p>
<p>bug (has 6 legs)</p>
<p>cat (has 4 legs)</p>
<p>horse (has 4 legs)</p>
<p>chicken (has 2 legs)</p>
<p>fish (has 0 legs)</p>
<p>Section 67.3: Sorting sequence containers by overloaded less</p>
<p>operator</p>
<p>If no ordering function is passed, std::sort will order the elements
by calling operator&lt; on pairs of elements, which must return a type
contextually convertible to bool (or just bool). Basic types (integers,
floats, pointers etc)</p>
<p>have already build in comparison operators.</p>
<p>We can overload this operator to make the default sort call work on
user-defined types.</p>
<p>// Include sequence containers</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>// Insert sorting algorithm</p>
<p>#include</p>
<p>class Base {</p>
<p>public:</p>
<p>// Constructor that set variable to the value of v</p>
<p>Base(int v): variable(v) {</p>
<p>}</p>
<p>// Use variable to provide total order operator less //`this` always
represents the left-hand side of the compare. bool operator&lt;(const
Base &amp;b) const {</p>
<p>return this-&gt;variable &lt; b.variable;</p>
<p>}</p>
<p>int variable;</p>
<p>};</p>
<p>int main() {</p>
<p>std::vector vector;</p>
<p>std::deque deque;</p>
<p>std::list list;</p>
<p>// Create 2 elements to sort</p>
<p>Base a(10);</p>
<p>Base b(5);</p>
<p>// Insert them into backs of containers</p>
<p>vector.push_back(a);</p>
<p>vector.push_back(b);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 351</p>
<p><span id="deque_push_back_a"
class="anchor"></span>deque.push_back(a);</p>
<p>deque.push_back(b);</p>
<p>list.push_back(a);</p>
<p>list.push_back(b);</p>
<p>// Now sort data using operator&lt;(const Base &amp;b) function</p>
<p>std::sort(vector.begin(), vector.end());</p>
<p>std::sort(deque.begin(), deque.end());</p>
<p>// List must be sorted differently due to its design</p>
<p>list.sort();</p>
<p>return 0;</p>
<p>}</p>
<p>Section 67.4: Sorting sequence containers using compare</p>
<p>function</p>
<p>// Include sequence containers</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>// Insert sorting algorithm</p>
<p>#include</p>
<p>class Base {</p>
<p>public:</p>
<p>// Constructor that set variable to the value of v</p>
<p>Base(int v): variable(v) {</p>
<p>}</p>
<p>int variable;</p>
<p>};</p>
<p>bool compare(const Base &amp;a, const Base &amp;b) {</p>
<p>return a.variable &lt; b.variable;</p>
<p>}</p>
<p>int main() {</p>
<p>std::vector vector;</p>
<p>std::deque deque;</p>
<p>std::list list;</p>
<p>// Create 2 elements to sort</p>
<p>Base a(10);</p>
<p>Base b(5);</p>
<p>// Insert them into backs of containers</p>
<p>vector.push_back(a);</p>
<p>vector.push_back(b);</p>
<p>deque.push_back(a);</p>
<p>deque.push_back(b);</p>
<p>list.push_back(a);</p>
<p>list.push_back(b);</p>
<p>// Now sort data using comparing function</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 352</p>
<p><span id="std__sort_vector_begin____vector"
class="anchor"></span>std::sort(vector.begin(), vector.end(),
compare);</p>
<p>std::sort(deque.begin(), deque.end(), compare);</p>
<p>list.sort(compare);</p>
<p>return 0;</p>
<p>}</p>
<p>Section 67.5: Sorting sequence containers using lambda</p>
<p>expressions (C++11)</p>
<p>Version ≥ C++11</p>
<p>// Include sequence containers</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>// Include sorting algorithm</p>
<p>#include</p>
<p>class Base {</p>
<p>public:</p>
<p>// Constructor that set variable to the value of v</p>
<p>Base(int v): variable(v) {</p>
<p>}</p>
<p>int variable;</p>
<p>};</p>
<p>int main() {</p>
<p>// Create 2 elements to sort</p>
<p>Base a(10);</p>
<p>Base b(5);</p>
<p>// We're using C++11, so let's use initializer lists to insert
items.</p>
<p>std::vector vector = {a, b};</p>
<p>std::deque deque = {a, b};</p>
<p>std::list list = {a, b};</p>
<p>std::array array = {a, b};</p>
<p>std::forward_list flist = {a, b};</p>
<p>// We can sort data using an inline lambda expression</p>
<p>std::sort(std::begin(vector), std::end(vector),</p>
<p>[](const Base &amp;a, const Base &amp;b) { return a.variable &lt;
b.variable;});</p>
<p>// We can also pass a lambda object as the comparator // and reuse
the lambda multiple times</p>
<p>auto compare = [](const Base &amp;a, const Base &amp;b) {</p>
<p>return a.variable &lt; b.variable;};</p>
<p>std::sort(std::begin(deque), std::end(deque), compare);</p>
<p>std::sort(std::begin(array), std::end(array), compare);</p>
<p>list.sort(compare);</p>
<p>flist.sort(compare);</p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 353</p>
<p><span id="Section_67_6__Sorting_built_in_a"
class="anchor"></span>Section 67.6: Sorting built-in arrays</p>
<p>The sort algorithm sorts a sequence defined by two iterators. This is
enough to sort a built-in (also known as c-</p>
<p>style) array.</p>
<p>Version ≥ C++11</p>
<p>int arr1[] = {36, 24, 42, 60, 59};</p>
<p>// sort numbers in ascending order</p>
<p>sort(std::begin(arr1), std::end(arr1));</p>
<p>// sort numbers in descending order</p>
<p>sort(std::begin(arr1), std::end(arr1), std::greater());</p>
<p>Prior to C++11, end of array had to be "calculated" using the size of
the array:</p>
<p>Version &lt; C++11</p>
<p>// Use a hard-coded number for array size</p>
<p>sort(arr1, arr1 + 5);</p>
<p>// Alternatively, use an expression</p>
<p>const size_t arr1_size = sizeof(arr1) / sizeof(*arr1); sort(arr1,
arr1 + arr1_size);</p>
<p>Section 67.7: Sorting sequence containers with specifed</p>
<p>ordering</p>
<p>If the values in a container have certain operators already
overloaded, std::sort can be used with specialized</p>
<p>functors to sort in either ascending or descending order:</p>
<p>Version ≥ C++11</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>std::vector v = {5,1,2,4,3};</p>
<p>//sort in ascending order (1,2,3,4,5)</p>
<p>std::sort(v.begin(), v.end(), std::less());</p>
<p>// Or just:</p>
<p>std::sort(v.begin(), v.end());</p>
<p>//sort in descending order (5,4,3,2,1)</p>
<p>std::sort(v.begin(), v.end(), std::greater());</p>
<p>//Or just:</p>
<p>std::sort(v.rbegin(), v.rend());</p>
<p>Version ≥ C++14</p>
<p>In C++14, we don't need to provide the template argument for the
comparison function objects and instead let the object deduce based on
what it gets passed in:</p>
<p>std::sort(v.begin(), v.end(), std::less&lt;&gt;()); // ascending
order std::sort(v.begin(), v.end(), std::greater&lt;&gt;()); //
descending order</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 354</p>
<p><span id="Chapter_68__Enumeration_1" class="anchor"></span>Chapter
68: Enumeration</p>
<p>Section 68.1: Iteration over an enum</p>
<p>There is no built-in to iterate over enumeration.</p>
<p>But there are several ways</p>
<p>for enum with only consecutive values:</p>
<p>enum E {</p>
<p>Begin,</p>
<p>E1 = Begin,</p>
<p>E2,</p>
<p>// ..</p>
<p>En,</p>
<p>End</p>
<p>};</p>
<p>for (E e = E::Begin; e != E::End; ++e) {</p>
<p>// Do job with e</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>with enum class, operator ++ has to be implemented:</p>
<p>E&amp; operator ++ (E&amp; e)</p>
<p>{</p>
<p>if (e == E::End) {</p>
<p>throw std::out_of_range("for E&amp; operator ++ (E&amp;)");</p>
<p>}</p>
<p>e = E(static_cast::type&gt;(e) + 1);</p>
<p>return e;</p>
<p>}</p>
<p>using a container as std::vector</p>
<p>enum E {</p>
<p>E1 = 4,</p>
<p>E2 = 8,</p>
<p>// ..</p>
<p>En</p>
<p>};</p>
<p>std::vector build_all_E()</p>
<p>{</p>
<p>const E all[] = {E1, E2, /*..*/ En};</p>
<p>return std::vector(all, all + sizeof(all) / sizeof(E));</p>
<p>}</p>
<p>std::vector all_E = build_all_E();</p>
<p>and then</p>
<p>for (std::vector::const_iterator it = all_E.begin(); it !=
all_E.end(); ++it) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 355</p>
<p><span id="E_e____it" class="anchor"></span>E e = *it;</p>
<p>// Do job with e;</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>or std::initializer_list and a simpler syntax:</p>
<p>enum E {</p>
<p>E1 = 4,</p>
<p>E2 = 8,</p>
<p>// ..</p>
<p>En</p>
<p>};</p>
<p>constexpr std::initializer_list all_E = {E1, E2, /*..*/ En};</p>
<p>and then</p>
<p>for (auto e : all_E) {</p>
<p>// Do job with e</p>
<p>}</p>
<p>Section 68.2: Scoped enums</p>
<p>C++11 introduces what are known as scoped enums. These are
enumerations whose members must be qualified</p>
<p>with enumname::membername. Scoped enums are declared using the enum
class syntax. For example, to store the colors in a rainbow:</p>
<p>enum class rainbow {</p>
<p>RED,</p>
<p>ORANGE,</p>
<p>YELLOW,</p>
<p>GREEN,</p>
<p>BLUE,</p>
<p>INDIGO,</p>
<p>VIOLET</p>
<p>};</p>
<p>To access a specific color:</p>
<p>rainbow r = rainbow::INDIGO;</p>
<p>enum classes cannot be implicitly converted to ints without a cast.
So int x = rainbow::RED is invalid.</p>
<p>Scoped enums also allow you to specify the underlying type, which is
the type used to represent a member. By default it is int. In a
Tic-Tac-Toe game, you may store the piece as</p>
<p>enum class piece : char {</p>
<p>EMPTY = '<strong>\0</strong>',</p>
<p>X = 'X',</p>
<p>O = 'O',</p>
<p>};</p>
<p>As you may notice, enums can have a trailing comma after the last
member.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 356</p>
<p><span id="Section_68_3__Enum_forward_decla"
class="anchor"></span>Section 68.3: Enum forward declaration in
C++11</p>
<p>Scoped enumerations:</p>
<p>...</p>
<p>enum class Status; // Forward declaration</p>
<p>Status doWork(); // Use the forward declaration</p>
<p>...</p>
<p>enum class Status { Invalid, Success, Fail };</p>
<p>Status doWork() // Full declaration required for implementation {</p>
<p>return Status::Success;</p>
<p>}</p>
<p>Unscoped enumerations:</p>
<p>...</p>
<p>enum Status: int; // Forward declaration, explicit type required
Status doWork(); // Use the forward declaration</p>
<p>...</p>
<p>enum Status: int{ Invalid=0, Success, Fail }; // Must match forward
declare type static_assert( Success == 1 );</p>
<p>An in-depth multi-file example can be found here: <a
href="http://stackoverflow.com/a/19074269/1873507">Blind fruit merchant
example</a></p>
<p>Section 68.4: Basic Enumeration Declaration</p>
<p>Standard enumerations allow users to declare a useful name for a set
of integers. The names are collectively referred to as enumerators. An
enumeration and its associated enumerators are defined as follows:</p>
<p>enum myEnum</p>
<p>{</p>
<p>enumName1,</p>
<p>enumName2,</p>
<p>};</p>
<p>An enumeration is a type, one which is distinct from all other types.
In this case, the name of this type is myEnum. Objects of this type are
expected to assume the value of an enumerator within the
enumeration.</p>
<p>The enumerators declared within the enumeration are constant values
of the type of the enumeration. Though the enumerators are declared
within the type, the scope operator :: is not needed to access the name.
So the name of</p>
<p>the first enumerator is enumName1.</p>
<p>Version ≥ C++11</p>
<p>The scope operator can be optionally used to access an enumerator
within an enumeration. So enumName1 can also</p>
<p>be spelled myEnum::enumName1.</p>
<p>Enumerators are assigned integer values starting from 0 and
increasing by 1 for each enumerator in an enumeration. So in the above
case, enumName1 has the value 0, while enumName2 has the value 1.</p>
<p>Enumerators can also be assigned a specific value by the user; this
value must be an integral constant expression. Enumerators who's values
are not explicitly provided will have their value set to the value of
the previous</p>
<p>enumerator + 1.</p>
<p>enum myEnum</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 357</p>
<p><span id="_27" class="anchor"></span>{</p>
<p>enumName1 = 1, // value will be 1</p>
<p>enumName2 = 2, // value will be 2</p>
<p>enumName3, // value will be 3, previous value + 1</p>
<p>enumName4 = 7, // value will be 7</p>
<p>enumName5, // value will be 8</p>
<p>enumName6 = 5, // value will be 5, legal to go backwards</p>
<p>enumName7 = 3, // value will be 3, legal to reuse numbers</p>
<p>enumName8 = enumName4 + 2, // value will be 9, legal to take prior
enums and adjust them };</p>
<p>Section 68.5: Enumeration in switch statements</p>
<p>A common use for enumerators is for switch statements and so they
commonly appear in state machines. In fact a</p>
<p>useful feature of switch statements with enumerations is that if no
default statement is included for the switch, and not all values of the
enum have been utilized, the compiler will issue a warning.</p>
<p>enum State {</p>
<p>start,</p>
<p>middle,</p>
<p>end</p>
<p>};</p>
<p>...</p>
<p>switch(myState) {</p>
<p>case start:</p>
<p>...</p>
<p>case middle:</p>
<p>...</p>
<p>} // warning: enumeration value 'end' not handled in switch
[-Wswitch]</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 358</p>
<p><span id="Chapter_69__Iteration_1" class="anchor"></span>Chapter 69:
Iteration</p>
<p>Section 69.1: break</p>
<p>Jumps out of the nearest enclosing loop or switch statement.</p>
<p>// print the numbers to a file, one per line</p>
<p>for (const int num : num_list) {</p>
<p>errno = 0;</p>
<p>fprintf(file, "%d<strong>\n</strong>", num);</p>
<p>if (errno == ENOSPC) {</p>
<p>fprintf(stderr, "no space left on device; output will be
truncated<strong>\n</strong>"); break;</p>
<p>}</p>
<p>}</p>
<p>Section 69.2: continue</p>
<p>Jumps to the end of the smallest enclosing loop.</p>
<p>int sum = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>int x;</p>
<p>std::cin &gt;&gt; x;</p>
<p>if (x &lt; 0) continue;</p>
<p>sum += x;</p>
<p>// equivalent to: if (x &gt;= 0) sum += x;</p>
<p>}</p>
<p>Section 69.3: do</p>
<p>Introduces a do-while loop.</p>
<p>// Gets the next non-whitespace character from standard input char
read_char() {</p>
<p>char c;</p>
<p>do {</p>
<p>c = getchar();</p>
<p>} while (isspace(c));</p>
<p>return c;</p>
<p>}</p>
<p>Section 69.4: while</p>
<p>Introduces a while loop.</p>
<p>int i = 0;</p>
<p>// print 10 asterisks</p>
<p>while (i &lt; 10) {</p>
<p>putchar('*');</p>
<p>i++;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 359</p>
<p><span id="Section_69_5__range_based_for_lo"
class="anchor"></span>Section 69.5: range-based for loop</p>
<p>std::vector primes = {2, 3, 5, 7, 11, 13};</p>
<p>for(auto prime : primes) {</p>
<p>std::cout &lt;&lt; prime &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 69.6: for</p>
<p>Introduces a for loop or, in C++11 and later, a range-based for
loop.</p>
<p>// print 10 asterisks</p>
<p>for (int i = 0; i &lt; 10; i++) {</p>
<p>putchar('*');</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 360</p>
<p><span id="Chapter_70__Regular_expressions_1"
class="anchor"></span>Chapter 70: Regular expressions</p>
<p>Signature Description</p>
<p><strong>BidirectionalIterator</strong> is any character iterator
that</p>
<p>bool provides increment and decrement operators
<strong>smatch</strong> may regex_match ( BidirectionalIterator first,
be cmatch or any other other variant of match_results that
BidirectionalIterator last, smatch &amp; sm, const accepts the type of
BidirectionalIterator the smatch regex &amp; re, regex_constraints ::
match_flag_type argument may be ommitted if the results of the regex are
flags ) not needed <strong>Returns</strong> whether re matches the
entire</p>
<p>character sequence defined by first and last</p>
<p><strong>string</strong> may be either a const char* or an L-Value
string,</p>
<p>the functions accepting an R-Value string are explicitly deleted</p>
<p>bool regex_match(const string&amp; str, smatch&amp;
<strong>smatch</strong> may be cmatch or any other other variant of sm,
const regex re&amp;, match_results that accepts the type of str the
smatch regex_constraints::match_flag_type flags) argument may be
ommitted if the results of the regex are</p>
<p>not needed <strong>Returns</strong> whether re matches the entire</p>
<p>character sequence defined by str</p>
<p><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular
Expressions</a> (sometimes called regexs or regexps) are a textual
syntax which represents the patterns which can be matched in the strings
operated upon.</p>
<p><a
href="https://stackoverflow.com/questions/tagged/c%2b%2b11">Regular
Expressions, introduced in c++11, may optionally support a return array
of matched strings or another</a> textual syntax defining how to replace
matched patterns in strings operated upon.</p>
<p>Section 70.1: Basic regex_match and regex_search Examples</p>
<p>const auto input = "Some people, when confronted with a problem,
think <strong>\"</strong>I know, I'll use regular
expressions.<strong>\"</strong>"s;</p>
<p>smatch sm;</p>
<p>cout &lt;&lt; input &lt;&lt; endl;</p>
<p>// If input ends in a quotation that contains a word that begins with
"reg" and another word beginning with "ex" then capture the preceding
portion of input if (regex_match(input, sm,
regex("(.*)<strong>\"</strong>.*<strong>\\</strong>breg.*<strong>\\</strong>bex.*<strong>\"\\</strong>s*$")))
{</p>
<p>const auto capture = sm[1].str();</p>
<p>cout &lt;&lt; '<strong>\t</strong>' &lt;&lt; capture &lt;&lt; endl;
// Outputs: "\tSome people, when confronted with a problem,</p>
<p>think\n"</p>
<p>// Search our capture for "a problem" or "# problems"
if(regex_search(capture, sm,
regex("(a|d+)<strong>\\</strong>s+problems?"))) {</p>
<p>const auto count = sm[1] == "a"s ? 1 : stoi(sm[1]);</p>
<p>cout &lt;&lt; '<strong>\t</strong>' &lt;&lt; count &lt;&lt; (count
&gt; 1 ? " problems<strong>\n</strong>" : "
problem<strong>\n</strong>"); // Outputs: "\t1</p>
<p>problem\n"</p>
<p>cout &lt;&lt; "Now they have " &lt;&lt; count + 1 &lt;&lt; "
problems.<strong>\n</strong>"; // Outputs: "Now they have 2</p>
<p>problems\n"</p>
<p>}</p>
<p>}</p>
<p><a href="http://ideone.com/nSRXEa">Live Example</a></p>
<p>Section 70.2: regex_iterator Example</p>
<p>When processing of captures has to be done iteratively a
regex_iterator is a good choice. Dereferencing a</p>
<p>regex_iterator returns a match_result. This is great for conditional
captures or captures which have</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 361</p>
<p><span id="interdependence__Let_s_say_that"
class="anchor"></span>interdependence. Let's say that we want to
tokenize some C++ code. Given:</p>
<p>enum TOKENS {</p>
<p>NUMBER,</p>
<p>ADDITION,</p>
<p>SUBTRACTION,</p>
<p>MULTIPLICATION,</p>
<p>DIVISION,</p>
<p>EQUALITY,</p>
<p>OPEN_PARENTHESIS,</p>
<p>CLOSE_PARENTHESIS</p>
<p>};</p>
<p>We can tokenize this string: const auto input = "42/2 +
-8<strong>\t</strong>=<strong>\n</strong>(2 + 2) * 2 * 2 -3"s with a
regex_iterator</p>
<p>like this:</p>
<p>vector tokens;</p>
<p>const regex re{
"<strong>\\</strong>s*(<strong>\\</strong>(?)<strong>\\</strong>s*(-?<strong>\\</strong>s*<strong>\\</strong>d+)<strong>\\</strong>s*(<strong>\\</strong>)?)<strong>\\</strong>s*(?:(<strong>\\</strong>+)|(-)|(<strong>\\</strong>*)|(/)|(=))"
};</p>
<p>for_each(sregex_iterator(cbegin(input), cend(input), re),
sregex_iterator(), [&amp;](const auto&amp; i) {</p>
<p>if(i[1].length() &gt; 0) {</p>
<p>tokens.push_back(OPEN_PARENTHESIS);</p>
<p>}</p>
<p>tokens.push_back(i[2].str().front() == '-' ? NEGATIVE_NUMBER :
NON_NEGATIVE_NUMBER);</p>
<p>if(i[3].length() &gt; 0) {</p>
<p>tokens.push_back(CLOSE_PARENTHESIS);</p>
<p>}</p>
<p>auto it = next(cbegin(i), 4);</p>
<p>for(int result = ADDITION; it != cend(i); ++result, ++it) {</p>
<p>if (it-&gt;length() &gt; 0U) {</p>
<p>tokens.push_back(static_cast(result));</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>match_results sm;</p>
<p>if(regex_search(crbegin(input), crend(input), sm, regex{
tokens.back() == SUBTRACTION ?
"^<strong>\\</strong>s*<strong>\\</strong>d+<strong>\\</strong>s*-<strong>\\</strong>s*(-?)"
: "^<strong>\\</strong>s*<strong>\\</strong>d+<strong>\\</strong>s*(-?)"
})) {</p>
<p>tokens.push_back(sm[1].length() == 0 ? NON_NEGATIVE_NUMBER :
NEGATIVE_NUMBER); }</p>
<p><a href="http://ideone.com/Rv5WNI">Live Example</a></p>
<p>A notable gotcha with regex iterators is that the regex <a
href="http://stackoverflow.com/q/29895747/2642059">argument must be an
L-value, an R-value will not work: Visual</a></p>
<p><a href="http://stackoverflow.com/q/29895747/2642059">Studio
regex_iterator Bug?</a></p>
<p>Section 70.3: Anchors</p>
<p>C++ provides only 4 anchors:</p>
<p>^ which asserts the start of the string</p>
<p>$ which asserts the end of the string</p>
<p>\b which asserts a \W character or the beginning or end of the
string</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 362</p>
<p><span id="_B_which_asserts_a__w_character" class="anchor"></span>\B
which asserts a \w character</p>
<p>Let's say for example we want to capture a number with it's sign:</p>
<p>auto input = "+1--12*123/+1234"s;</p>
<p>smatch sm;</p>
<p>if(regex_search(input, sm, regex{
"(?:^|<strong>\\</strong>b<strong>\\</strong>W)([+-]?<strong>\\</strong>d+)"
})) {</p>
<p>do {</p>
<p>cout &lt;&lt; sm[1] &lt;&lt; endl;</p>
<p>input = sm.suffix().str();</p>
<p>} while(regex_search(input, sm, regex{
"(?:^<strong>\\</strong>W|<strong>\\</strong>b<strong>\\</strong>W)([+-]?<strong>\\</strong>d+)"
}));</p>
<p>}</p>
<p><a href="http://ideone.com/uE4dGr">Live Example</a></p>
<p>An important note here is that the anchor does not consume any
characters.</p>
<p>Section 70.4: regex_replace Example</p>
<p><a
href="https://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS">This
code takes in various brace styles and converts them to One True Brace
Style:</a></p>
<p>const auto input = "if
(KnR)<strong>\n\t</strong>foo();<strong>\n</strong>if (spaces)
{<strong>\n</strong> foo();<strong>\n</strong>}<strong>\n</strong>if
(allman)<strong>\n</strong>{<strong>\n\t</strong>foo();<strong>\n</strong>}<strong>\n</strong>if
(horstmann)<strong>\n</strong>{<strong>\t</strong>foo();<strong>\n</strong>}<strong>\n</strong>if
(pico)<strong>\n</strong>{<strong>\t</strong>foo();
}<strong>\n</strong>if
(whitesmiths)<strong>\n\t</strong>{<strong>\n\t</strong>foo();<strong>\n\t</strong>}<strong>\n</strong>"s;</p>
<p>cout &lt;&lt; input &lt;&lt; regex_replace(input,
regex("(.+?)<strong>\\</strong>s*<strong>\\</strong>{?<strong>\\</strong>s*(.+?;)<strong>\\</strong>s*<strong>\\</strong>}?<strong>\\</strong>s*"),
"$1 {<strong>\n\t</strong>$2<strong>\n</strong>}<strong>\n</strong>")
&lt;&lt; endl;</p>
<p><a href="http://ideone.com/ICR5wM">Live Example</a></p>
<p>Section 70.5: regex_token_iterator Example</p>
<p>A <a
href="http://en.cppreference.com/w/cpp/regex/regex_token_iterator">std::regex_token_iterator</a>
<a href="http://stackoverflow.com/a/28880605/2642059">provides a
tremendous tool for extracting elements of a Comma Separated
Value</a></p>
<p><a href="http://stackoverflow.com/a/28880605/2642059">file. Aside
from the advantages of iteration, this iterator is also able to capture
escaped commas where other</a></p>
<p>methods struggle:</p>
<p>const auto input = "please split,this,csv,
,line,<strong>\\</strong>,<strong>\n</strong>"s; const regex re{
"((?:[^<strong>\\\\</strong>,]|<strong>\\\\</strong>.)+)(?:,|$)" };</p>
<p>const vector m_vecFields{ sregex_token_iterator(cbegin(input),
cend(input), re, 1), sregex_token_iterator() };</p>
<p>cout &lt;&lt; input &lt;&lt; endl;</p>
<p>copy(cbegin(m_vecFields), cend(m_vecFields), ostream_iterator(cout,
"<strong>\n</strong>"));</p>
<p><a href="http://ideone.com/lySlTJ">Live Example</a></p>
<p>A notable gotcha with regex iterators is, that the regex <a
href="http://stackoverflow.com/q/29895747/2642059">argument must be an
L-value. An R-value will not work</a>.</p>
<p>Section 70.6: Quantifiers</p>
<p>Let's say that we're given const string input as a phone number to be
validated. We could start by requiring a</p>
<p>numeric input with a <strong>zero or more quantifier</strong>:
regex_match(input, regex("<strong>\\</strong>d*")) or a <strong>one or
more</strong></p>
<p><strong>quantifier</strong>: regex_match(input,
regex("<strong>\\</strong>d+")) But both of those really fall short if
input contains an invalid</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 363</p>
<p>numeric string like: "123" Let's use a <strong>n or more
quantifier</strong> to ensure that we're getting at least 7 digits:</p>
<p>regex_match(input, regex("<strong>\\</strong>d{7,}"))</p>
<p>This will guarantee that we will get at least a phone number of
digits, but input could also contain a numeric string that's too long
like: "123456789012". So lets go with a <strong>between n and m
quantifier</strong> so the input is at least 7 digits</p>
<p>but not more than 11:</p>
<p>regex_match(input, regex("<strong>\\</strong>d{7,11}"));</p>
<p>This gets us closer, but illegal numeric strings that are in the
range of [7, 11] are still accepted, like: "123456789" So</p>
<p>let's make the country code optional with a <strong>lazy
quantifier</strong>:</p>
<p>regex_match(input,
regex("<strong>\\</strong>d?<strong>\\</strong>d{7,10}"))</p>
<p>It's important to note that the <strong>lazy quantifier</strong>
matches as few characters as possible, so the only way this
character</p>
<p>will be matched is if there are already 10 characters that have been
matched by \d{7,10}. (To match the first</p>
<p>character greedily we would have had to do: \d{0,1}.) The
<strong>lazy quantifier</strong> can be appended to any other</p>
<p>quantifier.</p>
<p>Now, how would we make the area code optional and only accept a
country code if the area code was present?</p>
<p>regex_match(input,
regex("(?:<strong>\\</strong>d{3,4})?<strong>\\</strong>d{7}"))</p>
<p>In this final regex, the \d{7} requires 7 digits. These 7 digits are
optionally preceded by either 3 or 4 digits.</p>
<p>Note that we did not append the <strong>lazy quantifier</strong>:
\d{3,4}?\d{7}, the \d{3,4}? would have matched either 3 or 4</p>
<p>characters, preferring 3. Instead we're making the non-capturing
group match at most once, preferring not to</p>
<p>match. Causing a mismatch if input didn't include the area code like:
"1234567".</p>
<p>In conclusion of the quantifier topic, I'd like to mention the other
appending quantifier that you can use, the</p>
<p>possessive quantifier<strong>. Either the</strong> lazy quantifier
<strong>or the</strong> possessive quantifier <strong>can be appended to
any quantifier.</strong></p>
<p>The <strong>possessive quantifier</strong>'s only function is to
assist the regex engine by telling it, greedily take these characters
and don't ever give them up even if it causes the regex to fail. This
for example doesn't make much sense:</p>
<p>regex_match(input,
regex("<strong>\\</strong>d{3,4}+<strong>\\</strong>d{7})) Because an
input like: "1234567890" wouldn't be matched as</p>
<p>\d{3,4}+ will always match 4 characters even if matching 3 would have
allowed the regex to succeed. The <strong>possessive quantifier</strong>
is best used when the quantified token limits the number of matchable
characters. For</p>
<p>example:</p>
<p>regex_match(input, regex("(?:.*<strong>\\</strong>d{3,4}+){3}"))</p>
<p>Can be used to match if input contained any of the following:</p>
<p>123 456 7890</p>
<p>123-456-7890</p>
<p>(123)456-7890</p>
<p>(123) 456 - 7890</p>
<p>But when this regex really shines is when input contains an illegal
input:</p>
<p>12345 - 67890</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 364</p>
<p><span id="Without_the_possessive_quantifie"
class="anchor"></span>Without the <strong>possessive quantifier</strong>
the regex engine has to go back and test every combination of .* and
either 3 or</p>
<p>4 characters to see if it can find a matchable combination. With the
<strong>possessive quantifier</strong> the regex starts where</p>
<p>the 2nd <strong>possessive quantifier</strong> left off, the '0'
character, and the regex engine tries to adjust the .* to allow
\d{3,4}</p>
<p>to match; when it can't the regex just fails, no back tracking is
done to see if earlier .* adjustment could have allowed a match.</p>
<p>Section 70.7: Splitting a string</p>
<p>std::vector split(const std::string &amp;str, std::string regex)
{</p>
<p>std::regex r{ regex };</p>
<p>std::sregex_token_iterator start{ str.begin(), str.end(), r, -1 },
end;</p>
<p>return std::vector(start, end);</p>
<p>}</p>
<p>split("Some string<strong>\t</strong> with whitespace ",
"<strong>\\</strong>s+"); // "Some", "string", "with", "whitespace"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 365</p>
<p><span id="Chapter_71__Implementation_defin_1"
class="anchor"></span>Chapter 71: Implementation-defined</p>
<p>behavior</p>
<p>Section 71.1: Size of integral types</p>
<p>The following types are defined as integral types:</p>
<p>char</p>
<p>Signed integer types</p>
<p>Unsigned integer types</p>
<p>char16_t and char32_t</p>
<p>bool</p>
<p>wchar_t</p>
<p>With the exception of sizeof(char) / sizeof(signed char) /
sizeof(unsigned char), which is split between §</p>
<p>3.9.1.1 [basic.fundamental/1] and § 5.3.3.1 [expr.sizeof], and
sizeof(bool), which is entirely implementation-defined and has no
minimum size, the minimum size requirements of these types are given in
section § 3.9.1</p>
<p>[basic.fundamental] of the standard, and shall be detailed below.</p>
<p>Size of char</p>
<p>All versions of the C++ standard specify, in § 5.3.3.1, that sizeof
yields 1 for unsigned char, signed char, and char (it is implementation
defined whether the char type is signed or unsigned).</p>
<p>Version ≥ C++14</p>
<p>char is large enough to represent 256 different values, to be
suitable for storing UTF-8 code units.</p>
<p>Size of signed and unsigned integer types</p>
<p>The standard specifies, in § 3.9.1.2, that in the list of standard
signed integer types, consisting of signed char, short</p>
<p>int, int, long int, and long long int, each type will provide at
least as much storage as those preceding it in the</p>
<p>list. Furthermore, as specified in § 3.9.1.3, each of these types has
a corresponding standard unsigned integer type, unsigned char , unsigned
short int, unsigned int, unsigned long int, and unsigned long long int,
which has</p>
<p>the same size and alignment as its corresponding signed type.
Additionally, as specified in § 3.9.1.1, char has the</p>
<p>same size and alignment requirements as both signed char and unsigned
char.</p>
<p>Version &lt; C++11</p>
<p>Prior to C++11, long long and unsigned long long were not officially
part of the C++ standard. However, after their introduction to C, in
C99, many compilers supported long long as an extended signed integer
type, and</p>
<p>unsigned long long as an extended unsigned integer type, with the
same rules as the C types.</p>
<p>The standard thus guarantees that:</p>
<p>1 == sizeof(char) == sizeof(signed char) == sizeof(unsigned char)</p>
<p>&lt;= sizeof(short) == sizeof(unsigned short)</p>
<p>&lt;= sizeof(int) == sizeof(unsigned int)</p>
<p>&lt;= sizeof(long) == sizeof(unsigned long)</p>
<p>Version ≥ C++11</p>
<p>&lt;= sizeof(long long) == sizeof(unsigned long long)</p>
<p>Specific minimum sizes for each type are not given by the standard.
Instead, each type has a minimum range of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 366</p>
<p>values it can support, which is, as specified in § 3.9.1.3, inherited
from the C standard, in §5.2.4.2.1. The minimum</p>
<p>size of each type can be roughly inferred from this range, by
determining the minimum number of bits required; note that for any given
platform, any type's actual supported range may be larger than the
minimum. Note that for</p>
<p>signed types, ranges correspond to one's complement, not the more
commonly used two's complement; this is to allow a wider range of
platforms to comply with the standard.</p>
<p>Type Minimum range Minimum bits required</p>
<p>signed char -127 to 127 (-(27 - 1) to (27 - 1)) 8</p>
<p>unsigned char 0 to 255 (0 to 28 - 1) 8</p>
<p>signed short -32,767 to 32,767 (-(215 - 1) to (215 - 1)) 16</p>
<p>unsigned short 0 to 65,535 (0 to 216 - 1) 16</p>
<p>signed int -32,767 to 32,767 (-(215 - 1) to (215 - 1)) 16</p>
<p>unsigned int 0 to 65,535 (0 to 216 - 1) 16</p>
<p>signed long -2,147,483,647 to 2,147,483,647 (-(231 - 1) to (231 - 1))
32</p>
<p>unsigned long 0 to 4,294,967,295 (0 to 232 - 1) 32</p>
<p>Version ≥ C++11</p>
<p>Type Minimum bits Minimum range required</p>
<p>signed -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807 (-(263
- 1) to long long 64 (263 - 1))</p>
<p>unsigned long long 0 to 18,446,744,073,709,551,615 (0 to 264 - 1)
64</p>
<p>As each type is allowed to be greater than its minimum size
requirement, types may differ in size between implementations. The most
notable example of this is with the 64-bit data models LP64 and LLP64,
where LLP64</p>
<p>systems (such as 64-bit Windows) have 32-bit ints and longs, and LP64
systems (such as 64-bit Linux) have 32-bit ints and 64-bit longs. Due to
this, integer types cannot be assumed to have a fixed width across all
platforms.</p>
<p>Version ≥ C++11</p>
<p>If integer types with fixed width are required, use types from the <a
href="http://en.cppreference.com/w/cpp/header/cstdint"><strong>&lt;cstdint&gt;</strong>
header, but note that the standard</a> makes it optional for
implementations to support the exact-width types int8_t, int16_t,
int32_t, int64_t,</p>
<p>intptr_t , uint8_t, uint16_t, uint32_t, uint64_t and uintptr_t.</p>
<p>Version ≥ C++11</p>
<p>Size of char16_t and char32_t</p>
<p>The sizes of char16_t and char32_t are implementation-defined, as
specified in § 5.3.3.1, with the stipulations</p>
<p>given in § 3.9.1.5:</p>
<p>char16_t is large enough to represent any UTF-16 code unit, and has
the same size, signedness, and</p>
<p><a href="http://en.cppreference.com/w/cpp/header/cstdint">alignment
as uint_least16_t</a>; it is thus required to be at least 16 bits in
size.</p>
<p>char32_t is large enough to represent any UTF-32 code unit, and has
the same size, signedness, and</p>
<p><a href="http://en.cppreference.com/w/cpp/header/cstdint">alignment
as uint_least32_t</a>; it is thus required to be at least 32 bits in
size.</p>
<p>Size of bool</p>
<p>The size of bool is implementation defined, and may or may not be
1.</p>
<p>Size of wchar_t</p>
<p>wchar_t , as specified in § 3.9.1.5, is a distinct type, whose range
of values can represent every distinct code unit of the largest extended
character set among the supported locales. It has the same size,
signedness, and alignment as</p>
<p>one of the other integral types, which is known as its underlying
type. This type's size is implementation-defined, as</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 367</p>
<p><span id="specified_in_SS_5_3_3_1__and_may"
class="anchor"></span>specified in § 5.3.3.1, and may be, for example,
at least 8, 16, or 32 bits; if a system supports Unicode, for
example,</p>
<p>wchar_t is required to be at least 32 bits (an exception to this rule
is Windows, where wchar_t is 16 bits for</p>
<p>compatibility purposes). It is inherited from the C90 standard, ISO
9899:1990 § 4.1.5, with only minor rewording.</p>
<p>Depending on the implementation, the size of wchar_t is often, but
not always, 8, 16, or 32 bits. The most common</p>
<p>examples of these are:</p>
<p>In Unix and Unix-like systems, wchar_t is 32-bit, and is usually used
for UTF-32.</p>
<p>In Windows, wchar_t is 16-bit, and is used for UTF-16.</p>
<p>On a system which only has 8-bit support, wchar_t is 8 bit.</p>
<p>Version ≥ C++11</p>
<p>If Unicode support is desired, it is recommended to use char for
UTF-8, char16_t for UTF-16, or char32_t for UTF-32, instead of using
wchar_t.</p>
<p>Data Models</p>
<p>As mentioned above, the widths of integer types can differ between
platforms. The most common models are as</p>
<p>follows, with sizes specified in bits:</p>
<p>Model int long pointer</p>
<p>LP32 (2/4/4) 16 32 32</p>
<p>ILP32 (4/4/4) 32 32 32</p>
<p>LLP64 (4/4/8) 32 32 64</p>
<p>LP64 (4/8/8) 32 64 64</p>
<p>Out of these models:</p>
<p>16-bit Windows used LP32.</p>
<p>32-bit *nix systems (Unix, Linux, Mac OSX, and other Unix-like OSes)
and Windows use ILP32. 64-bit Windows uses LLP64.</p>
<p>64-bit *nix systems use LP64.</p>
<p>Note, however, that these models aren't specifically mentioned in the
standard itself.</p>
<p>Section 71.2: Char might be unsigned or signed</p>
<p>The standard doesn't specify if char should be signed or unsigned.
Different compilers implement it differently, or</p>
<p>might allow to change it using a command line switch.</p>
<p>Section 71.3: Ranges of numeric types</p>
<p>The ranges of the integer types are implementation-defined. The
header <strong>&lt;limits&gt;</strong> provides the</p>
<p>std::numeric_limits template which provides the minimum and maximum
values of all fundamental types. The values satisfy guarantees provided
by the C standard through the <strong>&lt;climits&gt;</strong> and
(&gt;= C++11) <strong>&lt;cinttypes&gt;</strong></p>
<p>headers.</p>
<p>std::numeric_limits::min() equals SCHAR_MIN, which is less than or
equal to -127.</p>
<p>std::numeric_limits::max() equals SCHAR_MAX, which is greater than or
equal to 127. std::numeric_limits::max() equals UCHAR_MAX, which is
greater than or equal to 255.</p>
<p>std::numeric_limits::min() equals SHRT_MIN, which is less than or
equal to -32767. std::numeric_limits::max() equals SHRT_MAX, which is
greater than or equal to 32767.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 368</p>
<p><span id="std__numeric_limits__max___equal"
class="anchor"></span>std::numeric_limits::max() equals USHRT_MAX, which
is greater than or equal to 65535. std::numeric_limits::min() equals
INT_MIN, which is less than or equal to -32767.</p>
<p>std::numeric_limits::max() equals INT_MAX, which is greater than or
equal to 32767.</p>
<p>std::numeric_limits::max() equals UINT_MAX, which is greater than or
equal to 65535. std::numeric_limits::min() equals LONG_MIN, which is
less than or equal to -2147483647.</p>
<p>std::numeric_limits::max() equals LONG_MAX, which is greater than or
equal to 2147483647. std::numeric_limits::max() equals ULONG_MAX, which
is greater than or equal to</p>
<p>4294967295.</p>
<p>Version ≥ C++11</p>
<p>std::numeric_limits::min() equals LLONG_MIN, which is less than or
equal to</p>
<p>-9223372036854775807.</p>
<p>std::numeric_limits::max() equals LLONG_MAX, which is greater than or
equal to</p>
<p>9223372036854775807.</p>
<p>std::numeric_limits::max() equals ULLONG_MAX, which is greater than
or equal to</p>
<p>18446744073709551615.</p>
<p>For floating-point types T, max() is the maximum finite value while
min() is the minimum positive normalized value. Additional members are
provided for floating-point types, which are also implementation-defined
but satisfy</p>
<p>certain guarantees provided by the C standard through the
<strong>&lt;cfloat&gt;</strong> header.</p>
<p>The member digits10 gives the number of decimal digits of
precision.</p>
<p>std::numeric_limits::digits10 equals FLT_DIG, which is at least 6.
std::numeric_limits::digits10 equals DBL_DIG, which is at least 10.</p>
<p>std::numeric_limits::digits10 equals LDBL_DIG, which is at least
10.</p>
<p>The member min_exponent10 is the minimum negative E such that 10 to
the power E is normal.</p>
<p>std::numeric_limits::min_exponent10 equals FLT_MIN_10_EXP, which is
at most -37.</p>
<p>std::numeric_limits::min_exponent10 equals DBL_MIN_10_EXP, which is
at most -37. std::numeric_limits::min_exponent10 equals LDBL_MIN_10_EXP,
which is at most -37.</p>
<p>The member max_exponent10 is the maximum E such that 10 to the power
E is finite.</p>
<p>std::numeric_limits::max_exponent10 equals FLT_MIN_10_EXP, which is
at least 37.</p>
<p>std::numeric_limits::max_exponent10 equals DBL_MIN_10_EXP, which is
at least 37. std::numeric_limits::max_exponent10 equals LDBL_MIN_10_EXP,
which is at least 37.</p>
<p>If the member is_iec559 is true, the type conforms to IEC 559 / IEEE
754, and its range is therefore determined by that standard.</p>
<p>Section 71.4: Value representation of floating point types</p>
<p>The standard requires that long double provides at least as much
precision as double, which provides at least as much precision as float;
and that a long double can represent any value that a double can
represent, while a</p>
<p>double can represent any value that a float can represent. The
details of the representation are, however, implementation-defined.</p>
<p>For a floating point type T, std::numeric_limits::radix specifies the
radix used by the representation of T.</p>
<p>If std::numeric_limits::is_iec559 is true, then the representation of
T matches one of the formats defined</p>
<p>by IEC 559 / IEEE 754.</p>
<p>Section 71.5: Overflow when converting from integer to</p>
<p>signed integer</p>
<p>When either a signed or unsigned integer is converted to a signed
integer type, and its value is not representable in</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 369</p>
<p><span id="the_destination_type__the_value" class="anchor"></span>the
destination type, the value produced is implementation-defined.
Example:</p>
<p>// Suppose that on this implementation, the range of signed char is
-128 to +127 and // the range of unsigned char is 0 to 255</p>
<p>int x = 12345;</p>
<p>signed char sc = x; // sc has an implementation-defined value
unsigned char uc = x; // uc is initialized to 57 (i.e., 12345 modulo
256)</p>
<p>Section 71.6: Underlying type (and hence size) of an enum</p>
<p>If the underlying type is not explicitly specified for an unscoped
enumeration type, it is determined in an implementation-defined
manner.</p>
<p>enum E {</p>
<p>RED,</p>
<p>GREEN,</p>
<p>BLUE,</p>
<p>};</p>
<p>using T = std::underlying_type::type; // implementation-defined</p>
<p>However, the standard does require the underlying type of an
enumeration to be no larger than int unless both</p>
<p>int and unsigned int are unable to represent all the values of the
enumeration. Therefore, in the above code, T</p>
<p>could be int, unsigned int, or short, but not long long, to give a
few examples.</p>
<p>Note that an enum has the same size (as returned by sizeof) as its
underlying type.</p>
<p>Section 71.7: Numeric value of a pointer</p>
<p>The result of casting a pointer to an integer using reinterpret_cast
is implementation-defined, but "... is intended</p>
<p>to be unsurprising to those who know the addressing structure of the
underlying machine."</p>
<p>int x = 42;</p>
<p>int* p = &amp;x;</p>
<p>long addr = reinterpret_cast(p);</p>
<p>std::cout &lt;&lt; addr &lt;&lt; "<strong>\n</strong>"; // prints
some numeric address,</p>
<p>// probably in the architecture's native address format</p>
<p>Likewise, the pointer obtained by conversion from an integer is also
implementation-defined.</p>
<p>The right way to store a pointer as an integer is using the uintptr_t
or intptr_t types:</p>
<p>// `uintptr_t` was not in C++03. It's in C99, in , as an optional
type #include</p>
<p>uintptr_t uip;</p>
<p>Version ≥ C++11</p>
<p>// There is an optional `std::uintptr_t` in C++11</p>
<p>#include</p>
<p>std::uintptr_t uip;</p>
<p>C++11 refers to C99 for the definition uintptr_t (C99 standard,
6.3.2.3):</p>
<p>an unsigned integer type with the property that any valid pointer to
void can be converted to this type,</p>
<p>then converted back to pointer to void, and the result will compare
equal to the original pointer.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 370</p>
<p><span id="While__for_the_majority_of_moder"
class="anchor"></span>While, for the majority of modern platforms, you
can assume a flat address space and that arithmetic on uintptr_t is
equivalent to arithmetic on char *, it's entirely possible for an
implementation to perform any transformation</p>
<p>when casting void * to uintptr_t as long the transformation can be
reversed when casting back from uintptr_t</p>
<p>to void *.</p>
<p>Technicalities</p>
<p>On XSI-conformant (X/Open System Interfaces) systems, intptr_t and
uintptr_t types are required,</p>
<p>otherwise they are <strong>optional</strong>.</p>
<p>Within the meaning of the C standard, functions aren't objects; it
isn't guaranteed by the C standard that</p>
<p>uintptr_t can hold a function pointer. Anyway POSIX (2.12.3)
conformance requires that:</p>
<p>All function pointer types shall have the same representation as the
type pointer to void.</p>
<p>Conversion of a function pointer to void * shall not alter the
representation. A void * value resulting from such a conversion can be
converted back to the original function pointer type, using</p>
<p>an explicit cast, without loss of information.</p>
<p>C99 §7.18.1:</p>
<p>When typedef names differing only in the absence or presence of the
initial u are defined, they</p>
<p>shall denote corresponding signed and unsigned types as described in
6.2.5; an implementation providing one of these corresponding types
shall also provide the other.</p>
<p>uintptr_t might make sense if you want to do things to the bits of
the pointer that you can't do as sensibly</p>
<p>with a signed integer.</p>
<p>Section 71.8: Number of bits in a byte</p>
<p>In C++, a byte is the space occupied by a char object. The number of
bits in a byte is given by CHAR_BIT, which is defined in climits and
required to be at least 8. While most modern systems have 8-bit bytes,
and POSIX requires</p>
<p>CHAR_BIT to be exactly 8, there are some systems where CHAR_BIT is
greater than 8 i.e a single byte may be comprised of 8, 16, 32 or 64
bits.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 371</p>
<p><span id="Chapter_72__Exceptions_1" class="anchor"></span>Chapter 72:
Exceptions</p>
<p>Section 72.1: Catching exceptions</p>
<p>A try/catch block is used to catch exceptions. The code in the try
section is the code that may throw an exception, and the code in the
catch clause(s) handles the exception.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main() {</p>
<p>std::string str("foo");</p>
<p>try {</p>
<p>str.at(10); // access element, may throw std::out_of_range</p>
<p>} catch (const std::out_of_range&amp; e) {</p>
<p>// what() is inherited from std::exception and contains an
explanatory message</p>
<p>std::cout &lt;&lt; e.what();</p>
<p>}</p>
<p>}</p>
<p>Multiple catch clauses may be used to handle multiple exception
types. If multiple catch clauses are present, the</p>
<p>exception handling mechanism tries to match them <strong>in
order</strong> of their appearance in the code:</p>
<p>std::string str("foo");</p>
<p>try {</p>
<p>str.reserve(2); // reserve extra capacity, may throw
std::length_error</p>
<p>str.at(10); // access element, may throw std::out_of_range } catch
(const std::length_error&amp; e) {</p>
<p>std::cout &lt;&lt; e.what();</p>
<p>} catch (const std::out_of_range&amp; e) {</p>
<p>std::cout &lt;&lt; e.what();</p>
<p>}</p>
<p>Exception classes which are derived from a common base class can be
caught with a single catch clause for the common base class. The above
example can replace the two catch clauses for std::length_error and</p>
<p>std::out_of_range with a single clause for std:exception:</p>
<p>std::string str("foo");</p>
<p>try {</p>
<p>str.reserve(2); // reserve extra capacity, may throw
std::length_error</p>
<p>str.at(10); // access element, may throw std::out_of_range } catch
(const std::exception&amp; e) {</p>
<p>std::cout &lt;&lt; e.what();</p>
<p>}</p>
<p>Because the catch clauses are tried in order, be sure to write more
specific catch clauses first, otherwise your exception handling code
might never get called:</p>
<p>try {</p>
<p>/* Code throwing exceptions omitted. */</p>
<p>} catch (const std::exception&amp; e) {</p>
<p>/* Handle all exceptions of type std::exception. */</p>
<p>} catch (const std::runtime_error&amp; e) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 372</p>
<p><span id="___This_block_of_code_will_never" class="anchor"></span>/*
This block of code will never execute, because std::runtime_error
inherits</p>
<p>from std::exception, and all exceptions of type std::exception were
already</p>
<p>caught by the previous catch clause. */</p>
<p>}</p>
<p>Another possibility is the catch-all handler, which will catch any
thrown object:</p>
<p>try {</p>
<p>throw 10;</p>
<p>} catch (...) {</p>
<p>std::cout &lt;&lt; "caught an exception";</p>
<p>}</p>
<p>Section 72.2: Rethrow (propagate) exception</p>
<p>Sometimes you want to do something with the exception you catch (like
write to log or print a warning) and let it</p>
<p>bubble up to the upper scope to be handled. To do so, you can rethrow
any exception you catch:</p>
<p>try {</p>
<p>... // some code here</p>
<p>} catch (const SomeException&amp; e) {</p>
<p>std::cout &lt;&lt; "caught an exception";</p>
<p>throw;</p>
<p>}</p>
<p>Using throw; without arguments will re-throw the currently caught
exception.</p>
<p>Version ≥ C++11</p>
<p>To rethrow a managed std::exception_ptr, the C++ Standard Library has
the rethrow_exception function that can be used by including the
<strong>&lt;exception&gt;</strong> header in your program.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>void handle_eptr(std::exception_ptr eptr) // passing by value is ok
{</p>
<p>try {</p>
<p>if (eptr) {</p>
<p>std::rethrow_exception(eptr);</p>
<p>}</p>
<p>} catch(const std::exception&amp; e) {</p>
<p>std::cout &lt;&lt; "Caught exception <strong>\"</strong>" &lt;&lt;
e.what() &lt;&lt; "<strong>\"\n</strong>";</p>
<p>}</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>std::exception_ptr eptr;</p>
<p>try {</p>
<p>std::string().at(1); // this generates an std::out_of_range</p>
<p>} catch(...) {</p>
<p>eptr = std::current_exception(); // capture</p>
<p>}</p>
<p>handle_eptr(eptr);</p>
<p>} // destructor for std::out_of_range called here, when the eptr is
destructed</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 373</p>
<p><span id="Section_72_3__Best_practice__thr"
class="anchor"></span>Section 72.3: Best practice: throw by value, catch
by const</p>
<p>reference</p>
<p>In general, it is considered good practice to throw by value (rather
than by pointer), but catch by (const) reference.</p>
<p>try {</p>
<p>// throw new std::runtime_error("Error!"); // Don't do this! // This
creates an exception object</p>
<p>// on the heap and would require you to catch the</p>
<p>// pointer and manage the memory yourself. This can // cause memory
leaks!</p>
<p>throw std::runtime_error("Error!");</p>
<p>} catch (const std::runtime_error&amp; e) {</p>
<p>std::cout &lt;&lt; e.what() &lt;&lt; std::endl;</p>
<p>}</p>
<p>One reason why catching by reference is a good practice is that it
eliminates the need to reconstruct the object</p>
<p>when being passed to the catch block (or when propagating through to
other catch blocks). Catching by reference also allows the exceptions to
be handled polymorphically and avoids object slicing. However, if you
are rethrowing</p>
<p>an exception (like throw e;, see example below), you can still get
object slicing because the throw e; statement</p>
<p>makes a copy of the exception as whatever type is declared:</p>
<p>#include</p>
<p>struct BaseException {</p>
<p>virtual const char* what() const { return "BaseException"; }</p>
<p>};</p>
<p>struct DerivedException : BaseException {</p>
<p>// "virtual" keyword is optional here</p>
<p>virtual const char* what() const { return "DerivedException"; }</p>
<p>};</p>
<p>int main(int argc, char** argv) {</p>
<p>try {</p>
<p>try {</p>
<p>throw DerivedException();</p>
<p>} catch (const BaseException&amp; e) {</p>
<p>std::cout &lt;&lt; "First catch block: " &lt;&lt; e.what() &lt;&lt;
std::endl;</p>
<p>// Output ==&gt; First catch block: DerivedException</p>
<p>throw e; // This changes the exception to BaseException</p>
<p>// instead of the original DerivedException!</p>
<p>}</p>
<p>} catch (const BaseException&amp; e) {</p>
<p>std::cout &lt;&lt; "Second catch block: " &lt;&lt; e.what() &lt;&lt;
std::endl;</p>
<p>// Output ==&gt; Second catch block: BaseException</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>If you are sure that you are not going to do anything to change the
exception (like add information or modify the</p>
<p>message), catching by const reference allows the compiler to make
optimizations and can improve performance. But this can still cause
object splicing (as seen in the example above).</p>
<p><strong>Warning:</strong> Beware of throwing unintended exceptions in
catch blocks, especially related to allocating extra memory</p>
<p>or resources. For example, constructing logic_error, runtime_error or
their subclasses might throw bad_alloc</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 374</p>
<p><span id="due_to_memory_running_out_when_c" class="anchor"></span>due
to memory running out when copying the exception string, I/O streams
might throw during logging with respective exception masks set, etc.</p>
<p>Section 72.4: Custom exception</p>
<p>You shouldn't throw raw values as exceptions, instead use one of the
standard exception classes or make your own.</p>
<p>Having your own exception class inherited from std::exception is a
good way to go about it. Here's a custom exception class which directly
inherits from std::exception:</p>
<p>#include</p>
<p>class Except: virtual public std::exception {</p>
<p>protected:</p>
<p>int error_number; ///&lt; Error number</p>
<p>int error_offset; ///&lt; Error offset</p>
<p>std::string error_message; ///&lt; Error message</p>
<p>public:</p>
<p>/** Constructor (C++ STL string, int, int).</p>
<p>* @param msg The error message</p>
<p>* @param err_num Error number</p>
<p>* @param err_off Error offset</p>
<p>*/</p>
<p>explicit</p>
<p>Except(const std::string&amp; msg, int err_num, int err_off):</p>
<p>error_number(err_num),</p>
<p>error_offset(err_off),</p>
<p>error_message(msg)</p>
<p>{}</p>
<p>/** Destructor.</p>
<p>* Virtual to allow for subclassing.</p>
<p>*/</p>
<p>virtual ~Except() throw () {}</p>
<p>/** Returns a pointer to the (constant) error description.</p>
<p>* @return A pointer to a const char*. The underlying memory</p>
<p>* is in possession of the Except object. Callers must</p>
<p>* not attempt to free the memory.</p>
<p>*/</p>
<p>virtual const char* what() const throw () {</p>
<p>return error_message.c_str();</p>
<p>}</p>
<p>/** Returns error number.</p>
<p>* @return #error_number</p>
<p>*/</p>
<p>virtual int getErrorNumber() const throw() {</p>
<p>return error_number;</p>
<p>}</p>
<p>/**Returns error offset.</p>
<p>* @return #error_offset</p>
<p>*/</p>
<p>virtual int getErrorOffset() const throw() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 375</p>
<p>return error_offset;</p>
<p>}</p>
<p>};</p>
<p>An example throw catch:</p>
<p>try {</p>
<p>throw(Except("Couldn't do what you were expecting", -12, -34));</p>
<p>} catch (const Except&amp; e) {</p>
<p>std::cout&lt;</p>
<p>&lt;&lt;"<strong>\n</strong>Error number: "&lt;</p>
<p>&lt;&lt;"<strong>\n</strong>Error offset: "&lt;</p>
<p>}</p>
<p>As you are not only just throwing a dumb error message, also some
other values representing what the error exactly was, your error
handling becomes much more efficient and meaningful.</p>
<p>There's an exception class that let's you handle error messages
nicely :std::runtime_error</p>
<p>You can inherit from this class too:</p>
<p>#include</p>
<p>class Except: virtual public std::runtime_error {</p>
<p>protected:</p>
<p>int error_number; ///&lt; Error number</p>
<p>int error_offset; ///&lt; Error offset</p>
<p>public:</p>
<p>/** Constructor (C++ STL string, int, int).</p>
<p>* @param msg The error message</p>
<p>* @param err_num Error number</p>
<p>* @param err_off Error offset</p>
<p>*/</p>
<p>explicit</p>
<p>Except(const std::string&amp; msg, int err_num, int err_off):</p>
<p>std::runtime_error(msg)</p>
<p>{</p>
<p>error_number = err_num;</p>
<p>error_offset = err_off;</p>
<p>}</p>
<p>/** Destructor.</p>
<p>* Virtual to allow for subclassing.</p>
<p>*/</p>
<p>virtual ~Except() throw () {}</p>
<p>/** Returns error number.</p>
<p>* @return #error_number</p>
<p>*/</p>
<p>virtual int getErrorNumber() const throw() {</p>
<p>return error_number;</p>
<p>}</p>
<p>/**Returns error offset.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 376</p>
<p><span id="___return__error_offset" class="anchor"></span>* @return
#error_offset</p>
<p>*/</p>
<p>virtual int getErrorOffset() const throw() {</p>
<p>return error_offset;</p>
<p>}</p>
<p>};</p>
<p>Note that I haven't overridden the what() function from the base
class (std::runtime_error) i.e we will be using the base class's version
of what(). You can override it if you have further agenda.</p>
<p>Section 72.5: std::uncaught_exceptions</p>
<p>Version ≥ c++17</p>
<p>C++17 introduces int std::uncaught_exceptions() (to replace the
limited bool std::uncaught_exception()) to</p>
<p>know how many exceptions are currently uncaught. That allows for a
class to determine if it is destroyed during a stack unwinding or
not.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>// Apply change on destruction:</p>
<p>// Rollback in case of exception (failure)</p>
<p>// Else Commit (success)</p>
<p>class Transaction</p>
<p>{</p>
<p>public:</p>
<p>Transaction(const std::string&amp; s) : message(s) {}</p>
<p>Transaction(const Transaction&amp;) = delete;</p>
<p>Transaction&amp; operator =(const Transaction&amp;) = delete;</p>
<p>void Commit() { std::cout &lt;&lt; message &lt;&lt; ":
Commit<strong>\n</strong>"; } void RollBack() noexcept(true) { std::cout
&lt;&lt; message &lt;&lt; ": Rollback<strong>\n</strong>"; }</p>
<p>// ...</p>
<p>~Transaction() {</p>
<p>if (uncaughtExceptionCount == std::uncaught_exceptions()) {</p>
<p>Commit(); // May throw.</p>
<p>} else { // current stack unwinding</p>
<p>RollBack();</p>
<p>}</p>
<p>}</p>
<p>private:</p>
<p>std::string message;</p>
<p>int uncaughtExceptionCount = std::uncaught_exceptions();</p>
<p>};</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p>~Foo() {</p>
<p>try {</p>
<p>Transaction transaction("In ~Foo"); // Commit,</p>
<p>// even if there is an uncaught exception</p>
<p>//...</p>
<p>} catch (const std::exception&amp; e) {</p>
<p>std::cerr &lt;&lt; "exception/~Foo:" &lt;&lt; e.what() &lt;&lt;
std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 377</p>
<p><span id="_28" class="anchor"></span>}</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>try {</p>
<p>Transaction transaction("In main"); // RollBack</p>
<p>Foo foo; // ~Foo commit its transaction.</p>
<p>//...</p>
<p>throw std::runtime_error("Error");</p>
<p>} catch (const std::exception&amp; e) {</p>
<p>std::cerr &lt;&lt; "exception/main:" &lt;&lt; e.what() &lt;&lt;
std::endl;</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>In ~Foo: Commit</p>
<p>In main: Rollback</p>
<p>exception/main:Error</p>
<p>Section 72.6: Function Try Block for regular function</p>
<p>void function_with_try_block()</p>
<p>try</p>
<p>{</p>
<p>// try block body</p>
<p>}</p>
<p>catch (...)</p>
<p>{</p>
<p>// catch block body</p>
<p>}</p>
<p>Which is equivalent to</p>
<p>void function_with_try_block()</p>
<p>{</p>
<p>try</p>
<p>{</p>
<p>// try block body</p>
<p>}</p>
<p>catch (...)</p>
<p>{</p>
<p>// catch block body</p>
<p>}</p>
<p>}</p>
<p>Note that for constructors and destructors, the behavior is different
as the catch block re-throws an exception</p>
<p>anyway (the caught one if there is no other throw in the catch block
body).</p>
<p>The function main is allowed to have a function try block like any
other function, but main's function try block will not catch exceptions
that occur during the construction of a non-local static variable or the
destruction of any static</p>
<p>variable. Instead, std::terminate is called.</p>
<p>Section 72.7: Nested exception</p>
<p>Version ≥ C++11</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 378</p>
<p>During exception handling there is a common use case when you catch a
generic exception from a low-level function (such as a filesystem error
or data transfer error) and throw a more specific high-level exception
which</p>
<p>indicates that some high-level operation could not be performed (such
as being unable to publish a photo on Web).</p>
<p>This allows exception handling to react to specific problems with
high level operations and also allows, having only error an message, the
programmer to find a place in the application where an exception
occurred. Downside of this</p>
<p>solution is that exception callstack is truncated and original
exception is lost. This forces developers to manually include text of
original exception into a newly created one.</p>
<p>Nested exceptions aim to solve the problem by attaching low-level
exception, which describes the cause, to a high level exception, which
describes what it means in this particular case.</p>
<p>std::nested_exception allows to nest exceptions thanks to
std::throw_with_nested:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct MyException</p>
<p>{</p>
<p>MyException(const std::string&amp; message) : message(message) {}</p>
<p>std::string message;</p>
<p>};</p>
<p>void print_current_exception(int level)</p>
<p>{</p>
<p>try {</p>
<p>throw;</p>
<p>} catch (const std::exception&amp; e) {</p>
<p>std::cerr &lt;&lt; std::string(level, ' ') &lt;&lt; "exception: "
&lt;&lt; e.what() &lt;&lt; '<strong>\n</strong>';</p>
<p>} catch (const MyException&amp; e) {</p>
<p>std::cerr &lt;&lt; std::string(level, ' ') &lt;&lt; "MyException: "
&lt;&lt; e.message &lt;&lt; '<strong>\n</strong>';</p>
<p>} catch (...) {</p>
<p>std::cerr &lt;&lt; "Unkown exception<strong>\n</strong>";</p>
<p>}</p>
<p>}</p>
<p>void print_current_exception_with_nested(int level = 0) {</p>
<p>try {</p>
<p>throw;</p>
<p>} catch (...) {</p>
<p>print_current_exception(level);</p>
<p>}</p>
<p>try {</p>
<p>throw;</p>
<p>} catch (const std::nested_exception&amp; nested) {</p>
<p>try {</p>
<p>nested.rethrow_nested();</p>
<p>} catch (...) {</p>
<p>print_current_exception_with_nested(level + 1); // recursion</p>
<p>}</p>
<p>} catch (...) {</p>
<p>//Empty // End recursion</p>
<p>}</p>
<p>}</p>
<p>// sample function that catches an exception and wraps it in a nested
exception void open_file(const std::string&amp; s)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 379</p>
<p><span id="_29" class="anchor"></span>{</p>
<p>try {</p>
<p>std::ifstream file(s);</p>
<p>file.exceptions(std::ios_base::failbit);</p>
<p>} catch(...) {</p>
<p>std::throw_with_nested(MyException{"Couldn't open " + s});</p>
<p>}</p>
<p>}</p>
<p>// sample function that catches an exception and wraps it in a nested
exception void run()</p>
<p>{</p>
<p>try {</p>
<p>open_file("nonexistent.file");</p>
<p>} catch(...) {</p>
<p>std::throw_with_nested( std::runtime_error("run() failed") );</p>
<p>}</p>
<p>}</p>
<p>// runs the sample function above and prints the caught exception int
main()</p>
<p>{</p>
<p>try {</p>
<p>run();</p>
<p>} catch(...) {</p>
<p>print_current_exception_with_nested();</p>
<p>}</p>
<p>}</p>
<p>Possible output:</p>
<p>exception: run() failed</p>
<p>MyException: Couldn't open nonexistent.file</p>
<p>exception: basic_ios::clear</p>
<p>If you work only with exceptions inherited from std::exception, code
can even be simplified.</p>
<p>Section 72.8: Function Try Blocks In constructor</p>
<p>The only way to catch exception in initializer list:</p>
<p>struct A : public B</p>
<p>{</p>
<p>A() try : B(), foo(1), bar(2)</p>
<p>{</p>
<p>// constructor body</p>
<p>}</p>
<p>catch (...)</p>
<p>{</p>
<p>// exceptions from the initializer list and constructor are caught
here // if no exception is thrown here</p>
<p>// then the caught exception is re-thrown.</p>
<p>}</p>
<p>private:</p>
<p>Foo foo;</p>
<p>Bar bar;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 380</p>
<p><span id="Section_72_9__Function_Try_Block"
class="anchor"></span>Section 72.9: Function Try Blocks In
destructor</p>
<p>struct A</p>
<p>{</p>
<p>~A() noexcept(false) try</p>
<p>{</p>
<p>// destructor body</p>
<p>}</p>
<p>catch (...)</p>
<p>{</p>
<p>// exceptions of destructor body are caught here</p>
<p>// if no exception is thrown here</p>
<p>// then the caught exception is re-thrown.</p>
<p>}</p>
<p>};</p>
<p>Note that, although this is possible, one needs to be very careful
with throwing from destructor, as if a destructor called during stack
unwinding throws an exception, std::terminate is called.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 381</p>
<p><span id="Chapter_73__Lambdas_1" class="anchor"></span>Chapter 73:
Lambdas</p>
<p>Parameter Details</p>
<p>Specifies how all non-listed variables are captured. Can be =
(capture by value) or &amp; (capture by</p>
<p>default-capture reference). If omitted, non-listed variables are
inaccessible within the lambda-body. The default-</p>
<p>capture must precede the capture-list.</p>
<p>Specifies how local variables are made accessible within the
lambda-body. Variables without</p>
<p>capture-list prefix are captured by value. Variables prefixed with
&amp; are captured by reference. Within a class method, this can be used
to make all its members accessible by reference. Non-listed
variables</p>
<p>are inaccessible, unless the list is preceded by a
default-capture.</p>
<p>argument-list Specifies the arguments of the lambda function.</p>
<p>mutable const. Changes to those variables are retained between calls.
(optional) Normally variables captured by value are const. Specifying
mutable makes them non-</p>
<p>throw-specification (optional) Specifies the exception throwing
behavior of the lambda function. For example: noexcept or throw ( std ::
exception ) .</p>
<p>attributes (optional) Any attributes for the lambda function. For
example, if the lambda-body always throws an exception then [[ noreturn
]] can be used.</p>
<p>-&gt; (optional) Specifies the return type of the lambda function.
Required when the return type return-type cannot be determined by the
compiler.</p>
<p>lambda-body A code block containing the implementation of the lambda
function.</p>
<p>Section 73.1: What is a lambda expression?</p>
<p>A <strong>lambda expression</strong> provides a concise way to create
simple function objects. A lambda expression is a prvalue</p>
<p><a
href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">whose
result object is called closure object, which behaves like a function
object.</a></p>
<p><a href="https://en.wikipedia.org/wiki/Lambda_calculus">The name
'lambda expression' originates from lambda calculus, which is a
mathematical formalism invented in the</a></p>
<p>1930s by Alonzo Church to investigate questions about logic and
computability. Lambda calculus formed the basis</p>
<p>of <a
href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP, a
functional programming language. Compared to lambda calculus and LISP,
C++ lambda expressions share</a></p>
<p>the properties of being unnamed, and to capture variables from the
surrounding context, but they lack the ability to operate on and return
functions.</p>
<p>A lambda expression is often used as an argument to functions that
take a callable object. That can be simpler than creating a named
function, which would be only used when passed as the argument. In such
cases, lambda</p>
<p>expressions are generally preferred because they allow defining the
function objects inline.</p>
<p>A lambda consists typically of three parts: a capture list [], an
optional parameter list () and a body {}, all of which</p>
<p>can be empty:</p>
<p>[](){} // An empty lambda, which does and returns nothing</p>
<p>Capture list</p>
<p>[] is the <strong>capture list</strong>. By default, variables of the
enclosing scope cannot be accessed by a lambda. Capturing a</p>
<p>variable makes it accessible inside the lambda, either as a copy or
as a reference. Captured variables become a part of the lambda; in
contrast to function arguments, they do not have to be passed when
calling the lambda.</p>
<p>int a = 0; // Define an integer variable</p>
<p>auto f = []() { return a*9; }; // Error: 'a' cannot be accessed auto
f = [a]() { return a*9; }; // OK, 'a' is "captured" by value auto f =
[&amp;a]() { return a++; }; // OK, 'a' is "captured" by reference</p>
<p>// Note: It is the responsibility of the programmer // to ensure that
a is not destroyed before the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 382</p>
<p>// lambda is called.</p>
<p>auto b = f(); // Call the lambda function. a is taken from the
capture list and</p>
<p>not passed here.</p>
<p>Parameter list</p>
<p>() is the <strong>parameter list</strong>, which is almost the same
as in regular functions. If the lambda takes no arguments, these</p>
<p>parentheses can be omitted (except if you need to declare the lambda
mutable). These two lambdas are equivalent:</p>
<p>auto call_foo = [x](){ x.foo(); };</p>
<p>auto call_foo2 = [x]{ x.foo(); };</p>
<p>Version ≥ C++14</p>
<p>The parameter list can use the placeholder type auto instead of
actual types. By doing so, this argument behaves</p>
<p>like a template parameter of a function template. Following lambdas
are equivalent when you want to sort a vector in generic code:</p>
<p>auto sort_cpp11 = [](std::vector::const_reference lhs,
std::vector::const_reference rhs) { return lhs &lt; rhs; };</p>
<p>auto sort_cpp14 = [](const auto &amp;lhs, const auto &amp;rhs) {
return lhs &lt; rhs; };</p>
<p>Function body</p>
<p>{} is the <strong>body</strong>, which is the same as in regular
functions.</p>
<p>Calling a lambda</p>
<p><a
href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">A
lambda expression's result object is a closure</a>, which can be called
using the operator() (as with other function objects):</p>
<p>int multiplier = 5;</p>
<p>auto timesFive = [multiplier](int a) { return a * multiplier; };
std::out &lt;&lt; timesFive(2); // Prints 10</p>
<p>multiplier = 15;</p>
<p>std::out &lt;&lt; timesFive(2); // Still prints 2*5 == 10</p>
<p>Return Type</p>
<p>By default, the return type of a lambda expression is deduced.</p>
<p>[](){ return true; };</p>
<p>In this case the return type is bool.</p>
<p>You can also manually specify the return type using the following
syntax:</p>
<p>[]()-&gt; bool { return true; };</p>
<p>Mutable Lambda</p>
<p>Objects captured by value in the lambda are by default immutable.
This is because the operator() of the generated closure object is const
by default.</p>
<p>auto func = [c = 0](){++c; std::cout &lt;&lt; c;}; // fails to
compile because ++c</p>
<p>// tries to mutate the state of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 383</p>
<p><span id="___the_lambda" class="anchor"></span>// the lambda.</p>
<p>Modifying can be allowed by using the keyword mutable, which make the
closer object's operator() non-const:</p>
<p>auto func = [c = 0]() mutable {++c; std::cout &lt;&lt; c;};</p>
<p>If used together with the return type, mutable comes before it.</p>
<p>auto func = [c = 0]() mutable-&gt; int {++c; std::cout &lt;&lt; c;
return c;};</p>
<p>An example to illustrate the usefulness of lambdas</p>
<p>Before C++11:</p>
<p>Version &lt; C++11</p>
<p>// Generic functor used for comparison</p>
<p>struct islessthan</p>
<p>{</p>
<p>islessthan(int threshold) : _threshold(threshold) {}</p>
<p>bool operator()(int value) const</p>
<p>{</p>
<p>return value &lt; _threshold;</p>
<p>}</p>
<p>private:</p>
<p>int _threshold;</p>
<p>};</p>
<p>// Declare a vector</p>
<p>const int arr[] = { 1, 2, 3, 4, 5 };</p>
<p>std::vector vec(arr, arr+5);</p>
<p>// Find a number that's less than a given input (assume this would
have been function input) int threshold = 10;</p>
<p>std::vector::iterator it = std::find_if(vec.begin(), vec.end(),
islessthan(threshold));</p>
<p>Since C++11:</p>
<p>Version ≥ C++11</p>
<p>// Declare a vector</p>
<p>std::vector vec{ 1, 2, 3, 4, 5 };</p>
<p>// Find a number that's less than a given input (assume this would
have been function input) int threshold = 10;</p>
<p>auto it = std::find_if(vec.begin(), vec.end(), [threshold](int value)
{ return value &lt; threshold; });</p>
<p>Section 73.2: Specifying the return type</p>
<p>For lambdas with a single return statement, or multiple return
statements whose expressions are of the same type, the compiler can
deduce the return type:</p>
<p>// Returns bool, because "value &gt; 10" is a comparison which yields
a Boolean result auto l = [](int value) {</p>
<p>return value &gt; 10;</p>
<p>}</p>
<p>For lambdas with multiple return statements of different types, the
compiler can't deduce the return type:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 384</p>
<p><span id="___error__return_types_must_matc" class="anchor"></span>//
error: return types must match if lambda has unspecified return type
auto l = [](int value) {</p>
<p>if (value &lt; 10) {</p>
<p>return 1;</p>
<p>} else {</p>
<p>return 1.5;</p>
<p>}</p>
<p>};</p>
<p>In this case you have to specify the return type explicitly:</p>
<p>// The return type is specified explicitly as 'double' auto l =
[](int value)-&gt; double {</p>
<p>if (value &lt; 10) {</p>
<p>return 1;</p>
<p>} else {</p>
<p>return 1.5;</p>
<p>}</p>
<p>};</p>
<p>The rules for this match the rules for auto type deduction. Lambdas
without explicitly specified return types never return references, so if
a reference type is desired it must be explicitly specified as well:</p>
<p>auto copy = [](X&amp; x) { return x; }; // 'copy' returns an X, so
copies its input auto ref = [](X&amp; x)-&gt; X&amp; { return x; }; //
'ref' returns an X&amp;, no copy</p>
<p>Section 73.3: Capture by value</p>
<p>If you specify the variable's name in the capture list, the lambda
will capture it by value. This means that the generated closure type for
the lambda stores a copy of the variable. This also requires that the
variable's type be</p>
<p>copy-constructible:</p>
<p>int a = 0;</p>
<p>[a]() {</p>
<p>return a; // Ok, 'a' is captured by value</p>
<p>};</p>
<p>Version &lt; C++14</p>
<p>auto p = std::unique_ptr(...);</p>
<p>[p]() { // Compile error; `unique_ptr` is not copy-constructible</p>
<p>return p-&gt;createWidget();</p>
<p>};</p>
<p>From C++14 on, it is possible to initialize variables on the spot.
This allows move only types to be captured in the</p>
<p>lambda.</p>
<p>Version ≥ C++14</p>
<p>auto p = std::make_unique(...);</p>
<p>[p = std::move(p)]() {</p>
<p>return p-&gt;createWidget();</p>
<p>};</p>
<p>Even though a lambda captures variables by value when they are given
by their name, such variables cannot be</p>
<p>modified within the lambda body by default. This is because the
closure type puts the lambda body in a declaration of operator()
const.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 385</p>
<p><span id="The_const_applies_to_accesses_to" class="anchor"></span>The
const applies to accesses to member variables of the closure type, and
captured variables that are members of the closure (all appearances to
the contrary):</p>
<p>int a = 0;</p>
<p>[a]() {</p>
<p>a = 2; // Illegal, 'a' is accessed via `const`</p>
<p>decltype(a) a1 = 1;</p>
<p>a1 = 2; // valid: variable 'a1' is not const</p>
<p>};</p>
<p>To remove the const, you have to specify the keyword mutable on the
lambda:</p>
<p>int a = 0;</p>
<p>[a]() mutable {</p>
<p>a = 2; // OK, 'a' can be modified</p>
<p>return a;</p>
<p>};</p>
<p>Because a was captured by value, any modifications done by calling
the lambda will not affect a. The value of a was copied into the lambda
when it was constructed, so the lambda's copy of a is separate from the
external a variable.</p>
<p>int a = 5 ;</p>
<p>auto plus5Val = [a] (void) { return a + 5 ; } ;</p>
<p>auto plus5Ref = [&amp;a] (void) {return a + 5 ; } ;</p>
<p>a = 7 ;</p>
<p>std::cout &lt;&lt; a &lt;&lt; ", value " &lt;&lt; plus5Val() &lt;&lt;
", reference " &lt;&lt; plus5Ref() ; // The result will be "7, value 10,
reference 12"</p>
<p>Section 73.4: Recursive lambdas</p>
<p>Let's say we wish to write Euclid's gcd() as a lambda. As a function,
it is:</p>
<p>int gcd(int a, int b) {</p>
<p>return b == 0 ? a : gcd(b, a%b);</p>
<p>}</p>
<p>But a lambda cannot be recursive, it has no way to invoke itself. A
lambda has no name and using this within the body of a lambda refers to
a captured this (assuming the lambda is created in the body of a member
function,</p>
<p>otherwise it is an error). So how do we solve this problem?</p>
<p>Use std::function</p>
<p>We can have a lambda capture a reference to a not-yet constructed
std::function:</p>
<p>std::function<strong>&lt;</strong>int<strong>(</strong>int,
int<strong>)&gt;</strong> gcd = <strong>[&amp;](</strong>int a, int
b<strong>){</strong></p>
<p><strong>return</strong> b == 0 ? a : gcd<strong>(</strong>b,
a<strong>%</strong>b<strong>)</strong>;</p>
<p>}<strong>;</strong></p>
<p>This works, but should be used sparingly. It's slow (we're using type
erasure now instead of a direct function call),</p>
<p>it's fragile (copying gcd or returning gcd will break since the
lambda refers to the original object), and it won't work with generic
lambdas.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 386</p>
<p>Using two smart pointers:</p>
<p>auto gcd_self = std::make_shared &gt;&gt;(); *gcd_self =
std::make_unique&gt;(</p>
<p>[gcd_self](int a, int b){</p>
<p>return b == 0 ? a : (**gcd_self)(b, a%b);</p>
<p>};</p>
<p>};</p>
<p>This adds a lot of indirection (which is overhead), but it can be
copied/returned, and all copies share state. It does</p>
<p>let you return the lambda, and is otherwise less fragile than the
above solution.</p>
<p>Use a Y-combinator</p>
<p>With the help of a short utility struct, we can solve all of these
problems:</p>
<p>template</p>
<p>struct y_combinator {</p>
<p>F f; // the lambda will be stored here</p>
<p>// a forwarding operator():</p>
<p>template</p>
<p>decltype(auto) operator()(Args&amp;&amp;... args) const {</p>
<p>// we pass ourselves to f, then the arguments.</p>
<p>// the lambda should take the first argument as `auto&amp;&amp;
recurse` or similar. return f(*this, std::forward(args)...);</p>
<p>}</p>
<p>};</p>
<p>// helper function that deduces the type of the lambda: template</p>
<p>y_combinator&gt; make_y_combinator(F&amp;&amp; f) {</p>
<p>return {std::forward(f)};</p>
<p>}</p>
<p>// (Be aware that in C++17 we can do better than a `make_`
function)</p>
<p>we can implement our gcd as:</p>
<p>auto gcd = make_y_combinator<strong>(</strong></p>
<p><strong>[](</strong>auto<strong>&amp;&amp;</strong> gcd, int a, int
b<strong>){</strong></p>
<p><strong>return</strong> b == 0 ? a : gcd<strong>(</strong>b,
a<strong>%</strong>b<strong>)</strong>;</p>
<p>}</p>
<p>)<strong>;</strong></p>
<p>The y_combinator is a concept from the lambda calculus that lets you
have recursion without being able to name yourself until you are
defined. This is exactly the problem lambdas have.</p>
<p>You create a lambda that takes "recurse" as its first argument. When
you want to recurse, you pass the arguments to recurse.</p>
<p>The y_combinator then returns a function object that calls that
function with its arguments, but with a suitable</p>
<p>"recurse" object (namely the y_combinator itself) as its first
argument. It forwards the rest of the arguments you call</p>
<p>the y_combinator with to the lambda as well.</p>
<p>In short:</p>
<p>auto foo = make_y_combinator( [&amp;](auto&amp;&amp; recurse, some
arguments) {</p>
<p>// write body that processes some arguments</p>
<p>// when you want to recurse, call recurse(some other arguments)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 387</p>
<p><span id="_30" class="anchor"></span>});</p>
<p>and you have recursion in a lambda with no serious restrictions or
significant overhead.</p>
<p>Section 73.5: Default capture</p>
<p>By default, local variables that are not explicitly specified in the
capture list, cannot be accessed from within the</p>
<p>lambda body. However, it is possible to implicitly capture variables
named by the lambda body:</p>
<p>int a = 1;</p>
<p>int b = 2;</p>
<p>// Default capture by value</p>
<p>[=]() { return a + b; }; // OK; a and b are captured by value</p>
<p>// Default capture by reference</p>
<p>[&amp;]() { return a + b; }; // OK; a and b are captured by
reference</p>
<p>Explicit capturing can still be done alongside implicit default
capturing. The explicit capture definition will override the default
capture:</p>
<p>int a = 0;</p>
<p>int b = 1;</p>
<p>[=, &amp;b]() {</p>
<p>a = 2; // Illegal; 'a' is capture by value, and lambda is not
'mutable'</p>
<p>b = 2; // OK; 'b' is captured by reference</p>
<p>};</p>
<p>Section 73.6: Class lambdas and capture of this</p>
<p>A lambda expression evaluated in a class' member function is
implicitly a friend of that class:</p>
<p>class Foo</p>
<p>{</p>
<p>private:</p>
<p>int i;</p>
<p>public:</p>
<p>Foo(int val) : i(val) {}</p>
<p>// definition of a member function</p>
<p>void Test()</p>
<p>{</p>
<p>auto lamb = [](Foo &amp;foo, int val)</p>
<p>{</p>
<p>// modification of a private member variable</p>
<p>foo.i = val;</p>
<p>};</p>
<p>// lamb is allowed to access a private member, because it is a friend
of Foo</p>
<p>lamb(*this, 30);</p>
<p>}</p>
<p>};</p>
<p>Such a lambda is not only a friend of that class, it has the same
access as the class it is declared within has.</p>
<p>Lambdas can capture the this pointer which represents the object
instance the outer function was called on. This</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 388</p>
<p>is done by adding this to the capture list:</p>
<p>class Foo</p>
<p>{</p>
<p>private:</p>
<p>int i;</p>
<p>public:</p>
<p>Foo(int val) : i(val) {}</p>
<p>void Test()</p>
<p>{</p>
<p>// capture the this pointer by value</p>
<p>auto lamb = [this](int val)</p>
<p>{</p>
<p>i = val;</p>
<p>};</p>
<p>lamb(30);</p>
<p>}</p>
<p>};</p>
<p>When this is captured, the lambda can use member names of its
containing class as though it were in its</p>
<p>containing class. So an implicit this-&gt; is applied to such
members.</p>
<p>Be aware that this is captured by value, but not the value of the
type. It is captured by the value of this, which is a</p>
<p>pointer. As such, the lambda does not own this. If the lambda out
lives the lifetime of the object that created it, the lambda can become
invalid.</p>
<p>This also means that the lambda can modify this without being
declared mutable. It is the pointer which is const, not the object being
pointed to. That is, unless the outer member function was itself a const
function.</p>
<p>Also, be aware that the default capture clauses, both [=] and
[&amp;], will also capture this implicitly. And they both</p>
<p>capture it by the value of the pointer. Indeed, it is an error to
specify this in the capture list when a default is given.</p>
<p>Version ≥ C++17</p>
<p>Lambdas can capture a copy of the this object, created at the time
the lambda is created. This is done by adding</p>
<p>*this to the capture list:</p>
<p>class Foo</p>
<p>{</p>
<p>private:</p>
<p>int i;</p>
<p>public:</p>
<p>Foo(int val) : i(val) {}</p>
<p>void Test()</p>
<p>{</p>
<p>// capture a copy of the object given by the this pointer auto lamb =
[*this](int val) mutable</p>
<p>{</p>
<p>i = val;</p>
<p>};</p>
<p>lamb(30); // does not change this-&gt;i</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 389</p>
<p><span id="Section_73_7__Capture_by_referen"
class="anchor"></span>Section 73.7: Capture by reference</p>
<p>If you precede a local variable's name with an &amp;, then the
variable will be captured by reference. Conceptually, this</p>
<p>means that the lambda's closure type will have a reference variable,
initialized as a reference to the corresponding</p>
<p>variable from outside of the lambda's scope. Any use of the variable
in the lambda body will refer to the original variable:</p>
<p>// Declare variable 'a'</p>
<p>int a = 0;</p>
<p>// Declare a lambda which captures 'a' by reference auto set =
[&amp;a]() {</p>
<p>a = 1;</p>
<p>};</p>
<p>set();</p>
<p>assert(a == 1);</p>
<p>The keyword mutable is not needed, because a itself is not const.</p>
<p>Of course, capturing by reference means that the lambda <strong>must
not</strong> escape the scope of the variables it captures.</p>
<p>So you could call functions that take a function, but you must not
call a function that will store the lambda beyond the scope of your
references. And you must not return the lambda.</p>
<p>Section 73.8: Generic lambdas</p>
<p>Version ≥ c++14</p>
<p>Lambda functions can take arguments of arbitrary types. This allows a
lambda to be more generic:</p>
<p>auto twice = [](auto x){ return x+x; };</p>
<p>int i = twice(2); // i == 4</p>
<p>std::string s = twice("hello"); // s == "hellohello"</p>
<p>This is implemented in C++ by making the closure type's operator()
overload a template function. The following type has equivalent behavior
to the above lambda closure:</p>
<p>struct _unique_lambda_type</p>
<p>{</p>
<p>template</p>
<p>auto operator() (T x) const {return x + x;}</p>
<p>};</p>
<p>Not all parameters in a generic lambda need be generic:</p>
<p>[](auto x, int y) {return x + y;}</p>
<p>Here, x is deduced based on the first function argument, while y will
always be int.</p>
<p>Generic lambdas can take arguments by reference as well, using the
usual rules for auto and &amp;. If a generic</p>
<p>parameter is taken as auto&amp;&amp;, this is a <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf">forwarding
reference to the passed in argument and not an</a> <a
href="http://en.cppreference.com/w/cpp/language/reference">rvalue
reference</a>:</p>
<p>auto lamb1 = [](int &amp;&amp;x) {return x + 5;};</p>
<p>auto lamb2 = [](auto &amp;&amp;x) {return x + 5;};</p>
<p>int x = 10;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 390</p>
<p><span id="lamb1_x______Illegal__must_use"
class="anchor"></span>lamb1(x); // Illegal; must use `std::move(x)` for
`int&amp;&amp;` parameters. lamb2(x); // Legal; the type of `x` is
deduced as `int&amp;`.</p>
<p>Lambda functions can be variadic and perfectly forward their
arguments:</p>
<p>auto lam = [](auto&amp;&amp;... args){return
f(std::forward(args)...);};</p>
<p>or:</p>
<p>auto lam = [](auto&amp;&amp;... args){return
f(decltype(args)(args)...);};</p>
<p>which only works "properly" with variables of type
auto&amp;&amp;.</p>
<p>A strong reason to use generic lambdas is for visiting syntax.</p>
<p>boost::variant value;</p>
<p>apply_visitor(value, [&amp;](auto&amp;&amp; e){</p>
<p>std::cout &lt;&lt; e;</p>
<p>});</p>
<p>Here we are visiting in a polymorphic manner; but in other contexts,
the names of the type we are passing isn't interesting:</p>
<p>mutex_wrapped os = std::cout;</p>
<p>os.write([&amp;](auto&amp;&amp; os){</p>
<p>os &lt;&lt; "hello world<strong>\n</strong>";</p>
<p>});</p>
<p>Repeating the type of std::ostream&amp; is noise here; it would be
like having to mention the type of a variable every</p>
<p>time you use it. Here we are creating a visitor, but no a polymorphic
one; auto is used for the same reason you</p>
<p>might use auto in a for(:) loop.</p>
<p>Section 73.9: Using lambdas for inline parameter pack</p>
<p>unpacking</p>
<p>Version ≥ C++14</p>
<p>Parameter pack unpacking traditionally requires writing a helper
function for each time you want to do it.</p>
<p>In this toy example:</p>
<p>template</p>
<p>void print_indexes( std::index_sequence ) {</p>
<p>using discard=int[];</p>
<p>(void)discard{0,((void)(</p>
<p>std::cout &lt;&lt; Is &lt;&lt; '<strong>\n</strong>' // here Is is a
compile-time constant.</p>
<p>),0)...};</p>
<p>}</p>
<p>template</p>
<p>void print_indexes_upto() {</p>
<p>return print_indexes( std::make_index_sequence{} );</p>
<p>}</p>
<p>The print_indexes_upto wants to create and unpack a parameter pack of
indexes. In order to do so, it must call a helper function. Every time
you want to unpack a parameter pack you created, you end up having to
create a</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 391</p>
<p>custom helper function to do it.</p>
<p>This can be avoided with lambdas.</p>
<p>You can unpack parameter packs into a set of invocations of a lambda,
like this:</p>
<p>template</p>
<p>using index_t = std::integral_constant; template</p>
<p>constexpr index_t index{};</p>
<p>template</p>
<p>auto index_over( std::index_sequence ) {</p>
<p>return [](auto&amp;&amp; f){</p>
<p>using discard=int[];</p>
<p>(void)discard{0,(void(</p>
<p>f( index )</p>
<p>),0)...};</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>auto index_over(index_t = {}) {</p>
<p>return index_over( std::make_index_sequence{} );</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>With fold expressions, index_over() can be simplified to:</p>
<p>template</p>
<p>auto index_over( std::index_sequence ) {</p>
<p>return [](auto&amp;&amp; f){</p>
<p>((void)(f(index)), ...);</p>
<p>};</p>
<p>}</p>
<p>Once you have done that, you can use this to replace having to
manually unpack parameter packs with a second</p>
<p>overload in other code, letting you unpack parameter packs
"inline":</p>
<p>template</p>
<p>void for_each_tuple_element(Tup&amp;&amp; tup, F&amp;&amp; f) {</p>
<p>using T = std::remove_reference_t;</p>
<p>using std::tuple_size;</p>
<p>auto from_zero_to_N = index_over&lt; tuple_size{} &gt;();</p>
<p>from_zero_to_N(</p>
<p>[&amp;](auto i){</p>
<p>using std::get;</p>
<p>f( get( std::forward(tup) ) );</p>
<p>}</p>
<p>);</p>
<p>}</p>
<p>The auto i passed to the lambda by the index_over is a
std::integral_constant. This has a</p>
<p>constexpr conversion to std::size_t that does not depend on the state
of this, so we can use it as a compile-time constant, such as when we
pass it to std::get above.</p>
<p>To go back to the toy example at the top, rewrite it as:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 392</p>
<p><span id="template_3" class="anchor"></span>template</p>
<p>void print_indexes_upto() {</p>
<p>index_over(index)([](auto i){</p>
<p>std::cout &lt;&lt; i &lt;&lt; '<strong>\n</strong>'; // here i is a
compile-time constant</p>
<p>});</p>
<p>}</p>
<p>which is much shorter, and keeps logic in the code that uses it.</p>
<p><a href="http://coliru.stacked-crooked.com/a/32c204301f7163c9">Live
example to play with.</a></p>
<p>Section 73.10: Generalized capture</p>
<p>Version ≥ C++14</p>
<p>Lambdas can capture expressions, rather than just variables. This
permits lambdas to store move-only types:</p>
<p>auto p = std::make_unique(...);</p>
<p>auto lamb = [p = std::move(p)]() //Overrides capture-by-value of `p`.
{</p>
<p>p-&gt;SomeFunc();</p>
<p>};</p>
<p>This moves the outer p variable into the lambda capture variable,
also called p. lamb now owns the memory</p>
<p>allocated by make_unique. Because the closure contains a type that is
non-copyable, this means that lamb is itself non-copyable. But it can be
moved:</p>
<p>auto lamb_copy = lamb; //Illegal</p>
<p>auto lamb_move = std::move(lamb); //legal.</p>
<p>Now lamb_move owns the memory.</p>
<p>Note that std::function&lt;&gt; requires that the values stored be
copyable. You can write your own move-only-</p>
<p>requiring std::function, or you could just stuff the lambda into a
shared_ptr wrapper:</p>
<p>auto shared_lambda = [](auto&amp;&amp; f){</p>
<p>return [spf = std::make_shared&gt;(decltype(f)(f))]
(auto&amp;&amp;...args)-&gt;decltype(auto) {</p>
<p>return (*spf)(decltype(args)(args)...);</p>
<p>};</p>
<p>};</p>
<p>auto lamb_shared = shared_lambda(std::move(lamb_move));</p>
<p>takes our move-only lambda and stuffs its state into a shared pointer
then returns a lambda that can be copied,</p>
<p>and then stored in a std::function or similar.</p>
<p>Generalized capture uses auto type deduction for the variable's type.
It will declare these captures as values by</p>
<p>default, but they can be references as well:</p>
<p>int a = 0;</p>
<p>auto lamb = [&amp;v = a](int add) //Note that `a` and `v` have
different names {</p>
<p>v += add; //Modifies `a`</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 393</p>
<p><span id="lamb_20______a__becomes_20" class="anchor"></span>lamb(20);
//`a` becomes 20.</p>
<p>Generalize capture does not need to capture an external variable at
all. It can capture an arbitrary expression:</p>
<p>auto lamb = [p = std::make_unique(...)]()</p>
<p>{</p>
<p>p-&gt;SomeFunc();</p>
<p>}</p>
<p>This is useful for giving lambdas arbitrary values that they can hold
and potentially modify, without having to</p>
<p>declare them externally to the lambda. Of course, that is only useful
if you do not intend to access those variables after the lambda has
completed its work.</p>
<p>Section 73.11: Conversion to function pointer</p>
<p>If a lambda's capture list is empty, then the lambda has an implicit
conversion to a function pointer that takes the</p>
<p>same arguments and returns the same return type:</p>
<p>auto sorter = [](int lhs, int rhs)-&gt; bool {return lhs &lt;
rhs;};</p>
<p>using func_ptr = bool(*)(int, int);</p>
<p>func_ptr sorter_func = sorter; // implicit conversion</p>
<p>Such a conversion may also be enforced using unary plus operator:</p>
<p>func_ptr sorter_func2 = +sorter; // enforce implicit conversion</p>
<p>Calling this function pointer behaves exactly like invoking
operator() on the lambda. This function pointer is in no</p>
<p>way reliant on the source lambda closure's existence. It therefore
may outlive the lambda closure.</p>
<p>This feature is mainly useful for using lambdas with APIs that deal
in function pointers, rather than C++ function</p>
<p>objects.</p>
<p>Version ≥ C++14</p>
<p>Conversion to a function pointer is also possible for generic lambdas
with an empty capture list. If necessary, template argument deduction
will be used to select the correct specialization.</p>
<p>auto sorter = [](auto lhs, auto rhs) { return lhs &lt; rhs; }; using
func_ptr = bool(*)(int, int);</p>
<p>func_ptr sorter_func = sorter; // deduces int, int</p>
<p>// note however that the following is ambiguous</p>
<p>// func_ptr sorter_func2 = +sorter;</p>
<p>Section 73.12: Porting lambda functions to C++03 using</p>
<p>functors</p>
<p>Lambda functions in C++ are syntactic sugar that provide a very
concise syntax for writing functors. As such,</p>
<p>equivalent functionality can be obtained in C++03 (albeit much more
verbose) by converting the lambda function into a functor:</p>
<p>// Some dummy types:</p>
<p>struct T1 {int dummy;};</p>
<p>struct T2 {int dummy;};</p>
<p>struct R {int dummy;};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 394</p>
<p>// Code using a lambda function (requires C++11)</p>
<p>R use_lambda(T1 val, T2 ref) {</p>
<p>// Use auto because the type of the lambda is unknown. auto lambda =
[val, &amp;ref](int arg1, int arg2)-&gt; R {</p>
<p>/* lambda-body */</p>
<p>return R();</p>
<p>};</p>
<p>return lambda(12, 27);</p>
<p>}</p>
<p>// The functor class (valid C++03)</p>
<p>// Similar to what the compiler generates for the lambda function.
class Functor {</p>
<p>// Capture list.</p>
<p>T1 val;</p>
<p>T2&amp; ref;</p>
<p>public:</p>
<p>// Constructor</p>
<p>inline Functor(T1 val, T2&amp; ref) : val(val), ref(ref) {}</p>
<p>// Functor body</p>
<p>R operator()(int arg1, int arg2) const {</p>
<p>/* lambda-body */</p>
<p>return R();</p>
<p>}</p>
<p>};</p>
<p>// Equivalent to use_lambda, but uses a functor (valid C++03). R
use_functor(T1 val, T2 ref) {</p>
<p>Functor functor(val, ref);</p>
<p>return functor(12, 27);</p>
<p>}</p>
<p>// Make this a self-contained example.</p>
<p>int main() {</p>
<p>T1 t1;</p>
<p>T2 t2;</p>
<p>use_functor(t1,t2);</p>
<p>use_lambda(t1,t2);</p>
<p>return 0;</p>
<p>}</p>
<p>If the lambda function is mutable then make the functor's
call-operator non-const, i.e.:</p>
<p>R operator()(int arg1, int arg2) /*non-const*/ {</p>
<p>/* lambda-body */</p>
<p>return R();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 395</p>
<p><span id="Chapter_74__Value_Categories_1"
class="anchor"></span>Chapter 74: Value Categories</p>
<p>Section 74.1: Value Category Meanings</p>
<p>Expressions in C++ are assigned a particular value category, based on
the result of those expressions. Value categories for expressions can
affect C++ function overload resolution.</p>
<p>Value categories determines two important-but-separate properties
about an expression. One property is whether the expression has
identity. An expression has identity if it refers to an object that has
a variable name. The variable</p>
<p>name may not be involved in the expression, but the object can still
have one.</p>
<p>The other property is whether it is legal to implicitly move from the
expression's value. Or more specifically,</p>
<p>whether the expression, when used as a function parameter, will bind
to r-value parameter types or not.</p>
<p>C++ defines 3 value categories which represent the useful combination
of these properties: lvalue (expressions with</p>
<p>identity but not movable from), xvalue (expressions with identity
that are moveable from), and prvalue (expressions without identity that
are moveable from). C++ does not have expressions which have no identity
and cannot be</p>
<p>moved from.</p>
<p>C++ defines two other value categories, each based solely on one of
these properties: glvalue (expressions with</p>
<p>identity) and rvalue (expressions that can be moved from). These act
as useful groupings of the prior categories.</p>
<p>This graph serves as an illustration:</p>
<p><img src="media/index-414_1.png"
style="width:4.09722in;height:2.81944in" alt="index-414_1.png" /></p>
<p>Section 74.2: rvalue</p>
<p>An rvalue expression is any expression which can be implicitly moved
from, regardless of whether it has identity.</p>
<p>More precisely, rvalue expressions may be used as the argument to a
function that takes a parameter of type T &amp;&amp; (where T is the
type of expr). Only rvalue expressions may be given as arguments to such
function parameters; if a</p>
<p>non-rvalue expression is used, then overload resolution will pick any
function that does not use an rvalue reference parameter. And if none
exist, then you get an error.</p>
<p>The category of rvalue expressions includes all xvalue and prvalue
expressions, and only those expressions.</p>
<p>The standard library function std::move exists to explicitly
transform a non-rvalue expression into an rvalue. More</p>
<p>specifically, it turns the expression into an xvalue, since even if
it was an identity-less prvalue expression before, by passing it as a
parameter to std::move, it gains identity (the function's parameter
name) and becomes an xvalue.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 396</p>
<p><span id="Consider_the_following" class="anchor"></span>Consider the
following:</p>
<p>std::string str("init"); //1</p>
<p>std::string test1(str); //2</p>
<p>std::string test2(std::move(str)); //3</p>
<p>str = std::string("new value"); //4</p>
<p>std::string &amp;&amp;str_ref = std::move(str); //5</p>
<p>std::string test3(str_ref); //6</p>
<p>std::string has a constructor which takes a single parameter of type
std::string&amp;&amp;, commonly called a "move constructor". However,
the value category of the expression str is not an rvalue (specifically
it is an lvalue), so it</p>
<p>cannot call that constructor overload. Instead, it calls the const
std::string&amp; overload, the copy constructor.</p>
<p>Line 3 changes things. The return value of std::move is a
T&amp;&amp;, where T is the base type of the parameter passed in.</p>
<p>So std::move(str) returns std::string&amp;&amp;. A function call
who's return value is an rvalue reference is an rvalue expression
(specifically an xvalue), so it may call the move constructor of
std::string. After line 3, str has been</p>
<p>moved from (who's contents are now undefined).</p>
<p>Line 4 passes a temporary to the assignment operator of std::string.
This has an overload which takes a</p>
<p>std::string&amp;&amp;. The expression std::string("new value") is an
rvalue expression (specifically a prvalue), so it may call that
overload. Thus, the temporary is moved into str, replacing the undefined
contents with specific</p>
<p>contents.</p>
<p>Line 5 creates a named rvalue reference called str_ref that refers to
str. This is where value categories get</p>
<p>confusing.</p>
<p>See, while str_ref is an rvalue reference to std::string, the value
category of the expression str_ref is not an</p>
<p>rvalue. It is an lvalue expression. Yes, really. Because of this, one
cannot call the move constructor of std::string with the expression
str_ref. Line 6 therefore copies the value of str into test3.</p>
<p>To move it, we would have to employ std::move again.</p>
<p>Section 74.3: xvalue</p>
<p>An xvalue (eXpiring value) expression is an expression which has
identity and represents an object which can be implicitly moved from.
The general idea with xvalue expressions is that the object they
represent is going to be</p>
<p>destroyed soon (hence the "eXpiring" part), and therefore implicitly
moving from them is fine.</p>
<p>Given:</p>
<p>struct X { int n; };</p>
<p>extern X x;</p>
<p>4; // prvalue: does not have an identity</p>
<p>x; // lvalue</p>
<p>x.n; // lvalue</p>
<p>std::move(x); // xvalue</p>
<p>std::forward(x); // lvalue</p>
<p>X{4}; // prvalue: does not have an identity</p>
<p>X{4}.n; // xvalue: does have an identity and denotes resources</p>
<p>// that can be reused</p>
<p>Section 74.4: prvalue</p>
<p>A prvalue (pure-rvalue) expression is an expression which lacks
identity, whose evaluation is typically used to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 397</p>
<p><span id="initialize_an_object__and_which"
class="anchor"></span>initialize an object, and which can be implicitly
moved from. These include, but are not limited to:</p>
<p>Expressions that represent temporary objects, such as
std::string("123").</p>
<p>A function call expression that does not return a reference A literal
(except a string literal - those are lvalues), such has 1, true, 0.5f,
or 'a'</p>
<p>A lambda expression</p>
<p>The built-in addressof operator (&amp;) cannot be applied on these
expressions.</p>
<p>Section 74.5: lvalue</p>
<p>An lvalue expression is an expression which has identity, but cannot
be implicitly moved from. Among these are expressions that consist of a
variable name, function name, expressions that are built-in dereference
operator uses</p>
<p>and expressions that refer to lvalue references.</p>
<p>The typical lvalue is simply a name, but lvalues can come in other
flavors as well:</p>
<p>struct X { ... };</p>
<p>X x; // x is an lvalue</p>
<p>X* px = &amp;x; // px is an lvalue</p>
<p>*px = X{}; // *px is also an lvalue, X{} is a prvalue</p>
<p>X* foo_ptr(); // foo_ptr() is a prvalue</p>
<p>X&amp; foo_ref(); // foo_ref() is an lvalue</p>
<p>Additionally, while most literals (e.g. 4, 'x', etc.) are prvalues,
string literals are lvalues.</p>
<p>Section 74.6: glvalue</p>
<p>A glvalue (a "generalized lvalue") expression is any expression which
has identity, regardless of whether it can be moved from or not. This
category includes lvalues (expressions that have identity but can't be
moved from) and</p>
<p>xvalues (expressions that have identity, and can be moved from), but
excludes prvalues (expressions without identity).</p>
<p>If an expression has a name, it's a glvalue:</p>
<p>struct X { int n; };</p>
<p>X foo();</p>
<p>X x;</p>
<p>x; // has a name, so it's a glvalue</p>
<p>std::move(x); // has a name (we're moving from "x"), so it's a
glvalue</p>
<p>// can be moved from, so it's an xvalue not an lvalue</p>
<p>foo(); // has no name, so is a prvalue, not a glvalue X{}; //
temporary has no name, so is a prvalue, not a glvalue X{}.n; // HAS a
name, so is a glvalue. can be moved from, so it's an xvalue</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 398</p>
<p><span id="Chapter_75__Preprocessor_1" class="anchor"></span>Chapter
75: Preprocessor</p>
<p>The C preprocessor is a simple text parser/replacer that is run
before the actual compilation of the code. Used to</p>
<p>extend and ease the use of the C (and later C++) language, it can be
used for:</p>
<p><strong>a.</strong> Including other files <strong>using
#include</strong></p>
<p><strong>b.</strong> Define a text-replacement macro <strong>using
#define</strong></p>
<p><strong>c.</strong> Conditional Compilation <strong>using#if
#ifdef</strong></p>
<p>d. <strong>Platform/Compiler specific logic</strong> (as an extension
of conditional compilation)</p>
<p>Section 75.1: Include Guards</p>
<p>A header file may be included by other header files. A source file
(compilation unit) that includes multiple headers</p>
<p>may therefore, indirectly, include some headers more than once. If
such a header file that is included more than</p>
<p>once contains definitions, the compiler (after preprocessing) detects
a violation of the One Definition Rule (e.g. §3.2 of the 2003 C++
standard) and therefore issues a diagnostic and compilation fails.</p>
<p>Multiple inclusion is prevented using "include guards", which are
sometimes also known as header guards or macro guards. These are
implemented using the preprocessor #define, #ifndef, #endif
directives.</p>
<p>e.g.</p>
<p>// Foo.h</p>
<p>#ifndef FOO_H_INCLUDED</p>
<p>#define FOO_H_INCLUDED</p>
<p>class Foo // a class definition</p>
<p>{</p>
<p>};</p>
<p>#endif</p>
<p>The key advantage of using include guards is that they will work with
all standard-compliant compilers and</p>
<p>preprocessors.</p>
<p>However, include guards also cause some problems for developers, as
it is necessary to ensure the macros are</p>
<p>unique within all headers used in a project. Specifically, if two (or
more) headers use FOO_H_INCLUDED as their include guard, the first of
those headers included in a compilation unit will effectively prevent
the others from being</p>
<p>included. Particular challenges are introduced if a project uses a
number of third-party libraries with header files that happen to use
include guards in common.</p>
<p>It is also necessary to ensure that the macros used in include guards
do not conflict with any other macros defined in header files.</p>
<p><a href="https://en.wikipedia.org/wiki/Pragma_once#Portability">Most
C++ implementations also support the</a> #pragma once directive which
ensures the file is only included once</p>
<p><a href="https://en.wikipedia.org/wiki/De_facto_standard">within a
single compilation. This is a de facto standard directive, but it is not
part of any ISO C++ standard. For</a></p>
<p>example:</p>
<p>// Foo.h</p>
<p>#pragma once</p>
<p>class Foo</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 399</p>
<p><span id="_31" class="anchor"></span>{</p>
<p>};</p>
<p>While #pragma once avoids some problems associated with include
guards, a #pragma - by definition in the</p>
<p>standards - is inherently a compiler-specific hook, and will be
silently ignored by compilers that don't support it. Projects which use
#pragma once are more difficult to port to compilers that don't support
it.</p>
<p>A number of coding guidelines and assurance standards for C++
specifically discourage any use of the preprocessor other than to
#include header files or for the purposes of placing include guards in
headers.</p>
<p>Section 75.2: Conditional logic and cross-platform handling</p>
<p>In a nutshell, conditional pre-processing logic is about making
code-logic available or unavailable for compilation using macro
definitions.</p>
<p>Three prominent use-cases are:</p>
<p>different <strong>app profiles</strong> (e.g. debug, release,
testing, optimised) that can be candidates of the same app (e.g.</p>
<p>with extra logging).</p>
<p><strong>cross-platform compiles</strong> - single code-base, multiple
compilation platforms.</p>
<p>utilising a common code-base for multiple <strong>application
versions</strong> (e.g. Basic, Premium and Pro versions of a</p>
<p>software) - with slightly different features.</p>
<p><strong>Example a:</strong> A cross-platform approach for removing
files (illustrative):</p>
<p>#ifdef _WIN32</p>
<p>#include // and other windows system files #endif</p>
<p>#include</p>
<p>bool remove_file(const std::string &amp;path)</p>
<p>{</p>
<p>#ifdef _WIN32</p>
<p>return DeleteFile(path.c_str());</p>
<p>#elif defined(_POSIX_VERSION) || defined(__unix__)</p>
<p>return (0 == remove(path.c_str()));</p>
<p>#elif defined(__APPLE__)</p>
<p>//TODO: check if NSAPI has a more specific function with permission
dialog return (0 == remove(path.c_str()));</p>
<p>#else</p>
<p>#error "This platform is not supported"</p>
<p>#endif</p>
<p>}</p>
<p>Macros like _WIN32, __APPLE__ or __unix__ are normally predefined by
corresponding implementations.</p>
<p><strong>Example b:</strong> Enabling additional logging for a debug
build:</p>
<p>void s_PrintAppStateOnUserPrompt()</p>
<p>{</p>
<p>std::cout &lt;&lt;
"--------BEGIN-DUMP---------------<strong>\n</strong>"</p>
<p>&lt;&lt; AppState::Instance()-&gt;Settings().ToString() &lt;&lt;
"<strong>\n</strong>"</p>
<p>#if ( 1 == TESTING_MODE ) //privacy: we want user details only when
testing</p>
<p>&lt;&lt; ListToString(AppState::UndoStack()-&gt;GetActionNames())
&lt;&lt; AppState::Instance()-&gt;CrntDocument().Name()</p>
<p>&lt;&lt; AppState::Instance()-&gt;CrntDocument().SignatureSHA()
&lt;&lt; "<strong>\n</strong>"</p>
<p>#endif</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 400</p>
<p><span id="____________END_DUMP" class="anchor"></span>&lt;&lt;
"--------END-DUMP---------------<strong>\n</strong>"</p>
<p>}</p>
<p><strong>Example c:</strong> Enable a premium feature in a separate
product build (note: this is illustrative. it is often a better idea
to</p>
<p>allow a feature to be unlocked without the need to reinstall an
application)</p>
<p>void MainWindow::OnProcessButtonClick()</p>
<p>{</p>
<p>#ifndef _PREMIUM</p>
<p>CreatePurchaseDialog("Buy App Premium", "This feature is available
for our App Premium users. Click the Buy button to purchase the Premium
version at our website");</p>
<p>return;</p>
<p>#endif</p>
<p>//...actual feature logic here</p>
<p>}</p>
<p>Some common tricks:</p>
<p>Defining symbols at invocation time:</p>
<p>The preprocessor can be called with predefined symbols (with optional
initialisation). For example this command (gcc -E runs only the
preprocessor)</p>
<p>gcc -E -DOPTIMISE_FOR_OS_X -DTESTING_MODE=1 Sample.cpp</p>
<p>processes Sample.cpp in the same way as it would if #define
OPTIMISE_FOR_OS_X and #define TESTING_MODE 1</p>
<p>were added to the top of Sample.cpp.</p>
<p>Ensuring a macro is defined:</p>
<p>If a macro isn't defined and its value is compared or checked, the
preprocessor almost always silently assumes the</p>
<p>value to be 0. There are a few ways to work with this. One approach
is to assume that the default settings are represented as 0, and any
changes (e.g. to the app build profile) needs to be explicitly done
(e.g.</p>
<p>ENABLE_EXTRA_DEBUGGING=0 by default, set -DENABLE_EXTRA_DEBUGGING=1
to override). Another approach is make all definitions and defaults
explicit. This can be achieved using a combination of #ifndef and
#error</p>
<p>directives:</p>
<p>#ifndef (ENABLE_EXTRA_DEBUGGING)</p>
<p>// please include DefaultDefines.h if not already included. # error
"ENABLE_EXTRA_DEBUGGING is not defined" #else</p>
<p># if ( 1 == ENABLE_EXTRA_DEBUGGING )</p>
<p>//code</p>
<p># endif</p>
<p>#endif</p>
<p>Section 75.3: X-macros</p>
<p>An idiomatic technique for generating repeating code structures at
compile time.</p>
<p>An X-macro consists of two parts: the list, and the execution of the
list.</p>
<p>Example:</p>
<p>#define LIST \</p>
<p>X(dog) \</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 401</p>
<p>X(cat) \</p>
<p>X(racoon)</p>
<p>// class Animal {</p>
<p>// public:</p>
<p>// void say();</p>
<p>// };</p>
<p>#define X(name) Animal name;</p>
<p>LIST</p>
<p>#undef X</p>
<p>int main() {</p>
<p>#define X(name) name.say();</p>
<p>LIST</p>
<p>#undef X</p>
<p>return 0;</p>
<p>}</p>
<p>which is expanded by the preprocessor into the following:</p>
<p>Animal dog;</p>
<p>Animal cat;</p>
<p>Animal racoon;</p>
<p>int main() {</p>
<p>dog.say();</p>
<p>cat.say();</p>
<p>racoon.say();</p>
<p>return 0;</p>
<p>}</p>
<p>As lists become bigger (let's say, more than 100 elements), this
technique helps to avoid excessive copy-pasting.</p>
<p>Source: <a
href="https://en.wikipedia.org/wiki/X_Macro">https://en.wikipedia.org/wiki/X_Macro</a></p>
<p>See also: X-macros</p>
<p>If defining a seamingly irrelevant X before using LIST is not to your
liking, you can pass a macro name as an argument as well:</p>
<p>#define LIST(MACRO) \</p>
<p>MACRO(dog) \</p>
<p>MACRO(cat) \</p>
<p>MACRO(racoon)</p>
<p>Now, you explicitly specify which macro should be used when expanding
the list, e.g.</p>
<p>#define FORWARD_DECLARE_ANIMAL(name) Animal name;</p>
<p>LIST(FORWARD_DECLARE_ANIMAL)</p>
<p>If each invocation of the MACRO should take additional parameters -
constant with respect to the list, variadic macros</p>
<p>can be used</p>
<p>//a walkaround for Visual studio</p>
<p>#define EXPAND(x) x</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 402</p>
<p><span id="_define_LIST_MACRO" class="anchor"></span>#define
LIST(MACRO, ...) \</p>
<p>EXPAND(MACRO(dog, __VA_ARGS__)) \</p>
<p>EXPAND(MACRO(cat, __VA_ARGS__)) \</p>
<p>EXPAND(MACRO(racoon, __VA_ARGS__))</p>
<p>The first argument is supplied by the LIST, while the rest is
provided by the user in the LIST invocation. For</p>
<p>example:</p>
<p>#define FORWARD_DECLARE(name, type, prefix) type prefix##name;
LIST(FORWARD_DECLARE,Animal,anim_)</p>
<p>LIST(FORWARD_DECLARE,Object,obj_)</p>
<p>will expand to</p>
<p>Animal anim_dog;</p>
<p>Animal anim_cat;</p>
<p>Animal anim_racoon;</p>
<p>Object obj_dog;</p>
<p>Object obj_cat;</p>
<p>Object obj_racoon;</p>
<p>Section 75.4: Macros</p>
<p>Macros are categorized into two main groups: object-like macros and
function-like macros. Macros are treated as a token substitution early
in the compilation process. This means that large (or repeating)
sections of code can be</p>
<p>abstracted into a preprocessor macro.</p>
<p>// This is an object-like macro</p>
<p>#define PI 3.14159265358979</p>
<p>// This is a function-like macro.</p>
<p>// Note that we can use previously defined macros</p>
<p>// in other macro definitions (object-like or function-like) // But
watch out, its quite useful if you know what you're doing, but the //
Compiler doesn't know which type to handle, so using inline functions
instead // is quite recommended (But e.g. for Minimum/Maximum functions
it is quite useful) #define AREA(r) (PI*(r)*(r))</p>
<p>// They can be used like this:</p>
<p>double pi_macro = PI;</p>
<p>double area_macro = AREA(4.6);</p>
<p>The Qt library makes use of this technique to create a meta-object
system by having the user declare the Q_OBJECT macro at the head of the
user-defined class extending QObject.</p>
<p>Macro names are usually written in all caps, to make them easier to
differentiate from normal code. This isn't a requirement, but is merely
considered good style by many programmers.</p>
<p>When an object-like macro is encountered, it's expanded as a simple
copy-paste operation, with the macro's name being replaced with its
definition. When a function-like macro is encountered, both its name and
its parameters are</p>
<p>expanded.</p>
<p>double pi_squared = PI * PI;</p>
<p>// Compiler sees:</p>
<p>double pi_squared = 3.14159265358979 * 3.14159265358979;</p>
<p>double area = AREA(5);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 403</p>
<p>// Compiler sees:</p>
<p>double area = (3.14159265358979*(5)*(5))</p>
<p>Due to this, function-like macro parameters are often enclosed within
parentheses, as in AREA() above. This is to</p>
<p>prevent any bugs that can occur during macro expansion, specifically
bugs caused by a single macro parameter being composed of multiple
actual values.</p>
<p>#define BAD_AREA(r) PI * r * r</p>
<p>double bad_area = BAD_AREA(5 + 1.6);</p>
<p>// Compiler sees:</p>
<p>double bad_area = 3.14159265358979 * 5 + 1.6 * 5 + 1.6;</p>
<p>double good_area = AREA(5 + 1.6);</p>
<p>// Compiler sees:</p>
<p>double good_area = (3.14159265358979*(5 + 1.6)*(5 + 1.6));</p>
<p>Also note that due to this simple expansion, care must be taken with
the parameters passed to macros, to prevent</p>
<p>unexpected side effects. If the parameter is modified during
evaluation, it will be modified each time it is used in the expanded
macro, which usually isn't what we want. This is true even if the macro
encloses the parameters in</p>
<p>parentheses to prevent expansion from breaking anything.</p>
<p>int oops = 5;</p>
<p>double incremental_damage = AREA(oops++);</p>
<p>// Compiler sees:</p>
<p>double incremental_damage = (3.14159265358979*(oops++)*(oops++));</p>
<p>Additionally, macros provide no type-safety, leading to
hard-to-understand errors about type mismatch.</p>
<p>As programmers normally terminate lines with a semicolon, macros that
are intended to be used as standalone</p>
<p>lines are often designed to "swallow" a semicolon; this prevents any
unintended bugs from being caused by an extra semicolon.</p>
<p>#define IF_BREAKER(Func) Func();</p>
<p>if (some_condition)</p>
<p>// Oops.</p>
<p>IF_BREAKER(some_func);</p>
<p>else</p>
<p>std::cout &lt;&lt; "I am accidentally an orphan." &lt;&lt;
std::endl;</p>
<p>In this example, the inadvertent double semicolon breaks the
if...else block, preventing the compiler from</p>
<p>matching the else to the if. To prevent this, the semicolon is
omitted from the macro definition, which will cause it to "swallow" the
semicolon immediately following any usage of it.</p>
<p>#define IF_FIXER(Func) Func()</p>
<p>if (some_condition)</p>
<p>IF_FIXER(some_func);</p>
<p>else</p>
<p>std::cout &lt;&lt; "Hooray! I work again!" &lt;&lt; std::endl;</p>
<p>Leaving off the trailing semicolon also allows the macro to be used
without ending the current statement, which</p>
<p>can be beneficial.</p>
<p>#define DO_SOMETHING(Func, Param) Func(Param, 2)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 404</p>
<p>// ...</p>
<p>some_function(DO_SOMETHING(some_func, 3), DO_SOMETHING(some_func,
42));</p>
<p>Normally, a macro definition ends at the end of the line. If a macro
needs to cover multiple lines, however, a backslash can be used at the
end of a line to indicate this. This backslash must be the last
character in the line,</p>
<p>which indicates to the preprocessor that the following line should be
concatenated onto the current line, treating them as a single line. This
can be used multiple times in a row.</p>
<p>#define TEXT "I \</p>
<p>am \</p>
<p>many \</p>
<p>lines."</p>
<p>// ...</p>
<p>std::cout &lt;&lt; TEXT &lt;&lt; std::endl; // Output: I am many
lines.</p>
<p>This is especially useful in complex function-like macros, which may
need to cover multiple lines.</p>
<p>#define CREATE_OUTPUT_AND_DELETE(Str) \</p>
<p>std::string* tmp = new std::string(Str); \</p>
<p>std::cout &lt;&lt; *tmp &lt;&lt; std::endl; \</p>
<p>delete tmp;</p>
<p>// ...</p>
<p>CREATE_OUTPUT_AND_DELETE("There's no real need for this to use
'new'.")</p>
<p>In the case of more complex function-like macros, it can be useful to
give them their own scope to prevent possible name collisions or to
cause objects to be destroyed at the end of the macro, similar to an
actual function. A</p>
<p>common idiom for this is do while 0, where the macro is enclosed in a
do-while block. This block is generally not followed with a semicolon,
allowing it to swallow a semicolon.</p>
<p>#define DO_STUFF(Type, Param, ReturnVar) do { \</p>
<p>Type temp(some_setup_values); \</p>
<p>ReturnVar = temp.process(Param); \</p>
<p>} while (0)</p>
<p>int x;</p>
<p>DO_STUFF(MyClass, 41153.7, x);</p>
<p>// Compiler sees:</p>
<p>int x;</p>
<p>do {</p>
<p>MyClass temp(some_setup_values);</p>
<p>x = temp.process(41153.7);</p>
<p>} while (0);</p>
<p>There are also variadic macros; similarly to variadic functions,
these take a variable number of arguments, and then expand them all in
place of a special "Varargs" parameter, __VA_ARGS__.</p>
<p>#define VARIADIC(Param, ...) Param(__VA_ARGS__)</p>
<p>VARIADIC(printf, "%d", 8);</p>
<p>// Compiler sees:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 405</p>
<p><span id="printf___d___8" class="anchor"></span>printf("%d", 8);</p>
<p>Note that during expansion, __VA_ARGS__ can be placed anywhere in the
definition, and will be expanded correctly.</p>
<p>#define VARIADIC2(POne, PTwo, PThree, ...) POne(PThree, __VA_ARGS__,
PTwo)</p>
<p>VARIADIC2(some_func, 3, 8, 6, 9);</p>
<p>// Compiler sees:</p>
<p>some_func(8, 6, 9, 3);</p>
<p>In the case of a zero-argument variadic parameter, different
compilers will handle the trailing comma differently. Some compilers,
such as Visual Studio, will silently swallow the comma without any
special syntax. Other compilers,</p>
<p>such as GCC, require you to place ## immediately before __VA_ARGS__.
Due to this, it is wise to conditionally define variadic macros when
portability is a concern.</p>
<p>// In this example, COMPILER is a user-defined macro specifying the
compiler being used.</p>
<p>#if COMPILER == "VS"</p>
<p>#define VARIADIC3(Name, Param, ...) Name(Param, __VA_ARGS__)</p>
<p>#elif COMPILER == "GCC"</p>
<p>#define VARIADIC3(Name, Param, ...) Name(Param, ##__VA_ARGS__)</p>
<p>#endif /* COMPILER */</p>
<p>Section 75.5: Predefined macros</p>
<p>Predefined macros are those that the compiler defines (in contrast to
those user defines in the source file). Those macros must not be
re-defined or undefined by user.</p>
<p>The following macros are predefined by the C++ standard:</p>
<p>__LINE__ contains the line number of the line this macro is used on,
and can be changed by the #line</p>
<p>directive.</p>
<p>__FILE__ contains the filename of the file this macro is used in, and
can be changed by the #line directive.</p>
<p>__DATE__ contains date (in "Mmm dd yyyy" format) of the file
compilation, where Mmm is formatted as if obtained by a call to
std::asctime().</p>
<p>__TIME__ contains time (in "hh:mm:ss" format) of the file
compilation. __cplusplus is defined by (conformant) C++ compilers while
compiling C++ files. Its value is the standard</p>
<p>version the compiler is <strong>fully</strong> conformant with, i.e.
199711L for C++98 and C++03, 201103L for C++11 and</p>
<p>201402L for C++14 standard.</p>
<p>Version ≥ c++11</p>
<p>__STDC_HOSTED__ is defined to 1 if the implementation is hosted, or 0
if it is freestanding.</p>
<p>Version ≥ c++17</p>
<p>__STDCPP_DEFAULT_NEW_ALIGNMENT__ contains a size_t literal, which is
the alignment used for a call to</p>
<p>alignment-unaware operator new.</p>
<p>Additionally, the following macros are allowed to be predefined by
implementations, and may or may not be</p>
<p>present:</p>
<p>__STDC__ has implementation-dependent meaning, and is usually defined
only when compiling a file as C, to</p>
<p>signify full C standard compliance. (Or never, if the compiler
decides not to support this macro.)</p>
<p>Version ≥ c++11</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 406</p>
<p>__STDC_VERSION__ has implementation-dependent meaning, and its value
is usually the C version, similarly to how __cplusplus is the C++
version. (Or is not even defined, if the compiler decides not to support
this</p>
<p>macro.)</p>
<p>__STDC_MB_MIGHT_NEQ_WC__ is defined to 1, if values of the narrow
encoding of the basic character set might not be equal to the values of
their wide counterparts (e.g. if (uintmax_t)'x' != (uintmax_t)L'x')</p>
<p>__STDC_ISO_10646__ is defined if wchar_t is encoded as Unicode, and
expands to an integer constant in the form yyyymmL, indicating the
latest Unicode revision supported.</p>
<p>__STDCPP_STRICT_POINTER_SAFETY__ is defined to 1, if the
implementation has strict pointer safety (otherwise it has relaxed
pointer safety)</p>
<p>__STDCPP_THREADS__ is defined to 1, if the program can have more than
one thread of execution (applicable</p>
<p>to freestanding implementation — hosted implementations can always
have more than one thread)</p>
<p>It is also worth mentioning __func__, which is not an macro, but a
predefined function-local variable. It contains the</p>
<p>name of the function it is used in, as a static character array in an
implementation-defined format.</p>
<p>On top of those standard predefined macros, compilers can have their
own set of predefined macros. One must refer to the compiler
documentation to learn those. E.g.:</p>
<p><a
href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html">gcc</a></p>
<p><a
href="https://msdn.microsoft.com/en-us/library/b0084kay.aspx#Anchor_2">Microsoft
Visual C++</a></p>
<p><a
href="http://clang.llvm.org/docs/LanguageExtensions.html#builtin-macros">clang</a></p>
<p><a href="https://software.intel.com/en-us/node/514528">Intel C++
Compiler</a></p>
<p>Some of the macros are just to query support of some feature:</p>
<p>#ifdef __cplusplus // if compiled by C++ compiler</p>
<p>extern "C"{ // C code has to be decorated</p>
<p>// C library header declarations here</p>
<p>}</p>
<p>#endif</p>
<p>Others are very useful for debugging:</p>
<p>Version ≥ c++11</p>
<p>bool success = doSomething( /*some arguments*/ );</p>
<p>if( !success ){</p>
<p>std::cerr &lt;&lt; "ERROR: doSomething() failed on line " &lt;&lt;
__LINE__ -2</p>
<p>&lt;&lt; " in function " &lt;&lt; __func__ &lt;&lt; "()"</p>
<p>&lt;&lt; " in file " &lt;&lt; __FILE__</p>
<p>&lt;&lt; std::endl;</p>
<p>}</p>
<p>And others for trivial version control:</p>
<p>int main( int argc, char *argv[] ){</p>
<p>if( argc == 2 &amp;&amp; std::string( argv[1] ) == "-v" ){</p>
<p>std::cout &lt;&lt; "Hello World program<strong>\n</strong>"</p>
<p>&lt;&lt; "v 1.1<strong>\n</strong>" // I have to remember to update
this manually &lt;&lt; "compiled: " &lt;&lt; __DATE__ &lt;&lt; ' '
&lt;&lt; __TIME__ // this updates automagically &lt;&lt; std::endl;</p>
<p>}</p>
<p>else{</p>
<p>std::cout &lt;&lt; "Hello World!<strong>\n</strong>";</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 407</p>
<p><span id="Section_75_6__Preprocessor_Opera"
class="anchor"></span>Section 75.6: Preprocessor Operators</p>
<p># operator or stringizing operator is used to convert a Macro
parameter to a string literal. It can only be used with</p>
<p>the Macros having arguments.</p>
<p>// preprocessor will convert the parameter x to the string literal x
#define PRINT(x) printf(#x "\n")</p>
<p>PRINT(This line will be converted to string by preprocessor); //
Compiler sees</p>
<p>printf("This line will be converted to string by
preprocessor""<strong>\n</strong>");</p>
<p>Compiler concatenate two strings and the final printf() argument will
be a string literal with newline character at</p>
<p>its end.</p>
<p>Preprocessor will ignore the spaces before or after the macro
argument. So below print statement will give us the</p>
<p>same result.</p>
<p>PRINT( This line will be converted to string by preprocessor );</p>
<p>If the parameter of the string literal requires an escape sequence
like before a double quote() it will automatically be inserted by the
preprocessor.</p>
<p>PRINT(This "line" will be converted to "string" by preprocessor); //
Compiler sees</p>
<p>printf("This <strong>\"</strong>line<strong>\"</strong> will be
converted to <strong>\"</strong>string<strong>\"</strong> by
preprocessor""<strong>\n</strong>");</p>
<p>## operator or Token pasting operator is used to concatenate two
parameters or tokens of a Macro.</p>
<p>// preprocessor will combine the variable and the x #define PRINT(x)
printf("variable" #x " = %d", variable##x)</p>
<p>int variableY = 15;</p>
<p>PRINT(Y);</p>
<p>//compiler sees</p>
<p>printf("variable""Y"" = %d", variableY);</p>
<p>and the final output will be</p>
<p>variableY = 15</p>
<p>Section 75.7: #pragma once</p>
<p><a href="https://en.wikipedia.org/wiki/Pragma_once#Portability">Most,
but not all, C++ implementations</a> support the #pragma once directive
which ensures the file is only included</p>
<p>once within a single compilation. It is not part of any ISO C++
standard. For example:</p>
<p>// Foo.h</p>
<p>#pragma once</p>
<p>class Foo</p>
<p>{</p>
<p>};</p>
<p>While #pragma once avoids some problems associated with include
guards, a #pragma - by definition in the</p>
<p>standards - is inherently a compiler-specific hook, and will be
silently ignored by compilers that don't support it.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 408</p>
<p><span id="Projects_which_use__pragma_once"
class="anchor"></span>Projects which use #pragma once must be modified
to be standard-compliant.</p>
<p>With some compilers - particularly those that employ <a
href="https://en.wikipedia.org/wiki/Precompiled_header">precompiled
headers -</a> #pragma once can result in a</p>
<p>considerable speedup of the compilation process. Similarly, some
preprocessors achieve speedup of compilation by tracking which headers
have employed include guards. The net benefit, when both #pragma once
and include</p>
<p>guards are employed, depends on the implementation and can be either
an increase or decrease of compilation times.</p>
<p>#pragma once combined with include guards was the recommended layout
for header files when writing MFC</p>
<p>based applications on windows, and was generated by Visual Studio’s
add class, add dialog, add windows wizards. Hence it is very common to
find them combined in C++ Windows Applicants.</p>
<p>Section 75.8: Preprocessor error messages</p>
<p>Compile errors can be generated using the preprocessor. This is
useful for a number of reasons some of which include, notifying a user
if they are on an unsupported platform or an unsupported compiler.</p>
<p>e.g. Return Error if gcc version is 3.0.0 or earlier.</p>
<p>#if __GNUC__ &lt; 3</p>
<p>#error "This code requires gcc &gt; 3.0.0"</p>
<p>#endif</p>
<p>e.g. Return Error if compiling on an Apple computer.</p>
<p>#ifdef __APPLE__</p>
<p>#error "Apple products are not supported in this release" #endif</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 409</p>
<p><span id="Chapter_76__Data_Structures_in_C_1"
class="anchor"></span>Chapter 76: Data Structures in C++</p>
<p>Section 76.1: Linked List implementation in C++</p>
<p>Creating a List Node</p>
<p>class listNode</p>
<p>{</p>
<p>public:</p>
<p>int data;</p>
<p>listNode *next;</p>
<p>listNode(int val):data(val),next(NULL){}</p>
<p>};</p>
<p>Creating List class</p>
<p>class List</p>
<p>{</p>
<p>public:</p>
<p>listNode *head;</p>
<p>List():head(NULL){}</p>
<p>void insertAtBegin(int val);</p>
<p>void insertAtEnd(int val);</p>
<p>void insertAtPos(int val);</p>
<p>void remove(int val);</p>
<p>void print();</p>
<p>~List();</p>
<p>};</p>
<p>Insert a new node at the beginning of the list</p>
<p>void List::insertAtBegin(int val)//inserting at front of list {</p>
<p>listNode *newnode = new listNode(val);</p>
<p>newnode-&gt;next=this-&gt;head;</p>
<p>this-&gt;head=newnode;</p>
<p>}</p>
<p>Insert a new node at the end of the list</p>
<p>void List::insertAtEnd(int val) //inserting at end of list {</p>
<p>if(head==NULL)</p>
<p>{</p>
<p>insertAtBegin(val);</p>
<p>return;</p>
<p>}</p>
<p>listNode *newnode = new listNode(val);</p>
<p>listNode *ptr=this-&gt;head;</p>
<p>while(ptr-&gt;next!=NULL)</p>
<p>{</p>
<p>ptr=ptr-&gt;next;</p>
<p>}</p>
<p>ptr-&gt;next=newnode;</p>
<p>}</p>
<p>Insert at a particular position in list</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 410</p>
<p>void List::insertAtPos(int pos,int val)</p>
<p>{</p>
<p>listNode *newnode=new listNode(val);</p>
<p>if(pos==1)</p>
<p>{</p>
<p>//as head</p>
<p>newnode-&gt;next=this-&gt;head;</p>
<p>this-&gt;head=newnode;</p>
<p>return;</p>
<p>}</p>
<p>pos--;</p>
<p>listNode *ptr=this-&gt;head;</p>
<p>while(ptr!=NULL &amp;&amp;--pos)</p>
<p>{</p>
<p>ptr=ptr-&gt;next;</p>
<p>}</p>
<p>if(ptr==NULL)</p>
<p>return;//not enough elements</p>
<p>newnode-&gt;next=ptr-&gt;next;</p>
<p>ptr-&gt;next=newnode;</p>
<p>}</p>
<p>Removing a node from the list</p>
<p>void List::remove(int toBeRemoved)//removing an element {</p>
<p>if(this-&gt;head==NULL)</p>
<p>return; //empty</p>
<p>if(this-&gt;head-&gt;data==toBeRemoved)</p>
<p>{</p>
<p>//first node to be removed</p>
<p>listNode *temp=this-&gt;head;</p>
<p>this-&gt;head=this-&gt;head-&gt;next;</p>
<p>delete(temp);</p>
<p>return;</p>
<p>}</p>
<p>listNode *ptr=this-&gt;head;</p>
<p>while(ptr-&gt;next!=NULL &amp;&amp;
ptr-&gt;next-&gt;data!=toBeRemoved)</p>
<p>ptr=ptr-&gt;next;</p>
<p>if(ptr-&gt;next==NULL)</p>
<p>return;//not found</p>
<p>listNode *temp=ptr-&gt;next;</p>
<p>ptr-&gt;next=ptr-&gt;next-&gt;next;</p>
<p>delete(temp);</p>
<p>}</p>
<p>Print the list</p>
<p>void List::print()//printing the list</p>
<p>{</p>
<p>listNode *ptr=this-&gt;head;</p>
<p>while(ptr!=NULL)</p>
<p>{</p>
<p>cout&lt;data&lt;&lt;" " ;</p>
<p>ptr=ptr-&gt;next;</p>
<p>}</p>
<p>cout&lt;</p>
<p>}</p>
<p>Destructor for the list</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 411</p>
<p>List::~List()</p>
<p>{</p>
<p>listNode *ptr=this-&gt;head,*next=NULL;</p>
<p>while(ptr!=NULL)</p>
<p>{</p>
<p>next=ptr-&gt;next;</p>
<p>delete(ptr);</p>
<p>ptr=next;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 412</p>
<p><span id="Chapter_77__Templates_1" class="anchor"></span>Chapter 77:
Templates</p>
<p>Classes, functions, and (since C++14) variables can be templated. A
template is a piece of code with some free</p>
<p>parameters that will become a concrete class, function, or variable
when all parameters are specified. Parameters can be types, values, or
themselves templates. A well-known template is std::vector, which
becomes a concrete</p>
<p>container type when the element type is specified, e.g.,
std::vector.</p>
<p>Section 77.1: Basic Class Template</p>
<p>The basic idea of a class template is that the template parameter
gets substituted by a type at compile time. The</p>
<p>result is that the same class can be reused for multiple types. The
user specifies which type will be used when a variable of the class is
declared. Three examples of this are shown in main():</p>
<p>#include</p>
<p>using std::cout;</p>
<p>template // A simple class to hold one number of any type class
Number {</p>
<p>public:</p>
<p>void setNum(T n); // Sets the class field to the given number</p>
<p>T plus1() const; // returns class field's "follower" private:</p>
<p>T num; // Class field</p>
<p>};</p>
<p>template // Set the class field to the given number void
Number::setNum(T n) {</p>
<p>num = n;</p>
<p>}</p>
<p>template // returns class field's "follower" T Number::plus1() const
{</p>
<p>return num + 1;</p>
<p>}</p>
<p>int main() {</p>
<p>Number anInt; // Test with an integer (int replaces T in the
class)</p>
<p>anInt.setNum(1);</p>
<p>cout &lt;&lt; "My integer + 1 is " &lt;&lt; anInt.plus1() &lt;&lt;
"<strong>\n</strong>"; // Prints 2</p>
<p>Number aDouble; // Test with a double</p>
<p>aDouble.setNum(3.1415926535897);</p>
<p>cout &lt;&lt; "My double + 1 is " &lt;&lt; aDouble.plus1() &lt;&lt;
"<strong>\n</strong>"; // Prints 4.14159</p>
<p>Number aFloat; // Test with a float</p>
<p>aFloat.setNum(1.4);</p>
<p>cout &lt;&lt; "My float + 1 is " &lt;&lt; aFloat.plus1() &lt;&lt;
"<strong>\n</strong>"; // Prints 2.4</p>
<p>return 0; // Successful completion</p>
<p>}</p>
<p>Section 77.2: Function Templates</p>
<p>Templating can also be applied to functions (as well as the more
traditional structures) with the same effect.</p>
<p>// 'T' stands for the unknown type</p>
<p>// Both of our arguments will be of the same type.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 413</p>
<p>template</p>
<p>void printSum(T add1, T add2)</p>
<p>{</p>
<p>std::cout &lt;&lt; (add1 + add2) &lt;&lt; std::endl;</p>
<p>}</p>
<p>This can then be used in the same way as structure templates.</p>
<p>printSum(4, 5);</p>
<p>printSum(4.5f, 8.9f);</p>
<p>In both these case the template argument is used to replace the types
of the parameters; the result works just like</p>
<p>a normal C++ function (if the parameters don't match the template
type the compiler applies the standard conversions).</p>
<p>One additional property of template functions (unlike template
classes) is that the compiler can infer the template</p>
<p>parameters based on the parameters passed to the function.</p>
<p>printSum(4, 5); // Both parameters are int.</p>
<p>// This allows the compiler deduce that the type</p>
<p>// T is also int.</p>
<p>printSum(5.0, 4); // In this case the parameters are two different
types.</p>
<p>// The compiler is unable to deduce the type of T</p>
<p>// because there are contradictions. As a result</p>
<p>// this is a compile time error.</p>
<p>This feature allows us to simplify code when we combine template
structures and functions. There is a common</p>
<p>pattern in the standard library that allows us to make template
structure X using a helper function make_X().</p>
<p>// The make_X pattern looks like this.</p>
<p>// 1) A template structure with 1 or more template types.
template</p>
<p>struct MyPair</p>
<p>{</p>
<p>T1 first;</p>
<p>T2 second;</p>
<p>};</p>
<p>// 2) A make function that has a parameter type for // each template
parameter in the template structure. template</p>
<p>MyPair make_MyPair(T1 t1, T2 t2)</p>
<p>{</p>
<p>return MyPair{t1, t2};</p>
<p>}</p>
<p>How does this help?</p>
<p>auto val1 = MyPair{5, 8.7}; // Create object explicitly defining the
types auto val2 = make_MyPair(5, 8.7); // Create object using the types
of the parameters.</p>
<p>// In this code both val1 and val2 are the same</p>
<p>// type.</p>
<p>Note: This is not designed to shorten the code. This is designed to
make the code more robust. It allows the types</p>
<p>to be changed by changing the code in a single place rather than in
multiple locations.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 414</p>
<p><span id="Section_77_3__Variadic_template"
class="anchor"></span>Section 77.3: Variadic template data
structures</p>
<p>Version ≥ C++14</p>
<p>It is often useful to define classes or structures that have a
variable number and type of data members which are</p>
<p>defined at compile time. The canonical example is std::tuple, but
sometimes is it is necessary to define your own custom structures. Here
is an example that defines the structure using compounding (rather than
inheritance as</p>
<p>with std::tuple. Start with the general (empty) definition, which
also serves as the base-case for recrusion termination in the later
specialisation:</p>
<p>template</p>
<p>struct DataStructure {};</p>
<p>This already allows us to define an empty structure,
DataStructure&lt;&gt; data, albeit that isn't very useful yet.</p>
<p>Next comes the recursive case specialisation:</p>
<p>template</p>
<p>struct DataStructure</p>
<p>{</p>
<p>DataStructure(const T&amp; first, const Rest&amp; ... rest)</p>
<p>: first(first)</p>
<p>, rest(rest...)</p>
<p>{}</p>
<p>T first;</p>
<p>DataStructure rest;</p>
<p>};</p>
<p>This is now sufficient for us to create arbitrary data structures,
like DataStructure data(1, 2.1, "hello").</p>
<p>So what's going on? First, note that this is a specialisation whose
requirement is that at least one variadic template parameter (namely T
above) exists, whilst not caring about the specific makeup of the pack
Rest. Knowing that T</p>
<p>exists allows the definition of its data member, first. The rest of
the data is recursively packaged as DataStructure rest . The constructor
initiates both of those members, including a recursive</p>
<p>constructor call to the rest member.</p>
<p>To understand this better, we can work through an example: suppose
you have a declaration DataStructure</p>
<p>float&gt; data. The declaration first matches against the
specialisation, yielding a structure with int first and DataStructure
rest data members. The rest definition again matches this
specialisation, creating its own</p>
<p>float first and DataStructure&lt;&gt; rest members. Finally this last
rest matches against the base-case defintion, producing an empty
structure.</p>
<p>You can visualise this as follows:</p>
<p>DataStructure</p>
<p>-&gt; int first</p>
<p>-&gt; DataStructure rest</p>
<p>-&gt; float first</p>
<p>-&gt; DataStructure&lt;&gt; rest</p>
<p>-&gt; (empty)</p>
<p>Now we have the data structure, but its not terribly useful yet as we
cannot easily access the individual data elements (for example to access
the last member of DataStructure data we would</p>
<p>have to use data.rest.rest.first, which is not exactly
user-friendly). So we add a get method to it (only needed</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 415</p>
<p>in the specialisation as the base-case structure has no data to
get):</p>
<p>template</p>
<p>struct DataStructure</p>
<p>{</p>
<p>...</p>
<p>template</p>
<p>auto get()</p>
<p>{</p>
<p>return GetHelper&gt;::get(*this);</p>
<p>}</p>
<p>...</p>
<p>};</p>
<p>As you can see this get member function is itself templated - this
time on the index of the member that is needed</p>
<p>(so usage can be things like data.get&lt;1&gt;(), similar to
std::tuple). The actual work is done by a static function in a</p>
<p>helper class, GetHelper. The reason we can't define the required
functionality directly in DataStructure's get is because (as we will
shortly see) we would need to specialise on idx - but it isn't possible
to specialise a template</p>
<p>member function without specialising the containing class template.
Note also the use of a C++14-style auto here makes our lives
significantly simpler as otherwise we would need quite a complicated
expression for the return</p>
<p>type.</p>
<p>So on to the helper class. This time we will need an empty forward
declaration and two specialisations. First the</p>
<p>declaration:</p>
<p>template</p>
<p>struct GetHelper;</p>
<p>Now the base-case (when idx==0). In this case we just return the
first member:</p>
<p>template</p>
<p>struct GetHelper&lt;0, DataStructure&gt;</p>
<p>{</p>
<p>static T get(DataStructure&amp; data)</p>
<p>{</p>
<p>return data.first;</p>
<p>}</p>
<p>};</p>
<p>In the recursive case, we decrement idx and invoke the GetHelper for
the rest member:</p>
<p>template struct GetHelper&gt; {</p>
<p>static auto get(DataStructure&amp; data)</p>
<p>{</p>
<p>return GetHelper&gt;::get(data.rest);</p>
<p>}</p>
<p>};</p>
<p>To work through an example, suppose we have DataStructure data and we
need data.get&lt;1&gt;().</p>
<p>This invokes GetHelper&lt;1, DataStructure&gt;::get(data) (the 2nd
specialisation), which in turn invokes GetHelper&lt;0,
DataStructure&gt;::get(data.rest), which finally returns (by the 1st
specialisation as</p>
<p>now idx is 0) data.rest.first.</p>
<p>So that's it! Here is the whole functioning code, with some example
use in the main function:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 416</p>
<p><span id="_include_3" class="anchor"></span>#include</p>
<p>template</p>
<p>struct GetHelper;</p>
<p>template</p>
<p>struct DataStructure</p>
<p>{</p>
<p>};</p>
<p>template</p>
<p>struct DataStructure</p>
<p>{</p>
<p>DataStructure(const T&amp; first, const Rest&amp; ... rest)</p>
<p>: first(first)</p>
<p>, rest(rest...)</p>
<p>{}</p>
<p>T first;</p>
<p>DataStructure rest;</p>
<p>template</p>
<p>auto get()</p>
<p>{</p>
<p>return GetHelper&gt;::get(*this);</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>struct GetHelper&lt;0, DataStructure&gt;</p>
<p>{</p>
<p>static T get(DataStructure&amp; data)</p>
<p>{</p>
<p>return data.first;</p>
<p>}</p>
<p>};</p>
<p>template struct GetHelper&gt; {</p>
<p>static auto get(DataStructure&amp; data)</p>
<p>{</p>
<p>return GetHelper&gt;::get(data.rest);</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>DataStructure data(1, 2.1, "Hello");</p>
<p>std::cout &lt;&lt; data.get&lt;0&gt;() &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; data.get&lt;1&gt;() &lt;&lt; std::endl;</p>
<p>std::cout &lt;&lt; data.get&lt;2&gt;() &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Section 77.4: Argument forwarding</p>
<p>Template may accept both lvalue and rvalue references using
forwarding reference:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 417</p>
<p><span id="template_5" class="anchor"></span>template</p>
<p>void f(T &amp;&amp;t);</p>
<p>In this case, the real type of t will be deduced depending on the
context:</p>
<p>struct X { };</p>
<p>X x;</p>
<p>f(x); // calls f(x)</p>
<p>f(X()); // calls f(x)</p>
<p>In the first case, the type T is deduced as reference to X (X&amp;),
and the type of t is lvalue reference to X, while in the second case the
type of T is deduced as X and the type of t as rvalue reference to X
(X&amp;&amp;).</p>
<p><strong>Note:</strong> It is worth noticing that in the first case,
decltype(t) is the same as T, but not in the second.</p>
<p>In order to perfectly forward t to another function ,whether it is an
lvalue or rvalue reference, one must use std::forward:</p>
<p>template</p>
<p>void f(T &amp;&amp;t) {</p>
<p>g(std::forward(t));</p>
<p>}</p>
<p>Forwarding references may be used with variadic templates:</p>
<p>template</p>
<p>void f(Args&amp;&amp;... args) {</p>
<p>g(std::forward(args)...);</p>
<p>}</p>
<p><strong>Note:</strong> Forwarding references can only be used for
template parameters, for instance, in the following code, v is a</p>
<p>rvalue reference, not a forwarding reference:</p>
<p>#include</p>
<p>template</p>
<p>void f(std::vector &amp;&amp;v);</p>
<p>Section 77.5: Partial template specialization</p>
<p>In contrast of a full template specialization partial template
specialization allows to introduce template with some of</p>
<p>the arguments of existing template fixed. Partial template
specialization is only available for template class/structs:</p>
<p>// Common case:</p>
<p>template</p>
<p>struct S {</p>
<p>T t_val;</p>
<p>U u_val;</p>
<p>};</p>
<p>// Special case when the first template argument is fixed to int
template</p>
<p>struct S {</p>
<p>double another_value;</p>
<p>int foo(double arg) {// Do something}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 418</p>
<p>};</p>
<p>As shown above, partial template specializations may introduce
completely different sets of data and function members.</p>
<p>When a partially specialized template is instantiated, the most
suitable specialization is selected. For example, let's define a
template and two partial specializations:</p>
<p>template</p>
<p>struct S {</p>
<p>static void foo() {</p>
<p>std::cout &lt;&lt; "General case<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>struct S {</p>
<p>static void foo() {</p>
<p>std::cout &lt;&lt; "T = int<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>struct S {</p>
<p>static void foo() {</p>
<p>std::cout &lt;&lt; "T = int, U = double<strong>\n</strong>";</p>
<p>}</p>
<p>};</p>
<p>Now the following calls:</p>
<p>S::foo();</p>
<p>S::foo();</p>
<p>S::foo();</p>
<p>will print</p>
<p>General case</p>
<p>T = int</p>
<p>T = int, U = double</p>
<p>Function templates may only be fully specialized:</p>
<p>template</p>
<p>void foo(T t, U u) {</p>
<p>std::cout &lt;&lt; "General case: " &lt;&lt; t &lt;&lt; " " &lt;&lt;
u &lt;&lt; std::endl; }</p>
<p>// OK.</p>
<p>template&lt;&gt;</p>
<p>void foo(int a1, int a2) {</p>
<p>std::cout &lt;&lt; "Two ints: " &lt;&lt; a1 &lt;&lt; " " &lt;&lt; a2
&lt;&lt; std::endl; }</p>
<p>void invoke_foo() {</p>
<p>foo(1, 2.1); // Prints "General case: 1 2.1"</p>
<p>foo(1,2); // Prints "Two ints: 1 2"</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 419</p>
<p><span id="___Compilation_error__partial_fu" class="anchor"></span>//
Compilation error: partial function specialization is not allowed.
template</p>
<p>void foo(std::string t, U u) {</p>
<p>std::cout &lt;&lt; "General case: " &lt;&lt; t &lt;&lt; " " &lt;&lt;
u &lt;&lt; std::endl; }</p>
<p>Section 77.6: Template Specialization</p>
<p>You can define implementation for specific instantiations of a
template class/method.</p>
<p>For example if you have:</p>
<p>template</p>
<p>T sqrt(T t) { /* Some generic implementation */ }</p>
<p>You can then write:</p>
<p>template&lt;&gt;</p>
<p>int sqrt(int i) { /* Highly optimized integer implementation */ }</p>
<p>Then a user that writes sqrt(4.0) will get the generic implementation
whereas sqrt(4) will get the specialized implementation.</p>
<p>Section 77.7: Alias template</p>
<p>Version ≥ C++11</p>
<p>Basic example:</p>
<p>template using pointer = T*;</p>
<p>This definition makes pointer an alias of T*. For example:</p>
<p>pointer p = new int; // equivalent to: int* p = new int;</p>
<p>Alias templates cannot be specialized. However, that functionality
can be obtained indirectly by having them refer</p>
<p>to a nested type in a struct:</p>
<p>template</p>
<p>struct nonconst_pointer_helper { typedef T* type; };</p>
<p>template</p>
<p>struct nonconst_pointer_helper { typedef T* type; };</p>
<p>template using nonconst_pointer = nonconst_pointer_helper::type;</p>
<p>Section 77.8: Explicit instantiation</p>
<p>An explicit instantiation definition creates and declares a concrete
class, function, or variable from a template,</p>
<p>without using it just yet. An explicit instantiation can be
referenced from other translation units. This can be used to avoid
defining a template in a header file, if it will only be instantiated
with a finite set of arguments. For example:</p>
<p>// print_string.h</p>
<p>template</p>
<p>void print_string(const T* str);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 420</p>
<p><span id="___print_string_cpp" class="anchor"></span>//
print_string.cpp</p>
<p>#include "print_string.h"</p>
<p>template void print_string(const char*);</p>
<p>template void print_string(const wchar_t*);</p>
<p>Because print_string and print_string are explicitly instantiated in
print_string.cpp, the</p>
<p>linker will be able to find them even though the print_string
template is not defined in the header. If these explicit</p>
<p>instantiation declarations were not present, a linker error would
likely occur. See <a
href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file">Why
can templates only be</a></p>
<p><a
href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file">implemented
in the header file?</a></p>
<p>Version ≥ C++11</p>
<p>If an explicit instantiation definition is preceded by the extern
keyword, it becomes an explicit instantiation declaration instead. The
presence of an explicit instantiation declaration for a given
specialization prevents the</p>
<p>implicit instantiation of the given specialization within the current
translation unit. Instead, a reference to that</p>
<p>specialization that would otherwise cause an implicit instantiation
can refer to an explicit instantiation definition in the same or another
TU.</p>
<p>foo.h</p>
<p>#ifndef FOO_H</p>
<p>#define FOO_H</p>
<p>template void foo(T x) {</p>
<p>// complicated implementation</p>
<p>}</p>
<p>#endif</p>
<p>foo.cpp</p>
<p>#include "foo.h"</p>
<p>// explicit instantiation definitions for common cases template void
foo(int);</p>
<p>template void foo(double);</p>
<p>main.cpp</p>
<p>#include "foo.h"</p>
<p>// we already know foo.cpp has explicit instantiation definitions for
these extern template void foo(double);</p>
<p>int main() {</p>
<p>foo(42); // instantiates foo here;</p>
<p>// wasteful since foo.cpp provides an explicit instantiation
already!</p>
<p>foo(3.14); // does not instantiate foo here;</p>
<p>// uses instantiation of foo in foo.cpp instead</p>
<p>}</p>
<p>Section 77.9: Non-type template parameter</p>
<p>Apart from types as a template parameter we are allowed to declare
values of constant expressions meeting one of</p>
<p>the following criteria:</p>
<p>integral or enumeration type,</p>
<p>pointer to object or pointer to function,</p>
<p>lvalue reference to object or lvalue reference to function,</p>
<p>pointer to member,</p>
<p>std::nullptr_t.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 421</p>
<p><span id="Like_all_template_parameters__no"
class="anchor"></span>Like all template parameters, non-type template
parameters can be explicitly specified, defaulted, or derived implicitly
via Template Argument Deduction.</p>
<p>Example of non-type template parameter usage:</p>
<p>#include</p>
<p>template</p>
<p>std::size_t size_of(T (&amp;anArray)[size]) // Pass array by
reference. Requires. { // an exact size. We allow all sizes</p>
<p>return size; // by using a template "size".</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>char anArrayOfChar[15];</p>
<p>std::cout &lt;&lt; "anArrayOfChar: " &lt;&lt; size_of(anArrayOfChar)
&lt;&lt; "<strong>\n</strong>";</p>
<p>int anArrayOfData[] = {1,2,3,4,5,6,7,8,9};</p>
<p>std::cout &lt;&lt; "anArrayOfData: " &lt;&lt; size_of(anArrayOfData)
&lt;&lt; "<strong>\n</strong>"; }</p>
<p>Example of explicitly specifying both type and non-type template
parameters:</p>
<p>#include</p>
<p>int main ()</p>
<p>{</p>
<p>std::array foo; // int is a type parameter, 5 is non-type }</p>
<p>Non-type template parameters are one of the ways to achieve template
recurrence and enables to do</p>
<p>Metaprogramming.</p>
<p>Section 77.10: Declaring non-type template arguments with</p>
<p>auto</p>
<p>Prior to C++17, when writing a template non-type parameter, you had
to specify its type first. So a common pattern became writing something
like:</p>
<p>template</p>
<p>struct integral_constant {</p>
<p>using type = T;</p>
<p>static constexpr T value = N;</p>
<p>};</p>
<p>using five = integral_constant;</p>
<p>But for complicated expressions, using something like this involves
having to write decltype(expr), expr when instantiating templates. The
solution is to simplify this idiom and simply allow auto:</p>
<p>Version ≥ C++17</p>
<p>template</p>
<p>struct integral_constant {</p>
<p>using type = decltype(N);</p>
<p>static constexpr type value = N;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 422</p>
<p><span id="using_five___integral_constant_5"
class="anchor"></span>using five = integral_constant&lt;5&gt;;</p>
<p>Empty custom deleter for unique_ptr</p>
<p>A nice motivating example can come from trying to combine the empty
base optimization with a custom deleter for</p>
<p>unique_ptr. Different C API deleters have different return types, but
we don't care - we just want something to work for any function:</p>
<p>template</p>
<p>struct FunctionDeleter {</p>
<p>template</p>
<p>void operator()(T* ptr) const {</p>
<p>DeleteFn(ptr);</p>
<p>}</p>
<p>};</p>
<p>template</p>
<p>using unique_ptr_deleter = std::unique_ptr&gt;;</p>
<p>And now you can simply use any function pointer that can take an
argument of type T as a template non-type</p>
<p>parameter, regardless of return type, and get a no-size overhead
unique_ptr out of it:</p>
<p>unique_ptr_deleter p;</p>
<p>Section 77.11: Template template parameters</p>
<p>Sometimes we would like to pass into the template a template type
without fixing its values. This is what template template parameters are
created for. Very simple template template parameter examples:</p>
<p>template</p>
<p>struct Tag1 { };</p>
<p>template</p>
<p>struct Tag2 { };</p>
<p>template class Tag&gt;</p>
<p>struct IntTag {</p>
<p>typedef Tag type;</p>
<p>};</p>
<p>int main() {</p>
<p>IntTag::type t;</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p>#include</p>
<p>#include</p>
<p>template class C, class U&gt; C cast_all(const C &amp;c) {</p>
<p>C result(c.begin(), c.end());</p>
<p>return result;</p>
<p>}</p>
<p>int main() {</p>
<p>std::vector vf = {1.2, 2.6, 3.7};</p>
<p>auto vi = cast_all(vf);</p>
<p>for(auto &amp;&amp;i: vi) {</p>
<p>std::cout &lt;&lt; i &lt;&lt; std::endl;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 423</p>
<p><span id="_34" class="anchor"></span>}</p>
<p>Section 77.12: Default template parameter value</p>
<p>Just like in case of the function arguments, template parameters can
have their default values. All template parameters with a default value
have to be declared at the end of the template parameter list. The basic
idea is that</p>
<p>the template parameters with default value can be omitted while
template instantiation.</p>
<p>Simple example of default template parameter value usage:</p>
<p>template</p>
<p>struct my_array {</p>
<p>T arr[N];</p>
<p>};</p>
<p>int main() {</p>
<p>/* Default parameter is ignored, N = 5 */</p>
<p>my_array a;</p>
<p>/* Print the length of a.arr: 5 */</p>
<p>std::cout &lt;&lt; sizeof(a.arr) / sizeof(int) &lt;&lt;
std::endl;</p>
<p>/* Last parameter is omitted, N = 10 */</p>
<p>my_array b;</p>
<p>/* Print the length of a.arr: 10 */</p>
<p>std::cout &lt;&lt; sizeof(b.arr) / sizeof(int) &lt;&lt; std::endl;
}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 424</p>
<p><span id="Chapter_78__Expression_templates_1"
class="anchor"></span>Chapter 78: Expression templates</p>
<p>Section 78.1: A basic example illustrating expression</p>
<p>templates</p>
<p>An expression template is a compile-time optimization technique used
mostly in scientific computing. It's main</p>
<p>purpose is to avoid unnecessary temporaries and optimize loop
calculations using a single pass (typically when performing operations
on numerical aggregates). Expression templates were initially devised in
order to circumvent</p>
<p>the inefficiencies of naïve operator overloading when implementing
numerical Array or Matrix types. An equivalent</p>
<p>terminology for expression templates has been introduced by Bjarne
Stroustrup, who calls them "fused operations" in the latest version of
his book, "The C++ Programming Language".</p>
<p>Before actually diving into expression templates, you should
understand why you need them in the first place. To</p>
<p>illustrate this, consider the very simple Matrix class given
below:</p>
<p>template class Matrix {</p>
<p>public:</p>
<p>using value_type = T;</p>
<p>Matrix() : values(COL * ROW) {}</p>
<p>static size_t cols() { return COL; }</p>
<p>static size_t rows() { return ROW; }</p>
<p>const T&amp; operator()(size_t x, size_t y) const { return values[y *
COL + x]; }</p>
<p>T&amp; operator()(size_t x, size_t y) { return values[y * COL + x];
}</p>
<p>private:</p>
<p>std::vector values;</p>
<p>};</p>
<p>template Matrix</p>
<p>operator+(const Matrix&amp; lhs, const Matrix&amp; rhs) {</p>
<p>Matrix result;</p>
<p>for (size_t y = 0; y != lhs.rows(); ++y) {</p>
<p>for (size_t x = 0; x != lhs.cols(); ++x) {</p>
<p>result(x, y) = lhs(x, y) + rhs(x, y);</p>
<p>}</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>Given the previous class definition, you can now write Matrix
expressions such as:</p>
<p>const std::size_t cols = 2000;</p>
<p>const std::size_t rows = 1000;</p>
<p>Matrix a, b, c;</p>
<p>// initialize a, b &amp; c</p>
<p>for (std::size_t y = 0; y != rows; ++y) {</p>
<p>for (std::size_t x = 0; x != cols; ++x) {</p>
<p>a(x, y) = 1.0;</p>
<p>b(x, y) = 2.0;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 425</p>
<p>c(x, y) = 3.0;</p>
<p>}</p>
<p>}</p>
<p>Matrix d = a + b + c; // d(x, y) = 6</p>
<p>As illustrated above, being able to overload operator+() provides you
with a notation which mimics the natural mathematical notation for
matrices.</p>
<p>Unfortunately, the previous implementation is also highly inefficient
compared to an equivalent "hand-crafted" version.</p>
<p>To understand why, you have to consider what happens when you write
an expression such as Matrix d = a + b</p>
<p>+ c. This in fact expands to ((a + b) + c) or operator+(operator+(a,
b), c). In other words, the loop inside</p>
<p>operator+() is executed twice, whereas it could have been easily
performed in a single pass. This also results in 2 temporaries being
created, which further degrades performance. In essence, by adding the
flexibility to use a</p>
<p>notation close to its mathematical counterpart, you have also made
the Matrix class highly inefficient.</p>
<p>For example, without operator overloading, you could implement a far
more efficient Matrix summation using a</p>
<p>single pass:</p>
<p>template Matrix add3(const Matrix&amp; a,</p>
<p>const Matrix&amp; b,</p>
<p>const Matrix&amp; c)</p>
<p>{</p>
<p>Matrix result;</p>
<p>for (size_t y = 0; y != ROW; ++y) {</p>
<p>for (size_t x = 0; x != COL; ++x) {</p>
<p>result(x, y) = a(x, y) + b(x, y) + c(x, y);</p>
<p>}</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>The previous example however has its own disadvantages because it
creates a far more convoluted interface for</p>
<p>the Matrix class (you would have to consider methods such as
Matrix::add2(), Matrix::AddMultiply() and so on).</p>
<p>Instead let us take a step back and see how we can adapt operator
overloading to perform in a more efficient way</p>
<p>The problem stems from the fact that the expression Matrix d = a + b
+ c is evaluated too "eagerly" before you have had an opportunity to
build the entire expression tree. In other words, what you really want
to achieve is to</p>
<p>evaluate a + b + c in one pass and only once you actually need to
assign the resulting expressing to d.</p>
<p>This is the core idea behind expression templates: instead of having
operator+() evaluate immediately the result</p>
<p>of adding two Matrix instances, it will return an "expression
template" for future evaluation once the entire</p>
<p>expression tree has been built.</p>
<p>For example, here is a possible implementation for an expression
template corresponding to the summation of 2 types:</p>
<p>template</p>
<p>class MatrixSum</p>
<p>{</p>
<p>public:</p>
<p>using value_type = typename LHS::value_type;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 426</p>
<p>MatrixSum(const LHS&amp; lhs, const RHS&amp; rhs) : rhs(rhs),
lhs(lhs) {}</p>
<p>value_type operator() (int x, int y) const {</p>
<p>return lhs(x, y) + rhs(x, y);</p>
<p>}</p>
<p>private:</p>
<p>const LHS&amp; lhs;</p>
<p>const RHS&amp; rhs;</p>
<p>};</p>
<p>And here is the updated version of operator+()</p>
<p>template</p>
<p>MatrixSum operator+(const LHS&amp; lhs, const LHS&amp; rhs) {</p>
<p>return MatrixSum(lhs, rhs);</p>
<p>}</p>
<p>As you can see, operator+() no longer returns an "eager evaluation"
of the result of adding 2 Matrix instances (which would be another
Matrix instance), but instead an expression template representing the
addition operation.</p>
<p>The most important point to keep in mind is that the expression has
not been evaluated yet. It merely holds references to its operands.</p>
<p>In fact, nothing stops you from instantiating the MatrixSum&lt;&gt;
expression template as follows:</p>
<p>MatrixSum, Matrix &gt; SumAB(a, b);</p>
<p>You can however at a later stage, when you actually need the result
of the summation, evaluate the expression d = a + b as follows:</p>
<p>for (std::size_t y = 0; y != a.rows(); ++y) {</p>
<p>for (std::size_t x = 0; x != a.cols(); ++x) {</p>
<p>d(x, y) = SumAB(x, y);</p>
<p>}</p>
<p>}</p>
<p>As you can see, another benefit of using an expression template, is
that you have basically managed to evaluate the</p>
<p>sum of a and b and assign it to d in a single pass.</p>
<p>Also, nothing stops you from combining multiple expression templates.
For example, a + b + c would result in the following expression
template:</p>
<p>MatrixSum, Matrix &gt;, Matrix &gt; SumABC(SumAB, c);</p>
<p>And here again you can evaluate the final result using a single
pass:</p>
<p>for (std::size_t y = 0; y != a.rows(); ++y) {</p>
<p>for (std::size_t x = 0; x != a.cols(); ++x) {</p>
<p>d(x, y) = SumABC(x, y);</p>
<p>}</p>
<p>}</p>
<p>Finally, the last piece of the puzzle is to actually plug your
expression template into the Matrix class. This is</p>
<p>essentially achieved by providing an implementation for
Matrix::operator=(), which takes the expression template as an argument
and evaluates it in one pass, as you did "manually" before:</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 427</p>
<p>class Matrix {</p>
<p>public:</p>
<p>using value_type = T;</p>
<p>Matrix() : values(COL * ROW) {}</p>
<p>static size_t cols() { return COL; }</p>
<p>static size_t rows() { return ROW; }</p>
<p>const T&amp; operator()(size_t x, size_t y) const { return values[y *
COL + x]; }</p>
<p>T&amp; operator()(size_t x, size_t y) { return values[y * COL + x];
}</p>
<p>template</p>
<p>Matrix&amp; operator=(const E&amp; expression) {</p>
<p>for (std::size_t y = 0; y != rows(); ++y) {</p>
<p>for (std::size_t x = 0; x != cols(); ++x) {</p>
<p>values[y * COL + x] = expression(x, y);</p>
<p>}</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p>private:</p>
<p>std::vector values;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 428</p>
<p><span id="Chapter_79__Curiously_Recurring_1"
class="anchor"></span>Chapter 79: Curiously Recurring Template</p>
<p>Pattern (CRTP)</p>
<p>A pattern in which a class inherits from a class template with itself
as one of its template parameters. CRTP is</p>
<p>usually used to provide static polymorphism in C++.</p>
<p>Section 79.1: The Curiously Recurring Template Pattern</p>
<p>(CRTP)</p>
<p>CRTP is a powerful, static alternative to virtual functions and
traditional inheritance that can be used to give types</p>
<p>properties at compile time. It works by having a base class template
which takes, as one of its template parameters,</p>
<p>the derived class. This permits it to legally perform a static_cast
of its this pointer to the derived class.</p>
<p>Of course, this also means that a CRTP class must always be used as
the base class of some other class. And the derived class must pass
itself to the base class.</p>
<p>Version ≥ C++14</p>
<p>Let's say you have a set of containers that all support the functions
begin() and end(). The standard library's requirements for containers
require more functionality. We can design a CRTP base class that
provides that</p>
<p>functionality, based solely on begin() and end():</p>
<p>#include</p>
<p>template</p>
<p>class Container {</p>
<p>private:</p>
<p>// self() yields a reference to the derived type</p>
<p>Sub&amp; self() { return *static_cast(this); }</p>
<p>Sub const&amp; self() const { return *static_cast<sub>(this);
}</sub></p>
<p>public:</p>
<p>decltype(auto) front() {</p>
<p>return *self().begin();</p>
<p>}</p>
<p>decltype(auto) back() {</p>
<p>return *std::prev(self().end());</p>
<p>}</p>
<p>decltype(auto) size() const {</p>
<p>return std::distance(self().begin(), self().end());</p>
<p>}</p>
<p>decltype(auto) operator[](std::size_t i) {</p>
<p>return *std::next(self().begin(), i);</p>
<p>}</p>
<p>};</p>
<p>The above class provides the functions front(), back(), size(), and
operator[] for any subclass which provides begin() and end(). An example
subclass is a simple dynamically allocated array:</p>
<p>#include</p>
<p>// A dynamically allocated array</p>
<p>template</p>
<p>class DynArray : public Container&gt; {</p>
<p>public:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 429</p>
<p><span id="using_Base___Container" class="anchor"></span>using Base =
Container&gt;;</p>
<p>DynArray(std::size_t size)</p>
<p>: size_{size},</p>
<p>data_{std::make_unique(size_)}</p>
<p>{ }</p>
<p>T* begin() { return data_.get(); }</p>
<p>const T* begin() const { return data_.get(); }</p>
<p>T* end() { return data_.get() + size_; }</p>
<p>const T* end() const { return data_.get() + size_; }</p>
<p>private:</p>
<p>std::size_t size_;</p>
<p>std::unique_ptr data_;</p>
<p>};</p>
<p>Users of the DynArray class can use the interfaces provided by the
CRTP base class easily as follows:</p>
<p>DynArray arr(10);</p>
<p>arr.front() = 2;</p>
<p>arr[2] = 5;</p>
<p>assert(arr.size() == 10);</p>
<p><strong>Usefulness:</strong> This pattern particularly avoids virtual
function calls at run-time which occur to traverse down the</p>
<p>inheritance hierarchy and simply relies on static casts:</p>
<p>DynArray arr(10);</p>
<p>DynArray::Base &amp; base = arr;</p>
<p>base.begin(); // no virtual calls</p>
<p>The only static cast inside the function begin() in the base class
Container&gt; allows the compiler to</p>
<p>drastically optimize the code and no virtual table look up happens at
runtime.</p>
<p><strong>Limitations:</strong> Because the base class is templated and
different for two different DynArrays it is not possible to</p>
<p>store pointers to their base classes in an type-homogenous array as
one could generally do with normal inheritance</p>
<p>where the base class is not dependent on the derived type:</p>
<p>class A {};</p>
<p>class B: public A{};</p>
<p>A* a = new B;</p>
<p>Section 79.2: CRTP to avoid code duplication</p>
<p>The example in Visitor Pattern provides a compelling use-case for
CRTP:</p>
<p>struct IShape</p>
<p>{</p>
<p>virtual ~IShape() = default;</p>
<p>virtual void accept(IShapeVisitor&amp;) const = 0;</p>
<p>};</p>
<p>struct Circle : IShape</p>
<p>{</p>
<p>// ...</p>
<p>// Each shape has to implement this method the same way</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 430</p>
<p>void accept(IShapeVisitor&amp; visitor) const override {
visitor.visit(*this); } // ...</p>
<p>};</p>
<p>struct Square : IShape</p>
<p>{</p>
<p>// ...</p>
<p>// Each shape has to implement this method the same way void
accept(IShapeVisitor&amp; visitor) const override {
visitor.visit(*this); } // ...</p>
<p>};</p>
<p>Each child type of IShape needs to implement the same function the
same way. That's a lot of extra typing. Instead,</p>
<p>we can introduce a new type in the hierarchy that does this for
us:</p>
<p>template</p>
<p>struct IShapeAcceptor : IShape {</p>
<p>void accept(IShapeVisitor&amp; visitor) const override {</p>
<p>// visit with our exact type</p>
<p>visitor.visit(*static_cast(this));</p>
<p>}</p>
<p>};</p>
<p>And now, each shape simply needs to inherit from the acceptor:</p>
<p>struct Circle : IShapeAcceptor</p>
<p>{</p>
<p>Circle(const Point&amp; center, double radius) : center(center),
radius(radius) {}</p>
<p>Point center;</p>
<p>double radius;</p>
<p>};</p>
<p>struct Square : IShapeAcceptor</p>
<p>{</p>
<p>Square(const Point&amp; topLeft, double sideLength) :
topLeft(topLeft), sideLength(sideLength) {}</p>
<p>Point topLeft;</p>
<p>double sideLength;</p>
<p>};</p>
<p>No duplicate code necessary.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 431</p>
<p><span id="Chapter_80__Threading_1" class="anchor"></span>Chapter 80:
Threading</p>
<p>Parameter Details</p>
<p>other Takes ownership of other, other doesn't own the thread
anymore</p>
<p>func Function to call in a separate thread</p>
<p>args Arguments for func</p>
<p>Section 80.1: Creating a std::thread</p>
<p>In C++, threads are created using the std::thread class. A thread is
a separate flow of execution; it is analogous to having a helper perform
one task while you simultaneously perform another. When all the code in
the thread is</p>
<p>executed, it terminates. When creating a thread, you need to pass
something to be executed on it. A few things that you can pass to a
thread:</p>
<p>Free functions</p>
<p>Member functions</p>
<p>Functor objects</p>
<p>Lambda expressions</p>
<p><a href="http://ideone.com/hX1Ygn">Free function example - executes a
function on a separate thread (Live Example</a>):</p>
<p>#include</p>
<p>#include</p>
<p>void foo(int a)</p>
<p>{</p>
<p>std::cout &lt;&lt; a &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>// Create and execute the thread</p>
<p>std::thread thread(foo, 10); // foo is the function to execute, 10 is
the</p>
<p>// argument to pass to it</p>
<p>// Keep going; the thread is executed separately</p>
<p>// Wait for the thread to finish; we stay here until it is done</p>
<p>thread.join();</p>
<p>return 0;</p>
<p>}</p>
<p>Member function example - executes a member function on a separate
thread (<a href="http://ideone.com/4QeG4E">Live Example</a>):</p>
<p>#include</p>
<p>#include</p>
<p>class Bar</p>
<p>{</p>
<p>public:</p>
<p>void foo(int a)</p>
<p>{</p>
<p>std::cout &lt;&lt; a &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 432</p>
<p>int main()</p>
<p>{</p>
<p>Bar bar;</p>
<p>// Create and execute the thread</p>
<p>std::thread thread(&amp;Bar::foo, &amp;bar, 10); // Pass 10 to member
function</p>
<p>// The member function will be executed in a separate thread</p>
<p>// Wait for the thread to finish, this is a blocking operation</p>
<p>thread.join();</p>
<p>return 0;</p>
<p>}</p>
<p><a href="http://ideone.com/h2EepE">Functor object example (Live
Example):</a></p>
<p>#include</p>
<p>#include</p>
<p>class Bar</p>
<p>{</p>
<p>public:</p>
<p>void operator()(int a)</p>
<p>{</p>
<p>std::cout &lt;&lt; a &lt;&lt; '<strong>\n</strong>';</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Bar bar;</p>
<p>// Create and execute the thread</p>
<p>std::thread thread(bar, 10); // Pass 10 to functor object</p>
<p>// The functor object will be executed in a separate thread</p>
<p>// Wait for the thread to finish, this is a blocking operation</p>
<p>thread.join();</p>
<p>return 0;</p>
<p>}</p>
<p>Lambda expression example (<a href="http://ideone.com/UacLRf">Live
Example</a>):</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>auto lambda = [](int a) { std::cout &lt;&lt; a &lt;&lt;
'<strong>\n</strong>'; };</p>
<p>// Create and execute the thread</p>
<p>std::thread thread(lambda, 10); // Pass 10 to the lambda
expression</p>
<p>// The lambda expression will be executed in a separate thread</p>
<p>// Wait for the thread to finish, this is a blocking operation</p>
<p>thread.join();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 433</p>
<p><span id="return_0_1" class="anchor"></span>return 0;</p>
<p>}</p>
<p>Section 80.2: Passing a reference to a thread</p>
<p>You cannot pass a reference (or const reference) directly to a thread
because std::thread will copy/move them. Instead, use
std::reference_wrapper:</p>
<p>void foo(int&amp; b)</p>
<p>{</p>
<p>b = 10;</p>
<p>}</p>
<p>int a = 1;</p>
<p>std::thread thread{ foo, std::ref(a) }; //'a' is now really passed as
reference</p>
<p>thread.join();</p>
<p>std::cout &lt;&lt; a &lt;&lt; '<strong>\n</strong>'; //Outputs 10</p>
<p>void bar(const ComplexObject&amp; co)</p>
<p>{</p>
<p>co.doCalculations();</p>
<p>}</p>
<p>ComplexObject object;</p>
<p>std::thread thread{ bar, std::cref(object) }; //'object' is passed as
const&amp;</p>
<p>thread.join();</p>
<p>std::cout &lt;&lt; object.getResult() &lt;&lt; '<strong>\n</strong>';
//Outputs the result</p>
<p>Section 80.3: Using std::async instead of std::thread</p>
<p>std::async is also able to make threads. Compared to std::thread it
is considered less powerful but easier to use when you just want to run
a function asynchronously.</p>
<p>Asynchronously calling a function</p>
<p>#include</p>
<p>#include</p>
<p>unsigned int square(unsigned int i){</p>
<p>return i*i;</p>
<p>}</p>
<p>int main() {</p>
<p>auto f = std::async(std::launch::async, square, 8);</p>
<p>std::cout &lt;&lt; "square currently running<strong>\n</strong>";
//do something while square is running</p>
<p>std::cout &lt;&lt; "result is " &lt;&lt; f.get() &lt;&lt;
'<strong>\n</strong>'; //getting the result from square }</p>
<p>Common Pitfalls</p>
<p>std::async returns a std::future that holds the return value that
will be calculated by the function. When</p>
<p>that future gets destroyed it waits until the thread completes,
making your code effectively single threaded. This is easily overlooked
when you don't need the return value:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 434</p>
<p><span id="std__async_std__launch__async__s"
class="anchor"></span>std::async(std::launch::async, square, 5);</p>
<p>//thread already completed at this point, because the returning
future got destroyed</p>
<p>std::async works without a launch policy, so std::async(square, 5);
compiles. When you do that the system gets to decide if it wants to
create a thread or not. The idea was that the system chooses to make
a</p>
<p>thread unless it is already running more threads than it can run
efficiently. Unfortunately implementations commonly just choose not to
create a thread in that situation, ever, so you need to override that
behavior</p>
<p>with std::launch::async which forces the system to create a
thread.</p>
<p>Beware of race conditions.</p>
<p>More on async on Futures and Promises</p>
<p>Section 80.4: Basic Synchronization</p>
<p>Thread synchronization can be accomplished using mutexes, among other
synchronization primitives. There are several mutex types provided by
the standard library, but the simplest is std::mutex. To lock a mutex,
you</p>
<p>construct a lock on it. The simplest lock type is
std::lock_guard:</p>
<p>std::mutex m;</p>
<p>void worker() {</p>
<p>std::lock_guard guard(m); // Acquires a lock on the mutex</p>
<p>// Synchronized code here</p>
<p>} // the mutex is automatically released when guard goes out of
scope</p>
<p>With std::lock_guard the mutex is locked for the whole lifetime of
the lock object. In cases where you need to</p>
<p>manually control the regions for locking, use std::unique_lock
instead:</p>
<p>std::mutex m;</p>
<p>void worker() {</p>
<p>// by default, constructing a unique_lock from a mutex will lock the
mutex // by passing the std::defer_lock as a second argument, we // can
construct the guard in an unlocked state instead and // manually lock
later.</p>
<p>std::unique_lock guard(m, std::defer_lock);</p>
<p>// the mutex is not locked yet!</p>
<p>guard.lock();</p>
<p>// critical section</p>
<p>guard.unlock();</p>
<p>// mutex is again released</p>
<p>}</p>
<p>More Thread synchronization structures</p>
<p>Section 80.5: Create a simple thread pool</p>
<p>C++11 threading primitives are still relatively low level. They can
be used to write a higher level construct, like a thread pool:</p>
<p>Version ≥ C++14</p>
<p>struct tasks {</p>
<p>// the mutex, condition variable and deque form a single //
thread-safe triggered queue of tasks:</p>
<p>std::mutex m;</p>
<p>std::condition_variable v;</p>
<p>// note that a packaged_task can store a packaged_task:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 435</p>
<p>std::deque&gt; work;</p>
<p>// this holds futures representing the worker threads being done:</p>
<p>std::vector&gt; finished;</p>
<p>// queue( lambda ) will enqueue the lambda into the tasks for the
threads // to use. A future of the type the lambda returns is given to
let you get // the result out.</p>
<p>template&gt;</p>
<p>std::future queue(F&amp;&amp; f) {</p>
<p>// wrap the function object into a packaged task, splitting //
execution from the return value:</p>
<p>std::packaged_task p(std::forward(f));</p>
<p>auto r=p.get_future(); // get the return value before we hand off the
task {</p>
<p>std::unique_lock l(m);</p>
<p>work.emplace_back(std::move(p)); // store the task as a task</p>
<p>}</p>
<p>v.notify_one(); // wake a thread to work on the task</p>
<p>return r; // return the future result of the task</p>
<p>}</p>
<p>// start N threads in the thread pool.</p>
<p>void start(std::size_t N=1){</p>
<p>for (std::size_t i = 0; i &lt; N; ++i)</p>
<p>{</p>
<p>// each thread is a std::async running this-&gt;thread_task():</p>
<p>finished.push_back(</p>
<p>std::async(</p>
<p>std::launch::async,</p>
<p>[this]{ thread_task(); }</p>
<p>)</p>
<p>);</p>
<p>}</p>
<p>}</p>
<p>// abort() cancels all non-started tasks, and tells every working
thread // stop running, and waits for them to finish up.</p>
<p>void abort() {</p>
<p>cancel_pending();</p>
<p>finish();</p>
<p>}</p>
<p>// cancel_pending() merely cancels all non-started tasks: void
cancel_pending() {</p>
<p>std::unique_lock l(m);</p>
<p>work.clear();</p>
<p>}</p>
<p>// finish enques a "stop the thread" message for every thread, then
waits for them: void finish() {</p>
<p>{</p>
<p>std::unique_lock l(m);</p>
<p>for(auto&amp;&amp;unused:finished){</p>
<p>work.push_back({});</p>
<p>}</p>
<p>}</p>
<p>v.notify_all();</p>
<p>finished.clear();</p>
<p>}</p>
<p>~tasks() {</p>
<p>finish();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 436</p>
<p><span id="private" class="anchor"></span>private:</p>
<p>// the work that a worker thread does:</p>
<p>void thread_task() {</p>
<p>while(true){</p>
<p>// pop a task off the queue:</p>
<p>std::packaged_task f;</p>
<p>{</p>
<p>// usual thread-safe queue code:</p>
<p>std::unique_lock l(m);</p>
<p>if (work.empty()){</p>
<p>v.wait(l,[&amp;]{return !work.empty();});</p>
<p>}</p>
<p>f = std::move(work.front());</p>
<p>work.pop_front();</p>
<p>}</p>
<p>// if the task is invalid, it means we are asked to abort: if
(!f.valid()) return;</p>
<p>// otherwise, run the task:</p>
<p>f();</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>tasks.queue( []{ return "hello world"s; } ) returns a std::future,
which when the tasks object gets around to running it is populated with
hello world.</p>
<p>You create threads by running tasks.start(10) (which starts 10
threads).</p>
<p>The use of packaged_task is merely because there is no type-erased
std::function equivalent that stores move-only types. Writing a custom
one of those would probably be faster than using packaged_task.</p>
<p><a href="http://coliru.stacked-crooked.com/">Live example.</a></p>
<p>Version = C++11</p>
<p>In C++11, replace result_of_t with typename result_of::type.</p>
<p>More on Mutexes.</p>
<p>Section 80.6: Ensuring a thread is always joined</p>
<p>When the destructor for std::thread is invoked, a call to either
join() or detach() <strong>must</strong> have been made. If a</p>
<p>thread has not been joined or detached, then by default
std::terminate will be called. Using <a
href="http://en.cppreference.com/w/cpp/language/raii">RAII</a>, this is
generally simple enough to accomplish:</p>
<p>class thread_joiner</p>
<p>{</p>
<p>public:</p>
<p>thread_joiner(std::thread t)</p>
<p>: t_(std::move(t))</p>
<p>{ }</p>
<p>~thread_joiner()</p>
<p>{</p>
<p>if(t_.joinable()) {</p>
<p>t_.join();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 437</p>
<p><span id="_35" class="anchor"></span>}</p>
<p>private:</p>
<p>std::thread t_;</p>
<p>}</p>
<p>This is then used like so:</p>
<p>void perform_work()</p>
<p>{</p>
<p>// Perform some work</p>
<p>}</p>
<p>void t()</p>
<p>{</p>
<p>thread_joiner j{std::thread(perform_work)};</p>
<p>// Do some other calculations while thread is running</p>
<p>} // Thread is automatically joined here</p>
<p>This also provides exception safety; if we had created our thread
normally and the work done in t() performing</p>
<p>other calculations had thrown an exception, join() would never have
been called on our thread and our process would have been
terminated.</p>
<p>Section 80.7: Operations on the current thread</p>
<p>std::this_thread is a namespace which has functions to do interesting
things on the current thread from function it is called from.</p>
<p>Function Description</p>
<p>get_id Returns the id of the thread</p>
<p>sleep_for Sleeps for a specified amount of time</p>
<p>sleep_until Sleeps until a specific time</p>
<p>yield Reschedule running threads, giving other threads priority</p>
<p>Getting the current threads id using std::this_thread::get_id:</p>
<p>void foo()</p>
<p>{</p>
<p>//Print this threads id</p>
<p>std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt;
'<strong>\n</strong>';</p>
<p>}</p>
<p>std::thread thread{ foo };</p>
<p>thread.join(); //'threads' id has now been printed, should be
something like 12556</p>
<p>foo(); //The id of the main thread is printed, should be something
like 2420</p>
<p>Sleeping for 3 seconds using std::this_thread::sleep_for:</p>
<p>void foo()</p>
<p>{</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(3)); }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 438</p>
<p><span id="std__thread_thread__foo" class="anchor"></span>std::thread
thread{ foo };</p>
<p>foo.join();</p>
<p>std::cout &lt;&lt; "Waited for 3 seconds!<strong>\n</strong>";</p>
<p>Sleeping until 3 hours in the future using
std::this_thread::sleep_until:</p>
<p>void foo()</p>
<p>{</p>
<p>std::this_thread::sleep_until(std::chrono::system_clock::now() +
std::chrono::hours(3)); }</p>
<p>std::thread thread{ foo };</p>
<p>thread.join();</p>
<p>std::cout &lt;&lt; "We are now located 3 hours after the thread has
been called<strong>\n</strong>";</p>
<p>Letting other threads take priority using
std::this_thread::yield:</p>
<p>void foo(int a)</p>
<p>{</p>
<p>for (int i = 0; i &lt; al ++i)</p>
<p>std::this_thread::yield(); //Now other threads take priority, because
this thread</p>
<p>//isn't doing anything important</p>
<p>std::cout &lt;&lt; "Hello World!<strong>\n</strong>";</p>
<p>}</p>
<p>std::thread thread{ foo, 10 };</p>
<p>thread.join();</p>
<p>Section 80.8: Using Condition Variables</p>
<p>A condition variable is a primitive used in conjunction with a mutex
to orchestrate communication between</p>
<p>threads. While it is neither the exclusive or most efficient way to
accomplish this, it can be among the simplest to</p>
<p>those familiar with the pattern.</p>
<p>One waits on a std::condition_variable with a std::unique_lock. This
allows the code to safely</p>
<p>examine shared state before deciding whether or not to proceed with
acquisition.</p>
<p>Below is a producer-consumer sketch that uses std::thread,
std::condition_variable, std::mutex, and a few others to make things
interesting.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::condition_variable cond;</p>
<p>std::mutex mtx;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 439</p>
<p>std::queue intq;</p>
<p>bool stopped = false;</p>
<p>std::thread producer{[&amp;]()</p>
<p>{</p>
<p>// Prepare a random number generator.</p>
<p>// Our producer will simply push random numbers to intq. //</p>
<p>std::default_random_engine gen{};</p>
<p>std::uniform_int_distribution dist{};</p>
<p>std::size_t count = 4006;</p>
<p>while(count--)</p>
<p>{</p>
<p>// Always lock before changing</p>
<p>// state guarded by a mutex and</p>
<p>// condition_variable (a.k.a. "condvar").</p>
<p>std::lock_guard L{mtx};</p>
<p>// Push a random int into the queue</p>
<p>intq.push(dist(gen));</p>
<p>// Tell the consumer it has an int</p>
<p>cond.notify_one();</p>
<p>}</p>
<p>// All done.</p>
<p>// Acquire the lock, set the stopped flag,</p>
<p>// then inform the consumer.</p>
<p>std::lock_guard L{mtx};</p>
<p>std::cout &lt;&lt; "Producer is done!" &lt;&lt; std::endl;</p>
<p>stopped = true;</p>
<p>cond.notify_one();</p>
<p>}};</p>
<p>std::thread consumer{[&amp;]()</p>
<p>{</p>
<p>do{</p>
<p>std::unique_lock L{mtx};</p>
<p>cond.wait(L,[&amp;]()</p>
<p>{</p>
<p>// Acquire the lock only if</p>
<p>// we've stopped or the queue</p>
<p>// isn't empty</p>
<p>return stopped || ! intq.empty();</p>
<p>});</p>
<p>// We own the mutex here; pop the queue</p>
<p>// until it empties out.</p>
<p>while( ! intq.empty())</p>
<p>{</p>
<p>const auto val = intq.front();</p>
<p>intq.pop();</p>
<p>std::cout &lt;&lt; "Consumer popped: " &lt;&lt; val &lt;&lt;
std::endl;</p>
<p>}</p>
<p>if(stopped){</p>
<p>// producer has signaled a stop</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 440</p>
<p><span id="std__cout_____Consumer_is_done"
class="anchor"></span>std::cout &lt;&lt; "Consumer is done!" &lt;&lt;
std::endl;</p>
<p>break;</p>
<p>}</p>
<p>}while(true);</p>
<p>}};</p>
<p>consumer.join();</p>
<p>producer.join();</p>
<p>std::cout &lt;&lt; "Example Completed!" &lt;&lt; std::endl;</p>
<p>return 0;</p>
<p>}</p>
<p>Section 80.9: Thread operations</p>
<p>When you start a thread, it will execute until it is finished.</p>
<p>Often, at some point, you need to (possibly - the thread may already
be done) wait for the thread to finish, because</p>
<p>you want to use the result for example.</p>
<p>int n;</p>
<p>std::thread thread{ calculateSomething, std::ref(n) };</p>
<p>//Doing some other stuff</p>
<p>//We need 'n' now!</p>
<p>//Wait for the thread to finish - if it is not already done
thread.join();</p>
<p>//Now 'n' has the result of the calculation done in the separate
thread std::cout &lt;&lt; n &lt;&lt; '<strong>\n</strong>';</p>
<p>You can also detach the thread, letting it execute freely:</p>
<p>std::thread thread{ doSomething };</p>
<p>//Detaching the thread, we don't need it anymore (for whatever
reason) thread.detach();</p>
<p>//The thread will terminate when it is done, or when the main thread
returns</p>
<p>Section 80.10: Thread-local storage</p>
<p>Thread-local storage can be created using the thread_local keyword. A
variable declared with the thread_local</p>
<p>specifier is said to have <strong>thread storage
duration.</strong></p>
<p>Each thread in a program has its own copy of each thread-local
variable. A thread-local variable with function (local) scope will be
initialized the first time control passes through its</p>
<p>definition. Such a variable is implicitly static, unless declared
extern. A thread-local variable with namespace or class (non-local)
scope will be initialized as part of thread startup.</p>
<p>Thread-local variables are destroyed upon thread termination.</p>
<p>A member of a class can only be thread-local if it is static. There
will therefore be one copy of that variable per thread, rather than one
copy per (thread, instance) pair.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 441</p>
<p><span id="Example_1" class="anchor"></span>Example:</p>
<p>void debug_counter() {</p>
<p>thread_local int count = 0;</p>
<p>Logger::log("This function has been called %d times by this thread",
++count); }</p>
<p>Section 80.11: Reassigning thread objects</p>
<p>We can create empty thread objects and assign work to them later.</p>
<p>If we assign a thread object to another active, joinable thread,
std::terminate will automatically be called before the thread is
replaced.</p>
<p>#include</p>
<p>void foo()</p>
<p>{</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(3)); }</p>
<p>//create 100 thread objects that do nothing</p>
<p>std::thread executors[100];</p>
<p>// Some code</p>
<p>// I want to create some threads now</p>
<p>for (int i = 0;i &lt; 100;i++)</p>
<p>{</p>
<p>// If this object doesn't have a thread assigned</p>
<p>if (!executors[i].joinable())</p>
<p>executors[i] = std::thread(foo);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 442</p>
<p><span id="Chapter_81__Thread_synchronizati_1"
class="anchor"></span>Chapter 81: Thread synchronization</p>
<p>structures</p>
<p>Working with threads might need some synchronization techniques if
the threads interact. In this topic, you can</p>
<p>find the different structures which are provided by the standard
library to solve these issues.</p>
<p>Section 81.1: std::condition_variable_any, std::cv_status</p>
<p>A generalization of std::condition_variable,
std::condition_variable_any works with any type of</p>
<p>BasicLockable structure.</p>
<p>std::cv_status as a return status for a condition variable has two
possible return codes:</p>
<p>std::cv_status::no_timeout: There was no timeout, condition variable
was notified</p>
<p>std::cv_status::no_timeout: Condition variable timed out</p>
<p>Section 81.2: std::shared_lock</p>
<p>A shared_lock can be used in conjunction with a unique lock to allow
multiple readers and exclusive writers.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>class PhoneBook {</p>
<p>public:</p>
<p>string getPhoneNo( const std::string &amp; name )</p>
<p>{</p>
<p>shared_lock r(_protect);</p>
<p>auto it = _phonebook.find( name );</p>
<p>if ( it == _phonebook.end() )</p>
<p>return (*it).second;</p>
<p>return "";</p>
<p>}</p>
<p>void addPhoneNo ( const std::string &amp; name, const std::string
&amp; phone ) {</p>
<p>unique_lock w(_protect);</p>
<p>_phonebook[name] = phone;</p>
<p>}</p>
<p>shared_timed_mutex _protect;</p>
<p>unordered_map _phonebook;</p>
<p>};</p>
<p>Section 81.3: std::call_once, std::once_flag</p>
<p>std::call_once ensures execution of a function exactly once by
competing threads. It throws std::system_error in case it cannot
complete its task.</p>
<p>Used in conjunction with std::once_flag.</p>
<p>#include</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 443</p>
<p><span id="_include_4" class="anchor"></span>#include</p>
<p>std::once_flag flag;</p>
<p>void do_something(){</p>
<p>std::call_once(flag, [](){std::cout &lt;&lt; "Happens once" &lt;&lt;
std::endl;});</p>
<p>std::cout &lt;&lt; "Happens every time" &lt;&lt; std::endl;</p>
<p>}</p>
<p>Section 81.4: Object locking for ecient access</p>
<p>Often you want to lock the entire object while you perform multiple
operations on it. For example, if you need to</p>
<p>examine or modify the object using iterators. Whenever you need to
call multiple member functions it is generally more efficient to lock
the whole object rather than individual member functions.</p>
<p>For example:</p>
<p>class text_buffer</p>
<p>{</p>
<p>// for readability/maintainability</p>
<p>using mutex_type = std::shared_timed_mutex;</p>
<p>using reading_lock = std::shared_lock; using updates_lock =
std::unique_lock;</p>
<p>public:</p>
<p>// This returns a scoped lock that can be shared by multiple //
readers at the same time while excluding any writers [[nodiscard]]</p>
<p>reading_lock lock_for_reading() const { return reading_lock(mtx);
}</p>
<p>// This returns a scoped lock that is exclusing to one // writer
preventing any readers</p>
<p>[[nodiscard]]</p>
<p>updates_lock lock_for_updates() { return updates_lock(mtx); }</p>
<p>char* data() { return buf; }</p>
<p>char const* data() const { return buf; }</p>
<p>char* begin() { return buf; }</p>
<p>char const* begin() const { return buf; }</p>
<p>char* end() { return buf + sizeof(buf); }</p>
<p>char const* end() const { return buf + sizeof(buf); }</p>
<p>std::size_t size() const { return sizeof(buf); }</p>
<p>private:</p>
<p>char buf[1024];</p>
<p>mutable mutex_type mtx; // mutable allows const objects to be
locked</p>
<p>};</p>
<p>When calculating a checksum the object is locked for reading,
allowing other threads that want to read from the</p>
<p>object at the same time to do so.</p>
<p>std::size_t checksum(text_buffer const&amp; buf)</p>
<p>{</p>
<p>std::size_t sum = 0xA44944A4;</p>
<p>// lock the object for reading</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 444</p>
<p>auto lock = buf.lock_for_reading();</p>
<p>for(auto c: buf)</p>
<p>sum = (sum &lt;&lt; 8) | (((unsigned char) ((sum &amp; 0xFF000000)
&gt;&gt; 24)) ^ c);</p>
<p>return sum;</p>
<p>}</p>
<p>Clearing the object updates its internal data so it must be done
using an exclusing lock.</p>
<p>void clear(text_buffer&amp; buf)</p>
<p>{</p>
<p>auto lock = buf.lock_for_updates(); // exclusive lock</p>
<p>std::fill(std::begin(buf), std::end(buf), '<strong>\0</strong>');
}</p>
<p>When obtaining more than one lock care should be taken to always
acquire the locks in the same order for all</p>
<p>threads.</p>
<p>void transfer(text_buffer const&amp; input, text_buffer&amp; output)
{</p>
<p>auto lock1 = input.lock_for_reading();</p>
<p>auto lock2 = output.lock_for_updates();</p>
<p>std::copy(std::begin(input), std::end(input), std::begin(output));
}</p>
<p><strong>note:</strong> This is best done using <a
href="http://en.cppreference.com/w/cpp/thread/lock_tag">std::deferred::lock</a>
and calling <a
href="http://en.cppreference.com/w/cpp/thread/lock">std::lock</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 445</p>
<p><span id="Chapter_82__The_Rule_of_Three__F_1"
class="anchor"></span>Chapter 82: The Rule of Three, Five, And</p>
<p>Zero</p>
<p>Section 82.1: Rule of Zero</p>
<p>Version ≥ C++11</p>
<p>We can combine the principles of the Rule of Five and RAII to get a
much leaner interface: the Rule of Zero: any resource that needs to be
managed should be in its own type. That type would have to follow the
Rule of Five, but</p>
<p>all users of that resource do not need to write any of the five
special member functions and can simply default all of them.</p>
<p>Using the Person class introduced in the Rule of Three example, we
can create a resource-managing object for cstrings :</p>
<p>class cstring {</p>
<p>private:</p>
<p>char* p;</p>
<p>public:</p>
<p>~cstring() { delete [] p; }</p>
<p>cstring(cstring const&amp; );</p>
<p>cstring(cstring&amp;&amp; );</p>
<p>cstring&amp; operator=(cstring const&amp; );</p>
<p>cstring&amp; operator=(cstring&amp;&amp; );</p>
<p>/* other members as appropriate */</p>
<p>};</p>
<p>And once this is separate, our Person class becomes far simpler:</p>
<p>class Person {</p>
<p>cstring name;</p>
<p>int arg;</p>
<p>public:</p>
<p>~Person() = default;</p>
<p>Person(Person const&amp; ) = default;</p>
<p>Person(Person&amp;&amp; ) = default;</p>
<p>Person&amp; operator=(Person const&amp; ) = default;</p>
<p>Person&amp; operator=(Person&amp;&amp; ) = default;</p>
<p>/* other members as appropriate */</p>
<p>};</p>
<p>The special members in Person do not even need to be declared
explicitly; the compiler will default or delete them</p>
<p>appropriately, based on the contents of Person. Therefore, the
following is also an example of the rule of zero.</p>
<p>struct Person {</p>
<p>cstring name;</p>
<p>int arg;</p>
<p>};</p>
<p>If cstring were to be a move-only type, with a deleted copy
constructor/assignment operator, then Person would automatically be
move-only as well.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 446</p>
<p><span id="The_term_rule_of_zero_was_introd" class="anchor"></span><a
href="https://rmf.io/cxx11/rule-of-zero">The term rule of zero was
introduced by R. Martinho Fernandes</a></p>
<p>Section 82.2: Rule of Five</p>
<p>Version ≥ C++11</p>
<p>C++11 introduces two new special member functions: the move
constructor and the move assignment operator. For all the same reasons
that you want to follow the Rule of Three in C++03, you usually want to
follow the Rule of</p>
<p>Five in C++11: If a class requires ONE of five special member
functions, and if move semantics are desired, then it most likely
requires ALL FIVE of them.</p>
<p>Note, however, that failing to follow the Rule of Five is usually not
considered an error, but a missed optimisation opportunity, as long as
the Rule of Three is still followed. If no move constructor or move
assignment operator is</p>
<p>available when the compiler would normally use one, it will instead
use copy semantics if possible, resulting in a less efficient operation
due to unnecessary copy operations. If move semantics aren't desired for
a class, then it has</p>
<p>no need to declare a move constructor or assignment operator.</p>
<p>Same example as for the Rule of Three:</p>
<p>class Person</p>
<p>{</p>
<p>char* name;</p>
<p>int age;</p>
<p>public:</p>
<p>// Destructor</p>
<p>~Person() { delete [] name; }</p>
<p>// Implement Copy Semantics</p>
<p>Person(Person const&amp; other)</p>
<p>: name(new char[std::strlen(other.name) + 1])</p>
<p>, age(other.age)</p>
<p>{</p>
<p>std::strcpy(name, other.name);</p>
<p>}</p>
<p>Person &amp;operator=(Person const&amp; other)</p>
<p>{</p>
<p>// Use copy and swap idiom to implement assignment.</p>
<p>Person copy(other);</p>
<p>swap(*this, copy);</p>
<p>return *this;</p>
<p>}</p>
<p>// Implement Move Semantics</p>
<p>// Note: It is usually best to mark move operators as noexcept //
This allows certain optimizations in the standard library // when the
class is used in a container.</p>
<p>Person(Person&amp;&amp; that) noexcept</p>
<p>: name(nullptr) // Set the state so we know it is undefined</p>
<p>, age(0)</p>
<p>{</p>
<p>swap(*this, that);</p>
<p>}</p>
<p>Person&amp; operator=(Person&amp;&amp; that) noexcept</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 447</p>
<p><span id="swap__this__that" class="anchor"></span>swap(*this,
that);</p>
<p>return *this;</p>
<p>}</p>
<p>friend void swap(Person&amp; lhs, Person&amp; rhs) noexcept</p>
<p>{</p>
<p>std::swap(lhs.name, rhs.name);</p>
<p>std::swap(lhs.age, rhs.age);</p>
<p>}</p>
<p>};</p>
<p>Alternatively, both the copy and move assignment operator can be
replaced with a single assignment operator,</p>
<p>which takes an instance by value instead of reference or rvalue
reference to facilitate using the copy-and-swap idiom.</p>
<p>Person&amp; operator=(Person copy)</p>
<p>{</p>
<p>swap(*this, copy);</p>
<p>return *this;</p>
<p>}</p>
<p>Extending from the Rule of Three to the Rule of Five is important for
performance reasons, but is not strictly necessary in most cases. Adding
the copy constructor and assignment operator ensures that moving the
type will</p>
<p>not leak memory (move-constructing will simply fall back to copying
in that case), but will be performing copies that</p>
<p>the caller probably did not anticipate.</p>
<p>Section 82.3: Rule of Three</p>
<p>Version ≤ c++03</p>
<p>The Rule of Three states that if a type ever needs to have a
user-defined copy constructor, copy assignment</p>
<p>operator, or destructor, then it must have all three.</p>
<p>The reason for the rule is that a class which needs any of the three
manages some resource (file handles,</p>
<p>dynamically allocated memory, etc), and all three are needed to
manage that resource consistently. The copy functions deal with how the
resource gets copied between objects, and the destructor would destroy
the resource,</p>
<p>in accord with RAII principles.</p>
<p>Consider a type that manages a string resource:</p>
<p>class Person</p>
<p>{</p>
<p>char* name;</p>
<p>int age;</p>
<p>public:</p>
<p>Person(char const* new_name, int new_age)</p>
<p>: name(new char[std::strlen(new_name) + 1])</p>
<p>, age(new_age)</p>
<p>{</p>
<p>std::strcpy(name, new_name);</p>
<p>}</p>
<p>~Person() {</p>
<p>delete [] name;</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 448</p>
<p><span id="Since_name_was_allocated_in_the"
class="anchor"></span>Since name was allocated in the constructor, the
destructor deallocates it to avoid leaking memory. But what happens if
such an object is copied?</p>
<p>int main()</p>
<p>{</p>
<p>Person p1("foo", 11);</p>
<p>Person p2 = p1;</p>
<p>}</p>
<p>First, p1 will be constructed. Then p2 will be copied from p1.
However, the C++-generated copy constructor will copy</p>
<p>each component of the type as-is. Which means that p1.name and
p2.name both point to the <strong>same</strong> string.</p>
<p>When main ends, destructors will be called. First p2's destructor
will be called; it will delete the string. Then p1's destructor will be
called. However, the string is already deleted. Calling delete on memory
that was already deleted</p>
<p>yields undefined behavior.</p>
<p>To avoid this, it is necessary to provide a suitable copy
constructor. One approach is to implement a reference</p>
<p>counted system, where different Person instances share the same
string data. Each time a copy is performed, the shared reference count
is incremented. The destructor then decrements the reference count, only
releasing the</p>
<p>memory if the count is zero.</p>
<p>Or we could implement value semantics and deep copying behavior:</p>
<p>Person(Person const&amp; other)</p>
<p>: name(new char[std::strlen(other.name) + 1])</p>
<p>, age(other.age)</p>
<p>{</p>
<p>std::strcpy(name, other.name);</p>
<p>}</p>
<p>Person &amp;operator=(Person const&amp; other)</p>
<p>{</p>
<p>// Use copy and swap idiom to implement assignment</p>
<p>Person copy(other);</p>
<p>swap(copy); // assume swap() exchanges contents of *this and copy</p>
<p>return *this;</p>
<p>}</p>
<p>Implementation of the copy assignment operator is complicated by the
need to release an existing buffer. The copy</p>
<p>and swap technique creates a temporary object which holds a new
buffer. Swapping the contents of *this and copy gives ownership to copy
of the original buffer. Destruction of copy, as the function returns,
releases the buffer</p>
<p>previously owned by *this.</p>
<p>Section 82.4: Self-assignment Protection</p>
<p>When writing a copy assignment operator, it is very important that it
be able to work in the event of self-</p>
<p>assignment. That is, it has to allow this:</p>
<p>SomeType t = ...;</p>
<p>t = t;</p>
<p>Self-assignment usually doesn't happen in such an obvious way. It
typically happens via a circuitous route through</p>
<p>various code systems, where the location of the assignment simply has
two Person pointers or references and has no idea that they are the same
object.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 449</p>
<p>Any copy assignment operator you write must be able to take this into
account.</p>
<p>The typical way to do so is to wrap all of the assignment logic in a
condition like this:</p>
<p>SomeType &amp;operator=(const SomeType &amp;other)</p>
<p>{</p>
<p>if(this != &amp;other)</p>
<p>{</p>
<p>//Do assignment logic.</p>
<p>}</p>
<p>return *this;</p>
<p>}</p>
<p><strong>Note:</strong> It is important to think about self-assignment
and ensure that your code behaves correctly when it happens.</p>
<p>However, self-assignment is a very rare occurrence and optimizing to
prevent it may actually pessimize the normal case. Since the normal case
is much more common, pessimizing for self-assignment may well reduce
your code</p>
<p>efficiency (so be careful using it).</p>
<p>As an example, the normal technique for implementing the assignment
operator is the copy and swap idiom. The</p>
<p>normal implementation of this technique does not bother to test for
self-assignment (even though self-assignment is expensive because a copy
is made). The reason is that pessimization of the normal case has been
shown to be</p>
<p>much more costly (as it happens more often).</p>
<p>Version ≥ c++11</p>
<p>Move assignment operators must also be protected against
self-assignment. However, the logic for many such operators is based on
std::swap, which can handle swapping from/to the same memory just fine.
So if your move</p>
<p>assignment logic is nothing more than a series of swap operations,
then you do not need self-assignment</p>
<p>protection.</p>
<p>If this is not the case, you must take similar measures as above.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 450</p>
<p><span id="Chapter_83__RAII__Resource_Acqui_1"
class="anchor"></span>Chapter 83: RAII: Resource Acquisition Is</p>
<p>Initialization</p>
<p>Section 83.1: Locking</p>
<p>Bad locking:</p>
<p>std::mutex mtx;</p>
<p>void bad_lock_example() {</p>
<p>mtx.lock();</p>
<p>try</p>
<p>{</p>
<p>foo();</p>
<p>bar();</p>
<p>if (baz()) {</p>
<p>mtx.unlock(); // Have to unlock on each exit point.</p>
<p>return;</p>
<p>}</p>
<p>quux();</p>
<p>mtx.unlock(); // Normal unlock happens here.</p>
<p>}</p>
<p>catch(...) {</p>
<p>mtx.unlock(); // Must also force unlock in the presence of</p>
<p>throw; // exceptions and allow the exception to continue.</p>
<p>}</p>
<p>}</p>
<p>That is the wrong way to implement the locking and unlocking of the
mutex. To ensure the correct release of the mutex with unlock() requires
the programer to make sure that all the flows resulting in the exiting
of the function</p>
<p>result in a call to unlock(). As shown above this is a brittle
processes as it requires any maintainers to continue following the
pattern manually.</p>
<p>Using an appropriately crafted class to implement RAII, the problem
is trivial:</p>
<p>std::mutex mtx;</p>
<p>void good_lock_example() {</p>
<p>std::lock_guard lk(mtx); // constructor locks.</p>
<p>// destructor unlocks. destructor call</p>
<p>// guaranteed by language.</p>
<p>foo();</p>
<p>bar();</p>
<p>if (baz()) {</p>
<p>return;</p>
<p>}</p>
<p>quux();</p>
<p>}</p>
<p>lock_guard is an extremely simple class template that simply calls
lock() on its argument in its constructor, keeps</p>
<p>a reference to the argument, and calls unlock() on the argument in
its destructor. That is, when the lock_guard goes out of scope, the
mutex is guaranteed to be unlocked. It doesn't matter if the reason it
went out of scope is an</p>
<p>exception or an early return - all cases are handled; regardless of
the control flow, we have guaranteed that we will unlock correctly.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 451</p>
<p><span id="Section_83_2__ScopeSuccess__c__1"
class="anchor"></span>Section 83.2: ScopeSuccess (c++17)</p>
<p>Version ≥ C++17</p>
<p>Thanks to int std::uncaught_exceptions(), we can implement action
which executes only on success (no thrown</p>
<p>exception in scope). Previously bool std::uncaught_exception() just
allows to detect if <strong>any</strong> stack unwinding is</p>
<p>running.</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>class ScopeSuccess</p>
<p>{</p>
<p>private:</p>
<p>F f;</p>
<p>int uncaughtExceptionCount = std::uncaught_exceptions();</p>
<p>public:</p>
<p>explicit ScopeSuccess(const F&amp; f) : f(f) {}</p>
<p>ScopeSuccess(const ScopeSuccess&amp;) = delete;</p>
<p>ScopeSuccess&amp; operator =(const ScopeSuccess&amp;) = delete;</p>
<p>// f() might throw, as it can be caught normally.</p>
<p>~ScopeSuccess() noexcept(noexcept(f())) {</p>
<p>if (uncaughtExceptionCount == std::uncaught_exceptions()) {</p>
<p>f();</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>struct Foo {</p>
<p>~Foo() {</p>
<p>try {</p>
<p>ScopeSuccess logSuccess{[](){std::cout &lt;&lt; "Success
1<strong>\n</strong>";}};</p>
<p>// Scope succeeds,</p>
<p>// even if Foo is destroyed during stack unwinding // (so when 0 &lt;
std::uncaught_exceptions())</p>
<p>// (or previously std::uncaught_exception() == true)</p>
<p>} catch (...) {</p>
<p>}</p>
<p>try {</p>
<p>ScopeSuccess logSuccess{[](){std::cout &lt;&lt; "Success
2<strong>\n</strong>";}};</p>
<p>throw std::runtime_error("Failed"); // returned value</p>
<p>// of std::uncaught_exceptions increases</p>
<p>} catch (...) { // returned value of std::uncaught_exceptions
decreases }</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>try {</p>
<p>Foo foo;</p>
<p>throw std::runtime_error("Failed"); // std::uncaught_exceptions() ==
1</p>
<p>} catch (...) { // std::uncaught_exceptions() == 0</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 452</p>
<p><span id="Output" class="anchor"></span>Output:</p>
<p>Success 1</p>
<p>Section 83.3: ScopeFail (c++17)</p>
<p>Version ≥ C++17</p>
<p>Thanks to int std::uncaught_exceptions(), we can implement action
which executes only on failure (thrown exception in scope). Previously
bool std::uncaught_exception() just allows to detect if
<strong>any</strong> stack unwinding is</p>
<p>running.</p>
<p>#include</p>
<p>#include</p>
<p>template</p>
<p>class ScopeFail</p>
<p>{</p>
<p>private:</p>
<p>F f;</p>
<p>int uncaughtExceptionCount = std::uncaught_exceptions();</p>
<p>public:</p>
<p>explicit ScopeFail(const F&amp; f) : f(f) {}</p>
<p>ScopeFail(const ScopeFail&amp;) = delete;</p>
<p>ScopeFail&amp; operator =(const ScopeFail&amp;) = delete;</p>
<p>// f() should not throw, else std::terminate is called.</p>
<p>~ScopeFail() {</p>
<p>if (uncaughtExceptionCount != std::uncaught_exceptions()) {</p>
<p>f();</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>struct Foo {</p>
<p>~Foo() {</p>
<p>try {</p>
<p>ScopeFail logFailure{[](){std::cout &lt;&lt; "Fail
1<strong>\n</strong>";}};</p>
<p>// Scope succeeds,</p>
<p>// even if Foo is destroyed during stack unwinding // (so when 0 &lt;
std::uncaught_exceptions())</p>
<p>// (or previously std::uncaught_exception() == true)</p>
<p>} catch (...) {</p>
<p>}</p>
<p>try {</p>
<p>ScopeFail logFailure{[](){std::cout &lt;&lt; "Failure
2<strong>\n</strong>";}};</p>
<p>throw std::runtime_error("Failed"); // returned value</p>
<p>// of std::uncaught_exceptions increases</p>
<p>} catch (...) { // returned value of std::uncaught_exceptions
decreases }</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>try {</p>
<p>Foo foo;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 453</p>
<p><span id="throw_std__runtime_error__Failed"
class="anchor"></span>throw std::runtime_error("Failed"); //
std::uncaught_exceptions() == 1</p>
<p>} catch (...) { // std::uncaught_exceptions() == 0</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Failure 2</p>
<p>Section 83.4: Finally/ScopeExit</p>
<p>For cases when we don't want to write special classes to handle some
resource, we may write a generic class:</p>
<p>template</p>
<p>class Finally final</p>
<p>{</p>
<p>public:</p>
<p>explicit Finally(Function f) : f(std::move(f)) {}</p>
<p>~Finally() { f(); } // (1) See below</p>
<p>Finally(const Finally&amp;) = delete;</p>
<p>Finally(Finally&amp;&amp;) = default;</p>
<p>Finally&amp; operator =(const Finally&amp;) = delete;</p>
<p>Finally&amp; operator =(Finally&amp;&amp;) = delete;</p>
<p>private:</p>
<p>Function f;</p>
<p>};</p>
<p>// Execute the function f when the returned object goes out of scope.
template</p>
<p>auto onExit(Function &amp;&amp;f) { return
Finally&gt;{std::forward(f)}; }</p>
<p>And its example usage</p>
<p>void foo(std::vector&amp; v, int i)</p>
<p>{</p>
<p>// ...</p>
<p>v[i] += 42;</p>
<p>auto autoRollBackChange = onExit([&amp;](){ v[i]-= 42; });</p>
<p>// ... code as recursive call `foo(v, i + 1)`</p>
<p>}</p>
<p>Note (1): Some discussion about destructor definition has to be
considered to handle exception:</p>
<p>~Finally() noexcept { f(); }: std::terminate is called in case of
exception</p>
<p>~Finally() noexcept(noexcept(f())) { f(); }: terminate() is called
only in case of exception during stack</p>
<p>unwinding.</p>
<p>~Finally() noexcept { try { f(); } catch (...) { /* ignore exception
(might log it) */} } No</p>
<p>std::terminate called, but we cannot handle error (even for non stack
unwinding).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 454</p>
<p><span id="Chapter_84__RTTI__Run_Time_Type_1"
class="anchor"></span>Chapter 84: RTTI: Run-Time Type</p>
<p>Information</p>
<p>Section 84.1: dynamic_cast</p>
<p>Use dynamic_cast&lt;&gt;() as a function, which helps you to cast
down through an inheritance hierarchy (main description).</p>
<p>If you must do some non-polymorphic work on some derived classes B
and C, but received the base class A, then write like this:</p>
<p>class A { public: virtual ~A(){} };</p>
<p>class B: public A</p>
<p>{ public: void work4B(){} };</p>
<p>class C: public A</p>
<p>{ public: void work4C(){} };</p>
<p>void non_polymorphic_work(A* ap)</p>
<p>{</p>
<p>if (B* bp =dynamic_cast(ap))</p>
<p>bp-&gt;work4B();</p>
<p>if (C* cp =dynamic_cast(ap))</p>
<p>cp-&gt;work4C();</p>
<p>}</p>
<p>Section 84.2: The typeid keyword</p>
<p>The typeid keyword is a unary operator that yields run-time type
information about its operand if the operand's type is a polymorphic
class type. It returns an lvalue of type const std::type_info. Top-level
cv-qualification are</p>
<p>ignored.</p>
<p>struct Base {</p>
<p>virtual ~Base() = default;</p>
<p>};</p>
<p>struct Derived : Base {};</p>
<p>Base* b = new Derived;</p>
<p>assert(typeid(*b) == typeid(Derived{})); // OK</p>
<p>typeid can also be applied to a type directly. In this case, first
top-level references are stripped, then top-level cv-</p>
<p>qualification is ignored. Thus, the above example could have been
written with typeid(Derived) instead of typeid(Derived{}):</p>
<p>assert(typeid(*b) == typeid(Derived{})); // OK</p>
<p>If typeid is applied to any expression that is not of polymorphic
class type, the operand is not evaluated, and the</p>
<p>type info returned is for the static type.</p>
<p>struct Base {</p>
<p>// note: no virtual destructor</p>
<p>};</p>
<p>struct Derived : Base {};</p>
<p>Derived d;</p>
<p>Base&amp; b = d;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 455</p>
<p><span id="assert_typeid_b_____typeid_Base"
class="anchor"></span>assert(typeid(b) == typeid(Base)); // not
Derived</p>
<p>assert(typeid(std::declval()) == typeid(Base)); // OK because
unevaluated</p>
<p>Section 84.3: Name of a type</p>
<p>You can retrieve the implementation defined name of a type in runtime
by using the .name() member function of</p>
<p>the std::type_info object returned by typeid.</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>int speed = 110;</p>
<p>std::cout &lt;&lt; typeid(speed).name() &lt;&lt;
'<strong>\n</strong>';</p>
<p>}</p>
<p>Output (implementation-defined):</p>
<p>int</p>
<p>Section 84.4: When to use which cast in c++</p>
<p>Use <strong>dynamic_cast</strong> for converting pointers/references
within an inheritance hierarchy.</p>
<p>Use <strong>static_cast</strong> for ordinary type conversions.</p>
<p>Use <strong>reinterpret_cast</strong> for low-level reinterpreting of
bit patterns. Use with extreme caution.</p>
<p>Use <strong>const_cast</strong> for casting away const/volatile.
Avoid this unless you are stuck using a const-incorrect API.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 456</p>
<p><span id="Chapter_85__Mutexes_1" class="anchor"></span>Chapter 85:
Mutexes</p>
<p>Section 85.1: Mutex Types</p>
<p>C++1x offers a selection of mutex classes:</p>
<p>std::mutex - offers simple locking functionality.</p>
<p>std::timed_mutex - offers try_to_lock functionality</p>
<p>std::recursive_mutex - allows recursive locking by the same
thread.</p>
<p>std::shared_mutex, std::shared_timed_mutex - offers shared and unique
lock functionality.</p>
<p>Section 85.2: std::lock</p>
<p>std::lock uses deadlock avoidance algorithms to lock one or more
mutexes. If an exception is thrown during a call</p>
<p>to lock multiple objects, std::lock unlocks the successfully locked
objects before re-throwing the exception.</p>
<p>std::lock(_mutex1, _mutex2);</p>
<p>Section 85.3: std::unique_lock, std::shared_lock,</p>
<p>std::lock_guard</p>
<p>Used for the RAII style acquiring of try locks, timed try locks and
recursive locks.</p>
<p>std::unique_lock allows for exclusive ownership of mutexes.</p>
<p>std::shared_lock allows for shared ownership of mutexes. Several
threads can hold std::shared_locks on a</p>
<p>std::shared_mutex. Available from C++ 14.</p>
<p>std::lock_guard is a lightweight alternative to std::unique_lock and
std::shared_lock.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>class PhoneBook {</p>
<p>public:</p>
<p>std::string getPhoneNo( const std::string &amp; name )</p>
<p>{</p>
<p>std::shared_lock l(_protect);</p>
<p>auto it = _phonebook.find( name );</p>
<p>if ( it != _phonebook.end() )</p>
<p>return (*it).second;</p>
<p>return "";</p>
<p>}</p>
<p>void addPhoneNo ( const std::string &amp; name, const std::string
&amp; phone ) {</p>
<p>std::unique_lock l(_protect);</p>
<p>_phonebook[name] = phone;</p>
<p>}</p>
<p>std::shared_timed_mutex _protect;</p>
<p>std::unordered_map _phonebook;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 457</p>
<p><span id="_36" class="anchor"></span>};</p>
<p>Section 85.4: Strategies for lock classes: std::try_to_lock,</p>
<p>std::adopt_lock, std::defer_lock</p>
<p>When creating a std::unique_lock, there are three different locking
strategies to choose from: std::try_to_lock,</p>
<p>std::defer_lock and std::adopt_lock</p>
<p>1. std::try_to_lock allows for trying a lock without blocking:</p>
<p>{</p>
<p>std::atomic_int temp {0};</p>
<p>std::mutex _mutex;</p>
<p>std::thread t( [&amp;](){</p>
<p>while( temp!=-1){</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(5));</p>
<p>std::unique_lock lock( _mutex, std::try_to_lock);</p>
<p>if(lock.owns_lock()){</p>
<p>//do something</p>
<p>temp=0;</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>while ( true )</p>
<p>{</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(1));</p>
<p>std::unique_lock lock( _mutex, std::try_to_lock);</p>
<p>if(lock.owns_lock()){</p>
<p>if (temp &lt; INT_MAX){</p>
<p>++temp;</p>
<p>}</p>
<p>std::cout &lt;&lt; temp &lt;&lt; std::endl;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>2. std::defer_lock allows for creating a lock structure without
acquiring the lock. When locking more than one</p>
<p>mutex, there is a window of opportunity for a deadlock if two
function callers try to acquire the locks at the same time:</p>
<p>{</p>
<p>std::unique_lock lock1(_mutex1, std::defer_lock);</p>
<p>std::unique_lock lock2(_mutex2, std::defer_lock);</p>
<p>lock1.lock()</p>
<p>lock2.lock(); // deadlock here</p>
<p>std::cout &lt;&lt; "Locked! &lt;&lt; std::endl;</p>
<p>//...</p>
<p>}</p>
<p>With the following code, whatever happens in the function, the locks
are acquired and released in appropriate</p>
<p>order:</p>
<p>{</p>
<p>std::unique_lock lock1(_mutex1, std::defer_lock);</p>
<p>std::unique_lock lock2(_mutex2, std::defer_lock);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 458</p>
<p><span id="std__lock_lock1_lock2______no_de"
class="anchor"></span>std::lock(lock1,lock2); // no deadlock
possible</p>
<p>std::cout &lt;&lt; "Locked! &lt;&lt; std::endl;</p>
<p>//...</p>
<p>}</p>
<p>3. std::adopt_lock does not attempt to lock a second time if the
calling thread currently owns the lock.</p>
<p>{</p>
<p>std::unique_lock lock1(_mutex1, std::adopt_lock);</p>
<p>std::unique_lock lock2(_mutex2, std::adopt_lock);</p>
<p>std::cout &lt;&lt; "Locked! &lt;&lt; std::endl;</p>
<p>//...</p>
<p>}</p>
<p>Something to keep in mind is that std::adopt_lock is not a substitute
for recursive mutex usage. When the lock goes</p>
<p>out of scope the mutex is <strong>released</strong>.</p>
<p>Section 85.5: std::mutex</p>
<p>std::mutex is a simple, non-recursive synchronization structure that
is used to protect data which is accessed by multiple threads.</p>
<p>std::atomic_int temp{0};</p>
<p>std::mutex _mutex;</p>
<p>std::thread t( [&amp;](){</p>
<p>while( temp!=-1){</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(5));</p>
<p>std::unique_lock lock( _mutex);</p>
<p>temp=0;</p>
<p>}</p>
<p>});</p>
<p>while ( true )</p>
<p>{</p>
<p>std::this_thread::sleep_for(std::chrono::milliseconds(1));</p>
<p>std::unique_lock lock( _mutex, std::try_to_lock);</p>
<p>if ( temp &lt; INT_MAX )</p>
<p>temp++;</p>
<p>cout &lt;&lt; temp &lt;&lt; endl;</p>
<p>}</p>
<p>Section 85.6: std::scoped_lock (C++ 17)</p>
<p>std::scoped_lock provides RAII style semantics for owning one more
mutexes, combined with the lock avoidance algorithms used by std::lock.
When std::scoped_lock is destroyed, mutexes are released in the reverse
order</p>
<p>from which they where acquired.</p>
<p>{</p>
<p>std::scoped_lock lock{_mutex1,_mutex2};</p>
<p>//do something</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 459</p>
<p><span id="Chapter_86__Recursive_Mutex_1"
class="anchor"></span>Chapter 86: Recursive Mutex</p>
<p>Section 86.1: std::recursive_mutex</p>
<p>Recursive mutex allows the same thread to recursively lock a resource
- up to an unspecified limit.</p>
<p>There are very few real-word justifications for this. Certain complex
implementations might need to call an</p>
<p>overloaded copy of a function without releasing the lock.</p>
<p>std::atomic_int temp{0};</p>
<p>std::recursive_mutex _mutex;</p>
<p>//launch_deferred launches asynchronous tasks on the same thread
id</p>
<p>auto future1 = std::async(</p>
<p>std::launch::deferred,</p>
<p>[&amp;]()</p>
<p>{</p>
<p>std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</p>
<p>std::this_thread::sleep_for(std::chrono::seconds(3));</p>
<p>std::unique_lock lock( _mutex);</p>
<p>temp=0;</p>
<p>});</p>
<p>auto future2 = std::async(</p>
<p>std::launch::deferred,</p>
<p>[&amp;]()</p>
<p>{</p>
<p>std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</p>
<p>while ( true )</p>
<p>{</p>
<p>std::this_thread::sleep_for(std::chrono::milliseconds(1));</p>
<p>std::unique_lock lock( _mutex, std::try_to_lock);</p>
<p>if ( temp &lt; INT_MAX )</p>
<p>temp++;</p>
<p>cout &lt;&lt; temp &lt;&lt; endl;</p>
<p>}</p>
<p>});</p>
<p>future1.get();</p>
<p>future2.get();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 460</p>
<p><span id="Chapter_87__Semaphore_1" class="anchor"></span>Chapter 87:
Semaphore</p>
<p>Semaphores are not available in C++ as of now, but can easily be
implemented with a mutex and a condition</p>
<p>variable.</p>
<p>This example was taken from:</p>
<p><a
href="http://stackoverflow.com/questions/4792449/c0x-has-no-semaphores-how-to-synchronize-threads">C++0x
has no semaphores? How to synchronize threads?</a></p>
<p>Section 87.1: Semaphore C++ 11</p>
<p>#include</p>
<p>#include</p>
<p>class Semaphore {</p>
<p>public:</p>
<p>Semaphore (int count_ = 0)</p>
<p>: count(count_)</p>
<p>{</p>
<p>}</p>
<p>inline void notify( int tid ) {</p>
<p>std::unique_lock lock(mtx);</p>
<p>count++;</p>
<p>cout &lt;&lt; "thread " &lt;&lt; tid &lt;&lt; " notify" &lt;&lt;
endl;</p>
<p>//notify the waiting thread</p>
<p>cv.notify_one();</p>
<p>}</p>
<p>inline void wait( int tid ) {</p>
<p>std::unique_lock lock(mtx);</p>
<p>while(count == 0) {</p>
<p>cout &lt;&lt; "thread " &lt;&lt; tid &lt;&lt; " wait" &lt;&lt;
endl;</p>
<p>//wait on the mutex until notify is called</p>
<p>cv.wait(lock);</p>
<p>cout &lt;&lt; "thread " &lt;&lt; tid &lt;&lt; " run" &lt;&lt;
endl;</p>
<p>}</p>
<p>count--;</p>
<p>}</p>
<p>private:</p>
<p>std::mutex mtx;</p>
<p>std::condition_variable cv;</p>
<p>int count;</p>
<p>};</p>
<p>Section 87.2: Semaphore class in action</p>
<p>The following function adds four threads. Three threads compete for
the semaphore, which is set to a count of one. A slower thread calls
notify_one(), allowing one of the waiting threads to proceed.</p>
<p>The result is that s1 immediately starts spinning, causing the
Semaphore's usage count to remain below 1. The other threads wait in
turn on the condition variable until notify() is called.</p>
<p>int main()</p>
<p>{</p>
<p>Semaphore sem(1);</p>
<p>thread s1([&amp;]() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 461</p>
<p>while(true) {</p>
<p>this_thread::sleep_for(std::chrono::seconds(5));</p>
<p>sem.wait( 1 );</p>
<p>}</p>
<p>});</p>
<p>thread s2([&amp;]() {</p>
<p>while(true){</p>
<p>sem.wait( 2 );</p>
<p>}</p>
<p>});</p>
<p>thread s3([&amp;]() {</p>
<p>while(true) {</p>
<p>this_thread::sleep_for(std::chrono::milliseconds(600));</p>
<p>sem.wait( 3 );</p>
<p>}</p>
<p>});</p>
<p>thread s4([&amp;]() {</p>
<p>while(true) {</p>
<p>this_thread::sleep_for(std::chrono::seconds(5));</p>
<p>sem.notify( 4 );</p>
<p>}</p>
<p>});</p>
<p>s1.join();</p>
<p>s2.join();</p>
<p>s3.join();</p>
<p>s4.join();</p>
<p>...</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 462</p>
<p><span id="Chapter_88__Futures_and_Promises_1"
class="anchor"></span>Chapter 88: Futures and Promises</p>
<p>Promises and Futures are used to ferry a single object from one
thread to another.</p>
<p>A std::promise object is set by the thread which generates the
result.</p>
<p>A std::future object can be used to retrieve a value, to test to see
if a value is available, or to halt execution until the value is
available.</p>
<p>Section 88.1: Async operation classes</p>
<p>std::async: performs an asynchronous operation.</p>
<p>std::future: provides access to the result of an asynchronous
operation.</p>
<p>std::promise: packages the result of an asynchronous operation.
std::packaged_task: bundles a function and the associated promise for
its return type.</p>
<p>Section 88.2: std::future and std::promise</p>
<p>The following example sets a promise to be consumed by another
thread:</p>
<p>{</p>
<p>auto promise = std::promise();</p>
<p>auto producer = std::thread([&amp;]</p>
<p>{</p>
<p>promise.set_value("Hello World");</p>
<p>});</p>
<p>auto future = promise.get_future();</p>
<p>auto consumer = std::thread([&amp;]</p>
<p>{</p>
<p>std::cout &lt;&lt; future.get();</p>
<p>});</p>
<p>producer.join();</p>
<p>consumer.join();</p>
<p>}</p>
<p>Section 88.3: Deferred async example</p>
<p>This code implements a version of std::async, but it behaves as if
async were always called with the deferred launch policy. This function
also does not have async's special future behavior; the returned future
can be</p>
<p>destroyed without ever acquiring its value.</p>
<p>template</p>
<p>auto async_deferred(F&amp;&amp; func)-&gt; std::future {</p>
<p>using result_type = decltype(func());</p>
<p>auto promise = std::promise();</p>
<p>auto future = promise.get_future();</p>
<p>std::thread(std::bind([=](std::promise&amp; promise)</p>
<p>{</p>
<p>try</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 463</p>
<p><span id="_37" class="anchor"></span>{</p>
<p>promise.set_value(func());</p>
<p>// Note: Will not work with std::promise. Needs some meta-template
programming</p>
<p>which is out of scope for this example.</p>
<p>}</p>
<p>catch(...)</p>
<p>{</p>
<p>promise.set_exception(std::current_exception());</p>
<p>}</p>
<p>}, std::move(promise))).detach();</p>
<p>return future;</p>
<p>}</p>
<p>Section 88.4: std::packaged_task and std::future</p>
<p>std::packaged_task bundles a function and the associated promise for
its return type:</p>
<p>template</p>
<p>auto async_deferred(F&amp;&amp; func)-&gt; std::future {</p>
<p>auto task = std::packaged_task(std::forward(func)); auto future =
task.get_future();</p>
<p>std::thread(std::move(task)).detach();</p>
<p>return std::move(future);</p>
<p>}</p>
<p>The thread starts running immediately. We can either detach it, or
have join it at the end of the scope. When the</p>
<p>function call to std::thread finishes, the result is ready.</p>
<p>Note that this is slightly different from std::async where the
returned std::future when destructed will actually</p>
<p><strong>block</strong> until the thread is finished.</p>
<p>Section 88.5: std::future_error and std::future_errc</p>
<p>If constraints for std::promise and std::future are not met an
exception of type std::future_error is thrown.</p>
<p>The error code member in the exception is of type std::future_errc
and values are as below, along with some test</p>
<p>cases:</p>
<p>enum class future_errc {</p>
<p>broken_promise = /* the task is no longer shared */,</p>
<p>future_already_retrieved = /* the answer was already retrieved
*/,</p>
<p>promise_already_satisfied = /* the answer was stored already */,</p>
<p>no_state = /* access to a promise in non-shared state */ };</p>
<p>Inactive promise:</p>
<p>int test()</p>
<p>{</p>
<p>std::promise pr;</p>
<p>return 0; // returns ok</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 464</p>
<p><span id="Active_promise__unused" class="anchor"></span>Active
promise, unused:</p>
<p>int test()</p>
<p>{</p>
<p>std::promise pr;</p>
<p>auto fut = pr.get_future(); //blocks indefinitely!</p>
<p>return 0;</p>
<p>}</p>
<p>Double retrieval:</p>
<p>int test()</p>
<p>{</p>
<p>std::promise pr;</p>
<p>auto fut1 = pr.get_future();</p>
<p>try{</p>
<p>auto fut2 = pr.get_future(); // second attempt to get future return
0;</p>
<p>}</p>
<p>catch(const std::future_error&amp; e)</p>
<p>{</p>
<p>cout &lt;&lt; e.what() &lt;&lt; endl; // Error: "The future has
already been retrieved from the</p>
<p>promise or packaged_task."</p>
<p>return-1;</p>
<p>}</p>
<p>return fut2.get();</p>
<p>}</p>
<p>Setting std::promise value twice:</p>
<p>int test()</p>
<p>{</p>
<p>std::promise pr;</p>
<p>auto fut = pr.get_future();</p>
<p>try{</p>
<p>std::promise pr2(std::move(pr));</p>
<p>pr2.set_value(10);</p>
<p>pr2.set_value(10); // second attempt to set promise throws
exception</p>
<p>}</p>
<p>catch(const std::future_error&amp; e)</p>
<p>{</p>
<p>cout &lt;&lt; e.what() &lt;&lt; endl; // Error: "The state of the
promise has already been</p>
<p>set."</p>
<p>return-1;</p>
<p>}</p>
<p>return fut.get();</p>
<p>}</p>
<p>Section 88.6: std::future and std::async</p>
<p>In the following naive parallel merge sort example, std::async is
used to launch multiple parallel merge_sort tasks.</p>
<p>std::future is used to wait for the results and synchronize them:</p>
<p>#include</p>
<p>using namespace std;</p>
<p>void merge(int low,int mid,int high, vector&amp;num)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 465</p>
<p>{</p>
<p>vector copy(num.size());</p>
<p>int h,i,j,k;</p>
<p>h=low;</p>
<p>i=low;</p>
<p>j=mid+1;</p>
<p>while((h&lt;=mid)&amp;&amp;(j&lt;=high))</p>
<p>{</p>
<p>if(num[h]&lt;=num[j])</p>
<p>{</p>
<p>copy[i]=num[h];</p>
<p>h++;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>copy[i]=num[j];</p>
<p>j++;</p>
<p>}</p>
<p>i++;</p>
<p>}</p>
<p>if(h&gt;mid)</p>
<p>{</p>
<p>for(k=j;k&lt;=high;k++)</p>
<p>{</p>
<p>copy[i]=num[k];</p>
<p>i++;</p>
<p>}</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>for(k=h;k&lt;=mid;k++)</p>
<p>{</p>
<p>copy[i]=num[k];</p>
<p>i++;</p>
<p>}</p>
<p>}</p>
<p>for(k=low;k&lt;=high;k++)</p>
<p>swap(num[k],copy[k]);</p>
<p>}</p>
<p>void merge_sort(int low,int high,vector&amp; num) {</p>
<p>int mid;</p>
<p>if(low</p>
<p>{</p>
<p>mid = low + (high-low)/2;</p>
<p>auto future1 = std::async(std::launch::deferred,[&amp;]()</p>
<p>{</p>
<p>merge_sort(low,mid,num);</p>
<p>});</p>
<p>auto future2 = std::async(std::launch::deferred, [&amp;]()</p>
<p>{</p>
<p>merge_sort(mid+1,high,num) ;</p>
<p>});</p>
<p>future1.get();</p>
<p>future2.get();</p>
<p>merge(low,mid,high,num);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 466</p>
<p>Note: In the example std::async is launched with policy
std::launch_deferred. This is to avoid a new thread being created in
every call. In the case of our example, the calls to std::async are made
out of order, the they</p>
<p>synchronize at the calls for std::future::get().</p>
<p>std::launch_async forces a new thread to be created in every
call.</p>
<p>The default policy is std::launch::deferred| std::launch::async,
meaning the implementation determines the policy for creating new
threads.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 467</p>
<p><span id="Chapter_89__Atomic_Types_1" class="anchor"></span>Chapter
89: Atomic Types</p>
<p>Section 89.1: Multi-threaded Access</p>
<p>An atomic type can be used to safely read and write to a memory
location shared between two threads.</p>
<p>A Bad example that is likely to cause a data race:</p>
<p>#include</p>
<p>#include</p>
<p>//function will add all values including and between 'a' and 'b' to
'result' void add(int a, int b, int * result) {</p>
<p>for (int i = a; i &lt;= b; i++) {</p>
<p>*result += i;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>//a primitive data type has no thread safety</p>
<p>int shared = 0;</p>
<p>//create a thread that may run parallel to the 'main' thread //the
thread will run the function 'add' defined above with parameters a = 1,
b = 100, result =</p>
<p>&amp;shared</p>
<p>//analogous to 'add(1,100, &amp;shared);'</p>
<p>std::thread addingThread(add, 1, 100, &amp;shared);</p>
<p>//attempt to print the value of 'shared' to console //main will keep
repeating this until the addingThread becomes joinable while
(!addingThread.joinable()) {</p>
<p>//this may cause undefined behavior or print a corrupted value //if
the addingThread tries to write to 'shared' while the main thread is
reading it</p>
<p>std::cout &lt;&lt; shared &lt;&lt; std::endl;</p>
<p>}</p>
<p>//rejoin the thread at the end of execution for cleaning purposes</p>
<p>addingThread.join();</p>
<p>return 0;</p>
<p>}</p>
<p>The above example may cause a corrupted read and can lead to
undefined behavior.</p>
<p>An example with thread safety:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>//function will add all values including and between 'a' and 'b' to
'result'</p>
<p>void add(int a, int b, std::atomic * result) {</p>
<p>for (int i = a; i &lt;= b; i++) {</p>
<p>//atomically add 'i' to result</p>
<p>result-&gt;fetch_add(i);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 468</p>
<p>}</p>
<p>int main() {</p>
<p>//atomic template used to store non-atomic objects</p>
<p>std::atomic shared = 0;</p>
<p>//create a thread that may run parallel to the 'main' thread //the
thread will run the function 'add' defined above with parameters a = 1,
b = 100, result =</p>
<p>&amp;shared</p>
<p>//analogous to 'add(1,100, &amp;shared);'</p>
<p>std::thread addingThread(add, 1, 10000, &amp;shared);</p>
<p>//print the value of 'shared' to console</p>
<p>//main will keep repeating this until the addingThread becomes
joinable while (!addingThread.joinable()) {</p>
<p>//safe way to read the value of shared atomically for thread safe
read</p>
<p>std::cout &lt;&lt; shared.load() &lt;&lt; std::endl;</p>
<p>}</p>
<p>//rejoin the thread at the end of execution for cleaning purposes</p>
<p>addingThread.join();</p>
<p>return 0;</p>
<p>}</p>
<p>The above example is safe because all store() and load() operations
of the atomic data type protect the</p>
<p>encapsulated int from simultaneous access.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 469</p>
<p><span id="Chapter_90__Type_Erasure_1" class="anchor"></span>Chapter
90: Type Erasure</p>
<p>Type erasure is a set of techniques for creating a type that can
provide a uniform interface to various underlying</p>
<p>types, while hiding the underlying type information from the client.
std::function, which has the ability to hold callable objects of various
types, is perhaps the best known example of type erasure in C++.</p>
<p>Section 90.1: A move-only `std::function`</p>
<p>std::function type erases down to a few operations. One of the things
it requires is that the stored value be copyable.</p>
<p>This causes problems in a few contexts, like lambdas storing unique
ptrs. If you are using the std::function in a context where copying
doesn't matter, like a thread pool where you dispatch tasks to threads,
this requirement can</p>
<p>add overhead.</p>
<p>In particular, std::packaged_task is a callable object that is
move-only. You can store a</p>
<p>std::packaged_task in a std::packaged_task, but that is a pretty
heavy-weight and obscure way to create a move-only callable type-erasure
class.</p>
<p>Thus the task. This demonstrates how you could write a simple
std::function type. I omitted the copy constructor</p>
<p>(which would involve adding a clone method to
details::task_pimpl&lt;...&gt; as well).</p>
<p>template</p>
<p>struct task;</p>
<p>// putting it in a namespace allows us to specialize it nicely for
void return value: namespace details {</p>
<p>template</p>
<p>struct task_pimpl {</p>
<p>virtual R invoke(Args&amp;&amp;...args) const = 0;</p>
<p>virtual ~task_pimpl() {};</p>
<p>virtual const std::type_info&amp; target_type() const = 0;</p>
<p>};</p>
<p>// store an F. invoke(Args&amp;&amp;...) calls the f</p>
<p>template</p>
<p>struct task_pimpl_impl:task_pimpl {</p>
<p>F f;</p>
<p>template</p>
<p>task_pimpl_impl( Fin&amp;&amp; fin ):f(std::forward(fin)) {}</p>
<p>virtual R invoke(Args&amp;&amp;...args) const final override {</p>
<p>return f(std::forward(args)...);</p>
<p>}</p>
<p>virtual const std::type_info&amp; target_type() const final override
{</p>
<p>return typeid(F);</p>
<p>}</p>
<p>};</p>
<p>// the void version discards the return value of f: template</p>
<p>struct task_pimpl_impl:task_pimpl { F f;</p>
<p>template</p>
<p>task_pimpl_impl( Fin&amp;&amp; fin ):f(std::forward(fin)) {}</p>
<p>virtual void invoke(Args&amp;&amp;...args) const final override {</p>
<p>f(std::forward(args)...);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 470</p>
<p>virtual const std::type_info&amp; target_type() const final override
{</p>
<p>return typeid(F);</p>
<p>}</p>
<p>};</p>
<p>};</p>
<p>template</p>
<p>struct task {</p>
<p>// semi-regular:</p>
<p>task()=default;</p>
<p>task(task&amp;&amp;)=default;</p>
<p>// no copy</p>
<p>private:</p>
<p>// aliases to make some SFINAE code below less ugly: template</p>
<p>using call_r = std::result_of_t; template</p>
<p>using is_task = std::is_same, task&gt;;</p>
<p>public:</p>
<p>// can be constructed from a callable F</p>
<p>template</p>
<p>// that can be invoked with Args... and converted-to-R: class=
decltype( (R)(std::declval&gt;()) ),</p>
<p>// and is not this same type:</p>
<p>std::enable_if_t{}, int&gt;* = nullptr</p>
<p>&gt;</p>
<p>task(F&amp;&amp; f):</p>
<p>m_pImpl( make_pimpl(std::forward(f)) )</p>
<p>{}</p>
<p>// the meat: the call operator</p>
<p>R operator()(Args... args)const {</p>
<p>return m_pImpl-&gt;invoke( std::forward(args)... );</p>
<p>}</p>
<p>explicit operator bool() const {</p>
<p>return (bool)m_pImpl;</p>
<p>}</p>
<p>void swap( task&amp; o ) {</p>
<p>std::swap( m_pImpl, o.m_pImpl );</p>
<p>}</p>
<p>template</p>
<p>void assign( F&amp;&amp; f ) {</p>
<p>m_pImpl = make_pimpl(std::forward(f));</p>
<p>}</p>
<p>// Part of the std::function interface:</p>
<p>const std::type_info&amp; target_type() const {</p>
<p>if (!*this) return typeid(void);</p>
<p>return m_pImpl-&gt;target_type();</p>
<p>}</p>
<p>template&lt; class T &gt;</p>
<p>T* target() {</p>
<p>return target_impl();</p>
<p>}</p>
<p>template&lt; class T &gt;</p>
<p>const T* target() const {</p>
<p>return target_impl();</p>
<p>}</p>
<p>// compare with nullptr :</p>
<p>friend bool operator==( std::nullptr_t, task const&amp; self ) {
return !self; } friend bool operator==( task const&amp; self,
std::nullptr_t ) { return !self; } friend bool operator!=(
std::nullptr_t, task const&amp; self ) { return !!self; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 471</p>
<p><span id="friend_bool_operator____task_con"
class="anchor"></span>friend bool operator!=( task const&amp; self,
std::nullptr_t ) { return !!self; }</p>
<p>private:</p>
<p>template</p>
<p>using pimpl_t = details::task_pimpl_impl;</p>
<p>template</p>
<p>static auto make_pimpl( F&amp;&amp; f ) {</p>
<p>using dF=std::decay_t;</p>
<p>using pImpl_t = pimpl_t;</p>
<p>return std::make_unique(std::forward(f));</p>
<p>}</p>
<p>std::unique_ptr&gt; m_pImpl;</p>
<p>template&lt; class T &gt;</p>
<p>T* target_impl() const {</p>
<p>return dynamic_cast*&gt;(m_pImpl.get());</p>
<p>}</p>
<p>};</p>
<p>To make this library-worthy, you'd want to add in a small buffer
optimization, so it does not store every callable on the heap.</p>
<p>Adding SBO would require a non-default task(task&amp;&amp;), some
std::aligned_storage_t within the class, a m_pImpl unique_ptr with a
deleter that can be set to destroy-only (and not return the memory to
the heap), and a</p>
<p>emplace_move_to( void* ) = 0 in the task_pimpl.</p>
<p><a href="http://coliru.stacked-crooked.com/a/6e6811e8626a37d1">live
example of the above code (with no SBO).</a></p>
<p>Section 90.2: Erasing down to a Regular type with manual</p>
<p>vtable</p>
<p>C++ thrives on what is known as a Regular type (or at least
Pseudo-Regular).</p>
<p>A Regular type is a type that can be constructed and assigned-to and
assigned-from via copy or move, can be</p>
<p>destroyed, and can be compared equal-to. It can also be constructed
from no arguments. Finally, it also has support for a few other
operations that are highly useful in various std algorithms and
containers.</p>
<p><a href="http://www.stepanovpapers.com/DeSt98.pdf">This is the root
paper</a>, but in C++11 would want to add std::hash support.</p>
<p>I will use the manual vtable approach to type erasure here.</p>
<p>using dtor_unique_ptr = std::unique_ptr; template</p>
<p>dtor_unique_ptr make_dtor_unique_ptr( Args&amp;&amp;... args ) {</p>
<p>return {new T(std::forward(args)...), [](void* self){ delete
static_cast(self); }};</p>
<p>}</p>
<p>struct regular_vtable {</p>
<p>void(*copy_assign)(void* dest, void const* src); // T&amp;=(T
const&amp;) void(*move_assign)(void* dest, void* src); //
T&amp;=(T&amp;&amp;) bool(*equals)(void const* lhs, void const* rhs); //
T const&amp;==T const&amp; bool(*order)(void const* lhs, void const*
rhs); // std::less{}(T const&amp;, T const&amp;)</p>
<p>std::size_t(*hash)(void const* self); // std::hash{}(T const&amp;)
std::type_info const&amp;(*type)(); // typeid(T)</p>
<p>dtor_unique_ptr(*clone)(void const* self); // T(T const&amp;) };</p>
<p>template</p>
<p>regular_vtable make_regular_vtable() noexcept {</p>
<p>return {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 472</p>
<p>[](void* dest, void const* src){ *static_cast(dest) =
*static_cast(src); }, [](void* dest, void* src){ *static_cast(dest) =
std::move(*static_cast(src)); }, [](void const* lhs, void const* rhs){
return *static_cast(lhs) == *static_cast</p>
<p>const*&gt;(rhs); },</p>
<p>[](void const* lhs, void const* rhs) { return
std::less{}(*static_cast</p>
<p>const*&gt;(lhs),*static_cast(rhs)); },</p>
<p>[](void const* self){ return std::hash{}(*static_cast(self)); },
[]()-&gt;decltype(auto){ return typeid(T); },</p>
<p>[](void const* self){ return
make_dtor_unique_ptr(*static_cast(self)); }</p>
<p>};</p>
<p>}</p>
<p>template</p>
<p>regular_vtable const* get_regular_vtable() noexcept {</p>
<p>static const regular_vtable vtable=make_regular_vtable(); return
&amp;vtable;</p>
<p>}</p>
<p>struct regular_type {</p>
<p>using self=regular_type;</p>
<p>regular_vtable const* vtable = 0;</p>
<p>dtor_unique_ptr ptr{nullptr, [](void*){}};</p>
<p>bool empty() const { return !vtable; }</p>
<p>template</p>
<p>void emplace( Args&amp;&amp;... args ) {</p>
<p>ptr = make_dtor_unique_ptr(std::forward(args)...);</p>
<p>if (ptr)</p>
<p>vtable = get_regular_vtable();</p>
<p>else</p>
<p>vtable = nullptr;</p>
<p>}</p>
<p>friend bool operator==(regular_type const&amp; lhs, regular_type
const&amp; rhs) {</p>
<p>if (lhs.vtable != rhs.vtable) return false;</p>
<p>return lhs.vtable-&gt;equals( lhs.ptr.get(), rhs.ptr.get() );</p>
<p>}</p>
<p>bool before(regular_type const&amp; rhs) const {</p>
<p>auto const&amp; lhs = *this;</p>
<p>if (!lhs.vtable || !rhs.vtable)</p>
<p>return std::less{}(lhs.vtable,rhs.vtable);</p>
<p>if (lhs.vtable != rhs.vtable)</p>
<p>return lhs.vtable-&gt;type().before(rhs.vtable-&gt;type());</p>
<p>return lhs.vtable-&gt;order( lhs.ptr.get(), rhs.ptr.get() );</p>
<p>}</p>
<p>// technically friend bool operator&lt; that calls before is also
required</p>
<p>std::type_info const* type() const {</p>
<p>if (!vtable) return nullptr;</p>
<p>return &amp;vtable-&gt;type();</p>
<p>}</p>
<p>regular_type(regular_type&amp;&amp; o):</p>
<p>vtable(o.vtable),</p>
<p>ptr(std::move(o.ptr))</p>
<p>{</p>
<p>o.vtable = nullptr;</p>
<p>}</p>
<p>friend void swap(regular_type&amp; lhs, regular_type&amp; rhs){
std::swap(lhs.ptr, rhs.ptr);</p>
<p>std::swap(lhs.vtable, rhs.vtable);</p>
<p>}</p>
<p>regular_type&amp; operator=(regular_type&amp;&amp; o) {</p>
<p>if (o.vtable == vtable) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 473</p>
<p>vtable-&gt;move_assign(ptr.get(), o.ptr.get());</p>
<p>return *this;</p>
<p>}</p>
<p>auto tmp = std::move(o);</p>
<p>swap(*this, tmp);</p>
<p>return *this;</p>
<p>}</p>
<p>regular_type(regular_type const&amp; o):</p>
<p>vtable(o.vtable),</p>
<p>ptr(o.vtable?o.vtable-&gt;clone(o.ptr.get()):dtor_unique_ptr{nullptr,
[](void*){}})</p>
<p>{</p>
<p>if (!ptr &amp;&amp; vtable) vtable = nullptr;</p>
<p>}</p>
<p>regular_type&amp; operator=(regular_type const&amp; o) {</p>
<p>if (o.vtable == vtable) {</p>
<p>vtable-&gt;copy_assign(ptr.get(), o.ptr.get());</p>
<p>return *this;</p>
<p>}</p>
<p>auto tmp = o;</p>
<p>swap(*this, tmp);</p>
<p>return *this;</p>
<p>}</p>
<p>std::size_t hash() const {</p>
<p>if (!vtable) return 0;</p>
<p>return vtable-&gt;hash(ptr.get());</p>
<p>}</p>
<p>template</p>
<p>std::enable_if_t&lt; !std::is_same, regular_type&gt;{}, int&gt;*
=nullptr</p>
<p>&gt;</p>
<p>regular_type(T&amp;&amp; t) {</p>
<p>emplace&gt;(std::forward(t));</p>
<p>}</p>
<p>};</p>
<p>namespace std {</p>
<p>template&lt;&gt;</p>
<p>struct hash {</p>
<p>std::size_t operator()( regular_type const&amp; r )const {</p>
<p>return r.hash();</p>
<p>}</p>
<p>};</p>
<p>template&lt;&gt;</p>
<p>struct less {</p>
<p>bool operator()( regular_type const&amp; lhs, regular_type const&amp;
rhs ) const {</p>
<p>return lhs.before(rhs);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p><a href="http://coliru.stacked-crooked.com/a/28ef6be761012a81">live
example.</a></p>
<p>Such a regular type can be used as a key for a std::map or a
std::unordered_map that accepts anything regular for a key, like:</p>
<p>std::map</p>
<p>would be basically a map from anothing regular, to anything
copyable.</p>
<p>Unlike any, my regular_type does no small object optimization nor
does it support getting the original data back.</p>
<p>Getting the original type back isn't hard.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 474</p>
<p><span id="Small_object_optimization_requir"
class="anchor"></span>Small object optimization requires that we store
an aligned storage buffer within the regular_type, and carefully tweak
the deleter of the ptr to only destroy the object and not delete it.</p>
<p>I would start at make_dtor_unique_ptr and teach it how to sometimes
store the data in a buffer, and then in the heap if no room in the
buffer. That may be sufficient.</p>
<p>Section 90.3: Basic mechanism</p>
<p>Type erasure is a way to hide the type of an object from code using
it, even though it is not derived from a common base class. In doing so,
it provides a bridge between the worlds of static polymorphism
(templates; at the place of</p>
<p>use, the exact type must be known at compile time, but it need not be
declared to conform to an interface at definition) and dynamic
polymorphism (inheritance and virtual functions; at the place of use,
the exact type need</p>
<p>not be known at compile time, but must be declared to conform to an
interface at definition).</p>
<p>The following code shows the basic mechanism of type erasure.</p>
<p>#include</p>
<p>class Printable</p>
<p>{</p>
<p>public:</p>
<p>template</p>
<p>Printable(T value) : pValue(new Value(value)) {} ~Printable() {
delete pValue; }</p>
<p>void print(std::ostream &amp;os) const { pValue-&gt;print(os); }</p>
<p>private:</p>
<p>Printable(Printable const &amp;) /* in C++1x: =delete */; // not
implemented</p>
<p>void operator = (Printable const &amp;) /* in C++1x: =delete */; //
not implemented struct ValueBase</p>
<p>{</p>
<p>virtual ~ValueBase() = default;</p>
<p>virtual void print(std::ostream &amp;) const = 0;</p>
<p>};</p>
<p>template</p>
<p>struct Value : ValueBase</p>
<p>{</p>
<p>Value(T const &amp;t) : v(t) {}</p>
<p>virtual void print(std::ostream &amp;os) const { os &lt;&lt; v; }</p>
<p>T v;</p>
<p>};</p>
<p>ValueBase *pValue;</p>
<p>};</p>
<p>At the use site, only the above definition need to be visible, just
as with base classes with virtual functions. For</p>
<p>example:</p>
<p>#include</p>
<p>void print_value(Printable const &amp;p)</p>
<p>{</p>
<p>p.print(std::cout);</p>
<p>}</p>
<p>Note that this is not a template, but a normal function that only
needs to be declared in a header file, and can be</p>
<p>defined in an implementation file (unlike templates, whose definition
must be visible at the place of use).</p>
<p>At the definition of the concrete type, nothing needs to be known
about Printable, it just needs to conform to an</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 475</p>
<p><span id="interface__as_with_templates"
class="anchor"></span>interface, as with templates:</p>
<p>struct MyType { int i; };</p>
<p>ostream&amp; operator &lt;&lt; (ostream &amp;os, MyType const
&amp;mc) {</p>
<p>return os &lt;&lt; "MyType {" &lt;&lt; mc.i &lt;&lt; "}";</p>
<p>}</p>
<p>We can now pass an object of this class to the function defined
above:</p>
<p>MyType foo = { 42 };</p>
<p>print_value(foo);</p>
<p>Section 90.4: Erasing down to a contiguous buer of T</p>
<p>Not all type erasure involves virtual inheritance, allocations,
placement new, or even function pointers.</p>
<p>What makes type erasure type erasure is that it describes a (set of)
behavior(s), and takes any type that supports</p>
<p>that behavior and wraps it up. All information that isn't in that set
of behaviors is "forgotten" or "erased".</p>
<p>An array_view takes its incoming range or container type and erases
everything except the fact it is a contiguous</p>
<p>buffer of T.</p>
<p>// helper traits for SFINAE:</p>
<p>template</p>
<p>using data_t = decltype( std::declval().data() );</p>
<p>template</p>
<p>using compatible_data = std::integral_constant, T* &gt;{} ||
std::is_same&lt; data_t, std::remove_const_t* &gt;{}&gt;;</p>
<p>template</p>
<p>struct array_view {</p>
<p>// the core of the class:</p>
<p>T* b=nullptr;</p>
<p>T* e=nullptr;</p>
<p>T* begin() const { return b; }</p>
<p>T* end() const { return e; }</p>
<p>// provide the expected methods of a good contiguous range:</p>
<p>T* data() const { return begin(); }</p>
<p>bool empty() const { return begin()==end(); }</p>
<p>std::size_t size() const { return end()-begin(); }</p>
<p>T&amp; operator[](std::size_t i)const{ return begin()[i]; } T&amp;
front()const{ return *begin(); }</p>
<p>T&amp; back()const{ return *(end()-1); }</p>
<p>// useful helpers that let you generate other ranges from this one //
quickly and safely:</p>
<p>array_view without_front( std::size_t i=1 ) const {</p>
<p>i = (std::min)(i, size());</p>
<p>return {begin()+i, end()};</p>
<p>}</p>
<p>array_view without_back( std::size_t i=1 ) const {</p>
<p>i = (std::min)(i, size());</p>
<p>return {begin(), end()-i};</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 476</p>
<p><span id="___array_view_is_plain_old_data" class="anchor"></span>//
array_view is plain old data, so default copy:</p>
<p>array_view(array_view const&amp;)=default;</p>
<p>// generates a null, empty range:</p>
<p>array_view()=default;</p>
<p>// final constructor:</p>
<p>array_view(T* s, T* f):b(s),e(f) {}</p>
<p>// start and length is useful in my experience:</p>
<p>array_view(T* s, std::size_t length):array_view(s, s+length) {}</p>
<p>// SFINAE constructor that takes any .data() supporting container //
or other range in one fell swoop:</p>
<p>template</p>
<p>std::enable_if_t&lt; compatible_data&amp;, T &gt;{}, int&gt;*
=nullptr,</p>
<p>std::enable_if_t&lt; !std::is_same, array_view &gt;{}, int&gt;*
=nullptr</p>
<p>&gt;</p>
<p>array_view( Src&amp;&amp; src ):</p>
<p>array_view( src.data(), src.size() )</p>
<p>{}</p>
<p>// array constructor:</p>
<p>template</p>
<p>array_view( T(&amp;arr)[N] ):array_view(arr, N) {}</p>
<p>// initializer list, allowing {} based:</p>
<p>template</p>
<p>std::enable_if_t&lt; std::is_same{}, int&gt;* =nullptr</p>
<p>&gt;</p>
<p>array_view( std::initializer_list il ):array_view(il.begin(),
il.end()) {} };</p>
<p>an array_view takes any container that supports .data() returning a
pointer to T and a .size() method, or an</p>
<p>array, and erases it down to being a random-access range over
contiguous Ts.</p>
<p>It can take a std::vector, a std::string a std::array a T[37], an
initializer list (including {} based</p>
<p>ones), or something else you make up that supports it (via T*
x.data() and size_t x.size()).</p>
<p>In this case, the data we can extract from the thing we are erasing,
together with our "view" non-owning state,</p>
<p>means we don't have to allocate memory or write custom type-dependent
functions.</p>
<p><a href="http://coliru.stacked-crooked.com/a/c9f8e013a309ca66">Live
example.</a></p>
<p>An improvement would be to use a non-member data and a non-member
size in an ADL-enabled context.</p>
<p>Section 90.5: Type erasing type erasure with std::any</p>
<p>This example uses C++14 and boost::any. In C++17 you can swap in
std::any instead.</p>
<p>The syntax we end up with is:</p>
<p>const auto print =</p>
<p>make_any_method([](auto&amp;&amp; p, std::ostream&amp; t){ t &lt;&lt;
p &lt;&lt; "<strong>\n</strong>"; });</p>
<p>super_any a = 7;</p>
<p>(a-&gt;*print)(std::cout);</p>
<p>which is almost optimal.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 477</p>
<p><a href="http://coliru.stacked-crooked.com/a/2ab8d7e41d24e616">This
example is based off of work by @dyp and</a> <a
href="http://stackoverflow.com/a/38865269/1774667">@cpplearner as well
as my own.</a></p>
<p>First we use a tag to pass around types:</p>
<p>templatestruct tag_t{constexpr tag_t(){};}; templateconstexpr tag_t
tag{};</p>
<p>This trait class gets the signature stored with an any_method:</p>
<p>This creates a function pointer type, and a factory for said function
pointers, given an any_method:</p>
<p>template</p>
<p>using any_sig_from_method = typename any_method::signature;</p>
<p>template&gt; struct any_method_function;</p>
<p>template</p>
<p>struct any_method_function {</p>
<p>template</p>
<p>using decorate = std::conditional_t&lt; any_method::is_const, T
const, T &gt;;</p>
<p>using any = decorate;</p>
<p>using type = R(*)(any&amp;, any_method const*, Args&amp;&amp;...);
template</p>
<p>type operator()( tag_t )const{</p>
<p>return +[](any&amp; self, any_method const* method,
Args&amp;&amp;...args) {</p>
<p>return (*method)( boost::any_cast&amp;&gt;(self),
decltype(args)(args)... );</p>
<p>};</p>
<p>}</p>
<p>};</p>
<p>any_method_function::type is the type of a function pointer we will
store alongside the instance. any_method_function::operator() takes a
tag_t and writes a custom instance of the</p>
<p>any_method_function::type that assumes the any&amp; is going to be a
T.</p>
<p>We want to be able to type-erase more than one method at a time. So
we bundle them up in a tuple, and write a</p>
<p>helper wrapper to stick the tuple into static storage on a per-type
basis and maintain a pointer to them.</p>
<p>template</p>
<p>using any_method_tuple = std::tuple&lt; typename
any_method_function::type... &gt;;</p>
<p>template</p>
<p>any_method_tuple make_vtable( tag_t ) {</p>
<p>return std::make_tuple(</p>
<p>any_method_function{}(tag)...</p>
<p>);</p>
<p>}</p>
<p>template</p>
<p>struct any_methods {</p>
<p>private:</p>
<p>any_method_tuple const* vtable = 0;</p>
<p>template</p>
<p>static any_method_tuple const* get_vtable( tag_t ) {</p>
<p>static const auto table = make_vtable(tag); return &amp;table;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 478</p>
<p>}</p>
<p>public:</p>
<p>any_methods() = default;</p>
<p>template</p>
<p>any_methods( tag_t ): vtable(get_vtable(tag)) {} any_methods&amp;
operator=(any_methods const&amp;)=default;</p>
<p>template</p>
<p>void change_type( tag_t ={} ) { vtable = get_vtable(tag); }</p>
<p>template</p>
<p>auto get_invoker( tag_t ={} ) const {</p>
<p>return std::get::type&gt;( *vtable );</p>
<p>}</p>
<p>};</p>
<p>We could specialize this for a cases where the vtable is small (for
example, 1 item), and use direct pointers stored in-class in those cases
for efficiency.</p>
<p>Now we start the super_any. I use super_any_t to make the declaration
of super_any a bit easier.</p>
<p>template</p>
<p>struct super_any_t;</p>
<p>This searches the methods that the super any supports for SFINAE and
better error messages:</p>
<p>template</p>
<p>struct super_method_applies_helper : std::false_type {};</p>
<p>template</p>
<p>struct super_method_applies_helper, method&gt; :</p>
<p>std::integral_constant{} || super_method_applies_helper,
method&gt;{}&gt; {};</p>
<p>template</p>
<p>auto super_method_test( super_any_t const&amp;, tag_t ) {</p>
<p>return std::integral_constant, method</p>
<p>&gt;{} &amp;&amp; method::is_const &gt;{};</p>
<p>}</p>
<p>template</p>
<p>auto super_method_test( super_any_t&amp;, tag_t ) {</p>
<p>return std::integral_constant, method</p>
<p>&gt;{} &gt;{};</p>
<p>}</p>
<p>template</p>
<p>struct super_method_applies:</p>
<p>decltype( super_method_test( std::declval(), tag ) )</p>
<p>{};</p>
<p>Next we create the any_method type. An any_method is a
pseudo-method-pointer. We create it globally and constly using syntax
like:</p>
<p>const auto print=make_any_method( [](auto&amp;&amp;self,
auto&amp;&amp;os){ os &lt;&lt; self; } );</p>
<p>or in C++17:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 479</p>
<p>const any_method print=[](auto&amp;&amp;self, auto&amp;&amp;os){ os
&lt;&lt; self; };</p>
<p>Note that using a non-lambda can make things hairy, as we use the
type for a lookup step. This can be fixed, but</p>
<p>would make this example longer than it already is. So always
initialize an any method from a lambda, or from a</p>
<p>type parametarized on a lambda.</p>
<p>template</p>
<p>struct any_method {</p>
<p>using signature=Sig;</p>
<p>enum{is_const=const_method};</p>
<p>private:</p>
<p>F f;</p>
<p>public:</p>
<p>template</p>
<p>// SFINAE testing that one of the Anys's matches this type:</p>
<p>std::enable_if_t&lt; super_method_applies&lt; Any&amp;&amp;,
any_method &gt;{}, int&gt;* =nullptr</p>
<p>&gt;</p>
<p>friend auto operator-&gt;*( Any&amp;&amp; self, any_method const&amp;
m ) {</p>
<p>// we don't use the value of the any_method, because each any_method
has // a unique type (!) and we check that one of the auto*'s in the
super_any // already has a pointer to us. We then dispatch to the
corresponding // any_method_data...</p>
<p>return [&amp;self, invoke = self.get_invoker(tag),
m](auto&amp;&amp;...args)-&gt;decltype(auto) {</p>
<p>return invoke( decltype(self)(self), &amp;m, decltype(args)(args)...
);</p>
<p>};</p>
<p>}</p>
<p>any_method( F fin ):f(std::move(fin)) {}</p>
<p>template</p>
<p>decltype(auto) operator()(Args&amp;&amp;...args)const {</p>
<p>return f(std::forward(args)...);</p>
<p>}</p>
<p>};</p>
<p>A factory method, not needed in C++17 I believe:</p>
<p>template</p>
<p>any_method&gt;</p>
<p>make_any_method( F&amp;&amp; f ) {</p>
<p>return {std::forward(f)};</p>
<p>}</p>
<p>This is the augmented any. It is both an any, and it carries around a
bundle of type-erasure function pointers that change whenever the
contained any does:</p>
<p>template</p>
<p>struct super_any_t:boost::any, any_methods {</p>
<p>using vtable=any_methods;</p>
<p>public:</p>
<p>template</p>
<p>std::enable_if_t&lt; !std::is_base_of&gt;{}, int&gt; =0</p>
<p>&gt;</p>
<p>super_any_t( T&amp;&amp; t ):</p>
<p>boost::any( std::forward(t) )</p>
<p>{</p>
<p>using dT=std::decay_t;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 480</p>
<p>this-&gt;change_type( tag</p>
<p>);</p>
<p>}</p>
<p>boost::any&amp; as_any()&amp;{return *this;}</p>
<p>boost::any&amp;&amp; as_any()&amp;&amp;{return std::move(*this);}
boost::any const&amp; as_any()const&amp;{return *this;}</p>
<p>super_any_t()=default;</p>
<p>super_any_t(super_any_t&amp;&amp; o):</p>
<p>boost::any( std::move( o.as_any() ) ),</p>
<p>vtable(o)</p>
<p>{}</p>
<p>super_any_t(super_any_t const&amp; o):</p>
<p>boost::any( o.as_any() ),</p>
<p>vtable(o)</p>
<p>{}</p>
<p>template</p>
<p>std::enable_if_t&lt; std::is_same, super_any_t&gt;{}, int&gt; =0</p>
<p>&gt;</p>
<p>super_any_t( S&amp;&amp; o ):</p>
<p>boost::any( std::forward<del>(o).as_any() ),</del></p>
<p>vtable(o)</p>
<p>{}</p>
<p>super_any_t&amp; operator=(super_any_t&amp;&amp;)=default;</p>
<p>super_any_t&amp; operator=(super_any_t const&amp;)=default;</p>
<p>template</p>
<p><del>std::enable_if_t&lt; !std::is_same</del>, super_any_t&gt;{},
int&gt;* =nullptr</p>
<p>&gt;</p>
<p>super_any_t&amp; operator=( T&amp;&amp; t ) {</p>
<p>((boost::any&amp;)*this) = std::forward<del>(t);</del></p>
<p>using dT=std::decay_t<del>;</del></p>
<p>this-&gt;change_type( tag</p>
<p>);</p>
<p>return *this;</p>
<p>}</p>
<p>};</p>
<p>Because we store the <del>any_method</del>s as <del>const</del>
objects, this makes making a <del>super_any</del> a bit easier:</p>
<p>template</p>
<p>using super_any = super_any_t&lt; std::remove_cv_t<del>...
&gt;;</del></p>
<p>Test code:</p>
<p><del>const auto print = make_any_method</del>([](auto&amp;&amp; p,
std::ostream&amp; t){ t &lt;&lt; p &lt;&lt; "<strong>\n</strong>";
});</p>
<p><del>const auto wprint = make_any_method</del>([](auto&amp;&amp; p,
std::wostream&amp; os ){ os &lt;&lt; p &lt;&lt; L"<strong>\n</strong>";
});</p>
<p>int main()</p>
<p>{</p>
<p><del>super_any</del> a = 7; super_any a2 = 7;</p>
<p>(a-&gt;*print)(std::cout);</p>
<p>(a-&gt;*wprint)(std::wcout);</p>
<p>}</p>
<p><a href="http://coliru.stacked-crooked.com/a/fbd10edb3336cce1">live
example.</a></p>
<p>Originally posted <a
href="http://stackoverflow.com/a/38837687/1774667">here</a> in a SO self
question &amp; answer (and people noted above helped with the
implementation).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 481</p>
<p><span id="Chapter_91__Explicit_type_conver_1"
class="anchor"></span>Chapter 91: Explicit type conversions</p>
<p>An expression can be explicitly converted or cast to type
<del>T</del> using <del>dynamic_cast</del>, static_cast,</p>
<p>reinterpret_cast, or <del>const_cast</del>, depending on what type of
cast is intended.</p>
<p>C++ also supports function-style cast notation, <del>T(expr)</del>,
and C-style cast notation, <del>(T)expr</del>.</p>
<p>Section 91.1: C-style casting</p>
<p>C-Style casting can be considered 'Best effort' casting and is named
so as it is the only cast which could be used in</p>
<p>C. The syntax for this cast is <del>(NewType)variable</del>.</p>
<p>Whenever this cast is used, it uses one of the following c++ casts
(in order):</p>
<p>const_cast<del>(variable)</del></p>
<p>static_cast<del>(variable)</del></p>
<p><del>const_cast</del>(static_cast(variable))
reinterpret_cast(variable)</p>
<p><del>const_cast</del>(reinterpret_cast(variable))</p>
<p>Functional casting is very similar, though as a few restrictions as
the result of its syntax: <del>NewType(expression)</del>. As a</p>
<p>result, only types without spaces can be cast to.</p>
<p>It's better to use new c++ cast, because s more readable and can be
spotted easily anywhere inside a C++ source</p>
<p>code and errors will be detected in compile-time, instead in
run-time.</p>
<p>As this cast can result in unintended <del>reinterpret_cast</del>, it
is often considered dangerous.</p>
<p>Section 91.2: Casting away constness</p>
<p>A pointer to a const object can be converted to a pointer to
non-const object using the <del>const_cast</del> keyword. Here</p>
<p>we use <del>const_cast</del> to call a function that is not
const-correct. It only accepts a non-const <del>char*</del> argument
even</p>
<p>though it never writes through the pointer:</p>
<p>void bad_strlen(char*);</p>
<p>const char* s = "hello, world!";</p>
<p>bad_strlen(s); // compile error</p>
<p><del>bad_strlen(const_cast</del>(s)); // OK, but it's better to make
bad_strlen accept const char*</p>
<p><del>const_cast</del> to reference type can be used to convert a
const-qualified lvalue into a non-const-qualified value.</p>
<p><del>const_cast</del> is dangerous because it makes it impossible for
the C++ type system to prevent you from trying to</p>
<p>modify a const object. Doing so results in undefined behavior.</p>
<p>const int x = 123;</p>
<p>int&amp; mutable_x = const_cast<del>(x);</del></p>
<p>mutable_x = 456; // may compile, but produces *undefined
behavior*</p>
<p>Section 91.3: Base to derived conversion</p>
<p>A pointer to base class can be converted to a pointer to derived
class using <del>static_cast</del>. <del>static_cast</del> does not do
any run-time checking and can lead to undefined behaviour when the
pointer does not actually point to the desired</p>
<p>type.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 482</p>
<p><span id="struct_Base" class="anchor"></span>struct Base {};</p>
<p>struct Derived : Base {};</p>
<p>Derived d;</p>
<p>Base* p1 = &amp;d;</p>
<p>Derived* p2 = p1; // error; cast required</p>
<p><del>Derived* p3 = static_cast</del>(p1); // OK; p2 now points to
Derived object Base b;</p>
<p>Base* p4 = &amp;b;</p>
<p><del>Derived* p5 = static_cast</del>(p4); // undefined behaviour
since p4 does not</p>
<p>// point to a Derived object</p>
<p>Likewise, a reference to base class can be converted to a reference
to derived class using <del>static_cast</del>.</p>
<p>struct Base {};</p>
<p>struct Derived : Base {};</p>
<p>Derived d;</p>
<p>Base&amp; r1 = d;</p>
<p>Derived&amp; r2 = r1; // error; cast required</p>
<p><del>Derived&amp; r3 = static_cast</del>(r1); // OK; r3 now refers to
Derived object</p>
<p>If the source type is polymorphic, <del>dynamic_cast</del> can be
used to perform a base to derived conversion. It performs a run-time
check and failure is recoverable instead of producing undefined
behaviour. In the pointer case, a null</p>
<p>pointer is returned upon failure. In the reference case, an exception
is thrown upon failure of type <del>std::bad_cast</del></p>
<p>(or a class derived from <del>std::bad_cast</del>).</p>
<p>struct Base { virtual ~Base(); }; // Base is polymorphic struct
Derived : Base {};</p>
<p>Base* b1 = new Derived;</p>
<p><del>Derived* d1 = dynamic_cast</del>(b1); // OK; d1 points to
Derived object Base* b2 = new Base;</p>
<p><del>Derived* d2 = dynamic_cast</del>(b2); // d2 is a null
pointer</p>
<p>Section 91.4: Conversion between pointer and integer</p>
<p>An object pointer (including <del>void*</del>) or function pointer
can be converted to an integer type using <del>reinterpret_cast</del> .
This will only compile if the destination type is long enough. The
result is implementation-</p>
<p>defined and typically yields the numeric address of the byte in
memory that the pointer pointers to.</p>
<p>Typically, <del>long</del> or <del>unsigned long</del> is long enough
to hold any pointer value, but this is not guaranteed by the</p>
<p>standard.</p>
<p>Version ≥ C++11</p>
<p>If the types <del>std::intptr_t</del> and <del>std::uintptr_t</del>
exist, they are guaranteed to be long enough to hold a <del>void*</del>
(and hence any pointer to object type). However, they are not guaranteed
to be long enough to hold a function pointer.</p>
<p>Similarly, <del>reinterpret_cast</del> can be used to convert an
integer type into a pointer type. Again the result is
implementation-defined, but a pointer value is guaranteed to be
unchanged by a round trip through an integer</p>
<p>type. The standard does not guarantee that the value zero is
converted to a null pointer.</p>
<p>void register_callback(void (*fp)(void*), void* arg); // probably a C
API void my_callback(void* x) {</p>
<p>std::cout &lt;&lt; "the value is: " &lt;&lt;
reinterpret_cast<del>(x); // will probably compile }</del></p>
<p>long x;</p>
<p>std::cin &gt;&gt; x;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 483</p>
<p><span id="register_callback_my_callback"
class="anchor"></span>register_callback(my_callback,</p>
<p><del>reinterpret_cast</del>(x)); // hopefully this doesn't lose
information...</p>
<p>Section 91.5: Conversion by explicit constructor or explicit</p>
<p>conversion function</p>
<p>A conversion that involves calling an explicit constructor or
conversion function can't be done implicitly. We can request that the
conversion be done explicitly using <del>static_cast</del>. The meaning
is the same as that of a direct</p>
<p>initialization, except that the result is a temporary.</p>
<p>class C {</p>
<p>std::unique_ptr <del>p;</del></p>
<p>public:</p>
<p>explicit C(int* p) : p(p) {}</p>
<p>};</p>
<p>void f(C c);</p>
<p>void g(int* p) {</p>
<p>f(p); // error: C::C(int*) is explicit</p>
<p>f(static_cast<del>(p)); // ok</del></p>
<p>f(C(p)); // equivalent to previous line</p>
<p>C c(p); f(c); // error: C is not copyable</p>
<p>}</p>
<p>Section 91.6: Implicit conversion</p>
<p>static_cast can perform any implicit conversion. This use of
<del>static_cast</del> can occasionally be useful, such as in the
following examples:</p>
<p>When passing arguments to an ellipsis, the "expected" argument type
is not statically known, so no implicit conversion will occur.</p>
<p>const double x = 3.14;</p>
<p>printf("%d<strong><del>\n</del></strong>", static_cast<del>(x)); //
prints 3</del></p>
<p>// printf("%d\n", x); // undefined behaviour; printf is expecting an
int here // alternative:</p>
<p>// const int y = x; printf("%d\n", y);</p>
<p>Without the explicit type conversion, a <del>double</del> object
would be passed to the ellipsis, and undefined behaviour would
occur.</p>
<p>A derived class assignment operator can call a base class assignment
operator like so:</p>
<p>struct Base { <del>/* ... */</del> };</p>
<p>struct Derived : Base {</p>
<p>Derived&amp; operator=(const Derived&amp; other) {</p>
<p><del>static_cast</del>(*this) = other;</p>
<p>// alternative:</p>
<p>// Base&amp; this_base_ref = *this; this_base_ref = other;</p>
<p>}</p>
<p>};</p>
<p>Section 91.7: Enum conversions</p>
<p><del>static_cast</del> can convert from an integer or floating point
type to an enumeration type (whether scoped or</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 484</p>
<p>unscoped), and vice versa. It can also convert between enumeration
types.</p>
<p>The conversion from an unscoped enumeration type to an arithmetic
type is an implicit conversion; it is</p>
<p>possible, but not necessary, to use <del>static_cast</del>.</p>
<p>Version ≥ C++11</p>
<p>When a scoped enumeration type is converted to an arithmetic
type:</p>
<p>If the enum's value can be represented exactly in the destination
type, the result is that value.</p>
<p>Otherwise, if the destination type is an integer type, the result is
unspecified.</p>
<p>Otherwise, if the destination type is a floating point type, the
result is the same as that of converting to the underlying type and then
to the floating point type.</p>
<p>Example:</p>
<p>enum class Format {</p>
<p>TEXT = 0,</p>
<p>PDF = 1000,</p>
<p>OTHER = 2000,</p>
<p>};</p>
<p>Format f = Format::PDF;</p>
<p>int a = f; // error</p>
<p><del>int b = static_cast</del>(f); // ok; b is 1000</p>
<p><del>char c = static_cast</del>(f); // unspecified, if 1000 doesn't
fit into char double d = static_cast(f); // d is 1000.0... probably</p>
<p>When an integer or enumeration type is converted to an enumeration
type:</p>
<p>If the original value is within the destination enum's range, the
result is that value. Note that this value</p>
<p>might be unequal to all enumerators.</p>
<p>Otherwise, the result is unspecified (&lt;= C++14) or undefined
(&gt;= C++17).</p>
<p>Example:</p>
<p>enum Scale {</p>
<p>SINGLE = 1,</p>
<p>DOUBLE = 2,</p>
<p>QUAD = 4</p>
<p>};</p>
<p>Scale s1 = 1; // error</p>
<p>Scale s2 = static_cast<del>(2); // s2 is DOUBLE</del></p>
<p><del>Scale s3 = static_cast</del>(3); // s3 has value 3, and is not
equal to any enumerator Scale s9 = static_cast(9); // unspecified value
in C++14; UB in C++17</p>
<p>Version ≥ C++11</p>
<p>When a floating point type is converted to an enumeration type, the
result is the same as converting to the enum's underlying type and then
to the enum type.</p>
<p>enum Direction {</p>
<p>UP = 0,</p>
<p>LEFT = 1,</p>
<p>DOWN = 2,</p>
<p>RIGHT = 3,</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 485</p>
<p><span id="Direction_d___static_cast_3_14"
class="anchor"></span>Direction d = static_cast<del>(3.14); // d is
RIGHT</del></p>
<p>Section 91.8: Derived to base conversion for pointers to</p>
<p>members</p>
<p>A pointer to member of derived class can be converted to a pointer to
member of base class using <del>static_cast</del>.</p>
<p>The types pointed to must match.</p>
<p>If the operand is a null pointer to member value, the result is also
a null pointer to member value.</p>
<p>Otherwise, the conversion is only valid if the member pointed to by
the operand actually exists in the destination</p>
<p>class, or if the destination class is a base or derived class of the
class containing the member pointed to by the operand.
<del>static_cast</del> does not check for validity. If the conversion is
not valid, the behaviour is undefined.</p>
<p>struct A {};</p>
<p>struct B { int x; };</p>
<p>struct C : A, B { int y; double z; };</p>
<p>int B::*p1 = &amp;B::x;</p>
<p>int C::*p2 = p1; // ok; implicit conversion</p>
<p>int B::*p3 = p2; // error</p>
<p><del>int B::*p4 = static_cast</del>(p2); // ok; p4 is equal to p1 int
A::*p5 = static_cast(p2); // undefined; p2 points to x, which is a
member</p>
<p>// of the unrelated class B</p>
<p>double C::*p6 = &amp;C::z;</p>
<p><del>double A::*p7 = static_cast</del>(p6); // ok, even though A
doesn't contain z int A::*p8 = static_cast(p6); // error: types don't
match</p>
<p>Section 91.9: void* to T*</p>
<p>In C++, <del>void*</del> cannot be implicitly converted to
<del>T*</del> where <del>T</del> is an object type. Instead,
<del>static_cast</del> should be used to</p>
<p>perform the conversion explicitly. If the operand actually points to
a <del>T</del> object, the result points to that object.</p>
<p>Otherwise, the result is unspecified.</p>
<p>Version ≥ C++11</p>
<p>Even if the operand does not point to a <del>T</del> object, as long
as the operand points to a byte whose address is properly aligned for
the type <del>T</del>, the result of the conversion points to the same
byte.</p>
<p>// allocating an array of 100 ints, the hard way</p>
<p><del>int* a = malloc(100*sizeof(*a)); // error; malloc returns void*
int* a = static_cast</del>(malloc(100*sizeof(*a))); // ok // int* a =
new int[100]; // no cast needed // std::vector a(100); // better</p>
<p>const char c = '!';</p>
<p>const void* p1 = &amp;c;</p>
<p>const char* p2 = p1; // error</p>
<p><del>const char* p3 = static_cast</del>(p1); // ok; p3 points to c
const int* p4 = static_cast(p1); // unspecified in C++03;</p>
<p>// possibly unspecified in C++11 if</p>
<p>// alignof(int) &gt; alignof(char)</p>
<p><del>char* p5 = static_cast</del>(p1); // error: casting away
constness</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 486</p>
<p><span id="Section_91_10__Type_punning_conv"
class="anchor"></span>Section 91.10: Type punning conversion</p>
<p>A pointer (resp. reference) to an object type can be converted to a
pointer (resp. reference) to any other object type</p>
<p>using <del>reinterpret_cast</del>. This does not call any
constructors or conversion functions.</p>
<p>int x = 42;</p>
<p><del>char* p = static_cast</del>(&amp;x); // error: static_cast
cannot perform this conversion char* p = reinterpret_cast(&amp;x); //
OK</p>
<p>*p = 'z'; // maybe this modifies x (see below)</p>
<p>Version ≥ C++11</p>
<p>The result of <del>reinterpret_cast</del> represents the same address
as the operand, provided that the address is</p>
<p>appropriately aligned for the destination type. Otherwise, the result
is unspecified.</p>
<p>int x = 42;</p>
<p>char&amp; r = reinterpret_cast<del>(x);</del></p>
<p>const void* px = &amp;x;</p>
<p>const void* pr = &amp;r;</p>
<p>assert(px == pr); // should never fire</p>
<p>Version &lt; C++11</p>
<p>The result of <del>reinterpret_cast</del> is unspecified, except that
a pointer (resp. reference) will survive a round trip from</p>
<p>the source type to the destination type and back, as long as the
destination type's alignment requirement is not</p>
<p>stricter than that of the source type.</p>
<p>int x = 123;</p>
<p><del>unsigned int&amp; r1 = reinterpret_cast</del>(x); int&amp; r2 =
reinterpret_cast(r1);</p>
<p>r2 = 456; // sets x to 456</p>
<p>On most implementations, <del>reinterpret_cast</del> does not change
the address, but this requirement was not standardized until C++11.</p>
<p><del>reinterpret_cast</del> can also be used to convert from one
pointer-to-data-member type to another, or one
pointer-to-member-function type to another.</p>
<p>Use of <del>reinterpret_cast</del> is considered dangerous because
reading or writing through a pointer or reference</p>
<p>obtained using <del>reinterpret_cast</del> may trigger undefined
behaviour when the source and destination types are</p>
<p>unrelated.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 487</p>
<p><span id="Chapter_92__Unnamed_types_1" class="anchor"></span>Chapter
92: Unnamed types</p>
<p>Section 92.1: Unnamed classes</p>
<p>Unlike a named class or struct, unnamed classes and structs must be
instantiated where they are defined, and cannot have constructors or
destructors.</p>
<p>struct {</p>
<p>int foo;</p>
<p>double bar;</p>
<p>} foobar;</p>
<p>foobar.foo = 5;</p>
<p>foobar.bar = 4.0;</p>
<p>class {</p>
<p>int baz;</p>
<p>public:</p>
<p>int buzz;</p>
<p>void setBaz(int v) {</p>
<p>baz = v;</p>
<p>}</p>
<p>} barbar;</p>
<p>barbar.setBaz(15);</p>
<p>barbar.buzz = 2;</p>
<p>Section 92.2: As a type alias</p>
<p>Unnamed class types may also be used when creating type aliases, i.e.
via <del>typedef</del> and <del>using</del>:</p>
<p>Version &lt; C++11</p>
<p>using vec2d = struct {</p>
<p>float x;</p>
<p>float y;</p>
<p>};</p>
<p>typedef struct {</p>
<p>float x;</p>
<p>float y;</p>
<p>} vec2d;</p>
<p>vec2d pt;</p>
<p>pt.x = 4.f;</p>
<p>pt.y = 3.f;</p>
<p>Section 92.3: Anonymous members</p>
<p>As a non-standard extension to C++, common compilers allow the use of
classes as anonymous members.</p>
<p>struct Example {</p>
<p>struct {</p>
<p>int inner_b;</p>
<p>};</p>
<p>int outer_b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 488</p>
<p><span id="__The_anonymous_struct_s_members"
class="anchor"></span>//The anonymous struct's members are accessed as
if members of the parent struct</p>
<p>Example() : inner_b(2), outer_b(4) {</p>
<p>inner_b = outer_b + 2;</p>
<p>}</p>
<p>};</p>
<p>Example ex;</p>
<p>//The same holds true for external code referencing the struct
ex.inner_b-= ex.outer_b;</p>
<p>Section 92.4: Anonymous Union</p>
<p>Member names of an anonymous union belong to the scope of the union
declaration an must be distinct to all</p>
<p>other names of this scope. The example here has the same construction
as example Anonymous Members using "struct" but is standard conform.</p>
<p>struct Sample {</p>
<p>union {</p>
<p>int a;</p>
<p>int b;</p>
<p>};</p>
<p>int c;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>Sample sa;</p>
<p>sa.a =3;</p>
<p>sa.b =4;</p>
<p>sa.c =5;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 489</p>
<p><span id="Chapter_93__Type_Traits_1" class="anchor"></span>Chapter
93: Type Traits</p>
<p>Section 93.1: Type Properties</p>
<p>Version ≥ C++11</p>
<p>Type properties compare the modifiers that can be placed upon
different variables. The usefulness of these type</p>
<p>traits is not always obvious.</p>
<p><strong>Note:</strong> The example below would only offer an
improvement on a non-optimizing compiler. It is a simple a proof of</p>
<p>concept, rather than complex example.</p>
<p>e.g. Fast divide by four.</p>
<p>template</p>
<p>inline T FastDivideByFour(cont T &amp;var) {</p>
<p>// Will give an error if the inputted type is not an unsigned
integral type. static_assert(std::is_unsigned<del>::value &amp;&amp;
std::is_integral::value,</del></p>
<p>"This function is only designed for unsigned integral types.");</p>
<p>return (var &gt;&gt; 2);</p>
<p>}</p>
<p>Is Constant:</p>
<p>This will evaluate as true when type is constant.</p>
<p><del>std::cout &lt;&lt; std::is_const</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_const::value &lt;&lt; "<strong>\n</strong>"; // Prints
false.</p>
<p>Is Volatile:</p>
<p>This will evaluate as true when the type is volatile.</p>
<p><del>std::cout &lt;&lt; std::is_volatile</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_const::value &lt;&lt; "<strong>\n</strong>"; // Prints
false.</p>
<p>Is signed:</p>
<p>This will evaluate as true for all signed types.</p>
<p><del>std::cout &lt;&lt; std::is_signed</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_signed::value &lt;&lt; "<strong>\n</strong>"; // Prints true.
std::cout &lt;&lt; std::is_signed::value &lt;&lt; "<strong>\n</strong>";
// Prints false. std::cout &lt;&lt; std::is_signed::value &lt;&lt;
"<strong>\n</strong>"; // Prints false.</p>
<p>Is Unsigned:</p>
<p>Will evaluate as true for all unsigned types.</p>
<p><del>std::cout &lt;&lt; std::is_unsigned</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_signed::value &lt;&lt; "<strong>\n</strong>"; // Prints true.
std::cout &lt;&lt; std::is_unsigned::value &lt;&lt;
"<strong>\n</strong>"; // Prints false. std::cout &lt;&lt;
std::is_signed::value &lt;&lt; "<strong>\n</strong>"; // Prints
false.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 490</p>
<p><span id="Section_93_2__Standard_type_trai"
class="anchor"></span>Section 93.2: Standard type traits</p>
<p>Version ≥ C++11</p>
<p>The <del>type_traits</del> header contains a set of template classes
and helpers to transform and check properties of types</p>
<p>at compile-time.</p>
<p>These traits are typically used in templates to check for user
errors, support generic programming, and allow for</p>
<p>optimizations.</p>
<p>Most type traits are used to check if a type fulfils some criteria.
These have the following form:</p>
<p><del>template</del> struct is_foo;</p>
<p>If the template class is instantiated with a type which fulfils some
criteria <del>foo</del>, then <del>is_foo</del> inherits from
std::integral_constant (a.k.a. std::true_type), otherwise it inherits
from</p>
<p>std::integral_constant (a.k.a. <del>std::false_type</del>). This
gives the trait the following members:</p>
<p>Constants</p>
<p>static constexpr bool value</p>
<p>true if <del>T</del> fulfils the criteria <del>foo</del>,
<del>false</del> otherwise</p>
<p>Functions</p>
<p>operator bool</p>
<p>Returns <del>value</del></p>
<p>Version ≥ C++14</p>
<p>bool operator()</p>
<p>Returns <del>value</del></p>
<p>Types</p>
<p>Name Definition</p>
<p>value_type bool</p>
<p>type std::integral_constant</p>
<p>The trait can then be used in constructs such as
<del>static_assert</del> or <del>std::enable_if</del>. An example with
<del>std::is_pointer</del>:</p>
<p>template</p>
<p>void i_require_a_pointer (T t) {</p>
<p><del>static_assert(std::is_pointer</del>::value, "T must be a pointer
type");</p>
<p>}</p>
<p>//Overload for when T is not a pointer type</p>
<p>template</p>
<p>typename std::enable_if::value&gt;::type
does_something_special_with_pointer (T t) {</p>
<p>//Do something boring</p>
<p>}</p>
<p>//Overload for when T is a pointer type</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 491</p>
<p><span id="typename_std__enable_if__value"
class="anchor"></span><del>typename
std::enable_if</del>::value&gt;::type
does_something_special_with_pointer (T t) {</p>
<p>//Do something special</p>
<p>}</p>
<p>There are also various traits which transform types, such as
<del>std::add_pointer</del> and <del>std::underlying_type</del>.
These</p>
<p>traits generally expose a single <del>type</del> member type which
contains the transformed type. For example, std::add_pointer::type is
<del>int*</del>.</p>
<p>Section 93.3: Type relations with std::is_same&lt;T, T&gt;</p>
<p>Version ≥ C++11</p>
<p>The <del>std::is_same</del> type relation is used to compare two
types. It will evaluate as boolean, true if the types</p>
<p>are the same and false if otherwise.</p>
<p>e.g.</p>
<p>// Prints true on most x86 and x86_64 compilers.</p>
<p><del>std::cout &lt;&lt; std::is_same</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints false on all compilers.</p>
<p><del>std::cout &lt;&lt; std::is_same</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints false on all compilers.</p>
<p>std::cout &lt;&lt; std::is_same<del>::value &lt;&lt;
"<strong>\n</strong>";</del></p>
<p>The <del>std::is_same</del> type relation will also work regardless
of typedefs. This is actually demonstrated in the first</p>
<p>example when comparing <del>int == int32_t</del> however this is not
entirely clear.</p>
<p>e.g.</p>
<p>// Prints true on all compilers.</p>
<p>typedef int MyType</p>
<p>std::cout &lt;&lt; std::is_same<del>::value &lt;&lt;
"<strong>\n</strong>";</del></p>
<p>Using std::is_same to warn when improperly using a templated class or
function.</p>
<p>When combined with a static assert the <del>std::is_same</del>
template can be valuable tool in enforcing proper usage of</p>
<p>templated classes and functions.</p>
<p>e.g. A function that only allows input from an <del>int</del> and a
choice of two structs.</p>
<p>#include</p>
<p>struct foo {</p>
<p>int member;</p>
<p>// Other variables</p>
<p>};</p>
<p>struct bar {</p>
<p>char member;</p>
<p>};</p>
<p>template</p>
<p>int AddStructMember(T var1, int var2) {</p>
<p>// If type T != foo || T != bar then show error message.
static_assert(std::is_same<del>::value ||</del></p>
<p>std::is_same<del>::value,</del></p>
<p>"This function does not support the specified type.");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 492</p>
<p><span id="return_var1_member___var2" class="anchor"></span>return
var1.member + var2;</p>
<p>}</p>
<p>Section 93.4: Fundamental type traits</p>
<p>Version ≥ C++11</p>
<p>There are a number of different type traits that compare more general
types.</p>
<p>Is Integral:</p>
<p>Evaluates as true for all integer types <del>int</del>,
<del>char</del>, <del>long</del>, <del>unsigned int</del> etc.</p>
<p><del>std::cout &lt;&lt; std::is_integral</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_integral::value &lt;&lt; "<strong>\n</strong>"; // Prints true.
std::cout &lt;&lt; std::is_integral::value &lt;&lt;
"<strong>\n</strong>"; // Prints false.</p>
<p>Is Floating Point:</p>
<p>Evaluates as true for all floating point types.
<del>float</del>,<del>double</del>, <del>long double</del> etc.</p>
<p><del>std::cout &lt;&lt; std::is_floating_point</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_floating_point::value &lt;&lt; "<strong>\n</strong>"; // Prints
true. std::cout &lt;&lt; std::is_floating_point::value &lt;&lt;
"<strong>\n</strong>"; // Prints false.</p>
<p>Is Enum:</p>
<p>Evaluates as true for all enumerated types, including <del>enum
class</del>.</p>
<p>enum fruit {apple, pair, banana};</p>
<p>enum class vegetable {carrot, spinach, leek};</p>
<p><del>std::cout &lt;&lt; std::is_enum</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_enum::value &lt;&lt; "<strong>\n</strong>"; // Prints true.
std::cout &lt;&lt; std::is_enum::value &lt;&lt; "<strong>\n</strong>";
// Prints false.</p>
<p>Is Pointer:</p>
<p>Evaluates as true for all pointers.</p>
<p><del>std::cout &lt;&lt; std::is_pointer</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. typedef int* MyPTR;</p>
<p><del>std::cout &lt;&lt; std::is_pointer</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_pointer::value &lt;&lt; "<strong>\n</strong>"; // Prints
false.</p>
<p>Is Class:</p>
<p>Evaluates as true for all classes and struct, with the exception of
<del>enum class</del>.</p>
<p>struct FOO {int x, y;};</p>
<p>class BAR {</p>
<p>public:</p>
<p>int x, y;</p>
<p>};</p>
<p>enum class fruit {apple, pair, banana};</p>
<p><del>std::cout &lt;&lt; std::is_class</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints true. std::cout &lt;&lt;
std::is_class::value &lt;&lt; "<strong>\n</strong>"; // Prints true.
std::cout &lt;&lt; std::is_class::value &lt;&lt; "<strong>\n</strong>";
// Prints false.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 493</p>
<p><del>std::cout &lt;&lt; std::is_class</del>::value &lt;&lt;
"<strong>\n</strong>"; // Prints false.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 494</p>
<p><span id="Chapter_94__Return_Type_Covarian_1"
class="anchor"></span>Chapter 94: Return Type Covariance</p>
<p>Section 94.1: Covariant result version of the base example,</p>
<p>static type checking</p>
<p>// 2. Covariant result version of the base example, static type
checking.</p>
<p>class Top</p>
<p>{</p>
<p>public:</p>
<p>virtual Top* clone() const = 0;</p>
<p>virtual ~Top() = default; // Necessary for `delete` via Top*.</p>
<p>};</p>
<p>class D : public Top</p>
<p>{</p>
<p>public:</p>
<p>D* <del>/*</del> ← <del>Covariant return */</del> clone() const
override</p>
<p>{ return new D( *this ); }</p>
<p>};</p>
<p>class DD : public D</p>
<p>{</p>
<p>private:</p>
<p>int answer_ = 42;</p>
<p>public:</p>
<p>int answer() const</p>
<p>{ return answer_;}</p>
<p>DD* <del>/*</del> ← <del>Covariant return */</del> clone() const
override</p>
<p>{ return new DD( *this ); }</p>
<p>};</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main()</p>
<p>{</p>
<p>DD* p1 = new DD();</p>
<p>DD* p2 = p1-&gt;clone();</p>
<p>// Correct dynamic type DD for *p2 is guaranteed by the static type
checking.</p>
<p>cout &lt;&lt; p2-&gt;answer() &lt;&lt; endl; // "42"</p>
<p>delete p2;</p>
<p>delete p1;</p>
<p>}</p>
<p>Section 94.2: Covariant smart pointer result (automated</p>
<p>cleanup)</p>
<p>// 3. Covariant smart pointer result (automated cleanup).</p>
<p>#include</p>
<p>using std::unique_ptr;</p>
<p>template&lt; class Type &gt;</p>
<p>auto up( Type* p ) { return unique_ptr<del>( p ); }</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 495</p>
<p>class Top</p>
<p>{</p>
<p>private:</p>
<p>virtual Top* virtual_clone() const = 0;</p>
<p>public:</p>
<p><del>unique_ptr</del> clone() const</p>
<p>{ return up( virtual_clone() ); }</p>
<p>virtual ~Top() = default; // Necessary for `delete` via Top*.</p>
<p>};</p>
<p>class D : public Top</p>
<p>{</p>
<p>private:</p>
<p>D* <del>/*</del> ← <del>Covariant return */</del> virtual_clone()
const override</p>
<p>{ return new D( *this ); }</p>
<p>public:</p>
<p><del>unique_ptr</del> /* ← Apparent covariant return */ clone()
const</p>
<p>{ return up( virtual_clone() ); }</p>
<p>};</p>
<p>class DD : public D</p>
<p>{</p>
<p>private:</p>
<p>int answer_ = 42;</p>
<p>DD* <del>/*</del> ← <del>Covariant return */</del> virtual_clone()
const override</p>
<p>{ return new DD( *this ); }</p>
<p>public:</p>
<p>int answer() const</p>
<p>{ return answer_;}</p>
<p>unique_ptr</p>
<p>/* ← Apparent covariant return */ clone() const</p>
<p>{ return up( virtual_clone() ); }</p>
<p>};</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main()</p>
<p>{</p>
<p>auto p1 = unique_ptr</p>
<p>(new DD());</p>
<p>auto p2 = p1-&gt;clone();</p>
<p>// Correct dynamic type DD for *p2 is guaranteed by the static type
checking.</p>
<p>cout &lt;&lt; p2-&gt;answer() &lt;&lt; endl; // "42"</p>
<p>// Cleanup is automated via unique_ptr.</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 496</p>
<p><span id="Chapter_95__Layout_of_object_typ_1"
class="anchor"></span>Chapter 95: Layout of object types</p>
<p>Section 95.1: Class types</p>
<p>By "class", we mean a type that was defined using the
<del>class</del> or <del>struct</del> keyword (but not <del>enum
struct</del> or <del>enum class</del>).</p>
<p>Even an empty class still occupies at least one byte of storage; it
will therefore consist purely of padding. This ensures that if
<del>p</del> points to an object of an empty class, then <del>p +
1</del> is a distinct address and points to a distinct</p>
<p><a href="http://en.cppreference.com/w/cpp/language/ebo">object.
However, it is possible for an empty class to have a size of 0 when used
as a base class. See empty</a></p>
<p><a href="http://en.cppreference.com/w/cpp/language/ebo">base
optimisation</a>.</p>
<p>class Empty_1 {}; // sizeof(Empty_1) == 1</p>
<p>class Empty_2 {}; // sizeof(Empty_2) == 1</p>
<p>class Derived : Empty_1 {}; // sizeof(Derived) == 1 class
DoubleDerived : Empty_1, Empty_2 {}; // sizeof(DoubleDerived) == 1 class
Holder { Empty_1 e; }; // sizeof(Holder) == 1 class DoubleHolder {
Empty_1 e1; Empty_2 e2; }; // sizeof(DoubleHolder) == 2 class
DerivedHolder : Empty_1 { Empty_1 e; }; // sizeof(DerivedHolder) ==
2</p>
<p>The object representation of a class type contains the object
representations of the base class and non-static</p>
<p>member types. Therefore, for example, in the following class:</p>
<p>struct S {</p>
<p>int x;</p>
<p>char* y;</p>
<p>};</p>
<p>there is a consecutive sequence of <del>sizeof(int)</del> bytes
within an <del>S</del> object, called a subobject, that contain the</p>
<p>value of <del>x</del>, and another subobject with
<del>sizeof(char*)</del> bytes that contains the value of <del>y</del>.
The two cannot be interleaved.</p>
<p>If a class type has members and/or base classes with types <del>t1,
t2,...tN</del>, the size must be at least</p>
<p><del>sizeof(t1) + sizeof(t2) + ... + sizeof(tN)</del> given the
preceding points. However, depending on the alignment requirements of
the members and base classes, the compiler may be forced to insert
padding</p>
<p>between subobjects, or at the beginning or end of the complete
object.</p>
<p>struct AnInt { int i; };</p>
<p>// sizeof(AnInt) == sizeof(int)</p>
<p>// Assuming a typical 32- or 64-bit system, sizeof(AnInt) == 4
(4).</p>
<p>struct TwoInts { int i, j; };</p>
<p>// sizeof(TwoInts) &gt;= 2 * sizeof(int)</p>
<p>// Assuming a typical 32- or 64-bit system, sizeof(TwoInts) == 8 (4 +
4).</p>
<p>struct IntAndChar { int i; char c; };</p>
<p>// sizeof(IntAndChar) &gt;= sizeof(int) + sizeof(char) // Assuming a
typical 32- or 64-bit system, sizeof(IntAndChar) == 8 (4 + 1 +
padding).</p>
<p>struct AnIntDerived : AnInt { long long l; };</p>
<p>// sizeof(AnIntDerived) &gt;= sizeof(AnInt) + sizeof(long long) //
Assuming a typical 32- or 64-bit system, sizeof(AnIntDerived) == 16 (4 +
padding + 8).</p>
<p>If padding is inserted in an object due to alignment requirements,
the size will be greater than the sum of the</p>
<p>sizes of the members and base classes. With <del>n</del>-byte
alignment, size will typically be the smallest multiple of <del>n</del>
which is larger than the size of all members &amp; base classes. Each
member <del>memN</del> will typically be placed at an</p>
<p>address which is a multiple of <del>alignof(memN)</del>, and
<del>n</del> will typically be the largest <del>alignof</del> out of all
members'</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 497</p>
<p>alignof s. Due to this, if a member with a smaller <del>alignof</del>
is followed by a member with a larger <del>alignof</del>, there is a
possibility that the latter member will not be aligned properly if
placed immediately after the</p>
<p>former. In this case, padding (also known as an alignment member )
will be placed between the two members,</p>
<p>such that the latter member can have its desired alignment.
Conversely, if a member with a larger <del>alignof</del> is followed by
a member with a smaller <del>alignof</del>, no padding will usually be
necessary. This process is also</p>
<p>known as "packing".</p>
<p>Due to classes typically sharing the <del>alignof</del> of their
member with the largest <del>alignof</del>, classes will typically
be</p>
<p>aligned to the <del>alignof</del> of the largest built-in type they
directly or indirectly contain.</p>
<p>// Assume sizeof(short) == 2, sizeof(int) == 4, and sizeof(long long)
== 8. // Assume 4-byte alignment is specified to the compiler. struct
Char { char c; };</p>
<p>// sizeof(Char) == 1 (sizeof(char))</p>
<p>struct Int { int i; };</p>
<p>// sizeof(Int) == 4 (sizeof(int))</p>
<p>struct CharInt { char c; int i; };</p>
<p>// sizeof(CharInt) == 8 (1 (char) + 3 (padding) + 4 (int))</p>
<p>struct ShortIntCharInt { short s; int i; char c; int j; };</p>
<p>// sizeof(ShortIntCharInt) == 16 (2 (short) + 2 (padding) + 4 (int) +
1 (char) + // 3 (padding) + 4 (int))</p>
<p>struct ShortIntCharCharInt { short s; int i; char c; char d; int j;
};</p>
<p>// sizeof(ShortIntCharCharInt) == 16 (2 (short) + 2 (padding) + 4
(int) + 1 (char) + // 1 (char) + 2 (padding) + 4 (int))</p>
<p>struct ShortCharShortInt { short s; char c; short t; int i; };</p>
<p>// sizeof(ShortCharShortInt) == 12 (2 (short) + 1 (char) + 1
(padding) + 2 (short) + // 2 (padding) + 4 (int))</p>
<p>struct IntLLInt { int i; long long l; int j; };</p>
<p>// sizeof(IntLLInt) == 16 (4 (int) + 8 (long long) + 4 (int)) // If
packing isn't explicitly specified, most compilers will pack this as //
8-byte alignment, such that:</p>
<p>// sizeof(IntLLInt) == 24 (4 (int) + 4 (padding) + 8 (long long) + //
4 (int) + 4 (padding))</p>
<p>// Assume sizeof(bool) == 1, sizeof(ShortIntCharInt) == 16, and
sizeof(IntLLInt) == 24. // Assume default alignment:
alignof(ShortIntCharInt) == 4, alignof(IntLLInt) == 8. struct
ShortChar3ArrShortInt {</p>
<p>short s;</p>
<p>char c3[3];</p>
<p>short t;</p>
<p>int i;</p>
<p>};</p>
<p>// ShortChar3ArrShortInt has 4-byte alignment: alignof(int) &gt;=
alignof(char) &amp;&amp; // alignof(int) &gt;= alignof(short) //
sizeof(ShortChar3ArrShortInt) == 12 (2 (short) + 3 (char[3]) + 1
(padding) + // 2 (short) + 4 (int)) // Note that t is placed at
alignment of 2, not 4. alignof(short) == 2.</p>
<p>struct Large_1 {</p>
<p>ShortIntCharInt sici;</p>
<p>bool b;</p>
<p>ShortIntCharInt tjdj;</p>
<p>};</p>
<p>// Large_1 has 4-byte alignment.</p>
<p>// alignof(ShortIntCharInt) == alignof(int) == 4</p>
<p>// alignof(b) == 1</p>
<p>// Therefore, alignof(Large_1) == 4.</p>
<p>// sizeof(Large_1) == 36 (16 (ShortIntCharInt) + 1 (bool) + 3
(padding) + // 16 (ShortIntCharInt))</p>
<p>struct Large_2 {</p>
<p>IntLLInt illi;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 498</p>
<p><span id="float_f" class="anchor"></span>float f;</p>
<p>IntLLInt jmmj;</p>
<p>};</p>
<p>// Large_2 has 8-byte alignment.</p>
<p>// alignof(IntLLInt) == alignof(long long) == 8</p>
<p>// alignof(float) == 4</p>
<p>// Therefore, alignof(Large_2) == 8.</p>
<p>// sizeof(Large_2) == 56 (24 (IntLLInt) + 4 (float) + 4 (padding) +
24 (IntLLInt))</p>
<p>Version ≥ C++11</p>
<p>If strict alignment is forced with <del>alignas</del>, padding will
be used to force the type to meet the specified alignment, even when it
would otherwise be smaller. For example, with the definition below,
<del>Chars&lt;5&gt;</del> will</p>
<p>have three (or possibly more) padding bytes inserted at the end so
that its total size is 8. It is not possible for a class with an
alignment of 4 to have a size of 5 because it would be impossible to
make an array of that</p>
<p>class, so the size must be "rounded up" to a multiple of 4 by
inserting padding bytes.</p>
<p>// This type shall always be aligned to a multiple of 4. Padding
shall be inserted as // needed.</p>
<p>// Chars&lt;1&gt;..Chars&lt;4&gt; are 4 bytes,
Chars&lt;5&gt;..Chars&lt;8&gt; are 8 bytes, etc. template</p>
<p>struct alignas(4) Chars { char arr[SZ]; };</p>
<p>static_assert(sizeof(Chars&lt;1&gt;) == sizeof(Chars&lt;4&gt;),
"Alignment is strict.<strong><del>\n</del></strong>");</p>
<p>If two non-static members of a class have the same access specifier,
then the one that comes later in declaration order is guaranteed to come
later in the object representation. But if two non-static members</p>
<p>have different access specifiers, their relative order within the
object is unspecified.</p>
<p>It is unspecified what order the base class subobjects appear in
within an object, whether they occur consecutively, and whether they
appear before, after, or between member subobjects.</p>
<p>Section 95.2: Arithmetic types</p>
<p>Narrow character types</p>
<p>The <del>unsigned char</del> type uses all bits to represent a binary
number. Therefore, for example, if <del>unsigned char</del> is 8 bits
long, then the 256 possible bit patterns of a <del>char</del> object
represent the 256 different values {0, 1, ..., 255}. The</p>
<p>number 42 is guaranteed to be represented by the bit pattern
<del>00101010</del>.</p>
<p>The <del>signed char</del> type has no padding bits, i.e., if
<del>signed char</del> is 8 bits long, then it has 8 bits of capacity
to</p>
<p>represent a number.</p>
<p>Note that these guarantees do not apply to types other than narrow
character types.</p>
<p>Integer types</p>
<p>The unsigned integer types use a pure binary system, but may contain
padding bits. For example, it is possible</p>
<p>(though unlikely) for <del>unsigned int</del> to be 64 bits long but
only be capable of storing integers between 0 and 232 - 1, inclusive.
The other 32 bits would be padding bits, which should not be written to
directly.</p>
<p>The signed integer types use a binary system with a sign bit and
possibly padding bits. Values that belong to the common range of a
signed integer type and the corresponding unsigned integer type have the
same</p>
<p>representation. For example, if the bit pattern
<del>0001010010101011</del> of an <del>unsigned short</del> object
represents the value</p>
<p>5291, then it also represents the value <del>5291</del> when
interpreted as a <del>short</del> object.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 499</p>
<p><span id="It_is_implementation_defined_whe" class="anchor"></span>It
is implementation-defined whether a two's complement, one's complement,
or sign-magnitude representation is used, since all three systems
satisfy the requirement in the previous paragraph.</p>
<p>Floating point types</p>
<p>The value representation of floating point types is
implementation-defined. Most commonly, the <del>float</del> and
<del>double</del> types conform to IEEE 754 and are 32 and 64 bits long
(so, for example, <del>float</del> would have 23 bits of precision
which</p>
<p>would follow 8 exponent bits and 1 sign bit). However, the standard
does not guarantee anything. Floating point</p>
<p>types often have "trap representations", which cause errors when they
are used in calculations.</p>
<p>Section 95.3: Arrays</p>
<p>An array type has no padding in between its elements. Therefore, an
array with element type <del>T</del> is just a sequence of <del>T</del>
objects laid out in memory, in order.</p>
<p>A multidimensional array is an array of arrays, and the above applies
recursively. For example, if we have the declaration</p>
<p>int a[5][3];</p>
<p>then <del>a</del> is an array of 5 arrays of 3 <del>int</del>s.
Therefore, <del>a[0]</del>, which consists of the three elements
<del>a[0][0]</del>, <del>a[0][1]</del>,</p>
<p>a[0][2], is laid out in memory before <del>a[1]</del>, which consists
of <del>a[1][0]</del>, <del>a[1][1]</del>, and <del>a[1][2]</del>. This
is called row major order.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 500</p>
<p><span id="Chapter_96__Type_Inference_1" class="anchor"></span>Chapter
96: Type Inference</p>
<p>This topic discusses about type inferencing that involves the keyword
<del>auto</del> type that is available from C++11.</p>
<p>Section 96.1: Data Type: Auto</p>
<p>This example shows the basic type inferences the compiler can
perform.</p>
<p>auto a = 1; // a = int</p>
<p>auto b = 2u; // b = unsigned int</p>
<p>auto c = &amp;a; // c = int*</p>
<p>const auto d = c; // d = const int*</p>
<p>const auto&amp; e = b; // e = const unsigned int&amp;</p>
<p>auto x = a + b // x = int, #compiler warning unsigned and signed</p>
<p>auto v = std::vector<del>; // v = std::vector</del></p>
<p>However, the auto keyword does not always perform the expected type
inference without additional hints for <del>&amp;</del> or</p>
<p><del>const or</del> constexpr</p>
<p>// y = unsigned int,</p>
<p>// note that y does not infer as const unsigned int&amp; // The
compiler would have generated a copy instead of a reference value to e
or b auto y = e;</p>
<p>Section 96.2: Lambda auto</p>
<p>The data type auto keyword is a convenient way for programmers to
declare lambda functions. It helps by shortening the amount of text
programmers need to type to declare a function pointer.</p>
<p>auto DoThis = [](int a, int b) { return a + b; };</p>
<p>// Do this is of type (int)(*DoThis)(int, int)</p>
<p>// else we would have to write this long</p>
<p>int(*pDoThis)(int, int)= [](int a, int b) { return a + b; };</p>
<p>auto c = Dothis(1, 2); // c = int</p>
<p>auto d = pDothis(1, 2); // d = int</p>
<p>// using 'auto' shortens the definition for lambda functions</p>
<p>By default, if the return type of lambda functions is not defined, it
will be automatically inferred from the return</p>
<p>expression types.</p>
<p>These 3 is basically the same thing</p>
<p>[](int a, int b)-&gt; int { return a + b; };</p>
<p>[](int a, int b)-&gt; auto { return a + b; };</p>
<p>[](int a, int b) { return a + b; };</p>
<p>Section 96.3: Loops and auto</p>
<p>This example shows how auto can be used to shorten type declaration
for for loops</p>
<p>std::map <del>Map;</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 501</p>
<p><del>for (auto pair : Map) // pair = std::pair</del> for (const auto
pair : Map) // pair = const std::pair for (const auto&amp; pair : Map)
// pair = const std::pair&amp; for (auto i = 0; i &lt; 1000; ++i) // i =
int</p>
<p>for (auto i = 0; i &lt; Map.size(); ++i) // Note that i = int and not
size_t for (auto i = Map.size(); i &gt; 0;--i) // i = size_t</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 502</p>
<p><span id="Chapter_97__Typedef_and_type_ali_1"
class="anchor"></span>Chapter 97: Typedef and type aliases</p>
<p>The <del>typedef</del> and (since C++11) <del>using</del> keywords
can be used to give a new name to an existing type.</p>
<p>Section 97.1: Basic typedef syntax</p>
<p>A <del>typedef</del> declaration has the same syntax as a variable or
function declaration, but it contains the word <del>typedef</del>.</p>
<p>The presence of <del>typedef</del> causes the declaration to declare
a type instead of a variable or function.</p>
<p>int T; // T has type int</p>
<p>typedef int T; // T is an alias for int</p>
<p>int A[100]; // A has type "array of 100 ints"</p>
<p>typedef int A[100]; // A is an alias for the type "array of 100
ints"</p>
<p>Once a type alias has been defined, it can be used interchangeably
with the original name of the type.</p>
<p>typedef int A[100];</p>
<p>// S is a struct containing an array of 100 ints</p>
<p>struct S {</p>
<p>A data;</p>
<p>};</p>
<p><del>typedef</del> never creates a distinct type. It only gives
another way of referring to an existing type.</p>
<p>struct S {</p>
<p>int f(int);</p>
<p>};</p>
<p>typedef int I;</p>
<p>// ok: defines int S::f(int)</p>
<p>I S::f(I x) { return x; }</p>
<p>Section 97.2: More complex uses of typedef</p>
<p>The rule that <del>typedef</del> declarations have the same syntax as
ordinary variable and function declarations can be used to read and
write more complex declarations.</p>
<p>void (*f)(int); // f has type "pointer to function of int returning
void" typedef void (*f)(int); // f is an alias for "pointer to function
of int returning void"</p>
<p>This is especially useful for constructs with confusing syntax, such
as pointers to non-static members.</p>
<p>void (Foo::*pmf)(int); // pmf has type "pointer to member function of
Foo taking int</p>
<p>// and returning void"</p>
<p>typedef void (Foo::*pmf)(int); // pmf is an alias for "pointer to
member function of Foo</p>
<p>// taking int and returning void"</p>
<p>It is hard to remember the syntax of the following function
declarations, even for experienced programmers:</p>
<p>void (Foo::*Foo::f(const char*))(int);</p>
<p>int (&amp;g())[100];</p>
<p><del>typedef</del> can be used to make them easier to read and
write:</p>
<p>typedef void (Foo::pmf)(int); // pmf is a pointer to member function
type</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 503</p>
<p><span id="pmf_Foo__f_const_char" class="anchor"></span>pmf
Foo::f(const char*); // f is a member function of Foo</p>
<p>typedef int (&amp;ra)[100]; // ra means "reference to array of 100
ints" ra g(); // g returns reference to array of 100 ints</p>
<p>Section 97.3: Declaring multiple types with typedef</p>
<p>The <del>typedef</del> keyword is a specifier, so it applies
separately to each declarator. Therefore, each name declared</p>
<p>refers to the type that that name would have in the absence of
<del>typedef</del>.</p>
<p>int *x, (*p)(); // x has type int*, and p has type int(*)() typedef
int *x, (*p)(); // x is an alias for int*, while p is an alias for
int(*)()</p>
<p>Section 97.4: Alias declaration with "using"</p>
<p>Version ≥ C++11</p>
<p>The syntax of <del>using</del> is very simple: the name to be defined
goes on the left hand side, and the definition goes on the right hand
side. No need to scan to see where the name is.</p>
<p>using I = int;</p>
<p>using A = int[100]; // array of 100 ints</p>
<p>using FP = void(*)(int); // pointer to function of int returning void
using MP = void (Foo::*)(int); // pointer to member function of Foo of
int returning void</p>
<p>Creating a type alias with <del>using</del> has exactly the same
effect as creating a type alias with <del>typedef</del>. It is simply an
alternative syntax for accomplishing the same thing.</p>
<p>Unlike <del>typedef</del>, <del>using</del> can be templated. A
"template typedef" created with <del>using</del> is called an alias
template.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 504</p>
<p><span id="Chapter_98__type_deduction_1" class="anchor"></span>Chapter
98: type deduction</p>
<p>Section 98.1: Template parameter deduction for constructors</p>
<p>Prior to C++17, template deduction cannot deduce the class type for
you in a constructor. It must be explicitly specified. Sometimes,
however, these types can be very cumbersome or (in the case of lambdas)
impossible to</p>
<p>name, so we got a proliferation of type factories (like
<del>make_pair()</del>, <del>make_tuple()</del>,
<del>back_inserter()</del>, etc.).</p>
<p>Version ≥ C++17</p>
<p>This is no longer necessary:</p>
<p>std::pair p(2, 4.5); // std::pair</p>
<p>std::tuple t(4, 3, 2.5); // std::tuple <del>std::copy_n(vi1.begin(),
3,</del></p>
<p>std::back_insert_iterator(vi2)); // constructs a
back_insert_iterator<del>&gt; std::lock_guard lk(mtx); //
std::lock_guard</del></p>
<p>Constructors are considered to deduce the class template parameters,
but in some cases this is insufficient and we can provide explicit
deduction guides:</p>
<p>template</p>
<p>vector(Iter, Iter)-&gt; vector<del>::value_type&gt;</del></p>
<p>int array[] = {1, 2, 3};</p>
<p>std::vector v(std::begin(array), std::end(array)); // deduces
std::vector</p>
<p>Section 98.2: Auto Type Deduction</p>
<p>Version ≥ C++11</p>
<p>Type deduction using the <del>auto</del> keyword works almost the
same as Template Type Deduction. Below are a few examples:</p>
<p>auto x = 27; // (x is neither a pointer nor a reference), x's type is
int const auto cx = x; // (cx is neither a pointer nor a reference),
cs's type is const int const auto&amp; rx = x; <del>// (rx is a
non-universal reference), rx's type is a reference to a const</del></p>
<p>int</p>
<p>auto&amp;&amp; uref1 = x; // x is int and lvalue, so uref1's type is
int&amp; auto&amp;&amp; uref2 = cx; // cx is const int and lvalue, so
uref2's type is const int &amp; auto&amp;&amp; uref3 = 27; // 27 is an
int and rvalue, so uref3's type is int&amp;&amp;</p>
<p>The differences are outlined below:</p>
<p>auto x1 = 27; // type is int, value is 27</p>
<p>auto x2(27); // type is int, value is 27</p>
<p><del>auto x3 = { 27 }; // type is std::initializer_list</del>, value
is { 27 } auto x4{ 27 }; // type is std::initializer_list, value is { 27
}</p>
<p>// in some compilers type may be deduced as an int with a // value of
27. See remarks for more information.</p>
<p>auto x5 = { 1, 2.0 } // error! can't deduce T for
std::initializer_list</p>
<p>As you can see if you use braced initializers, auto is forced into
creating a variable of type</p>
<p>std::initializer_list. If it can't deduce the of <del>T</del>, the
code is rejected.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 505</p>
<p><span id="When_auto_is_used_as_the_return" class="anchor"></span>When
<del>auto</del> is used as the return type of a function, it specifies
that the function has a trailing return type.</p>
<p>auto f()-&gt; int {</p>
<p>return 42;</p>
<p>}</p>
<p>Version ≥ C++14</p>
<p>C++14 allows, in addition to the usages of auto allowed in C++11, the
following:</p>
<p>1. When used as the return type of a function without a trailing
return type, specifies that the function's return</p>
<p>type should be deduced from the return statements in the function's
body, if any.</p>
<p>// f returns int:</p>
<p>auto f() { return 42; }</p>
<p>// g returns void:</p>
<p>auto g() { std::cout &lt;&lt; "hello,
world!<strong><del>\n</del></strong>"; }</p>
<p>2. When used in the parameter type of a lambda, defines the lambda to
be a generic lambda.</p>
<p>auto triple = [](auto x) { return 3*x; };</p>
<p>const auto x = triple(42); // x is a const int with value 126</p>
<p>The special form <del>decltype(auto)</del> deduces a type using the
type deduction rules of <del>decltype</del> rather than those of</p>
<p>auto<del>.</del></p>
<p>int* p = new int(42);</p>
<p>auto x = *p; // x has type int</p>
<p>decltype(auto) y = *p; // y is a reference to *p</p>
<p>In C++03 and earlier, the <del>auto</del> keyword had a completely
different meaning as a storage class specifier that was</p>
<p>inherited from C.</p>
<p>Section 98.3: Template Type Deduction</p>
<p>Template Generic Syntax</p>
<p>template</p>
<p>void f(ParamType param);</p>
<p>f(expr);</p>
<p>Case 1: <del>ParamType</del> is a Reference or Pointer, but not a
Universal or Forward Reference. In this case type deduction works this
way. The compiler ignores the reference part if it exists in
<del>expr</del>. The compiler then pattern-matches</p>
<p>expr's type against <del>ParamType</del> to determing
<del>T</del>.</p>
<p>template</p>
<p>void f(T&amp; param); //param is a reference</p>
<p>int x = 27; // x is an int</p>
<p>const int cx = x; // cx is a const int</p>
<p>const int&amp; rx = x; // rx is a reference to x as a const int</p>
<p>f(x); // T is int, param's type is int&amp;</p>
<p>f(cx); // T is const int, param's type is const int&amp; f(rx); // T
is const int, param's type is const int&amp;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 506</p>
<p>Case 2: <del>ParamType</del> is a Universal Reference or Forward
Reference. In this case type deduction is the same as in case 1 if the
<del>expr</del> is an rvalue. If <del>expr</del> is an lvalue, both
<del>T</del> and <del>ParamType</del> are deduced to be lvalue
references.</p>
<p>template</p>
<p>void f(T&amp;&amp; param); // param is a universal reference</p>
<p>int x = 27; // x is an int</p>
<p>const int cx = x; // cx is a const int</p>
<p>const int&amp; rx = x; // rx is a reference to x as a const int</p>
<p>f(x); // x is lvalue, so T is int&amp;, param's type is also int&amp;
f(cx); // cx is lvalue, so T is const int&amp;, param's type is also
const int&amp; f(rx); // rx is lvalue, so T is const int&amp;, param's
type is also const int&amp; f(27); // 27 is rvalue, so T is int, param's
type is therefore int&amp;&amp;</p>
<p>Case 3: <del>ParamType</del> is Neither a Pointer nor a Reference. If
<del>expr</del> is a reference the reference part is ignored. If
<del>expr</del> is</p>
<p>const that is ignored as well. If it is volatile that is also ignored
when deducing T's type.</p>
<p>template</p>
<p>void f(T param); // param is now passed by value</p>
<p>int x = 27; // x is an int</p>
<p>const int cx = x; // cx is a const int</p>
<p>const int&amp; rx = x; // rx is a reference to x as a const int</p>
<p>f(x); // T's and param's types are both int</p>
<p>f(cx); // T's and param's types are again both int</p>
<p>f(rx); // T's and param's types are still both int</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 507</p>
<p><span id="Chapter_99__Trailing_return_type_1"
class="anchor"></span>Chapter 99: Trailing return type</p>
<p>Section 99.1: Avoid qualifying a nested type name</p>
<p>class ClassWithAReallyLongName {</p>
<p>public:</p>
<p>class Iterator { <del>/* ... */</del> };</p>
<p>Iterator end();</p>
<p>};</p>
<p>Defining the member <del>end</del> with a trailing return type:</p>
<p>auto ClassWithAReallyLongName::end()-&gt; Iterator { return
Iterator(); }</p>
<p>Defining the member <del>end</del> without a trailing return
type:</p>
<p>ClassWithAReallyLongName::Iterator ClassWithAReallyLongName::end() {
return Iterator(); }</p>
<p>The trailing return type is looked up in the scope of the class,
while a leading return type is looked up in the enclosing namespace
scope and can therefore require "redundant" qualification.</p>
<p>Section 99.2: Lambda expressions</p>
<p>A lambda can only have a trailing return type; the leading return
type syntax is not applicable to lambdas. Note that in many cases it is
not necessary to specify a return type for a lambda at all.</p>
<p>struct Base {};</p>
<p>struct Derived1 : Base {};</p>
<p>struct Derived2 : Base {};</p>
<p>auto lambda = [](bool b)-&gt; Base* { if (b) return new Derived1;
else return new Derived2; }; // ill-formed: auto lambda = Base* [](bool
b) { ... };</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 508</p>
<p><span id="Chapter_100__Alignment_1" class="anchor"></span>Chapter
100: Alignment</p>
<p>All types in C++ have an alignment. This is a restriction on the
memory address that objects of that type can be</p>
<p>created within. A memory address is valid for an object's creation if
dividing that address by the object's alignment is a whole number.</p>
<p>Type alignments are always a power of two (including 1).</p>
<p>Section 100.1: Controlling alignment</p>
<p>Version ≥ C++11</p>
<p>The <del>alignas</del> keyword can be used to force a variable, class
data member, declaration or definition of a class, or declaration or
definition of an enum, to have a particular alignment, if supported. It
comes in two forms:</p>
<p>alignas(x) , where <del>x</del> is a constant expression, gives the
entity the alignment <del>x</del>, if supported. alignas(T) , where
<del>T</del> is a type, gives the entity an alignment equal to the
alignment requirement of <del>T</del>, that is,</p>
<p><del>alignof(T)</del> , if supported.</p>
<p>If multiple <del>alignas</del> specifiers are applied to the same
entity, the strictest one applies.</p>
<p>In this example, the buffer <del>buf</del> is guaranteed to be
appropriately aligned to hold an <del>int</del> object, even though
its</p>
<p>element type is <del>unsigned char</del>, which may have a weaker
alignment requirement.</p>
<p>alignas(int) unsigned char buf[sizeof(int)];</p>
<p>new (buf) int(42);</p>
<p><del>alignas</del> cannot be used to give a type a smaller alignment
than the type would have without this declaration:</p>
<p>alignas(1) int i; //Il-formed, unless `int` on this platform is
aligned to 1 byte. alignas(char) int j; //Il-formed, unless `int` has
the same or smaller alignment than `char`.</p>
<p><del>alignas</del> , when given an integer constant expression, must
be given a valid alignment. Valid alignments are always powers of two,
and must be greater than zero. Compilers are required to support all
valid alignments up to the</p>
<p>alignment of the type <del>std::max_align_t</del>. They may support
larger alignments than this, but support for allocating memory for such
objects is limited. The upper limit on alignments is implementation
dependent.</p>
<p>C++17 features direct support in <del>operator new</del> for
allocating memory for over-aligned types.</p>
<p>Section 100.2: Querying the alignment of a type</p>
<p>Version ≥ c++11</p>
<p>The alignment requirement of a type can be queried using the
<del>alignof</del> keyword as a unary operator. The result is a constant
expression of type <del>std::size_t</del>, i.e., it can be evaluated at
compile time.</p>
<p>#include</p>
<p>int main() {</p>
<p>std::cout &lt;&lt; "The alignment requirement of int is: " &lt;&lt;
alignof(int) &lt;&lt; '<strong><del>\n</del></strong>'; }</p>
<p>Possible output</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 509</p>
<p>The alignment requirement of int is: 4</p>
<p>If applied to an array, it yields the alignment requirement of the
element type. If applied to a reference type, it</p>
<p>yields the alignment requirement of the referenced type. (References
themselves have no alignment, since they are not objects.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 510</p>
<p><span id="Chapter_101__Perfect_Forwarding_1"
class="anchor"></span>Chapter 101: Perfect Forwarding</p>
<p>Section 101.1: Factory functions</p>
<p>Suppose we want to write a factory function that accepts an arbitrary
list of arguments and passes those arguments unmodified to another
function. An example of such a function is <del>make_unique</del>, which
is used to safely</p>
<p>construct a new instance of <del>T</del> and return a
<del>unique_ptr</del> that owns the instance.</p>
<p>The language rules regarding variadic templates and rvalue references
allows us to write such a function.</p>
<p>template</p>
<p><del>unique_ptr</del> make_unique(A&amp;&amp;... args)</p>
<p>{</p>
<p><del>return unique_ptr</del>(new T(std::forward(args)...));</p>
<p>}</p>
<p>The use of ellipses ... indicate a parameter pack, which represents
an arbitrary number of types. The compiler will expand this parameter
pack to the correct number of arguments at the call site. These
arguments are then passed</p>
<p>to T's constructor using std::forward. This function is required to
preserve the ref-qualifiers of the arguments.</p>
<p>struct foo</p>
<p>{</p>
<p>foo() {}</p>
<p>foo(const foo&amp;) {} // copy constructor</p>
<p>foo(foo&amp;&amp;) {} // copy constructor</p>
<p>foo(int, int, int) {}</p>
<p>};</p>
<p>foo f;</p>
<p>auto p1 = make_unique(f); // calls foo::foo(const foo&amp;) auto p2 =
make_unique(std::move(f)); // calls foo::foo(foo&amp;&amp;) auto p3 =
make_unique(1, 2, 3);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 511</p>
<p><span id="Chapter_102__decltype_1" class="anchor"></span>Chapter 102:
decltype</p>
<p>The keyword <del>decltype</del> can be used to get the type of a
variable, function or an expression.</p>
<p>Section 102.1: Basic Example</p>
<p>This example just illustrates how this keyword can be used.</p>
<p>int a = 10;</p>
<p>// Assume that type of variable 'a' is not known here, or it may //
be changed by programmer (from int to long long, for example). // Hence
we declare another variable, 'b' of the same type using // decltype
keyword.</p>
<p>decltype(a) b; // 'decltype(a)' evaluates to 'int'</p>
<p>If, for example, someone changes, type of 'a' to:</p>
<p>float a=99.0f;</p>
<p>Then the type of variable <del>b</del> now automatically becomes
<del>float</del>.</p>
<p>Section 102.2: Another example</p>
<p>Let's say we have vector:</p>
<p>std::vector <del>intVector;</del></p>
<p>And we want to declare an iterator for this vector. An obvious idea
is to use <del>auto</del>. However, it may be needed just</p>
<p>declare an iterator variable (and not to assign it to anything). We
would do:</p>
<p><del>vector</del>::iterator iter;</p>
<p>However, with <del>decltype</del> it becomes easy and less error
prone (if type of <del>intVector</del> changes).</p>
<p>decltype(intVector)::iterator iter;</p>
<p>Alternatively:</p>
<p>decltype(intVector.begin()) iter;</p>
<p>In second example, the return type of <del>begin</del> is used to
determine the actual type, which is <del>vector</del>::iterator.</p>
<p>If we need a const_iterator, we just need to use
<del>cbegin</del>:</p>
<p>decltype(intVector.cbegin()) iter; //
vector<del>::const_iterator</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 512</p>
<p><span id="Chapter_103__SFINAE__Substitutio_1"
class="anchor"></span>Chapter 103: SFINAE (Substitution Failure Is</p>
<p>Not An Error)</p>
<p>Section 103.1: What is SFINAE</p>
<p>SFINAE stands for <strong>S</strong>ubstitution
<strong>F</strong>ailure <strong>I</strong>s <strong>N</strong>ot
<strong>A</strong>n <strong>E</strong>rror. Ill-formed code that results
from substituting types (or</p>
<p>values) to instantiate a function template or a class template is
<strong>not</strong> a hard compile error, it is only treated as a</p>
<p>deduction failure.</p>
<p>Deduction failures on instantiating function templates or class
template specializations remove that candidate from the set of
consideration - as if that failed candidate did not exist to begin
with.</p>
<p>template</p>
<p>auto begin(T&amp; c)-&gt; decltype(c.begin()) { return c.begin();
}</p>
<p>template</p>
<p>T* begin(T (&amp;arr)[N]) { return arr; }</p>
<p>int vals[10];</p>
<p>begin(vals); // OK. The first function template substitution fails
because</p>
<p>// vals.begin() is ill-formed. This is not an error! That function //
is just removed from consideration as a viable overload candidate, //
leaving us with the array overload.</p>
<p>Only substitution failures in the <strong>immediate context</strong>
are considered deduction failures, all others are considered</p>
<p>hard errors.</p>
<p>template</p>
<p>void add_one(T&amp; val) { val += 1; }</p>
<p>int i = 4;</p>
<p>add_one(i); // ok</p>
<p>std::string msg = "Hello";</p>
<p>add_one(msg); // error. msg += 1 is ill-formed for std::string, but
this</p>
<p>// failure is NOT in the immediate context of substituting T</p>
<p>Section 103.2: void_t</p>
<p>Version ≥ C++11</p>
<p>void_t is a meta-function that maps any (number of) types to type
<del>void</del>. The primary purpose of <del>void_t</del> is to</p>
<p>facilitate writing of type traits.</p>
<p><a href="http://en.cppreference.com/w/cpp/types/void_t">std::void_t
will be part of C++17, but until then, it is extremely straightforward
to implement:</a></p>
<p><del>template</del> using void_t = void;</p>
<p>Some compilers <a
href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558">require
a slightly different implementation:</a></p>
<p>template</p>
<p>struct make_void { using type = void; };</p>
<p>template</p>
<p>using void_t = typename make_void<del>::type;</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 513</p>
<p>The primary application of <del>void_t</del> is writing type traits
that check validity of a statement. For example, let's check if a type
has a member function <del>foo()</del> that takes no arguments:</p>
<p>template</p>
<p>struct has_foo : std::false_type {};</p>
<p>template</p>
<p><del>struct has_foo</del>().foo())&gt;&gt; : std::true_type {};</p>
<p>How does this work? When I try to instantiate
<del>has_foo</del>::value, that will cause the compiler to try to look
for the</p>
<p>best specialization for <del>has_foo</del>. We have two options: the
primary, and this secondary one which involves having to instantiate
that underlying expression:</p>
<p>If <del>T</del> does have a member function <del>foo()</del>, then
whatever type that returns gets converted to <del>void</del>, and the
specialization is preferred to the primary based on the template partial
ordering rules. So</p>
<p>has_foo::value will be <del>true</del></p>
<p>If <del>T</del> doesn't have such a member function (or it requires
more than one argument), then substitution fails for</p>
<p>the specialization and we only have the primary template to fallback
on. Hence, <del>has_foo</del>::value is false.</p>
<p>A simpler case:</p>
<p>template</p>
<p>struct can_reference : std::false_type {};</p>
<p>template</p>
<p><del>struct can_reference</del>&gt; : std::true_type {};</p>
<p>this doesn't use <del>std::declval</del> or <del>decltype</del>.</p>
<p>You may notice a common pattern of a void argument. We can factor
this out:</p>
<p>struct details {</p>
<p><del>template</del>class Z, class=void, class...Ts&gt; struct
can_apply:</p>
<p>std::false_type</p>
<p>{};</p>
<p><del>template</del>class Z, class...Ts&gt;</p>
<p><del>struct can_apply</del>&gt;, Ts...&gt;: std::true_type</p>
<p>{};</p>
<p>};</p>
<p><del>template</del>class Z, class...Ts&gt;</p>
<p>using can_apply = details::can_apply<del>;</del></p>
<p>which hides the use of <del>std::void_t</del> and makes
<del>can_apply</del> act like an indicator whether the type supplied as
the first template argument is well-formed after substituting the other
types into it. The previous examples may now be</p>
<p>rewritten using <del>can_apply</del> as:</p>
<p>template</p>
<p>using ref_t = T&amp;;</p>
<p>template</p>
<p>using can_reference = can_apply<del>; // Is T&amp; well formed for
T?</del></p>
<p>and:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 514</p>
<p><span id="template_6" class="anchor"></span>template</p>
<p>using dot_foo_r = decltype(std::declval<del>().foo());</del></p>
<p>template</p>
<p>using can_dot_foo = can_apply&lt; dot_foo_r, T &gt;; // Is T.foo()
well formed for T?</p>
<p>which seems simpler than the original versions.</p>
<p>There are post-C++17 proposals for <del>std</del> traits similar to
<del>can_apply</del>.</p>
<p>The utility of <del>void_t</del> <a
href="https://youtu.be/a0FliKwcwXE?t=1747">was discovered by Walter
Brown. He gave a wonderful presentation on it at CppCon 2016.</a></p>
<p>Section 103.3: enable_if</p>
<p><del>std::enable_if</del> is a convenient utility to use boolean
conditions to trigger SFINAE. It is defined as:</p>
<p>template</p>
<p>struct enable_if { };</p>
<p>template</p>
<p>struct enable_if <del>{</del></p>
<p>using type = Result;</p>
<p>};</p>
<p>That is, <del>enable_if</del>::type is an alias for R, whereas
enable_if::type is ill-formed as that specialization of enable_if does
not have a type member type.</p>
<p><del>std::enable_if</del> can be used to constrain templates:</p>
<p>int negate(int i) { return-i; }</p>
<p>template</p>
<p>auto negate(F f) { return-f(); }</p>
<p>Here, a call to <del>negate(1)</del> would fail due to ambiguity. But
the second overload is not intended to be used for</p>
<p>integral types, so we can add:</p>
<p>int negate(int i) { return-i; }</p>
<p><del>template</del> ::value&gt;::type&gt; auto negate(F f) {
return-f(); }</p>
<p>Now, instantiating <del>negate</del> would result in a substitution
failure since !std::is_arithmetic::value is false . Due to SFINAE, this
is not a hard error, this candidate is simply removed from the overload
set. As a result,</p>
<p><del>negate(1)</del> only has one single viable candidate - which is
then called.</p>
<p>When to use it</p>
<p>It's worth keeping in mind that <del>std::enable_if</del> is a helper
on top of SFINAE, but it's not what makes SFINAE work in</p>
<p>the first place. Let's consider these two alternatives for
implementing functionality similar to <del>std::size</del>, i.e. an</p>
<p>overload set <del>size(arg)</del> that produces the size of a
container or array:</p>
<p>// for containers</p>
<p>template</p>
<p>auto size1(Cont const&amp; cont)-&gt; decltype( cont.size() );</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 515</p>
<p><span id="___for_arrays" class="anchor"></span>// for arrays</p>
<p>template</p>
<p>std::size_t size1(Elt const(&amp;arr)[Size]);</p>
<p>// implementation omitted</p>
<p>template</p>
<p>struct is_sizeable;</p>
<p>// for containers</p>
<p><del>template</del>::value, int&gt; = 0&gt; auto size2(Cont
const&amp; cont);</p>
<p>// for arrays</p>
<p>template</p>
<p>std::size_t size2(Elt const(&amp;arr)[Size]);</p>
<p>Assuming that <del>is_sizeable</del> is written appropriately, these
two declarations should be exactly equivalent with</p>
<p>respect to SFINAE. Which is the easiest to write, and which is the
easiest to review and understand at a glance?</p>
<p>Now let's consider how we might want to implement arithmetic helpers
that avoid signed integer overflow in favour</p>
<p>of wrap around or modular behaviour. Which is to say that e.g.
<del>incr(i, 3)</del> would be the same as <del>i += 3</del> save for
the fact that the result would always be defined even if <del>i</del> is
an <del>int</del> with value <del>INT_MAX</del>. These are two
possible</p>
<p>alternatives:</p>
<p>// handle signed types</p>
<p>template</p>
<p>auto incr1(Int&amp; target, Int amount)</p>
<p><del>-&gt; std::void_t</del>(-1) &lt; static_cast(0)]&gt;;</p>
<p>// handle unsigned types by just doing target += amount // since
unsigned arithmetic already behaves as intended template</p>
<p>auto incr1(Int&amp; target, Int amount)</p>
<p><del>-&gt; std::void_t</del>(0) &lt; static_cast(-1)]&gt;;</p>
<p><del>template</del>::value, int&gt; = 0&gt; void incr2(Int&amp;
target, Int amount);</p>
<p><del>template</del>::value, int&gt; = 0&gt; void incr2(Int&amp;
target, Int amount);</p>
<p>Once again which is the easiest to write, and which is the easiest to
review and understand at a glance?</p>
<p>A strength of <del>std::enable_if</del> is how it plays with
refactoring and API design. If <del>is_sizeable</del>::value is</p>
<p>meant to reflect whether <del>cont.size()</del> is valid then just
using the expression as it appears for <del>size1</del> can be more
concise, although that could depend on whether <del>is_sizeable</del>
would be used in several places or not. Contrast that</p>
<p>with <del>std::is_signed</del> which reflects its intention much more
clearly than when its implementation leaks into the declaration of
<del>incr1</del>.</p>
<p>Section 103.4: is_detected</p>
<p>To generalize type_trait creation:based on SFINAE there are
experimental traits <del>detected_or</del>, <del>detected_t</del>,
<del>is_detected</del>.</p>
<p>With template parameters <del>typename Default</del>,
<del>template</del> Op and typename ... Args:</p>
<p>is_detected: alias of <del>std::true_type</del> or
<del>std::false_type</del> depending of the validity of
<del>Op</del></p>
<p>detected_t: alias of <del>Op</del> or nonesuch depending of validity
of Op.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 516</p>
<p>detected_or: alias of a struct with <del>value_t</del> which is
<del>is_detected</del>, and <del>type</del> which is <del>Op</del> or
Default depending of validity of Op</p>
<p>which can be implemented using <del>std::void_t</del> for SFINAE as
following:</p>
<p>Version ≥ C++17</p>
<p>namespace detail {</p>
<p>template</p>
<p><del>template</del> class Op, class... Args&gt;</p>
<p>struct detector</p>
<p>{</p>
<p>using value_t = std::false_type;</p>
<p>using type = Default;</p>
<p>};</p>
<p><del>template</del> class Op, class... Args&gt; struct detector&gt;,
Op, Args...&gt; {</p>
<p>using value_t = std::true_type;</p>
<p>using type = Op<del>;</del></p>
<p>};</p>
<p>} // namespace detail</p>
<p>// special type to indicate detection failure</p>
<p>struct nonesuch {</p>
<p>nonesuch() = delete;</p>
<p>~nonesuch() = delete;</p>
<p>nonesuch(nonesuch const&amp;) = delete;</p>
<p>void operator=(nonesuch const&amp;) = delete;</p>
<p>};</p>
<p><del>template</del> class Op, class... Args&gt; using is_detected
=</p>
<p>typename detail::detector<del>::value_t;</del></p>
<p><del>template</del> class Op, class... Args&gt; using detected_t =
typename detail::detector::type;</p>
<p><del>template</del> class Op, class... Args&gt; using detected_or =
detail::detector;</p>
<p>Traits to detect presence of method can then be simply
implemented:</p>
<p>typename</p>
<p>using foo_type =
decltype(std::declval<del>().foo(std::declval()...));</del></p>
<p>struct C1 {};</p>
<p>struct C2 {</p>
<p>int foo(char) const;</p>
<p>};</p>
<p>template</p>
<p>using has_foo_char = is_detected<del>;</del></p>
<p><del>static_assert(!has_foo_char</del>::value, "Unexpected");
static_assert(has_foo_char::value, "Unexpected");</p>
<p>static_assert(std::is_same<del>&gt;::value,</del></p>
<p>"Unexpected");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 517</p>
<p><span id="static_assert_std__is_same"
class="anchor"></span>static_assert(std::is_same</p>
<p>detected_or<del>&gt;::value,</del></p>
<p>"Unexpected");</p>
<p>static_assert(std::is_same<del>&gt;::value,</del></p>
<p>"Unexpected");</p>
<p>Section 103.5: Overload resolution with a large number of</p>
<p>options</p>
<p>If you need to select between several options, enabling just one via
<del>enable_if&lt;&gt;</del> can be quite cumbersome, since</p>
<p>several conditions needs to be negated too.</p>
<p>The ordering between overloads can instead be selected using
inheritance, i.e. tag dispatch.</p>
<p>Instead of testing for the thing that needs to be well-formed, and
also testing the negation of all the other versions</p>
<p>conditions, we instead test just for what we need, preferably in a
<del>decltype</del> in a trailing return. This might leave several
option well formed, we differentiate between those using 'tags', similar
to iterator-trait tags</p>
<p>(<del>random_access_tag</del> et al). This works because a direct
match is better that a base class, which is better that a base class of
a base class, etc.</p>
<p>#include</p>
<p>#include</p>
<p>namespace detail</p>
<p>{</p>
<p>// this gives us infinite types, that inherit from each other
template</p>
<p>struct pick : pick <del>{};</del></p>
<p>template&lt;&gt;</p>
<p>struct pick&lt;0&gt; {};</p>
<p>// the overload we want to be preferred have a higher N in pick
<del>// this is the first helper template function</del></p>
<p>template</p>
<p>auto stable_sort(T&amp; t, pick&lt;2&gt;)</p>
<p>-&gt; decltype( t.stable_sort(), void() )</p>
<p>{</p>
<p>// if the container have a member stable_sort, use that</p>
<p>t.stable_sort();</p>
<p>}</p>
<p>// this helper will be second best match</p>
<p>template</p>
<p>auto stable_sort(T&amp; t, pick&lt;1&gt;)</p>
<p>-&gt; decltype( t.sort(), void() )</p>
<p>{</p>
<p>// if the container have a member sort, but no member stable_sort //
it's customary that the sort member is stable</p>
<p>t.sort();</p>
<p>}</p>
<p>// this helper will be picked last</p>
<p>template</p>
<p>auto stable_sort(T&amp; t, pick&lt;0&gt;)</p>
<p>-&gt; decltype( std::stable_sort(std::begin(t), std::end(t)), void()
)</p>
<p>{</p>
<p>// the container have neither a member sort, nor member
stable_sort</p>
<p>std::stable_sort(std::begin(t), std::end(t));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 518</p>
<p><span id="_41" class="anchor"></span>}</p>
<p>// this is the function the user calls. it will dispatch the call //
to the correct implementation with the help of 'tags'. template</p>
<p>void stable_sort(T&amp; t)</p>
<p>{</p>
<p>// use an N that is higher that any used above.</p>
<p>// this will pick the highest overload that is well formed.</p>
<p>detail::stable_sort(t, detail::pick&lt;10&gt;{});</p>
<p>}</p>
<p>There are other methods commonly used to differentiate between
overloads, such as exact match being better</p>
<p>than conversion, being better than ellipsis.</p>
<p>However, tag-dispatch can extend to any number of choices, and is a
bit more clear in intent.</p>
<p>Section 103.6: trailing decltype in function templates</p>
<p>Version ≥ C++11</p>
<p>One of constraining function is to use trailing <del>decltype</del>
to specify the return type:</p>
<p>namespace details {</p>
<p>using std::to_string;</p>
<p>// this one is constrained on being able to call to_string(T)
template</p>
<p>auto convert_to_string(T const&amp; val, int )</p>
<p>-&gt; decltype(to_string(val))</p>
<p>{</p>
<p>return to_string(val);</p>
<p>}</p>
<p>// this one is unconstrained, but less preferred due to the ellipsis
argument template</p>
<p>std::string convert_to_string(T const&amp; val, ... )</p>
<p>{</p>
<p>std::ostringstream oss;</p>
<p>oss &lt;&lt; val;</p>
<p>return oss.str();</p>
<p>}</p>
<p>}</p>
<p>template</p>
<p>std::string convert_to_string(T const&amp; val)</p>
<p>{</p>
<p>return details::convert_to_string(val, 0);</p>
<p>}</p>
<p>If I call <del>convert_to_string()</del> with an argument with which
I can invoke <del>to_string()</del>, then I have two viable</p>
<p>functions for <del>details::convert_to_string()</del>. The first is
preferred since the conversion from <del>0</del> to <del>int</del> is a
better implicit conversion sequence than the conversion from
<del>0</del> to <del>...</del></p>
<p>If I call <del>convert_to_string()</del> with an argument from which
I cannot invoke <del>to_string()</del>, then the first function template
instantiation leads to substitution failure (there is no
<del>decltype(to_string(val))</del>). As a result, that</p>
<p>candidate is removed from the overload set. The second function
template is unconstrained, so it is selected and we instead go through
<del>operator&lt;&lt;(std::ostream&amp;, T)</del>. If that one is
undefined, then we have a hard compile error</p>
<p>with a template stack on the line <del>oss &lt;&lt; val</del>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 519</p>
<p><span id="Section_103_7__enable_if_all___e"
class="anchor"></span>Section 103.7: enable_if_all / enable_if_any</p>
<p>Version ≥ C++11</p>
<p>Motivational example</p>
<p>When you have a variadic template pack in the template parameters
list, like in the following code snippet:</p>
<p><del>template</del> void func(Args &amp;&amp;...args) { //... };</p>
<p>The standard library (prior to C++17) offers no direct way to write
<strong>enable_if</strong> to impose SFINAE constraints on <strong>all
of</strong></p>
<p><strong>the parameters</strong> in <del>Args</del> or <strong>any of
the parameters</strong> in <del>Args</del>. C++17 offers <a
href="http://en.cppreference.com/w/cpp/types/conjunction">std::conjunction
and</a> <a
href="http://en.cppreference.com/w/cpp/types/disjunction">std::disjunction</a></p>
<p>which solve this problem. For example:</p>
<p>/// C++17: SFINAE constraints on all of the parameters in Args.
template</p>
<p><del>std::enable_if_t</del>...&gt;&gt;* = nullptr&gt; void func(Args
&amp;&amp;...args) { //... };</p>
<p>/// C++17: SFINAE constraints on any of the parameters in Args.
template</p>
<p><del>std::enable_if_t</del>...&gt;&gt;* = nullptr&gt; void func(Args
&amp;&amp;...args) { //... };</p>
<p>If you do not have C++17 available, there are several solutions to
achieve these. One of them is to use a base-case</p>
<p>class and <strong>partial specializations</strong>, as demonstrated
in answers of this <a
href="http://stackoverflow.com/questions/26421104/how-do-i-enable-if-a-class-with-variadic-template-arguments">question</a>.</p>
<p>Alternatively, one may also implement by hand the behavior of
<del>std::conjunction</del> and <del>std::disjunction</del> in a</p>
<p>rather straight-forward way. In the following example I'll
demonstrate the implementations and combine them with std::enable_if to
produce two alias: <del>enable_if_all</del> and
<del>enable_if_any</del>, which do exactly what they are supposed</p>
<p>to semantically. This may provide a more scalable solution.</p>
<p><strong><del>Implementation of</del></strong> enable_if_all
<strong><del>and</del></strong> enable_if_any</p>
<p>First let's emulate <del>std::conjunction</del> and
<del>std::disjunction</del> using customized <del>seq_and</del> and
<del>seq_or</del> respectively:</p>
<p>/// Helper for prior to C++14.</p>
<p>template</p>
<p>using conditional_t = typename std::conditional<del>::type;</del></p>
<p>/// Emulate C++17 std::conjunction.</p>
<p><del>template</del> struct seq_or: std::false_type {}; template
struct seq_and: std::true_type {};</p>
<p>template</p>
<p>struct seq_or<del>:</del></p>
<p>conditional_t<del>&gt; {};</del></p>
<p>template</p>
<p>struct seq_and<del>:</del></p>
<p><del>conditional_t</del>,std::false_type&gt; {};</p>
<p>Then the implementation is quite straight-forward:</p>
<p>template</p>
<p>using enable_if_any = std::enable_if<del>::value&gt;;</del></p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 520</p>
<p>using enable_if_all = std::enable_if<del>::value&gt;;</del></p>
<p>Eventually some helpers:</p>
<p>template</p>
<p>using enable_if_any_t = typename enable_if_any<del>::type;</del></p>
<p>template</p>
<p>using enable_if_all_t = typename enable_if_all<del>::type;</del></p>
<p>Usage</p>
<p>The usage is also straight-forward:</p>
<p>/// SFINAE constraints on all of the parameters in Args. template</p>
<p><del>enable_if_all_t</del>...&gt;* = nullptr&gt;</p>
<p>void func(Args &amp;&amp;...args) { //... };</p>
<p>/// SFINAE constraints on any of the parameters in Args. template</p>
<p><del>enable_if_any_t</del>...&gt;* = nullptr&gt;</p>
<p>void func(Args &amp;&amp;...args) { //... };</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 521</p>
<p><span id="Chapter_104__Undefined_Behavior_1"
class="anchor"></span>Chapter 104: Undefined Behavior</p>
<p>What is undefined behavior (UB)? According to the ISO C++ Standard
(§1.3.24, N4296), it is "behavior for which this</p>
<p>International Standard imposes no requirements."</p>
<p>This means that when a program encounters UB, it is allowed to do
whatever it wants. This often means a crash,</p>
<p>but it may simply do nothing, <a
href="http://catb.org/jargon/html/N/nasal-demons.html">make demons fly
out of your nose, or even</a> appear to work properly!</p>
<p>Needless to say, you should avoid writing code that invokes UB.</p>
<p>Section 104.1: Reading or writing through a null pointer</p>
<p>int *ptr = nullptr;</p>
<p>*ptr = 1; // Undefined behavior</p>
<p>This is <strong>undefined behavior</strong>, because a null pointer
does not point to any valid object, so there is no object at
<del>*ptr</del></p>
<p>to write to.</p>
<p>Although this most often causes a segmentation fault, it is undefined
and anything can happen.</p>
<p>Section 104.2: Using an uninitialized local variable</p>
<p>int a;</p>
<p>std::cout &lt;&lt; a; // Undefined behavior!</p>
<p>This results in <strong>undefined behavior</strong>, because
<del>a</del> is uninitialised.</p>
<p>It is often, incorrectly, claimed that this is because the value is
"indeterminate", or "whatever value was in that memory location before".
However, it is the act of accessing the value of <del>a</del> in the
above example that gives</p>
<p>undefined behaviour. In practice, printing a "garbage value" is a
common symptom in this case, but that is only one possible form of
undefined behaviour.</p>
<p>Although highly unlikely in practice (since it is reliant on specific
hardware support) the compiler could equally well electrocute the
programmer when compiling the code sample above. With such a compiler
and hardware support,</p>
<p>such a response to undefined behaviour would markedly increase
average (living) programmer understanding of the true meaning of
undefined behaviour - which is that the standard places no constraint on
the resultant</p>
<p>behaviour.</p>
<p>Version ≥ C++14</p>
<p>Using an indeterminate value of <del>unsigned char</del> type does
not produce undefined behavior if the value is used as:</p>
<p>the second or third operand of the ternary conditional operator;</p>
<p>the right operand of the built-in comma operator;</p>
<p>the operand of a conversion to <del>unsigned char</del>;</p>
<p>the right operand of the assignment operator, if the left operand is
also of type <del>unsigned char</del>;</p>
<p>the initializer for an <del>unsigned char</del> object;</p>
<p>or if the value is discarded. In such cases, the indeterminate value
simply propagates to the result of the</p>
<p>expression, if applicable.</p>
<p>Note that a <del>static</del> variable is <strong>always</strong>
zero-initialized (if possible):</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 522</p>
<p><span id="static_int_a" class="anchor"></span>static int a;</p>
<p>std::cout &lt;&lt; a; // Defined behavior, 'a' is 0</p>
<p>Section 104.3: Accessing an out-of-bounds index</p>
<p>It is <strong>undefined behavior</strong> to access an index that is
out of bounds for an array (or standard library container for that</p>
<p>matter, as they are all implemented using a raw array):</p>
<p>int array[] = {1, 2, 3, 4, 5};</p>
<p>array[5] = 0; // Undefined behavior</p>
<p>It is allowed to have a pointer pointing to the end of the array (in
this case <del>array + 5</del>), you just can't dereference it, as it is
not a valid element.</p>
<p>const int *end = array + 5; // Pointer to one past the last index for
(int *p = array; p != end; ++p)</p>
<p>// Do something with `p`</p>
<p>In general, you're not allowed to create an out-of-bounds pointer. A
pointer must point to an element within the array, or one past the
end.</p>
<p>Section 104.4: Deleting a derived object via a pointer to a</p>
<p>base class that doesn't have a virtual destructor</p>
<p>class base { };</p>
<p>class derived: public base { };</p>
<p>int main() {</p>
<p>base* p = new derived();</p>
<p>delete p; // The is undefined behavior!</p>
<p>}</p>
<p>In section [expr.delete] §5.3.5/3 the standard says that if
<del>delete</del> is called on an object whose static type does not have
a <del>virtual</del> destructor:</p>
<p>if the static type of the object to be deleted is different from its
dynamic type, the static type shall be a</p>
<p>base class of the dynamic type of the object to be deleted and the
static type shall have a virtual</p>
<p>destructor or the behavior is undefined.</p>
<p>This is the case regardless of the question whether the derived class
added any data members to the base class.</p>
<p>Section 104.5: Extending the `std` or `posix` Namespace</p>
<p><a href="https://isocpp.org/files/papers/N3690.pdf">The standard
(17.6.4.2.1/1)</a> generally forbids extending the <del>std</del>
namespace:</p>
<p>The behavior of a C++ program is undefined if it adds declarations or
definitions to namespace std or to a</p>
<p>namespace within namespace std unless otherwise specified.</p>
<p>The same goes for <del>posix</del> (17.6.4.2.2/1):</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 523</p>
<p><span id="The_behavior_of_a_C___program_is" class="anchor"></span>The
behavior of a C++ program is undefined if it adds declarations or
definitions to namespace posix or to a namespace within namespace posix
unless otherwise specified.</p>
<p>Consider the following:</p>
<p>#include</p>
<p>namespace std</p>
<p>{</p>
<p>int foo(){}</p>
<p>}</p>
<p>Nothing in the standard forbids <del>algorithm</del> (or one of the
headers it includes) defining the same definition, and so</p>
<p><a href="https://en.wikipedia.org/wiki/One_Definition_Rule">this code
would violate the One Definition Rule.</a></p>
<p>So, in general, this is forbidden. There are <a
href="http://en.cppreference.com/w/cpp/language/extending_std">specific
exceptions allowed</a>, though. Perhaps most usefully, it is allowed to
add specializations for user defined types. So, for example, suppose
your code has</p>
<p>class foo</p>
<p>{</p>
<p>// Stuff</p>
<p>};</p>
<p>Then the following is fine</p>
<p>namespace std</p>
<p>{</p>
<p>template&lt;&gt;</p>
<p>struct hash</p>
<p>{</p>
<p>public:</p>
<p>size_t operator()(const foo &amp;f) const;</p>
<p>};</p>
<p>}</p>
<p>Section 104.6: Invalid pointer arithmetic</p>
<p>The following uses of pointer arithmetic cause undefined
behavior:</p>
<p>Addition or subtraction of an integer, if the result does not belong
to the same array object as the pointer operand. (Here, the element one
past the end is considered to still belong to the array.)</p>
<p>int a[10];</p>
<p>int* p1 = &amp;a[5];</p>
<p>int* p2 = p1 + 4; // ok; p2 points to a[9]</p>
<p>int* p3 = p1 + 5; // ok; p2 points to one past the end of a int* p4 =
p1 + 6; // UB</p>
<p>int* p5 = p1 -5; // ok; p2 points to a[0]</p>
<p>int* p6 = p1 -6; // UB</p>
<p>int* p7 = p3 -5; // ok; p7 points to a[5]</p>
<p>Subtraction of two pointers if they do not both belong to the same
array object. (Again, the element one past the end is considered to
belong to the array.) The exception is that two null pointers may be
subtracted,</p>
<p>yielding 0.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 524</p>
<p><span id="int_a_10" class="anchor"></span>int a[10];</p>
<p>int b[10];</p>
<p>int *p1 = &amp;a[8], *p2 = &amp;a[3];</p>
<p>int d1 = p1 - p2; // yields 5</p>
<p>int *p3 = p1 + 2; // ok; p3 points to one past the end of a int d2 =
p3 - p2; // yields 7</p>
<p>int *p4 = &amp;b[0];</p>
<p>int d3 = p4 - p1; // UB</p>
<p>Subtraction of two pointers if the result overflows
<del>std::ptrdiff_t</del>.</p>
<p>Any pointer arithmetic where either operand's pointee type does not
match the dynamic type of the object</p>
<p>pointed to (ignoring cv-qualification). According to the standard,
"[in] particular, a pointer to a base class cannot be used for pointer
arithmetic when the array contains objects of a derived class type."</p>
<p>struct Base { int x; };</p>
<p>struct Derived : Base { int y; };</p>
<p>Derived a[10];</p>
<p>Base* p1 = &amp;a[1]; // ok</p>
<p>Base* p2 = p1 + 1; // UB; p1 points to Derived</p>
<p>Base* p3 = p1 -1; // likewise</p>
<p>Base* p4 = &amp;a[2]; // ok</p>
<p>auto p5 = p4 - p1; // UB; p4 and p1 point to Derived const Derived*
p6 = &amp;a[1];</p>
<p>const Derived* p7 = p6 + 1; // ok; cv-qualifiers don't matter</p>
<p>Section 104.7: No return statement for a function with a non-</p>
<p>void return type</p>
<p>Omitting the <del>return</del> statement in a function which is has a
return type that is not <del>void</del> is <strong>undefined
behavior</strong>.</p>
<p>int function() {</p>
<p>// Missing return statement</p>
<p>}</p>
<p>int main() {</p>
<p>function(); //Undefined Behavior</p>
<p>}</p>
<p>Most modern day compilers emit a warning at compile time for this
kind of undefined behavior.</p>
<p><strong>Note:</strong> <del>main</del> is the only exception to the
rule. If <del>main</del> doesn't have a <del>return</del> statement, the
compiler automatically</p>
<p>inserts <del>return 0;</del> for you, so it can be safely left
out.</p>
<p>Section 104.8: Accessing a dangling reference</p>
<p>It is illegal to access a reference to an object that has gone out of
scope or been otherwise destroyed. Such a reference is said to be
dangling since it no longer refers to a valid object.</p>
<p>#include</p>
<p>int&amp; getX() {</p>
<p>int x = 42;</p>
<p>return x;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 525</p>
<p><span id="int_main_2" class="anchor"></span>int main() {</p>
<p>int&amp; r = getX();</p>
<p>std::cout &lt;&lt; r &lt;&lt; "<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>In this example, the local variable <del>x</del> goes out of scope
when <del>getX</del> returns. (Note that lifetime extension cannot</p>
<p>extend the lifetime of a local variable past the scope of the block
in which it is defined.) Therefore <del>r</del> is a dangling reference.
This program has undefined behavior, although it may appear to work and
print <del>42</del> in some cases.</p>
<p>Section 104.9: Integer division by zero</p>
<p>int x = 5 / 0; // Undefined behavior</p>
<p>Division by <del>0</del> is mathematically undefined, and as such it
makes sense that this is undefined behavior.</p>
<p>However:</p>
<p>float x = 5.0f / 0.0f; // x is +infinity</p>
<p>Most implementation implement IEEE-754, which defines floating point
division by zero to return <del>NaN</del> (if numerator</p>
<p>is <del>0.0f</del>), <del>infinity</del> (if numerator is positive)
or <del>-infinity</del> (if numerator is negative).</p>
<p>Section 104.10: Shifting by an invalid number of positions</p>
<p>For the built-in shift operator, the right operand must be
nonnegative and strictly less than the bit width of the</p>
<p>promoted left operand. Otherwise, the behavior is undefined.</p>
<p>const int a = 42;</p>
<p>const int b = a &lt;&lt;-1; // UB</p>
<p>const int c = a &lt;&lt; 0; // ok</p>
<p>const int d = a &lt;&lt; 32; // UB if int is 32 bits or less const
int e = a &gt;&gt; 32; // also UB if int is 32 bits or less const signed
char f = 'x';</p>
<p>const int g = f &lt;&lt; 10; // ok even if signed char is 10 bits or
less;</p>
<p>// int must be at least 16 bits</p>
<p>Section 104.11: Incorrect pairing of memory allocation and</p>
<p>deallocation</p>
<p>An object can only be deallocated by <del>delete</del> if it was
allocated by <del>new</del> and is not an array. If the argument to
<del>delete</del></p>
<p>was not returned by <del>new</del> or is an array, the behavior is
undefined.</p>
<p>An object can only be deallocated by <del>delete[]</del> if it was
allocated by <del>new</del> and is an array. If the argument to
<del>delete[]</del></p>
<p>was not returned by <del>new</del> or is not an array, the behavior
is undefined.</p>
<p>If the argument to <del>free</del> was not returned by
<del>malloc</del>, the behavior is undefined.</p>
<p>int* p1 = new int;</p>
<p>delete p1; // correct</p>
<p>// delete[] p1; // undefined</p>
<p>// free(p1); // undefined</p>
<p>int* p2 = new int[10];</p>
<p>delete[] p2; // correct</p>
<p>// delete p2; // undefined</p>
<p>// free(p2); // undefined</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 526</p>
<p><span id="int__p3___static_cast_malloc_siz"
class="anchor"></span><del>int* p3 =
static_cast</del>(malloc(sizeof(int)));</p>
<p>free(p3); // correct</p>
<p>// delete p3; // undefined</p>
<p>// delete[] p3; // undefined</p>
<p>Such issues can be avoided by completely avoiding <del>malloc</del>
and <del>free</del> in C++ programs, preferring the standard</p>
<p>library smart pointers over raw <del>new</del> and <del>delete</del>,
and preferring <del>std::vector</del> and <del>std::string</del> over
raw <del>new</del> and <del>delete[]</del>.</p>
<p>Section 104.12: Signed Integer Overflow</p>
<p>int x = INT_MAX + 1;</p>
<p>// x can be anything -&gt; Undefined behavior</p>
<p>If during the evaluation of an expression, the result is not
mathematically defined or not in the range of representable values for
its type, the behavior is undefined.</p>
<p>(C++11 Standard paragraph 5/4)</p>
<p>This is one of the more nasty ones, as it usually yields
reproducible, non-crashing behavior so developers may be</p>
<p>tempted to rely heavily on the observed behavior.</p>
<p>On the other hand:</p>
<p>unsigned int x = UINT_MAX + 1;</p>
<p>// x is 0</p>
<p>is well defined since:</p>
<p>Unsigned integers, declared unsigned, shall obey the laws of
arithmetic modulo <del>2^n</del> where <del>n</del> is the number of
bits in the value representation of that particular size of integer.</p>
<p>(C++11 Standard paragraph 3.9.1/4)</p>
<p>Sometimes compilers may exploit an undefined behavior and
optimize</p>
<p>signed int x ;</p>
<p>if(x &gt; x + 1)</p>
<p>{</p>
<p>//do something</p>
<p>}</p>
<p>Here since a signed integer overflow is not defined, compiler is free
to assume that it may never happen and hence it can optimize away the
"if" block</p>
<p>Section 104.13: Multiple non-identical definitions (the One</p>
<p>Definition Rule)</p>
<p>If a class, enum, inline function, template, or member of a template
has external linkage and is defined in multiple</p>
<p><a
href="https://en.wikipedia.org/wiki/One_Definition_Rule">translation
units, all definitions must be identical or the behavior is undefined
according to the One Definition Rule</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 527</p>
<p><span id="_ODR" class="anchor"></span><a
href="https://en.wikipedia.org/wiki/One_Definition_Rule">(ODR)</a>.</p>
<p>foo.h<del>:</del></p>
<p>class Foo {</p>
<p>public:</p>
<p>double x;</p>
<p>private:</p>
<p>int y;</p>
<p>};</p>
<p>Foo get_foo();</p>
<p>foo.cpp<del>:</del></p>
<p>#include "foo.h"</p>
<p><del>Foo get_foo() {</del> /* implementation */ <del>}</del></p>
<p>main.cpp<del>:</del></p>
<p>// I want access to the private member, so I am going to replace Foo
with my own type class Foo {</p>
<p>public:</p>
<p>double x;</p>
<p>int y;</p>
<p>};</p>
<p>Foo get_foo(); // declare this function ourselves since we aren't
including foo.h int main() {</p>
<p>Foo foo = get_foo();</p>
<p>// do something with foo.y</p>
<p>}</p>
<p>The above program exhibits undefined behavior because it contains two
definitions of the class <del>::Foo</del>, which has</p>
<p>external linkage, in different translation units, but the two
definitions are not identical. Unlike redefinition of a class within the
same translation unit, this problem is not required to be diagnosed by
the compiler.</p>
<p>Section 104.14: Modifying a const object</p>
<p>Any attempt to modify a <del>const</del> object results in undefined
behavior. This applies to <del>const</del> variables, members of const
objects, and class members declared <del>const</del>. (However, a
<del>mutable</del> member of a <del>const</del> object is not
<del>const</del>.)</p>
<p>Such an attempt can be made through <del>const_cast</del>:</p>
<p>const int x = 123;</p>
<p>const_cast<del>(x) = 456;</del></p>
<p>std::cout &lt;&lt; x &lt;&lt; '<strong><del>\n</del></strong>';</p>
<p>A compiler will usually inline the value of a <del>const int</del>
object, so it's possible that this code compiles and prints
<del>123</del>.</p>
<p>Compilers can also place <del>const</del> objects' values in
read-only memory, so a segmentation fault may occur. In any</p>
<p>case, the behavior is undefined and the program might do
anything.</p>
<p>The following program conceals a far more subtle error:</p>
<p>#include</p>
<p>class Foo* instance;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 528</p>
<p><span id="class_Foo" class="anchor"></span>class Foo {</p>
<p>public:</p>
<p>int get_x() const { return m_x; }</p>
<p>void set_x(int x) { m_x = x; }</p>
<p>private:</p>
<p>Foo(int x, Foo*&amp; this_ref): m_x(x) {</p>
<p>this_ref = this;</p>
<p>}</p>
<p>int m_x;</p>
<p>friend const Foo&amp; getFoo();</p>
<p>};</p>
<p>const Foo&amp; getFoo() {</p>
<p>static const Foo foo(123, instance);</p>
<p>return foo;</p>
<p>}</p>
<p>void do_evil(int x) {</p>
<p>instance-&gt;set_x(x);</p>
<p>}</p>
<p>int main() {</p>
<p>const Foo&amp; foo = getFoo();</p>
<p>do_evil(456);</p>
<p>std::cout &lt;&lt; foo.get_x() &lt;&lt;
'<strong><del>\n</del></strong>';</p>
<p>}</p>
<p>In this code, <del>getFoo</del> creates a singleton of type
<del>const Foo</del> and its member <del>m_x</del> is initialized to
<del>123</del>. Then <del>do_evil</del> is</p>
<p>called and the value of <del>foo.m_x</del> is apparently changed to
456. What went wrong?</p>
<p>Despite its name, <del>do_evil</del> does nothing particularly evil;
all it does is call a setter through a <del>Foo*</del>. But that
pointer</p>
<p>points to a <del>const Foo</del> object even though
<del>const_cast</del> was not used. This pointer was obtained through
<del>Foo</del>'s</p>
<p>constructor. A <del>const</del> object does not become
<del>const</del> until its initialization is complete, so
<del>this</del> has type <del>Foo*</del>, not <del>const Foo*</del> ,
within the constructor.</p>
<p>Therefore, undefined behavior occurs even though there are no
obviously dangerous constructs in this program.</p>
<p>Section 104.15: Returning from a [[noreturn]] function</p>
<p>Version ≥ C++11</p>
<p>Example from the Standard, [dcl.attr.noreturn]:</p>
<p>[[ noreturn ]] void f() {</p>
<p>throw "error"; // OK</p>
<p>}</p>
<p>[[ noreturn ]] void q(int i) { // behavior is undefined if called
with an argument &lt;= 0</p>
<p>if (i &gt; 0)</p>
<p>throw "positive";</p>
<p>}</p>
<p>Section 104.16: Infinite template recursion</p>
<p>Example from the Standard, [temp.inst]/17:</p>
<p><del>template</del> class X {</p>
<p><del>X</del>* p; // OK</p>
<p><del>X</del> a; // implicit generation of X requires</p>
<p>// the implicit instantiation of X <del>which requires</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 529</p>
<p><span id="___the_implicit_instantiation_of" class="anchor"></span>//
the implicit instantiation of X <del>which ...</del></p>
<p>};</p>
<p>Section 104.17: Overflow during conversion to or from</p>
<p>floating point type</p>
<p>If, during the conversion of:</p>
<p>an integer type to a floating point type,</p>
<p>a floating point type to an integer type, or</p>
<p>a floating point type to a shorter floating point type,</p>
<p>the source value is outside the range of values that can be
represented in the destination type, the result is</p>
<p>undefined behavior. Example:</p>
<p>double x = 1e100;</p>
<p>int y = x; // int probably cannot hold numbers that large, so this is
UB</p>
<p>Section 104.18: Modifying a string literal</p>
<p>Version &lt; C++11</p>
<p>char *str = "hello world";</p>
<p>str[0] = 'H';</p>
<p><del>"hello world"</del> is a string literal, so modifying it gives
undefined behaviour.</p>
<p>The initialisation of <del>str</del> in the above example was
formally deprecated (scheduled for removal from a future version of the
standard) in C++03. A number of compilers before 2003 might issue a
warning about this (e.g. a</p>
<p>suspicious conversion). After 2003, compilers typically warn about a
deprecated conversion.</p>
<p>Version ≥ C++11</p>
<p>The above example is illegal, and results in a compiler diagnostic,
in C++11 and later. A similar example may be constructed to exhibit
undefined behaviour by explicitly permitting the type conversion, such
as:</p>
<p>char *str = const_cast<del>("hello world");</del></p>
<p>str[0] = 'H';</p>
<p>Section 104.19: Accessing an object as the wrong type</p>
<p>In most cases, it is illegal to access an object of one type as
though it were a different type (disregarding cv-qualifiers).
Example:</p>
<p>float x = 42;</p>
<p>int y = reinterpret_cast<del>(x);</del></p>
<p>The result is undefined behavior.</p>
<p>There are some exceptions to this strict aliasing rule:</p>
<p>An object of class type can be accessed as though it were of a type
that is a base class of the actual class type.</p>
<p>Any type can be accessed as a <del>char</del> or <del>unsigned
char</del>, but the reverse is not true: a char array cannot be accessed
as though it were an arbitrary type.</p>
<p>A signed integer type can be accessed as the corresponding unsigned
type and vice versa.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 530</p>
<p><span id="A_related_rule_is_that_if_a_non" class="anchor"></span>A
related rule is that if a non-static member function is called on an
object that does not actually have the same type as the defining class
of the function, or a derived class, then undefined behavior occurs.
This is true even if the</p>
<p>function does not access the object.</p>
<p>struct Base {</p>
<p>};</p>
<p>struct Derived : Base {</p>
<p>void f() {}</p>
<p>};</p>
<p>struct Unrelated {};</p>
<p>Unrelated u;</p>
<p>Derived&amp; r1 = reinterpret_cast<del>(u); // ok</del></p>
<p>r1.f(); // UB</p>
<p>Base b;</p>
<p>Derived&amp; r2 = reinterpret_cast<del>(b); // ok</del></p>
<p>r2.f(); // UB</p>
<p>Section 104.20: Invalid derived-to-base conversion for</p>
<p>pointers to members</p>
<p>When <del>static_cast</del> is used to convert <del>T D::*</del> to
<del>T B::*</del>, the member pointed to must belong to a class that is
a</p>
<p>base class or derived class of <del>B</del>. Otherwise the behavior
is undefined. See Derived to base conversion for pointers to members</p>
<p>Section 104.21: Destroying an object that has already been</p>
<p>destroyed</p>
<p>In this example, a destructor is explicitly invoked for an object
that will later be automatically destroyed.</p>
<p>struct S {</p>
<p>~S() { std::cout &lt;&lt; "destroying
S<strong><del>\n</del></strong>"; }</p>
<p>};</p>
<p>int main() {</p>
<p>S s;</p>
<p>s.~S();</p>
<p>} // UB: s destroyed a second time here</p>
<p>A similar issue occurs when a <del>std::unique_ptr</del> is made to
point at a T with automatic or static storage duration.</p>
<p>void f(std::unique_ptr p);</p>
<p>int main() {</p>
<p>S s;</p>
<p>std::unique_ptr p(&amp;s);</p>
<p>f(std::move(p)); // s destroyed upon return from f } // UB: s
destroyed</p>
<p>Another way to destroy an object twice is by having two
<del>shared_ptr</del>s both manage the object without sharing</p>
<p>ownership with each other.</p>
<p>void f(std::shared_ptr p1, std::shared_ptr p2); int main() {</p>
<p>S* p = new S;</p>
<p>// I want to pass the same object twice...</p>
<p>std::shared_ptr sp1(p);</p>
<p>std::shared_ptr sp2(p);</p>
<p>f(sp1, sp2);</p>
<p>} // UB: both sp1 and sp2 will destroy s separately</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 531</p>
<p><span id="___NB__this_is_correct" class="anchor"></span>// NB: this
is correct:</p>
<p>// std::shared_ptr sp(p);</p>
<p>// f(sp, sp);</p>
<p>Section 104.22: Access to nonexistent member through</p>
<p>pointer to member</p>
<p>When accessing a non-static member of an object through a pointer to
member, if the object does not actually</p>
<p>contain the member denoted by the pointer, the behavior is undefined.
(Such a pointer to member can be obtained through
<del>static_cast</del>.)</p>
<p>struct Base { int x; };</p>
<p>struct Derived : Base { int y; };</p>
<p>int Derived::*pdy = &amp;Derived::y;</p>
<p>int Base::*pby = static_cast<del>(pdy);</del></p>
<p>Base* b1 = new Derived;</p>
<p>b1-&gt;*pby = 42; // ok; sets y in Derived object to 42 Base* b2 =
new Base;</p>
<p>b2-&gt;*pby = 42; // undefined; there is no y member in Base</p>
<p>Section 104.23: Invalid base-to-derived static cast</p>
<p>If <del>static_cast</del> is used to convert a pointer (resp.
reference) to base class to a pointer (resp. reference) to derived
class, but the operand does not point (resp. refer) to an object of the
derived class type, the behavior is undefined.</p>
<p>See Base to derived conversion.</p>
<p>Section 104.24: Floating point overflow</p>
<p>If an arithmetic operation that yields a floating point type produces
a value that is not in the range of representable</p>
<p>values of the result type, the behavior is undefined according to the
C++ standard, but may be defined by other standards the machine might
conform to, such as IEEE 754.</p>
<p>float x = 1.0;</p>
<p>for (int i = 0; i &lt; 10000; i++) {</p>
<p>x *= 10.0; // will probably overflow eventually; undefined behavior
}</p>
<p>Section 104.25: Calling (Pure) Virtual Members From</p>
<p>Constructor Or Destructor</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf">The
Standard (10.4) states:</a></p>
<p>Member functions can be called from a constructor (or destructor) of
an abstract class; the effect of</p>
<p>making a virtual call (10.3) to a pure virtual function directly or
indirectly for the object being created (or destroyed) from such a
constructor (or destructor) is undefined.</p>
<p><a href="http://www.artima.com/cppsource/nevercall.html">More
generally, some C++ authorities, e.g. Scott Meyers, suggest</a> never
calling virtual functions (even non-pure</p>
<p>ones) from constructors and dstructors.</p>
<p>Consider the following example, modified from the above link:</p>
<p>class transaction</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 532</p>
<p><span id="_42" class="anchor"></span>{</p>
<p>public:</p>
<p>transaction(){ log_it(); }</p>
<p>virtual void log_it() const = 0;</p>
<p>};</p>
<p>class sell_transaction : public transaction</p>
<p>{</p>
<p>public:</p>
<p>virtual void log_it() const { <del>/* Do something */</del> }</p>
<p>};</p>
<p>Suppose we create a <del>sell_transaction</del> object:</p>
<p>sell_transaction s;</p>
<p>This implicitly calls the constructor of <del>sell_transaction</del>,
which first calls the constructor of <del>transaction</del>. When
the</p>
<p>constructor of <del>transaction</del> is called though, the object is
not yet of the type <del>sell_transaction</del>, but rather only of the
type <del>transaction</del>.</p>
<p>Consequently, the call in <del>transaction::transaction()</del> to
<del>log_it</del>, won't do what might seem to be the intuitive thing -
namely call <del>sell_transaction::log_it</del>.</p>
<p>If <del>log_it</del> is pure virtual, as in this example, the
behaviour is undefined.</p>
<p>If <del>log_it</del> is non-pure virtual,
<del>transaction::log_it</del> will be called.</p>
<p>Section 104.26: Function call through mismatched function</p>
<p>pointer type</p>
<p>In order to call a function through a function pointer, the function
pointer's type must exactly match the function's</p>
<p>type. Otherwise, the behaviour is undefined. Example:</p>
<p>int f();</p>
<p>void (*p)() = reinterpret_cast<del>(f);</del></p>
<p>p(); // undefined</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 533</p>
<p><span id="Chapter_105__Overload_resolution_1"
class="anchor"></span>Chapter 105: Overload resolution</p>
<p>Section 105.1: Categorization of argument to parameter cost</p>
<p>Overload resolution partitions the cost of passing an argument to a
parameter into one of four different categorizes, called "sequences".
Each sequence may include zero, one or several conversions</p>
<p>Standard conversion sequence</p>
<p>void f(int a); f(42);</p>
<p>User defined conversion sequence</p>
<p>void f(std::string s); f("hello");</p>
<p>Ellipsis conversion sequence</p>
<p>void f(...); f(42);</p>
<p>List initialization sequence</p>
<p>void f(std::vector <del>v); f({1, 2, 3});</del></p>
<p>The general principle is that Standard conversion sequences are the
cheapest, followed by user defined conversion</p>
<p>sequences, followed by ellipsis conversion sequences.</p>
<p>A special case is the list initialization sequence, which does not
constitute a conversion (an initializer list is not an</p>
<p>expression with a type). Its cost is determined by defining it to be
equivalent to one of the other three conversion sequences, depending on
the parameter type and form of initializer list.</p>
<p>Section 105.2: Arithmetic promotions and conversions</p>
<p>Converting an integer type to the corresponding promoted type is
better than converting it to some other integer</p>
<p>type.</p>
<p>void f(int x);</p>
<p>void f(short x);</p>
<p>signed char c = 42;</p>
<p>f(c); // calls f(int); promotion to int is better than conversion to
short short s = 42;</p>
<p>f(s); // calls f(short); exact match is better than promotion to
int</p>
<p>Promoting a <del>float</del> to <del>double</del> is better than
converting it to some other floating point type.</p>
<p>void f(double x);</p>
<p>void f(long double x);</p>
<p>f(3.14f); // calls f(double); promotion to double is better than
conversion to long double</p>
<p>Arithmetic conversions other than promotions are neither better nor
worse than each other.</p>
<p>void f(float x);</p>
<p>void f(long double x);</p>
<p>f(3.14); // ambiguous</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 534</p>
<p><span id="void_g_long_x" class="anchor"></span>void g(long x);</p>
<p>void g(long double x);</p>
<p>g(42); // ambiguous</p>
<p>g(3.14); // ambiguous</p>
<p>Therefore, in order to ensure that there will be no ambiguity when
calling a function <del>f</del> with either integral or</p>
<p>floating-point arguments of any standard type, a total of eight
overloads are needed, so that for each possible argument type, either an
overload matches exactly or the unique overload with the promoted
argument type will</p>
<p>be selected.</p>
<p>void f(int x);</p>
<p>void f(unsigned int x);</p>
<p>void f(long x);</p>
<p>void f(unsigned long x);</p>
<p>void f(long long x);</p>
<p>void f(unsigned long long x);</p>
<p>void f(double x);</p>
<p>void f(long double x);</p>
<p>Section 105.3: Overloading on Forwarding Reference</p>
<p>You must be very careful when providing a forwarding reference
overload as it may match too well:</p>
<p>struct A {</p>
<p>A() = default; // #1</p>
<p>A(A const&amp; ) = default; // #2</p>
<p>template</p>
<p>A(T&amp;&amp; ); // #3</p>
<p>};</p>
<p>The intent here was that <del>A</del> is copyable, and that we have
this other constructor that might initialize some other member.
However:</p>
<p>A a; // calls #1</p>
<p>A b(a); // calls #3!</p>
<p>There are two viable matches for the construction call:</p>
<p>A(A const&amp; ); // #2</p>
<p>A(A&amp; ); // #3, with T = A&amp;</p>
<p>Both are Exact Matches, but <del>#3</del> takes a reference to a less
cv-qualified object than <del>#2</del> does, so it has the better
standard conversion sequence and is the best viable function.</p>
<p>The solution here is to always constrain these constructors (e.g.
using SFINAE):</p>
<p>template</p>
<p>class = std::enable_if_t*, A*&gt;::value&gt; &gt;</p>
<p>A(T&amp;&amp; );</p>
<p>The type trait here is to exclude any <del>A</del> or class publicly
and unambiguously derived from <del>A</del> from consideration,</p>
<p>which would make this constructor ill-formed in the example described
earlier (and hence removed from the overload set). As a result, the copy
constructor is invoked - which is what we wanted.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 535</p>
<p><span id="Section_105_4__Exact_match" class="anchor"></span>Section
105.4: Exact match</p>
<p>An overload without conversions needed for parameter types or only
conversions needed between types that are</p>
<p>still considered exact matches is preferred over an overload that
requires other conversions in order to call.</p>
<p>void f(int x);</p>
<p>void f(double x);</p>
<p>f(42); // calls f(int)</p>
<p>When an argument binds to a reference to the same type, the match is
considered to not require a conversion even if the reference is more
cv-qualified.</p>
<p>void f(int&amp; x);</p>
<p>void f(double x);</p>
<p>int x = 42;</p>
<p>f(x); // argument type is int; exact match with int&amp;</p>
<p>void g(const int&amp; x);</p>
<p>void g(int x);</p>
<p>g(x); // ambiguous; both overloads give exact match</p>
<p>For the purposes of overload resolution, the type "array of
<del>T</del>" is considered to match exactly with the type "pointer to
<del>T</del>", and the function type <del>T</del> is considered to match
exactly with the function pointer type <del>T*</del>, even though
both</p>
<p>require conversions.</p>
<p>void f(int* p);</p>
<p>void f(void* p);</p>
<p>void g(int* p);</p>
<p>void g(int (&amp;p)[100]);</p>
<p>int a[100];</p>
<p>f(a); // calls f(int*); exact match with array-to-pointer conversion
g(a); // ambiguous; both overloads give exact match</p>
<p>Section 105.5: Overloading on constness and volatility</p>
<p>Passing a pointer argument to a <del>T*</del> parameter, if possible,
is better than passing it to a <del>const T*</del> parameter.</p>
<p>struct Base {};</p>
<p>struct Derived : Base {};</p>
<p>void f(Base* pb);</p>
<p>void f(const Base* pb);</p>
<p>void f(const Derived* pd);</p>
<p>void f(bool b);</p>
<p>Base b;</p>
<p>f(&amp;b); // f(Base*) is better than f(const Base*)</p>
<p>Derived d;</p>
<p>f(&amp;d); // f(const Derived*) is better than f(Base*) though;</p>
<p>// constness is only a "tie-breaker" rule</p>
<p>Likewise, passing an argument to a <del>T&amp;</del> parameter, if
possible, is better than passing it to a <del>const T&amp;</del>
parameter,</p>
<p>even if both have exact match rank.</p>
<p>void f(int&amp; r);</p>
<p>void f(const int&amp; r);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 536</p>
<p><span id="int_x" class="anchor"></span>int x;</p>
<p>f(x); // both overloads match exactly, but f(int&amp;) is still
better const int y = 42;</p>
<p>f(y); // only f(const int&amp;) is viable</p>
<p>This rule applies to const-qualified member functions as well, where
it is important for allowing mutable access to</p>
<p>non-const objects and immutable access to const objects.</p>
<p>class IntVector {</p>
<p>public:</p>
<p>// ...</p>
<p>int* data() { return m_data; }</p>
<p>const int* data() const { return m_data; }</p>
<p>private:</p>
<p>// ...</p>
<p>int* m_data;</p>
<p>};</p>
<p>IntVector v1;</p>
<p>int* data1 = v1.data(); // Vector::data() is better than
Vector::data() const;</p>
<p>// data1 can be used to modify the vector's data</p>
<p>const IntVector v2;</p>
<p>const int* data2 = v2.data(); // only Vector::data() const is
viable;</p>
<p>// data2 can't be used to modify the vector's data</p>
<p>In the same way, a volatile overload will be less preferred than a
non-volatile overload.</p>
<p>class AtomicInt {</p>
<p>public:</p>
<p>// ...</p>
<p>int load();</p>
<p>int load() volatile;</p>
<p>private:</p>
<p>// ...</p>
<p>};</p>
<p>AtomicInt a1;</p>
<p>a1.load(); // non-volatile overload preferred; no side effect
volatile AtomicInt a2;</p>
<p>a2.load(); // only volatile overload is viable; side effect
static_cast<del>(a1).load(); // force volatile semantics for
a1</del></p>
<p>Section 105.6: Name lookup and access checking</p>
<p>Overload resolution occurs after name lookup. This means that a
better-matching function will not be selected by overload resolution if
it loses name lookup:</p>
<p>void f(int x);</p>
<p>struct S {</p>
<p>void f(double x);</p>
<p>void g() { f(42); } // calls S::f because global f is not visible
here,</p>
<p>// even though it would be a better match</p>
<p>};</p>
<p>Overload resolution occurs before access checking. An inaccessible
function might be selected by overload</p>
<p>resolution if it is a better match than an accessible function.</p>
<p>class C {</p>
<p>public:</p>
<p>static void f(double x);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 537</p>
<p><span id="private_1" class="anchor"></span>private:</p>
<p>static void f(int x);</p>
<p>};</p>
<p>C::f(42); // Error! Calls private C::f(int) even though public
C::f(double) is viable.</p>
<p>Similarly, overload resolution happens without checking whether the
resulting call is well-formed with regards to</p>
<p>explicit <del>:</del></p>
<p>struct X {</p>
<p>explicit X(int );</p>
<p>X(char );</p>
<p>};</p>
<p>void foo(X );</p>
<p>foo({4}); // X(int) is better much, but expression is</p>
<p>// ill-formed because selected constructor is explicit</p>
<p>Section 105.7: Overloading within a class hierarchy</p>
<p>The following examples will use this class hierarchy:</p>
<p>struct A { int m; };</p>
<p>struct B : A {};</p>
<p>struct C : B {};</p>
<p>The conversion from derived class type to base class type is
preferred to user-defined conversions. This applies when passing by
value or by reference, as well as when converting pointer-to-derived to
pointer-to-base.</p>
<p>struct Unrelated {</p>
<p>Unrelated(B b);</p>
<p>};</p>
<p>void f(A a);</p>
<p>void f(Unrelated u);</p>
<p>B b;</p>
<p>f(b); // calls f(A)</p>
<p>A pointer conversion from derived class to base class is also better
than conversion to <del>void*</del>.</p>
<p>void f(A* p);</p>
<p>void f(void* p);</p>
<p>B b;</p>
<p>f(&amp;b); // calls f(A*)</p>
<p>If there are multiple overloads within the same chain of inheritance,
the most derived base class overload is</p>
<p>preferred. This is based on a similar principle as virtual dispatch:
the "most specialized" implementation is chosen. However, overload
resolution always occurs at compile time and will never implicitly
down-cast.</p>
<p>void f(const A&amp; a);</p>
<p>void f(const B&amp; b);</p>
<p>C c;</p>
<p>f(c); // calls f(const B&amp;)</p>
<p>B b;</p>
<p>A&amp; r = b;</p>
<p>f(r); // calls f(const A&amp;); the f(const B&amp;) overload is not
viable</p>
<p>For pointers to members, which are contravariant with respect to the
class, a similar rule applies in the opposite</p>
<p>direction: the least derived derived class is preferred.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 538</p>
<p><span id="void_f_int_B___p" class="anchor"></span>void f(int
B::*p);</p>
<p>void f(int C::*p);</p>
<p>int A::*p = &amp;A::m;</p>
<p>f(p); // calls f(int B::*)</p>
<p>Section 105.8: Steps of Overload Resolution</p>
<p>The steps of overload resolution are:</p>
<p>1. Find candidate functions via name lookup. Unqualified calls will
perform both regular unqualified lookup as</p>
<p>well as argument-dependent lookup (if applicable).</p>
<p>2. Filter the set of candidate functions to a set of viable
functions. A viable function for which there exists an</p>
<p>implicit conversion sequence between the arguments the function is
called with and the parameters the</p>
<p>function takes.</p>
<p>void f(char); // (1)</p>
<p>void f(int ) = delete; // (2)</p>
<p>void f(); // (3)</p>
<p>void f(int&amp; ); // (4)</p>
<p>f(4); // 1,2 are viable (even though 2 is deleted!)</p>
<p>// 3 is not viable because the argument lists don't match // 4 is not
viable because we cannot bind a temporary to // a non-const lvalue
reference</p>
<p>3. Pick the best viable candidate. A viable function <del>F1</del> is
a better function than another viable function <del>F2</del> if the</p>
<p>implicit conversion sequence for each argument in <del>F1</del> is
not worse than the corresponding implicit</p>
<p>conversion sequence in <del>F2</del>, and...:</p>
<p>3.1. For some argument, the implicit conversion sequence for that
argument in <del>F1</del> is a better conversion sequence than for that
argument in <del>F2</del>, or</p>
<p>void f(int ); // (1)</p>
<p>void f(char ); // (2)</p>
<p>f(4); // call (1), better conversion sequence</p>
<p>3.2. In a user-defined conversion, the standard conversion sequence
from the return of <del>F1</del> to the destination</p>
<p>type is a better conversion sequence than that of the return type of
<del>F2</del>, or</p>
<p>struct A</p>
<p>{</p>
<p>operator int();</p>
<p>operator double();</p>
<p>} a;</p>
<p>int i = a; // a.operator int() is better than a.operator double() and
a conversion float f = a; // ambiguous</p>
<p>3.3. In a direct reference binding, <del>F1</del> has the same kind
of reference by <del>F2</del> is not, or</p>
<p>struct A</p>
<p>{</p>
<p>operator X&amp;(); // #1</p>
<p>operator X&amp;&amp;(); // #2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 539</p>
<p>};</p>
<p>A a;</p>
<p>X&amp; lx = a; // calls #1</p>
<p>X&amp;&amp; rx = a; // calls #2</p>
<p>3.4. <del>F1</del> is not a function template specialization, but
<del>F2</del> is, or</p>
<p><del>template</del> void f(T ); // #1</p>
<p>void f(int ); // #2</p>
<p>f(42); // calls #2, the non-template</p>
<p>3.5. <del>F1</del> and <del>F2</del> are both function template
specializations, but <del>F1</del> is more specialized than
<del>F2</del>.</p>
<p><del>template</del> void f(T ); // #1</p>
<p><del>template</del> void f(T* ); // #2</p>
<p>int* p;</p>
<p>f(p); // calls #2, more specialized</p>
<p>The ordering here is significant. The better conversion sequence
check happens before the template vs non-template check. This leads to a
common error with overloading on forwarding reference:</p>
<p>struct A {</p>
<p>A(A const&amp; ); // #1</p>
<p>template</p>
<p>A(T&amp;&amp; ); // #2, not constrained</p>
<p>};</p>
<p>A a;</p>
<p>A b(a); // calls #2!</p>
<p>// #1 is not a template but #2 resolves to</p>
<p>// A(A&amp; ), which is a less cv-qualified reference than #1 //
which makes it a better implicit conversion sequence</p>
<p>If there's no single best viable candidate at the end, the call is
ambiguous:</p>
<p>void f(double ) { }</p>
<p>void f(float ) { }</p>
<p>f(42); // error: ambiguous</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 540</p>
<p><span id="Chapter_106__Move_Semantics_1"
class="anchor"></span>Chapter 106: Move Semantics</p>
<p>Section 106.1: Move semantics</p>
<p>Move semantics are a way of moving one object to another in C++. For
this, we empty the old object and place everything it had in the new
object.</p>
<p>For this, we must understand what an rvalue reference is. An rvalue
reference (<del>T&amp;&amp;</del> where T is the object type) is not
much different than a normal reference (<del>T&amp;</del>, now called
lvalue references). But they act as 2 different types, and so,</p>
<p>we can make constructors or functions that take one type or the
other, which will be necessary when dealing with move semantics.</p>
<p>The reason why we need two different types is to specify two
different behaviors. Lvalue reference constructors are related to
copying, while rvalue reference constructors are related to moving.</p>
<p>To move an object, we will use <del>std::move(obj)</del>. This
function returns an rvalue reference to the object, so that we can steal
the data from that object into a new one. There are several ways of
doing this which are discussed below.</p>
<p>Important to note is that the use of <del>std::move</del> creates
just an rvalue reference. In other words the statement</p>
<p>std::move(obj) does not change the content of obj, while <del>auto
obj2 = std::move(obj)</del> (possibly) does.</p>
<p>Section 106.2: Using std::move to reduce complexity from</p>
<p>O(n²) to O(n)</p>
<p>C++11 introduced core language and standard library support for
<strong>moving</strong> an object. The idea is that when an</p>
<p>object o is a temporary and one wants a logical copy, then its safe
to just pilfer o's resources, such as a dynamically allocated buffer,
leaving o logically empty but still destructible and copyable.</p>
<p>The core language support is mainly</p>
<p>the <strong>rvalue reference</strong> type builder
<del>&amp;&amp;</del>, e.g., <del>std::string&amp;&amp;</del> is an
rvalue reference to a <del>std::string</del>, indicating that that
referred to object is a temporary whose resources can just be pilfered
(i.e. moved)</p>
<p>special support for a <strong>move constructor</strong> <del>T(
T&amp;&amp; )</del>, which is supposed to efficiently move resources
from the</p>
<p>specified other object, instead of actually copying those resources,
and</p>
<p>special support for a <strong>move assignment operator</strong>
<del>auto operator=(T&amp;&amp;)-&gt; T&amp;</del>, which also is
supposed to</p>
<p>move from the source.</p>
<p>The standard library support is mainly the <del>std::move</del>
function template from the <strong>&lt;utility&gt;</strong> header. This
function</p>
<p>produces an rvalue reference to the specified object, indicating that
it can be moved from, just as if it were a temporary.</p>
<p>For a container actual copying is typically of O(n) complexity, where
n is the number of items in the container, while moving is O(1),
constant time. And for an algorithm that logically copies that container
n times, this can reduce the</p>
<p>complexity from the usually impractical O(n²) to just linear
O(n).</p>
<p>In his article <a
href="http://www.drdobbs.com/cpp/containters-that-never-change/240161543">“Containers
That Never Change” in Dr. Dobbs Journal in September 19 2013</a>, Andrew
Koenig presented an interesting example of algorithmic inefficiency when
using a style of programming where variables are</p>
<p>immutable after initialization. With this style loops are generally
expressed using recursion. And for some</p>
<p>algorithms such as generating a Collatz sequence, the recursion
requires logically copying a container:</p>
<p>// Based on an example by Andrew Koenig in his Dr. Dobbs Journal
article</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 541</p>
<p>// “Containers That Never Change” September 19, 2013, available at
//</p>
<p>// Includes here, e.g.</p>
<p>namespace my {</p>
<p>template&lt; class Item &gt;</p>
<p><del>using Vector_ =</del> /* E.g. std::vector&lt;Item&gt;
*/<del>;</del></p>
<p><del>auto concat( Vector_</del> const&amp; v, int const x )</p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>auto result{ v };</p>
<p>result.push_back( x );</p>
<p>return result;</p>
<p>}</p>
<p>auto collatz_aux( int const n, Vector_ <del>const&amp; result
)</del></p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>if( n == 1 )</p>
<p>{</p>
<p>return result;</p>
<p>}</p>
<p>auto const new_result = concat( result, n );</p>
<p>if( n % 2 == 0 )</p>
<p>{</p>
<p>return collatz_aux( n/2, new_result );</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>return collatz_aux( 3*n + 1, new_result );</p>
<p>}</p>
<p>}</p>
<p>auto collatz( int const n )</p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>assert( n != 0 );</p>
<p>return collatz_aux( n, Vector_<del>() );</del></p>
<p>}</p>
<p>} // namespace my</p>
<p>#include</p>
<p>using namespace std;</p>
<p>auto main()-&gt; int</p>
<p>{</p>
<p>for( int const x : my::collatz( 42 ) )</p>
<p>{</p>
<p>cout &lt;&lt; x &lt;&lt; ' ';</p>
<p>}</p>
<p>cout &lt;&lt; '<strong><del>\n</del></strong>';</p>
<p>}</p>
<p>Output:</p>
<p>42 21 64 32 16 8 4 2</p>
<p>The number of item copy operations due to copying of the vectors is
here roughly O(n²), since it's the sum 1 + 2 + 3</p>
<p>+ ... n.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 542</p>
<p>In concrete numbers, with g++ and Visual C++ compilers the above
invocation of <del>collatz(42)</del> resulted in a Collatz sequence of 8
items and 36 item copy operations (8*7/2 = 28, plus some) in vector copy
constructor calls.</p>
<p>All of these item copy operations can be removed by simply moving
vectors whose values are not needed anymore. To do this it's necessary
to remove <del>const</del> and reference for the vector type arguments,
passing the vectors by value.</p>
<p>The function returns are already automatically optimized. For the
calls where vectors are passed, and not used again further on in the
function, just apply <del>std::move</del> to move those buffers rather
than actually copying them:</p>
<p>using std::move;</p>
<p>auto concat( Vector_ <del>v, int const x )</del></p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>v.push_back( x );</p>
<p>// warning: moving a local object in a return statement prevents copy
elision [-Wpessimizing-</p>
<p>move]</p>
<p>// See
https://stackoverflow.com/documentation/c%2b%2b/2489/copy-elision //
return move( v );</p>
<p>return v;</p>
<p>}</p>
<p>auto collatz_aux( int const n, Vector_ <del>result )</del></p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>if( n == 1 )</p>
<p>{</p>
<p>return result;</p>
<p>}</p>
<p>auto new_result = concat( move( result ), n );</p>
<p>struct result; // Make absolutely sure no use of `result` after this.
if( n % 2 == 0 )</p>
<p>{</p>
<p>return collatz_aux( n/2, move( new_result ) );</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>return collatz_aux( 3*n + 1, move( new_result ) );</p>
<p>}</p>
<p>}</p>
<p>auto collatz( int const n )</p>
<p>-&gt; Vector_</p>
<p>{</p>
<p>assert( n != 0 );</p>
<p>return collatz_aux( n, Vector_<del>() );</del></p>
<p>}</p>
<p>Here, with g++ and Visual C++ compilers, the number of item copy
operations due to vector copy constructor invocations, was exactly
0.</p>
<p>The algorithm is necessarily still O(n) in the length of the Collatz
sequence produced, but this is a quite dramatic improvement: O(n²) →
O(n).</p>
<p>With some language support one could perhaps use moving and still
express and enforce the immutability of a variable between its
initialization and final move, after which any use of that variable
should be an error. Alas, as of</p>
<p>C++14 C++ does not support that. For loop-free code the no use after
move can be enforced via a re-declaration of</p>
<p>the relevant name as an incomplete <del>struct</del>, as with
<del>struct result;</del> above, but this is ugly and not likely to be
understood by other programmers; also the diagnostics can be quite
misleading.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 543</p>
<p><span id="Summing_up__the_C___language_and"
class="anchor"></span>Summing up, the C++ language and library support
for moving allows drastic improvements in algorithm complexity, but due
the support's incompleteness, at the cost of forsaking the code
correctness guarantees and</p>
<p>code clarity that <del>const</del> can provide.</p>
<p>For completeness, the instrumented vector class used to measure the
number of item copy operations due to copy constructor invocations:</p>
<p>template&lt; class Item &gt;</p>
<p>class Copy_tracking_vector</p>
<p>{</p>
<p>private:</p>
<p>static auto n_copy_ops()</p>
<p>-&gt; int&amp;</p>
<p>{</p>
<p>static int value;</p>
<p>return value;</p>
<p>}</p>
<p><del>vector</del> items_;</p>
<p>public:</p>
<p>static auto n()-&gt; int { return n_copy_ops(); }</p>
<p>void push_back( Item const&amp; o ) { items_.push_back( o ); } auto
begin() const { return items_.begin(); }</p>
<p>auto end() const { return items_.end(); }</p>
<p>Copy_tracking_vector(){}</p>
<p>Copy_tracking_vector( Copy_tracking_vector const&amp; other )</p>
<p>: items_( other.items_ )</p>
<p>{ n_copy_ops() += items_.size(); }</p>
<p>Copy_tracking_vector( Copy_tracking_vector&amp;&amp; other )</p>
<p>: items_( move( other.items_ ) )</p>
<p>{}</p>
<p>};</p>
<p>Section 106.3: Move constructor</p>
<p>Say we have this code snippet.</p>
<p>class A {</p>
<p>public:</p>
<p>int a;</p>
<p>int b;</p>
<p>A(const A &amp;other) {</p>
<p>this-&gt;a = other.a;</p>
<p>this-&gt;b = other.b;</p>
<p>}</p>
<p>};</p>
<p>To create a copy constructor, that is, to make a function that copies
an object and creates a new one, we normally</p>
<p>would choose the syntax shown above, we would have a constructor for
A that takes an reference to another object of type A, and we would copy
the object manually inside the method.</p>
<p>Alternatively, we could have written <del>A(const A &amp;) =
default;</del> which automatically copies over all members,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 544</p>
<p>making use of its copy constructor.</p>
<p>To create a move constructor, however, we will be taking an rvalue
reference instead of an lvalue reference, like</p>
<p>here.</p>
<p>class Wallet {</p>
<p>public:</p>
<p>int nrOfDollars;</p>
<p>Wallet() = default; //default ctor</p>
<p>Wallet(Wallet &amp;&amp;other) {</p>
<p>this-&gt;nrOfDollars = other.nrOfDollars;</p>
<p>other.nrOfDollars = 0;</p>
<p>}</p>
<p>};</p>
<p>Please notice that we set the old values to <del>zero</del>. The
default move constructor (<del>Wallet(Wallet&amp;&amp;) =
default;</del>)</p>
<p>copies the value of <del>nrOfDollars</del>, as it is a POD.</p>
<p>As move semantics are designed to allow 'stealing' state from the
original instance, it is important to consider how</p>
<p>the original instance should look like after this stealing. In this
case, if we would not change the value to zero we would have doubled the
amount of dollars into play.</p>
<p>Wallet a;</p>
<p>a.nrOfDollars = 1;</p>
<p>Wallet b (std::move(a)); //calling B(B&amp;&amp; other);</p>
<p>std::cout &lt;&lt; a.nrOfDollars &lt;&lt; std::endl; //0</p>
<p>std::cout &lt;&lt; b.nrOfDollars &lt;&lt; std::endl; //1</p>
<p>Thus we have move constructed an object from an old one.</p>
<p>While the above is a simple example, it shows what the move
constructor is intended to do. It becomes more useful</p>
<p>in more complex cases, such as when resource management is
involved.</p>
<p>// Manages operations involving a specified type.</p>
<p>// Owns a helper on the heap, and one in its memory (presumably on
the stack). // Both helpers are DefaultConstructible, CopyConstructible,
and MoveConstructible. template</p>
<p><del>template</del> typename HeapHelper,</p>
<p><del>template</del> typename StackHelper&gt;</p>
<p>class OperationsManager {</p>
<p>using MyType = OperationsManager<del>;</del></p>
<p><del>HeapHelper</del>* h_helper;</p>
<p>StackHelper <del>s_helper;</del></p>
<p>// ...</p>
<p>public:</p>
<p>// Default constructor &amp; Rule of Five.</p>
<p>OperationsManager() : h_helper(new HeapHelper<del>) {}</del></p>
<p>OperationsManager(const MyType&amp; other)</p>
<p><del>: h_helper(new HeapHelper</del>(*other.h_helper)),
s_helper(other.s_helper) {}</p>
<p>MyType&amp; operator=(MyType copy) {</p>
<p>swap(*this, copy);</p>
<p>return *this;</p>
<p>}</p>
<p>~OperationsManager() {</p>
<p>if (h_helper) { delete h_helper; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 545</p>
<p><span id="_44" class="anchor"></span>}</p>
<p>// Move constructor (without swap()).</p>
<p>// Takes other's HeapHelper<del>*.</del></p>
<p><del>// Takes other's StackHelper</del>, by forcing the use of
StackHelper's move constructor. // Replaces other's HeapHelper* with
nullptr, to keep other from deleting our shiny // new helper when it's
destroyed.</p>
<p>OperationsManager(MyType&amp;&amp; other) noexcept</p>
<p>: h_helper(other.h_helper),</p>
<p>s_helper(std::move(other.s_helper)) {</p>
<p>other.h_helper = nullptr;</p>
<p>}</p>
<p>// Move constructor (with swap()).</p>
<p>// Places our members in the condition we want other's to be in, then
switches members // with other.</p>
<p>// OperationsManager(MyType&amp;&amp; other) noexcept :
h_helper(nullptr) { // swap(*this, other);</p>
<p>// }</p>
<p>// Copy/move helper.</p>
<p>friend void swap(MyType&amp; left, MyType&amp; right) noexcept {</p>
<p>std::swap(left.h_helper, right.h_helper);</p>
<p>std::swap(left.s_helper, right.s_helper);</p>
<p>}</p>
<p>};</p>
<p>Section 106.4: Re-use a moved object</p>
<p>You can re-use a moved object:</p>
<p>void consumingFunction(std::vector <del>vec) {</del></p>
<p>// Some operations</p>
<p>}</p>
<p>int main() {</p>
<p>// initialize vec with 1, 2, 3, 4</p>
<p><del>std::vector</del> vec{1, 2, 3, 4};</p>
<p>// Send the vector by move</p>
<p>consumingFunction(std::move(vec));</p>
<p>// Here the vec object is in an indeterminate state. // Since the
object is not destroyed, we can assign it a new content. // We will, in
this case, assign an empty value to the vector, // making it effectively
empty</p>
<p>vec = {};</p>
<p>// Since the vector as gained a determinate value, we can use it
normally.</p>
<p>vec.push_back(42);</p>
<p>// Send the vector by move again.</p>
<p>consumingFunction(std::move(vec));</p>
<p>}</p>
<p>Section 106.5: Move assignment</p>
<p>Similarly to how we can assign a value to an object with an lvalue
reference, copying it, we can also move the values from an object to
another without constructing a new one. We call this move assignment. We
move the values from</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 546</p>
<p><span id="one_object_to_another_existing_o" class="anchor"></span>one
object to another existing object.</p>
<p>For this, we will have to overload <del>operator =</del>, not so that
it takes an lvalue reference, like in copy assignment, but</p>
<p>so that it takes an rvalue reference.</p>
<p>class A {</p>
<p>int a;</p>
<p>A&amp; operator= (A&amp;&amp; other) {</p>
<p>this-&gt;a = other.a;</p>
<p>other.a = 0;</p>
<p>return *this;</p>
<p>}</p>
<p>};</p>
<p>This is the typical syntax to define move assignment. We overload
<del>operator =</del> so that we can feed it an rvalue</p>
<p>reference and it can assign it to another object.</p>
<p>A a;</p>
<p>a.a = 1;</p>
<p>A b;</p>
<p>b = std::move(a); //calling A&amp; operator= (A&amp;&amp; other)
std::cout &lt;&lt; a.a &lt;&lt; std::endl; //0</p>
<p>std::cout &lt;&lt; b.a &lt;&lt; std::endl; //1</p>
<p>Thus, we can move assign an object to another one.</p>
<p>Section 106.6: Using move semantics on containers</p>
<p>You can move a container instead of copying it:</p>
<p>void print(const std::vector<del>&amp; vec) {</del></p>
<p>for (auto&amp;&amp; val : vec) {</p>
<p>std::cout &lt;&lt; val &lt;&lt; ", ";</p>
<p>}</p>
<p>std::cout &lt;&lt; std::endl;</p>
<p>}</p>
<p>int main() {</p>
<p>// initialize vec1 with 1, 2, 3, 4 and vec2 as an empty vector</p>
<p><del>std::vector</del> vec1{1, 2, 3, 4};</p>
<p>std::vector <del>vec2;</del></p>
<p>// The following line will print 1, 2, 3, 4</p>
<p>print(vec1);</p>
<p>// The following line will print a new line</p>
<p>print(vec2);</p>
<p>// The vector vec2 is assigned with move assingment. // This will
"steal" the value of vec1 without copying it.</p>
<p>vec2 = std::move(vec1);</p>
<p>// Here the vec1 object is in an indeterminate state, but still
valid. // The object vec1 is not destroyed,</p>
<p>// but there's is no guarantees about what it contains.</p>
<p>// The following line will print 1, 2, 3, 4</p>
<p>print(vec2);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 547</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 548</p>
<p><span id="Chapter_107__Pimpl_Idiom_1" class="anchor"></span>Chapter
107: Pimpl Idiom</p>
<p>Section 107.1: Basic Pimpl idiom</p>
<p>Version ≥ C++11</p>
<p>In the header file:</p>
<p>// widget.h</p>
<p><del>#include</del> // std::unique_ptr</p>
<p>#include</p>
<p>class Widget</p>
<p>{</p>
<p>public:</p>
<p>Widget();</p>
<p>~Widget();</p>
<p>void DoSomething();</p>
<p>private:</p>
<p>// the pImpl idiom is named after the typical variable name used //
ie, pImpl:</p>
<p>struct Impl; // forward declaration</p>
<p><del>std::experimental::propagate_const</del>&gt; pImpl; // ptr to
actual implementation</p>
<p>};</p>
<p>In the implementation file:</p>
<p>// widget.cpp</p>
<p>#include "widget.h"</p>
<p>#include "reallycomplextype.h" // no need to include this header
inside widget.h</p>
<p>struct Widget::Impl</p>
<p>{</p>
<p>// the attributes needed from Widget go here</p>
<p>ReallyComplexType rct;</p>
<p>};</p>
<p>Widget::Widget() :</p>
<p>pImpl(std::make_unique<del>())</del></p>
<p>{}</p>
<p>Widget::~Widget() = default;</p>
<p>void Widget::DoSomething()</p>
<p>{</p>
<p>// do the stuff here with pImpl</p>
<p>}</p>
<p>The <del>pImpl</del> contains the <del>Widget</del> state (or
some/most of it). Instead of the <del>Widget</del> description of state
being exposed in the header file, it can be only exposed within the
implementation.</p>
<p>pImpl stands for "pointer to implementation". The "real"
implementation of <del>Widget</del> is in the <del>pImpl</del>.</p>
<p>Danger: Note that for this to work with <del>unique_ptr</del>,
<del>~Widget()</del> must be implemented at a point in a file where
the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 549</p>
<p>Impl is fully visible. You can <del>=default</del> it there, but if
<del>=default</del> where <del>Impl</del> is undefined, the program may
easily become ill-formed, no diagnostic required.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 550</p>
<p><span id="Chapter_108__auto_1" class="anchor"></span>Chapter 108:
auto</p>
<p>Section 108.1: Basic auto sample</p>
<p>The keyword <del>auto</del> provides the auto-deduction of type of a
variable.</p>
<p>It is especially convenient when dealing with long type names:</p>
<p>std::map&lt; std::string, std::shared_ptr&lt; Widget &gt; &gt; table;
// C++98</p>
<p>std::map&lt; std::string, std::shared_ptr&lt; Widget &gt;
&gt;::iterator i = table.find( "42" ); // C++11/14/17</p>
<p>auto j = table.find( "42" );</p>
<p>with range-based for loops:</p>
<p><del>vector</del> v = {0, 1, 2, 3, 4, 5};</p>
<p>for(auto n: v)</p>
<p>std::cout &lt;&lt; n &lt;&lt; ' ';</p>
<p>with lambdas:</p>
<p>auto f = [](){ std::cout &lt;&lt;
"lambda<strong><del>\n</del></strong>"; };</p>
<p>f();</p>
<p>to avoid the repetition of the type:</p>
<p>auto w = std::make_shared&lt; Widget &gt;();</p>
<p>to avoid surprising and unnecessary copies:</p>
<p>auto myMap = std::map<del>();</del></p>
<p>myMap.emplace(1,3.14);</p>
<p><del>std::pair</del> const&amp; firstPair2 = *myMap.begin(); // copy!
auto const&amp; firstPair = *myMap.begin(); // no copy!</p>
<p>The reason for the copy is that the returned type is actually
<del>std::pair</del>!</p>
<p>Section 108.2: Generic lambda (C++14)</p>
<p>Version ≥ C++14</p>
<p>C++14 allows to use <del>auto</del> in lambda argument</p>
<p>auto print = [](const auto&amp; arg) { std::cout &lt;&lt; arg
&lt;&lt; std::endl; };</p>
<p>print(42);</p>
<p>print("hello world");</p>
<p>That lambda is mostly equivalent to</p>
<p>struct lambda {</p>
<p>template</p>
<p>auto operator ()(const T&amp; arg) const {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 551</p>
<p><span id="std__cout____arg____std__endl"
class="anchor"></span>std::cout &lt;&lt; arg &lt;&lt; std::endl;</p>
<p>}</p>
<p>};</p>
<p>and then</p>
<p>lambda print;</p>
<p>print(42);</p>
<p>print("hello world");</p>
<p>Section 108.3: auto and proxy objects</p>
<p>Sometimes <del>auto</del> may behave not quite as was expected by a
programmer. It type deduces the expression, even</p>
<p>when type deduction is not the right thing to do.</p>
<p>As an example, when proxy objects are used in the code:</p>
<p><del>std::vector</del> flags{true, true, false};</p>
<p>auto flag = flags[0];</p>
<p>flags.push_back(true);</p>
<p>Here <del>flag</del> would be not <del>bool</del>, but
<del>std::vector</del>::reference, since for bool specialization of
template vector the operator [] returns a proxy object with conversion
operator operator bool defined.</p>
<p>When <del>flags.push_back(true)</del> modifies the container, this
pseudo-reference could end up dangling, referring to an element that no
longer exists.</p>
<p>It also makes the next situation possible:</p>
<p>void foo(bool b);</p>
<p><del>std::vector</del> getFlags();</p>
<p>auto flag = getFlags()[5];</p>
<p>foo(flag);</p>
<p>The <del>vector</del> is discarded immediately, so <del>flag</del> is
a pseudo-reference to an element that has been discarded. The call to
<del>foo</del> invokes undefined behavior.</p>
<p>In cases like this you can declare a variable with <del>auto</del>
and initialize it by casting to the type you want to be deduced:</p>
<p>auto flag = static_cast<del>(getFlags()[5]);</del></p>
<p>but at that point, simply replacing <del>auto</del> with
<del>bool</del> makes more sense.</p>
<p>Another case where proxy objects can cause problems is expression
templates. In that case, the templates are sometimes not designed to
last beyond the current full-expression for efficiency sake, and using
the proxy object</p>
<p>on the next causes undefined behavior.</p>
<p>Section 108.4: auto and Expression Templates</p>
<p><del>auto</del> can also cause problems where expression templates
come into play:</p>
<p>auto mult(int c) {</p>
<p>return c * std::valarray<del>{1};</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 552</p>
<p><span id="_46" class="anchor"></span>}</p>
<p>auto v = mult(3);</p>
<p>std::cout &lt;&lt; v[0]; // some value that could be, but almost
certainly is not, 3.</p>
<p>The reason is that <del>operator*</del> on <del>valarray</del> gives
you a proxy object that refers to the <del>valarray</del> as a means of
lazy</p>
<p>evaluation. By using <del>auto</del>, you're creating a dangling
reference. Instead of <del>mult</del> had returned a
<del>std::valarray</del>, then the code would definitely print 3.</p>
<p>Section 108.5: auto, const, and references</p>
<p>The <del>auto</del> keyword by itself represents a value type,
similar to <del>int</del> or <del>char</del>. It can be modified with
the <del>const</del> keyword and the <del>&amp;</del> symbol to
represent a const type or a reference type, respectively. These
modifiers can be</p>
<p>combined.</p>
<p>In this example, <del>s</del> is a value type (its type will be
inferred as <del>std::string</del>), so each iteration of the
<del>for</del> loop copies a</p>
<p>string from the vector into <del>s</del>.</p>
<p><del>std::vector</del> strings = { "stuff", "things", "misc" };
for(auto s : strings) {</p>
<p>std::cout &lt;&lt; s &lt;&lt; std::endl;</p>
<p>}</p>
<p>If the body of the loop modifies <del>s</del> (such as by calling
<del>s.append(" and stuff")</del>), only this copy will be modified,
not</p>
<p>the original member of <del>strings</del>.</p>
<p>On the other hand, if <del>s</del> is declared with
<del>auto&amp;</del> it will be a reference type (inferred to be
<del>std::string&amp;</del>), so on each iteration of the loop it will
be assigned a reference to a string in the vector:</p>
<p>for(auto&amp; s : strings) {</p>
<p>std::cout &lt;&lt; s &lt;&lt; std::endl;</p>
<p>}</p>
<p>In the body of this loop, modifications to <del>s</del> will directly
affect the element of <del>strings</del> that it references.</p>
<p>Finally, if <del>s</del> is declared <del>const auto&amp;</del>, it
will be a const reference type, meaning that on each iteration of the
loop it will be assigned a const reference to a string in the
vector:</p>
<p>for(const auto&amp; s : strings) {</p>
<p>std::cout &lt;&lt; s &lt;&lt; std::endl;</p>
<p>}</p>
<p>Within the body of this loop, <del>s</del> cannot be modified (i.e.
no non-const methods can be called on it).</p>
<p>When using <del>auto</del> with range-based <del>for</del> loops, it
is generally good practice to use <del>const auto&amp;</del> if the loop
body will</p>
<p>not modify the structure being looped over, since this avoids
unnecessary copies.</p>
<p>Section 108.6: Trailing return type</p>
<p><del>auto</del> is used in the syntax for trailing return type:</p>
<p>auto main()-&gt; int {}</p>
<p>which is equivalent to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 553</p>
<p>int main() {}</p>
<p>Mostly useful combined with <del>decltype</del> to use parameters
instead of <del>std::declval</del>:</p>
<p>template</p>
<p>auto Add(const T1&amp; lhs, const T2&amp; rhs)-&gt; decltype(lhs +
rhs) { return lhs + rhs; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 554</p>
<p><span id="Chapter_109__Copy_Elision_1" class="anchor"></span>Chapter
109: Copy Elision</p>
<p>Section 109.1: Purpose of copy elision</p>
<p>There are places in the standard where an object is copied or moved
in order to initialize an object. Copy elision (sometimes called return
value optimization) is an optimization whereby, under certain specific
circumstances, a</p>
<p>compiler is permitted to avoid the copy or move even though the
standard says that it must happen.</p>
<p>Consider the following function:</p>
<p>std::string get_string()</p>
<p>{</p>
<p>return std::string("I am a string.");</p>
<p>}</p>
<p>According to the strict wording of the standard, this function will
initialize a temporary <del>std::string</del>, then</p>
<p>copy/move that into the return value object, then destroy the
temporary. The standard is very clear that this is how</p>
<p>the code is interpreted.</p>
<p>Copy elision is a rule that permits a C++ compiler to ignore the
creation of the temporary and its subsequent copy/destruction. That is,
the compiler can take the initializing expression for the temporary and
initialize the</p>
<p>function's return value from it directly. This obviously saves
performance.</p>
<p>However, it does have two visible effects on the user:</p>
<p>1. The type must have the copy/move constructor that would have been
called. Even if the compiler elides the</p>
<p>copy/move, the type must still be able to have been copied/moved.</p>
<p>2. Side-effects of copy/move constructors are not guaranteed in
circumstances where elision can happen.</p>
<p>Consider the following:</p>
<p>Version ≥ C++11</p>
<p>struct my_type</p>
<p>{</p>
<p>my_type() = default;</p>
<p>my_type(const my_type &amp;) {std::cout
&lt;&lt;"Copying<strong><del>\n</del></strong>";} my_type(my_type
&amp;&amp;) {std::cout
&lt;&lt;"Moving<strong><del>\n</del></strong>";}</p>
<p>};</p>
<p>my_type func()</p>
<p>{</p>
<p>return my_type();</p>
<p>}</p>
<p>What will calling <del>func</del> do? Well, it will never print
"Copying", since the temporary is an rvalue and <del>my_type</del> is
a</p>
<p>moveable type. So will it print "Moving"?</p>
<p>Without the copy elision rule, this would be required to always print
"Moving". But because the copy elision rule exists, the move constructor
may or may not be called; it is implementation-dependent.</p>
<p>And therefore, you cannot depend on the calling of copy/move
constructors in contexts where elision is possible.</p>
<p>Because elision is an optimization, your compiler may not support
elision in all cases. And regardless of whether</p>
<p>the compiler elides a particular case or not, the type must still
support the operation being elided. So if a copy</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 555</p>
<p><span id="construction_is_elided__the_type"
class="anchor"></span>construction is elided, the type must still have a
copy constructor, even though it will not be called.</p>
<p>Section 109.2: Guaranteed copy elision</p>
<p>Version ≥ C++17</p>
<p>Normally, elision is an optimization. While virtually every compiler
support copy elision in the simplest of cases,</p>
<p>having elision still places a particular burden on users. Namely, the
type who's copy/move is being elided must still have the copy/move
operation that was elided.</p>
<p>For example:</p>
<p>std::mutex a_mutex;</p>
<p>std::lock_guard <del>get_lock()</del></p>
<p>{</p>
<p>return std::lock_guard<del>(a_mutex);</del></p>
<p>}</p>
<p>This might be useful in cases where <del>a_mutex</del> is a mutex
that is privately held by some system, yet an external user</p>
<p>might want to have a scoped lock to it.</p>
<p>This is also not legal, because <del>std::lock_guard</del> cannot be
copied or moved. Even though virtually every C++</p>
<p>compiler will elide the copy/move, the standard still requires the
type to have that operation available.</p>
<p>Until C++17.</p>
<p>C++17 mandates elision by effectively redefining the very meaning of
certain expressions so that no copy/moving</p>
<p>takes place. Consider the above code.</p>
<p>Under pre-C++17 wording, that code says to create a temporary and
then use the temporary to copy/move into the</p>
<p>return value, but the temporary copy can be elided. Under C++17
wording, that does not create a temporary at all.</p>
<p>In C++17, any prvalue expression, when used to initialize an object
of the same type as the expression, does not</p>
<p>generate a temporary. The expression directly initializes that
object. If you return a prvalue of the same type as the return value,
then the type need not have a copy/move constructor. And therefore,
under C++17 rules, the above</p>
<p>code can work.</p>
<p>The C++17 wording works in cases where the prvalue's type matches the
type being initialized. So given <del>get_lock</del></p>
<p>above, this will also not require a copy/move:</p>
<p>std::lock_guard the_lock = get_lock();</p>
<p>Since the result of <del>get_lock</del> is a prvalue expression being
used to initialize an object of the same type, no copying or moving will
happen. That expression never creates a temporary; it is used to
directly initialize <del>the_lock</del>. There is</p>
<p>no elision because there is no copy/move to be elided elide.</p>
<p>The term "guaranteed copy elision" is therefore something of a
misnomer, but <a href="http://wg21.link/P0135">that is the name of the
feature as it</a></p>
<p><a href="http://wg21.link/P0135">is proposed for C++17
standardization. It does not guarantee elision at all; it</a> eliminates
the copy/move altogether, redefining C++ so that there never was a
copy/move to be elided.</p>
<p>This feature only works in cases involving a prvalue expression. As
such, this uses the usual elision rules:</p>
<p>std::mutex a_mutex;</p>
<p>std::lock_guard <del>get_lock()</del></p>
<p>{</p>
<p><del>std::lock_guard</del> my_lock(a_mutex);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 556</p>
<p><span id="__Do_stuff" class="anchor"></span>//Do stuff</p>
<p>return my_lock;</p>
<p>}</p>
<p>While this is a valid case for copy elision, C++17 rules do not
eliminate the copy/move in this case. As such, the type must still have
a copy/move constructor to use to initialize the return value. And since
<del>lock_guard</del> does not, this is</p>
<p>still a compile error. Implementations are allowed to refuse to elide
copies when passing or returning an object of trivially-copyable type.
This is to allow moving such objects around in registers, which some
ABIs might mandate in</p>
<p>their calling conventions.</p>
<p>struct trivially_copyable {</p>
<p>int a;</p>
<p>};</p>
<p>void foo (trivially_copyable a) {}</p>
<p>foo(trivially_copyable{}); //copy elision not mandated</p>
<p>Section 109.3: Parameter elision</p>
<p>When you pass an argument to a function, and the argument is a
prvalue expression of the function's parameter type, and this type is
not a reference, then the prvalue's construction can be elided.</p>
<p>void func(std::string str) { ... }</p>
<p>func(std::string("foo"));</p>
<p>This says to create a temporary <del>string</del>, then move it into
the function parameter <del>str</del>. Copy elision permits this</p>
<p>expression to directly create the object in <del>str</del>, rather
than using a temporary+move.</p>
<p>This is a useful optimization for cases where a constructor is
declared <del>explicit</del>. For example, we could have written the
above as <del>func("foo")</del>, but only because <del>string</del> has
an implicit constructor that converts from a <del>const</del></p>
<p>char* to a <del>string</del>. If that constructor was
<del>explicit</del>, we would be forced to use a temporary to call the
<del>explicit</del></p>
<p>constructor. Copy elision saves us from having to do a needless
copy/move.</p>
<p>Section 109.4: Return value elision</p>
<p>If you return a prvalue expression from a function, and the prvalue
expression has the same type as the function's return type, then the
copy from the prvalue temporary can be elided:</p>
<p>std::string func()</p>
<p>{</p>
<p>return std::string("foo");</p>
<p>}</p>
<p>Pretty much all compilers will elide the temporary construction in
this case.</p>
<p>Section 109.5: Named return value elision</p>
<p>If you return an lvalue expression from a function, and this
lvalue:</p>
<p>represents an automatic variable local to that function, which will
be destroyed after the <del>return</del></p>
<p>the automatic variable is not a function parameter</p>
<p>and the type of the variable is the same type as the function's
return type</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 557</p>
<p><span id="If_all_of_these_are_the_case__th" class="anchor"></span>If
all of these are the case, then the copy/move from the lvalue can be
elided:</p>
<p>std::string func()</p>
<p>{</p>
<p>std::string str("foo");</p>
<p>//Do stuff</p>
<p>return str;</p>
<p>}</p>
<p>More complex cases are eligible for elision, but the more complex the
case, the less likely the compiler will be to</p>
<p>actually elide it:</p>
<p>std::string func()</p>
<p>{</p>
<p>std::string ret("foo");</p>
<p>if(some_condition)</p>
<p>{</p>
<p>return "bar";</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>The compiler could still elide <del>ret</del>, but the chances of
them doing so go down.</p>
<p>As noted earlier, elision is not permitted for value parameters.</p>
<p>std::string func(std::string str)</p>
<p>{</p>
<p>str.assign("foo");</p>
<p>//Do stuff</p>
<p>return str; //No elision possible</p>
<p>}</p>
<p>Section 109.6: Copy initialization elision</p>
<p>If you use a prvalue expression to copy initialize a variable, and
that variable has the same type as the prvalue expression, then the
copying can be elided.</p>
<p>std::string str = std::string("foo");</p>
<p>Copy initialization effectively transforms this into <del>std::string
str("foo");</del> (there are minor differences).</p>
<p>This also works with return values:</p>
<p>std::string func()</p>
<p>{</p>
<p>return std::string("foo");</p>
<p>}</p>
<p>std::string str = func();</p>
<p>Without copy elision, this would provoke 2 calls to
<del>std::string</del>'s move constructor. Copy elision permits this to
call the move constructor 1 or zero times, and most compilers will opt
for the latter.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 558</p>
<p><span id="Chapter_110__Fold_Expressions_1"
class="anchor"></span>Chapter 110: Fold Expressions</p>
<p>Section 110.1: Unary Folds</p>
<p>Unary folds are used to fold parameter packs over a specific
operator. There are 2 kinds of unary folds:</p>
<p>Unary <strong>Left</strong> Fold <del>(... op pack)</del> which
expands as follows:</p>
<p>((Pack1 op Pack2) op ...) op PackN</p>
<p>Unary <strong>Right</strong> Fold <del>(pack op ...)</del> which
expands as follows:</p>
<p>Pack1 op (... (Pack(N-1) op PackN))</p>
<p>Here is an example</p>
<p>template</p>
<p>int sum(Ts... args)</p>
<p>{</p>
<p>return (... + args); //Unary left fold</p>
<p>//return (args + ...); //Unary right fold</p>
<p>// The two are equivalent if the operator is associative. // For +,
((1+2)+3) (left fold) == (1+(2+3)) (right fold) // For -, ((1-2)-3)
(left fold) != (1-(2-3)) (right fold)</p>
<p>}</p>
<p>int result = sum(1, 2, 3); // 6</p>
<p>Section 110.2: Binary Folds</p>
<p>Binary folds are basically unary folds, with an extra argument.</p>
<p>There are 2 kinds of binary folds:</p>
<p>Binary <strong>Left</strong> Fold - <del>(value op ... op pack)</del>
- Expands as follows:</p>
<p>(((Value op Pack1) op Pack2) op ...) op PackN</p>
<p>Binary <strong>Right</strong> Fold <del>(pack op ... op value)</del>
- Expands as follows:</p>
<p>Pack1 op (... op (Pack(N-1) op (PackN op Value)))</p>
<p>Here is an example:</p>
<p>template</p>
<p>int removeFrom(int num, Ts... args)</p>
<p>{</p>
<p>return (num - ... - args); //Binary left fold</p>
<p>// Note that a binary right fold cannot be used</p>
<p>// due to the lack of associativity of operator-</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 559</p>
<p><span id="int_result___removeFrom_1000__5" class="anchor"></span>int
result = removeFrom(1000, 5, 10, 15); //'result' is 1000 - 5 - 10 - 15 =
970</p>
<p>Section 110.3: Folding over a comma</p>
<p>It is a common operation to need to perform a particular function
over each element in a parameter pack. With C++11, the best we can do
is:</p>
<p>template</p>
<p>void print_all(std::ostream&amp; os, Ts const&amp;... args) {</p>
<p>using expander = int[];</p>
<p>(void)expander{0,</p>
<p>(void(os &lt;&lt; args), 0)...</p>
<p>};</p>
<p>}</p>
<p>But with a fold expression, the above simplifies nicely to:</p>
<p>template</p>
<p>void print_all(std::ostream&amp; os, Ts const&amp;... args) {</p>
<p>(void(os &lt;&lt; args), ...);</p>
<p>}</p>
<p>No cryptic boilerplate required.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 560</p>
<p><span id="Chapter_111__Unions_1" class="anchor"></span>Chapter 111:
Unions</p>
<p>Section 111.1: Undefined Behavior</p>
<p>union U {</p>
<p>int a;</p>
<p>short b;</p>
<p>float c;</p>
<p>};</p>
<p>U u;</p>
<p>u.a = 10;</p>
<p>if (u.b == 10) {</p>
<p>// this is undefined behavior since 'a' was the last member to be //
written to. A lot of compilers will allow this and might issue a //
warning, but the result will be "as expected"; this is a compiler //
extension and cannot be guaranteed across compilers (i.e. this is // not
compliant/portable code).</p>
<p>}</p>
<p>Section 111.2: Basic Union Features</p>
<p>Unions are a specialized struct within which all members occupy
overlapping memory.</p>
<p>union U {</p>
<p>int a;</p>
<p>short b;</p>
<p>float c;</p>
<p>};</p>
<p>U u;</p>
<p>//Address of a and b will be equal</p>
<p>(void*)&amp;u.a == (void*)&amp;u.b;</p>
<p>(void*)&amp;u.a == (void*)&amp;u.c;</p>
<p>//Assigning to any union member changes the shared memory of all
members u.c = 4.f;</p>
<p>u.a = 5;</p>
<p>u.c != 4.f;</p>
<p>Section 111.3: Typical Use</p>
<p>Unions are useful for minimizing memory usage for exclusive data,
such as when implementing mixed data types.</p>
<p>struct AnyType {</p>
<p>enum {</p>
<p>IS_INT,</p>
<p>IS_FLOAT</p>
<p>} type;</p>
<p>union Data {</p>
<p>int as_int;</p>
<p>float as_float;</p>
<p>} value;</p>
<p>AnyType(int i) : type(IS_INT) { value.as_int = i; }</p>
<p>AnyType(float f) : type(IS_FLOAT) { value.as_float = f; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 561</p>
<p>int get_int() const {</p>
<p>if(type == IS_INT)</p>
<p>return value.as_int;</p>
<p>else</p>
<p>return (int)value.as_float;</p>
<p>}</p>
<p>float get_float() const {</p>
<p>if(type == IS_FLOAT)</p>
<p>return value.as_float;</p>
<p>else</p>
<p>return (float)value.as_int;</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 562</p>
<p><span id="Chapter_112__Design_pattern" class="anchor"></span>Chapter
112: Design pattern</p>
<p>implementation in C++</p>
<p>On this page, you can find examples of how design patterns are
implemented in C++. For the details on these</p>
<p>patterns, you can check out the design patterns documentation.</p>
<p>Section 112.1: Adapter Pattern</p>
<p>Convert the interface of a class into another interface clients
expect. Adapter (or Wrapper) lets classes work</p>
<p>together that couldn't otherwise because of incompatible interfaces.
Adapter pattern's motivation is that we can reuse existing software if
we can modify the interface.</p>
<p>1. Adapter pattern relies on object composition.</p>
<p>2. Client calls operation on Adapter object.</p>
<p>3. Adapter calls Adaptee to carry out the operation.</p>
<p>4. In STL, stack adapted from vector: When stack executes push(),
underlying vector does vector::push_back().</p>
<p>Example:</p>
<p>#include</p>
<p>// Desired interface (Target)</p>
<p>class Rectangle</p>
<p>{</p>
<p>public:</p>
<p>virtual void draw() = 0;</p>
<p>};</p>
<p>// Legacy component (Adaptee)</p>
<p>class LegacyRectangle</p>
<p>{</p>
<p>public:</p>
<p>LegacyRectangle(int x1, int y1, int x2, int y2) {</p>
<p>x1_ = x1;</p>
<p>y1_ = y1;</p>
<p>x2_ = x2;</p>
<p>y2_ = y2;</p>
<p>std::cout &lt;&lt;
"LegacyRectangle(x1,y1,x2,y2)<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>void oldDraw() {</p>
<p>std::cout &lt;&lt; "LegacyRectangle: oldDraw().
<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>private:</p>
<p>int x1_;</p>
<p>int y1_;</p>
<p>int x2_;</p>
<p>int y2_;</p>
<p>};</p>
<p>// Adapter wrapper</p>
<p>class RectangleAdapter: public Rectangle, private LegacyRectangle
{</p>
<p>public:</p>
<p>RectangleAdapter(int x, int y, int w, int h):</p>
<p>LegacyRectangle(x, y, x + w, y + h) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 563</p>
<p>std::cout &lt;&lt;
"RectangleAdapter(x,y,x+w,x+h)<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>void draw() {</p>
<p>std::cout &lt;&lt; "RectangleAdapter:
draw().<strong><del>\n</del></strong>";</p>
<p>oldDraw();</p>
<p>}</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>int x = 20, y = 50, w = 300, h = 200;</p>
<p>Rectangle *r = new RectangleAdapter(x,y,w,h);</p>
<p>r-&gt;draw();</p>
<p>}</p>
<p>//Output:</p>
<p>//LegacyRectangle(x1,y1,x2,y2)</p>
<p>//RectangleAdapter(x,y,x+w,x+h)</p>
<p>Summary of the code:</p>
<p>1. The client thinks he is talking to a <del>Rectangle</del></p>
<p>2. The target is the <del>Rectangle</del> class. This is what the
client invokes method on.</p>
<p>Rectangle *r = new RectangleAdapter(x,y,w,h);</p>
<p>r-&gt;draw();</p>
<p>3. Note that the adapter class uses multiple inheritance.</p>
<p>class RectangleAdapter: public Rectangle, private LegacyRectangle
{</p>
<p>...</p>
<p>}</p>
<p>4. The Adapter <del>RectangleAdapter</del> lets the
<del>LegacyRectangle</del> responds to request (<del>draw()</del> on a
<del>Rectangle</del>) by</p>
<p>inheriting BOTH classes.</p>
<p>5. The <del>LegacyRectangle</del> class does not have the same
methods (<del>draw()</del>) as <del>Rectangle</del>, but the</p>
<p>Adapter(RectangleAdapter) can take the <del>Rectangle</del> method
calls and turn around and invoke method on</p>
<p><del>the</del> LegacyRectangle<del>,</del> oldDraw()<del>.</del></p>
<p>class RectangleAdapter: public Rectangle, private LegacyRectangle
{</p>
<p>public:</p>
<p>RectangleAdapter(int x, int y, int w, int h):</p>
<p>LegacyRectangle(x, y, x + w, y + h) {</p>
<p>std::cout &lt;&lt;
"RectangleAdapter(x,y,x+w,x+h)<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>void draw() {</p>
<p>std::cout &lt;&lt; "RectangleAdapter:
draw().<strong><del>\n</del></strong>";</p>
<p>oldDraw();</p>
<p>}</p>
<p>};</p>
<p><strong>Adapter</strong> design pattern translates the interface for
one class into a compatible but different interface. So, this is</p>
<p>similar to the <strong>proxy</strong> pattern in that it's a
single-component wrapper. But the interface for the adapter class and
the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 564</p>
<p><span id="original_class_may_be_different"
class="anchor"></span>original class may be different.</p>
<p>As we've seen in the example above, this <strong>adapter</strong>
pattern is useful to expose a different interface for an existing</p>
<p>API to allow it to work with other code. Also, by using adapter
pattern, we can take heterogeneous interfaces, and transform them to
provide consistent API.</p>
<p><strong>Bridge pattern</strong> has a structure similar to an object
adapter, but Bridge has a different intent: It is meant to</p>
<p><strong>separate</strong> an interface from its implementation so
that they can be varied easily and independently. An
<strong>adapter</strong> is</p>
<p><strong>meant to</strong> change the interface <strong>of an</strong>
existing <strong>object.</strong></p>
<p>Section 112.2: Observer pattern</p>
<p>Observer Pattern's intent is to define a one-to-many dependency
between objects so that when one object changes</p>
<p>state, all its dependents are notified and updated automatically.</p>
<p>The subject and observers define the one-to-many relationship. The
observers are dependent on the subject such</p>
<p>that when the subject's state changes, the observers get notified.
Depending on the notification, the observers may also be updated with
new values.</p>
<p>Here is the example from the book "Design Patterns" by Gamma.</p>
<p>#include</p>
<p>#include</p>
<p>class Subject;</p>
<p>class Observer</p>
<p>{</p>
<p>public:</p>
<p>virtual ~Observer() = default;</p>
<p>virtual void Update(Subject&amp;) = 0;</p>
<p>};</p>
<p>class Subject</p>
<p>{</p>
<p>public:</p>
<p>virtual ~Subject() = default;</p>
<p>void Attach(Observer&amp; o) { observers.push_back(&amp;o); } void
Detach(Observer&amp; o)</p>
<p>{</p>
<p>observers.erase(std::remove(observers.begin(), observers.end(),
&amp;o));</p>
<p>}</p>
<p>void Notify()</p>
<p>{</p>
<p>for (auto* o : observers) {</p>
<p>o-&gt;Update(*this);</p>
<p>}</p>
<p>}</p>
<p>private:</p>
<p>std::vector <del>observers;</del></p>
<p>};</p>
<p>class ClockTimer : public Subject</p>
<p>{</p>
<p>public:</p>
<p>void SetTime(int hour, int minute, int second)</p>
<p>{</p>
<p>this-&gt;hour = hour;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 565</p>
<p>this-&gt;minute = minute;</p>
<p>this-&gt;second = second;</p>
<p>Notify();</p>
<p>}</p>
<p>int GetHour() const { return hour; }</p>
<p>int GetMinute() const { return minute; }</p>
<p>int GetSecond() const { return second; }</p>
<p>private:</p>
<p>int hour;</p>
<p>int minute;</p>
<p>int second;</p>
<p>};</p>
<p>class DigitalClock: public Observer</p>
<p>{</p>
<p>public:</p>
<p>explicit DigitalClock(ClockTimer&amp; s) : subject(s) {
subject.Attach(*this); }</p>
<p>~DigitalClock() { subject.Detach(*this); }</p>
<p>void Update(Subject&amp; theChangedSubject) override</p>
<p>{</p>
<p>if (&amp;theChangedSubject == &amp;subject) {</p>
<p>Draw();</p>
<p>}</p>
<p>}</p>
<p>void Draw()</p>
<p>{</p>
<p>int hour = subject.GetHour();</p>
<p>int minute = subject.GetMinute();</p>
<p>int second = subject.GetSecond();</p>
<p>std::cout &lt;&lt; "Digital time is " &lt;&lt; hour &lt;&lt; ":"</p>
<p>&lt;&lt; minute &lt;&lt; ":"</p>
<p>&lt;&lt; second &lt;&lt; std::endl;</p>
<p>}</p>
<p>private:</p>
<p>ClockTimer&amp; subject;</p>
<p>};</p>
<p>class AnalogClock: public Observer</p>
<p>{</p>
<p>public:</p>
<p>explicit AnalogClock(ClockTimer&amp; s) : subject(s) {
subject.Attach(*this); }</p>
<p>~AnalogClock() { subject.Detach(*this); }</p>
<p>void Update(Subject&amp; theChangedSubject) override</p>
<p>{</p>
<p>if (&amp;theChangedSubject == &amp;subject) {</p>
<p>Draw();</p>
<p>}</p>
<p>}</p>
<p>void Draw()</p>
<p>{</p>
<p>int hour = subject.GetHour();</p>
<p>int minute = subject.GetMinute();</p>
<p>int second = subject.GetSecond();</p>
<p>std::cout &lt;&lt; "Analog time is " &lt;&lt; hour &lt;&lt; ":"</p>
<p>&lt;&lt; minute &lt;&lt; ":"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 566</p>
<p>&lt;&lt; second &lt;&lt; std::endl;</p>
<p>}</p>
<p>private:</p>
<p>ClockTimer&amp; subject;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>ClockTimer timer;</p>
<p>DigitalClock digitalClock(timer);</p>
<p>AnalogClock analogClock(timer);</p>
<p>timer.SetTime(14, 41, 36);</p>
<p>}</p>
<p>Output:</p>
<p>Digital time is 14:41:36</p>
<p>Analog time is 14:41:36</p>
<p>Here are the summary of the pattern:</p>
<p>1. Objects (<del>DigitalClock</del> or <del>AnalogClock</del> object)
use the Subject interfaces (<del>Attach()</del> or <del>Detach()</del>)
either to</p>
<p>subscribe (register) as observers or unsubscribe (remove) themselves
from being observers (<del>subject.Attach(*this);</del> ,
<del>subject.Detach(*this);</del>.</p>
<p>2. Each subject can have many observers( <del>vector</del>
observers;).</p>
<p>3. All observers need to implement the Observer interface. This
interface just has one method, <del>Update()</del>, that</p>
<p>gets called when the Subject's state changes (<del>Update(Subject
&amp;)</del>)</p>
<p>4. In addition to the <del>Attach()</del> and <del>Detach()</del>
methods, the concrete subject implements a <del>Notify()</del> method
that</p>
<p>is used to update all the current observers whenever state changes.
But in this case, all of them are done in the parent class,
<del>Subject</del> (<del>Subject::Attach (Observer&amp;)</del>,
<del>void Subject::Detach(Observer&amp;)</del> and <del>void</del></p>
<p>Subject::Notify() <del>.</del></p>
<p>5. The Concrete object may also have methods for setting and getting
its state.</p>
<p>6. Concrete observers can be any class that implements the Observer
interface. Each observer subscribe</p>
<p>(register) with a concrete subject to receive update
(<del>subject.Attach(*this);</del> ).</p>
<p>7. The two objects of Observer Pattern are <strong>loosely
coupled</strong>, they can interact but with little knowledge of
each</p>
<p>other.</p>
<p>Variation:</p>
<p>Signal and Slots</p>
<p>Signals and slots is a language construct introduced in Qt, which
makes it easy to implement the Observer pattern</p>
<p>while avoiding boilerplate code. The concept is that controls (also
known as widgets) can send signals containing event information which
can be received by other controls using special functions known as
slots. The slot in Qt</p>
<p>must be a class member declared as such. The signal/slot system fits
well with the way Graphical User Interfaces are designed. Similarly, the
signal/slot system can be used for asynchronous I/O (including sockets,
pipes, serial</p>
<p>devices, etc.) event notification or to associate timeout events with
appropriate object instances and methods or functions. No
registration/deregistration/invocation code need be written, because
Qt's Meta Object Compiler</p>
<p>(MOC) automatically generates the needed infrastructure.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 567</p>
<p><span id="The_C__language_also_supports_a" class="anchor"></span>The
C# language also supports a similar construct although with a different
terminology and syntax: events play the role of signals, and delegates
are the slots. Additionally, a delegate can be a local variable, much
like a function</p>
<p>pointer, while a slot in Qt must be a class member declared as
such.</p>
<p>Section 112.3: Factory Pattern</p>
<p>Factory pattern decouples object creation and allows creation by name
using a common interface:</p>
<p>class Animal{</p>
<p>public:</p>
<p>virtual std::shared_ptr <del>clone() const = 0;</del></p>
<p>virtual std::string getname() const = 0;</p>
<p>};</p>
<p>class Bear: public Animal{</p>
<p>public:</p>
<p><del>virtual std::shared_ptr</del> clone() const override {</p>
<p>return std::make_shared<del>(*this);</del></p>
<p>}</p>
<p>virtual std::string getname() const override</p>
<p>{</p>
<p>return "bear";</p>
<p>}</p>
<p>};</p>
<p>class Cat: public Animal{</p>
<p>public:</p>
<p><del>virtual std::shared_ptr</del> clone() const override {</p>
<p>return std::make_shared<del>(*this);</del></p>
<p>}</p>
<p>virtual std::string getname() const override</p>
<p>{</p>
<p>return "cat";</p>
<p>}</p>
<p>};</p>
<p>class AnimalFactory{</p>
<p>public:</p>
<p><del>static std::shared_ptr</del> getAnimal( const std::string&amp;
name ) {</p>
<p>if ( name == "bear" )</p>
<p>return std::make_shared<del>();</del></p>
<p>if ( name == "cat" )</p>
<p>return std::shared_ptr<del>();</del></p>
<p>return nullptr;</p>
<p>}</p>
<p>};</p>
<p>Section 112.4: Builder Pattern with Fluent API</p>
<p>The Builder Pattern decouples the creation of the object from the
object itself. The main idea behind is that <strong>an</strong></p>
<p>object does not have to be responsible for its own creation<strong>.
The correct and valid assembly of a complex object</strong></p>
<p>may be a complicated task in itself, so this task can be delegated to
another class.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 568</p>
<p>Inspired by the Email Builder in C#, I've decided to make a C++
version here. An Email object is not necessarily a very complex object,
but it can demonstrate the pattern.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>// Forward declaring the builder</p>
<p>class EmailBuilder;</p>
<p>class Email</p>
<p>{</p>
<p>public:</p>
<p>friend class EmailBuilder; // the builder can access Email's
privates</p>
<p>static EmailBuilder make();</p>
<p>string to_string() const {</p>
<p>stringstream stream;</p>
<p>stream &lt;&lt; "from: " &lt;&lt; m_from</p>
<p>&lt;&lt; "<strong><del>\n</del></strong>to: " &lt;&lt; m_to</p>
<p>&lt;&lt; "<strong><del>\n</del></strong>subject: " &lt;&lt;
m_subject</p>
<p>&lt;&lt; "<strong><del>\n</del></strong>body: " &lt;&lt; m_body;</p>
<p>return stream.str();</p>
<p>}</p>
<p>private:</p>
<p>Email() = default; // restrict construction to builder</p>
<p>string m_from;</p>
<p>string m_to;</p>
<p>string m_subject;</p>
<p>string m_body;</p>
<p>};</p>
<p>class EmailBuilder</p>
<p>{</p>
<p>public:</p>
<p>EmailBuilder&amp; from(const string &amp;from) {</p>
<p>m_email.m_from = from;</p>
<p>return *this;</p>
<p>}</p>
<p>EmailBuilder&amp; to(const string &amp;to) {</p>
<p>m_email.m_to = to;</p>
<p>return *this;</p>
<p>}</p>
<p>EmailBuilder&amp; subject(const string &amp;subject) {</p>
<p>m_email.m_subject = subject;</p>
<p>return *this;</p>
<p>}</p>
<p>EmailBuilder&amp; body(const string &amp;body) {</p>
<p>m_email.m_body = body;</p>
<p>return *this;</p>
<p>}</p>
<p>operator Email&amp;&amp;() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 569</p>
<p>return std::move(m_email); // notice the move</p>
<p>}</p>
<p>private:</p>
<p>Email m_email;</p>
<p>};</p>
<p>EmailBuilder Email::make()</p>
<p>{</p>
<p>return EmailBuilder();</p>
<p>}</p>
<p>// Bonus example!</p>
<p>std::ostream&amp; operator &lt;&lt;(std::ostream&amp; stream, const
Email&amp; email) {</p>
<p>stream &lt;&lt; email.to_string();</p>
<p>return stream;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>Email mail = Email::make().from("me@mail.com")</p>
<p>.to("you@mail.com")</p>
<p>.subject("C++ builders")</p>
<p>.body("I like this API, don't you?");</p>
<p>cout &lt;&lt; mail &lt;&lt; endl;</p>
<p>}</p>
<p>For older versions of C++, one may just ignore the
<del>std::move</del> operation and remove the &amp;&amp; from the
conversion operator (although this will create a temporary copy).</p>
<p>The builder finishes its work when it releases the built email by the
<del>operator Email&amp;&amp;()</del>. In this example, the builder is a
temporary object and returns the email before being destroyed. You could
also use an explicit</p>
<p>operation like <del>Email EmailBuilder::build() {...}</del> instead
of the conversion operator.</p>
<p>Pass the builder around</p>
<p>A great feature the Builder Pattern provides is the ability to
<strong>use several actors to build an object together.</strong> This
is</p>
<p>done by passing the builder to the other actors that will each one
give some more information to the built object. This is specially
powerful when you are building some sort of query, adding filters and
other specifications.</p>
<p>void add_addresses(EmailBuilder&amp; builder)</p>
<p>{</p>
<p>builder.from("me@mail.com")</p>
<p>.to("you@mail.com");</p>
<p>}</p>
<p>void compose_mail(EmailBuilder&amp; builder)</p>
<p>{</p>
<p>builder.subject("I know the subject")</p>
<p>.body("And the body. Someone else knows the addresses."); }</p>
<p>int main()</p>
<p>{</p>
<p>EmailBuilder builder;</p>
<p>add_addresses(builder);</p>
<p>compose_mail(builder);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 570</p>
<p>Email mail = builder;</p>
<p>cout &lt;&lt; mail &lt;&lt; endl;</p>
<p>}</p>
<p>Design variant : Mutable object</p>
<p>You can change the design of this pattern to fit your needs. I'll
give one variant.</p>
<p>In the given example the Email object is immutable, i.e., it's
properties can't be modified because there is no access to them. This
was a desired feature. If you need to modify the object after its
creation you have to provide some</p>
<p>setters to it. Since those setters would be duplicated in the
builder, you may consider to do it all in one class (no</p>
<p>builder class needed anymore). Nevertheless, I would consider the
need to make the built object mutable in the first place.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 571</p>
<p><span id="Chapter_113__Singleton_Design_Pa_1"
class="anchor"></span>Chapter 113: Singleton Design Pattern</p>
<p>Section 113.1: Lazy Initialization</p>
<p>This example has been lifted from the <del>Q &amp; A</del> <a
href="http://stackoverflow.com/a/1008289/3807729">section
here:http://stackoverflow.com/a/1008289/3807729</a></p>
<p>See this article for a simple design for a lazy evaluated with
guaranteed destruction singleton:</p>
<p><a
href="http://stackoverflow.com/questions/270947/can-any-one-provide-me-a-sample-of-singleton-in-c/271104#271104">Can
any one provide me a sample of Singleton in c++?</a></p>
<p>The classic lazy evaluated and correctly destroyed singleton.</p>
<p>class S</p>
<p>{</p>
<p>public:</p>
<p>static S&amp; getInstance()</p>
<p>{</p>
<p>static S instance; // Guaranteed to be destroyed.</p>
<p>// Instantiated on first use.</p>
<p>return instance;</p>
<p>}</p>
<p>private:</p>
<p>S() {}; // Constructor? (the {} brackets) are needed here.</p>
<p>// C++ 03</p>
<p>// ========</p>
<p>// Don't forget to declare these two. You want to make sure they //
are unacceptable otherwise you may accidentally get copies of // your
singleton appearing.</p>
<p>S(S const&amp;); // Don't Implement</p>
<p>void operator=(S const&amp;); // Don't implement</p>
<p>// C++ 11</p>
<p>// =======</p>
<p>// We can use the better technique of deleting the methods // we
don't want.</p>
<p>public:</p>
<p>S(S const&amp;) = delete;</p>
<p>void operator=(S const&amp;) = delete;</p>
<p>// Note: Scott Meyers mentions in his Effective Modern // C++ book,
that deleted functions should generally // be public as it results in
better error messages // due to the compilers behavior to check
accessibility // before deleted status</p>
<p>};</p>
<p>See this article about when to use a singleton: (not often)</p>
<p><a
href="http://stackoverflow.com/questions/86582/singleton-how-should-it-be-used">Singleton:
How should it be used</a></p>
<p>See this two article about initialization order and how to cope:</p>
<p><a
href="http://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307#211307">Static
variables initialisation order</a></p>
<p><a
href="http://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746">Finding
C++ static initialization order problems</a></p>
<p>See this article describing lifetimes:</p>
<p><a
href="http://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function">What
is the lifetime of a static variable in a C++ function?</a></p>
<p>See this article that discusses some threading implications to
singletons:</p>
<p><a
href="http://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823#449823">Singleton
instance declared as static variable of GetInstance method</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 572</p>
<p><span id="See_this_article_that_explains_w" class="anchor"></span>See
this article that explains why double checked locking will not work on
C++:</p>
<p><a
href="http://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690">What
are all the common undefined behaviours that a C++ programmer should
know about?</a></p>
<p>Section 113.2: Static deinitialization-safe singleton</p>
<p>There are times with multiple static objects where you need to be
able to guarantee that the singleton will not be destroyed until all the
static objects that use the singleton no longer need it.</p>
<p>In this case <del>std::shared_ptr</del> can be used to keep the
singleton alive for all users even when the static destructors are being
called at the end of the program:</p>
<p>class Singleton</p>
<p>{</p>
<p>public:</p>
<p>Singleton(Singleton const&amp;) = delete;</p>
<p>Singleton&amp; operator=(Singleton const&amp;) = delete;</p>
<p>static std::shared_ptr <del>instance()</del></p>
<p>{</p>
<p><del>static std::shared_ptr</del> s{new Singleton}; return s;</p>
<p>}</p>
<p>private:</p>
<p>Singleton() {}</p>
<p>};</p>
<p><a href="http://stackoverflow.com/a/40337728/3807729">NOTE: This
example appears as an answer in the Q&amp;A section here.</a></p>
<p>Section 113.3: Thread-safe Singeton</p>
<p>Version ≥ C++11</p>
<p>The C++11 standards guarantees that the initialization of function
scope objects are initialized in a synchronized manner. This can be used
to implement a thread-safe singleton with lazy initialization.</p>
<p>class Foo</p>
<p>{</p>
<p>public:</p>
<p>static Foo&amp; instance()</p>
<p>{</p>
<p>static Foo inst;</p>
<p>return inst;</p>
<p>}</p>
<p>private:</p>
<p>Foo() {}</p>
<p>Foo(const Foo&amp;) = delete;</p>
<p>Foo&amp; operator =(const Foo&amp;) = delete;</p>
<p>};</p>
<p>Section 113.4: Subclasses</p>
<p>class API</p>
<p>{</p>
<p>public:</p>
<p>static API&amp; instance();</p>
<p>virtual ~API() {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 573</p>
<p>virtual const char* func1() = 0;</p>
<p>virtual void func2() = 0;</p>
<p>protected:</p>
<p>API() {}</p>
<p>API(const API&amp;) = delete;</p>
<p>API&amp; operator=(const API&amp;) = delete;</p>
<p>};</p>
<p>class WindowsAPI : public API</p>
<p>{</p>
<p>public:</p>
<p>virtual const char* func1() override { <del>/* Windows code */</del>
} virtual void func2() override { <del>/* Windows code */</del> }</p>
<p>};</p>
<p>class LinuxAPI : public API</p>
<p>{</p>
<p>public:</p>
<p>virtual const char* func1() override { <del>/* Linux code */</del> }
virtual void func2() override { <del>/* Linux code */</del> }</p>
<p>};</p>
<p>API&amp; API::instance() {</p>
<p>#if PLATFORM == WIN32</p>
<p>static WindowsAPI instance;</p>
<p>#elif PLATFORM = LINUX</p>
<p>static LinuxAPI instance;</p>
<p>#endif</p>
<p>return instance;</p>
<p>}</p>
<p>In this example, a simple compiler switch binds the <del>API</del>
class to the appropriate subclass. In this way, <del>API</del> can
be</p>
<p>accessed without being coupled to platform-specific code.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 574</p>
<p><span id="Chapter_114__User_Defined_Litera_1"
class="anchor"></span>Chapter 114: User-Defined Literals</p>
<p>Section 114.1: Self-made user-defined literal for binary</p>
<p>Despite you can write a binary number in C++14 like:</p>
<p>int number =0b0001'0101; // ==21</p>
<p>here comes a famous example with a self-made implementation for
binary numbers:</p>
<p>Note: The whole template expanding program is running at compile
time.</p>
<p>template&lt; char FIRST, char... REST &gt; struct binary</p>
<p>{</p>
<p>static_assert( FIRST == '0' || FIRST == '1', "invalid binary digit" )
; enum { value = ( ( FIRST -'0' ) &lt;&lt; sizeof...(REST) ) +
binary<del>::value } ;</del></p>
<p>};</p>
<p>template&lt;&gt; struct binary&lt;'0'&gt; { enum { value = 0 } ;
};</p>
<p>template&lt;&gt; struct binary&lt;'1'&gt; { enum { value = 1 } ;
};</p>
<p>// raw literal operator</p>
<p>template&lt; char... LITERAL &gt; inline</p>
<p>constexpr unsigned int operator "" _b() { return binary<del>::value ;
}</del></p>
<p>// raw literal operator</p>
<p>template&lt; char... LITERAL &gt; inline</p>
<p>constexpr unsigned int operator "" _B() { return binary<del>::value ;
}</del></p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; 10101_B &lt;&lt; ", " &lt;&lt; 011011000111_b
&lt;&lt; '<strong><del>\n</del></strong>' ; // prints 21, 1735 }</p>
<p>Section 114.2: Standard user-defined literals for duration</p>
<p>Version ≥ C++14</p>
<p>Those following duration user literals are declared in the
<del>namespace std::literals::chrono_literals</del>, where both</p>
<p>literals and <del>chrono_literals</del> are inline namespaces. Access
to these operators can be gained with <del>using</del> namespace
std::literals, <del>using namespace std::chrono_literals</del>, and
<del>using namespace</del></p>
<p>std::literals::chrono_literals<del>.</del></p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>using namespace std::literals::chrono_literals;</p>
<p>std::chrono::nanoseconds t1 = 600ns;</p>
<p>std::chrono::microseconds t2 = 42us;</p>
<p>std::chrono::milliseconds t3 = 51ms;</p>
<p>std::chrono::seconds t4 = 61s;</p>
<p>std::chrono::minutes t5 = 88min;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 575</p>
<p><span id="auto_t6___2___0_5h" class="anchor"></span>auto t6 = 2 *
0.5h;</p>
<p>auto total = t1 + t2 + t3 + t4 + t5 + t6;</p>
<p>std::cout.precision(13);</p>
<p>std::cout &lt;&lt; total.count() &lt;&lt; " nanoseconds" &lt;&lt;
std::endl; // 8941051042600 nanoseconds</p>
<p>std::cout &lt;&lt;
std::chrono::duration_cast<del>(total).count()</del></p>
<p>&lt;&lt; " hours" &lt;&lt; std::endl; // 2 hours</p>
<p>}</p>
<p>Section 114.3: User-defined literals with long double values</p>
<p>#include</p>
<p>long double operator"" _km(long double val)</p>
<p>{</p>
<p>return val * 1000.0;</p>
<p>}</p>
<p>long double operator"" _mi(long double val)</p>
<p>{</p>
<p>return val * 1609.344;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "3 km = " &lt;&lt; 3.0_km &lt;&lt; "
m<strong><del>\n</del></strong>";</p>
<p>std::cout &lt;&lt; "3 mi = " &lt;&lt; 3.0_mi &lt;&lt; "
m<strong><del>\n</del></strong>";</p>
<p>return 0;</p>
<p>}</p>
<p>The output of this program is the following:</p>
<p>3 km = 3000 m</p>
<p>3 mi = 4828.03 m</p>
<p>Section 114.4: Standard user-defined literals for strings</p>
<p>Version ≥ C++14</p>
<p>Those following string user literals are declared in the
<del>namespace std::literals::string_literals</del>, where both</p>
<p>literals and <del>string_literals</del> are inline namespaces. Access
to these operators can be gained with <del>using</del> namespace
std::literals, <del>using namespace std::string_literals</del>, and
<del>using namespace</del></p>
<p>std::literals::string_literals<del>.</del></p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>using namespace std::literals::string_literals;</p>
<p>std::string s = "hello world"s;</p>
<p>std::u16string s16 = u"hello world"s;</p>
<p>std::u32string s32 = U"hello world"s;</p>
<p>std::wstring ws = L"hello world"s;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 576</p>
<p><span id="std__cout____s____std__endl"
class="anchor"></span>std::cout &lt;&lt; s &lt;&lt; std::endl;</p>
<p><del>std::wstring_convert</del>, char16_t&gt; utf16conv;</p>
<p>std::cout &lt;&lt; utf16conv.to_bytes(s16) &lt;&lt; std::endl;</p>
<p><del>std::wstring_convert</del>, char32_t&gt; utf32conv;</p>
<p>std::cout &lt;&lt; utf32conv.to_bytes(s32) &lt;&lt; std::endl;</p>
<p>std::wcout &lt;&lt; ws &lt;&lt; std::endl;</p>
<p>}</p>
<p>Note:</p>
<p>Literal string may containing <del>\0</del></p>
<p>std::string s1 = "foo<strong><del>\0\0</del></strong>bar"; //
constructor from C-string: results in "foo"s std::string s2 =
"foo<strong><del>\0\0</del></strong>bar"s; // That string contains 2
'\0' in its middle</p>
<p>Section 114.5: Standard user-defined literals for complex</p>
<p>Version ≥ C++14</p>
<p>Those following complex user literals are declared in the
<del>namespace std::literals::complex_literals</del>, where</p>
<p>both <del>literals</del> and <del>complex_literals</del> are inline
namespaces. Access to these operators can be gained with
<del>using</del></p>
<p><del>namespace std::literals,</del> using namespace
std::complex_literals<del>, and</del> using namespace
std::literals::complex_literals<del>.</del></p>
<p>#include</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>using namespace std::literals::complex_literals;</p>
<p><del>std::complex</del> c = 2.0 + 1i; // {2.0, 1.}</p>
<p><del>std::complex</del> cf = 2.0f + 1if; // {2.0f, 1.f}</p>
<p><del>std::complex</del> cl = 2.0L + 1il; // {2.0L, 1.L}</p>
<p>std::cout &lt;&lt; "abs" &lt;&lt; c &lt;&lt; " = " &lt;&lt; abs(c)
&lt;&lt; std::endl; // abs(2,1) = 2.23607</p>
<p>std::cout &lt;&lt; "abs" &lt;&lt; cf &lt;&lt; " = " &lt;&lt; abs(cf)
&lt;&lt; std::endl; // abs(2,1) = 2.23607</p>
<p>std::cout &lt;&lt; "abs" &lt;&lt; cl &lt;&lt; " = " &lt;&lt; abs(cl)
&lt;&lt; std::endl; // abs(2,1) = 2.23607 }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 577</p>
<p><span id="Chapter_115__Memory_management_1"
class="anchor"></span>Chapter 115: Memory management</p>
<p>Section 115.1: Free Storage (Heap, Dynamic Allocation ...)</p>
<p>The term <strong>'heap'</strong> is a general computing term meaning
an area of memory from which portions can be allocated</p>
<p>and deallocated independently of the memory provided by the
<strong>stack</strong>.</p>
<p>In <del>C++</del> the Standard refers to this area as the
<strong>Free Store</strong> which is considered a more accurate
term.</p>
<p>Areas of memory allocated from the <strong>Free Store</strong> may
live longer than the original scope in which it was allocated.</p>
<p>Data too large to be stored on the stack may also be allocated from
the <strong>Free Store</strong>.</p>
<p>Raw memory can be allocated and deallocated by the new and delete
keywords.</p>
<p>float *foo = nullptr;</p>
<p>{</p>
<p>*foo = new float; // Allocates memory for a float</p>
<p>float bar; // Stack allocated</p>
<p>} // End lifetime of bar, while foo still alive</p>
<p>delete foo; // Deletes the memory for the float at pF, invalidating
the pointer foo = nullptr; // Setting the pointer to nullptr after
delete is often considered good practice</p>
<p>It's also possible to allocate fixed size arrays with new and delete,
with a slightly different syntax. Array allocation is</p>
<p>not compatible with non-array allocation, and mixing the two will
lead to heap corruption. Allocating an array also allocates memory to
track the size of the array for later deletion in an
implementation-defined way.</p>
<p>// Allocates memory for an array of 256 ints</p>
<p>int *foo = new int[256];</p>
<p>// Deletes an array of 256 ints at foo</p>
<p>delete[] foo;</p>
<p>When using new and delete instead malloc and free, the constructor
and destructor will get executed (Similar to stack based objects). This
is why new and delete are preferred over malloc and free.</p>
<p>struct ComplexType {</p>
<p>int a = 0;</p>
<p>ComplexType() { std::cout &lt;&lt; "Ctor" &lt;&lt; std::endl; }</p>
<p>~ComplexType() { std::cout &lt;&lt; "Dtor" &lt;&lt; std::endl; }</p>
<p>};</p>
<p>// Allocates memory for a ComplexType, and calls its constructor
ComplexType *foo = new ComplexType();</p>
<p>//Calls the destructor for ComplexType() and deletes memory for a
Complextype at pC delete foo;</p>
<p>Version ≥ C++11</p>
<p>From C++11 on, the use of smart pointers is recommended for
indicating ownership.</p>
<p>Version ≥ C++14</p>
<p>C++14 added <del>std::make_unique</del> to the STL, changing the
recommendation to favor <del>std::make_unique</del> or
<del>std::make_shared</del> instead of using naked new and delete.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 578</p>
<p><span id="Section_115_2__Placement_new" class="anchor"></span>Section
115.2: Placement new</p>
<p>There are situations when we don't want to rely upon Free Store for
allocating memory and we want to use custom</p>
<p>memory allocations using <del>new</del>.</p>
<p>For these situations we can use <del>Placement New</del>, where we
can tell `new' operator to allocate memory from a pre-</p>
<p>allocated memory location</p>
<p>For example</p>
<p>int a4byteInteger;</p>
<p>char *a4byteChar = new (&amp;a4byteInteger) char[4];</p>
<p>In this example, the memory pointed by <del>a4byteChar</del> is 4
byte allocated to 'stack' via integer variable
<del>a4byteInteger</del>.</p>
<p>The benefit of this kind of memory allocation is the fact that
programmers control the allocation. In the example</p>
<p>above, since <del>a4byteInteger</del> is allocated on stack, we don't
need to make an explicit call to 'delete a4byteChar`.</p>
<p>Same behavior can be achieved for dynamic allocated memory also. For
example</p>
<p>int *a8byteDynamicInteger = new int[2];</p>
<p>char *a8byteChar = new (a8byteDynamicInteger) char[8];</p>
<p>In this case, the memory pointer by <del>a8byteChar</del> will be
referring to dynamic memory allocated by</p>
<p>a8byteDynamicInteger. In this case however, we need to explicitly
call<del>delete a8byteDynamicInteger</del> to release the memory</p>
<p>Another example for C++ Class</p>
<p>struct ComplexType {</p>
<p>int a;</p>
<p>ComplexType() : a(0) {}</p>
<p>~ComplexType() {}</p>
<p>};</p>
<p>int main() {</p>
<p>char* dynArray = new char[256];</p>
<p>//Calls ComplexType's constructor to initialize memory as a
ComplexType new((void*)dynArray) ComplexType();</p>
<p>//Clean up memory once we're done</p>
<p><del>reinterpret_cast</del>(dynArray)-&gt;~ComplexType(); delete[]
dynArray;</p>
<p>//Stack memory can also be used with placement new
alignas(ComplexType) char localArray[256]; //alignas() available since
C++11</p>
<p>new((void*)localArray) ComplexType();</p>
<p>//Only need to call the destructor for stack memory
reinterpret_cast<del>(localArray)-&gt;~ComplexType();</del></p>
<p>return 0;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 579</p>
<p><span id="Section_115_3__Stack" class="anchor"></span>Section 115.3:
Stack</p>
<p>The stack is a small region of memory into which temporary values are
placed during execution. Allocating data into</p>
<p>the stack is very fast compared to heap allocation, as all the memory
has already been assigned for this purpose.</p>
<p>int main() {</p>
<p>int a = 0; //Stored on the stack</p>
<p>return a;</p>
<p>}</p>
<p>The stack is named because chains of function calls will have their
temporary memory 'stacked' on top of each</p>
<p>other, each one using a separate small section of memory.</p>
<p>float bar() {</p>
<p>//f will be placed on the stack after anything else float f = 2;</p>
<p>return f;</p>
<p>}</p>
<p>double foo() {</p>
<p>//d will be placed just after anything within main() double d =
bar();</p>
<p>return d;</p>
<p>}</p>
<p>int main() {</p>
<p>//The stack has no user variables stored in it until foo() is called
return (int)foo();</p>
<p>}</p>
<p>Data stored on the stack is only valid so long as the scope that
allocated the variable is still active.</p>
<p>int* pA = nullptr;</p>
<p>void foo() {</p>
<p>int b = *pA;</p>
<p>pA = &amp;b;</p>
<p>}</p>
<p>int main() {</p>
<p>int a = 5;</p>
<p>pA = &amp;a;</p>
<p>foo();</p>
<p>//Undefined behavior, the value pointed to by pA is no longer in
scope</p>
<p>a = *pA;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 580</p>
<p><span id="Chapter_116__C__11_Memory_Model_1"
class="anchor"></span>Chapter 116: C++11 Memory Model</p>
<p>Different threads trying to access the same memory location
participate in a data race if at least one of the</p>
<p>operations is a modification (also known as store operation). These
data races cause undefined behavior. To avoid them one needs to prevent
these threads from concurrently executing such conflicting
operations.</p>
<p>Synchronization primitives (mutex, critical section and the like) can
guard such accesses. The Memory Model introduced in C++11 defines two
new portable ways to synchronize access to memory in multi-threaded</p>
<p>environment: atomic operations and fences.</p>
<p>Atomic Operations</p>
<p>It is now possible to read and write to given memory location by the
use of atomic load and atomic store operations.</p>
<p>For convenience these are wrapped in the <del>std::atomic</del>
template class. This class wraps a value of type t but this time loads
and stores to the object are atomic.</p>
<p>The template is not available for all types. Which types are
available is implementation specific, but this usually includes most (or
all) available integral types as well as pointer types. So that
<del>std::atomic</del> and</p>
<p>std::atomic *&gt; should be available, while
<del>std::atomic</del>&gt; most probably wont be.</p>
<p>Atomic operations have the following properties:</p>
<p>All atomic operations can be performed concurrently from multiple
threads without causing undefined</p>
<p>behavior.</p>
<p>An atomic load will see either the initial value which the atomic
object was constructed with, or the value</p>
<p>written to it via some atomic store operation.</p>
<p>Atomic stores to the same atomic object are ordered the same in all
threads. If a thread has already seen the</p>
<p>value of some atomic store operation, subsequent atomic load
operations will see either the same value, or the value stored by
subsequent atomic store operation.</p>
<p>Atomic read-modify-write operations allow atomic load and atomic
store to happen without other atomic store in between. For example one
can atomically increment a counter from multiple threads, and no
increment</p>
<p>will be lost regardless of the contention between the threads.</p>
<p>Atomic operations receive an optional <del>std::memory_order</del>
parameter which defines what additional properties the operation has
regarding other memory locations.</p>
<p>std::memory_order Meaning</p>
<p>std::memory_order_relaxed <del>no additional restrictions</del></p>
<p>std if load-acquire sees the value stored by store-release then ::
memory_order_release → stores sequenced before the store - release
happen before std :: memory_order_acquire loads sequenced after the load
acquire</p>
<p>std::memory_order_consume like <del>memory_order_acquire</del> but
only for dependent loads</p>
<p>std::memory_order_acq_rel combines <del>load-acquire</del> and
<del>store-release</del></p>
<p>std::memory_order_seq_cst <del>sequential consistency</del></p>
<p>These memory order tags allow three different memory ordering
disciplines: sequential consistency, relaxed, and</p>
<p>release-acquire with its sibling release-consume.</p>
<p>Sequential Consistency</p>
<p>If no memory order is specified for an atomic operation, the order
defaults to sequential consistency. This mode can</p>
<p>also be explicitly selected by tagging the operation with
<del>std::memory_order_seq_cst</del>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 581</p>
<p><span id="With_this_order_no_memory_operat"
class="anchor"></span>With this order no memory operation can cross the
atomic operation. All memory operations sequenced before the atomic
operation happen before the atomic operation and the atomic operation
happens before all memory</p>
<p>operations that are sequenced after it. This mode is probably the
easiest one to reason about but it also leads to</p>
<p>the greatest penalty to performance. It also prevents all compiler
optimizations that might otherwise try to reorder operations past the
atomic operation.</p>
<p>Relaxed Ordering</p>
<p>The opposite to sequential consistency is the relaxed memory
ordering. It is selected with the <del>std::memory_order_relaxed</del>
tag. Relaxed atomic operation will impose no restrictions on other
memory</p>
<p>operations. The only effect that remains, is that the operation is
itself still atomic.</p>
<p>Release-Acquire Ordering</p>
<p>An atomic store operation can be tagged with
<del>std::memory_order_release</del> and an atomic load operation can
be</p>
<p>tagged with <del>std::memory_order_acquire</del>. The first operation
is called (atomic) store-release while the second is called (atomic)
load-acquire.</p>
<p>When load-acquire sees the value written by a store-release the
following happens: all store operations sequenced before the
store-release become visible to (happen before) load operations that are
sequenced after the load-acquire.</p>
<p>Atomic read-modify-write operations can also receive the cumulative
tag <del>std::memory_order_acq_rel</del>. This makes</p>
<p>the atomic load portion of the operation an atomic load-acquire while
the atomic store portion becomes atomic store-</p>
<p>release.</p>
<p>The compiler is not allowed to move store operations after an atomic
store-release operation. It is also not allowed</p>
<p>to move load operations before atomic load-acquire (or
load-consume).</p>
<p>Also note that there is no atomic load-release or atomic
store-acquire. Attempting to create such operations makes them relaxed
operations.</p>
<p>Release-Consume Ordering</p>
<p>This combination is similar to release-acquire, but this time the
atomic load is tagged with <del>std::memory_order_consume</del> and
becomes (atomic) load-consume operation. This mode is the same as
release-</p>
<p>acquire with the only difference that among the load operations
sequenced after the load-consume only these</p>
<p>depending on the value loaded by the load-consume are ordered.</p>
<p>Fences</p>
<p>Fences also allow memory operations to be ordered between threads. A
fence is either a release fence or acquire</p>
<p>fence.</p>
<p>If a release fence happens before an acquire fence, then stores
sequenced before the release fence are visible to loads sequenced after
the acquire fence. To guarantee that the release fence happens before
the acquire fence one</p>
<p>may use other synchronization primitives including relaxed atomic
operations.</p>
<p>Section 116.1: Need for Memory Model</p>
<p>int x, y;</p>
<p>bool ready = false;</p>
<p>void init()</p>
<p>{</p>
<p>x = 2;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 582</p>
<p>y = 3;</p>
<p>ready = true;</p>
<p>}</p>
<p>void use()</p>
<p>{</p>
<p>if (ready)</p>
<p>std::cout &lt;&lt; x + y;</p>
<p>}</p>
<p>One thread calls the <del>init()</del> function while another thread
(or signal handler) calls the <del>use()</del> function. One might</p>
<p>expect that the <del>use()</del> function will either print
<del>5</del> or do nothing. This may not always be the case for several
reasons:</p>
<p>The CPU may reorder the writes that happen in <del>init()</del> so
that the code that actually executes might look</p>
<p>like:</p>
<p>void init()</p>
<p>{</p>
<p>ready = true;</p>
<p>x = 2;</p>
<p>y = 3;</p>
<p>}</p>
<p>The CPU may reorder the reads that happen in <del>use()</del> so that
the actually executed code might become:</p>
<p>void use()</p>
<p>{</p>
<p>int local_x = x;</p>
<p>int local_y = y;</p>
<p>if (ready)</p>
<p>std::cout &lt;&lt; local_x + local_y;</p>
<p>}</p>
<p>An optimizing C++ compiler may decide to reorder the program in
similar way.</p>
<p>Such reordering cannot change the behavior of a program running in
single thread because a thread cannot</p>
<p>interleave the calls to <del>init()</del> and <del>use()</del>. On
the other hand in a multi-threaded setting one thread may see part of
the writes performed by the other thread where it may happen that
<del>use()</del> may see <del>ready==true</del> and garbage in
<del>x</del></p>
<p>or <del>y</del> or both.</p>
<p>The C++ Memory Model allows the programmer to specify which
reordering operations are permitted and which</p>
<p>are not, so that a multi-threaded program would also be able to
behave as expected. The example above can be rewritten in thread-safe
way like this:</p>
<p>int x, y;</p>
<p><del>std::atomic</del> ready{false};</p>
<p>void init()</p>
<p>{</p>
<p>x = 2;</p>
<p>y = 3;</p>
<p>ready.store(true, std::memory_order_release);</p>
<p>}</p>
<p>void use()</p>
<p>{</p>
<p>if (ready.load(std::memory_order_acquire))</p>
<p>std::cout &lt;&lt; x + y;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 583</p>
<p><span id="Here_init___performs_atomic_stor"
class="anchor"></span>Here <del>init()</del> performs atomic
store-release operation. This not only stores the value <del>true</del>
into <del>ready</del>, but also tells the compiler that it cannot move
this operation before write operations that are sequenced before it.</p>
<p>The <del>use()</del> function does an atomic load-acquire operation.
It reads the current value of <del>ready</del> and also forbids the
compiler from placing read operations that are sequenced after it to
happen before the atomic load-acquire.</p>
<p>These atomic operations also cause the compiler to put whatever
hardware instructions are needed to inform the CPU to refrain from the
unwanted reorderings.</p>
<p>Because the atomic store-release is to the same memory location as
the atomic load-acquire, the memory model stipulates that if the
load-acquire operation sees the value written by the store-release
operation, then all writes</p>
<p>performed by <del>init()</del>'s thread prior to that store-release
will be visible to loads that <del>use()</del>'s thread executes after
its load-acquire. That is if <del>use()</del> sees
<del>ready==true</del>, then it is guaranteed to see <del>x==2</del> and
<del>y==3</del>.</p>
<p>Note that the compiler and the CPU are still allowed to write to
<del>y</del> before writing to <del>x</del>, and similarly the reads
from these variables in <del>use()</del> can happen in any order.</p>
<p>Section 116.2: Fence example</p>
<p>The example above can also be implemented with fences and relaxed
atomic operations:</p>
<p>int x, y;</p>
<p><del>std::atomic</del> ready{false};</p>
<p>void init()</p>
<p>{</p>
<p>x = 2;</p>
<p>y = 3;</p>
<p>atomic_thread_fence(std::memory_order_release);</p>
<p>ready.store(true, std::memory_order_relaxed);</p>
<p>}</p>
<p>void use()</p>
<p>{</p>
<p>if (ready.load(std::memory_order_relaxed))</p>
<p>{</p>
<p>atomic_thread_fence(std::memory_order_acquire);</p>
<p>std::cout &lt;&lt; x + y;</p>
<p>}</p>
<p>}</p>
<p>If the atomic load operation sees the value written by the atomic
store then the store happens before the load, and</p>
<p>so do the fences: the release fence happens before the acquire fence
making the writes to <del>x</del> and <del>y</del> that precede the</p>
<p>release fence to become visible to the <del>std::cout</del> statement
that follows the acquire fence.</p>
<p>A fence might be beneficial if it can reduce the overall number of
acquire, release or other synchronization operations. For example:</p>
<p>void block_and_use()</p>
<p>{</p>
<p>while (!ready.load(std::memory_order_relaxed))</p>
<p>;</p>
<p>atomic_thread_fence(std::memory_order_acquire);</p>
<p>std::cout &lt;&lt; x + y;</p>
<p>}</p>
<p>The <del>block_and_use()</del> function spins until the
<del>ready</del> flag is set with the help of relaxed atomic load. Then
a single</p>
<p>acquire fence is used to provide the needed memory ordering.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 584</p>
<p><span id="Chapter_117__Scopes_1" class="anchor"></span>Chapter 117:
Scopes</p>
<p>Section 117.1: Global variables</p>
<p>To declare a single instance of a variable which is accessible in
different source files, it is possible to make it in the global scope
with keyword <del>extern</del>. This keyword says the compiler that
somewhere in the code there is a definition</p>
<p>for this variable, so it can be used everywhere and all write/read
will be done in one place of memory.</p>
<p>// File my_globals.h:</p>
<p>#ifndef __MY_GLOBALS_H__</p>
<p>#define __MY_GLOBALS_H__</p>
<p>extern int circle_radius; // Promise to the compiler that
circle_radius</p>
<p>// will be defined somewhere</p>
<p>#endif</p>
<p>// File foo1.cpp:</p>
<p>#include "my_globals.h"</p>
<p>int circle_radius = 123; // Defining the extern variable</p>
<p>// File main.cpp:</p>
<p>#include "my_globals.h"</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "The radius is: " &lt;&lt; circle_radius &lt;&lt;
"<strong><del>\n</del></strong>";'</p>
<p>return 0;</p>
<p>}</p>
<p>Output:</p>
<p>The radius is: 123</p>
<p>Section 117.2: Simple block scope</p>
<p>The scope of a variable in a block <del>{ ... }</del>, begins after
declaration and ends at the end of the block. If there is nested block,
the inner block can hide the scope of a variable which is declared in
the outer block.</p>
<p>{</p>
<p>int x = 100;</p>
<p>// ^</p>
<p>// Scope of `x` begins here</p>
<p>//</p>
<p>} // &lt;- Scope of `x` ends here</p>
<p>If a nested block starts within an outer block, a new declared
variable with the same name which is before in the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 585</p>
<p>outer class, hides the first one.</p>
<p>{</p>
<p>int x = 100;</p>
<p>{</p>
<p>int x = 200;</p>
<p>std::cout &lt;&lt; x; // &lt;- Output is 200</p>
<p>}</p>
<p>std::cout &lt;&lt; x; // &lt;- Output is 100</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 586</p>
<p><span id="Chapter_118__static_assert_1" class="anchor"></span>Chapter
118: static_assert</p>
<p>Parameter Details</p>
<p>bool_constexpr Expression to check</p>
<p>message Message to print when bool_constexpr is false</p>
<p>Section 118.1: static_assert</p>
<p>Assertations mean that a condition should be checked and if it's
false, it's an error. For <del>static_assert()</del>, this is</p>
<p>done compile-time.</p>
<p>template</p>
<p>T mul10(const T t)</p>
<p>{</p>
<p><del>static_assert( std::is_integral</del>::value, "mul10() only
works for integral types" ); return (t &lt;&lt; 3) + (t &lt;&lt; 1);</p>
<p>}</p>
<p>A <del>static_assert()</del> has a mandatory first parameter, the
condition, that is a bool constexpr. It might have a second</p>
<p>parameter, the message, that is a string literal. From C++17, the
second parameter is optional; before that, it's mandatory.</p>
<p>Version ≥ C++17</p>
<p>template</p>
<p>T mul10(const T t)</p>
<p>{</p>
<p>static_assert(std::is_integral<del>::value);</del></p>
<p>return (t &lt;&lt; 3) + (t &lt;&lt; 1);</p>
<p>}</p>
<p>It is used when:</p>
<p>In general, a verification at compile-time is required on some type
on constexpr value A template function needs to verify certain
properties of a type passed to it</p>
<p>One wants to write test cases for:</p>
<p>template metafunctions</p>
<p>constexpr functions</p>
<p>macro metaprogramming</p>
<p>Certain defines are required (for ex., C++ version)</p>
<p>Porting legacy code, assertations on <del>sizeof(T)</del> (e.g.,
32-bit int)</p>
<p>Certain compiler features are required for the program to work
(packing, empty base class optimization, etc.)</p>
<p>Note that <del>static_assert()</del> does not participate in SFINAE:
thus, when additional overloads / specializations are</p>
<p>possible, one should not use it instead of template metaprogramming
techniques (like <del>std::enable_if&lt;&gt;</del>). It might be used in
template code when the expected overload / specialization is already
found, but further verifications are</p>
<p>required. In such cases, it might provide more concrete error
message(s) than relying on SFINAE for this.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 587</p>
<p><span id="Chapter_119__constexpr_1" class="anchor"></span>Chapter
119: constexpr</p>
<p><del>constexpr</del> is a keyword that can be used to mark a
variable's value as a constant expression, a function as</p>
<p>potentially usable in constant expressions, or (since C++17) an if
statement as having only one of its branches selected to be
compiled.</p>
<p>Section 119.1: constexpr variables</p>
<p>A variable declared <del>constexpr</del> is implicitly
<del>const</del> and its value may be used as a constant expression.</p>
<p>Comparison with #define</p>
<p>A <del>constexpr</del> is type-safe replacement for
<del>#define</del> based compile-time expressions. With
<del>constexpr</del> the compile-</p>
<p>time evaluated expression is replaced with the result. For
example:</p>
<p>Version ≥ C++11</p>
<p>int main()</p>
<p>{</p>
<p>constexpr int N = 10 + 2;</p>
<p>cout &lt;&lt; N;</p>
<p>}</p>
<p>will produce the following code:</p>
<p>cout &lt;&lt; 12;</p>
<p>A pre-processor based compile-time macro would be different.
Consider:</p>
<p>#define N 10 + 2</p>
<p>int main()</p>
<p>{</p>
<p>cout &lt;&lt; N;</p>
<p>}</p>
<p>will produce:</p>
<p>cout &lt;&lt; 10 + 2;</p>
<p>which will obviously be converted to <del>cout &lt;&lt; 10 +
2;</del>. However, the compiler would have to do more work. Also, it</p>
<p>creates a problem if not used correctly.</p>
<p>For example (with <del>#define</del>):</p>
<p>cout &lt;&lt; N * 2;</p>
<p>forms:</p>
<p>cout &lt;&lt; 10 + 2 * 2; // 14</p>
<p>But a pre-evaluated <del>constexpr</del> would correctly give
<del>24</del>.</p>
<p>Comparison with const</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 588</p>
<p><span id="A_const_variable_is_a_variable_w" class="anchor"></span>A
<del>const</del> variable is a <strong>variable</strong> which needs
memory for its storage. A <del>constexpr</del> does not. A
<del>constexpr</del> produces</p>
<p>compile time constant, which cannot be changed. You may argue that
<del>const</del> may also not be changed. But</p>
<p>consider:</p>
<p>int main()</p>
<p>{</p>
<p>const int size1 = 10;</p>
<p>const int size2 = abs(10);</p>
<p>int arr_one[size1];</p>
<p>int arr_two[size2];</p>
<p>}</p>
<p>With most compilers the second statement will fail (may work with
GCC, for example). The size of any array, as you might know, has to be a
constant expression (i.e. results in compile-time value). The second
variable <del>size2</del> is</p>
<p>assigned some value that is decided at runtime (even though you know
it is <del>10</del>, for the compiler it is not compile-</p>
<p>time).</p>
<p>This means that a <del>const</del> may or may not be a true
compile-time constant. You cannot guarantee or enforce that a particular
<del>const</del> value is absolutely compile-time. You may use
<del>#define</del> but it has its own pitfalls.</p>
<p>Therefore simply use:</p>
<p>Version ≥ C++11</p>
<p>int main()</p>
<p>{</p>
<p>constexpr int size = 10;</p>
<p>int arr[size];</p>
<p>}</p>
<p>A <del>constexpr</del> expression must evaluate to a compile-time
value. Thus, you cannot use:</p>
<p>Version ≥ C++11</p>
<p>constexpr int size = abs(10);</p>
<p>Unless the function (<del>abs</del>) is itself returning a
<del>constexpr</del>.</p>
<p>All basic types can be initialized with <del>constexpr</del>.</p>
<p>Version ≥ C++11</p>
<p>constexpr bool FailFatal = true;</p>
<p>constexpr float PI = 3.14f;</p>
<p>constexpr char* site= "StackOverflow";</p>
<p>Interestingly, and conveniently, you may also use
<del>auto</del>:</p>
<p>Version ≥ C++11</p>
<p>constexpr auto domain = ".COM"; // const char * const domain = ".COM"
constexpr auto PI = 3.14; // constexpr double</p>
<p>Section 119.2: Static if statement</p>
<p>Version ≥ C++17</p>
<p>The <del>if constexpr</del> statement can be used to conditionally
compile code. The condition must be a constant expression. The branch
not selected is discarded. A discarded statement inside a template is
not instantiated. For</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 589</p>
<p><span id="example" class="anchor"></span>example:</p>
<p>template</p>
<p>void g(T &amp;&amp;p, Rest &amp;&amp;...rs)</p>
<p>{</p>
<p>// ... handle p</p>
<p>if constexpr (sizeof...(rs) &gt; 0)</p>
<p>g(rs...); // never instantiated with an empty argument list }</p>
<p>In addition, variables and functions that are odr-used only inside
discarded statements are not required to be defined, and discarded
<del>return</del> statements are not used for function return type
deduction.</p>
<p>if constexpr is distinct from <del>#ifdef</del>. <del>#ifdef</del>
conditionally compiles code, but only based on conditions that can
be</p>
<p>evaluated at preprocessing time. For example, <del>#ifdef</del> could
not be used to conditionally compile code depending</p>
<p>on the value of a template parameter. On the other hand, <del>if
constexpr</del> cannot be used to discard syntactically invalid code,
while <del>#ifdef</del> can.</p>
<p>if constexpr(false) {</p>
<p>foobar; // error; foobar has not been declared</p>
<p><del>std::vector</del> v("hello, world"); // error; no matching
constructor }</p>
<p>Section 119.3: constexpr functions</p>
<p>A function that is declared <del>constexpr</del> is implicitly inline
and calls to such a function potentially yield constant</p>
<p>expressions. For example, the following function, if called with
constant expression arguments, yields a constant</p>
<p>expression too:</p>
<p>Version ≥ C++11</p>
<p>constexpr int Sum(int a, int b)</p>
<p>{</p>
<p>return a + b;</p>
<p>}</p>
<p>Thus, the result of the function call may be used as an array bound
or a template argument, or to initialize a <del>constexpr</del>
variable:</p>
<p>Version ≥ C++11</p>
<p>int main()</p>
<p>{</p>
<p>constexpr int S = Sum(10,20);</p>
<p>int Array[S];</p>
<p>int Array2[Sum(20,30)]; // 50 array size, compile time</p>
<p>}</p>
<p>Note that if you remove <del>constexpr</del> from function's return
type specification, assignment to <del>S</del> will not work, as
<del>S</del> is a <del>constexpr</del> variable, and must be assigned a
compile-time const. Similarly, size of array will also not be a
constant-</p>
<p>expression, if function <del>Sum</del> is not
<del>constexpr</del>.</p>
<p>Interesting thing about <del>constexpr</del> functions is that you
may also use it like ordinary functions:</p>
<p>Version ≥ C++11</p>
<p>int a = 20;</p>
<p>auto sum = Sum(a, abs(-20));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 590</p>
<p>Sum will not be a <del>constexpr</del> function now, it will be
compiled as an ordinary function, taking variable (non-constant)
arguments, and returning non-constant value. You need not to write two
functions.</p>
<p>It also means that if you try to assign such call to a non-const
variable, it won't compile:</p>
<p>Version ≥ C++11</p>
<p>int a = 20;</p>
<p>constexpr auto sum = Sum(a, abs(-20));</p>
<p>The reason is simple: <del>constexpr</del> must only be assigned a
compile-time constant. However, the above function call</p>
<p>makes <del>Sum</del> a non-<del>constexpr</del> (R-value is
non-const, but L-value is declaring itself to be
<del>constexpr</del>).</p>
<p>The <del>constexpr</del> function <strong>must</strong> also return a
compile-time constant. Following will not compile:</p>
<p>Version ≥ C++11</p>
<p>constexpr int Sum(int a, int b)</p>
<p>{</p>
<p>int a1 = a; // ERROR</p>
<p>return a + b;</p>
<p>}</p>
<p>Because <del>a1</del> is a non-constexpr variable, and prohibits the
function from being a true <del>constexpr</del> function. Making it</p>
<p>constexpr and assigning it <del>a</del> will also not work - since
value of <del>a</del> (incoming parameter) is still not yet known:</p>
<p>Version ≥ C++11</p>
<p>constexpr int Sum(int a, int b)</p>
<p>{</p>
<p>constexpr int a1 = a; // ERROR</p>
<p>..</p>
<p>Furthermore, following will also not compile:</p>
<p>Version ≥ C++11</p>
<p>constexpr int Sum(int a, int b)</p>
<p>{</p>
<p>return abs(a) + b; // or abs(a) + abs(b)</p>
<p>}</p>
<p>Since <del>abs(a)</del> is not a constant expression (even
<del>abs(10)</del> will not work, since <del>abs</del> is not returning
a <del>constexpr int</del> !</p>
<p>What about this?</p>
<p>Version ≥ C++11</p>
<p>constexpr int Abs(int v)</p>
<p>{</p>
<p>return v &gt;= 0 ? v :-v;</p>
<p>}</p>
<p>constexpr int Sum(int a, int b)</p>
<p>{</p>
<p>return Abs(a) + b;</p>
<p>}</p>
<p>We crafted our own <del>Abs</del> function which is a
<del>constexpr</del>, and the body of <del>Abs</del> also doesn't break
any rule. Also, at the</p>
<p>call site (inside <del>Sum</del>), the expression evaluates to a
<del>constexpr</del>. Hence, the call to <del>Sum(-10, 20)</del> will be
a compile-time constant expression resulting to <del>30</del>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 591</p>
<p><span id="Chapter_120__One_Definition_Rule_1"
class="anchor"></span>Chapter 120: One Definition Rule (ODR)</p>
<p>Section 120.1: ODR violation via overload resolution</p>
<p>Even with identical tokens for inline functions, ODR can be violated
if lookup of names doesn't refer to the same entity. let's consider
<del>func</del> in following:</p>
<p>header.h</p>
<p>void overloaded(int);</p>
<p>inline void func() { overloaded('*'); }</p>
<p>foo.cpp</p>
<p>#include "header.h"</p>
<p>void foo()</p>
<p>{</p>
<p>func(); // `overloaded` refers to `void overloaded(int)`</p>
<p>}</p>
<p>bar.cpp</p>
<p>void overloaded(char); // can come from other include #include
"header.h"</p>
<p>void bar()</p>
<p>{</p>
<p>func(); // `overloaded` refers to `void overloaded(char)`</p>
<p>}</p>
<p>We have an ODR violation as <del>overloaded</del> refers to different
entities depending of the translation unit.</p>
<p>Section 120.2: Multiply defined function</p>
<p>The most important consequence of the One Definition Rule is that
non-inline functions with external linkage should only be defined once
in a program, although they can be declared multiple times. Therefore,
such functions</p>
<p>should not be defined in headers, since a header can be included
multiple times from different translation units.</p>
<p>foo.h<del>:</del></p>
<p>#ifndef FOO_H</p>
<p>#define FOO_H</p>
<p>#include</p>
<p>void foo() { std::cout &lt;&lt; "foo"; }</p>
<p>void bar();</p>
<p>#endif</p>
<p>foo.cpp<del>:</del></p>
<p>#include "foo.h"</p>
<p>void bar() { std:: cout &lt;&lt; "bar"; }</p>
<p>main.cpp<del>:</del></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 592</p>
<p><span id="_include__foo_h" class="anchor"></span>#include "foo.h"</p>
<p>int main() {</p>
<p>foo();</p>
<p>bar();</p>
<p>}</p>
<p>In this program, the function <del>foo</del> is defined in the header
<del>foo.h</del>, which is included twice: once from <del>foo.cpp</del>
and</p>
<p>once from <del>main.cpp</del>. Each translation unit therefore
contains its own definition of <del>foo</del>. Note that the include
guards in <del>foo.h</del> do not prevent this from happening, since
<del>foo.cpp</del> and <del>main.cpp</del> both separately include
<del>foo.h</del>. The most</p>
<p>likely result of trying to build this program is a link-time error
identifying <del>foo</del> as having been multiply defined.</p>
<p>To avoid such errors, one should declare functions in headers and
define them in the corresponding <del>.cpp</del> files, with</p>
<p>some exceptions (see other examples).</p>
<p>Section 120.3: Inline functions</p>
<p>A function declared <del>inline</del> may be defined in multiple
translation units, provided that all definitions are identical. It</p>
<p>also must be defined in every translation unit in which it is used.
Therefore, inline functions should be defined in headers and there is no
need to mention them in the implementation file.</p>
<p>The program will behave as though there is a single definition of the
function.</p>
<p>foo.h<del>:</del></p>
<p>#ifndef FOO_H</p>
<p>#define FOO_H</p>
<p>#include</p>
<p>inline void foo() { std::cout &lt;&lt; "foo"; }</p>
<p>void bar();</p>
<p>#endif</p>
<p>foo.cpp<del>:</del></p>
<p>#include "foo.h"</p>
<p>void bar() {</p>
<p>// more complicated definition</p>
<p>}</p>
<p>main.cpp<del>:</del></p>
<p>#include "foo.h"</p>
<p>int main() {</p>
<p>foo();</p>
<p>bar();</p>
<p>}</p>
<p>In this example, the simpler function <del>foo</del> is defined
inline in the header file while the more complicated function</p>
<p>bar is not inline and is defined in the implementation file. Both the
<del>foo.cpp</del> and <del>main.cpp</del> translation units contain
definitions of <del>foo</del>, but this program is well-formed since
<del>foo</del> is inline.</p>
<p>A function defined within a class definition (which may be a member
function or a friend function) is implicitly inline. Therefore, if a
class is defined in a header, member functions of the class may be
defined within the class definition,</p>
<p>even though the definitions may be included in multiple translation
units:</p>
<p>// in foo.h</p>
<p>class Foo {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 593</p>
<p>void bar() { std::cout &lt;&lt; "bar"; }</p>
<p>void baz();</p>
<p>};</p>
<p>// in foo.cpp</p>
<p>void Foo::baz() {</p>
<p>// definition</p>
<p>}</p>
<p>The function <del>Foo::baz</del> is defined out-of-line, so it is not
an inline function, and must not be defined in the header.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 594</p>
<p><span id="Chapter_121__Unspecified_behavio_1"
class="anchor"></span>Chapter 121: Unspecified behavior</p>
<p>Section 121.1: Value of an out-of-range enum</p>
<p>If a scoped enum is converted to an integral type that is too small
to hold its value, the resulting value is unspecified. Example:</p>
<p>enum class E {</p>
<p>X = 1,</p>
<p>Y = 1000,</p>
<p>};</p>
<p>// assume 1000 does not fit into a char</p>
<p>char c1 = static_cast<del>(E::X); // c1 is 1</del></p>
<p><del>char c2 = static_cast</del>(E::Y); // c2 has an unspecified
value</p>
<p>Also, if an integer is converted to an enum and the integer's value
is outside the range of the enum's values, the resulting value is
unspecified. Example:</p>
<p>enum Color {</p>
<p>RED = 1,</p>
<p>GREEN = 2,</p>
<p>BLUE = 3,</p>
<p>};</p>
<p>Color c = static_cast<del>(4);</del></p>
<p>However, in the next example, the behavior is not unspecified, since
the source value is within the range of the enum, although it is unequal
to all enumerators:</p>
<p>enum Scale {</p>
<p>ONE = 1,</p>
<p>TWO = 2,</p>
<p>FOUR = 4,</p>
<p>};</p>
<p>Scale s = static_cast<del>(3);</del></p>
<p>Here <del>s</del> will have the value 3, and be unequal to
<del>ONE</del>, <del>TWO</del>, and <del>FOUR</del>.</p>
<p>Section 121.2: Evaluation order of function arguments</p>
<p>If a function has multiple arguments, it is unspecified what order
they are evaluated in. The following code could print <del>x = 1, y =
2</del> or <del>x = 2, y = 1</del> but it is unspecified which.</p>
<p>int f(int x, int y) {</p>
<p>printf("x = %d, y = %d<strong><del>\n</del></strong>", x, y);</p>
<p>}</p>
<p>int get_val() {</p>
<p>static int x = 0;</p>
<p>return ++x;</p>
<p>}</p>
<p>int main() {</p>
<p>f(get_val(), get_val());</p>
<p>}</p>
<p>Version ≥ C++17</p>
<p>In C++17, the order of evaluation of function arguments remains
unspecified.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 595</p>
<p><span id="However__each_function_argument"
class="anchor"></span>However, each function argument is completely
evaluated, and the calling object is guaranteed evaluated before any
function arguments are.</p>
<p>struct from_int {</p>
<p>from_int(int x) { std::cout &lt;&lt; "from_int (" &lt;&lt; x &lt;&lt;
")<strong><del>\n</del></strong>"; } };</p>
<p>int make_int(int x){ std::cout &lt;&lt; "make_int (" &lt;&lt; x
&lt;&lt; ")<strong><del>\n</del></strong>"; return x; }</p>
<p>void foo(from_int a, from_int b) {</p>
<p>}</p>
<p>void bar(from_int a, from_int b) {</p>
<p>}</p>
<p>auto which_func(bool b){</p>
<p>std::cout &lt;&lt; b?"foo":"bar" &lt;&lt;
"<strong><del>\n</del></strong>";</p>
<p>return b?foo:bar;</p>
<p>}</p>
<p>int main(int argc, char const*const* argv) {</p>
<p>which_func( true )( make_int(1), make_int(2) );</p>
<p>}</p>
<p>this must print:</p>
<p>bar</p>
<p>make_int(1)</p>
<p>from_int(1)</p>
<p>make_int(2)</p>
<p>from_int(2)</p>
<p>or</p>
<p>bar</p>
<p>make_int(2)</p>
<p>from_int(2)</p>
<p>make_int(1)</p>
<p>from_int(1)</p>
<p>it may not print <del>bar</del> after any of the <del>make</del> or
<del>from</del>'s, and it may not print:</p>
<p>bar</p>
<p>make_int(2)</p>
<p>make_int(1)</p>
<p>from_int(2)</p>
<p>from_int(1)</p>
<p>or similar. Prior to C++17 printing <del>bar</del> after
<del>make_int</del>s was legal, as was doing both <del>make_int</del>s
prior to doing any</p>
<p>from_int <del>s.</del></p>
<p>Section 121.3: Result of some reinterpret_cast conversions</p>
<p>The result of a <del>reinterpret_cast</del> from one function pointer
type to another, or one function reference type to another, is
unspecified. Example:</p>
<p>int f();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 596</p>
<p><span id="auto_fp___reinterpret_cast__f"
class="anchor"></span><del>auto fp = reinterpret_cast</del>(&amp;f); //
fp has unspecified value</p>
<p>Version ≤ C++03</p>
<p>The result of a <del>reinterpret_cast</del> from one object pointer
type to another, or one object reference type to another, is
unspecified. Example:</p>
<p>int x = 42;</p>
<p><del>char* p = reinterpret_cast</del>(&amp;x); // p has unspecified
value</p>
<p>However, with most compilers, this was equivalent to
<del>static_cast</del>(static_cast(&amp;x)) so the resulting pointer p
pointed to the first byte of x. This was made the standard behavior in
C++11. See type punning</p>
<p>conversion for more details.</p>
<p>Section 121.4: Space occupied by a reference</p>
<p>A reference is not an object, and unlike an object, it is not
guaranteed to occupy some contiguous bytes of memory. The standard
leaves it unspecified whether a reference requires any storage at all. A
number of features of the</p>
<p>language conspire to make it impossible to portably examine any
storage the reference might occupy:</p>
<p>If <del>sizeof</del> is applied to a reference, it returns the size
of the referenced type, thereby giving no information</p>
<p>about whether the reference occupies any storage.</p>
<p>Arrays of references are illegal, so it is not possible to examine
the addresses of two consecutive elements of</p>
<p>a hypothetical reference of arrays in order to determine the size of
a reference.</p>
<p>If the address of a reference is taken, the result is the address of
the referent, so we cannot get a pointer to the reference itself.</p>
<p>If a class has a reference member, attempting to extract the address
of that member using <del>offsetof</del> yields undefined behavior since
such a class is not a standard-layout class.</p>
<p>If a class has a reference member, the class is no longer standard
layout, so attempts to access any data used to store the reference
results in undefined or unspecified behavior.</p>
<p>In practice, in some cases a reference variable may be implemented
similarly to a pointer variable and hence occupy the same amount of
storage as a pointer, while in other cases a reference may occupy no
space at all since</p>
<p>it can be optimized out. For example, in:</p>
<p>void f() {</p>
<p>int x;</p>
<p>int&amp; r = x;</p>
<p>// do something with r</p>
<p>}</p>
<p>the compiler is free to simply treat <del>r</del> as an alias for
<del>x</del> and replace all occurrences of <del>r</del> in the rest of
the function <del>f</del> with <del>x</del>, and not allocate any
storage to hold <del>r</del>.</p>
<p>Section 121.5: Moved-from state of most standard library</p>
<p>classes</p>
<p>Version ≥ C++11</p>
<p>All standard library containers are left in a valid but unspecified
state after being moved from. For example, in the</p>
<p>following code, <del>v2</del> will contain <del>{1, 2, 3, 4}</del>
after the move, but <del>v1</del> is not guaranteed to be empty.</p>
<p>int main() {</p>
<p><del>std::vector</del> v1{1, 2, 3, 4};</p>
<p><del>std::vector</del> v2 = std::move(v1);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 597</p>
<p><span id="_47" class="anchor"></span>}</p>
<p>Some classes do have a precisely defined moved-from state. The most
important case is that of <del>std::unique_ptr</del>, which is
guaranteed to be null after being moved from.</p>
<p>Section 121.6: Result of some pointer comparisons</p>
<p>If two pointers are compared using <del>&lt;</del>, <del>&gt;</del>,
<del>&lt;=</del>, or <del>&gt;=</del>, the result is unspecified in the
following cases:</p>
<p>The pointers point into different arrays. (A non-array object is
considered an array of size 1.)</p>
<p>int x;</p>
<p>int y;</p>
<p>const bool b1 = &amp;x &lt; &amp;y; // unspecified</p>
<p>int a[10];</p>
<p>const bool b2 = &amp;a[0] &lt; &amp;a[1]; // true</p>
<p>const bool b3 = &amp;a[0] &lt; &amp;x; // unspecified</p>
<p>const bool b4 = (a + 9) &lt; (a + 10); // true</p>
<p>// note: a+10 points past the end of the array</p>
<p>The pointers point into the same object, but to members with
different access control.</p>
<p>class A {</p>
<p>public:</p>
<p>int x;</p>
<p>int y;</p>
<p>bool f1() { return &amp;x &lt; &amp;y; } // true; x comes before
y</p>
<p>bool f2() { return &amp;x &lt; &amp;z; } // unspecified</p>
<p>private:</p>
<p>int z;</p>
<p>};</p>
<p>Section 121.7: Static cast from bogus void* value</p>
<p>If a <del>void*</del> value is converted to a pointer to object type,
<del>T*</del>, but is not properly aligned for <del>T</del>, the
resulting pointer value is unspecified. Example:</p>
<p>// Suppose that alignof(int) is 4</p>
<p>int x = 42;</p>
<p>void* p1 = &amp;x;</p>
<p>// Do some pointer arithmetic...</p>
<p>void* p2 = static_cast<del>(p1) + 2;</del></p>
<p>int* p3 = static_cast<del>(p2);</del></p>
<p>The value of <del>p3</del> is unspecified because <del>p2</del>
cannot point to an object of type <del>int</del>; its value is not a
properly aligned</p>
<p>address.</p>
<p>Section 121.8: Order of initialization of globals across TU</p>
<p>Whereas inside a Translation Unit, order of initialization of global
variables is specified, order of initialization across</p>
<p>Translation Units is unspecified.</p>
<p>So program with following files</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 598</p>
<p>foo.cpp</p>
<p>#include</p>
<p>int dummyFoo = ((std::cout &lt;&lt; "foo"), 0);</p>
<p>bar.cpp</p>
<p>#include</p>
<p>int dummyBar = ((std::cout &lt;&lt; "bar"), 0);</p>
<p>main.cpp</p>
<p>int main() {}</p>
<p>might produce as output:</p>
<p>foobar</p>
<p>or</p>
<p>barfoo</p>
<p>That may lead to Static Initialization Order Fiasco.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 599</p>
<p><span id="Chapter_122__Argument_Dependent_1"
class="anchor"></span>Chapter 122: Argument Dependent Name</p>
<p>Lookup</p>
<p>Section 122.1: What functions are found</p>
<p>Functions are found by first collecting a set of "associated classes"
and "associated namespaces" that include one ore more of the following,
depending on the argument type <del>T</del>. First, let us show the
rules for classes, enumeration and</p>
<p>class template specialization names.</p>
<p>If <del>T</del> is a nested class, member enumeration, then the
surrounding class of it.</p>
<p>If <del>T</del> is an enumeration (it may also be a class member!),
the innermost namespace of it. If <del>T</del> is a class (it may also
be nested!), all its base classes and the class itself. The innermost
namespace of all</p>
<p>associated classes.</p>
<p>If <del>T</del> is a <del>ClassTemplate</del> (this is also a
class!), the classes and namespaces associated</p>
<p>with the template type arguments, the namespace of any template
template argument and the surrounding</p>
<p>class of any template template argument, if a template argument is a
member template.</p>
<p>Now there are a few rules for builtin types as well</p>
<p>If <del>T</del> is a pointer to <del>U</del> or array of
<del>U</del>, the classes and namespaces associated with <del>U</del>.
Example: <del>void (*fptr)(A);</del></p>
<p>f(fptr);, includes the namespaces and classes associated with
<del>void(A)</del> (see next rule). If <del>T</del> is a function type,
the classes and namespaces associated with parameter and return types.
Example:</p>
<p>void(A) would includes the namespaces and classes associated with
<del>A</del>.</p>
<p>If <del>T</del> is a pointer to member, the classes and namespaces
associated with the member type (may apply to both pointer to member
functions and pointer to data member!). Example: <del>B A::*p; void
(A::*pf)(B); f(p);</del></p>
<p>f(pf); includes the namespaces and classes associated with
<del>A</del>, <del>B</del>, <del>void(B)</del> (which applies bullet
above for function types).</p>
<p>All functions and templates within all associated namespaces are
found by argument dependent lookup. In addition, namespace-scope friend
functions declared in associated classes are found, which are normally
not visible. Using</p>
<p>directives are ignored, however.</p>
<p>All of the following example calls are valid, without qualifying
<del>f</del> by the namespace name in the call.</p>
<p>namespace A {</p>
<p>struct Z { };</p>
<p>namespace I { void g(Z); }</p>
<p>using namespace I;</p>
<p>struct X { struct Y { }; friend void f(Y) { } };</p>
<p>void f(X p) { }</p>
<p>void f(std::shared_ptr <del>p) { }</del></p>
<p>}</p>
<p>// example calls</p>
<p>f(A::X());</p>
<p>f(A::X::Y());</p>
<p>f(std::make_shared<del>());</del></p>
<p>g(A::Z()); // invalid: "using namespace I;" is ignored!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 600</p>
<p><span id="Chapter_123__Attributes_1" class="anchor"></span>Chapter
123: Attributes</p>
<p>Section 123.1: [[fallthrough]]</p>
<p>Version ≥ C++17</p>
<p>Whenever a <del>case</del> is ended in a <del>switch</del>, the code
of the next case will get executed. This last one can be prevented</p>
<p>by using the ´break` statement. As this so-called fallthrough
behavior can introduce bugs when not intended,</p>
<p>several compilers and static analyzers give a warning on this.</p>
<p>From C++17 on, a standard attribute was introduced to indicate that
the warning is not needed when the code is</p>
<p>meant to fall through. Compilers can safely give warnings when a case
is ended without <del>break</del> or <del>[[fallthrough]]</del> and has
at least one statement.</p>
<p>switch(input) {</p>
<p>case 2011:</p>
<p>case 2014:</p>
<p>case 2017:</p>
<p>std::cout &lt;&lt; "Using modern C++" &lt;&lt; std::endl;</p>
<p>[[fallthrough]]; // &gt; No warning</p>
<p>case 1998:</p>
<p>case 2003:</p>
<p>standard = input;</p>
<p>}</p>
<p><a href="https://isocpp.org/files/papers/P0188R0.pdf">See the
proposal</a> for more detailed examples on how
<del>[[fallthrough]]</del> can be used.</p>
<p>Section 123.2: [[nodiscard]]</p>
<p>Version ≥ C++17</p>
<p>The <del>[[nodiscard]]</del> attribute can be used to indicate that
the return value of a function shouldn't be ignored when</p>
<p>you do a function call. If the return value is ignored, the compiler
should give a warning on this. The attribute can be added to:</p>
<p>A function definition</p>
<p>A type</p>
<p>Adding the attribute to a type has the same behaviour as adding the
attribute to every single function which returns this type.</p>
<p>template</p>
<p><del>[[nodiscard]] Finally</del>&gt; onExit(Function
&amp;&amp;f);</p>
<p>void f(int &amp;i) {</p>
<p>assert(i == 0); // Just to make comments clear!</p>
<p>++i; // i == 1</p>
<p>auto exit1 = onExit([&amp;i]{--i; }); // Reduce by 1 on exiting f()
++i; // i == 2</p>
<p>onExit([&amp;i]{--i; }); // BUG: Reducing by 1 directly</p>
<p>// Compiler warning expected</p>
<p>std::cout &lt;&lt; i &lt;&lt; std::end; // Expected: 2, Real: 1 }</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0068r0.pdf">See
the proposal</a> for more detailed examples on how
<del>[[nodiscard]]</del> can be used.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 601</p>
<p><span id="Note__The_implementation_details"
class="anchor"></span><strong>Note:</strong> The implementation details
of <del>Finally</del>/<del>onExit</del> are omitted in the example, see
Finally/ScopeExit.</p>
<p>Section 123.3: [[deprecated]] and [[deprecated("reason")]]</p>
<p>Version ≥ C++14</p>
<p>C++14 introduced a standard way of deprecating functions via
attributes. <del>[[deprecated]]</del> can be used to indicate that a
function is deprecated. <del>[[deprecated("reason")]]</del> allows
adding a specific reason which can be shown by</p>
<p>the compiler.</p>
<p>void function(std::unique_ptr <del>&amp;&amp;a);</del></p>
<p>// Provides specific message which helps other programmers fixing
there code [[deprecated("Use the variant with unique_ptr instead, this
function will be removed in the next release")]]</p>
<p>void function(std::auto_ptr a);</p>
<p>// No message, will result in generic warning if called.
[[deprecated]]</p>
<p>void function(A *a);</p>
<p>This attribute may be applied to:</p>
<p>the declaration of a class</p>
<p>a typedef-name</p>
<p>a variable</p>
<p>a non-static data member</p>
<p>a function</p>
<p>an enumeration</p>
<p>a template specialization</p>
<p><a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">(ref.
c++14 standard draft: 7.6.5 Deprecated attribute)</a></p>
<p>Section 123.4: [[maybe_unused]]</p>
<p>The <del>[[maybe_unused]]</del> attribute is created for indicating
in code that certain logic might not be used. This if often linked to
preprocessor conditions where this might be used or might not be used.
As compilers can give warnings</p>
<p>on unused variables, this is a way of suppressing them by indicating
intent.</p>
<p>A typical example of variables which are needed in debug builds while
unneeded in production are return values</p>
<p>indicating success. In the debug builds, the condition should be
asserted, though in production these asserts have been removed.</p>
<p>[[maybe_unused]] auto mapInsertResult =
configuration.emplace("LicenseInfo", stringifiedLicenseInfo);</p>
<p>assert(mapInsertResult.second); // We only get called during startup,
so we can't be in the map</p>
<p>A more complex example are different kind of helper functions which
are in an unnamed namespace. If these</p>
<p>functions aren't used during compilation, a compiler might give a
warning on them. Ideally you would like to guard them with the same
preprocessor tags as the caller, though as this might become complex the
<del>[[maybe_unused]]</del></p>
<p>attribute is a more maintainable alternative.</p>
<p>namespace {</p>
<p>[[maybe_unused]] std::string createWindowsConfigFilePath(const
std::string &amp;relativePath);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 602</p>
<p><span id="___TODO__Reuse_this_on_BSD__MAC" class="anchor"></span>//
TODO: Reuse this on BSD, MAC ...</p>
<p>[[maybe_unused]] std::string createLinuxConfigFilePath(const
std::string &amp;relativePath);</p>
<p>}</p>
<p>std::string createConfigFilePath(const std::string &amp;relativePath)
{ #if OS == "WINDOWS"</p>
<p>return createWindowsConfigFilePath(relativePath);</p>
<p>#elif OS == "LINUX"</p>
<p>return createLinuxConfigFilePath(relativePath);</p>
<p>#else</p>
<p>#error "OS is not yet supported"</p>
<p>#endif</p>
<p>}</p>
<p><a href="https://isocpp.org/files/papers/P0212R0.pdf">See the
proposal</a> for more detailed examples on how
<del>[[maybe_unused]]</del> can be used.</p>
<p>Section 123.5: [[noreturn]]</p>
<p>Version ≥ C++11</p>
<p>C++11 introduced the <del>[[noreturn]]</del> attribute. It can be
used for a function to indicate that the function does not</p>
<p>return to the caller by either executing a return statement, or by
reaching the end if it's body (it is important to note</p>
<p>that this does not apply to <del>void</del> functions, since they do
return to the caller, they just do not return any value). Such a
function may end by calling <del>std::terminate</del> or
<del>std::exit</del>, or by throwing an exception. It is also worth
noting</p>
<p>that such a function can return by executing <del>longjmp</del>.</p>
<p>For instance, the function below will always either throw an
exception or call <del>std::terminate</del>, so it is a good</p>
<p>candidate for <del>[[noreturn]]</del>:</p>
<p>[[noreturn]] void ownAssertFailureHandler(std::string message) {</p>
<p>std::cerr &lt;&lt; message &lt;&lt; std::endl;</p>
<p>if (THROW_EXCEPTION_ON_ASSERT)</p>
<p>throw AssertException(std::move(message));</p>
<p>std::terminate();</p>
<p>}</p>
<p>This kind of functionality allows the compiler to end a function
without a return statement if it knows the code will never be executed.
Here, because the call to <del>ownAssertFailureHandler</del> (defined
above) in the code below will</p>
<p>never return, the compiler does not need to add code below that
call:</p>
<p><del>std::vector</del> createSequence(int end) {</p>
<p>if (end &gt; 0) {</p>
<p>std::vector <del>sequence;</del></p>
<p>sequence.reserve(end+1);</p>
<p>for (int i = 0; i &lt;= end; ++i)</p>
<p>sequence.push_back(i);</p>
<p>return sequence;</p>
<p>}</p>
<p>ownAssertFailureHandler("Negative number passed to
createSequence()"s);</p>
<p><del>// return std::vector</del>{}; //&lt; Not needed because of
[[noreturn]]</p>
<p>}</p>
<p>It is undefined behavior if the function will actually return, so the
following is not allowed:</p>
<p>[[noreturn]] void assertPositive(int number) {</p>
<p>if (number &gt;= 0)</p>
<p>return;</p>
<p>else</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 603</p>
<p>ownAssertFailureHandler("Positive number expected"s); //&lt;
[[noreturn]] }</p>
<p>Note that the <del>[[noreturn]]</del> is mostly used in void
functions. However, this is not a requirement, allowing the</p>
<p>functions to be used in generic programming:</p>
<p>template</p>
<p>double fortyTwoDivideBy(int i) {</p>
<p>if (i == 0)</p>
<p>i = InconsistencyHandler::correct(i);</p>
<p>return 42. / i;</p>
<p>}</p>
<p>struct InconsistencyThrower {</p>
<p>static [[noreturn]] int correct(int i) {
ownAssertFailureHandler("Unknown inconsistency"s); }</p>
<p>}</p>
<p>struct InconsistencyChangeToOne {</p>
<p>static int correct(int i) { return 1; }</p>
<p>}</p>
<p><del>double fortyTwo = fortyTwoDivideBy</del>(0); double unreachable
= fortyTwoDivideBy(0);</p>
<p>The following standard library functions have this attribute:</p>
<p>std::abort</p>
<p>std::exit</p>
<p>std::quick_exit</p>
<p>std::unexpected</p>
<p>std::terminate</p>
<p>std::rethrow_exception</p>
<p>std::throw_with_nested</p>
<p>std::nested_exception::rethrow_nested</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 604</p>
<p><span id="Chapter_124__Recursion_in_C_1"
class="anchor"></span>Chapter 124: Recursion in C++</p>
<p>Section 124.1: Using tail recursion and Fibonnaci-style</p>
<p>recursion to solve the Fibonnaci sequence</p>
<p>The simple and most obvious way to use recursion to get the Nth term
of the Fibonnaci sequence is this</p>
<p>int get_term_fib(int n)</p>
<p>{</p>
<p>if (n == 0)</p>
<p>return 0;</p>
<p>if (n == 1)</p>
<p>return 1;</p>
<p>return get_term_fib(n -1) + get_term_fib(n -2);</p>
<p>}</p>
<p>However, this algorithm does not scale for higher terms: for bigger
and bigger <del>n</del>, the number of function calls that</p>
<p>you need to make grows exponentially. This can be replaced with a
simple tail recursion.</p>
<p>int get_term_fib(int n, int prev = 0, int curr = 1)</p>
<p>{</p>
<p>if (n == 0)</p>
<p>return prev;</p>
<p>if (n == 1)</p>
<p>return curr;</p>
<p>return get_term_fib(n -1, curr, prev + curr);</p>
<p>}</p>
<p>Each call to the function now immediately calculates the next term in
the Fibonnaci sequence, so the number of function calls scales linearly
with <del>n</del>.</p>
<p>Section 124.2: Recursion with memoization</p>
<p>Recursive functions can get quite expensive. If they are pure
functions (functions that always return the same value when called with
the same arguments, and that neither depend on nor modify external
state), they can be made</p>
<p>considerably faster at the expense of memory by storing the values
already calculated.</p>
<p>The following is an implementation of the Fibonacci sequence with
memoization:</p>
<p>#include</p>
<p>int fibonacci(int n)</p>
<p>{</p>
<p>static std::map <del>values;</del></p>
<p>if (n==0 || n==1)</p>
<p>return n;</p>
<p><del>std::map</del>::iterator iter = values.find(n);</p>
<p>if (iter == values.end())</p>
<p>{</p>
<p>return values[n] = fibonacci(n-1) + fibonacci(n-2);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>return iter-&gt;second;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 605</p>
<p>Note that despite using the simple recursion formula, on first call
this function is $O(n)$. On subsequent calls with the same value, it is
of course $O(1)$.</p>
<p>Note however that this implementation is not reentrant. Also, it
doesn't allow to get rid of stored values. An alternative implementation
would be to allow the map to be passed as additional argument:</p>
<p>#include</p>
<p>int fibonacci(int n, std::map <del>values)</del></p>
<p>{</p>
<p>if (n==0 || n==1)</p>
<p>return n;</p>
<p><del>std::map</del>::iterator iter = values.find(n);</p>
<p>if (iter == values.end())</p>
<p>{</p>
<p>return values[n] = fibonacci(n-1) + fibonacci(n-2);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>return iter-&gt;second;</p>
<p>}</p>
<p>}</p>
<p>For this version, the caller is required to maintain the map with the
stored values. This has the advantage that the</p>
<p>function is now reentrant, and that the caller can remove values that
are no longer needed, saving memory. It has the disadvantage that it
breaks encapsulation; the caller can change the output by populating the
map with</p>
<p>incorrect values.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 606</p>
<p><span id="Chapter_125__Arithmitic_Metaprog_1"
class="anchor"></span>Chapter 125: Arithmitic Metaprogramming</p>
<p>These are example of using C++ template metaprogramming in processing
arithmitic operations in compile time.</p>
<p>Section 125.1: Calculating power in O(log n)</p>
<p>This example shows an efficient way of calculating power using
template metaprogramming.</p>
<p>template</p>
<p>struct power</p>
<p>{</p>
<p><del>static const int halfvalue = power</del>::value; static const
int value = halfvalue * halfvalue * power::value;</p>
<p>};</p>
<p>template</p>
<p>struct power</p>
<p>{</p>
<p>static const int value = 1;</p>
<p>static_assert(base != 0, "power&lt;0, 0&gt; is not allowed");</p>
<p>};</p>
<p>template</p>
<p>struct power</p>
<p>{</p>
<p>static const int value = base;</p>
<p>};</p>
<p>Example Usage:</p>
<p>std::cout &lt;&lt; power&lt;2, 9&gt;::value;</p>
<p>Version ≥ C++14</p>
<p>This one also handles negative exponents:</p>
<p>template</p>
<p>struct powerDouble</p>
<p>{</p>
<p>static const int exponentAbs = exponent &lt; 0 ? (-exponent) :
exponent; static const int halfvalue =
powerDouble<del>::intermediateValue; static const int intermediateValue
= halfvalue * halfvalue * powerDouble</del></p>
<p>2&gt;::intermediateValue;</p>
<p>constexpr static double value = exponent &lt; 0 ? (1.0 /
intermediateValue) : intermediateValue;</p>
<p>};</p>
<p>template</p>
<p>struct powerDouble</p>
<p>{</p>
<p>static const int intermediateValue = 1;</p>
<p>constexpr static double value = 1;</p>
<p>static_assert(base != 0, "powerDouble&lt;0, 0&gt; is not
allowed");</p>
<p>};</p>
<p>template</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 607</p>
<p>struct powerDouble</p>
<p>{</p>
<p>static const int intermediateValue = base;</p>
<p>constexpr static double value = base;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; powerDouble&lt;2,-3&gt;::value;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 608</p>
<p><span id="Chapter_126__Callable_Objects_1"
class="anchor"></span>Chapter 126: Callable Objects</p>
<p>Callable objects are the collection of all C++ structures which can
be used as a function. In practice, this are all</p>
<p>things you can pass to the C++17 STL function invoke() or which can
be used in the constructor of std::function, this includes: Function
pointers, Classes with operator(), Classes with implicit conversions,
References to functions,</p>
<p>Pointers to member functions, Pointers to member data, lambdas. The
callable objects are used in many STL algorithms as predicate.</p>
<p>Section 126.1: Function Pointers</p>
<p>Function pointers are the most basic way of passing functions around,
which can also be used in C. (See the C documentation for more
details).</p>
<p>For the purpose of callable objects, a function pointer can be
defined as:</p>
<p>typedef returnType(*name)(arguments); // All</p>
<p>using name = returnType(*)(arguments); // &lt;= C++11</p>
<p><del>using name = std::add_pointer</del>::type; // &lt;= C++11 using
name = std::add_pointer_t; // &lt;= C++14</p>
<p>If we would be using a function pointer for writing our own vector
sort, it would look like:</p>
<p><del>using LessThanFunctionPtr = std::add_pointer_t</del>; void
sortVectorInt(std::vector&amp;v, LessThanFunctionPtr lessThan) {</p>
<p>if (v.size() &lt; 2)</p>
<p>return;</p>
<p>if (v.size() == 2) {</p>
<p>if (!lessThan(v.front(), v.back())) // Invoke the function
pointer</p>
<p>std::swap(v.front(), v.back());</p>
<p>return;</p>
<p>}</p>
<p>std::sort(v, lessThan);</p>
<p>}</p>
<p>bool lessThanInt(int lhs, int rhs) { return lhs &lt; rhs; }
sortVectorInt(vectorOfInt, lessThanInt); // Passes the pointer to a free
function</p>
<p>struct GreaterThanInt {</p>
<p>static bool cmp(int lhs, int rhs) { return lhs &gt; rhs; }</p>
<p>};</p>
<p>sortVectorInt(vectorOfInt, &amp;GreaterThanInt::cmp); // Passes the
pointer to a static member function</p>
<p>Alternatively, we could have invoked the function pointer one of
following ways:</p>
<p>(*lessThan)(v.front(), v.back()) // All</p>
<p>std::invoke(lessThan, v.front(), v.back()) // &lt;= C++17</p>
<p>Section 126.2: Classes with operator() (Functors)</p>
<p>Every class which overloads the <del>operator()</del> can be used as
a function object. These classes can be written by hand</p>
<p>(often referred to as functors) or automatically generated by the
compiler by writing Lambdas from C++11 on.</p>
<p>struct Person {</p>
<p>std::string name;</p>
<p>unsigned int age;</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 609</p>
<p>// Functor which find a person by name</p>
<p>struct FindPersonByName {</p>
<p>FindPersonByName(const std::string &amp;name) : _name(name) {}</p>
<p>// Overloaded method which will get called</p>
<p>bool operator()(const Person &amp;person) const {</p>
<p>return person.name == _name;</p>
<p>}</p>
<p>private:</p>
<p>std::string _name;</p>
<p>};</p>
<p><del>std::vector</del> v; // Assume this contains data
std::vector::iterator iFind =</p>
<p>std::find_if(v.begin(), v.end(), FindPersonByName("Foobar")); //
...</p>
<p>As functors have their own identity, they cannot be put in a typedef
and these have to be accepted via template argument. The definition of
<del>std::find_if</del> can look like:</p>
<p>template</p>
<p>Iterator find_if(Iterator begin, Iterator end, Predicate
&amp;predicate) {</p>
<p>for (Iterator i = begin, i != end, ++i)</p>
<p>if (predicate(*i))</p>
<p>return i;</p>
<p>return end;</p>
<p>}</p>
<p>From C++17 on, the calling of the predicate can be done with invoke:
<del>std::invoke(predicate, *i)</del>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 610</p>
<p><span id="Chapter_127__Client_server_examp_1"
class="anchor"></span>Chapter 127: Client server examples</p>
<p>Section 127.1: Hello TCP Client</p>
<p>This program is complimentary to Hello TCP Server program, you can
run either of them to check the validity of each other. The program flow
is quite common with Hello TCP server, so make sure to take a look at
that too.</p>
<p>Here's the code -</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>// Now we're taking an ipaddress and a port number as arguments to
our program if (argc != 3) {</p>
<p>std::cerr &lt;&lt; "Run program as 'program
<del>'<strong>\n</strong>";</del></p>
<p>return-1;</p>
<p>}</p>
<p>auto &amp;ipAddress = argv[1];</p>
<p>auto &amp;portNum = argv[2];</p>
<p>addrinfo hints, *p;</p>
<p>memset(&amp;hints, 0, sizeof(hints));</p>
<p>hints.ai_family = AF_UNSPEC;</p>
<p>hints.ai_socktype = SOCK_STREAM;</p>
<p>hints.ai_flags = AI_PASSIVE;</p>
<p>int gAddRes = getaddrinfo(ipAddress, portNum, &amp;hints, &amp;p); if
(gAddRes != 0) {</p>
<p>std::cerr &lt;&lt; gai_strerror(gAddRes) &lt;&lt;
"<strong><del>\n</del></strong>";</p>
<p>return-2;</p>
<p>}</p>
<p>if (p == NULL) {</p>
<p>std::cerr &lt;&lt; "No addresses
found<strong><del>\n</del></strong>";</p>
<p>return-3;</p>
<p>}</p>
<p>// socket() call creates a new socket and returns it's descriptor int
sockFD = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
if (sockFD ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while creating
socket<strong><del>\n</del></strong>";</p>
<p>return-4;</p>
<p>}</p>
<p>// Note: there is no bind() call as there was in Hello TCP Server //
why? well you could call it though it's not necessary // because client
doesn't necessarily has to have a fixed port number // so next call will
bind it to a random available port number</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 611</p>
<p><span id="___connect___call_tries_to_estab" class="anchor"></span>//
connect() call tries to establish a TCP connection to the specified
server int connectR = connect(sockFD, p-&gt;ai_addr, p-&gt;ai_addrlen);
if (connectR ==-1) {</p>
<p>close(sockFD);</p>
<p>std::cerr &lt;&lt; "Error while connecting
socket<strong><del>\n</del></strong>";</p>
<p>return-5;</p>
<p>}</p>
<p>std::string reply(15, ' ');</p>
<p>// recv() call tries to get the response from server // BUT there's a
catch here, the response might take multiple calls // to recv() before
it is completely received</p>
<p>// will be demonstrated in another example to keep this minimal auto
bytes_recv = recv(sockFD, &amp;reply.front(), reply.size(), 0); if
(bytes_recv ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while receiving
bytes<strong><del>\n</del></strong>";</p>
<p>return-6;</p>
<p>}</p>
<p>std::cout &lt;&lt; "<strong><del>\n</del></strong>Client recieved: "
&lt;&lt; reply &lt;&lt; std::endl;</p>
<p>close(sockFD);</p>
<p>freeaddrinfo(p);</p>
<p>return 0;</p>
<p>}</p>
<p>Section 127.2: Hello TCP Server</p>
<p><a
href="https://beej.us/guide/bgnet/output/html/singlepage/bgnet.html">Let
me start by saying you should first visit Beej's Guide to Network
Programming</a> and give it a quick read, which</p>
<p>explains most of this stuff a bit more verbosely. We'll be creating a
simple TCP server here which will say "Hello</p>
<p>World" to all incoming connections and then close them. Another thing
to note is, the server will be communicating to clients iteratively,
which means one client at a time. Make sure to check out relevant man
pages as they might</p>
<p>contain valuable information about each function call and socket
structures.</p>
<p>We'll run the server with a port, so we'll take an argument for port
number as well. Let's get started with code -</p>
<p><del>#include</del> // sizeof()</p>
<p>#include</p>
<p>#include</p>
<p>// headers for socket(), getaddrinfo() and friends #include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p><del>#include</del> // close()</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>// Let's check if port number is supplied or not.. if (argc != 2)
{</p>
<p>std::cerr &lt;&lt; "Run program as 'program
<del>'<strong>\n</strong>";</del></p>
<p>return-1;</p>
<p>}</p>
<p>auto &amp;portNum = argv[1];</p>
<p>const unsigned int backLog = 8; // number of connections allowed on
the incoming queue</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 612</p>
<p>addrinfo hints, *res, *p; // we need 2 pointers, res to hold and p to
iterate over</p>
<p>memset(&amp;hints, 0, sizeof(hints));</p>
<p>// for more explanation, man socket</p>
<p>hints.ai_family = AF_UNSPEC; // don't specify which IP version to use
yet</p>
<p>hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM refers to TCP,
SOCK_DGRAM will be?</p>
<p>hints.ai_flags = AI_PASSIVE;</p>
<p>// man getaddrinfo</p>
<p>int gAddRes = getaddrinfo(NULL, portNum, &amp;hints, &amp;res); if
(gAddRes != 0) {</p>
<p>std::cerr &lt;&lt; gai_strerror(gAddRes) &lt;&lt;
"<strong><del>\n</del></strong>";</p>
<p>return-2;</p>
<p>}</p>
<p>std::cout &lt;&lt; "Detecting addresses" &lt;&lt; std::endl;</p>
<p>unsigned int numOfAddr = 0;</p>
<p><del>char ipStr[INET6_ADDRSTRLEN];</del> // ipv6 length makes sure
both ipv4/6 addresses can be stored</p>
<p>in this variable</p>
<p>// Now since getaddrinfo() has given us a list of addresses // we're
going to iterate over them and ask user to choose one // address for
program to bind to</p>
<p>for (p = res; p != NULL; p = p-&gt;ai_next) {</p>
<p>void *addr;</p>
<p>std::string ipVer;</p>
<p>// if address is ipv4 address</p>
<p>if (p-&gt;ai_family == AF_INET) {</p>
<p>ipVer = "IPv4";</p>
<p>sockaddr_in *ipv4 = reinterpret_cast<del>(p-&gt;ai_addr);</del></p>
<p>addr = &amp;(ipv4-&gt;sin_addr);</p>
<p>++numOfAddr;</p>
<p>}</p>
<p>// if address is ipv6 address</p>
<p>else {</p>
<p>ipVer = "IPv6";</p>
<p>sockaddr_in6 *ipv6 = reinterpret_cast<del>(p-&gt;ai_addr);</del></p>
<p>addr = &amp;(ipv6-&gt;sin6_addr);</p>
<p>++numOfAddr;</p>
<p>}</p>
<p>// convert IPv4 and IPv6 addresses from binary to text form</p>
<p>inet_ntop(p-&gt;ai_family, addr, ipStr, sizeof(ipStr));</p>
<p>std::cout &lt;&lt; "(" &lt;&lt; numOfAddr &lt;&lt; ") " &lt;&lt;
ipVer &lt;&lt; " : " &lt;&lt; ipStr</p>
<p>&lt;&lt; std::endl;</p>
<p>}</p>
<p>// if no addresses found :(</p>
<p>if (!numOfAddr) {</p>
<p>std::cerr &lt;&lt; "Found no host address to
use<strong><del>\n</del></strong>";</p>
<p>return-3;</p>
<p>}</p>
<p>// ask user to choose an address</p>
<p>std::cout &lt;&lt; "Enter the number of host address to bind with:
";</p>
<p>unsigned int choice = 0;</p>
<p>bool madeChoice = false;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 613</p>
<p>do {</p>
<p>std::cin &gt;&gt; choice;</p>
<p>if (choice &gt; (numOfAddr + 1) || choice &lt; 1) {</p>
<p>madeChoice = false;</p>
<p>std::cout &lt;&lt; "Wrong choice, try again!" &lt;&lt; std::endl;</p>
<p>} else</p>
<p>madeChoice = true;</p>
<p>} while (!madeChoice);</p>
<p>p = res;</p>
<p>// let's create a new socket, socketFD is returned as descriptor //
man socket for more information</p>
<p>// these calls usually return -1 as result of some error int sockFD =
socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol); if
(sockFD ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while creating
socket<strong><del>\n</del></strong>";</p>
<p>freeaddrinfo(res);</p>
<p>return-4;</p>
<p>}</p>
<p>// Let's bind address to our socket we've just created int bindR =
bind(sockFD, p-&gt;ai_addr, p-&gt;ai_addrlen); if (bindR ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while binding
socket<strong><del>\n</del></strong>";</p>
<p>// if some error occurs, make sure to close socket and free
resources</p>
<p>close(sockFD);</p>
<p>freeaddrinfo(res);</p>
<p>return-5;</p>
<p>}</p>
<p>// finally start listening for connections on our socket int listenR
= listen(sockFD, backLog);</p>
<p>if (listenR ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while Listening on
socket<strong><del>\n</del></strong>";</p>
<p>// if some error occurs, make sure to close socket and free
resources</p>
<p>close(sockFD);</p>
<p>freeaddrinfo(res);</p>
<p>return-6;</p>
<p>}</p>
<p>// structure large enough to hold client's address</p>
<p>sockaddr_storage client_addr;</p>
<p>socklen_t client_addr_size = sizeof(client_addr);</p>
<p>const std::string response = "Hello World";</p>
<p>// a fresh infinite loop to communicate with incoming connections //
this will take client connections one at a time // in further examples,
we're going to use fork() call for each client connection while (1)
{</p>
<p>// accept call will give us a new socket descriptor</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 614</p>
<p>int newFD</p>
<p>= accept(sockFD, (sockaddr *) &amp;client_addr,
&amp;client_addr_size);</p>
<p>if (newFD ==-1) {</p>
<p>std::cerr &lt;&lt; "Error while Accepting on
socket<strong><del>\n</del></strong>";</p>
<p>continue;</p>
<p>}</p>
<p>// send call sends the data you specify as second param and it's
length as 3rd param, also</p>
<p>returns how many bytes were actually sent</p>
<p>auto bytes_sent = send(newFD, response.data(), response.length(),
0);</p>
<p>close(newFD);</p>
<p>}</p>
<p>close(sockFD);</p>
<p>freeaddrinfo(res);</p>
<p>return 0;</p>
<p>}</p>
<p>The following program runs as -</p>
<p>Detecting addresses</p>
<p>(1) IPv4 : 0.0.0.0</p>
<p>(2) IPv6 : ::</p>
<p>Enter the number of host address to bind with: 1</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 615</p>
<p><span id="Chapter_128__Const_Correctness_1"
class="anchor"></span>Chapter 128: Const Correctness</p>
<p>Section 128.1: The Basics</p>
<p>const correctness is the practice of designing code so that only code
that needs to modify an instance is able to modify an instance (i.e. has
write access), and conversely, that any code that doesn't need to modify
an instance is</p>
<p>unable to do so (i.e. only has read access). This prevents the
instance from being modified unintentionally, making code less
errorprone, and documents whether the code is intended to change the
instance's state or not. It also</p>
<p>allows instances to be treated as <del>const</del> whenever they
don't need to be modified, or defined as <del>const</del> if they don't
need to be changed after initialisation, without losing any
functionality.</p>
<p>This is done by giving member functions <del>const</del>
CV-qualifiers, and by making pointer/reference parameters
<del>const</del>, except in the case that they need write access.</p>
<p>class ConstCorrectClass {</p>
<p>int x;</p>
<p>public:</p>
<p>int getX() const { return x; } // Function is const: Doesn't modify
instance. void setX(int i) { x = i; } // Not const: Modifies
instance.</p>
<p>};</p>
<p>// Parameter is const: Doesn't modify parameter.</p>
<p>int const_correct_reader(const ConstCorrectClass&amp; c) {</p>
<p>return c.getX();</p>
<p>}</p>
<p>// Parameter isn't const: Modifies parameter.</p>
<p>void const_correct_writer(ConstCorrectClass&amp; c) {</p>
<p>c.setX(42);</p>
<p>}</p>
<p>const ConstCorrectClass invariant; // Instance is const: Can't be
modified. ConstCorrectClass variant; // Instance isn't const: Can be
modified.</p>
<p>// ...</p>
<p>const_correct_reader(invariant); // Good. Calling non-modifying
function on const instance. const_correct_reader(variant); <del>// Good.
Calling non-modifying function on modifiable instance.</del></p>
<p><del>const_correct_writer(variant);</del> // Good. Calling modifying
function on modifiable instance.</p>
<p>const_correct_writer(invariant); // Error. Calling modifying function
on const instance.</p>
<p>Due to the nature of const correctness, this starts with the class'
member functions, and works its way outwards; if you try to call a
non-<del>const</del> member function from a <del>const</del> instance,
or from a non-<del>const</del> instance being treated as</p>
<p><del>const</del>, the compiler will give you an error about it losing
cv-qualifiers.</p>
<p>Section 128.2: Const Correct Class Design</p>
<p>In a <del>const</del>-correct class, all member functions which don't
change logical state have <del>this</del> cv-qualified as
<del>const</del>,</p>
<p>indicating that they don't modify the object (apart from any
<del>mutable</del> fields, which can freely be modified even in const
instances); if a <del>const</del> cv-qualified function returns a
reference, that reference should also be <del>const</del>. This</p>
<p>allows them to be called on both constant and non-cv-qualified
instances, as a <del>const T*</del> is capable of binding to</p>
<p>either a <del>T*</del> or a <del>const T*</del>. This, in turn,
allows functions to declare their passed-by-reference parameters as
<del>const</del> when they don't need to be modified, without losing any
functionality.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 616</p>
<p>Furthermore, in a <del>const</del> correct class, all
passed-by-reference function parameters will be <del>const</del>
correct, as discussed in <del>Const Correct Function Parameters</del>,
so that they can only be modified when the function explicitly</p>
<p>needs to modify them.</p>
<p>First, let's look at <del>this</del> cv-qualifiers:</p>
<p>// Assume class Field, with member function "void
insert_value(int);".</p>
<p>class ConstIncorrect {</p>
<p>Field fld;</p>
<p>public:</p>
<p>ConstIncorrect(Field&amp; f); // Modifies.</p>
<p>Field&amp; getField(); // Might modify. Also exposes member as
non-const reference,</p>
<p>// allowing indirect modification.</p>
<p>void setField(Field&amp; f); // Modifies.</p>
<p>void doSomething(int i); // Might modify.</p>
<p>void doNothing(); // Might modify.</p>
<p>};</p>
<p>ConstIncorrect::ConstIncorrect(Field&amp; f) : fld(f) {} // Modifies.
Field&amp; ConstIncorrect::getField() { return fld; } // Doesn't modify.
void ConstIncorrect::setField(Field&amp; f) { fld = f; } // Modifies.
void ConstIncorrect::doSomething(int i) { // Modifies.</p>
<p>fld.insert_value(i);</p>
<p>}</p>
<p>void ConstIncorrect::doNothing() {} // Doesn't modify.</p>
<p>class ConstCorrectCVQ {</p>
<p>Field fld;</p>
<p>public:</p>
<p>ConstCorrectCVQ(Field&amp; f); // Modifies.</p>
<p>const Field&amp; getField() const; // Doesn't modify. Exposes member
as const reference,</p>
<p>// preventing indirect modification.</p>
<p>void setField(Field&amp; f); // Modifies.</p>
<p>void doSomething(int i); // Modifies.</p>
<p>void doNothing() const; // Doesn't modify.</p>
<p>};</p>
<p>ConstCorrectCVQ::ConstCorrectCVQ(Field&amp; f) : fld(f) {} Field&amp;
ConstCorrectCVQ::getField() const { return fld; } void
ConstCorrectCVQ::setField(Field&amp; f) { fld = f; } void
ConstCorrectCVQ::doSomething(int i) {</p>
<p>fld.insert_value(i);</p>
<p>}</p>
<p>void ConstCorrectCVQ::doNothing() const {}</p>
<p>// This won't work.</p>
<p>// No member functions can be called on const ConstIncorrect
instances. void const_correct_func(const ConstIncorrect&amp; c) {</p>
<p>Field f = c.getField();</p>
<p>c.do_nothing();</p>
<p>}</p>
<p>// But this will.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 617</p>
<p><span id="___getField___and_doNothing___ca" class="anchor"></span>//
getField() and doNothing() can be called on const ConstCorrectCVQ
instances. void const_correct_func(const ConstCorrectCVQ&amp; c) {</p>
<p>Field f = c.getField();</p>
<p>c.do_nothing();</p>
<p>}</p>
<p>We can then combine this with <del>Const Correct Function
Parameters</del>, causing the class to be fully
<del>const</del>-correct.</p>
<p>class ConstCorrect {</p>
<p>Field fld;</p>
<p>public:</p>
<p>ConstCorrect(const Field&amp; f); // Modifies instance. Doesn't
modify parameter.</p>
<p>const Field&amp; getField() const; // Doesn't modify. Exposes member
as const reference,</p>
<p>// preventing indirect modification.</p>
<p>void setField(const Field&amp; f); // Modifies instance. Doesn't
modify parameter.</p>
<p>void doSomething(int i); // Modifies. Doesn't modify parameter
(passed by value). void doNothing() const; // Doesn't modify.</p>
<p>};</p>
<p>ConstCorrect::ConstCorrect(const Field&amp; f) : fld(f) {} Field&amp;
ConstCorrect::getField() const { return fld; }</p>
<p>void ConstCorrect::setField(const Field&amp; f) { fld = f; } void
ConstCorrect::doSomething(int i) {</p>
<p>fld.insert_value(i);</p>
<p>}</p>
<p>void ConstCorrect::doNothing() const {}</p>
<p>This can also be combined with overloading based on
<del>const</del>ness, in the case that we want one behaviour if the
instance is <del>const</del>, and a different behaviour if it isn't; a
common use for this is constainers providing accessors that</p>
<p>only allow modification if the container itself is
non-<del>const</del>.</p>
<p>class ConstCorrectContainer {</p>
<p>int arr[5];</p>
<p>public:</p>
<p>// Subscript operator provides read access if instance is const, or
read/write access // otherwise.</p>
<p>int&amp; operator[](size_t index) { return arr[index]; }</p>
<p>const int&amp; operator[](size_t index) const { return arr[index];
}</p>
<p>// ...</p>
<p>};</p>
<p>This is commonly used in the standard library, with most containers
providing overloads to take <del>const</del>ness into account.</p>
<p>Section 128.3: Const Correct Function Parameters</p>
<p>In a <del>const</del>-correct function, all passed-by-reference
parameters are marked as <del>const</del> unless the function directly
or</p>
<p>indirectly modifies them, preventing the programmer from
inadvertently changing something they didn't mean to</p>
<p>change. This allows the function to take both <del>const</del> and
non-cv-qualified instances, and in turn, causes the instance's
<del>this</del> to be of type <del>const T*</del> when a member function
is called, where <del>T</del> is the class' type.</p>
<p>struct Example {</p>
<p>void func() { std::cout &lt;&lt; 3 &lt;&lt; std::endl; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 618</p>
<p>void func() const { std::cout &lt;&lt; 5 &lt;&lt; std::endl; }</p>
<p>};</p>
<p>void const_incorrect_function(Example&amp; one, Example* two) {</p>
<p>one.func();</p>
<p>two-&gt;func();</p>
<p>}</p>
<p>void const_correct_function(const Example&amp; one, const Example*
two) {</p>
<p>one.func();</p>
<p>two-&gt;func();</p>
<p>}</p>
<p>int main() {</p>
<p>Example a, b;</p>
<p>const_incorrect_function(a, &amp;b);</p>
<p>const_correct_function(a, &amp;b);</p>
<p>}</p>
<p>// Output:</p>
<p>3</p>
<p>3</p>
<p>5</p>
<p>5</p>
<p>While the effects of this are less immediately visible than those of
<del>const</del> correct class design (in that <del>const</del>-correct
functions and <del>const</del>-incorrect classes will cause compilation
errors, while <del>const</del>-correct classes and
<del>const</del>-incorrect</p>
<p>functions will compile properly), <del>const</del> correct functions
will catch a lot of errors that <del>const</del> incorrect functions
would let slip through, such as the one below. [Note, however, that a
<del>const</del>-incorrect function will cause</p>
<p>compilation errors if passed a <del>const</del> instance when it
expected a non-<del>const</del> one.]</p>
<p>// Read value from vector, then compute &amp; return a value. //
Caches return values for speed.</p>
<p>template</p>
<p>const T&amp; bad_func(std::vector<del>&amp; v, Helper&amp; h)
{</del></p>
<p>// Cache values, for future use.</p>
<p>// Once a return value has been calculated, it's cached &amp; its
index is registered. static std::vector <del>vals = {};</del></p>
<p>int v_ind = h.get_index(); // Current working index for v. int
vals_ind = h.get_cache_index(v_ind); // Will be -1 if cache index isn't
registered.</p>
<p>if (vals.size() &amp;&amp; (vals_ind !=-1) &amp;&amp; (vals_ind &lt;
vals.size()) &amp;&amp; !(h.needs_recalc())) {</p>
<p>return vals[h.get_cache_index(v_ind)];</p>
<p>}</p>
<p>T temp = v[v_ind];</p>
<p>temp -= h.poll_device();</p>
<p>temp *= h.obtain_random();</p>
<p>temp += h.do_tedious_calculation(temp,
v[h.get_last_handled_index()]);</p>
<p>// We're feeling tired all of a sudden, and this happens. if
(vals_ind !=-1) {</p>
<p>vals[vals_ind] = temp;</p>
<p>} else {</p>
<p>v.push_back(temp); // Oops. Should've been accessing vals.</p>
<p>vals_ind = vals.size()-1;</p>
<p>h.register_index(v_ind, vals_ind);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 619</p>
<p><span id="return_vals_vals_ind" class="anchor"></span>return
vals[vals_ind];</p>
<p>}</p>
<p>// Const correct version. Is identical to above version, so most of
it shall be skipped. template</p>
<p>const T&amp; good_func(const std::vector<del>&amp; v, Helper&amp; h)
{</del></p>
<p>// ...</p>
<p>// We're feeling tired all of a sudden, and this happens. if
(vals_ind !=-1) {</p>
<p>vals[vals_ind] = temp;</p>
<p>} else {</p>
<p>v.push_back(temp); // Error: discards qualifiers.</p>
<p>vals_ind = vals.size()-1;</p>
<p>h.register_index(v_ind, vals_ind);</p>
<p>}</p>
<p>return vals[vals_ind];</p>
<p>}</p>
<p>Section 128.4: Const Correctness as Documentation</p>
<p>One of the more useful things about <del>const</del> correctness is
that it serves as a way of documenting code, providing</p>
<p>certain guarantees to the programmer and other users. These
guarantees are enforced by the compiler due to constness, with a lack of
<del>const</del>ness in turn indicating that code doesn't provide
them.</p>
<p>const CV-Qualified Member Functions:</p>
<p>Any member function which is <del>const</del> can be assumed to have
intent to read the instance, and:</p>
<p>Shall not modify the logical state of the instance they are called
on. Therefore, they shall not modify</p>
<p>any member variables of the instance they are called on, except
<del>mutable</del> variables. Shall not call any other functions that
would modify any member variables of the instance, except</p>
<p><del>mutable</del> variables.</p>
<p>Conversely, any member function which isn't <del>const</del> can be
assumed to have intent to modify the instance,</p>
<p>and:</p>
<p>May or may not modify logical state.</p>
<p>May or may not call other functions which modify logical state.</p>
<p>This can be used to make assumptions about the state of the object
after any given member function is called, even</p>
<p>without seeing the definition of that function:</p>
<p>// ConstMemberFunctions.h</p>
<p>class ConstMemberFunctions {</p>
<p>int val;</p>
<p>mutable int cache;</p>
<p>mutable bool state_changed;</p>
<p>public:</p>
<p>// Constructor clearly changes logical state. No assumptions
necessary.</p>
<p>ConstMemberFunctions(int v = 0);</p>
<p>// We can assume this function doesn't change logical state, and
doesn't call // set_val(). It may or may not call squared_calc() or
bad_func(). int calc() const;</p>
<p>// We can assume this function doesn't change logical state, and
doesn't call // set_val(). It may or may not call calc() or
bad_func().</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 620</p>
<p>int squared_calc() const;</p>
<p>// We can assume this function doesn't change logical state, and
doesn't call // set_val(). It may or may not call calc() or
squared_calc(). void bad_func() const;</p>
<p>// We can assume this function changes logical state, and may or may
not call // calc(), squared_calc(), or bad_func().</p>
<p>void set_val(int v);</p>
<p>};</p>
<p>Due to <del>const</del> rules, these assumptions will in fact be
enforced by the compiler.</p>
<p>// ConstMemberFunctions.cpp</p>
<p>ConstMemberFunctions::ConstMemberFunctions(int v <del>/* =
0*/</del>)</p>
<p>: cache(0), val(v), state_changed(true) {}</p>
<p>// Our assumption was correct.</p>
<p>int ConstMemberFunctions::calc() const {</p>
<p>if (state_changed) {</p>
<p>cache = 3 * val;</p>
<p>state_changed = false;</p>
<p>}</p>
<p>return cache;</p>
<p>}</p>
<p>// Our assumption was correct.</p>
<p>int ConstMemberFunctions::squared_calc() const {</p>
<p>return calc() * calc();</p>
<p>}</p>
<p>// Our assumption was incorrect.</p>
<p>// Function fails to compile, due to `this` losing qualifiers. void
ConstMemberFunctions::bad_func() const {</p>
<p>set_val(863);</p>
<p>}</p>
<p>// Our assumption was correct.</p>
<p>void ConstMemberFunctions::set_val(int v) {</p>
<p>if (v != val) {</p>
<p>val = v;</p>
<p>state_changed = true;</p>
<p>}</p>
<p>}</p>
<p>const Function Parameters:</p>
<p>Any function with one or more parameters which are <del>const</del>
can be assumed to have intent to read those</p>
<p>parameters, and:</p>
<p>Shall not modify those parameters, or call any member functions that
would modify them.</p>
<p>Shall not pass those parameters to any other function which would
modify them and/or call any</p>
<p>member functions that would modify them.</p>
<p>Conversely, any function with one or more parameters which aren't
<del>const</del> can be assumed to have intent to</p>
<p>modify those parameters, and:</p>
<p>May or may not modify those parameters, or call any member functions
which whould modify them.</p>
<p>May or may not pass those parameters to other functions which would
modify them and/or call any member functions that would modify them.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 621</p>
<p>This can be used to make assumptions about the state of the
parameters after being passed to any given function, even without seeing
the definition of that function.</p>
<p>// function_parameter.h</p>
<p>// We can assume that c isn't modified (and c.set_val() isn't
called), and isn't passed // to non_qualified_function_parameter(). If
passed to one_const_one_not(), it is the first // parameter.</p>
<p>void const_function_parameter(const ConstMemberFunctions&amp; c);</p>
<p>// We can assume that c is modified and/or c.set_val() is called, and
may or may not be passed // to any of these functions. If passed to
one_const_one_not, it may be either parameter. void
non_qualified_function_parameter(ConstMemberFunctions&amp; c);</p>
<p>// We can assume that:</p>
<p>// l is not modified, and l.set_val() won't be called. // l may or
may not be passed to const_function_parameter(). // r is modified,
and/or r.set_val() may be called. // r may or may not be passed to
either of the preceding functions.</p>
<p>void one_const_one_not(const ConstMemberFunctions&amp; l,
ConstMemberFunctions&amp; r);</p>
<p>// We can assume that c isn't modified (and c.set_val() isn't
called), and isn't passed // to non_qualified_function_parameter(). If
passed to one_const_one_not(), it is the first // parameter.</p>
<p>void bad_parameter(const ConstMemberFunctions&amp; c);</p>
<p>Due to <del>const</del> rules, these assumptions will in fact be
enforced by the compiler.</p>
<p>// function_parameter.cpp</p>
<p>// Our assumption was correct.</p>
<p>void const_function_parameter(const ConstMemberFunctions&amp; c)
{</p>
<p>std::cout &lt;&lt; "With the current value, the output is: " &lt;&lt;
c.calc() &lt;&lt; '<strong><del>\n</del></strong>'</p>
<p>&lt;&lt; "If squared, it's: " &lt;&lt; c.squared_calc()</p>
<p>&lt;&lt; std::endl;</p>
<p>}</p>
<p>// Our assumption was correct.</p>
<p>void non_qualified_function_parameter(ConstMemberFunctions&amp; c)
{</p>
<p>c.set_val(42);</p>
<p>std::cout &lt;&lt; "For the value 42, the output is: " &lt;&lt;
c.calc() &lt;&lt; '<strong><del>\n</del></strong>'</p>
<p>&lt;&lt; "If squared, it's: " &lt;&lt; c.squared_calc()</p>
<p>&lt;&lt; std::endl;</p>
<p>}</p>
<p>// Our assumption was correct, in the ugliest possible way. // Note
that const correctness doesn't prevent encapsulation from intentionally
being broken, // it merely prevents code from having write access when
it doesn't need it. void one_const_one_not(const
ConstMemberFunctions&amp; l, ConstMemberFunctions&amp; r) {</p>
<p>// Let's just punch access modifiers and common sense in the face
here. struct Machiavelli {</p>
<p>int val;</p>
<p>int unimportant;</p>
<p>bool state_changed;</p>
<p>};</p>
<p><del>reinterpret_cast</del>(r).val = l.calc();</p>
<p><del>reinterpret_cast</del>(r).state_changed = true;</p>
<p>const_function_parameter(l);</p>
<p>const_function_parameter(r);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 622</p>
<p>// Our assumption was incorrect.</p>
<p>// Function fails to compile, due to `this` losing qualifiers in
c.set_val(). void bad_parameter(const ConstMemberFunctions&amp; c) {</p>
<p>c.set_val(18);</p>
<p>}</p>
<p>While it is possible to circumvent <del>const</del> correctness, and
by extension break these guarantees, this must be done intentionally by
the programmer (just like breaking encapsulation with
<del>Machiavelli</del>, above), and is likely to cause</p>
<p>undefined behaviour.</p>
<p>class DealBreaker : public ConstMemberFunctions {</p>
<p>public:</p>
<p>DealBreaker(int v = 0);</p>
<p>// A foreboding name, but it's const...</p>
<p>void no_guarantees() const;</p>
<p>}</p>
<p>DealBreaker::DealBreaker(int v <del>/* = 0 */</del>) :
ConstMemberFunctions(v) {}</p>
<p>// Our assumption was incorrect.</p>
<p>// const_cast removes const-ness, making the compiler think we know
what we're doing. void DealBreaker::no_guarantees() const {</p>
<p><del>const_cast</del>(this)-&gt;set_val(823);</p>
<p>}</p>
<p>// ...</p>
<p>const DealBreaker d(50);</p>
<p>d.no_guarantees(); // Undefined behaviour: d really IS const, it may
or may not be modified.</p>
<p>However, due to this requiring the programmer to very specifically
tell the compiler that they intend to ignore constness, and being
inconsistent across compilers, it is generally safe to assume that
<del>const</del> correct code will</p>
<p>refrain from doing so unless otherwise specified.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 623</p>
<p><span id="Chapter_129__Parameter_packs_1"
class="anchor"></span>Chapter 129: Parameter packs</p>
<p>Section 129.1: A template with a parameter pack</p>
<p><del>template</del> struct Tuple {};</p>
<p>A parameter pack is a template parameter accepting zero or more
template arguments. If a template has at least</p>
<p>one parameter pack is a variadic template.</p>
<p>Section 129.2: Expansion of a parameter pack</p>
<p>The pattern <del>parameter_pack ...</del> is expanded into a list of
comma-separated substitutions of <del>parameter_pack</del> with</p>
<p>each one of its parameters</p>
<p><del>template</del> // Base of recursion</p>
<p>void variadic_printer(T last_argument) {</p>
<p>std::cout &lt;&lt; last_argument;</p>
<p>}</p>
<p>template</p>
<p>void variadic_printer(T first_argument, Args... other_arguments) {
std::cout &lt;&lt; first_argument &lt;&lt;
"<strong><del>\n</del></strong>";</p>
<p>variadic_printer(other_arguments...); // Parameter pack expansion
}</p>
<p>The code above invoked with <del>variadic_printer(1, 2, 3,
"hello");</del> prints</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>hello</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 624</p>
<p><span id="Chapter_130__Build_Systems_1" class="anchor"></span>Chapter
130: Build Systems</p>
<p>C++, like C, has a long and varied history regarding compilation
workflows and build processes. Today, C++ has</p>
<p>various popular build systems that are used to compile programs,
sometimes for multiple platforms within one build system. Here, a few
build systems will be reviewed and analyzed.</p>
<p>Section 130.1: Generating Build Environment with CMake</p>
<p><a href="https://cmake.org/">CMake</a> generates build environments
for nearly any compiler or IDE from a single project definition. The
following examples will demonstrate how to add a CMake file to the
cross-platform "Hello World" C++ code.</p>
<p>CMake files are always named "CMakeLists.txt" and should already
exist in every project's root directory (and possibly in sub-directories
too.) A basic CMakeLists.txt file looks like:</p>
<p>cmake_minimum_required(VERSION 2.4)</p>
<p>project(HelloWorld)</p>
<p>add_executable(HelloWorld main.cpp)</p>
<p><a href="http://coliru.stacked-crooked.com/a/616a0939bdd91b8b">See it
live on Coliru.</a></p>
<p>This file tells CMake the project name, what file version to expect,
and instructions to generate an executable called</p>
<p>"HelloWorld" that requires <del>main.cpp</del>.</p>
<p>Generate a build environment for your installed compiler/IDE from the
command line:</p>
<p>&gt; cmake .</p>
<p>Build the application with:</p>
<p>&gt; cmake --build .</p>
<p>This generates the default build environment for the system,
depending on the OS and installed tools. Keep source code clean from any
build artifacts with use of "out-of-source" builds:</p>
<p>&gt; mkdir <strong><del>build</del></strong></p>
<p><strong><del>&gt; cd</del></strong> build</p>
<p><strong><del>&gt;</del></strong> cmake ..</p>
<p><strong><del>&gt;</del></strong> cmake --build .</p>
<p>CMake can also abstract the platform shell's basic commands from the
previous example:</p>
<p>&gt; cmake -E make_directory build</p>
<p>&gt; cmake -E chdir build cmake ..</p>
<p>&gt; cmake --build build</p>
<p>CMake includes <a
href="https://cmake.org/cmake/help/v3.0/manual/cmake-generators.7.html">generators</a>
for a number of common build tools and IDEs. To generate makefiles for
<a href="https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx">Visual
Studio's</a></p>
<p><a
href="https://msdn.microsoft.com/en-us/library/dd9y37ha.aspx">nmake</a>:</p>
<p>&gt; cmake -G "NMake Makefiles" ..</p>
<p>&gt; nmake</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 625</p>
<p><span id="Section_130_2__Compiling_with_GN"
class="anchor"></span>Section 130.2: Compiling with GNU make</p>
<p>Introduction</p>
<p>The GNU Make (styled <del>make</del>) is a program dedicated to the
automation of executing shell commands. GNU Make is one specific program
that falls under the Make family. Make remains popular among Unix-like
and POSIX-like</p>
<p>operating systems, including those derived from the Linux kernel, Mac
OS X, and BSD.</p>
<p>GNU Make is especially notable for being attached to the GNU Project,
which is attached to the popular GNU/Linux</p>
<p>operating system. GNU Make also has compatible versions running on
various flavors of Windows and Mac OS X. It is also a very stable
version with historical significance that remains popular. It is for
these reasons that GNU Make</p>
<p>is often taught alongside C and C++.</p>
<p>Basic rules</p>
<p>To compile with make, create a Makefile in your project directory.
Your Makefile could be as simple as:</p>
<p>Makefile</p>
<p># Set some variables to use in our command</p>
<p># First, we set the compiler to be g++</p>
<p>CXX=g++</p>
<p># Then, we say that we want to compile with g++'s recommended
warnings and some extra ones. CXXFLAGS=-Wall -Wextra -pedantic</p>
<p># This will be the output file</p>
<p>EXE=app</p>
<p>SRCS=main.cpp</p>
<p># When you call `make` at the command line, this "target" is called.
# The $(EXE) at the right says that the `all` target depends on the
`$(EXE)` target. # $(EXE) expands to be the content of the EXE variable
# Note: Because this is the first target, it becomes the default target
if `make` is called without target</p>
<p>all: $(EXE)</p>
<p># This is equivalent to saying</p>
<p># app: $(SRCS)</p>
<p># $(SRCS) can be separated, which means that this target would depend
on each file. # Note that this target has a "method body": the part
indented by a tab (not four spaces). # When we build this target, make
will execute the command, which is: # g++ -Wall -Wextra -pedantic -o app
main.cpp</p>
<p># I.E. Compile main.cpp with warnings, and output to the file ./app
$(EXE): $(SRCS)</p>
<p>@$(CXX) $(CXXFLAGS)-o $@ $(SRCS)</p>
<p># This target should reverse the `all` target. If you call # make
with an argument, like `make clean`, the corresponding target # gets
called.</p>
<p>clean:</p>
<p>@rm -f $(EXE)</p>
<p>NOTE: Make absolutely sure that the indentations are with a tab, not
with four spaces. Otherwise,</p>
<p><strong><del>you'll get an error of</del></strong> Makefile:10: ***
missing separator. Stop.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 626</p>
<p>To run this from the command-line, do the following:</p>
<p>$ <strong><del>cd</del></strong>
~<strong><del>/</del></strong>Path<strong><del>/</del></strong>to<strong><del>/</del></strong>project</p>
<p><strong><del>$</del></strong> make</p>
<p>$ <strong><del>ls</del></strong></p>
<p>app main.cpp Makefile</p>
<p>$ .<strong><del>/</del></strong>app</p>
<p>Hello World<strong><del>!</del></strong></p>
<p>$ <strong><del>make</del></strong> clean</p>
<p>$ <strong><del>ls</del></strong></p>
<p>main.cpp Makefile</p>
<p>Incremental builds</p>
<p>When you start having more files, make becomes more useful. What if
you edited <strong>a.cpp</strong> but not <strong>b.cpp</strong>?
Recompiling</p>
<p><strong>b.cpp</strong> would take more time.</p>
<p>With the following directory structure:</p>
<p>.</p>
<p>+-- src</p>
<p>| +-- a.cpp</p>
<p>| +-- a.hpp</p>
<p>| +-- b.cpp</p>
<p>| +-- b.hpp</p>
<p>+-- Makefile</p>
<p>This would be a good Makefile:</p>
<p>Makefile</p>
<p>CXX=g++</p>
<p>CXXFLAGS=-Wall -Wextra -pedantic</p>
<p>EXE=app</p>
<p>SRCS_GLOB=src<del>/*.cpp</del></p>
<p>SRCS=$(wildcard $(SRCS_GLOB))</p>
<p>OBJS=$(SRCS:.cpp=.o)</p>
<p>all: $(EXE)</p>
<p>$(EXE): $(OBJS)</p>
<p>@$(CXX) -o $@ $(OBJS)</p>
<p>depend: .depend</p>
<p>.depend: $(SRCS)</p>
<p>@-rm -f ./.depend</p>
<p>@$(CXX) $(CXXFLAGS) -MM $^&gt;&gt;./.depend</p>
<p>clean:</p>
<p>-rm -f $(EXE)</p>
<p>-rm $(OBJS)</p>
<p>-rm *~</p>
<p>-rm .depend</p>
<p>include .depend</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 627</p>
<p><span id="Again_watch_the_tabs__This_new_M"
class="anchor"></span>Again watch the tabs. This new Makefile ensures
that you only recompile changed files, minimizing compile time.</p>
<p>Documentation</p>
<p>For more on make, see <a
href="https://www.gnu.org/software/make/manual/">the official
documentation by the Free Software Foundation</a>, the stackoverflow</p>
<p><a href="http://stackoverflow.com/a/2481326/1896169">documentation
and dmckee's elaborate answer on stackoverflow.</a></p>
<p>Section 130.3: Building with SCons</p>
<p><a href="http://scons.org/">You can build the cross-platform "Hello
World" C++ code, using Scons</a> <a href="https://www.python.org/">- A
Python</a>-language software construction</p>
<p>tool.</p>
<p>First, create a file called <del>SConstruct</del> (note that SCons
will look for a file with this exact name by default). For now,</p>
<p>the file should be in a directory right along your
<del>hello.cpp</del>. Write in the new file the line</p>
<p>Program('hello.cpp')</p>
<p>Now, from the terminal, run <del>scons</del>. You should see
something like</p>
<p>$ scons</p>
<p>scons: Reading SConscript files ...</p>
<p>scons: done reading SConscript files.</p>
<p>scons: Building targets ...</p>
<p>g++-o hello.o-c hello.cpp</p>
<p>g++-o hello hello.o</p>
<p>scons: done building targets.</p>
<p>(although the details will vary depending on your operating system
and installed compiler).</p>
<p>The <del>Environment</del> and <del>Glob</del> classes will help you
further configure what to build. E.g., the <del>SConstruct</del>
file</p>
<p>env=Environment(CPPPATH='/usr/include/boost/',</p>
<p>CPPDEFINES=[],</p>
<p>LIBS=[],</p>
<p>SCONS_CXX_STANDARD="c++11"</p>
<p>)</p>
<p>env.Program('hello', Glob('src/*.cpp'))</p>
<p>builds the executable <del>hello</del>, using all <del>cpp</del>
files in <del>src</del>. Its <del>CPPPATH</del> is
<del>/usr/include/boost</del> and it specifies the C++11</p>
<p>standard.</p>
<p>Section 130.4: Autotools (GNU)</p>
<p>Introduction</p>
<p>The Autotools are a group of programs that create a GNU Build System
for a given software package. It is a suite of</p>
<p>tools that work together to produce various build resources, such as
a Makefile (to be used with GNU Make). Thus, Autotools can be considered
a de facto build system generator.</p>
<p>Some notable Autotools programs include:</p>
<p>Autoconf</p>
<p>Automake (not to be confused with <del>make</del>)</p>
<p>In general, Autotools is meant to generate the Unix-compatible script
and Makefile to allow the following command</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 628</p>
<p><span id="to_build__as_well_as_install__mo" class="anchor"></span>to
build (as well as install) most packages (in the simple case):</p>
<p>./configure &amp;&amp; make &amp;&amp; make install</p>
<p>As such, Autotools also has a relationship with certain package
managers, especially those that are attached to operating systems that
conform to the POSIX Standard(s).</p>
<p>Section 130.5: Ninja</p>
<p>Introduction</p>
<p>The Ninja build system is described by its project website as <a
href="https://ninja-build.org/">"a small build system with a focus on
speed."</a> Ninja is designed to have its files generated by build
system file generators, and takes a low-level approach to build</p>
<p>systems, in contrast to higher-level build system managers like CMake
or Meson.</p>
<p>Ninja is primarily written in C++ and Python, and was created as an
alternative to the SCons build system for the</p>
<p>Chromium project.</p>
<p>Section 130.6: NMAKE (Microsoft Program Maintenance Utility)</p>
<p>Introduction</p>
<p>NMAKE is a command-line utility developed by Microsoft to be used
primarily in conjunction with Microsoft Visual</p>
<p>Studio and/or the Visual C++ command line tools.</p>
<p>NMAKE is build system that falls under the Make family of build
systems, but has certain distinct features that</p>
<p>diverge from Unix-like Make programs, such as supporting
Windows-specific file path syntax (which itself differs from Unix-style
file paths).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 629</p>
<p><span id="Chapter_131__Concurrency_With_Op_1"
class="anchor"></span>Chapter 131: Concurrency With OpenMP</p>
<p>This topic covers the basics of concurrency in C++ using OpenMP.
OpenMP is documented in more detail in the</p>
<p>OpenMP tag.</p>
<p>Parallelism or concurrency implies the execution of code at the same
time.</p>
<p>Section 131.1: OpenMP: Parallel Sections</p>
<p>This example illustrates the basics of executing sections of code in
parallel.</p>
<p>As OpenMP is a built-in compiler feature, it works on any supported
compilers without including any libraries. You may wish to include
<del>omp.h</del> if you want to use any of the openMP API features.</p>
<p>Sample Code</p>
<p>std::cout &lt;&lt; "begin ";</p>
<p>// This pragma statement hints the compiler that the // contents
within the { } are to be executed in as // parallel sections using
openMP, the compiler will // generate this chunk of code for parallel
execution #pragma omp parallel sections</p>
<p>{</p>
<p>// This pragma statement hints the compiler that // this is a section
that can be executed in parallel // with other section, a single section
will be executed // by a single thread.</p>
<p>// Note that it is "section" as opposed to "sections" above #pragma
omp section</p>
<p>{</p>
<p>std::cout &lt;&lt; "hello " &lt;&lt; std::endl;</p>
<p>/** Do something **/</p>
<p>}</p>
<p>#pragma omp section</p>
<p>{</p>
<p>std::cout &lt;&lt; "world " &lt;&lt; std::endl;</p>
<p>/** Do something **/</p>
<p>}</p>
<p>}</p>
<p>// This line will not be executed until all the // sections defined
above terminates</p>
<p>std::cout &lt;&lt; "end" &lt;&lt; std::endl;</p>
<p>Outputs</p>
<p>This example produces 2 possible outputs and is dependent on the
operating system and hardware. The output</p>
<p>also illustrates a <strong>race condition</strong> problem that would
occur from such an implementation.</p>
<p>OUTPUT A OUTPUT B</p>
<p>begin hello world end begin world hello end</p>
<p>Section 131.2: OpenMP: Parallel Sections</p>
<p>This example shows how to execute chunks of code in parallel</p>
<p>std::cout &lt;&lt; "begin ";</p>
<p>// Start of parallel sections</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 630</p>
<p><span id="_pragma_omp_parallel_sections"
class="anchor"></span>#pragma omp parallel sections</p>
<p>{</p>
<p>// Execute these sections in parallel</p>
<p>#pragma omp section</p>
<p>{</p>
<p>... do something ...</p>
<p>std::cout &lt;&lt; "hello ";</p>
<p>}</p>
<p>#pragma omp section</p>
<p>{</p>
<p>... do something ...</p>
<p>std::cout &lt;&lt; "world ";</p>
<p>}</p>
<p>#pragma omp section</p>
<p>{</p>
<p>... do something ...</p>
<p>std::cout &lt;&lt; "forever ";</p>
<p>}</p>
<p>}</p>
<p>// end of parallel sections</p>
<p>std::cout &lt;&lt; "end";</p>
<p>Output</p>
<p>begin hello world forever end</p>
<p>begin world hello forever end</p>
<p>begin hello forever world end</p>
<p>begin forever hello world end</p>
<p>As execution order is not guaranteed, you may observe any of the
above output.</p>
<p>Section 131.3: OpenMP: Parallel For Loop</p>
<p>This example shows how to divide a loop into equal parts and execute
them in parallel.</p>
<p>// Splits element vector into element.size() / Thread Qty // and
allocate that range for each thread.</p>
<p>#pragma omp parallel for</p>
<p>for (size_t i = 0; i &lt; element.size(); ++i)</p>
<p>element[i] = ...</p>
<p>// Example Allocation (100 element per thread)</p>
<p>// Thread 1 : 0 ~ 99</p>
<p>// Thread 2 : 100 ~ 199</p>
<p>// Thread 2 : 200 ~ 299</p>
<p>// ...</p>
<p>// Continue process</p>
<p>// Only when all threads completed their allocated // loop job</p>
<p>...</p>
<p>*Please take extra care to not modify the size of the vector used in
parallel for loops as <strong>allocated range indices</strong></p>
<p>doesn't update automatically<strong>.</strong></p>
<p>Section 131.4: OpenMP: Parallel Gathering / Reduction</p>
<p>This example illustrates a concept to perform reduction or gathering
using <del>std::vector</del> and OpenMP.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 631</p>
<p>Supposed we have a scenario where we want multiple threads to help us
generate a bunch of stuff, <del>int</del> is used here for simplicity
and can be replaced with other data types.</p>
<p>This is particularly useful when you need to merge results from
slaves to avoid segement faults or memory access violations and do not
wish to use libraries or custom sync container libraries.</p>
<p>// The Master vector</p>
<p>// We want a vector of results gathered from slave threads
std::vector <del>Master;</del></p>
<p>// Hint the compiler to parallelize this { } of code // with all
available threads (usually the same as logical processor qty) #pragma
omp parallel</p>
<p>{</p>
<p>// In this area, you can write any code you want for each // slave
thread, in this case a vector to hold each of their results // We don't
have to worry about how many threads were spawn or if we need // to
repeat this declaration or not.</p>
<p>std::vector <del>Slave;</del></p>
<p>// Tell the compiler to use all threads allocated for this parallel
region // to perform this loop in parts. Actual load appx = 1000000 /
Thread Qty // The nowait keyword tells the compiler that the slave
threads don't // have to wait for all other slaves to finish this for
loop job #pragma omp for nowait</p>
<p>for (size_t i = 0; i &lt; 1000000; ++i</p>
<p>{</p>
<p>/* Do something */</p>
<p>....</p>
<p>Slave.push_back(...);</p>
<p>}</p>
<p>// Slaves that finished their part of the job</p>
<p>// will perform this thread by thread one at a time // critical
section ensures that only 0 or 1 thread performs // the { } at any
time</p>
<p>#pragma omp critical</p>
<p>{</p>
<p>// Merge slave into master</p>
<p>// use move iterators instead, avoid copy unless // you want to use
it for something else after this section</p>
<p>Master.insert(Master.end(),</p>
<p>std::make_move_iterator(Slave.begin()),</p>
<p>std::make_move_iterator(Slave.end()));</p>
<p>}</p>
<p>}</p>
<p>// Have fun with Master vector</p>
<p>...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 632</p>
<p><span id="Chapter_132__Resource_Management_1"
class="anchor"></span>Chapter 132: Resource Management</p>
<p>One of the hardest things to do in C and C++ is resource management.
Thankfully, in C++, we have many ways to go</p>
<p>about designing resource management in our programs. This article
hopes to explain some of the idioms and methods used to manage allocated
resources.</p>
<p>Section 132.1: Resource Acquisition Is Initialization</p>
<p>Resource Acquisition Is Initialization (RAII) is a common idiom in
resource management. In the case of dynamic memory, it uses smart
pointers to accomplish resource management. When using RAII, an acquired
resource is</p>
<p>immediately given ownership to a smart pointer or equivalent resource
manager. The resource is only accessed through this manager, so the
manager can keep track of various operations. For example,
<del>std::auto_ptr</del></p>
<p>automatically frees its corresponding resource when it falls out of
scope or is otherwise deleted.</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>{</p>
<p>auto_ptr ap(new int(5)); // dynamic memory is the resource</p>
<p>cout &lt;&lt; *ap &lt;&lt; endl; // prints 5</p>
<p>} // auto_ptr is destroyed, its resource is automatically freed</p>
<p>}</p>
<p>Version ≥ C++11</p>
<p><del>std::auto_ptr</del>'s main problem is that it can't copied
without transferring ownership:</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>auto_ptr ap1(new int(5));</p>
<p>cout &lt;&lt; *ap1 &lt;&lt; endl; // prints 5</p>
<p>auto_ptr ap2(ap1); // copy ap2 from ap1; ownership now transfers to
ap2</p>
<p>cout &lt;&lt; *ap2 &lt;&lt; endl; // prints 5</p>
<p>cout &lt;&lt; ap1 == nullptr &lt;&lt; endl; // prints 1; ap1 has lost
ownership of resource</p>
<p>}</p>
<p>Because of these weird copy semantics, <del>std::auto_ptr</del> can't
be used in containers, among other things. The</p>
<p>reason it does this is to prevent deleting memory twice: if there are
two <del>auto_ptrs</del> with ownership of the same resource, they both
try to free it when they're destroyed. Freeing an already freed resource
can generally cause</p>
<p>problems, so it is important to prevent it. However,
<del>std::shared_ptr</del> has a method to avoid this while not</p>
<p>transferring ownership when copying:</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>shared_ptr sp2;</p>
<p>{</p>
<p>shared_ptr sp1(new int(5)); // give ownership to sp1</p>
<p>cout &lt;&lt; *sp1 &lt;&lt; endl; // prints 5</p>
<p>sp2 = sp1; // copy sp2 from sp1; both have ownership of resource</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 633</p>
<p><span id="cout_____sp1____endl_____prints" class="anchor"></span>cout
&lt;&lt; *sp1 &lt;&lt; endl; // prints 5</p>
<p>cout &lt;&lt; *sp2 &lt;&lt; endl; // prints 5</p>
<p>} // sp1 goes out of scope and is destroyed; sp2 has sole ownership
of resource cout &lt;&lt; *sp2 &lt;&lt; endl;</p>
<p>} // sp2 goes out of scope; nothing has ownership, so resource is
freed</p>
<p>Section 132.2: Mutexes &amp; Thread Safety</p>
<p>Problems may happen when multiple threads try to access a resource.
For a simple example, suppose we have a thread that adds one to a
variable. It does this by first reading the variable, adding one to it,
then storing it back.</p>
<p>Suppose we initialize this variable to 1, then create two instances
of this thread. After both threads finish, intuition suggests that this
variable should have a value of 3. However, the below table illustrates
what might go wrong:</p>
<p>Thread 1 Thread 2</p>
<p>Time Step 1 Read 1 from variable</p>
<p>Time Step 2 Read 1 from variable</p>
<p>Time Step 3 Add 1 plus 1 to get 2</p>
<p>Time Step 4 Add 1 plus 1 to get 2</p>
<p>Time Step 5 Store 2 into variable</p>
<p>Time Step 6 Store 2 into variable</p>
<p>As you can see, at the end of the operation, 2 is in the variable,
instead of 3. The reason is that Thread 2 read the</p>
<p>variable before Thread 1 was done updating it. The solution?
Mutexes.</p>
<p>A mutex (portmanteau of <strong>mut</strong>ual
<strong>ex</strong>clusion) is a resource management object designed to
solve this type of problem. When a thread wants to access a resource, it
"acquires" the resource's mutex. Once it is done accessing</p>
<p>the resource, the thread "releases" the mutex. While the mutex is
acquired, all calls to acquire the mutex will not</p>
<p>return until the mutex is released. To better understand this, think
of a mutex as a waiting line at the supermarket: the threads go into
line by trying to acquire the mutex and then waiting for the threads
ahead of them to finish up,</p>
<p>then using the resource, then stepping out of line by releasing the
mutex. There would be complete pandemonium if everybody tried to access
the resource at once.</p>
<p>Version ≥ C++11</p>
<p><del>std::mutex</del> is C++11's implementation of a mutex.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>void add_1(int&amp; i, const mutex&amp; m) { // function to be run in
thread</p>
<p>m.lock();</p>
<p>i += 1;</p>
<p>m.unlock();</p>
<p>}</p>
<p>int main() {</p>
<p>int var = 1;</p>
<p>mutex m;</p>
<p>cout &lt;&lt; var &lt;&lt; endl; // prints 1</p>
<p>thread t1(add_1, var, m); // create thread with arguments</p>
<p>thread t2(add_1, var, m); // create another thread</p>
<p>t1.join(); t2.join(); // wait for both threads to finish</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 634</p>
<p>cout &lt;&lt; var &lt;&lt; endl; // prints 3</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 635</p>
<p><span id="Chapter_133__Storage_class_speci_1"
class="anchor"></span>Chapter 133: Storage class specifiers</p>
<p>Storage class specifiers are keywords that can be used in
declarations. They do not affect the type of the</p>
<p>declaration, but typically modify the way in which the entity is
stored.</p>
<p>Section 133.1: extern</p>
<p>The <del>extern</del> storage class specifier can modify a
declaration in one of the three following ways, depending on</p>
<p>context:</p>
<p>1. It can be used to declare a variable without defining it.
Typically, this is used in a header file for a variable that</p>
<p>will be defined in a separate implementation file.</p>
<p>// global scope</p>
<p>int x; // definition; x will be default-initialized extern int y; //
declaration; y is defined elsewhere, most likely another TU extern int z
= 42; // definition; "extern" has no effect here (compiler may warn)</p>
<p>2. It gives external linkage to a variable at namespace scope even if
<del>const</del> or <del>constexpr</del> would have otherwise</p>
<p>caused it to have internal linkage.</p>
<p>// global scope</p>
<p>const int w = 42; // internal linkage in C++; external linkage in C
static const int x = 42; // internal linkage in both C++ and C extern
const int y = 42; // external linkage in both C++ and C namespace {</p>
<p>extern const int z = 42; // however, this has internal linkage
since</p>
<p>// it's in an unnamed namespace</p>
<p>}</p>
<p>3. It redeclares a variable at block scope if it was previously
declared with linkage. Otherwise, it declares a new</p>
<p>variable with linkage, which is a member of the nearest enclosing
namespace.</p>
<p>// global scope</p>
<p>namespace {</p>
<p>int x = 1;</p>
<p>struct C {</p>
<p>int x = 2;</p>
<p>void f() {</p>
<p>extern int x; // redeclares namespace-scope x</p>
<p>std::cout &lt;&lt; x &lt;&lt; '<strong><del>\n</del></strong>'; //
therefore, this prints 1, not 2</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>void g() {</p>
<p>extern int y; // y has external linkage; refers to global y defined
elsewhere</p>
<p>}</p>
<p>A function can also be declared <del>extern</del>, but this has no
effect. It is usually used as a hint to the reader that a</p>
<p>function declared here is defined in another translation unit. For
example:</p>
<p>void f(); // typically a forward declaration; f defined later in this
TU extern void g(); // typically not a forward declaration; g defined in
another TU</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 636</p>
<p><span id="In_the_above_code__if_f_were_cha" class="anchor"></span>In
the above code, if <del>f</del> were changed to <del>extern</del> and
<del>g</del> to non-<del>extern</del>, it would not affect the
correctness or semantics of the program at all, but would likely confuse
the reader of the code.</p>
<p>Section 133.2: register</p>
<p>Version &lt; C++17</p>
<p>A storage class specifier that hints to the compiler that a variable
will be heavily used. The word "register" is related to the fact that a
compiler might choose to store such a variable in a CPU register so that
it can be accessed in fewer</p>
<p>clock cycles. It was deprecated starting in C++11.</p>
<p>register int i = 0;</p>
<p>while (i &lt; 100) {</p>
<p>f(i);</p>
<p>int g = i*i;</p>
<p>i += h(i, g);</p>
<p>}</p>
<p>Both local variables and function parameters may be declared
<del>register</del>. Unlike C, C++ does not place any restrictions on
what can be done with a <del>register</del> variable. For example, it is
valid to take the address of a <del>register</del></p>
<p>variable, but this may prevent the compiler from actually storing
such a variable in a register.</p>
<p>Version ≥ C++17</p>
<p>The keyword <del>register</del> is unused and reserved. A program
that uses the keyword <del>register</del> is ill-formed.</p>
<p>Section 133.3: static</p>
<p>The <del>static</del> storage class specifier has three different
meanings.</p>
<p>1. Gives internal linkage to a variable or function declared at
namespace scope.</p>
<p>// internal function; can't be linked to</p>
<p>static double semiperimeter(double a, double b, double c) {</p>
<p>return (a + b + c)/2.0;</p>
<p>}</p>
<p>// exported to client</p>
<p>double area(double a, double b, double c) {</p>
<p>const double s = semiperimeter(a, b, c);</p>
<p>return sqrt(s*(s-a)*(s-b)*(s-c));</p>
<p>}</p>
<p>2. Declares a variable to have static storage duration (unless it is
<del>thread_local</del>). Namespace-scope variables</p>
<p>are implicitly static. A static local variable is initialized only
once, the first time control passes through its</p>
<p>definition, and is not destroyed every time its scope is exited.</p>
<p>void f() {</p>
<p>static int count = 0;</p>
<p>std::cout &lt;&lt; "f has been called " &lt;&lt; ++count &lt;&lt; "
times so far<strong><del>\n</del></strong>";</p>
<p>}</p>
<p>3. When applied to the declaration of a class member, declares that
member to be a static member.</p>
<p>struct S {</p>
<p>static S* create() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 637</p>
<p><span id="return_new_S" class="anchor"></span>return new S;</p>
<p>}</p>
<p>};</p>
<p>int main() {</p>
<p>S* s = S::create();</p>
<p>}</p>
<p>Note that in the case of a static data member of a class, both 2 and
3 apply simultaneously: the <del>static</del> keyword both makes the
member into a static data member and makes it into a variable with
static storage duration.</p>
<p>Section 133.4: auto</p>
<p>Version ≤ C++03</p>
<p>Declares a variable to have automatic storage duration. It is
redundant, since automatic storage duration is already</p>
<p>the default at block scope, and the auto specifier is not allowed at
namespace scope.</p>
<p>void f() {</p>
<p>auto int x; // equivalent to: int x;</p>
<p>auto y; // illegal in C++; legal in C89</p>
<p>}</p>
<p>auto int z; // illegal: namespace-scope variable cannot be
automatic</p>
<p>In C++11, <del>auto</del> changed meaning completely, and is no
longer a storage class specifier, but is instead used for type
deduction.</p>
<p>Section 133.5: mutable</p>
<p>A specifier that can be applied to the declaration of a non-static,
non-reference data member of a class. A mutable</p>
<p>member of a class is not <del>const</del> even when the object is
<del>const</del>.</p>
<p>class C {</p>
<p>int x;</p>
<p>mutable int times_accessed;</p>
<p>public:</p>
<p>C(): x(0), times_accessed(0) {</p>
<p>}</p>
<p>int get_x() const {</p>
<p>++times_accessed; // ok: const member function can modify mutable
data member return x;</p>
<p>}</p>
<p>void set_x(int x) {</p>
<p>++times_accessed;</p>
<p>this-&gt;x = x;</p>
<p>}</p>
<p>};</p>
<p>Version ≥ C++11</p>
<p>A second meaning for <del>mutable</del> was added in C++11. When it
follows the parameter list of a lambda, it suppresses</p>
<p>the implicit <del>const</del> on the lambda's function call operator.
Therefore, a mutable lambda can modify the values of entities captured
by copy. See mutable lambdas for more details.</p>
<p><del>std::vector</del> my_iota(int start, int count) {</p>
<p><del>std::vector</del> result(count);</p>
<p>std::generate(result.begin(), result.end(),</p>
<p>[start]() mutable { return start++; });</p>
<p>return result;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 638</p>
<p>}</p>
<p>Note that <del>mutable</del> is not a storage class specifier when
used this way to form a mutable lambda.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 639</p>
<p><span id="Chapter_134__Linkage_specificati_1"
class="anchor"></span>Chapter 134: Linkage specifications</p>
<p>A linkage specification tells the compiler to compile declarations in
a way that allows them to be linked together</p>
<p>with declarations written in another language, such as C.</p>
<p>Section 134.1: Signal handler for Unix-like operating system</p>
<p>Since a signal handler will be called by the kernel using the C
calling convention, we must tell the compiler to use</p>
<p>the C calling convention when compiling the function.</p>
<p>volatile sig_atomic_t death_signal = 0;</p>
<p>extern "C" void cleanup(int signum) {</p>
<p>death_signal = signum;</p>
<p>}</p>
<p>int main() {</p>
<p>bind(...);</p>
<p>listen(...);</p>
<p>signal(SIGTERM, cleanup);</p>
<p>while (int fd = accept(...)) {</p>
<p>if (fd ==-1 &amp;&amp; errno == EINTR &amp;&amp; death_signal) {</p>
<p>printf("Caught signal %d; shutting
down<strong><del>\n</del></strong>", death_signal); break;</p>
<p>}</p>
<p>// ...</p>
<p>}</p>
<p>}</p>
<p>Section 134.2: Making a C library header compatible with C++</p>
<p>A C library header can usually be included into a C++ program, since
most declarations are valid in both C and C++.</p>
<p>For example, consider the following <del>foo.h</del>:</p>
<p>typedef struct Foo {</p>
<p>int bar;</p>
<p>} Foo;</p>
<p>Foo make_foo(int);</p>
<p>The definition of <del>make_foo</del> is separately compiled and
distributed with the header in object form.</p>
<p>A C++ program can <del>#include</del> , but the compiler will not
know that the make_foo function is defined as a C symbol, and will
probably try to look for it with a mangled name, and fail to locate it.
Even if it can find the definition</p>
<p>of <del>make_foo</del> in the library, not all platforms use the same
calling conventions for C and C++, and the C++ compiler will use the C++
calling convention when calling <del>make_foo</del>, which is likely to
cause a segmentation fault if <del>make_foo</del> is</p>
<p>expecting to be called with the C calling convention.</p>
<p>The way to remedy this problem is to wrap almost all the declarations
in the header in an <del>extern "C"</del> block.</p>
<p>#ifdef __cplusplus</p>
<p>extern "C" {</p>
<p>#endif</p>
<p>typedef struct Foo {</p>
<p>int bar;</p>
<p>} Foo;</p>
<p>Foo make_foo(int);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 640</p>
<p>#ifdef __cplusplus</p>
<p><del>}</del> /* end of "extern C" block */</p>
<p>#endif</p>
<p>Now when <del>foo.h</del> is included from a C program, it will just
appear as ordinary declarations, but when <del>foo.h</del> is included
from a C++ program, <del>make_foo</del> will be inside an <del>extern
"C"</del> block and the compiler will know to look for</p>
<p>an unmangled name and use the C calling convention.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 641</p>
<p><span id="Chapter_135__Digit_separators_1"
class="anchor"></span>Chapter 135: Digit separators</p>
<p>Section 135.1: Digit Separator</p>
<p>Numeric literals of more than a few digits are hard to read.</p>
<p>Pronounce 7237498123.</p>
<p>Compare 237498123 with 237499123 for equality.</p>
<p>Decide whether 237499123 or 20249472 is larger.</p>
<p>C++14 define Simple Quotation Mark <del>'</del> as a digit separator,
in numbers and user-defined literals. This can make it easier for human
readers to parse large numbers.</p>
<p>Version ≥ C++14</p>
<p>long long decn = 1'000'000'000ll;</p>
<p>long long hexn = 0xFFFF'FFFFll;</p>
<p>long long octn = 00'23'00ll;</p>
<p>long long binn = 0b1010'0011ll;</p>
<p>Single quotes mark are ignored when determining its value.</p>
<p>Example:</p>
<p>The literals <del>1048576</del>, <del>1'048'576</del>,
<del>0X100000</del>, <del>0x10'0000</del>, and <del>0'004'000'000</del>
all have the same value. The literals <del>1.602'176'565e-19</del> and
<del>1.602176565e-19</del> have the same value.</p>
<p>The position of the single quotes is irrelevant. All the following
are equivalent:</p>
<p>Version ≥ C++14</p>
<p>long long a1 = 123456789ll;</p>
<p>long long a2 = 123'456'789ll;</p>
<p>long long a3 = 12'34'56'78'9ll;</p>
<p>long long a4 = 12345'6789ll;</p>
<p>It is also allowed in <del>user-defined</del> literals:</p>
<p>Version ≥ C++14</p>
<p>std::chrono::seconds tiempo = 1'674'456s + 5'300h;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 642</p>
<p><span id="Chapter_136__C_incompatibilities_1"
class="anchor"></span>Chapter 136: C incompatibilities</p>
<p>This describes what C code will break in a C++ compiler.</p>
<p>Section 136.1: Reserved Keywords</p>
<p>The first example are keywords that have a special purpose in C++:
the following is legal in C, but not C++.</p>
<p>int class = 5</p>
<p>These errors are easy to fix: just rename the variable.</p>
<p>Section 136.2: Weakly typed pointers</p>
<p>In C, pointers can be cast to a <del>void*</del>, which needs an
explicit cast in C++. The following is illegal in C++, but legal in
C:</p>
<p>void* ptr;</p>
<p>int* intptr = ptr;</p>
<p>Adding an explicit cast makes this work, but can cause further
issues.</p>
<p>Section 136.3: goto or switch</p>
<p>In C++, you may not skip initializations with <del>goto</del> or
<del>switch</del>. The following is valid in C, but not C++:</p>
<p>goto foo;</p>
<p>int skipped = 1;</p>
<p>foo;</p>
<p>These bugs may require redesign.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 643</p>
<p><span id="Chapter_137__Side_by_Side_Compar_1"
class="anchor"></span>Chapter 137: Side by Side Comparisons of</p>
<p>classic C++ examples solved via C++ vs</p>
<p>C++11 vs C++14 vs C++17</p>
<p>Section 137.1: Looping through a container</p>
<p>In C++, looping through a sequence container <del>c</del> can be done
using indexes as follows:</p>
<p>for(size_t i = 0; i &lt; c.size(); ++i) c[i] = 0;</p>
<p>While simple, such writings are subject to common semantic errors,
like wrong comparison operator, or wrong indexing variable:</p>
<p>for(size_t i = 0; i &lt;= c.size(); ++j) c[i] = 0;</p>
<p>^~~~~~~~~~~~~~^</p>
<p>Looping can also be achieved for all containers using iterators, with
similar drawbacks:</p>
<p>for(iterator it = c.begin(); it != c.end(); ++it) (*it) = 0;</p>
<p>C++11 introduced range-based for loops and <del>auto</del> keyword,
allowing the code to become:</p>
<p>for(auto&amp; x : c) x = 0;</p>
<p>Here the only parameters are the container <del>c</del>, and a
variable <del>x</del> to hold the current value. This prevents the</p>
<p>semantics errors previously pointed.</p>
<p>According to the C++11 standard, the underlying implementation is
equivalent to:</p>
<p>for(auto begin = c.begin(), end = c.end(); begin != end; ++begin)
{</p>
<p>// ...</p>
<p>}</p>
<p>In such implementation, the expression <del>auto begin = c.begin(),
end = c.end();</del> forces <del>begin</del> and <del>end</del> to be of
the same type, while <del>end</del> is never incremented, nor
dereferenced. So the range-based for loop only works for</p>
<p>containers defined by a pair iterator/iterator. The C++17 standard
relaxes this constraint by changing the implementation to:</p>
<p>auto begin = c.begin();</p>
<p>auto end = c.end();</p>
<p>for(; begin != end; ++begin)</p>
<p>{</p>
<p>// ...</p>
<p>}</p>
<p>Here <del>begin</del> and <del>end</del> are allowed to be of
different types, as long as they can be compared for inequality. This
allows</p>
<p>to loop through more containers, e.g. a container defined by a pair
iterator/sentinel.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 644</p>
<p><span id="Chapter_138__Compiling_and_Build_1"
class="anchor"></span>Chapter 138: Compiling and Building</p>
<p>Programs written in C++ need to be compiled before they can be run.
There is a large variety of compilers available</p>
<p>depending on your operating system.</p>
<p>Section 138.1: Compiling with GCC</p>
<p>Assuming a single source file named <del>main.cpp</del>, the command
to compile and link an non-optimized executable is as</p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-Og-723">follows
(Compiling without optimization is useful for initial development and
debugging, although -Og is officially</a> recommended for newer GCC
versions).</p>
<p>g++-o app -Wall main.cpp-O0</p>
<p>To produce an optimized executable for use in production, use one of
the <a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-O-716">-O</a>
options (see: <a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-O1-717">-O1</a>,
<a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-O2-718">-O2</a>,
<a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-O3-719">-O3,</a>
<a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-Os-721">-Os,</a>
<a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-Ofast-722">-</a></p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-Ofast-722">Ofast</a>
):</p>
<p>g++-o app -Wall -O2 main.cpp</p>
<p>If the -O option is omitted, -O0, which means no optimizations, is
used as default (specifying -O without a number</p>
<p>resolves to -O1).</p>
<p>Alternatively, use optimization flags from the <del>O</del> groups
(or more experimental optimizations) directly. The following</p>
<p>example builds with <del>-O2</del> optimization, plus one flag from
the <del>-O3</del> optimization level:</p>
<p>g++-o app -Wall -O2 -ftree-partial-pre main.cpp</p>
<p>To produce a platform-specific optimized executable (for use in
production on the machine with the same architecture), use:</p>
<p>g++-o app -Wall -O2 -march=native main.cpp</p>
<p>Either of the above will produce a binary file that can be run with
<del>.\app.exe</del> on Windows and <del>./app</del> on Linux, Mac</p>
<p>OS, etc.</p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#index-o-86">The
-o flag can also be skipped. In this case, GCC will create default
output executable</a> <del>a.exe</del> on Windows and</p>
<p>a.out <a
href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#index-c-82">on
Unix-like systems. To compile a file without linking it, use the -c</a>
option:</p>
<p>g++-o file.o-Wall -c file.cpp</p>
<p>This produces an object file named <del>file.o</del> which can later
be linked with other files to produce a binary:</p>
<p>g++-o app file.o otherfile.o</p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">More
about optimization options can be found at gcc.gnu.org. Of particular
note are</a> <del>-Og</del> (optimization with an</p>
<p>emphasis on debugging experience -- recommended for the standard
edit-compile-debug cycle) and <del>-Ofast</del> (all</p>
<p>optimizations, including ones disregarding strict standards
compliance).</p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wall-307">The
-Wall flag enables warnings for many common errors and should always be
used. To improve code quality it is</a></p>
<p>often encouraged also to use <a
href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wextra-310">-Wextra
and other warning flags which are not automatically enabled by</a>
<del>-Wall</del> and <del>-</del></p>
<p>Wextra <del>.</del></p>
<p><a
href="https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#index-std-112">If
the code expects a specific C++ standard, specify which standard to use
by including the -std= flag. Supported</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 645</p>
<p><span id="values_correspond_to_the_year_of"
class="anchor"></span>values correspond to the year of finalization for
each version of the ISO C++ standard. As of GCC 6.1.0, valid values for
the <del>std=</del> flag are <del>c++98</del>/<del>c++03</del>,
<del>c++11</del>, <del>c++14</del>, and
<del>c++17</del>/<del>c++1z</del>. Values separated by a forward slash
are</p>
<p>equivalent.</p>
<p>g++-std=c++11</p>
<p>GCC includes some compiler-specific extensions that are disabled when
they conflict with a standard specified by the <del>-std=</del> flag. To
compile with all extensions enabled, the value <del>gnu++XX</del> may be
used, where <del>XX</del> is any of the years</p>
<p>used by the <del>c++</del> values listed above.</p>
<p>The default standard will be used if none is specified. For versions
of GCC prior to 6.1.0, the default is <del>-</del></p>
<p>std=gnu++03 ; in GCC 6.1.0 and greater, the default is
<del>-std=gnu++14</del>.</p>
<p>Note that due to bugs in GCC, the <del>-pthread</del> flag must be
present at compilation and linking for GCC to support the</p>
<p>C++ standard threading functionality introduced with C++11, such as
<del>std::thread</del> and <del>std::wait_for</del>. Omitting it</p>
<p>when using threading functions may result in <a
href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58929">no warnings
but invalid results on some platforms.</a></p>
<p>Linking with libraries:</p>
<p>Use the <del>-l</del> option to pass the library name:</p>
<p>g++ main.cpp-lpcre2-8</p>
<p>#pcre2-8 is the PCRE2 library for 8bit code units (UTF-8)</p>
<p>If the library is not in the standard library path, add the path with
<del>-L</del> option:</p>
<p>g++ main.cpp-L/my/custom/path/-lmylib</p>
<p>Multiple libraries can be linked together:</p>
<p>g++ main.cpp-lmylib1 -lmylib2 -lmylib3</p>
<p>If one library depends on another, put the dependent library
<strong>before</strong> the independent library:</p>
<p>g++ main.cpp-lchild-lib -lbase-lib</p>
<p>Or let the linker determine the ordering itself via
<del>--start-group</del> and <del>--end-group</del> (note: this has
significant performance cost):</p>
<p>g++ main.cpp-Wl,--start-group -lbase-lib -lchild-lib
-Wl,--end-group</p>
<p>Section 138.2: Compiling with Visual Studio (Graphical</p>
<p>Interface) - Hello World</p>
<p>1. Download and install <a
href="https://www.visualstudio.com/">Visual Studio Community
2015</a></p>
<p>2. Open Visual Studio Community</p>
<p>3. Click File -&gt; New -&gt; Project</p>
<p><img src="media/index-664_1.png" style="width:6.5in;height:0.95833in"
alt="index-664_1.png" /></p>
<p>4. Click Templates -&gt; Visual C++ -&gt; Win32 Console Application
and then name the project <strong>MyFirstProgram</strong>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 646</p>
<p><img src="media/index-665_1.jpeg"
style="width:6.5in;height:4.48611in" alt="index-665_1.jpg" /></p>
<p>5. Click Ok</p>
<p>6. Click Next in the following window.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 647</p>
<p><img src="media/index-666_1.png" style="width:6.5in;height:5.125in"
alt="index-666_1.png" /></p>
<p>7. Check the <del>Empty project</del> box and then click Finish:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 648</p>
<p><img src="media/index-667_1.png" style="width:6.5in;height:5.09722in"
alt="index-667_1.png" /></p>
<p>8. Right click on folder Source File then -&gt; Add --&gt; New Item
:</p>
<p><img src="media/index-667_2.png" style="width:6.5in;height:3.72222in"
alt="index-667_2.png" /></p>
<p>9. Select C++ File and name the file main.cpp, then click Add:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 649</p>
<p><img src="media/index-668_1.jpeg"
style="width:6.5in;height:4.48611in" alt="index-668_1.jpg" /></p>
<p>10: Copy and paste the following code in the new file main.cpp:</p>
<p>#include</p>
<p>int main()</p>
<p>{</p>
<p>std::cout &lt;&lt; "Hello World!<strong><del>\n</del></strong>";</p>
<p>return 0;</p>
<p>}</p>
<p>You environment should look like:</p>
<p><img src="media/index-668_2.jpeg"
style="width:6.5in;height:1.09722in" alt="index-668_2.jpg" /></p>
<p>11. Click Debug -&gt; Start <strong>Without</strong> Debugging (or
press ctrl + F5) :</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 650</p>
<p><span id="page_669" class="anchor"></span><img
src="media/index-669_1.png" style="width:6.5in;height:4.91667in"
alt="index-669_1.png" /></p>
<p>12. Done. You should get the following console output :</p>
<p><img src="media/index-669_2.png" style="width:6.5in;height:3.22222in"
alt="index-669_2.png" /></p>
<p>Section 138.3: Online Compilers</p>
<p>Various websites provide online access to C++ compilers. Online
compiler's feature set vary significantly from site to site, but usually
they allow to do the following:</p>
<p>Paste your code into a web form in the browser.</p>
<p>Select some compiler options and compile the code.</p>
<p>Collect compiler and/or program output.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 651</p>
<p>Online compiler website behavior is usually quite restrictive as they
allow anyone to run compilers and execute arbitrary code on their server
side, whereas ordinarily remote arbitrary code execution is considered
as</p>
<p>vulnerability.</p>
<p>Online compilers may be useful for the following purposes:</p>
<p>Run a small code snippet from a machine which lacks C++ compiler
(smartphones, tablets, etc.). Ensure that code compiles successfully
with different compilers and runs the same way regardless the</p>
<p>compiler it was compiled with.</p>
<p>Learn or teach basics of C++.</p>
<p>Learn modern C++ features (C++14 and C++17 in near future) when
up-to-date C++ compiler is not available on local machine.</p>
<p>Spot a bug in your compiler by comparison with a large set of other
compilers. Check if a compiler bug was</p>
<p>fixed in future versions, which are unavailable on your machine.
Solve online judge problems.</p>
<p>What online compilers should <strong>not</strong> be used for:</p>
<p>Develop full-featured (even small) applications using C++. Usually
online compilers do not allow to link with third-party libraries or
download build artifacts.</p>
<p>Perform intensive computations. Sever-side computing resources are
limited, so any user-provided program will be killed after a few seconds
of execution. The permitted execution time is usually enough for testing
and</p>
<p>learning.</p>
<p>Attack compiler server itself or any third-party hosts on the
net.</p>
<p>Examples:</p>
<p>Disclaimer: documentation author(s) are not affiliated with any
resources listed below. Websites are listed alphabetically.</p>
<p><a href="http://codepad.org/">http://codepad.org/ Online compiler
with code sharing. Editing code after compiling with a source code</a>
warning or error does not work so well.</p>
<p><a
href="http://coliru.stacked-crooked.com/">http://coliru.stacked-crooked.com/</a>
Online compiler for which you specify the command line. Provides both
GCC and Clang compilers for use.</p>
<p><a href="http://cpp.sh/">http://cpp.sh/ - Online compiler with C++14
support. Does not allow you to edit compiler command line, but</a> some
options are available via GUI controls.</p>
<p><a href="https://gcc.godbolt.org/">https://gcc.godbolt.org/ -
Provides a wide list of compiler versions, architectures, and
disassembly output.</a> Very useful when you need to inspect what your
code compiles into by different compilers. GCC, Clang, MSVC</p>
<p>(<del>CL</del>), Intel compiler (<del>icc</del>), ELLCC, and Zapcc
are present, with one or more of these compilers available for the</p>
<p>ARM, ARMv8 (as ARM64), Atmel AVR, MIPS, MIPS64, MSP430, PowerPC, x86,
and x64 architecutres. Compiler command line arguments may be
edited.</p>
<p><a href="https://ideone.com/">https://ideone.com/</a> - Widely used
on the Net to illustrate code snippet behavior. Provides both GCC and
Clang for use, but doesn't allow you to edit the compiler command
line.</p>
<p><a href="http://melpon.org/wandbox">http://melpon.org/wandbox -
Supports numerous Clang and GNU/GCC compiler versions.</a></p>
<p><a href="http://onlinegdb.com/">http://onlinegdb.com/</a> - An
extremely minimalistic IDE that includes an editor, a compiler (gcc),
and a</p>
<p>debugger (gdb).</p>
<p><a href="http://rextester.com/">http://rextester.com/</a> - Provides
Clang, GCC, and Visual Studio compilers for both C and C++ (along
with</p>
<p>compilers for other languages), with the Boost library available for
use.</p>
<p><a
href="http://tutorialspoint.com/compile_cpp11_online.php">http://tutorialspoint.com/compile_cpp11_online.php</a>
- Full-featured UNIX shell with GCC, and a user-friendly project
explorer.</p>
<p><a
href="http://webcompiler.cloudapp.net/">http://webcompiler.cloudapp.net/
- Online Visual Studio 2015 compiler, provided by Microsoft as part
of</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 652</p>
<p><span id="RiSE4fun" class="anchor"></span>RiSE4fun.</p>
<p>Section 138.4: Compiling with Visual C++ (Command Line)</p>
<p>For programmers coming from GCC or Clang to Visual Studio, or
programmers more comfortable with the</p>
<p>command line in general, you can use the Visual C++ compiler from the
command line as well as the IDE.</p>
<p>If you desire to compile your code from the command line in Visual
Studio, you first need to set up the command</p>
<p>line environment. This can be done either by opening the <a
href="https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx#Anchor_0">Visual
Studio Command Prompt/Developer Command</a></p>
<p><a
href="https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx#Anchor_0">Prompt
/x86 Native Tools Command Prompt/x64 Native Tools Command Prompt or
similar</a> <del>(as provided by your</del></p>
<p>version of Visual Studio), or at the command prompt, by navigating to
the <del>VC</del> subdirectory of the compiler's install directory
(typically <del>\Program Files (x86)\Microsoft Visual Studio x\VC</del>,
where <del>x</del> is the version number (such</p>
<p>as <del>10.0</del> for 2010, or <del>14.0</del> for 2015) and running
the <del>VCVARSALL</del> batch file with a command-line parameter
specified</p>
<p><a
href="https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx#Anchor_1">here.</a></p>
<p>Note that unlike GCC, Visual Studio doesn't provide a front-end for
the linker (<del>link.exe</del>) via the compiler (<del>cl.exe</del>),
but instead provides the linker as a separate program, which the
compiler calls as it exits. <del>cl.exe</del> and <del>link.exe</del>
can</p>
<p>be used separately with different files and options, or <del>cl</del>
can be told to pass files and options to <del>link</del> if both
tasks</p>
<p>are done together. Any linking options specified to <del>cl</del>
will be translated into options for <del>link</del>, and any files not
processed by <del>cl</del> will be passed directly to <del>link</del>.
As this is mainly a simple guide to compiling with the Visual Studio</p>
<p>command line, arguments for <del>link</del> <a
href="https://msdn.microsoft.com/en-us/library/y0zzbyt4.aspx">will not
be described at this time; if you need a list, see here.</a></p>
<p>Note that arguments to <del>cl</del> are case-sensitive, while
arguments to <del>link</del> are not.</p>
<p>[Be advised that some of the following examples use the Windows shell
"current directory" variable, <del>%cd%</del>, when</p>
<p>specifying absolute path names. For anyone unfamiliar with this
variable, it expands to the current working directory. From the command
line, it will be the directory you were in when you ran <del>cl</del>,
and is specified in the</p>
<p>command prompt by default (if your command prompt is
<del>C:\src&gt;</del>, for example, then <del>%cd%</del> is
<del>C:\src\</del>).]</p>
<p>Assuming a single source file named <del>main.cpp</del> in the
current folder, the command to compile and link an</p>
<p>unoptimised executable (useful for initial development and debugging)
is (use either of the following):</p>
<p>cl main.cpp</p>
<p>// Generates object file "main.obj".</p>
<p>// Performs linking with "main.obj".</p>
<p>// Generates executable "main.exe".</p>
<p>cl /Od main.cpp</p>
<p>// Same as above.</p>
<p>// "/Od" is the "Optimisation: disabled" option, and is the default
when no /O is specified.</p>
<p>Assuming an additional source file "niam.cpp" in the same directory,
use the following:</p>
<p>cl main.cpp niam.cpp</p>
<p>// Generates object files "main.obj" and "niam.obj". // Performs
linking with "main.obj" and "niam.obj". // Generates executable
"main.exe".</p>
<p>You can also use wildcards, as one would expect:</p>
<p>cl main.cpp src\*.cpp</p>
<p>// Generates object file "main.obj", plus one object file for each
".cpp" file in folder // "%cd%\src".</p>
<p>// Performs linking with "main.obj", and every additional object file
generated. // All object files will be in the current folder.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 653</p>
<p>// Generates executable "main.exe".</p>
<p>To rename or relocate the executable, use one of the following:</p>
<p>cl /o name main.cpp</p>
<p>// Generates executable named "name.exe".</p>
<p>cl /o folder\ main.cpp</p>
<p>// Generates executable named "main.exe", in folder
"%cd%\folder".</p>
<p>cl /o folder\name main.cpp</p>
<p>// Generates executable named "name.exe", in folder
"%cd%\folder".</p>
<p>cl /Fename main.cpp</p>
<p>// Same as "/o name".</p>
<p>cl /Fefolder\ main.cpp</p>
<p>// Same as "/o folder\".</p>
<p>cl /Fefolder\name main.cpp</p>
<p>// Same as "/o folder\name".</p>
<p>Both <del>/o</del> and <del>/Fe</del> pass their parameter (let's
call it <del>o-param</del>) to <del>link</del> as
<del>/OUT:o-param</del>, appending the appropriate</p>
<p>extension (generally <del>.exe</del> or <del>.dll</del>) to "name"
<del>o-param</del>s as necessary. While both <del>/o</del> and
<del>/Fe</del> are to my knowledge identical in functionality, the
latter is preferred for Visual Studio. <del>/o</del> is marked as
deprecated, and appears to mainly</p>
<p>be provided for programmers more familiar with GCC or Clang.</p>
<p>Note that while the space between <del>/o</del> and the specified
folder and/or name is optional, there cannot be a space</p>
<p>between <del>/Fe</del> and the specified folder and/or name.</p>
<p>Similarly, to produce an optimised executable (for use in
production), use:</p>
<p>cl /O1 main.cpp</p>
<p>// Optimise for executable size. Produces small programs, at the
possible expense of slower // execution.</p>
<p>cl /O2 main.cpp</p>
<p>// Optimise for execution speed. Produces fast programs, at the
possible expense of larger // file size.</p>
<p>cl /GL main.cpp other.cpp</p>
<p>// Generates special object files used for whole-program
optimisation, which allows CL to // take every module (translation unit)
into consideration during optimisation. // Passes the option "/LTCG"
(Link-Time Code Generation) to LINK, telling it to call CL during // the
linking phase to perform additional optimisations. If linking is not
performed at this // time, the generated object files should be linked
with "/LTCG". // Can be used with other CL optimisation options.</p>
<p>Finally, to produce a platform-specific optimized executable (for use
in production on the machine with the</p>
<p><a
href="https://msdn.microsoft.com/en-us/library/x4d2c09s.aspx">specified
architecture), choose the appropriate command prompt or VCVARSALL
parameter</a> <del>for the target platform.</del></p>
<p>link <a
href="https://msdn.microsoft.com/en-us/library/5wy54dk2.aspx">should
detect the desired platform from the object files; if not, use the
/MACHINE option</a> to explicitly specify the target platform.</p>
<p>// If compiling for x64, and LINK doesn't automatically detect target
platform: cl main.cpp /link /machine:X64</p>
<p>Any of the above will produce an executable with the name specified
by <del>/o</del> or <del>/Fe</del>, or if neither is provided, with a
name identical to the first source or object file specified to the
compiler.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 654</p>
<p>cl a.cpp b.cpp c.cpp</p>
<p>// Generates "a.exe".</p>
<p>cl d.obj a.cpp q.cpp</p>
<p>// Generates "d.exe".</p>
<p>cl y.lib n.cpp o.obj</p>
<p>// Generates "n.exe".</p>
<p>cl /o yo zp.obj pz.cpp</p>
<p>// Generates "yo.exe".</p>
<p>To compile a file(s) without linking, use:</p>
<p>cl /c main.cpp</p>
<p>// Generates object file "main.obj".</p>
<p>This tells <del>cl</del> to exit without calling <del>link</del>, and
produces an object file, which can later be linked with other files
to</p>
<p>produce a binary.</p>
<p>cl main.obj niam.cpp</p>
<p>// Generates object file "niam.obj".</p>
<p>// Performs linking with "main.obj" and "niam.obj". // Generates
executable "main.exe".</p>
<p>link main.obj niam.obj</p>
<p>// Performs linking with "main.obj" and "niam.obj". // Generates
executable "main.exe".</p>
<p>There are other valuable command line parameters as well, which it
would be very useful for users to know:</p>
<p>cl /EHsc main.cpp</p>
<p>// "/EHsc" specifies that only standard C++ ("synchronous")
exceptions will be caught, // and `extern "C"` functions will not throw
exceptions. // This is recommended when writing portable,
platform-independent code.</p>
<p>cl /clr main.cpp</p>
<p>// "/clr" specifies that the code should be compiled to use the
common language runtime, // the .NET Framework's virtual machine.</p>
<p>// Enables the use of Microsoft's C++/CLI language in addition to
standard ("native") C++, // and creates an executable that requires .NET
to run.</p>
<p>cl /Za main.cpp</p>
<p>// "/Za" specifies that Microsoft extensions should be disabled, and
code should be // compiled strictly according to ISO C++ specifications.
// This is recommended for guaranteeing portability.</p>
<p>cl /Zi main.cpp</p>
<p>// "/Zi" generates a program database (PDB) file for use when
debugging a program, without // affecting optimisation specifications,
and passes the option "/DEBUG" to LINK.</p>
<p>cl /LD dll.cpp</p>
<p>// "/LD" tells CL to configure LINK to generate a DLL instead of an
executable. // LINK will output a DLL, in addition to an LIB and EXP
file for use when linking. // To use the DLL in other programs, pass its
associated LIB to CL or LINK when compiling those // programs.</p>
<p>cl main.cpp /link /LINKER_OPTION</p>
<p>// "/link" passes everything following it directly to LINK, without
parsing it in any way.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 655</p>
<p><span id="___Replace___LINKER_OPTION__with" class="anchor"></span>//
Replace "/LINKER_OPTION" with any desired LINK option(s).</p>
<p>For anyone more familiar with *nix systems and/or GCC/Clang,
<del>cl</del>, <del>link</del>, and other Visual Studio command line
tools can accept parameters specified with a hyphen (such as
<del>-c</del>) instead of a slash (such as <del>/c</del>).
Additionally,</p>
<p>Windows recognises either a slash or a backslash as a valid path
separator, so *nix-style paths can be used as well. This makes it easy
to convert simple compiler command lines from <del>g++</del> or
<del>clang++</del> to <del>cl</del>, or vice versa, with minimal</p>
<p>changes.</p>
<p>g++-o app src/main.cpp</p>
<p>cl -o app src/main.cpp</p>
<p>Of course, when porting command lines that use more complex
<del>g++</del> or <del>clang++</del> options, you need to look up</p>
<p>equivalent commands in the applicable compiler documentations and/or
on resource sites, but this makes it easier to get things started with
minimal time spent learning about new compilers.</p>
<p>In case you need specific language features for your code, a specific
release of MSVC was required. From <a
href="https://blogs.msdn.microsoft.com/vcblog/2016/06/07/standards-version-switches-in-the-compiler/">Visual
C++</a></p>
<p><a
href="https://blogs.msdn.microsoft.com/vcblog/2016/06/07/standards-version-switches-in-the-compiler/">2015
Update 3 on it is possible to choose the version of the standard to
compile with via the</a> <del>/std</del> flag. Possible</p>
<p>values are <del>/std:c++14</del> and <del>/std:c++latest</del>
(<del>/std:c++17</del> will follow soon).</p>
<p>Note: In older versions of this compiler, specific feature flags were
available however this was mostly used for</p>
<p>previews of new features.</p>
<p>Section 138.5: Compiling with Clang</p>
<p>As the <a href="http://clang.llvm.org/">Clang front-end is designed
for being compatible with GCC, most programs that can be compiled via
GCC will</a></p>
<p>compile when you swap <del>g++</del> by <del>clang++</del> in the
build scripts. If no <del>-std=version</del> is given, gnu11 will be
used.</p>
<p>Windows users who are used to MSVC can swap <del>cl.exe</del> with
<del>clang-cl.exe</del>. By default, clang tries to be compatible</p>
<p>with the highest version of MSVC that has been installed.</p>
<p>In the case of compiling with visual studio, clang-cl can be used by
changing the <del>Platform toolset</del> in the project</p>
<p>properties.</p>
<p>In both cases, clang is only compatible via its front-end, though it
also tries to generate binary compatible object</p>
<p><a href="http://clang.llvm.org/docs/MSVCCompatibility.html">files.
Users of clang-cl should note that the compatibility with MSVC is not
complete yet.</a></p>
<p>To use clang or clang-cl, one could use the default installation on
certain Linux distributions or those bundled with IDEs (like XCode on
Mac). For other versions of this compiler or on platforms which don't
have this installed, this</p>
<p>can be download from the <a
href="http://llvm.org/releases/download.html">official download
page.</a></p>
<p>If you're using CMake to build your code you can usually switch the
compiler by setting the <del>CC</del> and <del>CXX</del> environment</p>
<p>variables like this:</p>
<p><strong><del>mkdir</del></strong> build</p>
<p><strong><del>cd</del></strong> build</p>
<p>CC=clang CXX=clang++ cmake ..</p>
<p>cmake --build .</p>
<p>See also introduction to Cmake.</p>
<p>Section 138.6: The C++ compilation process</p>
<p>When you develop a C++ program, the next step is to compile the
program before running it. The compilation is the</p>
<p>process which converts the program written in human readable language
like C, C++ etc into a machine code,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 656</p>
<p>directly understood by the Central Processing Unit. For example, if
you have a C++ source code file named prog.cpp and you execute the
compile command,</p>
<p>g++-Wall -ansi -o prog prog.cpp</p>
<p>There are 4 main stages involved in creating an executable file from
the source file.</p>
<p>1. The C++ the preprocessor takes a C++ source code file and deals
with the headers(#include), macros(#define)</p>
<p>and other preprocessor directives.</p>
<p>2. The expanded C++ source code file produced by the C++ preprocessor
is compiled into the assembly</p>
<p>language for the platform.</p>
<p>3. The assembler code generated by the compiler is assembled into the
object code for the platform.</p>
<p>4. The object code file produced by the assembler is linked
together</p>
<p>with the object code files for any library functions used to produce
either a library or an executable file.</p>
<p>Preprocessing</p>
<p>The preprocessor handles the preprocessor directives, like #include
and #define. It is agnostic of the syntax of C++,</p>
<p>which is why it must be used with care.</p>
<p>It works on one C++ source file at a time by replacing #include
directives with the content of the respective files</p>
<p>(which is usually just declarations), doing replacement of macros
(#define), and selecting different portions of text depending of #if,
#ifdef and #ifndef directives.</p>
<p>The preprocessor works on a stream of preprocessing tokens. Macro
substitution is defined as replacing tokens with other tokens (the
operator ## enables merging two tokens when it make sense).</p>
<p>After all this, the preprocessor produces a single output that is a
stream of tokens resulting from the transformations described above. It
also adds some special markers that tell the compiler where each line
came</p>
<p>from so that it can use those to produce sensible error messages.</p>
<p>Some errors can be produced at this stage with clever use of the #if
and #error directives.</p>
<p>By using below compiler flag, we can stop the process at
preprocessing stage.</p>
<p>g++-E prog.cpp</p>
<p>Compilation</p>
<p>The compilation step is performed on each output of the preprocessor.
The compiler parses the pure C++ source code (now without any
preprocessor directives) and converts it into assembly code. Then
invokes underlying back-</p>
<p>end(assembler in toolchain) that assembles that code into machine
code producing actual binary file in some format(ELF, COFF, a.out, ...).
This object file contains the compiled code (in binary form) of the
symbols defined in</p>
<p>the input. Symbols in object files are referred to by name.</p>
<p>Object files can refer to symbols that are not defined. This is the
case when you use a declaration, and don't</p>
<p>provide a definition for it. The compiler doesn't mind this, and will
happily produce the object file as long as the source code is
well-formed.</p>
<p>Compilers usually let you stop compilation at this point. This is
very useful because with it you can compile each source code file
separately. The advantage this provides is that you don't need to
recompile everything if you only</p>
<p>change a single file.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 657</p>
<p><span id="The_produced_object_files_can_be" class="anchor"></span>The
produced object files can be put in special archives called static
libraries, for easier reusing later on.</p>
<p>It's at this stage that "regular" compiler errors, like syntax errors
or failed overload resolution errors, are reported.</p>
<p>In order to stop the process after the compile step, we can use the
-S option:</p>
<p>g++-Wall -ansi -S prog.cpp</p>
<p>Assembling</p>
<p>The assembler creates object code. On a UNIX system you may see files
with a .o suffix (.OBJ on MSDOS) to indicate object code files. In this
phase the assembler converts those object files from assembly code into
machine level</p>
<p>instructions and the file created is a relocatable object code.
Hence, the compilation phase generates the relocatable object program
and this program can be used in different places without having to
compile again.</p>
<p>To stop the process after the assembly step, you can use the -c
option:</p>
<p>g++-Wall -ansi -c prog.cpp</p>
<p>Linking</p>
<p>The linker is what produces the final compilation output from the
object files the assembler produced. This output can be either a shared
(or dynamic) library (and while the name is similar, they don't have
much in common with</p>
<p>static libraries mentioned earlier) or an executable.</p>
<p>It links all the object files by replacing the references to
undefined symbols with the correct addresses. Each of</p>
<p>these symbols can be defined in other object files or in libraries.
If they are defined in libraries other than the standard library, you
need to tell the linker about them.</p>
<p>At this stage the most common errors are missing definitions or
duplicate definitions. The former means that either</p>
<p>the definitions don't exist (i.e. they are not written), or that the
object files or libraries where they reside were not</p>
<p>given to the linker. The latter is obvious: the same symbol was
defined in two different object files or libraries.</p>
<p>Section 138.7: Compiling with Code::Blocks (Graphical</p>
<p>interface)</p>
<p>1. <a href="http://www.codeblocks.org/downloads/binaries">Download
and install Code::Blocks here. If you're on Windows, be careful to
select a file for which the name</a></p>
<p>contains <del>mingw</del>, the other files don't install any
compiler.</p>
<p>2. Open Code::Blocks and click on "Create a new project":</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 658</p>
<p><img src="media/index-677_1.jpeg"
style="width:6.5in;height:3.65278in" alt="index-677_1.jpg" /></p>
<p>3. Select "Console application" and click "Go":</p>
<p><img src="media/index-677_2.png" style="width:6.5in;height:4.47222in"
alt="index-677_2.png" /></p>
<p>4. Click "Next", select "C++", click "Next", select a name for your
project and choose a folder to save it in, click</p>
<p>"Next" and then click "Finish".</p>
<p>5. Now you can edit and compile your code. A default code that prints
"Hello world!" in the console is already</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 659</p>
<p>there. To compile and/or run your program, press one of the three
compile/run buttons in the toolbar:</p>
<p><img src="media/index-678_1.jpeg"
style="width:6.5in;height:3.65278in" alt="index-678_1.jpg" /></p>
<p>To compile without running, press <a
href="https://i.stack.imgur.com/gOkY9.png">, to run without compiling
again, press</a> and to compile and then</p>
<p><img src="media/index-678_2.png"
style="width:0.23611in;height:0.22222in" alt="index-678_2.png" /></p>
<p>run, press <a href="https://i.stack.imgur.com/Zgyi8.png">.</a></p>
<p><img src="media/index-678_3.png"
style="width:0.23611in;height:0.20833in" alt="index-678_3.png" /></p>
<p>Compiling and running the default "Hello world!" code gives the
following result:</p>
<p><img src="media/index-678_4.png"
style="width:0.20833in;height:0.20833in" alt="index-678_4.png" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 660</p>
<p><img src="media/index-678_5.jpeg"
style="width:6.5in;height:3.69444in" alt="index-678_5.jpg" /></p>
<p><span id="Chapter_139__Common_compile_link_1"
class="anchor"></span>Chapter 139: Common compile/linker</p>
<p>errors (GCC)</p>
<p>Section 139.1: undefined reference to `***'</p>
<p>This linker error happens, if the linker can't find a used symbol.
Most of the time, this happens if a used library is not linked
against.</p>
<p>qmake:</p>
<p>LIBS += nameOfLib</p>
<p>cmake:</p>
<p>TARGET_LINK_LIBRARIES(target nameOfLib)</p>
<p>g++ call:</p>
<p>g++-o main main.cpp-Llibrary/dir -lnameOfLib</p>
<p>One might also forget to compile and link all used <del>.cpp</del>
files (functionsModule.cpp defines the needed function):</p>
<p>g++ -o binName main.o functionsModule.o</p>
<p>Section 139.2: error: '***' was not declared in this scope</p>
<p>This error happens if a unknown object is used.</p>
<p>Variables</p>
<p>Not compiling:</p>
<p>#include</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>{</p>
<p>int i = 2;</p>
<p>}</p>
<p>std::cout &lt;&lt; i &lt;&lt; std::endl; // i is not in the scope of
the main function</p>
<p>return 0;</p>
<p>}</p>
<p>Fix:</p>
<p>#include</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>{</p>
<p>int i = 2;</p>
<p>std::cout &lt;&lt; i &lt;&lt; std::endl;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 661</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>Functions</p>
<p>Most of the time this error occurs if the needed header is not
included (e.g. using <del>std::cout</del> without <del>#include</del>
)</p>
<p>Not compiling:</p>
<p>#include</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>doCompile();</p>
<p>return 0;</p>
<p>}</p>
<p>void doCompile()</p>
<p>{</p>
<p>std::cout &lt;&lt; "No!" &lt;&lt; std::endl;</p>
<p>}</p>
<p>Fix:</p>
<p>#include</p>
<p>void doCompile(); // forward declare the function</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>doCompile();</p>
<p>return 0;</p>
<p>}</p>
<p>void doCompile()</p>
<p>{</p>
<p>std::cout &lt;&lt; "No!" &lt;&lt; std::endl;</p>
<p>}</p>
<p>Or:</p>
<p>#include</p>
<p>void doCompile() // define the function before using it {</p>
<p>std::cout &lt;&lt; "No!" &lt;&lt; std::endl;</p>
<p>}</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>doCompile();</p>
<p>return 0;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 662</p>
<p><span id="_50" class="anchor"></span>}</p>
<p><strong>Note:</strong> The compiler interprets the code from top to
bottom (simplification). Everything must be at least <a
href="http://www.cprogramming.com/declare_vs_define.html">declared
(or</a></p>
<p><a
href="http://www.cprogramming.com/declare_vs_define.html">defined)</a>
before usage.</p>
<p>Section 139.3: fatal error: ***: No such file or directory</p>
<p>The compiler can't find a file (a source file uses <del>#include
"someFile.hpp"</del>).</p>
<p>qmake:</p>
<p>INCLUDEPATH += dir/Of/File</p>
<p>cmake:</p>
<p>include_directories(dir/Of/File)</p>
<p>g++ call:</p>
<p>g++-o main main.cpp-Idir/Of/File</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 663</p>
<p><span id="Chapter_140__More_undefined_beha_1"
class="anchor"></span>Chapter 140: More undefined behaviors in</p>
<p>C++</p>
<p>More examples on how C++ can go wrong.</p>
<p>Continuation from Undefined Behavior</p>
<p>Section 140.1: Referring to non-static members in initializer</p>
<p>lists</p>
<p>Referring to non-static members in initializer lists before the
constructor has started executing can result in</p>
<p>undefined behavior. This results since not all members are
constructed at this time. From the standard draft:</p>
<p>§12.7.1: For an object with a non-trivial constructor, referring to
any non-static member or base class of</p>
<p>the object before the constructor begins execution results in
undefined behavior.</p>
<p>Example</p>
<p>struct W { int j; };</p>
<p>struct X : public virtual W { };</p>
<p>struct Y {</p>
<p>int *p;</p>
<p>X x;</p>
<p>Y() : p(&amp;x.j) { // undefined, x is not yet constructed</p>
<p>}</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 664</p>
<p><span id="Chapter_141__Unit_Testing_in_C_1"
class="anchor"></span>Chapter 141: Unit Testing in C++</p>
<p>Unit testing is a level in software testing that validates the
behavior and correctness of units of code.</p>
<p>In C++, "units of code" often refer to either classes, functions, or
groups of either. Unit testing is often performed</p>
<p>using specialized "testing frameworks" or "testing libraries" that
often use non-trivial syntax or usage patterns.</p>
<p>This topic will review different strategies and unit testing
libraries or frameworks.</p>
<p>Section 141.1: Google Test</p>
<p><a href="https://github.com/google/googletest">Google Test is a C++
testing framework maintained by Google. It requires building the</a>
<del>gtest</del> library and linking it to your testing framework when
building a test case file.</p>
<p>Minimal Example</p>
<p>// main.cpp</p>
<p>#include</p>
<p>#include</p>
<p>// Google Test test cases are created using a C++ preprocessor macro
// Here, a "test suite" name and a specific "test name" are provided.
TEST(module_name, test_name) {</p>
<p>std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;</p>
<p>// Google Test will also provide macros for assertions.</p>
<p>ASSERT_EQ(1+1, 2);</p>
<p>}</p>
<p>// Google Test can be run manually from the main() function // or, it
can be linked to the gtest_main library for an already // set-up main()
function primed to accept Google Test test cases. int main(int argc,
char** argv) {</p>
<p>::testing::InitGoogleTest(&amp;argc, argv);</p>
<p>return RUN_ALL_TESTS();</p>
<p>}</p>
<p>// Build command: g++ main.cpp -lgtest</p>
<p>Section 141.2: Catch</p>
<p><a href="https://github.com/philsquared/Catch">Catch is a header only
library that allows you to use both</a> <a
href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and
<a
href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>
unit test style.</p>
<p>The following snippet is from the Catch documentation page at <a
href="https://github.com/philsquared/Catch/blob/master/docs/tutorial.md">this
link:</a></p>
<p>SCENARIO( "vectors can be sized and resized", "[vector]" ) {</p>
<p>GIVEN( "A vector with some items" ) {</p>
<p>std::vector v( 5 );</p>
<p>REQUIRE( v.size() == 5 );</p>
<p>REQUIRE( v.capacity() &gt;= 5 );</p>
<p>WHEN( "the size is increased" ) {</p>
<p>v.resize( 10 );</p>
<p>THEN( "the size and capacity change" ) {</p>
<p>REQUIRE( v.size() == 10 );</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 665</p>
<p>REQUIRE( v.capacity() &gt;= 10 );</p>
<p>}</p>
<p>}</p>
<p>WHEN( "the size is reduced" ) {</p>
<p>v.resize( 0 );</p>
<p>THEN( "the size changes but not capacity" ) {</p>
<p>REQUIRE( v.size() == 0 );</p>
<p>REQUIRE( v.capacity() &gt;= 5 );</p>
<p>}</p>
<p>}</p>
<p>WHEN( "more capacity is reserved" ) {</p>
<p>v.reserve( 10 );</p>
<p>THEN( "the capacity changes but not the size" ) {</p>
<p>REQUIRE( v.size() == 5 );</p>
<p>REQUIRE( v.capacity() &gt;= 10 );</p>
<p>}</p>
<p>}</p>
<p>WHEN( "less capacity is reserved" ) {</p>
<p>v.reserve( 0 );</p>
<p>THEN( "neither size nor capacity are changed" ) {</p>
<p>REQUIRE( v.size() == 5 );</p>
<p>REQUIRE( v.capacity() &gt;= 5 );</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Conveniently, these tests will be reported as follows when run:</p>
<p>Scenario: vectors can be sized and resized Given: A vector with some
items When: more capacity is reserved Then:</p>
<p>the capacity changes but not the size</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 666</p>
<p><span id="Chapter_142__C___Debugging_and_D_1"
class="anchor"></span>Chapter 142: C++ Debugging and Debug-</p>
<p>prevention Tools &amp; Techniques</p>
<p>A lot of time from C++ developers is spent debugging. This topic is
meant to assist with this task and give inspiration</p>
<p>for techniques. Don't expect an extensive list of issues and
solutions fixed by the tools or a manual on the mentioned tools.</p>
<p>Section 142.1: Static analysis</p>
<p>Static analysis is the technique in which on checks the code for
patterns linked to known bugs. Using this technique is less time
consuming than a code review, though, its checks are only limited to
those programmed in the tool.</p>
<p>Checks can include the incorrect semi-colon behind the if-statement
(<del>if (var);</del>) till advanced graph algorithms which determine if
a variable is not initialized.</p>
<p>Compiler warnings</p>
<p>Enabling static analysis is easy, the most simplistic version is
already build-in in your compiler:</p>
<p><a
href="https://clang.llvm.org/docs/DiagnosticsReference.html">clang++
-Wall -Weverything -Werror ...</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">g++
-Wall -Weverything -Werror ...</a></p>
<p><a
href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-option-warning-level">cl.exe
/W4 /WX ...</a></p>
<p>If you enable these options, you will notice that each compiler will
find bugs the others don't and that you will get</p>
<p>errors on techniques which might be valid or valid in a specific
context. <del>while (staticAtomicBool);</del> might be</p>
<p>acceptable even if <del>while (localBool);</del> ain't.</p>
<p>So unlike code review, you are fighting a tool which understands your
code, tells you a lot of useful bugs and sometimes disagrees with you.
In this last case, you might have to suppress the warning locally.</p>
<p>As the options above enable all warnings, they might enable warnings
you don't want. (Why should your code be C++98 compatible?) If so, you
can simply disable that specific warning:</p>
<p>clang++-Wall -Weverything -Werror -Wno-errortoaccept ... g++-Wall
-Weverything -Werror -Wno-errortoaccept ...</p>
<p>cl.exe /W4 /WX /wd<del>...</del></p>
<p>Where compiler warnings assist you during development, they slow down
compilation quite a bit. That is why you</p>
<p>might not always want to enable them by default. Either you run them
by default or you enable some continuous integration with the more
expensive checks (or all of them).</p>
<p>External tools</p>
<p><a href="http://clang.llvm.org/extra/clang-tidy/">If you decide to
have some continuous integration, the use of other tools ain't such a
stretch. A tool like clang-tidy</a></p>
<p>has an <a
href="http://clang.llvm.org/extra/clang-tidy/checks/list.html">list of
checks</a> which covers a wide range of issues, some examples:</p>
<p>Actual bugs</p>
<p>Prevention of slicing</p>
<p>Asserts with side effects</p>
<p>Readability checks</p>
<p>Misleading indentation</p>
<p>Check identifier naming</p>
<p>Modernization checks</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 667</p>
<p><span id="Use_make_unique" class="anchor"></span>Use
make_unique()</p>
<p>Use nullptr</p>
<p>Performance checks</p>
<p>Find unneeded copies</p>
<p>Find inefficient algorithm calls</p>
<p>The list might not be that large, as Clang already has a lot of
compiler warnings, however it will bring you one step</p>
<p>closer to a high quality code base.</p>
<p>Other tools</p>
<p>Other tools with similar purpose exist, like:</p>
<p><a
href="https://blogs.msdn.microsoft.com/hkamel/2013/10/24/visual-studio-2013-static-code-analysis-in-depth-what-when-and-how/">the
visual studio static analyzer</a> as external tool</p>
<p><a
href="https://blogs.kde.org/2015/11/15/new-cqt-code-checks-clazy-static-analyzer">clazy</a>,
a Clang compiler plugin for checking Qt code</p>
<p>Conclusion</p>
<p>A lot static analysis tools exist for C++, both build-in in the
compiler as external tools. Trying them out doesn't take</p>
<p>that much time for easy setups and they will find bugs you might miss
in code review.</p>
<p>Section 142.2: Segfault analysis with GDB</p>
<p>Lets use the same code as above for this example.</p>
<p>#include</p>
<p>void fail() {</p>
<p>int *p1;</p>
<p>int *p2(NULL);</p>
<p>int *p3 = p1;</p>
<p>if (p3) {</p>
<p>std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>fail();</p>
<p>}</p>
<p>First lets compile it</p>
<p>g++-g -o main main.cpp</p>
<p>Lets run it with gdb</p>
<p>gdb ./main</p>
<p>Now we will be in gdb shell. Type run.</p>
<p>(gdb) run</p>
<p>The program being debugged has been started already. Start it from
the beginning? (y or n) y</p>
<p>Starting program: /home/opencog/code-snippets/stackoverflow/a.out</p>
<p>Program received signal SIGSEGV, Segmentation fault.
0x0000000000400850 in fail () at debugging_with_gdb.cc:11</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 668</p>
<p><span id="11_______std__cout_____p2____std" class="anchor"></span>11
std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</p>
<p>We see the segmentation fault is happening at line 11. So the only
variable being used at this line is pointer p2. Lets examine its content
typing print.</p>
<p>(gdb) print p2</p>
<p>$1 = (int *) 0x0</p>
<p>Now we see that p2 was initialized to 0x0 which stands for NULL. At
this line, we know that we are trying to dereference a NULL pointer. So
we go and fix it.</p>
<p>Section 142.3: Clean code</p>
<p>Debugging starts with understanding the code you are trying to
debug.</p>
<p>Bad code:</p>
<p>int main() {</p>
<p>int value;</p>
<p><del>std::vector</del> vectorToSort;</p>
<p>vectorToSort.push_back(42); vectorToSort.push_back(13);</p>
<p>for (int i = 52; i; i = i -1)</p>
<p>{</p>
<p>vectorToSort.push_back(i *2);</p>
<p>}</p>
<p>/// Optimized for sorting small vectors</p>
<p>if (vectorToSort.size() == 1);</p>
<p>else</p>
<p>{</p>
<p>if (vectorToSort.size() &lt;= 2)</p>
<p>std::sort(vectorToSort.begin(), std::end(vectorToSort));</p>
<p>}</p>
<p>for (value : vectorToSort) std::cout &lt;&lt; value &lt;&lt; ' ';</p>
<p>return 0; }</p>
<p>Better code:</p>
<p><del>std::vector</del> createSemiRandomData() {</p>
<p>std::vector <del>data;</del></p>
<p>data.push_back(42);</p>
<p>data.push_back(13);</p>
<p>for (int i = 52; i;--i)</p>
<p>vectorToSort.push_back(i *2);</p>
<p>return data;</p>
<p>}</p>
<p>/// Optimized for sorting small vectors</p>
<p>void sortVector(std::vector &amp;v) {</p>
<p>if (vectorToSort.size() == 1)</p>
<p>return;</p>
<p>if (vectorToSort.size() &gt; 2)</p>
<p>return;</p>
<p>std::sort(vectorToSort.begin(), vectorToSort.end()); }</p>
<p>void printVector(const std::vector <del>&amp;v) {</del></p>
<p>for (auto i : v)</p>
<p>std::cout &lt;&lt; i &lt;&lt; ' ';</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 669</p>
<p>}</p>
<p>int main() {</p>
<p>auto vectorToSort = createSemiRandomData();</p>
<p>sortVector(std::ref(vectorToSort));</p>
<p>printVector(vectorToSort);</p>
<p>return 0;</p>
<p>}</p>
<p>Regardless of the coding styles you prefer and use, having a
consistent coding (and formatting) style will help you understanding the
code.</p>
<p>Looking at the code above, one can identify a couple of improvements
to improve readability and debuggability:</p>
<p>The use of separate functions for separate actions</p>
<p>The use of separate functions allow you to skip over some functions
in the debugger if you ain't interested in the details. In this specific
case, you might not be interested in the creation or printing of the
data and only want to step</p>
<p>into the sorting.</p>
<p>Another advantage is that you need to read less code (and memorize
it) while stepping through the code. You now</p>
<p>only need to read 3 lines of code in <del>main()</del> in order to
understand it, instead of the whole function.</p>
<p>The third advantage is that you simply have less code to look at,
which helps a trained eye in spotting this bug</p>
<p>within seconds.</p>
<p>Using consistent formatting/constructions</p>
<p>The use of consistent formatting and constructions will remove
clutter from the code making it easier to focus on</p>
<p>the code instead of text. A lot of discussions have been fed on the
'right' formatting style. Regardless of that style, having a single
consistent style in the code will improve familiarity and make it easier
to focus on the code.</p>
<p>As formatting code is time consuming task, it is recommended to use a
dedicated tool for this. Most IDEs have at least some kind of support
for this and can do formatting more consistent than humans.</p>
<p>You might note that the style is not limited to spaces and newlines
as we no longer mix the free-style and the member functions to get
begin/end of the container. (<del>v.begin()</del> vs
<del>std::end(v)</del>).</p>
<p>Point attention to the important parts of your code.</p>
<p>Regardless of the style you determine to choose, the above code
contains a couple of markers which might give you a hint on what might
be important:</p>
<p>A comment stating <del>optimized</del>, this indicates some fancy
techniques Some early returns in <del>sortVector()</del> indicate that
we are doing something special</p>
<p>The <del>std::ref()</del> indicates that something is going on with
the <del>sortVector()</del></p>
<p>Conclusion</p>
<p>Having clean code will help you understanding the code and will
reduce the time you need to debug it. In the second example, a code
reviewer might even spot the bug at first glance, while the bug might be
hidden in the</p>
<p>details in the first one. (PS: The bug is in the compare with
<del>2</del>.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 670</p>
<p><span id="Chapter_143__Optimization_in_C_1"
class="anchor"></span>Chapter 143: Optimization in C++</p>
<p>Section 143.1: Introduction to performance</p>
<p>C and C++ are well known as high-performance languages - largely due
to the heavy amount of code customization, allowing a user to specify
performance by choice of structure.</p>
<p>When optimizing it is important to benchmark relevant code and
completely understand how the code will be used.</p>
<p>Common optimization mistakes include:</p>
<p><strong>Premature optimization:</strong> Complex code may perform
worse after optimization, wasting time and effort.</p>
<p>First priority should be to write correct and maintainable code,
rather than optimized code.</p>
<p><strong>Optimization for the wrong use case:</strong> Adding overhead
for the 1% might not be worth the slowdown for the other 99%</p>
<p><strong>Micro-optimization:</strong> Compilers do this very
efficiently and micro-optimization can even hurt the compilers</p>
<p>ability to further optimize the code</p>
<p>Typical optimization goals are:</p>
<p>To do less work</p>
<p>To use more efficient algorithms/structures</p>
<p>To make better use of hardware</p>
<p>Optimized code can have negative side effects, including:</p>
<p>Higher memory usage</p>
<p>Complex code -being difficult to read or maintain</p>
<p>Compromised API and code design</p>
<p>Section 143.2: Empty Base Class Optimization</p>
<p>An object cannot occupy less than 1 byte, as then the members of an
array of this type would have the same</p>
<p>address. Thus <del>sizeof(T)&gt;=1</del> always holds. It's also true
that a derived class cannot be smaller than any of its base classes.
However, when the base class is empty, its size is not necessarily added
to the derived class:</p>
<p>class Base {};</p>
<p>class Derived : public Base</p>
<p>{</p>
<p>public:</p>
<p>int i;</p>
<p>};</p>
<p>In this case, it's not required to allocate a byte for
<del>Base</del> within <del>Derived</del> to have a distinct address per
type per</p>
<p>object. If empty base class optimization is performed (and no padding
is required), then <del>sizeof(Derived) == sizeof(int)</del>, that is,
no additional allocation is done for the empty base. This is possible
with multiple base classes</p>
<p>as well (in C++, multiple bases cannot have the same type, so no
issues arise from that).</p>
<p>Note that this can only be performed if the first member of
<del>Derived</del> differs in type from any of the base classes.</p>
<p>This includes any direct or indirect common bases. If it's the same
type as one of the bases (or there's a common base), at least allocating
a single byte is required to ensure that no two distinct objects of the
same type have the</p>
<p>same address.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 671</p>
<p><span id="Section_143_3__Optimizing_by_exe"
class="anchor"></span>Section 143.3: Optimizing by executing less
code</p>
<p>The most straightforward approach to optimizing is by executing less
code. This approach usually gives a fixed</p>
<p>speed-up without changing the time complexity of the code.</p>
<p>Even though this approach gives you a clear speedup, this will only
give noticable improvements when the code is</p>
<p>called a lot.</p>
<p>Removing useless code</p>
<p>void func(const A *a); // Some random function</p>
<p>// useless memory allocation + deallocation for the instance auto a1
= std::make_unique<del>();</del></p>
<p>func(a1.get());</p>
<p>// making use of a stack object prevents</p>
<p>auto a2 = A{};</p>
<p>func(&amp;a2);</p>
<p>Version ≥ C++14</p>
<p>From C++14, compilers are allowed to optimize this code to remove the
allocation and matching deallocation.</p>
<p>Doing code only once</p>
<p>std::map&gt; lookup;</p>
<p>// Slow insertion/lookup</p>
<p>// Within this function, we will traverse twice through the map
lookup an element // and even a thirth time when it wasn't in</p>
<p>const A *lazyLookupSlow(const std::string &amp;key) {</p>
<p>if (lookup.find(key) != lookup.cend())</p>
<p>lookup.emplace_back(key, std::make_unique());</p>
<p>return lookup[key].get();</p>
<p>}</p>
<p>// Within this function, we will have the same noticeable effect as
the slow variant while going at double speed as we only traverse once
through the code const A *lazyLookupSlow(const std::string &amp;key)
{</p>
<p>auto &amp;value = lookup[key];</p>
<p>if (!value)</p>
<p>value = std::make_unique();</p>
<p>return value.get();</p>
<p>}</p>
<p>A similar approach to this optimization can be used to implement a
stable version of unique</p>
<p>std::vector stableUnique(const std::vector &amp;v) {</p>
<p>std::vector result;</p>
<p>std::set checkUnique;</p>
<p>for (const auto &amp;s : v) {</p>
<p>// As insert returns if the insertion was successful, we can deduce
if the element was</p>
<p>already in or not</p>
<p>// This prevents an insertion, which will traverse through the map
for every unique element // As a result we can almost gain 50% if v
would not contain any duplicates if (checkUnique.insert(s).second)</p>
<p>result.push_back(s);</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 672</p>
<p><span id="Preventing_useless_reallocating"
class="anchor"></span>Preventing useless reallocating and
copying/moving</p>
<p>In the previous example, we already prevented lookups in the
std::set, however the <del>std::vector</del> still contains a</p>
<p>growing algorithm, in which it will have to realloc its storage. This
can be prevented by first reserving for the right size.</p>
<p><del>std::vector</del> stableUnique(const std::vector &amp;v) {</p>
<p>std::vector <del>result;</del></p>
<p>// By reserving 'result', we can ensure that no copying or moving
will be done in the vector // as it will have capacity for the maximum
number of elements we will be inserting // If we make the assumption
that no allocation occurs for size zero // and allocating a large block
of memory takes the same time as a small block of memory // this will
never slow down the program</p>
<p>// Side note: Compilers can even predict this and remove the checks
the growing from the</p>
<p>generated code</p>
<p>result.reserve(v.size());</p>
<p><del>std::set</del> checkUnique;</p>
<p>for (const auto &amp;s : v) {</p>
<p>// See example above</p>
<p>if (checkUnique.insert(s).second)</p>
<p>result.push_back(s);</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>Section 143.4: Using ecient containers</p>
<p>Optimizing by using the right data structures at the right time can
change the time-complexity of the code.</p>
<p>// This variant of stableUnique contains a complexity of N log(N) //
N &gt; number of elements in v</p>
<p>// log(N) &gt; insert complexity of std::set</p>
<p><del>std::vector</del> stableUnique(const std::vector &amp;v) {</p>
<p>std::vector <del>result;</del></p>
<p><del>std::set</del> checkUnique;</p>
<p>for (const auto &amp;s : v) {</p>
<p>// See Optimizing by executing less code</p>
<p>if (checkUnique.insert(s).second)</p>
<p>result.push_back(s);</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>By using a container which uses a different implementation for
storing its elements (hash container instead of tree),</p>
<p>we can transform our implementation to complexity N. As a side
effect, we will call the comparison operator for</p>
<p>std::string less, as it only has to be called when the inserted
string should end up in the same bucket.</p>
<p>// This variant of stableUnique contains a complexity of N // N &gt;
number of elements in v</p>
<p>// 1 &gt; insert complexity of std::unordered_set</p>
<p><del>std::vector</del> stableUnique(const std::vector &amp;v) {</p>
<p>std::vector <del>result;</del></p>
<p>std::unordered_set <del>checkUnique;</del></p>
<p>for (const auto &amp;s : v) {</p>
<p>// See Optimizing by executing less code</p>
<p>if (checkUnique.insert(s).second)</p>
<p>result.push_back(s);</p>
<p>}</p>
<p>return result;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 673</p>
<p><span id="_52" class="anchor"></span>}</p>
<p>Section 143.5: Small Object Optimization</p>
<p>Small object optimization is a technique which is used within low
level data structures, for instance the <del>std::string</del>
(Sometimes referred to as Short/Small String Optimization). It's meant
to use stack space as a buffer instead of</p>
<p>some allocated memory in case the content is small enough to fit
within the reserved space.</p>
<p>By adding extra memory overhead and extra calculations, it tries to
prevent an expensive heap allocation. The</p>
<p>benefits of this technique are dependent on the usage and can even
hurt performance if incorrectly used.</p>
<p>Example</p>
<p>A very naive way of implementing a string with this optimization
would the following:</p>
<p>#include</p>
<p>class string final</p>
<p>{</p>
<p>constexpr static auto SMALL_BUFFER_SIZE = 16;</p>
<p>bool _isAllocated{false}; ///&lt; Remember if we allocated memory
char *_buffer{nullptr}; ///&lt; Pointer to the buffer we are using char
_smallBuffer[SMALL_BUFFER_SIZE]= {'<strong><del>\0</del></strong>'};
///&lt; Stack space used for SMALL OBJECT</p>
<p>OPTIMIZATION</p>
<p>public:</p>
<p>~string()</p>
<p>{</p>
<p>if (_isAllocated)</p>
<p>delete [] _buffer;</p>
<p>}</p>
<p>explicit string(const char *cStyleString)</p>
<p>{</p>
<p>auto stringSize = std::strlen(cStyleString);</p>
<p>_isAllocated = (stringSize &gt; SMALL_BUFFER_SIZE);</p>
<p>if (_isAllocated)</p>
<p>_buffer = new char[stringSize];</p>
<p>else</p>
<p>_buffer = &amp;_smallBuffer[0];</p>
<p>std::strcpy(_buffer, &amp;cStyleString[0]);</p>
<p>}</p>
<p>string(string &amp;&amp;rhs)</p>
<p>: _isAllocated(rhs._isAllocated)</p>
<p>, _buffer(rhs._buffer)</p>
<p>, _smallBuffer(rhs._smallBuffer) //&lt; Not needed if allocated</p>
<p>{</p>
<p>if (_isAllocated)</p>
<p>{</p>
<p>// Prevent double deletion of the memory</p>
<p>rhs._buffer = nullptr;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>// Copy over data</p>
<p>std::strcpy(_smallBuffer, rhs._smallBuffer);</p>
<p>_buffer = &amp;_smallBuffer[0];</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 674</p>
<p>}</p>
<p>// Other methods, including other constructors, copy constructor, //
assignment operators have been omitted for readability</p>
<p>};</p>
<p>As you can see in the code above, some extra complexity has been
added in order to prevent some <del>new</del> and <del>delete</del></p>
<p>operations. On top of this, the class has a larger memory footprint
which might not be used except in a couple of cases.</p>
<p>Often it is tried to encode the bool value <del>_isAllocated</del>,
within the pointer <del>_buffer</del> with bit manipulation to reduce
the size of a single instance (intel 64 bit: Could reduce size by 8
byte). An optimization which is only possible when</p>
<p>its known what the alignment rules of the platform is.</p>
<p>When to use?</p>
<p>As this optimization adds a lot of complexity, it is not recommended
to use this optimization on every single class. It</p>
<p>will often be encountered in commonly used, low-level data
structures. In common C++11 <del>standard library</del> implementations
one can find usages in <del>std::basic_string&lt;&gt;</del> and
<del>std::function&lt;&gt;</del>.</p>
<p>As this optimization only prevents memory allocations when the stored
data is smaller than the buffer, it will only give benefits if the class
is often used with small data.</p>
<p>A final drawback of this optimization is that extra effort is
required when moving the buffer, making the move-operation more
expensive than when the buffer would not be used. This is especially
true when the buffer contains</p>
<p>a non-POD type.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 675</p>
<p><span id="Chapter_144__Optimization_1" class="anchor"></span>Chapter
144: Optimization</p>
<p><a href="http://en.cppreference.com/w/cpp/language/as_if">When
compiling, the compiler will often modify the program to increase
performance. This is permitted by the as-if</a></p>
<p><a href="http://en.cppreference.com/w/cpp/language/as_if">rule</a>,
which allows any and all transformations that do not change observable
behavior.</p>
<p>Section 144.1: Inline Expansion/Inlining</p>
<p>Inline expansion (also known as inlining) is compiler optimisation
that replaces a call to a function with the body of</p>
<p>that function. This saves the function call overhead, but at the cost
of space, since the function may be duplicated several times.</p>
<p>// source:</p>
<p>int process(int value)</p>
<p>{</p>
<p>return 2 * value;</p>
<p>}</p>
<p>int foo(int a)</p>
<p>{</p>
<p>return process(a);</p>
<p>}</p>
<p>// program, after inlining:</p>
<p>int foo(int a)</p>
<p>{</p>
<p>return 2 * a; // the body of process() is copied into foo()</p>
<p>}</p>
<p>Inlining is most commonly done for small functions, where the
function call overhead is significant compared to the</p>
<p>size of the function body.</p>
<p>Section 144.2: Empty base optimization</p>
<p>The size of any object or member subobject is required to be at least
1 even if the type is an empty <del>class</del> type (that is, a
<del>class</del> or <del>struct</del> that has no non-static data
members), in order to be able to guarantee that the addresses of</p>
<p>distinct objects of the same type are always distinct.</p>
<p>However, base <del>class</del> subobjects are not so constrained, and
can be completely optimized out from the object</p>
<p>layout:</p>
<p>#include</p>
<p>struct Base {}; // empty class</p>
<p>struct Derived1 : Base {</p>
<p>int i;</p>
<p>};</p>
<p>int main() {</p>
<p>// the size of any object of empty class type is at least 1
assert(sizeof(Base) == 1);</p>
<p>// empty base optimization applies</p>
<p>assert(sizeof(Derived1) == sizeof(int));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 676</p>
<p>}</p>
<p>Empty base optimization is commonly used by allocator-aware standard
library classes (<del>std::vector</del>, std::function,
<del>std::shared_ptr</del>, etc) to avoid occupying any additional
storage for its allocator member if the</p>
<p>allocator is stateless. This is achieved by storing one of the
required data members (e.g., <del>begin</del>, <del>end</del>, or
<del>capacity</del> pointer for the <del>vector</del>).</p>
<p>Reference: <a
href="http://en.cppreference.com/w/cpp/language/ebo">cppreference</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 677</p>
<p><span id="Chapter_145__Profiling_1" class="anchor"></span>Chapter
145: Profiling</p>
<p>Section 145.1: Profiling with gcc and gprof</p>
<p><a href="https://sourceware.org/binutils/docs/gprof/">The GNU gprof
profiler, gprof, allows you to profile your code. To use it, you need to
perform the following steps:</a></p>
<p>1. Build the application with settings for generating profiling
information</p>
<p>2. Generate profiling information by running the built
application</p>
<p>3. View the generated profiling information with gprof</p>
<p>In order to build the application with settings for generating
profiling information, we add the <del>-pg</del> flag. So, for</p>
<p>example, we could use</p>
<p>$ gcc -pg *.cpp-o app</p>
<p>or</p>
<p>$ gcc -O2 -pg *.cpp-o app</p>
<p>and so forth.</p>
<p>Once the application, say <del>app</del>, is built, execute it as
usual:</p>
<p>$ ./app</p>
<p>This should produce a file called <del>gmon.out</del>.</p>
<p>To see the profiling results, now run</p>
<p>$ gprof app gmon.out</p>
<p>(note that we provide both the application as well as the generated
output).</p>
<p>Of course, you can also pipe or redirect:</p>
<p>$ gprof app gmon.out | less</p>
<p>and so forth.</p>
<p>The result of the last command should be a table, whose rows are the
functions, and whose columns indicate the number of calls, total time
spent, self time spent (that is, time spent in the function excluding
calls to children).</p>
<p>Section 145.2: Generating callgraph diagrams with gperf2dot</p>
<p>For more complex applications, flat execution profiles may be
difficult to follow. This is why many profiling tools also generate some
form of annotated callgraph information.</p>
<p><a href="https://github.com/jrfonseca/gprof2dot">gperf2dot converts
text output from many profilers (Linux perf, callgrind, oprofile etc.)
into a callgraph diagram.</a></p>
<p>You can use it by running your profiler (example for
<del>gprof</del>):</p>
<p># compile with profiling flags</p>
<p>g++ *.cpp-pg</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 678</p>
<p><span id="__run_to_generate_profiling_data" class="anchor"></span>#
run to generate profiling data ./main</p>
<p># translate profiling data to text, create image gprof ./main |
gprof2dot -s | dot -Tpng -o output.png</p>
<p><img src="media/index-697_1.jpeg"
style="width:6.5in;height:4.44444in" alt="index-697_1.jpg" /></p>
<p>Section 145.3: Profiling CPU Usage with gcc and Google Perf</p>
<p>Tools</p>
<p><a href="https://github.com/gperftools/gperftools">Google Perf Tools
also provides a CPU profiler, with a slightly friendlier interface. To
use it:</a></p>
<p>1. <a href="https://github.com/gperftools/gperftools">Install Google
Perf Tools</a></p>
<p>2. Compile your code as usual</p>
<p>3. Add the <del>libprofiler</del> profiler library to your library
load path at runtime 4. Use <del>pprof</del> to generate a flat
execution profile, or a callgraph diagram</p>
<p>For example:</p>
<p># compile code</p>
<p>g++-O3 -std=c++11 main.cpp-o main</p>
<p># run with profiler</p>
<p>LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=main.prof
CPUPROFILE_FREQUENCY=100000 ./main</p>
<p>where:</p>
<p><del>CPUPROFILE</del> indicates the output file for profiling
data</p>
<p><del>CPUPROFILE_FREQUENCY</del> indicates the profiler sampling
frequency;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 679</p>
<p>Use <del>pprof</del> to post-process the profiling data.</p>
<p>You can generate a flat call profile as text:</p>
<p>$ pprof --text ./main main.prof</p>
<p>PROFILE: interrupts/evictions/bytes = 67/15/2016</p>
<p>pprof --text --lines ./main main.prof</p>
<p>Using local file ./main.</p>
<p>Using local file main.prof.</p>
<p>Total: 67 samples</p>
<p>22 32.8% 32.8% 67 100.0% longRunningFoo ??:0 20 29.9% 62.7% 20 29.9%
__memmove_ssse3_back
/build/eglibc-3GlaMS/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S:1627
4 6.0% 68.7% 4 6.0% __memmove_ssse3_back
/build/eglibc-3GlaMS/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S:1619
3 4.5% 73.1% 3 4.5% __random_r
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/random_r.c:388 3 4.5% 77.6% 3
4.5% __random_r /build/eglibc-3GlaMS/eglibc-2.19/stdlib/random_r.c:401 2
3.0% 80.6% 2 3.0% __munmap</p>
<p>/build/eglibc-3GlaMS/eglibc-2.19/misc/../sysdeps/unix/syscall-template.S:81
2 3.0% 83.6% 12 17.9% __random
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/random.c:298 2 3.0% 86.6% 2 3.0%
__random_r /build/eglibc-3GlaMS/eglibc-2.19/stdlib/random_r.c:385 2 3.0%
89.6% 2 3.0% rand /build/eglibc-3GlaMS/eglibc-2.19/stdlib/rand.c:26 1
1.5% 91.0% 1 1.5% __memmove_ssse3_back
/build/eglibc-3GlaMS/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S:1617
1 1.5% 92.5% 1 1.5% __memmove_ssse3_back
/build/eglibc-3GlaMS/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-ssse3-back.S:1623
1 1.5% 94.0% 1 1.5% __random
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/random.c:293 1 1.5% 95.5% 1 1.5%
__random /build/eglibc-3GlaMS/eglibc-2.19/stdlib/random.c:296 1 1.5%
97.0% 1 1.5% __random_r
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/random_r.c:371 1 1.5% 98.5% 1
1.5% __random_r /build/eglibc-3GlaMS/eglibc-2.19/stdlib/random_r.c:381 1
1.5% 100.0% 1 1.5% rand
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/rand.c:28 0 0.0% 100.0% 67
100.0% __libc_start_main
/build/eglibc-3GlaMS/eglibc-2.19/csu/libc-start.c:287</p>
<p>0 0.0% 100.0% 67 100.0% _start ??:0</p>
<p>0 0.0% 100.0% 67 100.0% main ??:0</p>
<p>0 0.0% 100.0% 14 20.9% rand
/build/eglibc-3GlaMS/eglibc-2.19/stdlib/rand.c:27 0 0.0% 100.0% 27 40.3%
std::vector::_M_emplace_back_aux ??:0</p>
<p>... or you can generate an annotated callgraph in a pdf with:</p>
<p>pprof --pdf ./main main.prof &gt; out.pdf</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 680</p>
<p><span id="Chapter_146__Refactoring_Techniq_1"
class="anchor"></span>Chapter 146: Refactoring Techniques</p>
<p>Refactoring refers to the modification of existing code into an
improved version. Although refactoring is often done</p>
<p>while changing code to add features or fix bugs, the term
particularly refers improving code without necessarily adding features
or fixing bugs.</p>
<p>Section 146.1: Goto Cleanup</p>
<p>In C++ code bases which used to be C, one can find the pattern
<del>goto cleanup</del>. As the <del>goto</del> command makes the
workflow of a function harder to understand, this is often avoided.
Often, it can be replaced by return statements,</p>
<p>loops, functions. Though, with the <del>goto cleanup</del> one needs
to get rid of cleanup logic.</p>
<p>short calculate(VectorStr **data) {</p>
<p>short result = FALSE;</p>
<p>VectorStr *vec = NULL;</p>
<p>if (!data)</p>
<p>goto cleanup; //&lt; Could become return false</p>
<p>// ... Calculation which 'new's VectorStr</p>
<p>result = TRUE;</p>
<p>cleanup:</p>
<p>delete [] vec;</p>
<p>return result;</p>
<p>}</p>
<p>In C++ one could use RAII to fix this issue:</p>
<p>struct VectorRAII final {</p>
<p>VectorStr *data{nullptr};</p>
<p>VectorRAII() = default;</p>
<p>~VectorRAII() {</p>
<p>delete [] data;</p>
<p>}</p>
<p>VectorRAII(const VectorRAII &amp;) = delete;</p>
<p>};</p>
<p>short calculate(VectorStr **data) {</p>
<p>VectorRAII vec{};</p>
<p>if (!data)</p>
<p>return FALSE; //&lt; Could become return false</p>
<p>// ... Calculation which 'new's VectorStr and stores it in
vec.data</p>
<p>return TRUE;</p>
<p>}</p>
<p>From this point on, one could continue refactoring the actual code.
For example by replacing the <del>VectorRAII</del> by</p>
<p>std::unique_ptr or <del>std::vector</del>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 681</p>
<p><span id="Credits" class="anchor"></span>Credits</p>
<p>Thank you greatly to all the people from Stack Overflow Documentation
who helped provide this content,</p>
<p>more changes can be sent to web@petercv.com for new content to be
published or updated</p>
<p><a href="https://stackoverflow.com/users/839932/">0x5f3759df</a>
Chapter 38</p>
<p><a href="https://stackoverflow.com/users/2834504/">1337ninja</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/5249858/">3442</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/1464444/">4444</a> Chapter
143</p>
<p><a href="https://stackoverflow.com/users/3132173/">A. Sarid</a>
Chapters 6 and 25</p>
<p><a href="https://stackoverflow.com/users/885287/">aaronsnoswell</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/2648679/">Abhinav
Gauniyal</a> Chapter 127</p>
<p><a href="https://stackoverflow.com/users/343443/">Abyx</a> Chapter
33</p>
<p><a href="https://stackoverflow.com/users/446252/">Adam Trhon</a>
Chapter 142</p>
<p><a href="https://stackoverflow.com/users/1460520/">Adhokshaj
Mishra</a> Chapter 138</p>
<p><a href="https://stackoverflow.com/users/6524169/">Aditya</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/264325/">Ajay</a> Chapters
7, 33, 73, 102 and 119</p>
<p><a href="https://stackoverflow.com/users/3435400/">alain</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/1274223/">Alejandro</a>
Chapter 80</p>
<p><a href="https://stackoverflow.com/users/6799654/">Alexey
Guseynov</a> Chapter 72</p>
<p><a href="https://stackoverflow.com/users/3291022/">Alexey
Voytenko</a> Chapters 33 and 34</p>
<p><a href="https://stackoverflow.com/users/5023438/">alter igel</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/5768335/">amanuel2</a>
Chapters 21, 29, 32, 39 and 128</p>
<p><a href="https://stackoverflow.com/users/2489715/">amchacon</a>
Chapter 80</p>
<p><a href="https://stackoverflow.com/users/3510736/">Ami Tavory</a>
Chapters 13, 49, 62, 104, 130 and 145</p>
<p><a href="https://stackoverflow.com/users/2808371/">an0o0nym</a>
Chapter 3</p>
<p><a href="https://stackoverflow.com/users/509868/">anatolyg</a>
Chapters 49 and 67</p>
<p><a href="https://stackoverflow.com/users/3198247/">anderas</a>
Chapters 12, 16, 33, 34, 44, 49 and 73</p>
<p><a href="https://stackoverflow.com/users/7193177/">Andrea Chua</a>
Chapters 44, 96 and 131</p>
<p><a href="https://stackoverflow.com/users/6503444/">Andrea
Corbelli</a> Chapters 26, 47, 50 and 73</p>
<p><a href="https://stackoverflow.com/users/27678/">AndyG</a> Chapters
49 and 110</p>
<p><a href="https://stackoverflow.com/users/6896866/">Anonymous1847</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/7369809/">anotherGatsby</a>
Chapters 11 and 15</p>
<p><a href="https://stackoverflow.com/users/4783169/">Antonio
Barreto</a> Chapter 112</p>
<p><a href="https://stackoverflow.com/users/136208/">AProgrammer</a>
Chapter 12</p>
<p><a href="https://stackoverflow.com/users/6873330/">Aravind .KEN</a>
Chapter 39</p>
<p><a
href="https://stackoverflow.com/users/5508296/">ArchbishopOfBanterbury</a>
Chapters 1, 36 and 138</p>
<p><a href="https://stackoverflow.com/users/5232529/">Artalus</a>
Chapter 108</p>
<p><a href="https://stackoverflow.com/users/6355709/">asantacreu</a>
Chapter 146</p>
<p><a href="https://stackoverflow.com/users/6261331/">Asu</a> Chapter
26</p>
<p><a href="https://stackoverflow.com/users/23501/">Ates Goral</a>
Chapter 36</p>
<p><a href="https://stackoverflow.com/users/6879340/">Bakhtiar Hasan</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/2860921/">Baron
Akramovic</a> Chapter 30</p>
<p><a href="https://stackoverflow.com/users/2069064/">Barry</a> Chapters
6, 9, 11, 16, 18, 24, 33, 36, 40, 44, 47, 49, 51, 63, 67, 73, 74, 77,
79, 82, 83, 98, 103, 105, 108, 110 and 138</p>
<p><a href="https://stackoverflow.com/users/558366/">bcmpinc</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/7204614/">Ben H</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/7691497/">Ben Steffan</a>
Chapter 138</p>
<p><a href="https://stackoverflow.com/users/919578/">Benjy Kessler</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/826938/">BigONotation</a>
Chapter 78</p>
<p><a href="https://stackoverflow.com/users/4396802/">Bim</a> Chapters
39 and 54</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 682</p>
<p><a href="https://stackoverflow.com/users/481267/">Brian</a> Chapters
1, 2, 3, 15, 20, 21, 22, 23, 34, 36, 44, 46, 64, 69, 71, 72, 73, 77, 79,
80, 84, 91, 95, 97, 98, 99, 100, 104, 105, 115, 119, 120, 121, 133 and
134</p>
<p><a href="https://stackoverflow.com/users/101954/">C.W.Holeman II</a>
Chapter 63</p>
<p><a href="https://stackoverflow.com/users/4005742/">CaffeineToCode</a>
Chapters 33 and 80</p>
<p><a href="https://stackoverflow.com/users/4975646/">callyalater</a>
Chapters 34, 72 and 75</p>
<p><a href="https://stackoverflow.com/users/3307308/">Candlemancer</a>
Chapter 36</p>
<p><a href="https://stackoverflow.com/users/2025214/">caps</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/1318479/">cb4</a> Chapter
77</p>
<p><a href="https://stackoverflow.com/users/1032073/">celtschk</a>
Chapters 1, 16, 24, 77, 90, 108 and 124</p>
<p><a href="https://stackoverflow.com/users/1429351/">Chachmu</a>
Chapter 12</p>
<p><a href="https://stackoverflow.com/users/464581/">Cheers and hth.</a>
Chapters 1, 8, 75, 94 and 106</p>
<p><a href="https://stackoverflow.com/users/6410484/">chema989</a>
Chapter 144</p>
<p><a href="https://stackoverflow.com/users/3563094/">ChemiCalChems</a>
Chapters 11, 74 and 106</p>
<p><a href="https://stackoverflow.com/users/2351345/">CHess</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/3098505/">chrisb2244</a>
Chapters 1 and 34</p>
<p><a href="https://stackoverflow.com/users/3853/">ChrisN</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/3723423/">Christophe</a>
Chapter 25</p>
<p><a href="https://stackoverflow.com/users/278842/">Christopher
Oezbek</a> Chapters 24, 33, 47 and 73</p>
<p><a href="https://stackoverflow.com/users/3120862/">Cid1025</a>
Chapter 114</p>
<p><a href="https://stackoverflow.com/users/2912665/">CinCout</a>
Chapters 48 and 49</p>
<p><a href="https://stackoverflow.com/users/472647/">CodeMouse92</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/366904/">Cody Gray</a>
Chapters 1, 6 and 49</p>
<p><a href="https://stackoverflow.com/users/2297448/">CoffeeandCode</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/2209008/">Colin Basnett</a>
Chapters 16, 34, 49 and 77</p>
<p><a href="https://stackoverflow.com/users/3735425/">ColleenV</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/577603/">ComicSansMS</a>
Chapters 12, 33, 49 and 80</p>
<p><a href="https://stackoverflow.com/users/4672588/">cpplearner</a>
Chapter 33</p>
<p><a href="https://stackoverflow.com/users/1051830/">crea7or</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/1953533/">CroCo</a> Chapter
6</p>
<p><a href="https://stackoverflow.com/users/2419922/">cshu</a> Chapter
104</p>
<p><a href="https://stackoverflow.com/users/5501675/">Curious</a>
Chapters 1 and 47</p>
<p><a href="https://stackoverflow.com/users/7152606/">cute_ptr</a>
Chapters 9 and 49</p>
<p><a href="https://stackoverflow.com/users/635654/">CygnusX1</a>
Chapters 50 and 75</p>
<p><a href="https://stackoverflow.com/users/2045438/">Daemon</a>
Chapters 1 and 10</p>
<p><a href="https://stackoverflow.com/users/5662469/">Daksh Gupta</a>
Chapters 1, 26, 33, 38, 48, 49 and 115</p>
<p><a href="https://stackoverflow.com/users/967945/">Dan Hulme</a>
Chapter 34</p>
<p><a href="https://stackoverflow.com/users/4115625/">Danh</a> Chapter
107</p>
<p><a href="https://stackoverflow.com/users/4758972/">Daniel</a>
Chapters 62 and 67</p>
<p><a href="https://stackoverflow.com/users/1116364/">Daniel Jour</a>
Chapter 9</p>
<p><a href="https://stackoverflow.com/users/1079174/">Daniel Käfer</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/5449709/">Daniel
Stradowski</a> Chapter 49</p>
<p><a href="https://stackoverflow.com/users/993040/">Daniele
Pallastrelli</a> Chapters 33, 107 and 108</p>
<p><a href="https://stackoverflow.com/users/6649800/">darkpsychic</a>
Chapters 1 and 26</p>
<p><a href="https://stackoverflow.com/users/30773/">davidsheldon</a>
Chapter 50</p>
<p><a href="https://stackoverflow.com/users/4764736/">DawidPi</a>
Chapter 16</p>
<p><a href="https://stackoverflow.com/users/921070/">Dean Seo</a>
Chapter 18</p>
<p><a href="https://stackoverflow.com/users/6639835/">DeepCoder</a>
Chapters 1, 24, 49 and 77</p>
<p><a href="https://stackoverflow.com/users/952747/">deepmax</a>
Chapters 16, 84, 113 and 117</p>
<p><a href="https://stackoverflow.com/users/6452255/">define cindy
const</a> Chapter 99</p>
<p><a href="https://stackoverflow.com/users/368519/">defube</a> Chapters
36, 80 and 83</p>
<p><a href="https://stackoverflow.com/users/462639/">demonplus</a>
Chapters 54 and 58</p>
<p><a href="https://stackoverflow.com/users/1873507/">Denkkar</a>
Chapter 68</p>
<p><a href="https://stackoverflow.com/users/7902545/">didiz</a> Chapters
3, 80, 81, 85, 86, 87, 88, 105, 112 and 140</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 683</p>
<p><a href="https://stackoverflow.com/users/8186051/">diegodfrf</a>
Chapters 49, 119 and 135</p>
<p><a href="https://stackoverflow.com/users/1120273/">Dietmar Kühl</a>
Chapter 60</p>
<p><a href="https://stackoverflow.com/users/2355119/">Dim_ov</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/1013504/">dkg</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/4284627/">Donald Duck</a>
Chapters 1 and 138</p>
<p><a href="https://stackoverflow.com/users/7886227/">Dr t</a> Chapters
1, 12, 49 and 72</p>
<p><a href="https://stackoverflow.com/users/6624845/">Dragma</a> Chapter
34</p>
<p><a href="https://stackoverflow.com/users/4289519/">drov</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/1705189/">Duly Kinsky</a>
Chapters 49 and 62</p>
<p><a href="https://stackoverflow.com/users/73657/">Dutow</a> Chapter
71</p>
<p><a href="https://stackoverflow.com/users/4064372/">Edd</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/5507349/">Edgar Rokjān</a>
Chapter 62</p>
<p><a href="https://stackoverflow.com/users/3191481/">Edward</a>
Chapters 1, 11, 33, 47, 66, 108 and 146</p>
<p><a href="https://stackoverflow.com/users/1385661/">ehudt</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/1345959/">Ela782</a> Chapter
24</p>
<p><a href="https://stackoverflow.com/users/2745573/">elimad</a> Chapter
52</p>
<p><a href="https://stackoverflow.com/users/1266688/">elvis.dukaj</a>
Chapter 141</p>
<p><a href="https://stackoverflow.com/users/5410879/">Emil Rowland</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/3425536/">emlai</a> Chapter
33</p>
<p><a href="https://stackoverflow.com/users/4250197/">Emmanuel Mathi</a>
Chapters 69 and 98</p>
<p><a href="https://stackoverflow.com/users/3555000/">Enamul Hassan</a>
Chapters 1, 24, 47, 49, 50, 67 and 138</p>
<p><a href="https://stackoverflow.com/users/364056/">enzom83</a> Chapter
36</p>
<p><a href="https://stackoverflow.com/users/8150685/">Error</a> Chapters
48 and 117</p>
<p><a href="https://stackoverflow.com/users/3209505/">Evgeniy</a>
Chapter 52</p>
<p><a href="https://stackoverflow.com/users/1894478/">EvgeniyZh</a>
Chapter 9</p>
<p><a href="https://stackoverflow.com/users/2263978/">Falias</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/1294207/">Fantastic Mr
Fox</a> Chapters 1, 24, 34, 47, 49, 50, 68, 75 and 138</p>
<p><a href="https://stackoverflow.com/users/153535/">fbrereto</a>
Chapters 9 and 47</p>
<p><a href="https://stackoverflow.com/users/5501669/">FedeWar</a>
Chapters 30 and 77</p>
<p><a href="https://stackoverflow.com/users/4763489/">Florian</a>
Chapters 1 and 130</p>
<p><a href="https://stackoverflow.com/users/134793/">Fox</a> Chapters 49
and 75</p>
<p><a href="https://stackoverflow.com/users/44738/">foxcub</a> Chapters
33, 49 and 50</p>
<p><a href="https://stackoverflow.com/users/293195/">Gabriel</a> Chapter
79</p>
<p><a href="https://stackoverflow.com/users/3580365/">Gal Dreiman</a>
Chapter 9</p>
<p><a href="https://stackoverflow.com/users/3807729/">Galik</a> Chapters
12, 24, 49, 50, 81 and 113</p>
<p><a href="https://stackoverflow.com/users/3141151/">Gaurav Kumar
Garg</a> Chapter 9</p>
<p><a href="https://stackoverflow.com/users/3475381/">Gaurav Sehgal</a>
Chapter 76</p>
<p><a href="https://stackoverflow.com/users/4822120/">ggrr</a> Chapter
104</p>
<p><a href="https://stackoverflow.com/users/6770027/">GIRISH kuniyal</a>
Chapter 104</p>
<p><a href="https://stackoverflow.com/users/4532326/">granmirupa</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/384507/">Greg</a> Chapter
77</p>
<p><a href="https://stackoverflow.com/users/4186872/">Guillaume
Pascal</a> Chapters 62 and 63</p>
<p><a href="https://stackoverflow.com/users/2104697/">Guillaume
Racicot</a> Chapter 106</p>
<p><a href="https://stackoverflow.com/users/289684/">Ha.</a> Chapter
65</p>
<p><a href="https://stackoverflow.com/users/3067055/">hello</a> Chapter
82</p>
<p><a href="https://stackoverflow.com/users/2768788/">Henkersmann</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/5156017/">Hindrik
Stegenga</a> Chapter 30</p>
<p><a href="https://stackoverflow.com/users/1979521/">holmicz</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/2666289/">Holt</a> Chapters
16, 47, 49 and 77</p>
<p><a href="https://stackoverflow.com/users/2675154/">honk</a> Chapters
1, 9, 11, 12, 24, 33, 47, 50, 73, 77, 79 and 82</p>
<p><a href="https://stackoverflow.com/users/4523099/">Humam Helfawi</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1084944/">Hurkyl</a>
Chapters 9, 12 and 49</p>
<p><a href="https://stackoverflow.com/users/7898708/">hyoslee</a>
Chapter 85</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 684</p>
<p><a href="https://stackoverflow.com/users/57159/">Ian Ringrose</a>
Chapter 75</p>
<p><a href="https://stackoverflow.com/users/44673/">Igor Oks</a> Chapter
108</p>
<p><a href="https://stackoverflow.com/users/1347198/">immerhart</a>
Chapters 49 and 139</p>
<p><a href="https://stackoverflow.com/users/308661/">In silico</a>
Chapter 101</p>
<p><a href="https://stackoverflow.com/users/1433373/">Ivan Kush</a>
Chapter 63</p>
<p><a href="https://stackoverflow.com/users/4789256/">Jérémy Roy</a>
Chapter 44</p>
<p><a href="https://stackoverflow.com/users/121747/">Jack</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/3744681/">Jahid</a> Chapters
47, 71, 72 and 138</p>
<p><a href="https://stackoverflow.com/users/4505712/">James Adkison</a>
Chapters 36 and 80</p>
<p><a href="https://stackoverflow.com/users/709010/">Jared Payne</a>
Chapters 33 and 51</p>
<p><a href="https://stackoverflow.com/users/2684539/">Jarod42</a>
Chapters 6, 16, 17, 25, 34, 44, 68, 72, 78, 83, 90, 103, 108, 112, 113,
114, 120, 121 and 138</p>
<p><a href="https://stackoverflow.com/users/1118660/">Jason Watkins</a>
Chapters 49, 80, 130 and 138</p>
<p><a href="https://stackoverflow.com/users/4762201/">Jatin</a> Chapters
17 and 35</p>
<p><a href="https://stackoverflow.com/users/719263/">Jean</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/179910/">Jerry Coffin</a>
Chapter 34</p>
<p><a href="https://stackoverflow.com/users/5331194/">Jim Clark</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1149664/">Johan Lundberg</a>
Chapters 1, 24, 33, 49, 82, 108, 113 and 138</p>
<p><a href="https://stackoverflow.com/users/34509/">Johannes Schaub</a>
Chapters 11, 24, 35, 37, 44, 73, 74, 101, 105 and 122</p>
<p><a href="https://stackoverflow.com/users/6445597/">John Burger</a>
Chapter 31</p>
<p><a href="https://stackoverflow.com/users/6230654/">John DiFini</a>
Chapter 43</p>
<p><a href="https://stackoverflow.com/users/6521181/">John London</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6141807/">Jonathan Lee</a>
Chapters 78 and 103</p>
<p><a href="https://stackoverflow.com/users/2642059/">Jonathan Mee</a>
Chapters 47 and 70</p>
<p><a href="https://stackoverflow.com/users/3919155/">jotik</a> Chapters
1, 33, 34, 47, 71, 72, 92 and 138</p>
<p><a href="https://stackoverflow.com/users/754534/">JPNotADragon</a>
Chapter 9</p>
<p><a href="https://stackoverflow.com/users/3336423/">jpo38</a> Chapters
47 and 49</p>
<p><a href="https://stackoverflow.com/users/143504/">Julien</a> Chapter
44</p>
<p><a href="https://stackoverflow.com/users/1896169/">Justin</a>
Chapters 1, 16, 17, 33, 70, 77 and 130</p>
<p><a href="https://stackoverflow.com/users/5386374/">Justin Time</a>
Chapters 1, 11, 20, 23, 25, 32, 34, 35, 38, 41, 71, 75, 82, 95, 106, 128
and 138</p>
<p><a href="https://stackoverflow.com/users/2466431/">JVApen</a>
Chapters 1, 3, 6, 12, 15, 27, 33, 35, 44, 49, 59, 63, 73, 83, 89, 91,
106, 107, 115, 118, 123, 126, 130, 138, 142, 143 and 146</p>
<p><a href="https://stackoverflow.com/users/6269864/">K48</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/2576475/">kd1508</a> Chapter
104</p>
<p><a href="https://stackoverflow.com/users/1270789/">Ken Y</a> Chapters
47 and 75</p>
<p><a href="https://stackoverflow.com/users/596781/">Kerrek SB</a>
Chapters 21, 33 and 34</p>
<p><a href="https://stackoverflow.com/users/6130880/">Keshav Sharma</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4688321/">kiner_shah</a>
Chapters 1 and 57</p>
<p><a href="https://stackoverflow.com/users/3007154/">krOoze</a>
Chapters 1, 40, 49 and 75</p>
<p><a href="https://stackoverflow.com/users/2292816/">Kunal Tyagi</a>
Chapter 37</p>
<p><a href="https://stackoverflow.com/users/6911592/">L.V.Rao</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/1070117/">Leandros</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/183120/">legends2k</a>
Chapter 39</p>
<p><a href="https://stackoverflow.com/users/211659/">Let_Me_Be</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/6292621/">lorro</a> Chapters
118 and 143</p>
<p><a href="https://stackoverflow.com/users/2531068/">Loufylouf</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/726300/">Luc Danton</a>
Chapter 103</p>
<p><a href="https://stackoverflow.com/users/723918/">maccard</a> Chapter
67</p>
<p><a href="https://stackoverflow.com/users/2369389/">madduci</a>
Chapters 115 and 138</p>
<p><a href="https://stackoverflow.com/users/3175443/">Malcolm</a>
Chapters 1 and 48</p>
<p><a href="https://stackoverflow.com/users/3205529/">Malick</a>
Chapters 1 and 138</p>
<p><a href="https://stackoverflow.com/users/3235496/">manlio</a>
Chapters 1, 5, 6, 11, 12, 25, 47, 49, 50, 63, 65, 71, 104, 111 and
138</p>
<p><a href="https://stackoverflow.com/users/3258851/">Marc.2377</a>
Chapter 47</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 685</p>
<p><a href="https://stackoverflow.com/users/471160/">marcinj</a> Chapter
66</p>
<p><a href="https://stackoverflow.com/users/1938163/">Marco A.</a>
Chapters 58, 63, 75, 100, 118 and 129</p>
<p><a href="https://stackoverflow.com/users/7105391/">Mark Gardner</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4015174/">marquesm91</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/14065/">Martin York</a>
Chapters 5, 12, 24, 49, 73, 77, 82 and 83</p>
<p><a href="https://stackoverflow.com/users/2163727/">MasterHD</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1979005/">MathSquared</a>
Chapter 123</p>
<p><a href="https://stackoverflow.com/users/859774/">Matt</a> Chapters 1
and 138</p>
<p><a href="https://stackoverflow.com/users/6630530/">Matthew Brien</a>
Chapter 8</p>
<p><a href="https://stackoverflow.com/users/147192/">Matthieu M.</a>
Chapter 16</p>
<p><a href="https://stackoverflow.com/users/2313339/">Maxito</a> Chapter
77</p>
<p><a href="https://stackoverflow.com/users/3997133/">Meena Alfons</a>
Chapter 125</p>
<p><a href="https://stackoverflow.com/users/3792942/">merlinND</a>
Chapter 65</p>
<p><a href="https://stackoverflow.com/users/69537/">Meysam</a> Chapters
33, 47 and 50</p>
<p><a href="https://stackoverflow.com/users/2577852/">Michael
Gaskill</a> Chapter 138</p>
<p><a href="https://stackoverflow.com/users/966097/">Mike H</a> Chapter
9</p>
<p><a href="https://stackoverflow.com/users/2881849/">MikeMB</a> Chapter
67</p>
<p><a href="https://stackoverflow.com/users/6065774/">Mikitori</a>
Chapter 59</p>
<p><a href="https://stackoverflow.com/users/2822643/">Mimouni</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/3233921/">mindriot</a>
Chapters 12 and 143</p>
<p><a href="https://stackoverflow.com/users/1083220/">Misgevolution</a>
Chapter 142</p>
<p><a href="https://stackoverflow.com/users/2079109/">MKAROL</a> Chapter
67</p>
<p><a href="https://stackoverflow.com/users/199201/">mkluwe</a> Chapter
15</p>
<p><a href="https://stackoverflow.com/users/5976576/">MotKohn</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/3848/">Motti</a> Chapters
38, 49 and 104</p>
<p><a href="https://stackoverflow.com/users/3102264/">mpromonet</a>
Chapters 13 and 47</p>
<p><a href="https://stackoverflow.com/users/15416/">MSalters</a>
Chapters 63 and 77</p>
<p><a href="https://stackoverflow.com/users/2082004/">MSD</a> Chapter
138</p>
<p><a href="https://stackoverflow.com/users/5520058/">mtb</a> Chapter
119</p>
<p><a href="https://stackoverflow.com/users/1135954/">mtk</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/235860/">Muhammad
Aladdin</a> Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4711812/">muXXmit2X</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/775806/">n.m.</a> Chapters
75 and 138</p>
<p><a href="https://stackoverflow.com/users/2656778/">Naor Hadar</a>
Chapter 66</p>
<p><a href="https://stackoverflow.com/users/193619/">Nathan Osman</a>
Chapters 1, 130 and 138</p>
<p><a href="https://stackoverflow.com/users/5453555/">Naveen Mittal</a>
Chapter 50</p>
<p><a href="https://stackoverflow.com/users/6719703/">Neil A.</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/133707/">Nemanja Boric</a>
Chapters 1, 72 and 138</p>
<p><a href="https://stackoverflow.com/users/3747990/">Niall</a> Chapters
24, 47, 49 and 83</p>
<p><a href="https://stackoverflow.com/users/5120389/">Nicholas</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/734069/">Nicol Bolas</a>
Chapters 11, 12, 16, 24, 27, 30, 44, 49, 52, 67, 68, 73, 74, 75, 79, 82,
88, 100 and 109</p>
<p><a href="https://stackoverflow.com/users/6181967/">Nikola Vasilev</a>
Chapters 2, 48, 53, 54, 55, 57, 91 and 112</p>
<p><a href="https://stackoverflow.com/users/2706918/">Nitinkumar
Ambekar</a> Chapter 30</p>
<p><a href="https://stackoverflow.com/users/4749396/">nnrales</a>
Chapter 115</p>
<p><a href="https://stackoverflow.com/users/1587418/">NonNumeric</a>
Chapter 116</p>
<p><a href="https://stackoverflow.com/users/3964927/">Null</a> Chapters
11, 44, 47, 50, 72 and 82</p>
<p><a href="https://stackoverflow.com/users/3484570/">nwp</a> Chapter
80</p>
<p><a href="https://stackoverflow.com/users/167958/">Omnifarious</a>
Chapter 20</p>
<p><a href="https://stackoverflow.com/users/321937/">Oz.</a> Chapter
9</p>
<p><a href="https://stackoverflow.com/users/5248907/">pandaman1234</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/6696267/">Pankaj Kumar
Boora</a> Chapter 84</p>
<p><a href="https://stackoverflow.com/users/1846282/">patmanpato</a>
Chapters 12 and 49</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 686</p>
<p><a href="https://stackoverflow.com/users/2033752/">Patryk Obara</a>
Chapter 62</p>
<p><a href="https://stackoverflow.com/users/4128833/">paul</a> Chapters
49 and 145</p>
<p><a href="https://stackoverflow.com/users/14356/">Paul Beckingham</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/344347/">Pavel Strakhov</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4932834/">PcAF</a> Chapters
33 and 34</p>
<p><a href="https://stackoverflow.com/users/4271923/">Ped7g</a> Chapters
11 and 49</p>
<p><a href="https://stackoverflow.com/users/5265558/">Perette
Barella</a> Chapter 7</p>
<p><a href="https://stackoverflow.com/users/4706785/">Peter</a> Chapters
24, 50, 71, 75, 104 and 138</p>
<p><a href="https://stackoverflow.com/users/3880898/">phandinhlan</a>
Chapter 75</p>
<p><a href="https://stackoverflow.com/users/1749822/">Pietro
Saccardi</a> Chapter 30</p>
<p><a href="https://stackoverflow.com/users/2430597/">plasmacel</a>
Chapter 48</p>
<p><a href="https://stackoverflow.com/users/1333978/">pmelanson</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/2081094/">Podgorskiy</a>
Chapter 17</p>
<p><a href="https://stackoverflow.com/users/241631/">Praetorian</a>
Chapters 49 and 73</p>
<p><a href="https://stackoverflow.com/users/3527464/">Pyves</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/868770/">Qchmqs</a> Chapter
15</p>
<p><a href="https://stackoverflow.com/users/2844164/">Quirk</a> Chapters
1 and 138</p>
<p><a href="https://stackoverflow.com/users/46642/">R. Martinho
Fernandes</a> Chapter 49</p>
<p><a href="https://stackoverflow.com/users/3980929/">Rakete1111</a>
Chapters 11, 12, 24, 33, 34, 35, 36, 44, 47, 49, 73, 77, 80, 104 and
110</p>
<p><a href="https://stackoverflow.com/users/6936976/">ralismark</a>
Chapters 104 and 144</p>
<p><a href="https://stackoverflow.com/users/6392939/">RamenChef</a>
Chapters 2, 15, 20, 21, 22 and 69</p>
<p><a href="https://stackoverflow.com/users/820800/">Ravi Chandra</a>
Chapters 54 and 67</p>
<p><a href="https://stackoverflow.com/users/6041265/">Reuben Thomas</a>
Chapter 40</p>
<p><a href="https://stackoverflow.com/users/5037799/">Richard Dally</a>
Chapters 33, 47, 49, 50, 75 and 138</p>
<p><a href="https://stackoverflow.com/users/62849/">rockoder</a> Chapter
26</p>
<p><a href="https://stackoverflow.com/users/865874/">rodrigo</a> Chapter
33</p>
<p><a href="https://stackoverflow.com/users/3951733/">Roland</a>
Chapters 33, 44, 84, 92, 101 and 114</p>
<p><a href="https://stackoverflow.com/users/5867869/">RomCoo</a> Chapter
12</p>
<p><a href="https://stackoverflow.com/users/1134649/">Ronen Ness</a>
Chapter 72</p>
<p><a href="https://stackoverflow.com/users/2465194/">rtmh</a> Chapter
16</p>
<p><a href="https://stackoverflow.com/users/2635286/">Rushikesh
Deshpande</a> Chapters 1 and 49</p>
<p><a href="https://stackoverflow.com/users/1013719/">Ryan Haining</a>
Chapters 73 and 79</p>
<p><a href="https://stackoverflow.com/users/5195699/">R_Kapp</a> Chapter
124</p>
<p><a href="https://stackoverflow.com/users/6514807/">Saint</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/3073378/">SajithP</a>
Chapter 67</p>
<p><a href="https://stackoverflow.com/users/5986881/">Samer Tufail</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/26095/">Sean</a> Chapters 35
and 75</p>
<p><a href="https://stackoverflow.com/users/1690777/">Sergey</a>
Chapters 9, 13, 19, 34, 38, 77 and 138</p>
<p><a href="https://stackoverflow.com/users/4899740/">Serikov</a>
Chapters 12, 47, 49 and 73</p>
<p><a href="https://stackoverflow.com/users/493122/">Shoe</a> Chapters 1
and 49</p>
<p><a href="https://stackoverflow.com/users/3554605/">sigalor</a>
Chapter 114</p>
<p><a href="https://stackoverflow.com/users/4955829/">silvergasp</a>
Chapters 34, 49, 75 and 93</p>
<p><a
href="https://stackoverflow.com/users/1490355/">SingerOfTheFall</a>
Chapter 123</p>
<p><a href="https://stackoverflow.com/users/1277769/">SirGuy</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/4241435/">Skipper</a>
Chapters 47 and 49</p>
<p><a href="https://stackoverflow.com/users/4855159/">Skywrath</a>
Chapter 34</p>
<p><a href="https://stackoverflow.com/users/6255513/">Smeeheey</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/3762339/">Snowhawk</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/3198508/">SouvikMaji</a>
Chapter 50</p>
<p><a href="https://stackoverflow.com/users/3202093/">sp2danny</a>
Chapter 103</p>
<p><a href="https://stackoverflow.com/users/2469027/">stackptr</a>
Chapter 68</p>
<p><a href="https://stackoverflow.com/users/4501684/">start2learn</a>
Chapters 36 and 133</p>
<p><a href="https://stackoverflow.com/users/5468596/">Stephen</a>
Chapters 24, 49 and 89</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 687</p>
<p><a href="https://stackoverflow.com/users/56338/">sth</a> Chapters 16
and 49</p>
<p><a href="https://stackoverflow.com/users/280904/">Stradigos</a>
Chapter 113</p>
<p><a href="https://stackoverflow.com/users/5006740/">strangeqargo</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/2640636/">SU3</a> Chapter
103</p>
<p><a href="https://stackoverflow.com/users/2209007/">Sumurai8</a>
Chapters 33, 65 and 83</p>
<p><a href="https://stackoverflow.com/users/2756719/">T.C.</a> Chapters
38 and 49</p>
<p><a href="https://stackoverflow.com/users/2176813/">tambre</a> Chapter
6</p>
<p><a href="https://stackoverflow.com/users/1918759/">Tannin</a>
Chapters 83 and 104</p>
<p><a href="https://stackoverflow.com/users/4719550/">Tarod</a> Chapter
52</p>
<p><a href="https://stackoverflow.com/users/496161/">TartanLlama</a>
Chapters 93 and 109</p>
<p><a href="https://stackoverflow.com/users/730537/">Tejendra</a>
Chapter 15</p>
<p><a href="https://stackoverflow.com/users/2575377/">tenpercent</a>
Chapters 17, 18, 24, 44 and 75</p>
<p><a href="https://stackoverflow.com/users/3312620/">Tharindu
Kumara</a> Chapter 138</p>
<p><a href="https://stackoverflow.com/users/6339395/">The Philomath</a>
Chapter 75</p>
<p><a href="https://stackoverflow.com/users/6244076/">theo2003</a>
Chapter 49</p>
<p><a href="https://stackoverflow.com/users/4586007/">ThyReaper</a>
Chapters 17, 92, 111 and 115</p>
<p><a href="https://stackoverflow.com/users/1292918/">Toby</a> Chapter
138</p>
<p><a href="https://stackoverflow.com/users/888916/">Tom</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/472245/">towi</a> Chapter
49</p>
<p><a href="https://stackoverflow.com/users/908939/">Trevor Hickey</a>
Chapters 6, 67 and 104</p>
<p><a href="https://stackoverflow.com/users/4433546/">TriskalJM</a>
Chapters 1, 40, 49 and 82</p>
<p><a href="https://stackoverflow.com/users/245614/">Trygve Laugstøl</a>
Chapter 138</p>
<p><a href="https://stackoverflow.com/users/6114605/">tulak.hord</a>
Chapter 61</p>
<p><a href="https://stackoverflow.com/users/3681671/">turoni</a> Chapter
3</p>
<p><a href="https://stackoverflow.com/users/1152524/">txtechhelp</a>
Chapters 5 and 111</p>
<p><a href="https://stackoverflow.com/users/60531/">UncleZeiv</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1336087/">user1336087</a>
Chapters 47, 49 and 50</p>
<p><a href="https://stackoverflow.com/users/2176127/">user2176127</a>
Chapters 47 and 49</p>
<p><a href="https://stackoverflow.com/users/3384414/">user3384414</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/3684240/">user3684240</a>
Chapter 33</p>
<p><a href="https://stackoverflow.com/users/2225297/">vdaras</a> Chapter
50</p>
<p><a href="https://stackoverflow.com/users/751865/">Venki</a> Chapter
16</p>
<p><a
href="https://stackoverflow.com/users/3819850/">VermillionAzure</a>
Chapters 1, 45, 130 and 141</p>
<p><a href="https://stackoverflow.com/users/6173047/">Vijayabhaskarreddy
CH</a> Chapter 42</p>
<p><a href="https://stackoverflow.com/users/5489178/">Ville</a> Chapters
1 and 24</p>
<p><a href="https://stackoverflow.com/users/5011111/">Vladimir
Gamalyan</a> Chapter 49</p>
<p><a href="https://stackoverflow.com/users/3545806/">VladimirS</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/25472/">VolkA</a> Chapter
50</p>
<p><a href="https://stackoverflow.com/users/4324224/">W.F.</a> Chapters
16 and 77</p>
<p><a href="https://stackoverflow.com/users/929037/">w1th0utnam3</a>
Chapter 103</p>
<p><a href="https://stackoverflow.com/users/1023390/">Walter</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/6612932/">wasthishelpful</a>
Chapter 137</p>
<p><a href="https://stackoverflow.com/users/2932052/">Wolf</a> Chapters
8, 47, 49 and 77</p>
<p><a href="https://stackoverflow.com/users/7421086/">WQYeo</a> Chapters
1 and 8</p>
<p><a href="https://stackoverflow.com/users/226975/">Wyzard</a> Chapter
50</p>
<p><a href="https://stackoverflow.com/users/5241642/">Xirema</a> Chapter
4</p>
<p><a href="https://stackoverflow.com/users/1774667/">Yakk</a> Chapters
9, 11, 24, 33, 36, 42, 44, 49, 51, 56, 57, 73, 80, 90, 103, 107, 108 and
121</p>
<p><a href="https://stackoverflow.com/users/5089102/">Yousuf Azad</a>
Chapter 33</p>
<p><a href="https://stackoverflow.com/users/637866/">ysdx</a> Chapter
16</p>
<p><a href="https://stackoverflow.com/users/1085573/">Yuushi</a> Chapter
80</p>
<p><a href="https://stackoverflow.com/users/982161/">ΦXocę 웃 Пepeúpa
ツ</a> Chapter 8</p>
<p><a href="https://stackoverflow.com/users/7172363/">Алексей
Неудачин</a> Chapters 5 and 12</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 688</p>
<p><a href="https://stackoverflow.com/users/8221170/">Владимир
Стрелец</a> Chapters 10 and 14</p>
<p><a href="https://stackoverflow.com/users/7632486/">パスカル</a>
Chapters 1, 75 and 136</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – C++ Notes for
Professionals</a> 689</p>
<p><span id="You_may_also_like" class="anchor"></span>You may also
like</p>
<p><img src="media/index-708_1.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_1.jpg" /></p>
<p><img src="media/index-708_2.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_2.jpg" /></p>
<p><img src="media/index-708_3.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_3.jpg" /></p>
<p><img src="media/index-708_4.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_4.jpg" /></p>
<p><img src="media/index-708_5.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_5.jpg" /></p>
<p><img src="media/index-708_6.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_6.jpg" /></p>
<p><img src="media/index-708_7.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_7.jpg" /></p>
<p><img src="media/index-708_8.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_8.jpg" /></p>
<p><img src="media/index-708_9.jpeg"
style="width:2.52778in;height:3.5in" alt="index-708_9.jpg" /></p>
</body>
</html>
