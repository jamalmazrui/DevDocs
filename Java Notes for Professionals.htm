<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Java Notes for Professionals</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h1 id="table-of-contents">Table of Contents</h1>
<p><a
href="#chapter-10-primitive-data-types-.......................................................................................................................-42"><u>Chapter
10: Primitive Data Types
.......................................................................................................................
42</u></a></p>
<p><a
href="#chapter-11-strings-......................................................................................................................................................-51"><u>Chapter
11: Strings
......................................................................................................................................................
51</u></a></p>
<p><a
href="#chapter-12-stringbuer-.........................................................................................................................................-68"><u>Chapter
12: StringBuer
.........................................................................................................................................
68</u></a></p>
<p><a
href="#chapter-13-stringbuilder-........................................................................................................................................-69"><u>Chapter
13: StringBuilder
........................................................................................................................................
69</u></a></p>
<p><a
href="#chapter-14-string-tokenizer-................................................................................................................................-71"><u>Chapter
14: String Tokenizer
................................................................................................................................
71</u></a></p>
<p><a
href="#chapter-15-splitting-a-string-into-fixed-length-parts-...............................................................................-72"><u>Chapter
15: Splitting a string into fixed length parts
...............................................................................
72</u></a></p>
<p><a
href="#chapter-16-date-class-.............................................................................................................................................-73"><u>Chapter
16: Date Class
.............................................................................................................................................
73</u></a></p>
<p><a
href="#chapter-17-dates-and-time-java.time.-.......................................................................................................-82"><u>Chapter
17: Dates and Time (java.time.*)
.......................................................................................................
82</u></a></p>
<p><a
href="#chapter-18-localtime-..............................................................................................................................................-87"><u>Chapter
18: LocalTime
..............................................................................................................................................
87</u></a></p>
<p><a
href="#chapter-19-bigdecimal-............................................................................................................................................-90"><u>Chapter
19: BigDecimal
............................................................................................................................................
90</u></a></p>
<p><a
href="#chapter-20-biginteger-............................................................................................................................................-96"><u>Chapter
20: BigInteger
............................................................................................................................................
96</u></a></p>
<p><a href="#Chapter_21__NumberFormat"><u>Chapter 21: NumberFormat
.................................................................................................................................
103</u></a></p>
<p><a
href="#chapter-22-bit-manipulation-..............................................................................................................................-104"><u>Chapter
22: Bit Manipulation
..............................................................................................................................
104</u></a></p>
<p><a
href="#chapter-23-arrays-...................................................................................................................................................-109"><u>Chapter
23: Arrays
...................................................................................................................................................
109</u></a></p>
<p><a
href="#chapter-24-collections-.........................................................................................................................................-133"><u>Chapter
24: Collections
.........................................................................................................................................
133</u></a></p>
<p><a
href="#chapter-25-lists-.......................................................................................................................................................-146"><u>Chapter
25: Lists
.......................................................................................................................................................
146</u></a></p>
<p><a
href="#chapter-26-sets-........................................................................................................................................................-157"><u>Chapter
26: Sets
........................................................................................................................................................
157</u></a></p>
<p><a
href="#chapter-27-list-vs-set-...........................................................................................................................................-161"><u>Chapter
27: List vs Set
...........................................................................................................................................
161</u></a></p>
<p><a
href="#chapter-28-maps-......................................................................................................................................................-162"><u>Chapter
28: Maps
......................................................................................................................................................
162</u></a></p>
<p><a
href="#chapter-29-linkedhashmap-...............................................................................................................................-175"><u>Chapter
29: LinkedHashMap
...............................................................................................................................
175</u></a></p>
<p><a
href="#chapter-30-weakhashmap-.................................................................................................................................-176"><u>Chapter
30: WeakHashMap
.................................................................................................................................
176</u></a></p>
<p><a
href="#chapter-31-sortedmap-..........................................................................................................................................-177"><u>Chapter
31: SortedMap
..........................................................................................................................................
177</u></a></p>
<p><a
href="#chapter-32-treemap-and-treeset-..................................................................................................................-178"><u>Chapter
32: TreeMap and TreeSet
..................................................................................................................
178</u></a></p>
<p><a
href="#chapter-33-queues-and-deques-......................................................................................................................-182"><u>Chapter
33: Queues and Deques
......................................................................................................................
182</u></a></p>
<p><a
href="#chapter-34-dequeue-interface-........................................................................................................................-187"><u>Chapter
34: Dequeue Interface
........................................................................................................................
187</u></a></p>
<p><a
href="#chapter-35-enums-...................................................................................................................................................-189"><u>Chapter
35: Enums
...................................................................................................................................................
189</u></a></p>
<p><a
href="#chapter-36-enum-map-...........................................................................................................................................-205"><u>Chapter
36: Enum Map
...........................................................................................................................................
205</u></a></p>
<p><a
href="#chapter-37-enumset-class-..................................................................................................................................-206"><u>Chapter
37: EnumSet class
..................................................................................................................................
206</u></a></p>
<p><a
href="#chapter-38-enum-starting-with-number-......................................................................................................-207"><u>Chapter
38: Enum starting with number
......................................................................................................
207</u></a></p>
<p><a
href="#chapter-39-hashtable-...........................................................................................................................................-208"><u>Chapter
39: Hashtable
...........................................................................................................................................
208</u></a></p>
<p><a
href="#chapter-40-operators-..........................................................................................................................................-209"><u>Chapter
40: Operators
..........................................................................................................................................
209</u></a></p>
<p><a
href="#chapter-41-constructors-.....................................................................................................................................-225"><u>Chapter
41: Constructors
.....................................................................................................................................
225</u></a></p>
<p><a
href="#chapter-42-object-class-methods-and-constructor-.............................................................................-229"><u>Chapter
42: Object Class Methods and Constructor
.............................................................................
229</u></a></p>
<p><a
href="#chapter-43-annotations-......................................................................................................................................-241"><u>Chapter
43: Annotations
......................................................................................................................................
241</u></a></p>
<p><a
href="#chapter-44-immutable-class-............................................................................................................................-255"><u>Chapter
44: Immutable Class
............................................................................................................................
255</u></a></p>
<p><a
href="#chapter-45-immutable-objects-.......................................................................................................................-257"><u>Chapter
45: Immutable Objects
.......................................................................................................................
257</u></a></p>
<p><a href="#Chapter_46__Visibility__controll"><u>Chapter 46: Visibility
(controlling access to members of a class)
................................................. 262</u></a></p>
<p><a
href="#chapter-47-generics-..............................................................................................................................................-265"><u>Chapter
47: Generics
..............................................................................................................................................
265</u></a></p>
<p><a
href="#chapter-48-classes-and-objects-.....................................................................................................................-280"><u>Chapter
48: Classes and Objects
.....................................................................................................................
280</u></a></p>
<p><a
href="#chapter-49-local-inner-class-............................................................................................................................-289"><u>Chapter
49: Local Inner Class
............................................................................................................................
289</u></a></p>
<p><a
href="#chapter-50-nested-and-inner-classes-..........................................................................................................-290"><u>Chapter
50: Nested and Inner Classes
..........................................................................................................
290</u></a></p>
<p><a
href="#chapter-51-the-java.util.objects-class-.........................................................................................................-297"><u>Chapter
51: The java.util.Objects Class
.........................................................................................................
297</u></a></p>
<p><a
href="#chapter-52-default-methods-.............................................................................................................................-298"><u>Chapter
52: Default Methods
.............................................................................................................................
298</u></a></p>
<p><a
href="#chapter-53-packages-............................................................................................................................................-303"><u>Chapter
53: Packages
............................................................................................................................................
303</u></a></p>
<p><a
href="#chapter-54-inheritance-........................................................................................................................................-305"><u>Chapter
54: Inheritance
........................................................................................................................................
305</u></a></p>
<p><a
href="#chapter-55-reference-types-............................................................................................................................-320"><u>Chapter
55: Reference Types
............................................................................................................................
320</u></a></p>
<p><a href="#Chapter_56__Console_I_O"><u>Chapter 56: Console I/O
........................................................................................................................................
322</u></a></p>
<p><a
href="#chapter-57-streams-...............................................................................................................................................-326"><u>Chapter
57: Streams
...............................................................................................................................................
326</u></a></p>
<p><a
href="#chapter-58-inputstreams-and-outputstreams-.......................................................................................-349"><u>Chapter
58: InputStreams and OutputStreams
.......................................................................................
349</u></a></p>
<p><a
href="#chapter-59-readers-and-writers-....................................................................................................................-353"><u>Chapter
59: Readers and Writers
....................................................................................................................
353</u></a></p>
<p><a
href="#chapter-60-preferences-.......................................................................................................................................-355"><u>Chapter
60: Preferences
.......................................................................................................................................
355</u></a></p>
<p><a
href="#chapter-61-collection-factory-methods-.......................................................................................................-361"><u>Chapter
61: Collection Factory Methods
.......................................................................................................
361</u></a></p>
<p><a
href="#chapter-62-alternative-collections-................................................................................................................-362"><u>Chapter
62: Alternative Collections
................................................................................................................
362</u></a></p>
<p><a
href="#chapter-63-concurrent-collections-................................................................................................................-371"><u>Chapter
63: Concurrent Collections
................................................................................................................
371</u></a></p>
<p><a
href="#chapter-64-choosing-collections-....................................................................................................................-374"><u>Chapter
64: Choosing Collections
....................................................................................................................
374</u></a></p>
<p><a
href="#chapter-65-super-keyword-.................................................................................................................................-375"><u>Chapter
65: super keyword
.................................................................................................................................
375</u></a></p>
<p><a
href="#chapter-66-serialization-......................................................................................................................................-378"><u>Chapter
66: Serialization
......................................................................................................................................
378</u></a></p>
<p><a href="#Chapter_67__Optional"><u>Chapter 67: Optional
...............................................................................................................................................
387</u></a></p>
<p><a
href="#chapter-68-object-references-.........................................................................................................................-391"><u>Chapter
68: Object References
.........................................................................................................................
391</u></a></p>
<p><a
href="#chapter-69-exceptions-and-exception-handling-......................................................................................-394"><u>Chapter
69: Exceptions and exception handling
......................................................................................
394</u></a></p>
<p><a
href="#chapter-70-calendar-and-its-subclasses-....................................................................................................-416"><u>Chapter
70: Calendar and its Subclasses
....................................................................................................
416</u></a></p>
<p><a
href="#chapter-71-using-the-static-keyword-............................................................................................................-418"><u>Chapter
71: Using the static keyword
............................................................................................................
418</u></a></p>
<p><a
href="#chapter-72-properties-class-..............................................................................................................................-420"><u>Chapter
72: Properties Class
..............................................................................................................................
420</u></a></p>
<p><a
href="#chapter-73-lambda-expressions-.....................................................................................................................-424"><u>Chapter
73: Lambda Expressions
.....................................................................................................................
424</u></a></p>
<p><a
href="#chapter-74-basic-control-structures-............................................................................................................-438"><u>Chapter
74: Basic Control Structures
............................................................................................................
438</u></a></p>
<p><a
href="#chapter-75-bueredwriter-................................................................................................................................-446"><u>Chapter
75: BueredWriter
................................................................................................................................
446</u></a></p>
<p><a href="#Chapter_76__New_File_I_O"><u>Chapter 76: New File I/O
.......................................................................................................................................
447</u></a></p>
<p><a
href="#chapter-77-file-io-.................................................................................................................................................-450"><u>Chapter
77: File I/O
.................................................................................................................................................
450</u></a></p>
<p><a
href="#chapter-78-scanner-...............................................................................................................................................-464"><u>Chapter
78: Scanner
...............................................................................................................................................
464</u></a></p>
<p><a
href="#chapter-79-interfaces-...........................................................................................................................................-469"><u>Chapter
79: Interfaces
...........................................................................................................................................
469</u></a></p>
<p><a
href="#chapter-80-regular-expressions-.....................................................................................................................-480"><u>Chapter
80: Regular Expressions
.....................................................................................................................
480</u></a></p>
<p><a href="#Chapter_81__Comparable_and_Compa"><u>Chapter 81: Comparable
and Comparator
..................................................................................................
484</u></a></p>
<p><a
href="#chapter-82-java-floating-point-operations-..............................................................................................-491"><u>Chapter
82: Java Floating Point Operations
..............................................................................................
491</u></a></p>
<p><a
href="#chapter-83-currency-and-money-....................................................................................................................-496"><u>Chapter
83: Currency and Money
....................................................................................................................
496</u></a></p>
<p><a
href="#chapter-84-object-cloning-.................................................................................................................................-497"><u>Chapter
84: Object Cloning
.................................................................................................................................
497</u></a></p>
<p><a href="#Chapter_85__Recursion"><u>Chapter 85: Recursion
............................................................................................................................................
501</u></a></p>
<p><a
href="#chapter-86-converting-to-and-from-strings-.............................................................................................-508"><u>Chapter
86: Converting to and from Strings
.............................................................................................
508</u></a></p>
<p><a
href="#chapter-87-random-number-generation-..................................................................................................-512"><u>Chapter
87: Random Number Generation
..................................................................................................
512</u></a></p>
<p><a
href="#chapter-88-singletons-..........................................................................................................................................-516"><u>Chapter
88: Singletons
..........................................................................................................................................
516</u></a></p>
<p><a href="#Chapter_89__Autoboxing"><u>Chapter 89: Autoboxing
.........................................................................................................................................
521</u></a></p>
<p><a
href="#chapter-90-2d-graphics-in-java-......................................................................................................................-525"><u>Chapter
90: 2D Graphics in Java
......................................................................................................................
525</u></a></p>
<p><a
href="#chapter-91-jaxb-.......................................................................................................................................................-528"><u>Chapter
91: JAXB
.......................................................................................................................................................
528</u></a></p>
<p><a
href="#chapter-92-class---java-reflection-................................................................................................................-537"><u>Chapter
92: Class - Java Reflection
................................................................................................................
537</u></a></p>
<p><a
href="#chapter-93-networking-........................................................................................................................................-538"><u>Chapter
93: Networking
........................................................................................................................................
538</u></a></p>
<p><a
href="#chapter-94-nio---networking-...........................................................................................................................-547"><u>Chapter
94: NIO - Networking
...........................................................................................................................
547</u></a></p>
<p><a
href="#chapter-95-httpurlconnection-......................................................................................................................-549"><u>Chapter
95: HttpURLConnection
......................................................................................................................
549</u></a></p>
<p><a
href="#chapter-96-jax-ws-................................................................................................................................................-553"><u>Chapter
96: JAX-WS
................................................................................................................................................
553</u></a></p>
<p><a
href="#chapter-97-nashorn-javascript-engine-......................................................................................................-554"><u>Chapter
97: Nashorn JavaScript engine
......................................................................................................
554</u></a></p>
<p><a
href="#chapter-98-java-native-interface-..................................................................................................................-558"><u>Chapter
98: Java Native Interface
..................................................................................................................
558</u></a></p>
<p><a
href="#chapter-99-functional-interfaces-...................................................................................................................-563"><u>Chapter
99: Functional Interfaces
...................................................................................................................
563</u></a></p>
<p><a
href="#chapter-100-fluent-interface-............................................................................................................................-565"><u>Chapter
100: Fluent Interface
............................................................................................................................
565</u></a></p>
<p><a
href="#chapter-101-remote-method-invocation-rmi-.........................................................................................-567"><u>Chapter
101: Remote Method Invocation (RMI)
.........................................................................................
567</u></a></p>
<p><a
href="#chapter-102-iterator-and-iterable-..................................................................................................................-576"><u>Chapter
102: Iterator and Iterable
..................................................................................................................
576</u></a></p>
<p><a
href="#chapter-103-reflection-api-.................................................................................................................................-579"><u>Chapter
103: Reflection API
.................................................................................................................................
579</u></a></p>
<p><a href="#Chapter_104__ByteBu_er"><u>Chapter 104: ByteBuer
.......................................................................................................................................
590</u></a></p>
<p><a
href="#chapter-105-applets-...............................................................................................................................................-592"><u>Chapter
105: Applets
...............................................................................................................................................
592</u></a></p>
<p><a
href="#chapter-106-expressions-......................................................................................................................................-596"><u>Chapter
106: Expressions
......................................................................................................................................
596</u></a></p>
<p><a
href="#chapter-107-json-in-java-..................................................................................................................................-601"><u>Chapter
107: JSON in Java
..................................................................................................................................
601</u></a></p>
<p><a
href="#chapter-108-xml-parsing-using-the-jaxp-apis-.........................................................................................-607"><u>Chapter
108: XML Parsing using the JAXP APIs
.........................................................................................
607</u></a></p>
<p><a
href="#chapter-109-xml-xpath-evaluation-................................................................................................................-610"><u>Chapter
109: XML XPath Evaluation
................................................................................................................
610</u></a></p>
<p><a
href="#chapter-110-xom---xml-object-model-...........................................................................................................-612"><u>Chapter
110: XOM - XML Object Model
...........................................................................................................
612</u></a></p>
<p><a
href="#chapter-111-polymorphism-..................................................................................................................................-617"><u>Chapter
111: Polymorphism
..................................................................................................................................
617</u></a></p>
<p><a
href="#chapter-112-encapsulation-..................................................................................................................................-625"><u>Chapter
112: Encapsulation
..................................................................................................................................
625</u></a></p>
<p><a href="#Chapter_113__Java_Agents"><u>Chapter 113: Java Agents
......................................................................................................................................
627</u></a></p>
<p><a
href="#chapter-114-varargs-variable-argument-................................................................................................-629"><u>Chapter
114: Varargs (Variable Argument)
................................................................................................
629</u></a></p>
<p><a
href="#chapter-115-logging-java.util.logging-.......................................................................................................-630"><u>Chapter
115: Logging (java.util.logging)
.......................................................................................................
630</u></a></p>
<p><a
href="#chapter-116-log4j-log4j2-..................................................................................................................................-634"><u>Chapter
116: log4j / log4j2
..................................................................................................................................
634</u></a></p>
<p><a
href="#chapter-117-oracle-ocial-code-standard-...............................................................................................-639"><u>Chapter
117: Oracle Ocial Code Standard
...............................................................................................
639</u></a></p>
<p><a
href="#chapter-118-character-encoding-.....................................................................................................................-649"><u>Chapter
118: Character encoding
.....................................................................................................................
649</u></a></p>
<p><a
href="#chapter-119-apache-commons-lang-.............................................................................................................-651"><u>Chapter
119: Apache Commons Lang
.............................................................................................................
651</u></a></p>
<p><a
href="#chapter-120-localization-and-internationalization-................................................................................-654"><u>Chapter
120: Localization and Internationalization
................................................................................
654</u></a></p>
<p><a href="#Chapter_121__Parallel_programmin"><u>Chapter 121: Parallel
programming with Fork/Join framework
...................................................... 656</u></a></p>
<p><a
href="#chapter-122-non-access-modifiers-.................................................................................................................-658"><u>Chapter
122: Non-Access Modifiers
.................................................................................................................
658</u></a></p>
<p><a
href="#chapter-123-process-...............................................................................................................................................-664"><u>Chapter
123: Process
...............................................................................................................................................
664</u></a></p>
<p><a
href="#chapter-124-java-native-access-.....................................................................................................................-667"><u>Chapter
124: Java Native Access
.....................................................................................................................
667</u></a></p>
<p><a href="#Chapter_125__Modules"><u>Chapter 125: Modules
..............................................................................................................................................
668</u></a></p>
<p><a
href="#chapter-126-concurrent-programming-threads-..................................................................................-669"><u>Chapter
126: Concurrent Programming (Threads)
..................................................................................
669</u></a></p>
<p><a
href="#chapter-127-executor-executorservice-and-thread-pools-................................................................-693"><u>Chapter
127: Executor, ExecutorService and Thread pools
................................................................
693</u></a></p>
<p><a
href="#chapter-128-threadlocal-....................................................................................................................................-705"><u>Chapter
128: ThreadLocal
....................................................................................................................................
705</u></a></p>
<p><a href="#Chapter_129__Using_ThreadPoolExe"><u>Chapter 129: Using
ThreadPoolExecutor in MultiThreaded applications.
.................................... 709</u></a></p>
<p><a
href="#chapter-130-common-java-pitfalls-................................................................................................................-715"><u>Chapter
130: Common Java Pitfalls
................................................................................................................
715</u></a></p>
<p><a
href="#chapter-131-java-pitfalls---exception-usage-..............................................................................................-725"><u>Chapter
131: Java Pitfalls - Exception usage
..............................................................................................
725</u></a></p>
<p><a
href="#chapter-132-java-pitfalls---language-syntax-...........................................................................................-732"><u>Chapter
132: Java Pitfalls - Language syntax
...........................................................................................
732</u></a></p>
<p><a href="#Chapter_133__Java_Pitfalls___Thr"><u>Chapter 133: Java
Pitfalls - Threads and Concurrency
.........................................................................
741</u></a></p>
<p><a
href="#chapter-134-java-pitfalls---nulls-and-nullpointerexception-.............................................................-749"><u>Chapter
134: Java Pitfalls - Nulls and NullPointerException
.............................................................
749</u></a></p>
<p><a
href="#chapter-135-java-pitfalls---performance-issues-......................................................................................-754"><u>Chapter
135: Java Pitfalls - Performance Issues
......................................................................................
754</u></a></p>
<p><a
href="#chapter-136-serviceloader-................................................................................................................................-766"><u>Chapter
136: ServiceLoader
................................................................................................................................
766</u></a></p>
<p><a
href="#chapter-137-classloaders-....................................................................................................................................-769"><u>Chapter
137: Classloaders
....................................................................................................................................
769</u></a></p>
<p><a
href="#chapter-138-creating-images-programmatically-...................................................................................-772"><u>Chapter
138: Creating Images Programmatically
...................................................................................
772</u></a></p>
<p><a
href="#chapter-139-atomic-types-..................................................................................................................................-779"><u>Chapter
139: Atomic Types
..................................................................................................................................
779</u></a></p>
<p><a
href="#chapter-140-rsa-encryption-.............................................................................................................................-783"><u>Chapter
140: RSA Encryption
.............................................................................................................................
783</u></a></p>
<p><a
href="#chapter-141-secure-objects-................................................................................................................................-788"><u>Chapter
141: Secure objects
................................................................................................................................
788</u></a></p>
<p><a
href="#chapter-142-security-cryptography-.........................................................................................................-790"><u>Chapter
142: Security &amp; Cryptography
.........................................................................................................
790</u></a></p>
<p><a
href="#chapter-143-security-cryptography-.........................................................................................................-793"><u>Chapter
143: Security &amp; Cryptography
.........................................................................................................
793</u></a></p>
<p><a
href="#chapter-144-securitymanager-.........................................................................................................................-795"><u>Chapter
144: SecurityManager
.........................................................................................................................
795</u></a></p>
<p><a
href="#chapter-145-jndi-....................................................................................................................................................-804"><u>Chapter
145: JNDI
....................................................................................................................................................
804</u></a></p>
<p><a
href="#chapter-146-sun.misc.unsafe-............................................................................................................................-808"><u>Chapter
146: sun.misc.Unsafe
............................................................................................................................
808</u></a></p>
<p><a
href="#chapter-147-java-memory-model-...................................................................................................................-810"><u>Chapter
147: Java Memory Model
...................................................................................................................
810</u></a></p>
<p><a href="#Chapter_148__Java_deployment"><u>Chapter 148: Java
deployment
.........................................................................................................................
817</u></a></p>
<p><a
href="#chapter-149-java-plugin-system-implementations-...............................................................................-823"><u>Chapter
149: Java plugin system implementations
...............................................................................
823</u></a></p>
<p><a
href="#chapter-150-javabean-.........................................................................................................................................-827"><u>Chapter
150: JavaBean
.........................................................................................................................................
827</u></a></p>
<p><a
href="#chapter-151-java-se-7-features-.......................................................................................................................-828"><u>Chapter
151: Java SE 7 Features
.......................................................................................................................
828</u></a></p>
<p><a
href="#chapter-152-java-se-8-features-......................................................................................................................-831"><u>Chapter
152: Java SE 8 Features
......................................................................................................................
831</u></a></p>
<p><a
href="#chapter-153-dynamic-method-dispatch-.......................................................................................................-832"><u>Chapter
153: Dynamic Method Dispatch
.......................................................................................................
832</u></a></p>
<p><a
href="#chapter-154-generating-java-code-..............................................................................................................-835"><u>Chapter
154: Generating Java Code
..............................................................................................................
835</u></a></p>
<p><a
href="#chapter-155-jshell-..................................................................................................................................................-836"><u>Chapter
155: JShell
..................................................................................................................................................
836</u></a></p>
<p><a
href="#chapter-156-stack-walking-api-........................................................................................................................-839"><u>Chapter
156: Stack-Walking API
........................................................................................................................
839</u></a></p>
<p><a
href="#chapter-157-sockets-..............................................................................................................................................-842"><u>Chapter
157: Sockets
..............................................................................................................................................
842</u></a></p>
<p><a
href="#chapter-158-java-sockets-..................................................................................................................................-843"><u>Chapter
158: Java Sockets
..................................................................................................................................
843</u></a></p>
<p><a
href="#chapter-159-ftp-file-transfer-protocol-....................................................................................................-846"><u>Chapter
159: FTP (File Transfer Protocol)
....................................................................................................
846</u></a></p>
<p><a
href="#chapter-160-using-other-scripting-languages-in-java-.......................................................................-851"><u>Chapter
160: Using Other Scripting Languages in Java
.......................................................................
851</u></a></p>
<p><a
href="#chapter-161-c-comparison-.............................................................................................................................-854"><u>Chapter
161: C++ Comparison
.............................................................................................................................
854</u></a></p>
<p><a href="#Chapter_162__Audio"><u>Chapter 162: Audio
....................................................................................................................................................
859</u></a></p>
<p><a
href="#chapter-163-java-print-service-........................................................................................................................-863"><u>Chapter
163: Java Print Service
........................................................................................................................
863</u></a></p>
<p><a
href="#chapter-164-completablefuture-.....................................................................................................................-868"><u>Chapter
164: CompletableFuture
.....................................................................................................................
868</u></a></p>
<p><a
href="#chapter-165-runtime-commands-....................................................................................................................-869"><u>Chapter
165: Runtime Commands
....................................................................................................................
869</u></a></p>
<p><a href="#Chapter_166__Unit_Testing"><u>Chapter 166: Unit Testing
......................................................................................................................................
870</u></a></p>
<p><a
href="#chapter-167-asserting-...........................................................................................................................................-873"><u>Chapter
167: Asserting
...........................................................................................................................................
873</u></a></p>
<p><a
href="#chapter-168-multi-release-jar-files-.............................................................................................................-874"><u>Chapter
168: Multi-Release JAR Files
.............................................................................................................
874</u></a></p>
<p><a
href="#chapter-169-just-in-time-jit-compiler-......................................................................................................-877"><u>Chapter
169: Just in Time (JIT) compiler
......................................................................................................
877</u></a></p>
<p><a href="#Chapter_170__Bytecode_Modificati"><u>Chapter 170: Bytecode
Modification
...............................................................................................................
879</u></a></p>
<p><a
href="#chapter-171-disassembling-and-decompiling-............................................................................................-885"><u>Chapter
171: Disassembling and Decompiling
............................................................................................
885</u></a></p>
<p><a
href="#chapter-172-jmx-......................................................................................................................................................-892"><u>Chapter
172: JMX
......................................................................................................................................................
892</u></a></p>
<p><a
href="#chapter-173-java-virtual-machine-jvm-....................................................................................................-896"><u>Chapter
173: Java Virtual Machine (JVM)
....................................................................................................
896</u></a></p>
<p><a href="#Chapter_174__XJC"><u>Chapter 174: XJC
.......................................................................................................................................................
897</u></a></p>
<p><a
href="#chapter-175-jvm-flags-.........................................................................................................................................-900"><u>Chapter
175: JVM Flags
.........................................................................................................................................
900</u></a></p>
<p><a
href="#chapter-176-jvm-tool-interface-......................................................................................................................-903"><u>Chapter
176: JVM Tool Interface
......................................................................................................................
903</u></a></p>
<p><a href="#Chapter_177__Java_Memory_Managem"><u>Chapter 177: Java
Memory Management
....................................................................................................
907</u></a></p>
<p><a
href="#chapter-178-java-performance-tuning-.......................................................................................................-913"><u>Chapter
178: Java Performance Tuning
.......................................................................................................
913</u></a></p>
<p><a href="#Chapter_179__Benchmarks"><u>Chapter 179: Benchmarks
.....................................................................................................................................
916</u></a></p>
<p><a
href="#chapter-180-fileupload-to-aws-.......................................................................................................................-919"><u>Chapter
180: FileUpload to AWS
.......................................................................................................................
919</u></a></p>
<p><a href="#Chapter_181__AppDynamics_and_TIB"><u>Chapter 181:
AppDynamics and TIBCO BusinessWorks Instrumentation for Easy</u></a></p>
<p><a href="#Chapter_1__Getting_started_with"><u>Chapter 1: Getting
started with Java</u></a></p>
<p><a href="#Chapter_2__Type_Conversion"><u>Chapter 2: Type
Conversion</u></a></p>
<p><a href="#Chapter_3__Getters_and_Setters"><u>Chapter 3: Getters and
Setters</u></a></p>
<p><a href="#Chapter_4__Reference_Data_Types"><u>Chapter 4: Reference
Data Types</u></a></p>
<p><a href="#Chapter_5__Java_Compiler____java"><u>Chapter 5: Java
Compiler - 'javac'</u></a></p>
<p><a href="#Chapter_6__Documenting_Java_Code"><u>Chapter 6: Documenting
Java Code</u></a></p>
<p><a href="#Chapter_7__Command_line_Argument"><u>Chapter 7: Command
line Argument</u></a></p>
<p><a href="#Chapter_8__The_Java_Command____j"><u>Chapter 8: The Java
Command - 'java' and</u></a></p>
<p><a href="#Chapter_9__Literals"><u>Chapter 9: Literals</u></a></p>
<p><a href="#Chapter_10__Primitive_Data_Types_1"><u>Chapter 10:
Primitive Data Types</u></a></p>
<p><a href="#Chapter_11__Strings_1"><u>Chapter 11: Strings</u></a></p>
<p><a href="#Chapter_12__StringBu_er_1"><u>Chapter 12:
StringBuer</u></a></p>
<p><a href="#Chapter_13__StringBuilder_1"><u>Chapter 13:
StringBuilder</u></a></p>
<p><a href="#Chapter_14__String_Tokenizer_1"><u>Chapter 14: String
Tokenizer</u></a></p>
<p><a href="#Chapter_15__Splitting_a_string_i_1"><u>Chapter 15:
Splitting a string into fixed</u></a></p>
<p><a href="#Chapter_16__Date_Class_1"><u>Chapter 16: Date
Class</u></a></p>
<p><a href="#Chapter_17__Dates_and_Time__java_1"><u>Chapter 17: Dates
and Time (java.time.*)</u></a></p>
<p><a href="#Chapter_18__LocalTime_1"><u>Chapter 18:
LocalTime</u></a></p>
<p><a href="#Chapter_19__BigDecimal_1"><u>Chapter 19:
BigDecimal</u></a></p>
<p><a href="#Chapter_20__BigInteger_1"><u>Chapter 20:
BigInteger</u></a></p>
<p><a href="#Chapter_21__NumberFormat_1"><u>Chapter 21:
NumberFormat</u></a></p>
<p><a href="#Chapter_22__Bit_Manipulation_1"><u>Chapter 22: Bit
Manipulation</u></a></p>
<p><a href="#Chapter_23__Arrays_1"><u>Chapter 23: Arrays</u></a></p>
<p><a href="#Chapter_24__Collections_1"><u>Chapter 24:
Collections</u></a></p>
<p><a href="#Chapter_25__Lists_1"><u>Chapter 25: Lists</u></a></p>
<p><a href="#Chapter_26__Sets_1"><u>Chapter 26: Sets</u></a></p>
<p><a href="#Chapter_27__List_vs_Set_1"><u>Chapter 27: List vs
Set</u></a></p>
<p><a href="#Chapter_28__Maps_1"><u>Chapter 28: Maps</u></a></p>
<p><a href="#Chapter_29__LinkedHashMap_1"><u>Chapter 29:
LinkedHashMap</u></a></p>
<p><a href="#Chapter_30__WeakHashMap_1"><u>Chapter 30:
WeakHashMap</u></a></p>
<p><a href="#Chapter_31__SortedMap_1"><u>Chapter 31:
SortedMap</u></a></p>
<p><a href="#Chapter_32__TreeMap_and_TreeSet_1"><u>Chapter 32: TreeMap
and TreeSet</u></a></p>
<p><a href="#Chapter_33__Queues_and_Deques_1"><u>Chapter 33: Queues and
Deques</u></a></p>
<p><a href="#Chapter_34__Dequeue_Interface_1"><u>Chapter 34: Dequeue
Interface</u></a></p>
<p><a href="#Chapter_35__Enums_1"><u>Chapter 35: Enums</u></a></p>
<p><a href="#Chapter_36__Enum_Map_1"><u>Chapter 36: Enum Map</u></a></p>
<p><a href="#Chapter_37__EnumSet_class_1"><u>Chapter 37: EnumSet
class</u></a></p>
<p><a href="#Chapter_38__Enum_starting_with_n_1"><u>Chapter 38: Enum
starting with number</u></a></p>
<p><a href="#Chapter_39__Hashtable_1"><u>Chapter 39:
Hashtable</u></a></p>
<p><a href="#Chapter_40__Operators_1"><u>Chapter 40:
Operators</u></a></p>
<p><a href="#Chapter_41__Constructors_1"><u>Chapter 41:
Constructors</u></a></p>
<p><a href="#Chapter_42__Object_Class_Methods_1"><u>Chapter 42: Object
Class Methods and</u></a></p>
<p><a href="#Chapter_43__Annotations_1"><u>Chapter 43:
Annotations</u></a></p>
<p><a href="#Chapter_44__Immutable_Class_1"><u>Chapter 44: Immutable
Class</u></a></p>
<p><a href="#Chapter_45__Immutable_Objects_1"><u>Chapter 45: Immutable
Objects</u></a></p>
<p><a href="#Chapter_46__Visibility__controll_1"><u>Chapter 46:
Visibility (controlling access to</u></a></p>
<p><a href="#Chapter_47__Generics_1"><u>Chapter 47: Generics</u></a></p>
<p><a href="#Chapter_48__Classes_and_Objects_1"><u>Chapter 48: Classes
and Objects</u></a></p>
<p><a href="#Chapter_49__Local_Inner_Class_1"><u>Chapter 49: Local Inner
Class</u></a></p>
<p><a href="#Chapter_50__Nested_and_Inner_Cla_1"><u>Chapter 50: Nested
and Inner Classes</u></a></p>
<p><a href="#Chapter_51__The_java_util_Object_1"><u>Chapter 51: The
java.util.Objects Class</u></a></p>
<p><a href="#Chapter_52__Default_Methods_1"><u>Chapter 52: Default
Methods</u></a></p>
<p><a href="#Chapter_53__Packages_1"><u>Chapter 53: Packages</u></a></p>
<p><a href="#Chapter_54__Inheritance_1"><u>Chapter 54:
Inheritance</u></a></p>
<p><a href="#Chapter_55__Reference_Types_1"><u>Chapter 55: Reference
Types</u></a></p>
<p><a href="#Chapter_56__Console_I_O_1"><u>Chapter 56: Console
I/O</u></a></p>
<p><a href="#Chapter_57__Streams_1"><u>Chapter 57: Streams</u></a></p>
<p><a href="#Chapter_58__InputStreams_and"><u>Chapter 58: InputStreams
and</u></a></p>
<p><a href="#Chapter_59__Readers_and_Writers_1"><u>Chapter 59: Readers
and Writers</u></a></p>
<p><a href="#Chapter_60__Preferences_1"><u>Chapter 60:
Preferences</u></a></p>
<p><a href="#Chapter_61__Collection_Factory_M_1"><u>Chapter 61:
Collection Factory Methods</u></a></p>
<p><a href="#Chapter_62__Alternative_Collecti_1"><u>Chapter 62:
Alternative Collections</u></a></p>
<p><a href="#Chapter_63__Concurrent_Collectio_1"><u>Chapter 63:
Concurrent Collections</u></a></p>
<p><a href="#Chapter_64__Choosing_Collections_1"><u>Chapter 64: Choosing
Collections</u></a></p>
<p><a href="#Chapter_65__super_keyword_1"><u>Chapter 65: super
keyword</u></a></p>
<p><a href="#Chapter_66__Serialization_1"><u>Chapter 66:
Serialization</u></a></p>
<p><a href="#Chapter_67__Optional_1"><u>Chapter 67: Optional</u></a></p>
<p><a href="#Chapter_68__Object_References_1"><u>Chapter 68: Object
References</u></a></p>
<p><a href="#Chapter_69__Exceptions_and_excep_1"><u>Chapter 69:
Exceptions and exception</u></a></p>
<p><a href="#Chapter_70__Calendar_and_its_Sub_1"><u>Chapter 70: Calendar
and its Subclasses</u></a></p>
<p><a href="#Chapter_71__Using_the_static_key_1"><u>Chapter 71: Using
the static keyword</u></a></p>
<p><a href="#Chapter_72__Properties_Class_1"><u>Chapter 72: Properties
Class</u></a></p>
<p><a href="#Chapter_73__Lambda_Expressions_1"><u>Chapter 73: Lambda
Expressions</u></a></p>
<p><a href="#Chapter_74__Basic_Control_Struct_1"><u>Chapter 74: Basic
Control Structures</u></a></p>
<p><a href="#Chapter_75__Bu_eredWriter_1"><u>Chapter 75:
BueredWriter</u></a></p>
<p><a href="#Chapter_76__New_File_I_O_1"><u>Chapter 76: New File
I/O</u></a></p>
<p><a href="#Chapter_77__File_I_O_1"><u>Chapter 77: File I/O</u></a></p>
<p><a href="#Chapter_78__Scanner_1"><u>Chapter 78: Scanner</u></a></p>
<p><a href="#Chapter_79__Interfaces_1"><u>Chapter 79:
Interfaces</u></a></p>
<p><a href="#Chapter_80__Regular_Expressions_1"><u>Chapter 80: Regular
Expressions</u></a></p>
<p><a href="#Chapter_81__Comparable_and_Compa_1"><u>Chapter 81:
Comparable and Comparator</u></a></p>
<p><a href="#Chapter_82__Java_Floating_Point_1"><u>Chapter 82: Java
Floating Point</u></a></p>
<p><a href="#Chapter_83__Currency_and_Money_1"><u>Chapter 83: Currency
and Money</u></a></p>
<p><a href="#Chapter_84__Object_Cloning_1"><u>Chapter 84: Object
Cloning</u></a></p>
<p><a href="#Chapter_85__Recursion_1"><u>Chapter 85:
Recursion</u></a></p>
<p><a href="#Chapter_86__Converting_to_and_fr_1"><u>Chapter 86:
Converting to and from</u></a></p>
<p><a href="#Chapter_87__Random_Number_Genera_1"><u>Chapter 87: Random
Number Generation</u></a></p>
<p><a href="#Chapter_88__Singletons_1"><u>Chapter 88:
Singletons</u></a></p>
<p><a href="#Chapter_89__Autoboxing_1"><u>Chapter 89:
Autoboxing</u></a></p>
<p><a href="#Chapter_90__2D_Graphics_in_Java_1"><u>Chapter 90: 2D
Graphics in Java</u></a></p>
<p><a href="#Chapter_91__JAXB_1"><u>Chapter 91: JAXB</u></a></p>
<p><a href="#Chapter_92__Class___Java_Reflect_1"><u>Chapter 92: Class -
Java Reflection</u></a></p>
<p><a href="#Chapter_93__Networking_1"><u>Chapter 93:
Networking</u></a></p>
<p><a href="#Chapter_94__NIO___Networking_1"><u>Chapter 94: NIO -
Networking</u></a></p>
<p><a href="#Chapter_95__HttpURLConnection_1"><u>Chapter 95:
HttpURLConnection</u></a></p>
<p><a href="#Chapter_96__JAX_WS_1"><u>Chapter 96: JAX-WS</u></a></p>
<p><a href="#Chapter_97__Nashorn_JavaScript_e_1"><u>Chapter 97: Nashorn
JavaScript engine</u></a></p>
<p><a href="#Chapter_98__Java_Native_Interfac_1"><u>Chapter 98: Java
Native Interface</u></a></p>
<p><a href="#Chapter_99__Functional_Interface_1"><u>Chapter 99:
Functional Interfaces</u></a></p>
<p><a href="#Chapter_100__Fluent_Interface_1"><u>Chapter 100: Fluent
Interface</u></a></p>
<p><a href="#Chapter_101__Remote_Method_Invoc_1"><u>Chapter 101: Remote
Method Invocation</u></a></p>
<p><a href="#Chapter_102__Iterator_and_Iterab_1"><u>Chapter 102:
Iterator and Iterable</u></a></p>
<p><a href="#Chapter_103__Reflection_API_1"><u>Chapter 103: Reflection
API</u></a></p>
<p><a href="#Chapter_104__ByteBu_er_1"><u>Chapter 104:
ByteBuer</u></a></p>
<p><a href="#Chapter_105__Applets_1"><u>Chapter 105: Applets</u></a></p>
<p><a href="#Chapter_106__Expressions_1"><u>Chapter 106:
Expressions</u></a></p>
<p><a href="#Chapter_107__JSON_in_Java_1"><u>Chapter 107: JSON in
Java</u></a></p>
<p><a href="#Chapter_108__XML_Parsing_using_t_1"><u>Chapter 108: XML
Parsing using the JAXP</u></a></p>
<p><a href="#Chapter_109__XML_XPath_Evaluatio_1"><u>Chapter 109: XML
XPath Evaluation</u></a></p>
<p><a href="#Chapter_110__XOM___XML_Object_Mo_1"><u>Chapter 110: XOM -
XML Object Model</u></a></p>
<p><a href="#Chapter_111__Polymorphism_1"><u>Chapter 111:
Polymorphism</u></a></p>
<p><a href="#Chapter_112__Encapsulation_1"><u>Chapter 112:
Encapsulation</u></a></p>
<p><a href="#Chapter_113__Java_Agents_1"><u>Chapter 113: Java
Agents</u></a></p>
<p><a href="#Chapter_114__Varargs__Variable_A_1"><u>Chapter 114: Varargs
(Variable Argument)</u></a></p>
<p><a href="#Chapter_115__Logging__java_util_1"><u>Chapter 115: Logging
(java.util.logging)</u></a></p>
<p><a href="#Chapter_116__log4j___log4j2_1"><u>Chapter 116: log4j /
log4j2</u></a></p>
<p><a href="#Chapter_117__Oracle_O_cial_Code_1"><u>Chapter 117: Oracle
Ocial Code Standard</u></a></p>
<p><a href="#Chapter_118__Character_encoding_1"><u>Chapter 118:
Character encoding</u></a></p>
<p><a href="#Chapter_119__Apache_Commons_Lang_1"><u>Chapter 119: Apache
Commons Lang</u></a></p>
<p><a href="#Chapter_120__Localization_and"><u>Chapter 120: Localization
and</u></a></p>
<p><a href="#Chapter_121__Parallel_programmin_1"><u>Chapter 121:
Parallel programming with</u></a></p>
<p><a href="#Chapter_122__Non_Access_Modifier_1"><u>Chapter 122:
Non-Access Modifiers</u></a></p>
<p><a href="#Chapter_123__Process_1"><u>Chapter 123: Process</u></a></p>
<p><a href="#Chapter_124__Java_Native_Access_1"><u>Chapter 124: Java
Native Access</u></a></p>
<p><a href="#Chapter_125__Modules_1"><u>Chapter 125: Modules</u></a></p>
<p><a href="#Chapter_126__Concurrent_Programm_1"><u>Chapter 126:
Concurrent Programming</u></a></p>
<p><a href="#Chapter_127__Executor__ExecutorS_1"><u>Chapter 127:
Executor, ExecutorService</u></a></p>
<p><a href="#Chapter_128__ThreadLocal_1"><u>Chapter 128:
ThreadLocal</u></a></p>
<p><a href="#Chapter_129__Using_ThreadPoolExe_1"><u>Chapter 129: Using
ThreadPoolExecutor in</u></a></p>
<p><a href="#Chapter_130__Common_Java_Pitfall_1"><u>Chapter 130: Common
Java Pitfalls</u></a></p>
<p><a href="#Chapter_131__Java_Pitfalls___Exc_1"><u>Chapter 131: Java
Pitfalls - Exception usage</u></a></p>
<p><a href="#Chapter_132__Java_Pitfalls___Lan_1"><u>Chapter 132: Java
Pitfalls - Language</u></a></p>
<p><a href="#Chapter_133__Java_Pitfalls___Thr_1"><u>Chapter 133: Java
Pitfalls - Threads and</u></a></p>
<p><a href="#Chapter_134__Java_Pitfalls___Nul_1"><u>Chapter 134: Java
Pitfalls - Nulls and</u></a></p>
<p><a href="#Chapter_135__Java_Pitfalls___Per_1"><u>Chapter 135: Java
Pitfalls - Performance</u></a></p>
<p><a href="#Chapter_136__ServiceLoader_1"><u>Chapter 136:
ServiceLoader</u></a></p>
<p><a href="#Chapter_137__Classloaders_1"><u>Chapter 137:
Classloaders</u></a></p>
<p><a href="#Chapter_138__Creating_Images"><u>Chapter 138: Creating
Images</u></a></p>
<p><a href="#Chapter_139__Atomic_Types_1"><u>Chapter 139: Atomic
Types</u></a></p>
<p><a href="#Chapter_140__RSA_Encryption_1"><u>Chapter 140: RSA
Encryption</u></a></p>
<p><a href="#Chapter_141__Secure_objects_1"><u>Chapter 141: Secure
objects</u></a></p>
<p><a href="#Chapter_142__Security___Cryptogr_1"><u>Chapter 142:
Security &amp; Cryptography</u></a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1"><u>Chapter 143:
Security &amp; Cryptography</u></a></p>
<p><a href="#Chapter_144__SecurityManager_1"><u>Chapter 144:
SecurityManager</u></a></p>
<p><a href="#Chapter_145__JNDI_1"><u>Chapter 145: JNDI</u></a></p>
<p><a href="#Chapter_146__sun_misc_Unsafe_1"><u>Chapter 146:
sun.misc.Unsafe</u></a></p>
<p><a href="#Chapter_147__Java_Memory_Model_1"><u>Chapter 147: Java
Memory Model</u></a></p>
<p><a href="#Chapter_148__Java_deployment_1"><u>Chapter 148: Java
deployment</u></a></p>
<p><a href="#Chapter_149__Java_plugin_system_1"><u>Chapter 149: Java
plugin system</u></a></p>
<p><a href="#Chapter_150__JavaBean_1"><u>Chapter 150:
JavaBean</u></a></p>
<p><a href="#Chapter_151__Java_SE_7_Features_1"><u>Chapter 151: Java SE
7 Features</u></a></p>
<p><a href="#Chapter_152__Java_SE_8_Features_1"><u>Chapter 152: Java SE
8 Features</u></a></p>
<p><a href="#Chapter_153__Dynamic_Method_Disp_1"><u>Chapter 153: Dynamic
Method Dispatch</u></a></p>
<p><a href="#Chapter_154__Generating_Java_Cod_1"><u>Chapter 154:
Generating Java Code</u></a></p>
<p><a href="#Chapter_155__JShell_1"><u>Chapter 155: JShell</u></a></p>
<p><a href="#Chapter_156__Stack_Walking_API_1"><u>Chapter 156:
Stack-Walking API</u></a></p>
<p><a href="#Chapter_157__Sockets_1"><u>Chapter 157: Sockets</u></a></p>
<p><a href="#Chapter_158__Java_Sockets_1"><u>Chapter 158: Java
Sockets</u></a></p>
<p><a href="#Chapter_159__FTP__File_Transfer_1"><u>Chapter 159: FTP
(File Transfer Protocol)</u></a></p>
<p><a href="#Chapter_160__Using_Other_Scripti_1"><u>Chapter 160: Using
Other Scripting</u></a></p>
<p><a href="#Chapter_161__C___Comparison_1"><u>Chapter 161: C++
Comparison</u></a></p>
<p><a href="#Chapter_162__Audio_1"><u>Chapter 162: Audio</u></a></p>
<p><a href="#Chapter_163__Java_Print_Service_1"><u>Chapter 163: Java
Print Service</u></a></p>
<p><a href="#Chapter_164__CompletableFuture_1"><u>Chapter 164:
CompletableFuture</u></a></p>
<p><a href="#Chapter_165__Runtime_Commands_1"><u>Chapter 165: Runtime
Commands</u></a></p>
<p><a href="#Chapter_166__Unit_Testing_1"><u>Chapter 166: Unit
Testing</u></a></p>
<p><a href="#Chapter_167__Asserting_1"><u>Chapter 167:
Asserting</u></a></p>
<p><a href="#Chapter_168__Multi_Release_JAR_F_1"><u>Chapter 168:
Multi-Release JAR Files</u></a></p>
<p><a href="#Chapter_169__Just_in_Time__JIT_1"><u>Chapter 169: Just in
Time (JIT) compiler</u></a></p>
<p><a href="#Chapter_170__Bytecode_Modificati_1"><u>Chapter 170:
Bytecode Modification</u></a></p>
<p><a href="#Chapter_171__Disassembling_and"><u>Chapter 171:
Disassembling and</u></a></p>
<p><a href="#Chapter_172__JMX_1"><u>Chapter 172: JMX</u></a></p>
<p><a href="#Chapter_173__Java_Virtual_Machin_1"><u>Chapter 173: Java
Virtual Machine (JVM)</u></a></p>
<p><a href="#Chapter_174__XJC_1"><u>Chapter 174: XJC</u></a></p>
<p><a href="#Chapter_175__JVM_Flags_1"><u>Chapter 175: JVM
Flags</u></a></p>
<p><a href="#Chapter_176__JVM_Tool_Interface_1"><u>Chapter 176: JVM Tool
Interface</u></a></p>
<p><a href="#Chapter_177__Java_Memory_Managem_1"><u>Chapter 177: Java
Memory Management</u></a></p>
<p><a href="#Chapter_178__Java_Performance_Tu_1"><u>Chapter 178: Java
Performance Tuning</u></a></p>
<p><a href="#Chapter_179__Benchmarks_1"><u>Chapter 179:
Benchmarks</u></a></p>
<p><a href="#Chapter_180__FileUpload_to_AWS_1"><u>Chapter 180:
FileUpload to AWS</u></a></p>
<p><a href="#Chapter_181__AppDynamics_and_TIB_1"><u>Chapter 181:
AppDynamics and TIBCO</u></a></p>
<p>Notes for Professionals Java Java <strong>Notes for
Professionals</strong>®</p>
<p><img src="media/index-1_1.jpeg" style="width:6.5in;height:4.02778in"
alt="index-1_1.jpg" /></p>
<p>900+ pages</p>
<p>of professional hints and tricks</p>
<p><a href="https://goalkicker.com">GoalKicker.com</a> Disclaimer</p>
<p>This is an unocial free book created for educational purposes and
is</p>
<p><a href="https://goalkicker.com">Free Programming Books</a> not
aliated with ocial Java® group(s) or company(s).</p>
<p>All trademarks and registered trademarks are</p>
<p>the property of their respective owners</p>
<p>Contents</p>
<p><a href="#About"><strong>About</strong></a>
...................................................................................................................................................................................
<a href="#About">1</a></p>
<p><a href="#Chapter_1__Getting_started_with"><strong>Chapter 1: Getting
started with Java Language</strong></a>
..........................................................................................
<a href="#Chapter_1__Getting_started_with">2</a></p>
<p><a href="#Chapter_1__Getting_started_with">Section 1.1: Creating Your
First Java Program</a>
...........................................................................................................
<a href="#Chapter_1__Getting_started_with">2</a></p>
<p><a href="#Chapter_2__Type_Conversion"><strong>Chapter 2: Type
Conversion</strong></a>
....................................................................................................................................
<a href="#Chapter_2__Type_Conversion">8</a></p>
<p><a href="#Chapter_2__Type_Conversion">Section 2.1: Numeric primitive
casting</a>
.........................................................................................................................
<a href="#Chapter_2__Type_Conversion">8</a></p>
<p><a href="#Chapter_2__Type_Conversion">Section 2.2: Basic Numeric
Promotion</a>
........................................................................................................................
<a href="#Chapter_2__Type_Conversion">8</a></p>
<p><a href="#Chapter_2__Type_Conversion">Section 2.3: Non-numeric
primitive casting</a>
................................................................................................................
<a href="#Chapter_2__Type_Conversion">8</a></p>
<p><a href="#char_char1______char_____65">Section 2.4: Object
casting</a>
...........................................................................................................................................
<a href="#char_char1______char_____65">9</a></p>
<p><a href="#char_char1______char_____65">Section 2.5: Testing if an
object can be cast using instanceof
.................................................................................
9</a></p>
<p><a href="#Chapter_3__Getters_and_Setters"><strong>Chapter 3: Getters
and Setters</strong></a>
...........................................................................................................................
<a href="#Chapter_3__Getters_and_Setters">10</a></p>
<p><a href="#Chapter_3__Getters_and_Setters">Section 3.1: Using a setter
or getter to implement a constraint</a>
.............................................................................
<a href="#Chapter_3__Getters_and_Setters">10</a></p>
<p><a href="#Chapter_3__Getters_and_Setters">Section 3.2: Why Use
Getters and Setters?</a>
..............................................................................................................
<a href="#Chapter_3__Getters_and_Setters">10</a></p>
<p><a href="#public_int_count___0">Section 3.3: Adding Getters and
Setters</a>
...................................................................................................................
<a href="#public_int_count___0">11</a></p>
<p><a href="#Chapter_4__Reference_Data_Types"><strong>Chapter 4:
Reference Data Types</strong></a>
....................................................................................................................
<a href="#Chapter_4__Reference_Data_Types">13</a></p>
<p><a href="#Chapter_4__Reference_Data_Types">Section 4.1:
Dereferencing</a>
..........................................................................................................................................
<a href="#Chapter_4__Reference_Data_Types">13</a></p>
<p><a href="#Chapter_4__Reference_Data_Types">Section 4.2: Instantiating
a reference type</a>
...............................................................................................................
<a href="#Chapter_4__Reference_Data_Types">13</a></p>
<p><a href="#Chapter_5__Java_Compiler____java"><strong>Chapter 5: Java
Compiler - 'javac'</strong></a>
....................................................................................................................
<a href="#Chapter_5__Java_Compiler____java">14</a></p>
<p><a href="#Chapter_5__Java_Compiler____java">Section 5.1: The 'javac'
command - getting started</a>
................................................................................................
<a href="#Chapter_5__Java_Compiler____java">14</a></p>
<p><a href="#com_example_HelloWorld_java">Section 5.2: Compiling for a
dierent version of Java</a>
............................................................................................
<a href="#com_example_HelloWorld_java">16</a></p>
<p><a href="#Chapter_6__Documenting_Java_Code"><strong>Chapter 6:
Documenting Java Code</strong></a>
.................................................................................................................
<a href="#Chapter_6__Documenting_Java_Code">18</a></p>
<p><a href="#Chapter_6__Documenting_Java_Code">Section 6.1: Building
Javadocs From the Command Line</a>
.......................................................................................
<a href="#Chapter_6__Documenting_Java_Code">18</a></p>
<p><a href="#Chapter_6__Documenting_Java_Code">Section 6.2: Class
Documentation</a>
.............................................................................................................................
<a href="#Chapter_6__Documenting_Java_Code">18</a></p>
<p><a href="#__You_can_also_have_custom_tags">Section 6.3: Method
Documentation</a>
.........................................................................................................................
<a href="#__You_can_also_have_custom_tags">19</a></p>
<p><a href="#Section_6_4__Package_Documentati">Section 6.4: Package
Documentation</a>
.......................................................................................................................
<a href="#Section_6_4__Package_Documentati">20</a></p>
<p><a href="#Section_6_4__Package_Documentati">Section 6.5: Links</a>
.........................................................................................................................................................
<a href="#Section_6_4__Package_Documentati">20</a></p>
<p><a href="#With_the__see_tag_you_can_add_el">Section 6.6: Code
snippets inside documentation</a>
...................................................................................................
<a href="#With_the__see_tag_you_can_add_el">21</a></p>
<p><a href="#___public_SingleTestRule_singleT">Section 6.7: Field
Documentation</a>
..............................................................................................................................
<a href="#___public_SingleTestRule_singleT">22</a></p>
<p><a href="#___public_SingleTestRule_singleT">Section 6.8: Inline Code
Documentation</a>
...................................................................................................................
<a href="#___public_SingleTestRule_singleT">22</a></p>
<p><a href="#Chapter_7__Command_line_Argument"><strong>Chapter 7:
Command line Argument Processing</strong></a>
.......................................................................................
<a href="#Chapter_7__Command_line_Argument">24</a></p>
<p><a href="#Chapter_7__Command_line_Argument">Section 7.1: Argument
processing using GWT ToolBase</a>
.........................................................................................
<a href="#Chapter_7__Command_line_Argument">24</a></p>
<p><a href="#Chapter_7__Command_line_Argument">Section 7.2: Processing
arguments by hand</a>
............................................................................................................
<a href="#Chapter_7__Command_line_Argument">24</a></p>
<p><a href="#Chapter_8__The_Java_Command____j"><strong>Chapter 8: The
Java Command - 'java' and 'javaw'</strong></a>
.................................................................................
<a href="#Chapter_8__The_Java_Command____j">27</a></p>
<p><a href="#Chapter_8__The_Java_Command____j">Section 8.1: Entry point
classes</a>
..................................................................................................................................
<a href="#Chapter_8__The_Java_Command____j">27</a></p>
<p><a href="#Chapter_8__The_Java_Command____j">Section 8.2:
Troubleshooting the 'java' command</a>
..................................................................................................
<a href="#Chapter_8__The_Java_Command____j">27</a></p>
<p><a href="#as_the_classname">Section 8.3: Running a Java application
with library dependencies</a>
..................................................................... <a
href="#as_the_classname">29</a></p>
<p><a href="#__java__cp_myApp_jar_lib_library">Section 8.4: Java
Options</a>
...........................................................................................................................................
<a href="#__java__cp_myApp_jar_lib_library">30</a></p>
<p><a href="#Enabling_and_disabling_assertion">Section 8.5: Spaces and
other special characters in arguments</a>
...........................................................................
<a href="#Enabling_and_disabling_assertion">31</a></p>
<p><a href="#The_cmd_exe_shell_apparently_has">Section 8.6: Running an
executable JAR file</a>
............................................................................................................
<a href="#The_cmd_exe_shell_apparently_has">33</a></p>
<p><a href="#The_cmd_exe_shell_apparently_has">Section 8.7: Running a
Java applications via a "main" class</a>
.................................................................................
<a href="#The_cmd_exe_shell_apparently_has">33</a></p>
<p><a href="#Chapter_9__Literals"><strong>Chapter 9:
Literals</strong></a>
......................................................................................................................................................
<a href="#Chapter_9__Literals">35</a></p>
<p><a href="#Chapter_9__Literals">Section 9.1: Using underscore to
improve readability</a>
.............................................................................................
<a href="#Chapter_9__Literals">35</a></p>
<p><a href="#Chapter_9__Literals">Section 9.2: Hexadecimal, Octal and
Binary literals</a>
................................................................................................
<a href="#Chapter_9__Literals">35</a></p>
<p><a href="#int_hex___0x6E________________0x">Section 9.3: Boolean
literals</a>
.......................................................................................................................................
<a href="#int_hex___0x6E________________0x">36</a></p>
<p><a href="#int_hex___0x6E________________0x">Section 9.4: String
literals</a>
...........................................................................................................................................
<a href="#int_hex___0x6E________________0x">36</a></p>
<p><a href="#When_class_file_containing_strin">Section 9.5: The Null
literal</a>
.........................................................................................................................................
<a href="#When_class_file_containing_strin">37</a></p>
<p><a href="#When_class_file_containing_strin">Section 9.6: Escape
sequences in literals</a>
..................................................................................................................
<a href="#When_class_file_containing_strin">37</a></p>
<p><a href="#Reference">Section 9.7: Character literals</a>
....................................................................................................................................
<a href="#Reference">38</a></p>
<p><a href="#Reference">Section 9.8: Decimal Integer literals</a>
..........................................................................................................................
<a href="#Reference">38</a></p>
<p><a href="#1___________The_decimal_number_o">Section 9.9:
Floating-point literals</a>
.............................................................................................................................
<a href="#1___________The_decimal_number_o">39</a></p>
<h1
id="chapter-10-primitive-data-types-.......................................................................................................................-42"><a
href="#Chapter_10__Primitive_Data_Types_1">Chapter 10: Primitive Data
Types</a>
.......................................................................................................................
<a href="#Chapter_10__Primitive_Data_Types_1">42</a></h1>
<p><a href="#Chapter_10__Primitive_Data_Types_1">Section 10.1: The char
primitive</a>
..................................................................................................................................
<a href="#Chapter_10__Primitive_Data_Types_1">42</a></p>
<p><a href="#Chapter_10__Primitive_Data_Types_1">Section 10.2: Primitive
Types Cheatsheet</a>
.................................................................................................................
<a href="#Chapter_10__Primitive_Data_Types_1">42</a></p>
<p><a href="#boolean_n_a___________________fa">Section 10.3: The float
primitive</a>
.................................................................................................................................
<a href="#boolean_n_a___________________fa">43</a></p>
<p><a href="#___multiplication">Section 10.4: The int primitive</a>
.....................................................................................................................................
<a href="#___multiplication">44</a></p>
<p><a href="#__2147483648____4294967296__2147">Section 10.5: Converting
Primitives</a>
............................................................................................................................
<a href="#__2147483648____4294967296__2147">45</a></p>
<p><a href="#__2147483648____4294967296__2147">Section 10.6: Memory
consumption of primitives vs. boxed primitives</a>
.................................................................. <a
href="#__2147483648____4294967296__2147">45</a></p>
<p><a href="#char______Char_______2_bytes___1">Section 10.7: The double
primitive</a>
.............................................................................................................................
<a href="#char______Char_______2_bytes___1">46</a></p>
<p><a href="#Note__Double_POSITIVE_INFINITY">Section 10.8: The long
primitive</a>
.................................................................................................................................
<a href="#Note__Double_POSITIVE_INFINITY">47</a></p>
<p><a href="#System_out_println_val3____val4">Section 10.9: The boolean
primitive</a>
...........................................................................................................................
<a href="#System_out_println_val3____val4">48</a></p>
<p><a href="#System_out_println_val3____val4">Section 10.10: The byte
primitive</a>
................................................................................................................................
<a href="#System_out_println_val3____val4">48</a></p>
<p><a href="#byte_defaultByte________defaultB">Section 10.11: Negative
value representation</a>
............................................................................................................
<a href="#byte_defaultByte________defaultB">49</a></p>
<p><a href="#Section_10_12__The_short_primiti">Section 10.12: The short
primitive</a>
...............................................................................................................................
<a href="#Section_10_12__The_short_primiti">50</a></p>
<h1
id="chapter-11-strings-......................................................................................................................................................-51"><a
href="#Chapter_11__Strings_1">Chapter 11: Strings</a>
......................................................................................................................................................
<a href="#Chapter_11__Strings_1">51</a></h1>
<p><a href="#Chapter_11__Strings_1">Section 11.1: Comparing Strings</a>
..................................................................................................................................
<a href="#Chapter_11__Strings_1">51</a></p>
<p><a href="#Comparing_with_interned_Strings">Section 11.2: Changing the
case of characters within a String</a>
...............................................................................
<a href="#Comparing_with_interned_Strings">53</a></p>
<p><a href="#__else_if__d_____A_____d_____Z">Section 11.3: Finding a
String Within Another String</a>
.................................................................................................
<a href="#__else_if__d_____A_____d_____Z">55</a></p>
<p><a href="#Section_11_4__String_pool_and_he">Section 11.4: String pool
and heap storage</a>
...............................................................................................................
<a href="#Section_11_4__String_pool_and_he">56</a></p>
<p><a href="#When_we_use_double_quotes_to_cre">Section 11.5: Splitting
Strings</a>
.......................................................................................................................................
<a href="#When_we_use_double_quotes_to_cre">57</a></p>
<p><a href="#String_str____the_lazy_fox_jumpe">Section 11.6: Joining
Strings with a delimiter</a>
............................................................................................................
<a href="#String_str____the_lazy_fox_jumpe">59</a></p>
<p><a href="#To_join_a_stream_of_strings__you">Section 11.7: String
concatenation and StringBuilders</a>
.............................................................................................
<a href="#To_join_a_stream_of_strings__you">60</a></p>
<p><a href="#">Section 11.8: Substrings</a>
...............................................................................................................................................
<a href="#">61</a></p>
<p><a href="#the_piece_extends_until_the_end">Section 11.9: Platform
independent new line separator</a>
...........................................................................................
<a href="#the_piece_extends_until_the_end">62</a></p>
<p><a href="#the_piece_extends_until_the_end">Section 11.10: Reversing
Strings</a>
..................................................................................................................................
<a href="#the_piece_extends_until_the_end">62</a></p>
<p><a href="#String_code____code">Section 11.11: Adding toString()
method for custom objects</a>
....................................................................................
<a href="#String_code____code">63</a></p>
<p><a href="#public_String_toString">Section 11.12: Remove Whitespace
from the Beginning and End of a String</a>
........................................................ <a
href="#public_String_toString">64</a></p>
<p><a href="#public_String_toString">Section 11.13: Case insensitive
switch</a>
.........................................................................................................................
<a href="#public_String_toString">64</a></p>
<p><a href="#Care_must_be_taken_not_to_have_a">Section 11.14: Replacing
parts of Strings</a>
...................................................................................................................
<a href="#Care_must_be_taken_not_to_have_a">65</a></p>
<p><a href="#spiral_metallica_petallica_et_al">Section 11.15: Getting
the length of a String</a>
..............................................................................................................
<a href="#spiral_metallica_petallica_et_al">66</a></p>
<p><a href="#spiral_metallica_petallica_et_al">Section 11.16: Getting
the nth character in a String</a>
..................................................................................................
<a href="#spiral_metallica_petallica_et_al">66</a></p>
<p><a href="#spiral_metallica_petallica_et_al">Section 11.17: Counting
occurrences of a substring or character in a string</a>
......................................................... <a
href="#spiral_metallica_petallica_et_al">66</a></p>
<h1
id="chapter-12-stringbuer-.........................................................................................................................................-68"><a
href="#Chapter_12__StringBu_er_1">Chapter 12: StringBuer</a>
.........................................................................................................................................
<a href="#Chapter_12__StringBu_er_1">68</a></h1>
<p><a href="#Chapter_12__StringBu_er_1">Section 12.1: String Buer
class</a>
..................................................................................................................................
<a href="#Chapter_12__StringBu_er_1">68</a></p>
<h1
id="chapter-13-stringbuilder-........................................................................................................................................-69"><a
href="#Chapter_13__StringBuilder_1">Chapter 13: StringBuilder</a>
........................................................................................................................................
<a href="#Chapter_13__StringBuilder_1">69</a></h1>
<p><a href="#Chapter_13__StringBuilder_1">Section 13.1: Comparing
StringBuer, StringBuilder, Formatter and StringJoiner</a>
............................................... <a
href="#Chapter_13__StringBuilder_1">69</a></p>
<p><a href="#The_StringJoiner_class_is_not_id">Section 13.2: Repeat a
String n times</a>
........................................................................................................................
<a href="#The_StringJoiner_class_is_not_id">70</a></p>
<h1
id="chapter-14-string-tokenizer-................................................................................................................................-71"><a
href="#Chapter_14__String_Tokenizer_1">Chapter 14: String Tokenizer</a>
................................................................................................................................
<a href="#Chapter_14__String_Tokenizer_1">71</a></h1>
<p><a href="#Chapter_14__String_Tokenizer_1">Section 14.1:
StringTokenizer Split by space</a>
.............................................................................................................
<a href="#Chapter_14__String_Tokenizer_1">71</a></p>
<p><a href="#Chapter_14__String_Tokenizer_1">Section 14.2:
StringTokenizer Split by comma ','</a>
......................................................................................................
<a href="#Chapter_14__String_Tokenizer_1">71</a></p>
<h1
id="chapter-15-splitting-a-string-into-fixed-length-parts-...............................................................................-72"><a
href="#Chapter_15__Splitting_a_string_i_1">Chapter 15: Splitting a
string into fixed length parts</a>
...............................................................................
<a href="#Chapter_15__Splitting_a_string_i_1">72</a></h1>
<p><a href="#Chapter_15__Splitting_a_string_i_1">Section 15.1: Break a
string up into substrings all of a known length</a>
.................................................................... <a
href="#Chapter_15__Splitting_a_string_i_1">72</a></p>
<p><a href="#Chapter_15__Splitting_a_string_i_1">Section 15.2: Break a
string up into substrings all of variable length</a>
.................................................................... <a
href="#Chapter_15__Splitting_a_string_i_1">72</a></p>
<h1
id="chapter-16-date-class-.............................................................................................................................................-73"><a
href="#Chapter_16__Date_Class_1">Chapter 16: Date Class</a>
.............................................................................................................................................
<a href="#Chapter_16__Date_Class_1">73</a></h1>
<p><a href="#Chapter_16__Date_Class_1">Section 16.1: Convert
java.util.Date to java.sql.Date</a>
.................................................................................................
<a href="#Chapter_16__Date_Class_1">73</a></p>
<p><a href="#Chapter_16__Date_Class_1">Section 16.2: A basic date
output</a>
...............................................................................................................................
<a href="#Chapter_16__Date_Class_1">73</a></p>
<p><a href="#___define_the_format_to_use">Section 16.3: Java 8 LocalDate
and LocalDateTime objects</a>
..................................................................................
<a href="#___define_the_format_to_use">74</a></p>
<p><a href="#___Date_to_LocalDate">Section 16.4: Creating a Specific
Date</a>
.......................................................................................................................
<a href="#___Date_to_LocalDate">75</a></p>
<p><a href="#___Date_to_LocalDate">Section 16.5: Converting Date to a
certain String format</a>
.......................................................................................
<a href="#___Date_to_LocalDate">75</a></p>
<p><a href="#SimpleDateFormat_dateFormat___ne">Section 16.6:
LocalTime</a>
...............................................................................................................................................
<a href="#SimpleDateFormat_dateFormat___ne">76</a></p>
<p><a href="#SimpleDateFormat_dateFormat___ne">Section 16.7: Convert
formatted string representation of date to Date object</a>
.................................................... <a
href="#SimpleDateFormat_dateFormat___ne">76</a></p>
<p><a href="#SimpleDateFormat_objDf___new_Sim">Section 16.8: Creating
Date objects</a>
...........................................................................................................................
<a href="#SimpleDateFormat_objDf___new_Sim">77</a></p>
<p><a href="#SimpleDateFormat_objDf___new_Sim">Section 16.9: Comparing
Date objects</a>
......................................................................................................................
<a href="#SimpleDateFormat_objDf___new_Sim">77</a></p>
<p><a href="#isAfter_ChronoLocalDate_other">Section 16.10: Converting
String into Date</a>
................................................................................................................
<a href="#isAfter_ChronoLocalDate_other">80</a></p>
<p><a href="#isAfter_ChronoLocalDate_other">Section 16.11: Time Zones
and java.util.Date</a>
.............................................................................................................
<a href="#isAfter_ChronoLocalDate_other">80</a></p>
<h1
id="chapter-17-dates-and-time-java.time.-.......................................................................................................-82"><a
href="#Chapter_17__Dates_and_Time__java_1">Chapter 17: Dates and Time
(java.time.*)</a>
.......................................................................................................
<a href="#Chapter_17__Dates_and_Time__java_1">82</a></h1>
<p><a href="#Chapter_17__Dates_and_Time__java_1">Section 17.1: Calculate
Dierence between 2 LocalDates</a>
.......................................................................................
<a href="#Chapter_17__Dates_and_Time__java_1">82</a></p>
<p><a href="#Chapter_17__Dates_and_Time__java_1">Section 17.2: Date and
time</a>
........................................................................................................................................
<a href="#Chapter_17__Dates_and_Time__java_1">82</a></p>
<p><a href="#Chapter_17__Dates_and_Time__java_1">Section 17.3:
Operations on dates and times</a>
...........................................................................................................
<a href="#Chapter_17__Dates_and_Time__java_1">82</a></p>
<p><a href="#Chapter_17__Dates_and_Time__java_1">Section 17.4:
Instant</a>
.....................................................................................................................................................
<a href="#Chapter_17__Dates_and_Time__java_1">82</a></p>
<p><a href="#Instant_epoch2___Instant_parse">Section 17.5: Usage of
various classes of Date Time API</a>
........................................................................................
<a href="#Instant_epoch2___Instant_parse">83</a></p>
<p><a href="#__A_date_time_with_Time_zone_det">Section 17.6: Date Time
Formatting</a>
...........................................................................................................................
<a href="#__A_date_time_with_Time_zone_det">85</a></p>
<p><a href="#__A_date_time_with_Time_zone_det">Section 17.7: Simple Date
Manipulations</a>
...................................................................................................................
<a href="#__A_date_time_with_Time_zone_det">85</a></p>
<h1
id="chapter-18-localtime-..............................................................................................................................................-87"><a
href="#Chapter_18__LocalTime_1">Chapter 18: LocalTime</a>
..............................................................................................................................................
<a href="#Chapter_18__LocalTime_1">87</a></h1>
<p><a href="#Chapter_18__LocalTime_1">Section 18.1: Amount of time
between two LocalTime</a>
............................................................................................
<a href="#Chapter_18__LocalTime_1">87</a></p>
<p><a href="#Section_18_2__Intro">Section 18.2: Intro</a>
........................................................................................................................................................
<a href="#Section_18_2__Intro">88</a></p>
<p><a href="#Section_18_2__Intro">Section 18.3: Time Modification</a>
..................................................................................................................................
<a href="#Section_18_2__Intro">88</a></p>
<p><a href="#Section_18_2__Intro">Section 18.4: Time Zones and their
time dierence</a>
.................................................................................................
<a href="#Section_18_2__Intro">88</a></p>
<h1
id="chapter-19-bigdecimal-............................................................................................................................................-90"><a
href="#Chapter_19__BigDecimal_1">Chapter 19: BigDecimal</a>
............................................................................................................................................
<a href="#Chapter_19__BigDecimal_1">90</a></h1>
<p><a href="#Chapter_19__BigDecimal_1">Section 19.1: Comparing
BigDecimals</a>
........................................................................................................................
<a href="#Chapter_19__BigDecimal_1">90</a></p>
<p><a href="#Chapter_19__BigDecimal_1">Section 19.2: Using BigDecimal
instead of float</a>
.......................................................................................................
<a href="#Chapter_19__BigDecimal_1">90</a></p>
<p><a href="#Operations_using_float">Section 19.3:
BigDecimal.valueOf()</a>
............................................................................................................................
<a href="#Operations_using_float">91</a></p>
<p><a href="#Operations_using_float">Section 19.4: Mathematical
operations with BigDecimal</a>
.........................................................................................
<a href="#Operations_using_float">91</a></p>
<p><a href="#BigDecimal_a___new_BigDecimal__5">Section 19.5:
Initialization of BigDecimals with value zero, one or ten</a>
................................................................... <a
href="#BigDecimal_a___new_BigDecimal__5">94</a></p>
<p><a href="#BigDecimal_a___new_BigDecimal__5">Section 19.6: BigDecimal
objects are immutable</a>
.....................................................................................................
<a href="#BigDecimal_a___new_BigDecimal__5">94</a></p>
<h1
id="chapter-20-biginteger-............................................................................................................................................-96"><a
href="#Chapter_20__BigInteger_1">Chapter 20: BigInteger</a>
............................................................................................................................................
<a href="#Chapter_20__BigInteger_1">96</a></h1>
<p><a href="#Chapter_20__BigInteger_1">Section 20.1: Initialization</a>
............................................................................................................................................
<a href="#Chapter_20__BigInteger_1">96</a></p>
<p><a href="#BigInteger_ZERO____value_of__0">Section 20.2: BigInteger
Mathematical Operations Examples</a>
...............................................................................
<a href="#BigInteger_ZERO____value_of__0">97</a></p>
<p><a href="#BigInteger_value1___new_BigInteg">Section 20.3: Comparing
BigIntegers</a>
........................................................................................................................
<a href="#BigInteger_value1___new_BigInteg">99</a></p>
<p><a href="#0__When_both_are_equal">Section 20.4: Binary Logic
Operations on BigInteger</a>
...........................................................................................
<a href="#0__When_both_are_equal">100</a></p>
<p><a href="#val1_shiftRight_1________the_arg">Section 20.5: Generating
random BigIntegers</a>
.......................................................................................................
<a href="#val1_shiftRight_1________the_arg">101</a></p>
<p><span id="Chapter_21__NumberFormat" class="anchor"></span><a
href="#Chapter_21__NumberFormat_1">Chapter 21: NumberFormat
.................................................................................................................................
103</a></p>
<p><a href="#Chapter_21__NumberFormat_1">Section 21.1: NumberFormat</a>
....................................................................................................................................
<a href="#Chapter_21__NumberFormat_1">103</a></p>
<h1
id="chapter-22-bit-manipulation-..............................................................................................................................-104"><a
href="#Chapter_22__Bit_Manipulation_1">Chapter 22: Bit Manipulation</a>
..............................................................................................................................
<a href="#Chapter_22__Bit_Manipulation_1">104</a></h1>
<p><a href="#Chapter_22__Bit_Manipulation_1">Section 22.1: Checking,
setting, clearing, and toggling individual bits. Using long as bit
mask</a> ........................ <a
href="#Chapter_22__Bit_Manipulation_1">104</a></p>
<p><a href="#Chapter_22__Bit_Manipulation_1">Section 22.2:
java.util.BitSet class</a>
............................................................................................................................
<a href="#Chapter_22__Bit_Manipulation_1">104</a></p>
<p><a href="#bitSet_set_3__false_______0__2">Section 22.3: Checking if a
number is a power of 2</a>
..............................................................................................
<a href="#bitSet_set_3__false_______0__2">105</a></p>
<p><a href="#0001_0000_0000__READ">Section 22.4: Signed vs unsigned
shift</a>
....................................................................................................................
<a href="#0001_0000_0000__READ">107</a></p>
<p><a href="#0001_0000_0000__READ">Section 22.5: Expressing the power of
2</a>
.................................................................................................................
<a href="#0001_0000_0000__READ">107</a></p>
<p><a href="#instead_of_using_hexadecimal_or">Section 22.6: Packing /
unpacking values as bit fragments</a>
................................................................................
<a href="#instead_of_using_hexadecimal_or">108</a></p>
<h1
id="chapter-23-arrays-...................................................................................................................................................-109"><a
href="#Chapter_23__Arrays_1">Chapter 23: Arrays</a>
...................................................................................................................................................
<a href="#Chapter_23__Arrays_1">109</a></h1>
<p><a href="#Chapter_23__Arrays_1">Section 23.1: Creating and
Initializing Arrays</a>
.........................................................................................................
<a href="#Chapter_23__Arrays_1">109</a></p>
<p><a href="#___Prints__1_2_3">Section 23.2: Creating a List from an
Array</a>
...........................................................................................................
<a href="#___Prints__1_2_3">115</a></p>
<p><a href="#Section_23_3__Creating_an_Array">Section 23.3: Creating an
Array from a Collection</a>
................................................................................................
<a href="#Section_23_3__Creating_an_Array">117</a></p>
<p><a href="#Section_23_3__Creating_an_Array">Section 23.4:
Multidimensional and Jagged Arrays</a>
..............................................................................................
<a href="#Section_23_3__Creating_an_Array">117</a></p>
<p><a href="#Jagged_array_literal_intializati">Section 23.5:
ArrayIndexOutOfBoundsException</a>
..................................................................................................
<a href="#Jagged_array_literal_intializati">119</a></p>
<p><a href="#be_useful_to_find_the_cause_of_t">Section 23.6: Array
Covariance</a>
...............................................................................................................................
<a href="#be_useful_to_find_the_cause_of_t">120</a></p>
<p><a href="#Section_23_7__Arrays_to_Stream">Section 23.7: Arrays to
Stream</a>
................................................................................................................................
<a href="#Section_23_7__Arrays_to_Stream">121</a></p>
<p><a href="#Section_23_7__Arrays_to_Stream">Section 23.8: Iterating
over arrays</a>
..........................................................................................................................
<a href="#Section_23_7__Arrays_to_Stream">121</a></p>
<p><a href="#_2">Section 23.9: Arrays to a String</a>
...............................................................................................................................
<a href="#_2">123</a></p>
<p><a href="#int_____arr">Section 23.10: Sorting arrays
....................................................................................................................................
124</a></p>
<p><a href="#Section_23_11__Getting_the_Lengt">Section 23.11: Getting
the Length of an Array</a>
........................................................................................................
<a href="#Section_23_11__Getting_the_Lengt">126</a></p>
<p><a href="#Section_23_11__Getting_the_Lengt">Section 23.12: Finding an
element in an array</a>
.......................................................................................................
<a href="#Section_23_11__Getting_the_Lengt">126</a></p>
<p><a href="#Using_a_Arrays_asList__for_non_p">Section 23.13: How do you
change the size of an array?</a>
.....................................................................................
<a href="#Using_a_Arrays_asList__for_non_p">127</a></p>
<p><a href="#listOfCities_1_____London">Section 23.14: Converting arrays
between primitives and boxed types</a>
.............................................................. <a
href="#listOfCities_1_____London">128</a></p>
<p><a href="#Version_____Java_SE_8">Section 23.15: Remove an element
from an array</a>
................................................................................................
<a href="#Version_____Java_SE_8">129</a></p>
<p><a href="#___Copy_the_elements_at_the_left">Section 23.16: Comparing
arrays for equality</a>
........................................................................................................
<a href="#___Copy_the_elements_at_the_left">130</a></p>
<p><a href="#___Copy_the_elements_at_the_left">Section 23.17: Copying
arrays</a>
..................................................................................................................................
<a href="#___Copy_the_elements_at_the_left">130</a></p>
<p><a href="#Note_that_using_this_option_with">Section 23.18: Casting
Arrays</a>
...................................................................................................................................
<a href="#Note_that_using_this_option_with">131</a></p>
<h1
id="chapter-24-collections-.........................................................................................................................................-133"><a
href="#Chapter_24__Collections_1">Chapter 24: Collections</a>
.........................................................................................................................................
<a href="#Chapter_24__Collections_1">133</a></h1>
<p><a href="#Chapter_24__Collections_1">Section 24.1: Removing items
from a List within a loop</a>
........................................................................................
<a href="#Chapter_24__Collections_1">133</a></p>
<p><a href="#if___Apple__equals_fruits_get_i">Section 24.2: Constructing
collections from existing data</a>
....................................................................................
<a href="#if___Apple__equals_fruits_get_i">135</a></p>
<p><a href="#Using_Stream">Section 24.3: Declaring an ArrayList and
adding objects</a>
.....................................................................................
<a href="#Using_Stream">137</a></p>
<p><a href="#Using_Stream">Section 24.4: Iterating over Collections</a>
..................................................................................................................
<a href="#Using_Stream">137</a></p>
<p><a href="#_4">Section 24.5: Immutable Empty Collections</a>
...........................................................................................................
<a href="#_4">139</a></p>
<p><a href="#_4">Section 24.6: Sub Collections</a>
...................................................................................................................................
<a href="#_4">139</a></p>
<p><a href="#Set_set1___set_subSet_fromIndex">Section 24.7: Unmodifiable
Collection
.....................................................................................................................
140</a></p>
<p><a href="#output">Section 24.8: Pitfall: concurrent modification
exceptions</a>
.....................................................................................
<a href="#output">141</a></p>
<p><a href="#output">Section 24.9: Removing matching items from Lists
using Iterator</a>
......................................................................
<a href="#output">141</a></p>
<p><a href="#private_static_void_removeNames">Section 24.10: Join
lists</a>
.............................................................................................................................................
<a href="#private_static_void_removeNames">142</a></p>
<p><a href="#private_static_void_removeNames">Section 24.11: Creating
your own Iterable structure for use with Iterator or for-each loop</a>
.............................. <a
href="#private_static_void_removeNames">142</a></p>
<p><a href="#while__current_next____null">Section 24.12: Collections and
Primitive Values</a>
.....................................................................................................
<a href="#while__current_next____null">144</a></p>
<h1
id="chapter-25-lists-.......................................................................................................................................................-146"><a
href="#Chapter_25__Lists_1">Chapter 25: Lists</a>
.......................................................................................................................................................
<a href="#Chapter_25__Lists_1">146</a></h1>
<p><a href="#Chapter_25__Lists_1">Section 25.1: Sorting a generic
list</a>
...........................................................................................................................
<a href="#Chapter_25__Lists_1">146</a></p>
<p><a href="#_Aside__many_standard_Java_class">Section 25.2: Convert a
list of integers to a list of strings
.....................................................................................
147</a></p>
<p><a href="#_Aside__many_standard_Java_class">Section 25.3: Classes
implementing List - Pros and Cons
.....................................................................................
147</a></p>
<p><a href="#Vector">Section 25.4: Finding common elements between 2
lists</a>
.....................................................................................
<a href="#Vector">150</a></p>
<p><a href="#Vector">Section 25.5: In-place replacement of a List
element</a>
...........................................................................................
<a href="#Vector">150</a></p>
<p><a href="#strings_set_pos___Goodbye_cruel">Section 25.6: Making a
list unmodifiable</a>
................................................................................................................
<a href="#strings_set_pos___Goodbye_cruel">151</a></p>
<p><a href="#strings_set_pos___Goodbye_cruel">Section 25.7: Moving
objects around in the list</a>
......................................................................................................
<a href="#strings_set_pos___Goodbye_cruel">151</a></p>
<p><a href="#Section_25_8__Creating__Adding_a">Section 25.8: Creating,
Adding and Removing element from an ArrayList</a>
........................................................ <a
href="#Section_25_8__Creating__Adding_a">152</a></p>
<p><a href="#Section_25_8__Creating__Adding_a">Section 25.9: Creating a
List
.....................................................................................................................................
152</a></p>
<p><a href="#both_equal_null">Section 25.10: Positional Access
Operations</a>
..........................................................................................................
<a href="#both_equal_null">153</a></p>
<p><a href="#the_index_of_the_first_occurrenc">Section 25.11: Iterating
over elements in a list</a>
........................................................................................................
<a href="#the_index_of_the_first_occurrenc">155</a></p>
<p><a href="#the_index_of_the_first_occurrenc">Section 25.12: Removing
elements from list B that are present in the list A
....................................................... 155</a></p>
<h1
id="chapter-26-sets-........................................................................................................................................................-157"><a
href="#Chapter_26__Sets_1">Chapter 26: Sets</a>
........................................................................................................................................................
<a href="#Chapter_26__Sets_1">157</a></h1>
<p><a href="#Chapter_26__Sets_1">Section 26.1: Initialization</a>
..........................................................................................................................................
<a href="#Chapter_26__Sets_1">157</a></p>
<p><a href="#Chapter_26__Sets_1">Section 26.2: Basics of Set
........................................................................................................................................
157</a></p>
<p><a href="#Elements_can_be_added_to_a_set_u">Section 26.3: Types and
Usage of Sets
...................................................................................................................
158</a></p>
<p><a href="#set_add__Banana">Section 26.4: Create a list from an
existing Set
......................................................................................................
159</a></p>
<p><a href="#set_add__Banana">Section 26.5: Eliminating duplicates using
Set</a>
.......................................................................................................
<a href="#set_add__Banana">159</a></p>
<p><a href="#Collection_noDuplicates___new_Ha">Section 26.6: Declaring a
HashSet with values</a>
......................................................................................................
<a href="#Collection_noDuplicates___new_Ha">160</a></p>
<h1
id="chapter-27-list-vs-set-...........................................................................................................................................-161"><a
href="#Chapter_27__List_vs_Set_1">Chapter 27: List vs Set</a>
...........................................................................................................................................
<a href="#Chapter_27__List_vs_Set_1">161</a></h1>
<p><a href="#Chapter_27__List_vs_Set_1">Section 27.1: List vs Set</a>
.............................................................................................................................................
<a href="#Chapter_27__List_vs_Set_1">161</a></p>
<h1
id="chapter-28-maps-......................................................................................................................................................-162"><a
href="#Chapter_28__Maps_1">Chapter 28: Maps</a>
......................................................................................................................................................
<a href="#Chapter_28__Maps_1">162</a></h1>
<p><a href="#Chapter_28__Maps_1">Section 28.1: Iterating Map Entries
Eciently
.........................................................................................................
162</a></p>
<p><a href="#test1_UsingWhileAndMapEntry">Section 28.2: Usage of
HashMap</a>
............................................................................................................................
<a href="#test1_UsingWhileAndMapEntry">164</a></p>
<p><a href="#KeyType_and_ValueType_must_be_va">Section 28.3: Using
Default Methods of Map from Java 8</a>
...................................................................................
<a href="#KeyType_and_ValueType_must_be_va">165</a></p>
<p><a href="#map_computeIfAbsent__kelly___k">Section 28.4: Iterating
through the contents of a Map</a>
.........................................................................................
<a href="#map_computeIfAbsent__kelly___k">167</a></p>
<p><a href="#for__String_key___repMap_keySet">Section 28.5: Merging,
combine and composing Maps</a>
........................................................................................
<a href="#for__String_key___repMap_keySet">168</a></p>
<p><a href="#numbers_put__Three___3">Section 28.6: Add multiple items
..............................................................................................................................
169</a></p>
<p><a href="#Section_28_7__Creating_and_Initi">Section 28.7: Creating
and Initializing Maps</a>
...........................................................................................................
<a href="#Section_28_7__Creating_and_Initi">171</a></p>
<p><a href="#Way_6">Section 28.8: Check if key exists</a>
..............................................................................................................................
<a href="#Way_6">172</a></p>
<p><a href="#Way_6">Section 28.9: Add an element</a>
..................................................................................................................................
<a href="#Way_6">172</a></p>
<p><a href="#Map_map___new_HashMap">Section 28.10: Clear the map
....................................................................................................................................
173</a></p>
<p><a href="#Map_map___new_HashMap">Section 28.11: Use custom object as
key</a>
.................................................................................................................
<a href="#Map_map___new_HashMap">173</a></p>
<h1
id="chapter-29-linkedhashmap-...............................................................................................................................-175"><a
href="#Chapter_29__LinkedHashMap_1">Chapter 29: LinkedHashMap</a>
...............................................................................................................................
<a href="#Chapter_29__LinkedHashMap_1">175</a></h1>
<p><a href="#Chapter_29__LinkedHashMap_1">Section 29.1: Java
LinkedHashMap class</a>
...............................................................................................................
<a href="#Chapter_29__LinkedHashMap_1">175</a></p>
<h1
id="chapter-30-weakhashmap-.................................................................................................................................-176"><a
href="#Chapter_30__WeakHashMap_1">Chapter 30: WeakHashMap</a>
.................................................................................................................................
<a href="#Chapter_30__WeakHashMap_1">176</a></h1>
<p><a href="#Chapter_30__WeakHashMap_1">Section 30.1: Concepts of
WeakHashmap</a>
..............................................................................................................
<a href="#Chapter_30__WeakHashMap_1">176</a></p>
<h1
id="chapter-31-sortedmap-..........................................................................................................................................-177"><a
href="#Chapter_31__SortedMap_1">Chapter 31: SortedMap</a>
..........................................................................................................................................
<a href="#Chapter_31__SortedMap_1">177</a></h1>
<p><a href="#Chapter_31__SortedMap_1">Section 31.1: Introduction to
sorted Map</a>
.................................................................................................................
<a href="#Chapter_31__SortedMap_1">177</a></p>
<h1
id="chapter-32-treemap-and-treeset-..................................................................................................................-178"><a
href="#Chapter_32__TreeMap_and_TreeSet_1">Chapter 32: TreeMap and
TreeSet</a>
..................................................................................................................
<a href="#Chapter_32__TreeMap_and_TreeSet_1">178</a></h1>
<p><a href="#Chapter_32__TreeMap_and_TreeSet_1">Section 32.1: TreeMap of
a simple Java type</a>
........................................................................................................
<a href="#Chapter_32__TreeMap_and_TreeSet_1">178</a></p>
<p><a href="#Chapter_32__TreeMap_and_TreeSet_1">Section 32.2: TreeSet of
a simple Java Type</a>
.........................................................................................................
<a href="#Chapter_32__TreeMap_and_TreeSet_1">178</a></p>
<p><a href="#treeSet_add_12">Section 32.3: TreeMap/TreeSet of a custom
Java type</a>
.......................................................................................
<a href="#treeSet_add_12">179</a></p>
<p><a href="#public_class_Person_implements_C">Section 32.4: TreeMap and
TreeSet Thread Safety</a>
..............................................................................................
<a href="#public_class_Person_implements_C">180</a></p>
<h1
id="chapter-33-queues-and-deques-......................................................................................................................-182"><a
href="#Chapter_33__Queues_and_Deques_1">Chapter 33: Queues and
Deques</a>
......................................................................................................................
<a href="#Chapter_33__Queues_and_Deques_1">182</a></h1>
<p><a href="#Chapter_33__Queues_and_Deques_1">Section 33.1: The usage of
the PriorityQueue</a>
.........................................................................................................
<a href="#Chapter_33__Queues_and_Deques_1">182</a></p>
<p><a href="#Chapter_33__Queues_and_Deques_1">Section 33.2: Deque
...................................................................................................................................................
182</a></p>
<p><a href="#Deque_dequeA___new_LinkedList">Section 33.3: Stacks</a>
...................................................................................................................................................
<a href="#Deque_dequeA___new_LinkedList">183</a></p>
<p><a href="#st_pop">Section 33.4: BlockingQueue</a>
....................................................................................................................................
<a href="#st_pop">184</a></p>
<p><a href="#capacity">Section 33.5: LinkedList as a FIFO Queue</a>
...............................................................................................................
<a href="#capacity">185</a></p>
<p><a href="#second_element">Section 33.6: Queue Interface</a>
..................................................................................................................................
<a href="#second_element">186</a></p>
<h1
id="chapter-34-dequeue-interface-........................................................................................................................-187"><a
href="#Chapter_34__Dequeue_Interface_1">Chapter 34: Dequeue
Interface</a>
........................................................................................................................
<a href="#Chapter_34__Dequeue_Interface_1">187</a></h1>
<p><a href="#Chapter_34__Dequeue_Interface_1">Section 34.1: Adding
Elements to Deque</a>
.................................................................................................................
<a href="#Chapter_34__Dequeue_Interface_1">187</a></p>
<p><a href="#Chapter_34__Dequeue_Interface_1">Section 34.2: Removing
Elements from Deque
......................................................................................................
187</a></p>
<p><a href="#Chapter_34__Dequeue_Interface_1">Section 34.3: Retrieving
Element without Removing</a>
.............................................................................................
<a href="#Chapter_34__Dequeue_Interface_1">187</a></p>
<p><a href="#Chapter_34__Dequeue_Interface_1">Section 34.4: Iterating
through Deque</a>
....................................................................................................................
<a href="#Chapter_34__Dequeue_Interface_1">187</a></p>
<h1
id="chapter-35-enums-...................................................................................................................................................-189"><a
href="#Chapter_35__Enums_1">Chapter 35: Enums</a>
...................................................................................................................................................
<a href="#Chapter_35__Enums_1">189</a></h1>
<p><a href="#Chapter_35__Enums_1">Section 35.1: Declaring and using a
basic enum</a>
....................................................................................................
<a href="#Chapter_35__Enums_1">189</a></p>
<p><a href="#count">Section 35.2: Enums with constructors</a>
...................................................................................................................
<a href="#count">192</a></p>
<p><a href="#private_Coin_int_value">Section 35.3: Enums with Abstract
Methods</a>
...........................................................................................................
<a href="#private_Coin_int_value">193</a></p>
<p><a href="#public_boolean_execute_Player_pl">Section 35.4: Implements
Interface</a>
.........................................................................................................................
<a href="#public_boolean_execute_Player_pl">194</a></p>
<p><a href="#enum_Acceptor_implements_Predica">Section 35.5: Implement
Singleton pattern with a single-element enum
............................................................ 195</a></p>
<p><a href="#Section_35_6__Using_methods_and">Section 35.6: Using
methods and static blocks</a>
......................................................................................................
<a href="#Section_35_6__Using_methods_and">196</a></p>
<p><a href="#Section_35_6__Using_methods_and">Section 35.7: Zero
instance enum</a>
...........................................................................................................................
<a href="#Section_35_6__Using_methods_and">196</a></p>
<p><a href="#public_static_int_clamp_int_min">Section 35.8: Enum as a
bounded type parameter</a>
...............................................................................................
<a href="#public_static_int_clamp_int_min">197</a></p>
<p><a href="#public_static_int_clamp_int_min">Section 35.9: Documenting
enums</a>
..........................................................................................................................
<a href="#public_static_int_clamp_int_min">197</a></p>
<p><a href="#_6">Section 35.10: Enum constant specific body
...........................................................................................................
198</a></p>
<p><a href="#public_String_getSex">Section 35.11: Getting the values of
an enum</a>
.........................................................................................................
<a href="#public_String_getSex">199</a></p>
<p><a href="#public_enum_Day">Section 35.12: Enum Polymorphism
Pattern</a>
...........................................................................................................
<a href="#public_enum_Day">200</a></p>
<p><a href="#Section_35_13__Compare_and_Conta">Section 35.13: Compare
and Contains for Enum values
........................................................................................
201</a></p>
<p><a href="#Section_35_13__Compare_and_Conta">Section 35.14: Get enum
constant by name</a>
...........................................................................................................
<a href="#Section_35_13__Compare_and_Conta">201</a></p>
<p><a href="#enum_DayOfWeek">Section 35.15: Enum with properties
(fields)</a>
...........................................................................................................
<a href="#enum_DayOfWeek">202</a></p>
<p><a href="#System_out_println_dime_isGreate">Section 35.16: Convert
enum to String</a>
....................................................................................................................
<a href="#System_out_println_dime_isGreate">203</a></p>
<p><a href="#System_out_println_dime_isGreate">Section 35.17: Enums with
static fields
.....................................................................................................................
203</a></p>
<h1
id="chapter-36-enum-map-...........................................................................................................................................-205"><a
href="#Chapter_36__Enum_Map_1">Chapter 36: Enum Map</a>
...........................................................................................................................................
<a href="#Chapter_36__Enum_Map_1">205</a></h1>
<p><a href="#Chapter_36__Enum_Map_1">Section 36.1: Enum Map Book
Example</a>
..................................................................................................................
<a href="#Chapter_36__Enum_Map_1">205</a></p>
<h1
id="chapter-37-enumset-class-..................................................................................................................................-206"><a
href="#Chapter_37__EnumSet_class_1">Chapter 37: EnumSet class</a>
..................................................................................................................................
<a href="#Chapter_37__EnumSet_class_1">206</a></h1>
<p><a href="#Chapter_37__EnumSet_class_1">Section 37.1: Enum Set
Example</a>
..............................................................................................................................
<a href="#Chapter_37__EnumSet_class_1">206</a></p>
<h1
id="chapter-38-enum-starting-with-number-......................................................................................................-207"><a
href="#Chapter_38__Enum_starting_with_n_1">Chapter 38: Enum starting
with number</a>
......................................................................................................
<a href="#Chapter_38__Enum_starting_with_n_1">207</a></h1>
<p><a href="#Chapter_38__Enum_starting_with_n_1">Section 38.1: Enum with
name at beginning</a>
...........................................................................................................
<a href="#Chapter_38__Enum_starting_with_n_1">207</a></p>
<h1
id="chapter-39-hashtable-...........................................................................................................................................-208"><a
href="#Chapter_39__Hashtable_1">Chapter 39: Hashtable</a>
...........................................................................................................................................
<a href="#Chapter_39__Hashtable_1">208</a></h1>
<p><a href="#Chapter_39__Hashtable_1">Section 39.1: Hashtable</a>
.............................................................................................................................................
<a href="#Chapter_39__Hashtable_1">208</a></p>
<h1
id="chapter-40-operators-..........................................................................................................................................-209"><a
href="#Chapter_40__Operators_1">Chapter 40: Operators</a>
..........................................................................................................................................
<a href="#Chapter_40__Operators_1">209</a></h1>
<p><a href="#Chapter_40__Operators_1">Section 40.1: The
Increment/Decrement Operators (++/--)</a>
................................................................................
<a href="#Chapter_40__Operators_1">209</a></p>
<p><a href="#Chapter_40__Operators_1">Section 40.2: The Conditional
Operator (? :)</a>
..........................................................................................................
<a href="#Chapter_40__Operators_1">209</a></p>
<p><a href="#10____a____a___19___b___5___b">Section 40.3: The Bitwise
and Logical Operators (~, &amp;, |, ^)</a>
..................................................................................
<a href="#10____a____a___19___b___5___b">211</a></p>
<p><a href="#The___operator_is_used_for__mask">Section 40.4: The String
Concatenation Operator (+)
...........................................................................................
212</a></p>
<p><a href="#tmp_append_s2____null____null">Section 40.5: The Arithmetic
Operators (+, -, *, /, %)</a>
.............................................................................................
<a href="#tmp_append_s2____null____null">214</a></p>
<p><a href="#Floating_point_remainder_can_pro">Section 40.6: The Shift
Operators (&lt;&lt;, &gt;&gt; and &gt;&gt;&gt;)</a>
...............................................................................................
<a href="#Floating_point_remainder_can_pro">216</a></p>
<p><a href="#are_all_binary_operators_with_th">Section 40.7: The
Instanceof Operator</a>
...................................................................................................................
<a href="#are_all_binary_operators_with_th">217</a></p>
<p><a href="#__Object_reference_variable___in">Section 40.8: The
Assignment Operators (=, +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;= ,
&gt;&gt;&gt;=, &amp;=, |= and ^=)</a> ............................. <a
href="#__Object_reference_variable___in">218</a></p>
<p><a href="#8">Section 40.9: The conditional-and and conditional-or
Operators ( &amp;&amp; and || )</a>
.................................................. <a
href="#8">220</a></p>
<p><a href="#_7">Section 40.10: The Relational Operators (&lt;, &lt;=,
&gt;, &gt;=)</a>
............................................................................................
<a href="#_7">221</a></p>
<p><a href="#you_would_expect__For_example__i">Section 40.11: The
Equality Operators (==, !=)</a>
.........................................................................................................
<a href="#you_would_expect__For_example__i">222</a></p>
<p><a href="#String_s1____We_are_equal">Section 40.12: The Lambda
operator ( -&gt; )
.............................................................................................................
224</a></p>
<h1
id="chapter-41-constructors-.....................................................................................................................................-225"><a
href="#Chapter_41__Constructors_1">Chapter 41: Constructors</a>
.....................................................................................................................................
<a href="#Chapter_41__Constructors_1">225</a></h1>
<p><a href="#Chapter_41__Constructors_1">Section 41.1: Default
Constructor</a>
.............................................................................................................................
<a href="#Chapter_41__Constructors_1">225</a></p>
<p><a href="#TestClass_testClass___new_TestCl">Section 41.2: Call parent
constructor
.......................................................................................................................
226</a></p>
<p><a href="#If_you_don_t_call_any_super">Section 41.3: Constructor with
Arguments</a>
..............................................................................................................
<a href="#If_you_don_t_call_any_super">227</a></p>
<h1
id="chapter-42-object-class-methods-and-constructor-.............................................................................-229"><a
href="#Chapter_42__Object_Class_Methods_1">Chapter 42: Object Class
Methods and Constructor</a>
.............................................................................
<a href="#Chapter_42__Object_Class_Methods_1">229</a></h1>
<p><a href="#Chapter_42__Object_Class_Methods_1">Section 42.1:
hashCode() method</a>
............................................................................................................................
<a href="#Chapter_42__Object_Class_Methods_1">229</a></p>
<p><a href="#_Override_1">Section 42.2: toString() method
...............................................................................................................................
231</a></p>
<p><a href="#same_thing">Section 42.3: equals() method</a>
.................................................................................................................................
<a href="#same_thing">232</a></p>
<p><a href="#Foo_f____Foo__obj">Section 42.4: wait() and notify()
methods</a>
..............................................................................................................
<a href="#Foo_f____Foo__obj">234</a></p>
<p><a href="#System_out_println__Finished">Section 42.5: getClass()
method
..............................................................................................................................
236</a></p>
<p><a href="#System_out_println_specificUser">Section 42.6: clone()
method</a>
...................................................................................................................................
<a href="#System_out_println_specificUser">237</a></p>
<p><a href="#result_y___this_y_clone">Section 42.7: Object constructor
..............................................................................................................................
238</a></p>
<p><a href="#public_MyClass_int_size">Section 42.8: finalize()
method</a>
................................................................................................................................
<a href="#public_MyClass_int_size">239</a></p>
<h1
id="chapter-43-annotations-......................................................................................................................................-241"><a
href="#Chapter_43__Annotations_1">Chapter 43: Annotations</a>
......................................................................................................................................
<a href="#Chapter_43__Annotations_1">241</a></h1>
<p><a href="#Chapter_43__Annotations_1">Section 43.1: The idea behind
Annotations</a>
.............................................................................................................
<a href="#Chapter_43__Annotations_1">241</a></p>
<p><a href="#Chapter_43__Annotations_1">Section 43.2: Defining
annotation types</a>
.................................................................................................................
<a href="#Chapter_43__Annotations_1">241</a></p>
<p><a href="#annotation_in_the_documentation">Section 43.3: Runtime
annotation checks via reflection</a>
.......................................................................................
<a href="#annotation_in_the_documentation">243</a></p>
<p><a href="#annotation_in_the_documentation">Section 43.4: Built-in
annotations</a>
............................................................................................................................
<a href="#annotation_in_the_documentation">243</a></p>
<p><a href="#This_annotation_can_be_applied_t">Section 43.5: Compile
time processing using annotation processor</a>
................................................................... <a
href="#This_annotation_can_be_applied_t">246</a></p>
<p><a href="#page_274">Section 43.6: Repeating Annotations</a>
......................................................................................................................
<a href="#page_274">250</a></p>
<p><a href="#container">Section 43.7: Inherited Annotations</a>
.........................................................................................................................
<a href="#container">251</a></p>
<p><a href="#System_out_println_new_B___getCl">Section 43.8: Getting
Annotation values at run-time
.............................................................................................
252</a></p>
<p><a href="#AnnotationExample_example___new">Section 43.9: Annotations
for 'this' and receiver parameters</a>
..............................................................................
<a href="#AnnotationExample_example___new">253</a></p>
<p><a href="#public_void_close">Section 43.10: Add multiple annotation
values
.......................................................................................................
254</a></p>
<h1
id="chapter-44-immutable-class-............................................................................................................................-255"><a
href="#Chapter_44__Immutable_Class_1">Chapter 44: Immutable Class</a>
............................................................................................................................
<a href="#Chapter_44__Immutable_Class_1">255</a></h1>
<p><a href="#Chapter_44__Immutable_Class_1">Section 44.1: Example
without mutable refs</a>
...........................................................................................................
<a href="#Chapter_44__Immutable_Class_1">255</a></p>
<p><a href="#Chapter_44__Immutable_Class_1">Section 44.2: What is the
advantage of immutability?</a>
.........................................................................................
<a href="#Chapter_44__Immutable_Class_1">255</a></p>
<p><a href="#Chapter_44__Immutable_Class_1">Section 44.3: Rules to
define immutable classes</a>
...................................................................................................
<a href="#Chapter_44__Immutable_Class_1">255</a></p>
<p><a href="#Section_44_4__Example_with_mutab">Section 44.4: Example
with mutable refs</a>
................................................................................................................
<a href="#Section_44_4__Example_with_mutab">256</a></p>
<h1
id="chapter-45-immutable-objects-.......................................................................................................................-257"><a
href="#Chapter_45__Immutable_Objects_1">Chapter 45: Immutable
Objects</a>
.......................................................................................................................
<a href="#Chapter_45__Immutable_Objects_1">257</a></h1>
<p><a href="#Chapter_45__Immutable_Objects_1">Section 45.1: Creating an
immutable version of a type using defensive copying</a>
.............................................. <a
href="#Chapter_45__Immutable_Objects_1">257</a></p>
<p><a href="#Chapter_45__Immutable_Objects_1">Section 45.2: The recipe
for an immutable class</a>
...................................................................................................
<a href="#Chapter_45__Immutable_Objects_1">257</a></p>
<p><a href="#public_String_getName">Section 45.3: Typical design flaws
which prevent a class from being immutable</a>
............................................. <a
href="#public_String_getName">258</a></p>
<p><span id="Chapter_46__Visibility__controll" class="anchor"></span><a
href="#Chapter_46__Visibility__controll_1">Chapter 46: Visibility
(controlling access to members of a class)</a>
................................................. <a
href="#Chapter_46__Visibility__controll_1">262</a></p>
<p><a href="#Chapter_46__Visibility__controll_1">Section 46.1: Private
Visibility</a>
...................................................................................................................................
<a href="#Chapter_46__Visibility__controll_1">262</a></p>
<p><a href="#Chapter_46__Visibility__controll_1">Section 46.2: Public
Visibility</a>
....................................................................................................................................
<a href="#Chapter_46__Visibility__controll_1">262</a></p>
<p><a href="#_11">Section 46.3: Package Visibility</a>
................................................................................................................................
<a href="#_11">263</a></p>
<p><a href="#_11">Section 46.4: Protected Visibility</a>
..............................................................................................................................
<a href="#_11">263</a></p>
<p><a href="#Note_that_this_modifier_only_wor">Section 46.5: Summary of
Class Member Access Modifiers</a>
.................................................................................
<a href="#Note_that_this_modifier_only_wor">264</a></p>
<p><a href="#Note_that_this_modifier_only_wor">Section 46.6: Interface
members</a>
.............................................................................................................................
<a href="#Note_that_this_modifier_only_wor">264</a></p>
<h1
id="chapter-47-generics-..............................................................................................................................................-265"><a
href="#Chapter_47__Generics_1">Chapter 47: Generics</a>
..............................................................................................................................................
<a href="#Chapter_47__Generics_1">265</a></h1>
<p><a href="#Chapter_47__Generics_1">Section 47.1: Creating a Generic
Class</a>
....................................................................................................................
<a href="#Chapter_47__Generics_1">265</a></p>
<p><a href="#Note_that_using_the_diamond_with">Section 47.2: Deciding
between `T`, `? super T`, and `? extends T`</a>
........................................................................
<a href="#Note_that_using_the_diamond_with">267</a></p>
<p><a href="#Producer_uses__Extends__and_Cons">Section 47.3: The Diamond
.......................................................................................................................................
269</a></p>
<p><a href="#Producer_uses__Extends__and_Cons">Section 47.4: Declaring a
Generic Method
..............................................................................................................
269</a></p>
<p><a href="#___The_type_parameter_T_is_scope">Section 47.5: Requiring
multiple upper bounds ("extends A &amp; B")</a>
.......................................................................
<a href="#___The_type_parameter_T_is_scope">270</a></p>
<p><a href="#___The_type_parameter_T_is_scope">Section 47.6: Obtain
class that satisfies generic parameter at runtime</a>
............................................................. <a
href="#___The_type_parameter_T_is_scope">270</a></p>
<p><a href="#thread_type_information_through">Section 47.7: Benefits of
Generic class and interface</a>
...........................................................................................
<a href="#thread_type_information_through">271</a></p>
<p><a href="#When_re_written_to_use_generics">Section 47.8:
Instantiating a generic type</a>
..............................................................................................................
<a href="#When_re_written_to_use_generics">272</a></p>
<p><a href="#When_re_written_to_use_generics">Section 47.9: Creating a
Bounded Generic Class</a>
...................................................................................................
<a href="#When_re_written_to_use_generics">272</a></p>
<p><a href="#_13">Section 47.10: Referring to the declared generic type
within its own declaration</a>
............................................. <a href="#_13">274</a></p>
<p><a href="#_14">Section 47.11: Binding generic parameter to more than
1 type</a>
............................................................................
<a href="#_14">275</a></p>
<p><a href="#public_void_test2__T_param">Section 47.12: Using Generics
to auto-cast
.............................................................................................................
276</a></p>
<p><a href="#public_void_test2__T_param">Section 47.13: Use of
instanceof with Generics</a>
......................................................................................................
<a href="#public_void_test2__T_param">276</a></p>
<p><a href="#Since__even_if_the_type_erasure">Section 47.14: Dierent
ways for implementing a Generic Interface (or extending a Generic
Class)</a> ............. <a
href="#Since__even_if_the_type_erasure">278</a></p>
<h1
id="chapter-48-classes-and-objects-.....................................................................................................................-280"><a
href="#Chapter_48__Classes_and_Objects_1">Chapter 48: Classes and
Objects</a>
.....................................................................................................................
<a href="#Chapter_48__Classes_and_Objects_1">280</a></h1>
<p><a href="#Chapter_48__Classes_and_Objects_1">Section 48.1:
Overloading Methods</a>
.........................................................................................................................
<a href="#Chapter_48__Classes_and_Objects_1">280</a></p>
<p><a href="#Section_48_2__Explaining_what_is">Section 48.2: Explaining
what is method overloading and overriding</a>
................................................................ <a
href="#Section_48_2__Explaining_what_is">281</a></p>
<p><a href="#_15">Section 48.3: Constructors
........................................................................................................................................
283</a></p>
<p><a href="#_16">Section 48.4: Initializing static final fields using a
static initializer
........................................................................
284</a></p>
<p><a href="#_17">Section 48.5: Basic Object Construction and Use</a>
..................................................................................................
<a href="#_17">285</a></p>
<p><a href="#are_thrown">Section 48.6: Simplest Possible Class</a>
......................................................................................................................
<a href="#are_thrown">287</a></p>
<p><a href="#are_thrown">Section 48.7: Object Member vs Static
Member</a>
....................................................................................................
<a href="#are_thrown">287</a></p>
<h1
id="chapter-49-local-inner-class-............................................................................................................................-289"><a
href="#Chapter_49__Local_Inner_Class_1">Chapter 49: Local Inner
Class</a>
............................................................................................................................
<a href="#Chapter_49__Local_Inner_Class_1">289</a></h1>
<p><a href="#Chapter_49__Local_Inner_Class_1">Section 49.1: Local Inner
Class</a>
.................................................................................................................................
<a href="#Chapter_49__Local_Inner_Class_1">289</a></p>
<h1
id="chapter-50-nested-and-inner-classes-..........................................................................................................-290"><a
href="#Chapter_50__Nested_and_Inner_Cla_1">Chapter 50: Nested and Inner
Classes</a>
..........................................................................................................
<a href="#Chapter_50__Nested_and_Inner_Cla_1">290</a></h1>
<p><a href="#Chapter_50__Nested_and_Inner_Cla_1">Section 50.1: A Simple
Stack Using a Nested Class</a>
...............................................................................................
<a href="#Chapter_50__Nested_and_Inner_Cla_1">290</a></p>
<p><a href="#Chapter_50__Nested_and_Inner_Cla_1">Section 50.2: Static vs
Non Static Nested Classes</a>
.................................................................................................
<a href="#Chapter_50__Nested_and_Inner_Cla_1">290</a></p>
<p><a href="#_18">Section 50.3: Access Modifiers for Inner Classes</a>
...................................................................................................
<a href="#_18">292</a></p>
<p><a href="#public_class_InnerClass">Section 50.4: Anonymous Inner
Classes</a>
.................................................................................................................
<a href="#public_class_InnerClass">293</a></p>
<p><a href="#Callable___For_example">Section 50.5: Create instance of
non-static inner class from outside</a>
................................................................. <a
href="#Callable___For_example">294</a></p>
<p><a href="#Note_the_usage_as_outer_new">Section 50.6: Method Local
Inner Classes</a>
..............................................................................................................
<a href="#Note_the_usage_as_outer_new">295</a></p>
<p><a href="#Note_the_usage_as_outer_new">Section 50.7: Accessing the
outer class from a non-static inner class
................................................................
295</a></p>
<h1
id="chapter-51-the-java.util.objects-class-.........................................................................................................-297"><a
href="#Chapter_51__The_java_util_Object_1">Chapter 51: The
java.util.Objects Class</a>
.........................................................................................................
<a href="#Chapter_51__The_java_util_Object_1">297</a></h1>
<p><a href="#Chapter_51__The_java_util_Object_1">Section 51.1: Basic use
for object null check</a>
...........................................................................................................
<a href="#Chapter_51__The_java_util_Object_1">297</a></p>
<p><a href="#Chapter_51__The_java_util_Object_1">Section 51.2:
Objects.nonNull() method reference use in stream api</a>
.................................................................. <a
href="#Chapter_51__The_java_util_Object_1">297</a></p>
<h1
id="chapter-52-default-methods-.............................................................................................................................-298"><a
href="#Chapter_52__Default_Methods_1">Chapter 52: Default Methods</a>
.............................................................................................................................
<a href="#Chapter_52__Default_Methods_1">298</a></h1>
<p><a href="#Chapter_52__Default_Methods_1">Section 52.1: Basic usage of
default methods
........................................................................................................
298</a></p>
<p><a href="#Chapter_52__Default_Methods_1">Section 52.2: Accessing
overridden default methods from implementing class</a>
............................................... <a
href="#Chapter_52__Default_Methods_1">298</a></p>
<p><a href="#default_int_foo____return_3">Section 52.3: Why use Default
Methods?</a>
...............................................................................................................
<a href="#default_int_foo____return_3">299</a></p>
<p><a href="#default_int_foo____return_3">Section 52.4: Accessing other
interface methods within default method</a>
........................................................... <a
href="#default_int_foo____return_3">299</a></p>
<p><a href="#public_interface_Summable">Section 52.5: Default method
multiple inheritance collision</a>
.................................................................................
<a href="#public_interface_Summable">300</a></p>
<p><a href="#_20">Section 52.6: Class, Abstract class and Interface
method precedence</a>
.............................................................. <a
href="#_20">301</a></p>
<h1
id="chapter-53-packages-............................................................................................................................................-303"><a
href="#Chapter_53__Packages_1">Chapter 53: Packages</a>
............................................................................................................................................
<a href="#Chapter_53__Packages_1">303</a></h1>
<p><a href="#Chapter_53__Packages_1">Section 53.1: Using Packages to
create classes with the same name</a>
................................................................. <a
href="#Chapter_53__Packages_1">303</a></p>
<p><a href="#Chapter_53__Packages_1">Section 53.2: Using Package
Protected Scope</a>
......................................................................................................
<a href="#Chapter_53__Packages_1">303</a></p>
<h1
id="chapter-54-inheritance-........................................................................................................................................-305"><a
href="#Chapter_54__Inheritance_1">Chapter 54: Inheritance</a>
........................................................................................................................................
<a href="#Chapter_54__Inheritance_1">305</a></h1>
<p><a href="#Chapter_54__Inheritance_1">Section 54.1: Inheritance</a>
...........................................................................................................................................
<a href="#Chapter_54__Inheritance_1">305</a></p>
<p><a href="#public_class_BaseClassWithPrivat">Section 54.2: Abstract
Classes</a>
.................................................................................................................................
<a href="#public_class_BaseClassWithPrivat">306</a></p>
<p><a href="#Component_myAnonymousComponent">Section 54.3: Using 'final'
to restrict inheritance and overriding</a>
..........................................................................
<a href="#Component_myAnonymousComponent">308</a></p>
<p><a href="#The_final_modifier_can_also_be_a">Section 54.4: The Liskov
Substitution Principle</a>
......................................................................................................
<a href="#The_final_modifier_can_also_be_a">309</a></p>
<p><a href="#Section_54_5__Abstract_class_and">Section 54.5: Abstract
class and Interface usage: "Is-a" relation vs "Has-a" capability</a>
................................... <a
href="#Section_54_5__Abstract_class_and">310</a></p>
<p><a href="#2__You_want_to_specify_the_behav">Section 54.6: Static
Inheritance</a>
................................................................................................................................
<a href="#2__You_want_to_specify_the_behav">313</a></p>
<p><a href="#Hello">Section 54.7: Programming to an interface</a>
...........................................................................................................
<a href="#Hello">314</a></p>
<p><a href="#_22">Section 54.8: Overriding in Inheritance</a>
...................................................................................................................
<a href="#_22">316</a></p>
<p><a href="#B">Section 54.9: Variable shadowing</a>
...........................................................................................................................
<a href="#B">317</a></p>
<p><a href="#B">Section 54.10: Narrowing and Widening of object
references</a>
.............................................................................
<a href="#B">317</a></p>
<p><a href="#public_static_void_main_String_2">Section 54.11:
Inheritance and Static Methods
........................................................................................................
318</a></p>
<h1
id="chapter-55-reference-types-............................................................................................................................-320"><a
href="#Chapter_55__Reference_Types_1">Chapter 55: Reference Types</a>
............................................................................................................................
<a href="#Chapter_55__Reference_Types_1">320</a></h1>
<p><a href="#Chapter_55__Reference_Types_1">Section 55.1: Dierent
Reference Types</a>
.................................................................................................................
<a href="#Chapter_55__Reference_Types_1">320</a></p>
<p><span id="Chapter_56__Console_I_O" class="anchor"></span><a
href="#Chapter_56__Console_I_O_1">Chapter 56: Console I/O
........................................................................................................................................
322</a></p>
<p><a href="#Chapter_56__Console_I_O_1">Section 56.1: Reading user input
from the console</a>
................................................................................................
<a href="#Chapter_56__Console_I_O_1">322</a></p>
<p><a href="#scanner_nextBigDecimal">Section 56.2: Aligning strings in
console</a>
.................................................................................................................
<a href="#scanner_nextBigDecimal">323</a></p>
<p><a href="#1____1___________1">Section 56.3: Implementing Basic
Command-Line Behavior
................................................................................
324</a></p>
<h1
id="chapter-57-streams-...............................................................................................................................................-326"><a
href="#Chapter_57__Streams_1">Chapter 57: Streams</a>
...............................................................................................................................................
<a href="#Chapter_57__Streams_1">326</a></h1>
<p><a href="#Chapter_57__Streams_1">Section 57.1: Using Streams</a>
.....................................................................................................................................
<a href="#Chapter_57__Streams_1">326</a></p>
<p><a href="#A_Stream_object_s_processing_can">Section 57.2: Consuming
Streams</a>
...........................................................................................................................
<a href="#A_Stream_object_s_processing_can">328</a></p>
<p><a href="#page_354">Section 57.3: Creating a Frequency Map</a>
................................................................................................................
<a href="#page_354">330</a></p>
<p><a href="#page_354">Section 57.4: Infinite Streams</a>
...................................................................................................................................
<a href="#page_354">330</a></p>
<p><a href="#This_example_generates_a_Stream">Section 57.5: Collect
Elements of a Stream into a Collection</a>
...............................................................................
<a href="#This_example_generates_a_Stream">331</a></p>
<p><a href="#Collect_to_a_Map_with_unique_key">Section 57.6: Using
Streams to Implement Mathematical Functions</a>
.................................................................. <a
href="#Collect_to_a_Map_with_unique_key">334</a></p>
<p><a href="#Collect_to_a_Map_with_unique_key">Section 57.7: Flatten
Streams with flatMap()</a>
.........................................................................................................
<a href="#Collect_to_a_Map_with_unique_key">334</a></p>
<p><a href="#List__list___new_ArrayList">Section 57.8: Parallel
Stream</a>
...................................................................................................................................
<a href="#List__list___new_ArrayList">335</a></p>
<p><a href="#Section_57_9__Creating_a_Stream">Section 57.9: Creating a
Stream</a>
..............................................................................................................................
<a href="#Section_57_9__Creating_a_Stream">336</a></p>
<p><a href="#___BANANA">Section 57.10: Finding Statistics about
Numerical Streams</a>
..................................................................................
<a href="#___BANANA">337</a></p>
<p><a href="#___BANANA">Section 57.11: Converting an iterator to a
stream</a>
..................................................................................................
<a href="#___BANANA">337</a></p>
<p><a href="#___BANANA">Section 57.12: Using IntStream to iterate over
indexes</a>
.........................................................................................
<a href="#___BANANA">337</a></p>
<p><a href="#_5_Marc">Section 57.13: Concatenate Streams</a>
.......................................................................................................................
<a href="#_5_Marc">338</a></p>
<p><a href="#_5_Marc">Section 57.14: Reduction with Streams</a>
....................................................................................................................
<a href="#_5_Marc">338</a></p>
<p><a href="#This_reduction_is_equivalent_to">Section 57.15: Using
Streams of Map.Entry to Preserve Initial Values after Mapping</a>
....................................... <a
href="#This_reduction_is_equivalent_to">341</a></p>
<p><a href="#This_reduction_is_equivalent_to">Section 57.16: IntStream
to String</a>
............................................................................................................................
<a href="#This_reduction_is_equivalent_to">341</a></p>
<p><a href="#This_reduction_is_equivalent_to">Section 57.17: Finding the
First Element that Matches a Predicate</a>
......................................................................
<a href="#This_reduction_is_equivalent_to">341</a></p>
<p><a href="#Note_that_with_an_infinite_Strea">Section 57.18: Using
Streams and Method References to Write Self-Documenting Processes
........................ 342</a></p>
<p><a href="#_23">Section 57.19: Converting a Stream of Optional to a
Stream of Values
..............................................................
343</a></p>
<p><a href="#_23">Section 57.20: Get a Slice of a Stream</a>
....................................................................................................................
<a href="#_23">343</a></p>
<p><a href="#_23">Section 57.21: Create a Map based on a Stream</a>
...................................................................................................
<a href="#_23">343</a></p>
<p><a href="#Stream_characters___Stream_of__A">Section 57.22: Joining a
stream to a single String</a>
................................................................................................
<a href="#Stream_characters___Stream_of__A">344</a></p>
<p><a href="#APPLE__BANANA__ORANGE__PEAR">Section 57.23: Sort Using
Stream</a>
............................................................................................................................
<a href="#APPLE__BANANA__ORANGE__PEAR">345</a></p>
<p><a href="#data_stream___sorted_Comparator">Section 57.24: Streams of
Primitives</a>
.......................................................................................................................
<a href="#data_stream___sorted_Comparator">346</a></p>
<p><a href="#data_stream___sorted_Comparator">Section 57.25: Stream
operations categories</a>
........................................................................................................
<a href="#data_stream___sorted_Comparator">346</a></p>
<p><a href="#IntStream_iterate_0__i____i___1">Section 57.26: Collect
Results of a Stream into an Array</a>
.....................................................................................
<a href="#IntStream_iterate_0__i____i___1">347</a></p>
<p><a href="#IntStream_iterate_0__i____i___1">Section 57.27: Generating
random Strings using Streams</a>
...................................................................................
<a href="#IntStream_iterate_0__i____i___1">347</a></p>
<h1
id="chapter-58-inputstreams-and-outputstreams-.......................................................................................-349"><a
href="#Chapter_58__InputStreams_and">Chapter 58: InputStreams and
OutputStreams</a>
.......................................................................................
<a href="#Chapter_58__InputStreams_and">349</a></h1>
<p><a href="#Chapter_58__InputStreams_and">Section 58.1: Closing
Streams</a>
..................................................................................................................................
<a href="#Chapter_58__InputStreams_and">349</a></p>
<p><a href="#Chapter_58__InputStreams_and">Section 58.2: Reading
InputStream into a String</a>
...................................................................................................
<a href="#Chapter_58__InputStreams_and">349</a></p>
<p><a href="#between_byte_and_the__native_Jav">Section 58.3: Wrapping
Input/Output Streams</a>
.....................................................................................................
<a href="#between_byte_and_the__native_Jav">350</a></p>
<p><a href="#DataOutputStream__DataInputStrea">Section 58.4:
DataInputStream Example</a>
................................................................................................................
<a href="#DataOutputStream__DataInputStrea">351</a></p>
<p><a href="#DataOutputStream__DataInputStrea">Section 58.5: Writing
bytes to an OutputStream</a>
...................................................................................................
<a href="#DataOutputStream__DataInputStrea">351</a></p>
<p><a href="#DataOutputStream__DataInputStrea">Section 58.6: Copying
Input Stream to Output Stream</a>
.........................................................................................
<a href="#DataOutputStream__DataInputStrea">351</a></p>
<h1
id="chapter-59-readers-and-writers-....................................................................................................................-353"><a
href="#Chapter_59__Readers_and_Writers_1">Chapter 59: Readers and
Writers</a>
....................................................................................................................
<a href="#Chapter_59__Readers_and_Writers_1">353</a></h1>
<p><a href="#Chapter_59__Readers_and_Writers_1">Section 59.1:
BueredReader</a>
...................................................................................................................................
<a href="#Chapter_59__Readers_and_Writers_1">353</a></p>
<p><a href="#try__BufferedReader_br___new_Buf">Section 59.2:
StringWriter Example</a>
.........................................................................................................................
<a href="#try__BufferedReader_br___new_Buf">354</a></p>
<h1
id="chapter-60-preferences-.......................................................................................................................................-355"><a
href="#Chapter_60__Preferences_1">Chapter 60: Preferences</a>
.......................................................................................................................................
<a href="#Chapter_60__Preferences_1">355</a></h1>
<p><a href="#Chapter_60__Preferences_1">Section 60.1: Using
preferences</a>
...............................................................................................................................
<a href="#Chapter_60__Preferences_1">355</a></p>
<p><a href="#Chapter_60__Preferences_1">Section 60.2: Adding event
listeners</a>
.......................................................................................................................
<a href="#Chapter_60__Preferences_1">355</a></p>
<p><a href="#preferences_addPreferenceChangeL">Section 60.3: Getting
sub-nodes of Preferences</a>
....................................................................................................
<a href="#preferences_addPreferenceChangeL">356</a></p>
<p><a href="#_one_two_three_com_mycompany_mya">Section 60.4:
Coordinating preferences access across multiple application
instances</a> .................................... <a
href="#_one_two_three_com_mycompany_mya">357</a></p>
<p><a href="#_one_two_three_com_mycompany_mya">Section 60.5: Exporting
preferences</a>
.......................................................................................................................
<a href="#_one_two_three_com_mycompany_mya">357</a></p>
<p><a href="#___Exception_whilst_writing_data">Section 60.6: Importing
preferences</a>
.......................................................................................................................
<a href="#___Exception_whilst_writing_data">358</a></p>
<p><a href="#exporting_functionality_of_Prefe">Section 60.7: Removing
event listeners</a>
..................................................................................................................
<a href="#exporting_functionality_of_Prefe">359</a></p>
<p><a href="#PreferenceChangeListener_listene">Section 60.8: Getting
preferences values</a>
...............................................................................................................
<a href="#PreferenceChangeListener_listene">360</a></p>
<p><a href="#PreferenceChangeListener_listene">Section 60.9: Setting
preferences values
................................................................................................................
360</a></p>
<h1
id="chapter-61-collection-factory-methods-.......................................................................................................-361"><a
href="#Chapter_61__Collection_Factory_M_1">Chapter 61: Collection
Factory Methods</a>
.......................................................................................................
<a href="#Chapter_61__Collection_Factory_M_1">361</a></h1>
<p><a href="#Chapter_61__Collection_Factory_M_1">Section 61.1:
List&lt;E&gt; Factory Method Examples</a>
.....................................................................................................
<a href="#Chapter_61__Collection_Factory_M_1">361</a></p>
<p><a href="#Chapter_61__Collection_Factory_M_1">Section 61.2:
Set&lt;E&gt; Factory Method Examples</a>
.....................................................................................................
<a href="#Chapter_61__Collection_Factory_M_1">361</a></p>
<p><a href="#Chapter_61__Collection_Factory_M_1">Section 61.3: Map&lt;K,
V&gt; Factory Method Examples</a>
..............................................................................................
<a href="#Chapter_61__Collection_Factory_M_1">361</a></p>
<h1
id="chapter-62-alternative-collections-................................................................................................................-362"><a
href="#Chapter_62__Alternative_Collecti_1">Chapter 62: Alternative
Collections</a>
................................................................................................................
<a href="#Chapter_62__Alternative_Collecti_1">362</a></h1>
<p><a href="#Chapter_62__Alternative_Collecti_1">Section 62.1: Multimap
in Guava, Apache and Eclipse Collections</a>
.......................................................................
<a href="#Chapter_62__Alternative_Collecti_1">362</a></p>
<p><a href="#System_out_println__Empty">Section 62.2: Apache HashBag,
Guava HashMultiset and Eclipse HashBag</a>
...................................................... <a
href="#System_out_println__Empty">364</a></p>
<p><a href="#System_out_println__Hello">Section 62.3: Compare operation
with collections - Create collections</a>
.............................................................. <a
href="#System_out_println__Hello">366</a></p>
<h1
id="chapter-63-concurrent-collections-................................................................................................................-371"><a
href="#Chapter_63__Concurrent_Collectio_1">Chapter 63: Concurrent
Collections</a>
................................................................................................................
<a href="#Chapter_63__Concurrent_Collectio_1">371</a></h1>
<p><a href="#Chapter_63__Concurrent_Collectio_1">Section 63.1:
Thread-safe Collections
......................................................................................................................
371</a></p>
<p><a href="#Chapter_63__Concurrent_Collectio_1">Section 63.2: Insertion
into ConcurrentHashMap</a>
..................................................................................................
<a href="#Chapter_63__Concurrent_Collectio_1">371</a></p>
<p><a href="#_24">Section 63.3: Concurrent Collections</a>
.......................................................................................................................
<a href="#_24">372</a></p>
<h1
id="chapter-64-choosing-collections-....................................................................................................................-374"><a
href="#Chapter_64__Choosing_Collections_1">Chapter 64: Choosing
Collections</a>
....................................................................................................................
<a href="#Chapter_64__Choosing_Collections_1">374</a></h1>
<p><a href="#Chapter_64__Choosing_Collections_1">Section 64.1: Java
Collections Flowchart</a>
................................................................................................................
<a href="#Chapter_64__Choosing_Collections_1">374</a></p>
<h1
id="chapter-65-super-keyword-.................................................................................................................................-375"><a
href="#Chapter_65__super_keyword_1">Chapter 65: super keyword</a>
.................................................................................................................................
<a href="#Chapter_65__super_keyword_1">375</a></h1>
<p><a href="#Chapter_65__super_keyword_1">Section 65.1: Super keyword
use with examples</a>
....................................................................................................
<a href="#Chapter_65__super_keyword_1">375</a></p>
<h1
id="chapter-66-serialization-......................................................................................................................................-378"><a
href="#Chapter_66__Serialization_1">Chapter 66: Serialization</a>
......................................................................................................................................
<a href="#Chapter_66__Serialization_1">378</a></h1>
<p><a href="#Chapter_66__Serialization_1">Section 66.1: Basic
Serialization in Java</a>
..................................................................................................................
<a href="#Chapter_66__Serialization_1">378</a></p>
<p><a href="#import_java_io_ObjectOutputStrea">Section 66.2: Custom
Serialization</a>
..........................................................................................................................
<a href="#import_java_io_ObjectOutputStrea">379</a></p>
<p><a href="#_25">Section 66.3: Versioning and serialVersionUID</a>
......................................................................................................
<a href="#_25">382</a></p>
<p><a href="#It_should_call_defaultReadObject">Section 66.4:
Serialization with Gson</a>
.......................................................................................................................
<a href="#It_should_call_defaultReadObject">383</a></p>
<p><a href="#__getters_and_setters">Section 66.5: Custom JSON
Deserialization with Jackson
....................................................................................
384</a></p>
<p><span id="Chapter_67__Optional" class="anchor"></span><a
href="#Chapter_67__Optional_1">Chapter 67: Optional
...............................................................................................................................................
387</a></p>
<p><a href="#Chapter_67__Optional_1">Section 67.1: Map</a>
.......................................................................................................................................................
<a href="#Chapter_67__Optional_1">387</a></p>
<p><a href="#_map_Baz__toString">Section 67.2: Return default value if
Optional is empty</a>
........................................................................................
<a href="#_map_Baz__toString">388</a></p>
<p><a href="#_map_Baz__toString">Section 67.3: Throw an exception, if
there is no value
...........................................................................................
388</a></p>
<p><a href="#_map_Baz__toString">Section 67.4: Lazily provide a default
value using a Supplier</a>
..............................................................................
<a href="#_map_Baz__toString">388</a></p>
<p><a href="#here__the_orElseGet_method">Section 67.5: Filter</a>
.....................................................................................................................................................
<a href="#here__the_orElseGet_method">389</a></p>
<p><a href="#here__the_orElseGet_method">Section 67.6: Using Optional
containers for primitive number types</a>
.................................................................. <a
href="#here__the_orElseGet_method">389</a></p>
<p><a href="#___Prints_the_value_since_it_is">Section 67.7: Run code
only if there is a value present
.........................................................................................
390</a></p>
<p><a href="#___Prints_the_value_since_it_is">Section 67.8: FlatMap</a>
................................................................................................................................................
<a href="#___Prints_the_value_since_it_is">390</a></p>
<h1
id="chapter-68-object-references-.........................................................................................................................-391"><a
href="#Chapter_68__Object_References_1">Chapter 68: Object
References</a>
.........................................................................................................................
<a href="#Chapter_68__Object_References_1">391</a></h1>
<p><a href="#Chapter_68__Object_References_1">Section 68.1: Object
References as method parameters</a>
......................................................................................
<a href="#Chapter_68__Object_References_1">391</a></p>
<h1
id="chapter-69-exceptions-and-exception-handling-......................................................................................-394"><a
href="#Chapter_69__Exceptions_and_excep_1">Chapter 69: Exceptions and
exception handling</a>
......................................................................................
<a href="#Chapter_69__Exceptions_and_excep_1">394</a></h1>
<p><a href="#Chapter_69__Exceptions_and_excep_1">Section 69.1: Catching
an exception with try-catch</a>
...............................................................................................
<a href="#Chapter_69__Exceptions_and_excep_1">394</a></p>
<p><a href="#The__top_down__matching_strategy">Section 69.2: The
try-with-resources statement</a>
....................................................................................................
<a href="#The__top_down__matching_strategy">395</a></p>
<p><a href="#stream_println__Hello_world">Section 69.3: Custom
Exceptions</a>
.............................................................................................................................
<a href="#stream_println__Hello_world">398</a></p>
<p><a href="#Why_does_RuntimeException_not_re">Section 69.4: Handling
InterruptedException</a>
.........................................................................................................
<a href="#Why_does_RuntimeException_not_re">400</a></p>
<p><a href="#In_limited_cases__e_g__while_ove">Section 69.5: Return
statements in try catch block</a>
...............................................................................................
<a href="#In_limited_cases__e_g__while_ove">401</a></p>
<p><a href="#_26">Section 69.6: Introduction</a>
.........................................................................................................................................
<a href="#_26">402</a></p>
<p><a href="#result___a___b">Section 69.7: The Java Exception Hierarchy
- Unchecked and Checked Exceptions</a>
........................................ <a
href="#result___a___b">403</a></p>
<p><a href="#private_static_final_InputStream">Section 69.8: Creating
and reading stacktraces</a>
....................................................................................................
<a href="#private_static_final_InputStream">406</a></p>
<p><a href="#The__Caused_by___is_only_include">Section 69.9: Throwing an
exception</a>
......................................................................................................................
<a href="#The__Caused_by___is_only_include">409</a></p>
<p><a href="#The_throw_within_the_try_block_d">Section 69.10: Advanced
features of Exceptions</a>
...................................................................................................
<a href="#The_throw_within_the_try_block_d">411</a></p>
<p><a href="#_28">Section 69.11: The try-finally and try-catch-finally
statements</a>
............................................................................
<a href="#_28">412</a></p>
<p><a href="#Version_____Java_SE_7">Section 69.12: The 'throws' clause
in a method declaration</a>
.................................................................................
<a href="#Version_____Java_SE_7">414</a></p>
<h1
id="chapter-70-calendar-and-its-subclasses-....................................................................................................-416"><a
href="#Chapter_70__Calendar_and_its_Sub_1">Chapter 70: Calendar and its
Subclasses</a>
....................................................................................................
<a href="#Chapter_70__Calendar_and_its_Sub_1">416</a></h1>
<p><a href="#Chapter_70__Calendar_and_its_Sub_1">Section 70.1: Creating
Calendar objects</a>
.................................................................................................................
<a href="#Chapter_70__Calendar_and_its_Sub_1">416</a></p>
<p><a href="#Chapter_70__Calendar_and_its_Sub_1">Section 70.2:
Increasing / Decreasing calendar fields
..........................................................................................
416</a></p>
<p><a href="#Chapter_70__Calendar_and_its_Sub_1">Section 70.3:
Subtracting calendars</a>
........................................................................................................................
<a href="#Chapter_70__Calendar_and_its_Sub_1">416</a></p>
<p><a href="#Chapter_70__Calendar_and_its_Sub_1">Section 70.4: Finding
AM/PM</a>
...................................................................................................................................
<a href="#Chapter_70__Calendar_and_its_Sub_1">416</a></p>
<h1
id="chapter-71-using-the-static-keyword-............................................................................................................-418"><a
href="#Chapter_71__Using_the_static_key_1">Chapter 71: Using the static
keyword</a>
............................................................................................................
<a href="#Chapter_71__Using_the_static_key_1">418</a></h1>
<p><a href="#Chapter_71__Using_the_static_key_1">Section 71.1: Reference
to non-static member from static context</a>
..................................................................... <a
href="#Chapter_71__Using_the_static_key_1">418</a></p>
<p><a href="#Chapter_71__Using_the_static_key_1">Section 71.2: Using
static to declare constants</a>
......................................................................................................
<a href="#Chapter_71__Using_the_static_key_1">418</a></p>
<h1
id="chapter-72-properties-class-..............................................................................................................................-420"><a
href="#Chapter_72__Properties_Class_1">Chapter 72: Properties Class</a>
..............................................................................................................................
<a href="#Chapter_72__Properties_Class_1">420</a></h1>
<p><a href="#Chapter_72__Properties_Class_1">Section 72.1: Loading
properties</a>
..............................................................................................................................
<a href="#Chapter_72__Properties_Class_1">420</a></p>
<p><a href="#Chapter_72__Properties_Class_1">Section 72.2: Saving
Properties as XML</a>
..................................................................................................................
<a href="#Chapter_72__Properties_Class_1">420</a></p>
<p><a href="#___save_the_properties">Section 72.3: Property files
caveat: trailing whitespace</a>
........................................................................................
<a href="#___save_the_properties">421</a></p>
<h1
id="chapter-73-lambda-expressions-.....................................................................................................................-424"><a
href="#Chapter_73__Lambda_Expressions_1">Chapter 73: Lambda
Expressions</a>
.....................................................................................................................
<a href="#Chapter_73__Lambda_Expressions_1">424</a></h1>
<p><a href="#Chapter_73__Lambda_Expressions_1">Section 73.1:
Introduction to Java lambdas</a>
...........................................................................................................
<a href="#Chapter_73__Lambda_Expressions_1">424</a></p>
<p><a href="#public_void_passMeALambda_Foo1_f">Section 73.2: Using
Lambda Expressions to Sort a Collection</a>
.............................................................................
<a href="#public_void_passMeALambda_Foo1_f">427</a></p>
<p><a href="#_double_colon__symbol">Section 73.3: Method References</a>
............................................................................................................................
<a href="#_double_colon__symbol">428</a></p>
<p><a href="#Non_static_method__on_instance">Section 73.4: Implementing
multiple interfaces</a>
.....................................................................................................
<a href="#Non_static_method__on_instance">430</a></p>
<p><a href="#Non_static_method__on_instance">Section 73.5: Lambda -
Listener Example</a>
..............................................................................................................
<a href="#Non_static_method__on_instance">430</a></p>
<p><a href="#Lambda_listener">Section 73.6: Java Closures with lambda
expressions</a>
..........................................................................................
<a href="#Lambda_listener">431</a></p>
<p><a href="#changes_in_the_environment_in_wh">Section 73.7: Lambdas and
memory utilization</a>
.....................................................................................................
<a href="#changes_in_the_environment_in_wh">432</a></p>
<p><a href="#1___For_instance__Java_9_introdu">Section 73.8: Using
lambda expression with your own functional interface</a>
...................................................... <a
href="#1___For_instance__Java_9_introdu">433</a></p>
<p><a href="#1___For_instance__Java_9_introdu">Section 73.9: Traditional
style to Lambda style</a>
.....................................................................................................
<a href="#1___For_instance__Java_9_introdu">433</a></p>
<p><a href="#public_class_LambdaTry">Section 73.10: `return` only
returns from the lambda, not the outer method</a>
..................................................... <a
href="#public_class_LambdaTry">434</a></p>
<p><a href="#executeAround_r">Section 73.11: Lambdas and Execute-around
Pattern</a>
...........................................................................................
<a href="#executeAround_r">436</a></p>
<p><a href="#executeAround_r">Section 73.12: Using lambda expressions
&amp; predicates to get a certain value(s) from a list</a>
........................... <a href="#executeAround_r">436</a></p>
<h1
id="chapter-74-basic-control-structures-............................................................................................................-438"><a
href="#Chapter_74__Basic_Control_Struct_1">Chapter 74: Basic Control
Structures</a>
............................................................................................................
<a href="#Chapter_74__Basic_Control_Struct_1">438</a></h1>
<p><a href="#Chapter_74__Basic_Control_Struct_1">Section 74.1: Switch
statement</a>
.................................................................................................................................
<a href="#Chapter_74__Basic_Control_Struct_1">438</a></p>
<p><a href="#In_case_of_foo____1_the_output_w">Section 74.2: do...while
Loop</a>
.....................................................................................................................................
<a href="#In_case_of_foo____1_the_output_w">439</a></p>
<p><a href="#In_this_example__the_loop_will_r">Section 74.3: For Each
...............................................................................................................................................
440</a></p>
<p><a href="#int">Section 74.4: Continue Statement in Java</a>
..............................................................................................................
<a href="#int">441</a></p>
<p><a href="#int">Section 74.5: If / Else If / Else Control</a>
.....................................................................................................................
<a href="#int">441</a></p>
<p><a href="#int">Section 74.6: For Loops
.............................................................................................................................................
441</a></p>
<p><a href="#false_the_loop_will_stop__Assumi">Section 74.7: Ternary
Operator</a>
...............................................................................................................................
<a href="#false_the_loop_will_stop__Assumi">442</a></p>
<p><a href="#String_name___A___B____Billy">Section 74.8: Try ... Catch
... Finally</a>
..........................................................................................................................
<a href="#String_name___A___B____Billy">443</a></p>
<p><a href="#String_name___A___B____Billy">Section 74.9: Break
....................................................................................................................................................
443</a></p>
<p><a href="#while_true">Section 74.10: While Loops</a>
.......................................................................................................................................
<a href="#while_true">444</a></p>
<p><a href="#while_true">Section 74.11: If / Else</a>
................................................................................................................................................
<a href="#while_true">444</a></p>
<p><a href="#while_true">Section 74.12: Nested break / continue</a>
..................................................................................................................
<a href="#while_true">444</a></p>
<h1
id="chapter-75-bueredwriter-................................................................................................................................-446"><a
href="#Chapter_75__Bu_eredWriter_1">Chapter 75: BueredWriter</a>
................................................................................................................................
<a href="#Chapter_75__Bu_eredWriter_1">446</a></h1>
<p><a href="#Chapter_75__Bu_eredWriter_1">Section 75.1: Write a line of
text to File
....................................................................................................................
446</a></p>
<p><span id="Chapter_76__New_File_I_O" class="anchor"></span><a
href="#Chapter_76__New_File_I_O_1">Chapter 76: New File I/O
.......................................................................................................................................
447</a></p>
<p><a href="#Chapter_76__New_File_I_O_1">Section 76.1: Creating
paths</a>
.....................................................................................................................................
<a href="#Chapter_76__New_File_I_O_1">447</a></p>
<p><a href="#Chapter_76__New_File_I_O_1">Section 76.2: Manipulating
paths
.............................................................................................................................
447</a></p>
<p><a href="#Chapter_76__New_File_I_O_1">Section 76.3: Retrieving
information about a path</a>
................................................................................................
<a href="#Chapter_76__New_File_I_O_1">447</a></p>
<p><a href="#Path_p3___Paths_get__C___Users">Section 76.4: Retrieving
information using the filesystem</a>
....................................................................................
<a href="#Path_p3___Paths_get__C___Users">448</a></p>
<p><a href="#Files_isRegularFile_p2_____true">Section 76.5: Reading
files
........................................................................................................................................
449</a></p>
<p><a href="#Files_isRegularFile_p2_____true">Section 76.6: Writing
files
..........................................................................................................................................
449</a></p>
<h1
id="chapter-77-file-io-.................................................................................................................................................-450"><a
href="#Chapter_77__File_I_O_1">Chapter 77: File I/O</a>
.................................................................................................................................................
<a href="#Chapter_77__File_I_O_1">450</a></h1>
<p><a href="#Chapter_77__File_I_O_1">Section 77.1: Migrating from
java.io.File to Java 7 NIO (java.nio.file.Path)</a>
.......................................................... <a
href="#Chapter_77__File_I_O_1">450</a></p>
<p><a href="#public_FileVisitResult_preVisitD">Section 77.2: Reading an
image from a file</a>
...........................................................................................................
<a href="#public_FileVisitResult_preVisitD">452</a></p>
<p><a href="#public_FileVisitResult_preVisitD">Section 77.3: File
Read/Write Using FileInputStream/FileOutputStream</a>
........................................................... <a
href="#public_FileVisitResult_preVisitD">452</a></p>
<p><a href="#Read_from_file_test_txt">Section 77.4: Reading all bytes to
a byte[]</a>
............................................................................................................
<a href="#Read_from_file_test_txt">453</a></p>
<p><a href="#__catch_IOException_e">Section 77.5: Copying a file using
Channel</a>
.............................................................................................................
<a href="#__catch_IOException_e">454</a></p>
<p><a href="#__catch_IOException_e">Section 77.6: Writing a byte[] to a
file
.....................................................................................................................
454</a></p>
<p><a href="#ioe_printStackTrace">Section 77.7: Stream vs Writer/Reader
API</a>
............................................................................................................
<a href="#ioe_printStackTrace">455</a></p>
<p><a href="#charset__When_in_doubt__use_a_Un">Section 77.8: Reading a
file with a Scanner</a>
...........................................................................................................
<a href="#charset__When_in_doubt__use_a_Un">456</a></p>
<p><a href="#__catch__FileNotFoundException_e">Section 77.9: Copying a
file using InputStream and OutputStream</a>
.................................................................... <a
href="#__catch__FileNotFoundException_e">457</a></p>
<p><a href="#__catch__FileNotFoundException_e">Section 77.10: Reading
from a binary file</a>
...............................................................................................................
<a href="#__catch__FileNotFoundException_e">457</a></p>
<p><a href="#__catch__FileNotFoundException_e">Section 77.11: Reading a
file using Channel and Buer</a>
.........................................................................................
<a href="#__catch__FileNotFoundException_e">457</a></p>
<p><a href="#2__Call_the_getChannel___method">Section 77.12: Adding
Directories</a>
.............................................................................................................................
<a href="#2__Call_the_getChannel___method">458</a></p>
<p><a href="#parent_directories___source">Section 77.13: Blocking or
redirecting standard output / error</a>
............................................................................
<a href="#parent_directories___source">459</a></p>
<p><a href="#Caution__be_careful_how_you_use">Section 77.14: Reading a
whole file at once
............................................................................................................
460</a></p>
<p><a href="#Caution__be_careful_how_you_use">Section 77.15: Locking</a>
...............................................................................................................................................
<a href="#Caution__be_careful_how_you_use">460</a></p>
<p><a href="#Caution__be_careful_how_you_use">Section 77.16: Reading a
file using BueredInputStream</a>
.....................................................................................
<a href="#Caution__be_careful_how_you_use">460</a></p>
<p><a href="#buffer_to_store_bytes_read_from">Section 77.17: Iterate
over a directory printing subdirectories in it</a>
......................................................................
<a href="#buffer_to_store_bytes_read_from">461</a></p>
<p><a href="#buffer_to_store_bytes_read_from">Section 77.18: Writing a
file using Channel and Buer</a>
..........................................................................................
<a href="#buffer_to_store_bytes_read_from">461</a></p>
<p><a href="#FileChannel_fileChannel___fos_ge">Section 77.19: Writing a
file using PrintStream</a>
.......................................................................................................
<a href="#FileChannel_fileChannel___fos_ge">462</a></p>
<p><a href="#FileChannel_fileChannel___fos_ge">Section 77.20: Iterating
over a directory and filter by file extension</a>
................................................................... <a
href="#FileChannel_fileChannel___fos_ge">462</a></p>
<p><a href="#Section_77_21__Accessing_the_con">Section 77.21: Accessing
the contents of a ZIP file</a>
................................................................................................
<a href="#Section_77_21__Accessing_the_con">463</a></p>
<h1
id="chapter-78-scanner-...............................................................................................................................................-464"><a
href="#Chapter_78__Scanner_1">Chapter 78: Scanner</a>
...............................................................................................................................................
<a href="#Chapter_78__Scanner_1">464</a></h1>
<p><a href="#Chapter_78__Scanner_1">Section 78.1: General Pattern that
does most commonly asked about tasks</a>
.................................................... <a
href="#Chapter_78__Scanner_1">464</a></p>
<p><a href="#If_you_wanted_to_use_System_in_f">Section 78.2: Using
custom delimiters</a>
....................................................................................................................
<a href="#If_you_wanted_to_use_System_in_f">466</a></p>
<p><a href="#If_you_wanted_to_use_System_in_f">Section 78.3: Reading
system input using Scanner</a>
...............................................................................................
<a href="#If_you_wanted_to_use_System_in_f">466</a></p>
<p><a href="#If_you_wanted_to_use_System_in_f">Section 78.4: Reading
file input using Scanner</a>
......................................................................................................
<a href="#If_you_wanted_to_use_System_in_f">466</a></p>
<p><a href="#_34">Section 78.5: Read the entire input as a String using
Scanner
.............................................................................
467</a></p>
<p><a href="#_34">Section 78.6: Carefully Closing a Scanner</a>
..............................................................................................................
<a href="#_34">467</a></p>
<p><a href="#Section_78_7__Read_an_int_from_t">Section 78.7: Read an int
from the command line</a>
................................................................................................
<a href="#Section_78_7__Read_an_int_from_t">468</a></p>
<h1
id="chapter-79-interfaces-...........................................................................................................................................-469"><a
href="#Chapter_79__Interfaces_1">Chapter 79: Interfaces</a>
...........................................................................................................................................
<a href="#Chapter_79__Interfaces_1">469</a></h1>
<p><a href="#Chapter_79__Interfaces_1">Section 79.1: Implementing
multiple interfaces</a>
......................................................................................................
<a href="#Chapter_79__Interfaces_1">469</a></p>
<p><a href="#Section_79_2__Declaring_and_Impl">Section 79.2: Declaring
and Implementing an Interface
.......................................................................................
470</a></p>
<p><a href="#Section_79_2__Declaring_and_Impl">Section 79.3: Extending
an interface</a>
.......................................................................................................................
<a href="#Section_79_2__Declaring_and_Impl">470</a></p>
<p><a href="#_35">Section 79.4: Usefulness of interfaces</a>
....................................................................................................................
<a href="#_35">471</a></p>
<p><a href="#Section_79_5__Default_methods">Section 79.5: Default
methods</a>
.................................................................................................................................
<a href="#Section_79_5__Default_methods">473</a></p>
<p><a href="#Section_79_6__Modifiers_in_Inter">Section 79.6: Modifiers
in Interfaces</a>
........................................................................................................................
<a href="#Section_79_6__Modifiers_in_Inter">475</a></p>
<p><a href="#Section_79_6__Modifiers_in_Inter">Section 79.7: Using
Interfaces with Generics</a>
..........................................................................................................
<a href="#Section_79_6__Modifiers_in_Inter">475</a></p>
<p><a href="#_37">Section 79.8: Strengthen bounded type parameters</a>
............................................................................................
<a href="#_37">478</a></p>
<p><a href="#_37">Section 79.9: Implementing interfaces in an abstract
class</a>
.................................................................................
<a href="#_37">478</a></p>
<h1
id="chapter-80-regular-expressions-.....................................................................................................................-480"><a
href="#Chapter_80__Regular_Expressions_1">Chapter 80: Regular
Expressions</a>
.....................................................................................................................
<a href="#Chapter_80__Regular_Expressions_1">480</a></h1>
<p><a href="#Chapter_80__Regular_Expressions_1">Section 80.1: Using
capture groups</a>
.........................................................................................................................
<a href="#Chapter_80__Regular_Expressions_1">480</a></p>
<p><a href="#___d_3_____d_3_____d_4">Section 80.2: Using regex with
custom behaviour by compiling the Pattern with flags</a>
................................... <a
href="#___d_3_____d_3_____d_4">481</a></p>
<p><a href="#___d_3_____d_3_____d_4">Section 80.3: Escape Characters</a>
.............................................................................................................................
<a href="#___d_3_____d_3_____d_4">481</a></p>
<p><a href="#This_will_give_an_error">Section 80.4: Not matching a given
string</a>
.............................................................................................................
<a href="#This_will_give_an_error">482</a></p>
<p><a href="#This_will_give_an_error">Section 80.5: Matching with a
regex literal</a>
.............................................................................................................
<a href="#This_will_give_an_error">482</a></p>
<p><a href="#This_will_give_an_error">Section 80.6: Matching a
backslash</a>
........................................................................................................................
<a href="#This_will_give_an_error">482</a></p>
<p><span id="Chapter_81__Comparable_and_Compa" class="anchor"></span><a
href="#Chapter_81__Comparable_and_Compa_1">Chapter 81: Comparable and
Comparator
..................................................................................................
484</a></p>
<p><a href="#Chapter_81__Comparable_and_Compa_1">Section 81.1: Sorting a
List using Comparable&lt;T&gt; or a Comparator&lt;T&gt;</a>
............................................................. <a
href="#Chapter_81__Comparable_and_Compa_1">484</a></p>
<p><a href="#_38">Section 81.2: The compareTo and compare Methods</a>
..........................................................................................
<a href="#_38">487</a></p>
<p><a href="#Section_81_3__Natural__comparabl">Section 81.3: Natural
(comparable) vs explicit (comparator) sorting</a>
................................................................. <a
href="#Section_81_3__Natural__comparabl">488</a></p>
<p><a href="#System_out_println_pList">Section 81.4: Creating a
Comparator using comparing method</a>
.........................................................................
<a href="#System_out_println_pList">489</a></p>
<p><a href="#System_out_println_pList">Section 81.5: Sorting Map
entries</a>
.............................................................................................................................
<a href="#System_out_println_pList">489</a></p>
<h1
id="chapter-82-java-floating-point-operations-..............................................................................................-491"><a
href="#Chapter_82__Java_Floating_Point_1">Chapter 82: Java Floating
Point Operations</a>
..............................................................................................
<a href="#Chapter_82__Java_Floating_Point_1">491</a></h1>
<p><a href="#Chapter_82__Java_Floating_Point_1">Section 82.1: Comparing
floating point values</a>
.......................................................................................................
<a href="#Chapter_82__Java_Floating_Point_1">491</a></p>
<p><a href="#Also_for_comparison_of_double_an">Section 82.2: OverFlow
and UnderFlow
..................................................................................................................
493</a></p>
<p><a href="#System_out_println_result_____0">Section 82.3: Formatting
the floating point values
................................................................................................
494</a></p>
<p><a href="#System_out_println_result_____0">Section 82.4: Strict
Adherence to the IEEE Specification
.......................................................................................
494</a></p>
<h1
id="chapter-83-currency-and-money-....................................................................................................................-496"><a
href="#Chapter_83__Currency_and_Money_1">Chapter 83: Currency and
Money</a>
....................................................................................................................
<a href="#Chapter_83__Currency_and_Money_1">496</a></h1>
<p><a href="#Chapter_83__Currency_and_Money_1">Section 83.1: Add custom
currency</a>
.........................................................................................................................
<a href="#Chapter_83__Currency_and_Money_1">496</a></p>
<h1
id="chapter-84-object-cloning-.................................................................................................................................-497"><a
href="#Chapter_84__Object_Cloning_1">Chapter 84: Object Cloning</a>
.................................................................................................................................
<a href="#Chapter_84__Object_Cloning_1">497</a></h1>
<p><a href="#Chapter_84__Object_Cloning_1">Section 84.1: Cloning
performing a deep copy</a>
......................................................................................................
<a href="#Chapter_84__Object_Cloning_1">497</a></p>
<p><a href="#List_sheepChildren___sheep_getCh">Section 84.2: Cloning
using a copy factory</a>
............................................................................................................
<a href="#List_sheepChildren___sheep_getCh">498</a></p>
<p><a href="#List_sheepChildren___sheep_getCh">Section 84.3: Cloning
using a copy constructor</a>
.....................................................................................................
<a href="#List_sheepChildren___sheep_getCh">498</a></p>
<p><a href="#List_sheepChildren___sheep_getCh">Section 84.4: Cloning by
implementing Clonable interface</a>
..................................................................................
<a href="#List_sheepChildren___sheep_getCh">498</a></p>
<p><a href="#public_class_Sheep_implements_Cl">Section 84.5: Cloning
performing a shallow copy</a>
.................................................................................................
<a href="#public_class_Sheep_implements_Cl">499</a></p>
<p><span id="Chapter_85__Recursion" class="anchor"></span><a
href="#Chapter_85__Recursion_1">Chapter 85: Recursion
............................................................................................................................................
501</a></p>
<p><a href="#Chapter_85__Recursion_1">Section 85.1: The basic idea of
recursion</a>
................................................................................................................
<a href="#Chapter_85__Recursion_1">501</a></p>
<p><a href="#Chapter_85__Recursion_1">Section 85.2: Deep recursion is
problematic in Java</a>
............................................................................................
<a href="#Chapter_85__Recursion_1">501</a></p>
<p><a href="#stack_tracing__It_is_as_if_the_c">Section 85.3: Types of
Recursion
.............................................................................................................................
503</a></p>
<p><a href="#stack_tracing__It_is_as_if_the_c">Section 85.4: Computing
the Nth Fibonacci Number</a>
............................................................................................
<a href="#stack_tracing__It_is_as_if_the_c">503</a></p>
<p><a href="#However__while_this_example_is_i">Section 85.5:
StackOverflowError &amp; recursion to loop</a>
..........................................................................................
<a href="#However__while_this_example_is_i">504</a></p>
<p><a href="#___do_everything_done_before_the">Section 85.6: Computing
the Nth power of a number
...........................................................................................
506</a></p>
<p><a href="#___do_everything_done_before_the">Section 85.7: Traversing
a Tree data structure with recursion</a>
............................................................................
<a href="#___do_everything_done_before_the">506</a></p>
<p><a href="#_39">Section 85.8: Reverse a string using Recursion</a>
.....................................................................................................
<a href="#_39">507</a></p>
<p><a href="#_39">Section 85.9: Computing the sum of integers from 1 to
N</a>
....................................................................................
<a href="#_39">507</a></p>
<h1
id="chapter-86-converting-to-and-from-strings-.............................................................................................-508"><a
href="#Chapter_86__Converting_to_and_fr_1">Chapter 86: Converting to and
from Strings</a>
.............................................................................................
<a href="#Chapter_86__Converting_to_and_fr_1">508</a></h1>
<p><a href="#Chapter_86__Converting_to_and_fr_1">Section 86.1:
Converting String to other datatypes</a>
...............................................................................................
<a href="#Chapter_86__Converting_to_and_fr_1">508</a></p>
<p><a href="#boolean_tryParseInt__String_valu">Section 86.2: Conversion
to / from bytes</a>
...............................................................................................................
<a href="#boolean_tryParseInt__String_valu">509</a></p>
<p><a href="#boolean_tryParseInt__String_valu">Section 86.3: Base64
Encoding / Decoding
............................................................................................................
509</a></p>
<p><a href="#For_this_we_can_use_the_Datatype">Section 86.4: Converting
other datatypes to String</a>
..............................................................................................
<a href="#For_this_we_can_use_the_Datatype">510</a></p>
<p><a href="#You_can_get_the_value_of_other_p">Section 86.5: Getting a
`String` from an `InputStream`</a>
..........................................................................................
<a href="#You_can_get_the_value_of_other_p">511</a></p>
<h1
id="chapter-87-random-number-generation-..................................................................................................-512"><a
href="#Chapter_87__Random_Number_Genera_1">Chapter 87: Random Number
Generation</a>
..................................................................................................
<a href="#Chapter_87__Random_Number_Genera_1">512</a></h1>
<p><a href="#Chapter_87__Random_Number_Genera_1">Section 87.1: Pseudo
Random Numbers</a>
.................................................................................................................
<a href="#Chapter_87__Random_Number_Genera_1">512</a></p>
<p><a href="#Chapter_87__Random_Number_Genera_1">Section 87.2: Pseudo
Random Numbers in Specific Range</a>
.................................................................................
<a href="#Chapter_87__Random_Number_Genera_1">512</a></p>
<p><a href="#case_is_n_2_30_1__for_which_the">Section 87.3: Generating
cryptographically secure pseudorandom numbers
................................................... 513</a></p>
<p><a href="#case_is_n_2_30_1__for_which_the">Section 87.4: Generating
Random Numbers with a Specified Seed</a>
.................................................................... <a
href="#case_is_n_2_30_1__for_which_the">513</a></p>
<p><a href="#A_good_method_to_get_a_Long_that">Section 87.5: Select
random numbers without duplicates</a>
....................................................................................
<a href="#A_good_method_to_get_a_Long_that">514</a></p>
<p><a href="#length_of_possible_numbers__It_s">Section 87.6: Generating
Random number using apache-common lang3</a>
........................................................ <a
href="#length_of_possible_numbers__It_s">515</a></p>
<h1
id="chapter-88-singletons-..........................................................................................................................................-516"><a
href="#Chapter_88__Singletons_1">Chapter 88: Singletons</a>
..........................................................................................................................................
<a href="#Chapter_88__Singletons_1">516</a></h1>
<p><a href="#Chapter_88__Singletons_1">Section 88.1: Enum Singleton</a>
...................................................................................................................................
<a href="#Chapter_88__Singletons_1">516</a></p>
<p><a href="#Chapter_88__Singletons_1">Section 88.2: Singleton without
use of Enum (eager initialization)</a>
......................................................................
<a href="#Chapter_88__Singletons_1">516</a></p>
<p><a href="#Therefore__as_long_as_there_are">Section 88.3: Thread-safe
lazy initialization using holder class | Bill Pugh Singleton
implementation</a> ............ <a
href="#Therefore__as_long_as_there_are">517</a></p>
<p><a href="#Therefore__as_long_as_there_are">Section 88.4: Thread safe
Singleton with double checked locking</a>
......................................................................
<a href="#Therefore__as_long_as_there_are">517</a></p>
<p><a href="#avoided__It_is_not_possible_to_i">Section 88.5: Extending
singleton (singleton inheritance)</a>
....................................................................................
<a href="#avoided__It_is_not_possible_to_i">518</a></p>
<p><span id="Chapter_89__Autoboxing" class="anchor"></span><a
href="#Chapter_89__Autoboxing_1">Chapter 89: Autoboxing
.........................................................................................................................................
521</a></p>
<p><a href="#Chapter_89__Autoboxing_1">Section 89.1: Using int and
Integer interchangeably</a>
.............................................................................................
<a href="#Chapter_89__Autoboxing_1">521</a></p>
<p><a href="#Integer_a___127">Section 89.2: Auto-unboxing may lead to
NullPointerException
..........................................................................
522</a></p>
<p><a href="#Integer_a___127">Section 89.3: Using Boolean in if
statement</a>
...........................................................................................................
<a href="#Integer_a___127">522</a></p>
<p><a href="#Integer_a___127">Section 89.4: Dierent Cases When Integer
and int can be used interchangeably</a>
.......................................... <a
href="#Integer_a___127">522</a></p>
<p><a href="#run_into_null_pointer_exception">Section 89.5: Memory and
Computational Overhead of Autoboxing</a>
................................................................. <a
href="#run_into_null_pointer_exception">524</a></p>
<h1
id="chapter-90-2d-graphics-in-java-......................................................................................................................-525"><a
href="#Chapter_90__2D_Graphics_in_Java_1">Chapter 90: 2D Graphics in
Java</a>
......................................................................................................................
<a href="#Chapter_90__2D_Graphics_in_Java_1">525</a></h1>
<p><a href="#Chapter_90__2D_Graphics_in_Java_1">Section 90.1: Example 1:
Draw and Fill a Rectangle Using Java</a>
..........................................................................
<a href="#Chapter_90__2D_Graphics_in_Java_1">525</a></p>
<p><a href="#Section_90_2__Example_2__Drawing">Section 90.2: Example 2:
Drawing and Filling Oval</a>
...............................................................................................
<a href="#Section_90_2__Example_2__Drawing">527</a></p>
<h1
id="chapter-91-jaxb-.......................................................................................................................................................-528"><a
href="#Chapter_91__JAXB_1">Chapter 91: JAXB</a>
.......................................................................................................................................................
<a href="#Chapter_91__JAXB_1">528</a></h1>
<p><a href="#Chapter_91__JAXB_1">Section 91.1: Reading an XML file
(unmarshalling)</a>
................................................................................................
<a href="#Chapter_91__JAXB_1">528</a></p>
<p><a href="#Chapter_91__JAXB_1">Section 91.2: Writing an XML file
(marshalling an object)
.....................................................................................
528</a></p>
<p><a href="#_XmlRootElement">Section 91.3: Manual field/property XML
mapping configuration</a>
.......................................................................
<a href="#_XmlRootElement">529</a></p>
<p><a href="#_XmlElement_name__different_name">Section 91.4: Binding an
XML namespace to a serializable Java class</a>
............................................................... <a
href="#_XmlElement_name__different_name">530</a></p>
<p><a href="#_XmlElement_name__different_name">Section 91.5: Using
XmlAdapter to generate desired xml format</a>
........................................................................
<a href="#_XmlElement_name__different_name">530</a></p>
<p><a href="#Section_91_6__Using_XmlAdapter_t">Section 91.6: Using
XmlAdapter to trim string</a>
........................................................................................................
<a href="#Section_91_6__Using_XmlAdapter_t">532</a></p>
<p><a href="#Section_91_6__Using_XmlAdapter_t">Section 91.7: Automatic
field/property XML mapping configuration (@XmlAccessorType)</a>
............................ <a
href="#Section_91_6__Using_XmlAdapter_t">532</a></p>
<p><a href="#getter">Section 91.8: Specifying a XmlAdapter instance to
(re)use existing data</a>
........................................................... <a
href="#getter">534</a></p>
<h1
id="chapter-92-class---java-reflection-................................................................................................................-537"><a
href="#Chapter_92__Class___Java_Reflect_1">Chapter 92: Class - Java
Reflection</a>
................................................................................................................
<a href="#Chapter_92__Class___Java_Reflect_1">537</a></h1>
<p><a href="#Chapter_92__Class___Java_Reflect_1">Section 92.1:
getClass() method of Object class</a>
....................................................................................................
<a href="#Chapter_92__Class___Java_Reflect_1">537</a></p>
<h1
id="chapter-93-networking-........................................................................................................................................-538"><a
href="#Chapter_93__Networking_1">Chapter 93: Networking</a>
........................................................................................................................................
<a href="#Chapter_93__Networking_1">538</a></h1>
<p><a href="#Chapter_93__Networking_1">Section 93.1: Basic Client and
Server Communication using a Socket</a>
................................................................ <a
href="#Chapter_93__Networking_1">538</a></p>
<p><a href="#___created_and_closed_in_the_sam">Section 93.2: Basic
Client/Server Communication using UDP (Datagram)
........................................................ 540</a></p>
<p><a href="#DatagramPacket_packet___new_Data">Section 93.3: Loading
TrustStore and KeyStore from InputStream</a>
.................................................................... <a
href="#DatagramPacket_packet___new_Data">541</a></p>
<p><a href="#__catch__KeyStoreException___IOE">Section 93.4: Socket
example - reading a web page using a simple socket</a>
...................................................... <a
href="#__catch__KeyStoreException___IOE">542</a></p>
<p><a href="#use_utility_methods_from_Apache">Section 93.5: Temporarily
disable SSL verification (for testing purposes)</a>
......................................................... <a
href="#use_utility_methods_from_Apache">543</a></p>
<p><a href="#use_utility_methods_from_Apache">Section 93.6: Downloading
a file using Channel</a>
....................................................................................................
<a href="#use_utility_methods_from_Apache">543</a></p>
<p><a href="#try__ReadableByteChannel_rbc">Section 93.7:
Multicasting</a>
.........................................................................................................................................
<a href="#try__ReadableByteChannel_rbc">544</a></p>
<h1
id="chapter-94-nio---networking-...........................................................................................................................-547"><a
href="#Chapter_94__NIO___Networking_1">Chapter 94: NIO - Networking</a>
...........................................................................................................................
<a href="#Chapter_94__NIO___Networking_1">547</a></h1>
<p><a href="#Chapter_94__NIO___Networking_1">Section 94.1: Using
Selector to wait for events (example with OP_CONNECT)</a>
................................................. <a
href="#Chapter_94__NIO___Networking_1">547</a></p>
<h1
id="chapter-95-httpurlconnection-......................................................................................................................-549"><a
href="#Chapter_95__HttpURLConnection_1">Chapter 95:
HttpURLConnection</a>
......................................................................................................................
<a href="#Chapter_95__HttpURLConnection_1">549</a></h1>
<p><a href="#Chapter_95__HttpURLConnection_1">Section 95.1: Get response
body from a URL as a String</a>
.....................................................................................
<a href="#Chapter_95__HttpURLConnection_1">549</a></p>
<p><a href="#Usage">Section 95.2: POST data</a>
...........................................................................................................................................
<a href="#Usage">550</a></p>
<p><a href="#Usage">Section 95.3: Delete resource
...................................................................................................................................
550</a></p>
<p><a href="#connection_setRequestMethod__DEL">Section 95.4: Check if
resource exists</a>
.....................................................................................................................
<a href="#connection_setRequestMethod__DEL">551</a></p>
<h1
id="chapter-96-jax-ws-................................................................................................................................................-553"><a
href="#Chapter_96__JAX_WS_1">Chapter 96: JAX-WS</a>
................................................................................................................................................
<a href="#Chapter_96__JAX_WS_1">553</a></h1>
<p><a href="#Chapter_96__JAX_WS_1">Section 96.1: Basic
Authentication</a>
...........................................................................................................................
<a href="#Chapter_96__JAX_WS_1">553</a></p>
<h1
id="chapter-97-nashorn-javascript-engine-......................................................................................................-554"><a
href="#Chapter_97__Nashorn_JavaScript_e_1">Chapter 97: Nashorn
JavaScript engine</a>
......................................................................................................
<a href="#Chapter_97__Nashorn_JavaScript_e_1">554</a></h1>
<p><a href="#Chapter_97__Nashorn_JavaScript_e_1">Section 97.1: Execute
JavaScript file
........................................................................................................................
554</a></p>
<p><a href="#Chapter_97__Nashorn_JavaScript_e_1">Section 97.2: Intercept
script output</a>
.......................................................................................................................
<a href="#Chapter_97__Nashorn_JavaScript_e_1">554</a></p>
<p><a href="#___stringWriter_toString___conta">Section 97.3: Hello
Nashorn</a>
.....................................................................................................................................
<a href="#___stringWriter_toString___conta">555</a></p>
<p><a href="#___stringWriter_toString___conta">Section 97.4: Evaluate
Arithmetic Strings</a>
...............................................................................................................
<a href="#___stringWriter_toString___conta">555</a></p>
<p><a href="#___stringWriter_toString___conta">Section 97.5: Set global
variables</a>
............................................................................................................................
<a href="#___stringWriter_toString___conta">555</a></p>
<p><a href="#Section_97_6__Set_and_get_global">Section 97.6: Set and get
global variables</a>
.............................................................................................................
<a href="#Section_97_6__Set_and_get_global">556</a></p>
<p><a href="#Section_97_6__Set_and_get_global">Section 97.7: Usage of
Java objects in JavaScript in Nashorn</a>
............................................................................
<a href="#Section_97_6__Set_and_get_global">556</a></p>
<p><a href="#Section_97_8__Implementing_an_in">Section 97.8:
Implementing an interface from script</a>
............................................................................................
<a href="#Section_97_8__Implementing_an_in">557</a></p>
<h1
id="chapter-98-java-native-interface-..................................................................................................................-558"><a
href="#Chapter_98__Java_Native_Interfac_1">Chapter 98: Java Native
Interface</a>
..................................................................................................................
<a href="#Chapter_98__Java_Native_Interfac_1">558</a></h1>
<p><a href="#Chapter_98__Java_Native_Interfac_1">Section 98.1: Calling
C++ methods from Java
........................................................................................................
558</a></p>
<p><a href="#JNIEXPORT_void_JNICALL_Java_com">Section 98.2: Calling Java
methods from C++ (callback)
.....................................................................................
559</a></p>
<p><a href="#Compiled_from__JNIJavaCallback_j">Section 98.3: Loading
native libraries</a>
.....................................................................................................................
<a href="#Compiled_from__JNIJavaCallback_j">561</a></p>
<h1
id="chapter-99-functional-interfaces-...................................................................................................................-563"><a
href="#Chapter_99__Functional_Interface_1">Chapter 99: Functional
Interfaces</a>
...................................................................................................................
<a href="#Chapter_99__Functional_Interface_1">563</a></h1>
<p><a href="#Chapter_99__Functional_Interface_1">Section 99.1: List of
standard Java Runtime Library functional interfaces by signature</a>
.................................. <a
href="#Chapter_99__Functional_Interface_1">563</a></p>
<h1
id="chapter-100-fluent-interface-............................................................................................................................-565"><a
href="#Chapter_100__Fluent_Interface_1">Chapter 100: Fluent
Interface</a>
............................................................................................................................
<a href="#Chapter_100__Fluent_Interface_1">565</a></h1>
<p><a href="#Chapter_100__Fluent_Interface_1">Section 100.1: Fluent
programming style</a>
................................................................................................................
<a href="#Chapter_100__Fluent_Interface_1">565</a></p>
<p><a href="#_41">Section 100.2: Truth - Fluent Testing Framework</a>
..................................................................................................
<a href="#_41">566</a></p>
<h1
id="chapter-101-remote-method-invocation-rmi-.........................................................................................-567"><a
href="#Chapter_101__Remote_Method_Invoc_1">Chapter 101: Remote Method
Invocation (RMI)</a>
.........................................................................................
<a href="#Chapter_101__Remote_Method_Invoc_1">567</a></h1>
<p><a href="#Chapter_101__Remote_Method_Invoc_1">Section 101.1:
Callback: invoking methods on a "client"</a>
.........................................................................................
<a href="#Chapter_101__Remote_Method_Invoc_1">567</a></p>
<p><a href="#Client1_received___7">Section 101.2: Simple RMI example
with Client and Server implementation</a>
....................................................... <a
href="#Client1_received___7">571</a></p>
<p><a href="#if__instance____null">Section 101.3: Client-Server:
invoking methods in one JVM from another</a>
.......................................................... <a
href="#if__instance____null">573</a></p>
<h1
id="chapter-102-iterator-and-iterable-..................................................................................................................-576"><a
href="#Chapter_102__Iterator_and_Iterab_1">Chapter 102: Iterator and
Iterable</a>
..................................................................................................................
<a href="#Chapter_102__Iterator_and_Iterab_1">576</a></h1>
<p><a href="#Chapter_102__Iterator_and_Iterab_1">Section 102.1: Removing
elements using an iterator</a>
.............................................................................................
<a href="#Chapter_102__Iterator_and_Iterab_1">576</a></p>
<p><a href="#Chapter_102__Iterator_and_Iterab_1">Section 102.2: Creating
your own Iterable</a>
..............................................................................................................
<a href="#Chapter_102__Iterator_and_Iterab_1">576</a></p>
<p><a href="#Iterable_there_is_only_one_which">Section 102.3: Using
Iterable in for loop</a>
..................................................................................................................
<a href="#Iterable_there_is_only_one_which">577</a></p>
<p><a href="#System_out_println_i">Section 102.4: Using the raw
iterator</a>
......................................................................................................................
<a href="#System_out_println_i">578</a></p>
<h1
id="chapter-103-reflection-api-.................................................................................................................................-579"><a
href="#Chapter_103__Reflection_API_1">Chapter 103: Reflection API</a>
.................................................................................................................................
<a href="#Chapter_103__Reflection_API_1">579</a></h1>
<p><a href="#Chapter_103__Reflection_API_1">Section 103.1: Dynamic
Proxies</a>
................................................................................................................................
<a href="#Chapter_103__Reflection_API_1">579</a></p>
<p><a href="#_43">Section 103.2: Introduction</a>
.......................................................................................................................................
<a href="#_43">580</a></p>
<p><a href="#import_java_util_Map">Section 103.3: Evil Java hacks with
Reflection</a>
.......................................................................................................
<a href="#import_java_util_Map">581</a></p>
<p><a href="#public_static_void_main_String_a">Section 103.4: Misuse of
Reflection API to change private and final variables
................................................... 583</a></p>
<p><a href="#field_set_a_25">Section 103.5: Getting and Setting
fields</a>
.................................................................................................................
<a href="#field_set_a_25">584</a></p>
<p><a href="#___Get_the_modifiers_on_the__NAM">Section 103.6: Call
constructor</a>
.................................................................................................................................
<a href="#___Get_the_modifiers_on_the__NAM">585</a></p>
<p><a href="#class">Section 103.7: Call constructor of nested class</a>
......................................................................................................
<a href="#class">586</a></p>
<p><a href="#class">Section 103.8: Invoking a method</a>
............................................................................................................................
<a href="#class">586</a></p>
<p><a href="#___invoke_s_substring_6">Section 103.9: Get Class given its
(fully qualified) name</a>
.......................................................................................
<a href="#___invoke_s_substring_6">587</a></p>
<p><a href="#___invoke_s_substring_6">Section 103.10: Getting the
Constants of an Enumeration</a>
....................................................................................
<a href="#___invoke_s_substring_6">587</a></p>
<p><a href="#EAST">Section 103.11: Call overloaded constructors using
reflection
...............................................................................
588</a></p>
<p><span id="Chapter_104__ByteBu_er" class="anchor"></span><a
href="#Chapter_104__ByteBu_er_1">Chapter 104: ByteBuer
.......................................................................................................................................
590</a></p>
<p><a href="#Chapter_104__ByteBu_er_1">Section 104.1: Basic Usage -
Using DirectByteBuer</a>
............................................................................................
<a href="#Chapter_104__ByteBu_er_1">590</a></p>
<p><a href="#Chapter_104__ByteBu_er_1">Section 104.2: Basic Usage -
Creating a ByteBuer</a>
.............................................................................................
<a href="#Chapter_104__ByteBu_er_1">590</a></p>
<p><a href="#If_you_do_not_have_an_already_ex">Section 104.3: Basic
Usage - Write Data to the Buer</a>
..........................................................................................
<a href="#If_you_do_not_have_an_already_ex">591</a></p>
<h1
id="chapter-105-applets-...............................................................................................................................................-592"><a
href="#Chapter_105__Applets_1">Chapter 105: Applets</a>
...............................................................................................................................................
<a href="#Chapter_105__Applets_1">592</a></h1>
<p><a href="#Chapter_105__Applets_1">Section 105.1: Minimal Applet</a>
...................................................................................................................................
<a href="#Chapter_105__Applets_1">592</a></p>
<p><a href="#Section_105_2__Creating_a_GUI">Section 105.2: Creating a
GUI</a>
...................................................................................................................................
<a href="#Section_105_2__Creating_a_GUI">593</a></p>
<p><a href="#Section_105_2__Creating_a_GUI">Section 105.3: Open links
from within the applet</a>
...................................................................................................
<a href="#Section_105_2__Creating_a_GUI">593</a></p>
<p><a href="#Section_105_4__Loading_images__a">Section 105.4: Loading
images, audio and other resources</a>
.................................................................................
<a href="#Section_105_4__Loading_images__a">594</a></p>
<h1
id="chapter-106-expressions-......................................................................................................................................-596"><a
href="#Chapter_106__Expressions_1">Chapter 106: Expressions</a>
......................................................................................................................................
<a href="#Chapter_106__Expressions_1">596</a></h1>
<p><a href="#Chapter_106__Expressions_1">Section 106.1: Operator
Precedence</a>
........................................................................................................................
<a href="#Chapter_106__Expressions_1">596</a></p>
<p><a href="#Logical_OR">Section 106.2: Expression Basics</a>
..............................................................................................................................
<a href="#Logical_OR">597</a></p>
<p><a href="#However___in_Java_8_and_later__t">Section 106.3: Expression
evaluation order</a>
............................................................................................................
<a href="#However___in_Java_8_and_later__t">598</a></p>
<p><a href="#3__The_right_operand_of_the___op">Section 106.4: Constant
Expressions</a>
.......................................................................................................................
<a href="#3__The_right_operand_of_the___op">599</a></p>
<h1
id="chapter-107-json-in-java-..................................................................................................................................-601"><a
href="#Chapter_107__JSON_in_Java_1">Chapter 107: JSON in Java</a>
..................................................................................................................................
<a href="#Chapter_107__JSON_in_Java_1">601</a></h1>
<p><a href="#Chapter_107__JSON_in_Java_1">Section 107.1: Using Jackson
Object Mapper</a>
.........................................................................................................
<a href="#Chapter_107__JSON_in_Java_1">601</a></p>
<p><a href="#Usage_example__jsonString_is_the">Section 107.2: JSON To
Object (Gson Library)
.......................................................................................................
602</a></p>
<p><a href="#Usage_example__jsonString_is_the">Section 107.3:
JSONObject.NULL</a>
.............................................................................................................................
<a href="#Usage_example__jsonString_is_the">602</a></p>
<p><a href="#Section_107_4__JSON_Builder___ch">Section 107.4: JSON
Builder - chaining methods</a>
...................................................................................................
<a href="#Section_107_4__JSON_Builder___ch">603</a></p>
<p><a href="#Section_107_4__JSON_Builder___ch">Section 107.5: Object To
JSON (Gson Library)
.......................................................................................................
603</a></p>
<p><a href="#Section_107_4__JSON_Builder___ch">Section 107.6: JSON
Iteration</a>
...................................................................................................................................
<a href="#Section_107_4__JSON_Builder___ch">603</a></p>
<p><a href="#arr_put__Over">Section 107.7: optXXX vs getXXX methods</a>
.............................................................................................................
<a href="#arr_put__Over">604</a></p>
<p><a href="#arr_put__Over">Section 107.8: Extract single element from
JSON</a>
..................................................................................................
<a href="#arr_put__Over">604</a></p>
<p><a href="#arr_put__Over">Section 107.9: JsonArray to Java List (Gson
Library)</a>
...........................................................................................
<a href="#arr_put__Over">604</a></p>
<p><a href="#return_list">Section 107.10: Encoding data as JSON</a>
..................................................................................................................
<a href="#return_list">605</a></p>
<p><a href="#return_list">Section 107.11: Decoding JSON data</a>
.......................................................................................................................
<a href="#return_list">605</a></p>
<h1
id="chapter-108-xml-parsing-using-the-jaxp-apis-.........................................................................................-607"><a
href="#Chapter_108__XML_Parsing_using_t_1">Chapter 108: XML Parsing
using the JAXP APIs</a>
.........................................................................................
<a href="#Chapter_108__XML_Parsing_using_t_1">607</a></h1>
<p><a href="#Chapter_108__XML_Parsing_using_t_1">Section 108.1: Parsing
a document using the StAX API
..........................................................................................
607</a></p>
<p><a href="#_44">Section 108.2: Parsing and navigating a document using
the DOM API</a>
............................................................. <a
href="#_44">608</a></p>
<h1
id="chapter-109-xml-xpath-evaluation-................................................................................................................-610"><a
href="#Chapter_109__XML_XPath_Evaluatio_1">Chapter 109: XML XPath
Evaluation</a>
................................................................................................................
<a href="#Chapter_109__XML_XPath_Evaluatio_1">610</a></h1>
<p><a href="#Chapter_109__XML_XPath_Evaluatio_1">Section 109.1: Parsing
multiple XPath Expressions in a single XML</a>
......................................................................
<a href="#Chapter_109__XML_XPath_Evaluatio_1">610</a></p>
<p><a href="#Chapter_109__XML_XPath_Evaluatio_1">Section 109.2: Parsing
single XPath Expression multiple times in an XML</a>
.......................................................... <a
href="#Chapter_109__XML_XPath_Evaluatio_1">610</a></p>
<p><a href="#XPath_xPath___XPathFactory_newIn">Section 109.3: Evaluating
a NodeList in an XML document</a>
..................................................................................
<a href="#XPath_xPath___XPathFactory_newIn">611</a></p>
<h1
id="chapter-110-xom---xml-object-model-...........................................................................................................-612"><a
href="#Chapter_110__XOM___XML_Object_Mo_1">Chapter 110: XOM - XML Object
Model</a>
...........................................................................................................
<a href="#Chapter_110__XOM___XML_Object_Mo_1">612</a></h1>
<p><a href="#Chapter_110__XOM___XML_Object_Mo_1">Section 110.1: Reading
a XML file</a>
..............................................................................................................................
<a href="#Chapter_110__XOM___XML_Object_Mo_1">612</a></p>
<p><a href="#This_will_print_out_in_the_conso">Section 110.2: Writing to
a XML File</a>
.........................................................................................................................
<a href="#This_will_print_out_in_the_conso">614</a></p>
<h1
id="chapter-111-polymorphism-..................................................................................................................................-617"><a
href="#Chapter_111__Polymorphism_1">Chapter 111: Polymorphism</a>
..................................................................................................................................
<a href="#Chapter_111__Polymorphism_1">617</a></h1>
<p><a href="#Chapter_111__Polymorphism_1">Section 111.1: Method
Overriding
...............................................................................................................................
617</a></p>
<p><a href="#types">Section 111.2: Method Overloading
...........................................................................................................................
618</a></p>
<p><a href="#Overloaded_methods_may_be_static">Section 111.3:
Polymorphism and dierent types of overriding</a>
............................................................................
<a href="#Overloaded_methods_may_be_static">619</a></p>
<p><a href="#game_setRunGame_false">Section 111.4: Virtual functions</a>
..................................................................................................................................
<a href="#game_setRunGame_false">622</a></p>
<p><a href="#public_class_B_extends_A">Section 111.5: Adding behaviour
by adding classes without touching existing code</a>
.......................................... <a
href="#public_class_B_extends_A">623</a></p>
<h1
id="chapter-112-encapsulation-..................................................................................................................................-625"><a
href="#Chapter_112__Encapsulation_1">Chapter 112: Encapsulation</a>
..................................................................................................................................
<a href="#Chapter_112__Encapsulation_1">625</a></h1>
<p><a href="#Chapter_112__Encapsulation_1">Section 112.1: Encapsulation
to maintain invariants</a>
...............................................................................................
<a href="#Chapter_112__Encapsulation_1">625</a></p>
<p><a href="#_45">Section 112.2: Encapsulation to reduce coupling
....................................................................................................
626</a></p>
<p><span id="Chapter_113__Java_Agents" class="anchor"></span><a
href="#Chapter_113__Java_Agents_1">Chapter 113: Java Agents
......................................................................................................................................
627</a></p>
<p><a href="#Chapter_113__Java_Agents_1">Section 113.1: Modifying
classes with agents
...........................................................................................................
627</a></p>
<p><a href="#Chapter_113__Java_Agents_1">Section 113.2: Adding an agent
at runtime</a>
.............................................................................................................
<a href="#Chapter_113__Java_Agents_1">627</a></p>
<p><a href="#VirtualMachine_attatch_String_id">Section 113.3: Setting up
a basic agent
....................................................................................................................
628</a></p>
<h1
id="chapter-114-varargs-variable-argument-................................................................................................-629"><a
href="#Chapter_114__Varargs__Variable_A_1">Chapter 114: Varargs
(Variable Argument)</a>
................................................................................................
<a href="#Chapter_114__Varargs__Variable_A_1">629</a></h1>
<p><a href="#Chapter_114__Varargs__Variable_A_1">Section 114.1: Working
with Varargs parameters</a>
...................................................................................................
<a href="#Chapter_114__Varargs__Variable_A_1">629</a></p>
<p><a href="#Chapter_114__Varargs__Variable_A_1">Section 114.2:
Specifying a varargs parameter</a>
......................................................................................................
<a href="#Chapter_114__Varargs__Variable_A_1">629</a></p>
<h1
id="chapter-115-logging-java.util.logging-.......................................................................................................-630"><a
href="#Chapter_115__Logging__java_util_1">Chapter 115: Logging
(java.util.logging)</a>
.......................................................................................................
<a href="#Chapter_115__Logging__java_util_1">630</a></h1>
<p><a href="#Chapter_115__Logging__java_util_1">Section 115.1: Logging
complex messages (eciently)</a>
.........................................................................................
<a href="#Chapter_115__Logging__java_util_1">630</a></p>
<p><a href="#42__return">Section 115.2: Using the default logger</a>
...................................................................................................................
<a href="#42__return">631</a></p>
<p><a href="#___together_with_the_exception_m">Section 115.3: Logging
levels</a>
....................................................................................................................................
<a href="#___together_with_the_exception_m">632</a></p>
<h1
id="chapter-116-log4j-log4j2-..................................................................................................................................-634"><a
href="#Chapter_116__log4j___log4j2_1">Chapter 116: log4j / log4j2</a>
..................................................................................................................................
<a href="#Chapter_116__log4j___log4j2_1">634</a></h1>
<p><a href="#Chapter_116__log4j___log4j2_1">Section 116.1:
Properties-File to log to DB</a>
...............................................................................................................
<a href="#Chapter_116__log4j___log4j2_1">634</a></p>
<p><a href="#Chapter_116__log4j___log4j2_1">Section 116.2: How to get
Log4j
................................................................................................................................
634</a></p>
<p><a href="#Using_Ivy">Section 116.3: Setting up property file</a>
......................................................................................................................
<a href="#Using_Ivy">635</a></p>
<p><a href="#log4j_appender_stdout_layout_Con">Section 116.4: Basic
log4j2.xml configuration file</a>
...................................................................................................
<a href="#log4j_appender_stdout_layout_Con">636</a></p>
<p><a href="#log4j_appender_stdout_layout_Con">Section 116.5: How to use
Log4j in Java code</a>
........................................................................................................
<a href="#log4j_appender_stdout_layout_Con">636</a></p>
<p><a href="#isXXXEnabled">Section 116.6: Migrating from log4j 1.x to
2.x</a>
...........................................................................................................
<a href="#isXXXEnabled">637</a></p>
<p><a href="#dependencies">Section 116.7: Filter Logoutput by level
(log4j 1.x)
...................................................................................................
638</a></p>
<h1
id="chapter-117-oracle-ocial-code-standard-...............................................................................................-639"><a
href="#Chapter_117__Oracle_O_cial_Code_1">Chapter 117: Oracle Ocial
Code Standard</a>
...............................................................................................
<a href="#Chapter_117__Oracle_O_cial_Code_1">639</a></h1>
<p><a href="#Chapter_117__Oracle_O_cial_Code_1">Section 117.1: Naming
Conventions</a>
..........................................................................................................................
<a href="#Chapter_117__Oracle_O_cial_Code_1">639</a></p>
<p><a href="#Examples__T__V__SRC_VERTEX">Section 117.2: Class
Structure</a>
...................................................................................................................................
<a href="#Examples__T__V__SRC_VERTEX">640</a></p>
<p><a href="#Related_fields_should_be_grouped">Section 117.3:
Annotations</a>
.........................................................................................................................................
<a href="#Related_fields_should_be_grouped">641</a></p>
<p><a href="#Related_fields_should_be_grouped">Section 117.4: Import
statements</a>
.............................................................................................................................
<a href="#Related_fields_should_be_grouped">641</a></p>
<p><a href="#___Then_third_party_libraries">Section 117.5: Braces</a>
.................................................................................................................................................
<a href="#___Then_third_party_libraries">642</a></p>
<p><a href="#preceding_block">Section 117.6: Redundant Parentheses</a>
....................................................................................................................
<a href="#preceding_block">643</a></p>
<p><a href="#preceding_block">Section 117.7: Modifiers</a>
..............................................................................................................................................
<a href="#preceding_block">643</a></p>
<p><a href="#Modifiers_should_not_be_written">Section 117.8:
Indentation</a>
..........................................................................................................................................
<a href="#Modifiers_should_not_be_written">644</a></p>
<p><a href="#Modifiers_should_not_be_written">Section 117.9:
Literals</a>
.................................................................................................................................................
<a href="#Modifiers_should_not_be_written">644</a></p>
<p><a href="#Modifiers_should_not_be_written">Section 117.10: Package
declaration</a>
........................................................................................................................
<a href="#Modifiers_should_not_be_written">644</a></p>
<p><a href="#Modifiers_should_not_be_written">Section 117.11: Lambda
Expressions</a>
.........................................................................................................................
<a href="#Modifiers_should_not_be_written">644</a></p>
<p><a href="#___Collection__contains_is_a_sim">Section 117.12: Java
Source Files</a>
..............................................................................................................................
<a href="#___Collection__contains_is_a_sim">645</a></p>
<p><a href="#___Collection__contains_is_a_sim">Section 117.13: Wrapping
statements</a>
.......................................................................................................................
<a href="#___Collection__contains_is_a_sim">645</a></p>
<p><a href="#String_pretty___Stream_of_args">Section 117.14: Wrapping
Method Declarations</a>
......................................................................................................
<a href="#String_pretty___Stream_of_args">646</a></p>
<p><a href="#String_pretty___Stream_of_args">Section 117.15: Wrapping
Expressions</a>
......................................................................................................................
<a href="#String_pretty___Stream_of_args">646</a></p>
<p><a href="#popupMsg__Inbox_notification__Yo">Section 117.16:
Whitespace</a>
........................................................................................................................................
<a href="#popupMsg__Inbox_notification__Yo">647</a></p>
<p><a href="#popupMsg__Inbox_notification__Yo">Section 117.17: Special
Characters</a>
............................................................................................................................
<a href="#popupMsg__Inbox_notification__Yo">647</a></p>
<p><a href="#Section_117_18__Variable_Declara">Section 117.18: Variable
Declarations</a>
.......................................................................................................................
<a href="#Section_117_18__Variable_Declara">648</a></p>
<h1
id="chapter-118-character-encoding-.....................................................................................................................-649"><a
href="#Chapter_118__Character_encoding_1">Chapter 118: Character
encoding</a>
.....................................................................................................................
<a href="#Chapter_118__Character_encoding_1">649</a></h1>
<p><a href="#Chapter_118__Character_encoding_1">Section 118.1: Reading
text from a file encoded in UTF-8</a>
.....................................................................................
<a href="#Chapter_118__Character_encoding_1">649</a></p>
<p><a href="#Chapter_118__Character_encoding_1">Section 118.2: Writing
text to a file in UTF-8
............................................................................................................
649</a></p>
<p><a href="#Section_118_3__Getting_byte_repr">Section 118.3: Getting
byte representation of a string in UTF-8</a>
...........................................................................
<a href="#Section_118_3__Getting_byte_repr">650</a></p>
<h1
id="chapter-119-apache-commons-lang-.............................................................................................................-651"><a
href="#Chapter_119__Apache_Commons_Lang_1">Chapter 119: Apache Commons
Lang</a>
.............................................................................................................
<a href="#Chapter_119__Apache_Commons_Lang_1">651</a></h1>
<p><a href="#Chapter_119__Apache_Commons_Lang_1">Section 119.1:
Implement equals() method</a>
..............................................................................................................
<a href="#Chapter_119__Apache_Commons_Lang_1">651</a></p>
<p><a href="#Chapter_119__Apache_Commons_Lang_1">Section 119.2:
Implement hashCode() method</a>
.......................................................................................................
<a href="#Chapter_119__Apache_Commons_Lang_1">651</a></p>
<p><a href="#Using_reflection">Section 119.3: Implement toString()
method</a>
...........................................................................................................
<a href="#Using_reflection">652</a></p>
<h1
id="chapter-120-localization-and-internationalization-................................................................................-654"><a
href="#Chapter_120__Localization_and">Chapter 120: Localization and
Internationalization</a>
................................................................................
<a href="#Chapter_120__Localization_and">654</a></h1>
<p><a href="#Chapter_120__Localization_and">Section 120.1: Locale</a>
..................................................................................................................................................
<a href="#Chapter_120__Localization_and">654</a></p>
<p><a href="#Section_120_2__Automatically_for">Section 120.2:
Automatically formatted Dates using "locale"</a>
..............................................................................
<a href="#Section_120_2__Automatically_for">655</a></p>
<p><a href="#Section_120_2__Automatically_for">Section 120.3: String
Comparison</a>
............................................................................................................................
<a href="#Section_120_2__Automatically_for">655</a></p>
<p><span id="Chapter_121__Parallel_programmin" class="anchor"></span><a
href="#Chapter_121__Parallel_programmin_1">Chapter 121: Parallel
programming with Fork/Join framework</a>
...................................................... <a
href="#Chapter_121__Parallel_programmin_1">656</a></p>
<p><a href="#Chapter_121__Parallel_programmin_1">Section 121.1:
Fork/Join Tasks in Java</a>
....................................................................................................................
<a href="#Chapter_121__Parallel_programmin_1">656</a></p>
<h1
id="chapter-122-non-access-modifiers-.................................................................................................................-658"><a
href="#Chapter_122__Non_Access_Modifier_1">Chapter 122: Non-Access
Modifiers</a>
.................................................................................................................
<a href="#Chapter_122__Non_Access_Modifier_1">658</a></h1>
<p><a href="#Chapter_122__Non_Access_Modifier_1">Section 122.1:
final</a>
......................................................................................................................................................
<a href="#Chapter_122__Non_Access_Modifier_1">658</a></p>
<p><a href="#public_Test">Section 122.2: static</a>
...................................................................................................................................................
<a href="#public_Test">659</a></p>
<p><a href="#___We_can_access_static_variable">Section 122.3:
abstract</a>
..............................................................................................................................................
<a href="#___We_can_access_static_variable">660</a></p>
<p><a href="#class_can_never_be_instantiated">Section 122.4:
strictfp</a>
................................................................................................................................................
<a href="#class_can_never_be_instantiated">661</a></p>
<p><a href="#class_can_never_be_instantiated">Section 122.5:
volatile</a>
................................................................................................................................................
<a href="#class_can_never_be_instantiated">661</a></p>
<p><a href="#_46">Section 122.6: synchronized</a>
.....................................................................................................................................
<a href="#_46">662</a></p>
<p><a href="#_47">Section 122.7: transient</a>
.............................................................................................................................................
<a href="#_47">663</a></p>
<h1
id="chapter-123-process-...............................................................................................................................................-664"><a
href="#Chapter_123__Process_1">Chapter 123: Process</a>
...............................................................................................................................................
<a href="#Chapter_123__Process_1">664</a></h1>
<p><a href="#Chapter_123__Process_1">Section 123.1: Pitfall:
Runtime.exec, Process and ProcessBuilder don't understand shell syntax
...................... 664</a></p>
<p><a href="#one_exec_d_process_cannot_change">Section 123.2: Simple
example (Java version &lt; 1.5)</a>
...............................................................................................
<a href="#one_exec_d_process_cannot_change">666</a></p>
<h1
id="chapter-124-java-native-access-.....................................................................................................................-667"><a
href="#Chapter_124__Java_Native_Access_1">Chapter 124: Java Native
Access</a>
.....................................................................................................................
<a href="#Chapter_124__Java_Native_Access_1">667</a></h1>
<p><a href="#Chapter_124__Java_Native_Access_1">Section 124.1:
Introduction to JNA</a>
...........................................................................................................................
<a href="#Chapter_124__Java_Native_Access_1">667</a></p>
<p><span id="Chapter_125__Modules" class="anchor"></span><a
href="#Chapter_125__Modules_1">Chapter 125: Modules
..............................................................................................................................................
668</a></p>
<p><a href="#Chapter_125__Modules_1">Section 125.1: Defining a basic
module</a>
...................................................................................................................
<a href="#Chapter_125__Modules_1">668</a></p>
<h1
id="chapter-126-concurrent-programming-threads-..................................................................................-669"><a
href="#Chapter_126__Concurrent_Programm_1">Chapter 126: Concurrent
Programming (Threads)</a>
..................................................................................
<a href="#Chapter_126__Concurrent_Programm_1">669</a></h1>
<p><a href="#Chapter_126__Concurrent_Programm_1">Section 126.1: Callable
and Future</a>
...........................................................................................................................
<a href="#Chapter_126__Concurrent_Programm_1">669</a></p>
<p><a href="#public_class_ComplexCalculator_i">Section 126.2:
CountDownLatch
...............................................................................................................................
670</a></p>
<p><a href="#1__CountDownLatch_is_initialized">Section 126.3: Basic
Multithreading</a>
.........................................................................................................................
<a href="#1__CountDownLatch_is_initialized">672</a></p>
<p><a href="#Section_126_4__Locks_as_Synchron">Section 126.4: Locks as
Synchronisation aids
.........................................................................................................
673</a></p>
<p><a href="#Only_do_something_when_able_to_l">Section 126.5:
Semaphore</a>
........................................................................................................................................
<a href="#Only_do_something_when_able_to_l">674</a></p>
<p><a href="#available_acquire">Section 126.6: Synchronization</a>
.................................................................................................................................
<a href="#available_acquire">675</a></p>
<p><a href="#block_and_it_will_successfully_a">Section 126.7: Runnable
Object</a>
................................................................................................................................
<a href="#block_and_it_will_successfully_a">676</a></p>
<p><a href="#Example_1">Section 126.8: Creating basic deadlocked
system</a>
.................................................................................................
<a href="#Example_1">677</a></p>
<p><a href="#method2_wait_for_mLock2__Second">Section 126.9: Creating a
java.lang.Thread instance</a>
.............................................................................................
<a href="#method2_wait_for_mLock2__Second">679</a></p>
<p><a href="#You_can_specify_the_thread_s_nam">Section 126.10: Atomic
operations</a>
...........................................................................................................................
<a href="#You_can_specify_the_thread_s_nam">680</a></p>
<p><a href="#executorService_execute">Section 126.11: Exclusive write /
Concurrent read access</a>
......................................................................................
<a href="#executorService_execute">681</a></p>
<p><a href="#public_class_Sample">Section 126.12: Producer-Consumer</a>
........................................................................................................................
<a href="#public_class_Sample">682</a></p>
<p><a href="#Thread_consumer___new_Thread_new">Section 126.13:
Visualizing read/write barriers while using synchronized / volatile
........................................... 684</a></p>
<p><a href="#updates">Section 126.14: Get status of all threads started
by your program excluding system threads</a> ........................ <a
href="#updates">685</a></p>
<p><a href="#err_printStackTrace">Section 126.15: Using ThreadLocal</a>
...........................................................................................................................
<a href="#err_printStackTrace">686</a></p>
<p><a href="#which_eliminates_a_lot_of_the_do">Section 126.16: Multiple
producer/consumer example with shared global queue</a>
............................................. <a
href="#which_eliminates_a_lot_of_the_do">687</a></p>
<p><a href="#class_Consumer_implements_Runnab">Section 126.17: Add two
`int` arrays using a Threadpool</a>
.......................................................................................
<a href="#class_Consumer_implements_Runnab">688</a></p>
<p><a href="#The_following_example_shows_how">Section 126.18: Pausing
Execution</a>
............................................................................................................................
<a href="#The_following_example_shows_how">689</a></p>
<p><a href="#precise__and_some_implementation">Section 126.19: Thread
Interruption / Stopping Threads</a>
.......................................................................................
<a href="#precise__and_some_implementation">690</a></p>
<h1
id="chapter-127-executor-executorservice-and-thread-pools-................................................................-693"><a
href="#Chapter_127__Executor__ExecutorS_1">Chapter 127: Executor,
ExecutorService and Thread pools</a>
................................................................ <a
href="#Chapter_127__Executor__ExecutorS_1">693</a></h1>
<p><a href="#Chapter_127__Executor__ExecutorS_1">Section 127.1:
ThreadPoolExecutor</a>
..........................................................................................................................
<a href="#Chapter_127__Executor__ExecutorS_1">693</a></p>
<p><a href="#RejectedExecutionException_upon">Section 127.2: Retrieving
value from computation - Callable
...............................................................................
694</a></p>
<p><a href="#___handle_appropriately">Section 127.3: submit() vs
execute() exception handling dierences</a>
.................................................................. <a
href="#___handle_appropriately">695</a></p>
<p><a href="#Other_simple_solution_to_above_p">Section 127.4: Handle
Rejected Execution</a>
..............................................................................................................
<a href="#Other_simple_solution_to_above_p">697</a></p>
<p><a href="#Other_simple_solution_to_above_p">Section 127.5: Fire and
Forget - Runnable Tasks</a>
...................................................................................................
<a href="#Other_simple_solution_to_above_p">697</a></p>
<p><a href="#_49">Section 127.6: Use cases for dierent types of
concurrency constructs
.............................................................
698</a></p>
<p><a href="#3__In_ThreadPoolExecutor_Discard">Section 127.7: Wait for
completion of all tasks in ExecutorService</a>
......................................................................
<a href="#3__In_ThreadPoolExecutor_Discard">699</a></p>
<p><a href="#__catch__InterruptedException_ie">Section 127.8: Use cases
for dierent types of ExecutorService
..........................................................................
701</a></p>
<p><a href="#Creates_a_work_stealing_thread_p">Section 127.9: Scheduling
tasks to run at a fixed time, after a delay or repeatedly</a>
.......................................... <a
href="#Creates_a_work_stealing_thread_p">703</a></p>
<p><a href="#ScheduledFuturenew_Runnable">Section 127.10: Using Thread
Pools</a>
.........................................................................................................................
<a href="#ScheduledFuturenew_Runnable">704</a></p>
<h1
id="chapter-128-threadlocal-....................................................................................................................................-705"><a
href="#Chapter_128__ThreadLocal_1">Chapter 128: ThreadLocal</a>
....................................................................................................................................
<a href="#Chapter_128__ThreadLocal_1">705</a></h1>
<p><a href="#Chapter_128__ThreadLocal_1">Section 128.1: Basic
ThreadLocal usage
..................................................................................................................
705</a></p>
<p><a href="#Thread_sleep_new_Random___nextIn">Section 128.2:
ThreadLocal Java 8 functional initialization</a>
..................................................................................
<a href="#Thread_sleep_new_Random___nextIn">706</a></p>
<p><a href="#private_static_final_ThreadLocal">Section 128.3: Multiple
threads with one shared object</a>
........................................................................................
<a href="#private_static_final_ThreadLocal">707</a></p>
<p><span id="Chapter_129__Using_ThreadPoolExe" class="anchor"></span><a
href="#Chapter_129__Using_ThreadPoolExe_1">Chapter 129: Using
ThreadPoolExecutor in MultiThreaded applications.</a>
.................................... <a
href="#Chapter_129__Using_ThreadPoolExe_1">709</a></p>
<p><a href="#Chapter_129__Using_ThreadPoolExe_1">Section 129.1:
Performing Asynchronous Tasks Where No Return Value Is Needed Using a
Runnable Class</a></p>
<p><a href="#Chapter_129__Using_ThreadPoolExe_1">Instance</a>
..............................................................................................................................................................
<a href="#Chapter_129__Using_ThreadPoolExe_1">709</a></p>
<p><a href="#executorService_shutdown">Section 129.2: Performing
Asynchronous Tasks Where a Return Value Is Needed Using a Callable
Class</a></p>
<p><a href="#executorService_shutdown">Instance</a>
..............................................................................................................................................................
<a href="#executorService_shutdown">710</a></p>
<p><a href="#INFO__A_task_just_completed_afte">Section 129.3: Defining
Asynchronous Tasks Inline using Lambdas</a>
.................................................................... <a
href="#INFO__A_task_just_completed_afte">713</a></p>
<h1
id="chapter-130-common-java-pitfalls-................................................................................................................-715"><a
href="#Chapter_130__Common_Java_Pitfall_1">Chapter 130: Common Java
Pitfalls</a>
................................................................................................................
<a href="#Chapter_130__Common_Java_Pitfall_1">715</a></h1>
<p><a href="#Chapter_130__Common_Java_Pitfall_1">Section 130.1: Pitfall:
using == to compare primitive wrappers objects such as Integer
..................................... 715</a></p>
<p><a href="#Chapter_130__Common_Java_Pitfall_1">Section 130.2: Pitfall:
using == to compare strings</a>
.................................................................................................
<a href="#Chapter_130__Common_Java_Pitfall_1">715</a></p>
<p><a href="#To_add_to_the_confusion__the_Jav">Section 130.3: Pitfall:
forgetting to free resources</a>
.................................................................................................
<a href="#To_add_to_the_confusion__the_Jav">717</a></p>
<p><a href="#private_static_void_printFileJav">Section 130.4: Pitfall:
testing a file before attempting to open it</a>
..........................................................................
<a href="#private_static_void_printFileJav">718</a></p>
<p><a href="#The_second_problem_is_that_check">Section 130.5: Pitfall:
thinking of variables as objects</a>
...........................................................................................
<a href="#The_second_problem_is_that_check">719</a></p>
<p><a href="#_50">Section 130.6: Pitfall: memory leaks</a>
........................................................................................................................
<a href="#_50">722</a></p>
<p><a href="#BigDecimal_number___numbers_peek">Section 130.7: Pitfall:
Not understanding that String is an immutable class</a>
....................................................... <a
href="#BigDecimal_number___numbers_peek">723</a></p>
<p><a href="#So_in_order_to_use_this_method_e">Section 130.8: Pitfall:
combining assignment and side-eects</a>
.............................................................................
<a href="#So_in_order_to_use_this_method_e">724</a></p>
<h1
id="chapter-131-java-pitfalls---exception-usage-..............................................................................................-725"><a
href="#Chapter_131__Java_Pitfalls___Exc_1">Chapter 131: Java Pitfalls -
Exception usage</a>
..............................................................................................
<a href="#Chapter_131__Java_Pitfalls___Exc_1">725</a></h1>
<p><a href="#Chapter_131__Java_Pitfalls___Exc_1">Section 131.1: Pitfall
- Catching Throwable, Exception, Error or RuntimeException</a>
............................................ <a
href="#Chapter_131__Java_Pitfalls___Exc_1">725</a></p>
<p><a href="#or_you_can_declare_them_as_throw">Section 131.2: Pitfall -
Ignoring or squashing exceptions</a>
.......................................................................................
<a href="#or_you_can_declare_them_as_throw">726</a></p>
<p><a href="#_51">Section 131.3: Pitfall - Throwing Throwable,
Exception, Error or RuntimeException</a>
........................................... <a href="#_51">727</a></p>
<p><a href="#3__Handling_Exception_properly_i">Section 131.4: Pitfall -
Using exceptions for normal flowcontrol</a>
...........................................................................
<a href="#3__Handling_Exception_properly_i">728</a></p>
<p><a href="#magnitude__slower_than_the_first">Section 131.5: Pitfall -
Directly subclassing `Throwable`</a>
.........................................................................................
<a href="#magnitude__slower_than_the_first">729</a></p>
<p><a href="#magnitude__slower_than_the_first">Section 131.6: Pitfall -
Catching InterruptedException</a>
............................................................................................
<a href="#magnitude__slower_than_the_first">729</a></p>
<p><a href="#Thread_currentThread___interrupt">Section 131.7: Pitfall -
Excessive or inappropriate stacktraces
..............................................................................
731</a></p>
<h1
id="chapter-132-java-pitfalls---language-syntax-...........................................................................................-732"><a
href="#Chapter_132__Java_Pitfalls___Lan_1">Chapter 132: Java Pitfalls -
Language syntax</a>
...........................................................................................
<a href="#Chapter_132__Java_Pitfalls___Lan_1">732</a></h1>
<p><a href="#Chapter_132__Java_Pitfalls___Lan_1">Section 132.1: Pitfall
- Missing a ‘break’ in a 'switch' case</a>
......................................................................................
<a href="#Chapter_132__Java_Pitfalls___Lan_1">732</a></p>
<p><a href="#Chapter_132__Java_Pitfalls___Lan_1">Section 132.2: Pitfall
- Declaring classes with the same names as standard classes</a>
........................................ <a
href="#Chapter_132__Java_Pitfalls___Lan_1">732</a></p>
<p><a href="#__My_string_utilities">Section 132.3: Pitfall - Leaving out
braces: the "dangling if" and "dangling else" problems</a>
............................. <a
href="#__My_string_utilities">733</a></p>
<p><a href="#doZ">Section 132.4: Pitfall - Octal literals</a>
..........................................................................................................................
<a href="#doZ">735</a></p>
<p><a href="#doZ">Section 132.5: Pitfall - Using '==' to test a
boolean</a>
.................................................................................................
<a href="#doZ">735</a></p>
<p><a href="#if__ok___true__________________O">Section 132.6: Pitfall -
Ignoring method visibility</a>
....................................................................................................
<a href="#if__ok___true__________________O">736</a></p>
<p><a href="#if__ok___true__________________O">Section 132.7: Pitfall:
Using 'assert' for argument or user input validation</a>
......................................................... <a
href="#if__ok___true__________________O">736</a></p>
<p><a href="#assertions_will_be_evaluated__Th">Section 132.8: Pitfall -
Wildcard imports can make your code fragile</a>
................................................................. <a
href="#assertions_will_be_evaluated__Th">737</a></p>
<p><a href="#Section_132_9__Pitfall___Misplac">Section 132.9: Pitfall -
Misplaced semicolons and missing braces</a>
.......................................................................
<a href="#Section_132_9__Pitfall___Misplac">738</a></p>
<p><a href="#code">Section 132.10: Pitfall - Overloading instead of
overriding</a>
....................................................................................
<a href="#code">739</a></p>
<p><a href="#polymorphic_context">Section 132.11: Pitfall of
Auto-Unboxing Null Objects into Primitives</a>
.................................................................... <a
href="#polymorphic_context">740</a></p>
<p><span id="Chapter_133__Java_Pitfalls___Thr" class="anchor"></span><a
href="#Chapter_133__Java_Pitfalls___Thr_1">Chapter 133: Java Pitfalls -
Threads and Concurrency
.........................................................................
741</a></p>
<p><a href="#Chapter_133__Java_Pitfalls___Thr_1">Section 133.1: Pitfall
- Extending 'java.lang.Thread'</a>
................................................................................................
<a href="#Chapter_133__Java_Pitfalls___Thr_1">741</a></p>
<p><a href="#examples_above">Section 133.2: Pitfall - Too many threads
makes an application slower</a>
............................................................. <a
href="#examples_above">742</a></p>
<p><a href="#Section_133_3__Pitfall__incorrec">Section 133.3: Pitfall:
incorrect use of wait() / notify()</a>
...........................................................................................
<a href="#Section_133_3__Pitfall__incorrec">743</a></p>
<p><a href="#Section_133_3__Pitfall__incorrec">Section 133.4: Pitfall:
Shared variables require proper synchronization</a>
.............................................................. <a
href="#Section_133_3__Pitfall__incorrec">743</a></p>
<p><a href="#invalidate_their_cached_copy_of">Section 133.5: Pitfall -
Thread creation is relatively expensive</a>
.............................................................................
<a href="#invalidate_their_cached_copy_of">746</a></p>
<h1
id="chapter-134-java-pitfalls---nulls-and-nullpointerexception-.............................................................-749"><a
href="#Chapter_134__Java_Pitfalls___Nul_1">Chapter 134: Java Pitfalls -
Nulls and NullPointerException</a>
............................................................. <a
href="#Chapter_134__Java_Pitfalls___Nul_1">749</a></h1>
<p><a href="#Chapter_134__Java_Pitfalls___Nul_1">Section 134.1: Pitfall
- "Making good" unexpected nulls
.........................................................................................
749</a></p>
<p><a href="#If_null_is_a_meaningful_value__t">Section 134.2: Pitfall -
Using null to represent an empty array or collection</a>
...................................................... <a
href="#If_null_is_a_meaningful_value__t">750</a></p>
<p><a href="#int___values___new_int_0">Section 134.3: Pitfall - Not
checking if an I/O stream isn't even initialized when closing it</a>
............................... <a
href="#int___values___new_int_0">751</a></p>
<p><a href="#int___values___new_int_0">Section 134.4: Pitfall -
Returning null instead of throwing an exception</a>
.............................................................. <a
href="#int___values___new_int_0">751</a></p>
<p><a href="#public_Reader_getReader_String_p">Section 134.5: Pitfall -
Unnecessary use of Primitive Wrappers can lead to
NullPointerExceptions</a> ................ <a
href="#public_Reader_getReader_String_p">752</a></p>
<p><a href="#If_the_fields_c_and_d_need_to_be">Section 134.6: Pitfall -
Using "Yoda notation" to avoid NullPointerException</a>
...................................................... <a
href="#If_the_fields_c_and_d_need_to_be">753</a></p>
<h1
id="chapter-135-java-pitfalls---performance-issues-......................................................................................-754"><a
href="#Chapter_135__Java_Pitfalls___Per_1">Chapter 135: Java Pitfalls -
Performance Issues</a>
......................................................................................
<a href="#Chapter_135__Java_Pitfalls___Per_1">754</a></h1>
<p><a href="#Chapter_135__Java_Pitfalls___Per_1">Section 135.1: Pitfall
- String concatenation in a loop does not scale</a>
.................................................................. <a
href="#Chapter_135__Java_Pitfalls___Per_1">754</a></p>
<p><a href="#tmp_append_message__append">Section 135.2: Pitfall - Using
size() to test if a collection is empty is inecient</a>
.................................................. <a
href="#tmp_append_message__append">755</a></p>
<p><a href="#tmp_append_message__append">Section 135.3: Pitfall -
Interning strings so that you can use == is a bad idea</a>
..................................................... <a
href="#tmp_append_message__append">755</a></p>
<p><a href="#The_hashcode_algorithm_for_strin">Section 135.4: Pitfall -
Using 'new' to create primitive wrapper instances is inecient</a>
..................................... <a
href="#The_hashcode_algorithm_for_strin">757</a></p>
<p><a href="#The_hashcode_algorithm_for_strin">Section 135.5: Pitfall -
Eciency concerns with regular expressions</a>
................................................................... <a
href="#The_hashcode_algorithm_for_strin">757</a></p>
<p><a href="#The_above_example_is_clearly_con">Section 135.6: Pitfall -
Small reads / writes on unbuered streams are inecient</a>
........................................... <a
href="#The_above_example_is_clearly_con">760</a></p>
<p><a href="#4__adjusting_thstream_pointerse">Section 135.7: Pitfall -
Over-use of primitive wrapper types is inecient
............................................................ 762</a></p>
<p><a href="#In_addition_to_that__the_second">Section 135.8: Pitfall -
The overheads of creating log messages</a>
.........................................................................
<a href="#In_addition_to_that__the_second">763</a></p>
<p><a href="#_52">Section 135.9: Pitfall - Iterating a Map's keys can be
inecient</a>
...........................................................................
<a href="#_52">764</a></p>
<p><a href="#_52">Section 135.10: Pitfall - Calling System.gc() is
inecient</a>
.......................................................................................
<a href="#_52">764</a></p>
<p><a href="#Third__running_a_full_garbage_co">Section 135.11: Pitfall -
Calling 'new String(String)' is inecient</a>
............................................................................
<a href="#Third__running_a_full_garbage_co">765</a></p>
<h1
id="chapter-136-serviceloader-................................................................................................................................-766"><a
href="#Chapter_136__ServiceLoader_1">Chapter 136: ServiceLoader</a>
................................................................................................................................
<a href="#Chapter_136__ServiceLoader_1">766</a></h1>
<p><a href="#Chapter_136__ServiceLoader_1">Section 136.1: Simple
ServiceLoader Example</a>
........................................................................................................
<a href="#Chapter_136__ServiceLoader_1">766</a></p>
<p><a href="#ServiceLoader_loader___ServiceLo">Section 136.2: Logger
Service
...................................................................................................................................
767</a></p>
<h1
id="chapter-137-classloaders-....................................................................................................................................-769"><a
href="#Chapter_137__Classloaders_1">Chapter 137: Classloaders</a>
....................................................................................................................................
<a href="#Chapter_137__Classloaders_1">769</a></h1>
<p><a href="#Chapter_137__Classloaders_1">Section 137.1: Implementing a
custom classLoader
...............................................................................................
769</a></p>
<p><a href="#Chapter_137__Classloaders_1">Section 137.2: Loading an
external .class file
..........................................................................................................
769</a></p>
<p><a href="#To_access_it__what_we_will_do_is">Section 137.3:
Instantiating and using a classloader</a>
.............................................................................................
<a href="#To_access_it__what_we_will_do_is">770</a></p>
<h1
id="chapter-138-creating-images-programmatically-...................................................................................-772"><a
href="#Chapter_138__Creating_Images">Chapter 138: Creating Images
Programmatically</a>
...................................................................................
<a href="#Chapter_138__Creating_Images">772</a></h1>
<p><a href="#Chapter_138__Creating_Images">Section 138.1: Creating a
simple image programmatically and displaying it</a>
..................................................... <a
href="#Chapter_138__Creating_Images">772</a></p>
<p><a href="#page_797">Section 138.2: Save an Image to disk</a>
......................................................................................................................
<a href="#page_797">773</a></p>
<p><a href="#page_797">Section 138.3: Setting individual pixel's color
in BueredImage</a>
...........................................................................
<a href="#page_797">773</a></p>
<p><a href="#Output">Section 138.4: Specifying image rendering
quality</a>
................................................................................................
<a href="#Output">774</a></p>
<p><a href="#page_800">Section 138.5: Creating an image with
BueredImage class</a>
...............................................................................
<a href="#page_800">776</a></p>
<p><a href="#page_801">Section 138.6: Editing and re-using image with
BueredImage
...........................................................................
777</a></p>
<p><a href="#page_802">Section 138.7: How to scale a BueredImage</a>
........................................................................................................
<a href="#page_802">778</a></p>
<h1
id="chapter-139-atomic-types-..................................................................................................................................-779"><a
href="#Chapter_139__Atomic_Types_1">Chapter 139: Atomic Types</a>
..................................................................................................................................
<a href="#Chapter_139__Atomic_Types_1">779</a></h1>
<p><a href="#Chapter_139__Atomic_Types_1">Section 139.1: Creating Atomic
Types</a>
......................................................................................................................
<a href="#Chapter_139__Atomic_Types_1">779</a></p>
<p><a href="#Chapter_139__Atomic_Types_1">Section 139.2: Motivation for
Atomic Types
............................................................................................................
779</a></p>
<h1
id="chapter-140-rsa-encryption-.............................................................................................................................-783"><a
href="#Chapter_140__RSA_Encryption_1">Chapter 140: RSA Encryption</a>
.............................................................................................................................
<a href="#Chapter_140__RSA_Encryption_1">783</a></h1>
<p><a href="#Chapter_140__RSA_Encryption_1">Section 140.1: An example
using a hybrid cryptosystem consisting of OAEP and GCM</a>
.................................... <a
href="#Chapter_140__RSA_Encryption_1">783</a></p>
<h1
id="chapter-141-secure-objects-................................................................................................................................-788"><a
href="#Chapter_141__Secure_objects_1">Chapter 141: Secure objects</a>
................................................................................................................................
<a href="#Chapter_141__Secure_objects_1">788</a></h1>
<p><a href="#Chapter_141__Secure_objects_1">Section 141.1: SealedObject
(javax.crypto.SealedObject)</a>
......................................................................................
<a href="#Chapter_141__Secure_objects_1">788</a></p>
<p><a href="#Chapter_141__Secure_objects_1">Section 141.2: SignedObject
(java.security.SignedObject)</a>
.....................................................................................
<a href="#Chapter_141__Secure_objects_1">788</a></p>
<h1
id="chapter-142-security-cryptography-.........................................................................................................-790"><a
href="#Chapter_142__Security___Cryptogr_1">Chapter 142: Security &amp;
Cryptography</a>
.........................................................................................................
<a href="#Chapter_142__Security___Cryptogr_1">790</a></h1>
<p><a href="#Chapter_142__Security___Cryptogr_1">Section 142.1: Compute
Cryptographic Hashes
......................................................................................................
790</a></p>
<p><a href="#Chapter_142__Security___Cryptogr_1">Section 142.2: Encrypt
and Decrypt Data with Public / Private Keys</a>
.................................................................. <a
href="#Chapter_142__Security___Cryptogr_1">790</a></p>
<p><a href="#System_out_println__Decrypted">Section 142.3: Generate
Cryptographically Random Data</a>
...................................................................................
<a href="#System_out_println__Decrypted">791</a></p>
<p><a href="#System_out_println__Decrypted">Section 142.4: Generate
Public / Private Key Pairs
................................................................................................
791</a></p>
<p><a href="#Additional_algorithms_and_key_si">Section 142.5: Compute
and Verify Digital Signatures</a>
..........................................................................................
<a href="#Additional_algorithms_and_key_si">792</a></p>
<h1
id="chapter-143-security-cryptography-.........................................................................................................-793"><a
href="#Chapter_143__Security___Cryptogr_1">Chapter 143: Security &amp;
Cryptography</a>
.........................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></h1>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.1: The
JCE</a>
...............................................................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.2: Keys and
Key Management</a>
............................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.3: Common
Java vulnerabilities</a>
..........................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.4:
Networking Concerns</a>
.......................................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.5:
Randomness and You</a>
.......................................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<p><a href="#Chapter_143__Security___Cryptogr_1">Section 143.6: Hashing
and Validation</a>
....................................................................................................................
<a href="#Chapter_143__Security___Cryptogr_1">793</a></p>
<h1
id="chapter-144-securitymanager-.........................................................................................................................-795"><a
href="#Chapter_144__SecurityManager_1">Chapter 144: SecurityManager</a>
.........................................................................................................................
<a href="#Chapter_144__SecurityManager_1">795</a></h1>
<p><a href="#Chapter_144__SecurityManager_1">Section 144.1: Sandboxing
classes loaded by a ClassLoader</a>
...............................................................................
<a href="#Chapter_144__SecurityManager_1">795</a></p>
<p><a href="#public_PermissionCollection_getP">Section 144.2: Enabling
the SecurityManager</a>
........................................................................................................
<a href="#public_PermissionCollection_getP">796</a></p>
<p><a href="#public_PermissionCollection_getP">Section 144.3:
Implementing policy deny rules</a>
......................................................................................................
<a href="#public_PermissionCollection_getP">796</a></p>
<h1
id="chapter-145-jndi-....................................................................................................................................................-804"><a
href="#Chapter_145__JNDI_1">Chapter 145: JNDI</a>
....................................................................................................................................................
<a href="#Chapter_145__JNDI_1">804</a></h1>
<p><a href="#Chapter_145__JNDI_1">Section 145.1: RMI through JNDI</a>
..............................................................................................................................
<a href="#Chapter_145__JNDI_1">804</a></p>
<h1
id="chapter-146-sun.misc.unsafe-............................................................................................................................-808"><a
href="#Chapter_146__sun_misc_Unsafe_1">Chapter 146: sun.misc.Unsafe</a>
............................................................................................................................
<a href="#Chapter_146__sun_misc_Unsafe_1">808</a></h1>
<p><a href="#Chapter_146__sun_misc_Unsafe_1">Section 146.1:
Instantiating sun.misc.Unsafe via reflection</a>
....................................................................................
<a href="#Chapter_146__sun_misc_Unsafe_1">808</a></p>
<p><a href="#Chapter_146__sun_misc_Unsafe_1">Section 146.2:
Instantiating sun.misc.Unsafe via bootclasspath
...........................................................................
808</a></p>
<p><a href="#Chapter_146__sun_misc_Unsafe_1">Section 146.3: Getting
Instance of Unsafe</a>
..............................................................................................................
<a href="#Chapter_146__sun_misc_Unsafe_1">808</a></p>
<p><a href="#_57">Section 146.4: Uses of Unsafe</a>
..................................................................................................................................
<a href="#_57">809</a></p>
<h1
id="chapter-147-java-memory-model-...................................................................................................................-810"><a
href="#Chapter_147__Java_Memory_Model_1">Chapter 147: Java Memory
Model</a>
...................................................................................................................
<a href="#Chapter_147__Java_Memory_Model_1">810</a></h1>
<p><a href="#Chapter_147__Java_Memory_Model_1">Section 147.1: Motivation
for the Memory Model
....................................................................................................
810</a></p>
<p><a href="#But_even_with_this__it_is_import">Section 147.2:
Happens-before relationships</a>
.........................................................................................................
<a href="#But_even_with_this__it_is_import">812</a></p>
<p><a href="#Program_Order_and_Synchronizatio">Section 147.3: How to
avoid needing to understand the Memory Model</a>
............................................................ <a
href="#Program_Order_and_Synchronizatio">813</a></p>
<p><a href="#If_you_adopt_the_following_princ">Section 147.4:
Happens-before reasoning applied to some examples</a>
............................................................... <a
href="#If_you_adopt_the_following_princ">814</a></p>
<p><span id="Chapter_148__Java_deployment" class="anchor"></span><a
href="#Chapter_148__Java_deployment_1">Chapter 148: Java deployment
.........................................................................................................................
817</a></p>
<p><a href="#Chapter_148__Java_deployment_1">Section 148.1: Making an
executable JAR from the command line</a>
..................................................................... <a
href="#Chapter_148__Java_deployment_1">817</a></p>
<p><a href="#Section_148_2__Creating_an_UberJ">Section 148.2: Creating
an UberJAR for an application and its dependencies</a>
.................................................. <a
href="#Section_148_2__Creating_an_UberJ">818</a></p>
<p><a href="#You_cannot_break_the_library_dep">Section 148.3: Creating
JAR, WAR and EAR files</a>
...................................................................................................
<a href="#You_cannot_break_the_library_dep">819</a></p>
<p><a href="#Eclipse___http___stackoverflow_c">Section 148.4:
Introduction to Java Web Start</a>
.......................................................................................................
<a href="#Eclipse___http___stackoverflow_c">820</a></p>
<h1
id="chapter-149-java-plugin-system-implementations-...............................................................................-823"><a
href="#Chapter_149__Java_plugin_system_1">Chapter 149: Java plugin
system implementations</a>
...............................................................................
<a href="#Chapter_149__Java_plugin_system_1">823</a></h1>
<p><a href="#Chapter_149__Java_plugin_system_1">Section 149.1: Using
URLClassLoader</a>
......................................................................................................................
<a href="#Chapter_149__Java_plugin_system_1">823</a></p>
<h1
id="chapter-150-javabean-.........................................................................................................................................-827"><a
href="#Chapter_150__JavaBean_1">Chapter 150: JavaBean</a>
.........................................................................................................................................
<a href="#Chapter_150__JavaBean_1">827</a></h1>
<p><a href="#Chapter_150__JavaBean_1">Section 150.1: Basic Java Bean</a>
................................................................................................................................
<a href="#Chapter_150__JavaBean_1">827</a></p>
<h1
id="chapter-151-java-se-7-features-.......................................................................................................................-828"><a
href="#Chapter_151__Java_SE_7_Features_1">Chapter 151: Java SE 7
Features</a>
.......................................................................................................................
<a href="#Chapter_151__Java_SE_7_Features_1">828</a></h1>
<p><a href="#Chapter_151__Java_SE_7_Features_1">Section 151.1: New Java
SE 7 programming language features</a>
..........................................................................
<a href="#Chapter_151__Java_SE_7_Features_1">828</a></p>
<p><a href="#Chapter_151__Java_SE_7_Features_1">Section 151.2: Binary
Literals</a>
....................................................................................................................................
<a href="#Chapter_151__Java_SE_7_Features_1">828</a></p>
<p><a href="#Chapter_151__Java_SE_7_Features_1">Section 151.3: The
try-with-resources statement</a>
...................................................................................................
<a href="#Chapter_151__Java_SE_7_Features_1">828</a></p>
<p><a href="#_58">Section 151.4: Underscores in Numeric Literals</a>
......................................................................................................
<a href="#_58">829</a></p>
<p><a href="#_58">Section 151.5: Type Inference for Generic Instance
Creation
................................................................................
829</a></p>
<p><a href="#_58">Section 151.6: Strings in switch Statements</a>
.............................................................................................................
<a href="#_58">829</a></p>
<h1
id="chapter-152-java-se-8-features-......................................................................................................................-831"><a
href="#Chapter_152__Java_SE_8_Features_1">Chapter 152: Java SE 8
Features</a>
......................................................................................................................
<a href="#Chapter_152__Java_SE_8_Features_1">831</a></h1>
<p><a href="#Chapter_152__Java_SE_8_Features_1">Section 152.1: New Java
SE 8 programming language features</a>
.........................................................................
<a href="#Chapter_152__Java_SE_8_Features_1">831</a></p>
<h1
id="chapter-153-dynamic-method-dispatch-.......................................................................................................-832"><a
href="#Chapter_153__Dynamic_Method_Disp_1">Chapter 153: Dynamic Method
Dispatch</a>
.......................................................................................................
<a href="#Chapter_153__Dynamic_Method_Disp_1">832</a></h1>
<p><a href="#Chapter_153__Dynamic_Method_Disp_1">Section 153.1: Dynamic
Method Dispatch - Example Code</a>
...................................................................................
<a href="#Chapter_153__Dynamic_Method_Disp_1">832</a></p>
<h1
id="chapter-154-generating-java-code-..............................................................................................................-835"><a
href="#Chapter_154__Generating_Java_Cod_1">Chapter 154: Generating Java
Code</a>
..............................................................................................................
<a href="#Chapter_154__Generating_Java_Cod_1">835</a></h1>
<p><a href="#Chapter_154__Generating_Java_Cod_1">Section 154.1: Generate
POJO From JSON</a>
.............................................................................................................
<a href="#Chapter_154__Generating_Java_Cod_1">835</a></p>
<h1
id="chapter-155-jshell-..................................................................................................................................................-836"><a
href="#Chapter_155__JShell_1">Chapter 155: JShell</a>
..................................................................................................................................................
<a href="#Chapter_155__JShell_1">836</a></h1>
<p><a href="#Chapter_155__JShell_1">Section 155.1: Editting Snippets</a>
................................................................................................................................
<a href="#Chapter_155__JShell_1">836</a></p>
<p><a href="#To_delete_all_snippets__thereby">Section 155.2: Entering
and Exiting JShell
...............................................................................................................
837</a></p>
<p><a href="#To_delete_all_snippets__thereby">Section 155.3:
Expressions</a>
........................................................................................................................................
<a href="#To_delete_all_snippets__thereby">837</a></p>
<p><a href="#Section_155_4__Methods_and_Class">Section 155.4: Methods
and Classes</a>
........................................................................................................................
<a href="#Section_155_4__Methods_and_Class">838</a></p>
<p><a href="#Section_155_4__Methods_and_Class">Section 155.5:
Variables</a>
............................................................................................................................................
<a href="#Section_155_4__Methods_and_Class">838</a></p>
<h1
id="chapter-156-stack-walking-api-........................................................................................................................-839"><a
href="#Chapter_156__Stack_Walking_API_1">Chapter 156: Stack-Walking
API</a>
........................................................................................................................
<a href="#Chapter_156__Stack_Walking_API_1">839</a></h1>
<p><a href="#Chapter_156__Stack_Walking_API_1">Section 156.1: Print all
stack frames of the current thread
....................................................................................
839</a></p>
<p><a href="#Section_156_2__Print_current_cal">Section 156.2: Print
current caller class</a>
...................................................................................................................
<a href="#Section_156_2__Print_current_cal">840</a></p>
<p><a href="#Section_156_2__Print_current_cal">Section 156.3: Showing
reflection and other hidden frames</a>
.................................................................................
<a href="#Section_156_2__Print_current_cal">840</a></p>
<h1
id="chapter-157-sockets-..............................................................................................................................................-842"><a
href="#Chapter_157__Sockets_1">Chapter 157: Sockets</a>
..............................................................................................................................................
<a href="#Chapter_157__Sockets_1">842</a></h1>
<p><a href="#Chapter_157__Sockets_1">Section 157.1: Read from socket</a>
..............................................................................................................................
<a href="#Chapter_157__Sockets_1">842</a></p>
<h1
id="chapter-158-java-sockets-..................................................................................................................................-843"><a
href="#Chapter_158__Java_Sockets_1">Chapter 158: Java Sockets</a>
..................................................................................................................................
<a href="#Chapter_158__Java_Sockets_1">843</a></h1>
<p><a href="#Chapter_158__Java_Sockets_1">Section 158.1: A simple TCP
echo back server</a>
........................................................................................................
<a href="#Chapter_158__Java_Sockets_1">843</a></p>
<h1
id="chapter-159-ftp-file-transfer-protocol-....................................................................................................-846"><a
href="#Chapter_159__FTP__File_Transfer_1">Chapter 159: FTP (File
Transfer Protocol)</a>
....................................................................................................
<a href="#Chapter_159__FTP__File_Transfer_1">846</a></h1>
<p><a href="#Chapter_159__FTP__File_Transfer_1">Section 159.1:
Connecting and Logging Into a FTP Server</a>
....................................................................................
<a href="#Chapter_159__FTP__File_Transfer_1">846</a></p>
<h1
id="chapter-160-using-other-scripting-languages-in-java-.......................................................................-851"><a
href="#Chapter_160__Using_Other_Scripti_1">Chapter 160: Using Other
Scripting Languages in Java</a>
.......................................................................
<a href="#Chapter_160__Using_Other_Scripti_1">851</a></h1>
<p><a href="#Chapter_160__Using_Other_Scripti_1">Section 160.1:
Evaluating A JavaScript file in -scripting mode of nashorn</a>
.......................................................... <a
href="#Chapter_160__Using_Other_Scripti_1">851</a></p>
<h1
id="chapter-161-c-comparison-.............................................................................................................................-854"><a
href="#Chapter_161__C___Comparison_1">Chapter 161: C++ Comparison</a>
.............................................................................................................................
<a href="#Chapter_161__C___Comparison_1">854</a></h1>
<p><a href="#Chapter_161__C___Comparison_1">Section 161.1: Static Class
Members</a>
.........................................................................................................................
<a href="#Chapter_161__C___Comparison_1">854</a></p>
<p><a href="#Chapter_161__C___Comparison_1">Section 161.2: Classes
Defined within Other Constructs</a>
........................................................................................
<a href="#Chapter_161__C___Comparison_1">854</a></p>
<p><a href="#Section_161_3__Pass_by_value___P">Section 161.3:
Pass-by-value &amp; Pass-by-reference</a>
................................................................................................
<a href="#Section_161_3__Pass_by_value___P">856</a></p>
<p><a href="#Section_161_4__Inheritance_vs_Co">Section 161.4:
Inheritance vs Composition</a>
..............................................................................................................
<a href="#Section_161_4__Inheritance_vs_Co">857</a></p>
<p><a href="#Section_161_4__Inheritance_vs_Co">Section 161.5: Outcast
Downcasting</a>
........................................................................................................................
<a href="#Section_161_4__Inheritance_vs_Co">857</a></p>
<p><a href="#Section_161_4__Inheritance_vs_Co">Section 161.6: Abstract
Methods &amp; Classes</a>
.............................................................................................................
<a href="#Section_161_4__Inheritance_vs_Co">857</a></p>
<p><span id="Chapter_162__Audio" class="anchor"></span><a
href="#Chapter_162__Audio_1">Chapter 162: Audio
....................................................................................................................................................
859</a></p>
<p><a href="#Chapter_162__Audio_1">Section 162.1: Play a MIDI file
....................................................................................................................................
859</a></p>
<p><a href="#sequence_until_the_end__It_can_s">Section 162.2: Play an
Audio file Looped</a>
................................................................................................................
<a href="#sequence_until_the_end__It_can_s">860</a></p>
<p><a href="#sequence_until_the_end__It_can_s">Section 162.3: Basic
audio output</a>
............................................................................................................................
<a href="#sequence_until_the_end__It_can_s">860</a></p>
<p><a href="#___Get_a_sound_clip_resource">Section 162.4: Bare metal
sound
..............................................................................................................................
861</a></p>
<h1
id="chapter-163-java-print-service-........................................................................................................................-863"><a
href="#Chapter_163__Java_Print_Service_1">Chapter 163: Java Print
Service</a>
........................................................................................................................
<a href="#Chapter_163__Java_Print_Service_1">863</a></h1>
<p><a href="#Chapter_163__Java_Print_Service_1">Section 163.1: Building
the Doc that will be printed</a>
................................................................................................
<a href="#Chapter_163__Java_Print_Service_1">863</a></p>
<p><a href="#Chapter_163__Java_Print_Service_1">Section 163.2:
Discovering the available print services</a>
.........................................................................................
<a href="#Chapter_163__Java_Print_Service_1">863</a></p>
<p><a href="#This_program__when_executed_on_a">Section 163.3: Defining
print request attributes
......................................................................................................
864</a></p>
<p><a href="#This_program__when_executed_on_a">Section 163.4: Listening
print job request status change</a>
......................................................................................
<a href="#This_program__when_executed_on_a">864</a></p>
<p><a href="#private_static_final_Logger_LOG">Section 163.5: Discovering
the default print service</a>
..............................................................................................
<a href="#private_static_final_Logger_LOG">866</a></p>
<p><a href="#private_static_final_Logger_LOG">Section 163.6: Creating a
print job from a print service</a>
........................................................................................
<a href="#private_static_final_Logger_LOG">866</a></p>
<h1
id="chapter-164-completablefuture-.....................................................................................................................-868"><a
href="#Chapter_164__CompletableFuture_1">Chapter 164:
CompletableFuture</a>
.....................................................................................................................
<a href="#Chapter_164__CompletableFuture_1">868</a></h1>
<p><a href="#Chapter_164__CompletableFuture_1">Section 164.1: Simple
Example of CompletableFuture</a>
...........................................................................................
<a href="#Chapter_164__CompletableFuture_1">868</a></p>
<h1
id="chapter-165-runtime-commands-....................................................................................................................-869"><a
href="#Chapter_165__Runtime_Commands_1">Chapter 165: Runtime
Commands</a>
....................................................................................................................
<a href="#Chapter_165__Runtime_Commands_1">869</a></h1>
<p><a href="#Chapter_165__Runtime_Commands_1">Section 165.1: Adding
shutdown hooks</a>
....................................................................................................................
<a href="#Chapter_165__Runtime_Commands_1">869</a></p>
<p><span id="Chapter_166__Unit_Testing" class="anchor"></span><a
href="#Chapter_166__Unit_Testing_1">Chapter 166: Unit Testing
......................................................................................................................................
870</a></p>
<p><a href="#Chapter_166__Unit_Testing_1">Section 166.1: What is Unit
Testing?</a>
.........................................................................................................................
<a href="#Chapter_166__Unit_Testing_1">870</a></p>
<h1
id="chapter-167-asserting-...........................................................................................................................................-873"><a
href="#Chapter_167__Asserting_1">Chapter 167: Asserting</a>
...........................................................................................................................................
<a href="#Chapter_167__Asserting_1">873</a></h1>
<p><a href="#Chapter_167__Asserting_1">Section 167.1: Checking
arithmetic with assert</a>
.......................................................................................................
<a href="#Chapter_167__Asserting_1">873</a></p>
<h1
id="chapter-168-multi-release-jar-files-.............................................................................................................-874"><a
href="#Chapter_168__Multi_Release_JAR_F_1">Chapter 168: Multi-Release
JAR Files</a>
.............................................................................................................
<a href="#Chapter_168__Multi_Release_JAR_F_1">874</a></h1>
<p><a href="#Chapter_168__Multi_Release_JAR_F_1">Section 168.1: Example
of a multi-release Jar file's contents</a>
...............................................................................
<a href="#Chapter_168__Multi_Release_JAR_F_1">874</a></p>
<p><a href="#Chapter_168__Multi_Release_JAR_F_1">Section 168.2: Creating
a multi-release Jar using the jar tool</a>
..............................................................................
<a href="#Chapter_168__Multi_Release_JAR_F_1">874</a></p>
<p><a href="#package_demo">Section 168.3: URL of a loaded class inside a
multi-release Jar</a>
..........................................................................
<a href="#package_demo">875</a></p>
<h1
id="chapter-169-just-in-time-jit-compiler-......................................................................................................-877"><a
href="#Chapter_169__Just_in_Time__JIT_1">Chapter 169: Just in Time (JIT)
compiler</a>
......................................................................................................
<a href="#Chapter_169__Just_in_Time__JIT_1">877</a></h1>
<p><a href="#Chapter_169__Just_in_Time__JIT_1">Section 169.1:
Overview</a>
.............................................................................................................................................
<a href="#Chapter_169__Just_in_Time__JIT_1">877</a></p>
<p><span id="Chapter_170__Bytecode_Modificati" class="anchor"></span><a
href="#Chapter_170__Bytecode_Modificati_1">Chapter 170: Bytecode
Modification
...............................................................................................................
879</a></p>
<p><a href="#Chapter_170__Bytecode_Modificati_1">Section 170.1: What is
Bytecode?</a>
.............................................................................................................................
<a href="#Chapter_170__Bytecode_Modificati_1">879</a></p>
<p><a href="#bytecode_using_different_librari">Section 170.2: How to
edit jar files with ASM</a>
..........................................................................................................
<a href="#bytecode_using_different_librari">880</a></p>
<p><a href="#try">Section 170.3: How to load a ClassNode as a Class</a>
..............................................................................................
<a href="#try">882</a></p>
<p><a href="#public_Classbyte___bytes">Section 170.4: How to rename
classes in a jar file</a>
.................................................................................................
<a href="#public_Classbyte___bytes">883</a></p>
<p><a href="#public_Classbyte___bytes">Section 170.5: Javassist
Basic</a>
..................................................................................................................................
<a href="#public_Classbyte___bytes">883</a></p>
<h1
id="chapter-171-disassembling-and-decompiling-............................................................................................-885"><a
href="#Chapter_171__Disassembling_and">Chapter 171: Disassembling and
Decompiling</a>
............................................................................................
<a href="#Chapter_171__Disassembling_and">885</a></h1>
<p><a href="#Chapter_171__Disassembling_and">Section 171.1: Viewing
bytecode with javap
.............................................................................................................
885</a></p>
<h1
id="chapter-172-jmx-......................................................................................................................................................-892"><a
href="#Chapter_172__JMX_1">Chapter 172: JMX</a>
......................................................................................................................................................
<a href="#Chapter_172__JMX_1">892</a></h1>
<p><a href="#Chapter_172__JMX_1">Section 172.1: Simple example with
Platform MBean Server</a>
................................................................................
<a href="#Chapter_172__JMX_1">892</a></p>
<h1
id="chapter-173-java-virtual-machine-jvm-....................................................................................................-896"><a
href="#Chapter_173__Java_Virtual_Machin_1">Chapter 173: Java Virtual
Machine (JVM)</a>
....................................................................................................
<a href="#Chapter_173__Java_Virtual_Machin_1">896</a></h1>
<p><a href="#Chapter_173__Java_Virtual_Machin_1">Section 173.1: These
are the basics</a>
..........................................................................................................................
<a href="#Chapter_173__Java_Virtual_Machin_1">896</a></p>
<p><span id="Chapter_174__XJC" class="anchor"></span><a
href="#Chapter_174__XJC_1">Chapter 174: XJC
.......................................................................................................................................................
897</a></p>
<p><a href="#Chapter_174__XJC_1">Section 174.1: Generating Java code
from simple XSD file</a>
...................................................................................
<a href="#Chapter_174__XJC_1">897</a></p>
<h1
id="chapter-175-jvm-flags-.........................................................................................................................................-900"><a
href="#Chapter_175__JVM_Flags_1">Chapter 175: JVM Flags</a>
.........................................................................................................................................
<a href="#Chapter_175__JVM_Flags_1">900</a></h1>
<p><a href="#Chapter_175__JVM_Flags_1">Section 175.1: -XXaggressive</a>
....................................................................................................................................
<a href="#Chapter_175__JVM_Flags_1">900</a></p>
<p><a href="#Chapter_175__JVM_Flags_1">Section 175.2:
-XXallocClearChunks
.........................................................................................................................
900</a></p>
<p><a href="#Chapter_175__JVM_Flags_1">Section 175.3:
-XXallocClearChunkSize</a>
....................................................................................................................
<a href="#Chapter_175__JVM_Flags_1">900</a></p>
<p><a href="#Chapter_175__JVM_Flags_1">Section 175.4:
-XXcallProfiling</a>
..................................................................................................................................
<a href="#Chapter_175__JVM_Flags_1">900</a></p>
<p><a href="#Note__This_option_is_supported_w">Section 175.5:
-XXdisableFatSpin</a>
.............................................................................................................................
<a href="#Note__This_option_is_supported_w">901</a></p>
<p><a href="#Note__This_option_is_supported_w">Section 175.6:
-XXdisableGCHeuristics</a>
....................................................................................................................
<a href="#Note__This_option_is_supported_w">901</a></p>
<p><a href="#Note__This_option_is_supported_w">Section 175.7:
-XXdumpSize</a>
......................................................................................................................................
<a href="#Note__This_option_is_supported_w">901</a></p>
<p><a href="#Section_175_8___XXexitOnOutOfMem">Section 175.8:
-XXexitOnOutOfMemory
...................................................................................................................
902</a></p>
<h1
id="chapter-176-jvm-tool-interface-......................................................................................................................-903"><a
href="#Chapter_176__JVM_Tool_Interface_1">Chapter 176: JVM Tool
Interface</a>
......................................................................................................................
<a href="#Chapter_176__JVM_Tool_Interface_1">903</a></h1>
<p><a href="#Chapter_176__JVM_Tool_Interface_1">Section 176.1: Iterate
over objects reachable from object (Heap 1.0)</a>
.................................................................. <a
href="#Chapter_176__JVM_Tool_Interface_1">903</a></p>
<p><a href="#_60">Section 176.2: Get JVMTI environment</a>
....................................................................................................................
<a href="#_60">905</a></p>
<p><a href="#_60">Section 176.3: Example of initialization inside of
Agent_OnLoad method</a>
.......................................................... <a
href="#_60">905</a></p>
<p><span id="Chapter_177__Java_Memory_Managem" class="anchor"></span><a
href="#Chapter_177__Java_Memory_Managem_1">Chapter 177: Java Memory
Management
....................................................................................................
907</a></p>
<p><a href="#Chapter_177__Java_Memory_Managem_1">Section 177.1: Setting
the Heap, PermGen and Stack sizes</a>
...................................................................................
<a href="#Chapter_177__Java_Memory_Managem_1">907</a></p>
<p><a href="#uintx_InitialHeapSize">Section 177.2: Garbage
collection</a>
............................................................................................................................
<a href="#uintx_InitialHeapSize">908</a></p>
<p><a href="#n1____Node1__Node1_next___Node2">Section 177.3: Memory
leaks in Java</a>
.......................................................................................................................
<a href="#n1____Node1__Node1_next___Node2">910</a></p>
<p><a href="#In_this_case__the_solution_is_st">Section 177.4:
Finalization</a>
.........................................................................................................................................
<a href="#In_this_case__the_solution_is_st">911</a></p>
<p><a href="#Java_makes_no_guarantees_about_w">Section 177.5: Manually
triggering GC</a>
.....................................................................................................................
<a href="#Java_makes_no_guarantees_about_w">912</a></p>
<h1
id="chapter-178-java-performance-tuning-.......................................................................................................-913"><a
href="#Chapter_178__Java_Performance_Tu_1">Chapter 178: Java Performance
Tuning</a>
.......................................................................................................
<a href="#Chapter_178__Java_Performance_Tu_1">913</a></h1>
<p><a href="#Chapter_178__Java_Performance_Tu_1">Section 178.1: An
evidence-based approach to Java performance tuning</a>
........................................................ <a
href="#Chapter_178__Java_Performance_Tu_1">913</a></p>
<p><a href="#take_a_more_radical_approach__Fo">Section 178.2: Reducing
amount of Strings</a>
............................................................................................................
<a href="#take_a_more_radical_approach__Fo">914</a></p>
<p><a href="#take_a_more_radical_approach__Fo">Section 178.3: General
approach</a>
.............................................................................................................................
<a href="#take_a_more_radical_approach__Fo">914</a></p>
<p><span id="Chapter_179__Benchmarks" class="anchor"></span><a
href="#Chapter_179__Benchmarks_1">Chapter 179: Benchmarks
.....................................................................................................................................
916</a></p>
<p><a href="#Chapter_179__Benchmarks_1">Section 179.1: Simple JMH
example</a>
.........................................................................................................................
<a href="#Chapter_179__Benchmarks_1">916</a></p>
<h1
id="chapter-180-fileupload-to-aws-.......................................................................................................................-919"><a
href="#Chapter_180__FileUpload_to_AWS_1">Chapter 180: FileUpload to
AWS</a>
.......................................................................................................................
<a href="#Chapter_180__FileUpload_to_AWS_1">919</a></h1>
<p><a href="#Chapter_180__FileUpload_to_AWS_1">Section 180.1: Upload
file to s3 bucket</a>
....................................................................................................................
<a href="#Chapter_180__FileUpload_to_AWS_1">919</a></p>
<p><span id="Chapter_181__AppDynamics_and_TIB" class="anchor"></span><a
href="#Chapter_181__AppDynamics_and_TIB_1">Chapter 181: AppDynamics and
TIBCO BusinessWorks Instrumentation for Easy</a></p>
<p><a
href="#Chapter_181__AppDynamics_and_TIB_1"><strong>Integration</strong></a>
...................................................................................................................................................................
<a href="#Chapter_181__AppDynamics_and_TIB_1">921</a></p>
<p><a href="#Chapter_181__AppDynamics_and_TIB_1">Section 181.1: Example
of Instrumentation of all BW Applications in a Single Step for
Appdynamics</a> ............. <a
href="#Chapter_181__AppDynamics_and_TIB_1">921</a></p>
<p><a href="#Appendix_A__Installing_Java__Sta"><strong>Appendix A:
Installing Java (Standard Edition)</strong></a>
........................................................................................
<a href="#Appendix_A__Installing_Java__Sta">922</a></p>
<p><a href="#Appendix_A__Installing_Java__Sta">Section A.1: Setting
%PATH% and %JAVA_HOME% after installing on Windows</a>
.............................................. <a
href="#Appendix_A__Installing_Java__Sta">922</a></p>
<p><a href="#page_947">Section A.2: Installing a Java JDK on Linux</a>
...........................................................................................................
<a href="#page_947">923</a></p>
<p><a href="#Installing_from_an_Oracle_Java_R">Section A.3: Installing a
Java JDK on macOS
........................................................................................................
925</a></p>
<p><a href="#export_JAVA_HOME___usr_libexec_j">Section A.4: Installing a
Java JDK or JRE on Windows</a>
........................................................................................
<a href="#export_JAVA_HOME___usr_libexec_j">926</a></p>
<p><a href="#5__Navigate_to_the_newly_created">Section A.5: Configuring
and switching Java versions on Linux using alternatives</a>
.......................................... <a
href="#5__Navigate_to_the_newly_created">927</a></p>
<p><a href="#2____________Data_jdk1_8_0_67_bi">Section A.6: What do I
need for Java Development</a>
.............................................................................................
<a href="#2____________Data_jdk1_8_0_67_bi">928</a></p>
<p><a href="#2____________Data_jdk1_8_0_67_bi">Section A.7: Selecting an
appropriate Java SE release</a>
........................................................................................
<a href="#2____________Data_jdk1_8_0_67_bi">928</a></p>
<p><a href="#If_you_are_working_on_an_older_J">Section A.8: Java release
and version naming
......................................................................................................
929</a></p>
<p><a href="#If_you_are_working_on_an_older_J">Section A.9: Installing
Oracle Java on Linux with latest tar file
............................................................................
929</a></p>
<p><a href="#3__Create_a_dir_for_jdk_install">Section A.10:
Post-installation checking and configuration on Linux
...................................................................
930</a></p>
<p><a href="#Appendix_B__Java_Editions__Versi">Appendix B: Java
Editions, Versions, Releases and Distributions</a>
<strong>................................................... <a
href="#Appendix_B__Java_Editions__Versi">933</a></strong></p>
<p><a href="#Appendix_B__Java_Editions__Versi">Section B.1: Dierences
between Java SE JRE or Java SE JDK distributions</a>
.................................................... <a
href="#Appendix_B__Java_Editions__Versi">933</a></p>
<p><a href="#From_Java_6_onwards__the_complet">Section B.2: Java SE
Versions
..................................................................................................................................
934</a></p>
<p><a href="#Generics__annotations__auto_boxi">Section B.3: Dierences
between Java EE, Java SE, Java ME and JavaFX</a>
....................................................... <a
href="#Generics__annotations__auto_boxi">935</a></p>
<p><a href="#Appendix_C__The_Classpath"><strong>Appendix C: The
Classpath</strong></a>
..................................................................................................................................
<a href="#Appendix_C__The_Classpath">937</a></p>
<p><a href="#Appendix_C__The_Classpath">Section C.1: Dierent ways to
specify the classpath</a>
.............................................................................................
<a href="#Appendix_C__The_Classpath">937</a></p>
<p><a href="#Appendix_C__The_Classpath">Section C.2: Adding all JARs in
a directory to the classpath
................................................................................
937</a></p>
<p><a href="#Notes">Section C.3: Load a resource from the classpath</a>
..................................................................................................
<a href="#Notes">938</a></p>
<p><a href="#Notes">Section C.4: Classpath path syntax</a>
.........................................................................................................................
<a href="#Notes">938</a></p>
<p><a href="#When_the_classpath_is_specified">Section C.5: Dynamic
Classpath</a>
..............................................................................................................................
<a href="#When_the_classpath_is_specified">939</a></p>
<p><a href="#When_the_classpath_is_specified">Section C.6: Mapping
classnames to pathnames</a>
..................................................................................................
<a href="#When_the_classpath_is_specified">939</a></p>
<p><a href="#When_the_classpath_is_specified">Section C.7: The bootstrap
classpath</a>
.....................................................................................................................
<a href="#When_the_classpath_is_specified">939</a></p>
<p><a href="#Very_occasionally__it_is_necessa">Section C.8: What the
classpath means: how searches work</a>
..............................................................................
<a href="#Very_occasionally__it_is_necessa">940</a></p>
<p><a href="#Appendix_D__Resources__on_classp"><strong>Appendix D:
Resources (on classpath)</strong></a>
..........................................................................................................
<a href="#Appendix_D__Resources__on_classp">941</a></p>
<p><a href="#Appendix_D__Resources__on_classp">Section D.1: Loading
default configuration</a>
............................................................................................................
<a href="#Appendix_D__Resources__on_classp">941</a></p>
<p><a href="#Appendix_D__Resources__on_classp">Section D.2: Loading an
image from a resource</a>
...................................................................................................
<a href="#Appendix_D__Resources__on_classp">941</a></p>
<p><a href="#Appendix_D__Resources__on_classp">Section D.3: Finding and
reading resources using a classloader</a>
........................................................................
<a href="#Appendix_D__Resources__on_classp">941</a></p>
<p><a href="#If_your_code_uses_a_getResourceA">Section D.4: Loading
same-name resource from multiple JARs</a>
.........................................................................
<a href="#If_your_code_uses_a_getResourceA">943</a></p>
<p><a href="#Credits"><strong>Credits</strong></a>
............................................................................................................................................................................
<a href="#Credits">944</a></p>
<p><a href="#You_may_also_like"><strong>You may also like</strong>
......................................................................................................................................................
958</a></p>
<p><span id="About" class="anchor"></span>About</p>
<p>Please feel free to share this PDF with anyone for free,</p>
<p>latest version of this book can be downloaded from:</p>
<p><a
href="https://goalkicker.com/JavaBook">https://goalkicker.com/JavaBook</a></p>
<p><em>This</em> Java® Notes for Professionals <em>book is compiled from
<a href="https://archive.org/details/documentation-dump.7z">Stack
Overflow</a></em></p>
<p><a
href="https://archive.org/details/documentation-dump.7z">Documentation</a>,
the content is written by the beautiful people at Stack Overflow.</p>
<p>Text content is released under Creative Commons BY-SA, see credits at
the end</p>
<p>of this book whom contributed to the various chapters. Images may be
copyright</p>
<p>of their respective owners unless otherwise specified</p>
<p>This is an unofficial free book created for educational purposes and
is not affiliated with official Java® group(s) or company(s) nor Stack
Overflow. All</p>
<p>trademarks and registered trademarks are the property of their
respective</p>
<p>company owners</p>
<p>The information presented in this book is not guaranteed to be
correct nor</p>
<p>accurate, use at your own risk</p>
<p>Please send feedback and corrections to web@petercv.com</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 1</p>
<p><span id="Chapter_1__Getting_started_with"
class="anchor"></span>Chapter 1: Getting started with Java</p>
<p>Language</p>
<p>Java SE Version Code Name End-of-life (free1) Release Date</p>
<p><a href="https://docs.oracle.com/javase/10/docs/toc.htm">Java SE 10
(Early Access)</a> <em>None</em> future 2018-03-20</p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/index.html">Java
SE 9</a> <em>None</em> future 2017-07-27</p>
<p><a href="http://docs.oracle.com/javase/8/docs/api/">Java SE 8</a>
Spider future 2014-03-18</p>
<p><a href="http://docs.oracle.com/javase/7/docs/api/">Java SE 7</a>
Dolphin 2015-04-14 2011-07-28</p>
<p><a href="http://docs.oracle.com/javase/6/docs/api/">Java SE 6</a>
Mustang 2013-04-16 2006-12-23</p>
<p><a href="http://docs.oracle.com/javase/1.5.0/docs/api/">Java SE 5</a>
Tiger 2009-11-04 2004-10-04</p>
<p><a href="http://docs.oracle.com/javase/1.4.2/docs/api/">Java SE
1.4</a> Merlin prior to 2009-11-04 2002-02-06</p>
<p><a href="http://docs.oracle.com/javase/1.3/docs/api/">Java SE 1.3</a>
Kestrel prior to 2009-11-04 2000-05-08</p>
<p><a href="http://java.com/">Java SE 1.2</a> Playground prior to
2009-11-04 1998-12-08</p>
<p><a href="http://java.com/">Java SE 1.1</a> <em>None</em> prior to
2009-11-04 1997-02-19</p>
<p><a href="http://java.com/">Java SE 1.0</a> Oak prior to 2009-11-04
1996-01-21</p>
<p>Section 1.1: Creating Your First Java Program</p>
<p>Create a new file in your <a
href="https://en.wikipedia.org/wiki/Text_editor">text editor</a> <a
href="https://en.wikipedia.org/wiki/Integrated_development_environment">or
IDE named</a> HelloWorld.java. Then paste this code block into the file
and</p>
<p>save:</p>
<p><strong>public class</strong> HelloWorld {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println("Hello, World!");</p>
<p>}</p>
<p>}</p>
<p><a href="https://ideone.com/rbWs4M">Run live on Ideone</a></p>
<p><em><strong>Note:</strong></em> For Java to recognize this as a
<strong>public class</strong> (and not throw a <a
href="http://stackoverflow.com/questions/1841847/can-i-compile-a-java-file-with-a-different-name-than-the-class">compile
time error</a>), the filename must be the</p>
<p>same as the class name (HelloWorld in this example) with a .java
extension. There should also be a <strong>public</strong> access</p>
<p>modifier before it.</p>
<p>Naming conventions recommend that Java classes begin with an
uppercase character, and be in <a
href="https://en.wikipedia.org/wiki/Camel_case?oldformat=true">camel
case</a> format</p>
<p>(in which the first letter of each word is capitalized). The
conventions recommend against underscores (_) and dollar signs ($).</p>
<p>To compile, open a terminal window and navigate to the directory of
HelloWorld.java:</p>
<p><strong>cd
/</strong>path<strong>/</strong>to<strong>/</strong>containing<strong>/</strong>folder<strong>/</strong></p>
<p><em><strong>Note:</strong></em> <a
href="http://www.linfo.org/cd.html">cd is the terminal command to change
directory.</a></p>
<p>Enter javac followed by the file name and extension as follows:</p>
<p>$ javac HelloWorld.java</p>
<p>It's fairly common to get the error 'javac' is not recognized as an
internal or external command, operable program or batch file. even when
you have installed the JDK and are able to run the program from IDE
ex.</p>
<p>eclipse etc. Since the path is not added to the environment by
default.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 2</p>
<p>In case you get this on windows, to resolve, first try browsing to
your javac.exe path, it's most probably in your C:\Program
Files\Java\jdk(version number)\bin. Then try running it with below.</p>
<p>$ C:\Program Files\Java\jdk(version number)\bin\javac
HelloWorld.java</p>
<p>Previously when we were calling javac it was same as above command.
Only in that case your OS knew where</p>
<p>javac resided. So let's tell it now, this way you don't have to type
the whole path every-time. We would need to add this to our PATH</p>
<p>To edit the PATH environment variable in Windows XP/Vista/7/8/10:</p>
<p>Control Panel ⇒ System ⇒ Advanced system settings</p>
<p>Switch to "Advanced" tab ⇒ Environment Variables</p>
<p>In "System Variables", scroll down to select "PATH" ⇒ Edit</p>
<p><strong>You cannot undo this</strong> so be careful. First copy your
existing path to notepad. Then to get the exact PATH to your</p>
<p>javac browse manually to the folder where javac resides and click on
the address bar and then copy it. It should</p>
<p>look something like c:\Program Files\Java\jdk1.8.0_xx\bin</p>
<p>In "Variable value" field, paste this <strong>IN FRONT</strong> of
all the existing directories, followed by a semi-colon (;). <strong>DO
NOT</strong></p>
<p><strong>DELETE</strong> any existing entries.</p>
<p>Variable name : PATH</p>
<p>Variable value : c:\Program Files\Java\jdk1.8.0_xx\bin;[Existing
Entries...]</p>
<p>Now this should resolve.</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">For
Linux Based systems try here</a>.</p>
<p><strong>Note:</strong> The javac command invokes the Java
compiler.</p>
<p><a href="https://en.wikipedia.org/wiki/Bytecode">The compiler will
then generate a bytecode file called</a>
HelloWorld.<strong>class</strong> <a
href="https://en.wikipedia.org/wiki/Java_virtual_machine">which can be
executed in the Java Virtual</a></p>
<p><a href="https://en.wikipedia.org/wiki/Java_virtual_machine">Machine
(JVM)</a>. The Java programming language compiler, javac, reads source
files written in the Java programming language and compiles them into
bytecode class files. Optionally, the compiler can also process
annotations found</p>
<p>in source and class files using the Pluggable Annotation Processing
API. The compiler is a command line tool but can also be invoked using
the Java Compiler API.</p>
<p>To run your program, enter java followed by the name of the class
which contains the main method (HelloWorld in our example). Note how the
.<strong>class</strong> is omitted:</p>
<p>$ java HelloWorld</p>
<p><strong>Note:</strong> The <a
href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">java</a>
command runs a Java application.</p>
<p>This will output to your console:</p>
<p>Hello, World!</p>
<p>You have successfully coded and built your very first Java
program!</p>
<p><em><strong>Note:</strong></em> In order for Java commands (java,
javac, etc) to be recognized, you will need to make sure:</p>
<p>A JDK is installed (e.g. <a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html">Oracle</a>,
<a href="http://openjdk.java.net/install/">OpenJDK</a> and other
sources)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 3</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">Your
environment variables are properly set up</a></p>
<p>You will need to use a compiler (javac) and an executor (java)
provided by your JVM. To find out which versions you</p>
<p>have installed, enter java -version and javac -version on the command
line. The version number of your program will be printed in the terminal
(e.g. 1.8.0_73).</p>
<p>A closer look at the Hello World program</p>
<p>The "Hello World" program contains a single file, which consists of a
HelloWorld class definition, a main method,</p>
<p>and a statement inside the main method.</p>
<p><strong>public class</strong> HelloWorld {</p>
<p>The <strong>class</strong> keyword begins the class definition for a
class named HelloWorld. Every Java application contains at least one
class definition (Further information about classes).</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>This is an entry point method (defined by its name and signature of
<strong>public static void</strong> main(String[])) from</p>
<p>which the JVM can run your program. Every Java program should have
one. It is:</p>
<p><strong>public</strong> : meaning that the method can be called from
anywhere mean from outside the program as well. See</p>
<p>Visibility for more information on this.</p>
<p><strong>static</strong> : meaning it exists and can be run by itself
(at the class level without creating an object).</p>
<p><em><strong>void</strong>: meaning it returns no value.</em>
<strong>Note:</strong> This is unlike C and C++ where a return code such
as <strong>int</strong> is expected</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#exit-int-">(Java's
way is System.exit()</a>).</p>
<p>This main method accepts:</p>
<p>An array (typically called args) of Strings passed as arguments to
main function (e.g. from command line arguments).</p>
<p>Almost all of this is required for a Java entry point method.</p>
<p>Non-required parts:</p>
<p>The name args is a variable name, so it can be called anything you
want, although it is typically called args.</p>
<p>Whether its parameter type is an array (String[] args) or Varargs
(String... args) does not matter because arrays can be passed into
varargs.</p>
<p><em><strong>Note:</strong></em> A single application may have
multiple classes containing an entry point (main) method. The entry
point of the</p>
<p>application is determined by the class name passed as an argument to
the java command.</p>
<p>Inside the main method, we see the following statement:</p>
<p>System.out.println("Hello, World!");</p>
<p>Let's break down this statement element-by-element:</p>
<p>Element Purpose</p>
<p>System this denotes that the subsequent expression will call upon the
System class, from the java.lang</p>
<p>package.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 4</p>
<p>this is a "dot operator". Dot operators provide you access to a
classes members1; i.e. its fields</p>
<p>. (variables) and its methods. In this case, this dot operator allows
you to reference the out static field</p>
<p>within the System class.</p>
<p>out this is the name of the static field of PrintStream type within
the System class containing the</p>
<p>standard output functionality.</p>
<p>. this is another dot operator. This dot operator provides access to
the println method within the out</p>
<p>variable.</p>
<p>println this is the name of a method within the PrintStream class.
This method in particular prints the</p>
<p>contents of the parameters into the console and inserts a newline
after.</p>
<p>( this parenthesis indicates that a method is being accessed (and not
a field) and begins the</p>
<p>parameters being passed into the println method.</p>
<p>"Hello, this is the String literal that is passed as a parameter,
into the println method. The double quotation World!" marks on each end
delimit the text as a String.</p>
<p>) this parenthesis signifies the closure of the parameters being
passed into the println method.</p>
<p>; this semicolon marks the end of the statement.</p>
<p><strong>Note:</strong> Each statement in Java must end with a
semicolon (;).</p>
<p>The method body and class body are then closed.</p>
<p><em>}</em> // end of main function scope</p>
<p><em>}</em> // end of class HelloWorld scope</p>
<p>Here's another example demonstrating the OO paradigm. Let's model a
football team with one (yes, one!) member. There can be more, but we'll
discuss that when we get to arrays.</p>
<p>First, let's define our Team class:</p>
<p>public class <strong>Team {</strong></p>
<p>Member member;</p>
<p><strong>public</strong> Team(Member member) { <em>// who is in this
Team?</em></p>
<p><em><strong>this</strong>.member = member;</em> // one 'member' is in
this Team!</p>
<p>}</p>
<p>}</p>
<p>Now, let's define our Member class:</p>
<p><strong>class</strong> Member {</p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> String type;</p>
<p><em><strong>private int</strong> level;</em> // note the data type
here</p>
<p><em><strong>private int</strong> rank;</em> // note the data type
here as well</p>
<p><strong>public</strong> Member(String name, String type,
<strong>int</strong> level, <strong>int</strong> rank) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.type = type;</p>
<p><strong>this</strong>.level = level;</p>
<p><strong>this</strong>.rank = rank;</p>
<p>}</p>
<p>}</p>
<p>Why do we use <strong>private</strong> here? Well, if someone wanted
to know your name, they should ask you directly, instead of</p>
<p>reaching into your pocket and pulling out your Social Security card.
This <strong>private</strong> does something like that: it prevents
outside entities from accessing your variables. You can only return
<strong>private</strong> members through getter</p>
<p>functions (shown below).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 5</p>
<p>After putting it all together, and adding the getters and main method
as discussed before, we have:</p>
<p>public class <strong>Team {</strong></p>
<p>Member member;</p>
<p><strong>public</strong> Team(Member member) {</p>
<p><strong>this</strong>.member = member;</p>
<p>}</p>
<p>// here's our main method</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Member myMember = <strong>new</strong> Member("Aurieel", "light", 10,
1);</p>
<p>Team myTeam = <strong>new</strong> Team(myMember);</p>
<p>System.out.println(myTeam.member.getName());</p>
<p>System.out.println(myTeam.member.getType());</p>
<p>System.out.println(myTeam.member.getLevel());</p>
<p>System.out.println(myTeam.member.getRank());</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Member {</p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> String type;</p>
<p>private int <strong>level;</strong></p>
<p>private int <strong>rank;</strong></p>
<p><strong>public</strong> Member(String name, String type,
<strong>int</strong> level, <strong>int</strong> rank) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.type = type;</p>
<p><strong>this</strong>.level = level;</p>
<p><strong>this</strong>.rank = rank;</p>
<p>}</p>
<p>/* let's define our getter functions here */</p>
<p><em><strong>public</strong> String getName() {</em> // what is your
name?</p>
<p><em><strong>return this</strong>.name;</em> // my name is ...</p>
<p>}</p>
<p><em><strong>public</strong> String getType() {</em> // what is your
type?</p>
<p><em><strong>return this</strong>.type;</em> // my type is ...</p>
<p>}</p>
<p><em><strong>public int</strong> getLevel() {</em> // what is your
level?</p>
<p><em><strong>return this</strong>.level;</em> // my level is ...</p>
<p>}</p>
<p><em><strong>public int</strong> getRank() {</em> // what is your
rank?</p>
<p><em><strong>return this</strong>.rank;</em> // my rank is</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Aurieel</p>
<p>light</p>
<p>10</p>
<p>1</p>
<p><a href="https://ideone.com/hHWFdk">Run on ideone</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 6</p>
<p>Once again, the main method inside the Test class is the entry point
to our program. Without the main method, we cannot tell the Java Virtual
Machine (JVM) from where to begin execution of the program.</p>
<p>1 - Because the HelloWorld class has little relation to the System
class, it can only access <strong>public</strong> data.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 7</p>
<p><span id="Chapter_2__Type_Conversion" class="anchor"></span>Chapter
2: Type Conversion</p>
<p>Section 2.1: Numeric primitive casting</p>
<p>Numeric primitives can be cast in two ways. <em>Implicit</em> casting
happens when the source type has smaller range than the target type.</p>
<p>//Implicit casting</p>
<p><strong>byte</strong> byteVar = 42;</p>
<p><strong>short</strong> shortVar = byteVar;</p>
<p><strong>int</strong> intVar = shortVar;</p>
<p><strong>long</strong> longVar = intvar;</p>
<p><strong>float</strong> floatVar = longVar;</p>
<p><strong>double</strong> doubleVar = floatVar;</p>
<p><em>Explicit</em> casting has to be done when the source type has
larger range than the target type.</p>
<p>//Explicit casting</p>
<p><strong>double</strong> doubleVar = 42.0d;</p>
<p><strong>float</strong> floatVar = (<strong>float</strong>)
doubleVar;</p>
<p><strong>long</strong> longVar = (<strong>long</strong>) floatVar;</p>
<p><strong>int</strong> intVar = (<strong>int</strong>) longVar;</p>
<p><strong>short</strong> shortVar = (<strong>short</strong>)
intVar;</p>
<p><strong>byte</strong> byteVar = (<strong>byte</strong>) shortVar;</p>
<p>When casting floating point primitives (<strong>float</strong>,
<strong>double</strong>) to whole number primitives, the number is
<strong>rounded down</strong>.</p>
<p>Section 2.2: Basic Numeric Promotion</p>
<p><strong>static void</strong> testNumericPromotion() {</p>
<p><strong>char</strong> char1 = 1, char2 = 2;</p>
<p><strong>short</strong> short1 = 1, short2 = 2;</p>
<p><strong>int</strong> int1 = 1, int2 = 2;</p>
<p><strong>float</strong> float1 = 1.0f, float2 = 2.0f;</p>
<p>// char1 = char1 + char2; // Error: Cannot convert from int to char;
// short1 = short1 + short2; // Error: Cannot convert from int to
short;</p>
<p><em>int1 = char1 + char2;</em> // char is promoted to int.</p>
<p><em>int1 = short1 + short2;</em> // short is promoted to int.</p>
<p><em>int1 = char1 + short2;</em> // both char and short promoted to
int.</p>
<p><em>float1 = short1 + float2;</em> // short is promoted to float.</p>
<p>int1 = int1 + int2; <em>// int is unchanged.</em></p>
<p>}</p>
<p>Section 2.3: Non-numeric primitive casting</p>
<p>The <strong>boolean</strong> type cannot be cast to/from any other
primitive type.</p>
<p>A <strong>char</strong> can be cast to/from any numeric type by using
the code-point mappings specified by Unicode. A <strong>char</strong>
is</p>
<p>represented in memory as an unsigned 16-bit integer value (2 bytes),
so casting to <strong>byte</strong> (1 byte) will drop 8 of those bits
(this is safe for ASCII characters). The utility methods of the
Character class use <strong>int</strong> (4 bytes) to transfer</p>
<p>to/from code-point values, but a <strong>short</strong> (2 bytes)
would also suffice for storing a Unicode code-point.</p>
<p><em><strong>int</strong> badInt = (<strong>int</strong>)
<strong>true</strong>;</em> // Compiler error: incompatible types</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 8</p>
<p><span id="char_char1______char_____65"
class="anchor"></span><strong>char</strong> char1 =
(<strong>char</strong>) 65; <em>// A</em></p>
<p><strong>byte</strong> byte1 = (<strong>byte</strong>) 'A'; <em>//
65</em></p>
<p><strong>short</strong> short1 = (<strong>short</strong>) 'A'; <em>//
65</em></p>
<p><strong>int</strong> int1 = (<strong>int</strong>) 'A'; <em>//
65</em></p>
<p><strong>char</strong> char2 = (<strong>char</strong>) 8253;
<em>//</em> ‽</p>
<p><em><strong>byte</strong> byte2 = (<strong>byte</strong>) ' ‽';</em>
// 61 (truncated code-point into the ASCII range)
<em><strong>short</strong> short2 = (<strong>short</strong>) ' ‽';</em>
// 8253</p>
<p><strong>int</strong> int2 = (<strong>int</strong>) ' ‽'; <em>//
8253</em></p>
<p>Section 2.4: Object casting</p>
<p>As with primitives, objects can be cast both explicitly and
implicitly.</p>
<p>Implicit casting happens when the source type extends or implements
the target type (casting to a superclass or interface).</p>
<p>Explicit casting has to be done when the source type is extended or
implemented by the target type (casting to a</p>
<p>subtype). This can produce a runtime exception (ClassCastException)
when the object being cast is not of the</p>
<p>target type (or the target's subtype).</p>
<p>Float floatVar = <strong>new</strong> Float(42.0f);</p>
<p>Number n = floatVar; <em>//Implicit (Float implements Number)</em>
Float floatVar2 = (Float) n; <em>//Explicit</em></p>
<p><em>Double doubleVar = (Double) n;</em> //Throws exception (the
object is not Double)</p>
<p>Section 2.5: Testing if an object can be cast using instanceof</p>
<p>Java provides the <strong>instanceof</strong> operator to test if an
object is of a certain type, or a subclass of that type. The program can
then choose to cast or not cast that object accordingly.</p>
<p>Object obj = Calendar.getInstance();</p>
<p><strong>long</strong> time = 0;</p>
<p><strong>if</strong>(obj <strong>instanceof</strong> Calendar)</p>
<p>{</p>
<p>time = ((Calendar)obj).getTime();</p>
<p>}</p>
<p>if<strong>(obj</strong> instanceof <strong>Date)</strong></p>
<p>{</p>
<p><em>time = ((Date)obj).getTime();</em> // This line will never be
reached, obj is not a Date type. <em>}</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 9</p>
<p><span id="Chapter_3__Getters_and_Setters"
class="anchor"></span>Chapter 3: Getters and Setters</p>
<p>This article discusses getters and setters; the standard way to
provide access to data in Java classes.</p>
<p>Section 3.1: Using a setter or getter to implement a constraint</p>
<p>Setters and Getters allow for an object to contain private variables
which can be accessed and changed with</p>
<p>restrictions. For example,</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String name;</p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p><strong>if</strong>(name!=<strong>null</strong> &amp;&amp;
name.length()&gt;2)</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p>In this Person class, there is a single variable: name. This variable
can be accessed using the getName() method and changed using the
setName(String) method, however, setting a name requires the new name to
have a length</p>
<p>greater than 2 characters and to not be null. Using a setter method
rather than making the variable name public allows others to set the
value of name with certain restrictions. The same can be applied to the
getter method:</p>
<p><strong>public</strong> String getName(){</p>
<p><strong>if</strong>(name.length()&gt;16)</p>
<p><strong>return</strong> "Name is too large!";</p>
<p>else</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p>In the modified getName() method above, the name is returned only if
its length is less than or equal to 16.</p>
<p>Otherwise, "Name is too large" is returned. This allows the
programmer to create variables that are reachable</p>
<p>and modifiable however they wish, preventing client classes from
editing the variables unwantedly.</p>
<p>Section 3.2: Why Use Getters and Setters?</p>
<p>Consider a basic class containing an object with getters and setters
in Java:</p>
<p><strong>public class</strong> CountHolder {</p>
<p>private int <strong>count = 0;</strong></p>
<p><strong>public int</strong> getCount() { <strong>return</strong>
count; }</p>
<p><strong>public void</strong> setCount(<strong>int</strong> c) { count
= c; }</p>
<p>}</p>
<p>We can't access the count variable because it's private. But we can
access the getCount() and the setCount(<strong>int</strong>)</p>
<p>methods because they are public. To some, this might raise the
question; why introduce the middleman? Why not just simply make they
count public?</p>
<p><strong>public class</strong> CountHolder {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 10</p>
<p><span id="public_int_count___0" class="anchor"></span><strong>public
int</strong> count = 0;</p>
<p>}</p>
<p>For all intents and purposes, these two are exactly the same,
functionality-wise. The difference between them is the</p>
<p>extensibility. Consider what each class says:</p>
<p><strong>First</strong>: "I have a method that will give you an
<strong>int</strong> value, and a method that will set that value to
another <strong>int</strong>".</p>
<p><strong>Second</strong>: "I have an <strong>int</strong> that you can
set and get as you please."</p>
<p>These might sound similar, but the first is actually much more
guarded in its nature; it only lets you interact with its internal
nature as <strong>it</strong> dictates. This leaves the ball in its
court; it gets to choose how the internal interactions occur.</p>
<p>The second has exposed its internal implementation externally, and is
now not only prone to external users, but, in</p>
<p>the case of an API, <strong>committed</strong> to maintaining that
implementation (or otherwise releasing a non-backward-</p>
<p>compatible API).</p>
<p>Lets consider if we want to synchronize access to modifying and
accessing the count. In the first, this is simple:</p>
<p><strong>public class</strong> CountHolder {</p>
<p>private int <strong>count = 0;</strong></p>
<p>public synchronized int <strong>getCount() {</strong> return
<strong>count; }</strong></p>
<p><strong>public synchronized void</strong>
setCount(<strong>int</strong> c) { count = c; }</p>
<p>}</p>
<p>but in the second example, this is now nearly impossible without
going through and modifying each place where the count variable is
referenced. Worse still, if this is an item that you're providing in a
library to be consumed by</p>
<p>others, you do <strong>not</strong> have a way of performing that
modification, and are forced to make the hard choice mentioned</p>
<p>above.</p>
<p>So it begs the question; are public variables ever a good thing (or,
at least, not evil)?</p>
<p>I'm unsure. On one hand, you can see examples of public variables
that have stood the test of time (IE: the out variable referenced in
System.out). On the other, providing a public variable gives no benefit
outside of extremely</p>
<p>minimal overhead and potential reduction in wordiness. My guideline
here would be that, if you're planning on</p>
<p>making a variable public, you should judge it against these criteria
with <strong>extreme</strong> prejudice:</p>
<p>1. The variable should have no conceivable reason to
<strong>ever</strong> change in its implementation. This is
something</p>
<p>that's extremely easy to screw up (and, even if you do get it right,
requirements can change), which is why</p>
<p>getters/setters are the common approach. If you're going to have a
public variable, this really needs to be thought through, especially if
released in a library/framework/API.</p>
<p>2. The variable needs to be referenced frequently enough that the
minimal gains from reducing verbosity</p>
<p>warrants it. I don't even think the overhead for using a method
versus directly referencing should be</p>
<p>considered here. It's far too negligible for what I'd conservatively
estimate to be 99.9% of applications.</p>
<p>There's probably more than I haven't considered off the top of my
head. If you're ever in doubt, always use</p>
<p>getters/setters.</p>
<p>Section 3.3: Adding Getters and Setters</p>
<p>Encapsulation is a basic concept in OOP. It is about wrapping data
and code as a single unit. In this case, it is a good</p>
<p>practice to declare the variables as <strong>private</strong> and
then access them through Getters and Setters to view and/or modify
them.</p>
<p>public class <strong>Sample {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 11</p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>age;</strong></p>
<p><strong>public int</strong> getAge() {</p>
<p>return <strong>age;</strong></p>
<p>}</p>
<p><strong>public void</strong> setAge(<strong>int</strong> age) {</p>
<p><strong>this</strong>.age = age;</p>
<p>}</p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p>These private variables cannot be accessed directly from outside the
class. Hence they are protected from</p>
<p>unauthorized access. But if you want to view or modify them, you can
use Getters and Setters.</p>
<p>getXxx() method will return the current value of the variable xxx,
while you can set the value of the variable xxx</p>
<p>using setXxx().</p>
<p>The naming convention of the methods are (in example variable is
called variableName):</p>
<p>All non <strong>boolean</strong> variables</p>
<p><em>getVariableName()</em> //Getter, The variable name should start
with uppercase <em>setVariableName(..)</em> //Setter, The variable name
should start with uppercase</p>
<p><strong>boolean</strong> variables</p>
<p><em>isVariableName()</em> //Getter, The variable name should start
with uppercase <em>setVariableName(...)</em> //Setter, The variable name
should start with uppercase</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html">Public
Getters and Setters are part of the Property definition of a Java
Bean.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 12</p>
<p><span id="Chapter_4__Reference_Data_Types"
class="anchor"></span>Chapter 4: Reference Data Types</p>
<p>Section 4.1: Dereferencing</p>
<p>Dereferencing happens with the . operator:</p>
<p>Object obj = <strong>new</strong> Object();</p>
<p>String text = obj.toString(); <em>// 'obj' is dereferenced.</em></p>
<p>Dereferencing <em>follows</em> the memory address stored in a
reference, to the place in memory where the actual object</p>
<p>resides. When an object has been found, the requested method is
called (toString in this case).</p>
<p>When a reference has the value <strong>null</strong>, dereferencing
results in a NullPointerException:</p>
<p>Object obj = <strong>null</strong>;</p>
<p><em>obj.toString();</em> // Throws a NullpointerException when this
statement is executed.</p>
<p><strong>null</strong> indicates the absence of a value, i.e.
<em>following</em> the memory address leads nowhere. So there is no
object on</p>
<p>which the requested method can be called.</p>
<p>Section 4.2: Instantiating a reference type</p>
<p><em>Object obj = <strong>new</strong> Object();</em> // Note the
'new' keyword</p>
<p>Where:</p>
<p>Object is a reference type.</p>
<p>obj is the variable in which to store the new reference.</p>
<p>Object() is the call to a constructor of Object.</p>
<p>What happens:</p>
<p>Space in memory is allocated for the object.</p>
<p>The constructor Object() is called to initialize that memory
space.</p>
<p>The memory address is stored in obj, so that it <em>references</em>
the newly created object.</p>
<p>This is different from primitives:</p>
<p><strong>int</strong> i = 10;</p>
<p>Where the actual value 10 is stored in i.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 13</p>
<p><span id="Chapter_5__Java_Compiler____java"
class="anchor"></span>Chapter 5: Java Compiler - 'javac'</p>
<p>Section 5.1: The 'javac' command - getting started</p>
<p>Simple example</p>
<p>Assuming that the "HelloWorld.java" contains the following Java
source:</p>
<p><strong>public class</strong> HelloWorld {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println("Hello world!");</p>
<p>}</p>
<p>}</p>
<p>(For an explanation of the above code, please refer to Getting
started with Java Language .)</p>
<p>We can compile the above file using this command:</p>
<p>$ javac HelloWorld.java</p>
<p>This produces a file called "HelloWorld.class", which we can then run
as follows:</p>
<p>$ java HelloWorld</p>
<p>Hello world!</p>
<p>The key points to note from this example are:</p>
<p>1. The source filename "HelloWorld.java" must match the class name in
the source file ... which is HelloWorld. If</p>
<p>they don't match, you will get a compilation error.</p>
<p>2. The bytecode filename "HelloWorld.class" corresponds to the
classname. If you were to rename the</p>
<p>"HelloWorld.class", you would get an error when your tried to run
it.</p>
<p>3. When running a Java application using java, you supply the
classname NOT the bytecode filename.</p>
<p>Example with packages</p>
<p>Most practical Java code uses packages to organize the namespace for
classes and reduce the risk of accidental class name collision.</p>
<p>If we wanted to declare the HelloWorld class in a package call
com.example, the "HelloWorld.java" would contain the following Java
source:</p>
<p><strong>package</strong> com.example;</p>
<p><strong>public class</strong> HelloWorld {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println("Hello world!");</p>
<p>}</p>
<p>}</p>
<p>This source code file needs to stored in a directory tree whose
structure corresponds to the package naming.</p>
<p>. # the current directory (<strong>for this</strong> example)</p>
<p>|</p>
<p>----com</p>
<p>|</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 14</p>
<p>----example</p>
<p>|</p>
<p>----HelloWorld.java</p>
<p>We can compile the above file using this command:</p>
<p>$ javac com/example/HelloWorld.java</p>
<p>This produces a file called "com/example/HelloWorld.class"; i.e.
after compilation, the file structure should look like this:</p>
<p>. # the current directory (<strong>for this</strong> example)</p>
<p>|</p>
<p>----com</p>
<p>|</p>
<p>----example</p>
<p>|</p>
<p>----HelloWorld.java</p>
<p>----HelloWorld.<strong>class</strong></p>
<p>We can then run the application as follows:</p>
<p>$ java com.example.HelloWorld</p>
<p>Hello world!</p>
<p>Additional points to note from this example are:</p>
<p>1. The directory structure must match the package name structure.</p>
<p>2. When you run the class, the full class name must be supplied; i.e.
"com.example.HelloWorld" not</p>
<p>"HelloWorld".</p>
<p>3. You don't have to compile and run Java code out of the current
directory. We are just doing it here for</p>
<p>illustration.</p>
<p>Compiling multiple files at once with 'javac'.</p>
<p>If your application consists of multiple source code files (and most
do!) you can compile them one at a time.</p>
<p>Alternatively, you can compile multiple files at the same time by
listing the pathnames:</p>
<p>$ javac Foo.java Bar.java</p>
<p>or using your command shell's filename wildcard functionality
....</p>
<p>$ javac *.java</p>
<p>$ javac com/example<em>/*.java</em></p>
<p>$ javac */<em>**</em>/*.java #Only works on Zsh or with globstar
enabled on your shell</p>
<p>This will compile all Java source files in the current directory, in
the "com/example" directory, and recursively in child directories
respectively. A third alternative is to supply a list of source
filenames (and compiler options) as a</p>
<p>file. For example:</p>
<p>$ javac @sourcefiles</p>
<p>where the sourcefiles file contains:</p>
<p>Foo.java</p>
<p>Bar.java</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 15</p>
<p><span id="com_example_HelloWorld_java"
class="anchor"></span>com/example/HelloWorld.java</p>
<p>Note: compiling code like this is appropriate for small one-person
projects, and for once-off programs. Beyond that,</p>
<p><a href="https://netbeans.org/">it is advisable to select and use a
Java build tool. Alternatively, most programmers use a Java IDE (e.g.
NetBeans,</a></p>
<p><a href="https://eclipse.org/">eclipse</a><a
href="https://www.jetbrains.com/idea/">, IntelliJ IDEA</a>) which offers
an embedded compiler and incremental building of "projects".</p>
<p>Commonly used 'javac' options</p>
<p>Here are a few options for the javac command that are likely to be
useful to you</p>
<p>The -d option sets a destination directory for writing the ".class"
files. The -sourcepath option sets a source code search path.</p>
<p>The -cp or -classpath option sets the search path for finding
external and previously compiled classes. For more information on the
classpath and how to specify it, refer to the The Classpath Topic.</p>
<p>The -version option prints the compiler's version information.</p>
<p>A more complete list of compiler options will be described in a
separate example.</p>
<p>References</p>
<p>The definitive reference for the javac command is the <a
href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html">Oracle
manual page for javac.</a></p>
<p>Section 5.2: Compiling for a dierent version of Java</p>
<p>The Java programming language (and its runtime) has undergone
numerous changes since its release since its</p>
<p>initial public release. These changes include:</p>
<p>Changes in the Java programming language syntax and semantics</p>
<p>Changes in the APIs provided by the Java standard class libraries.
Changes in the Java (bytecode) instruction set and classfile format.</p>
<p>With very few exceptions (for example the <strong>enum</strong>
keyword, changes to some "internal" classes, etc), these changes</p>
<p>are backwards compatible.</p>
<p>A Java program that was compiled using an older version of the Java
toolchain will run on a newer version</p>
<p>Java platform without recompilation.</p>
<p>A Java program that was written in an older version of Java will
compile successfully with a new Java compiler.</p>
<p>Compiling old Java with a newer compiler</p>
<p>If you need to (re-)compile older Java code on a newer Java platform
to run on the newer platform, you generally don't need to give any
special compilation flags. In a few cases (e.g. if you had used
<strong>enum</strong> as an identifier) you could</p>
<p>use the -source option to disable the new syntax. For example, given
the following class:</p>
<p>public class <strong>OldSyntax {</strong></p>
<p><em><strong>private static int enum</strong>;</em> // invalid in Java
5 or later</p>
<p>}</p>
<p>the following is required to compile the class using a Java 5
compiler (or later):</p>
<p>$ javac -source 1.4 OldSyntax.java</p>
<p>Compiling for an older execution platform</p>
<p>If you need to compile Java to run on an older Java platforms, the
simplest approach is to install a JDK for the oldest</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 16</p>
<p>version you need to support, and use that JDK's compiler in your
builds.</p>
<p>You can also compile with a newer Java compiler, but there are
complicated. First of all, there some important</p>
<p>preconditions that must be satisfied:</p>
<p>The code you are compiling must not use Java language constructs that
were not available in the version of</p>
<p>Java that you are targeting.</p>
<p>The code must not depend on standard Java classes, fields, methods
and so on that were not available in the</p>
<p>older platforms.</p>
<p>Third party libraries that the code depends must also be built for
the older platform and available at compile-</p>
<p>time and run-time.</p>
<p>Given the preconditions are met, you can recompile code for an older
platform using the -target option. For</p>
<p>example,</p>
<p>$ javac -target 1.4 SomeClass.java</p>
<p>will compile the above class to produce bytecodes that are compatible
with Java 1.4 or later JVM. (In fact, the -source option implies a
compatible -target, so javac -source 1.4 ... would have the same effect.
The</p>
<p>relationship between -source and -target is described in the Oracle
documentation.)</p>
<p>Having said that, if you simply use -target or -source, you will
still be compiling against the standard class libraries</p>
<p>provided by the compiler's JDK. If you are not careful, you can end
up with classes with the correct bytecode version, but with dependencies
on APIs that are not available. The solution is to use the
-bootclasspath option. For</p>
<p>example:</p>
<p>$ javac -target 1.4--bootclasspath path/to/java1.4/rt.jar
SomeClass.java</p>
<p>will compile against an alternative set of runtime libraries. If the
class being compiled has (accidental) dependencies on newer libraries,
this will give you compilation errors.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 17</p>
<p><span id="Chapter_6__Documenting_Java_Code"
class="anchor"></span>Chapter 6: Documenting Java Code</p>
<p>Documentation for java code is often generated using <a
href="http://www.oracle.com/technetwork/articles/java/index-jsp-135444.html">javadoc</a>.
Javadoc was created by Sun Microsystems for the</p>
<p>purpose of <a href="https://en.wikipedia.org/wiki/Javadoc">generating
API documentation in HTML format from java source code. Using the HTML
format gives the</a> convenience of being able to hyperlink related
documents together.</p>
<p>Section 6.1: Building Javadocs From the Command Line</p>
<p>Many IDEs provide support for generating HTML from Javadocs
automatically; some build tools (<a
href="https://maven.apache.org/">Maven and</a> <a
href="https://gradle.org/">Gradle</a>, for example) also have plugins
that can handle the HTML creation.</p>
<p>However, these tools are not required to generate the Javadoc HTML;
this can be done using the command line javadoc tool.</p>
<p>The most basic usage of the tool is:</p>
<p>javadoc JavaFile.java</p>
<p>Which will generate HTML from the Javadoc comments in
JavaFile.java.</p>
<p>A more practical use of the command line tool, which will recursively
read all java files in [source-directory], create documentation for
[<strong>package</strong>.name] and all sub-packages, and place the
generated HTML in the [docs-</p>
<p>directory] is:</p>
<p>javadoc -d [docs-directory]-subpackages -sourcepath
[source-directory] [<strong>package</strong>.name]</p>
<p>Section 6.2: Class Documentation</p>
<p>All Javadoc comments begin with a block comment followed by an
asterisk (<em>/**</em>) and end when the block comment does (*/).
Optionally, each line can begin with arbitrary whitespace and a single
asterisk; these are ignored when</p>
<p>the documentation files are generated.</p>
<p>/**</p>
<p>* Brief summary of this class, ending with a period. *</p>
<p>* It is common to leave a blank line between the summary and further
details. * The summary (everything before the first period) is used in
the class or package * overview section.</p>
<p>*</p>
<p>* The following inline tags can be used (not an exhaustive list): *
{@link some.other.class.Documentation} for linking to other docs or
symbols * {@link some.other.class.Documentation Some Display Name} the
link's appearance can be * customized by adding a display name after the
doc or symbol locator * {@code code goes here} for formatting as
code</p>
<p>* {@literal &lt;&gt;[]()foo} for interpreting literal text without
converting to HTML markup * or other tags.</p>
<p>*</p>
<p>* Optionally, the following tags may be used at the end of class
documentation * (not an exhaustive list):</p>
<p>*</p>
<p>* @author John Doe</p>
<p>* @version 1.0</p>
<p>* @since 5/10/15</p>
<p>* @see some.other.class.Documentation</p>
<p>* @deprecated This class has been replaced by
some.other.package.BetterFileReader *</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 18</p>
<p><span id="__You_can_also_have_custom_tags" class="anchor"></span> *
You can also have custom tags for displaying additional information. *
Using the @custom.&lt;NAME&gt; tag and the -tag
custom.&lt;NAME&gt;:htmltag:"context" * command line option, you can
create a custom tag. *</p>
<p>* Example custom tag and generation:</p>
<p>* @custom.updated 2.0</p>
<p>* Javadoc flag: -tag custom.updated:a:"Updated in version:" * The
above flag will display the value of @custom.updated under "Updated in
version:" *</p>
<p>*/</p>
<p><strong>public class</strong> FileReader {</p>
<p>}</p>
<p>The same tags and format used for Classes can be used for Enums and
Interfaces as well.</p>
<p>Section 6.3: Method Documentation</p>
<p>All Javadoc comments begin with a block comment followed by an
asterisk (<em>/**</em>) and end when the block comment</p>
<p>does (*/). Optionally, each line can begin with arbitrary whitespace
and a single asterisk; these are ignored when the documentation files
are generated.</p>
<p>/**</p>
<p>* Brief summary of method, ending with a period.</p>
<p>*</p>
<p>* Further description of method and what it does, including as much
detail as is * appropriate. Inline tags such as</p>
<p>* {@code code here}, {@link some.other.Docs}, and {@literal text
here} can be used. *</p>
<p>* If a method overrides a superclass method, {@inheritDoc} can be
used to copy the * documentation</p>
<p>* from the superclass method</p>
<p>*</p>
<p>* @param stream Describe this parameter. Include as much detail as is
appropriate * Parameter docs are commonly aligned as here, but this is
optional. * As with other docs, the documentation before the first
period is * used as a summary.</p>
<p>*</p>
<p>* @return Describe the return values. Include as much detail as is
appropriate * Return type docs are commonly aligned as here, but this is
optional. * As with other docs, the documentation before the first
period is used as a * summary.</p>
<p>*</p>
<p>* @throws IOException Describe when and why this exception can be
thrown. * Exception docs are commonly aligned as here, but this is *
optional.</p>
<p>* As with other docs, the documentation before the first period * is
used as a summary.</p>
<p>* Instead of @throws, @exception can also be used. *</p>
<p>* @since 2.1.0</p>
<p>* @see some.other.class.Documentation</p>
<p>* @deprecated Describe why this method is outdated. A replacement can
also be specified. */</p>
<p><strong>public</strong> String[] read(InputStream stream)
<strong>throws</strong> IOException {</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 19</p>
<p><span id="Section_6_4__Package_Documentati"
class="anchor"></span>Section 6.4: Package Documentation</p>
<p>Version ≥ Java SE 5</p>
<p>It is possible to create package-level documentation in Javadocs
using a file called package-info.java. This file</p>
<p>must be formatted as below. Leading whitespace and asterisks
optional, typically present in each line for formatting reason</p>
<p>/**</p>
<p>* Package documentation goes here; any documentation before the first
period will * be used as a summary.</p>
<p>*</p>
<p>* It is common practice to leave a blank line between the summary and
the rest * of the documentation; use this space to describe the package
in as much detail * as is appropriate.</p>
<p>*</p>
<p>* Inline tags such as {@code code here}, {@link
reference.to.other.Documentation}, * and {@literal text here} can be
used in this documentation. */</p>
<p><strong>package</strong> com.example.foo;</p>
<p>// The rest of the file must be empty.</p>
<p>In the above case, you must put this file package-info.java inside
the folder of the Java package com.example.foo.</p>
<p>Section 6.5: Links</p>
<p>Linking to other Javadocs is done with the @link tag:</p>
<p>/**</p>
<p>* You can link to the javadoc of an already imported class using
{@link ClassName}. *</p>
<p>* You can also use the fully-qualified name, if the class is not
already imported: * {@link some.other.ClassName}</p>
<p>*</p>
<p>* You can link to members (fields or methods) of a class like so: *
{@link ClassName#someMethod()}</p>
<p>* {@link ClassName#someMethodWithParameters(int, String)} * {@link
ClassName#someField}</p>
<p>* {@link #someMethodInThisClass()} - used to link to members in the
current class *</p>
<p>* You can add a label to a linked javadoc like so: * {@link
ClassName#someMethod() link text}</p>
<p>*/</p>
<p><img src="media/index-44_1.png"
style="width:6.41667in;height:2.40278in" alt="index-44_1.png" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 20</p>
<p><span id="With_the__see_tag_you_can_add_el"
class="anchor"></span>With the @see tag you can add elements to the
<em>See also</em> section. Like @param or @<strong>return</strong> the
place where they appear is not relevant. The spec says you should write
it after @<strong>return</strong>.</p>
<p>/**</p>
<p>* This method has a nice explanation but you might found further *
information at the bottom.</p>
<p>*</p>
<p>* @see ClassName#someMethod()</p>
<p>*/</p>
<p><img src="media/index-45_1.png"
style="width:3.88889in;height:0.81944in" alt="index-45_1.png" /></p>
<p>If you want to add <strong>links to external resources</strong> you
can just use the HTML <strong>&lt;a&gt;</strong> tag. You can use it
inline anywhere</p>
<p>or inside both @link and @see tags.</p>
<p>/**</p>
<p>* Wondering how this works? You might want</p>
<p>* to check this &lt;a href="http://stackoverflow.com/"&gt;great
service&lt;/a&gt;. *</p>
<p>* @see &lt;a href="http://stackoverflow.com/"&gt;Stack
Overflow&lt;/a&gt; */</p>
<p><img src="media/index-45_2.png"
style="width:4.59722in;height:0.77778in" alt="index-45_2.png" /></p>
<p>Section 6.6: Code snippets inside documentation</p>
<p>The canonical way of writing code inside documentation is with the
{@code } construct. If you have multiline code wrap inside
<strong>&lt;pre&gt;&lt;/pre&gt;</strong>.</p>
<p>/**</p>
<p>* The Class TestUtils.</p>
<p>* &lt;p&gt;</p>
<p>* This is an {@code inline("code example")}.</p>
<p>* &lt;p&gt;</p>
<p>* You should wrap it in pre tags when writing multiline code. *
&lt;pre&gt;{@code</p>
<p>* Example example1 = new FirstLineExample();</p>
<p>* example1.butYouCanHaveMoreThanOneLine();</p>
<p>* }&lt;/pre&gt;</p>
<p>* &lt;p&gt;</p>
<p>* Thanks for reading.</p>
<p>*/</p>
<p><strong>class</strong> TestUtils {</p>
<p>Sometimes you may need to put some complex code inside the javadoc
comment. The @ sign is specially</p>
<p>problematic. The use of the old <strong>&lt;code&gt;</strong> tag
alongside the {@literal } construct solves the problem.</p>
<p>/**</p>
<p>* Usage:</p>
<p>* &lt;pre&gt;&lt;code&gt;</p>
<p>* class SomethingTest {</p>
<p>* {@literal @}Rule</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 21</p>
<p><span id="___public_SingleTestRule_singleT" class="anchor"></span> *
public SingleTestRule singleTestRule = new SingleTestRule("test1");
*</p>
<p>* {@literal @}Test</p>
<p>* public void test1() {</p>
<p>* // only this test will be executed</p>
<p>* }</p>
<p>*</p>
<p>* ...</p>
<p>* }</p>
<p>* &lt;/code&gt;&lt;/pre&gt;</p>
<p>*/</p>
<p><strong>class</strong> SingleTestRule <strong>implements</strong>
TestRule { }</p>
<p>Section 6.7: Field Documentation</p>
<p>All Javadoc comments begin with a block comment followed by an
asterisk (<em>/**</em>) and end when the block comment</p>
<p>does (*/). Optionally, each line can begin with arbitrary whitespace
and a single asterisk; these are ignored when the documentation files
are generated.</p>
<p>/**</p>
<p>* Fields can be documented as well.</p>
<p>*</p>
<p>* As with other javadocs, the documentation before the first period
is used as a * summary, and is usually separated from the rest of the
documentation by a blank * line.</p>
<p>*</p>
<p>* Documentation for fields can use inline tags, such as: * {@code
code here}</p>
<p>* {@literal text here}</p>
<p>* {@link other.docs.Here}</p>
<p>*</p>
<p>* Field documentation can also make use of the following tags: *</p>
<p>* @since 2.1.0</p>
<p>* @see some.other.class.Documentation</p>
<p>* @deprecated Describe why this field is outdated</p>
<p>*/</p>
<p><strong>public static final</strong> String CONSTANT_STRING =
"foo";</p>
<p>Section 6.8: Inline Code Documentation</p>
<p>Apart from the Javadoc documentation code can be documented
inline.</p>
<p>Single Line comments are started by // and may be positioned after a
statement on the same line, but not before.</p>
<p>public void <strong>method() {</strong></p>
<p>//single line comment</p>
<p><em>someMethodCall();</em> //single line comment after statement</p>
<p>}</p>
<p>Multi-Line comments are defined between /* and */. They can span
multiple lines and may even been positioned between statements.</p>
<p><strong>public void</strong> method(Object object) {</p>
<p>/*</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 22</p>
<p>multi</p>
<p>line</p>
<p>comment</p>
<p>*/</p>
<p><em>object</em>/*inner-line-comment*/<em>.method();</em></p>
<p>}</p>
<p>JavaDocs are a special form of multi-line comments, starting with
<em>/**</em>.</p>
<p>As too many inline comments may decrease readability of code, they
should be used sparsely in case the code isn't</p>
<p>self-explanatory enough or the design decision isn't obvious.</p>
<p>An additional use case for single-line comments is the use of TAGs,
which are short, convention driven keywords.</p>
<p>Some development environments recognize certain conventions for such
single-comments. Common examples are</p>
<p>//TODO</p>
<p>//FIXME</p>
<p>Or issue references, i.e. for Jira</p>
<p>//PRJ-1234</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 23</p>
<p><span id="Chapter_7__Command_line_Argument"
class="anchor"></span>Chapter 7: Command line Argument</p>
<p>Processing</p>
<p>Parameter Details</p>
<p>args will be non-null, and will have no The command line arguments.
Assuming that the main method is invoked by the Java launcher, args
<strong>null</strong> elements.</p>
<p>Section 7.1: Argument processing using GWT ToolBase</p>
<p>If you want to parse more complex command-line arguments, e.g. with
optional parameters, than the best is to use google's GWT approach. All
classes are public available at:</p>
<p><a
href="https://gwt.googlesource.com/gwt/+/2.8.0-beta1/dev/core/src/com/google/gwt/util/tools/ToolBase.java">https://gwt.googlesource.com/gwt/+/2.8.0-beta1/dev/core/src/com/google/gwt/util/tools/ToolBase.java</a></p>
<p>An example for handling the command-line myprogram -dir
"~/Documents"-port 8888 is:</p>
<p><strong>public class</strong> MyProgramHandler
<strong>extends</strong> ToolBase {</p>
<p><strong>protected</strong> File dir;</p>
<p>protected int <strong>port;</strong></p>
<p>// getters for dir and port</p>
<p>...</p>
<p><strong>public</strong> MyProgramHandler() {</p>
<p><strong>this</strong>.registerHandler(<strong>new</strong>
ArgHandlerDir() {</p>
<p>@Override</p>
<p><strong>public void</strong> setDir(File dir) {</p>
<p><strong>this</strong>.dir = dir;</p>
<p>}</p>
<p>});</p>
<p><strong>this</strong>.registerHandler(<strong>new</strong>
ArgHandlerInt() {</p>
<p>@Override</p>
<p><strong>public</strong> String[] getTagArgs() {</p>
<p><strong>return new</strong> String[]{"port"};</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> setInt(<strong>int</strong> value) {</p>
<p><strong>this</strong>.port = value;</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>MyProgramHandler myShell = <strong>new</strong>
MyProgramHandler();</p>
<p><strong>if</strong> (myShell.processArgs(args)) {</p>
<p>// main program operation</p>
<p>System.out.println(String.format("port: %d; dir: %s",</p>
<p>myShell.getPort(), myShell.getDir()));</p>
<p>}</p>
<p>System.exit(1);</p>
<p>}</p>
<p>}</p>
<p>ArgHandler also has a method isRequired() which can be overwritten to
say that the command-line argument is</p>
<p>required (default return is <strong>false</strong> so that the
argument is optional.</p>
<p>Section 7.2: Processing arguments by hand</p>
<p>When the command-line syntax for an application is simple, it is
reasonable to do the command argument</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 24</p>
<p>processing entirely in custom code.</p>
<p>In this example, we will present a series of simple case studies. In
each case, the code will produce error messages</p>
<p>if the arguments are unacceptable, and then call System.exit(1) to
tell the shell that the command has failed. (We will assume in each case
that the Java code is invoked using a wrapper whose name is
"myapp".)</p>
<p>A command with no arguments</p>
<p>In this case-study, the command requires no arguments. The code
illustrates that args.length gives us the number of command line
arguments.</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>if</strong> (args.length &gt; 0) {</p>
<p>System.err.println("usage: myapp");</p>
<p>System.exit(1);</p>
<p>}</p>
<p>// Run the application</p>
<p>System.out.println("It worked");</p>
<p>}</p>
<p>}</p>
<p>A command with two arguments</p>
<p>In this case-study, the command requires at precisely two
arguments.</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>if</strong> (args.length != 2) {</p>
<p>System.err.println("usage: myapp ");</p>
<p>System.exit(1);</p>
<p>}</p>
<p>// Run the application</p>
<p>System.out.println("It worked: " + args[0] + ", " + args[1]);</p>
<p>}</p>
<p>}</p>
<p>Note that if we neglected to check args.length, the command would
crash if the user ran it with too few</p>
<p>command-line arguments.</p>
<p>A command with "flag" options and at least one argument</p>
<p>In this case-study, the command has a couple of (optional) flag
options, and requires at least one argument after</p>
<p>the options.</p>
<p>package <strong>tommy;</strong></p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>boolean <strong>feelMe =</strong> false<strong>;</strong></p>
<p>boolean <strong>seeMe =</strong> false<strong>;</strong></p>
<p><strong>int</strong> index;</p>
<p>loop: <strong>for</strong> (index = 0; index &lt; args.length;
index++) {</p>
<p>String opt = args[index];</p>
<p><strong>switch</strong> (opt) {</p>
<p><strong>case</strong> "-c":</p>
<p>seeMe = <strong>true</strong>;</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "-f":</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 25</p>
<p>feelMe = <strong>true</strong>;</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p><strong>if</strong> (!opts.isEmpty() &amp;&amp; opts.charAt(0) ==
'-') {</p>
<p>error("Unknown option: '" + opt + "'");</p>
<p>}</p>
<p><strong>break</strong> loop;</p>
<p>}</p>
<p>}</p>
<p><strong>if</strong> (index &gt;= args.length) {</p>
<p>error("Missing argument(s)");</p>
<p>}</p>
<p>// Run the application</p>
<p>// ...</p>
<p>}</p>
<p><strong>private static void</strong> error(String message) {</p>
<p><strong>if</strong> (message != <strong>null</strong>) {</p>
<p>System.err.println(message);</p>
<p>}</p>
<p>System.err.println("usage: myapp [-f] [-c] [ ...]");
System.exit(1);</p>
<p>}</p>
<p>}</p>
<p>As you can see, processing the arguments and options gets rather
cumbersome if the command syntax is</p>
<p>complicated. It is advisable to use a "command line parsing" library;
see the other examples.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 26</p>
<p><span id="Chapter_8__The_Java_Command____j"
class="anchor"></span>Chapter 8: The Java Command - 'java' and</p>
<p>'javaw'</p>
<p>Section 8.1: Entry point classes</p>
<p>A Java entry-point class has a main method with the following
signature and modifiers:</p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>Sidenote: because of how arrays work, it can also be (String
args[])</p>
<p>When the java command starts the virtual machine, it loads the
specified entry-point classes and tries to find main. If successful, the
arguments from command line are converted to Java String objects and
assembled into an array.</p>
<p>If main is invoked like this, the array will <em>not</em> be
<strong>null</strong> and won't contain any <strong>null</strong>
entries.</p>
<p>A valid entry-point class method must do the following:</p>
<p>Be named main (case-sensitive)</p>
<p><strong>Be</strong> public <strong>and</strong> static</p>
<p>Have a <strong>void</strong> return type</p>
<p>Have a single argument with an array String[]. The argument must be
present and no more than one</p>
<p>argument is allowed.</p>
<p>Be generic: type parameters are not allowed.</p>
<p>Have a non-generic, top-level (not nested or inner) enclosing
class</p>
<p>It is conventional to declare the class as <strong>public</strong>
but this not strictly necessary. From Java 5 onward, the main</p>
<p>method's argument type may be a String varargs instead of a string
array. main can optionally throw exceptions, and its parameter can be
named anything, but conventionally it is args.</p>
<p>JavaFX entry-points</p>
<p>From Java 8 onwards the java command can also directly launch a
JavaFX application. JavaFX is documented in the JavaFX tag, but a JavaFX
entry-point must do the following:</p>
<p>Extend javafx.application.Application</p>
<p><strong>Be</strong> public <strong>and not</strong> abstract</p>
<p>Not be generic or nested</p>
<p>Have an explicit or implicit <strong>public</strong> no-args
constructor</p>
<p>Section 8.2: Troubleshooting the 'java' command</p>
<p>This example covers common errors with using the 'java' command.</p>
<p>"Command not found"</p>
<p>If you get an error message like:</p>
<p>java: command not found</p>
<p>when trying to run the java command, this means that there is no java
command on your shell's command search path. The cause could be:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 27</p>
<p>you don't have a Java JRE or JDK installed at all,</p>
<p>you have not updated the PATH environment variable (correctly) in
your shell initialization file, or</p>
<p>you have not "sourced" the relevant initialization file in the
current shell.</p>
<p>Refer to "Installing Java" for the steps that you need to take.</p>
<p>"Could not find or load main class"</p>
<p>This error message is output by the java command if it has been
unable to find / load the entry-point class that you have specified. In
general terms, there are three broad reasons that this can happen:</p>
<p>You have specified an entry point class that does not exist. The
class exists, but you have specified it incorrectly.</p>
<p>The class exists and you have specified it correctly, but Java cannot
it find it because the classpath is incorrect.</p>
<p>Here is a procedure to diagnose and solve the problem:</p>
<p>1. Find out the full name of the entry-point class.</p>
<p>If you have source code for a class, then the full name consists of
the package name and the simple</p>
<p>class name. The instance the "Main" class is declared in the package
"com.example.myapp" then its full name is "com.example.myapp.Main".</p>
<p>If you have a compiled class file, you can find the class name by
running javap on it.</p>
<p>If the class file is in a directory, you can infer the full class
name from the directory names. If the class file is in a JAR or ZIP
file, you can infer the full class name from the file path in the JAR or
ZIP</p>
<p>file.</p>
<p>2. Look at the error message from the java command. The message
should end with the full class name that</p>
<p>java is trying to use.</p>
<p>Check that it exactly matches the full classname for the entry-point
class.</p>
<p>It should not end with ".java" or ".class".</p>
<p>It should not contain slashes or any other character that is not
legal in a Java identifier1. The casing of the name should exactly match
the full class name.</p>
<p>3. If you are using the correct classname, make sure that the class
is actually on the classpath:</p>
<p>Work out the pathname that the classname maps to; see Mapping
classnames to pathnames</p>
<p>Work out what the classpath is; see this example: Different ways to
specify the classpath</p>
<p>Look at each of the JAR and ZIP files on the classpath to see if they
contain a class with the required pathname.</p>
<p>Look at each directory to see if the pathname resolves to a file
within the directory.</p>
<p>If checking the classpath by hand did not find the issue, you could
add the -Xdiag and -XshowSettings options. The</p>
<p>former lists all classes that are loaded, and the latter prints out
settings that include the effective classpath for the</p>
<p>JVM.</p>
<p>Finally, there are some <em>obscure</em> causes for this problem:</p>
<p>An executable JAR file with a Main-<strong>Class</strong> attribute
that specifies a class that does not exist.</p>
<p>An executable JAR file with an incorrect Class-Path attribute. If you
mess up2 the options before the classname, the java command may attempt
to interpret one of them</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 28</p>
<p><span id="as_the_classname" class="anchor"></span>as the
classname.</p>
<p>If someone has ignored Java style rules and used package or class
identifiers that differ only in letter case,</p>
<p>and you are running on a platform that treats letter case in
filenames as non-significant.</p>
<p>Problems with homoglyphs in class names in the code or on the command
line.</p>
<p>"Main method not found in class &lt;name&gt;"</p>
<p>This problem happens when the java command is able to find and load
the class that you nominated, but is then unable to find an entry-point
method.</p>
<p>There are three possible explanations:</p>
<p>If you are trying to run an executable JAR file, then the JAR's
manifest has an incorrect "Main-Class" attribute that specifies a class
that is not a valid entry point class.</p>
<p>You have told the java command a class that is not an entry point
class.</p>
<p>The entry point class is incorrect; see Entry point classes for more
information.</p>
<p>Other Resources</p>
<p><a
href="http://stackoverflow.com/questions/18093928/what-does-could-not-find-or-load-main-class-mean">What
does "Could not find or load main class" mean?</a></p>
<p><a
href="http://docs.oracle.com/javase/tutorial/getStarted/problems/index.html">http://docs.oracle.com/javase/tutorial/getStarted/problems/index.html</a></p>
<p>1 - From Java 8 and later, the java command will helpfully map a
filename separator ("/" or "") to a period (".").</p>
<p>However, this behavior is not documented in the manual pages.</p>
<p>2 - A really obscure case is if you copy-and-paste a command from a
formatted document where the text editor has</p>
<p>used a "long hyphen" instead of a regular hyphen.</p>
<p>Section 8.3: Running a Java application with library</p>
<p>dependencies</p>
<p>This is a continuation of the "main class" and "executable JAR"
examples.</p>
<p>Typical Java applications consist of an application-specific code,
and various reusable library code that you have implemented or that has
been implemented by third parties. The latter are commonly referred to
as library</p>
<p>dependencies, and are typically packaged as JAR files.</p>
<p>Java is a dynamically bound language. When you run a Java application
with library dependencies, the JVM needs to</p>
<p>know where the dependencies are so that it can load classes as
required. Broadly speaking, there are two ways to deal with this:</p>
<p>The application and its dependencies can be repackaged into a single
JAR file that contains all of the required classes and resources.</p>
<p>The JVM can be told where to find the dependent JAR files via the
runtime classpath.</p>
<p>For an executable JAR file, the runtime classpath is specified by the
"Class-Path" manifest attribute. <em>(Editorial Note:</em> <em>This
should be described in a separate Topic on the jar command.)</em>
Otherwise, the runtime classpath needs to be</p>
<p>supplied using the -cp option or using the CLASSPATH environment
variable.</p>
<p>For example, suppose that we have a Java application in the
"myApp.jar" file whose entry point class is</p>
<p>com.example.MyApp . Suppose also that the application depends on
library JAR files "lib/library1.jar" and "lib/library2.jar". We could
launch the application using the java command as follows in a command
line:</p>
<p>$ # Alternative 1 (preferred)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 29</p>
<p><span id="__java__cp_myApp_jar_lib_library" class="anchor"></span>$
java -cp myApp.jar:lib/library1.jar:lib/library2.jar
com.example.MyApp</p>
<p>$ # Alternative 2</p>
<p>$ export CLASSPATH=myApp.jar:lib/library1.jar:lib/library2.jar $ java
com.example.MyApp</p>
<p>(On Windows, you would use ; instead of : as the classpath separator,
and you would set the (local) CLASSPATH variable using set rather than
export.)</p>
<p>While a Java developer would be comfortable with that, it is not
"user friendly". So it is common practice to write a simple shell script
(or Windows batch file) to hide the details that the user doesn't need
to know about. For</p>
<p>example, if you put the following shell script into a file called
"myApp", made it executable, and put it into a directory on the command
search path:</p>
<p>#!/bin/bash</p>
<p># The 'myApp' wrapper script</p>
<p><strong>export</strong>
DIR=<strong>/</strong>usr<strong>/</strong>libexec<strong>/</strong>myApp</p>
<p><strong>export</strong>
CLASSPATH=$DIR<strong>/</strong>myApp.jar:$DIR<strong>/</strong>lib<strong>/</strong>library1.jar:$DIR<strong>/</strong>lib<strong>/</strong>library2.jar
<strong>java</strong> com.example.MyApp</p>
<p>then you could run it as follows:</p>
<p>$ myApp arg1 arg2 ...</p>
<p>Any arguments on the command line will be passed to the Java
application via the "$@" expansion. (You can do</p>
<p>something similar with a Windows batch file, though the syntax is
different.)</p>
<p>Section 8.4: Java Options</p>
<p>The java command supports a wide range of options:</p>
<p>All options start with a single hyphen or minus-sign (-): the
GNU/Linux convention of using -- for "long" options is not
supported.</p>
<p>Options must appear before the <strong>&lt;classname&gt;</strong> or
the -jar argument to be recognized. Any</p>
<p>arguments after them will be treated as arguments to be passed to
Java app that is being run.</p>
<p>Options that do not start with -X or -XX are standard options. You
can rely on all Java implementations1 to</p>
<p>support any standard option.</p>
<p>Options that start with -X are non-standard options, and may be
withdrawn from one Java version to the next.</p>
<p>Options that start with -XX are advanced options, and may also be
withdrawn.</p>
<p>Setting system properties with -D</p>
<p>The -D= option is used to set a property in the system Properties
object. This parameter can be</p>
<p>repeated to set different properties.</p>
<p>Memory, Stack and Garbage Collector options</p>
<p>The main options for controlling the heap and stack sizes are
documented in Setting the Heap, PermGen and Stack</p>
<p><em>sizes.</em> (Editorial note: Garbage Collector options should be
described in the same topic.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 30</p>
<p><span id="Enabling_and_disabling_assertion"
class="anchor"></span>Enabling and disabling assertions</p>
<p>The -ea and -da options respectively enable and disable Java
<strong>assert</strong> checking:</p>
<p>All assertion checking is disabled by default.</p>
<p>The -ea option enables checking of all assertions</p>
<p>The -ea:... enables checking of assertions in a package <em>and all
subpackages</em>.</p>
<p>The -ea:... enables checking of assertions in a class.</p>
<p>The -da option disables checking of all assertions</p>
<p>The -da:... disables checking of assertions in a package <em>and all
subpackages</em>.</p>
<p>The -da:... disables checking of assertions in a class. The -esa
option enables checking for all system classes.</p>
<p>The -dsa option disables checking for all system classes.</p>
<p>The options can be combined. For example.</p>
<p>$ # Enable all assertion checking in non-system classes $ java -ea
-dsa MyApp</p>
<p>$ # Enable assertions <strong>for</strong> all classes in a
<strong>package</strong> except <strong>for</strong> one. $ java
-ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat MyApp</p>
<p>Note that enabling to assertion checking is liable to alter the
behavior of a Java programming.</p>
<p>It is liable make the application slower in general.</p>
<p>It can cause specific methods to take longer to run, which could
change timing of threads in a multi-threaded application.</p>
<p>It can introduce serendipitous <em>happens-before</em> relations
which can cause memory anomalies to disappear. An incorrectly
implemented <strong>assert</strong> statement could have unwanted
side-effects.</p>
<p>Selecting the VM type</p>
<p>The -client and -server options allow you to select between two
different forms of the HotSpot VM:</p>
<p>The "client" form is tuned for user applications and offers faster
startup. The "server" form is tuned for long running applications. It
takes longer capturing statistic during JVM "warm</p>
<p>up" which allows the JIT compiler to do a better of job of optimizing
the native code.</p>
<p>By default, the JVM will run in 64bit mode if possible, depending on
the capabilities of the platform. The -d32 and -</p>
<p>d64 options allow you to select the mode explicitly.</p>
<p>1 - Check the official manual for the java command. Sometimes a
<em>standard</em> option is described as "subject to</p>
<p>change".</p>
<p>Section 8.5: Spaces and other special characters in</p>
<p>arguments</p>
<p>First of all, the problem of handling spaces in arguments is NOT
actually a Java problem. Rather it is a problem that</p>
<p>needs to be handled by the command shell that you are using when you
run a Java program.</p>
<p>As an example, let us suppose that we have the following simple
program that prints the size of a file:</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>public class</strong> PrintFileSizes {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 31</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>for</strong> (String name: args) {</p>
<p>File file = <strong>new</strong> File(name);</p>
<p>System.out.println("Size of '" + file + "' is " + file.size());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now suppose that we want print the size of a file whose pathname has
spaces in it; e.g. /home/steve/Test</p>
<p>File.txt. If we run the command like this:</p>
<p>$ java PrintFileSizes /home/steve/Test File.txt</p>
<p>the shell won't know that /home/steve/Test File.txt is actually one
pathname. Instead, it will pass 2 distinct arguments to the Java
application, which will attempt to find their respective file sizes, and
fail because files with</p>
<p>those paths (probably) do not exist.</p>
<p>Solutions using a POSIX shell</p>
<p>POSIX shells include sh as well derivatives such as bash and ksh. If
you are using one of these shells, then you can</p>
<p>solve the problem by <em>quoting</em> the argument.</p>
<p>$ java PrintFileSizes "/home/steve/Test File.txt"</p>
<p>The double-quotes around the pathname tell the shell that it should
be passed as a single argument. The quotes</p>
<p>will be removed when this happens. There are a couple of other ways
to do this:</p>
<p>$ java PrintFileSizes '/home/steve/Test File.txt'</p>
<p>Single (straight) quotes are treated like double-quotes except that
they also suppress various expansions within the argument.</p>
<p>$ java PrintFileSizes /home/steve/Test\ File.txt</p>
<p>A backslash escapes the following space, and causes it not to be
interpreted as an argument separator.</p>
<p>For more comprehensive documentation, including descriptions of how
to deal with other special characters in arguments, please refer to the
quoting topic in the Bash documentation.</p>
<p>Solution for Windows</p>
<p>The fundamental problem for Windows is that at the OS level, the
arguments are passed to a child process as a</p>
<p><a
href="https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/">single
string (source</a>). This means that the ultimate responsibility of
parsing (or re-parsing) the command line falls</p>
<p>on either program or its runtime libraries. There is lots of
inconsistency.</p>
<p>In the Java case, to cut a long story short:</p>
<p>You can put double-quotes around an argument in a java command, and
that will allow you to pass arguments with spaces in them.</p>
<p>Apparently, the java command itself is parsing the command string,
and it gets it more or less right</p>
<p>However, when you try to combine this with the use of SET and
variable substitution in a batch file, it gets really complicated as to
whether double-quotes get removed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 32</p>
<p><span id="The_cmd_exe_shell_apparently_has" class="anchor"></span>The
cmd.exe shell apparently has other escaping mechanisms; e.g. doubling
double-quotes, and using ^ escapes.</p>
<p>For more detail, please refer to the Batch-File documentation.</p>
<p>Section 8.6: Running an executable JAR file</p>
<p>Executable JAR files are the simplest way to assemble Java code into
a single file that can be executed. *(Editorial</p>
<p>Note: Creation of JAR files should be covered by a separate Topic.)
*</p>
<p>Assuming that you have an executable JAR file with pathname
<strong>&lt;jar-path&gt;</strong>, you should be able to run it as
follows:</p>
<p>java -jar</p>
<p>If the command requires command-line arguments, add them after the
<strong>&lt;jar-path&gt;</strong>. For example:</p>
<p>java -jar arg1 arg2 arg3</p>
<p>If you need to provide additional JVM options on the java command
line, they need to go <em>before</em> the -jar option.</p>
<p>Note that a -cp / -classpath option will be ignored if you use -jar.
The application's classpath is determined by the JAR file manifest.</p>
<p>Section 8.7: Running a Java applications via a "main" class</p>
<p>When an application has not been packaged as an executable JAR, you
need to provide the name of an entry-point class on the java command
line.</p>
<p>Running the HelloWorld class</p>
<p>The "HelloWorld" example is described in Creating a new Java program
. It consists of a single class called HelloWorld which satisfies the
requirements for an entry-point.</p>
<p>Assuming that the (compiled) "HelloWorld.class" file is in the
current directory, it can be launched as follows:</p>
<p>java HelloWorld</p>
<p>Some important things to note are:</p>
<p>We must provide the name of the class: not the pathname for the
".class" file or the ".java" file. If the class is declared in a package
(as most Java classes are), then the class name we supply to the
java</p>
<p>command must be the full classname. For instance if SomeClass is
declared in the com.example package, then the full classname will be
com.example.SomeClass.</p>
<p>Specifying a classpath</p>
<p>Unless we are using in the java -jar command syntax, the java command
looks for the class to be loaded by</p>
<p>searching the classpath; see The Classpath. The above command is
relying on the default classpath being (or</p>
<p>including) the current directory. We can be more explicit about this
by specifying the classpath to be used using the-cp option.</p>
<p>java -cp . HelloWorld</p>
<p>This says to make the current directory (which is what "." refers to)
the sole entry on the classpath.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 33</p>
<p>The -cp is an option that is processed by the java command. All
options that are intended for the java command should be before the
classname. Anything after the class will be treated as an command line
argument for the Java</p>
<p>application, and will be passed to application in the String[] that
is passed to the main method.</p>
<p>(If no -cp option is provided, the java will use the classpath that
is given by the CLASSPATH environment variable. If</p>
<p>that variable is unset or empty, java uses "." as the default
classpath.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 34</p>
<p><span id="Chapter_9__Literals" class="anchor"></span>Chapter 9:
Literals</p>
<p>A Java literal is a syntactic element (i.e. something you find in the
<em>source code</em> of a Java program) that represents a</p>
<p>value. Examples are 1, 0.333F, <strong>false</strong>, 'X' and "Hello
world<strong>\n</strong>".</p>
<p>Section 9.1: Using underscore to improve readability</p>
<p>Since Java 7 it has been possible to use one or more underscores (_)
for separating groups of digits in a primitive</p>
<p>number literal to improve their readability.</p>
<p>For instance, these two declarations are equivalent:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>int</strong> i1 = 123456;</p>
<p><strong>int</strong> i2 = 123_456;</p>
<p>System.out.println(i1 == i2); <em>// true</em></p>
<p>This can be applied to all primitive number literals as shown
below:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>byte</strong> color = 1_2_3;</p>
<p><strong>short</strong> yearsAnnoDomini= 2_016;</p>
<p><strong>int</strong> socialSecurtyNumber = 999_99_9999;</p>
<p><strong>long</strong> creditCardNumber = 1234_5678_9012_3456L;</p>
<p><strong>float</strong> piFourDecimals = 3.14_15F;</p>
<p><strong>double</strong> piTenDecimals = 3.14_15_92_65_35;</p>
<p>This also works using prefixes for binary, octal and hexadecimal
bases:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>short</strong> binary= 0b0_1_0_1;</p>
<p><strong>int</strong> octal = 07_7_7_7_7_7_7_7_0;</p>
<p><strong>long</strong> hexBytes = 0xFF_EC_DE_5E;</p>
<p>There are a few rules about underscores which <strong>forbid</strong>
their placement in the following places:</p>
<p>At the beginning or end of a number (e.g. _123 or 123_ are
<em>not</em> valid) Adjacent to a decimal point in a floating point
literal (e.g. 1._23 or 1_.23 are <em>not</em> valid)</p>
<p>Prior to an F or L suffix (e.g. 1.23_F or 9999999_L are <em>not</em>
valid) In positions where a string of digits is expected (e.g. 0_xFFFF
is <em>not</em> valid)</p>
<p>Section 9.2: Hexadecimal, Octal and Binary literals</p>
<p>A hexadecimal number is a value in base-16. There are 16 digits, 0-9
and the letters A-F (case does not matter). A-F represent 10-15.</p>
<p>An octal number is a value in base-8, and uses the digits 0-7.</p>
<p>A binary number is a value in base-2, and uses the digits 0 and
1.</p>
<p>All of these numbers result in the same value, 110:</p>
<p><em><strong>int</strong> dec = 110;</em> // no prefix --&gt; decimal
literal</p>
<p><em><strong>int</strong> bin = 0b1101110;</em> // '0b' prefix --&gt;
binary literal <em><strong>int</strong> oct = 0156;</em> // '0' prefix
--&gt; octal literal</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 35</p>
<p><span id="int_hex___0x6E________________0x"
class="anchor"></span><em><strong>int</strong> hex = 0x6E;</em> // '0x'
prefix --&gt; hexadecimal literal</p>
<p>Note that binary literal syntax was introduced in Java 7.</p>
<p>The octal literal can easily be a trap for semantic errors. If you
define a leading '0' to your decimal literals you will</p>
<p>get the wrong value:</p>
<p><em><strong>int</strong> a = 0100;</em> // Instead of 100, a ==
64</p>
<p>Section 9.3: Boolean literals</p>
<p>Boolean literals are the simplest of the literals in the Java
programming language. The two possible <strong>boolean</strong> values
are represented by the literals <strong>true</strong> and
<strong>false</strong>. These are case-sensitive. For example:</p>
<p><em><strong>boolean</strong> flag = <strong>true</strong>;</em> //
using the 'true' literal</p>
<p><em>flag = <strong>false</strong>;</em> // using the 'false'
literal</p>
<p>Section 9.4: String literals</p>
<p>String literals provide the most convenient way to represent string
values in Java source code. A String literal</p>
<p>consists of:</p>
<p>An opening double-quote (") character.</p>
<p>Zero or more other characters that are neither a double-quote or a
line-break character. (A backslash (\) character alters the meaning of
subsequent characters; see Escape sequences in literals.)</p>
<p>A closing double-quote character.</p>
<p>For example:</p>
<p><em>"Hello world"</em> // A literal denoting an 11 character String
<em>""</em> // A literal denoting an empty (zero length) String
<em>"<strong>\"</strong>"</em> // A literal denoting a String consisting
of one</p>
<p>// double quote character</p>
<p><em>"1<strong>\t</strong>2<strong>\t</strong>3<strong>\n</strong>"</em>
// Another literal with escape sequences</p>
<p>Note that a single string literal may not span multiple source code
lines. It is a compilation error for a line-break (or</p>
<p>the end of the source file) to occur before a literal's closing
double-quote. For example:</p>
<p>"Jello world // Compilation error (at the end of the line!)</p>
<p>Long strings</p>
<p>If you need a string that is too long to fit on a line, the
conventional way to express it is to split it into multiple</p>
<p>literals and use the concatenation operator (+) to join the pieces.
For example</p>
<p>String typingPractice = "The quick brown fox " +</p>
<p>"jumped over " +</p>
<p>"the lazy dog"</p>
<p>An expression like the above consisting of string literals and +
satisfies the requirements to be a Constant Expression. That means that
the expression will be evaluated by the compiler and represented at
runtime by a</p>
<p>single String object.</p>
<p>Interning of string literals</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 36</p>
<p><span id="When_class_file_containing_strin"
class="anchor"></span>When class file containing string literals is
loaded by the JVM, the corresponding String objects are
<em>interned</em> by the runtime system. This means that a string
literal used in multiple classes occupies no more space than if it was
used</p>
<p>in one class.</p>
<p>For more information on interning and the string pool, refer to the
String pool and heap storage example in the</p>
<p>Strings topic.</p>
<p>Section 9.5: The Null literal</p>
<p>The Null literal (written as <strong>null</strong>) represents the
one and only value of the null type. Here are some examples</p>
<p>MyClass object = <strong>null</strong>;</p>
<p>MyClass[] objects = <strong>new</strong>
MyClass[]{<strong>new</strong> MyClass(), <strong>null</strong>,
<strong>new</strong> MyClass()};</p>
<p>myMethod(<strong>null</strong>);</p>
<p><strong>if</strong> (objects != <strong>null</strong>) {</p>
<p>// Do something</p>
<p>}</p>
<p>The null type is rather unusual. It has no name, so you cannot
express it in Java source code. (And it has no runtime</p>
<p>representation either.)</p>
<p>The sole purpose of the null type is to be the type of
<strong>null</strong>. It is assignment compatible with all reference
types, and</p>
<p>can be type cast to any reference type. (In the latter case, the cast
does not entail a runtime type check.)</p>
<p>Finally, <strong>null</strong> has the property that <strong>null
instanceof</strong> will evaluate to <strong>false</strong>, no matter
what</p>
<p>the type is.</p>
<p>Section 9.6: Escape sequences in literals</p>
<p>String and character literals provide an escape mechanism that allows
express character codes that would</p>
<p>otherwise not be allowed in the literal. An escape sequence consists
of a backslash character (\) followed by one ore more other characters.
The same sequences are valid in both character an string literals.</p>
<p>The complete set of escape sequences is as follows:</p>
<p>Escape sequence Meaning</p>
<p>\\ Denotes an backslash (\) character</p>
<p>\' Denotes a single-quote (') character</p>
<p>\" Denotes a double-quote (") character</p>
<p>\n Denotes a line feed (LF) character</p>
<p>\r Denotes a carriage return (CR) character</p>
<p>\t Denotes a horizontal tab (HT) character</p>
<p>\f Denotes a form feed (FF) character</p>
<p>\b Denotes a backspace (BS) character</p>
<p>\ Denotes a character code in the range 0 to 255.</p>
<p>The <strong>&lt;octal&gt;</strong> in the above consists of one, two
or three octal digits ('0' through '7') which represent a number between
0 and 255 (decimal).</p>
<p>Note that a backslash followed by any other character is an invalid
escape sequence. Invalid escape sequences are</p>
<p>treated as compilation errors by the JLS.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 37</p>
<p><span id="Reference" class="anchor"></span>Reference:</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6">JLS
3.10.6. Escape Sequences for Character and String Literals</a></p>
<p>Unicode escapes</p>
<p>In addition to the string and character escape sequences described
above, Java has a more general Unicode</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.3">escaping
mechanism, as defined in JLS 3.3. Unicode Escapes</a>. A Unicode escape
has the following syntax:</p>
<p>'<strong>\'</strong> 'u'</p>
<p>where <strong>&lt;hex-digit&gt;</strong> is one of '0', '1', '2',
'3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A',
'B', 'C', 'D', 'E', 'F'.</p>
<p>A Unicode escape is mapped by the Java compiler to a character
(strictly speaking a 16-bit Unicode <em>code unit</em>), and can be used
anywhere in the source code where the mapped character is valid. It is
commonly used in character</p>
<p>and string literals when you need to represent a non-ASCII character
in a literal.</p>
<p>Escaping in regexes</p>
<p>TBD</p>
<p>Section 9.7: Character literals</p>
<p>Character literals provide the most convenient way to express
<strong>char</strong> values in Java source code. A character literal
consists of:</p>
<p>An opening single-quote (') character.</p>
<p>A representation of a character. This representation cannot be a
single-quote or a line-break character, but it</p>
<p>can be an escape sequence introduced by a backslash (\) character;
see Escape sequences in literals. A closing single-quote (')
character.</p>
<p>For example:</p>
<p><strong>char</strong> a = 'a';</p>
<p><strong>char</strong> doubleQuote = '"';</p>
<p><strong>char</strong> singleQuote = '<strong>\'</strong>';</p>
<p>A line-break in a character literal is a compilation error:</p>
<p><strong>char</strong> newline = '</p>
<p>// Compilation error in previous line</p>
<p>char newLine = '\n'; // Correct</p>
<p>Section 9.8: Decimal Integer literals</p>
<p>Integer literals provide values that can be used where you need a
<strong>byte</strong>, <strong>short</strong>, <strong>int</strong>,
<strong>long</strong> or <strong>char</strong> instance. (This</p>
<p>example focuses on the simple decimal forms. Other examples explain
how to literals in octal, hexadecimal and binary, and the use of
underscores to improve readability.)</p>
<p>Ordinary integer literals</p>
<p>The simplest and most common form of integer literal is a decimal
integer literal. For example:</p>
<p><em>0</em> // The decimal number zero (type 'int')</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 38</p>
<p><span id="1___________The_decimal_number_o"
class="anchor"></span><em>1</em> // The decimal number one (type
'int')</p>
<p><em>42</em> // The decimal number forty two (type 'int')</p>
<p>You need to be careful with leading zeros. A leading zero causes an
integer literal to be interpreted as <em>octal</em> not</p>
<p>decimal.</p>
<p><em>077</em> // This literal actually means 7 x 8 + 7 ... or 63
decimal!</p>
<p>Integer literals are unsigned. If you see something like -10 or +10,
these are actually <em>expressions</em> using the unary -and unary +
operators.</p>
<p>The range of integer literals of this form have an intrinsic type of
<strong>int</strong>, and must fall in the range zero to 231 or
2,147,483,648.</p>
<p>Note that 231 is 1 greater than Integer.MAX_VALUE. Literals from 0
through to 2147483647 can be used anywhere, but it is a compilation
error to use 2147483648 without a preceding unary - operator. (In other
words, it is reserved</p>
<p>for expressing the value of Integer.MIN_VALUE.)</p>
<p><strong>int</strong> max = 2147483647; <em>// OK</em></p>
<p><strong>int</strong> min =-2147483648; <em>// OK</em></p>
<p><strong>int</strong> tooBig = 2147483648; <em>// ERROR</em></p>
<p>Long integer literals</p>
<p>Literals of type <strong>long</strong> are expressed by adding an L
suffix. For example:</p>
<p><em>0L</em> // The decimal number zero (type 'long') <em>1L</em> //
The decimal number one (type 'long') <em>2147483648L</em> // The value
of Integer.MAX_VALUE + 1</p>
<p><strong>long</strong> big = 2147483648; <em>// ERROR</em></p>
<p><strong>long</strong> big2 = 2147483648L; <em>// OK</em></p>
<p>Note that the distinction between <strong>int</strong> and
<strong>long</strong> literals is significant in other places. For
example</p>
<p><strong>int</strong> i = 2147483647;</p>
<p><em><strong>long</strong> l = i + 1;</em> // Produces a negative
value because the operation is</p>
<p>// performed using 32 bit arithmetic, and the</p>
<p>// addition overflows</p>
<p><em><strong>long</strong> l2 = i + 1L;</em> // Produces the
(intuitively) correct value.</p>
<p>Reference: <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.1">JLS
3.10.1 - Integer Literals</a></p>
<p>Section 9.9: Floating-point literals</p>
<p>Floating point literals provide values that can be used where you
need a <strong>float</strong> or <strong>double</strong> instance. There
are three kinds of floating point literal.</p>
<p>Simple decimal forms</p>
<p>Scaled decimal forms</p>
<p>Hexadecimal forms</p>
<p>(The JLS syntax rules combine the two decimal forms into a single
form. We treat them separately for ease of</p>
<p>explanation.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 39</p>
<p>There are distinct literal types for <strong>float</strong> and
<strong>double</strong> literals, expressed using suffixes. The various
forms use letters to express different things. These letters are case
insensitive.</p>
<p>Simple decimal forms</p>
<p>The simplest form of floating point literal consists of one or more
decimal digits and a decimal point (.) and an optional suffix (f, F, d
or D). The optional suffix allows you to specify that the literal is a
<strong>float</strong> (f or F) or <strong>double</strong> (d or</p>
<p>D) value. The default (when no suffix is specified) is
<strong>double</strong>.</p>
<p>For example</p>
<p><em>0.0</em> // this denotes zero</p>
<p><em>.0</em> // this also denotes zero</p>
<p><em>0.</em> // this also denotes zero</p>
<p><em>3.14159</em> // this denotes Pi, accurate to (approximately!) 5
decimal places.</p>
<p><em>1.0F</em> // a `float` literal</p>
<p><em>1.0D</em> // a `double` literal. (`double` is the default if no
suffix is given)</p>
<p>In fact, decimal digits followed by a suffix is also a floating point
literal.</p>
<p><em>1F</em> // means the same thing as 1.0F</p>
<p>The meaning of a decimal literal is the IEEE floating point number
that is <em>closest</em> to the infinite precision</p>
<p>mathematical Real number denoted by the decimal floating point form.
This conceptual value is converted to IEEE</p>
<p>binary floating point representation using <em>round to nearest</em>.
(The precise semantics of decimal conversion are</p>
<p>specified in the javadocs for <a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-">Double.valueOf(String)</a>
and <a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#valueOf-java.lang.String-">Float.valueOf(String),
bearing in mind that there are</a></p>
<p>differences in the number syntaxes.)</p>
<p>Scaled decimal forms</p>
<p>Scaled decimal forms consist of simple decimal with an exponent part
introduced by an E or e, and followed by a</p>
<p>signed integer. The exponent part is a short hand for multiplying the
decimal form by a power of ten, as shown in the examples below. There is
also an optional suffix to distinguish <strong>float</strong> and
<strong>double</strong> literals. Here are some</p>
<p>examples:</p>
<p><em>1.0E1</em> // this means 1.0 x 10^1 ... or 10.0 (double)
<em>1E-1D</em> // this means 1.0 x 10^(-1) ... or 0.1 (double)
<em>1.0e10f</em> // this means 1.0 x 10^(10) ... or 10000000000.0
(float)</p>
<p>The size of a literal is limited by the representation
(<strong>float</strong> or <strong>double</strong>). It is a compilation
error if the scale factor results in a value that is too large or too
small.</p>
<p>Hexadecimal forms</p>
<p>Starting with Java 6, it is possible to express floating point
literals in hexadecimal. The hexadecimal form have an analogous syntax
to the simple and scaled decimal forms with the following
differences:</p>
<p>1. Every hexadecimal floating point literal starts with a zero (0)
and then an x or X. 2. The digits of the number (but <em>not</em> the
exponent part!) also include the hexadecimal digits a through f and</p>
<p>their uppercase equivalents.</p>
<p>3. The exponent is <em>mandatory</em>, and is introduced by the
letter p (or P) instead of an e or E. The exponent</p>
<p>represents a scaling factor that is a power of 2 instead of a power
of 10.</p>
<p>Here are some examples:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 40</p>
<p><em>0x0.0p0f</em> // this is zero expressed in hexadecimal form
(`float`) <em>0xff.0p19</em> // this is 255.0 x 2^19 (`double`)</p>
<p>Advice: since hexadecimal floating-point forms are unfamiliar to most
Java programmers, it is advisable to use them sparingly.</p>
<p>Underscores</p>
<p>Starting with Java 7, underscores are permitted within the digit
strings in all three forms of floating point literal. This applies to
the "exponent" parts as well. See Using underscores to improve
readability.</p>
<p>Special cases</p>
<p>It is a compilation error if a floating point literal denotes a
number that is too large or too small to represent in the selected
representation; i.e. if the number would overflow to +INF or -INF, or
underflow to 0.0. However, it is legal</p>
<p>for a literal to represent a non-zero denormalized number.</p>
<p>The floating point literal syntax does not provide literal
representations for IEEE 754 special values such as the INF</p>
<p>and NaN values. If you need to express them in source code, the
recommended way is to use the constants defined by the java.lang.Float
and java.lang.Double; e.g. Float.NaN, Float.NEGATIVE_INFINITY and</p>
<p>Float.POSITIVE_INFINITY.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 41</p>
<p><span id="Chapter_10__Primitive_Data_Types_1"
class="anchor"></span>Chapter 10: Primitive Data Types</p>
<p>The 8 primitive data types <strong>byte</strong>,
<strong>short</strong>, <strong>int</strong>, <strong>long</strong>,
<strong>char</strong>, <strong>boolean</strong>, <strong>float</strong>,
and <strong>double</strong> are the types that store most</p>
<p>raw numerical data in Java programs.</p>
<p>Section 10.1: The char primitive</p>
<p>A <strong>char</strong> can store a single 16-bit Unicode character.
A character literal is enclosed in single quotes</p>
<p><strong>char</strong> myChar = 'u';</p>
<p><strong>char</strong> myChar2 = '5';</p>
<p><em><strong>char</strong> myChar3 = 65;</em> // myChar3 == 'A'</p>
<p>It has a minimum value of \u0000 (0 in the decimal representation,
also called the <em>null character</em>) and a maximum value of \uffff
(65,535).</p>
<p>The default value of a <strong>char</strong> is \u0000.</p>
<p><em><strong>char</strong> defaultChar;</em> // defaultChar ==
\u0000</p>
<p>In order to define a char of ' value an escape sequence (character
preceded by a backslash) has to be used:</p>
<p><strong>char</strong> singleQuote = '<strong>\'</strong>';</p>
<p>There are also other escape sequences:</p>
<p><strong>char</strong> tab = '<strong>\t</strong>';</p>
<p><strong>char</strong> backspace = '<strong>\b</strong>';</p>
<p><strong>char</strong> newline = '<strong>\n</strong>';</p>
<p><strong>char</strong> carriageReturn = '<strong>\r</strong>';</p>
<p><strong>char</strong> formfeed = '<strong>\f</strong>';</p>
<p><strong>char</strong> singleQuote = '<strong>\'</strong>';</p>
<p><em><strong>char</strong> doubleQuote = '<strong>\"</strong>';</em>
// escaping redundant here; '"' would be the same; however still allowed
<em><strong>char</strong> backslash = '<strong>\\</strong>';</em></p>
<p><em><strong>char</strong> unicodeChar =
'<strong>\u</strong>XXXX'</em> // XXXX represents the Unicode-value of
the character you want to display</p>
<p>You can declare a <strong>char</strong> of any Unicode character.</p>
<p><strong>char</strong> heart = '<strong>\u</strong>2764';</p>
<p>System.out.println(Character.toString(heart)); <em>// Prints a line
containing "</em>❤<em>".</em></p>
<p>It is also possible to add to a <strong>char</strong>. e.g. to
iterate through every lower-case letter, you could do to the
following:</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;= 26; i++)
{</p>
<p><strong>char</strong> letter = (<strong>char</strong>) ('a' + i);</p>
<p>System.out.println(letter);</p>
<p>}</p>
<p>Section 10.2: Primitive Types Cheatsheet</p>
<p>Table showing size and values range of all primitive types:</p>
<p>data type numeric representation default range of values value</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 42</p>
<p><span id="boolean_n_a___________________fa"
class="anchor"></span>boolean n/a false and true false</p>
<p>byte 8-bit signed -27 to 27 - 1 0</p>
<p>-128 to +127</p>
<p>short 16-bit signed -215 to 215 - 1 0</p>
<p>-32,768 to +32,767</p>
<p>int 32-bit signed -231 to 231 - 1 0</p>
<p>-2,147,483,648 to +2,147,483,647</p>
<p>long 64-bit signed -263 to 263 - 1 0L</p>
<p>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</p>
<p>float 32-bit floating point 1.401298464e-45 to 3.402823466e+38
(positive or negative) 0.0F</p>
<p>double 4.94065645841246544e-324d to 1.79769313486231570e+308d 64-bit
floating point 0.0D (positive or negative)</p>
<p>char 16-bit unsigned 0 to 216 - 1 0</p>
<p>0 to 65,535</p>
<p>Notes:</p>
<p>1. The Java Language Specification mandates that signed integral
types (<strong>byte</strong> through <strong>long</strong>) use binary
twos-</p>
<p>complement representation, and the floating point types use standard
IEE 754 binary floating point</p>
<p>representations.</p>
<p>2. Java 8 and later provide methods to perform unsigned arithmetic
operations on <strong>int</strong> and <strong>long</strong>. While
these</p>
<p>methods allow a program to <em>treat</em> values of the respective
types as unsigned, the types remain signed types.</p>
<p>3. The smallest floating point shown above are <em>subnormal</em>;
i.e. they have less precision than a <em>normal</em> value. The</p>
<p>smallest normal numbers are 1.175494351e−38 and
2.2250738585072014e−308</p>
<p>4. A <strong>char</strong> conventionally represents a Unicode /
UTF-16 <em>code unit</em>. 5. Although a <strong>boolean</strong>
contains just one bit of information, its size in memory varies
depending on the Java</p>
<p><a
href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4">Virtual
Machine implementation (see boolean type).</a></p>
<p>Section 10.3: The float primitive</p>
<p>A <strong>float</strong> is a single-precision 32-bit IEEE 754
floating point number. By default, decimals are interpreted as
doubles.</p>
<p>To create a <strong>float</strong>, simply append an f to the decimal
literal.</p>
<p><em><strong>double</strong> doubleExample = 0.5;</em> // without 'f'
after digits = double <em><strong>float</strong> floatExample =
0.5f;</em> // with 'f' after digits = float</p>
<p><em><strong>float</strong> myFloat = 92.7f;</em> // this is a
float...</p>
<p><strong>float</strong> positiveFloat = 89.3f; <em>// it can be
positive,</em></p>
<p><strong>float</strong> negativeFloat =-89.3f; <em>// or
negative</em></p>
<p><em><strong>float</strong> integerFloat = 43.0f;</em> // it can be a
whole number (not an int) <em><strong>float</strong> underZeroFloat =
0.0549f;</em> // it can be a fractional value less than 0</p>
<p>Floats handle the five common arithmetical operations: addition,
subtraction, multiplication, division, and modulus.</p>
<p>Note: The following may vary slightly as a result of floating point
errors. Some results have been rounded for clarity and</p>
<p>readability purposes (i.e. the printed result of the addition example
was actually 34.600002).</p>
<p>// addition</p>
<p><strong>float</strong> result = 37.2f +-2.6f; <em>// result:
34.6</em></p>
<p>// subtraction</p>
<p><strong>float</strong> result = 45.1f - 10.3f; <em>// result:
34.8</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 43</p>
<p><span id="___multiplication" class="anchor"></span>//
multiplication</p>
<p><strong>float</strong> result = 26.3f * 1.7f; <em>// result:
44.71</em></p>
<p>// division</p>
<p><strong>float</strong> result = 37.1f / 4.8f; <em>// result:
7.729166</em></p>
<p>// modulus</p>
<p><strong>float</strong> result = 37.1f % 4.8f; <em>// result:
3.4999971</em></p>
<p>Because of the way floating point numbers are stored (i.e. in binary
form), many numbers don't have an exact</p>
<p>representation.</p>
<p><strong>float</strong> notExact = 3.1415926f;</p>
<p>System.out.println(notExact); <em>// 3.1415925</em></p>
<p>While using <strong>float</strong> is fine for most applications,
neither <strong>float</strong> nor <strong>double</strong> should be
used to store exact</p>
<p>representations of decimal numbers (like monetary amounts), or
numbers where higher precision is required. Instead, the BigDecimal
class should be used.</p>
<p>The default value of a <strong>float</strong> is <em>0.0f</em>.</p>
<p><em><strong>float</strong> defaultFloat;</em> // defaultFloat ==
0.0f</p>
<p>A <strong>float</strong> is precise to roughly an error of 1 in 10
million.</p>
<p><strong>Note:</strong> Float.POSITIVE_INFINITY,
Float.NEGATIVE_INFINITY, Float.NaN are <strong>float</strong> values.
NaN stands for results of</p>
<p>operations that cannot be determined, such as dividing 2 infinite
values. Furthermore 0f and -0f are different, but</p>
<p>== yields true:</p>
<p><strong>float</strong> f1 = 0f;</p>
<p><strong>float</strong> f2 =-0f;</p>
<p>System.out.println(f1 == f2); <em>// true</em></p>
<p>System.out.println(1f / f1); <em>// Infinity</em></p>
<p>System.out.println(1f / f2); <em>// -Infinity</em></p>
<p>System.out.println(Float.POSITIVE_INFINITY /
Float.POSITIVE_INFINITY); <em>// NaN</em></p>
<p>Section 10.4: The int primitive</p>
<p>A primitive data type such as <strong>int</strong> holds values
directly into the variable that is using it, meanwhile a variable that
was declared using Integer holds a reference to the value.</p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/">According to
java API: "The Integer class wraps a value of the primitive type int in
an object. An object of type</a> Integer contains a single field whose
type is int."</p>
<p>By default, <strong>int</strong> is a 32-bit signed integer. It can
store a minimum value of -231, and a maximum value of 231 - 1.</p>
<p><strong>int</strong> example =-42;</p>
<p><strong>int</strong> myInt = 284;</p>
<p><strong>int</strong> anotherInt = 73;</p>
<p><strong>int</strong> addedInts = myInt + anotherInt; <em>// 284 + 73
= 357</em> <strong>int</strong> subtractedInts = myInt - anotherInt;
<em>// 284 - 73 = 211</em></p>
<p>If you need to store a number outside of this range,
<strong>long</strong> should be used instead. Exceeding the value range
of <strong>int</strong> leads to an integer overflow, causing the value
exceeding the range to be added to the opposite site of the range</p>
<p>(positive becomes negative and vise versa). The value is ((value -
MIN_VALUE) % RANGE) + MIN_VALUE, or ((value</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 44</p>
<p><span id="__2147483648____4294967296__2147" class="anchor"></span>+
2147483648) % 4294967296)-2147483648</p>
<p><em><strong>int</strong> demo = 2147483647;</em> //maximum positive
integer</p>
<p>System.out.println(demo); <em>//prints 2147483647</em></p>
<p><em>demo = demo + 1;</em> //leads to an integer overflow</p>
<p>System.out.println(demo); <em>// prints -2147483648</em></p>
<p>The maximum and minimum values of <strong>int</strong> can be found
at:</p>
<p><strong>int</strong> high = Integer.MAX_VALUE; <em>// high ==
2147483647</em></p>
<p><strong>int</strong> low = Integer.MIN_VALUE; <em>// low ==
-2147483648</em></p>
<p>The default value of an <strong>int</strong> is <em>0</em></p>
<p><em><strong>int</strong> defaultInt;</em> // defaultInt == 0</p>
<p>Section 10.5: Converting Primitives</p>
<p>In Java, we can convert between integer values and floating-point
values. Also, since every character corresponds to</p>
<p>a number in the Unicode encoding, <strong>char</strong> types can be
converted to and from the integer and floating-point types.
<strong>boolean</strong> is the only primitive datatype that cannot be
converted to or from any other primitive datatype.</p>
<p>There are two types of conversions: <em>widening conversion</em> and
<em>narrowing conversion</em>.</p>
<p>A <em>widening conversion</em> is when a value of one datatype is
converted to a value of another datatype that occupies</p>
<p>more bits than the former. There is no issue of data loss in this
case.</p>
<p>Correspondingly, A <em>narrowing conversion</em> is when a value of
one datatype is converted to a value of another</p>
<p>datatype that occupies fewer bits than the former. Data loss can
occur in this case.</p>
<p>Java performs <em>widening conversions</em> automatically. But if you
want to perform a <em>narrowing conversion</em> (if you are sure</p>
<p>that no data loss will occur), then you can force Java to perform the
conversion using a language construct known as a cast.</p>
<p>Widening Conversion:</p>
<p><strong>int</strong> a = 1;</p>
<p><em><strong>double</strong> d = a;</em> // valid conversion to
double, no cast needed (widening)</p>
<p>Narrowing Conversion:</p>
<p><strong>double</strong> d = 18.96</p>
<p><em><strong>int</strong> b = d;</em> // invalid conversion to int,
will throw a compile-time error <em><strong>int</strong> b =
(<strong>int</strong>) d;</em> // valid conversion to int, but result is
truncated (gets rounded down)</p>
<p>// This is type-casting</p>
<p>// Now, b = 18</p>
<p>Section 10.6: Memory consumption of primitives vs. boxed</p>
<p>primitives</p>
<p>Primitive Boxed Type Memory Size of primitive / boxed <strong>boolean
Boolean 1 byte / 16 bytes</strong></p>
<p>byte Byte 1 byte / 16 bytes</p>
<p>short Short 2 bytes / 16 bytes</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 45</p>
<p><span id="char______Char_______2_bytes___1"
class="anchor"></span>char Char 2 bytes / 16 bytes</p>
<p>int Integer 4 bytes / 16 bytes</p>
<p>long Long 8 bytes / 16 bytes</p>
<p>float Float 4 bytes / 16 bytes</p>
<p>double Double 8 bytes / 16 bytes</p>
<p>Boxed objects always require 8 bytes for type and memory management,
and because the size of objects is always</p>
<p>a multiple of 8, boxed types <em>all require 16 bytes total</em>. In
<em>addition</em>, each usage of a boxed object entails storing a
reference which accounts for another 4 or 8 bytes, depending on the JVM
and JVM options.</p>
<p>In data-intensive operations, memory consumption can have a major
impact on performance. Memory consumption grows even more when using
arrays: a <strong>float</strong>[5] array will require only 32 bytes;
whereas a Float[5]</p>
<p>storing 5 distinct non-null values will require 112 bytes total (on
64 bit without compressed pointers, this increases to 152 bytes).</p>
<p>Boxed value caches</p>
<p>The space overheads of the boxed types can be mitigated to a degree
by the boxed value caches. Some of the boxed types implement a cache of
instances. For example, by default, the Integer class will cache
instances to</p>
<p>represent numbers in the range -128 to +127. This does not, however,
reduce the additional cost arising from the</p>
<p>additional memory indirection.</p>
<p>If you create an instance of a boxed type either by autoboxing or by
calling the static valueOf(primitive) method, the runtime system will
attempt to use a cached value. If your application uses a lot of values
in the range that is</p>
<p>cached, then this can substantially reduce the memory penalty of
using boxed types. Certainly, if you are creating</p>
<p>boxed value instances "by hand", it is better to use valueOf rather
than <strong>new</strong>. (The <strong>new</strong> operation always
creates a new instance.) If, however, the majority of your values are
<em>not</em> in the cached range, it can be faster to call
<strong>new</strong> and</p>
<p>save the cache lookup.</p>
<p>Section 10.7: The double primitive</p>
<p>A <strong>double</strong> is a double-precision 64-bit IEEE 754
floating point number.</p>
<p><strong>double</strong> example =-7162.37;</p>
<p><strong>double</strong> myDouble = 974.21;</p>
<p><strong>double</strong> anotherDouble = 658.7;</p>
<p><strong>double</strong> addedDoubles = myDouble + anotherDouble;
<em>// 315.51</em> <strong>double</strong> subtractedDoubles = myDouble
- anotherDouble; <em>// 1632.91</em></p>
<p><strong>double</strong> scientificNotationDouble = 1.2e-3; <em>//
0.0012</em></p>
<p>Because of the way floating point numbers are stored, many numbers
don't have an exact representation.</p>
<p><strong>double</strong> notExact = 1.32-0.42; <em>// result should be
0.9</em></p>
<p>System.out.println(notExact); <em>// 0.9000000000000001</em></p>
<p>While using <strong>double</strong> is fine for most applications,
neither <strong>float</strong> nor <strong>double</strong> should be
used to store precise numbers such as currency. Instead, the BigDecimal
class should be used</p>
<p>The default value of a <strong>double</strong> is <em>0.0d</em></p>
<p><em><strong>public double</strong> defaultDouble;</em> //
defaultDouble == 0.0</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 46</p>
<p><span id="Note__Double_POSITIVE_INFINITY"
class="anchor"></span><strong>Note:</strong> Double.POSITIVE_INFINITY,
Double.NEGATIVE_INFINITY, Double.NaN are <strong>double</strong> values.
NaN stands for</p>
<p>results of operations that cannot be determined, such as dividing 2
infinite values. Furthermore 0d and -0d are</p>
<p>different, but == yields true:</p>
<p><strong>double</strong> d1 = 0d;</p>
<p><strong>double</strong> d2 =-0d;</p>
<p>System.out.println(d1 == d2); <em>// true</em></p>
<p>System.out.println(1d / d1); <em>// Infinity</em></p>
<p>System.out.println(1d / d2); <em>// -Infinity</em></p>
<p>System.out.println(Double.POSITIVE_INFINITY /
Double.POSITIVE_INFINITY); <em>// NaN</em></p>
<p>Section 10.8: The long primitive</p>
<p>By default, <strong>long</strong> is a 64-bit signed integer (in Java
8, it can be either signed or unsigned). Signed, it can store a</p>
<p>minimum value of -263, and a maximum value of 263 - 1, and unsigned
it can store a minimum value of 0 and a maximum value of 264 - 1</p>
<p><strong>long</strong> example =-42;</p>
<p><strong>long</strong> myLong = 284;</p>
<p><strong>long</strong> anotherLong = 73;</p>
<p>//an "L" must be appended to the end of the number, because by
default, //numbers are assumed to be the int type. Appending an "L"
makes it a long //as 549755813888 (2 ^ 39) is larger than the maximum
value of an int (2^31 - 1), //"L" must be appended</p>
<p><strong>long</strong> bigNumber = 549755813888L;</p>
<p><strong>long</strong> addedLongs = myLong + anotherLong; <em>// 284 +
73 = 357</em> <strong>long</strong> subtractedLongs = myLong -
anotherLong; <em>// 284 - 73 = 211</em></p>
<p>The maximum and minimum values of <strong>long</strong> can be found
at:</p>
<p><em><strong>long</strong> high = Long.MAX_VALUE;</em> // high ==
9223372036854775807L <em><strong>long</strong> low =
Long.MIN_VALUE;</em> // low == -9223372036854775808L</p>
<p>The default value of a <strong>long</strong> is <em>0L</em></p>
<p><em><strong>long</strong> defaultLong;</em> // defaultLong == 0L</p>
<p>Note: letter "L" appended at the end of <strong>long</strong> literal
is case insensitive, however it is good practice to use capital as
it</p>
<p>is easier to distinct from digit one:</p>
<p>2L == 2l; <em>// true</em></p>
<p>Warning: Java caches Integer objects instances from the range -128 to
127. The reasoning is explained here:</p>
<p><a
href="https://blogs.oracle.com/darcy/entry/boxing_and_caches_integer_valueof">https://blogs.oracle.com/darcy/entry/boxing_and_caches_integer_valueof</a></p>
<p>The following results can be found:</p>
<p>Long val1 = 127L;</p>
<p>Long val2 = 127L;</p>
<p>System.out.println(val1 == val2); <em>// true</em></p>
<p>Long val3 = 128L;</p>
<p>Long val4 = 128L;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 47</p>
<p><span id="System_out_println_val3____val4"
class="anchor"></span>System.out.println(val3 == val4); <em>//
false</em></p>
<p>To properly compare 2 Object Long values, use the following code(From
Java 1.7 onward):</p>
<p>Long val3 = 128L;</p>
<p>Long val4 = 128L;</p>
<p>System.out.println(Objects.equal(val3, val4)); <em>// true</em></p>
<p>Comparing a primitive long to an Object long will not result in a
false negative like comparing 2 objects with ==</p>
<p>does.</p>
<p>Section 10.9: The boolean primitive</p>
<p>A <strong>boolean</strong> can store one of two values, either
<strong>true</strong> or <strong>false</strong></p>
<p>boolean <strong>foo =</strong> true<strong>;</strong></p>
<p>System.out.println("foo = " + foo); <em>// foo = true</em></p>
<p>boolean <strong>bar =</strong> false<strong>;</strong></p>
<p>System.out.println("bar = " + bar); <em>// bar = false</em></p>
<p><strong>boolean</strong> notFoo = !foo;</p>
<p>System.out.println("notFoo = " + notFoo); <em>// notFoo =
false</em></p>
<p><strong>boolean</strong> fooAndBar = foo &amp;&amp; bar;</p>
<p>System.out.println("fooAndBar = " + fooAndBar); <em>// fooAndBar =
false</em></p>
<p><strong>boolean</strong> fooOrBar = foo || bar;</p>
<p>System.out.println("fooOrBar = " + fooOrBar); <em>// fooOrBar =
true</em></p>
<p><strong>boolean</strong> fooXorBar = foo ^ bar;</p>
<p>System.out.println("fooXorBar = " + fooXorBar); <em>// fooXorBar =
true</em></p>
<p>The default value of a <strong>boolean</strong> is <em>false</em></p>
<p><em><strong>boolean</strong> defaultBoolean;</em> // defaultBoolean
== false</p>
<p>Section 10.10: The byte primitive</p>
<p>A <strong>byte</strong> is a 8-bit signed integer. It can store a
minimum value of -27 (-128), and a maximum value of 27 - 1 (127)</p>
<p><strong>byte</strong> example =-36;</p>
<p><strong>byte</strong> myByte = 96;</p>
<p><strong>byte</strong> anotherByte = 7;</p>
<p><strong>byte</strong> addedBytes = (<strong>byte</strong>) (myByte +
anotherByte); <em>// 103</em> <strong>byte</strong> subtractedBytes =
(<strong>byte</strong>) (myBytes - anotherByte); <em>// 89</em></p>
<p>The maximum and minimum values of <strong>byte</strong> can be found
at:</p>
<p><strong>byte</strong> high = Byte.MAX_VALUE; <em>// high ==
127</em></p>
<p><strong>byte</strong> low = Byte.MIN_VALUE; <em>// low ==
-128</em></p>
<p>The default value of a <strong>byte</strong> is <em>0</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 48</p>
<p><span id="byte_defaultByte________defaultB"
class="anchor"></span><em><strong>byte</strong> defaultByte;</em> //
defaultByte == 0</p>
<p>Section 10.11: Negative value representation</p>
<p>Java and most other languages store negative integral numbers in a
representation called <em>2's complement</em> notation.</p>
<p>For a unique binary representation of a data type using n bits,
values are encoded like this:</p>
<p>The least significant n-1 bits store a positive integral number x in
integral representation. Most significant value</p>
<p>stores a bit vith value s. The value repesented by those bits is</p>
<p>x - s * 2n-1</p>
<p>i.e. if the most significant bit is 1, then a value that is just by 1
larger than the number you could represent with the</p>
<p>other bits (2n-2 + 2n-3 + ... + 21 + 20 = 2n-1-1) is subtracted
allowing a unique binary representation for</p>
<p>each value from - 2n-1 (s = 1; x = 0) to 2n-1 - 1 (s = 0; x = 2n-1 -
1).</p>
<p>This also has the nice side effect, that you can add the binary
representations as if they were positive binary numbers:</p>
<p>v1 = x1 - s1 * 2n-1 v2 = x2 - s2 * 2n-1</p>
<p>s1 s2 x1 + x2 overflow addition result</p>
<p>0 0 No x1 + x2 = v1 + v2</p>
<p>0 0 Yes too large to be represented with data type (overflow)</p>
<p>0 1 No x1 + x2 - 2n-1 = x1 + x2 - s2 * 2n-1 = v1 + v2</p>
<p>0 1 Yes (x1 + x2) <strong>mod</strong> 2n-1 = x1 + x2 - 2n-1 = v1 +
v2</p>
<p>1 0 * see above (swap summands)</p>
<p>1 1 No too small to be represented with data type (x1 + x2 - 2n &lt;
-2n-1 ; underflow)</p>
<p>(x1 + x2) <strong>mod</strong> 2n-1 - 2n-1 = (x1 + x2 - 2n-1) -
2n-1</p>
<p>1 1 Yes = (x1 - s1 * 2n-1) + (x2 - s2 * 2n-1)</p>
<p>= v1 + v2</p>
<p>Note that this fact makes finding binary representation of the
additive inverse (i.e. the negative value) easy:</p>
<p>Observe that adding the bitwise complement to the number results in
all bits being 1. Now add 1 to make value</p>
<p>overflow and you get the neutral element 0 (all bits 0).</p>
<p>So the negative value of a number i can be calculated using (ignoring
possible promotion to <strong>int</strong> here)</p>
<p>(~i) + 1</p>
<p><strong>Example:</strong> taking the negative value of 0
(<strong>byte</strong>):</p>
<p>The result of negating 0, is 11111111. Adding 1 gives a value of
100000000 (9 bits). Because a <strong>byte</strong> can only store 8</p>
<p>bits, the leftmost value is truncated, and the result is 00000000</p>
<p>Original Process Result</p>
<p>0 (00000000) Negate -0 (11111111)</p>
<p>11111111 Add 1 to binary 100000000</p>
<p>100000000 Truncate to 8 bits 00000000 (-0 equals 0)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 49</p>
<p><span id="Section_10_12__The_short_primiti"
class="anchor"></span>Section 10.12: The short primitive</p>
<p>A <strong>short</strong> is a 16-bit signed integer. It has a minimum
value of -215 (-32,768), and a maximum value of 215 ‑1 (32,767)</p>
<p><strong>short</strong> example =-48;</p>
<p><strong>short</strong> myShort = 987;</p>
<p><strong>short</strong> anotherShort = 17;</p>
<p><strong>short</strong> addedShorts = (<strong>short</strong>)
(myShort + anotherShort); <em>// 1,004</em> <strong>short</strong>
subtractedShorts = (<strong>short</strong>) (myShort - anotherShort);
<em>// 970</em></p>
<p>The maximum and minimum values of <strong>short</strong> can be found
at:</p>
<p><strong>short</strong> high = Short.MAX_VALUE; <em>// high ==
32767</em></p>
<p><strong>short</strong> low = Short.MIN_VALUE; <em>// low ==
-32768</em></p>
<p>The default value of a <strong>short</strong> is <em>0</em></p>
<p><em><strong>short</strong> defaultShort;</em> // defaultShort ==
0</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 50</p>
<p><span id="Chapter_11__Strings_1" class="anchor"></span>Chapter 11:
Strings</p>
<p>Strings (java.lang.String) are pieces of text stored in your program.
Strings are <strong>not</strong> a <a
href="http://stackoverflow.com/questions/10430582/primitive-data-types-in-java">primitive
data type in Java</a>,</p>
<p>however, they are very common in Java programs.</p>
<p>In Java, Strings are immutable, meaning that they cannot be changed.
(Click <a
href="http://stackoverflow.com/questions/279507/what-is-meant-by-immutable">here</a>
for a more thorough explanation of immutability.)</p>
<p>Section 11.1: Comparing Strings</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-">In
order to compare Strings for equality, you should use the String
object's equals or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equalsIgnoreCase-java.lang.String-">equalsIgnoreCase</a>
methods.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">For
example, the following snippet will determine if the two instances of
String are equal on all characters:</a></p>
<p>String firstString = "Test123";</p>
<p>String secondString = "Test" + 123;</p>
<p><strong>if</strong> (firstString.equals(secondString)) {</p>
<p>// Both Strings have the same content.</p>
<p>}</p>
<p><a href="https://ideone.com/TjaYMR">Live demo</a></p>
<p>This example will compare them, independent of their case:</p>
<p>String firstString = "Test123";</p>
<p>String secondString = "TEST123";</p>
<p><strong>if</strong> (firstString.equalsIgnoreCase(secondString))
{</p>
<p>// Both Strings are equal, ignoring the case of the individual
characters.</p>
<p>}</p>
<p><a href="https://ideone.com/XxKmM1">Live demo</a></p>
<p><strong>Note that</strong> equalsIgnoreCase does not let you specify
a Locale. For instance, if you compare the two words "Taki" and "TAKI"
in English they are equal; however, in Turkish they are different (in
Turkish, the lowercase I is ı). For</p>
<p>cases like this, converting both strings to lowercase (or uppercase)
with Locale and then comparing with equals is</p>
<p>the solution.</p>
<p>String firstString = "Taki";</p>
<p>String secondString = "TAKI";</p>
<p>System.out.println(firstString.equalsIgnoreCase(secondString));
<em>//prints true</em></p>
<p>Locale locale = Locale.forLanguageTag("tr-TR");</p>
<p>System.out.println(firstString.toLowerCase(locale).equals(</p>
<p>secondString.toLowerCase(locale))); <em>//prints false</em></p>
<p><a href="https://ideone.com/uWc348">Live demo</a></p>
<p>Do not use the == operator to compare Strings</p>
<p>Unless you can guarantee that all strings have been interned (see
below), you <strong>should not</strong> use the == or !=</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 51</p>
<p>operators to compare Strings. These operators actually test
references, and since multiple String objects can represent the same
String, this is liable to give the wrong answer.</p>
<p>Instead, use the String.equals(Object) method, which will compare the
String objects based on their values. For a detailed explanation, please
refer to Pitfall: using == to compare strings.</p>
<p>Comparing Strings in a switch statement</p>
<p>Version ≥ Java SE 7</p>
<p>As of Java 1.7, it is possible to compare a String variable to
literals in a <strong>switch</strong> statement. Make sure that the
String</p>
<p>is not null, otherwise it will always throw a NullPointerException.
Values are compared using String.equals, i.e. case sensitive.</p>
<p>String stringToSwitch = "A";</p>
<p><strong>switch</strong> (stringToSwitch) {</p>
<p><strong>case</strong> "a":</p>
<p>System.out.println("a");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "A":</p>
<p>System.out.println("A"); <em>//the code goes here</em></p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "B":</p>
<p>System.out.println("B");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p>break<strong>;</strong></p>
<p>}</p>
<p><a href="https://ideone.com/fbWBUR">Live demo</a></p>
<p>Comparing Strings with constant values</p>
<p>When comparing a String to a constant value, you can put the constant
value on the left side of equals to ensure</p>
<p>that you won't get a NullPointerException if the other String is
<strong>null</strong>.</p>
<p>"baz".equals(foo)</p>
<p>While foo.equals("baz") will throw a NullPointerException if foo is
<strong>null</strong>, "baz".equals(foo) will evaluate to
<strong>false</strong>.</p>
<p>Version ≥ Java SE 7</p>
<p>A more readable alternative is to use Objects.equals(), which does a
null check on both parameters:</p>
<p>Objects.equals(foo, "baz").</p>
<p>(<strong>Note:</strong> It is debatable as to whether it is better to
avoid NullPointerExceptions in general, or let them happen and</p>
<p>then fix the root cause; see here and here. Certainly, calling the
avoidance strategy "best practice" is not justifiable.)</p>
<p>String orderings</p>
<p>The String class implements Comparable with the String.compareTo
method (as described at the start of this example). This makes the
natural ordering of String objects case-sensitive order. The String
class provide a</p>
<p>Comparator constant called CASE_INSENSITIVE_ORDER suitable for
case-insensitive sorting.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 52</p>
<p><span id="Comparing_with_interned_Strings"
class="anchor"></span>Comparing with interned Strings</p>
<p>The Java Language Specification (<a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">JLS
3.10.6</a>) states the following:</p>
<p>"Moreover, a string literal always refers to the same instance of
class String. This is because string literals</p>
<p>- or, more generally, strings that are the values of constant
expressions - are <em>interned</em> so as to share unique instances,
using the method String.intern."</p>
<p>This means it is safe to compare references to two string
<em>literals</em> using ==. Moreover, the same is true for
references</p>
<p>to String objects that have been produced using the String.intern()
method.</p>
<p>For example:</p>
<p>String strObj = <strong>new</strong> String("Hello!");</p>
<p>String str = "Hello!";</p>
<p>// The two string references point two strings that are equal
<em><strong>if</strong> (strObj.equals(str)) {</em></p>
<p>System.out.println("The strings are equal");</p>
<p>}</p>
<p>// The two string references do not point to the same object
<em><strong>if</strong> (strObj != str) {</em></p>
<p>System.out.println("The strings are not the same object");</p>
<p>}</p>
<p>// If we intern a string that is equal to a given literal, the result
is // a string that has the same reference as the literal. <em>String
internedStr = strObj.intern();</em></p>
<p><strong>if</strong> (internedStr == str) {</p>
<p>System.out.println("The interned string and the literal are the same
object");</p>
<p>}</p>
<p>Behind the scenes, the interning mechanism maintains a hash table
that contains all interned strings that are still</p>
<p><em>reachable</em>. When you call intern() on a String, the method
looks up the object in the hash table:</p>
<p>If the string is found, then that value is returned as the interned
string.</p>
<p>Otherwise, a copy of the string is added to the hash table and that
string is returned as the interned string.</p>
<p>It is possible to use interning to allow strings to be compared using
==. However, there are significant problems with doing this; see Pitfall
- Interning strings so that you can use == is a bad idea for details. It
is not recommended</p>
<p>in most cases.</p>
<p>Section 11.2: Changing the case of characters within a String</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">The
String type provides two methods for converting strings between upper
case and lower case:</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--">toUpperCase
to convert all characters to upper case</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--">toLowerCase
to convert all characters to lower case</a></p>
<p>These methods both return the converted strings as new String
instances: the original String objects are not</p>
<p>modified because String is immutable in Java. See this for more on
immutability : <a
href="http://stackoverflow.com/questions/1552301/immutability-of-strings-in-java">Immutability
of Strings in Java</a></p>
<p>String string = "This is a Random String";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 53</p>
<p>String upper = string.toUpperCase();</p>
<p>String lower = string.toLowerCase();</p>
<p><em>System.out.println(string);</em> // prints "This is a Random
String" <em>System.out.println(lower);</em> // prints "this is a random
string" <em>System.out.println(upper);</em> // prints "THIS IS A RANDOM
STRING"</p>
<p>Non-alphabetic characters, such as digits and punctuation marks, are
unaffected by these methods. Note that these</p>
<p>methods may also incorrectly deal with certain Unicode characters
under certain conditions.</p>
<p><strong>Note</strong>: These methods are <em>locale-sensitive</em>,
and may produce unexpected results if used on strings that are
intended</p>
<p>to be interpreted independent of the locale. Examples are programming
language identifiers, protocol keys, and</p>
<p>HTML tags.</p>
<p>For instance, "TITLE".toLowerCase() in a Turkish locale returns
"tıtle", where ı (\u0131) is the <a
href="http://www.fileformat.info/info/unicode/char/0131/index.htm">LATIN
SMALL</a></p>
<p><a
href="http://www.fileformat.info/info/unicode/char/0131/index.htm">LETTER
DOTLESS I</a> character. To obtain correct results for locale
insensitive strings, pass Locale.ROOT as a parameter to the
corresponding case converting method (e.g. toLowerCase(Locale.ROOT)
or</p>
<p>toUpperCase(Locale.ROOT)).</p>
<p>Although using Locale.ENGLISH is also correct for most cases, the
<strong>language invariant</strong> way is Locale.ROOT.</p>
<p>A detailed list of Unicode characters that require special casing can
be found <a
href="http://unicode.org/Public/UNIDATA/SpecialCasing.txt">on the
Unicode Consortium website</a>.</p>
<p>Changing case of a specific character within an ASCII string:</p>
<p>To change the case of a specific character of an ASCII string
following algorithm can be used:</p>
<p>Steps:</p>
<p>1. Declare a string.</p>
<p>2. Input the string.</p>
<p>3. Convert the string into a character array.</p>
<p>4. Input the character that is to be searched.</p>
<p>5. Search for the character into the character array.</p>
<p>6. If found,check if the character is lowercase or uppercase.</p>
<p>If Uppercase, add 32 to the ASCII code of the character.</p>
<p>If Lowercase, subtract 32 from the ASCII code of the character.</p>
<p>7. Change the original character from the Character array.</p>
<p>8. Convert the character array back into the string.</p>
<p>Voila, the Case of the character is changed.</p>
<p>An example of the code for the algorithm is:</p>
<p>Scanner scanner = <strong>new</strong> Scanner(System.in);</p>
<p>System.out.println("Enter the String");</p>
<p>String s = scanner.next();</p>
<p><strong>char</strong>[] a = s.toCharArray();</p>
<p>System.out.println("Enter the character you are looking for");
System.out.println(s);</p>
<p>String c = scanner.next();</p>
<p><strong>char</strong> d = c.charAt(0);</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;= s.length();
i++) {</p>
<p><strong>if</strong> (a[i] == d) {</p>
<p><strong>if</strong> (d &gt;= 'a' &amp;&amp; d &lt;= 'z') {</p>
<p>d -= 32;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 54</p>
<p><span id="__else_if__d_____A_____d_____Z" class="anchor"></span>}
<strong>else if</strong> (d &gt;= 'A' &amp;&amp; d &lt;= 'Z') {</p>
<p>d += 32;</p>
<p>}</p>
<p>a[i] = d;</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>s = String.valueOf(a);</p>
<p>System.out.println(s);</p>
<p>Section 11.3: Finding a String Within Another String</p>
<p>To check whether a particular String a is being contained in a String
b or not, we can use the method</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-">String.contains()</a>
with the following syntax:</p>
<p><em>b.contains(a);</em> // Return true if a is contained in b, false
otherwise</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-">The
String.contains()</a> method can be used to verify if a CharSequence can
be found in the String. The method</p>
<p>looks for the String a in the String b in a case-sensitive way.</p>
<p>String str1 = "Hello World";</p>
<p>String str2 = "Hello";</p>
<p>String str3 = "helLO";</p>
<p>System.out.println(str1.contains(str2)); <em>//prints true</em>
System.out.println(str1.contains(str3)); <em>//prints false</em></p>
<p><a href="https://ideone.com/Tdef6b">Live Demo on Ideone</a></p>
<p>To find the exact position where a String starts within another
String, use <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-java.lang.String-">String.indexOf()</a>:</p>
<p>String s = "this is a long sentence";</p>
<p><em><strong>int</strong> i = s.indexOf('i');</em> // the first 'i' in
String is at index 2 <em><strong>int</strong> j =
s.indexOf("long");</em> // the index of the first occurrence of "long"
in s is 10 <em><strong>int</strong> k = s.indexOf('z');</em> // k is -1
because 'z' was not found in String s <em><strong>int</strong> h =
s.indexOf("LoNg");</em> // h is -1 because "LoNg" was not found in
String s</p>
<p><a href="https://ideone.com/RHHcF0">Live Demo on Ideone</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-java.lang.String-">The
String.indexOf() method returns the first index of a</a>
<strong>char</strong> or String in another String. The method
returns</p>
<p>-1 if it is not found.</p>
<p><strong>Note</strong><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-java.lang.String-">:
The String.indexOf() method is case sensitive.</a></p>
<p>Example of search ignoring the case:</p>
<p>String str1 = "Hello World";</p>
<p>String str2 = "wOr";</p>
<p>str1.indexOf(str2); <em>// -1</em></p>
<p>str1.toLowerCase().contains(str2.toLowerCase()); <em>// true</em>
str1.toLowerCase().indexOf(str2.toLowerCase()); <em>// 6</em></p>
<p><a href="https://ideone.com/TQtcMf">Live Demo on Ideone</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 55</p>
<p><span id="Section_11_4__String_pool_and_he"
class="anchor"></span>Section 11.4: String pool and heap storage</p>
<p>Like many Java objects, <strong>all</strong> String instances are
created on the heap, even literals. When the JVM finds a String</p>
<p>literal that has no equivalent reference in the heap, the JVM creates
a corresponding String instance on the heap</p>
<p><strong>and</strong> it also stores a reference to the newly created
String instance in the String pool. Any other references to the</p>
<p>same String literal are replaced with the previously created String
instance in the heap.</p>
<p>Let's look at the following example:</p>
<p><strong>class</strong> Strings</p>
<p>{</p>
<p><strong>public static void</strong> main (String[] args)</p>
<p>{</p>
<p>String a = "alpha";</p>
<p>String b = "alpha";</p>
<p>String c = <strong>new</strong> String("alpha");</p>
<p>//All three strings are equivalent</p>
<p>System.out.println(a.equals(b) &amp;&amp; b.equals(c));</p>
<p>//Although only a and b reference the same heap object
<em>System.out.println(a == b);</em></p>
<p>System.out.println(a != c);</p>
<p>System.out.println(b != c);</p>
<p>}</p>
<p>}</p>
<p>The output of the above is:</p>
<p>true</p>
<p>true</p>
<p>true</p>
<p>true</p>
<p><img src="media/index-80_1.jpeg" style="width:6.5in;height:3.59722in"
alt="index-80_1.jpg" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 56</p>
<p><span id="When_we_use_double_quotes_to_cre"
class="anchor"></span>When we use double quotes to create a String, it
first looks for String with same value in the String pool, if found it
just returns the reference else it creates a new String in the pool and
then returns the reference.</p>
<p>However using new operator, we force String class to create a new
String object in heap space. We can use intern() method to put it into
the pool or refer to other String object from string pool having same
value.</p>
<p>The String pool itself is also created on the heap.</p>
<p>Version &lt; Java SE 7</p>
<p>Before Java 7, String <strong>literals</strong> were stored in the
runtime constant pool in the method area of PermGen, that had a</p>
<p>fixed size.</p>
<p>The String pool also resided in PermGen.</p>
<p>Version ≥ Java SE 7</p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html">RFC:
6962931</a></p>
<p>In JDK 7, interned strings are no longer allocated in the permanent
generation of the Java heap, but are instead allocated in the main part
of the Java heap (known as the young and old generations), along
with</p>
<p>the other objects created by the application. This change will result
in more data residing in the main Java heap, and less data in the
permanent generation, and thus may require heap sizes to be adjusted.
Most</p>
<p>applications will see only relatively small differences in heap usage
due to this change, but larger applications that load many classes or
make heavy use of the String.intern() method will see more</p>
<p>significant differences.</p>
<p>Section 11.5: Splitting Strings</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">You
can split a String on a particular delimiting character or a Regular
Expression, you can use the</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-">String.split()</a></p>
<p>method that has the following signature:</p>
<p><strong>public</strong> String[] split(String regex)</p>
<p>Note that delimiting character or regular expression gets removed
from the resulting String Array.</p>
<p>Example using delimiting character:</p>
<p>String lineFromCsvFile = "Mickey;Bolton;12345;121216"; String[]
dataCells = lineFromCsvFile.split(";");</p>
<p>// Result is dataCells = { "Mickey", "Bolton", "12345",
"121216"};</p>
<p>Example using regular expression:</p>
<p>String lineFromInput = "What do you need from me?"; String[] words =
lineFromInput.split("<strong>\\</strong>s+"); <em>// one or more space
chars // Result is words = {"What", "do", "you", "need", "from",
"me?"};</em></p>
<p>You can even directly split a String literal:</p>
<p>String[] firstNames = "Mickey, Frank, Alicia, Tom".split(", ");
<em>// Result is firstNames = {"Mickey", "Frank", "Alicia",
"Tom"};</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 57</p>
<p><strong>Warning</strong>: Do not forget that the parameter is always
treated as a regular expression.</p>
<p><em>"aaa.bbb".split(".");</em> // This returns an empty array</p>
<p>In the previous example . is treated as the regular expression
wildcard that matches any character, and since every character is a
delimiter, the result is an empty array.</p>
<p>Splitting based on a delimiter which is a regex meta-character</p>
<p>The following characters are considered special (aka meta-characters)
in regex</p>
<p>&lt; <strong>&gt;</strong> - = ! ( ) [ ] { } \ ^ $ | ? * + .</p>
<p>To split a string based on one of the above delimiters, you need to
either <em>escape</em> them using \\ or use</p>
<p>Pattern.quote():</p>
<p>Using Pattern.quote():</p>
<p>String s = "a|b|c";</p>
<p>String regex = Pattern.quote("|");</p>
<p>String[] arr = s.split(regex);</p>
<p>Escaping the special characters:</p>
<p>String s = "a|b|c";</p>
<p>String[] arr = s.split("<strong>\\</strong>|");</p>
<p>Split removes empty values</p>
<p>split(delimiter) by default removes trailing empty strings from
result array. To turn this mechanism off we need</p>
<p>to use overloaded version of split(delimiter, limit) with limit set
to negative value like</p>
<p>String[] split = data.split("<strong>\\</strong>|", -1);</p>
<p>split(regex) internally returns result of split(regex, 0).</p>
<p>The limit parameter controls the number of times the pattern is
applied and therefore affects the length of the</p>
<p>resulting array.</p>
<p>If the limit <em>n</em> is greater than zero then the pattern will be
applied at most <em>n - 1</em> times, the array's length will be no</p>
<p>greater than <em>n</em>, and the array's last entry will contain all
input beyond the last matched delimiter. If <em>n</em> is negative, then
the pattern will be applied as many times as possible and the array can
have any length.</p>
<p>If <em>n</em> is zero then the pattern will be applied as many times
as possible, the array can have any length, and trailing</p>
<p>empty strings will be discarded.</p>
<p>Splitting with a StringTokenizer</p>
<p>Besides the split() method Strings can also be split using a
StringTokenizer.</p>
<p>StringTokenizer is even more restrictive than String.split(), and
also a bit harder to use. It is essentially</p>
<p>designed for pulling out tokens delimited by a fixed set of
characters (given as a String). Each character will act as a separator.
Because of this restriction, it's about twice as fast as
String.split().</p>
<p>Default set of characters are empty spaces (\t\n\r\f). The following
example will print out each word separately.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 58</p>
<p><span id="String_str____the_lazy_fox_jumpe"
class="anchor"></span>String str = "the lazy fox jumped over the brown
fence"; StringTokenizer tokenizer = <strong>new</strong>
StringTokenizer(str); <strong>while</strong> (tokenizer.hasMoreTokens())
{</p>
<p>System.out.println(tokenizer.nextToken());</p>
<p>}</p>
<p>This will print out:</p>
<p>the</p>
<p>lazy</p>
<p>fox</p>
<p>jumped</p>
<p>over</p>
<p>the</p>
<p>brown</p>
<p>fence</p>
<p>You can use different character sets for separation.</p>
<p>String str = "jumped over";</p>
<p><em>// In this case character `u` and `e` will be used as
delimiters</em> StringTokenizer tokenizer = <strong>new</strong>
StringTokenizer(str, "ue"); <strong>while</strong>
(tokenizer.hasMoreTokens()) {</p>
<p>System.out.println(tokenizer.nextToken());</p>
<p>}</p>
<p>This will print out:</p>
<p>j</p>
<p>mp</p>
<p>d ov</p>
<p>r</p>
<p>Section 11.6: Joining Strings with a delimiter</p>
<p>Version ≥ Java SE 8</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#join-java.lang.CharSequence-java.lang.CharSequence...-">An
array of strings can be joined using the static method
String.join()</a>:</p>
<p>String[] elements = { "foo", "bar", "foobar" };</p>
<p>String singleString = String.join(" + ", elements);</p>
<p>System.out.println(singleString); <em>// Prints "foo + bar +
foobar"</em></p>
<p>Similarly, there's an overloaded <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#join-java.lang.CharSequence-java.lang.Iterable-">String.join()</a>
method for Iterables.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html">To
have a fine-grained control over joining, you may use StringJoiner
class:</a></p>
<p>StringJoiner sj = <strong>new</strong> StringJoiner(", ", "[",
"]");</p>
<p>// The last two arguments are optional,</p>
<p>// they define prefix and suffix for the result string</p>
<p>sj.add("foo");</p>
<p>sj.add("bar");</p>
<p>sj.add("foobar");</p>
<p><em>System.out.println(sj);</em> // Prints "[foo, bar, foobar]"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 59</p>
<p><span id="To_join_a_stream_of_strings__you" class="anchor"></span><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#joining-java.lang.CharSequence-">To
join a stream of strings, you may use the joining collector</a>:</p>
<p>Stream stringStream = Stream.of("foo", "bar", "foobar"); String
joined = stringStream.collect(Collectors.joining(", "));
System.out.println(joined); <em>// Prints "foo, bar, foobar"</em></p>
<p>There's an option to define <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#joining-java.lang.CharSequence-java.lang.CharSequence-java.lang.CharSequence-">prefix
and suffix here as well:</a></p>
<p>Stream stringStream = Stream.of("foo", "bar", "foobar"); String
joined = stringStream.collect(Collectors.joining(", ", "{", "}"));
System.out.println(joined); <em>// Prints "{foo, bar, foobar}"</em></p>
<p>Section 11.7: String concatenation and StringBuilders</p>
<p>String concatenation can be performed using the + operator. For
example:</p>
<p>String s1 = "a";</p>
<p>String s2 = "b";</p>
<p>String s3 = "c";</p>
<p>String s = s1 + s2 + s3; <em>// abc</em></p>
<p>Normally a compiler implementation will perform the above
concatenation using methods involving a</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">StringBuilder
under the hood. When compiled, the code would look similar to the
below:</a></p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder("a");</p>
<p>String s = sb.append("b").append("c").toString();</p>
<p>StringBuilder has several overloaded methods for appending different
types, for example, to append an <strong>int</strong> instead of a
String. For example, an implementation can convert:</p>
<p>String s1 = "a";</p>
<p>String s2 = "b";</p>
<p>String s = s1 + s2 + 2; <em>// ab2</em></p>
<p>to the following:</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder("a");</p>
<p>String s = sb.append("b").append(2).toString();</p>
<p>The above examples illustrate a simple concatenation operation that
is effectively done in a single place in the code.</p>
<p>The concatenation involves a single instance of the StringBuilder. In
some cases, a concatenation is carried out in</p>
<p>a cumulative way such as in a loop:</p>
<p>String result = "";</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt; array.length;
i++) {</p>
<p>result += extractElement(array[i]);</p>
<p>}</p>
<p><strong>return</strong> result;</p>
<p>In such cases, the compiler optimization is usually not applied, and
each iteration will create a new StringBuilder</p>
<p>object. This can be optimized by explicitly transforming the code to
use a single StringBuilder:</p>
<p>StringBuilder result = <strong>new</strong> StringBuilder();</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt; array.length;
i++) {</p>
<p>result.append(extractElement(array[i]));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 60</p>
<p><span class="anchor"></span>}</p>
<p><strong>return</strong> result.toString();</p>
<p>A StringBuilder will be initialized with an empty space of only 16
characters. If you know in advance that you will</p>
<p>be building larger strings, it can be beneficial to initialize it
with sufficient size in advance, so that the internal buffer does not
need to be resized:</p>
<p>StringBuilder buf = <strong>new</strong> StringBuilder(30); <em>//
Default is 16 characters</em> buf.append("0123456789");</p>
<p><em>buf.append("0123456789");</em> // Would cause a reallocation of
the internal buffer otherwise <em>String result = buf.toString();</em>
// Produces a 20-chars copy of the string</p>
<p>If you are producing many strings, it is advisable to reuse
StringBuilders:</p>
<p>StringBuilder buf = <strong>new</strong> StringBuilder(100);</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100; i++)
{</p>
<p>buf.setLength(0); <em>// Empty buffer</em></p>
<p>buf.append("This is line
").append(i).append('<strong>\n</strong>');</p>
<p>outputfile.write(buf.toString());</p>
<p>}</p>
<p>If (and only if) multiple threads are writing to the <em>same</em>
buffer, use <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">StringBuffer</a>,
which is a <strong>synchronized</strong> version of StringBuilder. But
because usually only a single thread writes to a buffer, it is usually
faster to use StringBuilder</p>
<p>without synchronization.</p>
<p>Using concat() method:</p>
<p>String string1 = "Hello ";</p>
<p>String string2 = "world";</p>
<p>String string3 = string1.concat(string2); <em>// "Hello
world"</em></p>
<p>This returns a new string that is string1 with string2 added to it at
the end. You can also use the concat() method with string literals, as
in:</p>
<p>"My name is ".concat("Buyya");</p>
<p>Section 11.8: Substrings</p>
<p>String s = "this is an example";</p>
<p><em>String a = s.substring(11);</em> // a will hold the string
starting at character 11 until the end ("example")</p>
<p><em>String b = s.substring(5, 10);</em> // b will hold the string
starting at character 5 and ending right before character 10 ("is
an")</p>
<p><em>String b = s.substring(5, b.length()-3);</em> // b will hold the
string starting at character 5 ending right before b' s lenght is out of
3 ("is an exam")</p>
<p>Substrings may also be applied to slice and add/replace character
into its original String. For instance, you faced a Chinese date
containing Chinese characters but you want to store it as a well format
Date String.</p>
<p>String datestring = "2015年11月17日"</p>
<p>datestring = datestring.substring(0, 4) + "-" +
datestring.substring(5,7) + "-" + datestring.substring(8,10);</p>
<p>//Result will be 2015-11-17</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring-int-">The
substring method extracts a piece of a</a> String. When provided one
parameter, the parameter is the start and</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 61</p>
<p><span id="the_piece_extends_until_the_end" class="anchor"></span>the
piece extends until the end of the String. When given two parameters,
the first parameter is the starting character and the second parameter
is the index of the character right after the end (the character at the
index is</p>
<p>not included). An easy way to check is the subtraction of the first
parameter from the second should yield the</p>
<p>expected length of the string.</p>
<p>Version &lt; Java SE 7</p>
<p>In JDK &lt;7u6 versions the substring method instantiates a String
that shares the same backing <strong>char</strong>[] as the original
String and has the internal offset and count fields set to the result
start and length. Such sharing may</p>
<p>cause memory leaks, that can be prevented by calling
<strong>new</strong> String(s.substring(...)) to force creation of a
copy, after which the <strong>char</strong>[] can be garbage
collected.</p>
<p>Version ≥ Java SE 7</p>
<p>From JDK 7u6 the substring method always copies the entire underlying
<strong>char</strong>[] array, making the complexity</p>
<p>linear compared to the previous constant one but guaranteeing the
absence of memory leaks at the same time.</p>
<p>Section 11.9: Platform independent new line separator</p>
<p>Since the new line separator varies from platform to platform (e.g.
\n on Unix-like systems or \r\n on Windows) it is</p>
<p>often necessary to have a platform-independent way of accessing it.
In Java it can be retrieved from a system property:</p>
<p>System.getProperty("line.separator")</p>
<p>Version ≥ Java SE 7</p>
<p>Because the new line separator is so commonly needed, from Java 7 on
a shortcut method returning exactly the</p>
<p>same result as the code above is available:</p>
<p>System.lineSeparator()</p>
<p><strong>Note</strong>: Since it is very unlikely that the new line
separator changes during the program's execution, it is a good idea</p>
<p>to store it in in a static final variable instead of retrieving it
from the system property every time it is needed.</p>
<p>When using String.format, use %n rather than \n or '\r\n' to output a
platform independent new line separator.</p>
<p>System.out.println(String.format('line 1: %s.%nline 2: %s%n',
lines[0],lines[1]));</p>
<p>Section 11.10: Reversing Strings</p>
<p>There are a couple ways you can reverse a string to make it
backwards.</p>
<p>1. StringBuilder/StringBuffer:</p>
<p>String code = "code";</p>
<p>System.out.println(code);</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder(code);</p>
<p>code = sb.reverse().toString();</p>
<p>System.out.println(code);</p>
<p>2. Char array:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 62</p>
<p><span id="String_code____code" class="anchor"></span>String code =
"code";</p>
<p>System.out.println(code);</p>
<p><strong>char</strong>[] array = code.toCharArray();</p>
<p><strong>for</strong> (<strong>int</strong> index = 0, mirroredIndex =
array.length-1; index &lt; mirroredIndex; index++, mirroredIndex--)
{</p>
<p><strong>char</strong> temp = array[index];</p>
<p>array[index] = array[mirroredIndex];</p>
<p>array[mirroredIndex] = temp;</p>
<p>}</p>
<p>// print reversed</p>
<p>System.out.println(<strong>new</strong> String(array));</p>
<p>Section 11.11: Adding toString() method for custom objects</p>
<p>Suppose you have defined the following Person class:</p>
<p>public class <strong>Person {</strong></p>
<p>String name;</p>
<p><strong>int</strong> age;</p>
<p><strong>public</strong> Person (<strong>int</strong> age, String
name) {</p>
<p><strong>this</strong>.age = age;</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p>If you instantiate a new Person object:</p>
<p>Person person = <strong>new</strong> Person(25, "John");</p>
<p>and later in your code you use the following statement in order to
print the object:</p>
<p>System.out.println(person.toString());</p>
<p><a href="https://ideone.com/tAl58G">Live Demo on Ideone</a></p>
<p>you'll get an output similar to the following:</p>
<p>Person@7ab89d</p>
<p>This is the result of the implementation of the toString() method
defined in the Object class, a superclass of Person . The documentation
of Object.toString() states:</p>
<p>The toString method for class Object returns a string consisting of
the name of the class of which the</p>
<p>object is an instance, the at-sign character `@', and the unsigned
hexadecimal representation of the hash code of the object. In other
words, this method returns a string equal to the value of:</p>
<p>getClass().getName() + '@' + Integer.toHexString(hashCode())</p>
<p>So, for meaningful output, you'll have to <strong>override</strong>
the toString() method:</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 63</p>
<p><span id="public_String_toString"
class="anchor"></span><strong>public</strong> String toString() {</p>
<p><strong>return</strong> "My name is " + <strong>this</strong>.name +
" and my age is " + <strong>this</strong>.age;</p>
<p>}</p>
<p>Now the output will be:</p>
<p>My name is John and my age is 25</p>
<p>You can also write</p>
<p>System.out.println(person);</p>
<p><a href="https://ideone.com/51al3w">Live Demo on Ideone</a></p>
<p>In fact, println() implicitly invokes the toString method on the
object.</p>
<p>Section 11.12: Remove Whitespace from the Beginning and End</p>
<p>of a String</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--">The
trim() method returns a new String with the leading and trailing
whitespace removed.</a></p>
<p>String s = <strong>new</strong> String(" Hello World!! ");</p>
<p><em>String t = s.trim();</em> // t = "Hello World!!"</p>
<p>If you trim a String that doesn't have any whitespace to remove, you
will be returned the same String instance.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--">Note
that the trim() method</a> <a
href="http://stackoverflow.com/q/1437933/2170192">has its own notion of
whitespace, which differs from the notion used by the</a></p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-">Character.isWhitespace()
method:</a></p>
<p>All ASCII control characters with codes U+0000 to U+0020 are
considered whitespace and are removed by</p>
<p>trim(). This includes U+0020 'SPACE', U+0009 'CHARACTER TABULATION',
U+000A 'LINE FEED' and U+000D 'CARRIAGE RETURN' characters, but also the
characters like U+0007 'BELL'.</p>
<p>Unicode whitespace like U+00A0 'NO-BREAK SPACE' or U+2003 'EM SPACE'
are <em>not</em> recognized by trim().</p>
<p>Section 11.13: Case insensitive switch</p>
<p>Version ≥ Java SE 7</p>
<p><strong>switch</strong> itself can not be parameterised to be case
insensitive, but if absolutely required, can behave insensitive to</p>
<p>the input string by using toLowerCase() or toUpperCase:</p>
<p><strong>switch</strong> (myString.toLowerCase()) {</p>
<p><strong>case</strong> "case1" :</p>
<p>...</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "case2" :</p>
<p>...</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>Beware</p>
<p>Locale might affect how changing cases happen!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 64</p>
<p><span id="Care_must_be_taken_not_to_have_a"
class="anchor"></span>Care must be taken not to have any uppercase
characters in the labels - those will never get executed!</p>
<p>Section 11.14: Replacing parts of Strings</p>
<p>Two ways to replace: by regex or by exact match.</p>
<p><strong>Note:</strong> the original String object will be unchanged,
the return value holds the changed String.</p>
<p>Exact match</p>
<p>Replace single character with another single character:</p>
<p>String replace(<strong>char</strong> oldChar, <strong>char</strong>
newChar)</p>
<p>Returns a new string resulting from replacing all occurrences of
oldChar in this string with newChar.</p>
<p>String s = "popcorn";</p>
<p>System.out.println(s.replace('p','W'));</p>
<p>Result:</p>
<p>WoWcorn</p>
<p>Replace sequence of characters with another sequence of
characters:</p>
<p>String replace(CharSequence target, CharSequence replacement)</p>
<p>Replaces each substring of this string that matches the literal
target sequence with the specified literal replacement sequence.</p>
<p>String s = "metal petal et al.";</p>
<p>System.out.println(s.replace("etal","etallica"));</p>
<p>Result:</p>
<p>metallica petallica et al.</p>
<p>Regex</p>
<p><strong>Note</strong>: the grouping uses the $ character to reference
the groups, like $1.</p>
<p>Replace all matches:</p>
<p>String replaceAll(String regex, String replacement)</p>
<p>Replaces each substring of this string that matches the given regular
expression with the given</p>
<p>replacement.</p>
<p>String s = "spiral metal petal et al.";</p>
<p>System.out.println(s.replaceAll("(<strong>\\</strong>w*etal)","$1lica"));</p>
<p>Result:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 65</p>
<p><span id="spiral_metallica_petallica_et_al"
class="anchor"></span>spiral metallica petallica et al.</p>
<p>Replace first match only:</p>
<p>String replaceFirst(String regex, String replacement)</p>
<p>Replaces the first substring of this string that matches the given
regular expression with the given</p>
<p>replacement</p>
<p>String s = "spiral metal petal et al.";</p>
<p>System.out.println(s.replaceAll("(<strong>\\</strong>w*etal)","$1lica"));</p>
<p>Result:</p>
<p>spiral metallica petal et al.</p>
<p>Section 11.15: Getting the length of a String</p>
<p>In order to get the length of a String object, call the length()
method on it. The length is equal to the number of UTF-16 code units
(chars) in the string.</p>
<p>String str = "Hello, World!";</p>
<p>System.out.println(str.length()); <em>// Prints out 13</em></p>
<p><a href="https://ideone.com/0RWKcA">Live Demo on Ideone</a></p>
<p>A <strong>char</strong> in a String is UTF-16 value. Unicode
codepoints whose values are ≥ 0x1000 (for example, most emojis) use</p>
<p>two char positions. To count the number of Unicode codepoints in a
String, regardless of whether each codepoint</p>
<p>fits in a UTF-16 <strong>char</strong> value, you can use the
codePointCount method:</p>
<p><strong>int</strong> length = str.codePointCount(0,
str.length());</p>
<p>You can also use a Stream of codepoints, as of Java 8:</p>
<p><strong>int</strong> length = str.codePoints().count();</p>
<p>Section 11.16: Getting the nth character in a String</p>
<p>String str = "My String";</p>
<p>System.out.println(str.charAt(0)); <em>// "M"</em></p>
<p>System.out.println(str.charAt(1)); <em>// "y"</em></p>
<p>System.out.println(str.charAt(2)); <em>// " "</em></p>
<p>System.out.println(str.charAt(str.length-1)); <em>// Last character
"g"</em></p>
<p>To get the nth character in a string, simply call charAt(n) on a
String, where n is the index of the character you</p>
<p>would like to retrieve</p>
<p><strong>NOTE:</strong> index n is starting at 0, so the first element
is at n=0.</p>
<p>Section 11.17: Counting occurrences of a substring or</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 66</p>
<p>character in a string</p>
<p>countMatches method from <a
href="http://org.apache.commons.lang3.StringUtils">org.apache.commons.lang3.StringUtils</a>
is typically used to count occurrences of a</p>
<p>substring or character in a String:</p>
<p><strong>import</strong> org.apache.commons.lang3.StringUtils;</p>
<p>String text = "One fish, two fish, red fish, blue fish";</p>
<p>// count occurrences of a substring</p>
<p>String stringTarget = "fish";</p>
<p><strong>int</strong> stringOccurrences =
StringUtils.countMatches(text, stringTarget); <em>// 4</em></p>
<p>// count occurrences of a char</p>
<p><strong>char</strong> charTarget = ',';</p>
<p><strong>int</strong> charOccurrences = StringUtils.countMatches(text,
charTarget); <em>// 3</em></p>
<p>Otherwise for does the same with standard Java API's you could use
Regular Expressions:</p>
<p><strong>import</strong> java.util.regex.Matcher;</p>
<p><strong>import</strong> java.util.regex.Pattern;</p>
<p>String text = "One fish, two fish, red fish, blue fish";
System.out.println(countStringInString("fish", text)); <em>// prints
4</em> System.out.println(countStringInString(",", text)); <em>// prints
3</em></p>
<p><strong>public static int</strong> countStringInString(String search,
String text) {</p>
<p>Pattern pattern = Pattern.compile(search);</p>
<p>Matcher matcher = pattern.matcher(text);</p>
<p><strong>int</strong> stringOccurrences = 0;</p>
<p><strong>while</strong> (matcher.find()) {</p>
<p>stringOccurrences++;</p>
<p>}</p>
<p><strong>return</strong> stringOccurrences;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 67</p>
<p><span id="Chapter_12__StringBu_er_1" class="anchor"></span>Chapter
12: StringBuer</p>
<p>Introduction to Java StringBuffer class.</p>
<p>Section 12.1: String Buer class</p>
<p>Key Points:</p>
<p>used to created mutable (modifiable) string.</p>
<p><strong>Mutable</strong>: Which can be changed.</p>
<p>is thread-safe i.e. multiple threads cannot access it
simultaneously.</p>
<p>Methods:</p>
<p>public synchronized StringBuffer append(String s)</p>
<p>public synchronized StringBuffer insert(int offset, String s)</p>
<p>public synchronized StringBuffer replace(int startIndex, int
endIndex, String str)</p>
<p>public synchronized StringBuffer delete(int startIndex, int
endIndex)</p>
<p>public synchronized StringBuffer reverse()</p>
<p>public int capacity()</p>
<p>public void ensureCapacity(int minimumCapacity)</p>
<p>public char charAt(int index)</p>
<p>public int length()</p>
<p>public String substring(int beginIndex)</p>
<p>public String substring(int beginIndex, int endIndex)</p>
<p>Example Showing difference between String and String Buffer
implementation:</p>
<p><strong>class</strong> Test {</p>
<p><strong>public static void</strong> main(String args[])</p>
<p>{</p>
<p>String str = "study";</p>
<p>str.concat("tonight");</p>
<p>System.out.println(str); <em>// Output: study</em></p>
<p>StringBuffer strB = <strong>new</strong> StringBuffer("study");</p>
<p>strB.append("tonight");</p>
<p>System.out.println(strB); <em>// Output: studytonight</em></p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 68</p>
<p><span id="Chapter_13__StringBuilder_1" class="anchor"></span>Chapter
13: StringBuilder</p>
<p>Java StringBuilder class is used to create mutable (modifiable)
string. The Java StringBuilder class is same as</p>
<p>StringBuffer class except that it is non-synchronized. It is
available since JDK 1.5.</p>
<p>Section 13.1: Comparing StringBuer, StringBuilder, Formatter</p>
<p>and StringJoiner</p>
<p>The StringBuffer, StringBuilder, Formatter and StringJoiner classes
are Java SE utility classes that are primarily</p>
<p>used for assembling strings from other information:</p>
<p>The StringBuffer class has been present since Java 1.0, and provides
a variety of methods for building and</p>
<p>modifying a "buffer" containing a sequence of characters.</p>
<p>The StringBuilder class was added in Java 5 to address performance
issues with the original StringBuffer class. The APIs for the two clases
are essentially the same. The main difference between StringBuffer
and</p>
<p>StringBuilder is that the former is thread-safe and synchronized and
the latter is not.</p>
<p>This example shows how StringBuilder is can be used:</p>
<p><strong>int</strong> one = 1;</p>
<p>String color = "red";</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder();</p>
<p>sb.append("One=").append(one).append(",
Color=").append(color).append('<strong>\n</strong>');
System.out.print(sb);</p>
<p>// Prints "One=1, Colour=red" followed by an ASCII newline.</p>
<p>(The StringBuffer class is used the same way: just change
StringBuilder to StringBuffer in the above)</p>
<p>The StringBuffer and StringBuilder classes are suitable for both
assembling and modifying strings; i.e they provide methods for replacing
and removing characters as well as adding them in various. The remining
two</p>
<p>classes are specific to the task of assembling strings.</p>
<p>The Formatter class was added in Java 5, and is loosely modeled on
the sprintf function in the C standard</p>
<p>library. It takes a <em>format</em> string with embedded <em>format
specifiers</em> and a sequences of other arguments, and generates a
string by converting the arguments into text and substituting them in
place of the format</p>
<p>specifiers. The details of the format specifiers say how the
arguments are converted into text.</p>
<p>The StringJoiner class was added in Java 8. It is a special purpose
formatter that succinctly formats a sequence of strings with separators
between them. It is designed with a <em>fluent</em> API, and can be used
with Java</p>
<p>8 streams.</p>
<p>Here are some typical examples of Formatter usage:</p>
<p>// This does the same thing as the StringBuilder example above
<em><strong>int</strong> one = 1;</em></p>
<p>String color = "red";</p>
<p>Formatter f = <strong>new</strong> Formatter();</p>
<p><em>System.out.print(f.format("One=%d, colour=%s%n", one,
color));</em> // Prints "One=1, Colour=red" followed by the platform's
line separator</p>
<p><em>// The same thing using the `String.format` convenience
method</em> System.out.print(String.format("One=%d, color=%s%n", one,
color));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 69</p>
<p><span id="The_StringJoiner_class_is_not_id" class="anchor"></span>The
StringJoiner class is not ideal for the above task, so here is an
example of a formatting an array of strings.</p>
<p>StringJoiner sj = <strong>new</strong> StringJoiner(", ", "[", "]");
<strong>for</strong> (String s : <strong>new</strong> String[]{"A", "B",
"C"}) {</p>
<p>sj.add(s);</p>
<p>}</p>
<p>System.out.println(sj);</p>
<p>// Prints "[A, B, C]"</p>
<p>The use-cases for the 4 classes can be summarized:</p>
<p>StringBuilder suitable for any string assembly OR string modification
task.</p>
<p>StringBuffer use (only) when you require a thread-safe version of
StringBuilder.</p>
<p>Formatter provides much richer string formatting functionality, but
is not as efficient as StringBuilder. This is because each call to
Formatter.format(...) entails:</p>
<p>parsing the format string,</p>
<p>creating and populate a <em>varargs</em> array, and</p>
<p>autoboxing any primitive type arguments.</p>
<p>StringJoiner provides succinct and efficient formatting of a sequence
of strings with separators, but is not</p>
<p>suitable for other formatting tasks.</p>
<p>Section 13.2: Repeat a String n times</p>
<p>Problem: Create a String containing n repetitions of a String s.</p>
<p>The trivial approach would be repeatedly concatenating the String</p>
<p>final int <strong>n = ...</strong></p>
<p><strong>final</strong> String s = ...</p>
<p>String result = "";</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; n; i++)
{</p>
<p>result += s;</p>
<p>}</p>
<p>This creates n new string instances containing 1 to n repetitions of
s resulting in a runtime of O(s.length() * n²) =</p>
<p>O(s.length() * (1+2+...+(n-1)+n)).</p>
<p>To avoid this StringBuilder should be used, which allows creating the
String in O(s.length() * n) instead:</p>
<p>final int <strong>n = ...</strong></p>
<p><strong>final</strong> String s = ...</p>
<p>StringBuilder builder = <strong>new</strong> StringBuilder();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; n; i++)
{</p>
<p>builder.append(s);</p>
<p>}</p>
<p>String result = builder.toString();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 70</p>
<p><span id="Chapter_14__String_Tokenizer_1"
class="anchor"></span>Chapter 14: String Tokenizer</p>
<p>The java.util.StringTokenizer class allows you to break a string into
tokens. It is simple way to break string.</p>
<p>The set of delimiters (the characters that separate tokens) may be
specified either at creation time or on a per-</p>
<p>token basis.</p>
<p>Section 14.1: StringTokenizer Split by space</p>
<p><strong>import</strong> java.util.StringTokenizer;</p>
<p>public class <strong>Simple{</strong></p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>StringTokenizer st = <strong>new</strong> StringTokenizer("apple ball
cat dog"," ");</p>
<p><strong>while</strong> (st.hasMoreTokens()) {</p>
<p>System.out.println(st.nextToken());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>apple</p>
<p>ball</p>
<p>cat</p>
<p>dog</p>
<p>Section 14.2: StringTokenizer Split by comma ','</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>StringTokenizer st = <strong>new</strong> StringTokenizer("apple,ball
cat,dog", ","); <strong>while</strong> (st.hasMoreTokens()) {</p>
<p>System.out.println(st.nextToken());</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>apple</p>
<p>ball cat</p>
<p>dog</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 71</p>
<p><span id="Chapter_15__Splitting_a_string_i_1"
class="anchor"></span>Chapter 15: Splitting a string into fixed</p>
<p>length parts</p>
<p>Section 15.1: Break a string up into substrings all of a known</p>
<p>length</p>
<p>The trick is to use a look-behind with the regex \G, which means "end
of previous match":</p>
<p>String[] parts = str.split("(?&lt;=<strong>\\</strong>G.{8})");</p>
<p>The regex matches 8 characters after the end of the last match. Since
in this case the match is zero-width, we could</p>
<p>more simply say "8 characters after the last match".</p>
<p>Conveniently, \G is initialized to start of input, so it works for
the first part of the input too.</p>
<p>Section 15.2: Break a string up into substrings all of variable</p>
<p>length</p>
<p>Same as the known length example, but insert the length into
regex:</p>
<p><strong>int</strong> length = 5;</p>
<p>String[] parts = str.split("(?&lt;=<strong>\\</strong>G.{" + length +
"})");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 72</p>
<p><span id="Chapter_16__Date_Class_1" class="anchor"></span>Chapter 16:
Date Class</p>
<p>Parameter Explanation</p>
<p>No parameter Creates a new Date object using the allocation time (to
the nearest millisecond)</p>
<p>long date Creates a new Date object with the time set to the number
of milliseconds since "the epoch" (January 1, 1970, 00:00:00 GMT)</p>
<p>Section 16.1: Convert java.util.Date to java.sql.Date</p>
<p>java.util.Date to java.sql.Date conversion is usually necessary when
a Date object needs to be written in a</p>
<p>database.</p>
<p>java.sql.Date is a wrapper around millisecond value and is used by
JDBC to identify an SQL DATE type</p>
<p>In the below example, we use the java.util.Date() constructor, that
creates a Date object and initializes it to</p>
<p>represent time to the nearest millisecond. This date is used in the
convert(java.util.Date utilDate) method to</p>
<p>return a java.sql.Date object</p>
<p>Example</p>
<p><strong>public class</strong> UtilToSqlConversion {</p>
<p><strong>public static void</strong> main(String args[])</p>
<p>{</p>
<p>java.util.Date utilDate = <strong>new</strong> java.util.Date();</p>
<p>System.out.println("java.util.Date is : " + utilDate);</p>
<p>java.sql.Date sqlDate = convert(utilDate);</p>
<p>System.out.println("java.sql.Date is : " + sqlDate); DateFormat df =
<strong>new</strong> SimpleDateFormat("dd/MM/YYYY - hh:mm:ss");
System.out.println("dateFormated date is : " + df.format(utilDate));</p>
<p>}</p>
<p><strong>private static</strong> java.sql.Date convert(java.util.Date
uDate) { java.sql.Date sDate = <strong>new</strong>
java.sql.Date(uDate.getTime());</p>
<p><strong>return</strong> sDate;</p>
<p>}</p>
<p>}</p>
<p>Output</p>
<p>java.util.Date is : Fri Jul 22 14:40:35 IST 2016</p>
<p>java.sql.Date is : 2016-07-22</p>
<p>dateFormated date is : 22/07/2016 - 02:40:35</p>
<p>java.util.Date has both date and time information, whereas
java.sql.Date only has date information</p>
<p>Section 16.2: A basic date output</p>
<p>Using the following code with the format string yyyy/MM/dd hh:mm.ss,
we will receive the following output</p>
<p>2016/04/19 11:45.36</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 73</p>
<p><span id="___define_the_format_to_use" class="anchor"></span>//
define the format to use</p>
<p>String formatString = "yyyy/MM/dd hh:mm.ss";</p>
<p>// get a current date object</p>
<p>Date date = Calendar.getInstance().getTime();</p>
<p>// create the formatter</p>
<p>SimpleDateFormat simpleDateFormat = <strong>new</strong>
SimpleDateFormat(formatString);</p>
<p>// format the date</p>
<p>String formattedDate = simpleDateFormat.format(date);</p>
<p>// print it</p>
<p>System.out.println(formattedDate);</p>
<p>// single-line version of all above code</p>
<p>System.out.println(<strong>new</strong> SimpleDateFormat("yyyy/MM/dd
hh:mm.ss").format(Calendar.getInstance().getTime()));</p>
<p>Section 16.3: Java 8 LocalDate and LocalDateTime objects</p>
<p>Date and LocalDate objects <strong>cannot</strong> be
<em>exactly</em> converted between each other since a Date object
represents both a</p>
<p>specific day and time, while a LocalDate object does not contain time
or timezone information. However, it can be</p>
<p>useful to convert between the two if you only care about the actual
date information and not the time information.</p>
<p>Creates a LocalDate</p>
<p>// Create a default date</p>
<p>LocalDate lDate = LocalDate.now();</p>
<p>// Creates a date from values</p>
<p>lDate = LocalDate.of(2017, 12, 15);</p>
<p>// create a date from string</p>
<p>lDate = LocalDate.parse("2017-12-15");</p>
<p>// creates a date from zone</p>
<p>LocalDate.now(ZoneId.systemDefault());</p>
<p>Creates a LocalDateTime</p>
<p>// Create a default date time</p>
<p>LocalDateTime lDateTime = LocalDateTime.now();</p>
<p>// Creates a date time from values</p>
<p>lDateTime = LocalDateTime.of(2017, 12, 15, 11, 30);</p>
<p>// create a date time from string</p>
<p>lDateTime = LocalDateTime.parse("2017-12-05T11:30:30");</p>
<p>// create a date time from zone</p>
<p>LocalDateTime.now(ZoneId.systemDefault());</p>
<p>LocalDate to Date and vice-versa</p>
<p>Date date = Date.from(Instant.now());</p>
<p>ZoneId defaultZoneId = ZoneId.systemDefault();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 74</p>
<p><span id="___Date_to_LocalDate" class="anchor"></span>// Date to
LocalDate</p>
<p>LocalDate localDate =
date.toInstant().atZone(defaultZoneId).toLocalDate();</p>
<p>// LocalDate to Date</p>
<p>Date.from(localDate.atStartOfDay(defaultZoneId).toInstant());</p>
<p>LocalDateTime to Date and vice-versa</p>
<p>Date date = Date.from(Instant.now());</p>
<p>ZoneId defaultZoneId = ZoneId.systemDefault();</p>
<p>// Date to LocalDateTime</p>
<p>LocalDateTime localDateTime =
date.toInstant().atZone(defaultZoneId).toLocalDateTime();</p>
<p>// LocalDateTime to Date</p>
<p>Date out =
Date.from(localDateTime.atZone(defaultZoneId).toInstant());</p>
<p>Section 16.4: Creating a Specific Date</p>
<p>While the Java Date class has several constructors, you'll notice
that most are deprecated. The only acceptable way of creating a Date
instance directly is either by using the empty constructor or passing in
a long (number of</p>
<p>milliseconds since standard base time). Neither are handy unless
you're looking for the current date or have another Date instance
already in hand.</p>
<p>To create a new date, you will need a Calendar instance. From there
you can set the Calendar instance to the date that you need.</p>
<p>Calendar c = Calendar.getInstance();</p>
<p>This returns a new Calendar instance set to the current time.
Calendar has many methods for mutating it's date</p>
<p>and time or setting it outright. In this case, we'll set it to a
specific date.</p>
<p>c.set(1974, 6, 2, 8, 0, 0);</p>
<p>Date d = c.getTime();</p>
<p>The getTime method returns the Date instance that we need. Keep in
mind that the Calendar set methods only set one or more fields, they do
not set them all. That is, if you set the year, the other fields remain
unchanged.</p>
<p>PITFALL</p>
<p>In many cases, this code snippet fulfills its purpose, but keep in
mind that two important parts of the date/time are not defined.</p>
<p>the (1974, 6, 2, 8, 0, 0) parameters are interpreted within the
default timezone, defined somewhere else,</p>
<p>the milliseconds are not set to zero, but filled from the system
clock at the time the Calendar instance is created.</p>
<p>Section 16.5: Converting Date to a certain String format</p>
<p>format() from SimpleDateFormat class helps to convert a Date object
into certain format String object by using the supplied <em>pattern
string</em>.</p>
<p>Date today = <strong>new</strong> Date();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 75</p>
<p><span id="SimpleDateFormat_dateFormat___ne"
class="anchor"></span>SimpleDateFormat dateFormat = <strong>new</strong>
SimpleDateFormat("dd-MMM-yy"); <em>//pattern is specified here</em>
System.out.println(dateFormat.format(today)); <em>//25-Feb-16</em></p>
<p>Patterns can be applied again by using applyPattern()</p>
<p>dateFormat.applyPattern("dd-MM-yyyy");</p>
<p>System.out.println(dateFormat.format(today));
<em>//25-02-2016</em></p>
<p>dateFormat.applyPattern("dd-MM-yyyy HH:mm:ss E");</p>
<p>System.out.println(dateFormat.format(today)); <em>//25-02-2016
06:14:33 Thu</em></p>
<p><strong>Note:</strong> Here mm (small letter m) denotes minutes and
MM (capital M) denotes month. Pay careful attention when</p>
<p>formatting years: capital "Y" (Y) indicates the "week in the year"
while lower-case "y" (y) indicates the year.</p>
<p>Section 16.6: LocalTime</p>
<p>To use just the time part of a Date use LocalTime. You can
instantiate a LocalTime object in a couple ways</p>
<p>1. LocalTime time = LocalTime.now();</p>
<p>2. time = LocalTime.MIDNIGHT;</p>
<p>3. time = LocalTime.NOON;</p>
<p>4. time = LocalTime.of(12, 12, 45);</p>
<p>LocalTime also has a built in toString method that displays the
format very nicely.</p>
<p>System.out.println(time);</p>
<p>you can also get, add and subtract hours, minutes, seconds, and
nanoseconds from the LocalTime object i.e.</p>
<p>time.plusMinutes(1);</p>
<p>time.getMinutes();</p>
<p>time.minusMinutes(1);</p>
<p>You can turn it into a Date object with the following code:</p>
<p>LocalTime lTime = LocalTime.now();</p>
<p>Instant instant = lTime.atDate(LocalDate.of(A_YEAR, A_MONTH,
A_DAY)).</p>
<p>atZone(ZoneId.systemDefault()).toInstant();</p>
<p>Date time = Date.from(instant);</p>
<p>this class works very nicely within a timer class to simulate an
alarm clock.</p>
<p>Section 16.7: Convert formatted string representation of date</p>
<p>to Date object</p>
<p>This method can be used to convert a formatted string representation
of a date into a Date object.</p>
<p>/**</p>
<p>* Parses the date using the given format.</p>
<p>*</p>
<p>* @param formattedDate the formatted date string</p>
<p>* @param dateFormat the date format which was used to create the
string.</p>
<p>* @return the date</p>
<p>*/</p>
<p><strong>public static</strong> Date parseDate(String formattedDate,
String dateFormat) {</p>
<p>Date date = <strong>null</strong>;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 76</p>
<p><span id="SimpleDateFormat_objDf___new_Sim"
class="anchor"></span>SimpleDateFormat objDf = <strong>new</strong>
SimpleDateFormat(dateFormat); <strong>try</strong> {</p>
<p>date = objDf.parse(formattedDate);</p>
<p>} <strong>catch</strong> (ParseException e) {</p>
<p>// Do what ever needs to be done with exception.</p>
<p>}</p>
<p>return <strong>date;</strong></p>
<p>}</p>
<p>Section 16.8: Creating Date objects</p>
<p>Date date = <strong>new</strong> Date();</p>
<p><em>System.out.println(date);</em> // Thu Feb 25 05:03:59 IST
2016</p>
<p>Here this Date object contains the current date and time when this
object was created.</p>
<p>Calendar calendar = Calendar.getInstance();</p>
<p>calendar.set(90, Calendar.DECEMBER, 11);</p>
<p>Date myBirthDate = calendar.getTime();</p>
<p>System.out.println(myBirthDate); <em>// Mon Dec 31 00:00:00 IST
1990</em></p>
<p>Date objects are best created through a Calendar instance since the
use of the data constructors is deprecated and</p>
<p>discouraged. To do se we need to get an instance of the Calendar
class from the factory method. Then we can set year, month and day of
month by using numbers or in case of months constants provided py the
Calendar class to</p>
<p>improve readability and reduce errors.</p>
<p>calendar.set(90, Calendar.DECEMBER, 11, 8, 32, 35); Date
myBirthDatenTime = calendar.getTime();</p>
<p>System.out.println(myBirthDatenTime); <em>// Mon Dec 31 08:32:35 IST
1990</em></p>
<p>Along with date, we can also pass time in the order of hour, minutes
and seconds.</p>
<p>Section 16.9: Comparing Date objects</p>
<p>Calendar, Date, and LocalDate</p>
<p>Version &lt; Java SE 8</p>
<p>before, after, compareTo and equals methods</p>
<p>//Use of Calendar and Date objects</p>
<p><strong>final</strong> Date today = <strong>new</strong> Date();</p>
<p><strong>final</strong> Calendar calendar =
Calendar.getInstance();</p>
<p>calendar.set(1990, Calendar.NOVEMBER, 1, 0, 0, 0); Date birthdate =
calendar.getTime();</p>
<p><strong>final</strong> Calendar calendar2 =
Calendar.getInstance();</p>
<p>calendar2.set(1990, Calendar.NOVEMBER, 1, 0, 0, 0); Date
samebirthdate = calendar2.getTime();</p>
<p>//Before example</p>
<p>System.out.printf("Is %1$tF before %2$tF? %3$b%n", today, birthdate,
Boolean.valueOf(today.before(birthdate)));</p>
<p>System.out.printf("Is %1$tF before %1$tF? %3$b%n", today, today,
Boolean.valueOf(today.before(today)));</p>
<p>System.out.printf("Is %2$tF before %1$tF? %3$b%n", today, birthdate,
Boolean.valueOf(birthdate.before(today)));</p>
<p>//After example</p>
<p>System.out.printf("Is %1$tF after %2$tF? %3$b%n", today,
birthdate,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 77</p>
<p>Boolean.valueOf(today.after(birthdate)));</p>
<p>System.out.printf("Is %1$tF after %1$tF? %3$b%n", today, birthdate,
Boolean.valueOf(today.after(today)));</p>
<p>System.out.printf("Is %2$tF after %1$tF? %3$b%n", today, birthdate,
Boolean.valueOf(birthdate.after(today)));</p>
<p>//Compare example</p>
<p>System.out.printf("Compare %1$tF to %2$tF: %3$d%n", today, birthdate,
Integer.valueOf(today.compareTo(birthdate)));</p>
<p>System.out.printf("Compare %1$tF to %1$tF: %3$d%n", today, birthdate,
Integer.valueOf(today.compareTo(today)));</p>
<p>System.out.printf("Compare %2$tF to %1$tF: %3$d%n", today, birthdate,
Integer.valueOf(birthdate.compareTo(today)));</p>
<p>//Equal example</p>
<p>System.out.printf("Is %1$tF equal to %2$tF? %3$b%n", today,
birthdate, Boolean.valueOf(today.equals(birthdate)));</p>
<p>System.out.printf("Is %1$tF equal to %2$tF? %3$b%n", birthdate,
samebirthdate,</p>
<p>Boolean.valueOf(birthdate.equals(samebirthdate)));</p>
<p>System.out.printf(</p>
<p>"Because birthdate.getTime() -&gt; %1$d is different from
samebirthdate.getTime() -&gt; %2$d,</p>
<p>there are millisecondes!%n",</p>
<p>Long.valueOf(birthdate.getTime()),
Long.valueOf(samebirthdate.getTime()));</p>
<p>//Clear ms from calendars</p>
<p>calendar.clear(Calendar.MILLISECOND);</p>
<p>calendar2.clear(Calendar.MILLISECOND);</p>
<p>birthdate = calendar.getTime();</p>
<p>samebirthdate = calendar2.getTime();</p>
<p>System.out.printf("Is %1$tF equal to %2$tF after clearing ms?
%3$b%n", birthdate, samebirthdate,</p>
<p>Boolean.valueOf(birthdate.equals(samebirthdate)));</p>
<p>Version ≥ Java SE 8</p>
<p>isBefore, isAfter, compareTo and equals methods</p>
<p>//Use of LocalDate</p>
<p><strong>final</strong> LocalDate now = LocalDate.now();</p>
<p><strong>final</strong> LocalDate birthdate2 = LocalDate.of(2012, 6,
30); <strong>final</strong> LocalDate birthdate3 = LocalDate.of(2012, 6,
30);</p>
<p>//Hours, minutes, second and nanoOfsecond can also be configured with
an other class LocalDateTime //LocalDateTime.of(year, month, dayOfMonth,
hour, minute, second, nanoOfSecond);</p>
<p>//isBefore example</p>
<p>System.out.printf("Is %1$tF before %2$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.isBefore(birthdate2)));</p>
<p>System.out.printf("Is %1$tF before %1$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.isBefore(now)));</p>
<p>System.out.printf("Is %2$tF before %1$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(birthdate2.isBefore(now)));</p>
<p>//isAfter example</p>
<p>System.out.printf("Is %1$tF after %2$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.isAfter(birthdate2)));</p>
<p>System.out.printf("Is %1$tF after %1$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.isAfter(now)));</p>
<p>System.out.printf("Is %2$tF after %1$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(birthdate2.isAfter(now)));</p>
<p>//compareTo example</p>
<p>System.out.printf("Compare %1$tF to %2$tF %3$d%n", now, birthdate2,
Integer.valueOf(now.compareTo(birthdate2)));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 78</p>
<p>System.out.printf("Compare %1$tF to %1$tF %3$d%n", now, birthdate2,
Integer.valueOf(now.compareTo(now)));</p>
<p>System.out.printf("Compare %2$tF to %1$tF %3$d%n", now, birthdate2,
Integer.valueOf(birthdate2.compareTo(now)));</p>
<p>//equals example</p>
<p>System.out.printf("Is %1$tF equal to %2$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.equals(birthdate2)));</p>
<p>System.out.printf("Is %1$tF to %2$tF? %3$b%n", birthdate2,
birthdate3, Boolean.valueOf(birthdate2.equals(birthdate3)));</p>
<p>//isEqual example</p>
<p>System.out.printf("Is %1$tF equal to %2$tF? %3$b%n", now, birthdate2,
Boolean.valueOf(now.isEqual(birthdate2)));</p>
<p>System.out.printf("Is %1$tF to %2$tF? %3$b%n", birthdate2,
birthdate3, Boolean.valueOf(birthdate2.isEqual(birthdate3)));</p>
<p>Date comparison before Java 8</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html">Before
Java 8, dates could be compared using java.util.Calendar</a> and <a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html">java.util.Date
classes. Date class offers 4</a></p>
<p>methods to compare dates :</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html#after(java.util.Date)">after(Date
when)</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html#before(java.util.Date)">before(Date
when)</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html#compareTo(java.util.Date)">compareTo(Date
anotherDate)</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html#equals(java.lang.Object)">equals(Object
obj)</a></p>
<p>after , before, compareTo and equals methods compare the values
returned by <a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html#getTime()">getTime()
method for each date.</a></p>
<p>compareTo method returns positive integer.</p>
<p>Value greater than 0 : when the Date is after the Date argument Value
greater than 0 : when the Date is before the Date argument</p>
<p>Value equals to 0 : when the Date is equal to the Date argument</p>
<p>equals results can be surprising as shown in the example because
values, like milliseconds, are not initialize with</p>
<p>the same value if not explicitly given.</p>
<p>Since Java 8</p>
<p>With Java 8 a new Object to work with Date is available <a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">java.time.LocalDate</a>.
LocalDate implements</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/chrono/ChronoLocalDate.html">ChronoLocalDate,
the abstract representation of a date where the Chronology, or calendar
system, is pluggable.</a></p>
<p>To have the date time precision the Object <a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">java.time.LocalDateTime</a>
has to be used. LocalDate and LocalDateTime</p>
<p>use the same methods name for comparing.</p>
<p>Comparing dates using a LocalDate is different from using
ChronoLocalDate because the chronology, or calendar</p>
<p>system are not taken in account the first one.</p>
<p>Because most application should use LocalDate, ChronoLocalDate is not
included in examples. Further reading</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/chrono/ChronoLocalDate.html">here.</a></p>
<p>Most applications should declare method signatures, fields and
variables as LocalDate, not this[ChronoLocalDate] interface.</p>
<p>LocalDate has 5 methods to compare dates :</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 79</p>
<p><span id="isAfter_ChronoLocalDate_other" class="anchor"></span><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#isAfter-java.time.chrono.ChronoLocalDate-">isAfter(ChronoLocalDate
other)</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#isBefore-java.time.chrono.ChronoLocalDate-">isBefore(ChronoLocalDate
other)</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#isEqual-java.time.chrono.ChronoLocalDate-">isEqual(ChronoLocalDate
other)</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#compareTo-java.time.chrono.ChronoLocalDate-">compareTo(ChronoLocalDate
other)</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#equals-java.lang.Object-">equals(Object
obj)</a></p>
<p>In case of LocalDate parameter, isAfter, isBefore, isEqual, equals
and compareTo now use this method:</p>
<p><strong>int</strong> compareTo0(LocalDate otherDate) {</p>
<p><strong>int</strong> cmp = (year - otherDate.year);</p>
<p><strong>if</strong> (cmp == 0) {</p>
<p>cmp = (month - otherDate.month);</p>
<p><strong>if</strong> (cmp == 0) {</p>
<p>cmp = (day - otherDate.day);</p>
<p>}</p>
<p>}</p>
<p>return <strong>cmp;</strong></p>
<p>}</p>
<p>equals method check if the parameter reference equals the date first
whereas isEqual directly calls compareTo0.</p>
<p>In case of an other class instance of ChronoLocalDate the dates are
compared using the Epoch Day. The Epoch Day count is a simple
incrementing count of days where day 0 is 1970-01-01 (ISO).</p>
<p>Section 16.10: Converting String into Date</p>
<p>parse() from SimpleDateFormat class helps to convert a String pattern
into a Date object.</p>
<p>DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT,
Locale.US); String dateStr = "02/25/2016"; <em>// input String</em></p>
<p>Date date = dateFormat.parse(dateStr);</p>
<p>System.out.println(date.getYear()); <em>// 116</em></p>
<p>There are 4 different styles for the text format, SHORT, MEDIUM (this
is the default), LONG and FULL, all of which</p>
<p>depend on the locale. If no locale is specified, the system default
locale is used.</p>
<p>Style Locale.US Locale.France</p>
<p>SHORT 6/30/09 30/06/09</p>
<p>MEDIUM Jun 30, 2009 30 juin 2009</p>
<p>LONG June 30, 2009 30 juin 2009</p>
<p>FULL Tuesday, June 30, 2009 mardi 30 juin 2009</p>
<p>Section 16.11: Time Zones and java.util.Date</p>
<p>A java.util.Date object <em>does not</em> have a concept of time
zone.</p>
<p>There is no way to <strong>set</strong> a timezone for a Date</p>
<p>There is no way to <strong>change</strong> the timezone of a Date
object</p>
<p>A Date object created with the <strong>new</strong> Date() default
constructor will be initialised with the current time in the</p>
<p>system default timezone</p>
<p>However, it is possible to display the date represented by the point
in time described by the Date object in a</p>
<p>different time zone using e.g. java.text.SimpleDateFormat:</p>
<p>Date date = <strong>new</strong> Date();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 80</p>
<p>//print default time zone</p>
<p>System.out.println(TimeZone.getDefault().getDisplayName());
SimpleDateFormat sdf = <strong>new</strong> SimpleDateFormat("yyyy-MM-dd
HH:mm:ss"); <em>//note: time zone not in format!</em></p>
<p>//print date in the original time zone</p>
<p>System.out.println(sdf.format(date));</p>
<p>//current time in London</p>
<p>sdf.setTimeZone(TimeZone.getTimeZone("Europe/London"));
System.out.println(sdf.format(date));</p>
<p>Output:</p>
<p>Central European Time</p>
<p>2016-07-21 22:50:56</p>
<p>2016-07-21 21:50:56</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 81</p>
<p><span id="Chapter_17__Dates_and_Time__java_1"
class="anchor"></span>Chapter 17: Dates and Time (java.time.*)</p>
<p>Section 17.1: Calculate Dierence between 2 LocalDates</p>
<p>Use LocalDate and ChronoUnit:</p>
<p>LocalDate d1 = LocalDate.of(2017, 5, 1);</p>
<p>LocalDate d2 = LocalDate.of(2017, 5, 18);</p>
<p>now, since the method between of the ChronoUnit enumerator takes 2
Temporals as parameters so you can pass</p>
<p>without a problem the LocalDate instances</p>
<p><strong>long</strong> days = ChronoUnit.DAYS.between(d1, d2);</p>
<p>System.out.println( days );</p>
<p>Section 17.2: Date and time</p>
<p>Date and time without time zone information</p>
<p>LocalDateTime dateTime = LocalDateTime.of(2016, Month.JULY, 27, 8,
0); LocalDateTime now = LocalDateTime.now();</p>
<p>LocalDateTime parsed =
LocalDateTime.parse("2016-07-27T07:00:00");</p>
<p>Date and time with time zone information</p>
<p>ZoneId zoneId = ZoneId.of("UTC+2");</p>
<p>ZonedDateTime dateTime = ZonedDateTime.of(2016, Month.JULY, 27, 7, 0,
0, 235, zoneId); ZonedDateTime composition = ZonedDateTime.of(localDate,
localTime, zoneId); ZonedDateTime now = ZonedDateTime.now(); <em>//
Default time zone</em> ZonedDateTime parsed =
ZonedDateTime.parse("2016-07-27T07:00:00+01:00[Europe/Stockholm]");</p>
<p>Date and time with offset information (i.e. no DST changes taken into
account)</p>
<p>ZoneOffset zoneOffset = ZoneOffset.ofHours(2);</p>
<p>OffsetDateTime dateTime = OffsetDateTime.of(2016, 7, 27, 7, 0, 0,
235, zoneOffset); OffsetDateTime composition =
OffsetDateTime.of(localDate, localTime, zoneOffset); OffsetDateTime now
= OffsetDateTime.now(); <em>// Offset taken from the default ZoneId</em>
OffsetDateTime parsed =
OffsetDateTime.parse("2016-07-27T07:00:00+02:00");</p>
<p>Section 17.3: Operations on dates and times</p>
<p>LocalDate tomorrow = LocalDate.now().plusDays(1);</p>
<p>LocalDateTime anHourFromNow = LocalDateTime.now().plusHours(1); Long
daysBetween =
java.time.temporal.ChronoUnit.DAYS.between(LocalDate.now(),
LocalDate.now().plusDays(3)); <em>// 3</em></p>
<p>Duration duration = Duration.between(Instant.now(),
ZonedDateTime.parse("2016-07-27T07:00:00+01:00[Europe/Stockholm]"))</p>
<p>Section 17.4: Instant</p>
<p>Represents an instant in time. Can be thought of as a wrapper around
a Unix timestamp.</p>
<p>Instant now = Instant.now();</p>
<p>Instant epoch1 = Instant.ofEpochMilli(0);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 82</p>
<p><span id="Instant_epoch2___Instant_parse"
class="anchor"></span>Instant epoch2 =
Instant.parse("1970-01-01T00:00:00Z");
java.time.temporal.ChronoUnit.MICROS.between(epoch1, epoch2); <em>//
0</em></p>
<p>Section 17.5: Usage of various classes of Date Time API</p>
<p>Following example also have explanation required for understanding
example within it.</p>
<p><strong>import</strong> java.time.Clock;</p>
<p><strong>import</strong> java.time.Duration;</p>
<p><strong>import</strong> java.time.Instant;</p>
<p><strong>import</strong> java.time.LocalDate;</p>
<p><strong>import</strong> java.time.LocalDateTime;</p>
<p><strong>import</strong> java.time.LocalTime;</p>
<p><strong>import</strong> java.time.ZoneId;</p>
<p><strong>import</strong> java.time.ZonedDateTime;</p>
<p><strong>import</strong> java.util.TimeZone;</p>
<p><strong>public class</strong> SomeMethodsExamples {</p>
<p>/**</p>
<p>* Has the methods of the class {@link LocalDateTime} */</p>
<p><strong>public static void</strong> checkLocalDateTime() {</p>
<p>LocalDateTime localDateTime = LocalDateTime.now();</p>
<p>System.out.println("Local Date time using static now() method :::
&gt;&gt;&gt; "</p>
<p>+ localDateTime);</p>
<p>LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(ZoneId.SHORT_IDS</p>
<p>.get("AET")));</p>
<p>System.out</p>
<p>.println("LOCAL TIME USING now(ZoneId zoneId) method :::
&gt;&gt;&gt;&gt;"</p>
<p>+ ldt1);</p>
<p>LocalDateTime ldt2 = LocalDateTime.now(Clock.system(ZoneId</p>
<p>.of(ZoneId.SHORT_IDS.get("PST"))));</p>
<p>System.out</p>
<p>.println("Local TIME USING now(Clock.system(ZoneId.of())) :::
&gt;&gt;&gt;&gt; "</p>
<p>+ ldt2);</p>
<p>System.out</p>
<p>.println("Following is a static map in ZoneId class which has mapping
of short timezone names to their Actual timezone names");</p>
<p>System.out.println(ZoneId.SHORT_IDS);</p>
<p>}</p>
<p>/**</p>
<p>* This has the methods of the class {@link LocalDate} */</p>
<p><strong>public static void</strong> checkLocalDate() {</p>
<p>LocalDate localDate = LocalDate.now();</p>
<p>System.out.println("Gives date without Time using now() method.
&gt;&gt; "</p>
<p>+ localDate);</p>
<p>LocalDate localDate2 = LocalDate.now(ZoneId.of(ZoneId.SHORT_IDS</p>
<p>.get("ECT")));</p>
<p>System.out</p>
<p>.println("now() is overridden to take ZoneID as parametere using this
we can get the same date under different timezones. &gt;&gt; "</p>
<p>+ localDate2);</p>
<p>}</p>
<p>/**</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 83</p>
<p> * This has the methods of abstract class {@link Clock}. Clock can be
used * for time which has time with {@link TimeZone}.</p>
<p>*/</p>
<p>public static void <strong>checkClock() {</strong></p>
<p>Clock clock = Clock.systemUTC();</p>
<p>// Represents time according to ISO 8601</p>
<p>System.out.println("Time using Clock class : " +
clock.instant());</p>
<p>}</p>
<p>/**</p>
<p>* This has the {@link Instant} class methods.</p>
<p>*/</p>
<p>public static void <strong>checkInstant() {</strong></p>
<p>Instant instant = Instant.now();</p>
<p>System.out.println("Instant using now() method :: " + instant);</p>
<p>Instant ins1 = Instant.now(Clock.systemUTC());</p>
<p>System.out.println("Instants using now(Clock clock) :: " + ins1);</p>
<p>}</p>
<p>/**</p>
<p>* This class checks the methods of the {@link Duration} class. */</p>
<p>public static void <strong>checkDuration() {</strong></p>
<p>// toString() converts the duration to PTnHnMnS format according to
ISO // 8601 standard. If a field is zero its ignored.</p>
<p>// P is the duration designator (historically called "period") placed
at // the start of the duration representation.</p>
<p>// Y is the year designator that follows the value for the number of
// years.</p>
<p>// M is the month designator that follows the value for the number of
// months.</p>
<p>// W is the week designator that follows the value for the number of
// weeks.</p>
<p>// D is the day designator that follows the value for the number of
// days.</p>
<p>// T is the time designator that precedes the time components of the
// representation.</p>
<p>// H is the hour designator that follows the value for the number of
// hours.</p>
<p>// M is the minute designator that follows the value for the number
of // minutes.</p>
<p>// S is the second designator that follows the value for the number
of // seconds.</p>
<p>System.out.println(Duration.ofDays(2));</p>
<p>}</p>
<p>/**</p>
<p>* Shows Local time without date. It doesn't store or represenet a
date and * time. Instead its a representation of Time like clock on the
wall. */</p>
<p><strong>public static void</strong> checkLocalTime() {</p>
<p>LocalTime localTime = LocalTime.now();</p>
<p>System.out.println("LocalTime :: " + localTime);</p>
<p>}</p>
<p>/**</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 84</p>
<p><span id="__A_date_time_with_Time_zone_det" class="anchor"></span> *
A date time with Time zone details in ISO-8601 standards. */</p>
<p><strong>public static void</strong> checkZonedDateTime() {</p>
<p>ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId</p>
<p>.of(ZoneId.SHORT_IDS.get("CST")));</p>
<p>System.out.println(zonedDateTime);</p>
<p>}</p>
<p>}</p>
<p>Section 17.6: Date Time Formatting</p>
<p>Before Java 8, there was DateFormat and SimpleDateFormat classes in
the package java.text and this legacy code will be continued to be used
for sometime.</p>
<p>But, Java 8 offers a modern approach to handling Formatting and
Parsing.</p>
<p>In formatting and parsing first you pass a String object to
DateTimeFormatter, and in turn use it for formatting or parsing.</p>
<p><strong>import</strong> java.time.*;</p>
<p><strong>import</strong> java.time.format.*;</p>
<p><strong>class</strong> DateTimeFormat</p>
<p>{</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>//Parsing</p>
<p>String pattern = "d-MM-yyyy HH:mm";</p>
<p>DateTimeFormatter dtF1 = DateTimeFormatter.ofPattern(pattern);</p>
<p>LocalDateTime ldp1 = LocalDateTime.parse("2014-03-25T01:30"),
<em>//Default format</em></p>
<p>ldp2 = LocalDateTime.parse("15-05-2016 13:55",dtF1); <em>//Custom
format</em></p>
<p>System.out.println(ldp1 + "<strong>\n</strong>" + ldp2); <em>//Will
be printed in Default format</em></p>
<p>//Formatting</p>
<p>DateTimeFormatter dtF2 = DateTimeFormatter.ofPattern("EEE d, MMMM,
yyyy HH:mm");</p>
<p>DateTimeFormatter dtF3 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</p>
<p>LocalDateTime ldtf1 = LocalDateTime.now();</p>
<p>System.out.println(ldtf1.format(dtF2)
+"<strong>\n</strong>"+ldtf1.format(dtF3));</p>
<p>}</p>
<p>}</p>
<p>An important notice, instead of using Custom patterns, it is good
practice to use predefined formatters. Your code look more clear and
usage of ISO8061 will definitely help you in the long run.</p>
<p>Section 17.7: Simple Date Manipulations</p>
<p>Get the current date.</p>
<p>LocalDate.now()</p>
<p>Get yesterday's date.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 85</p>
<p>LocalDate y = LocalDate.now().minusDays(1);</p>
<p>Get tomorrow's date</p>
<p>LocalDate t = LocalDate.now().plusDays(1);</p>
<p>Get a specific date.</p>
<p>LocalDate t = LocalDate.of(1974, 6, 2, 8, 30, 0, 0);</p>
<p>In addition to the plus and minus methods, there are a set of "with"
methods that can be used to set a particular</p>
<p>field on a LocalDate instance.</p>
<p>LocalDate.now().withMonth(6);</p>
<p>The example above returns a new instance with the month set to June
(this differs from java.util.Date where setMonth was indexed a 0 making
June 5).</p>
<p>Because LocalDate manipulations return immutable LocalDate instances,
these methods may also be chained together.</p>
<p>LocalDate ld = LocalDate.now().plusDays(1).plusYears(1);</p>
<p>This would give us tomorrow's date one year from now.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 86</p>
<p><span id="Chapter_18__LocalTime_1" class="anchor"></span>Chapter 18:
LocalTime</p>
<p>Method Output</p>
<p>LocalTime.of(13, 12, 11) 13:12:11</p>
<p>LocalTime.MIDNIGHT 00:00</p>
<p>LocalTime.NOON 12:00</p>
<p>LocalTime.now() Current time from system clock</p>
<p>LocalTime.MAX The maximum supported local time 23:59:59.999999999</p>
<p>LocalTime.MIN The minimum supported local time 00:00</p>
<p>LocalTime.ofSecondOfDay(84399) 23:59:59 , Obtains Time from
second-of-day value</p>
<p>LocalTime.ofNanoOfDay(2000000000) 00:00:02 , Obtains Time from
nanos-of-day value</p>
<p>Section 18.1: Amount of time between two LocalTime</p>
<p>There are two equivalent ways to calculate the amount of time unit
between two LocalTime: (1) through until(Temporal, TemporalUnit) method
and through (2) TemporalUnit.between(Temporal, Temporal).</p>
<p><strong>import</strong> java.time.LocalTime;</p>
<p><strong>import</strong> java.time.temporal.ChronoUnit;</p>
<p><strong>public class</strong> AmountOfTime {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>LocalTime start = LocalTime.of(1, 0, 0); <em>// hour, minute,
second</em></p>
<p>LocalTime end = LocalTime.of(2, 10, 20); <em>// hour, minute,
second</em></p>
<p><strong>long</strong> halfDays1 = start.until(end,
ChronoUnit.HALF_DAYS); <em>// 0</em> <strong>long</strong> halfDays2 =
ChronoUnit.HALF_DAYS.between(start, end); <em>// 0</em></p>
<p><strong>long</strong> hours1 = start.until(end, ChronoUnit.HOURS);
<em>// 1</em> <strong>long</strong> hours2 =
ChronoUnit.HOURS.between(start, end); <em>// 1</em></p>
<p><strong>long</strong> minutes1 = start.until(end,
ChronoUnit.MINUTES); <em>// 70</em> <strong>long</strong> minutes2 =
ChronoUnit.MINUTES.between(start, end); <em>// 70</em></p>
<p><strong>long</strong> seconds1 = start.until(end,
ChronoUnit.SECONDS); <em>// 4220</em> <strong>long</strong> seconds2 =
ChronoUnit.SECONDS.between(start, end); <em>// 4220</em></p>
<p><strong>long</strong> millisecs1 = start.until(end,
ChronoUnit.MILLIS); <em>// 4220000</em> <strong>long</strong> millisecs2
= ChronoUnit.MILLIS.between(start, end); <em>// 4220000</em></p>
<p><strong>long</strong> microsecs1 = start.until(end,
ChronoUnit.MICROS); <em>// 4220000000</em> <strong>long</strong>
microsecs2 = ChronoUnit.MICROS.between(start, end); <em>//
4220000000</em></p>
<p><strong>long</strong> nanosecs1 = start.until(end, ChronoUnit.NANOS);
<em>// 4220000000000</em> <strong>long</strong> nanosecs2 =
ChronoUnit.NANOS.between(start, end); <em>// 4220000000000</em></p>
<p>// Using others ChronoUnit will be thrown
UnsupportedTemporalTypeException. // The following methods are examples
thereof.</p>
<p><strong>long</strong> days1 = start.until(end, ChronoUnit.DAYS);</p>
<p><strong>long</strong> days2 = ChronoUnit.DAYS.between(start,
end);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 87</p>
<p><span id="Section_18_2__Intro" class="anchor"></span>Section 18.2:
Intro</p>
<p>LocalTime is an immutable class and thread-safe, used to represent
time, often viewed as hour-min-sec. Time is</p>
<p>represented to nanosecond precision. For example, the value
"13:45.30.123456789" can be stored in a LocalTime.</p>
<p>This class does not store or represent a date or time-zone. Instead,
it is a description of the local time as seen on a</p>
<p>wall clock. It cannot represent an instant on the time-line without
additional information such as an offset or time-zone. This is a value
based class, equals method should be used for comparisons.</p>
<p>Fields</p>
<p>MAX - The maximum supported LocalTime, '23:59:59.999999999'.
MIDNIGHT, MIN, NOON</p>
<p>Important Static Methods</p>
<p>now(), now(Clock clock), now(ZoneId zone), parse(CharSequence
text)</p>
<p>Important Instance Methods</p>
<p>isAfter(LocalTime other), isBefore(LocalTime other),
minus(TemporalAmount amountToSubtract), minus(long amountToSubtract,
TemporalUnit unit), plus(TemporalAmount amountToAdd), plus(long
amountToAdd,</p>
<p>TemporalUnit unit)</p>
<p>ZoneId zone = ZoneId.of("Asia/Kolkata");</p>
<p>LocalTime now = LocalTime.now();</p>
<p>LocalTime now1 = LocalTime.now(zone);</p>
<p>LocalTime then = LocalTime.parse("04:16:40");</p>
<p>Difference in time can be calculated in any of following ways</p>
<p><strong>long</strong> timeDiff = Duration.between(now,
now1).toMinutes(); <strong>long</strong> timeDiff1 =
java.time.temporal.ChronoUnit.MINUTES.between(now2, now1);</p>
<p>You can also add/subtract hours, minutes or seconds from any object
of LocalTime.</p>
<p>minusHours(long hoursToSubtract), minusMinutes(long hoursToMinutes),
minusNanos(long nanosToSubtract), minusSeconds(long secondsToSubtract),
plusHours(long hoursToSubtract), plusMinutes(long hoursToMinutes),</p>
<p>plusNanos(long nanosToSubtract), plusSeconds(long
secondsToSubtract)</p>
<p>now.plusHours(1L);</p>
<p>now1.minusMinutes(20L);</p>
<p>Section 18.3: Time Modification</p>
<p>You can add hours, minutes, seconds and nanoseconds:</p>
<p>LocalTime time = LocalTime.now();</p>
<p>LocalTime addHours = time.plusHours(5); <em>// Add 5 hours</em>
LocaLTime addMinutes = time.plusMinutes(15) <em>// Add 15 minutes</em>
LocalTime addSeconds = time.plusSeconds(30) <em>// Add 30 seconds</em>
LocalTime addNanoseconds = time.plusNanos(150_000_000) <em>// Add
150.000.000ns (150ms)</em></p>
<p>Section 18.4: Time Zones and their time dierence</p>
<p><strong>import</strong> java.time.LocalTime;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 88</p>
<p><strong>import</strong> java.time.ZoneId;</p>
<p><strong>import</strong> java.time.temporal.ChronoUnit;</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>{</p>
<p>ZoneId zone1 = ZoneId.of("Europe/Berlin");</p>
<p>ZoneId zone2 = ZoneId.of("Brazil/East");</p>
<p>LocalTime now = LocalTime.now();</p>
<p>LocalTime now1 = LocalTime.now(zone1);</p>
<p>LocalTime now2 = LocalTime.now(zone2);</p>
<p>System.out.println("Current Time : " + now);</p>
<p>System.out.println("Berlin Time : " + now1);</p>
<p>System.out.println("Brazil Time : " + now2);</p>
<p><strong>long</strong> minutesBetween =
ChronoUnit.MINUTES.between(now2, now1); System.out.println("Minutes
Between Berlin and Brazil : " + minutesBetween +"mins");</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 89</p>
<p><span id="Chapter_19__BigDecimal_1" class="anchor"></span>Chapter 19:
BigDecimal</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">The
BigDecimal</a> class provides operations for arithmetic (add, subtract,
multiply, divide), scale manipulation,</p>
<p>rounding, comparison, hashing, and format conversion. The BigDecimal
represents immutable, arbitrary-precision signed decimal numbers. This
class shall be used in a necessity of high-precision calculation.</p>
<p>Section 19.1: Comparing BigDecimals</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#compareTo-java.math.BigDecimal-">The
method compareTo</a> should be used to compare BigDecimals:</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal(5);</p>
<p>a.compareTo(<strong>new</strong> BigDecimal(0)); <em>// a is greater,
returns 1</em> a.compareTo(<strong>new</strong> BigDecimal(5)); <em>// a
is equal, returns 0</em> a.compareTo(<strong>new</strong>
BigDecimal(10)); <em>// a is less, returns -1</em></p>
<p>Commonly you should <strong>not</strong> use the <a
href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#equals-java.lang.Object-">equals</a>
method since it considers two BigDecimals equal only if they are
equal</p>
<p>in value and also <strong>scale</strong>:</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal(5);</p>
<p><em>a.equals(<strong>new</strong> BigDecimal(5));</em> // value and
scale are equal, returns true <em>a.equals(<strong>new</strong>
BigDecimal(5.00));</em> // value is equal but scale is not, returns
false</p>
<p>Section 19.2: Using BigDecimal instead of float</p>
<p>Due to way that the float type is represented in computer memory,
results of operations using this type can be inaccurate - some values
are stored as approximations. Good examples of this are monetary
calculations. If high</p>
<p>precision is necessary, other types should be used. e.g. Java 7
provides BigDecimal.</p>
<p><strong>import</strong> java.math.BigDecimal;</p>
<p>public class <strong>FloatTest {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>float</strong> accountBalance = 10000.00f;</p>
<p>System.out.println("Operations using float:");</p>
<p>System.out.println("1000 operations for 1.99");</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i&lt;1000; i++){</p>
<p>accountBalance -= 1.99f;</p>
<p>}</p>
<p>System.out.println(String.format("Account balance after float
operations: %f",</p>
<p>accountBalance));</p>
<p>BigDecimal accountBalanceTwo = <strong>new</strong>
BigDecimal("10000.00"); System.out.println("Operations using
BigDecimal:"); System.out.println("1000 operations for 1.99");</p>
<p>BigDecimal operation = <strong>new</strong> BigDecimal("1.99");</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i&lt;1000; i++){</p>
<p>accountBalanceTwo = accountBalanceTwo.subtract(operation);</p>
<p>}</p>
<p>System.out.println(String.format("Account balance after BigDecimal
operations: %f",</p>
<p>accountBalanceTwo));</p>
<p>}</p>
<p>Output of this program is:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 90</p>
<p><span id="Operations_using_float" class="anchor"></span>Operations
using float:</p>
<p>1000 operations for 1.99</p>
<p>Account balance after float operations: 8009,765625 Operations using
BigDecimal:</p>
<p>1000 operations for 1.99</p>
<p>Account balance after BigDecimal operations: 8010,000000</p>
<p>For a starting balance of 10000.00, after 1000 operations for 1.99,
we expect the balance to be 8010.00. Using the</p>
<p>float type gives us an answer around 8009.77, which is unacceptably
imprecise in the case of monetary calculations. Using BigDecimal gives
us the proper result.</p>
<p>Section 19.3: BigDecimal.valueOf()</p>
<p>The BigDecimal class contains an internal cache of frequently used
numbers e.g. 0 to 10. The BigDecimal.valueOf()</p>
<p>methods are provided in preference to constructors with similar type
parameters i.e. in the below example a is</p>
<p>preferred to b.</p>
<p>BigDecimal a = BigDecimal.valueOf(10L); <em>//Returns cached Object
reference</em> BigDecimal b = <strong>new</strong> BigDecimal(10L);
<em>//Does not return cached Object reference</em></p>
<p><em>BigDecimal a = BigDecimal.valueOf(20L);</em> //Does not return
cached Object reference <em>BigDecimal b = <strong>new</strong>
BigDecimal(20L);</em> //Does not return cached Object reference</p>
<p><em>BigDecimal a = BigDecimal.valueOf(15.15);</em> //Preferred way to
convert a double (or float) into a BigDecimal, as the value returned is
equal to that resulting from constructing a BigDecimal from the result
of using Double.toString(double)</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal(15.15); <em>//Return
unpredictable result</em></p>
<p>Section 19.4: Mathematical operations with BigDecimal</p>
<p>This example shows how to perform basic mathematical operations using
BigDecimals.</p>
<p>1.Addition</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>//Equivalent to result = a + b</p>
<p>BigDecimal result = a.add(b);</p>
<p>System.out.println(result);</p>
<p>Result : 12</p>
<p>2.Subtraction</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>//Equivalent to result = a - b</p>
<p>BigDecimal result = a.subtract(b);</p>
<p>System.out.println(result);</p>
<p>Result : -2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 91</p>
<p>3.Multiplication</p>
<p>When multiplying two BigDecimals the result is going to have scale
equal to the sum of the scales of operands.</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5.11");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7.221");</p>
<p>//Equivalent to result = a * b</p>
<p>BigDecimal result = a.multiply(b);</p>
<p>System.out.println(result);</p>
<p>Result : 36.89931</p>
<p>To change the scale of the result use the overloaded multiply method
which allows passing MathContext - an object</p>
<p>describing the rules for operators, in particular the precision and
rounding mode of the result. For more information about available
rounding modes please refer to the Oracle Documentation.</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5.11");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7.221");</p>
<p>MathContext returnRules = <strong>new</strong> MathContext(4,
RoundingMode.HALF_DOWN);</p>
<p>//Equivalent to result = a * b</p>
<p>BigDecimal result = a.multiply(b, returnRules);</p>
<p>System.out.println(result);</p>
<p>Result : 36.90</p>
<p>4.Division</p>
<p>Division is a bit more complicated than the other arithmetic
operations, for instance consider the below example:</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>BigDecimal result = a.divide(b);</p>
<p>System.out.println(result);</p>
<p>We would expect this to give something similar to :
0.7142857142857143, but we would get:</p>
<p><strong>Result:</strong> java.lang.ArithmeticException:
Non-terminating decimal expansion; no exact representable</p>
<p>decimal result.</p>
<p>This would work perfectly well when the result would be a terminating
decimal say if I wanted to divide 5 by 2, but for those numbers which
upon dividing would give a non terminating result we would get an
ArithmeticException.</p>
<p>In the real world scenario, one cannot predict the values that would
be encountered during the division, so we need</p>
<p>to specify the <strong>Scale</strong> and the <strong>Rounding
Mode</strong> for BigDecimal division. For more information on the Scale
and</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html">Rounding
Mode, refer the Oracle Documentation.</a></p>
<p>For example, I could do:</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 92</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p><em>//Equivalent to result = a / b (Upto 10 Decimal places and Round
HALF_UP)</em> BigDecimal result = a.divide(b,10,RoundingMode.HALF_UP);
System.out.println(result);</p>
<p>Result : 0.7142857143</p>
<p>5.Remainder or Modulus</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>//Equivalent to result = a % b</p>
<p>BigDecimal result = a.remainder(b);</p>
<p>System.out.println(result);</p>
<p>Result : 5</p>
<p>6.Power</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>//Equivalent to result = a^10</p>
<p>BigDecimal result = a.pow(10);</p>
<p>System.out.println(result);</p>
<p>Result : 9765625</p>
<p>7.Max</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>//Equivalent to result = MAX(a,b)</p>
<p>BigDecimal result = a.max(b);</p>
<p>System.out.println(result);</p>
<p>Result : 7</p>
<p>8.Min</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("7");</p>
<p>//Equivalent to result = MIN(a,b)</p>
<p>BigDecimal result = a.min(b);</p>
<p>System.out.println(result);</p>
<p>Result : 5</p>
<p>9.Move Point To Left</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 93</p>
<p><span id="BigDecimal_a___new_BigDecimal__5"
class="anchor"></span>BigDecimal a = <strong>new</strong>
BigDecimal("5234.49843776");</p>
<p>//Moves the decimal point to 2 places left of current position
<em>BigDecimal result = a.movePointLeft(2);</em></p>
<p>System.out.println(result);</p>
<p>Result : 52.3449843776</p>
<p>10.Move Point To Right</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("5234.49843776");</p>
<p>//Moves the decimal point to 3 places right of current position
<em>BigDecimal result = a.movePointRight(3);</em></p>
<p>System.out.println(result);</p>
<p>Result : 5234498.43776</p>
<p>There are many more options and combination of parameters for the
above mentioned examples (For instance, there are 6 variations of the
divide method), this set is a non-exhaustive list and covers a few basic
examples.</p>
<p>Section 19.5: Initialization of BigDecimals with value zero, one</p>
<p>or ten</p>
<p>BigDecimal provides static properties for the numbers zero, one and
ten. It's good practise to use these instead of</p>
<p>using the actual numbers:</p>
<p><a
href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#ZERO">BigDecimal.ZERO</a></p>
<p><a
href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#ONE">BigDecimal.ONE</a></p>
<p><a
href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#TEN">BigDecimal.TEN</a></p>
<p>By using the static properties, you avoid an unnecessary
instantiation, also you've got a literal in your code instead</p>
<p>of a 'magic number'.</p>
<p>//Bad example:</p>
<p>BigDecimal bad0 = <strong>new</strong> BigDecimal(0);</p>
<p>BigDecimal bad1 = <strong>new</strong> BigDecimal(1);</p>
<p>BigDecimal bad10 = <strong>new</strong> BigDecimal(10);</p>
<p>//Good Example:</p>
<p>BigDecimal good0 = BigDecimal.ZERO;</p>
<p>BigDecimal good1 = BigDecimal.ONE;</p>
<p>BigDecimal good10 = BigDecimal.TEN;</p>
<p>Section 19.6: BigDecimal objects are immutable</p>
<p>If you want to calculate with BigDecimal you have to use the returned
value because BigDecimal objects are immutable:</p>
<p>BigDecimal a = <strong>new</strong> BigDecimal("42.23");</p>
<p>BigDecimal b = <strong>new</strong> BigDecimal("10.001");</p>
<p><em>a.add(b);</em> // a will still be 42.23</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 94</p>
<p>BigDecimal c = a.add(b); <em>// c will be 52.231</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 95</p>
<p><span id="Chapter_20__BigInteger_1" class="anchor"></span>Chapter 20:
BigInteger</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">The
BigInteger</a> class is used for mathematical operations involving large
integers with magnitudes too large for</p>
<p>primitive data types. For example 100-factorial is 158 digits - much
larger than a <strong>long</strong> can represent. BigInteger provides
analogues to all of Java's primitive integer operators, and all relevant
methods from java.lang.Math as</p>
<p>well as few other operations.</p>
<p>Section 20.1: Initialization</p>
<p>The java.math.BigInteger class provides operations analogues to all
of Java's primitive integer operators and for</p>
<p>all relevant methods from java.lang.Math. As the java.math package is
not automatically made available you may have to import
java.math.BigInteger before you can use the simple class name.</p>
<p>To convert <strong>long</strong> or <strong>int</strong> values to
BigInteger use:</p>
<p><strong>long</strong> longValue = Long.MAX_VALUE;</p>
<p>BigInteger valueFromLong = BigInteger.valueOf(longValue);</p>
<p>or, for integers:</p>
<p><strong>int</strong> intValue = Integer.MIN_VALUE; <em>//
negative</em></p>
<p>BigInteger valueFromInt = BigInteger.valueOf(intValue);</p>
<p>which will <em>widen</em> the intValue integer to long, using sign
bit extension for negative values, so that negative values</p>
<p>will stay negative.</p>
<p>To convert a numeric String to BigInteger use:</p>
<p>String decimalString = "-1";</p>
<p>BigInteger valueFromDecimalString = <strong>new</strong>
BigInteger(decimalString);</p>
<p>Following constructor is used to translate the String representation
of a BigInteger in the specified radix into a BigInteger.</p>
<p>String binaryString = "10";</p>
<p><strong>int</strong> binaryRadix = 2;</p>
<p>BigInteger valueFromBinaryString = <strong>new</strong>
BigInteger(binaryString , binaryRadix);</p>
<p>Java also supports direct conversion of bytes to an instance of
BigInteger. Currently only signed and unsigned big endian encoding may
be used:</p>
<p><strong>byte</strong>[] bytes = <strong>new byte</strong>[] {
(<strong>byte</strong>) 0x80 };</p>
<p>BigInteger valueFromBytes = <strong>new</strong>
BigInteger(bytes);</p>
<p>This will generate a BigInteger instance with value -128 as the first
bit is interpreted as the sign bit.</p>
<p><strong>byte</strong>[] unsignedBytes = <strong>new byte</strong>[] {
(<strong>byte</strong>) 0x80 };</p>
<p><strong>int</strong> sign = 1; <em>// positive</em></p>
<p>BigInteger valueFromUnsignedBytes = <strong>new</strong>
BigInteger(sign, unsignedBytes);</p>
<p>This will generate a BigInteger instance with value 128 as the bytes
are interpreted as unsigned number, and the sign is explicitly set to 1,
a positive number.</p>
<p>There are predefined constants for common values:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 96</p>
<p><span id="BigInteger_ZERO____value_of__0"
class="anchor"></span>BigInteger.ZERO — value of "0".</p>
<p>BigInteger.ONE — value of "1".</p>
<p>BigInteger.TEN — value of "10".</p>
<p>There's also BigInteger.TWO (value of "2"), but you can't use it in
your code because it's <strong>private</strong>.</p>
<p>Section 20.2: BigInteger Mathematical Operations Examples</p>
<p>BigInteger is in an immutable object, so you need to assign the
results of any mathematical operation, to a new BigInteger instance.</p>
<p><em><strong>Addition:</strong></em> 10 + 10 = 20</p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger sum = value1.add(value2);</p>
<p>System.out.println(sum);</p>
<p>output: 20</p>
<p>Subtraction: <em><strong>10 - 9 = 1</strong></em></p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("9");</p>
<p>BigInteger sub = value1.subtract(value2);</p>
<p>System.out.println(sub);</p>
<p>output: 1</p>
<p><em><strong>Division:</strong></em> 10 / 5 = 2</p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("5");</p>
<p>BigInteger div = value1.divide(value2);</p>
<p>System.out.println(div);</p>
<p>output: 2</p>
<p>Division: <em><strong>17/4 = 4</strong></em></p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("17");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("4");</p>
<p>BigInteger div = value1.divide(value2);</p>
<p>System.out.println(div);</p>
<p>output: 4</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 97</p>
<p>Multiplication: <em><strong>10 * 5 = 50</strong></em></p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("5");</p>
<p>BigInteger mul = value1.multiply(value2);</p>
<p>System.out.println(mul);</p>
<p>output: 50</p>
<p><em><strong>Power:</strong></em> 10 ^ 3 = 1000</p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger power = value1.pow(3);</p>
<p>System.out.println(power);</p>
<p>output: 1000</p>
<p>Remainder: <em><strong>10 % 6 = 4</strong></em></p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("6");</p>
<p>BigInteger power = value1.remainder(value2);</p>
<p>System.out.println(power);</p>
<p>output: 4</p>
<p><strong>GCD:</strong> Greatest Common Divisor (GCD) for 12and 18 is
6.</p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("12");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("18");</p>
<p>System.out.println(value1.gcd(value2));</p>
<p>Output: 6</p>
<p><strong>Maximum</strong> of two BigIntegers:</p>
<p>BigInteger value1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("11");</p>
<p>System.out.println(value1.max(value2));</p>
<p>Output: 11</p>
<p><strong>Minimum</strong> of two BigIntegers:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 98</p>
<p><span id="BigInteger_value1___new_BigInteg"
class="anchor"></span>BigInteger value1 = <strong>new</strong>
BigInteger("10");</p>
<p>BigInteger value2 = <strong>new</strong> BigInteger("11");</p>
<p>System.out.println(value1.min(value2));</p>
<p>Output: 10</p>
<p>Section 20.3: Comparing BigIntegers</p>
<p>You can compare BigIntegers same as you compare String or other
objects in Java.</p>
<p>For example:</p>
<p>BigInteger one = BigInteger.valueOf(1);</p>
<p>BigInteger two = BigInteger.valueOf(2);</p>
<p><strong>if</strong>(one.equals(two)){</p>
<p>System.out.println("Equal");</p>
<p>}</p>
<p>else<strong>{</strong></p>
<p>System.out.println("Not Equal");</p>
<p>}</p>
<p>Output:</p>
<p>Not Equal</p>
<p>Note:</p>
<p>In general, do <strong>not</strong> use use the == operator to
compare BigIntegers</p>
<p>== operator: compares references; i.e. whether two values refer to
the same object equals() method: compares the content of two
BigIntegers.</p>
<p>For example, BigIntegers should <strong>not</strong> be compared in
the following way:</p>
<p><strong>if</strong> (firstBigInteger == secondBigInteger) {</p>
<p>// Only checks for reference equality, not content equality!</p>
<p>}</p>
<p>Doing so may lead to unexpected behavior, as the == operator only
checks for reference equality. If both</p>
<p>BigIntegers contain the same content, but do not refer to the same
object, <strong>this will fail.</strong> Instead, compare</p>
<p>BigIntegers using the equals methods, as explained above.</p>
<p>You can also compare your BigInteger to constant values like
0,1,10.</p>
<p>for example:</p>
<p>BigInteger reallyBig = BigInteger.valueOf(1);</p>
<p><strong>if</strong>(BigInteger.ONE.equals(reallyBig)){</p>
<p>//code when they are equal.</p>
<p>}</p>
<p>You can also compare two BigIntegers by using compareTo() method, as
following: compareTo() returns 3 values.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 99</p>
<p><span id="0__When_both_are_equal"
class="anchor"></span><strong>0:</strong> When both are
<strong>equal</strong>.</p>
<p><strong>1:</strong> When first is <strong>greater than</strong>
second (the one in brackets).</p>
<p><strong>-1:</strong> When first is <strong>less than</strong>
second.</p>
<p>BigInteger reallyBig = BigInteger.valueOf(10);</p>
<p>BigInteger reallyBig1 = BigInteger.valueOf(100);</p>
<p><strong>if</strong>(reallyBig.compareTo(reallyBig1) == 0){</p>
<p>//code when both are equal.</p>
<p>}</p>
<p><strong>else if</strong>(reallyBig.compareTo(reallyBig1) == 1){</p>
<p>//code when reallyBig is greater than reallyBig1.</p>
<p>}</p>
<p><strong>else if</strong>(reallyBig.compareTo(reallyBig1) ==-1){</p>
<p>//code when reallyBig is less than reallyBig1.</p>
<p>}</p>
<p>Section 20.4: Binary Logic Operations on BigInteger</p>
<p>BigInteger supports the binary logic operations that are available to
Number types as well. As with all operations they are implemented by
calling a method.</p>
<p>Binary Or:</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger val2 = <strong>new</strong> BigInteger("9");</p>
<p>val1.or(val2);</p>
<p>Output: 11 (which is equivalent to 10 | 9)</p>
<p>Binary And:</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger val2 = <strong>new</strong> BigInteger("9");</p>
<p>val1.and(val2);</p>
<p>Output: 8 (which is equivalent to 10 &amp; 9)</p>
<p>Binary Xor:</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger val2 = <strong>new</strong> BigInteger("9");</p>
<p>val1.xor(val2);</p>
<p>Output: 3 (which is equivalent to 10 ^ 9)</p>
<p>RightShift:</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 100</p>
<p><span id="val1_shiftRight_1________the_arg"
class="anchor"></span><em>val1.shiftRight(1);</em> // the argument be an
Integer</p>
<p>Output: 5 (equivalent to 10 &gt;&gt; 1)</p>
<p>LeftShift:</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p><em>val1.shiftLeft(1);</em> // here parameter should be Integer</p>
<p>Output: 20 (equivalent to 10 &lt;&lt; 1)</p>
<p>Binary Inversion (Not):</p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p>val1.not();</p>
<p>Output: 5</p>
<p>NAND (And-Not):<em>*</em></p>
<p>BigInteger val1 = <strong>new</strong> BigInteger("10");</p>
<p>BigInteger val2 = <strong>new</strong> BigInteger("9");</p>
<p>val1.andNot(val2);</p>
<p>Output: 7</p>
<p>Section 20.5: Generating random BigIntegers</p>
<p>The BigInteger class has a constructor dedicated to generate random
BigIntegers, given an instance of java.util.Random and an
<strong>int</strong> that specifies how many bits will the BigInteger
have. Its usage is quite simple -</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#BigInteger-int-java.util.Random-">when
you call the constructor BigInteger(<strong>int</strong>, Random)</a>
like this:</p>
<p>BigInteger randomBigInt = <strong>new</strong> BigInteger(bitCount,
sourceOfRandomness);</p>
<p>then you'll end up with a BigInteger whose value is between 0
(inclusive) and 2bitCount (exclusive).</p>
<p>This also means that <strong>new</strong> BigInteger(2147483647,
sourceOfRandomness) may return all positive BigIntegers</p>
<p>given enough time.</p>
<p>What will the sourceOfRandomness be is up to you. For example, a
<strong>new</strong> Random() is good enough in most cases:</p>
<p><strong>new</strong> BigInteger(32, <strong>new</strong>
Random());</p>
<p>If you're willing to give up speed for higher-quality random numbers,
you can use a <strong>new</strong>
="https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html"
rel="nofollow</p>
<p>noreferrer"&gt;SecureRandom() instead:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 101</p>
<p><strong>import</strong> java.security.SecureRandom;</p>
<p>// somewhere in the code...</p>
<p><strong>new</strong> BigInteger(32, <strong>new</strong>
SecureRandom());</p>
<p>You can even implement an algorithm on-the-fly with an anonymous
class! Note that <strong>rolling out your own RNG</strong></p>
<p><strong>algorithm <em>will</em> end you up with low quality
randomness</strong>, so always be sure to use an algorithm that is
proven to</p>
<p>be decent unless you want the resulting BigInteger(s) to be
predictable.</p>
<p><strong>new</strong> BigInteger(32, <strong>new</strong> Random()
{</p>
<p><strong>int</strong> seed = 0;</p>
<p>@Override</p>
<p>protected int <strong>next(</strong>int <strong>bits) {</strong></p>
<p>seed = ((22695477 * seed) + 1) &amp; 2147483647; <em>// Values
shamelessly stolen from</em></p>
<p>="https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use"
rel="nofollow noreferrer"&gt;Wikipedia return seed; } });</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 102</p>
<p><span id="Chapter_21__NumberFormat_1" class="anchor"></span>Chapter
21: NumberFormat</p>
<p>Section 21.1: NumberFormat</p>
<p>Different countries have different number formats and considering
this we can have different formats using Locale of java. Using locale
can help in formatting</p>
<p>Locale locale = <strong>new</strong> Locale("en", "IN");</p>
<p>NumberFormat numberFormat = NumberFormat.getInstance(locale);</p>
<p>using above format you can perform various tasks</p>
<p>1. Format Number</p>
<p>numberFormat.format(10000000.99);</p>
<p>2. Format Currency</p>
<p>NumberFormat currencyFormat =
NumberFormat.getCurrencyInstance(locale);
currencyFormat.format(10340.999);</p>
<p>3. Format Percentage</p>
<p>NumberFormat percentageFormat =
NumberFormat.getPercentInstance(locale);
percentageFormat.format(10929.999);</p>
<p>4. Control Number of Digits</p>
<p>numberFormat.setMinimumIntegerDigits(<strong>int</strong> digits)</p>
<p>numberFormat.setMaximumIntegerDigits(<strong>int</strong> digits)</p>
<p>numberFormat.setMinimumFractionDigits(<strong>int</strong>
digits)</p>
<p>numberFormat.setMaximumFractionDigits(<strong>int</strong>
digits)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 103</p>
<p><span id="Chapter_22__Bit_Manipulation_1"
class="anchor"></span>Chapter 22: Bit Manipulation</p>
<p>Section 22.1: Checking, setting, clearing, and toggling</p>
<p>individual bits. Using long as bit mask</p>
<p>Assuming we want to modify bit n of an integer primitive, i (byte,
short, char, int, or long):</p>
<p>(i &amp; 1 &lt;&lt; n) != 0 <em>// checks bit 'n'</em></p>
<p><em>i |= 1 &lt;&lt; n;</em> // sets bit 'n' to 1</p>
<p><em>i &amp;= ~(1 &lt;&lt; n);</em> // sets bit 'n' to 0</p>
<p><em>i ^= 1 &lt;&lt; n;</em> // toggles the value of bit 'n'</p>
<p>Using long/int/short/byte as a bit mask:</p>
<p><strong>public class</strong> BitMaskExample {</p>
<p>private static final long <strong>FIRST_BIT = 1L &lt;&lt;
0;</strong></p>
<p>private static final long <strong>SECOND_BIT = 1L &lt;&lt;
1;</strong></p>
<p>private static final long <strong>THIRD_BIT = 1L &lt;&lt;
2;</strong></p>
<p>private static final long <strong>FOURTH_BIT = 1L &lt;&lt;
3;</strong></p>
<p>private static final long <strong>FIFTH_BIT = 1L &lt;&lt;
4;</strong></p>
<p>private static final long <strong>BIT_55 = 1L &lt;&lt;
54;</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>checkBitMask(FIRST_BIT | THIRD_BIT | FIFTH_BIT | BIT_55);</p>
<p>}</p>
<p><strong>private static void</strong>
checkBitMask(<strong>long</strong> bitmask) {</p>
<p>System.out.println("FIRST_BIT: " + ((bitmask &amp; FIRST_BIT) != 0));
System.out.println("SECOND_BIT: " + ((bitmask &amp; SECOND_BIT) != 0));
System.out.println("THIRD_BIT: " + ((bitmask &amp; THIRD_BIT) != 0));
System.out.println("FOURTh_BIT: " + ((bitmask &amp; FOURTH_BIT) != 0));
System.out.println("FIFTH_BIT: " + ((bitmask &amp; FIFTH_BIT) != 0));
System.out.println("BIT_55: " + ((bitmask &amp; BIT_55) != 0));</p>
<p>}</p>
<p>}</p>
<p>Prints</p>
<p>FIRST_BIT: <strong>true</strong></p>
<p>SECOND_BIT: <strong>false</strong></p>
<p>THIRD_BIT: <strong>true</strong></p>
<p>FOURTh_BIT: <strong>false</strong></p>
<p>FIFTH_BIT: <strong>true</strong></p>
<p>BIT_55: <strong>true</strong></p>
<p>which matches that mask we passed as checkBitMask parameter:
FIRST_BIT | THIRD_BIT | FIFTH_BIT | BIT_55.</p>
<p>Section 22.2: java.util.BitSet class</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html">Since
1.7 there's a java.util.BitSet</a> class that provides simple and
user-friendly bit storage and manipulation</p>
<p>interface:</p>
<p><em><strong>final</strong> BitSet bitSet = <strong>new</strong>
BitSet(8);</em> // by default all bits are unset</p>
<p>IntStream.range(0, 8).filter(i -&gt; i % 2 ==
0).<strong>forEach</strong>(bitSet::set); <em>// {0, 2, 4, 6}</em></p>
<p><em>bitSet.set(3);</em> // {0, 2, 3, 4, 6}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 104</p>
<p><span id="bitSet_set_3__false_______0__2"
class="anchor"></span>bitSet.set(3, <strong>false</strong>); <em>// {0,
2, 4, 6}</em></p>
<p><strong>final boolean</strong> b = bitSet.get(3); <em>// b =
false</em></p>
<p>bitSet.flip(6); <em>// {0, 2, 4}</em></p>
<p><em>bitSet.set(100);</em> // {0, 2, 4, 100} - expands
automatically</p>
<p>BitSet implements Clonable and Serializable, and under the hood all
bit values are stored in <strong>long</strong>[] words field, that
expands automatically.</p>
<p>It also supports whole-set logical operations and, or, xor,
andNot:</p>
<p>bitSet.and(<strong>new</strong> BitSet(8));</p>
<p>bitSet.or(<strong>new</strong> BitSet(8));</p>
<p>bitSet.xor(<strong>new</strong> BitSet(8));</p>
<p>bitSet.andNot(<strong>new</strong> BitSet(8));</p>
<p>Section 22.3: Checking if a number is a power of 2</p>
<p>If an integer x is a power of 2, only one bit is set, whereas x-1 has
all bits set after that. For example: 4 is 100 and 3 is 011 as binary
number, which satisfies the aforementioned condition. Zero is not a
power of 2 and has to be</p>
<p>checked explicitly.</p>
<p><strong>boolean</strong> isPowerOfTwo(<strong>int</strong> x)</p>
<p>{</p>
<p><strong>return</strong> (x != 0) &amp;&amp; ((x &amp; (x -1)) ==
0);</p>
<p>}</p>
<p>Usage for Left and Right Shift</p>
<p>Let’s suppose, we have three kind of permissions,
<strong>READ</strong>, <strong>WRITE</strong> and
<strong>EXECUTE</strong>. Each permission can range from 0 to</p>
<p>7. (Let’s assume 4 bit number system)</p>
<p>RESOURCE = READ WRITE EXECUTE (12 bit number)</p>
<p>RESOURCE = 0100 0110 0101 = 4 6 5 (12 bit number)</p>
<p>How can we get the (12 bit number) permissions, set on above (12 bit
number)?</p>
<p>0100 0110 0101</p>
<p>0000 0000 0111 (&amp;)</p>
<p>0000 0000 0101 = 5</p>
<p>So, this is how we can get the <strong>EXECUTE</strong> permissions
of the <strong>RESOURCE</strong>. Now, what if we want to get
<strong>READ</strong></p>
<p>permissions of the <strong>RESOURCE</strong>?</p>
<p>0100 0110 0101</p>
<p>0111 0000 0000 (&amp;)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 105</p>
<p>0100 0000 0000 = 1024</p>
<p>Right? You are probably assuming this? But, permissions are resulted
in 1024. We want to get only READ</p>
<p>permissions for the resource. Don’t worry, that’s why we had the
shift operators. If we see, READ permissions are 8</p>
<p>bits behind the actual result, so if apply some shift operator, which
will bring READ permissions to the very right of the result? What if we
do:</p>
<p>0100 0000 0000 &gt;&gt; 8 =&gt; 0000 0000 0100 (Because it’s a
positive number so replaced with 0’s, if you don’t care about sign, just
use unsigned right shift operator)</p>
<p>We now actually have the <strong>READ</strong> permissions which is
4.</p>
<p>Now, for example, we are given <strong>READ</strong>,
<strong>WRITE</strong>, <strong>EXECUTE</strong> permissions for a
<strong>RESOURCE</strong>, what can we do to make</p>
<p>permissions for this <strong>RESOURCE</strong>?</p>
<p>Let’s first take the example of binary permissions. (Still assuming 4
bit number system)</p>
<p>READ = 0001</p>
<p>WRITE = 0100</p>
<p>EXECUTE = 0110</p>
<p>If you are thinking that we will simply do:</p>
<p>READ | WRITE | EXECUTE, you are somewhat right but not exactly. See,
what will happen if we will perform READ | WRITE | EXECUTE</p>
<p>0001 | 0100 | 0110 =&gt; 0111</p>
<p>But permissions are actually being represented (in our example) as
0001 0100 0110</p>
<p>So, in order to do this, we know that <strong>READ</strong> is placed
8 bits behind, <strong>WRITE</strong> is placed 4 bits behind and
<strong>PERMISSIONS</strong></p>
<p>is placed at the last. The number system being used for
<strong>RESOURCE</strong> permissions is actually 12 bit (in our
example). It</p>
<p>can(will) be different in different systems.</p>
<p>(READ &lt;&lt; 8) | (WRITE &lt;&lt; 4) | (EXECUTE)</p>
<p>0000 0000 0001 &lt;&lt; 8 (READ)</p>
<p>0001 0000 0000 (Left shift by 8 bits)</p>
<p>0000 0000 0100 &lt;&lt; 4 (WRITE)</p>
<p>0000 0100 0000 (Left shift by 4 bits)</p>
<p>0000 0000 0001 (EXECUTE)</p>
<p>Now if we add the results of above shifting, it will be something
like;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 106</p>
<p><span id="0001_0000_0000__READ" class="anchor"></span>0001 0000 0000
(READ)</p>
<p>0000 0100 0000 (WRITE)</p>
<p>0000 0000 0001 (EXECUTE)</p>
<p>0001 0100 0001 (PERMISSIONS)</p>
<p>Section 22.4: Signed vs unsigned shift</p>
<p>In Java, all number primitives are signed. For example, an int always
represent values from [-2^31 - 1, 2^31], keeping</p>
<p>the first bit to sign the value - 1 for negative value, 0 for
positive.</p>
<p>Basic shift operators &gt;&gt; and &lt;&lt; are signed operators.
They will conserve the sign of the value.</p>
<p>But it is common for programmers to use numbers to store <em>unsigned
values</em>. For an int, it means shifting the range</p>
<p>to [0, 2^32 - 1], to have twice as much value as with a signed
int.</p>
<p>For those power users, the bit for sign as no meaning. That's why
Java added &gt;&gt;&gt;, a left-shift operator, disregarding</p>
<p>that sign bit.</p>
<p>initial value: 4 ( 100)</p>
<p>signed left-shift: 4 &lt;&lt; 1 8 ( 1000)</p>
<p>signed right-shift: 4 &gt;&gt; 1 2 ( 10)</p>
<p>unsigned right-shift: 4 &gt;&gt;&gt; 1 2 ( 10)</p>
<p>initial value: -4 ( 11111111111111111111111111111100)</p>
<p>signed left-shift:-4 &lt;&lt; 1 -8 (
11111111111111111111111111111000)</p>
<p>signed right-shift:-4 &gt;&gt; 1 -2 (
11111111111111111111111111111110) unsigned right-shift:-4 &gt;&gt;&gt; 1
2147483646 ( 1111111111111111111111111111110)</p>
<p>Why is there no &lt;&lt;&lt; ?</p>
<p>This comes from the intended definition of right-shift. As it fills
the emptied places on the left, there are no decision</p>
<p>to take regarding the bit of sign. As a consequence, there is no need
for 2 different operators.</p>
<p>See this <a
href="https://www.quora.com/Why-is-there-no-unsigned-left-shift-operator-in-Java">question</a>
for a more detailled answer.</p>
<p>Section 22.5: Expressing the power of 2</p>
<p>For expressing the power of 2 (2^n) of integers, one may use a
bitshift operation that allows to explicitly specify the</p>
<p>n.</p>
<p>The syntax is basically:</p>
<p><strong>int</strong> pow2 = 1&lt;</p>
<p>Examples:</p>
<p><strong>int</strong> twoExp4 = 1&lt;&lt;4; <em>//2^4</em></p>
<p><strong>int</strong> twoExp5 = 1&lt;&lt;5; <em>//2^5</em></p>
<p><strong>int</strong> twoExp6 = 1&lt;&lt;6; <em>//2^6</em></p>
<p>...</p>
<p><strong>int</strong> twoExp31 = 1&lt;&lt;31; <em>//2^31</em></p>
<p>This is especially useful when defining constant values that should
make it apparent, that a power of 2 is used,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 107</p>
<p><span id="instead_of_using_hexadecimal_or"
class="anchor"></span>instead of using hexadecimal or decimal
values.</p>
<p><strong>int</strong> twoExp4 = 0x10; <em>//hexadecimal</em></p>
<p><strong>int</strong> twoExp5 = 0x20; <em>//hexadecimal</em></p>
<p><strong>int</strong> twoExp6 = 64; <em>//decimal</em></p>
<p>...</p>
<p><strong>int</strong> twoExp31 =-2147483648; <em>//is that a power of
2?</em></p>
<p>A simple method to calculate the int power of 2 would be</p>
<p><strong>int</strong> pow2(<strong>int</strong> exp){</p>
<p>return <strong>1&lt;</strong></p>
<p>}</p>
<p>Section 22.6: Packing / unpacking values as bit fragments</p>
<p>It is common for memory performance to compress multiple values into
a single primitive value. This may be useful</p>
<p>to pass various information into a single variable.</p>
<p>For example, one can pack 3 bytes - such as color code in <a
href="https://en.wikipedia.org/wiki/RGB_color_model">RGB - into an
single int.</a></p>
<p>Packing the values</p>
<p>// Raw bytes as input</p>
<p><strong>byte</strong>[] b = {(<strong>byte</strong>)0x65,
(<strong>byte</strong>)0xFF, (<strong>byte</strong>)0x31};</p>
<p>// Packed in big endian: x == 0x65FF31</p>
<p><strong>int</strong> x = (b[0] &amp; 0xFF) &lt;&lt; 16 <em>//
Red</em></p>
<p>| (b[1] &amp; 0xFF) &lt;&lt; 8 <em>// Green</em></p>
<p>| (b[2] &amp; 0xFF) &lt;&lt; 0; <em>// Blue</em></p>
<p>// Packed in little endian: y == 0x31FF65</p>
<p><strong>int</strong> y = (b[0] &amp; 0xFF) &lt;&lt; 0</p>
<p>| (b[1] &amp; 0xFF) &lt;&lt; 8</p>
<p>| (b[2] &amp; 0xFF) &lt;&lt; 16;</p>
<p>Unpacking the values</p>
<p>// Raw int32 as input</p>
<p><strong>int</strong> x = 0x31FF65;</p>
<p>// Unpacked in big endian: {0x65, 0xFF, 0x31}</p>
<p><strong>byte</strong>[] c = {</p>
<p>(<strong>byte</strong>)(x &gt;&gt; 16),</p>
<p>(<strong>byte</strong>)(x &gt;&gt; 8),</p>
<p>(<strong>byte</strong>)(x &amp; 0xFF)</p>
<p>};</p>
<p>// Unpacked in little endian: {0x31, 0xFF, 0x65}</p>
<p><strong>byte</strong>[] d = {</p>
<p>(<strong>byte</strong>)(x &amp; 0xFF),</p>
<p>(<strong>byte</strong>)(x &gt;&gt; 8),</p>
<p>(<strong>byte</strong>)(x &gt;&gt; 16)</p>
<p>};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 108</p>
<p><span id="Chapter_23__Arrays_1" class="anchor"></span>Chapter 23:
Arrays</p>
<p>Parameter Details</p>
<p>ArrayType Type of the array. This can be primitive
(<strong>int</strong>, <strong>long</strong>, <strong>byte</strong>) or
Objects (String, MyObject, etc).</p>
<p>index Index refers to the position of a certain Object in an
array.</p>
<p>length Every array, when being created, needs a set length specified.
This is either done when creating an empty array ( <strong>new</strong>
<strong>int</strong> [ 3 ] ) or implied when specifying values ( { 1 , 2
, 3 } ).</p>
<p>Arrays allow for the storage and retrieval of an arbitrary quantity
of values. They are analogous to vectors in mathematics. Arrays of
arrays are analogous to matrices, and act as multidimensional arrays.
Arrays can store any</p>
<p>data of any type: primitives such as <strong>int</strong> or
reference types such as Object.</p>
<p>Section 23.1: Creating and Initializing Arrays</p>
<p>Basic cases</p>
<p><em><strong>int</strong>[] numbers1 = <strong>new
int</strong>[3];</em> // Array for 3 int values, default value is 0
<em><strong>int</strong>[] numbers2 = { 1, 2, 3 };</em> // Array literal
of 3 int values <em><strong>int</strong>[] numbers3 = <strong>new
int</strong>[] { 1, 2, 3 };</em> // Array of 3 int values initialized
<em><strong>int</strong>[][] numbers4 = { { 1, 2 }, { 3, 4, 5 } };</em>
// Jagged array literal <em><strong>int</strong>[][] numbers5 =
<strong>new int</strong>[5][];</em> // Jagged array, one dimension 5
long <em><strong>int</strong>[][] numbers6 = <strong>new
int</strong>[5][4];</em> // Multidimensional array: 5x4</p>
<p>Arrays may be created using any primitive or reference type.</p>
<p><strong>float</strong>[] boats = <strong>new float</strong>[5];
<em>// Array of five 32-bit floating point numbers.</em>
<strong>double</strong>[] header = <strong>new double</strong>[] { 4.56,
332.267, 7.0, 0.3367, 10.0 };</p>
<p>// Array of five 64-bit floating point numbers.</p>
<p>String[] theory = <strong>new</strong> String[] { "a", "b", "c"
};</p>
<p>// Array of three strings (reference type).</p>
<p>Object[] dArt = <strong>new</strong> Object[] { <strong>new</strong>
Object(), "We love Stack Overflow.", <strong>new</strong> Integer(3)
};</p>
<p>// Array of three Objects (reference type).</p>
<p>For the last example, note that subtypes of the declared array type
are allowed in the array.</p>
<p>Arrays for user defined types can also be built similar to primitive
types</p>
<p>UserDefinedClass[] udType = <strong>new</strong>
UserDefinedClass[5];</p>
<p>Arrays, Collections, and Streams</p>
<p>Version ≥ Java SE 1.2</p>
<p>// Parameters require objects, not primitives</p>
<p>// Auto-boxing happening for int 127 here</p>
<p>Integer[] initial = { 127, Integer.valueOf( 42 ) }; List toList =
Arrays.asList( initial ); <em>// Fixed size!</em></p>
<p>// Note: Works with all collections</p>
<p>Integer[] fromCollection = toList.toArray( <strong>new</strong>
Integer[toList.size()] );</p>
<p>//Java doesn't allow you to create an array of a parameterized type
<em>List[] list = <strong>new</strong> ArrayList[2];</em> // Compilation
error!</p>
<p>Version ≥ Java SE 8</p>
<p>// Streams - JDK 8+</p>
<p>Stream toStream = Arrays.stream( initial ); Integer[] fromStream =
toStream.toArray( Integer[]::<strong>new</strong> );</p>
<p>Intro</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 109</p>
<p>An <em>array</em> is a data structure that holds a fixed number of
primitive values <strong>or</strong> references to object instances.</p>
<p>Each item in an array is called an element, and each element is
accessed by its numerical index. The length of an</p>
<p>array is established when the array is created:</p>
<p><strong>int</strong> size = 42;</p>
<p><strong>int</strong>[] array = <strong>new int</strong>[size];</p>
<p><strong>The size of an array is fixed at runtime when
initialized.</strong> It cannot be changed after initialization. If the
size must</p>
<p>be mutable at runtime, a Collection class such as <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList
should be used instead.</a> ArrayList stores elements in</p>
<p>an array and supports resizing by allocating a new array and copying
elements from the old array.</p>
<p>If the array is of a primitive type, i.e.</p>
<p><strong>int</strong>[] array1 = { 1,2,3 };</p>
<p><strong>int</strong>[] array2 = <strong>new int</strong>[10];</p>
<p>the values are stored in the array itself. In the absence of an
initializer (as in array2 above), the default value</p>
<p>assigned to each element is 0 (zero).</p>
<p>If the array type is an object reference, as in</p>
<p>SomeClassOrInterface[] array = <strong>new</strong>
SomeClassOrInterface[10];</p>
<p>then the array contains <em>references</em> to objects of type
SomeClassOrInterface. Those references can refer to an</p>
<p><em>instance of SomeClassOrInterface</em> or any subclass (for
classes) or implementing class (for interfaces) of
SomeClassOrInterface<em>. If the array declaration has no initializer
then the default value of <strong>null</strong> is assigned to
each</em></p>
<p>element.</p>
<p>Because all arrays are <strong>int</strong>-indexed, the size of an
array must be specified by an <strong>int</strong>. The size of the
array cannot be</p>
<p>specified as a <strong>long</strong>:</p>
<p><strong>long</strong> size = 23L;</p>
<p><em><strong>int</strong>[] array = <strong>new
int</strong>[size];</em> // Compile-time error:</p>
<p>// incompatible types: possible lossy conversion from // long to
int</p>
<p>Arrays use a <strong>zero-based index</strong> system, which means
indexing starts at 0 and ends at length -1.</p>
<p>For example, the following image represents an array with size 10.
Here, the first element is at index 0 and the last</p>
<p>element is at index 9, instead of the first element being at index 1
and the last element at index 10 (see figure below).</p>
<p><img src="media/index-134_1.png"
style="width:3.76389in;height:1.38889in" alt="index-134_1.png" /></p>
<p>Accesses to elements of arrays are done in <strong>constant
time</strong>. That means accessing to the first element of the
array</p>
<p>has the same cost (in time) of accessing the second element, the
third element and so on.</p>
<p>Java offers several ways of defining and initializing arrays,
including <strong>literal</strong> and <strong>constructor</strong>
notations. When</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 110</p>
<p>declaring arrays using the <strong>new</strong> Type[length]
constructor, each element will be initialized with the following default
values:</p>
<p><strong>0 for</strong> <a
href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html"><strong>primitive
numerical types:</strong></a> byte<strong>,</strong>
short<strong>,</strong> int<strong>,</strong> long<strong>,</strong>
float<strong>, and</strong> double<strong>. '</strong>\u<strong>0000'
(null character) for the</strong> char <strong>type.</strong></p>
<p>false <strong>for the</strong> boolean <strong>type.</strong></p>
<p><strong>null</strong> for <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">reference
types.</a></p>
<p>Creating and initializing primitive type arrays</p>
<p><em><strong>int</strong>[] array1 = <strong>new int</strong>[] { 1,
2, 3 };</em> // Create an array with new operator and</p>
<p>// array initializer.</p>
<p><em><strong>int</strong>[] array2 = { 1, 2, 3 };</em> // Shortcut
syntax with array initializer. <em><strong>int</strong>[] array3 =
<strong>new int</strong>[3];</em> // Equivalent to { 0, 0, 0 }
<em><strong>int</strong>[] array4 = <strong>null</strong>;</em> // The
array itself is an object, so it</p>
<p>// can be set as null.</p>
<p>When declaring an array, [] will appear as part of the type at the
beginning of the declaration (after the type name), or as part of the
declarator for a particular variable (after variable name), or both:</p>
<p><strong>int</strong> array5[]; <em>/* equivalent to */</em>
<strong>int</strong>[] array5;</p>
<p><strong>int</strong> a, b[], c[][]; <em>/* equivalent to */</em>
<strong>int</strong> a; <strong>int</strong>[] b;
<strong>int</strong>[][] c; <strong>int</strong>[] a, b[]; <em>/*
equivalent to */</em> <strong>int</strong>[] a; <strong>int</strong>[][]
b;</p>
<p><em><strong>int</strong> a, []b, c[][];</em> /* Compilation Error,
because [] is not part of the type at beginning</p>
<p>of the declaration, rather it is before 'b'. */ // The same rules
apply when declaring a method that returns an array:
<em><strong>int</strong> foo()[] { ... }</em> /* equivalent to */
<em><strong>int</strong>[] foo() { ... }</em></p>
<p>In the following example, both declarations are correct and can
compile and run without any problems. However,</p>
<p>both the <a
href="http://www.oracle.com/technetwork/java/codeconvtoc-136057.html">Java
Coding Convention</a> and the <a
href="https://google.github.io/styleguide/javaguide.html#s4.8.3.1-array-initializers">Google
Java Style Guide discourage the form with brackets after the</a></p>
<p>variable name—<a
href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html">the
brackets identify the array type and should appear with the type
designation</a>. The same should</p>
<p>be used for method return signatures.</p>
<p><em><strong>float</strong> array[];</em> /* and */
<em><strong>int</strong> foo()[] { ... }</em> /* are discouraged */
<em><strong>float</strong>[] array;</em> /* and */
<em><strong>int</strong>[] foo() { ... }</em> /* are encouraged */</p>
<p><a
href="https://stackoverflow.com/questions/129178/difference-between-int-array-and-int-array/129188#129188">The
discouraged type is meant to accommodate transitioning C users</a>, who
are familiar with the syntax for C which</p>
<p>has the brackets after the variable name.</p>
<p>In Java, it is possible to have arrays of size 0:</p>
<p><em><strong>int</strong>[] array = <strong>new int</strong>[0];</em>
// Compiles and runs fine.</p>
<p><em><strong>int</strong>[] array2 = {};</em> // Equivalent
syntax.</p>
<p>However, since it's an empty array, no elements can be read from it
or assigned to it:</p>
<p><em>array[0] = 1;</em> // Throws
java.lang.ArrayIndexOutOfBoundsException. <em><strong>int</strong> i =
array2[0];</em> // Also throws ArrayIndexOutOfBoundsException.</p>
<p>Such empty arrays are typically useful as return values, so that the
calling code only has to worry about dealing with an array, rather than
a potential <strong>null</strong> value that may lead to a
NullPointerException.</p>
<p>The length of an array must be a non-negative integer:</p>
<p><em><strong>int</strong>[] array = <strong>new int</strong>[-1];</em>
// Throws java.lang.NegativeArraySizeException</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 111</p>
<p>The array size can be determined using a public final field called
length:</p>
<p>System.out.println(array.length); <em>// Prints 0 in this
case.</em></p>
<p><strong>Note</strong>: array.length returns the actual size of the
array and not the number of array elements which were assigned</p>
<p>a value, unlike <a
href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html#size%28%29">ArrayList.size()</a>
which returns the number of array elements which were assigned a
value.</p>
<p>Creating and initializing multi-dimensional arrays</p>
<p>The simplest way to create a multi-dimensional array is as
follows:</p>
<p><strong>int</strong>[][] a = <strong>new int</strong>[2][3];</p>
<p>It will create two three-length <strong>int</strong> arrays—a[0] and
a[1]. This is very similar to the classical, C-style initialization of
rectangular multi-dimensional arrays.</p>
<p>You can create and initialize at the same time:</p>
<p><strong>int</strong>[][] a = { {1, 2}, {3, 4}, {5, 6} };</p>
<p><a
href="http://stackoverflow.com/questions/7784758/c-c-multidimensional-array-internals/7784790">Unlike
C, where only rectangular multi-dimensional arrays are supported, inner
arrays do not need to be of the</a> same length, or even defined:</p>
<p><strong>int</strong>[][] a = { {1}, {2, 3}, <strong>null</strong>
};</p>
<p>Here, a[0] is a one-length <strong>int</strong> array, whereas a[1]
is a two-length <strong>int</strong> array and a[2] is
<strong>null</strong>. Arrays like this are</p>
<p>called jagged arrays or ragged arrays, that is, they are arrays of
arrays. Multi-dimensional arrays in Java are</p>
<p>implemented as arrays of arrays, i.e. array[i][j][k] is equivalent to
((array[i])[j])[k]. <a
href="http://stackoverflow.com/questions/597720/what-are-the-differences-between-a-multidimensional-array-and-an-array-of-arrays">Unlike
C#, the syntax</a></p>
<p>array[i,j] is not supported in Java.</p>
<p>Multidimensional array representation in Java</p>
<p><img src="media/index-136_1.png"
style="width:4.41667in;height:3.25in" alt="index-136_1.png" /></p>
<p><a href="http://math.hws.edu/eck/cs124/javanotes3/c8/s5.html">Source
-</a> <a href="https://ideone.com/3JdAmY">Live on Ideone</a></p>
<p>Creating and initializing <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">reference
type arrays</a></p>
<p>String[] array6 = <strong>new</strong> String[] { "Laurel", "Hardy"
}; <em>// Create an array with new</em></p>
<p>// operator and array initializer.</p>
<p>String[] array7 = { "Laurel", "Hardy" }; <em>// Shortcut syntax with
array</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 112</p>
<p>// initializer.</p>
<p>String[] array8 = <strong>new</strong> String[3]; <em>// { null,
null, null }</em> String[] array9 = <strong>null</strong>; <em>//
null</em></p>
<p><a href="https://ideone.com/WcAtr4">Live on Ideone</a></p>
<p>In addition to the String literals and primitives shown above, the
shortcut syntax for array initialization also works</p>
<p>with canonical Object types:</p>
<p>Object[] array10 = { <strong>new</strong> Object(),
<strong>new</strong> Object() };</p>
<p>Because arrays are covariant, a reference type array can be
initialized as an array of a subclass, although an ArrayStoreException
will be thrown if you try to set an element to something other than a
String:</p>
<p>Object[] array11 = <strong>new</strong> String[] { "foo", "bar",
"baz" }; array11[1] = "qux"; <em>// fine</em></p>
<p>array11[1] = <strong>new</strong> StringBuilder(); <em>// throws
ArrayStoreException</em></p>
<p>The shortcut syntax cannot be used for this because the shortcut
syntax would have an implicit type of Object[].</p>
<p>An array can be initialized with zero elements by using String[]
emptyArray = <strong>new</strong> String[0]. For example, an</p>
<p>array with zero length like this is used for Creating an Array from a
Collection when the method needs the runtime type of an object.</p>
<p>In both primitive and reference types, an empty array initialization
(for example String[] array8 = <strong>new</strong></p>
<p>String[3]) will initialize the array with the <a
href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">default
value for each data type.</a></p>
<p>Creating and initializing generic type arrays</p>
<p>In generic classes, arrays of generic types <strong>cannot</strong>
be initialized like this due to type erasure:</p>
<p><strong>public class</strong> MyGenericClass {</p>
<p>private <strong>T[] a;</strong></p>
<p><strong>public</strong> MyGenericClass() {</p>
<p><em>a = <strong>new</strong> T[5];</em> // Compile time error:
generic array creation</p>
<p>}</p>
<p>}</p>
<p>Instead, they can be created using one of the following methods:
(note that these will generate unchecked</p>
<p>warnings)</p>
<p>1. By creating an Object array, and casting it to the generic
type:</p>
<p>a = (T[]) <strong>new</strong> Object[5];</p>
<p>This is the simplest method, but since the underlying array is still
of type Object[], this method does not provide type safety. Therefore,
this method of creating an array is best used only within the generic
class -</p>
<p>not exposed publicly.</p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html#newInstance-java.lang.Class-int-">By
using Array.newInstance with a class parameter:</a></p>
<p><strong>public</strong> MyGenericClass(Class clazz) {</p>
<p>a = (T[]) Array.newInstance(clazz, 5);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 113</p>
<p>}</p>
<p>Here the class of T has to be explicitly passed to the constructor.
The return type of Array.newInstance is always Object. However, this
method is safer because the newly created array is always of type T[],
and</p>
<p>therefore can be safely externalized.</p>
<p>Filling an array after initialization</p>
<p>Version ≥ Java SE 1.2</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#fill-java.lang.Object:A-java.lang.Object-">Arrays.fill()
can be used to fill an array with</a> <strong>the same value</strong>
after initialization:</p>
<p>Arrays.fill(array8, "abc"); <em>// { "abc", "abc", "abc" }</em></p>
<p><a href="https://ideone.com/eXjMml">Live on Ideone</a></p>
<p>fill() can also assign a value to each element of the specified range
of the array:</p>
<p><em>Arrays.fill(array8, 1, 2, "aaa");</em> // Placing "aaa" from
index 1 to 2.</p>
<p><a href="https://ideone.com/zujsOh">Live on Ideone</a></p>
<p>Version ≥ Java SE 8</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#setAll-T:A-java.util.function.IntFunction-">Since
Java version 8, the method setAll</a>, and its Concurrent <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSetAll-T:A-java.util.function.IntFunction-">equivalent
parallelSetAll, can be used to set every</a></p>
<p>element of an array to generated values. These methods are passed a
generator function which accepts an index and returns the desired value
for that position.</p>
<p>The following example creates an integer array and sets all of its
elements to their respective index value:</p>
<p><strong>int</strong>[] array = <strong>new int</strong>[5];</p>
<p><em>Arrays.setAll(array, i -&gt; i);</em> // The array becomes { 0,
1, 2, 3, 4 }.</p>
<p><a href="https://ideone.com/txh8Xv">Live on Ideone</a></p>
<p>Separate declaration and initialization of arrays</p>
<p>The value of an index for an array element must be a whole number (0,
1, 2, 3, 4, ...) and less than the length of the</p>
<p>array (indexes are zero-based). Otherwise, an
ArrayIndexOutOfBoundsException will be thrown:</p>
<p><em><strong>int</strong>[] array9;</em> // Array declaration -
uninitialized</p>
<p><em>array9 = <strong>new int</strong>[3];</em> // Initialize array -
{ 0, 0, 0 } <em>array9[0] = 10;</em> // Set index 0 value - { 10, 0, 0
}</p>
<p><em>array9[1] = 20;</em> // Set index 1 value - { 10, 20, 0 }</p>
<p><em>array9[2] = 30;</em> // Set index 2 value - { 10, 20, 30 }</p>
<p>Arrays may not be re-initialized with array initializer shortcut
syntax</p>
<p>It is <a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.6">not
possible to re-initialize an array via a shortcut syntax with an array
initializer since an array initializer can</a> only be specified in a
field declaration or local variable declaration, or as a part of an
array creation expression.</p>
<p>However, it is possible to create a new array and assign it to the
variable being used to reference the old array. While this results in
the array referenced by that variable being re-initialized, the variable
contents are a completely</p>
<p>new array. To do this, the <strong>new</strong> operator can be used
with an array initializer and assigned to the array variable:</p>
<p>// First initialization of array</p>
<p><strong>int</strong>[] array = <strong>new int</strong>[] { 1, 2, 3
};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 114</p>
<p><span id="___Prints__1_2_3" class="anchor"></span>// Prints "1 2 3
".</p>
<p><strong>for</strong> (<strong>int</strong> i : array) {</p>
<p>System.out.print(i + " ");</p>
<p>}</p>
<p>// Re-initializes array to a new int[] array.</p>
<p>array = <strong>new int</strong>[] { 4, 5, 6 };</p>
<p>// Prints "4 5 6 ".</p>
<p><strong>for</strong> (<strong>int</strong> i : array) {</p>
<p>System.out.print(i + " ");</p>
<p>}</p>
<p><em>array = { 1, 2, 3, 4 };</em> // Compile-time error! Can't
re-initialize an array via shortcut</p>
<p>// syntax with array initializer.</p>
<p><a href="http://ideone.com/eCbTxB">Live on Ideone</a></p>
<p>Section 23.2: Creating a List from an Array</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">The
Arrays.asList() method can be used to return a fixed-size</a> List
containing the elements of the given array. The resulting List will be
of the same parameter type as the base type of the array.</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>List stringList = Arrays.asList(stringArray);</p>
<p><strong>Note</strong>: This list is backed by (<em>a view</em> of)
the original array, meaning that any changes to the list will change the
array</p>
<p>and vice versa. However, changes to the list that would change its
size (and hence the array length) will throw an exception.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList-java.util.Collection-">To
create a copy of the list, use the constructor of
java.util.ArrayList</a> taking a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection
as an argument:</a></p>
<p>Version ≥ Java SE 5</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>List stringList = <strong>new</strong>
ArrayList(Arrays.asList(stringArray));</p>
<p>Version ≥ Java SE 7</p>
<p>In Java SE 7 and later, a pair of angle brackets
&lt;<strong>&gt;</strong> (empty set of type arguments) can be used,
which is called the</p>
<p>Diamond. The compiler can determine the type arguments from the
context. This means the type information can be left out when calling
the constructor of ArrayList and it will be inferred automatically
during compilation. This is</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/type-inference-generic-instance-creation.html">called
Type Inference which is a part of Java Generics.</a></p>
<p>// Using Arrays.asList()</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>List stringList = <strong>new</strong>
ArrayList&lt;&gt;(Arrays.asList(stringArray));</p>
<p>// Using ArrayList.addAll()</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>ArrayList list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>list.addAll(Arrays.asList(stringArray));</p>
<p>// Using Collections.addAll()</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>ArrayList list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>Collections.addAll(list, stringArray);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 115</p>
<p>A point worth noting about the Diamond is that it cannot be used with
Anonymous Classes.</p>
<p>Version ≥ Java SE 8</p>
<p>// Using Streams</p>
<p><strong>int</strong>[] ints = {1, 2, 3};</p>
<p>List list =
Arrays.stream(ints).boxed().collect(Collectors.toList());</p>
<p>String[] stringArray = {"foo", "bar", "baz"};</p>
<p>List list =
Arrays.stream(stringArray).collect(Collectors.toList());</p>
<p>Important notes related to using Arrays.asList() method</p>
<p>This method returns List, which is an instance of
Arrays$ArrayList(static inner class of Arrays) and not</p>
<p>java.util.ArrayList . The resulting List is of fixed-size. That
means, adding or removing elements is not supported and will throw an
UnsupportedOperationException:</p>
<p><em>stringList.add("something");</em> // throws
java.lang.UnsupportedOperationException</p>
<p>A new List can be created by passing an array-backed List to the
constructor of a new List. This creates a new copy of the data, which
has changeable size and that is not backed by the original array:</p>
<p>List modifiableList = <strong>new</strong>
ArrayList&lt;&gt;(Arrays.asList("foo", "bar"));</p>
<p>Calling <strong>&lt;T&gt;</strong> List<strong>&lt;T&gt;</strong>
asList(T... a) on a primitive array, such as an <strong>int</strong>[],
will produce a List&lt;<strong>int</strong>[]&gt;</p>
<p>whose <a
href="http://stackoverflow.com/questions/2607289/converting-array-to-list-in-java">only
element is the source primitive array instead of the actual elements of
the source array.</a></p>
<p>The reason for this behavior is that primitive types cannot be used
in place of generic type parameters, so the entire primitive array
replaces the generic type parameter in this case. In order to convert a
primitive</p>
<p>array to a List, first of all, convert the primitive array to an
array of the corresponding wrapper type (i.e. call Arrays.asList on an
Integer[] instead of an <strong>int</strong>[]).</p>
<p>Therefore, this will print <strong>false</strong>:</p>
<p><em><strong>int</strong>[] arr = {1, 2, 3};</em> // primitive array
of int</p>
<p>System.out.println(Arrays.asList(arr).contains(1));</p>
<p><a href="https://ideone.com/xiyy6o">View Demo</a></p>
<p>On the other hand, this will print <strong>true</strong>:</p>
<p>Integer[] arr = {1, 2, 3}; <em>// object array of Integer (wrapper
for int)</em> System.out.println(Arrays.asList(arr).contains(1));</p>
<p><a href="https://ideone.com/QR1N59">View Demo</a></p>
<p>This will also print <strong>true</strong>, because the array will be
interpreted as an Integer[]):</p>
<p>System.out.println(Arrays.asList(1,2,3).contains(1));</p>
<p><a href="https://ideone.com/zfhHQz">View Demo</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 116</p>
<p><span id="Section_23_3__Creating_an_Array"
class="anchor"></span>Section 23.3: Creating an Array from a
Collection</p>
<p>Two methods in <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">java.util.Collection
create an array from a collection:</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#toArray--">Object[]
toArray()</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#toArray-T:A-"><strong>&lt;T&gt;</strong>
T[] toArray(T[] a)</a></p>
<p>Object[] toArray() can be used as follows:</p>
<p>Version ≥ Java SE 5</p>
<p>Set set = <strong>new</strong> HashSet();</p>
<p>set.add("red");</p>
<p>set.add("blue");</p>
<p>// although set is a Set&lt;String&gt;, toArray() returns an Object[]
not a String[] <em>Object[] objectArray = set.toArray();</em></p>
<p><strong>&lt;T&gt;</strong> T[] toArray(T[] a) can be used as
follows:</p>
<p>Version ≥ Java SE 5</p>
<p>Set set = <strong>new</strong> HashSet();</p>
<p>set.add("red");</p>
<p>set.add("blue");</p>
<p>// The array does not need to be created up front with the correct
size. // Only the array type matters. (If the size is wrong, a new array
will // be created with the same type.)</p>
<p>String[] stringArray = set.toArray(<strong>new</strong>
String[0]);</p>
<p>// If you supply an array of the same size as collection or bigger,
it // will be populated with collection values and returned (new array
// won't be allocated)</p>
<p>String[] stringArray2 = set.toArray(<strong>new</strong>
String[set.size()]);</p>
<p>The difference between them is more than just having untyped vs typed
results. Their performance can differ as</p>
<p><a
href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/#_meet_solaris_studio_performance_analyzer">well
(for details please read this performance analysis section</a>):</p>
<p>Object[] toArray() uses vectorized arraycopy, which is much faster
than the type-checked arraycopy used in T[] toArray(T[] a).</p>
<p>T[] toArray(<strong>new</strong> T[non-zero-size]) needs to zero-out
the array at runtime, while T[] toArray(<strong>new</strong> T[0])</p>
<p>does not. Such avoidance makes the latter call faster than the
former. Detailed analysis here : <a
href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">Arrays
of</a></p>
<p><a
href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">Wisdom of
the Ancients</a>.</p>
<p>Version ≥ Java SE 8</p>
<p>Starting from Java SE 8+, where the concept of Stream has been
introduced, it is possible to use the Stream</p>
<p>produced by the collection in order to create a new Array using the
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#toArray-java.util.function.IntFunction-">Stream.toArray</a>
method.</p>
<p>String[] strings =
list.stream().toArray(String[]::<strong>new</strong>);</p>
<p>Examples taken from two answers (<a
href="http://stackoverflow.com/a/4042464">1</a>, <a
href="http://stackoverflow.com/a/30302969">2) to</a> <a
href="http://stackoverflow.com/questions/4042434/converting-arrayliststring-to-string-in-java">Converting
'ArrayList to 'String[]' in Java on Stack Overflow.</a></p>
<p>Section 23.4: Multidimensional and Jagged Arrays</p>
<p>It is possible to define an array with more than one dimension.
Instead of being accessed by providing a single</p>
<p>index, a multidimensional array is accessed by specifying an index
for each dimension.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 117</p>
<p>The declaration of multidimensional array can be done by adding []
for each dimension to a regular array declaration. For instance, to make
a 2-dimensional <strong>int</strong> array, add another set of brackets
to the declaration, such</p>
<p>as <strong>int</strong>[][]. This continues for 3-dimensional arrays
(<strong>int</strong>[][][]) and so forth.</p>
<p>To define a 2-dimensional array with three rows and three
columns:</p>
<p><strong>int</strong> rows = 3;</p>
<p><strong>int</strong> columns = 3;</p>
<p><strong>int</strong>[][] table = <strong>new
int</strong>[rows][columns];</p>
<p>The array can be indexed and assign values to it with this construct.
Note that the unassigned values are the default</p>
<p>values for the type of an array, in this case 0 for
<strong>int</strong>.</p>
<p>table[0][0] = 0;</p>
<p>table[0][1] = 1;</p>
<p>table[0][2] = 2;</p>
<p>It is also possible to instantiate a dimension at a time, and even
make non-rectangular arrays. These are more</p>
<p>commonly referred to as <a
href="https://en.wikipedia.org/wiki/Jagged_array"><strong>jagged
arrays</strong></a>.</p>
<p><strong>int</strong>[][] nonRect = <strong>new int</strong>[4][];</p>
<p>It is important to note that although it is possible to define any
dimension of jagged array, it's preceding level
<em><strong>must</strong></em></p>
<p>be defined.</p>
<p>// valid</p>
<p>String[][] employeeGraph = <strong>new</strong> String[30][];</p>
<p>// invalid</p>
<p><strong>int</strong>[][] unshapenMatrix = <strong>new
int</strong>[][10];</p>
<p>// also invalid</p>
<p><strong>int</strong>[][][] misshapenGrid = <strong>new
int</strong>[100][][10];</p>
<p>How Multidimensional Arrays are represented in Java</p>
<p><img src="media/index-142_1.png"
style="width:4.41667in;height:3.25in" alt="index-142_1.png" /></p>
<p><a href="http://math.hws.edu/eck/cs124/javanotes3/c8/s5.html">Image
source: http://math.hws.edu/eck/cs124/javanotes3/c8/s5.html</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 118</p>
<p><span id="Jagged_array_literal_intializati"
class="anchor"></span>Jagged array literal intialization</p>
<p>Multidimensional arrays and jagged arrays can also be initialized
with a literal expression. The following declares</p>
<p>and populates a 2x3 <strong>int</strong> array:</p>
<p><strong>int</strong>[][] table = {</p>
<p>{1, 2, 3},</p>
<p>{4, 5, 6}</p>
<p>};</p>
<p><strong>Note</strong>: Jagged subarrays may also be
<strong>null</strong>. For instance, the following code declares and
populates a two</p>
<p>dimensional <strong>int</strong> array whose first subarray is
<strong>null</strong>, second subarray is of zero length, third subarray
is of one</p>
<p>length and the last subarray is a two length array:</p>
<p><strong>int</strong>[][] table = {</p>
<p>null<strong>,</strong></p>
<p>{},</p>
<p>{1},</p>
<p>{1,2}</p>
<p>};</p>
<p>For multidimensional array it is possible to extract arrays of
lower-level dimension by their indices:</p>
<p><strong>int</strong>[][][] arr = <strong>new
int</strong>[3][3][3];</p>
<p><em><strong>int</strong>[][] arr1 = arr[0];</em> // get first
3x3-dimensional array from arr <em><strong>int</strong>[] arr2 =
arr1[0];</em> // get first 3-dimensional array from arr1
<em><strong>int</strong>[] arr3 = arr[0];</em> // error: cannot convert
from int[][] to int[]</p>
<p>Section 23.5: ArrayIndexOutOfBoundsException</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ArrayIndexOutOfBoundsException.html">The
ArrayIndexOutOfBoundsException</a> is thrown when a non-existing index
of an array is being accessed.</p>
<p>Arrays are zero-based indexed, so the index of the first element is 0
and the index of the last element is the array capacity minus 1 (i.e.
array.length-1).</p>
<p>Therefore, any request for an array element by the index i has to
satisfy the condition 0 &lt;= i &lt; array.length,</p>
<p>otherwise the ArrayIndexOutOfBoundsException will be thrown.</p>
<p>The following code is a simple example where an
ArrayIndexOutOfBoundsException is thrown.</p>
<p>String[] people = <strong>new</strong> String[] { "Carol", "Andy"
};</p>
<p>// An array will be created:</p>
<p>// people[0]: "Carol"</p>
<p>// people[1]: "Andy"</p>
<p>// Notice: no item on index 2. Trying to access it triggers the
exception: <em>System.out.println(people[2]);</em> // throws an
ArrayIndexOutOfBoundsException.</p>
<p>Output:</p>
<p>Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
2 at your.package.path.method(YourClass.java:15)</p>
<p>Note that the illegal index that is being accessed is also included
in the exception (2 in the example); this information could</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 119</p>
<p><span id="be_useful_to_find_the_cause_of_t" class="anchor"></span>be
useful to find the cause of the exception.</p>
<p>To avoid this, simply check that the index is within the limits of
the array:</p>
<p><strong>int</strong> index = 2;</p>
<p><strong>if</strong> (index &gt;= 0 &amp;&amp; index &lt;
people.length) {</p>
<p>System.out.println(people[index]);</p>
<p>}</p>
<p>Section 23.6: Array Covariance</p>
<p>Object arrays are covariant, which means that just as Integer is a
subclass of Number, Integer[] is a subclass of</p>
<p>Number[]. This may seem intuitive, but can result in surprising
behavior:</p>
<p>Integer[] integerArray = {1, 2, 3};</p>
<p>Number[] numberArray = integerArray; <em>// valid</em></p>
<p>Number firstElement = numberArray[0]; <em>// valid</em></p>
<p><em>numberArray[0] = 4L;</em> // throws ArrayStoreException at
runtime</p>
<p>Although Integer[] is a subclass of Number[], it can only hold
Integers, and trying to assign a Long element throws</p>
<p>a runtime exception.</p>
<p>Note that this behavior is unique to arrays, and can be avoided by
using a generic List instead:</p>
<p>List integerList = Arrays.asList(1, 2, 3); <em>//List&lt;Number&gt;
numberList = integerList; // compile error</em> Listextends Number&gt;
numberList = integerList;</p>
<p>Number firstElement = numberList.get(0);</p>
<p>//numberList.set(0, 4L); // compile error</p>
<p>It's not necessary for all of the array elements to share the same
type, as long as they are a subclass of the array's</p>
<p>type:</p>
<p>interface <strong>I {}</strong></p>
<p>class <strong>A</strong> implements <strong>I {}</strong></p>
<p>class <strong>B</strong> implements <strong>I {}</strong></p>
<p>class <strong>C</strong> implements <strong>I {}</strong></p>
<p>I[] array10 = <strong>new</strong> I[] { <strong>new</strong> A(),
<strong>new</strong> B(), <strong>new</strong> C() }; <em>// Create an
array with new</em></p>
<p>// operator and array initializer.</p>
<p>I[] array11 = { <strong>new</strong> A(), <strong>new</strong> B(),
<strong>new</strong> C() }; <em>// Shortcut syntax with array</em></p>
<p>// initializer.</p>
<p><em>I[] array12 = <strong>new</strong> I[3];</em> // { null, null,
null }</p>
<p>I[] array13 = <strong>new</strong> A[] { <strong>new</strong> A(),
<strong>new</strong> A() }; <em>// Works because A implements
I.</em></p>
<p>Object[] array14 = <strong>new</strong> Object[] { "Hello, World!",
3.14159, 42 }; <em>// Create an array with</em></p>
<p>// new operator and array initializer.</p>
<p>Object[] array15 = { <strong>new</strong> A(), 64, "My String" };
<em>// Shortcut syntax</em></p>
<p>// with array initializer.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 120</p>
<p><span id="Section_23_7__Arrays_to_Stream"
class="anchor"></span>Section 23.7: Arrays to Stream</p>
<p>Version ≥ Java SE 8</p>
<p>Converting an array of objects to Stream:</p>
<p>String[] arr = <strong>new</strong> String[] {"str1", "str2",
"str3"}; Stream stream = Arrays.stream(arr);</p>
<p>Converting an array of primitives to Stream using <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-T:A-">Arrays.stream()</a>
will transform the array to a primitive specialization of Stream:</p>
<p><strong>int</strong>[] intArr = {1, 2, 3};</p>
<p>IntStream intStream = Arrays.stream(intArr);</p>
<p>You can also limit the Stream to a range of elements in the array.
The start index is inclusive and the end index is</p>
<p>exclusive:</p>
<p><strong>int</strong>[] values = {1, 2, 3, 4};</p>
<p>IntStream intStream = Arrays.stream(values, 2, 4);</p>
<p>A method similar to Arrays.stream() appears in the Stream class: <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#of-T...-">Stream.of().
The difference is that</a> Stream.of()</p>
<p>uses a varargs parameter, so you can write something like:</p>
<p>Stream intStream = Stream.of(1, 2, 3);</p>
<p>Stream stringStream = Stream.of("1", "2", "3"); Stream doubleStream =
Stream.of(<strong>new</strong> Double[]{1.0, 2.0});</p>
<p>Section 23.8: Iterating over arrays</p>
<p>You can iterate over arrays either by using enhanced for loop (aka
foreach) or by using array indices:</p>
<p><strong>int</strong>[] array = <strong>new int</strong>[10];</p>
<p>// using indices: read and write</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
array.length; i++) {</p>
<p>array[i] = i;</p>
<p>}</p>
<p>Version ≥ Java SE 5</p>
<p>// extended for: read only</p>
<p><strong>for</strong> (<strong>int</strong> e : array) {</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>It is worth noting here that there is no direct way to use an
Iterator on an Array, but through the Arrays library it can be easily
converted to a list to obtain an Iterable object.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)">For
boxed arrays use Arrays.asList</a>:</p>
<p>Integer[] boxed = {1, 2, 3};</p>
<p>Iterable boxedIt = Arrays.asList(boxed); <em>// list-backed
iterable</em> Iterator fromBoxed1 = boxedIt.iterator();</p>
<p>For primitive arrays (using java 8) use streams (specifically in this
example - <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-int:A-">Arrays.stream
-&gt; IntStream</a>):</p>
<p><strong>int</strong>[] primitives = {1, 2, 3};</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 121</p>
<p>IntStream primitiveStream = Arrays.stream(primitives); <em>//
list-backed iterable</em> PrimitiveIterator.OfInt fromPrimitive1 =
primitiveStream.iterator();</p>
<p><a href="https://github.com/google/guava">If you can't use streams
(no java 8), you can choose to use google's guava library:</a></p>
<p>Iterable fromPrimitive2 = Ints.asList(primitives);</p>
<p>In two-dimensional arrays or more, both techniques can be used in a
slightly more complex fashion.</p>
<p>Example:</p>
<p><strong>int</strong>[][] array = <strong>new
int</strong>[10][10];</p>
<p><strong>for</strong> (<strong>int</strong> indexOuter = 0; indexOuter
&lt; array.length; indexOuter++) {</p>
<p><strong>for</strong> (<strong>int</strong> indexInner = 0; indexInner
&lt; array[indexOuter].length; indexInner++) {
array[indexOuter][indexInner] = indexOuter + indexInner; }</p>
<p>}</p>
<p>Version ≥ Java SE 5</p>
<p><strong>for</strong> (<strong>int</strong>[] numbers : array) {</p>
<p><strong>for</strong> (<strong>int</strong> value : numbers) {</p>
<p>System.out.println(value);</p>
<p>}</p>
<p>}</p>
<p>It is impossible to set an Array to any non-uniform value without
using an index based loop.</p>
<p>Of course you can also use <strong>while</strong> or
do-<strong>while</strong> loops when iterating using indices.</p>
<p><strong>One note of caution:</strong> when using array indices, make
sure the index is between 0 and array.length-1 (both</p>
<p>inclusive). Don't make hard coded assumptions on the array length
otherwise you might break your code if the array length changes but your
hard coded values don't.</p>
<p>Example:</p>
<p><strong>int</strong>[] numbers = {1, 2, 3, 4};</p>
<p><strong>public void</strong> incrementNumbers() {</p>
<p>// DO THIS :</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
numbers.length; i++) {</p>
<p><em>numbers[i] += 1;</em> //or this: numbers[i] = numbers[i] + 1; or
numbers[i]++;</p>
<p>}</p>
<p>// DON'T DO THIS :</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 4; i++)
{</p>
<p>numbers[i] += 1;</p>
<p>}</p>
<p>}</p>
<p>It's also best if you don't use fancy calculations to get the index
but use the index to iterate and if you need</p>
<p>different values calculate those.</p>
<p>Example:</p>
<p><strong>public void</strong>
fillArrayWithDoubleIndex(<strong>int</strong>[] array) {</p>
<p>// DO THIS :</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
array.length; i++) {</p>
<p>array[i] = i * 2;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 122</p>
<p><span id="_2" class="anchor"></span>}</p>
<p>// DON'T DO THIS :</p>
<p><strong>int</strong> doubleLength = array.length * 2;</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
doubleLength; i += 2) {</p>
<p>array[i / 2] = i;</p>
<p>}</p>
<p>}</p>
<p>Accessing Arrays in reverse order</p>
<p><strong>int</strong>[] array = {0, 1, 1, 2, 3, 5, 8, 13};</p>
<p><strong>for</strong> (<strong>int</strong> i = array.length-1; i
&gt;= 0; i--) {</p>
<p>System.out.println(array[i]);</p>
<p>}</p>
<p>Using temporary Arrays to reduce code repetition</p>
<p>Iterating over a temporary array instead of repeating code can make
your code cleaner. It can be used where the</p>
<p>same operation is performed on multiple variables.</p>
<p>// we want to print out all of these</p>
<p>String name = "Margaret";</p>
<p><strong>int</strong> eyeCount = 16;</p>
<p><strong>double</strong> height = 50.2;</p>
<p><strong>int</strong> legs = 9;</p>
<p><strong>int</strong> arms = 5;</p>
<p>// copy-paste approach:</p>
<p>System.out.println(name);</p>
<p>System.out.println(eyeCount);</p>
<p>System.out.println(height);</p>
<p>System.out.println(legs);</p>
<p>System.out.println(arms);</p>
<p>// temporary array approach:</p>
<p><strong>for</strong>(Object attribute : <strong>new</strong>
Object[]{name, eyeCount, height, legs, arms})</p>
<p>System.out.println(attribute);</p>
<p>// using only numbers</p>
<p><strong>for</strong>(<strong>double</strong> number : <strong>new
double</strong>[]{eyeCount, legs, arms, height})</p>
<p>System.out.println(Math.sqrt(number));</p>
<p>Keep in mind that this code should not be used in
performance-critical sections, as an array is created every time the
loop is entered, and that primitive variables will be copied into the
array and thus cannot be modified.</p>
<p>Section 23.9: Arrays to a String</p>
<p>Version ≥ Java SE 5</p>
<p>Since Java 1.5 you can get a String representation of the contents of
the specified array without iterating over its</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#toString-java.lang.Object:A-">every
element. Just use Arrays.toString(Object[]) or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepToString-java.lang.Object:A-">Arrays.deepToString(Object[])</a>
for multidimentional</p>
<p>arrays:</p>
<p><strong>int</strong>[] arr = {1, 2, 3, 4, 5};</p>
<p>System.out.println(Arrays.toString(arr)); <em>// [1, 2, 3, 4,
5]</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 123</p>
<p><span id="int_____arr" class="anchor"></span><strong>int</strong>[][]
arr = {</p>
<p>{1, 2, 3},</p>
<p>{4, 5, 6},</p>
<p>{7, 8, 9}</p>
<p>};</p>
<p>System.out.println(Arrays.deepToString(arr)); <em>// [[1, 2, 3], [4,
5, 6], [7, 8, 9]]</em></p>
<p>Arrays.toString() method uses Object.toString() method to produce
String values of every item in the array,</p>
<p>beside primitive type array, it can be used for all type of arrays.
For instance:</p>
<p><em><strong>public class</strong> Cat {</em> /* implicitly extends
Object */</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> "CAT!";</p>
<p>}</p>
<p>}</p>
<p>Cat[] arr = { <strong>new</strong> Cat(), <strong>new</strong> Cat()
};</p>
<p>System.out.println(Arrays.toString(arr)); <em>// [CAT!,
CAT!]</em></p>
<p>If no overridden toString() exists for the class, then the inherited
toString() from Object will be used. Usually</p>
<p>the output is then not very useful, for example:</p>
<p>public class <strong>Dog {</strong></p>
<p>/* implicitly extends Object */</p>
<p>}</p>
<p>Dog[] arr = { <strong>new</strong> Dog() };</p>
<p>System.out.println(Arrays.toString(arr)); <em>//
[Dog@17ed40e0]</em></p>
<p>Section 23.10: Sorting arrays</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">Sorting
arrays can be easily done with the Arrays</a> api.</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p>// creating an array with integers</p>
<p><strong>int</strong>[] array = {7, 4, 2, 1, 19};</p>
<p>// this is the sorting part just one function ready to be used
<em>Arrays.sort(array);</em></p>
<p>// prints [1, 2, 4, 7, 19]</p>
<p>System.out.println(Arrays.toString(array));</p>
<p>Sorting String arrays:</p>
<p>String is not a numeric data, it defines it's own order which is
called lexicographic order, also known as alphabetic</p>
<p>order. When you sort an array of String using sort() method, it sorts
array into natural order defined by Comparable interface, as shown below
:</p>
<p>Increasing Order</p>
<p>String[] names = {"John", "Steve", "Shane", "Adam", "Ben"};
System.out.println("String array before sorting : " +
Arrays.toString(names)); Arrays.sort(names);</p>
<p>System.out.println("String array after sorting in ascending order : "
+ Arrays.toString(names));</p>
<p>Output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 124</p>
<p>String array before sorting : [John, Steve, Shane, Adam, Ben] String
array after sorting in ascending order : [Adam, Ben, John, Shane,
Steve]</p>
<p>Decreasing Order</p>
<p>Arrays.sort(names, 0, names.length, Collections.reverseOrder());
System.out.println("String array after sorting in descending order : " +
Arrays.toString(names));</p>
<p>Output:</p>
<p>String array after sorting in descending order : [Steve, Shane, John,
Ben, Adam]</p>
<p>Sorting an Object array</p>
<p>In order to sort an object array, all elements must implement either
Comparable or Comparator interface to define</p>
<p>the order of the sorting.</p>
<p>We can use either sort(Object[]) method to sort an object array on
its natural order, but you must ensure that all</p>
<p>elements in the array must implement Comparable.</p>
<p>Furthermore, they must be mutually comparable as well, for example
e1.compareTo(e2) must not throw a <em>ClassCastException</em> for any
elements e1 and e2 in the array. Alternatively you can sort an Object
array on custom</p>
<p>order using sort(T[], Comparator) method as shown in following
example.</p>
<p>// How to Sort Object Array in Java using Comparator and Comparable
<em>Course[] courses = <strong>new</strong> Course[4];</em></p>
<p>courses[0] = <strong>new</strong> Course(101, "Java", 200);</p>
<p>courses[1] = <strong>new</strong> Course(201, "Ruby", 300);</p>
<p>courses[2] = <strong>new</strong> Course(301, "Python", 400);</p>
<p>courses[3] = <strong>new</strong> Course(401, "Scala", 500);</p>
<p>System.out.println("Object array before sorting : " +
Arrays.toString(courses));</p>
<p>Arrays.sort(courses);</p>
<p>System.out.println("Object array after sorting in natural order : " +
Arrays.toString(courses));</p>
<p>Arrays.sort(courses, <strong>new</strong> Course.PriceComparator());
System.out.println("Object array after sorting by price : " +
Arrays.toString(courses));</p>
<p>Arrays.sort(courses, <strong>new</strong> Course.NameComparator());
System.out.println("Object array after sorting by name : " +
Arrays.toString(courses));</p>
<p>Output:</p>
<p>Object array before sorting : [#101 Java@200 , #201 Ruby@300 , #301
Python@400 , #401 Scala@500 ] Object array after sorting in natural
order : [#101 Java@200 , #201 Ruby@300 , #301 Python@400 , #401
Scala@500 ]</p>
<p>Object array after sorting by price : [#101 Java@200 , #201 Ruby@300
, #301 Python@400 , #401 Scala@500 ]</p>
<p>Object array after sorting by name : [#101 Java@200 , #301 Python@400
, #201 Ruby@300 , #401 Scala@500 ]</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 125</p>
<p><span id="Section_23_11__Getting_the_Lengt"
class="anchor"></span>Section 23.11: Getting the Length of an Array</p>
<p>Arrays are objects which provide space to store up to its size of
elements of specified type. An array's size can not</p>
<p>be modified after the array is created.</p>
<p><strong>int</strong>[] arr1 = <strong>new int</strong>[0];</p>
<p><strong>int</strong>[] arr2 = <strong>new int</strong>[2];</p>
<p><strong>int</strong>[] arr3 = <strong>new int</strong>[]{1, 2, 3,
4};</p>
<p><strong>int</strong>[] arr4 = {1, 2, 3, 4, 5, 6, 7};</p>
<p><strong>int</strong> len1 = arr1.length; <em>// 0</em></p>
<p><strong>int</strong> len2 = arr2.length; <em>// 2</em></p>
<p><strong>int</strong> len3 = arr3.length; <em>// 4</em></p>
<p><strong>int</strong> len4 = arr4.length; <em>// 7</em></p>
<p>The length field in an array stores the size of an array. It is a
<strong>final</strong> field and cannot be modified.</p>
<p>This code shows the difference between the length of an array and
amount of objects an array stores.</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Integer arr[] = <strong>new</strong> Integer[]
{1,2,3,<strong>null</strong>,5,<strong>null</strong>,7,<strong>null</strong>,<strong>null</strong>,<strong>null</strong>,11,<strong>null</strong>,13};</p>
<p><strong>int</strong> arrayLength = arr.length;</p>
<p><strong>int</strong> nonEmptyElementsCount = 0;</p>
<p><strong>for</strong> (<strong>int</strong> i=0; i</p>
<p>Integer arrElt = arr[i];</p>
<p><strong>if</strong> (arrElt != <strong>null</strong>) {</p>
<p>nonEmptyElementsCount++;</p>
<p>}</p>
<p>}</p>
<p>System.out.println("Array 'arr' has a length of
"+arrayLength+"<strong>\n</strong>"</p>
<p>+ "and it contains "+nonEmptyElementsCount+" non-empty values");</p>
<p>}</p>
<p>Result:</p>
<p>Array 'arr' has a length of 13</p>
<p>and it contains 7 non-empty values</p>
<p>Section 23.12: Finding an element in an array</p>
<p>There are many ways find the location of a value in an array. The
following example snippets all assume that the</p>
<p>array is one of the following:</p>
<p>String[] strings = <strong>new</strong> String[] { "A", "B", "C"
};</p>
<p><strong>int</strong>[] ints = <strong>new int</strong>[] { 1, 2, 3, 4
};</p>
<p>In addition, each one sets index or index2 to either the index of
required element, or -1 if the element is not</p>
<p>present.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-java.lang.Object:A-java.lang.Object-">Using
Arrays.binarySearch</a> (for sorted arrays only)</p>
<p><strong>int</strong> index = Arrays.binarySearch(strings, "A");</p>
<p><strong>int</strong> index2 = Arrays.binarySearch(ints, 1);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 126</p>
<p><span id="Using_a_Arrays_asList__for_non_p"
class="anchor"></span>Using a Arrays.asList (for non-primitive arrays
only)</p>
<p><strong>int</strong> index = Arrays.asList(strings).indexOf("A");</p>
<p><strong>int</strong> index2 = Arrays.asList(ints).indexOf(1); <em>//
compilation error</em></p>
<p>Using a Stream</p>
<p>Version ≥ Java SE 8</p>
<p><strong>int</strong> index = IntStream.range(0, strings.length)</p>
<p>.filter(i -&gt; "A".equals(strings[i]))</p>
<p>.findFirst()</p>
<p><em>.orElse(-1);</em> // If not present, gives us -1.</p>
<p>// Similar for an array of primitives</p>
<p>Linear search using a loop</p>
<p><strong>int</strong> index =-1;</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
array.length; i++) {</p>
<p><strong>if</strong> ("A".equals(array[i])) {</p>
<p>index = i;</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>// Similar for an array of primitives</p>
<p><a
href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/ArrayUtils.html">Linear
search using 3rd-party libraries such as org.apache.commons</a></p>
<p><strong>int</strong> index =
org.apache.commons.lang3.ArrayUtils.contains(strings, "A");
<strong>int</strong> index2 =
org.apache.commons.lang3.ArrayUtils.contains(ints, 1);</p>
<p>Note: Using a direct linear search is more efficient than wrapping in
a list.</p>
<p>Testing if an array contains an element</p>
<p>The examples above can be adapted to test if the array contains an
element by simply testing to see if the index</p>
<p>computed is greater or equal to zero.</p>
<p>Alternatively, there are also some more concise variations:</p>
<p><strong>boolean</strong> isPresent =
Arrays.asList(strings).contains("A");</p>
<p>Version ≥ Java SE 8</p>
<p><strong>boolean</strong> isPresent = Stream.of(strings).anyMatch(x
-&gt; "A".equals(x));</p>
<p><strong>boolean</strong> isPresent = <strong>false</strong>;</p>
<p><strong>for</strong> (String s : strings) {</p>
<p><strong>if</strong> ("A".equals(s)) {</p>
<p>isPresent = <strong>true</strong>;</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>boolean</strong> isPresent =
org.apache.commons.lang3.ArrayUtils.contains(ints, 4);</p>
<p>Section 23.13: How do you change the size of an array?</p>
<p>The simple answer is that you cannot do this. Once an array has been
created, its size cannot be changed. Instead,</p>
<p>an array can only be "resized" by creating a new array with the
appropriate size and copying the elements from the existing array to the
new one.</p>
<p>String[] listOfCities = <strong>new</strong> String[3]; <em>// array
created with size 3.</em> listOfCities[0] = "New York";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 127</p>
<p><span id="listOfCities_1_____London"
class="anchor"></span>listOfCities[1] = "London";</p>
<p>listOfCities[2] = "Berlin";</p>
<p>Suppose (for example) that a new element needs to be added to the
listOfCities array defined as above. To do</p>
<p>this, you will need to:</p>
<p>1. create a new array with size 4,</p>
<p>2. copy the existing 3 elements of the old array to the new array at
offsets 0, 1 and 2, and 3. add the new element to the new array at
offset 3.</p>
<p>There are various ways to do the above. Prior to Java 6, the most
concise way was:</p>
<p>String[] newArray = <strong>new</strong> String[listOfCities.length +
1]; System.arraycopy(listOfCities, 0, newArray, 0, listOfCities.length);
newArray[listOfCities.length] = "Sydney";</p>
<p>From Java 6 onwards, the Arrays.copyOf and Arrays.copyOfRange methods
can do this more simply:</p>
<p>String[] newArray = Arrays.copyOf(listOfCities, listOfCities.length +
1); newArray[listOfCities.length] = "Sydney";</p>
<p>For other ways to copy an array, refer to the following example. Bear
in mind that you need an array copy with a different length to the
original when resizing.</p>
<p>Copying arrays</p>
<p>A better alternatives to array resizing</p>
<p>There two major drawbacks with resizing an array as described
above:</p>
<p>It is inefficient. Making an array bigger (or smaller) involves
copying many or all of the existing array</p>
<p>elements, and allocating a new array object. The larger the array,
the more expensive it gets. You need to be able to update any "live"
variables that contain references to the old array.</p>
<p>One alternative is to create the array with a large enough size to
start with. This is only viable if you can determine that size
accurately <em>before allocating the array</em>. If you cannot do that,
then the problem of resizing the array arises</p>
<p>again.</p>
<p>The other alternative is to use a data structure class provided by
the Java SE class library or a third-party library. For</p>
<p>example, the Java SE "collections" framework provides a number of
implementations of the List, Set and Map APIs with different runtime
properties. The ArrayList class is closest to performance
characteristics of a plain array (e.g.</p>
<p>O(N) lookup, O(1) get and set, O(N) random insertion and deletion)
while providing more efficient resizing without the reference update
problem.</p>
<p>(The resize efficiency for ArrayList comes from its strategy of
doubling the size of the backing array on each resize. For a typical
use-case, this means that you only resize occasionally. When you
amortize over the lifetime of the list,</p>
<p>the resize cost per insert is O(1). It may be possible to use the
same strategy when resizing a plain array.)</p>
<p>Section 23.14: Converting arrays between primitives and</p>
<p>boxed types</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Sometimes
conversion of primitive</a> types to <a
href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">boxed
types is necessary.</a></p>
<p>To convert the array, it's possible to use streams (in Java 8 and
above):</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 128</p>
<p><span id="Version_____Java_SE_8" class="anchor"></span>Version ≥ Java
SE 8</p>
<p><strong>int</strong>[] primitiveArray = {1, 2, 3, 4};</p>
<p>Integer[] boxedArray =</p>
<p>Arrays.stream(primitiveArray).boxed().toArray(Integer[]::<strong>new</strong>);</p>
<p>With lower versions it can be by iterating the primitive array and
explicitly copying it to the boxed array:</p>
<p>Version &lt; Java SE 8</p>
<p><strong>int</strong>[] primitiveArray = {1, 2, 3, 4};</p>
<p>Integer[] boxedArray = <strong>new</strong>
Integer[primitiveArray.length]; <strong>for</strong>
(<strong>int</strong> i = 0; i &lt; primitiveArray.length; ++i) {</p>
<p>boxedArray[i] = primitiveArray[i]; <em>// Each element is autoboxed
here</em> }</p>
<p>Similarly, a boxed array can be converted to an array of its
primitive counterpart:</p>
<p>Version ≥ Java SE 8</p>
<p>Integer[] boxedArray = {1, 2, 3, 4};</p>
<p><strong>int</strong>[] primitiveArray =</p>
<p>Arrays.stream(boxedArray).mapToInt(Integer::intValue).toArray();</p>
<p>Version &lt; Java SE 8</p>
<p>Integer[] boxedArray = {1, 2, 3, 4};</p>
<p><strong>int</strong>[] primitiveArray = <strong>new
int</strong>[boxedArray.length];</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
boxedArray.length; ++i) {</p>
<p>primitiveArray[i] = boxedArray[i]; <em>// Each element is outboxed
here</em> }</p>
<p>Section 23.15: Remove an element from an array</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html">Java
doesn't provide a direct method in java.util.Arrays to remove an element
from an array. To perform it, you</a></p>
<p>can either copy the original array to a new one without the element
to remove or convert your array to another structure allowing the
removal.</p>
<p>Using ArrayList</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html">You
can convert the array to a java.util.List</a>, remove the element and
convert the list back to an array as follows:</p>
<p>String[] array = <strong>new</strong> String[]{"foo", "bar",
"baz"};</p>
<p>List list = <strong>new</strong>
ArrayList&lt;&gt;(Arrays.asList(array)); list.remove("foo");</p>
<p>// Creates a new array with the same size as the list and copies the
list // elements to it.</p>
<p>array = list.toArray(<strong>new</strong> String[list.size()]);</p>
<p>System.out.println(Arrays.toString(array)); <em>//[bar, baz]</em></p>
<p>Using System.arraycopy</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int)">System.arraycopy()</a>
can be used to make a copy of the original array and remove the element
you want. Below an example:</p>
<p><em><strong>int</strong>[] array = <strong>new int</strong>[] { 1, 2,
3, 4 };</em> // Original array. <em><strong>int</strong>[] result =
<strong>new int</strong>[array.length-1];</em> // Array which will
contain the result. <em><strong>int</strong> index = 1;</em> // Remove
the value "2".</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 129</p>
<p><span id="___Copy_the_elements_at_the_left" class="anchor"></span>//
Copy the elements at the left of the index.</p>
<p>System.arraycopy(array, 0, result, 0, index);</p>
<p>// Copy the elements at the right of the index.</p>
<p>System.arraycopy(array, index + 1, result, index, array.length- index
-1);</p>
<p>System.out.println(Arrays.toString(result)); <em>//[1, 3, 4]</em></p>
<p>Using Apache Commons Lang</p>
<p><a href="https://commons.apache.org/proper/commons-lang/">To easily
remove an element, you can use the Apache Commons Lang</a> library and
especially the static method</p>
<p><a
href="http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/ArrayUtils.html#removeElement(java.lang.Object%5B%5D,%20java.lang.Object)">removeElement()</a>
<a
href="http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/ArrayUtils.html">of
the class ArrayUtils</a>. Below an example:</p>
<p><strong>int</strong>[] array = <strong>new
int</strong>[]{1,2,3,4};</p>
<p>array = ArrayUtils.removeElement(array, 2); <em>//remove first
occurrence of 2</em> System.out.println(Arrays.toString(array));
<em>//[1, 3, 4]</em></p>
<p>Section 23.16: Comparing arrays for equality</p>
<p>Array types inherit their equals() (and hashCode()) implementations
from java.lang.Object, so equals() will only</p>
<p>return true when comparing against the exact same array object. To
compare arrays for equality based on their</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#equals-java.lang.Object:A-java.lang.Object:A-">values,
use java.util.Arrays.equals, which is overloaded for all array
types.</a></p>
<p><strong>int</strong>[] a = <strong>new int</strong>[]{1, 2, 3};</p>
<p><strong>int</strong>[] b = <strong>new int</strong>[]{1, 2, 3};</p>
<p><em>System.out.println(a.equals(b));</em> //prints "false" because a
and b refer to different objects <em>System.out.println(Arrays.equals(a,
b));</em> //prints "true" because the elements of a and b have the same
values</p>
<p>When the element type is a reference type, Arrays.equals() calls
equals() on the array elements to determine</p>
<p>equality. In particular, if the element type is itself an array type,
identity comparison will be used. To compare</p>
<p>multidimensional arrays for equality, use <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepEquals-java.lang.Object:A-java.lang.Object:A-">Arrays.deepEquals()
instead as below:</a></p>
<p><strong>int</strong> a[] = { 1, 2, 3 };</p>
<p><strong>int</strong> b[] = { 1, 2, 3 };</p>
<p><em>Object[] aObject = { a };</em> // aObject contains one element
<em>Object[] bObject = { b };</em> // bObject contains one element</p>
<p>System.out.println(Arrays.equals(aObject, bObject)); <em>//
false</em> System.out.println(Arrays.deepEquals(aObject,
bObject));<em>// true</em></p>
<p>Because sets and maps use equals() and hashCode(), arrays are
generally not useful as set elements or map keys.</p>
<p>Either wrap them in a helper class that implements equals() and
hashCode() in terms of the array elements, or</p>
<p>convert them to List instances and store the lists.</p>
<p>Section 23.17: Copying arrays</p>
<p>Java provides several ways to copy an array.</p>
<p>for loop</p>
<p><strong>int</strong>[] a = { 4, 1, 3, 2 };</p>
<p><strong>int</strong>[] b = <strong>new int</strong>[a.length];</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; a.length;
i++) {</p>
<p>b[i] = a[i];</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 130</p>
<p><span id="Note_that_using_this_option_with"
class="anchor"></span>Note that using this option with an Object array
instead of primitive array will fill the copy with reference to the
original content instead of copy of it.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone()">Object.clone()</a></p>
<p>Since arrays are Objects in Java, you can use <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#clone()">Object.clone()</a>.</p>
<p><strong>int</strong>[] a = { 4, 1, 3, 2 };</p>
<p><strong>int</strong>[] b = a.clone(); <em>// [4, 1, 3, 2]</em></p>
<p>Note that the Object.clone method for an array performs a
<strong>shallow copy</strong>, i.e. it returns a reference to a new
array</p>
<p>which references the <strong>same</strong> elements as the source
array.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#copyOf(T%5B%5D,%20int)">Arrays.copyOf()</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html">java.util.Arrays</a>
provides an easy way to perform the copy of an array to another. Here is
the basic usage:</p>
<p><strong>int</strong>[] a = {4, 1, 3, 2};</p>
<p><strong>int</strong>[] b = Arrays.copyOf(a, a.length); <em>// [4, 1,
3, 2]</em></p>
<p>Note that Arrays.copyOf also provides an overload which allows you to
change the type of the array:</p>
<p>Double[] doubles = { 1.0, 2.0, 3.0 };</p>
<p>Number[] numbers = Arrays.copyOf(doubles, doubles.length,
Number[].<strong>class</strong>);</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int)">System.arraycopy()</a></p>
<p><strong>public static void</strong> arraycopy(Object src,
<strong>int</strong> srcPos, Object dest, <strong>int</strong> destPos,
<strong>int</strong> length)</p>
<p>Copies an array from the specified source array, beginning at the
specified position, to the specified</p>
<p>position of the destination array.</p>
<p>Below an example of use</p>
<p><strong>int</strong>[] a = { 4, 1, 3, 2 };</p>
<p><strong>int</strong>[] b = <strong>new int</strong>[a.length];</p>
<p>System.arraycopy(a, 0, b, 0, a.length); <em>// [4, 1, 3, 2]</em></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#copyOfRange(T%5B%5D,%20int,%20int)">Arrays.copyOfRange()</a></p>
<p>Mainly used to copy a part of an Array, you can also use it to copy
whole array to another as below:</p>
<p><strong>int</strong>[] a = { 4, 1, 3, 2 };</p>
<p><strong>int</strong>[] b = Arrays.copyOfRange(a, 0, a.length); <em>//
[4, 1, 3, 2]</em></p>
<p>Section 23.18: Casting Arrays</p>
<p>Arrays are objects, but their type is defined by the type of the
contained objects. Therefore, one cannot just cast A[] to T[], but each
A member of the specific A[] must be cast to a T object. Generic
example:</p>
<p><strong>public static</strong> T[] castArray(T[] target, A[] array)
{</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
array.length; i++) {</p>
<p>target[i] = (T) array[i];</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 131</p>
<p>}</p>
<p><strong>return</strong> target;</p>
<p>}</p>
<p>Thus, given an A[] array:</p>
<p>T[] target = <strong>new</strong> T[array.Length];</p>
<p>target = castArray(target, array);</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#copyOf(U%5B%5D,%20int,%20java.lang.Class)">Java
SE provides the method Arrays.copyOf(original, newLength, newType) for
this purpose:</a></p>
<p>Double[] doubles = { 1.0, 2.0, 3.0 };</p>
<p>Number[] numbers = Arrays.copyOf(doubles, doubles.length,
Number[].<strong>class</strong>);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 132</p>
<p><span id="Chapter_24__Collections_1" class="anchor"></span>Chapter
24: Collections</p>
<p>The collections framework in java.util provides a number of generic
classes for sets of data with functionality that</p>
<p>can't be provided by regular arrays.</p>
<p>Collections framework contains interfaces for Collection, with main
sub-interfaces List and Set, and</p>
<p>mapping collection Map. Collections are the root interface and are
being implemented by many other collection frameworks.</p>
<p>Section 24.1: Removing items from a List within a loop</p>
<p>It is tricky to remove items from a list while within a loop, this is
due to the fact that the index and length of the list gets changed.</p>
<p>Given the following list, here are some examples that will give an
unexpected result and some that will give the</p>
<p>correct result.</p>
<p>List fruits = <strong>new</strong> ArrayList();</p>
<p>fruits.add("Apple");</p>
<p>fruits.add("Banana");</p>
<p>fruits.add("Strawberry");</p>
<p>INCORRECT</p>
<p>Removing in iteration of for statement <em>Skips "Banana":</em></p>
<p>The code sample will only print Apple and Strawberry. Banana is
skipped because it moves to index 0 once Apple is deleted, but at the
same time i gets incremented to 1.</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
fruits.size(); i++) {</p>
<p>System.out.println (fruits.get(i));</p>
<p><strong>if</strong> ("Apple".equals(fruits.get(i))) {</p>
<p>fruits.remove(i);</p>
<p>}</p>
<p>}</p>
<p>Removing in the enhanced for statement <em>Throws Exception:</em></p>
<p>Because of iterating over collection and modifying it at the same
time.</p>
<p>Throws: java.util.ConcurrentModificationException</p>
<p><strong>for</strong> (String fruit : fruits) {</p>
<p>System.out.println(fruit);</p>
<p><strong>if</strong> ("Apple".equals(fruit)) {</p>
<p>fruits.remove(fruit);</p>
<p>}</p>
<p>}</p>
<p>CORRECT</p>
<p>Removing in while loop using an Iterator</p>
<p>Iterator fruitIterator = fruits.iterator();
<strong>while</strong>(fruitIterator.hasNext()) {</p>
<p>String fruit = fruitIterator.next();</p>
<p>System.out.println(fruit);</p>
<p><strong>if</strong> ("Apple".equals(fruit)) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 133</p>
<p>fruitIterator.remove();</p>
<p>}</p>
<p>}</p>
<p>The Iterator interface has a remove() <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--">method
built in just for this case. However, this method is marked as</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--">"optional"</a>
in the documentation, and it might throw an
UnsupportedOperationException.</p>
<p>Throws: UnsupportedOperationException - if the remove operation is
not supported by this iterator</p>
<p>Therefore, it is advisable to check the documentation to make sure
this operation is supported (in practice, unless the collection is an
immutable one obtained through a 3rd party library or the use of one of
the</p>
<p>Collections.unmodifiable...() method, the operation is almost always
supported).</p>
<p>While using an Iterator a ConcurrentModificationException is thrown
when the modCount of the List is changed</p>
<p>from when the Iterator was created. This could have happened in the
same thread or in a multi-threaded application sharing the same
list.</p>
<p>A modCount is an <strong>int</strong> variable which counts the
number of times this list has been structurally modified. A structural
change essentially means an add() or remove() operation being invoked on
Collection object (changes made by</p>
<p>Iterator are not counted). When the Iterator is created, it stores
this modCount and on every iteration of the List checks if the current
modCount is same as and when the Iterator was created. If there is a
change in the modCount</p>
<p>value it throws a ConcurrentModificationException.</p>
<p>Hence for the above-declared list, an operation like below will not
throw any exception:</p>
<p>Iterator fruitIterator = fruits.iterator(); fruits.set(0,
"Watermelon");</p>
<p><strong>while</strong>(fruitIterator.hasNext()){</p>
<p>System.out.println(fruitIterator.next());</p>
<p>}</p>
<p>But adding a new element to the List after initializing an Iterator
will throw a ConcurrentModificationException:</p>
<p>Iterator fruitIterator = fruits.iterator();
fruits.add("Watermelon");</p>
<p><strong>while</strong>(fruitIterator.hasNext()){</p>
<p>System.out.println(fruitIterator.next());
<em>//ConcurrentModificationException here</em></p>
<p>}</p>
<p>Iterating backwards</p>
<p><strong>for</strong> (<strong>int</strong> i = (fruits.size()-1); i
&gt;=0; i--) {</p>
<p>System.out.println (fruits.get(i));</p>
<p><strong>if</strong> ("Apple".equals(fruits.get(i))) {</p>
<p>fruits.remove(i);</p>
<p>}</p>
<p>}</p>
<p>This does not skip anything. The downside of this approach is that
the output is reverse. However, in most cases</p>
<p>where you remove items that will not matter. You should never do this
with <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList.</a></p>
<p>Iterating forward, adjusting the loop index</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
fruits.size(); i++) {</p>
<p>System.out.println (fruits.get(i));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 134</p>
<p><span id="if___Apple__equals_fruits_get_i"
class="anchor"></span><strong>if</strong>
("Apple".equals(fruits.get(i))) {</p>
<p>fruits.remove(i);</p>
<p>i--;</p>
<p>}</p>
<p>}</p>
<p>This does not skip anything. When the ith element is removed from the
List, the element originally positioned at index i+1 becomes the new ith
element. Therefore, the loop can decrement i in order for the next
iteration to</p>
<p>process the next element, without skipping.</p>
<p>Using a "should-be-removed" list</p>
<p>ArrayList shouldBeRemoved = <strong>new</strong> ArrayList();</p>
<p><strong>for</strong> (String str : currentArrayList) {</p>
<p><strong>if</strong> (condition) {</p>
<p>shouldBeRemoved.add(str);</p>
<p>}</p>
<p>}</p>
<p>currentArrayList.removeAll(shouldBeRemoved);</p>
<p>This solution enables the developer to check if the correct elements
are removed in a cleaner way.</p>
<p>Version ≥ Java SE 8</p>
<p>In Java 8 the following alternatives are possible. These are cleaner
and more straight forward if the removing does not have to happen in a
loop.</p>
<p>Filtering a Stream</p>
<p>A List can be streamed and filtered. A proper filter can be used to
remove all undesired elements.</p>
<p>List filteredList =</p>
<p>fruits.stream().filter(p -&gt;
!"Apple".equals(p)).collect(Collectors.toList());</p>
<p>Note that unlike all the other examples here, this example produces a
new List instance and keeps the original</p>
<p>List unchanged.</p>
<p>Using removeIf</p>
<p>Saves the overhead of constructing a stream if all that is needed is
to remove a set of items.</p>
<p>fruits.removeIf(p -&gt; "Apple".equals(p));</p>
<p>Section 24.2: Constructing collections from existing data</p>
<p>Standard Collections</p>
<p>Java Collections framework</p>
<p>A simple way to construct a List from individual data values is to
use java.utils.Arrays method Arrays.asList:</p>
<p>List data = Arrays.asList("ab", "bc", "cd", "ab", "bc", "cd");</p>
<p>All standard collection implementations provide constructors that
take another collection as an argument adding all</p>
<p>elements to the new collection at the time of construction:</p>
<p><em>List list = <strong>new</strong> ArrayList&lt;&gt;(data);</em> //
will add data as is <em>Set set1 = <strong>new</strong>
HashSet&lt;&gt;(data);</em> // will add data keeping only unique
values</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 135</p>
<p><em>SortedSet set2 = <strong>new</strong> TreeSet&lt;&gt;(data);</em>
// will add data keeping unique values and sorting <em>Set set3 =
<strong>new</strong> LinkedHashSet&lt;&gt;(data);</em> // will add data
keeping only unique values and preserving the original order</p>
<p>Google Guava Collections framework</p>
<p>Another great framework is Google Guava that is amazing utility class
(providing convenience static methods) for construction of different
types of standard collections Lists and Sets:</p>
<p><strong>import</strong> com.google.common.collect.Lists;</p>
<p><strong>import</strong> com.google.common.collect.Sets;</p>
<p>...</p>
<p>List list1 = Lists.newArrayList("ab", "bc", "cd");</p>
<p>List list2 = Lists.newArrayList(data);</p>
<p>Set set4 = Sets.newHashSet(data);</p>
<p>SortedSet set5 = Sets.newTreeSet("bc", "cd", "ab", "bc", "cd");</p>
<p>Mapping Collections</p>
<p>Java Collections framework</p>
<p>Similarly for maps, given a Map map a new map can be constructed with
all elements as follows:</p>
<p>Map map1 = <strong>new</strong> HashMap&lt;&gt;(map);</p>
<p>SortedMap map2 = <strong>new</strong> TreeMap&lt;&gt;(map);</p>
<p>Apache Commons Collections framework</p>
<p>Using Apache Commons you can create Map using array in
ArrayUtils.toMap as well as MapUtils.toMap:</p>
<p><strong>import</strong> org.apache.commons.lang3.ArrayUtils;</p>
<p>...</p>
<p>// Taken from org.apache.commons.lang.ArrayUtils#toMap JavaDoc</p>
<p>// Create a Map mapping colors.</p>
<p>Map colorMap = MapUtils.toMap(<strong>new</strong> String[][] {{</p>
<p>{"RED", "#FF0000"},</p>
<p>{"GREEN", "#00FF00"},</p>
<p>{"BLUE", "#0000FF"}});</p>
<p>Each element of the array must be either a Map.Entry or an Array,
containing at least two elements, where the first</p>
<p>element is used as key and the second as value.</p>
<p>Google Guava Collections framework</p>
<p>Utility class from Google Guava framework is named Maps:</p>
<p><strong>import</strong> com.google.common.collect.Maps;</p>
<p>...</p>
<p><strong>void</strong> howToCreateMapsMethod(Functionsuper K,V&gt;
valueFunction,</p>
<p>Iterable keys1,</p>
<p>Set keys2,</p>
<p>SortedSet keys3) {</p>
<p>ImmutableMap map1 = toMap(keys1, valueFunction); <em>// Immutable
copy</em></p>
<p>Map map2 = asMap(keys2, valueFunction); <em>// Live Map view</em></p>
<p>SortedMap map3 = toMap(keys3, valueFunction); <em>// Live Map
view</em></p>
<p>}</p>
<p>Version ≥ Java SE 8</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 136</p>
<p><span id="Using_Stream" class="anchor"></span>Using <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>,</p>
<p>Stream.of("xyz", "abc").collect(Collectors.toList());</p>
<p>or</p>
<p>Arrays.stream("xyz", "abc").collect(Collectors.toList());</p>
<p>Section 24.3: Declaring an ArrayList and adding objects</p>
<p>We can create an ArrayList (following the List interface):</p>
<p>List aListOfFruits = <strong>new</strong> ArrayList();</p>
<p>Version ≥ Java SE 5</p>
<p>List aListOfFruits = <strong>new</strong> ArrayList();</p>
<p>Version ≥ Java SE 7</p>
<p>List aListOfFruits = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>Now, use the method add to add a String:</p>
<p>aListOfFruits.add("Melon");</p>
<p>aListOfFruits.add("Strawberry");</p>
<p>In the above example, the ArrayList will contain the String "Melon"
at index 0 and the String "Strawberry" at</p>
<p>index 1.</p>
<p>Also we can add multiple elements with addAll(Collectionextends E&gt;
c) method</p>
<p>List aListOfFruitsAndVeggies = <strong>new</strong> ArrayList();
aListOfFruitsAndVeggies.add("Onion");</p>
<p>aListOfFruitsAndVeggies.addAll(aListOfFruits);</p>
<p>Now "Onion" is placed at 0 index in aListOfFruitsAndVeggies, "Melon"
is at index 1 and "Strawberry" is at index 2.</p>
<p>Section 24.4: Iterating over Collections</p>
<p>Iterating over List</p>
<p>List names = <strong>new</strong>
ArrayList&lt;&gt;(Arrays.asList("Clementine", "Duran", "Mike"));</p>
<p>Version ≥ Java SE 8</p>
<p>names.<strong>forEach</strong>(System.out::println);</p>
<p>If we need parallelism use</p>
<p>names.parallelStream().<strong>forEach</strong>(System.out::println);</p>
<p>Version ≥ Java SE 5</p>
<p><strong>for</strong> (String name : names) {</p>
<p>System.out.println(name);</p>
<p>}</p>
<p>Version &lt; Java SE 5</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
names.size(); i++) {</p>
<p>System.out.println(names.get(i));</p>
<p>}</p>
<p>Version ≥ Java SE 1.2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 137</p>
<p>//Creates ListIterator which supports both forward as well as
backward traversel <em>ListIterator listIterator =
names.listIterator();</em></p>
<p>//Iterates list in forward direction</p>
<p><strong>while</strong>(listIterator.hasNext()){</p>
<p>System.out.println(listIterator.next());</p>
<p>}</p>
<p>//Iterates list in backward direction once reaches the last element
from above iterator in forward direction</p>
<p><strong>while</strong>(listIterator.hasPrevious()){</p>
<p>System.out.println(listIterator.previous());</p>
<p>}</p>
<p>Iterating over Set</p>
<p>Set names = <strong>new</strong>
HashSet&lt;&gt;(Arrays.asList("Clementine", "Duran", "Mike"));</p>
<p>Version ≥ Java SE 8</p>
<p>names.<strong>forEach</strong>(System.out::println);</p>
<p>Version ≥ Java SE 5</p>
<p><strong>for</strong> (Iterator iterator = names.iterator();
iterator.hasNext(); ) {</p>
<p>System.out.println(iterator.next());</p>
<p>}</p>
<p><strong>for</strong> (String name : names) {</p>
<p>System.out.println(name);</p>
<p>}</p>
<p>Version &lt; Java SE 5</p>
<p>Iterator iterator = names.iterator();</p>
<p><strong>while</strong> (iterator.hasNext()) {</p>
<p>System.out.println(iterator.next());</p>
<p>}</p>
<p>Iterating over Map</p>
<p>Map names = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>names.put(1, "Clementine");</p>
<p>names.put(2, "Duran");</p>
<p>names.put(3, "Mike");</p>
<p>Version ≥ Java SE 8</p>
<p>names.<strong>forEach</strong>((key, value)-&gt;
System.out.println("Key: " + key + " Value: " + value));</p>
<p>Version ≥ Java SE 5</p>
<p><strong>for</strong> (Map.Entry entry : names.entrySet()) {</p>
<p>System.out.println(entry.getKey());</p>
<p>System.out.println(entry.getValue());</p>
<p>}</p>
<p>// Iterating over only keys</p>
<p><strong>for</strong> (Integer key : names.keySet()) {</p>
<p>System.out.println(key);</p>
<p>}</p>
<p>// Iterating over only values</p>
<p><strong>for</strong> (String value : names.values()) {</p>
<p>System.out.println(value);</p>
<p>}</p>
<p>Version &lt; Java SE 5</p>
<p>Iterator entries = names.entrySet().iterator();</p>
<p><strong>while</strong> (entries.hasNext()) {</p>
<p>Map.Entry entry = (Map.Entry) entries.next();</p>
<p>System.out.println(entry.getKey());</p>
<p>System.out.println(entry.getValue());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 138</p>
<p><span id="_4" class="anchor"></span>}</p>
<p>Section 24.5: Immutable Empty Collections</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html">Sometimes
it is appropriate to use an immutable empty collection. The Collections
class provides methods to get</a> such collections in an efficient
way:</p>
<p>List anEmptyList = Collections.emptyList(); Map anEmptyMap =
Collections.emptyMap(); Set anEmptySet = Collections.emptySet();</p>
<p>These methods are generic and will automatically convert the returned
collection to the type it is assigned to. That</p>
<p>is, an invocation of e.g. emptyList() can be assigned to any type of
List and likewise for emptySet() and emptyMap() .</p>
<p>The collections returned by these methods are immutable in that they
will throw UnsupportedOperationException if you attempt to call methods
which would change their contents (add, put, etc.). These collections
are primarily</p>
<p>useful as substitutes for empty method results or other default
values, instead of using <strong>null</strong> or creating objects with
<strong>new</strong>.</p>
<p>Section 24.6: Sub Collections</p>
<p>List subList(int fromIndex, int toIndex)</p>
<p>Here fromIndex is inclusive and toIndex is exclusive.</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>List list1 = list.subList(fromIndex,toIndex);</p>
<p>1. If the list doesn't exist in the give range, it throws
IndexOutofBoundException. 2. What ever changes made on the list1 will
impact the same changes in the list.This is called backed
collections.</p>
<p>3. If the fromnIndex is greater than the toIndex (fromIndex &gt;
toIndex) it throws IllegalArgumentException.</p>
<p>Example:</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>list.add("Hello1");</p>
<p>list.add("Hello2");</p>
<p>System.out.println("Before Sublist "+list);</p>
<p>List list2 = list.subList(0, 1);</p>
<p>list2.add("Hello3");</p>
<p>System.out.println("After sublist changes "+list);</p>
<p>Output:</p>
<p>Before Sublist [Hello1, Hello2]</p>
<p>After sublist changes [Hello1, Hello3, Hello2]</p>
<p>Set subSet(fromIndex,toIndex)</p>
<p>Here fromIndex is inclusive and toIndex is exclusive.</p>
<p>Set set = <strong>new</strong> TreeSet();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 139</p>
<p><span id="Set_set1___set_subSet_fromIndex" class="anchor"></span>Set
set1 = set.subSet(fromIndex,toIndex);</p>
<p>The returned set will throw an IllegalArgumentException on an attempt
to insert an element outside its range.</p>
<p>Map subMap(fromKey,toKey)</p>
<p>fromKey is inclusive and toKey is exclusive</p>
<p>Map map = <strong>new</strong> TreeMap();</p>
<p>Map map1 = map.get(fromKey,toKey);</p>
<p>If fromKey is greater than toKey or if this map itself has a
restricted range, and fromKey or toKey lies outside the bounds of the
range then it throws IllegalArgumentException.</p>
<p>All the collections support backed collections means changes made on
the sub collection will have same change on</p>
<p>the main collection.</p>
<p>Section 24.7: Unmodifiable Collection</p>
<p>Sometimes it's not a good practice expose an internal collection
since it can lead to a malicious code vulnerability</p>
<p>due to it's mutable characteristic. In order to provide "read-only"
collections java provides its unmodifiable versions.</p>
<p>An unmodifiable collection is often a copy of a modifiable collection
which guarantees that the collection itself</p>
<p>cannot be altered. Attempts to modify it will result in an
UnsupportedOperationException exception.</p>
<p>It is important to notice that objects which are present inside the
collection can still be altered.</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.Collections;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>public class</strong> MyPojoClass {</p>
<p><strong>private</strong> List intList = <strong>new</strong>
ArrayList&lt;&gt;();</p>
<p><strong>public void</strong> addValueToIntList(Integer value){</p>
<p>intList.add(value);</p>
<p>}</p>
<p><strong>public</strong> List getIntList() {</p>
<p><strong>return</strong> Collections.unmodifiableList(intList);</p>
<p>}</p>
<p>}</p>
<p>The following attempt to modify an unmodifiable collection will throw
an exception:</p>
<p><strong>import</strong> java.util.List;</p>
<p>public class <strong>App {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>MyPojoClass pojo = <strong>new</strong> MyPojoClass();</p>
<p>pojo.addValueToIntList(42);</p>
<p>List list = pojo.getIntList();</p>
<p>list.add(69);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 140</p>
<p><span id="output" class="anchor"></span>output:</p>
<p>Exception in thread "main" java.lang.UnsupportedOperationException at
java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)
at App.main(App.java:12)</p>
<p>Section 24.8: Pitfall: concurrent modification exceptions</p>
<p>This exception occurs when a collection is modified while iterating
over it using methods other than those provided</p>
<p>by the iterator object. For example, we have a list of hats and we
want to remove all those that have ear flaps:</p>
<p>List hats = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><em>hats.add(<strong>new</strong> Ushanka());</em> // that one has
ear flaps</p>
<p>hats.add(<strong>new</strong> Fedora());</p>
<p>hats.add(<strong>new</strong> Sombrero());</p>
<p><strong>for</strong> (IHat hat : hats) {</p>
<p><strong>if</strong> (hat.hasEarFlaps()) {</p>
<p>hats.remove(hat);</p>
<p>}</p>
<p>}</p>
<p>If we run this code,
<em><strong>ConcurrentModificationException</strong></em> will be raised
since the code modifies the collection while</p>
<p>iterating it. The same exception may occur if one of the multiple
threads working with the same list is trying to modify the collection
while others iterate over it. Concurrent modification of collections in
multiple threads is a</p>
<p>natural thing, but should be treated with usual tools from the
concurrent programming toolbox such as</p>
<p>synchronization locks, special collections adopted for concurrent
modification, modifying the cloned collection from initial etc.</p>
<p>Section 24.9: Removing matching items from Lists using</p>
<p>Iterator</p>
<p>Above I noticed an example to remove items from a List within a Loop
and I thought of another example that may come in handy this time using
the Iterator interface.</p>
<p>This is a demonstration of a trick that might come in handy when
dealing with duplicate items in lists that you want to get rid of.</p>
<p>Note: This is only adding on to the <strong>Removing items from a
List within a loop</strong> example:</p>
<p>So let's define our lists as usual</p>
<p>String[] names =
{"James","Smith","Sonny","Huckle","Berry","Finn","Allan"};</p>
<p>List nameList = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>//Create a List from an Array</p>
<p>nameList.addAll(Arrays.asList(names));</p>
<p>String[] removeNames = {"Sonny","Huckle","Berry"};</p>
<p>List removeNameList = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>//Create a List from an Array</p>
<p>removeNameList.addAll(Arrays.asList(removeNames));</p>
<p>The following method takes in two Collection objects and performs the
magic of removing the elements in our</p>
<p>removeNameList that match with elements in nameList.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 141</p>
<p><span id="private_static_void_removeNames"
class="anchor"></span><strong>private static void</strong>
removeNames(Collection collection1, Collection collection2) {</p>
<p>//get Iterator.</p>
<p>Iterator iterator = collection1.iterator();</p>
<p>//Loop while collection has items</p>
<p><strong>while</strong>(iterator.hasNext()){</p>
<p><strong>if</strong> (collection2.contains(iterator.next()))</p>
<p><em>iterator.remove();</em> //remove the current Name or Item</p>
<p>}</p>
<p>}</p>
<p>Calling the method and passing in the nameList and the
removeNameListas follows removeNames(nameList,removeNameList);</p>
<p>Will produce the following output:</p>
<p><strong>Array List before removing names:</strong> James Smith Sonny
Huckle Berry Finn Allan</p>
<p>Array List after removing names: <strong>James Smith Finn
Allan</strong></p>
<p>A simple neat use for Collections that may come in handy to remove
repeating elements within lists.</p>
<p>Section 24.10: Join lists</p>
<p>Following ways can be used for joining lists without modifying source
list(s).</p>
<p>First approach. Has more lines but easy to understand</p>
<p>List newList = <strong>new</strong> ArrayList();</p>
<p>newList.addAll(listOne);</p>
<p>newList.addAll(listTwo);</p>
<p>Second approach. Has one less line but less readable.</p>
<p>List newList = <strong>new</strong> ArrayList(listOne);
newList.addAll(listTwo);</p>
<p>Third approach. Requires third party <a
href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/ListUtils.html">Apache
commons-collections library.</a></p>
<p>ListUtils.union(listOne,listTwo);</p>
<p>Version ≥ Java SE 8</p>
<p>Using Streams the same can be achieved by</p>
<p>List newList = Stream.concat(listOne.stream(),
listTwo.stream()).collect(Collectors.toList());</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-java.util.Collection-">References.
Interface List</a></p>
<p>Section 24.11: Creating your own Iterable structure for use</p>
<p>with Iterator or for-each loop</p>
<p>To ensure that our collection can be iterated using iterator or
for-each loop, we have to take care of following steps:</p>
<p>1. The stuff we want to iterate upon has to be Iterable and expose
iterator().</p>
<p>2. Design a java.util.Iterator by overriding hasNext(), next() and
remove().</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 142</p>
<p>I have added a simple generic linked list implementation below that
uses above entities to make the linked list iterable.</p>
<p><strong>package</strong> org.algorithms.linkedlist;</p>
<p><strong>import</strong> java.util.Iterator;</p>
<p><strong>import</strong> java.util.NoSuchElementException;</p>
<p><strong>public class</strong> LinkedList <strong>implements</strong>
Iterable {</p>
<p>Node head, current;</p>
<p>private static class <strong>Node {</strong></p>
<p>T data;</p>
<p>Node next;</p>
<p>Node(T data) {</p>
<p><strong>this</strong>.data = data;</p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> LinkedList(T data) {</p>
<p>head = <strong>new</strong> Node&lt;&gt;(data);</p>
<p>}</p>
<p><strong>public</strong> Iterator iterator() {</p>
<p><strong>return new</strong> LinkedListIterator();</p>
<p>}</p>
<p><strong>private class</strong> LinkedListIterator
<strong>implements</strong> Iterator {</p>
<p>Node node = head;</p>
<p>@Override</p>
<p>public boolean <strong>hasNext() {</strong></p>
<p>return <strong>node !=</strong> null<strong>;</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> T next() {</p>
<p><strong>if</strong> (!hasNext())</p>
<p><strong>throw new</strong> NoSuchElementException();</p>
<p>Node prevNode = node;</p>
<p>node = node.next;</p>
<p><strong>return</strong> prevNode.data;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>remove() {</strong></p>
<p><strong>throw new</strong> UnsupportedOperationException("Removal
logic not implemented.");</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> add(T data) {</p>
<p>Node current = head;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 143</p>
<p><span id="while__current_next____null"
class="anchor"></span><strong>while</strong> (current.next !=
<strong>null</strong>)</p>
<p>current = current.next;</p>
<p>current.next = <strong>new</strong> Node&lt;&gt;(data);</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> App {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>LinkedList list = <strong>new</strong> LinkedList&lt;&gt;(1);</p>
<p>list.add(2);</p>
<p>list.add(4);</p>
<p>list.add(3);</p>
<p>//Test #1</p>
<p>System.out.println("using Iterator:");</p>
<p>Iterator itr = list.iterator();</p>
<p><strong>while</strong> (itr.hasNext()) {</p>
<p>Integer i = itr.next();</p>
<p>System.out.print(i + " ");</p>
<p>}</p>
<p>//Test #2</p>
<p>System.out.println("<strong>\n\n</strong>using for-each:");</p>
<p><strong>for</strong> (Integer data : list) {</p>
<p>System.out.print(data + " ");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output</p>
<p>using Iterator:</p>
<p>1 2 4 3</p>
<p>using for-each:</p>
<p>1 2 4 3</p>
<p>This will run in Java 7+. You can make it run on Java 5 and Java 6
also by substituting:</p>
<p>LinkedList list = <strong>new</strong> LinkedList&lt;&gt;(1);</p>
<p>with</p>
<p>LinkedList list = <strong>new</strong> LinkedList(1);</p>
<p>or just any other version by incorporating the compatible
changes.</p>
<p>Section 24.12: Collections and Primitive Values</p>
<p>Collections in Java only work for objects. I.e. there is no
Map&lt;<strong>int</strong>, int&gt; in Java. Instead, primitive values
need to be <em>boxed</em> into objects, as in Map. Java auto-boxing will
enable transparent use of these collections:</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 144</p>
<p><em>map.put(1, 17);</em> // Automatic boxing of int to Integer
objects <em><strong>int</strong> a = map.get(1);</em> // Automatic
unboxing.</p>
<p>Unfortunately, the overhead of this is <em>substantial</em>. A
HashMap will require about 72 bytes per</p>
<p>entry (e.g. on 64-bit JVM with compressed pointers, and assuming
integers larger than 256, and assuming 50% load of the map). Because the
actual data is only 8 bytes, this yields a massive overhead.
Furthermore, it requires two</p>
<p>level of indirection (Map -&gt; Entry -&gt; Value) it is
unnecessarily slow.</p>
<p>There exist several libraries with optimized collections for
primitive data types (that require only ~16 bytes per entry</p>
<p>at 50% load, i.e. 4x less memory, and one level of indirection less),
that can yield substantial performance benefits when using large
collections of primitive values in Java.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 145</p>
<p><span id="Chapter_25__Lists_1" class="anchor"></span>Chapter 25:
Lists</p>
<p>A <em>list</em> is an <em>ordered</em> collection of values. In Java,
lists are part of the <a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html">Java
Collections Framework</a>. Lists implement the</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html">java.util.List
interface, which extends</a> <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">java.util.Collection.</a></p>
<p>Section 25.1: Sorting a generic list</p>
<p>The Collections class offers two standard static methods to sort a
list:</p>
<p>sort(List list) applicable to lists where T <strong>extends</strong>
Comparablesuper T&gt;, and</p>
<p>sort(List list, Comparatorsuper T&gt; c) applicable to lists of any
type.</p>
<p>Applying the former requires amending the class of list elements
being sorted, which is not always possible. It</p>
<p>might also be undesirable as although it provides the default
sorting, other sorting orders may be required in different
circumstances, or sorting is just a one off task.</p>
<p>Consider we have a task of sorting objects that are instances of the
following class:</p>
<p>public class <strong>User {</strong></p>
<p>public final <strong>Long id;</strong></p>
<p><strong>public final</strong> String username;</p>
<p><strong>public</strong> User(Long id, String username) {</p>
<p><strong>this</strong>.id = id;</p>
<p><strong>this</strong>.username = username;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> String.format("%s:%d", username, id);</p>
<p>}</p>
<p>}</p>
<p>In order to use Collections.sort(List list) we need to modify the
User class to implement the Comparable interface. For example</p>
<p>public class <strong>User</strong> implements <strong>Comparable
{</strong></p>
<p>public final <strong>Long id;</strong></p>
<p><strong>public final</strong> String username;</p>
<p><strong>public</strong> User(Long id, String username) {</p>
<p><strong>this</strong>.id = id;</p>
<p><strong>this</strong>.username = username;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> String.format("%s:%d", username, id);</p>
<p>}</p>
<p>@Override</p>
<p>/** The natural ordering for 'User' objects is by the 'id' field. */
<em>public int <strong>compareTo(User o) {</strong></em></p>
<p><strong>return</strong> id.compareTo(o.id);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 146</p>
<p><span id="_Aside__many_standard_Java_class"
class="anchor"></span>(Aside: many standard Java classes such as String,
Long, Integer implement the Comparable interface. This makes lists of
those elements sortable by default, and simplifies implementation of
compare or compareTo in other classes.)</p>
<p>With the modification above, the we can easily sort a list of User
objects based on the classes <em>natural ordering</em>. (In this case,
we have defined that to be ordering based on id values). For
example:</p>
<p>List users = Lists.newArrayList(</p>
<p><strong>new</strong> User(33L, "A"),</p>
<p><strong>new</strong> User(25L, "B"),</p>
<p><strong>new</strong> User(28L, ""));</p>
<p>Collections.sort(users);</p>
<p>System.out.print(users);</p>
<p>// [B:25, C:28, A:33]</p>
<p>However, suppose that we wanted to sort User objects by name rather
than by id. Alternatively, suppose that we had not been able to change
the class to make it implement Comparable.</p>
<p>This is where the sort method with the Comparator argument is
useful:</p>
<p>Collections.sort(users, <strong>new</strong> Comparator() {</p>
<p>@Override</p>
<p>/* Order two 'User' objects based on their names. */
<em><strong>public int</strong> compare(User left, User right)
{</em></p>
<p><strong>return</strong> left.username.compareTo(right.username);</p>
<p>}</p>
<p>});</p>
<p>System.out.print(users);</p>
<p>// [A:33, B:25, C:28]</p>
<p>Version ≥ Java SE 8</p>
<p>In Java 8 you can use a <em>lambda</em> instead of an anonymous
class. The latter reduces to a one-liner:</p>
<p>Collections.sort(users, (l, r)-&gt;
l.username.compareTo(r.username));</p>
<p>Further, there Java 8 adds a default sort method on the List
interface, which simplifies sorting even more.</p>
<p>users.sort((l, r)-&gt; l.username.compareTo(r.username))</p>
<p>Section 25.2: Convert a list of integers to a list of strings</p>
<p>List nums = Arrays.asList(1, 2, 3);</p>
<p>List strings = nums.stream()</p>
<p>.map(Object::toString)</p>
<p>.collect(Collectors.toList());</p>
<p>That is:</p>
<p>1. Create a stream from the list</p>
<p>2. Map each element using Object::toString</p>
<p>3. Collect the String values into a List using
Collectors.toList()</p>
<p>Section 25.3: Classes implementing List - Pros and Cons</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html">The
List interface is implemented by different classes. Each of them has its
own way for implementing it with</a></p>
<p>different strategies and providing different pros and cons.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 147</p>
<p>Classes implementing List</p>
<p>These are all of the <strong>public</strong> classes in Java SE 8
that implement the java.util.List interface:</p>
<p><strong>1.</strong> Abstract Classes:</p>
<p>AbstractList</p>
<p>AbstractSequentialList</p>
<p><strong>2.</strong> Concrete Classes:</p>
<p>ArrayList</p>
<p>AttributeList</p>
<p>CopyOnWriteArrayList</p>
<p>LinkedList</p>
<p>RoleList</p>
<p>RoleUnresolvedList</p>
<p>Stack</p>
<p>Vector</p>
<p>Pros and Cons of each implementation in term of time complexity</p>
<p>ArrayList</p>
<p>public class <strong>ArrayList</strong></p>
<p><strong>extends</strong> AbstractList</p>
<p><strong>implements</strong> List, RandomAccess, Cloneable,
Serializable</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html">ArrayList</a>
is a resizable-array implementation of the List interface. Storing the
list into an array, <em>ArrayList</em> provides methods (in addition to
the methods implementing the <em>List</em> interface) for manipulating
the size of the array.</p>
<p>Initialize ArrayList of Integer with size 100</p>
<p><em>List myList = <strong>new</strong> ArrayList(100);</em> //
Constructs an empty list with the specified initial capacity.</p>
<p>- PROS:</p>
<p>The size, isEmpty, <em><strong>get</strong></em>,
<em><strong>set</strong></em>, iterator, and listIterator operations run
in constant time. So getting and setting each</p>
<p>element of the List has the same <em>time cost</em>:</p>
<p><strong>int</strong> e1 = myList.get(0); <em>// \</em></p>
<p><em><strong>int</strong> e2 = myList.get(10);</em> // | =&gt; All the
same constant cost =&gt; O(1) <em>myList.set(2,10);</em> // /</p>
<p>- CONS:</p>
<p>Being implemented with an array (static structure) adding elements
over the size of the array has a big cost due to</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html">the
fact that a new allocation need to be done for all the array. However,
from documentation</a>:</p>
<p>The add operation runs in amortized constant time, that is, adding n
elements requires O(n) time</p>
<p>Removing an element requires O(n) time.</p>
<p>AttributeList</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 148</p>
<p>On coming</p>
<p>CopyOnWriteArrayList</p>
<p>On coming</p>
<p>LinkedList</p>
<p>public class <strong>LinkedList</strong></p>
<p><strong>extends</strong> AbstractSequentialList</p>
<p><strong>implements</strong> List, Deque, Cloneable, Serializable</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html">LinkedList
is implemented by a</a> <a
href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly-linked
list</a> a linked data structure that consists of a set of sequentially
linked records called nodes.</p>
<p>Iitialize LinkedList of Integer</p>
<p>List myList = <strong>new</strong> LinkedList(); <em>// Constructs an
empty list.</em></p>
<p>- PROS:</p>
<p>Adding or removing an element to the front of the list or to the end
has constant time.</p>
<p>myList.add(10); <em>// \</em></p>
<p><em>myList.add(0,2);</em> // | =&gt; constant time =&gt; O(1)</p>
<p>myList.remove(); <em>// /</em></p>
<p><strong>- CONS:</strong> <a
href="https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html">From
documentation</a>:</p>
<p>Operations that index into the list will traverse the list from the
beginning or the end, whichever is closer to the specified index.</p>
<p>Operations such as:</p>
<p>myList.get(10); <em>// \</em></p>
<p>myList.add(11,25); <em>// | =&gt; worst case done in O(n/2)</em>
myList.set(15,35); <em>// /</em></p>
<p>RoleList</p>
<p>On coming</p>
<p>RoleUnresolvedList</p>
<p>On coming</p>
<p>Stack</p>
<p>On coming</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 149</p>
<p><span id="Vector" class="anchor"></span>Vector</p>
<p>On coming</p>
<p>Section 25.4: Finding common elements between 2 lists</p>
<p>Suppose you have two lists: A and B, and you need to find the
elements that exist in both lists.</p>
<p>You can do it by just invoking the method List.retainAll().</p>
<p>Example:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List numbersA = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>List numbersB = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>numbersA.addAll(Arrays.asList(<strong>new</strong> Integer[] { 1, 3,
4, 7, 5, 2 }));</p>
<p>numbersB.addAll(Arrays.asList(<strong>new</strong> Integer[] { 13,
32, 533, 3, 4, 2 }));</p>
<p>System.out.println("A: " + numbersA);</p>
<p>System.out.println("B: " + numbersB);</p>
<p>List numbersC = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>numbersC.addAll(numbersA);</p>
<p>numbersC.retainAll(numbersB);</p>
<p>System.out.println("List A : " + numbersA);</p>
<p>System.out.println("List B : " + numbersB);</p>
<p>System.out.println("Common elements between A and B: " +
numbersC);</p>
<p>}</p>
<p>Section 25.5: In-place replacement of a List element</p>
<p>This example is about replacing a List element while ensuring that
the replacement element is at the same position as the element that is
replaced.</p>
<p>This can be done using these methods:</p>
<p>set(int index, T type)</p>
<p>int indexOf(T type)</p>
<p>Consider an ArrayList containing the elements "Program starting!",
"Hello world!" and "Goodbye world!"</p>
<p>List strings = <strong>new</strong> ArrayList();</p>
<p>strings.add("Program starting!");</p>
<p>strings.add("Hello world!");</p>
<p>strings.add("Goodbye world!");</p>
<p>If we know the index of the element we want to replace, we can simply
use set as follows:</p>
<p>strings.set(1, "Hi world");</p>
<p>If we don't know the index, we can search for it first. For
example:</p>
<p><strong>int</strong> pos = strings.indexOf("Goodbye world!");</p>
<p><strong>if</strong> (pos &gt;= 0) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 150</p>
<p><span id="strings_set_pos___Goodbye_cruel"
class="anchor"></span>strings.set(pos, "Goodbye cruel world!");</p>
<p>}</p>
<p>Notes:</p>
<p>1. The set operation will not cause a
ConcurrentModificationException. 2. The set operation is fast ( O(1) )
for ArrayList but slow ( O(N) ) for a LinkedList.</p>
<p>3. An indexOf search on an ArrayList or LinkedList is slow ( O(N)
).</p>
<p>Section 25.6: Making a list unmodifiable</p>
<p>The Collections class provides a way to make a list unmodifiable:</p>
<p>List ls = <strong>new</strong> ArrayList();</p>
<p>List unmodifiableList = Collections.unmodifiableList(ls);</p>
<p>If you want an unmodifiable list with one item you can use:</p>
<p>List unmodifiableList = Collections.singletonList("Only string in the
list");</p>
<p>Section 25.7: Moving objects around in the list</p>
<p>The Collections class allows for you to move objects around in the
list using various methods (ls is the List):</p>
<p>Reversing a list:</p>
<p>Collections.reverse(ls);</p>
<p>Rotating positions of elements in a list</p>
<p>The rotate method requires an integer argument. This is how many
spots to move it along the line by. An example</p>
<p>of this is below:</p>
<p>List ls = <strong>new</strong> ArrayList();</p>
<p>ls.add(" how");</p>
<p>ls.add(" are");</p>
<p>ls.add(" you?");</p>
<p>ls.add("hello,");</p>
<p>Collections.rotate(ls, 1);</p>
<p><strong>for</strong>(String line : ls) System.out.print(line);</p>
<p>System.out.println();</p>
<p>This will print "hello, how are you?"</p>
<p>Shuffling elements around in a list</p>
<p>Using the same list above, we can shuffle the elements in a list:</p>
<p>Collections.shuffle(ls);</p>
<p>We can also give it a java.util.Random object that it uses to
randomly place objects in spots:</p>
<p>Random random = <strong>new</strong> Random(12);</p>
<p>Collections.shuffle(ls, random);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 151</p>
<p><span id="Section_25_8__Creating__Adding_a"
class="anchor"></span>Section 25.8: Creating, Adding and Removing
element from</p>
<p>an ArrayList</p>
<p>ArrayList is one of the inbuilt data structures in Java. It is a
dynamic array (where the size of the data structure not needed to be
declared first) for storing elements (Objects).</p>
<p>It extends AbstractList class and implements List interface. An
ArrayList can contain duplicate elements where it maintains insertion
order. It should be noted that the class ArrayList is non-synchronized,
so care should be</p>
<p>taken when handling concurrency with ArrayList. ArrayList allows
random access because array works at the index basis. Manipulation is
slow in ArrayList because of shifting that often occurs when an element
is removed</p>
<p>from the array list.</p>
<p>An ArrayList can be created as follows:</p>
<p>List myArrayList = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>Where T ( Generics ) is the type that will be stored inside
ArrayList.</p>
<p>The type of the ArrayList <a
href="https://en.wikipedia.org/wiki/Primitive_wrapper_class">can be any
Object. The type can't be a primitive type (use their <em>wrapper
classes</em></a> instead).</p>
<p>To add an element to the ArrayList, use add() method:</p>
<p>myArrayList.add(element);</p>
<p>Or to add item to a certain index:</p>
<p><em>myArrayList.add(index, element);</em> //index of the element
should be an int (starting from 0)</p>
<p>To remove an item from the ArrayList, use the remove() method:</p>
<p>myArrayList.remove(element);</p>
<p>Or to remove an item from a certain index:</p>
<p><em>myArrayList.remove(index);</em> //index of the element should be
an int (starting from 0)</p>
<p>Section 25.9: Creating a List</p>
<p>Giving your list a type</p>
<p>To create a list you need a type (any class, e.g. String). This is
the type of your List. The List will only store objects</p>
<p>of the specified type. For example:</p>
<p>List strings;</p>
<p>Can store "string1", "hello world!", "goodbye", etc, but it can't
store 9.2, however:</p>
<p>List doubles;</p>
<p>Can store 9.2, but not "hello world!".</p>
<p>Initialising your list</p>
<p>If you try to add something to the lists above you will get a
NullPointerException, because strings and doubles</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 152</p>
<p><span id="both_equal_null" class="anchor"></span>both equal
<strong>null</strong>!</p>
<p>There are two ways to initialise a list:</p>
<p>Option 1: Use a class that implements List</p>
<p>List is an interface, which means that does not have a constructor,
rather methods that a class must override.</p>
<p>ArrayList is the most commonly used List, though LinkedList is also
common. So we initialise our list like this:</p>
<p>List strings = <strong>new</strong> ArrayList();</p>
<p>or</p>
<p>List strings = <strong>new</strong> LinkedList();</p>
<p>Version ≥ Java SE 7</p>
<p>Starting from Java SE 7, you can use a <em>diamond operator</em>:</p>
<p>List strings = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>or</p>
<p>List strings = <strong>new</strong> LinkedList&lt;&gt;();</p>
<p>Option 2: Use the Collections class</p>
<p>The Collections class provides two useful methods for creating Lists
without a List variable:</p>
<p>emptyList() : returns an empty list.</p>
<p>singletonList(T): creates a list of type T and adds the element
specified.</p>
<p>And a method which uses an existing List to fill data in:</p>
<p>addAll(L, T...): adds all the specified elements to the list passed
as the first parameter.</p>
<p>Examples:</p>
<p>import java.util.List; import java.util.Collections; List l =
Collections.emptyList(); List l1 = Collections.singletonList(42);
Collections.addAll(l1, 1, 2, 3);</p>
<p>Section 25.10: Positional Access Operations</p>
<p>The List API has eight methods for positional access operations:</p>
<p>add(T type)</p>
<p>add(<strong>int</strong> index, T type)</p>
<p>remove(Object o)</p>
<p>remove(<strong>int</strong> index)</p>
<p>get(<strong>int</strong> index)</p>
<p>set(<strong>int</strong> index, E element)</p>
<p><strong>int</strong> indexOf(Object o)</p>
<p><strong>int</strong> lastIndexOf(Object o)</p>
<p>So, if we have a List:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 153</p>
<p>List strings = <strong>new</strong> ArrayList();</p>
<p>And we wanted to add the strings "Hello world!" and "Goodbye world!"
to it, we would do it as such:</p>
<p>strings.add("Hello world!");</p>
<p>strings.add("Goodbye world!");</p>
<p>And our list would contain the two elements. Now lets say we wanted
to add "Program starting!" at the <strong>front</strong> of the</p>
<p>list. We would do this like this:</p>
<p>strings.add(0, "Program starting!");</p>
<p>NOTE: The first element is 0.</p>
<p>Now, if we wanted to remove the "Goodbye world!" line, we could do it
like this:</p>
<p>strings.remove("Goodbye world!");</p>
<p>And if we wanted to remove the first line (which in this case would
be "Program starting!", we could do it like this:</p>
<p>strings.remove(0);</p>
<p>Note:</p>
<p>1. Adding and removing list elements modify the list, and this can
lead to a ConcurrentModificationException</p>
<p>if the list is being iterated concurrently.</p>
<p>2. Adding and removing elements can be O(1) or O(N) depending on the
list class, the method used, and</p>
<p>whether you are adding / removing an element at the start, the end,
or in the middle of the list.</p>
<p>In order to retrieve an element of the list at a specified position
you can use the E get(<strong>int</strong> index); method of the List
API. For example:</p>
<p>strings.get(0);</p>
<p>will return the first element of the list.</p>
<p>You can replace any element at a specified position by using the
set(<strong>int</strong> index, E element);. For example:</p>
<p>strings.set(0,"This is a replacement");</p>
<p>This will set the String "This is a replacement" as the first element
of the list.</p>
<p>Note: The set method will overwrite the element at the position 0. It
will not add the new String at the position 0 and push the old one to
the position 1.</p>
<p>The <strong>int</strong> indexOf(Object o); returns the position of
the first occurrence of the object passed as argument. If there are no
occurrences of the object in the list then the -1 value is returned. In
continuation of the previous example if</p>
<p>you call:</p>
<p>strings.indexOf("This is a replacement")</p>
<p>the 0 is expected to be returned as we set the String "This is a
replacement" in the position 0 of our list. In case where there are more
than one occurrence in the list when <strong>int</strong> indexOf(Object
o); is called then as mentioned</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 154</p>
<p><span id="the_index_of_the_first_occurrenc" class="anchor"></span>the
index of the first occurrence will be returned. By calling the
<strong>int</strong> lastIndexOf(Object o) you can retrieve the index of
the last occurrence in the list. So if we add another "This is a
replacement":</p>
<p>strings.add("This is a replacement");</p>
<p>strings.lastIndexOf("This is a replacement");</p>
<p>This time the 1 will be returned and not the 0;</p>
<p>Section 25.11: Iterating over elements in a list</p>
<p>For the example, lets say that we have a List of type String that
contains four elements: "hello, ", "how ", "are ",</p>
<p>"you?"</p>
<p>The best way to iterate over each element is by using a for-each
loop:</p>
<p><strong>public void</strong> printEachElement(List list){</p>
<p><strong>for</strong>(String s : list){</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>}</p>
<p>Which would print:</p>
<p>hello,</p>
<p>how</p>
<p>are</p>
<p>you?</p>
<p>To print them all in the same line, you can use a StringBuilder:</p>
<p><strong>public void</strong> printAsLine(List list){</p>
<p>StringBuilder builder = <strong>new</strong> StringBuilder();</p>
<p><strong>for</strong>(String s : list){</p>
<p>builder.append(s);</p>
<p>}</p>
<p>System.out.println(builder.toString());</p>
<p>}</p>
<p>Will print:</p>
<p>hello, how are you?</p>
<p>Alternatively, you can use element indexing ( as described in
Accessing element at ith Index from ArrayList ) to iterate a list.
Warning: this approach is inefficient for linked lists.</p>
<p>Section 25.12: Removing elements from list B that are present</p>
<p>in the list A</p>
<p>Lets suppose you have 2 Lists A and B, and you want to remove from
<strong>B</strong> all the elements that you have in <strong>A</strong>
the</p>
<p>method in this case is</p>
<p>List.removeAll(Collection c);</p>
<p>#Example:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 155</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List numbersA = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>List numbersB = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>numbersA.addAll(Arrays.asList(<strong>new</strong> Integer[] { 1, 3,
4, 7, 5, 2 }));</p>
<p>numbersB.addAll(Arrays.asList(<strong>new</strong> Integer[] { 13,
32, 533, 3, 4, 2 }));</p>
<p>System.out.println("A: " + numbersA);</p>
<p>System.out.println("B: " + numbersB);</p>
<p>numbersB.removeAll(numbersA);</p>
<p>System.out.println("B cleared: " + numbersB);</p>
<p>}</p>
<p>this will print</p>
<p>A: [1, 3, 4, 7, 5, 2]</p>
<p>B: [13, 32, 533, 3, 4, 2]</p>
<p>B cleared: [13, 32, 533]</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 156</p>
<p><span id="Chapter_26__Sets_1" class="anchor"></span>Chapter 26:
Sets</p>
<p>Section 26.1: Initialization</p>
<p>A Set is a Collection that cannot contain duplicate elements. It
models the mathematical set abstraction.</p>
<p>Set have its implementation in various classes like HashSet, TreeSet,
LinkedHashSet.</p>
<p>For example:</p>
<p>HashSet:</p>
<p>Set set = <strong>new</strong> HashSet();</p>
<p>Here T can be String, Integer or any other <strong>object</strong>.
<strong>HashSet</strong> allows for quick lookup of O(1) but does not
sort the</p>
<p>data added to it and loses the insertion order of items.</p>
<p>TreeSet:</p>
<p>It stores data in a sorted manner sacrificing some speed for basic
operations which take O(lg(n)). It does not</p>
<p>maintain the insertion order of items.</p>
<p>TreeSet sortedSet = <strong>new</strong> TreeSet();</p>
<p>LinkedHashSet:</p>
<p>It is a linked list implementation of HashSet Once can iterate over
the items in the order they were added. Sorting is not provided for its
contents. O(1) basic operations are provided, however there is higher
cost than HashSet in</p>
<p>maintaining the backing linked list.</p>
<p>LinkedHashSet linkedhashset = <strong>new</strong>
LinkedHashSet();</p>
<p>Section 26.2: Basics of Set</p>
<p>What is a Set?</p>
<p>A set is a data structure which contains a set of elements with an
important property that no two elements in the set are equal.</p>
<p>Types of Set:</p>
<p>1. <strong>HashSet:</strong> A set backed by a hash table (actually a
HashMap instance)</p>
<p>2. <strong>Linked HashSet:</strong> A Set backed by Hash table and
linked list, with predictable iteration order</p>
<p>3. <strong>TreeSet:</strong> A NavigableSet implementation based on a
TreeMap.</p>
<p>Creating a set</p>
<p><em>Set set = <strong>new</strong> HashSet();</em> // Creates an
empty Set of Integers</p>
<p><em>Set linkedHashSet = <strong>new</strong> LinkedHashSet();</em>
//Creates a empty Set of Integers, with predictable iteration order</p>
<p>Adding elements to a Set</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 157</p>
<p><span id="Elements_can_be_added_to_a_set_u"
class="anchor"></span>Elements can be added to a set using the add()
method</p>
<p><em>set.add(12);</em> // - Adds element 12 to the set</p>
<p><em>set.add(13);</em> // - Adds element 13 to the set</p>
<p>Our set after executing this method:</p>
<p>set = [12,13]</p>
<p>Delete all the elements of a Set</p>
<p><em>set.clear();</em> //Removes all objects from the collection.</p>
<p>After this set will be:</p>
<p>set = []</p>
<p>Check whether an element is part of the Set</p>
<p>Existence of an element in the set can be checked using the
contains() method</p>
<p><em>set.contains(0);</em> //Returns true if a specified object is an
element within the set.</p>
<p>Output: False</p>
<p>Check whether a Set is empty</p>
<p>isEmpty() method can be used to check whether a Set is empty.</p>
<p><em>set.isEmpty();</em> //Returns true if the set has no elements</p>
<p>Output: <strong>True</strong></p>
<p>Remove an element from the Set</p>
<p><em>set.remove(0);</em> // Removes first occurrence of a specified
object from the collection</p>
<p>Check the Size of the Set</p>
<p><em>set.size();</em> //Returns the number of elements in the
collection</p>
<p>Output: <strong>0</strong></p>
<p>Section 26.3: Types and Usage of Sets</p>
<p>Generally, sets are a type of collection which stores unique values.
Uniqueness is determined by the equals() and</p>
<p>hashCode() methods.</p>
<p>Sorting is determined by the type of set.</p>
<p>HashSet - Random Sorting</p>
<p>Version ≥ Java SE 7</p>
<p>Set set = <strong>new</strong> HashSet&lt;&gt; ();</p>
<p>set.add("Banana");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 158</p>
<p><span id="set_add__Banana"
class="anchor"></span>set.add("Banana");</p>
<p>set.add("Apple");</p>
<p>set.add("Strawberry");</p>
<p>// Set Elements: ["Strawberry", "Banana", "Apple"]</p>
<p>LinkedHashSet - Insertion Order</p>
<p>Version ≥ Java SE 7</p>
<p>Set set = <strong>new</strong> LinkedHashSet&lt;&gt; ();</p>
<p>set.add("Banana");</p>
<p>set.add("Banana");</p>
<p>set.add("Apple");</p>
<p>set.add("Strawberry");</p>
<p>// Set Elements: ["Banana", "Apple", "Strawberry"]</p>
<p>TreeSet - By compareTo() or Comparator</p>
<p>Version ≥ Java SE 7</p>
<p>Set set = <strong>new</strong> TreeSet&lt;&gt; ();</p>
<p>set.add("Banana");</p>
<p>set.add("Banana");</p>
<p>set.add("Apple");</p>
<p>set.add("Strawberry");</p>
<p>// Set Elements: ["Apple", "Banana", "Strawberry"]</p>
<p>Version ≥ Java SE 7</p>
<p>Set set = <strong>new</strong> TreeSet&lt;&gt; ((string1,
string2)-&gt; string2.compareTo(string1)); set.add("Banana");</p>
<p>set.add("Banana");</p>
<p>set.add("Apple");</p>
<p>set.add("Strawberry");</p>
<p>// Set Elements: ["Strawberry", "Banana", "Apple"]</p>
<p>Section 26.4: Create a list from an existing Set</p>
<p>Using a new List</p>
<p>List list = <strong>new</strong> ArrayList(listOfElements);</p>
<p>Using List.addAll() method</p>
<p>Set set = <strong>new</strong> HashSet();</p>
<p>set.add("foo");</p>
<p>set.add("boo");</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>list.addAll(set);</p>
<p>Using Java 8 Steam API</p>
<p>List list = set.stream().collect(Collectors.toList());</p>
<p>Section 26.5: Eliminating duplicates using Set</p>
<p>Suppose you have a collection elements, and you want to create
another collection containing the same elements</p>
<p><strong>but with all</strong> duplicates
eliminated<strong>:</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 159</p>
<p><span id="Collection_noDuplicates___new_Ha"
class="anchor"></span>Collection noDuplicates = <strong>new</strong>
HashSet(elements);</p>
<p>Example<em>:</em></p>
<p>List names = <strong>new</strong> ArrayList&lt;&gt;(</p>
<p>Arrays.asList("John", "Marco", "Jenny", "Emily", "Jenny", "Emily",
"John"));</p>
<p>Set noDuplicates = <strong>new</strong> HashSet&lt;&gt;(names);</p>
<p>System.out.println("noDuplicates = " + noDuplicates);</p>
<p>Output<em>:</em></p>
<p>noDuplicates = [Marco, Emily, John, Jenny]</p>
<p>Section 26.6: Declaring a HashSet with values</p>
<p>You can create a new class that inherits from HashSet:</p>
<p>Set h = <strong>new</strong> HashSet() {{</p>
<p>add("a");</p>
<p>add("b");</p>
<p>}};</p>
<p>One line solution:</p>
<p>Set h = <strong>new</strong> HashSet(Arrays.asList("a", "b"));</p>
<p>Using guava:</p>
<p>Sets.newHashSet("a", "b", "c")</p>
<p>Using Streams:</p>
<p>Set set3 = Stream.of("a", "b", "c").collect(toSet());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 160</p>
<p><span id="Chapter_27__List_vs_Set_1" class="anchor"></span>Chapter
27: List vs Set</p>
<p>What are differences between List and Set collection at the top level
and How to choose when to use List in java and</p>
<p>when to use Set in Java</p>
<p>Section 27.1: List vs Set</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.HashSet;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.Set;</p>
<p><strong>public class</strong> SetAndListExample</p>
<p>{</p>
<p><strong>public static void</strong> main( String[] args )</p>
<p>{</p>
<p>System.out.println("List example .....");</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>list.add("1");</p>
<p>list.add("2");</p>
<p>list.add("3");</p>
<p>list.add("4");</p>
<p>list.add("1");</p>
<p><strong>for</strong> (String temp : list){</p>
<p>System.out.println(temp);</p>
<p>}</p>
<p>System.out.println("Set example .....");</p>
<p>Set set = <strong>new</strong> HashSet();</p>
<p>set.add("1");</p>
<p>set.add("2");</p>
<p>set.add("3");</p>
<p>set.add("4");</p>
<p>set.add("1");</p>
<p>set.add("2");</p>
<p>set.add("5");</p>
<p><strong>for</strong> (String temp : set){</p>
<p>System.out.println(temp);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output List example ..... 1 2 3 4 1 Set example ..... 3 2 10 5 4</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 161</p>
<p><span id="Chapter_28__Maps_1" class="anchor"></span>Chapter 28:
Maps</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/Map.html">The
java.util.Map interface</a> represents a mapping between keys and their
values. A map cannot contain duplicate</p>
<p>keys; and each key can map to at most one value.</p>
<p>Since Map is an interface, then you need to instantiate a concrete
implementation of that interface in order to use it;</p>
<p>there are several Map implementations, and mostly used are the
java.util.HashMap and java.util.TreeMap</p>
<p>Section 28.1: Iterating Map Entries Eciently</p>
<p>This section provides code and benchmarks for ten unique example
implementations which iterate over the entries</p>
<p>of a Map and generate the sum of the Integer values. All of the
examples have an algorithmic complexity of Θ(n), however, the benchmarks
are still useful for providing insight on which implementations are</p>
<p>more efficient in a "real world" environment.</p>
<p>1. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Implementation
using <strong>Iterator</strong> with</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html"><strong>Map.Entry</strong></a></p>
<p>Iterator&gt; it = map.entrySet().iterator();</p>
<p><strong>while</strong> (it.hasNext()) {</p>
<p>Map.Entry pair = it.next();</p>
<p>sum += pair.getKey() + pair.getValue();</p>
<p>}</p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/foreach.html">Implementation
using <strong>for</strong></a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html">with
<strong>Map.Entry</strong></a></p>
<p><strong>for</strong> (Map.Entry pair : map.entrySet()) { sum +=
pair.getKey() + pair.getValue();</p>
<p>}</p>
<p>3. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#forEach-java.util.function.BiConsumer-">Implementation
using <strong>Map.forEach</strong></a> (Java 8+)</p>
<p>map.<strong>forEach</strong>((k, v)-&gt; sum[0] += k + v);</p>
<p>4. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#keySet--">Implementation
using <strong>Map.keySet</strong></a> with <a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/foreach.html"><strong>for</strong></a></p>
<p><strong>for</strong> (Integer key : map.keySet()) {</p>
<p>sum += key + map.get(key);</p>
<p>}</p>
<p>5. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#keySet--">Implementation
using <strong>Map.keySet</strong></a> with <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html"><strong>Iterator</strong></a></p>
<p>Iterator it = map.keySet().iterator();</p>
<p><strong>while</strong> (it.hasNext()) {</p>
<p>Integer key = it.next();</p>
<p>sum += key + map.get(key);</p>
<p>}</p>
<p>6. <a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/foreach.html">Implementation
using <strong>for</strong></a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">with
<strong>Iterator</strong> and</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html"><strong>Map.Entry</strong></a></p>
<p><strong>for</strong> (Iterator&gt; entries =</p>
<p>map.entrySet().iterator(); entries.hasNext(); ) {</p>
<p>Map.Entry entry = entries.next();</p>
<p>sum += entry.getKey() + entry.getValue();</p>
<p>}</p>
<p>7. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-">Implementation
using <strong>Stream.forEach</strong></a> (Java 8+)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 162</p>
<p>map.entrySet().stream().<strong>forEach</strong>(e -&gt; sum +=
e.getKey() + e.getValue());</p>
<p>8. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-">Implementation
using <strong>Stream.forEach</strong></a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">with
<strong>Stream.parallel</strong> (Java 8+)</a></p>
<p>map.entrySet()</p>
<p>.stream()</p>
<p>.parallel()</p>
<p>.<strong>forEach</strong>(e -&gt; sum += e.getKey() +
e.getValue());</p>
<p>9. <a
href="https://commons.apache.org/proper/commons-collections/javadocs/api-release/org/apache/commons/collections4/IterableMap.html">Implementation
using <strong>IterableMap</strong></a> <a
href="https://commons.apache.org/proper/commons-collections/">from
Apache Collections</a></p>
<p>MapIterator mit = iterableMap.mapIterator();</p>
<p><strong>while</strong> (mit.hasNext()) {</p>
<p>sum += mit.next() + it.getValue();</p>
<p>}</p>
<p>10. <a
href="https://www.eclipse.org/collections/javadoc/8.0.0/org/eclipse/collections/api/map/MutableMap.html">Implementation
using <strong>MutableMap</strong></a> <a
href="https://www.eclipse.org/collections/">from Eclipse
Collections</a></p>
<p>mutableMap.forEachKeyValue((key, value)-&gt; {</p>
<p>sum += key + value;</p>
<p>});</p>
<p><em><strong>Performance Tests</strong> (</em>Code available on <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java">Github<em>)</em></a></p>
<p>Test Environment: Windows 8.1 64-bit, Intel i7-4790 3.60GHz, 16
GB</p>
<p>1. Average Performance of 10 Trials (100 elements) Best: 308±21
ns/op</p>
<p>Benchmark Score Error Units test3_UsingForEachAndJava8 308 ± 21 ns/op
test10_UsingEclipseMutableMap 309 ± 9 ns/op test1_UsingWhileAndMapEntry
380 ± 14 ns/op test6_UsingForAndIterator 387 ± 16 ns/op
test2_UsingForEachAndMapEntry 391 ± 23 ns/op test7_UsingJava8StreamAPI
510 ± 14 ns/op test9_UsingApacheIterableMap 524 ± 8 ns/op
test4_UsingKeySetAndForEach 816 ± 26 ns/op test5_UsingKeySetAndIterator
863 ± 25 ns/op test8_UsingJava8StreamAPIParallel 5552 ± 185 ns/op</p>
<p>2. Average Performance of 10 Trials (10000 elements) Best:
37.606±0.790 μs/op</p>
<p>Benchmark Score Error Units test10_UsingEclipseMutableMap 37606 ± 790
ns/op test3_UsingForEachAndJava8 50368 ± 887 ns/op
test6_UsingForAndIterator 50332 ± 507 ns/op
test2_UsingForEachAndMapEntry 51406 ± 1032 ns/op
test1_UsingWhileAndMapEntry 52538 ± 2431 ns/op test7_UsingJava8StreamAPI
54464 ± 712 ns/op test4_UsingKeySetAndForEach 79016 ± 25345 ns/op
test5_UsingKeySetAndIterator 91105 ± 10220 ns/op
test8_UsingJava8StreamAPIParallel 112511 ± 365 ns/op
test9_UsingApacheIterableMap 125714 ± 1935 ns/op</p>
<p>3. Average Performance of 10 Trials (100000 elements) Best:
1184.767±332.968 μs/op</p>
<p>Benchmark Score Error Units</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 163</p>
<p><span id="test1_UsingWhileAndMapEntry"
class="anchor"></span>test1_UsingWhileAndMapEntry 1184.767 ± 332.968
μs/op test10_UsingEclipseMutableMap 1191.735 ± 304.273 μs/op
test2_UsingForEachAndMapEntry 1205.815 ± 366.043 μs/op
test6_UsingForAndIterator 1206.873 ± 367.272 μs/op
test8_UsingJava8StreamAPIParallel 1485.895 ± 233.143 μs/op
test5_UsingKeySetAndIterator 1540.281 ± 357.497 μs/op
test4_UsingKeySetAndForEach 1593.342 ± 294.417 μs/op
test3_UsingForEachAndJava8 1666.296 ± 126.443 μs/op
test7_UsingJava8StreamAPI 1706.676 ± 436.867 μs/op
test9_UsingApacheIterableMap 3289.866 ± 1445.564 μs/op</p>
<p>4. A Comparison of Performance Variations Respective to Map Size</p>
<p><img src="media/index-188_1.jpeg"
style="width:6.5in;height:3.18056in" alt="index-188_1.jpg" /></p>
<p>x: Size of Map</p>
<p>f(x): Benchmark Score (μs/op)</p>
<p>100 600 1100 1600 2100</p>
<p>---------------------------------------------------10 | 0.333 1.631
2.752 5.937 8.024</p>
<p>3 | 0.309 1.971 4.147 8.147 10.473</p>
<p>6 | 0.372 2.190 4.470 8.322 10.531</p>
<p>1 | 0.405 2.237 4.616 8.645 10.707</p>
<p>Tests 2 | 0.376 2.267 4.809 8.403 10.910</p>
<p>f(x) 7 | 0.473 2.448 5.668 9.790 12.125</p>
<p>9 | 0.565 2.830 5.952 13.22 16.965</p>
<p>4 | 0.808 5.012 8.813 13.939 17.407</p>
<p>5 | 0.81 5.104 8.533 14.064 17.422</p>
<p>8 | 5.173 12.499 17.351 24.671 30.403</p>
<p>Section 28.2: Usage of HashMap</p>
<p>HashMap is an implementation of the Map interface that provides a
Data Structure to store data in Key-Value pairs.</p>
<p>1. Declaring HashMap</p>
<p>Map myMap = <strong>new</strong> HashMap();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 164</p>
<p><span id="KeyType_and_ValueType_must_be_va"
class="anchor"></span>KeyType and ValueType must be valid types in Java,
such as - String, Integer, Float or any custom class like Employee,
Student etc..</p>
<p>For Example : Map myMap = <strong>new</strong> HashMap();</p>
<p>2. Putting values in HashMap.</p>
<p>To put a value in the HashMap, we have to call put method on the
HashMap object by passing the Key and the</p>
<p>Value as parameters.</p>
<p>myMap.put("key1", 1);</p>
<p>myMap.put("key2", 2);</p>
<p>If you call the put method with the Key that already exists in the
Map, the method will override its value and return</p>
<p>the old value.</p>
<p>3. Getting values from HashMap.</p>
<p>For getting the value from a HashMap you have to call the get method,
by passing the Key as a parameter.</p>
<p><em>myMap.get("key1");</em> //return 1 (class Integer)</p>
<p>If you pass a key that does not exists in the HashMap, this method
will return <strong>null</strong></p>
<p>4. Check whether the Key is in the Map or not.</p>
<p>myMap.containsKey(varKey);</p>
<p>5. Check whether the Value is in the Map or not.</p>
<p>myMap.containsValue(varValue);</p>
<p>The above methods will return a <strong>boolean</strong> value true
or false if key, value exists in the Map or not.</p>
<p>Section 28.3: Using Default Methods of Map from Java 8</p>
<p>Examples of using Default Methods introduced in Java 8 in Map
interface</p>
<p><strong>1. Using</strong> getOrDefault</p>
<p>Returns the value mapped to the key, or if the key is not present,
returns the default value</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put(1, "First element");</p>
<p><em>map.get(1);</em> // =&gt; First element</p>
<p>map.get(2); <em>// =&gt; null</em></p>
<p>map.getOrDefault(2, "Default element"); <em>// =&gt; Default
element</em></p>
<p>2. Using <strong>forEach</strong></p>
<p>Allows to perform the operation specified in the 'action' on each Map
Entry</p>
<p>Map map = <strong>new</strong> HashMap(); map.put(1, "one");</p>
<p>map.put(2, "two");</p>
<p>map.put(3, "three");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 165</p>
<p>map.<strong>forEach</strong>((key, value)-&gt;
System.out.println("Key: "+key+ " :: Value: "+value));</p>
<p>// Key: 1 :: Value: one</p>
<p>// Key: 2 :: Value: two</p>
<p>// Key: 3 :: Value: three</p>
<p><strong>3. Using</strong> replaceAll</p>
<p>Will replace with new-value only if key is present</p>
<p>Map map = <strong>new</strong> HashMap(); map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p>map.replaceAll((key,value)-&gt;value+10); <em>//{john=30, paul=40,
peter=50}</em></p>
<p><strong>4. Using</strong> putIfAbsent</p>
<p>Key-Value pair is added to the map, if the key is not present or
mapped to null</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p><em>map.putIfAbsent("kelly", 50);</em> //{john=20, paul=30, peter=40,
kelly=50}</p>
<p>5. Using <strong>remove</strong></p>
<p>Removes the key only if its associated with the given value</p>
<p>Map map = <strong>new</strong> HashMap(); map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p>map.remove("peter",40); <em>//{john=30, paul=40}</em></p>
<p>6. Using <strong>replace</strong></p>
<p>If the key is present then the value is replaced by new-value. If the
key is not present, does nothing.</p>
<p>Map map = <strong>new</strong> HashMap(); map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p><em>map.replace("peter",50);</em> //{john=20, paul=30, peter=50}
<em>map.replace("jack",60);</em> //{john=20, paul=30, peter=50}</p>
<p><strong>7. Using</strong> computeIfAbsent</p>
<p>This method adds an entry in the Map. the key is specified in the
function and the value is the result of the</p>
<p>application of the mapping function</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 166</p>
<p><span id="map_computeIfAbsent__kelly___k"
class="anchor"></span>map.computeIfAbsent("kelly",
k-&gt;map.get("john")+10); <em>//{john=20, paul=30, peter=40,
kelly=30}</em></p>
<p><em>map.computeIfAbsent("peter", k-&gt;map.get("john")+10);</em>
//{john=20, paul=30, peter=40, kelly=30} //peter already present</p>
<p><strong>8. Using</strong> computeIfPresent</p>
<p>This method adds an entry or modifies an existing entry in the Map.
Does nothing if an entry with that key is not</p>
<p>present</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p><em>map.computeIfPresent("kelly", (k,v)-&gt;v+10);</em> //{john=20,
paul=30, peter=40} //kelly not present</p>
<p><em>map.computeIfPresent("peter", (k,v)-&gt;v+10);</em> //{john=20,
paul=30, peter=50} // peter present, so increase the value</p>
<p>9. Using <strong>compute</strong></p>
<p>This method replaces the value of a key by the newly computed
value</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p><em>map.compute("peter", (k,v)-&gt;v+50);</em> //{john=20, paul=30,
peter=90} //Increase the value</p>
<p>10. Using <strong>merge</strong></p>
<p>Adds the key-value pair to the map, if key is not present or value
for the key is null Replaces the value with the newly computed value, if
the key is present Key is removed from the map , if new value computed
is null</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("john", 20);</p>
<p>map.put("paul", 30);</p>
<p>map.put("peter", 40);</p>
<p>//Adds the key-value pair to the map, if key is not present or value
for the key is null</p>
<p>map.merge("kelly", 50 , (k,v)-&gt;map.get("john")+10); <em>//
{john=20, paul=30, peter=40, kelly=50}</em></p>
<p>//Replaces the value with the newly computed value, if the key is
present</p>
<p>map.merge("peter", 50 , (k,v)-&gt;map.get("john")+10);
<em>//{john=20, paul=30, peter=30, kelly=50}</em></p>
<p>//Key is removed from the map , if new value computed is null</p>
<p>map.merge("peter", 30 , (k,v)-&gt;map.get("nancy")); <em>//{john=20,
paul=30, kelly=50}</em></p>
<p>Section 28.4: Iterating through the contents of a Map</p>
<p>Maps provide methods which let you access the keys, values, or
key-value pairs of the map as collections. You can</p>
<p>iterate through these collections. Given the following map for
example:</p>
<p>Map repMap = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>repMap.put("Jon Skeet", 927_654);</p>
<p>repMap.put("BalusC", 708_826);</p>
<p>repMap.put("Darin Dimitrov", 715_567);</p>
<p>Iterating through map keys:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 167</p>
<p><span id="for__String_key___repMap_keySet"
class="anchor"></span><strong>for</strong> (String key :
repMap.keySet()) {</p>
<p>System.out.println(key);</p>
<p>}</p>
<p>Prints:</p>
<p>Darin Dimitrov</p>
<p>Jon Skeet</p>
<p>BalusC</p>
<p>keySet() <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html">provides
the keys of the map as a Set</a>. Set is used as the keys cannot contain
duplicate values. Iterating through the set yields each key in turn.
HashMaps are not ordered, so in this example the keys may be returned
in</p>
<p>any order.</p>
<p>Iterating through map values:</p>
<p><strong>for</strong> (Integer value : repMap.values()) {</p>
<p>System.out.println(value);</p>
<p>}</p>
<p>Prints:</p>
<p>715567</p>
<p>927654</p>
<p>708826</p>
<p>values() returns the values of the map as a <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection.
Iterating through the collection yields each value in turn.</a></p>
<p>Again, the values may be returned in any order.</p>
<p>Iterating through keys and values together</p>
<p><strong>for</strong> (Map.Entry entry : repMap.entrySet()) {</p>
<p>System.out.printf("%s = %d<strong>\n</strong>", entry.getKey(),
entry.getValue());</p>
<p>}</p>
<p>Prints:</p>
<p>Darin Dimitrov = 715567</p>
<p>Jon Skeet = 927654</p>
<p>BalusC = 708826</p>
<p>entrySet() returns a collection of <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html">Map.Entry
objects. Map.Entry gives access to the key and value for each
entry.</a></p>
<p>Section 28.5: Merging, combine and composing Maps</p>
<p>Use putAll to put every member of one map into another. Keys already
present in the map will have their</p>
<p>corresponding values overwritten.</p>
<p>Map numbers = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>numbers.put("One", 1)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 168</p>
<p><span id="numbers_put__Three___3"
class="anchor"></span>numbers.put("Three", 3)</p>
<p>Map other_numbers = <strong>new</strong> HashMap&lt;&gt;();
other_numbers.put("Two", 2)</p>
<p>other_numbers.put("Three", 4)</p>
<p>numbers.putAll(other_numbers)</p>
<p>This yields the following mapping in numbers:</p>
<p>"One"-&gt; 1</p>
<p>"Two"-&gt; 2</p>
<p><em>"Three"-&gt; 4</em> //old value 3 was overwritten by new value
4</p>
<p>If you want to combine values instead of overwriting them, you can
use <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-">Map.merge,
added in Java 8, which uses a</a></p>
<p>user-provided BiFunction to merge values for duplicate keys. merge
operates on individual keys and values, so you'll need to use a loop or
Map.<strong>forEach</strong>. Here we concatenate strings for duplicate
keys:</p>
<p><strong>for</strong> (Map.Entry e : other_numbers.entrySet())</p>
<p>numbers.merge(e.getKey(), e.getValue(), Integer::sum); <em>//or
instead of the above loop</em></p>
<p>other_numbers.<strong>forEach</strong>((k, v)-&gt; numbers.merge(k,
v, Integer::sum));</p>
<p>If you want to enforce the constraint there are no duplicate keys,
you can use a merge function that throws an</p>
<p>AssertionError:</p>
<p>mapA.<strong>forEach</strong>((k, v)-&gt;</p>
<p>mapB.merge(k, v, (v1, v2)-&gt;</p>
<p>{<strong>throw new</strong> AssertionError("duplicate values for key:
"+k);}));</p>
<p>Composing Map&lt;X,Y&gt; and Map&lt;Y,Z&gt; to get Map&lt;X,Z&gt;</p>
<p>If you want to compose two mappings, you can do it as follows</p>
<p>Map map1 = <strong>new</strong> HashMap();</p>
<p>map1.put("key1", 1);</p>
<p>map1.put("key2", 2);</p>
<p>map1.put("key3", 3);</p>
<p>Map map2 = <strong>new</strong> HashMap();</p>
<p>map2.put(1, 1.0);</p>
<p>map2.put(2, 2.0);</p>
<p>map2.put(3, 3.0);</p>
<p>Map map3 = <strong>new new</strong> HashMap();</p>
<p>map1.<strong>forEach</strong>((key,value)-&gt;map3.put(key,map2.get(value)));</p>
<p>This yields the following mapping</p>
<p>"key1"-&gt; 1.0</p>
<p>"key2"-&gt; 2.0</p>
<p>"key3"-&gt; 3.0</p>
<p>Section 28.6: Add multiple items</p>
<p>We can use V put(K key,V value):</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 169</p>
<p>Associates the specified value with the specified key in this map
(optional operation). If the map previously contained a mapping for the
key, the old value is replaced by the specified value.</p>
<p>String currentVal;</p>
<p>Map map = <strong>new</strong> TreeMap&lt;&gt;();</p>
<p>currentVal = map.put(1, "First element.");</p>
<p>System.out.println(currentVal);<em>// Will print null</em></p>
<p>currentVal = map.put(2, "Second element.");</p>
<p>System.out.println(currentVal); <em>// Will print null yet again</em>
currentVal = map.put(2, "This will replace 'Second element'");
System.out.println(currentVal); <em>// will print Second element.</em>
System.out.println(map.size()); <em>// Will print 2 as key having //
value 2 was replaced.</em></p>
<p>Map map2 = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map2.put(2, "Element 2");</p>
<p>map2.put(3, "Element 3");</p>
<p>map.putAll(map2);</p>
<p>System.out.println(map.size());</p>
<p>Output:</p>
<p>3</p>
<p>To add many items you can use an inner classes like this:</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;() {{</p>
<p>// This is now an anonymous inner class with an unnamed instance
constructor</p>
<p>put(5, "high");</p>
<p>put(4, "low");</p>
<p>put(1, "too slow");</p>
<p>}};</p>
<p>Keep in mind that creating an anonymous inner class is not always
efficient and can lead to memory leaks so when possible, use an
initializer block instead:</p>
<p><strong>static</strong> Map map = <strong>new</strong>
HashMap&lt;&gt;();</p>
<p>static <strong>{</strong></p>
<p>// Now no inner classes are created so we can avoid memory leaks</p>
<p>put(5, "high");</p>
<p>put(4, "low");</p>
<p>put(1, "too slow");</p>
<p>}</p>
<p>The example above makes the map static. It can also be used in a
non-static context by removing all occurrences of</p>
<p>static <strong>.</strong></p>
<p>In addition to that most implementations support putAll, which can
add all entries in one map to another like this:</p>
<p>another.putAll(one);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 170</p>
<p><span id="Section_28_7__Creating_and_Initi"
class="anchor"></span>Section 28.7: Creating and Initializing Maps</p>
<p>Introduction</p>
<p>Maps stores key/value pairs, where each key has an associated value.
Given a particular key, the map can look up the associated value very
quickly.</p>
<p>Maps, also known as associate array, is an object that stores the
data in form of keys and values. In Java, maps are</p>
<p>represented using Map interface which is not an extension of the
collection interface.</p>
<p>Way 1:</p>
<p>/*J2SE &lt; 5.0*/</p>
<p>Map map = <strong>new</strong> HashMap();</p>
<p>map.put("name", "A");</p>
<p>map.put("address", "Malviya-Nagar");</p>
<p>map.put("city", "Jaipur");</p>
<p>System.out.println(map);</p>
<p>Way 2:</p>
<p>/*J2SE 5.0+ style (use of generics):*/</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put("name", "A");</p>
<p>map.put("address", "Malviya-Nagar");</p>
<p>map.put("city", "Jaipur");</p>
<p>System.out.println(map);</p>
<p>Way 3:</p>
<p>Map map = <strong>new</strong> HashMap(){{</p>
<p>put("name", "A");</p>
<p>put("address", "Malviya-Nagar");</p>
<p>put("city", "Jaipur");</p>
<p>}};</p>
<p>System.out.println(map);</p>
<p>Way 4:</p>
<p>Map map = <strong>new</strong> TreeMap();</p>
<p>map.put("name", "A");</p>
<p>map.put("address", "Malviya-Nagar");</p>
<p>map.put("city", "Jaipur");</p>
<p>System.out.println(map);</p>
<p>Way 5:</p>
<p>//Java 8</p>
<p><strong>final</strong> Map map =</p>
<p>Arrays.stream(<strong>new</strong> String[][] {</p>
<p>{ "name", "A" },</p>
<p>{ "address", "Malviya-Nagar" },</p>
<p>{ "city", "jaipur" },</p>
<p>}).collect(Collectors.toMap(m -&gt; m[0], m -&gt; m[1]));</p>
<p>System.out.println(map);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 171</p>
<p><span id="Way_6" class="anchor"></span>Way 6:</p>
<p>//This way for initial a map in outside the function
<em><strong>final static</strong> Map map;</em></p>
<p>static</p>
<p>{</p>
<p>map = <strong>new</strong> HashMap();</p>
<p>map.put("a", "b");</p>
<p>map.put("c", "d");</p>
<p>}</p>
<p>Way 7: Creating an immutable single key-value map.</p>
<p>//Immutable single key-value map</p>
<p>Map singletonMap = Collections.singletonMap("key", "value");</p>
<p><strong>Please note, that</strong> it is impossible to modify such
map<strong>.</strong></p>
<p>Any attemts to modify the map will result in throwing the
UnsupportedOperationException.</p>
<p>//Immutable single key-value pair</p>
<p>Map singletonMap = Collections.singletonMap("key", "value");</p>
<p><em>singletonMap.put("newKey", "newValue");</em> //will throw
UnsupportedOperationException</p>
<p><em>singletonMap.putAll(<strong>new</strong> HashMap&lt;&gt;());</em>
//will throw UnsupportedOperationException</p>
<p><em>singletonMap.remove("key");</em> //will throw
UnsupportedOperationException</p>
<p>singletonMap.replace("key", "value", "newValue"); <em>//will
throw</em></p>
<p>UnsupportedOperationException</p>
<p>//and etc</p>
<p>Section 28.8: Check if key exists</p>
<p>Map num = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>num.put("one", "first");</p>
<p><strong>if</strong> (num.containsKey("one")) {</p>
<p>System.out.println(num.get("one")); <em>// =&gt; first</em></p>
<p>}</p>
<p>Maps can contain null values</p>
<p>For maps, one has to be carrefull not to confuse "containing a key"
with "having a value". For example, HashMaps can contain null which
means the following is perfectly normal behavior :</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put("one", <strong>null</strong>);</p>
<p><strong>if</strong> (map.containsKey("one")) {</p>
<p>System.out.println("This prints !"); <em>// This line is
reached</em></p>
<p>}</p>
<p><strong>if</strong> (map.get("one") != <strong>null</strong>) {</p>
<p>System.out.println("This is never reached !"); <em>// This line is
never reached</em></p>
<p>}</p>
<p>More formally, there is no guarantee that map.contains(key) &lt;=&gt;
map.get(key)!=<strong>null</strong></p>
<p>Section 28.9: Add an element</p>
<p>1. Addition</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 172</p>
<p><span id="Map_map___new_HashMap" class="anchor"></span>Map map =
<strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put(1, "First element.");</p>
<p>System.out.println(map.get(1));</p>
<p>Output: First element.</p>
<p>2. Override</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put(1, "First element.");</p>
<p>map.put(1, "New element.");</p>
<p>System.out.println(map.get(1));</p>
<p>Output: <strong>New</strong> element.</p>
<p>HashMap is used as an example. Other implementations that implement
the Map interface may be used as well.</p>
<p>Section 28.10: Clear the map</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>map.put(1, "First element.");</p>
<p>map.put(2, "Second element.");</p>
<p>map.put(3, "Third element.");</p>
<p>map.clear();</p>
<p>System.out.println(map.size()); <em>// =&gt; 0</em></p>
<p>Section 28.11: Use custom object as key</p>
<p>Before using your own object as key you must override hashCode() and
equals() method of your object.</p>
<p>In simple case you would have something like:</p>
<p><strong>class</strong> MyKey {</p>
<p><strong>private</strong> String name;</p>
<p>MyKey(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong>(obj <strong>instanceof</strong> MyKey) {</p>
<p><strong>return this</strong>.name.equals(((MyKey)obj).name);</p>
<p>}</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return this</strong>.name.hashCode();</p>
<p>}</p>
<p>}</p>
<p>hashCode will decide which hash bucket the key belongs to and equals
will decide which object inside that hash</p>
<p>bucket.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 173</p>
<p>Without these method, the reference of your object will be used for
above comparison which will not work unless you use the same object
reference every time.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 174</p>
<p><span id="Chapter_29__LinkedHashMap_1" class="anchor"></span>Chapter
29: LinkedHashMap</p>
<p>LinkedHashMap class is Hash table and Linked list implementation of
the Map interface, with predictable iteration</p>
<p>order. It inherits HashMap class and implements the Map
interface.</p>
<p>The important points about Java LinkedHashMap class are: A
LinkedHashMap contains values based on the key. It</p>
<p>contains only unique elements. It may have one null key and multiple
null values. It is same as HashMap instead maintains insertion
order.</p>
<p>Section 29.1: Java LinkedHashMap class</p>
<p>Key Points:</p>
<p>Is Hash table and Linked list implementation of the Map interface,
with predictable iteration order.</p>
<p>inherits HashMap class and implements the Map interface.</p>
<p>contains values based on the key.</p>
<p>only unique elements.</p>
<p>may have one null key and multiple null values.</p>
<p>same as HashMap instead maintains insertion order.</p>
<p>Methods:</p>
<p>void clear().</p>
<p>boolean containsKey(Object key).</p>
<p>Object get(Object key).</p>
<p>protected boolean removeEldestEntry(Map.Entry eldest)</p>
<p>Example:</p>
<p><strong>public static void</strong> main(String arg[])</p>
<p>{</p>
<p>LinkedHashMap lhm = <strong>new</strong> LinkedHashMap();</p>
<p>lhm.put("Ramesh", "Intermediate");</p>
<p>lhm.put("Shiva", "B-Tech");</p>
<p>lhm.put("Santosh", "B-Com");</p>
<p>lhm.put("Asha", "Msc");</p>
<p>lhm.put("Raghu", "M-Tech");</p>
<p>Set set = lhm.entrySet();</p>
<p>Iterator i = set.iterator();</p>
<p><strong>while</strong> (i.hasNext()) {</p>
<p>Map.Entry me = (Map.Entry) i.next();</p>
<p>System.out.println(me.getKey() + " : " + me.getValue());</p>
<p>}</p>
<p>System.out.println("The Key Contains : " + lhm.containsKey("Shiva"));
System.out.println("The value to the corresponding to key : " +
lhm.get("Asha"));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 175</p>
<p><span id="Chapter_30__WeakHashMap_1" class="anchor"></span>Chapter
30: WeakHashMap</p>
<p>Concepts of weak Hashmap</p>
<p>Section 30.1: Concepts of WeakHashmap</p>
<p>Key Points:</p>
<p>Implementation of Map.</p>
<p>stores only weak references to its keys.</p>
<p><strong>Weak References</strong> : The objects that are referenced
only by weak references are garbage collected eagerly; the GC</p>
<p>won’t wait until it needs memory in that case.</p>
<p>Difference between Hashmap and WeakHashMap:</p>
<p>If the Java memory manager no longer has a strong reference to the
object specified as a key, then the entry in the map will be removed in
WeakHashMap.</p>
<p>Example:</p>
<p><strong>public class</strong> WeakHashMapTest {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Map hashMap= <strong>new</strong> HashMap();</p>
<p>Map weakHashMap = <strong>new</strong> WeakHashMap();</p>
<p>String keyHashMap = <strong>new</strong> String("keyHashMap");</p>
<p>String keyWeakHashMap = <strong>new</strong>
String("keyWeakHashMap");</p>
<p>hashMap.put(keyHashMap, "Ankita");</p>
<p>weakHashMap.put(keyWeakHashMap, "Atul");</p>
<p>System.gc();</p>
<p>System.out.println("Before: hash map
value:"+hashMap.get("keyHashMap")+" and weak hash map</p>
<p>value:"+weakHashMap.get("keyWeakHashMap"));</p>
<p>keyHashMap = <strong>null</strong>;</p>
<p>keyWeakHashMap = <strong>null</strong>;</p>
<p>System.gc();</p>
<p>System.out.println("After: hash map
value:"+hashMap.get("keyHashMap")+" and weak hash map</p>
<p>value:"+weakHashMap.get("keyWeakHashMap"));</p>
<p>}</p>
<p>Size differences (HashMap vs WeakHashMap):</p>
<p>Calling size() method on HashMap object will return the same number
of key-value pairs. size will decrease only if</p>
<p>remove() method is called explicitly on the HashMap object.</p>
<p>Because the garbage collector may discard keys at anytime, a
WeakHashMap may behave as though an unknown</p>
<p>thread is silently removing entries. So it is possible for the size
method to return smaller values over time.So, in</p>
<p>WeakHashMap size decrease happens automatically<strong>.</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 176</p>
<p><span id="Chapter_31__SortedMap_1" class="anchor"></span>Chapter 31:
SortedMap</p>
<p>Introduction to sorted Map.</p>
<p>Section 31.1: Introduction to sorted Map</p>
<p>Keypoint:</p>
<p>SortedMap interface extends Map.</p>
<p>entries are maintained in an ascending key order.</p>
<p>Methods of sorted Map :</p>
<p>Comparator comparator( ).</p>
<p>Object firstKey( ).</p>
<p>SortedMap headMap(Object end).</p>
<p>Object lastKey( ).</p>
<p>SortedMap subMap(Object start, Object end).</p>
<p>SortedMap tailMap(Object start).</p>
<p>Example</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>// Create a hash map</p>
<p>TreeMap tm = <strong>new</strong> TreeMap();</p>
<p>// Put elements to the map</p>
<p>tm.put("Zara", <strong>new</strong> Double(3434.34));</p>
<p>tm.put("Mahnaz", <strong>new</strong> Double(123.22));</p>
<p>tm.put("Ayan", <strong>new</strong> Double(1378.00));</p>
<p>tm.put("Daisy", <strong>new</strong> Double(99.22));</p>
<p>tm.put("Qadir", <strong>new</strong> Double(-19.08));</p>
<p>// Get a set of the entries</p>
<p>Set set = tm.entrySet();</p>
<p>// Get an iterator</p>
<p>Iterator i = set.iterator();</p>
<p>// Display elements</p>
<p><strong>while</strong>(i.hasNext()) {</p>
<p>Map.Entry me = (Map.Entry)i.next();</p>
<p>System.out.print(me.getKey() + ": ");</p>
<p>System.out.println(me.getValue());</p>
<p>}</p>
<p>System.out.println();</p>
<p>// Deposit 1000 into Zara's account</p>
<p><strong>double</strong> balance =
((Double)tm.get("Zara")).doubleValue();</p>
<p>tm.put("Zara", <strong>new</strong> Double(balance + 1000));</p>
<p>System.out.println("Zara's new balance: " + tm.get("Zara"));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 177</p>
<p><span id="Chapter_32__TreeMap_and_TreeSet_1"
class="anchor"></span>Chapter 32: TreeMap and TreeSet</p>
<p>TreeMap and TreeSet are basic Java collections added in Java 1.2.
TreeMap is a <strong>mutable</strong>, <strong>ordered</strong>, Map</p>
<p>implementation. Similarly, TreeSet is a <strong>mutable</strong>,
<strong>ordered</strong> Set implementation.</p>
<p>TreeMap is implemented as a Red-Black tree, which provides O(log n)
access times. TreeSet is implemented using a TreeMap with dummy
values.</p>
<p>Both collections are <strong>not</strong> thread-safe.</p>
<p>Section 32.1: TreeMap of a simple Java type</p>
<p>First, we create an empty map, and insert some elements into it:</p>
<p>Version ≥ Java SE 7</p>
<p>TreeMap treeMap = <strong>new</strong> TreeMap&lt;&gt;();</p>
<p>Version &lt; Java SE 7</p>
<p>TreeMap treeMap = <strong>new</strong> TreeMap();</p>
<p>treeMap.put(10, "ten");</p>
<p>treeMap.put(4, "four");</p>
<p>treeMap.put(1, "one");</p>
<p>treeSet.put(12, "twelve");</p>
<p>Once we have a few elements in the map, we can perform some
operations:</p>
<p>System.out.println(treeMap.firstEntry()); <em>// Prints 1=one</em>
System.out.println(treeMap.lastEntry()); <em>// Prints 12=twelve</em>
System.out.println(treeMap.size()); <em>// Prints 4, since there are 4
elemens in the map</em> System.out.println(treeMap.get(12)); <em>//
Prints twelve</em> System.out.println(treeMap.get(15)); <em>// Prints
null, since the key is not found in the map</em></p>
<p>We can also iterate over the map elements using either an Iterator,
or a foreach loop. Note that the entries are</p>
<p>printed according to their <a
href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">natural
ordering</a>, not the insertion order:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>for</strong> (Entry entry : treeMap.entrySet()) {</p>
<p><em>System.out.print(entry + " ");</em> //prints 1=one 4=four 10=ten
12=twelve</p>
<p>}</p>
<p>Iterator&gt; iter = treeMap.entrySet().iterator();
<strong>while</strong> (iter.hasNext()) {</p>
<p><em>System.out.print(iter.next() + " ");</em> //prints 1=one 4=four
10=ten 12=twelve</p>
<p>}</p>
<p>Section 32.2: TreeSet of a simple Java Type</p>
<p>First, we create an empty set, and insert some elements into it:</p>
<p>Version ≥ Java SE 7</p>
<p>TreeSet treeSet = <strong>new</strong> TreeSet&lt;&gt;();</p>
<p>Version &lt; Java SE 7</p>
<p>TreeSet treeSet = <strong>new</strong> TreeSet();</p>
<p>treeSet.add(10);</p>
<p>treeSet.add(4);</p>
<p>treeSet.add(1);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 178</p>
<p><span id="treeSet_add_12" class="anchor"></span>treeSet.add(12);</p>
<p>Once we have a few elements in the set, we can perform some
operations:</p>
<p>System.out.println(treeSet.first()); <em>// Prints 1</em></p>
<p>System.out.println(treeSet.last()); <em>// Prints 12</em></p>
<p>System.out.println(treeSet.size()); <em>// Prints 4, since there are
4 elemens in the set</em> System.out.println(treeSet.contains(12));
<em>// Prints true</em> System.out.println(treeSet.contains(15)); <em>//
Prints false</em></p>
<p>We can also iterate over the map elements using either an Iterator,
or a foreach loop. Note that the entries are</p>
<p>printed according to their <a
href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">natural
ordering</a>, not the insertion order:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>for</strong> (Integer i : treeSet) {</p>
<p>System.out.print(i + " "); <em>//prints 1 4 10 12</em></p>
<p>}</p>
<p>Iterator iter = treeSet.iterator();</p>
<p><strong>while</strong> (iter.hasNext()) {</p>
<p>System.out.print(iter.next() + " "); <em>//prints 1 4 10 12</em></p>
<p>}</p>
<p>Section 32.3: TreeMap/TreeSet of a custom Java type</p>
<p>Since TreeMaps and TreeSet<a
href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">s
maintain keys/elements according to their natural ordering. Therefor</a>
TreeMap keys</p>
<p>and TreeSet elements have to comparable to one another.</p>
<p>Say we have a custom Person class:</p>
<p>public class <strong>Person {</strong></p>
<p>private int <strong>id;</strong></p>
<p><strong>private</strong> String firstName, lastName;</p>
<p><strong>private</strong> Date birthday;</p>
<p>//... Constuctors, getters, setters and various methods</p>
<p>}</p>
<p>If we store it as-is in a TreeSet (or a Key in a TreeMap):</p>
<p>TreeSet set = ...</p>
<p>set.add(<strong>new</strong>
Person(1,"first","last",Date.from(Instant.now())));</p>
<p>Then we'd run into an Exception such as this one:</p>
<p>Exception in thread "main" java.lang.ClassCastException: Person
cannot be cast to java.lang.Comparable</p>
<p>at java.util.TreeMap.compare(TreeMap.java:1294)</p>
<p>at java.util.TreeMap.put(TreeMap.java:538)</p>
<p>at java.util.TreeSet.add(TreeSet.java:255)</p>
<p>To fix that, let's assume that we want to order Person instances
based on the order of their ids (<strong>private int</strong> id).</p>
<p>We could do it in one of two ways:</p>
<p>1. One solution is to modify Person <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">so
it would implement the Comparable interface:</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 179</p>
<p><span id="public_class_Person_implements_C"
class="anchor"></span>public class <strong>Person</strong> implements
<strong>Comparable {</strong></p>
<p>private int <strong>id;</strong></p>
<p><strong>private</strong> String firstName, lastName;</p>
<p><strong>private</strong> Date birthday;</p>
<p>//... Constuctors, getters, setters and various methods</p>
<p>@Override</p>
<p><strong>public int</strong> compareTo(Person o) {</p>
<p><strong>return</strong> Integer.compare(<strong>this</strong>.id,
o.id); <em>//Compare by id</em></p>
<p>}</p>
<p>}</p>
<p>2. Another solution is to provide the TreeSet with a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a>:</p>
<p>Version ≥ Java SE 8</p>
<p>TreeSet treeSet = <strong>new</strong> TreeSet&lt;&gt;((personA,
personB)-&gt; Integer.compare(personA.getId(), personB.getId()));</p>
<p>TreeSet treeSet = <strong>new</strong>
TreeSet&lt;&gt;(<strong>new</strong> Comparator(){</p>
<p>@Override</p>
<p><strong>public int</strong> compare(Person personA, Person personB)
{</p>
<p><strong>return</strong> Integer.compare(personA.getId(),
personB.getId());</p>
<p>}</p>
<p>});</p>
<p>However, there are two caveats to both approaches:</p>
<p>1. It's <strong>very important</strong> not to modify any fields used
for ordering once an instance has been inserted into a</p>
<p>TreeSet /TreeMap. In the above example, if we change the id of a
person that's already inserted into the</p>
<p>collection, we might run into unexpected behavior.</p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">It's
important to implement the comparison properly and consistently. As per
the Javadoc</a>:</p>
<p>The implementor must ensure sgn(x.compareTo(y))
==-sgn(y.compareTo(x)) for all x and y. (This implies that
x.compareTo(y) must throw an exception iff y.compareTo(x) throws an
exception.)</p>
<p>The implementor must also ensure that the relation is transitive:
(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0) implies
x.compareTo(z)&gt;0.</p>
<p>Finally, the implementor must ensure that x.compareTo(y)==0 implies
that sgn(x.compareTo(z)) == sgn(y.compareTo(z)), for all z.</p>
<p>Section 32.4: TreeMap and TreeSet Thread Safety</p>
<p>TreeMap and TreeSet are <strong>not</strong> thread-safe collections,
so care must be taken to ensure when used in multi-threaded</p>
<p>programs.</p>
<p>Both TreeMap and TreeSet are safe when read, even concurrently, by
multiple threads. So if they have been created</p>
<p>and populated by a single thread (say, at the start of the program),
and only then read, but not modified by multiple threads, there's no
reason for synchronization or locking.</p>
<p>However, if read and modified concurrently, or modified concurrently
by more than one thread, the collection</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html">might
throw a ConcurrentModificationException</a> or behave unexpectedly. In
these cases, it's imperative to</p>
<p>synchronize/lock access to the collection using one of the following
approaches:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 180</p>
<p>1. Using Collections.synchronizedSorted..:</p>
<p>SortedSet set =
Collections.synchronizedSortedSet(<strong>new</strong> TreeSet());
SortedMap map = Collections.synchronizedSortedMap(<strong>new</strong>
TreeMap());</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">This
will provide a SortedSet/</a><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">SortedMap</a>
implementation backed by the actual collection, and synchronized on some
mutex object. Note that this will synchronize all read and write access
to the collection on a single</p>
<p>lock, so even concurrent reads would not be possible.</p>
<p>2. By manually synchronizing on some object, like the collection
itself:</p>
<p>TreeSet set = <strong>new</strong> TreeSet&lt;&gt;();</p>
<p>...</p>
<p>//Thread 1</p>
<p>synchronized <strong>(set) {</strong></p>
<p>set.add(4);</p>
<p>}</p>
<p>...</p>
<p>//Thread 2</p>
<p>synchronized <strong>(set) {</strong></p>
<p>set.remove(5);</p>
<p>}</p>
<p>3. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">By
using a lock, such as a ReentrantReadWriteLock</a>:</p>
<p>TreeSet set = <strong>new</strong> TreeSet&lt;&gt;();</p>
<p>ReentrantReadWriteLock lock = <strong>new</strong>
ReentrantReadWriteLock();</p>
<p>...</p>
<p>//Thread 1</p>
<p>lock.writeLock().lock();</p>
<p>set.add(4);</p>
<p>lock.writeLock().unlock();</p>
<p>...</p>
<p>//Thread 2</p>
<p>lock.readLock().lock();</p>
<p>set.contains(5);</p>
<p>lock.readLock().unlock();</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html">As
opposed to the previous synchronization methods, using a ReadWriteLock
allows multiple threads to read from</a> the map concurrently.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 181</p>
<p><span id="Chapter_33__Queues_and_Deques_1"
class="anchor"></span>Chapter 33: Queues and Deques</p>
<p>Section 33.1: The usage of the PriorityQueue</p>
<p>PriorityQueue is a data structure. Like SortedSet, PriorityQueue
sorts also its elements based on their priorities. The elements, which
have a higher priority, comes first. The type of the PriorityQueue
should implement</p>
<p>comparable or comparator interface, whose methods decides the
priorities of the elements of the data structure.</p>
<p>//The type of the PriorityQueue is Integer.</p>
<p>PriorityQueue queue = <strong>new</strong> PriorityQueue();</p>
<p>//The elements are added to the PriorityQueue</p>
<p>queue.addAll( Arrays.asList( 9, 2, 3, 1, 3, 8 ) );</p>
<p>//The PriorityQueue sorts the elements by using compareTo method of
the Integer Class //The head of this queue is the least element with
respect to the specified ordering <em>System.out.println( queue );</em>
//The Output: [1, 2, 3, 9, 3, 8] <em>queue.remove();</em></p>
<p>System.out.println( queue ); <em>//The Output: [2, 3, 3, 9, 8]</em>
queue.remove();</p>
<p>System.out.println( queue ); <em>//The Output: [3, 8, 3, 9]</em>
queue.remove();</p>
<p>System.out.println( queue ); <em>//The Output: [3, 8, 9]</em>
queue.remove();</p>
<p>System.out.println( queue ); <em>//The Output: [8, 9]</em></p>
<p>queue.remove();</p>
<p>System.out.println( queue ); <em>//The Output: [9]</em></p>
<p>queue.remove();</p>
<p>System.out.println( queue ); <em>//The Output: []</em></p>
<p>Section 33.2: Deque</p>
<p>A Deque is a "double ended queue" which means that a elements can be
added at the front or the tail of the queue.</p>
<p>The queue only can add elements to the tail of a queue.</p>
<p>The Deque inherits the Queue interface which means the regular
methods remain, however the Deque interface offers additional methods to
be more flexible with a queue. The additional methods really speak for
them self if you</p>
<p>know how a queue works, since those methods are intended to add more
flexibility:</p>
<p>Method Brief description</p>
<p>getFirst() Gets the first item of the <strong>head</strong> of the
queue without removing it.</p>
<p>getLast() Gets the first item of the <strong>tail</strong> of the
queue without removing it.</p>
<p>addFirst(E e) Adds an item to the <strong>head</strong> of the
queue</p>
<p>addLast(E e) Adds an item to the <strong>tail</strong> of the
queue</p>
<p>removeFirst() Removes the first item at the <strong>head</strong> of
the queue</p>
<p>removeLast() Removes the first item at the <strong>tail</strong> of
the queue</p>
<p>Of course the same options for offer, poll and peek are available,
however they do not work with exceptions but</p>
<p>rather with special values. There is no point in showing what they do
here.</p>
<p>Adding and Accessing Elements</p>
<p>To add elements to the tail of a Deque you call its add() method. You
can also use the addFirst() and addLast()</p>
<p>methods, which add elements to the head and tail of the deque.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 182</p>
<p><span id="Deque_dequeA___new_LinkedList" class="anchor"></span>Deque
dequeA = <strong>new</strong> LinkedList&lt;&gt;();</p>
<p>dequeA.add("element 1"); <em>//add element at tail</em></p>
<p>dequeA.addFirst("element 2"); <em>//add element at head</em></p>
<p>dequeA.addLast("element 3"); <em>//add element at tail</em></p>
<p>You can peek at the element at the head of the queue without taking
the element out of the queue. This is done via</p>
<p>the element() method. You can also use the getFirst() and getLast()
methods, which return the first and last element in the Deque. Here is
how that looks:</p>
<p>String firstElement0 = dequeA.element();</p>
<p>String firstElement1 = dequeA.getFirst();</p>
<p>String lastElement = dequeA.getLast();</p>
<p>Removing Elements</p>
<p>To remove elements from a deque, you call the remove(), removeFirst()
and removeLast() methods. Here are a few examples:</p>
<p>String firstElement = dequeA.remove();</p>
<p>String firstElement = dequeA.removeFirst();</p>
<p>String lastElement = dequeA.removeLast();</p>
<p>Section 33.3: Stacks</p>
<p>What is a Stack?</p>
<p>In Java, Stacks are a LIFO (Last In, First Out) Data structure for
objects.</p>
<p>Stack API</p>
<p>Java contains a Stack API with the following methods</p>
<p><em>Stack()</em> //Creates an empty Stack</p>
<p><em>isEmpty()</em> //Is the Stack Empty? Return Type: Boolean
<em>push(Item item)</em> //push an item onto the stack</p>
<p><em>pop()</em> //removes item from top of stack Return Type: Item
<em>size()</em> //returns # of items in stack Return Type: Int</p>
<p>Example</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>public class</strong> StackExample {</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>Stack st = <strong>new</strong> Stack();</p>
<p>System.out.println("stack: " + st);</p>
<p>st.push(10);</p>
<p>System.out.println("10 was pushed to the stack");</p>
<p>System.out.println("stack: " + st);</p>
<p>st.push(15);</p>
<p>System.out.println("15 was pushed to the stack");</p>
<p>System.out.println("stack: " + st);</p>
<p>st.push(80);</p>
<p>System.out.println("80 was pushed to the stack");</p>
<p>System.out.println("stack: " + st);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 183</p>
<p><span id="st_pop" class="anchor"></span>st.pop();</p>
<p>System.out.println("80 was popped from the stack");
System.out.println("stack: " + st);</p>
<p>st.pop();</p>
<p>System.out.println("15 was popped from the stack");
System.out.println("stack: " + st);</p>
<p>st.pop();</p>
<p>System.out.println("10 was popped from the stack");
System.out.println("stack: " + st);</p>
<p><strong>if</strong>(st.isEmpty())</p>
<p>{</p>
<p>System.out.println("empty stack");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>This returns:</p>
<p>stack: []</p>
<p>10 was pushed to the stack</p>
<p>stack: [10]</p>
<p>15 was pushed to the stack</p>
<p>stack: [10, 15]</p>
<p>80 was pushed to the stack</p>
<p>stack: [10, 15, 80]</p>
<p>80 was popped from the stack</p>
<p>stack: [10, 15]</p>
<p>15 was popped from the stack</p>
<p>stack: [10]</p>
<p>10 was popped from the stack</p>
<p>stack: []</p>
<p>empty stack</p>
<p>Section 33.4: BlockingQueue</p>
<p>A BlockingQueue is an interface, which is a queue that blocks when
you try to dequeue from it and the queue is empty, or if you try to
enqueue items to it and the queue is already full. A thread trying to
dequeue from an empty</p>
<p>queue is blocked until some other thread inserts an item into the
queue. A thread trying to enqueue an item in a full queue is blocked
until some other thread makes space in the queue, either by dequeuing
one or more items or</p>
<p>clearing the queue completely.</p>
<p>BlockingQueue methods come in four forms, with different ways of
handling operations that cannot be satisfied</p>
<p>immediately, but may be satisfied at some point in the future: one
throws an exception, the second returns a</p>
<p>special value (either null or false, depending on the operation), the
third blocks the current thread indefinitely until the operation can
succeed, and the fourth blocks for only a given maximum time limit
before giving up.</p>
<p>Operation Throws Exception Special Value Blocks Times out
<strong>Insert add() offer(e) put(e) offer(e, time, unit)</strong></p>
<p>Remove remove() poll() take() poll(time, unit)</p>
<p>Examine element() peek() N/A N/A</p>
<p>A BlockingQueue can be <strong>bounded</strong> or
<strong>unbounded</strong>. A bounded BlockingQueue is one which is
initialized with initial</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 184</p>
<p><span id="capacity" class="anchor"></span>capacity.</p>
<p>BlockingQueue bQueue = <strong>new</strong>
ArrayBlockingQueue(2);</p>
<p>Any calls to a put() method will be blocked if the size of the queue
is equal to the initial capacity defined.</p>
<p>An unbounded Queue is one which is initialized without capacity,
actually by default it initialized</p>
<p>with Integer.MAX_VALUE.</p>
<p>Some common implementations of BlockingQueue are:</p>
<p>1. ArrayBlockingQueue</p>
<p>2. LinkedBlockingQueue</p>
<p>3. PriorityBlockingQueue</p>
<p>Now let's look at an example of ArrayBlockingQueue:</p>
<p>BlockingQueue bQueue = <strong>new</strong>
ArrayBlockingQueue&lt;&gt;(2); bQueue.put("This is entry 1");</p>
<p>System.out.println("Entry one done");</p>
<p>bQueue.put("This is entry 2");</p>
<p>System.out.println("Entry two done");</p>
<p>bQueue.put("This is entry 3");</p>
<p>System.out.println("Entry three done");</p>
<p>This will print:</p>
<p>Entry one done</p>
<p>Entry two done</p>
<p>And the thread will be blocked after the second output.</p>
<p>Section 33.5: LinkedList as a FIFO Queue</p>
<p>The java.util.LinkedList class, while implementing java.util.List is
a general-purpose implementation of</p>
<p>java.util.Queue interface too operating on a <a
href="https://en.wikipedia.org/wiki/FIFO">FIFO (First In, First Out)</a>
principle.</p>
<p>In the example below, with offer() method, the elements are inserted
into the LinkedList. This insertion operation is called enqueue. In the
<strong>while</strong> loop below, the elements are removed from the
Queue based on FIFO. This</p>
<p>operation is called dequeue.</p>
<p>Queue queue = <strong>new</strong> LinkedList();</p>
<p>queue.offer( "first element" );</p>
<p>queue.offer( "second element" );</p>
<p>queue.offer( "third element" );</p>
<p>queue.offer( "fourth. element" );</p>
<p>queue.offer( "fifth. element" );</p>
<p><strong>while</strong> ( !queue.isEmpty() ) {</p>
<p>System.out.println( queue.poll() );</p>
<p>}</p>
<p>The output of this code is</p>
<p>first element</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 185</p>
<p><span id="second_element" class="anchor"></span>second element</p>
<p>third element</p>
<p>fourth element</p>
<p>fifth element</p>
<p>As seen in the output, the first inserted element "first element" is
removed firstly, "second element" is removed in</p>
<p>the second place etc.</p>
<p>Section 33.6: Queue Interface</p>
<p>Basics</p>
<p>A Queue is a collection for holding elements prior to processing.
Queues typically, but not necessarily, order</p>
<p>elements in a FIFO (first-in-first-out) manner.</p>
<p>Head of the queue is the element that would be removed by a call to
remove or poll. In a FIFO queue, all new</p>
<p>elements are inserted at the tail of the queue.</p>
<p>The Queue Interface</p>
<p>public interface <strong>Queue</strong> extends <strong>Collection
{</strong></p>
<p><strong>boolean</strong> add(E e);</p>
<p><strong>boolean</strong> offer(E e);</p>
<p>E remove();</p>
<p>E poll();</p>
<p>E element();</p>
<p>E peek();</p>
<p>}</p>
<p>Each Queue method exists in two forms:</p>
<p>one throws an exception if the operation fails;</p>
<p>other returns a special value if the operation fails (either
<strong>null</strong> or <strong>false</strong> depending on the
operation.</p>
<p>Type of operation Throws exception Returns special value
<strong>Insert add(e) offer(e)</strong></p>
<p>Remove remove() poll()</p>
<p>Examine element() peek()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 186</p>
<p><span id="Chapter_34__Dequeue_Interface_1"
class="anchor"></span>Chapter 34: Dequeue Interface</p>
<p>A Deque is linear collection that supports element insertion and
removal at both ends.</p>
<p>The name deque is short for "double ended queue" and is usually
pronounced "deck".</p>
<p>Most Deque implementations place no fixed limits on the number of
elements they may contain, but this interface supports
capacity-restricted deques as well as those with no fixed size
limit.</p>
<p>The Deque interface is a richer abstract data type than both Stack
and Queue because it implements both stacks and queues at same time</p>
<p>Section 34.1: Adding Elements to Deque</p>
<p>Deque deque = <strong>new</strong> LinkedList();</p>
<p>//Adding element at tail</p>
<p>deque.add("Item1");</p>
<p>//Adding element at head</p>
<p>deque.addFirst("Item2");</p>
<p>//Adding element at tail</p>
<p>deque.addLast("Item3");</p>
<p>Section 34.2: Removing Elements from Deque</p>
<p>//Retrieves and removes the head of the queue represented by this
deque <em>Object headItem = deque.remove();</em></p>
<p>//Retrieves and removes the first element of this deque. <em>Object
firstItem = deque.removeFirst();</em></p>
<p>//Retrieves and removes the last element of this deque. <em>Object
lastItem = deque.removeLast();</em></p>
<p>Section 34.3: Retrieving Element without Removing</p>
<p>//Retrieves, but does not remove, the head of the queue represented
by this deque <em>Object headItem = deque.element();</em></p>
<p>//Retrieves, but does not remove, the first element of this deque.
<em>Object firstItem = deque.getFirst();</em></p>
<p>//Retrieves, but does not remove, the last element of this deque.
<em>Object lastItem = deque.getLast();</em></p>
<p>Section 34.4: Iterating through Deque</p>
<p>//Using Iterator</p>
<p>Iterator iterator = deque.iterator();</p>
<p><strong>while</strong>(iterator.hasNext(){</p>
<p>String Item = (String) iterator.next();</p>
<p>}</p>
<p>//Using For Loop</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 187</p>
<p><strong>for</strong>(Object object : deque) {</p>
<p>String Item = (String) object;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 188</p>
<p><span id="Chapter_35__Enums_1" class="anchor"></span>Chapter 35:
Enums</p>
<p>Java enums (declared using the <strong>enum</strong> keyword) are
shorthand syntax for sizable quantities of constants of a single</p>
<p>class.</p>
<p>Section 35.1: Declaring and using a basic enum</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Enum</a>
can be considered to be syntax sugar for a sealed class that is
instantiated only a number of times known at</p>
<p>compile-time to define a set of constants.</p>
<p>A simple enum to list the different seasons would be declared as
follows:</p>
<p>public enum <strong>Season {</strong></p>
<p>WINTER,</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p>}</p>
<p>While the enum constants don't necessarily need to be in all-caps, it
is Java convention that names of constants are</p>
<p>entirely uppercase, with words separated by underscores.</p>
<p>You can declare an Enum in its own file:</p>
<p>/**</p>
<p>* This enum is declared in the Season.java file.</p>
<p>*/</p>
<p>public enum <strong>Season {</strong></p>
<p>WINTER,</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p>}</p>
<p>But you can also declare it inside another class:</p>
<p>public class <strong>Day {</strong></p>
<p><strong>private</strong> Season season;</p>
<p><strong>public</strong> String getSeason() {</p>
<p><strong>return</strong> season.name();</p>
<p>}</p>
<p><strong>public void</strong> setSeason(String season) {</p>
<p><strong>this</strong>.season = Season.valueOf(season);</p>
<p>}</p>
<p>/**</p>
<p>* This enum is declared inside the Day.java file and</p>
<p>* cannot be accessed outside because it's declared as private.</p>
<p>*/</p>
<p>private enum <strong>Season {</strong></p>
<p>WINTER,</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 189</p>
<p>}</p>
<p>}</p>
<p>Finally, you cannot declare an Enum inside a method body or
constructor:</p>
<p>public class <strong>Day {</strong></p>
<p>/**</p>
<p>* Constructor</p>
<p>*/</p>
<p><strong>public</strong> Day() {</p>
<p>// Illegal. Compilation error</p>
<p><strong>enum</strong> Season {</p>
<p>WINTER,</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> aSimpleMethod() {</p>
<p>// Legal. You can declare a primitive (or an Object) inside a method.
Compile! <em><strong>int</strong> primitiveInt = 42;</em></p>
<p>// Illegal. Compilation error.</p>
<p><strong>enum</strong> Season {</p>
<p>WINTER,</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p>}</p>
<p>Season season = Season.SPRING;</p>
<p>}</p>
<p>}</p>
<p>Duplicate enum constants are not allowed:</p>
<p>public enum <strong>Season {</strong></p>
<p>WINTER,</p>
<p><em>WINTER,</em> //Compile Time Error : Duplicate Constants</p>
<p>SPRING,</p>
<p>SUMMER,</p>
<p>FALL</p>
<p>}</p>
<p>Every constant of enum is <strong>public, static</strong> and
<strong>final</strong> by default. As every constant is
<strong>static</strong>, they can be accessed</p>
<p>directly using the enum name.</p>
<p>Enum constants can be passed around as method parameters:</p>
<p><strong>public static void</strong> display(Season s) {</p>
<p><em>System.out.println(s.name());</em> // name() is a built-in method
that gets the exact name of the</p>
<p>enum constant</p>
<p>}</p>
<p>display(Season.WINTER); <em>// Prints out "WINTER"</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 190</p>
<p>You can get an array of the enum constants using the values() method.
The values are guaranteed to be in declaration order in the returned
array:</p>
<p>Season[] seasons = Season.values();</p>
<p>Note: this method allocates a new array of values each time it is
called.</p>
<p>To iterate over the enum constants:</p>
<p>public static void <strong>enumIterate() {</strong></p>
<p><strong>for</strong> (Season s : Season.values()) {</p>
<p>System.out.println(s.name());</p>
<p>}</p>
<p>}</p>
<p>You can use enums in a <strong>switch</strong> statement:</p>
<p><strong>public static void</strong> enumSwitchExample(Season s) {</p>
<p>switch<strong>(s) {</strong></p>
<p><strong>case</strong> WINTER:</p>
<p>System.out.println("It's pretty cold");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> SPRING:</p>
<p>System.out.println("It's warming up");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> SUMMER:</p>
<p>System.out.println("It's pretty hot");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> FALL:</p>
<p>System.out.println("It's cooling down");</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>You can also compare enum constants using ==:</p>
<p>Season.FALL == Season.WINTER <em>// false</em></p>
<p>Season.SPRING == Season.SPRING <em>// true</em></p>
<p>Another way to compare enum constants is by using equals() as below,
which is considered bad practice as you can easily fall into pitfalls as
follows:</p>
<p>Season.FALL.equals(Season.FALL); <em>// true</em></p>
<p>Season.FALL.equals(Season.WINTER); <em>// false</em></p>
<p><em>Season.FALL.equals("FALL");</em> // false and no compiler
error</p>
<p>Furthermore, although the set of instances in the
<strong>enum</strong> cannot be changed at run-time, the instances
themselves</p>
<p>are not inherently immutable because like any other class, an
<strong>enum</strong> can contain mutable fields as is demonstrated
below.</p>
<p><strong>public enum</strong> MutableExample {</p>
<p>A,</p>
<p>B;</p>
<p>private int <strong>count = 0;</strong></p>
<p><strong>public void</strong> increment() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 191</p>
<p><span id="count" class="anchor"></span>count++;</p>
<p>}</p>
<p>public void <strong>print() {</strong></p>
<p>System.out.println("The count of " + name() + " is " + count);</p>
<p>}</p>
<p>}</p>
<p>// Usage:</p>
<p>MutableExample.A.print(); <em>// Outputs 0</em></p>
<p>MutableExample.A.increment();</p>
<p><em>MutableExample.A.print();</em> // Outputs 1 -- we've changed a
field <em>MutableExample.B.print();</em> // Outputs 0 -- another
instance remains unchanged</p>
<p>However, a good practice is to make <strong>enum</strong> instances
immutable, i.e. when they either don't have any additional</p>
<p>fields or all such fields are marked as <strong>final</strong> and
are immutable themselves. This will ensure that for a lifetime of</p>
<p>the application an <strong>enum</strong> won't leak any memory and
that it is safe to use its instances across all threads.</p>
<p>Enums implicitly implement Serializable and Comparable because the
<strong>Enum</strong> class does:</p>
<p>public abstract class <strong>Enumextends Enum&gt;</strong></p>
<p>extends <strong>Object</strong></p>
<p><strong>implements</strong> Comparable, Serializable</p>
<p>Section 35.2: Enums with constructors</p>
<p>An <strong>enum</strong> cannot have a public constructor; however,
private constructors are acceptable (constructors for enums are
package-private by default):</p>
<p>public enum <strong>Coin {</strong></p>
<p>PENNY(1), NICKEL(5), DIME(10), QUARTER(25); <em>// usual names for US
coins</em></p>
<p>// note that the above parentheses and the constructor arguments
match <em><strong>private int</strong> value;</em></p>
<p>Coin(<strong>int</strong> value) {</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p><strong>public int</strong> getValue() {</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p>}</p>
<p><strong>int</strong> p = Coin.NICKEL.getValue(); <em>// the int value
will be 5</em></p>
<p>It is recommended that you keep all fields private and provide getter
methods, as there are a finite number of instances for an enum.</p>
<p>If you were to implement an <strong>Enum</strong> as a
<strong>class</strong> instead, it would look like this:</p>
<p><strong>public class</strong> Coinextends Coin&gt;
<strong>implements</strong> Comparable, Serializable{</p>
<p><strong>public static final</strong> Coin PENNY =
<strong>new</strong> Coin(1);</p>
<p><strong>public static final</strong> Coin NICKEL =
<strong>new</strong> Coin(5);</p>
<p><strong>public static final</strong> Coin DIME = <strong>new</strong>
Coin(10);</p>
<p><strong>public static final</strong> Coin QUARTER =
<strong>new</strong> Coin(25);</p>
<p>private int <strong>value;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 192</p>
<p><span id="private_Coin_int_value"
class="anchor"></span><strong>private</strong> Coin(<strong>int</strong>
value){</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p><strong>public int</strong> getValue() {</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p>}</p>
<p><strong>int</strong> p = Coin.NICKEL.getValue(); <em>// the int value
will be 5</em></p>
<p>Enum constants are technically mutable, so a setter could be added to
change the internal structure of an enum</p>
<p>constant. However, this is considered very bad practice and should be
avoided.</p>
<p>Best practice is to make Enum fields immutable, with
<strong>final</strong>:</p>
<p>public enum <strong>Coin {</strong></p>
<p>PENNY(1), NICKEL(5), DIME(10), QUARTER(25);</p>
<p>private final int <strong>value;</strong></p>
<p>Coin(<strong>int</strong> value){</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>You may define multiple constructors in the same enum. When you do,
the arguments you pass in your enum declaration decide which constructor
is called:</p>
<p>public enum <strong>Coin {</strong></p>
<p>PENNY(1, <strong>true</strong>), NICKEL(5, <strong>false</strong>),
DIME(10), QUARTER(25);</p>
<p>private final int <strong>value;</strong></p>
<p>private final boolean <strong>isCopperColored;</strong></p>
<p>Coin(<strong>int</strong> value){</p>
<p><strong>this</strong>(value, <strong>false</strong>);</p>
<p>}</p>
<p>Coin(<strong>int</strong> value, <strong>boolean</strong>
isCopperColored){</p>
<p><strong>this</strong>.value = value;</p>
<p><strong>this</strong>.isCopperColored = isCopperColored;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html">Note:
All non-primitive enum fields should implement Serializable</a> because
the <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html"><strong>Enum</strong></a>
class does.</p>
<p>Section 35.3: Enums with Abstract Methods</p>
<p>Enums can define abstract methods, which each <strong>enum</strong>
member is required to implement.</p>
<p><strong>enum</strong> Action {</p>
<p>DODGE {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 193</p>
<p><span id="public_boolean_execute_Player_pl"
class="anchor"></span><strong>public boolean</strong> execute(Player
player) {</p>
<p><strong>return</strong> player.isAttacking();</p>
<p>}</p>
<p>},</p>
<p>ATTACK {</p>
<p><strong>public boolean</strong> execute(Player player) {</p>
<p><strong>return</strong> player.hasWeapon();</p>
<p>}</p>
<p>},</p>
<p>JUMP {</p>
<p><strong>public boolean</strong> execute(Player player) {</p>
<p><strong>return</strong>
player.getCoordinates().equals(<strong>new</strong> Coordinates(0,
0));</p>
<p>}</p>
<p>};</p>
<p><strong>public abstract boolean</strong> execute(Player player);</p>
<p>}</p>
<p>This allows for each enum member to define its own behaviour for a
given operation, without having to switch on</p>
<p>types in a method in the top-level definition.</p>
<p>Note that this pattern is a short form of what is typically achieved
using polymorphism and/or implementing</p>
<p>interfaces.</p>
<p>Section 35.4: Implements Interface</p>
<p>This is an <strong>enum</strong> that is also a callable function
that tests String inputs against precompiled regular expression</p>
<p>patterns.</p>
<p><strong>import</strong> java.util.function.Predicate;</p>
<p><strong>import</strong> java.util.regex.Pattern;</p>
<p><strong>enum</strong> RegEx <strong>implements</strong> Predicate
{</p>
<p>UPPER("[A-Z]+"), LOWER("[a-z]+"), NUMERIC("[+-]?[0-9]+");</p>
<p><strong>private final</strong> Pattern pattern;</p>
<p><strong>private</strong> RegEx(<strong>final</strong> String pattern)
{</p>
<p><strong>this</strong>.pattern = Pattern.compile(pattern);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public boolean</strong> test(<strong>final</strong> String
input) {</p>
<p><strong>return this</strong>.pattern.matcher(input).matches();</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println(RegEx.UPPER.test("ABC"));</p>
<p>System.out.println(RegEx.LOWER.test("abc"));</p>
<p>System.out.println(RegEx.NUMERIC.test("+111"));</p>
<p>}</p>
<p>}</p>
<p>Each member of the enum can also implement the method:</p>
<p><strong>import</strong> java.util.function.Predicate;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 194</p>
<p><span id="enum_Acceptor_implements_Predica"
class="anchor"></span><strong>enum</strong> Acceptor
<strong>implements</strong> Predicate {</p>
<p>NULL <strong>{</strong></p>
<p>@Override</p>
<p><strong>public boolean</strong> test(String s) {
<strong>return</strong> s == <strong>null</strong>; }</p>
<p>},</p>
<p>EMPTY {</p>
<p>@Override</p>
<p><strong>public boolean</strong> test(String s) {
<strong>return</strong> s.equals(""); }</p>
<p>},</p>
<p>NULL_OR_EMPTY {</p>
<p>@Override</p>
<p><strong>public boolean</strong> test(String s) { <strong>return
NULL</strong>.test(s) || EMPTY.test(s); }</p>
<p>};</p>
<p>}</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println(Acceptor.<strong>NULL</strong>.test(<strong>null</strong>));
<em>// true</em> System.out.println(Acceptor.EMPTY.test("")); <em>//
true</em> System.out.println(Acceptor.NULL_OR_EMPTY.test(" ")); <em>//
false</em></p>
<p>}</p>
<p>}</p>
<p>Section 35.5: Implement Singleton pattern with a single-</p>
<p>element enum</p>
<p>Enum constants are instantiated when an enum is referenced for the
first time. Therefore, that allows to implement Singleton software
design pattern with a single-element enum.</p>
<p><strong>public enum</strong> Attendant {</p>
<p>INSTANCE;</p>
<p><strong>private</strong> Attendant() {</p>
<p>// perform some initialization routine</p>
<p>}</p>
<p><strong>public void</strong> sayHello() {</p>
<p>System.out.println("Hello!");</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String... args) {</p>
<p>Attendant.INSTANCE.sayHello();<em>// instantiated at this
point</em></p>
<p>}</p>
<p>}</p>
<p>According to "Effective Java" book by Joshua Bloch, a single-element
enum is the best way to implement a singleton.</p>
<p>This approach has following advantages:</p>
<p>thread safety</p>
<p>guarantee of single instantiation</p>
<p>out-of-the-box serialization</p>
<p>And as shown in the section implements interface this singleton might
also implement one or more interfaces.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 195</p>
<p><span id="Section_35_6__Using_methods_and"
class="anchor"></span>Section 35.6: Using methods and static blocks</p>
<p>An enum can contain a method, just like any class. To see how this
works, we'll declare an enum like this:</p>
<p><strong>public enum</strong> Direction {</p>
<p>NORTH, SOUTH, EAST, WEST;</p>
<p>}</p>
<p>Let's have a method that returns the enum in the opposite
direction:</p>
<p><strong>public enum</strong> Direction {</p>
<p>NORTH, SOUTH, EAST, WEST;</p>
<p><strong>public</strong> Direction getOpposite(){</p>
<p>switch <strong>(</strong>this<strong>){</strong></p>
<p><strong>case</strong> NORTH:</p>
<p><strong>return</strong> SOUTH;</p>
<p><strong>case</strong> SOUTH:</p>
<p><strong>return</strong> NORTH;</p>
<p><strong>case</strong> WEST:</p>
<p>return <strong>EAST;</strong></p>
<p><strong>case</strong> EAST:</p>
<p>return <strong>WEST;</strong></p>
<p><em><strong>default</strong>:</em> //This will never happen</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>This can be improved further through the use of fields and static
initializer blocks:</p>
<p><strong>public enum</strong> Direction {</p>
<p>NORTH, SOUTH, EAST, WEST;</p>
<p><strong>private</strong> Direction opposite;</p>
<p><strong>public</strong> Direction getOpposite(){</p>
<p><strong>return</strong> opposite;</p>
<p>}</p>
<p>static <strong>{</strong></p>
<p>NORTH.opposite = SOUTH;</p>
<p>SOUTH.opposite = NORTH;</p>
<p>WEST.opposite = EAST;</p>
<p>EAST.opposite = WEST;</p>
<p>}</p>
<p>}</p>
<p>In this example, the opposite direction is stored in a private
instance field opposite, which is statically initialized the</p>
<p>first time a Direction is used. In this particular case (because
NORTH references SOUTH and conversely), we cannot use Enums with
constructors here (Constructors NORTH(SOUTH), SOUTH(NORTH), EAST(WEST),
WEST(EAST) would</p>
<p>be more elegant and would allow opposite to be declared
<strong>final</strong>, but would be self-referential and therefore are
not allowed).</p>
<p>Section 35.7: Zero instance enum</p>
<p><strong>enum</strong> Util {</p>
<p>/* No instances */<em>;</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 196</p>
<p><span id="public_static_int_clamp_int_min"
class="anchor"></span>public static int <strong>clamp(</strong>int
<strong>min,</strong> int <strong>max,</strong> int <strong>i)
{</strong></p>
<p><strong>return</strong> Math.min(Math.max(i, min), max);</p>
<p>}</p>
<p>// other utility methods...</p>
<p>}</p>
<p>Just as <strong>enum</strong> can be used for singletons (1 instance
classes), it can be used for utility classes (0 instance classes).
Just</p>
<p>make sure to terminate the (empty) list of enum constants with a
;.</p>
<p>See the question <a
href="http://stackoverflow.com/questions/25137490/zero-instance-enum-vs-private-constructors-for-preventing-instantiation">Zero
instance enum vs private constructors for preventing instantiation for a
discussion on pro's</a></p>
<p>and con's compared to private constructors.</p>
<p>Section 35.8: Enum as a bounded type parameter</p>
<p>When writing a class with generics in java, it is possible to ensure
that the type parameter is an enum. Since all</p>
<p>enums extend the <strong>Enum</strong> class, the following syntax
may be used.</p>
<p><strong>public class</strong> Holderextends Enum&gt; {</p>
<p>public final <strong>T value;</strong></p>
<p><strong>public</strong> Holder(T init) {</p>
<p><strong>this</strong>.value = init;</p>
<p>}</p>
<p>}</p>
<p>In this example, the type T <em>must</em> be an enum.</p>
<p>Section 35.9: Documenting enums</p>
<p>Not always the <strong>enum</strong> name is clear enough to be
understood. To document an <strong>enum</strong>, use standard
javadoc:</p>
<p>/**</p>
<p>* United States coins</p>
<p>*/</p>
<p>public enum <strong>Coins {</strong></p>
<p>/**</p>
<p>* One-cent coin, commonly known as a penny,</p>
<p>* is a unit of currency equaling one-hundredth</p>
<p>* of a United States dollar</p>
<p>*/</p>
<p>PENNY(1),</p>
<p>/**</p>
<p>* A nickel is a five-cent coin equaling</p>
<p>* five-hundredth of a United States dollar</p>
<p>*/</p>
<p>NICKEL(5),</p>
<p>/**</p>
<p>* The dime is a ten-cent coin refers to</p>
<p>* one tenth of a United States dollar</p>
<p>*/</p>
<p>DIME(10),</p>
<p>/**</p>
<p>* The quarter is a US coin worth 25 cents,</p>
<p>* one-fourth of a United States dollar</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 197</p>
<p><span id="_6" class="anchor"></span> */</p>
<p>QUARTER(25);</p>
<p>private int <strong>value;</strong></p>
<p>Coins(<strong>int</strong> value){</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p><strong>public int</strong> getValue(){</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p>}</p>
<p>Section 35.10: Enum constant specific body</p>
<p>In an <strong>enum</strong> it is possible to define a specific
behavior for a particular constant of the <strong>enum</strong> which
overrides the</p>
<p>default behavior of the <strong>enum</strong>, this technique is
known as <em>constant specific body</em>.</p>
<p>Suppose three piano students - John, Ben and Luke - are defined in an
<strong>enum</strong> named PianoClass, as follows:</p>
<p><strong>enum</strong> PianoClass {</p>
<p>JOHN, BEN, LUKE;</p>
<p><strong>public</strong> String getSex() {</p>
<p><strong>return</strong> "Male";</p>
<p>}</p>
<p><strong>public</strong> String getLevel() {</p>
<p><strong>return</strong> "Beginner";</p>
<p>}</p>
<p>}</p>
<p>And one day two other students arrive - Rita and Tom - with a sex
(Female) and level (Intermediate) that do not match the previous
ones:</p>
<p><strong>enum</strong> PianoClass2 {</p>
<p>JOHN, BEN, LUKE, RITA, TOM;</p>
<p><strong>public</strong> String getSex() {</p>
<p><em><strong>return</strong> "Male";</em> // issue, Rita is a
female</p>
<p>}</p>
<p><strong>public</strong> String getLevel() {</p>
<p><em><strong>return</strong> "Beginner";</em> // issue, Tom is an
intermediate student</p>
<p>}</p>
<p>}</p>
<p>so that simply adding the new students to the constant declaration,
as follows, is not correct:</p>
<p>PianoClass2 tom = PianoClass2.TOM;</p>
<p>PianoClass2 rita = PianoClass2.RITA;</p>
<p><em>System.out.println(tom.getLevel());</em> // prints Beginner -&gt;
wrong Tom's not a beginner <em>System.out.println(rita.getSex());</em>
// prints Male -&gt; wrong Rita's not a male</p>
<p>It's possible to define a specific behavior for each of the constant,
Rita and Tom, which overrides the PianoClass2</p>
<p>default behavior as follows:</p>
<p><strong>enum</strong> PianoClass3 {</p>
<p>JOHN, BEN, LUKE,</p>
<p>RITA {</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 198</p>
<p><span id="public_String_getSex"
class="anchor"></span><strong>public</strong> String getSex() {</p>
<p><strong>return</strong> "Female";</p>
<p>}</p>
<p>},</p>
<p>TOM {</p>
<p>@Override</p>
<p><strong>public</strong> String getLevel() {</p>
<p><strong>return</strong> "Intermediate";</p>
<p>}</p>
<p>};</p>
<p><strong>public</strong> String getSex() {</p>
<p><strong>return</strong> "Male";</p>
<p>}</p>
<p><strong>public</strong> String getLevel() {</p>
<p><strong>return</strong> "Beginner";</p>
<p>}</p>
<p>}</p>
<p>and now Tom's level and Rita's sex are as they should be:</p>
<p>PianoClass3 tom = PianoClass3.TOM;</p>
<p>PianoClass3 rita = PianoClass3.RITA;</p>
<p>System.out.println(tom.getLevel()); <em>// prints Intermediate</em>
System.out.println(rita.getSex()); <em>// prints Female</em></p>
<p>Another way to define content specific body is by using constructor,
for instance:</p>
<p><strong>enum</strong> Friend {</p>
<p>MAT("Male"),</p>
<p>JOHN("Male"),</p>
<p>JANE("Female");</p>
<p><strong>private</strong> String gender;</p>
<p>Friend(String gender) {</p>
<p><strong>this</strong>.gender = gender;</p>
<p>}</p>
<p><strong>public</strong> String getGender() {</p>
<p>return this<strong>.gender;</strong></p>
<p>}</p>
<p>}</p>
<p>and usage:</p>
<p>Friend mat = Friend.MAT;</p>
<p>Friend john = Friend.JOHN;</p>
<p>Friend jane = Friend.JANE;</p>
<p>System.out.println(mat.getGender()); <em>// Male</em></p>
<p>System.out.println(john.getGender()); <em>// Male</em></p>
<p>System.out.println(jane.getGender()); <em>// Female</em></p>
<p>Section 35.11: Getting the values of an enum</p>
<p>Each enum class contains an implicit static method named values().
This method returns an array containing all</p>
<p>values of that enum. You can use this method to iterate over the
values. It is important to note however that this</p>
<p>method returns a <strong>new</strong> array every time it is
called.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 199</p>
<p><span id="public_enum_Day" class="anchor"></span>public enum
<strong>Day {</strong></p>
<p>MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</p>
<p>/**</p>
<p>* Print out all the values in this enum.</p>
<p>*/</p>
<p>public static void <strong>printAllDays() {</strong></p>
<p><strong>for</strong>(Day day : Day.values()) {</p>
<p>System.out.println(day.name());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>If you need a Set you can use
EnumSet.allOf(Day.<strong>class</strong>) as well.</p>
<p>Section 35.12: Enum Polymorphism Pattern</p>
<p>When a method need to accept an "extensible" set of
<strong>enum</strong> values, the programmer can apply polymorphism like
on a normal <strong>class</strong> by creating an interface which will
be used anywere where the <strong>enum</strong>s shall be used:</p>
<p><strong>public interface</strong> ExtensibleEnum {</p>
<p>String name();</p>
<p>}</p>
<p>This way, any <strong>enum</strong> tagged by (implementing) the
interface can be used as a parameter, allowing the programmer to</p>
<p>create a variable amount of <strong>enum</strong>s that will be
accepted by the method. This can be useful, for example, in APIs where
there is a default (unmodifiable) <strong>enum</strong> and the user of
these APIs want to "extend" the <strong>enum</strong> with more
values.</p>
<p>A set of default enum values can be defined as follows:</p>
<p><strong>public enum</strong> DefaultValues
<strong>implements</strong> ExtensibleEnum {</p>
<p>VALUE_ONE, VALUE_TWO;</p>
<p>}</p>
<p>Additional values can then be defined like this:</p>
<p><strong>public enum</strong> ExtendedValues
<strong>implements</strong> ExtensibleEnum {</p>
<p>VALUE_THREE, VALUE_FOUR;</p>
<p>}</p>
<p>Sample which shows how to use the enums - note how printEnum()
accepts values from both <strong>enum</strong> types:</p>
<p><strong>private void</strong> printEnum(ExtensibleEnum val) {</p>
<p>System.out.println(val.name());</p>
<p>}</p>
<p>printEnum(DefaultValues.VALUE_ONE); <em>// VALUE_ONE</em></p>
<p>printEnum(DefaultValues.VALUE_TWO); <em>// VALUE_TWO</em></p>
<p>printEnum(ExtendedValues.VALUE_THREE); <em>// VALUE_THREE</em>
printEnum(ExtendedValues.VALUE_FOUR); <em>// VALUE_FOUR</em></p>
<p>Note: This pattern does not prevent you from redefining enum values,
which are already defined in one enum, in another enum. These enum
values would be different instances then. Also, it is not possible to
use switch-on-enum</p>
<p>since all we have is the interface, not the real
<strong>enum</strong>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 200</p>
<p><span id="Section_35_13__Compare_and_Conta"
class="anchor"></span>Section 35.13: Compare and Contains for Enum
values</p>
<p>Enums contains only constants and can be compared directly with ==.
So, only reference check is needed, no need</p>
<p>to use .equals method. Moreover, if .equals used incorrectly, may
raise the NullPointerException while that's</p>
<p>not the case with == check.</p>
<p><strong>enum</strong> Day {</p>
<p>GOOD, AVERAGE, WORST;</p>
<p>}</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Day day = <strong>null</strong>;</p>
<p><strong>if</strong> (day.equals(Day.GOOD))
{<em>//NullPointerException!</em></p>
<p>System.out.println("Good Day!");</p>
<p>}</p>
<p><em><strong>if</strong> (day == Day.GOOD) {</em>//Always use == to
compare enum</p>
<p>System.out.println("Good Day!");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>To group, complement, range the enum values we have <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html">EnumSet</a>
class which contains different methods.</p>
<p>EnumSet#range : To get subset of enum by range defined by two
endpoints</p>
<p>EnumSet#of : Set of specific enums without any range. Multiple
overloaded of methods are there.</p>
<p>EnumSet#complementOf : Set of enum which is complement of enum values
provided in method parameter</p>
<p><strong>enum</strong> Page {</p>
<p>A1, A2, A3, A4, A5, A6, A7, A8, A9, A10</p>
<p>}</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>EnumSet range = EnumSet.range(Page.A1, Page.A5);</p>
<p><strong>if</strong> (range.contains(Page.A4)) {</p>
<p>System.out.println("Range contains A4");</p>
<p>}</p>
<p>EnumSet of = EnumSet.of(Page.A1, Page.A5, Page.A3);</p>
<p><strong>if</strong> (of.contains(Page.A1)) {</p>
<p>System.out.println("Of contains A1");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 35.14: Get enum constant by name</p>
<p>Say we have an enum DayOfWeek:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 201</p>
<p><span id="enum_DayOfWeek" class="anchor"></span><strong>enum</strong>
DayOfWeek {</p>
<p>SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY; }</p>
<p>An enum is compiled with a built-in static valueOf() method which can
be used to lookup a constant by its name:</p>
<p>String dayName = DayOfWeek.SUNDAY.name();</p>
<p><strong>assert</strong> dayName.equals("SUNDAY");</p>
<p>DayOfWeek day = DayOfWeek.valueOf(dayName);</p>
<p><strong>assert</strong> day == DayOfWeek.SUNDAY;</p>
<p>This is also possible using a dynamic enum type:</p>
<p>Class enumType = DayOfWeek.<strong>class</strong>;</p>
<p>DayOfWeek day = <strong>Enum</strong>.valueOf(enumType,
"SUNDAY");</p>
<p><strong>assert</strong> day == DayOfWeek.SUNDAY;</p>
<p>Both of these valueOf() methods will throw an
IllegalArgumentException if the specified enum does not have a constant
with a matching name.</p>
<p><a
href="https://google.github.io/guava/releases/18.0/api/docs/com/google/common/base/Enums.html#getIfPresent(java.lang.Class,%20java.lang.String)">The
Guava library provides a helper method Enums.getIfPresent()</a> that
returns a Guava <a
href="https://google.github.io/guava/releases/18.0/api/docs/com/google/common/base/Optional.html">Optional
to eliminate</a> explicit exception handling:</p>
<p>DayOfWeek defaultDay = DayOfWeek.SUNDAY;</p>
<p>DayOfWeek day = Enums.valueOf(DayOfWeek.<strong>class</strong>,
"INVALID").or(defaultDay); <strong>assert</strong> day ==
DayOfWeek.SUNDAY;</p>
<p>Section 35.15: Enum with properties (fields)</p>
<p>In case we want to use <strong>enum</strong> with more information
and not just as constant values, and we want to be able to</p>
<p>compare two enums.</p>
<p>Consider the following example:</p>
<p>public enum <strong>Coin {</strong></p>
<p>PENNY(1), NICKEL(5), DIME(10), QUARTER(25);</p>
<p>private final int <strong>value;</strong></p>
<p>Coin(<strong>int</strong> value){</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p><strong>public boolean</strong> isGreaterThan(Coin other){</p>
<p><strong>return this</strong>.value &gt; other.value;</p>
<p>}</p>
<p>}</p>
<p>Here we defined an <strong>Enum</strong> called Coin which represent
its value. With the method isGreaterThan we can compare</p>
<p>two <strong>enum</strong>s:</p>
<p>Coin penny = Coin.PENNY;</p>
<p>Coin dime = Coin.DIME;</p>
<p>System.out.println(penny.isGreaterThan(dime)); <em>// prints:
false</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 202</p>
<p><span id="System_out_println_dime_isGreate"
class="anchor"></span>System.out.println(dime.isGreaterThan(penny));
<em>// prints: true</em></p>
<p>Section 35.16: Convert enum to String</p>
<p>Sometimes you want to convert your enum to a String, there are two
ways to do that.</p>
<p>Assume we have:</p>
<p>public enum <strong>Fruit {</strong></p>
<p>APPLE, ORANGE, STRAWBERRY, BANANA, LEMON, GRAPE_FRUIT; }</p>
<p>So how do we convert something like Fruit.APPLE to "APPLE"?</p>
<p>Convert using name()</p>
<p>name() is an internal method in <strong>enum</strong> that returns
the String representation of the enum, the return String</p>
<p>represents <em><strong>exactly</strong></em> how the enum value was
defined.</p>
<p>For example:</p>
<p>System.out.println(Fruit.BANANA.name()); <em>// "BANANA"</em>
System.out.println(Fruit.GRAPE_FRUIT.name()); <em>//
"GRAPE_FRUIT"</em></p>
<p>Convert using toString()</p>
<p>toString() is, <em>by default</em>, overridden to have the same
behavior as name()</p>
<p>However, toString() is likely overridden by <em>developers</em> to
make it print a more user friendly String</p>
<p>Don't use toString() if you want to do checking in your code, name()
is much more stable for that. Only</p>
<p>use toString() when you are going to output the value to logs or
stdout or something</p>
<p>By default:</p>
<p>System.out.println(Fruit.BANANA.toString()); <em>// "BANANA"</em>
System.out.println(Fruit.GRAPE_FRUIT.toString()); <em>//
"GRAPE_FRUIT"</em></p>
<p>Example of being overridden</p>
<p>System.out.println(Fruit.BANANA.toString()); <em>// "Banana"</em>
System.out.println(Fruit.GRAPE_FRUIT.toString()); <em>// "Grape
Fruit"</em></p>
<p>Section 35.17: Enums with static fields</p>
<p>If your enum class is required to have static fields, keep in mind
they are created <strong>after</strong> the enum values</p>
<p>themselves. That means, the following code will result in a
NullPointerException:</p>
<p><strong>enum</strong> Example {</p>
<p>ONE(1), TWO(2);</p>
<p><strong>static</strong> Map integers = <strong>new</strong>
HashMap&lt;&gt;();</p>
<p><strong>private</strong> Example(<strong>int</strong> value) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 203</p>
<p>integers.put(<strong>this</strong>.name(), value);</p>
<p>}</p>
<p>}</p>
<p>A possible way to fix this:</p>
<p><strong>enum</strong> Example {</p>
<p>ONE(1), TWO(2);</p>
<p><strong>static</strong> Map integers;</p>
<p><strong>private</strong> Example(<strong>int</strong> value) {</p>
<p>putValue(<strong>this</strong>.name(), value);</p>
<p>}</p>
<p><strong>private static void</strong> putValue(String name,
<strong>int</strong> value) {</p>
<p><strong>if</strong> (integers == <strong>null</strong>)</p>
<p>integers = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>integers.put(name, value);</p>
<p>}</p>
<p>}</p>
<p>Do not initialize the static field:</p>
<p><strong>enum</strong> Example {</p>
<p>ONE(1), TWO(2);</p>
<p>// after initialisisation integers is null!!</p>
<p><strong>static</strong> Map integers = <strong>null</strong>;</p>
<p><strong>private</strong> Example(<strong>int</strong> value) {</p>
<p>putValue(<strong>this</strong>.name(), value);</p>
<p>}</p>
<p><strong>private static void</strong> putValue(String name,
<strong>int</strong> value) {</p>
<p><strong>if</strong> (integers == <strong>null</strong>)</p>
<p>integers = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>integers.put(name, value);</p>
<p>}</p>
<p>// !!this may lead to null poiner exception!!</p>
<p><strong>public int</strong> getValue(){</p>
<p><strong>return</strong>
(Example.integers.get(<strong>this</strong>.name()));</p>
<p>}</p>
<p>}</p>
<p>initialisisation:</p>
<p>create the enum values</p>
<p>as side effect putValue() called that initializes integers</p>
<p>the static values are set</p>
<p>integers = null; // is executed after the enums so the content of
integers is lost</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 204</p>
<p><span id="Chapter_36__Enum_Map_1" class="anchor"></span>Chapter 36:
Enum Map</p>
<p>Java EnumMap class is the specialized Map implementation for enum
keys. It inherits Enum and AbstractMap</p>
<p>classes.</p>
<p>the Parameters for java.util.EnumMap class.</p>
<p>K: It is the type of keys maintained by this map. V: It is the type
of mapped values.</p>
<p>Section 36.1: Enum Map Book Example</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>class</strong> Book {</p>
<p><strong>int</strong> id;</p>
<p>String name,author,publisher;</p>
<p><strong>int</strong> quantity;</p>
<p><strong>public</strong> Book(<strong>int</strong> id, String name,
String author, String publisher, <strong>int</strong> quantity) {</p>
<p><strong>this</strong>.id = id;</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.author = author;</p>
<p><strong>this</strong>.publisher = publisher;</p>
<p><strong>this</strong>.quantity = quantity;</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> EnumMapExample {</p>
<p>// Creating enum</p>
<p>public enum <strong>Key{</strong></p>
<p>One, Two, Three</p>
<p>};</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>EnumMap map = <strong>new</strong>
EnumMap(Key.<strong>class</strong>);</p>
<p>// Creating Books</p>
<p>Book b1=<strong>new</strong> Book(101,"Let us C","Yashwant
Kanetkar","BPB",8); Book b2=<strong>new</strong> Book(102,"Data
Communications &amp; Networking","Forouzan","Mc Graw Hill",4); Book
b3=<strong>new</strong> Book(103,"Operating System","Galvin","Wiley",6);
<em>// Adding Books to Map</em></p>
<p>map.put(Key.One, b1);</p>
<p>map.put(Key.Two, b2);</p>
<p>map.put(Key.Three, b3);</p>
<p>// Traversing EnumMap</p>
<p><strong>for</strong>(Map.Entry entry:map.entrySet()){</p>
<p>Book b=entry.getValue();</p>
<p>System.out.println(b.id+" "+b.name+" "+b.author+" "+b.publisher+"
"+b.quantity);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 205</p>
<p><span id="Chapter_37__EnumSet_class_1" class="anchor"></span>Chapter
37: EnumSet class</p>
<p>Java EnumSet class is the specialized Set implementation for use with
enum types. It inherits AbstractSet class and</p>
<p>implements the Set interface.</p>
<p>Section 37.1: Enum Set Example</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>enum</strong> days {</p>
<p>SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY }</p>
<p><strong>public class</strong> EnumSetExample {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Set set = EnumSet.of(days.TUESDAY, days.WEDNESDAY);</p>
<p>// Traversing elements</p>
<p>Iterator iter = set.iterator();</p>
<p><strong>while</strong> (iter.hasNext())</p>
<p>System.out.println(iter.next());</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 206</p>
<p><span id="Chapter_38__Enum_starting_with_n_1"
class="anchor"></span>Chapter 38: Enum starting with number</p>
<p>Java does not allow the name of enum to start with number like 100A,
25K. In that case, we can append the code</p>
<p>with _ (underscore) or any allowed pattern and make check of it.</p>
<p>Section 38.1: Enum with name at beginning</p>
<p>public enum <strong>BookCode {</strong></p>
<p>_10A("Simon Haykin", "Communication System"),</p>
<p>_42B("Stefan Hakins", "A Brief History of Time"),</p>
<p>E1("Sedra Smith", "Electronics Circuits");</p>
<p><strong>private</strong> String author;</p>
<p><strong>private</strong> String title;</p>
<p>BookCode(String author, String title) {</p>
<p><strong>this</strong>.author = author;</p>
<p><strong>this</strong>.title = title;</p>
<p>}</p>
<p><strong>public</strong> String getName() {</p>
<p>String name = name();</p>
<p><strong>if</strong> (name.charAt(0) == '_') {</p>
<p>name = name.substring(1, name.length());</p>
<p>}</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public static</strong> BookCode of(String code) {</p>
<p><strong>if</strong> (Character.isDigit(code.charAt(0))) {</p>
<p>code = "_" + code;</p>
<p>}</p>
<p><strong>return</strong> BookCode.valueOf(code);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 207</p>
<p><span id="Chapter_39__Hashtable_1" class="anchor"></span>Chapter 39:
Hashtable</p>
<p><strong>Hashtable</strong> is a class in Java collections which
implements Map interface and extends the Dictionary Class</p>
<p>Contains only unique elements and its synchronized</p>
<p>Section 39.1: Hashtable</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>public class</strong> HashtableDemo {</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>// create and populate hash table</p>
<p>Hashtable map = <strong>new</strong> Hashtable();</p>
<p>map.put(101,"C Language");</p>
<p>map.put(102, "Domain");</p>
<p>map.put(104, "Databases");</p>
<p>System.out.println("Values before remove: "+ map); <em>// Remove
value for key 102</em></p>
<p>map.remove(102);</p>
<p>System.out.println("Values after remove: "+ map);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 208</p>
<p><span id="Chapter_40__Operators_1" class="anchor"></span>Chapter 40:
Operators</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html">Operators
in Java programming language are special symbols that perform specific
operations on one, two, or</a></p>
<p>three operands, and then return a result.</p>
<p>Section 40.1: The Increment/Decrement Operators (++/--)</p>
<p>Variables can be incremented or decremented by 1 using the ++ and --
operators, respectively.</p>
<p>When the ++ and -- operators follow variables, they are called
<strong>post-increment</strong> and <strong>post-decrement</strong>
respectively.</p>
<p><strong>int</strong> a = 10;</p>
<p><em>a++;</em> // a now equals 11</p>
<p><em>a--;</em> // a now equals 10 again</p>
<p>When the ++ and -- operators precede the variables the operations are
called <strong>pre-increment</strong> and
<strong>pre-decrement</strong></p>
<p>respectively.</p>
<p><strong>int</strong> x = 10;</p>
<p><em>--x;</em> // x now equals 9</p>
<p><em>++x;</em> // x now equals 10</p>
<p>If the operator precedes the variable, the value of the expression is
the value of the variable after being</p>
<p>incremented or decremented. If the operator follows the variable, the
value of the expression is the value of the variable prior to being
incremented or decremented.</p>
<p><strong>int</strong> x=10;</p>
<p>System.out.println("x=" + x + " x=" + x++ + " x=" + x); <em>//
outputs x=10 x=10 x=11</em> System.out.println("x=" + x + " x=" + ++x +
" x=" + x); <em>// outputs x=11 x=12 x=12</em> System.out.println("x=" +
x + " x=" + x--+ " x=" + x); <em>// outputs x=12 x=12 x=11</em>
System.out.println("x=" + x + " x=" +--x + " x=" + x); <em>// outputs
x=11 x=10 x=10</em></p>
<p>Be careful not to overwrite post-increments or decrements. This
happens if you use a post-in/decrement operator</p>
<p>at the end of an expression which is reassigned to the in/decremented
variable itself. The in/decrement will not have an effect. Even though
the variable on the left hand side is incremented correctly, its value
will be immediately</p>
<p>overwritten with the previously evaluated result from the right hand
side of the expression:</p>
<p><strong>int</strong> x = 0;</p>
<p>x = x++ + 1 + x++; <em>// x = 0 + 1 + 1</em></p>
<p>// do not do this - the last increment has no effect (bug!)</p>
<p>System.out.println(x); <em>// prints 2 (not 3!)</em></p>
<p>Correct:</p>
<p><strong>int</strong> x = 0;</p>
<p><em>x = x++ + 1 + x;</em> // evaluates to x = 0 + 1 + 1</p>
<p><em>x++;</em> // adds 1</p>
<p>System.out.println(x); <em>// prints 3</em></p>
<p>Section 40.2: The Conditional Operator (? :)</p>
<p>Syntax</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 209</p>
<p>{condition-to-evaluate} <em><strong>?</strong></em>
{statement-executed-on-true} <em><strong>:</strong></em>
{statement-executed-on-false}</p>
<p>As shown in the syntax, the Conditional Operator (also known as the
Ternary Operator1) uses the ? (question mark)</p>
<p>and : (colon) characters to enable a conditional expression of two
possible outcomes. It can be used to replace longer
if-<strong>else</strong> blocks to return one of two values based on
condition.</p>
<p>result = testCondition ? value1 : value2</p>
<p>Is equivalent to</p>
<p><strong>if</strong> (testCondition) {</p>
<p>result = value1;</p>
<p>} <strong>else</strong> {</p>
<p>result = value2;</p>
<p>}</p>
<p><em><strong>It can be read as “</strong></em>If testCondition is
true, set result to value1; otherwise, set result to
value2<em><strong>”</strong></em>.</p>
<p>For example:</p>
<p>// get absolute value using conditional operator</p>
<p>a =-10;</p>
<p><strong>int</strong> absValue = a &lt; 0 ?-a : a;</p>
<p>System.out.println("abs = " + absValue); <em>// prints "abs =
10"</em></p>
<p>Is equivalent to</p>
<p>// get absolute value using if/else loop</p>
<p>a =-10;</p>
<p><strong>int</strong> absValue;</p>
<p><strong>if</strong> (a &lt; 0) {</p>
<p>absValue =-a;</p>
<p>} <strong>else</strong> {</p>
<p>absValue = a;</p>
<p>}</p>
<p>System.out.println("abs = " + absValue); <em>// prints "abs =
10"</em></p>
<p>Common Usage</p>
<p>You can use the conditional operator for conditional assignments
(like null checking).</p>
<p>String x = y != <strong>null</strong> ? y.toString() : "";
<em>//where y is an object</em></p>
<p>This example is equivalent to:</p>
<p>String x = "";</p>
<p><strong>if</strong> (y != <strong>null</strong>) {</p>
<p>x = y.toString();</p>
<p>}</p>
<p>Since the Conditional Operator has the second-lowest precedence,
above the Assignment Operators, there is rarely</p>
<p>a need for use parenthesis around the <em>condition</em>, but
parenthesis is required around the entire Conditional Operator construct
when combined with other operators:</p>
<p>// no parenthesis needed for expressions in the 3 parts</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 210</p>
<p><span id="10____a____a___19___b___5___b" class="anchor"></span>10
&lt;= a &amp;&amp; a &lt; 19 ? b * 5 : b * 7</p>
<p>// parenthesis required</p>
<p>7 * (a &gt; 0 ? 2 : 5)</p>
<p>Conditional operators nesting can also be done in the third part,
where it works more like chaining or like a switch</p>
<p>statement.</p>
<p>a ? "a is true" :</p>
<p>b ? "a is false, b is true" :</p>
<p>c ? "a and b are false, c is true" :</p>
<p>"a, b, and c are false"</p>
<p>//Operator precedence can be illustrated with parenthesis:</p>
<p>a ? x : (b ? y : (c ? z : w))</p>
<p>Footnote:</p>
<p>1 - Both the <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25">Java
Language Specification and the</a> <a
href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html">Java
Tutorial</a> call the (? :) operator the <em>Conditional Operator</em>.
The</p>
<p>Tutorial says that it is "also known as the Ternary Operator" as it
is (currently) the only ternary operator defined by Java. The
"Conditional Operator" terminology is consistent with C and C++ and
other languages with an equivalent</p>
<p>operator.</p>
<p>Section 40.3: The Bitwise and Logical Operators (~, &amp;, |, ^)</p>
<p>The Java language provides 4 operators that perform bitwise or
logical operations on integer or boolean operands.</p>
<p>The complement (~) operator is a unary operator that performs a
bitwise or logical inversion of the bits of</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.15.5">one
operand; see JLS 15.15.5.</a>.</p>
<p>The AND (&amp;) operator is a binary operator that performs a bitwise
or logical "and" of two operands; see <a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">JLS</a></p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">15.22.2.</a>.</p>
<p>The OR (|) operator is a binary operator that performs a bitwise or
logical "inclusive or" of two operands; see</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">JLS
15.22.2.</a>.</p>
<p>The XOR (^) operator is a binary operator that performs a bitwise or
logical "exclusive or" of two operands;</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2">see
JLS 15.22.2.</a>.</p>
<p>The logical operations performed by these operators when the operands
are booleans can be summarized as follows:</p>
<p>A B ~A A &amp; B A | B A ^ B</p>
<p>0 0 1 0 0 0</p>
<p>0 1 1 0 1 1</p>
<p>1 0 0 0 1 1</p>
<p>1 1 0 1 1 0</p>
<p>Note that for integer operands, the above table describes what
happens for individual bits. The operators actually</p>
<p>operate on all 32 or 64 bits of the operand or operands in
parallel.</p>
<p>Operand types and result types.</p>
<p>The usual arithmetic conversions apply when the operands are
integers. Common use-cases for the bitwise</p>
<p>operators</p>
<p>The ~ operator is used to reverse a boolean value, or change all the
bits in an integer operand.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 211</p>
<p><span id="The___operator_is_used_for__mask" class="anchor"></span>The
&amp; operator is used for "masking out" some of the bits in an integer
operand. For example:</p>
<p><strong>int</strong> word = 0b00101010;</p>
<p><em><strong>int</strong> mask = 0b00000011;</em> // Mask for masking
out all but the bottom</p>
<p>// two bits of a word</p>
<p><strong>int</strong> lowBits = word &amp; mask; <em>// -&gt;
0b00000010</em></p>
<p><strong>int</strong> highBits = word &amp; ~mask; <em>// -&gt;
0b00101000</em></p>
<p>The | operator is used to combine the truth values of two operands.
For example:</p>
<p><strong>int</strong> word2 = 0b01011111;</p>
<p>// Combine the bottom 2 bits of word1 with the top 30 bits of word2
<em><strong>int</strong> combined = (word &amp; mask) | (word2 &amp;
~mask);</em> // -&gt; 0b01011110</p>
<p>The ^ operator is used for toggling or "flipping" bits:</p>
<p><strong>int</strong> word3 = 0b00101010;</p>
<p><strong>int</strong> word4 = word3 ^ mask; <em>// -&gt;
0b00101001</em></p>
<p>For more examples of the use of the bitwise operators, see Bit
Manipulation</p>
<p>Section 40.4: The String Concatenation Operator (+)</p>
<p>The + symbol can mean three distinct operators in Java:</p>
<p>If there is no operand before the +, then it is the unary Plus
operator. If there are two operands, and they are both numeric. then it
is the binary Addition operator.</p>
<p>If there are two operands, and at least one of them is a String, then
it it the binary Concatenation operator.</p>
<p>In the simple case, the Concatenation operator joins two strings to
give a third string. For example:</p>
<p>String s1 = "a String";</p>
<p><em>String s2 = "This is " + s1;</em> // s2 contains "This is a
String"</p>
<p>When one of the two operands is not a string, it is converted to a
String as follows:</p>
<p>An operand whose type is a primitive type is converted <em>as if</em>
by calling toString() on the boxed value.</p>
<p>An operand whose type is a reference type is converted by calling the
operand's toString() method. If the</p>
<p>operand is <strong>null</strong>, or if the toString() method returns
<strong>null</strong>, then the string literal "null" is used
instead.</p>
<p>For example:</p>
<p><strong>int</strong> one = 1;</p>
<p>String s3 = "One is " + one; <em>// s3 contains "One is 1"</em>
String s4 = <strong>null</strong> + " is null"; <em>// s4 contains "null
is null"</em> String s5 = "{1} is " + <strong>new int</strong>[]{1};
<em>// s5 contains something like</em></p>
<p>// "{} is [I@xxxxxxxx"</p>
<p>The explanation for the s5 example is that the toString() method on
array types is inherited from</p>
<p>java.lang.Object , and the behavior is to produce a string that
consists of the type name, and the object's identity hashcode.</p>
<p>The Concatenation operator is specified to create a new String
object, except in the case where the expression is a Constant
Expression. In the latter case, the expression is evaluated at compile
type, and its runtime value is</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 212</p>
<p>equivalent to a string literal. This means that there is no runtime
overhead in splitting a long string literal like this:</p>
<p>String typing = "The quick brown fox " +</p>
<p>"jumped over the " +</p>
<p><em>"lazy dog";</em> // constant expression</p>
<p>Optimization and efficiency</p>
<p>As noted above, with the exception of constant expressions, each
string concatenation expression creates a new String object. Consider
this code:</p>
<p><strong>public</strong> String stars(<strong>int</strong> count)
{</p>
<p>String res = "";</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; count; i++)
{</p>
<p>res = res + "*";</p>
<p>}</p>
<p>return <strong>res;</strong></p>
<p>}</p>
<p>In the method above, each iteration of the loop will create a new
String that is one character longer than the previous iteration. Each
concatenation copies all of the characters in the operand strings to
form the new String.</p>
<p>Thus, stars(N) will:</p>
<p>create N new String objects, and throw away all but the last one,</p>
<p>copy N * (N + 1) / 2 characters, and</p>
<p>generate O(N^2) bytes of garbage.</p>
<p>This is very expensive for large N. Indeed, any code that
concatenates strings in a loop is liable to have this problem. A better
way to write this would be as follows:</p>
<p><strong>public</strong> String stars(<strong>int</strong> count)
{</p>
<p>// Create a string builder with capacity 'count'</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder(count);</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; count; i++)
{</p>
<p>sb.append("*");</p>
<p>}</p>
<p><strong>return</strong> sb.toString();</p>
<p>}</p>
<p>Ideally, you should set the capacity of the StringBuilder, but if
this is not practical, the class will automatically <em>grow</em></p>
<p>the backing array that the builder uses to hold characters. (Note:
the implementation expands the backing array</p>
<p>exponentially. This strategy keeps that amount of character copying
to a O(N) rather than O(N^2).)</p>
<p>Some people apply this pattern to all string concatenations. However,
this is unnecessary because the JLS <em>allows</em> a Java compiler to
optimize string concatenations within a single expression. For
example:</p>
<p>String s1 = ...;</p>
<p>String s2 = ...;</p>
<p>String test = "Hello " + s1 + ". Welcome to " + s2 +
"<strong>\n</strong>";</p>
<p>will <em>typically</em> be optimized by the bytecode compiler to
something like this;</p>
<p>StringBuilder tmp = <strong>new</strong> StringBuilder();</p>
<p>tmp.append("Hello ")</p>
<p>tmp.append(s1 == <strong>null</strong> ? "null" + s1);</p>
<p>tmp.append("Welcome to ");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 213</p>
<p><span id="tmp_append_s2____null____null"
class="anchor"></span>tmp.append(s2 == <strong>null</strong> ? "null" +
s2);</p>
<p>tmp.append("<strong>\n</strong>");</p>
<p>String test = tmp.toString();</p>
<p>(The JIT compiler may optimize that further if it can deduce that s1
or s2 cannot be <strong>null</strong>.) But note that this optimization
is only permitted within a single expression.</p>
<p>In short, if you are concerned about the efficiency of string
concatenations:</p>
<p>Do hand-optimize if you are doing repeated concatenation in a loop
(or similar).</p>
<p>Don't hand-optimize a single concatenation expression.</p>
<p>Section 40.5: The Arithmetic Operators (+, -, *, /, %)</p>
<p>The Java language provides 7 operators that perform arithmetic on
integer and floating point values.</p>
<p>There are two + operators:</p>
<p>The binary addition operator adds one number to another one. (There
is also a binary + operator that performs string concatenation. That is
described in a separate example.)</p>
<p>The unary plus operator does nothing apart from triggering numeric
promotion (see below)</p>
<p>There are two - operators:</p>
<p>The binary subtraction operator subtracts one number from another
one.</p>
<p>The unary minus operator is equivalent to subtracting its operand
from zero.</p>
<p>The binary multiply operator (*) multiplies one number by
another.</p>
<p>The binary divide operator (/) divides one number by another. The
binary remainder1 operator (%) calculates the remainder when one number
is divided by another.</p>
<p>1. This is often incorrectly referred to as the "modulus" operator.
"Remainder" is the term that is used by the JLS. "Modulus" and
"remainder" are not the same thing.</p>
<p>Operand and result types, and numeric promotion</p>
<p>The operators require numeric operands and produce numeric results.
The operand types can be any primitive numeric type (i.e.
<strong>byte</strong>, <strong>short</strong>, <strong>char</strong>,
<strong>int</strong>, <strong>long</strong>, <strong>float</strong> or
<strong>double</strong>) or any numeric wrapper type define in
java.lang;</p>
<p>i.e. (Byte, Character, Short, Integer, Long, Float or Double.</p>
<p>The result type is determined base on the types of the operand or
operands, as follows:</p>
<p>If either of the operands is a <strong>double</strong> or Double,
then the result type is <strong>double</strong>.</p>
<p>Otherwise, if either of the operands is a <strong>float</strong> or
Float, then the result type is <strong>float</strong>.</p>
<p>Otherwise, if either of the operands is a <strong>long</strong> or
Long, then the result type is <strong>long</strong>. Otherwise, the
result type is <strong>int</strong>. This covers <strong>byte</strong>,
<strong>short</strong> and <strong>char</strong> operands as well as
`int.</p>
<p>The result type of the operation determines how the arithmetic
operation is performed, and how the operands are</p>
<p>handled</p>
<p>If the result type is <strong>double</strong>, the operands are
promoted to <strong>double</strong>, and the operation is performed
using 64-</p>
<p>bit (double precision binary) IEE 754 floating point arithmetic. If
the result type is <strong>float</strong>, the operands are promoted to
<strong>float</strong>, and the operation is performed using 32-bit</p>
<p>(single precision binary) IEE 754 floating point arithmetic.</p>
<p>If the result type is <strong>long</strong>, the operands are
promoted to <strong>long</strong>, and the operation is performed using
64-bit signed twos-complement binary integer arithmetic.</p>
<p>If the result type is <strong>int</strong>, the operands are promoted
to <strong>int</strong>, and the operation is performed using 32-bit
signed twos-complement binary integer arithmetic.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 214</p>
<p>Promotion is performed in two stages:</p>
<p>If the operand type is a wrapper type, the operand value is
<em>unboxed</em> to a value of the corresponding primitive</p>
<p>type.</p>
<p>If necessary, the primitive type is promoted to the required
type:</p>
<p>Promotion of integers to <strong>int</strong> or
<strong>long</strong> is loss-less.</p>
<p>Promotion of <strong>float</strong> to <strong>double</strong> is
loss-less.</p>
<p>Promotion of an integer to a floating point value can lead to loss of
precision. The conversion is</p>
<p>performed using IEE 768 "round-to-nearest" semantics.</p>
<p>The meaning of division</p>
<p>The / operator divides the left-hand operand n (the
<em>dividend</em>) and the right-hand operand d (the <em>divisor</em>)
and produces the result q (the <em>quotient</em>).</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.17.2">Java
integer division rounds towards zero. The JLS Section 15.17.2</a>
specifies the behavior of Java integer division as follows:</p>
<p>The quotient produced for operands n and d is an integer value q
whose magnitude is as large as possible</p>
<p>while satisfying |d ⋅ q| ≤ |n|. Moreover, q is positive when |n| ≥
|d| and n and d have the same sign, but q is negative when |n| ≥ |d| and
n and d have opposite signs.</p>
<p>There are a couple of special cases:</p>
<p>If the n is MIN_VALUE, and the divisor is -1, then integer overflow
occurs and the result is MIN_VALUE. No exception is thrown in this
case.</p>
<p>If d is 0, then `ArithmeticException is thrown.</p>
<p>Java floating point division has more edge cases to consider. However
the basic idea is that the result q is the value</p>
<p>that is closest to satisfying d . q = n.</p>
<p>Floating point division will never result in an exception. Instead,
operations that divide by zero result in an INF and</p>
<p>NaN values; see below.</p>
<p>The meaning of remainder</p>
<p>Unlike C and C++, the remainder operator in Java works with both
integer and floating point operations.</p>
<p>For integer cases, the result of a % b is defined to be the number r
such that (a / b) * b + r is equal to a, where /, * and + are the
appropriate Java integer operators. This applies in all cases except
when b is zero. That case,</p>
<p>remainder results in an ArithmeticException.</p>
<p>It follows from the above definition that a % b can be negative only
if a is negative, and it be positive only if a is</p>
<p>positive. Moreover, the magnitude of a % b is always less than the
magnitude of b.</p>
<p>Floating point remainder operation is a generalization of the integer
case. The result of a % b is the remainder r is</p>
<p>defined by the mathematical relation r = a -(b ⋅ q) where:</p>
<p>q is an integer,</p>
<p>it is negative only if a / b is negative an positive only if a / b is
positive, and</p>
<p>its magnitude is as large as possible without exceeding the magnitude
of the true mathematical quotient of a</p>
<p>and b.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 215</p>
<p><span id="Floating_point_remainder_can_pro"
class="anchor"></span>Floating point remainder can produce INF and NaN
values in edge-cases such as when b is zero; see below. It will not
throw an exception.</p>
<p>Important note:</p>
<p>The result of a floating-point remainder operation as computed by %
<strong>is not the same</strong> as that produced by</p>
<p>the remainder operation defined by IEEE 754. The IEEE 754 remainder
may be computed using the</p>
<p>Math.IEEEremainder library method.</p>
<p>Integer Overflow</p>
<p>Java 32 and 64 bit integer values are signed and use twos-complement
binary representation. For example, the</p>
<p>range of numbers representable as (32 bit) <strong>int</strong> -231
through +231 - 1.</p>
<p>When you add, subtract or multiple two N bit integers (N == 32 or
64), the result of the operation may be too large</p>
<p>to represent as an N bit integer. In this case, the operation leads
to <em>integer overflow</em>, and the result can be computed as
follows:</p>
<p>The mathematical operation is performed to give a intermediate
two's-complement representation of the</p>
<p>entire number. This representation will be larger than N bits.</p>
<p>The bottom 32 or 64 bits of the intermediate representation are used
as the result.</p>
<p>It should be noted that integer overflow does not result in
exceptions under any circumstances.</p>
<p>Floating point INF and NAN values</p>
<p>Java uses IEE 754 floating point representations for
<strong>float</strong> and <strong>double</strong>. These
representations have some special</p>
<p>values for representing values that fall outside of the domain of
Real numbers:</p>
<p>The "infinite" or INF values denote numbers that are too large. The
+INF value denote numbers that are too</p>
<p>large and positive. The -INF value denote numbers that are too large
and negative. The "indefinite" / "not a number" or NaN denote values
resulting from meaningless operations.</p>
<p>The INF values are produced by floating operations that cause
overflow, or by division by zero.</p>
<p>The NaN values are produced by dividing zero by zero, or computing
zero remainder zero.</p>
<p>Surprisingly, it is possible perform arithmetic using INF and NaN
operands without triggering exceptions. For</p>
<p>example:</p>
<p>Adding +INF and a finite value gives +INF.</p>
<p>Adding +INF and +INF gives +INF.</p>
<p>Adding +INF and -INF gives NaN.</p>
<p>Dividing by INF gives either +0.0 or -0.0.</p>
<p>All operations with one or more NaN operands give NaN.</p>
<p>For full details, please refer to the relevant subsections of <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html">JLS
15. Note that this is largely "academic". For typical</a> calculations,
an INF or NaN means that something has gone wrong; e.g. you have
incomplete or incorrect input data,</p>
<p>or the calculation has been programmed incorrectly.</p>
<p>Section 40.6: The Shift Operators (&lt;&lt;, &gt;&gt; and
&gt;&gt;&gt;)</p>
<p>The Java language provides three operator for performing bitwise
shifting on 32 and 64 bit integer values. These</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 216</p>
<p><span id="are_all_binary_operators_with_th" class="anchor"></span>are
all binary operators with the first operand being the value to be
shifted, and the second operand saying how far to shift.</p>
<p>The &lt;&lt; or <em>left shift</em> operator shifts the value given
by the first operand <em>leftwards</em> by the number of bit positions
given by the second operand. The empty positions at the right end are
filled with zeros.</p>
<p>The '&gt;&gt;' or <em>arithmetic shift</em> operator shifts the value
given by the first operand <em>rightwards</em> by the number of bit</p>
<p>positions given by the second operand. The empty positions at the
left end are filled by copying the left-most bit. This process is known
as <em>sign extension</em>.</p>
<p>The '&gt;&gt;&gt;' or <em>logical right shift</em> operator shifts
the value given by the first operand <em>rightwards</em> by the number
of</p>
<p>bit positions given by the second operand. The empty positions at the
left end are filled with zeros.</p>
<p>Notes:</p>
<p>1. These operators require an <strong>int</strong> or
<strong>long</strong> value as the first operand, and produce a value
with the same type as</p>
<p>the first operand. (You will need to use an explicit type cast when
assigning the result of a shift to a <strong>byte</strong>,</p>
<p><strong>short</strong> or <strong>char</strong> variable.)</p>
<p>2. If you use a shift operator with a first operand that is a
<strong>byte</strong>, <strong>char</strong> or <strong>short</strong>,
it is promoted to an <strong>int</strong> and the</p>
<p>operation produces an <strong>int</strong>.)</p>
<p>3. The second operand is reduced <em>modulo the number of bits of the
operation</em> to give the amount of the shift. For</p>
<p>more about the <strong>mod mathematical concept</strong>, see Modulus
examples.</p>
<p>4. The bits that are shifted off the left or right end by the
operation are discarded. (Java does not provide a</p>
<p>primitive "rotate" operator.)</p>
<p>5. The arithmetic shift operator is equivalent dividing a (two's
complement) number by a power of 2.</p>
<p>6. The left shift operator is equivalent multiplying a (two's
complement) number by a power of 2.</p>
<p>The following table will help you see the effects of the three shift
operators. (The numbers have been expressed in binary notation to aid
vizualization.)</p>
<p>Operand1 Operand2 &lt;&lt; &gt;&gt; &gt;&gt;&gt;</p>
<p>0b0000000000001011 0 0b0000000000001011 0b0000000000001011
0b0000000000001011</p>
<p>0b0000000000001011 1 0b0000000000010110 0b0000000000000101
0b0000000000000101</p>
<p>0b0000000000001011 2 0b0000000000101100 0b0000000000000010
0b0000000000000010</p>
<p>0b0000000000001011 28 0b1011000000000000 0b0000000000000000
0b0000000000000000</p>
<p>0b0000000000001011 31 0b1000000000000000 0b0000000000000000
0b0000000000000000</p>
<p>0b0000000000001011 32 0b0000000000001011 0b0000000000001011
0b0000000000001011</p>
<p>... ... ... ... ...</p>
<p>0b1000000000001011 0 0b1000000000001011 0b1000000000001011
0b1000000000001011</p>
<p>0b1000000000001011 1 0b0000000000010110 0b1100000000000101
0b0100000000000101</p>
<p>0b1000000000001011 2 0b0000000000101100 0b1110000000000010
0b00100000000000100</p>
<p>0b1000000000001011 31 0b1000000000000000 0b1111111111111111
0b0000000000000001</p>
<p>There examples of the user of shift operators in Bit manipulation</p>
<p>Section 40.7: The Instanceof Operator</p>
<p>This operator checks whether the object is of a particular
class/interface type. <strong>instanceof</strong> operator is written
as:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 217</p>
<p><span id="__Object_reference_variable___in" class="anchor"></span>(
Object reference variable ) <strong>instanceof</strong>
(<strong>class</strong>/<strong>interface</strong> type)</p>
<p>Example:</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>String name = "Buyya";</p>
<p>// following will return true since name is type of String
<em><strong>boolean</strong> result = name <strong>instanceof</strong>
String;</em></p>
<p>System.out.println( result );</p>
<p>}</p>
<p>}</p>
<p>This would produce the following result:</p>
<p>true</p>
<p>This operator will still return true if the object being compared is
the assignment compatible with the type on the right.</p>
<p>Example:</p>
<p><strong>class</strong> Vehicle {}</p>
<p>public class <strong>Car</strong> extends <strong>Vehicle
{</strong></p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>Vehicle a = <strong>new</strong> Car();</p>
<p>boolean <strong>result = a</strong> instanceof
<strong>Car;</strong></p>
<p>System.out.println( result );</p>
<p>}</p>
<p>}</p>
<p>This would produce the following result:</p>
<p>true</p>
<p>Section 40.8: The Assignment Operators (=, +=, -=, *=, /=, %=,</p>
<p>&lt;&lt;=, &gt;&gt;= , &gt;&gt;&gt;=, &amp;=, |= and ^=)</p>
<p>The left hand operand for these operators must be a either a
non-final variable or an element of an array. The right hand operand
must be <em>assignment compatible</em> with the left hand operand. This
means that either the types must be</p>
<p>the same, or the right operand type must be convertible to the left
operands type by a combination of boxing,</p>
<p><a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.2">unboxing
or widening. (For complete details refer to JLS 5.2</a>.)</p>
<p><a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2">The
precise meaning of the "operation and assign" operators is specified by
JLS 15.26.2</a> as:</p>
<p>A compound assignment expression of the form E1 op= E2 is equivalent
to E1 = (T) ((E1) op (E2)), where T is the type of E1, except that E1 is
evaluated only once.</p>
<p>Note that there is an implicit type-cast before the final
assignment.</p>
<p>1. =</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 218</p>
<p>The simple assignment operator: assigns the value of the right hand
operand to the left hand operand.</p>
<p>Example: c = a + b will add the value of a + b to the value of c and
assign it to c</p>
<p>2. +=</p>
<p>The "add and assign" operator: adds the value of right hand operand
to the value of the left hand operand and</p>
<p>assigns the result to left hand operand. If the left hand operand has
type String, then this a "concatenate and assign" operator.</p>
<p>Example: c += a is roughly the same as c = c + a</p>
<p>3. -=</p>
<p>The "subtract and assign" operator: subtracts the value of the right
operand from the value of the left hand operand and assign the result to
left hand operand.</p>
<p>Example: c -= a is roughly the same as c = c - a</p>
<p>4. *=</p>
<p>The "multiply and assign" operator: multiplies the value of the right
hand operand by the value of the left hand operand and assign the result
to left hand operand. .</p>
<p>Example: c *= a is roughly the same as c = c * a</p>
<p>5. /=</p>
<p>The "divide and assign" operator: divides the value of the right hand
operand by the value of the left hand operand and assign the result to
left hand operand.</p>
<p>Example: c <em>/*= a</em> is roughly the same as c = c / a</p>
<p>6. %=</p>
<p>The "modulus and assign" operator: calculates the modulus of the
value of the right hand operand by the value of the left hand operand
and assign the result to left hand operand.</p>
<p>Example: c %*= a is roughly the same as c = c % a</p>
<p>7. &lt;&lt;=</p>
<p>The "left shift and assign" operator.</p>
<p>Example: c &lt;&lt;= 2 is roughly the same as c = c &lt;&lt; 2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 219</p>
<p><span id="8" class="anchor"></span>8. &gt;&gt;=</p>
<p>The "arithmetic right shift and assign" operator.</p>
<p>Example: c &gt;&gt;= 2 is roughly the same as c = c &gt;&gt; 2</p>
<p>9. &gt;&gt;&gt;=</p>
<p>The "logical right shift and assign" operator.</p>
<p>Example: c &gt;&gt;&gt;= 2 is roughly the same as c = c &gt;&gt;&gt;
2</p>
<p>10. &amp;=</p>
<p>The "bitwise and and assign" operator.</p>
<p>Example: c &amp;= 2 is roughly the same as c = c &amp; 2</p>
<p>11. |=</p>
<p>The "bitwise or and assign" operator.</p>
<p>Example: c |= 2 is roughly the same as c = c | 2</p>
<p>12. ^=</p>
<p>The "bitwise exclusive or and assign" operator.</p>
<p>Example: c ^= 2 is roughly the same as c = c ^ 2</p>
<p>Section 40.9: The conditional-and and conditional-or</p>
<p>Operators ( &amp;&amp; and || )</p>
<p>Java provides a conditional-and and a conditional-or operator, that
both take one or two operands of type <strong>boolean</strong></p>
<p>and produce a <strong>boolean</strong> result. These are:</p>
<p>&amp;&amp; - the conditional-AND operator,</p>
<p>|| - the conditional-OR operators. The evaluation of
<strong>&lt;left-expr&gt;</strong> &amp;&amp; is equivalent to the
following pseudo-code:</p>
<p>{</p>
<p><strong>boolean</strong> L = evaluate();</p>
<p><strong>if</strong> (L) {</p>
<p><strong>return</strong> evaluate();</p>
<p>} <strong>else</strong> {</p>
<p>// short-circuit the evaluation of the 2nd operand expression
<em><strong>return false</strong>;</em></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 220</p>
<p><span id="_7" class="anchor"></span>}</p>
<p>The evaluation of <strong>&lt;left-expr&gt;</strong> ||
<strong>&lt;right-expr&gt;</strong> is equivalent to the following
pseudo-code:</p>
<p>{</p>
<p><strong>boolean</strong> L = evaluate();</p>
<p><strong>if</strong> (!L) {</p>
<p><strong>return</strong> evaluate();</p>
<p>} <strong>else</strong> {</p>
<p>// short-circuit the evaluation of the 2nd operand expression
<em><strong>return true</strong>;</em></p>
<p>}</p>
<p>}</p>
<p>As the pseudo-code above illustrates, the behavior of the
short-circuit operators are equivalent to using if /
<strong>else</strong> statements.</p>
<p>Example - using &amp;&amp; as a guard in an expression</p>
<p>The following example shows the most common usage pattern for the
&amp;&amp; operator. Compare these two versions of a method to test if a
supplied Integer is zero.</p>
<p><strong>public boolean</strong> isZero(Integer value) {</p>
<p><strong>return</strong> value == 0;</p>
<p>}</p>
<p><strong>public boolean</strong> isZero(Integer value) {</p>
<p><strong>return</strong> value != <strong>null</strong> &amp;&amp;
value == 0;</p>
<p>}</p>
<p>The first version works in most cases, but if the value argument is
<strong>null</strong>, then a NullPointerException will be</p>
<p>thrown.</p>
<p>In the second version we have added a "guard" test. The value !=
<strong>null</strong> &amp;&amp; value == 0 expression is evaluated
by</p>
<p>first performing the value != <strong>null</strong> test. If the
<strong>null</strong> test succeeds (i.e. it evaluates to
<strong>true</strong>) then the value == 0 expression is evaluated. If
the <strong>null</strong> test fails, then the evaluation of value == 0
is skipped (short-circuited), and we</p>
<p><em>don't</em> get a NullPointerException.</p>
<p>Example - using &amp;&amp; to avoid a costly calculation</p>
<p>The following example shows how &amp;&amp; can be used to avoid a
relatively costly calculation:</p>
<p><strong>public boolean</strong> verify(<strong>int</strong> value,
<strong>boolean</strong> needPrime) {</p>
<p><strong>return</strong> !needPrime | isPrime(value);</p>
<p>}</p>
<p><strong>public boolean</strong> verify(<strong>int</strong> value,
<strong>boolean</strong> needPrime) {</p>
<p><strong>return</strong> !needPrime || isPrime(value);</p>
<p>}</p>
<p>In the first version, both operands of the | will always be
evaluated, so the (expensive) isPrime method will be called
unnecessarily. The second version avoids the unnecessary call by using
|| instead of |.</p>
<p>Section 40.10: The Relational Operators (&lt;, &lt;=, &gt;,
&gt;=)</p>
<p>The operators &lt;, &lt;=, &gt; and &gt;= are binary operators for
comparing numeric types. The meaning of the operators is as</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 221</p>
<p><span id="you_would_expect__For_example__i" class="anchor"></span>you
would expect. For example, if a and b are declared as any of
<strong>byte</strong>, <strong>short</strong>, <strong>char</strong>,
<strong>int</strong>, <strong>long</strong>, <strong>float</strong>,
<strong>double</strong> or the corresponding boxed types:</p>
<p>- `a &lt; b` tests <strong>if</strong> the value of `a` is less than
the value of `b`.- `a &lt;= b` tests <strong>if</strong> the value of
`a` is less than or equal to the value of `b`.- `a &gt; b` tests
<strong>if</strong> the value of `a` is greater than the value of `b`.-
`a &gt;= b` tests <strong>if</strong> the value of `a` is greater than
or equal to the value of `b`.</p>
<p>The result type for these operators is <strong>boolean</strong> in
all cases.</p>
<p>Relational operators can be used to compare numbers with different
types. For example:</p>
<p><strong>int</strong> i = 1;</p>
<p><strong>long</strong> l = 2;</p>
<p><strong>if</strong> (i &lt; l) {</p>
<p>System.out.println("i is smaller");</p>
<p>}</p>
<p>Relational operators can be used when either or both numbers are
instances of boxed numeric types. For example:</p>
<p><em>Integer i = 1;</em> // 1 is autoboxed to an Integer</p>
<p><em>Integer j = 2;</em> // 2 is autoboxed to an Integer</p>
<p><strong>if</strong> (i &lt; j) {</p>
<p>System.out.println("i is smaller");</p>
<p>}</p>
<p>The precise behavior is summarized as follows:</p>
<p>1. If one of the operands is a boxed type, it is unboxed.</p>
<p>2. If either of the operands now a <strong>byte</strong>,
<strong>short</strong> or <strong>char</strong>, it is promoted to an
<strong>int</strong>.</p>
<p>3. If the types of the operands are not the same, then the operand
with the "smaller" type is promoted to the</p>
<p>"larger" type.</p>
<p>4. The comparison is performed on the resulting <strong>int</strong>,
<strong>long</strong>, <strong>float</strong> or <strong>double</strong>
values.</p>
<p>You need to be careful with relational comparisons that involve
floating point numbers:</p>
<p>Expressions that compute floating point numbers often incur rounding
errors due to the fact that the computer floating-point representations
have limited precision.</p>
<p>When comparing an integer type and a floating point type, the
conversion of the integer to floating point can</p>
<p>also lead to rounding errors.</p>
<p>Finally, Java does bit support the use of relational operators with
any types other than the ones listed above. For example, you
<em>cannot</em> use these operators to compare strings, arrays of
numbers, and so on.</p>
<p>Section 40.11: The Equality Operators (==, !=)</p>
<p>The == and != operators are binary operators that evaluate to
<strong>true</strong> or <strong>false</strong> depending on whether the
operands are equal. The == operator gives <strong>true</strong> if the
operands are equal and <strong>false</strong> otherwise. The != operator
gives <strong>false</strong> if</p>
<p>the operands are equal and <strong>true</strong> otherwise.</p>
<p>These operators can be used operands with primitive and reference
types, but the behavior is significantly</p>
<p>different. According to the JLS, there are actually three distinct
sets of these operators:</p>
<p>The Boolean == and != operators.</p>
<p>The Numeric == and != operators.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 222</p>
<p>The Reference == and != operators.</p>
<p>However, in all cases, the result type of the == and != operators is
<strong>boolean</strong>.</p>
<p>The Numeric == and != operators</p>
<p>When one (or both) of the operands of an == or != operator is a
primitive numeric type (<strong>byte</strong>, <strong>short</strong>,
<strong>char</strong>, <strong>int</strong>, <strong>long</strong>,
<strong>float</strong> or <strong>double</strong>), the operator is a
numeric comparison. The second operand must be either a primitive</p>
<p>numeric type, or a boxed numeric type.</p>
<p>The behavior other numeric operators is as follows:</p>
<p>1. If one of the operands is a boxed type, it is unboxed.</p>
<p>2. If either of the operands now a <strong>byte</strong>,
<strong>short</strong> or <strong>char</strong>, it is promoted to an
<strong>int</strong>.</p>
<p>3. If the types of the operands are not the same, then the operand
with the "smaller" type is promoted to the</p>
<p>"larger" type.</p>
<p>4. The comparison is then carried out as follows:</p>
<p>If the promoted operands are <strong>int</strong> or
<strong>long</strong> then the values are tested to see if they are
identical.</p>
<p>If the promoted operands are <strong>float</strong> or
<strong>double</strong> then:</p>
<p>the two versions of zero (+0.0 and -0.0) are treated as equal</p>
<p>a NaN value is treated as not equals to anything, and</p>
<p>other values are equal if their IEEE 754 representations are
identical.</p>
<p>Note: you need to be careful when using == and != to compare floating
point values.</p>
<p>The Boolean == and != operators</p>
<p>If both operands are <strong>boolean</strong>, or one is
<strong>boolean</strong> and the other is Boolean, these operators the
Boolean == and !=</p>
<p>operators. The behavior is as follows:</p>
<p>1. If one of the operands is a Boolean, it is unboxed.</p>
<p>2. The unboxed operands are tested and the boolean result is
calculated according to the following truth table</p>
<p>A B A == B A != B</p>
<p>false false true false</p>
<p>false true false true</p>
<p>true false false true</p>
<p>true true true false</p>
<p>There are two "pitfalls" that make it advisable to use == and !=
sparingly with truth values:</p>
<p>If you use == or != to compare two Boolean objects, then the
Reference operators are used. This may give an</p>
<p>unexpected result; see Pitfall: using == to compare primitive
wrappers objects such as Integer</p>
<p>The == operator can easily be mistyped as =. For most operand types,
this mistake leads to a compilation error. However, for
<strong>boolean</strong> and Boolean operands the mistake leads to
incorrect runtime behavior; see</p>
<p>Pitfall - Using '==' to test a boolean</p>
<p>The Reference == and != operators</p>
<p>If both operands are object references, the == and != operators test
if the two operands <strong>refer to the same object</strong>.</p>
<p>This often not what you want. To test if two objects are equal <em>by
value</em>, the .equals() method should be used instead.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 223</p>
<p><span id="String_s1____We_are_equal" class="anchor"></span>String s1
= "We are equal";</p>
<p>String s2 = <strong>new</strong> String("We are equal");</p>
<p>s1.equals(s2); <em>// true</em></p>
<p>// WARNING - don't use == or != with String values</p>
<p>s1 == s2; <em>// false</em></p>
<p>Warning: using == and != to compare String values is
<strong>incorrect</strong> in most cases; see</p>
<p>http://stackoverflow.com/documentation/java/4388/java-pitfalls/16290/using-to-compare-strings
. A similar problem applies to primitive wrapper types; see</p>
<p>http://stackoverflow.com/documentation/java/4388/java-pitfalls/8996/using-to-compare-primitive-wrappers-objects-such-as-integer
.</p>
<p>About the NaN edge-cases</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1">JLS
15.21.1</a> states the following:</p>
<p>If either operand is NaN, then the result of == is
<strong>false</strong> but the result of != is <strong>true</strong>.
Indeed, the test x != x is <strong>true</strong> if and only if the
value of x is NaN.</p>
<p>This behavior is (to most programmers) unexpected. If you test if a
NaN value is equal to itself, the answer is "No it</p>
<p>isn't!". In other words, == is not <em>reflexive</em> for NaN
values.</p>
<p>However, this is not a Java "oddity", this behavior is specified in
the IEEE 754 floating-point standards, and you will</p>
<p>find that it is implemented by most modern programming languages.
(For more information, see</p>
<p><a
href="http://stackoverflow.com/a/1573715/139985">http://stackoverflow.com/a/1573715/139985
... noting that this is written by someone who was "in the room when</a>
the decisions were made"!)</p>
<p>Section 40.12: The Lambda operator ( -&gt; )</p>
<p>From Java 8 onwards, the Lambda operator ( -&gt; ) is the operator
used to introduce a Lambda Expression. There are</p>
<p>two common syntaxes, as illustrated by these examples:</p>
<p>Version ≥ Java SE 8</p>
<p><em>a -&gt; a + 1</em> // a lambda that adds one to its argument
<em>a -&gt; { <strong>return</strong> a + 1; }</em> // an equivalent
lambda using a block.</p>
<p>A lambda expression defines an anonymous function, or more correctly
an instance of an anonymous class that</p>
<p><em>implements a</em> functional interface<em>.</em></p>
<p>(This example is included here for completeness. Refer to the Lambda
Expressions topic for the full treatment.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 224</p>
<p><span id="Chapter_41__Constructors_1" class="anchor"></span>Chapter
41: Constructors</p>
<p>While not required, constructors in Java are methods recognized by
the compiler to instantiate specific values for</p>
<p>the class which may be essential to the role of the object. This
topic demonstrates proper usage of Java class constructors.</p>
<p>Section 41.1: Default Constructor</p>
<p>The "default" for constructors is that they do not have any
arguments. In case you do not specify <strong>any</strong>
constructor,</p>
<p>the compiler will generate a default constructor for you.</p>
<p>This means the following two snippets are semantically
equivalent:</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String test;</p>
<p>}</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String test;</p>
<p><strong>public</strong> TestClass() {</p>
<p>}</p>
<p>}</p>
<p>The visibility of the default constructor is the same as the
visibility of the class. Thus a class defined package-</p>
<p>privately has a package-private default constructor</p>
<p>However, if you have non-default constructor, the compiler will not
generate a default constructor for you. So these</p>
<p>are not equivalent:</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String test;</p>
<p><strong>public</strong> TestClass(String arg) {</p>
<p>}</p>
<p>}</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String test;</p>
<p><strong>public</strong> TestClass() {</p>
<p>}</p>
<p><strong>public</strong> TestClass(String arg) {</p>
<p>}</p>
<p>}</p>
<p>Beware that the generated constructor performs no non-standard
initialization. This means all fields of your class</p>
<p>will have their default value, unless they have an initializer.</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String testData;</p>
<p><strong>public</strong> TestClass() {</p>
<p>testData = "Test"</p>
<p>}</p>
<p>}</p>
<p>Constructors are called like this:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 225</p>
<p><span id="TestClass_testClass___new_TestCl"
class="anchor"></span>TestClass testClass = <strong>new</strong>
TestClass();</p>
<p>Section 41.2: Call parent constructor</p>
<p>Say you have a Parent class and a Child class. To construct a Child
instance always requires some Parent</p>
<p>constructor to be run at the very gebinning of the Child constructor.
We can select the Parent constructor we want</p>
<p>by explicitly calling <strong>super</strong>(...) with the
appropriate arguments as our first Child constructor statement. Doing
this saves us time by reusing the Parent classes' constructor instead of
rewriting the same code in the Child classes'</p>
<p>constructor.</p>
<p>Without super<strong>(...)</strong> method:</p>
<p>(implicitly, the no-args version <strong>super</strong>() is called
invisibly)</p>
<p><strong>class</strong> Parent {</p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>age;</strong></p>
<p><em><strong>public</strong> Parent() {}</em> // necessary because we
call super() without arguments</p>
<p><strong>public</strong> Parent(String tName, <strong>int</strong>
tAge) {</p>
<p>name = tName;</p>
<p>age = tAge;</p>
<p>}</p>
<p>}</p>
<p>// This does not even compile, because name and age are private, //
making them invisible even to the child class.</p>
<p><strong>class</strong> Child <strong>extends</strong> Parent {</p>
<p><strong>public</strong> Child() {</p>
<p>// compiler implicitly calls super() here</p>
<p>name = "John";</p>
<p>age = 42;</p>
<p>}</p>
<p>}</p>
<p>With super<strong>()</strong> method:</p>
<p><strong>class</strong> Parent {</p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>age;</strong></p>
<p><strong>public</strong> Parent(String tName, <strong>int</strong>
tAge) {</p>
<p>name = tName;</p>
<p>age = tAge;</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Child <strong>extends</strong> Parent {</p>
<p><strong>public</strong> Child() {</p>
<p><em><strong>super</strong>("John", 42);</em> // explicit
super-call</p>
<p>}</p>
<p>}</p>
<p><strong>Note:</strong> Calls to another constructor (chaining) or the
super constructor <strong>MUST</strong> be the first statement inside
the</p>
<p>constructor.</p>
<p>If you call the <strong>super</strong>(...) constructor explicitly, a
matching parent constructor must exist (that's straightforward, isn't
it?).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 226</p>
<p><span id="If_you_don_t_call_any_super" class="anchor"></span>If you
don't call any <strong>super</strong>(...) constructor explicitly, your
parent class must have a no-args constructor - and this can be either
written explicitly or created as a default by the compiler if the parent
class doesn't provide any</p>
<p>constructor.</p>
<p><strong>class</strong> Parent{</p>
<p><strong>public</strong> Parent(String tName, <strong>int</strong>
tAge) {}</p>
<p>}</p>
<p><strong>class</strong> Child <strong>extends</strong> Parent{</p>
<p><strong>public</strong> Child(){}</p>
<p>}</p>
<p>The class Parent has no default constructor, so, the compiler can't
add <strong>super</strong> in the Child constructor. This code will not
compile. You must change the constructors to fit both sides, or write
your own <strong>super</strong> call, like that:</p>
<p><strong>class</strong> Child <strong>extends</strong> Parent{</p>
<p><strong>public</strong> Child(){</p>
<p><strong>super</strong>("",0);</p>
<p>}</p>
<p>}</p>
<p>Section 41.3: Constructor with Arguments</p>
<p>Constructors can be created with any kinds of arguments.</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String testData;</p>
<p><strong>public</strong> TestClass(String testData) {</p>
<p><strong>this</strong>.testData = testData;</p>
<p>}</p>
<p>}</p>
<p>Called like this:</p>
<p>TestClass testClass = <strong>new</strong> TestClass("Test
Data");</p>
<p>A class can have multiple constructors with different signatures. To
chain constructor calls (call a different</p>
<p>constructor of the same class when instantiating) use
<strong>this</strong>().</p>
<p>public class <strong>TestClass {</strong></p>
<p><strong>private</strong> String testData;</p>
<p><strong>public</strong> TestClass(String testData) {</p>
<p><strong>this</strong>.testData = testData;</p>
<p>}</p>
<p><strong>public</strong> TestClass() {</p>
<p><em><strong>this</strong>("Test");</em> // testData defaults to
"Test"</p>
<p>}</p>
<p>}</p>
<p>Called like this:</p>
<p>TestClass testClass1 = <strong>new</strong> TestClass("Test
Data");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 227</p>
<p>TestClass testClass2 = <strong>new</strong> TestClass();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 228</p>
<p><span id="Chapter_42__Object_Class_Methods_1"
class="anchor"></span>Chapter 42: Object Class Methods and</p>
<p>Constructor</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html">This
documentation page is for showing details with example about java class
constructors</a> and about <a
href="https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html">Object
Class</a></p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html">Methods</a>
which are automatically inherited from the superclass Object of any
newly created class.</p>
<p>Section 42.1: hashCode() method</p>
<p>When a Java class overrides the equals method, it should override the
hashCode method as well. As defined <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html">in
the</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html">method's
contract:</a></p>
<p>Whenever it is invoked on the same object more than once during an
execution of a Java application, the hashCode method must consistently
return the same integer, provided no</p>
<p>information used in equals comparisons on the object is modified.
This integer need not remain consistent from one execution of an
application to another execution of the same application.</p>
<p>If two objects are equal according to the equals(Object) method, then
calling the hashCode method on each of the two objects must produce the
same integer result.</p>
<p>It is not required that if two objects are unequal according to the
equals(Object) method, then calling the hashCode method on each of the
two objects must produce distinct integer results.</p>
<p>However, the programmer should be aware that producing distinct
integer results for unequal objects may improve the performance of hash
tables.</p>
<p>Hash codes are used in hash implementations such as HashMap,
HashTable, and HashSet. The result of the hashCode</p>
<p>function determines the bucket in which an object will be put. These
hash implementations are more efficient if the provided hashCode
implementation is good. An important property of good hashCode
implementation is that the</p>
<p>distribution of the hashCode values is uniform. In other words, there
is a small probability that numerous instances</p>
<p>will be stored in the same bucket.</p>
<p>An algorithm for computing a hash code value may be similar to the
following:</p>
<p>public class <strong>Foo {</strong></p>
<p><strong>private int</strong> field1, field2;</p>
<p><strong>private</strong> String field3;</p>
<p><strong>public</strong> Foo(<strong>int</strong> field1,
<strong>int</strong> field2, String field3) {</p>
<p><strong>this</strong>.field1 = field1;</p>
<p><strong>this</strong>.field2 = field2;</p>
<p><strong>this</strong>.field3 = field3;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong> (<strong>this</strong> == obj) {</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p><strong>if</strong> (obj == <strong>null</strong> || getClass() !=
obj.getClass()) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>Foo f = (Foo) obj;</p>
<p><strong>return</strong> field1 == f.field1 &amp;&amp;</p>
<p>field2 == f.field2 &amp;&amp;</p>
<p>(field3 == <strong>null</strong> ? f.field3 == <strong>null</strong>
: field3.equals(f.field3);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 229</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>int</strong> hash = 1;</p>
<p>hash = 31 * hash + field1;</p>
<p>hash = 31 * hash + field2;</p>
<p>hash = 31 * hash + (field3 == <strong>null</strong> ? 0 :
field3.hashCode());</p>
<p>return <strong>hash;</strong></p>
<p>}</p>
<p>}</p>
<p>Using Arrays.hashCode() as a short cut</p>
<p>Version ≥ Java SE 1.2</p>
<p>In Java 1.2 and above, instead of developing an algorithm to compute
a hash code, one can be generated using</p>
<p>java.util.Arrays#hashCode by supplying an Object or primitives array
containing the field values:</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong> Arrays.hashCode(<strong>new</strong> Object[]
{field1, field2, field3});</p>
<p>}</p>
<p>Version ≥ Java SE 7</p>
<p>Java 1.7 introduced the java.util.Objects class which provides a
convenience method, hash(Object...</p>
<p>objects), that computes a hash code based on the values of the
objects supplied to it. This method works just like
java.util.Arrays#hashCode.</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong> Objects.hash(field1, field2, field3);</p>
<p>}</p>
<p>Note: this approach is inefficient, and produces garbage objects each
time your custom hashCode() method is</p>
<p>called:</p>
<p>A temporary Object[] is created. (In the Objects.hash() version, the
array is created by the "varargs"</p>
<p>mechanism.)</p>
<p>If any of the fields are primitive types, they must be boxed and that
may create more temporary objects.</p>
<p>The array must be populated.</p>
<p>The array must iterated by the Arrays.hashCode or Objects.hash
method. The calls to Object.hashCode() that Arrays.hashCode or
Objects.hash has to make (probably) cannot be</p>
<p>inlined.</p>
<p>Internal caching of hash codes</p>
<p>Since the calculation of an object's hash code can be expensive, it
can be attractive to cache the hash code value within the object the
first time that it is calculated. For example</p>
<p>public final class <strong>ImmutableArray {</strong></p>
<p>private int<strong>[] array;</strong></p>
<p>private volatile int <strong>hash = 0;</strong></p>
<p><strong>public</strong> ImmutableArray(<strong>int</strong>[]
initial) {</p>
<p>array = initial.clone();</p>
<p>}</p>
<p>// Other methods</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 230</p>
<p><span id="_Override_1" class="anchor"></span>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p>// ...</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>int</strong> h = hash;</p>
<p><strong>if</strong> (h == 0) {</p>
<p>h = Arrays.hashCode(array);</p>
<p>hash = h;</p>
<p>}</p>
<p>return <strong>h;</strong></p>
<p>}</p>
<p>}</p>
<p>This approach trades off the cost of (repeatedly) calculating the
hash code against the overhead of an extra field to</p>
<p>cache the hash code. Whether this pays off as a performance
optimization will depend on how often a given object is hashed (looked
up) and other factors.</p>
<p>You will also notice that if the true hashcode of an ImmutableArray
happens to be zero (one chance in 232), the cache is ineffective.</p>
<p>Finally, this approach is much harder to implement correctly if the
object we are hashing is mutable. However, there are bigger concerns if
hash codes change; see the contract above.</p>
<p>Section 42.2: toString() method</p>
<p>The toString() method is used to create a String representation of an
object by using the object´s content. This</p>
<p>method should be overridden when writing your class. toString() is
called implicitly when an object is concatenated to a string as in
"hello " + anObject.</p>
<p>Consider the following:</p>
<p>public class <strong>User {</strong></p>
<p><strong>private</strong> String firstName;</p>
<p><strong>private</strong> String lastName;</p>
<p><strong>public</strong> User(String firstName, String lastName) {</p>
<p><strong>this</strong>.firstName = firstName;</p>
<p><strong>this</strong>.lastName = lastName;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> firstName + " " + lastName;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>User user = <strong>new</strong> User("John", "Doe");</p>
<p>System.out.println(user.toString()); <em>// Prints "John
Doe"</em></p>
<p>}</p>
<p>}</p>
<p>Here toString() from Object class is overridden in the User class to
provide meaningful data regarding the object when printing it.</p>
<p>When using println(), the object's toString() method is implicitly
called. Therefore, these statements do the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 231</p>
<p><span id="same_thing" class="anchor"></span>same thing:</p>
<p>System.out.println(user); <em>// toString() is implicitly called on
`user`</em> System.out.println(user.toString());</p>
<p>If the toString() is not overridden in the above mentioned User
class, System.out.println(user) may return</p>
<p>User@659e0bfd or a similar String with almost no useful information
except the class name. This will be because the call will use the
toString() implementation of the base Java Object class which does not
know anything about the</p>
<p>User class's structure or business rules. If you want to change this
functionality in your class, simply override the method.</p>
<p>Section 42.3: equals() method</p>
<p>TL;DR</p>
<p>== tests for reference equality (whether they are the
<em><strong>same object</strong></em>)</p>
<p>.equals() tests for value equality (whether they are
<em><strong>logically "equal"</strong></em>)</p>
<p>equals() is a method used to compare two objects for equality. The
default implementation of the equals()</p>
<p>method in the Object class returns <strong>true</strong> if and only
if both references are pointing to the same instance. It therefore
behaves the same as comparison by ==.</p>
<p>public class <strong>Foo {</strong></p>
<p><strong>int</strong> field1, field2;</p>
<p>String field3;</p>
<p><strong>public</strong> Foo(<strong>int</strong> i,
<strong>int</strong> j, String k) {</p>
<p>field1 = i;</p>
<p>field2 = j;</p>
<p>field3 = k;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Foo foo1 = <strong>new</strong> Foo(0, 0, "bar");</p>
<p>Foo foo2 = <strong>new</strong> Foo(0, 0, "bar");</p>
<p>System.out.println(foo1.equals(foo2)); <em>// prints false</em></p>
<p>}</p>
<p>}</p>
<p>Even though foo1 and foo2 are created with the same fields, they are
pointing to two different objects in memory. The default equals()
implementation therefore evaluates to <strong>false</strong>.</p>
<p>To compare the contents of an object for equality, equals() has to be
overridden.</p>
<p>public class <strong>Foo {</strong></p>
<p><strong>int</strong> field1, field2;</p>
<p>String field3;</p>
<p><strong>public</strong> Foo(<strong>int</strong> i,
<strong>int</strong> j, String k) {</p>
<p>field1 = i;</p>
<p>field2 = j;</p>
<p>field3 = k;</p>
<p>}</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 232</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong> (<strong>this</strong> == obj) {</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p><strong>if</strong> (obj == <strong>null</strong> || getClass() !=
obj.getClass()) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>Foo f = (Foo) obj;</p>
<p><strong>return</strong> field1 == f.field1 &amp;&amp;</p>
<p>field2 == f.field2 &amp;&amp;</p>
<p>(field3 == <strong>null</strong> ? f.field3 == <strong>null</strong>
: field3.equals(f.field3));</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>int</strong> hash = 1;</p>
<p>hash = 31 * hash + <strong>this</strong>.field1;</p>
<p>hash = 31 * hash + <strong>this</strong>.field2;</p>
<p>hash = 31 * hash + (field3 == <strong>null</strong> ? 0 :
field3.hashCode());</p>
<p>return <strong>hash;</strong></p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Foo foo1 = <strong>new</strong> Foo(0, 0, "bar");</p>
<p>Foo foo2 = <strong>new</strong> Foo(0, 0, "bar");</p>
<p>System.out.println(foo1.equals(foo2)); <em>// prints true</em></p>
<p>}</p>
<p>}</p>
<p>Here the overridden equals() method decides that the objects are
equal if their fields are the same.</p>
<p>Notice that the hashCode() method was also overwritten. The contract
for that method states that when two objects are equal, their hash
values must also be the same. That's why one must almost always
override</p>
<p>hashCode() and equals() together.</p>
<p>Pay special attention to the argument type of the equals method. It
is Object obj, not Foo obj. If you put the latter</p>
<p>in your method, that is not an override of the equals method.</p>
<p>When writing your own class, you will have to write similar logic
when overriding equals() and hashCode(). Most</p>
<p>IDEs can automatically generate this for you.</p>
<p>An example of an equals() implementation can be found in the String
class, which is part of the core Java API.</p>
<p>Rather than comparing pointers, the String class compares the content
of the String.</p>
<p>Version ≥ Java SE 7</p>
<p>Java 1.7 introduced the java.util.Objects class which provides a
convenience method, equals, that compares two potentially
<strong>null</strong> references, so it can be used to simplify
implementations of the equals method.</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong> (<strong>this</strong> == obj) {</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p><strong>if</strong> (obj == <strong>null</strong> || getClass() !=
obj.getClass()) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 233</p>
<p><span id="Foo_f____Foo__obj" class="anchor"></span>Foo f = (Foo)
obj;</p>
<p><strong>return</strong> field1 == f.field1 &amp;&amp; field2 ==
f.field2 &amp;&amp; Objects.equals(field3, f.field3);</p>
<p>}</p>
<p>Class Comparison</p>
<p>Since the equals method can run against any object, one of the first
things the method often does (after checking</p>
<p>for <strong>null</strong>) is to check if the class of the object
being compared matches the current class.</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p>//...check for null</p>
<p><strong>if</strong> (getClass() != obj.getClass()) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>//...compare fields</p>
<p>}</p>
<p>This is typically done as above by comparing the class objects.
However, that can fail in a few special cases which may not be obvious.
For example, some frameworks generate dynamic proxies of classes and
these dynamic</p>
<p>proxies are actually a different class. Here is an example using
JPA.</p>
<p>Foo detachedInstance = ...</p>
<p>Foo mergedInstance = entityManager.merge(detachedInstance);
<strong>if</strong> (mergedInstance.equals(detachedInstance)) {</p>
<p>//Can never get here if equality is tested with getClass() //as
mergedInstance is a proxy (subclass) of Foo</p>
<p>}</p>
<p>One mechanism to work around that limitation is to compare classes
using <strong>instanceof</strong></p>
<p>@Override</p>
<p><strong>public final boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong> (!(obj <strong>instanceof</strong> Foo)) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>//...compare fields</p>
<p>}</p>
<p>However, there are a few pitfalls that must be avoided when using
<strong>instanceof</strong>. Since Foo could potentially have other
subclasses and those subclasses might override equals() you could get
into a case where a Foo is equal to a</p>
<p>FooSubclass but the FooSubclass is not equal to Foo.</p>
<p>Foo foo = <strong>new</strong> Foo(7);</p>
<p>FooSubclass fooSubclass = <strong>new</strong> FooSubclass(7,
<strong>false</strong>); foo.equals(fooSubclass) <em>//true</em></p>
<p>fooSubclass.equals(foo) <em>//false</em></p>
<p>This violates the properties of symmetry and transitivity and thus is
an invalid implementation of the equals()</p>
<p>method. As a result, when using <strong>instanceof</strong>, a good
practice is to make the equals() method <strong>final</strong> (as in
the above example). This will ensure that no subclass overrides equals()
and violates key assumptions.</p>
<p>Section 42.4: wait() and notify() methods</p>
<p>wait() and notify() work in tandem – when one thread calls wait() on
an object, that thread will block until another thread calls notify() or
notifyAll() on that same object.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 234</p>
<p>(See Also: wait()/notify() )</p>
<p><strong>package</strong> com.example.examples.object;</p>
<p><strong>import</strong>
java.util.concurrent.atomic.AtomicBoolean;</p>
<p><strong>public class</strong> WaitAndNotify {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> InterruptedException {</p>
<p><strong>final</strong> Object obj = <strong>new</strong>
Object();</p>
<p>AtomicBoolean aHasFinishedWaiting = <strong>new</strong>
AtomicBoolean(<strong>false</strong>);</p>
<p>Thread threadA = <strong>new</strong> Thread("Thread A") {</p>
<p>public void <strong>run() {</strong></p>
<p>System.out.println("A1: Could print before or after B1");
System.out.println("A2: Thread A is about to start waiting...");
<strong>try</strong> {</p>
<p><em><strong>synchronized</strong> (obj) {</em> // wait() must be in a
synchronized block</p>
<p>// execution of thread A stops until obj.notify() is called</p>
<p>obj.wait();</p>
<p>}</p>
<p>System.out.println("A3: Thread A has finished waiting. "</p>
<p>+ "Guaranteed to happen after B3");</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>System.out.println("Thread A was interrupted while waiting");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>aHasFinishedWaiting.set(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>Thread threadB = <strong>new</strong> Thread("Thread B") {</p>
<p>public void <strong>run() {</strong></p>
<p>System.out.println("B1: Could print before or after A1");</p>
<p>System.out.println("B2: Thread B is about to wait for 10 seconds");
<strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++) {</p>
<p>try <strong>{</strong></p>
<p><em>Thread.sleep(1000);</em> // sleep for 1 second</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>System.err.println("Thread B was interrupted from waiting");</p>
<p>}</p>
<p>}</p>
<p>System.out.println("B3: Will ALWAYS print before A3 since "</p>
<p>+ "A3 can only happen after obj.notify() is called.");</p>
<p><strong>while</strong> (!aHasFinishedWaiting.get()) {</p>
<p>synchronized <strong>(obj) {</strong></p>
<p>// notify ONE thread which has called obj.wait()</p>
<p>obj.notify();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>threadA.start();</p>
<p>threadB.start();</p>
<p>threadA.join();</p>
<p>threadB.join();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 235</p>
<p><span id="System_out_println__Finished"
class="anchor"></span>System.out.println("Finished!");</p>
<p>}</p>
<p>}</p>
<p>Some example output:</p>
<p>A1: Could print before or after B1</p>
<p>B1: Could print before or after A1</p>
<p>A2: Thread A is about to start waiting...</p>
<p>B2: Thread B is about to wait for 10 seconds</p>
<p>B3: Will ALWAYS print before A3 since A3 can only happen after
obj.notify() is called. A3: Thread A has finished waiting. Guaranteed to
happen after B3 Finished!</p>
<p>B1: Could print before or after A1</p>
<p>B2: Thread B is about to wait for 10 seconds</p>
<p>A1: Could print before or after B1</p>
<p>A2: Thread A is about to start waiting...</p>
<p>B3: Will ALWAYS print before A3 since A3 can only happen after
obj.notify() is called. A3: Thread A has finished waiting. Guaranteed to
happen after B3 Finished!</p>
<p>A1: Could print before or after B1</p>
<p>A2: Thread A is about to start waiting...</p>
<p>B1: Could print before or after A1</p>
<p>B2: Thread B is about to wait for 10 seconds</p>
<p>B3: Will ALWAYS print before A3 since A3 can only happen after
obj.notify() is called. A3: Thread A has finished waiting. Guaranteed to
happen after B3 Finished!</p>
<p>Section 42.5: getClass() method</p>
<p>The getClass() method can be used to find the runtime class type of
an object. See the example below:</p>
<p>public class <strong>User {</strong></p>
<p>private long <strong>userID;</strong></p>
<p><strong>private</strong> String name;</p>
<p><strong>public</strong> User(<strong>long</strong> userID, String
name) {</p>
<p><strong>this</strong>.userID = userID;</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SpecificUser <strong>extends</strong>
User {</p>
<p><strong>private</strong> String specificUserID;</p>
<p><strong>public</strong> SpecificUser(String specificUserID,
<strong>long</strong> userID, String name) {</p>
<p><strong>super</strong>(userID, name);</p>
<p><strong>this</strong>.specificUserID = specificUserID;</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>User user = <strong>new</strong> User(879745, "John");</p>
<p>SpecificUser specificUser = <strong>new</strong>
SpecificUser("1AAAA", 877777, "Jim");</p>
<p>User anotherSpecificUser = <strong>new</strong> SpecificUser("1BBBB",
812345, "Jenny");</p>
<p>System.out.println(user.getClass()); <em>//Prints "class
User"</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 236</p>
<p><span id="System_out_println_specificUser"
class="anchor"></span>System.out.println(specificUser.getClass());
<em>//Prints "class SpecificUser"</em>
System.out.println(anotherSpecificUser.getClass()); <em>//Prints "class
SpecificUser"</em></p>
<p>}</p>
<p>The getClass() method will return the most specific class type, which
is why when getClass() is called on anotherSpecificUser , the return
value is <strong>class</strong> SpecificUser because that is lower down
the inheritance tree</p>
<p>than User.</p>
<p>It is noteworthy that, while the getClass method is declared as:</p>
<p>public final native <strong>Class getClass();</strong></p>
<p>The actual static type returned by a call to getClass is Classextends
T&gt; where T is the static type of the object</p>
<p>on which getClass is called.</p>
<p>i.e. the following will compile:</p>
<p>Classextends String&gt; cls = "".getClass();</p>
<p>Section 42.6: clone() method</p>
<p>The clone() method is used to create and return a copy of an object.
This method arguable should be avoided as it is problematic and a copy
constructor or some other approach for copying should be used in favour
of clone().</p>
<p>For the method to be used all classes calling the method must
implement the Cloneable interface.</p>
<p>The Cloneable interface itself is just a tag interface used to change
the behaviour of the <strong>native</strong> clone() method</p>
<p>which checks if the calling objects class implements Cloneable. If
the caller does not implement this interface a
CloneNotSupportedException will be thrown.</p>
<p>The Object class itself does not implement this interface so a
CloneNotSupportedException will be thrown if the calling object is of
class Object.</p>
<p>For a clone to be correct it should be independent of the object it
is being cloned from, therefore it may be</p>
<p>necessary to modify the object before it gets returned. This means to
essentially create a "deep copy" by also</p>
<p>copying any of the <em>mutable</em> objects that make up the internal
structure of the object being cloned. If this is not implemented
correctly the cloned object will not be independent and have the same
references to the mutable</p>
<p>objects as the object that it was cloned from. This would result in
inconsistent behaviour as any changes to those in one would affect the
other.</p>
<p><strong>class</strong> Foo <strong>implements</strong> Cloneable
{</p>
<p>int <strong>w;</strong></p>
<p>String x;</p>
<p>float<strong>[] y;</strong></p>
<p>Date z;</p>
<p><strong>public</strong> Foo clone() {</p>
<p>try <strong>{</strong></p>
<p>Foo result = <strong>new</strong> Foo();</p>
<p>// copy primitives by value</p>
<p>result.w = <strong>this</strong>.w;</p>
<p>// immutable objects like String can be copied by reference</p>
<p>result.x = <strong>this</strong>.x;</p>
<p>// The fields y and z refer to a mutable objects; clone them
recursively. <em><strong>if</strong> (<strong>this</strong>.y !=
<strong>null</strong>) {</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 237</p>
<p><span id="result_y___this_y_clone" class="anchor"></span>result.y =
<strong>this</strong>.y.clone();</p>
<p>}</p>
<p><strong>if</strong> (<strong>this</strong>.z !=
<strong>null</strong>) {</p>
<p>result.z = <strong>this</strong>.z.clone();</p>
<p>}</p>
<p>// Done, return the new object</p>
<p><strong>return</strong> result;</p>
<p>} <strong>catch</strong> (CloneNotSupportedException e) {</p>
<p>// in case any of the cloned mutable fields do not implement
Cloneable <em><strong>throw new</strong> AssertionError(e);</em></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 42.7: Object constructor</p>
<p>All constructors in Java must make a call to the Object constructor.
This is done with the call <strong>super</strong>(). This has to be</p>
<p>the first line in a constructor. The reason for this is so that the
object can actually be created on the heap before any additional
initialization is performed.</p>
<p>If you do not specify the call to <strong>super</strong>() in a
constructor the compiler will put it in for you.</p>
<p>So all three of these examples are functionally identical</p>
<p>with explicit call to <strong>super</strong>() constructor</p>
<p>public class <strong>MyClass {</strong></p>
<p><strong>public</strong> MyClass() {</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p>}</p>
<p>with implicit call to <strong>super</strong>() constructor</p>
<p>public class <strong>MyClass {</strong></p>
<p><strong>public</strong> MyClass() {</p>
<p>// empty</p>
<p>}</p>
<p>}</p>
<p>with implicit constructor</p>
<p>public class <strong>MyClass {</strong></p>
<p>}</p>
<p>What about Constructor-Chaining?</p>
<p>It is possible to call other constructors as the first instruction of
a constructor. As both the explicit call to a super constructor and the
call to another constructor have to be both first instructions, they are
mutually exclusive.</p>
<p>public class <strong>MyClass {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 238</p>
<p><span id="public_MyClass_int_size"
class="anchor"></span><strong>public</strong>
MyClass(<strong>int</strong> size) {</p>
<p>doSomethingWith(size);</p>
<p>}</p>
<p><strong>public</strong> MyClass(Collection initialValues) {</p>
<p><strong>this</strong>(initialValues.size());</p>
<p>addInitialValues(initialValues);</p>
<p>}</p>
<p>}</p>
<p>Calling new MyClass(Arrays.asList("a", "b", "c")) will call the
second constructor with the List-argument,</p>
<p>which will in turn delegate to the first constructor (which will
delegate implicitly to <strong>super</strong>()) and then call
addInitialValues(<strong>int</strong> size) with the second size of the
list. This is used to reduce code duplication where</p>
<p>multiple constructors need to do the same work.</p>
<p>How do I call a specific constructor?</p>
<p>Given the example above, one can either call <strong>new</strong>
MyClass("argument") or <strong>new</strong> MyClass("argument", 0). In
other words, much like method overloading, you just call the constructor
with the parameters that are necessary for your</p>
<p>chosen constructor.</p>
<p>What will happen in the Object class constructor?</p>
<p>Nothing more than would happen in a sub-class that has a default
empty constructor (minus the call to <strong>super</strong>()).</p>
<p>The default empty constructor can be explicitly defined but if not
the compiler will put it in for you as long as no other constructors are
already defined.</p>
<p>How is an Object then created from the constructor in Object?</p>
<p>The actual creation of objects is down to the JVM. Every constructor
in Java appears as a special method named <strong>&lt;init&gt;</strong>
which is responsible for instance initializing. This
<strong>&lt;init&gt;</strong> method is supplied by the compiler and
because</p>
<p><strong>&lt;init&gt;</strong> is not a valid identifier in Java, it
cannot be used directly in the language.</p>
<p>How does the JVM invoke this <strong>&lt;init&gt;</strong>
method?</p>
<p>The JVM will invoke the <strong>&lt;init&gt;</strong> method using
the invokespecial instruction and can only be invoked on</p>
<p>uninitialized class instances.</p>
<p>For more information take a look at the JVM specification and the
Java Language Specification:</p>
<p><a
href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">Special
Methods (JVM) - JVMS - 2.9</a></p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html">Constructors
- JLS - 8.8</a></p>
<p>Section 42.8: finalize() method</p>
<p>This is a <em>protected</em> and <em>non-static</em> method of the
Object class. This method is used to perform some final operations</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 239</p>
<p>or clean up operations on an object before it gets removed from the
memory.</p>
<p>According to the doc, this method gets called by the garbage
collector on an object when garbage</p>
<p>collection determines that there are no more references to the
object.</p>
<p>But there are no guarantees that finalize() method would gets called
if the object is still reachable or no Garbage</p>
<p>Collectors run when the object become eligible. That's why it's
better <strong>not rely</strong> on this method.</p>
<p>In Java core libraries some usage examples could be found, for
instance in FileInputStream.java:</p>
<p><strong>protected void</strong> finalize() <strong>throws</strong>
IOException {</p>
<p><strong>if</strong> ((fd != <strong>null</strong>) &amp;&amp; (fd !=
FileDescriptor.in)) {</p>
<p>/* if fd is shared, the references in FileDescriptor</p>
<p>* will ensure that finalizer is only called when</p>
<p>* safe to do so. All references using the fd have</p>
<p>* become unreachable. We can call close()</p>
<p>*/</p>
<p>close();</p>
<p>}</p>
<p>}</p>
<p>In this case it's the last chance to close the resource if that
resource has not been closed before.</p>
<p>Generally it's considered bad practice to use finalize() method in
applications of any kind and should be avoided.</p>
<p>Finalizers are <em>not</em> meant for freeing resources (e.g.,
closing files). The garbage collector gets called when (if!) the</p>
<p>system runs low on heap space. You can't rely on it to be called when
the system is running low on file handles or, for any other reason.</p>
<p>The intended use-case for finalizers is for an object that is about
to be reclaimed to notify some other object about its impending doom. A
better mechanism now exists for that purpose---the
java.lang.ref.WeakReference</p>
<p>class. If you think you need write a finalize() method, then you
should look into whether you can solve the same problem using
WeakReference instead. If that won't solve your problem, then you may
need to re-think your design</p>
<p>on a deeper level.</p>
<p>For further reading <a
href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=7">here</a>
is an Item about finalize() method from "Effective Java" book by Joshua
Bloch.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 240</p>
<p><span id="Chapter_43__Annotations_1" class="anchor"></span>Chapter
43: Annotations</p>
<p><a href="https://en.wikipedia.org/wiki/Java_annotation">In Java, an
annotation is a form of syntactic metadata that can be added to Java
source code.</a> <a
href="https://docs.oracle.com/javase/tutorial/java/annotations/">It
provides data</a> about</p>
<p>a program that is not part of the program itself. Annotations have no
direct effect on the operation of the code they annotate. Classes,
methods, variables, parameters and packages are allowed to be
annotated.</p>
<p>Section 43.1: The idea behind Annotations</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7">The
Java Language Specification describes Annotations as follows:</a></p>
<p>An annotation is a marker which associates information with a program
construct, but has no effect at run time.</p>
<p>Annotations may appear before types or declarations. It is possible
for them to appear in a place where they could</p>
<p>apply to both a type or a declaration.</p>
<p>What exactly an annotation applies to is governed by the
"meta-annotation" @Target. See "Defining annotation types" for more
information.</p>
<p>Annotations are used for a multitude of purposes. Frameworks like
Spring and Spring-MVC make use of</p>
<p>annotations to define where Dependencies should be injected or where
requests should be routed.</p>
<p>Other frameworks use annotations for code-generation. Lombok and JPA
are prime examples, that use annotations</p>
<p>to generate Java (and SQL) code.</p>
<p>This topic aims to provide a comprehensive overview of:</p>
<p>How to define your own Annotations?</p>
<p>What Annotations does the Java Language provide?</p>
<p>How are Annotations used in practice?</p>
<p>Section 43.2: Defining annotation types</p>
<p>Annotation types are defined with @<strong>interface</strong>.
Parameters are defined similar to methods of a regular interface.</p>
<p>@<strong>interface</strong> MyAnnotation {</p>
<p>String param1();</p>
<p><strong>boolean</strong> param2();</p>
<p><em><strong>int</strong>[] param3();</em> // array parameter</p>
<p>}</p>
<p>Default values</p>
<p>@<strong>interface</strong> MyAnnotation {</p>
<p>String param1() <strong>default</strong> "someValue";</p>
<p>boolean <strong>param2()</strong> default true<strong>;</strong></p>
<p><strong>int</strong>[] param3() <strong>default</strong> {};</p>
<p>}</p>
<p>Meta-Annotations</p>
<p>Meta-annotations are annotations that can be applied to annotation
types. Special predefined meta-annotation</p>
<p>define how annotation types can be used.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 241</p>
<p>@Target</p>
<p>The @Target meta-annotation restricts the types the annotation can be
applied to.</p>
<p>@Target(ElementType.METHOD)</p>
<p>@<strong>interface</strong> MyAnnotation {</p>
<p>// this annotation can only be applied to methods</p>
<p>}</p>
<p>Multiple values can be added using array notation, e.g.
@Target({ElementType.FIELD, ElementType.TYPE})</p>
<p>Available Values</p>
<p>ElementType target example usage on target element</p>
<p>ANNOTATION_TYPE annotation types @Retention(RetentionPolicy.RUNTIME)
terface MyAnnotation</p>
<p>CONSTRUCTOR constructors @MyAnnotationlic MyClass() {}</p>
<p>FIELD fields, enum constants @XmlAttributevate int count;</p>
<p><strong>for</strong> (@LoopVariable <strong>int</strong> i = 0; i
&lt; 100; i++) {</p>
<p>LOCAL_VARIABLE variable declarations inside @Unused</p>
<p>methods String resultVariable;</p>
<p>}</p>
<p>PACKAGE package (in package- @Deprecatedkage very.old; info. java
)</p>
<p>METHOD methods @XmlElementlic int getCount() {...}</p>
<p><strong>public</strong> Rectangle( @NamedArg("width") double
width,</p>
<p>PARAMETER method/constructor @NamedArg("height") double height) {</p>
<p>parameters ...</p>
<p>}</p>
<p>TYPE classes, interfaces, enums @XmlRootElementlic class Report {}
Version ≥ Java SE 8</p>
<p>ElementType target example usage on target element</p>
<p>TYPE_PARAMETER Type parameter declarations <strong>public</strong>
&lt;@MyAnnotation T&gt; <strong>void</strong> f(T t) {}</p>
<p>TYPE_USE Use of a type Object o = "42";ing s = (@MyAnnotation String)
o;</p>
<p>@Retention</p>
<p>The @Retention meta-annotation defines the annotation visibility
during the applications compilation process or</p>
<p>execution. By default, annotations are included in
.<strong>class</strong> files, but are not visible at runtime. To make
an annotation accessible at runtime, RetentionPolicy.RUNTIME has to be
set on that annotation.</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@<strong>interface</strong> MyAnnotation {</p>
<p>// this annotation can be accessed with reflections at runtime</p>
<p>}</p>
<p>Available values</p>
<p>RetentionPolicy Effect</p>
<p>CLASS The annotation is available in the .<strong>class</strong>
file, but not at runtime</p>
<p>RUNTIME The annotation is available at runtime and can be accessed
via reflection</p>
<p>SOURCE The annotation is available at compile time, but not added to
the .<strong>class</strong> files. The annotation can be used e.g. by an
annotation processor.</p>
<p>@Documented</p>
<p>The @Documented meta-annotation is used to mark annotations whose
usage should be documented by API</p>
<p>documentation generators like <a
href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html">javadoc</a>.
It has no values. With @Documented, all classes that use the annotation
will list it on their generated documentation page. Without @Documented,
it's not possible to see which classes use the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 242</p>
<p><span id="annotation_in_the_documentation"
class="anchor"></span>annotation in the documentation.</p>
<p>@Inherited</p>
<p>The @Inherited meta-annotation is relevant to annotations that are
applied to classes. It has no values. Marking an</p>
<p>annotation as @Inherited alters the way that annotation querying
works.</p>
<p>For a non-inherited annotation, the query only examines the class
being examined.</p>
<p>For an inherited annotation, the query will also check the
super-class chain (recursively) until an instance of the annotation is
found.</p>
<p>Note that only the super-classes are queried: any annotations
attached to interfaces in the classes hierarchy will be ignored.</p>
<p>@Repeatable</p>
<p>The @Repeatable meta-annotation was added in Java 8. It indicates
that multiple instances of the annotation can be attached to the
annotation's target. This meta-annotation has no values.</p>
<p>Section 43.3: Runtime annotation checks via reflection</p>
<p>Java's Reflection API allows the programmer to perform various checks
and operations on class fields, methods and annotations during runtime.
However, in order for an annotation to be at all visible at runtime,
the</p>
<p>RetentionPolicy must be changed to RUNTIME, as demonstrated in the
example below:</p>
<p>@<strong>interface</strong> MyDefaultAnnotation {</p>
<p>}</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@<strong>interface</strong> MyRuntimeVisibleAnnotation {</p>
<p>}</p>
<p><strong>public class</strong> AnnotationAtRuntimeTest {</p>
<p>@MyDefaultAnnotation</p>
<p><strong>static class</strong> RuntimeCheck1 {</p>
<p>}</p>
<p>@MyRuntimeVisibleAnnotation</p>
<p><strong>static class</strong> RuntimeCheck2 {</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Annotation[] annotationsByType =
RuntimeCheck1.<strong>class</strong>.getAnnotations(); Annotation[]
annotationsByType2 =
RuntimeCheck2.<strong>class</strong>.getAnnotations();</p>
<p>System.out.println("default retention: " +
Arrays.toString(annotationsByType)); System.out.println("runtime
retention: " + Arrays.toString(annotationsByType2));</p>
<p>}</p>
<p>}</p>
<p>Section 43.4: Built-in annotations</p>
<p>The Standard Edition of Java comes with some annotations predefined.
You do not need to define them by yourself and you can use them
immediately. They allow the compiler to enable some fundamental checking
of methods,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 243</p>
<p>classes and code.</p>
<p>@Override</p>
<p>This annotation applies to a method and says that this method must
override a superclass' method or implement</p>
<p>an abstract superclass' method definition. If this annotation is used
with any other kind of method, the compiler will throw an error.</p>
<p>Concrete superclass</p>
<p>public class <strong>Vehicle {</strong></p>
<p>public void <strong>drive() {</strong></p>
<p>System.out.println("I am driving");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Car <strong>extends</strong> Vehicle {</p>
<p>// Fine</p>
<p>@Override</p>
<p>public void <strong>drive() {</strong></p>
<p>System.out.prinln("Brrrm, brrm");</p>
<p>}</p>
<p>}</p>
<p>Abstract class</p>
<p>abstract class <strong>Animal {</strong></p>
<p>public abstract void <strong>makeNoise();</strong></p>
<p>}</p>
<p><strong>class</strong> Dog <strong>extends</strong> Animal {</p>
<p>// Fine</p>
<p>@Override</p>
<p><strong>public void</strong> makeNoise() {</p>
<p>System.out.prinln("Woof");</p>
<p>}</p>
<p>}</p>
<p>Does not work</p>
<p><strong>class</strong> Logger1 {</p>
<p><strong>public void</strong> log(String logString) {</p>
<p>System.out.prinln(logString);</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Logger2 {</p>
<p>// This will throw compile-time error. Logger2 is not a subclass of
Logger1. // log method is not overriding anything</p>
<p>@Override</p>
<p><strong>public void</strong> log(String logString) {</p>
<p>System.out.println("Log 2" + logString);</p>
<p>}</p>
<p>}</p>
<p>The main purpose is to catch mistyping, where you think you are
overriding a method, but are actually defining a new one.</p>
<p><strong>class</strong> Vehicle {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 244</p>
<p>public void <strong>drive() {</strong></p>
<p>System.out.println("I am driving");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Car <strong>extends</strong> Vehicle {</p>
<p>// Compiler error. "dirve" is not the correct method name to
override.</p>
<p>@Override</p>
<p>public void <strong>dirve() {</strong></p>
<p>System.out.prinln("Brrrm, brrm");</p>
<p>}</p>
<p>}</p>
<p>Note that the meaning of @Override has changed over time:</p>
<p>In Java 5, it meant that the annotated method had to override a
non-abstract method declared in the</p>
<p>superclass chain.</p>
<p>From Java 6 onward, it is <em>also</em> satisfied if the annotated
method implements an abstract method declared in</p>
<p>the classes superclass / interface hierarchy.</p>
<p>(This can occasionally cause problems when back-porting code to Java
5.)</p>
<p>@Deprecated</p>
<p>This marks the method as deprecated. There can be several reasons for
this:</p>
<p>the API is flawed and is impractical to fix,</p>
<p>usage of the API is likely to lead to errors,</p>
<p>the API has been superseded by another API,</p>
<p>the API is obsolete,</p>
<p>the API is experimental and is subject to incompatible changes,</p>
<p>or any combination of the above.</p>
<p>The specific reason for deprecation can usually be found in the
documentation of the API.</p>
<p>The annotation will cause the compiler to emit an error if you use
it. IDEs may also highlight this method somehow</p>
<p>as deprecated</p>
<p><strong>class</strong> ComplexAlgorithm {</p>
<p>@Deprecated</p>
<p><strong>public void</strong> oldSlowUnthreadSafeMethod() {</p>
<p>// stuff here</p>
<p>}</p>
<p><strong>public void</strong> quickThreadSafeMethod() {</p>
<p>// client code should use this instead</p>
<p>}</p>
<p>}</p>
<p>@SuppressWarnings</p>
<p>In almost all cases, when the compiler emits a warning, the most
appropriate action is to fix the cause. In some instances (Generics code
using untype-safe pre-generics code, for example) this may not be
possible and it's better</p>
<p>to suppress those warnings that you expect and cannot fix, so you can
more clearly see unexpected warnings.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 245</p>
<p><span id="This_annotation_can_be_applied_t"
class="anchor"></span>This annotation can be applied to a whole class,
method or line. It takes the category of warning as a parameter.</p>
<p>@SuppressWarnings("deprecation")</p>
<p><strong>public class</strong> RiddledWithWarnings {</p>
<p>// several methods calling deprecated code here</p>
<p>}</p>
<p>@SuppressWarning("finally")</p>
<p>public boolean <strong>checkData() {</strong></p>
<p>// method calling return from within finally block</p>
<p>}</p>
<p>It is better to limit the scope of the annotation as much as
possible, to prevent unexpected warnings also being suppressed. For
example, confining the scope of the annotation to a single-line:</p>
<p>ComplexAlgorithm algorithm = <strong>new</strong> ComplexAlgorithm();
@SuppressWarnings("deprecation") algoritm.slowUnthreadSafeMethod();
<em>// we marked this method deprecated in an example above</em></p>
<p><em>@SuppressWarnings("unsafe") List list = getUntypeSafeList();</em>
// old library returns, non-generic List containing only integers</p>
<p>The warnings supported by this annotation may vary from compiler to
compiler. Only the unchecked and</p>
<p>deprecation warnings are specifically mentioned in the JLS.
Unrecognized warning types will be ignored.</p>
<p>@SafeVarargs</p>
<p>Because of type erasure, <strong>void</strong> method(T... t) will be
converted to <strong>void</strong> method(Object[] t) meaning that
the</p>
<p>compiler is not always able to verify that the use of varargs is
type-safe. For instance:</p>
<p><strong>private static</strong> <strong>void</strong>
generatesVarargsWarning(T... lists) {</p>
<p>There are instances where the use is safe, in which case you can
annotate the method with the SafeVarargs annotation to suppress the
warning. This obviously hides the warning if your use is unsafe too.</p>
<p>@FunctionalInterface</p>
<p>This is an optional annotation used to mark a FunctionalInterface. It
will cause the compiler to complain if it does not conform to the
FunctionalInterface spec (has a single abstract method)</p>
<p>@FunctionalInterface</p>
<p>public interface <strong>ITrade {</strong></p>
<p><strong>public boolean</strong> check(Trade t);</p>
<p>}</p>
<p>@FunctionalInterface</p>
<p>public interface <strong>Predicate {</strong></p>
<p><strong>boolean</strong> test(T t);</p>
<p>}</p>
<p>Section 43.5: Compile time processing using annotation</p>
<p>processor</p>
<p>This example demonstrates how to do compile time checking of an
annotated element.</p>
<p>The annotation</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 246</p>
<p>The @Setter annotation is a marker can be applied to methods. The
annotation will be discarded during compilation not be available
afterwards.</p>
<p><strong>package</strong> annotation;</p>
<p><strong>import</strong> java.lang.annotation.ElementType;</p>
<p><strong>import</strong> java.lang.annotation.Retention;</p>
<p><strong>import</strong> java.lang.annotation.RetentionPolicy;</p>
<p><strong>import</strong> java.lang.annotation.Target;</p>
<p>@Retention(RetentionPolicy.SOURCE)</p>
<p>@Target(ElementType.METHOD)</p>
<p>public <strong>@</strong>interface <strong>Setter {</strong></p>
<p>}</p>
<p>The annotation processor</p>
<p>The SetterProcessor class is used by the compiler to process the
annotations. It checks, if the methods annotated</p>
<p>with the @Setter annotation are <strong>public</strong>,
non-<strong>static</strong> methods with a name starting with set and
having a uppercase letter as 4th letter. If one of these conditions
isn't met, a error is written to the Messager. The compiler</p>
<p>writes this to stderr, but other tools could use this information
differently. E.g. the NetBeans IDE allows the user</p>
<p>specify annotation processors that are used to display error messages
in the editor.</p>
<p><strong>package</strong> annotation.processor;</p>
<p><strong>import</strong> annotation.Setter;</p>
<p><strong>import</strong> java.util.Set;</p>
<p><strong>import</strong>
javax.annotation.processing.AbstractProcessor; <strong>import</strong>
javax.annotation.processing.Messager;</p>
<p><strong>import</strong>
javax.annotation.processing.ProcessingEnvironment;
<strong>import</strong> javax.annotation.processing.RoundEnvironment;
<strong>import</strong>
javax.annotation.processing.SupportedAnnotationTypes;
<strong>import</strong>
javax.annotation.processing.SupportedSourceVersion;
<strong>import</strong> javax.lang.model.SourceVersion;</p>
<p><strong>import</strong> javax.lang.model.element.Element;</p>
<p><strong>import</strong> javax.lang.model.element.ElementKind;</p>
<p><strong>import</strong>
javax.lang.model.element.ExecutableElement;</p>
<p><strong>import</strong> javax.lang.model.element.Modifier;</p>
<p><strong>import</strong> javax.lang.model.element.TypeElement;</p>
<p><strong>import</strong> javax.tools.Diagnostic;</p>
<p>@SupportedAnnotationTypes({"annotation.Setter"})</p>
<p>@SupportedSourceVersion(SourceVersion.RELEASE_8)</p>
<p><strong>public class</strong> SetterProcessor
<strong>extends</strong> AbstractProcessor {</p>
<p><strong>private</strong> Messager messager;</p>
<p>@Override</p>
<p><strong>public boolean</strong> process(Setextends TypeElement&gt;
annotations, RoundEnvironment roundEnv) {</p>
<p>// get elements annotated with the @Setter annotation</p>
<p>Setextends Element&gt; annotatedElements =
roundEnv.getElementsAnnotatedWith(Setter.<strong>class</strong>);</p>
<p><strong>for</strong> (Element element : annotatedElements) {</p>
<p><strong>if</strong> (element.getKind() == ElementKind.METHOD) {</p>
<p>// only handle methods as targets</p>
<p>checkMethod((ExecutableElement) element);</p>
<p>}</p>
<p>}</p>
<p>// don't claim annotations to allow other processors to process them
<em><strong>return false</strong>;</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 247</p>
<p>}</p>
<p><strong>private void</strong> checkMethod(ExecutableElement method)
{</p>
<p>// check for valid name</p>
<p>String name = method.getSimpleName().toString();</p>
<p><strong>if</strong> (!name.startsWith("set")) {</p>
<p>printError(method, "setter name must start with
<strong>\"</strong>set<strong>\"</strong>");</p>
<p>} <strong>else if</strong> (name.length() == 3) {</p>
<p>printError(method, "the method name must contain more than just
<strong>\"</strong>set<strong>\"</strong>");</p>
<p>} <strong>else if</strong> (Character.isLowerCase(name.charAt(3)))
{</p>
<p><strong>if</strong> (method.getParameters().size() != 1) {</p>
<p>printError(method, "character following
<strong>\"</strong>set<strong>\"</strong> must be upper case");</p>
<p>}</p>
<p>}</p>
<p>// check, if setter is public</p>
<p><strong>if</strong>
(!method.getModifiers().contains(Modifier.<strong>PUBLIC</strong>))
{</p>
<p>printError(method, "setter must be public");</p>
<p>}</p>
<p>// check, if method is static</p>
<p><strong>if</strong>
(method.getModifiers().contains(Modifier.<strong>STATIC</strong>)) {</p>
<p>printError(method, "setter must not be static");</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> printError(Element element, String
message) { messager.printMessage(Diagnostic.Kind.ERROR, message,
element); }</p>
<p>@Override</p>
<p><strong>public void</strong> init(ProcessingEnvironment
processingEnvironment) {</p>
<p><strong>super</strong>.init(processingEnvironment);</p>
<p>// get messager for printing errors</p>
<p>messager = processingEnvironment.getMessager();</p>
<p>}</p>
<p>}</p>
<p>Packaging</p>
<p>To be applied by the compiler, the annotation processor needs to be
made available to the SPI (see ServiceLoader).</p>
<p>To do this a text file
META-INF/services/javax.annotation.processing.Processor needs to be
added to the jar</p>
<p>file containing the annotation processor and the annotation in
addition to the other files. The file needs to include the fully
qualified name of the annotation processor, i.e. it should look like
this</p>
<p>annotation.processor.SetterProcessor</p>
<p>We'll assume the jar file is called AnnotationProcessor.jar
below.</p>
<p>Example annotated class</p>
<p>The following class is example class in the default package with the
annotations being applied to the correct</p>
<p>elements according to the retention policy. However only the
annotation processor only considers the second</p>
<p>method a valid annotation target.</p>
<p><strong>import</strong> annotation.Setter;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 248</p>
<p><strong>public class</strong> AnnotationProcessorTest {</p>
<p>@Setter</p>
<p><strong>private void</strong> setValue(String value) {}</p>
<p>@Setter</p>
<p><strong>public void</strong> setString(String value) {}</p>
<p>@Setter</p>
<p><strong>public static void</strong> main(String[] args) {}</p>
<p>}</p>
<p>Using the annotation processor with javac</p>
<p>If the annotation processor is discovered using the SPI, it is
automatically used to process annotated elements. E.g.</p>
<p>compiling the AnnotationProcessorTest class using</p>
<p>javac -cp AnnotationProcessor.jar AnnotationProcessorTest.java</p>
<p>yields the following output</p>
<p>AnnotationProcessorTest.java:6: error: setter must be public private
void setValue(String value) {}</p>
<p>^</p>
<p>AnnotationProcessorTest.java:12: error: setter name must start with
"set" public static void main(String[] args) {}</p>
<p>^</p>
<p>2 errors</p>
<p>instead of compiling normally. No .<strong>class</strong> file is
created.</p>
<p>This could be prevented by specifying the -proc:none option for
javac. You could also forgo the usual compilation</p>
<p>by specifying -proc:only instead.</p>
<p>IDE integration</p>
<p>Netbeans</p>
<p>Annotation processors can be used in the NetBeans editor. To do this
the annotation processor needs to be specified in the project
settings:</p>
<p>1. go to Project Properties &gt; Build &gt; Compiling</p>
<p>2. add check marks for Enable Annotation Processing and Enable
Annotation Processing in Editor</p>
<p>3. click Add next to the annotation processor list</p>
<p>4. in the popup that appears enter the fully qualified class name of
the annotation processor and click Ok.</p>
<p>Result</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 249</p>
<p><span id="page_274" class="anchor"></span><img
src="media/index-274_1.png" style="width:5.45833in;height:3.05556in"
alt="index-274_1.png" /></p>
<p>Section 43.6: Repeating Annotations</p>
<p>Until Java 8, two instances of the same annotation could not be
applied to a single element. The standard workaround was to use a
container annotation holding an array of some other annotation:</p>
<p>// Author.java</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public <strong>@</strong>interface <strong>Author {</strong></p>
<p>String value();</p>
<p>}</p>
<p>// Authors.java</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>public <strong>@</strong>interface <strong>Authors {</strong></p>
<p>Author[] value();</p>
<p>}</p>
<p>// Test.java</p>
<p>@Authors({</p>
<p>@Author("Mary"),</p>
<p>@Author("Sam")</p>
<p>})</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Author[] authors =
Test.<strong>class</strong>.getAnnotation(Authors.<strong>class</strong>).value();</p>
<p><strong>for</strong> (Author author : authors) {</p>
<p>System.out.println(author.value());</p>
<p>// Output:</p>
<p>// Mary</p>
<p>// Sam</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Version ≥ Java SE 8</p>
<p>Java 8 provides a cleaner, more transparent way of using container
annotations, using the @Repeatable annotation. First we add this to the
Author class:</p>
<p>@Repeatable(Authors.<strong>class</strong>)</p>
<p>This tells Java to treat multiple @Author annotations as though they
were surrounded by the @Authors container.</p>
<p>We can also use <strong>Class</strong>.getAnnotationsByType() to
access the @Author array by its own class, instead of through its</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 250</p>
<p><span id="container" class="anchor"></span>container:</p>
<p>@Author("Mary")</p>
<p>@Author("Sam")</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Author[] authors =
Test.<strong>class</strong>.getAnnotationsByType(Author.<strong>class</strong>);</p>
<p><strong>for</strong> (Author author : authors) {</p>
<p>System.out.println(author.value());</p>
<p>// Output:</p>
<p>// Mary</p>
<p>// Sam</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 43.7: Inherited Annotations</p>
<p>By default class annotations do not apply to types extending them.
This can be changed by adding the @Inherited</p>
<p>annotation to the annotation definition</p>
<p>Example</p>
<p>Consider the following 2 Annotations:</p>
<p>@Inherited</p>
<p>@Target(ElementType.TYPE)</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p><strong>public</strong> @<strong>interface</strong>
InheritedAnnotationType {</p>
<p>}</p>
<p>and</p>
<p>@Target(ElementType.TYPE)</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p><strong>public</strong> @<strong>interface</strong>
UninheritedAnnotationType {</p>
<p>}</p>
<p>If three classes are annotated like this:</p>
<p>@UninheritedAnnotationType</p>
<p>class <strong>A {</strong></p>
<p>}</p>
<p>@InheritedAnnotationType</p>
<p>class <strong>B</strong> extends <strong>A {</strong></p>
<p>}</p>
<p>class <strong>C</strong> extends <strong>B {</strong></p>
<p>}</p>
<p>running this code</p>
<p>System.out.println(<strong>new</strong>
A().getClass().getAnnotation(InheritedAnnotationType.<strong>class</strong>));
System.out.println(<strong>new</strong>
B().getClass().getAnnotation(InheritedAnnotationType.<strong>class</strong>));
System.out.println(<strong>new</strong>
C().getClass().getAnnotation(InheritedAnnotationType.<strong>class</strong>));
System.out.println("_________________________________");
System.out.println(<strong>new</strong>
A().getClass().getAnnotation(UninheritedAnnotationType.<strong>class</strong>));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 251</p>
<p><span id="System_out_println_new_B___getCl"
class="anchor"></span>System.out.println(<strong>new</strong>
B().getClass().getAnnotation(UninheritedAnnotationType.<strong>class</strong>));
System.out.println(<strong>new</strong>
C().getClass().getAnnotation(UninheritedAnnotationType.<strong>class</strong>));</p>
<p>will print a result similar to this (depending on the packages of the
annotation):</p>
<p>null</p>
<p>@InheritedAnnotationType()</p>
<p>@InheritedAnnotationType()</p>
<p>_________________________________</p>
<p>@UninheritedAnnotationType()</p>
<p>null</p>
<p>null</p>
<p>Note that annotations can only be inherited from classes, not
interfaces.</p>
<p>Section 43.8: Getting Annotation values at run-time</p>
<p>You can fetch the current properties of the Annotation by using
Reflection to fetch the Method or Field or Class</p>
<p>which has an Annotation applied to it, and then fetching the desired
properties.</p>
<p>@Retention(RetentionPolicy.RUNTIME)</p>
<p>@<strong>interface</strong> MyAnnotation {</p>
<p>String key() <strong>default</strong> "foo";</p>
<p>String value() <strong>default</strong> "bar";</p>
<p>}</p>
<p><strong>class</strong> AnnotationExample {</p>
<p>// Put the Annotation on the method, but leave the defaults</p>
<p>@MyAnnotation</p>
<p><strong>public void</strong> testDefaults() <strong>throws</strong>
Exception {</p>
<p>// Using reflection, get the public method "testDefaults", which is
this method with no args <em>Method method =
AnnotationExample.<strong>class</strong>.getMethod("testDefaults",
<strong>null</strong>);</em></p>
<p>// Fetch the Annotation that is of type MyAnnotation from the
Method</p>
<p>MyAnnotation annotation =
(MyAnnotation)method.getAnnotation(MyAnnotation.<strong>class</strong>);</p>
<p>// Print out the settings of the Annotation</p>
<p>print(annotation);</p>
<p>}</p>
<p>//Put the Annotation on the method, but override the settings</p>
<p>@MyAnnotation(key="baz", value="buzz")</p>
<p><strong>public void</strong> testValues() <strong>throws</strong>
Exception {</p>
<p>// Using reflection, get the public method "testValues", which is
this method with no args <em>Method method =
AnnotationExample.<strong>class</strong>.getMethod("testValues",
<strong>null</strong>);</em></p>
<p>// Fetch the Annotation that is of type MyAnnotation from the
Method</p>
<p>MyAnnotation annotation =
(MyAnnotation)method.getAnnotation(MyAnnotation.<strong>class</strong>);</p>
<p>// Print out the settings of the Annotation</p>
<p>print(annotation);</p>
<p>}</p>
<p><strong>public void</strong> print(MyAnnotation annotation) {</p>
<p>// Fetch the MyAnnotation 'key' &amp; 'value' properties, and print
them out <em>System.out.println(annotation.key() + " = " +
annotation.value());</em></p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 252</p>
<p><span id="AnnotationExample_example___new"
class="anchor"></span>AnnotationExample example = <strong>new</strong>
AnnotationExample();</p>
<p>try <strong>{</strong></p>
<p>example.testDefaults();</p>
<p>example.testValues();</p>
<p>} <strong>catch</strong>( Exception e ) {</p>
<p>// Shouldn't throw any Exceptions</p>
<p>System.err.println("Exception [" + e.getClass().getName() + "] - " +
e.getMessage());</p>
<p>e.printStackTrace(System.err);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The output will be</p>
<p>foo = bar</p>
<p>baz = buzz</p>
<p>Section 43.9: Annotations for 'this' and receiver parameters</p>
<p>When Java annotations were first introduced there was no provision
for annotating the target of an instance</p>
<p>method or the hidden constructor parameter for an inner classes
constructor. This was remedied in Java 8 with</p>
<p>addition of <em>receiver parameter</em> declarations; see <a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1-220">JLS
8.4.1</a>.</p>
<p>The receiver parameter is an optional syntactic device for an
instance method or an inner class's</p>
<p>constructor. For an instance method, the receiver parameter
represents the object for which the method is invoked. For an inner
class's constructor, the receiver parameter represents the immediately
enclosing</p>
<p>instance of the newly constructed object. Either way, the receiver
parameter exists solely to allow the type</p>
<p>of the represented object to be denoted in source code, so that the
type may be annotated. The receiver parameter is not a formal parameter;
more precisely, it is not a declaration of any kind of variable</p>
<p>(§4.12.3), it is never bound to any value passed as an argument in a
method invocation expression or</p>
<p>qualified class instance creation expression, and it has no effect
whatsoever at run time.</p>
<p>The following example illustrates the syntax for both kinds of
receiver parameter:</p>
<p>public class <strong>Outer {</strong></p>
<p>public class <strong>Inner {</strong></p>
<p><strong>public</strong> Inner (Outer <strong>this</strong>) {</p>
<p>// ...</p>
<p>}</p>
<p>public void <strong>doIt(Inner</strong> this<strong>) {</strong></p>
<p>// ...</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The sole purpose of receiver parameters is to allow you to add
annotations. For example, you might have a custom annotation @IsOpen
whose purpose is to assert that a Closeable object has not been closed
when a method is</p>
<p>called. For example:</p>
<p><strong>public class</strong> MyResource <strong>extends</strong>
Closeable {</p>
<p><strong>public void</strong> update(@IsOpen MyResource
<strong>this</strong>, <strong>int</strong> value) {</p>
<p>// ...</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 253</p>
<p><span id="public_void_close" class="anchor"></span>public void
<strong>close() {</strong></p>
<p>// ...</p>
<p>}</p>
<p>}</p>
<p>At one level, the @IsOpen annotation on <strong>this</strong> could
simply serve as documentation. However, we could potentially</p>
<p>do more. For example:</p>
<p>An annotation processor could insert a runtime check that
<strong>this</strong> is not in closed state when update is called.</p>
<p>A code checker could perform a static code analysis to find cases
where <strong>this</strong> <em>could be</em> closed when update is
called.</p>
<p>Section 43.10: Add multiple annotation values</p>
<p>An Annotation parameter can accept multiple values if it is defined
as an array. For example the standard annotation @SuppressWarnings is
defined like this:</p>
<p><strong>public</strong> @<strong>interface</strong> SuppressWarnings
{</p>
<p>String[] value();</p>
<p>}</p>
<p>The value parameter is an array of Strings. You can set multiple
values by using a notation similar to Array initializers:</p>
<p>@SuppressWarnings({"unused"})</p>
<p>@SuppressWarnings({"unused", "javadoc"})</p>
<p>If you only need to set a single value, the brackets can be
omitted:</p>
<p>@SuppressWarnings("unused")</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 254</p>
<p><span id="Chapter_44__Immutable_Class_1"
class="anchor"></span>Chapter 44: Immutable Class</p>
<p>Immutable objects are instances whose state doesn’t change after it
has been initialized. For example, String is an</p>
<p>immutable class and once instantiated its value never changes.</p>
<p>Section 44.1: Example without mutable refs</p>
<p>public final class <strong>Color {</strong></p>
<p>final private int <strong>red;</strong></p>
<p>final private int <strong>green;</strong></p>
<p>final private int <strong>blue;</strong></p>
<p><strong>private void</strong> check(<strong>int</strong> red,
<strong>int</strong> green, <strong>int</strong> blue) {</p>
<p><strong>if</strong> (red &lt; 0 || red &gt; 255 || green &lt; 0 ||
green &gt; 255 || blue &lt; 0 || blue &gt; 255) {</p>
<p><strong>throw new</strong> IllegalArgumentException();</p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> Color(<strong>int</strong> red,
<strong>int</strong> green, <strong>int</strong> blue) {</p>
<p>check(red, green, blue);</p>
<p><strong>this</strong>.red = red;</p>
<p><strong>this</strong>.green = green;</p>
<p><strong>this</strong>.blue = blue;</p>
<p>}</p>
<p><strong>public</strong> Color invert() {</p>
<p><strong>return new</strong> Color(255- red, 255- green, 255-
blue);</p>
<p>}</p>
<p>}</p>
<p>Section 44.2: What is the advantage of immutability?</p>
<p>The advantage of immutability comes with concurrency. It is difficult
to maintain correctness in mutable objects, as multiple threads could be
trying to change the state of the same object, leading to some threads
seeing a different</p>
<p>state of the same object, depending on the timing of the reads and
writes to the said object.</p>
<p>By having an immutable object, one can ensure that all threads that
are looking at the object will be seeing the</p>
<p>same state, as the state of an immutable object will not change.</p>
<p>Section 44.3: Rules to define immutable classes</p>
<p>The following rules define a simple strategy for creating immutable
objects.</p>
<p>1. Don't provide "setter" methods - methods that modify fields or
objects referred to by fields.</p>
<p>2. Make all fields final and private.</p>
<p>3. Don't allow subclasses to override methods. The simplest way to do
this is to declare the class as final. A</p>
<p>more sophisticated approach is to make the constructor private and
construct instances in factory methods.</p>
<p>4. If the instance fields include references to mutable objects,
don't allow those objects to be changed: 5. Don't provide methods that
modify the mutable objects.</p>
<p>6. Don't share references to the mutable objects. Never store
references to external, mutable objects passed to</p>
<p>the constructor; if necessary, create copies, and store references to
the copies. Similarly, create copies of</p>
<p>your internal mutable objects when necessary to avoid returning the
originals in your methods.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 255</p>
<p><span id="Section_44_4__Example_with_mutab"
class="anchor"></span>Section 44.4: Example with mutable refs</p>
<p>In this case class Point is mutable and some user can modify state of
object of this class.</p>
<p><strong>class</strong> Point {</p>
<p>private int <strong>x, y;</strong></p>
<p><strong>public</strong> Point(<strong>int</strong> x,
<strong>int</strong> y) {</p>
<p><strong>this</strong>.x = x;</p>
<p><strong>this</strong>.y = y;</p>
<p>}</p>
<p>public int <strong>getX() {</strong></p>
<p>return <strong>x;</strong></p>
<p>}</p>
<p>public void <strong>setX(</strong>int <strong>x) {</strong></p>
<p><strong>this</strong>.x = x;</p>
<p>}</p>
<p>public int <strong>getY() {</strong></p>
<p>return <strong>y;</strong></p>
<p>}</p>
<p>public void <strong>setY(</strong>int <strong>y) {</strong></p>
<p><strong>this</strong>.y = y;</p>
<p>}</p>
<p>}</p>
<p>//...</p>
<p>public final class <strong>ImmutableCircle {</strong></p>
<p><strong>private final</strong> Point center;</p>
<p>private final double <strong>radius;</strong></p>
<p><strong>public</strong> ImmutableCircle(Point center,
<strong>double</strong> radius) {</p>
<p><em>// we create new object here because it shouldn't be changed</em>
<strong>this</strong>.center = <strong>new</strong> Point(center.getX(),
center.getY()); <strong>this</strong>.radius = radius;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 256</p>
<p><span id="Chapter_45__Immutable_Objects_1"
class="anchor"></span>Chapter 45: Immutable Objects</p>
<p>Section 45.1: Creating an immutable version of a type using</p>
<p>defensive copying</p>
<p>Some basic types and classes in Java are fundamentally mutable. For
example, all array types are mutable, and so</p>
<p>are classes like java.util.Data. This can be awkward in situations
where an immutable type is mandated.</p>
<p>One way to deal with this is to create an immutable wrapper for the
mutable type. Here is a simple wrapper for an array of integers</p>
<p><strong>public class</strong> ImmutableIntArray {</p>
<p>private final int<strong>[] array;</strong></p>
<p><strong>public</strong> ImmutableIntArray(<strong>int</strong>[]
array) {</p>
<p><strong>this</strong>.array = array.clone();</p>
<p>}</p>
<p><strong>public int</strong>[] getValue() {</p>
<p>return this<strong>.clone();</strong></p>
<p>}</p>
<p>}</p>
<p>This class works by using <em>defensive copying</em> to isolate the
mutable state (the <strong>int</strong>[]) from any code that might
mutate</p>
<p>it:</p>
<p>The constructor uses clone() to create a distinct copy of the
parameter array. If the caller of the constructor subsequent changed the
parameter array, it would not affect the state of the
ImmutableIntArray.</p>
<p>The getValue() method also uses clone() to create the array that is
returned. If the caller were to change</p>
<p>the result array, it would not affect the state of the
ImmutableIntArray.</p>
<p>We could also add methods to ImmutableIntArray to perform read-only
operations on the wrapped array; e.g. get</p>
<p>its length, get the value at a particular index, and so on.</p>
<p>Note that an immutable wrapper type implemented this way is not type
compatible with the original type. You</p>
<p>cannot simply substitute the former for the latter.</p>
<p>Section 45.2: The recipe for an immutable class</p>
<p>An immutable object is an object whose state cannot be changed. An
immutable class is a class whose instances are</p>
<p>immutable by design, and implementation. The Java class which is most
commonly presented as an example of</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">immutability
is java.lang.String.</a></p>
<p>The following is a stereotypical example:</p>
<p>public final class <strong>Person {</strong></p>
<p>private final <strong>String name;</strong></p>
<p><em><strong>private final</strong> String ssn;</em> // (SSN == social
security number)</p>
<p><strong>public</strong> Person(String name, String ssn) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.ssn = ssn;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 257</p>
<p><span id="public_String_getName"
class="anchor"></span><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public</strong> String getSSN() {</p>
<p>return <strong>ssn;</strong></p>
<p>}</p>
<p>}</p>
<p>A variation on this is to declare the constructor as
<strong>private</strong> and provide a <strong>public static</strong>
factory method instead.</p>
<p>The <em>standard recipe</em> for an immutable class is as
follows:</p>
<p>All properties must be set in the constructor(s) or factory
method(s). There should be no setters.</p>
<p>If it is necessary to include setters for interface compatibility
reasons, they should either do nothing or throw an exception.</p>
<p>All properties should be declared as <strong>private</strong> and
<strong>final</strong>.</p>
<p>For all properties that are references to mutable types:</p>
<p>the property should be initialized with a deep copy of the value
passed via the constructor, and</p>
<p>the property's getter should return a deep copy of the property
value.</p>
<p>The class should be declared as <strong>final</strong> to prevent
someone creating a mutable subclass of an immutable</p>
<p>class.</p>
<p>A couple of other things to note:</p>
<p>Immutability does not prevent object from being nullable; e.g.
<strong>null</strong> can be assigned to a String variable.</p>
<p>If an immutable classes properties are declared as
<strong>final</strong>, instances are inherently thread-safe. This
makes</p>
<p>immutable classes a good building block for implementing
multi-threaded applications.</p>
<p>Section 45.3: Typical design flaws which prevent a class from</p>
<p>being immutable</p>
<p>Using some setters, without setting all needed properties in the
constructor(s)</p>
<p><em><strong>public final class</strong> Person {</em> // example of a
bad immutability</p>
<p>private final <strong>String name;</strong></p>
<p><strong>private final</strong> String surname;</p>
<p><strong>public</strong> Person(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p><strong>public</strong> String getName() { <strong>return</strong>
name;}</p>
<p><strong>public</strong> String getSurname() { <strong>return</strong>
surname;}</p>
<p><strong>public void</strong> setSurname(String surname) {
<strong>this</strong>.surname = surname); }</p>
<p>}</p>
<p>It’s easy to show that Person class is not immutable:</p>
<p>Person person = <strong>new</strong> Person("Joe");</p>
<p><em>person.setSurname("Average");</em> // NOT OK, change surname
field after creation</p>
<p>To fix it, simply delete setSurname() and refactor the constructor as
follows:</p>
<p><strong>public</strong> Person(String name, String surname) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.surname = surname;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 258</p>
<p>}</p>
<p>Not marking instance variables as private and final</p>
<p>Take a look at the following class:</p>
<p>public final class <strong>Person {</strong></p>
<p><strong>public</strong> String name;</p>
<p><strong>public</strong> Person(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p>}</p>
<p>The following snippet shows that the above class is not
immutable:</p>
<p>Person person = <strong>new</strong> Person("Average Joe");</p>
<p><em>person.name = "Magic Mike";</em> // not OK, new name for person
after creation</p>
<p>To fix it, simply mark name property as <strong>private</strong> and
<strong>final</strong>.</p>
<p>Exposing a mutable object of the class in a getter</p>
<p>Take a look at the following class:</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p>public final class <strong>Names {</strong></p>
<p>private final <strong>List names;</strong></p>
<p><strong>public</strong> Names(List names) {</p>
<p><strong>this</strong>.names = <strong>new</strong>
ArrayList(names);</p>
<p>}</p>
<p><strong>public</strong> List getNames() {</p>
<p><strong>return</strong> names;</p>
<p>}</p>
<p>public int <strong>size() {</strong></p>
<p><strong>return</strong> names.size();</p>
<p>}</p>
<p>}</p>
<p>Names class seems immutable at the first sight, but it is not as the
following code shows:</p>
<p>List namesList = <strong>new</strong> ArrayList();</p>
<p>namesList.add("Average Joe");</p>
<p>Names names = <strong>new</strong> Names(namesList);</p>
<p>System.out.println(names.size()); <em>// 1, only containing "Average
Joe"</em> namesList = names.getNames();</p>
<p>namesList.add("Magic Mike");</p>
<p><em>System.out.println(names.size());</em> // 2, NOT OK, now names
also contains "Magic Mike"</p>
<p>This happened because a change to the reference List returned by
getNames() can modify the actual list of Names.</p>
<p>To fix this, simply avoid returning references that reference class's
mutable objects <em>either</em> by making defensive copies, as
follows:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 259</p>
<p><strong>public</strong> List getNames() {</p>
<p><strong>return new</strong> ArrayList(<strong>this</strong>.names);
<em>// copies elements</em></p>
<p>}</p>
<p><em>or</em> by designing getters in way that only other <em>immutable
objects</em> and <em>primitives</em> are returned, as follows:</p>
<p><strong>public</strong> String getName(<strong>int</strong> index)
{</p>
<p><strong>return</strong> names.get(index);</p>
<p>}</p>
<p>public int <strong>size() {</strong></p>
<p><strong>return</strong> names.size();</p>
<p>}</p>
<p>Injecting constructor with object(s) that can be modified outside the
immutable class</p>
<p>This is a variation of the previous flaw. Take a look at the
following class:</p>
<p><strong>import</strong> java.util.List;</p>
<p>public final class <strong>NewNames {</strong></p>
<p>private final <strong>List names;</strong></p>
<p><strong>public</strong> Names(List names) {</p>
<p><strong>this</strong>.names = names;</p>
<p>}</p>
<p><strong>public</strong> String getName(<strong>int</strong> index)
{</p>
<p><strong>return</strong> names.get(index);</p>
<p>}</p>
<p>public int <strong>size() {</strong></p>
<p><strong>return</strong> names.size();</p>
<p>}</p>
<p>}</p>
<p>As Names class before, also NewNames class seems immutable at the
first sight, but it is not, in fact the following</p>
<p>snippet proves the contrary:</p>
<p>List namesList = <strong>new</strong> ArrayList();</p>
<p>namesList.add("Average Joe");</p>
<p>NewNames names = <strong>new</strong> NewNames(namesList);</p>
<p>System.out.println(names.size()); <em>// 1, only containing "Average
Joe"</em> namesList.add("Magic Mike");</p>
<p><em>System.out.println(names.size());</em> // 2, NOT OK, now names
also contains "Magic Mike"</p>
<p>To fix this, as in the previous flaw, simply make defensive copies of
the object without assigning it directly to the immutable class, i.e.
constructor can be changed as follows:</p>
<p><strong>public</strong> Names(List names) {</p>
<p><strong>this</strong>.names = <strong>new</strong>
ArrayList(names);</p>
<p>}</p>
<p>Letting the methods of the class being overridden</p>
<p>Take a look at the following class:</p>
<p>public class <strong>Person {</strong></p>
<p>private final <strong>String name;</strong></p>
<p><strong>public</strong> Person(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p><strong>public</strong> String getName() { <strong>return</strong>
name;}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 260</p>
<p>}</p>
<p>Person class seems immutable at the first sight, but suppose a new
subclass of Person is defined:</p>
<p><strong>public class</strong> MutablePerson <strong>extends</strong>
Person {</p>
<p><strong>private</strong> String newName;</p>
<p><strong>public</strong> MutablePerson(String name) {</p>
<p><strong>super</strong>(name);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String getName() {</p>
<p><strong>return</strong> newName;</p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p>newName = name;</p>
<p>}</p>
<p>}</p>
<p>now Person (im)mutability can be exploited through polymorphism by
using the new subclass:</p>
<p>Person person = <strong>new</strong> MutablePerson("Average
Joe");</p>
<p>System.out.println(person.getName()); prints Average Joe
person.setName("Magic Mike"); <em>// NOT OK, person has now a new
name!</em> System.out.println(person.getName()); <em>// prints Magic
Mike</em></p>
<p>To fix this, <em>either</em> mark the class as <strong>final</strong>
so it cannot be extended <em>or</em> declare all of its constructor(s)
as <strong>private</strong>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 261</p>
<p><span id="Chapter_46__Visibility__controll_1"
class="anchor"></span>Chapter 46: Visibility (controlling access to</p>
<p>members of a class)</p>
<p>Section 46.1: Private Visibility</p>
<p><strong>private</strong> visibility allows a variable to only be
accessed by its class. They are often used in
<strong>conjunction</strong> with <strong>public</strong></p>
<p>getters and setters.</p>
<p><strong>class</strong> SomeClass {</p>
<p>private int <strong>variable;</strong></p>
<p><strong>public int</strong> getVariable() {</p>
<p><strong>return</strong> variable;</p>
<p>}</p>
<p><strong>public void</strong> setVariable(<strong>int</strong>
variable) {</p>
<p><strong>this</strong>.variable = variable;</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SomeOtherClass {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>SomeClass sc = <strong>new</strong> SomeClass();</p>
<p>// These statement won't compile because SomeClass#variable is
private:</p>
<p>sc.variable = 7;</p>
<p>System.out.println(sc.variable);</p>
<p>// Instead, you should use the public getter and setter:</p>
<p>sc.setVariable(7);</p>
<p>System.out.println(sc.getVariable());</p>
<p>}</p>
<p>}</p>
<p>Section 46.2: Public Visibility</p>
<p>Visible to the class, package, and subclass.</p>
<p>Let's see an example with the class Test.</p>
<p>public class <strong>Test{</strong></p>
<p><strong>public int</strong> number = 2;</p>
<p><strong>public</strong> Test(){</p>
<p>}</p>
<p>}</p>
<p>Now let's try to create an instance of the class. In this example,
<strong>we can</strong> access number because it is
<strong>public</strong>.</p>
<p>public class <strong>Other{</strong></p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>Test t = <strong>new</strong> Test();</p>
<p>System.out.println(t.number);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 262</p>
<p><span id="_11" class="anchor"></span>}</p>
<p>Section 46.3: Package Visibility</p>
<p>With <strong>no modifier</strong>, the default is package visibility.
<em>From the Java Documentation,</em> "[package visibility]
indicates</p>
<p>whether classes in the same package as the class (regardless of their
parentage) have access to the member." In</p>
<p>this example from <a
href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/javax/swing">javax.swing,</a></p>
<p><strong>package</strong> javax.swing;</p>
<p>public abstract class <strong>JComponent</strong> extends
<strong>Container … {</strong></p>
<p>…</p>
<p><strong>static boolean</strong> DEBUG_GRAPHICS_LOADED;</p>
<p>…</p>
<p>}</p>
<p>DebugGraphics is in the same package, so DEBUG_GRAPHICS_LOADED is
accessible.</p>
<p><strong>package</strong> javax.swing;</p>
<p><strong>public class</strong> DebugGraphics <strong>extends</strong>
Graphics {</p>
<p>…</p>
<p>static <strong>{</strong></p>
<p>JComponent.DEBUG_GRAPHICS_LOADED = <strong>true</strong>;</p>
<p>}</p>
<p>…</p>
<p>}</p>
<p>This <a href="http://programmers.stackexchange.com/q/220053">article
gives some background on the topic.</a></p>
<p>Section 46.4: Protected Visibility</p>
<p>Protected visibility causes means that this member is visible to its
package, along with any of its subclasses.</p>
<p>As an example:</p>
<p><strong>package</strong> com.stackexchange.docs;</p>
<p>public class <strong>MyClass{</strong></p>
<p><em><strong>protected int</strong> variable;</em> //This is the
variable that we are trying to access <em><strong>public</strong>
MyClass(){</em></p>
<p>variable = 2;</p>
<p>};</p>
<p>}</p>
<p>Now we'll extend this class and try to access one of its
<strong>protected</strong> members.</p>
<p><strong>package</strong> some.other.pack;</p>
<p><strong>import</strong> com.stackexchange.docs.MyClass;</p>
<p>public class <strong>SubClass</strong> extends
<strong>MyClass{</strong></p>
<p><strong>public</strong> SubClass(){</p>
<p>super<strong>();</strong></p>
<p>System.out.println(<strong>super</strong>.variable);</p>
<p>}</p>
<p>}</p>
<p>You would be also able to access a <strong>protected</strong> member
without extending it if you are accessing it from the same package.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 263</p>
<p><span id="Note_that_this_modifier_only_wor"
class="anchor"></span>Note that this modifier only works on members of a
class, not on the class itself.</p>
<p>Section 46.5: Summary of Class Member Access Modifiers</p>
<p>Access Modifier Visibility Inheritance</p>
<p>Private Class only Can't be inherited</p>
<p><em>No modifier</em> / Package In package Available if subclass in
package</p>
<p>Protected In package Available in subclass</p>
<p>Public Everywhere Available in subclass</p>
<p>There was once a <strong>private protected</strong> (both keywords at
once) modifier that could be applied to methods or variables to make
them accessible from a subclass outside the package, but make them
private to the classes in</p>
<p><a href="http://stackoverflow.com/q/41431533/6754053">that package.
However, this was removed in Java 1.0's release.</a></p>
<p>Section 46.6: Interface members</p>
<p>public interface <strong>MyInterface {</strong></p>
<p>public void <strong>foo();</strong></p>
<p><strong>int</strong> bar();</p>
<p><strong>public</strong> String TEXT = "Hello";</p>
<p><strong>int</strong> ANSWER = 42;</p>
<p>public class <strong>X {</strong></p>
<p>}</p>
<p>class <strong>Y {</strong></p>
<p>}</p>
<p>}</p>
<p>Interface members always have public visibility, even if the
<strong>public</strong> keyword is omitted. So both foo(), bar(),
TEXT,</p>
<p>ANSWER , X, and Y have public visibility. However, access may still
be limited by the containing interface - since MyInterface has public
visibility, its members may be accessed from anywhere, but if
MyInterface had had</p>
<p>package visibility, its members would only have been accessible from
within the same package.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 264</p>
<p><span id="Chapter_47__Generics_1" class="anchor"></span>Chapter 47:
Generics</p>
<p><a href="https://en.wikipedia.org/wiki/Generics_in_Java">Generics are
a facility of generic programming that extend Java's type system to
allow a type or method to operate</a></p>
<p>on objects of various types while providing compile-time type safety.
In particular, the Java collections framework supports generics to
specify the type of objects stored in a collection instance.</p>
<p>Section 47.1: Creating a Generic Class</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/generics/">Generics
enable classes, interfaces, and methods to take other classes and
interfaces as type parameters.</a></p>
<p>This example uses generic class Param to take a single <strong>type
parameter</strong> T, delimited by angle brackets
(&lt;<strong>&gt;</strong>):</p>
<p>public class <strong>Param {</strong></p>
<p><strong>private</strong> T value;</p>
<p><strong>public</strong> T getValue() {</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p><strong>public void</strong> setValue(T value) {</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p>}</p>
<p>To instantiate this class, provide a <strong>type argument</strong>
in place of T. For example, Integer:</p>
<p>Param integerParam = <strong>new</strong> Param();</p>
<p>The type argument can be any reference type, including arrays and
other generic types:</p>
<p>Param stringArrayParam;</p>
<p>Param&lt;<strong>int</strong>[][]&gt; int2dArrayParam;</p>
<p>Param&gt; objectNestedParam;</p>
<p>In Java SE 7 and later, the type argument can be replaced with an
empty set of type arguments (&lt;<strong>&gt;</strong>) called the
<em>diamond</em>:</p>
<p>Version ≥ Java SE 7</p>
<p>Param integerParam = <strong>new</strong> Param&lt;&gt;();</p>
<p>Unlike other identifiers, type parameters have no naming constraints.
However their names are commonly the first</p>
<p>letter of their purpose in upper case. (This is true even throughout
the official JavaDocs.)</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Examples
include T for "type",</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">E
for "element"</a> and <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">K/V
for "key"/"value"</a>.</p>
<p>Extending a generic class</p>
<p>public abstract class <strong>AbstractParam {</strong></p>
<p><strong>private</strong> T value;</p>
<p><strong>public</strong> T getValue() {</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p><strong>public void</strong> setValue(T value) {</p>
<p><strong>this</strong>.value = value;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 265</p>
<p>}</p>
<p>}</p>
<p>AbstractParam is an abstract class declared with a type parameter of
T. When extending this class, that type</p>
<p>parameter can be replaced by a type argument written inside
&lt;<strong>&gt;</strong>, or the type parameter can remain unchanged.
In the first and second examples below, String and Integer replace the
type parameter. In the third example, the</p>
<p>type parameter remains unchanged. The fourth example doesn't use
generics at all, so it's similar to if the class had an Object
parameter. The compiler will warn about AbstractParam being a raw type,
but it will compile the</p>
<p>ObjectParam class. The fifth example has 2 type parameters (see
"multiple type parameters" below), choosing the</p>
<p>second parameter as the type parameter passed to the superclass.</p>
<p><strong>public class</strong> Email <strong>extends</strong>
AbstractParam {</p>
<p>// ...</p>
<p>}</p>
<p><strong>public class</strong> Age <strong>extends</strong>
AbstractParam {</p>
<p>// ...</p>
<p>}</p>
<p><strong>public class</strong> Height <strong>extends</strong>
AbstractParam {</p>
<p>// ...</p>
<p>}</p>
<p><strong>public class</strong> ObjectParam <strong>extends</strong>
AbstractParam {</p>
<p>// ...</p>
<p>}</p>
<p><strong>public class</strong> MultiParam <strong>extends</strong>
AbstractParam {</p>
<p>// ...</p>
<p>}</p>
<p>The following is the usage:</p>
<p>Email email = <strong>new</strong> Email();</p>
<p>email.setValue("test@example.com");</p>
<p>String retrievedEmail = email.getValue();</p>
<p>Age age = <strong>new</strong> Age();</p>
<p>age.setValue(25);</p>
<p>Integer retrievedAge = age.getValue();</p>
<p><strong>int</strong> autounboxedAge = age.getValue();</p>
<p>Height heightInInt = <strong>new</strong> Height&lt;&gt;();</p>
<p>heightInInt.setValue(125);</p>
<p>Height heightInFloat = <strong>new</strong> Height&lt;&gt;();</p>
<p>heightInFloat.setValue(120.3f);</p>
<p>MultiParam multiParam = <strong>new</strong> MultiParam&lt;&gt;();
multiParam.setValue(3.3);</p>
<p>Notice that in the Email class, the T getValue() method acts as if it
had a signature of String getValue(), and the</p>
<p><strong>void</strong> setValue(T) method acts as if it was declared
<strong>void</strong> setValue(String).</p>
<p>It is also possible to instantiate with anonymous inner class with an
empty curly braces ({}):</p>
<p>AbstractParam height = <strong>new</strong> AbstractParam(){};
height.setValue(198.6);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 266</p>
<p><span id="Note_that_using_the_diamond_with"
class="anchor"></span>Note that <a
href="http://stackoverflow.com/questions/22200647/why-cant-java-7-diamond-operator-be-used-with-anonymous-classes">using
the diamond with anonymous inner classes is not allowed.</a></p>
<p>Multiple type parameters</p>
<p>Java provides the ability to use more than one type parameter in a
generic class or interface. Multiple type</p>
<p>parameters can be used in a class or interface by placing a
<strong>comma-separated list</strong> of types between the angle</p>
<p>brackets. Example:</p>
<p><strong>public class</strong> MultiGenericParam {</p>
<p><strong>private</strong> T firstParam;</p>
<p><strong>private</strong> S secondParam;</p>
<p><strong>public</strong> MultiGenericParam(T firstParam, S
secondParam) {</p>
<p><strong>this</strong>.firstParam = firstParam;</p>
<p><strong>this</strong>.secondParam = secondParam;</p>
<p>}</p>
<p><strong>public</strong> T getFirstParam() {</p>
<p><strong>return</strong> firstParam;</p>
<p>}</p>
<p><strong>public void</strong> setFirstParam(T firstParam) {</p>
<p><strong>this</strong>.firstParam = firstParam;</p>
<p>}</p>
<p><strong>public</strong> S getSecondParam() {</p>
<p><strong>return</strong> secondParam;</p>
<p>}</p>
<p><strong>public void</strong> setSecondParam(S secondParam) {</p>
<p><strong>this</strong>.secondParam = secondParam;</p>
<p>}</p>
<p>}</p>
<p>The usage can be done as below:</p>
<p>MultiGenericParam aParam = <strong>new</strong>
MultiGenericParam("value1", "value2");</p>
<p>MultiGenericParam dayOfWeekDegrees = <strong>new</strong>
MultiGenericParam(1, 2.6);</p>
<p>Section 47.2: Deciding between `T`, `? super T`, and `? extends</p>
<p>T`</p>
<p>The syntax for Java generics bounded wildcards, representing the
unknown type by ? is:</p>
<p>? <strong>extends</strong> T represents an upper bounded wildcard.
The unknown type represents a type that must be a subtype of T, or type
T itself.</p>
<p>? <strong>super</strong> T represents a lower bounded wildcard. The
unknown type represents a type that must be a</p>
<p>supertype of T, or type T itself.</p>
<p>As a rule of thumb, you should use</p>
<p>? <strong>extends</strong> T if you only need "read" access
("input")</p>
<p>? <strong>super</strong> T if you need "write" access ("output")</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 267</p>
<p>T if you need both ("modify")</p>
<p>Using <strong>extends</strong> or <strong>super</strong> is usually
<em>better</em> because it makes your code more flexible (as in:
allowing the use of</p>
<p>subtypes and supertypes), as you will see below.</p>
<p><strong>class</strong> Shoe {}</p>
<p><strong>class</strong> IPhone {}</p>
<p>interface <strong>Fruit {}</strong></p>
<p><strong>class</strong> Apple <strong>implements</strong> Fruit {}</p>
<p><strong>class</strong> Banana <strong>implements</strong> Fruit
{}</p>
<p><strong>class</strong> GrannySmith <strong>extends</strong> Apple
{}</p>
<p><strong>public class</strong> FruitHelper {</p>
<p><strong>public void</strong> eatAll(Collectionextends Fruit&gt;
fruits) {}</p>
<p><strong>public void</strong> addApple(Collectionsuper Apple&gt;
apples) {}</p>
<p>}</p>
<p>The compiler will now be able to detect certain bad usage:</p>
<p><strong>public class</strong> GenericsTest {</p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>FruitHelper fruitHelper = <strong>new</strong> FruitHelper() ;</p>
<p>List fruits = <strong>new</strong> ArrayList();</p>
<p><em>fruits.add(<strong>new</strong> Apple());</em> // Allowed, as
Apple is a Fruit</p>
<p><em>fruits.add(<strong>new</strong> Banana());</em> // Allowed, as
Banana is a Fruit</p>
<p><em>fruitHelper.addApple(fruits);</em> // Allowed, as "Fruit super
Apple"</p>
<p>fruitHelper.eatAll(fruits); <em>// Allowed</em></p>
<p>Collection bananas = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>bananas.add(<strong>new</strong> Banana()); <em>// Allowed</em></p>
<p>//fruitHelper.addApple(bananas); // Compile error: may only contain
Bananas!</p>
<p><em>fruitHelper.eatAll(bananas);</em> // Allowed, as all Bananas are
Fruits</p>
<p>Collection apples = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>fruitHelper.addApple(apples); <em>// Allowed</em></p>
<p><em>apples.add(<strong>new</strong> GrannySmith());</em> // Allowed,
as this is an Apple</p>
<p><em>fruitHelper.eatAll(apples);</em> // Allowed, as all Apples are
Fruits.</p>
<p>Collection grannySmithApples = <strong>new</strong>
ArrayList&lt;&gt;();</p>
<p>fruitHelper.addApple(grannySmithApples); <em>//Compile error: Not
allowed.</em></p>
<p>// GrannySmith is not a supertype of Apple</p>
<p><em>apples.add(<strong>new</strong> GrannySmith());</em> //Still
allowed, GrannySmith is an Apple</p>
<p><em>fruitHelper.eatAll(grannySmithApples);</em>//Still allowed,
GrannySmith is a Fruit</p>
<p>Collection objects = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><em>fruitHelper.addApple(objects);</em> // Allowed, as Object super
Apple</p>
<p>objects.add(<strong>new</strong> Shoe()); <em>// Not a fruit</em></p>
<p>objects.add(<strong>new</strong> IPhone()); <em>// Not a
fruit</em></p>
<p>//fruitHelper.eatAll(objects); // Compile error: may contain a Shoe,
too!</p>
<p>}</p>
<p>Choosing the right T, ? <strong>super</strong> T or ?
<strong>extends</strong> T is <em>necessary</em> to allow the use with
subtypes. The compiler can then</p>
<p>ensure type safety; you should not need to cast (which is not type
safe, and may cause programming errors) if you use them properly.</p>
<p>If it is not easy to understand, please remember
<strong>PECS</strong> rule:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 268</p>
<p><span id="Producer_uses__Extends__and_Cons"
class="anchor"></span><strong>P</strong>roducer uses
"<strong>E</strong>xtends" and <strong>C</strong>onsumer uses
"<strong>S</strong>uper".</p>
<p>(Producer has only write access, and Consumer has only read
access)</p>
<p>Section 47.3: The Diamond</p>
<p>Version ≥ Java SE 7</p>
<p><a
href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/type-inference-generic-instance-creation.html">Java
7 introduced the <em>Diamond</em>1 to remove some boiler-plate around
generic class instantiation. With Java 7+ you</a> can write:</p>
<p>List list = <strong>new</strong> LinkedList&lt;&gt;();</p>
<p>Where you had to write in previous versions, this:</p>
<p>List list = <strong>new</strong> LinkedList();</p>
<p>One limitation is for Anonymous Classes, where you still must provide
the type parameter in the instantiation:</p>
<p>// This will compile:</p>
<p>Comparator caseInsensitiveComparator = <strong>new</strong>
Comparator() {</p>
<p>@Override</p>
<p><strong>public int</strong> compare(String s1, String s2) {</p>
<p><strong>return</strong> s1.compareToIgnoreCase(s2);</p>
<p>}</p>
<p>};</p>
<p>// But this will not:</p>
<p>Comparator caseInsensitiveComparator = <strong>new</strong>
Comparator&lt;&gt;() {</p>
<p>@Override</p>
<p><strong>public int</strong> compare(String s1, String s2) {</p>
<p><strong>return</strong> s1.compareToIgnoreCase(s2);</p>
<p>}</p>
<p>};</p>
<p>Version &gt; Java SE 8</p>
<p><a href="https://bugs.openjdk.java.net/browse/JDK-8062373">Although
using the diamond with Anonymous Inner Classes is not supported in Java
7 and 8, <strong>it will be included as</strong></a></p>
<p><a href="https://bugs.openjdk.java.net/browse/JDK-8062373">a new
feature in Java 9</a><strong>.</strong></p>
<p>Footnote:</p>
<p>1 - Some people call the &lt;<strong>&gt;</strong> usage the "diamond
<em>operator</em>". This is incorrect. The diamond does not behave as
an</p>
<p>operator, and is not described or listed anywhere in the JLS or the
(official) Java Tutorials as an operator. Indeed,
&lt;<strong>&gt;</strong> is not even a distinct Java token. Rather it
is a &lt; token followed by a &gt; token, and it is legal (though bad
style) to have</p>
<p>whitespace or comments between the two. The JLS and the Tutorials
consistently refer to &lt;<strong>&gt;</strong> as "the diamond", and
that is therefore the correct term for it.</p>
<p>Section 47.4: Declaring a Generic Method</p>
<p>Methods can also have <a
href="https://docs.oracle.com/javase/tutorial/java/generics/">generic
type parameters.</a></p>
<p>public class <strong>Example {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 269</p>
<p><span id="___The_type_parameter_T_is_scope" class="anchor"></span>//
The type parameter T is scoped to the method</p>
<p>// and is independent of type parameters of other methods.
<em><strong>public</strong> List makeList(T t1, T t2) {</em></p>
<p>List result = <strong>new</strong> ArrayList();</p>
<p>result.add(t1);</p>
<p>result.add(t2);</p>
<p><strong>return</strong> result;</p>
<p>}</p>
<p>public void <strong>usage() {</strong></p>
<p>List listString = makeList("Jeff", "Atwood");</p>
<p>List listInteger = makeList(1, 2);</p>
<p>}</p>
<p>}</p>
<p>Notice that we don't have to pass an actual type argument to a
generic method. The compiler infers the type argument for us, based on
the target type (e.g. the variable we assign the result to), or on the
types of the actual</p>
<p>arguments. It will generally infer the most specific type argument
that will make the call type-correct.</p>
<p>Sometimes, albeit rarely, it can be necessary to override this type
inference with explicit type arguments:</p>
<p><strong>void</strong> usage() {</p>
<p>consumeObjects(<strong>this</strong>.makeList("Jeff",
"Atwood").stream()); }</p>
<p><strong>void</strong> consumeObjects(Stream stream) { ... }</p>
<p>It's necessary in this example because the compiler can't "look
ahead" to see that Object is desired for T after</p>
<p>calling stream() and it would otherwise infer String based on the
makeList arguments. Note that the Java language doesn't support omitting
the class or object on which the method is called (<strong>this</strong>
in the above example)</p>
<p>when type arguments are explicitly provided.</p>
<p>Section 47.5: Requiring multiple upper bounds ("extends A &amp;</p>
<p>B")</p>
<p>You can require a generic type to extend multiple upper bounds.</p>
<p>Example: we want to sort a list of numbers but Number doesn't
implement Comparable.</p>
<p><strong>public</strong> extends Number &amp; Comparable&gt;
<strong>void</strong> sortNumbers( List n ) {</p>
<p>Collections.sort( n );</p>
<p>}</p>
<p>In this example T must extend Number <em>and</em> implement
Comparable which should fit all "normal" built-in number implementations
like Integer or BigDecimal but doesn't fit the more exotic ones like
Striped64.</p>
<p>Since multiple inheritance is not allowed, you can use at most one
class as a bound and it must be the first listed.</p>
<p>For example, <strong>&lt;T</strong> extends
Comparable<strong>&lt;T&gt;</strong> &amp; Number&gt; is not allowed
because Comparable is an interface, and not a</p>
<p>class.</p>
<p>Section 47.6: Obtain class that satisfies generic parameter at</p>
<p>runtime</p>
<p>Many unbound generic parameters, like those used in a static method,
cannot be recovered at runtime (see <em>Other</em></p>
<p><em>Threads</em> on <em>Erasure</em>). However there is a common
strategy employed for accessing the type satisfying a generic parameter
on a class at runtime. This allows for generic code that depends on
access to type <em>without</em> having to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 270</p>
<p><span id="thread_type_information_through"
class="anchor"></span>thread type information through every call.</p>
<p>Background</p>
<p>Generic parameterization on a class can be inspected by creating an
anonymous inner class. This class will capture</p>
<p>the type information. In general this mechanism is referred to as
<strong>super type tokens</strong><a
href="http://gafter.blogspot.com/2006/12/super-type-tokens.html">, which
are detailed in Neal</a></p>
<p><a
href="http://gafter.blogspot.com/2006/12/super-type-tokens.html">Gafter's
blog post.</a></p>
<p>Implementations</p>
<p>Three common implementations in Java are:</p>
<p><a
href="https://github.com/google/guava/wiki/ReflectionExplained">Guava's
TypeToken</a></p>
<p><a
href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html">Spring's
ParameterizedTypeReference</a></p>
<p><a
href="http://fasterxml.github.io/jackson-core/javadoc/2.0.0/com/fasterxml/jackson/core/type/TypeReference.html">Jackson's
TypeReference</a></p>
<p>Example usage</p>
<p><strong>public class</strong> DataService {</p>
<p><strong>private final</strong> DataDao dataDao = <strong>new</strong>
DataDao();</p>
<p><strong>private final</strong> Class type = (Class)
<strong>new</strong> TypeToken</p>
<p>(getClass()){}.getRawType();</p>
<p><strong>public</strong> List getAll() {</p>
<p><strong>return</strong> dataDao.getAllOfType(type);</p>
<p>}</p>
<p>}</p>
<p>// the subclass definitively binds the parameterization to User //
for all instances of this class, so that information can be // recovered
at runtime</p>
<p><strong>public class</strong> UserService <strong>extends</strong>
DataService {}</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>UserService service = <strong>new</strong> UserService();</p>
<p>List users = service.getAll();</p>
<p>}</p>
<p>}</p>
<p>Section 47.7: Benefits of Generic class and interface</p>
<p>Code that uses generics has many benefits over non-generic code.
Below are the main benefits</p>
<p>Stronger type checks at compile time</p>
<p>A Java compiler applies strong type checking to generic code and
issues errors if the code violates type safety. Fixing</p>
<p>compile-time errors is easier than fixing runtime errors, which can
be difficult to find.</p>
<p>Elimination of casts</p>
<p>The following code snippet without generics requires casting:</p>
<p>List list = <strong>new</strong> ArrayList();</p>
<p>list.add("hello");</p>
<p>String s = (String) list.get(0);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 271</p>
<p><span id="When_re_written_to_use_generics" class="anchor"></span>When
re-written to <em>use generics</em>, the code does not require
casting:</p>
<p>List list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>list.add("hello");</p>
<p>String s = list.get(0); <em>// no cast</em></p>
<p>Enabling programmers to implement generic algorithms</p>
<p>By using generics, programmers can implement generic algorithms that
work on collections of different types, can be customized, and are type
safe and easier to read.</p>
<p>Section 47.8: Instantiating a generic type</p>
<p>Due to type erasure the following will not work:</p>
<p><strong>public</strong> <strong>void</strong> genericMethod() {</p>
<p><em>T t = <strong>new</strong> T();</em> // Can not instantiate the
type T.</p>
<p>}</p>
<p>The type T is erased. Since, at runtime, the JVM does not know what T
originally was, it does not know which</p>
<p>constructor to call.</p>
<p>Workarounds</p>
<p>1. Passing T's class when calling genericMethod:</p>
<p><strong>public</strong> <strong>void</strong> genericMethod(Class
cls) {</p>
<p>try <strong>{</strong></p>
<p>T t = cls.newInstance();</p>
<p>} <strong>catch</strong> (InstantiationException |
IllegalAccessException e) {</p>
<p>System.err.println("Could not instantiate: " + cls.getName());</p>
<p>}</p>
<p>}</p>
<p>genericMethod(String.<strong>class</strong>);</p>
<p>Which throws exceptions, since there is no way to know if the passed
class has an accessible default constructor.</p>
<p>Version ≥ Java SE 8</p>
<p>2. Passing a reference to T's constructor:</p>
<p><strong>public</strong> <strong>void</strong> genericMethod(Supplier
cons) {</p>
<p>T t = cons.get();</p>
<p>}</p>
<p>genericMethod(String::<strong>new</strong>);</p>
<p>Section 47.9: Creating a Bounded Generic Class</p>
<p>You can restrict the valid types used in a <strong>generic
class</strong> by bounding that type in the class definition. Given
the</p>
<p>following simple type hierarchy:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 272</p>
<p>public abstract class <strong>Animal {</strong></p>
<p><strong>public abstract</strong> String getSound();</p>
<p>}</p>
<p>public class <strong>Cat</strong> extends <strong>Animal
{</strong></p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "Meow";</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Dog</strong> extends <strong>Animal
{</strong></p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "Woof";</p>
<p>}</p>
<p>}</p>
<p>Without <strong>bounded generics</strong>, we cannot make a container
class that is both generic and knows that each element is</p>
<p>an animal:</p>
<p><strong>public class</strong> AnimalContainer {</p>
<p><strong>private</strong> Collection col;</p>
<p><strong>public</strong> AnimalContainer() {</p>
<p>col = <strong>new</strong> ArrayList();</p>
<p>}</p>
<p>public void <strong>add(T t) {</strong></p>
<p>col.add(t);</p>
<p>}</p>
<p><strong>public void</strong> printAllSounds() {</p>
<p><strong>for</strong> (T t : col) {</p>
<p>// Illegal, type T doesn't have makeSound()</p>
<p>// it is used as an java.lang.Object here</p>
<p>System.out.println(t.makeSound());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>With generic bound in class definition, this is now possible.</p>
<p><strong>public class</strong> BoundedAnimalContainerextends
Animal&gt; { <em>// Note bound here.</em></p>
<p><strong>private</strong> Collection col;</p>
<p><strong>public</strong> BoundedAnimalContainer() {</p>
<p>col = <strong>new</strong> ArrayList();</p>
<p>}</p>
<p>public void <strong>add(T t) {</strong></p>
<p>col.add(t);</p>
<p>}</p>
<p><strong>public void</strong> printAllSounds() {</p>
<p><strong>for</strong> (T t : col) {</p>
<p>// Now works because T is extending Animal</p>
<p>System.out.println(t.makeSound());</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 273</p>
<p><span id="_13" class="anchor"></span>}</p>
<p>This also restricts the valid instantiations of the generic type:</p>
<p>// Legal</p>
<p>AnimalContainer a = <strong>new</strong> AnimalContainer();</p>
<p>// Legal</p>
<p>AnimalContainer a = <strong>new</strong> AnimalContainer();</p>
<p>// Legal because Cat extends Animal</p>
<p>BoundedAnimalContainer b = <strong>new</strong>
BoundedAnimalContainer();</p>
<p>// Illegal because String doesn't extends Animal</p>
<p>BoundedAnimalContainer b = <strong>new</strong>
BoundedAnimalContainer();</p>
<p>Section 47.10: Referring to the declared generic type within</p>
<p>its own declaration</p>
<p>How do you go about using an instance of a (possibly further)
inherited generic type within a method declaration in</p>
<p>the generic type itself being declared? This is one of the problems
you will face when you dig a bit deeper into</p>
<p>generics, but still a fairly common one.</p>
<p>Assume we have a DataSeries type (interface here), which defines a
generic data series containing values of type T. It is cumbersome to
work with this type directly when we want to perform a lot of operations
with e.g.</p>
<p>double values, so we define DoubleSeries <strong>extends</strong>
DataSeries. Now assume, the original DataSeries</p>
<p>type has a method add(values) which adds another series of the same
length and returns a new one. How do we enforce the type of values and
the type of the return to be DoubleSeries rather than DataSeries in
our</p>
<p>derived class?</p>
<p>The problem can be solved by adding a generic type parameter
referring back to and extending the type being</p>
<p>declared (applied to an interface here, but the same stands for
classes):</p>
<p><strong>public interface</strong> DataSeriesextends DataSeries&gt;
{</p>
<p>DS add(DS values);</p>
<p>List data();</p>
<p>}</p>
<p>Here T represents the data type the series holds, e.g. Double and DS
the series itself. An inherited type (or types) can now be easily
implemented by substituting the above mentioned parameter by a
corresponding derived type, thus,</p>
<p>yielding a concrete Double-based definition of the form:</p>
<p><strong>public interface</strong> DoubleSeries
<strong>extends</strong> DataSeries {</p>
<p><strong>static</strong> DoubleSeries instance(Collection data) {</p>
<p><strong>return new</strong> DoubleSeriesImpl(data);</p>
<p>}</p>
<p>}</p>
<p>At this moment even an IDE will implement the above interface with
correct types in place, which, after a bit of content filling may look
like this:</p>
<p><strong>class</strong> DoubleSeriesImpl <strong>implements</strong>
DoubleSeries {</p>
<p>private final <strong>List data;</strong></p>
<p>DoubleSeriesImpl(Collection data) {</p>
<p><strong>this</strong>.data = <strong>new</strong>
ArrayList&lt;&gt;(data);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 274</p>
<p><span id="_14" class="anchor"></span>}</p>
<p>@Override</p>
<p><strong>public</strong> DoubleSeries add(DoubleSeries values) {</p>
<p>List incoming = values != <strong>null</strong> ? values.data() :
<strong>null</strong>;</p>
<p><strong>if</strong> (incoming == <strong>null</strong> ||
incoming.size() != data.size()) {</p>
<p><strong>throw new</strong> IllegalArgumentException("bad
series");</p>
<p>}</p>
<p>List newdata = <strong>new</strong>
ArrayList&lt;&gt;(data.size());</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; data.size();
i++) {</p>
<p>newdata.add(<strong>this</strong>.data.get(i) + incoming.get(i));
<em>// beware autoboxing</em></p>
<p>}</p>
<p><strong>return</strong> DoubleSeries.instance(newdata);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> List data() {</p>
<p><strong>return</strong> Collections.unmodifiableList(data);</p>
<p>}</p>
<p>}</p>
<p>As you can see the add method is declared as DoubleSeries
add(DoubleSeries values) and the compiler is happy.</p>
<p>The pattern can be further nested if required.</p>
<p>Section 47.11: Binding generic parameter to more than 1 type</p>
<p>Generic parameters can also be bound to more than one type using the
T <strong>extends</strong> Type1 &amp; Type2 &amp; ... syntax.</p>
<p>Let's say you want to create a class whose Generic type should
implement both Flushable and Closeable, you can</p>
<p>write</p>
<p><strong>class</strong> ExampleClassextends Flushable &amp;
Closeable&gt; { }</p>
<p>Now, the ExampleClass only accepts as generic parameters, types which
implement both Flushable <strong>and</strong> Closeable .</p>
<p><em>ExampleClass arg1;</em> // Works because BufferedWriter
implements both Flushable and Closeable</p>
<p><em>ExampleClass arg4;</em> // Does NOT work because Console only
implements Flushable <em>ExampleClass arg5;</em> // Does NOT work
because ZipFile only implements Closeable</p>
<p><em>ExampleClass arg2;</em> // Does NOT work because Closeable bound
is not satisfied. <em>ExampleClass arg3;</em> // Does NOT work because
Flushable bound is not satisfied.</p>
<p>The class methods can choose to infer generic type arguments as
either Closeable or Flushable.</p>
<p><strong>class</strong> ExampleClassextends Flushable &amp;
Closeable&gt; {</p>
<p>/* Assign it to a valid type as you want. */</p>
<p><strong>public void</strong> test (T param) {</p>
<p>Flushable arg1 = param; <em>// Works</em></p>
<p>Closeable arg2 = param; <em>// Works too.</em></p>
<p>}</p>
<p>/* You can even invoke the methods of any valid type directly. */</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 275</p>
<p><span id="public_void_test2__T_param"
class="anchor"></span><strong>public void</strong> test2 (T param) {</p>
<p><em>param.flush();</em> // Method of Flushable called on T and works
fine.</p>
<p><em>param.close();</em> // Method of Closeable called on T and works
fine too.</p>
<p>}</p>
<p>}</p>
<p>Note:</p>
<p>You cannot bind the generic parameter to either of the type using
<em>OR</em> (|) clause. Only the <em>AND</em> (&amp;) clause is
supported. Generic type can extends only one class and many interfaces.
Class must be placed at the beginning of</p>
<p>the list.</p>
<p>Section 47.12: Using Generics to auto-cast</p>
<p>With generics, it's possible to return whatever the caller
expects:</p>
<p><strong>private</strong> Map data;</p>
<p><strong>public</strong> T get(String key) {</p>
<p><strong>return</strong> (T) data.get(key);</p>
<p>}</p>
<p>The method will compile with a warning. The code is actually more
safe than it looks because the Java runtime will</p>
<p>do a cast when you use it:</p>
<p>Bar bar = foo.get("bar");</p>
<p>It's less safe when you use generic types:</p>
<p>List bars = foo.get("bars");</p>
<p>Here, the cast will work when the returned type is any kind of List
(i.e. returning List would not trigger a ClassCastException ; you'd
eventually get it when taking elements out of the list).</p>
<p>To work around this problem, you can create an API which uses typed
keys:</p>
<p><strong>public final static</strong> Key&gt; BARS =
<strong>new</strong> Key&lt;&gt;("BARS");</p>
<p>along with this put() method:</p>
<p><strong>public</strong> T put(Key key, T value);</p>
<p>With this approach, you can't put the wrong type into the map, so the
result will always be correct (unless you</p>
<p>accidentally create two keys with the same name but different
types).</p>
<p>Related:</p>
<p><a
href="https://blog.pdark.de/2010/05/28/type-safe-object-map/">Type-safe
Map</a></p>
<p>Section 47.13: Use of instanceof with Generics</p>
<p>Using generics to define the type in instanceof</p>
<p>Consider the following generic class Example declared with the formal
parameter <strong>&lt;T&gt;</strong>:</p>
<p><strong>class</strong> Example {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 276</p>
<p><strong>public boolean</strong> isTypeAString(String s) {</p>
<p><em><strong>return</strong> s <strong>instanceof</strong> T;</em> //
Compilation error, cannot use T as class type here</p>
<p>}</p>
<p>}</p>
<p>This will always give a Compilation error because as soon as the
compiler compiles the <em>Java source</em> into <em>Java</em></p>
<p><em>bytecode</em> it applies a process known as <em>type
erasure</em>, which converts all generic code into non-generic code,
making</p>
<p>impossible to distinguish among T types at runtime. The type used
with <strong>instanceof</strong> <a
href="https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html">has
to be <em>reifiable</em></a>, which</p>
<p>means that all information about the type has to be available at
runtime, and this is usually not the case for generic types.</p>
<p>The following class represents what two different classes of Example,
Example and Example, look like after generics has stripped off by
<em>type erasure</em>:</p>
<p><em><strong>class</strong> Example {</em> // formal parameter is
gone</p>
<p><strong>public boolean</strong> isTypeAString(String s) {</p>
<p><em><strong>return</strong> s <strong>instanceof</strong>
Object;</em> // Both &lt;String&gt; and &lt;Number&gt; are now
Object</p>
<p>}</p>
<p>}</p>
<p>Since types are gone, it's not possible for the JVM to know which
type is T.</p>
<p>Exception to the previous rule</p>
<p>You can always use <em>unbounded wildcard</em> (?) for specifying a
type in the <strong>instanceof</strong> as follows:</p>
<p><strong>public boolean</strong> isAList(Object obj) {</p>
<p>return <strong>obj</strong> instanceof <strong>List;</strong></p>
<p>}</p>
<p>This can be useful to evaluate whether an instance obj is a List or
not:</p>
<p>System.out.println(isAList("foo")); <em>// prints false</em>
System.out.println(isAList(<strong>new</strong> ArrayList()); <em>//
prints true</em> System.out.println(isAList(<strong>new</strong>
ArrayList()); <em>// prints true</em></p>
<p>In fact, unbounded wildcard is considered a reifiable type.</p>
<p>Using a generic instance with instanceof</p>
<p>The other side of the coin is that using an instance t of T with
<strong>instanceof</strong> is legal, as shown in the following
example:</p>
<p><strong>class</strong> Example {</p>
<p><strong>public boolean</strong> isTypeAString(T t) {</p>
<p><em><strong>return</strong> t <strong>instanceof</strong>
String;</em> // No compilation error this time</p>
<p>}</p>
<p>}</p>
<p>because after the type erasure the class will look like the
following:</p>
<p><em><strong>class</strong> Example {</em> // formal parameter is
gone</p>
<p><strong>public boolean</strong> isTypeAString(Object t) {</p>
<p><em><strong>return</strong> t <strong>instanceof</strong>
String;</em> // No compilation error this time</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 277</p>
<p><span id="Since__even_if_the_type_erasure"
class="anchor"></span>Since, even if the type erasure happen anyway, now
the JVM can distinguish among different types in memory, even if they
use the same reference type (Object), as the following snippet
shows:</p>
<p><em>Object obj1 = <strong>new</strong> String("foo");</em> //
reference type Object, object type String <em>Object obj2 =
<strong>new</strong> Integer(11);</em> // reference type Object, object
type Integer <em>System.out.println(obj1 <strong>instanceof</strong>
String);</em> // true</p>
<p><em>System.out.println(obj2 <strong>instanceof</strong> String);</em>
// false, it's an Integer, not a String</p>
<p>Section 47.14: Dierent ways for implementing a Generic</p>
<p>Interface (or extending a Generic Class)</p>
<p>Suppose the following generic interface has been declared:</p>
<p><strong>public interface</strong> MyGenericInterface {</p>
<p>public void <strong>foo(T t);</strong></p>
<p>}</p>
<p>Below are listed the possible ways to implement it.</p>
<p>Non-generic class implementation with a specific type</p>
<p>Choose a specific type to replace the formal type parameter
<strong>&lt;T&gt;</strong> of MyGenericClass and implement it, as
the</p>
<p>following example does:</p>
<p><strong>public class</strong> NonGenericClass
<strong>implements</strong> MyGenericInterface {</p>
<p><em><strong>public void</strong> foo(String t) { }</em> // type T has
been replaced by String</p>
<p>}</p>
<p>This class only deals with String, and this means that using
MyGenericInterface with different parameters (e.g. Integer , Object
etc.) won't compile, as the following snippet shows:</p>
<p>NonGenericClass myClass = <strong>new</strong> NonGenericClass();</p>
<p>myClass.foo("foo_string"); <em>// OK, legal</em></p>
<p><em>myClass.foo(11);</em> // NOT OK, does not compile</p>
<p><em>myClass.foo(<strong>new</strong> Object());</em> // NOT OK, does
not compile</p>
<p>Generic class implementation</p>
<p>Declare another generic interface with the formal type parameter
<strong>&lt;T&gt;</strong> which implements MyGenericInterface, as
follows:</p>
<p><strong>public class</strong> MyGenericSubclass
<strong>implements</strong> MyGenericInterface {</p>
<p><em><strong>public void</strong> foo(T t) { }</em> // type T is still
the same</p>
<p>// other methods...</p>
<p>}</p>
<p>Note that a different formal type parameter may have been used, as
follows:</p>
<p><em><strong>public class</strong> MyGenericSubclass
<strong>implements</strong> MyGenericInterface {</em> // equivalent to
the previous declaration</p>
<p><strong>public void</strong> foo(U t) { }</p>
<p>// other methods...</p>
<p>}</p>
<p>Raw type class implementation</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 278</p>
<p>Declare a non-generic class which implements MyGenericInteface as a
<em>raw type</em> (not using generic at all), as follows:</p>
<p><strong>public class</strong> MyGenericSubclass
<strong>implements</strong> MyGenericInterface {</p>
<p><em><strong>public void</strong> foo(Object t) { }</em> // type T has
been replaced by Object // other possible methods</p>
<p>}</p>
<p>This way is <strong>not</strong> recommended, since it is not 100%
safe at runtime because it mixes up <em>raw type</em> (of the subclass)
with <em>generics</em> (of the interface) and it is also confusing.
Modern Java compilers will raise a warning with this kind of</p>
<p>implementation, nevertheless the code - for compatibility reasons
with older JVM (1.4 or earlier) - will compile.</p>
<p>All the ways listed above are also allowed when using a generic class
as a supertype instead of a generic interface.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 279</p>
<p><span id="Chapter_48__Classes_and_Objects_1"
class="anchor"></span>Chapter 48: Classes and Objects</p>
<p>Objects have states and behaviors. Example: A dog has states - color,
name, breed as well as behaviors – wagging</p>
<p>the tail, barking, eating. An object is an instance of a class.</p>
<p>Class − A class can be defined as a template/blueprint that describes
the behavior/state that the object of its type support.</p>
<p>Section 48.1: Overloading Methods</p>
<p>Sometimes the same functionality has to be written for different
kinds of inputs. At that time, one can use the same method name with a
different set of parameters. Each different set of parameters is known
as a method signature.</p>
<p>As seen per the example, a single method can have multiple
signatures.</p>
<p>public class <strong>Displayer {</strong></p>
<p><strong>public void</strong> displayName(String firstName) {</p>
<p>System.out.println("Name is: " + firstName);</p>
<p>}</p>
<p><strong>public void</strong> displayName(String firstName, String
lastName) {</p>
<p>System.out.println("Name is: " + firstName + " " + lastName);</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Displayer displayer = <strong>new</strong> Displayer();</p>
<p>displayer.displayName("Ram"); <em>//prints "Name is: Ram"</em></p>
<p>displayer.displayName("Jon", "Skeet"); <em>//prints "Name is: Jon
Skeet"</em></p>
<p>}</p>
<p>}</p>
<p>The advantage is that the same functionality is called with two
different numbers of inputs. While invoking the method according to the
input we are passing, (In this case either one string value or two
string values) the</p>
<p>corresponding method is executed.</p>
<p>Methods can be overloaded:</p>
<p>1. Based on the <strong>number of parameters</strong> passed.</p>
<p>Example: method(String s) and method(String s1, String s2).</p>
<p><strong>2. Based on the</strong> order of
parameters<strong>.</strong></p>
<p>Example: method(<strong>int</strong> i, <strong>float</strong> f) and
method(<strong>float</strong> f, <strong>int</strong> i)).</p>
<p><strong>Note:</strong> Methods cannot be overloaded by changing just
the return type (<strong>int</strong> method() is considered the same as
String</p>
<p>method() and will throw a RuntimeException if attempted). If you
change the return type you must also change the</p>
<p>parameters in order to overload.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 280</p>
<p><span id="Section_48_2__Explaining_what_is"
class="anchor"></span>Section 48.2: Explaining what is method
overloading and</p>
<p>overriding</p>
<p>Method Overriding and Overloading are two forms of polymorphism
supported by Java.</p>
<p>Method Overloading</p>
<p>Method overloading (also known as static Polymorphism) is a way you
can have two (or more) methods (functions)</p>
<p>with same name in a single class. Yes its as simple as that.</p>
<p>public class <strong>Shape{</strong></p>
<p>//It could be a circle or rectangle or square</p>
<p><strong>private</strong> String type;</p>
<p>//To calculate area of rectangle</p>
<p><strong>public</strong> Double area(Long length, Long breadth){</p>
<p><strong>return</strong> (Double) length * breadth;</p>
<p>}</p>
<p>//To calculate area of a circle</p>
<p><strong>public</strong> Double area(Long radius){</p>
<p><strong>return</strong> (Double) 3.14 * r * r;</p>
<p>}</p>
<p>}</p>
<p>This way user can call the same method for area depending on the type
of shape it has.</p>
<p>But the real question now is, how will java compiler will distinguish
which method body is to be executed?</p>
<p>Well Java have made it clear that even though the <strong>method
names</strong> (area() in our case) <strong>can be same but
the</strong></p>
<p>arguments method is taking should be different.</p>
<p>Overloaded methods must have different arguments list (quantity and
types).</p>
<p>That being said we cannot add another method to calculate area of a
square like this : <strong>public</strong> Double area(Long</p>
<p>side) because in this case, it will conflict with area method of
circle and will cause <strong>ambiguity</strong> for java compiler.</p>
<p>Thank god, there are some relaxations while writing overloaded
methods like</p>
<p>May have different return types.</p>
<p>May have different access modifiers.</p>
<p>May throw different exceptions.</p>
<p>Why is this called static polymorphism?</p>
<p>Well that's because which overloaded methods is to be invoked is
decided at compile time, based on the actual number of arguments and the
compile-time types of the arguments.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 281</p>
<p>One of common reasons of using method overloading is the simplicity
of code it provides. For example remember String.valueOf() which takes
almost any type of argument? What is written behind the</p>
<p>scene is probably something like this:</p>
<p><strong>static</strong> String valueOf(<strong>boolean</strong>
b)</p>
<p><strong>static</strong> String valueOf(<strong>char</strong> c)</p>
<p><strong>static</strong> String valueOf(<strong>char</strong>[]
data)</p>
<p><strong>static</strong> String valueOf(<strong>char</strong>[] data,
<strong>int</strong> offset, <strong>int</strong> count)
<strong>static</strong> String valueOf(<strong>double</strong> d)</p>
<p><strong>static</strong> String valueOf(<strong>float</strong> f)</p>
<p><strong>static</strong> String valueOf(<strong>int</strong> i)</p>
<p><strong>static</strong> String valueOf(<strong>long</strong> l)</p>
<p><strong>static</strong> String valueOf(Object obj)</p>
<p>Method Overriding</p>
<p>Well, method overriding (yes you guess it right, it is also known as
dynamic polymorphism) is somewhat more interesting and complex
topic.</p>
<p>In method overriding we overwrite the method body provided by the
parent class. Got it? No? Let's go through an</p>
<p>example.</p>
<p>public abstract class <strong>Shape{</strong></p>
<p>public abstract <strong>Double area(){</strong></p>
<p>return <strong>0.0;</strong></p>
<p>}</p>
<p>}</p>
<p>So we have a class called Shape and it has method called area which
will probably return the area of the shape.</p>
<p>Let's say now we have two classes called Circle and Rectangle.</p>
<p>public class <strong>Circle</strong> extends <strong>Shape
{</strong></p>
<p><strong>private</strong> Double radius = 5.0;</p>
<p>// See this annotation @Override, it is telling that this method is
from parent // class Shape and is overridden here</p>
<p>@Override</p>
<p><strong>public</strong> Double area(){</p>
<p><strong>return</strong> 3.14 * radius * radius;</p>
<p>}</p>
<p>}</p>
<p>Similarly rectangle class:</p>
<p>public class <strong>Rectangle</strong> extends <strong>Shape
{</strong></p>
<p><strong>private</strong> Double length = 5.0;</p>
<p><strong>private</strong> Double breadth= 10.0;</p>
<p>// See this annotation @Override, it is telling that this method is
from parent // class Shape and is overridden here</p>
<p>@Override</p>
<p><strong>public</strong> Double area(){</p>
<p><strong>return</strong> length * breadth;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 282</p>
<p><span id="_15" class="anchor"></span>}</p>
<p>So, now both of your children classes have updated method body
provided by the parent (Shape) class. Now question is how to see the
result? Well lets do it the old psvm way.</p>
<p>public class <strong>AreaFinder{</strong></p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>//This will create an object of circle class</p>
<p>Shape circle = <strong>new</strong> Circle();</p>
<p>//This will create an object of Rectangle class</p>
<p>Shape rectangle = <strong>new</strong> Rectangle();</p>
<p>// Drumbeats ......</p>
<p>//This should print 78.5</p>
<p>System.out.println("Shape of circle : "+circle.area());</p>
<p>//This should print 50.0</p>
<p>System.out.println("Shape of rectangle: "+rectangle.area());</p>
<p>}</p>
<p>}</p>
<p>Wow! isn't it great? Two objects of same type calling same methods
and returning different values. My friend, that's</p>
<p>the power of dynamic polymorphism.</p>
<p>Here's a chart to better compare the differences between these
two:</p>
<p>Method Overloading Method Overriding</p>
<p>Method overloading is used to increase the readability of Method
overriding is used to provide the specific implementation of the method
that is already the program. provided by its super class.</p>
<p>Method overloading is performed within class. Method overriding
occurs in two classes that have IS-A (inheritance) relationship.</p>
<p>In case of method overloading, parameter must be In case of method
overriding, parameter must be</p>
<p>different. same.</p>
<p>Method overloading is the example of compile time Method overriding
is the example of run time polymorphism. polymorphism.</p>
<p>In java, method overloading can't be performed by</p>
<p>changing return type of the method only. Return type can Return type
must be same or covariant in method</p>
<p>be same or different in method overloading. But you must overriding.
have to change the parameter.</p>
<p>Section 48.3: Constructors</p>
<p>Constructors are special methods named after the class and without a
return type, and are used to construct objects. Constructors, like
methods, can take input parameters. Constructors are used to initialize
objects. Abstract</p>
<p>classes can have constructors also.</p>
<p>public class <strong>Hello{</strong></p>
<p>// constructor</p>
<p><strong>public</strong> Hello(String wordToPrint){</p>
<p>printHello(wordToPrint);</p>
<p>}</p>
<p><strong>public void</strong> printHello(String word){</p>
<p>System.out.println(word);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 283</p>
<p><span id="_16" class="anchor"></span>}</p>
<p>}</p>
<p>// instantiates the object during creating and prints out the content
// of wordToPrint</p>
<p>It is important to understand that constructors are different from
methods in several ways:</p>
<p>1. Constructors can only take the modifiers <strong>public</strong>,
<strong>private</strong>, and <strong>protected</strong>, and cannot be
declared <strong>abstract</strong>,</p>
<p>final <strong>,</strong> static<strong>, or</strong>
synchronized<strong>.</strong></p>
<p>2. Constructors do not have a return type.</p>
<p>3. Constructors MUST be named the same as the class name. In the
Hello example, the Hello object's</p>
<p>constructor name is the same as the class name.</p>
<p>4. The <strong>this</strong> keyword has an additional usage inside
constructors. <strong>this</strong>.method(...) calls a method on
the</p>
<p>current instance, while <strong>this</strong>(...) refers to another
constructor in the current class with different signatures.</p>
<p>Constructors also can be called through inheritance using the keyword
<strong>super</strong>.</p>
<p><strong>public class</strong> SuperManClass{</p>
<p><strong>public</strong> SuperManClass(){</p>
<p>// some implementation</p>
<p>}</p>
<p>// ... methods</p>
<p>}</p>
<p><strong>public class</strong> BatmanClass <strong>extends</strong>
SupermanClass{</p>
<p><strong>public</strong> BatmanClass(){</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p>//... methods...</p>
<p>}</p>
<p><a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8">See
Java Language Specification #8.8</a> <a
href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.9">and
#15.9</a></p>
<p>Section 48.4: Initializing static final fields using a static</p>
<p>initializer</p>
<p>To initialize a <strong>static final</strong> fields that require
using more than a single expression, a <strong>static</strong>
initializer can be used to assign the value. The following example
initializes a unmodifiable set of Strings:</p>
<p>public class <strong>MyClass {</strong></p>
<p>public static final <strong>Set WORDS;</strong></p>
<p>static <strong>{</strong></p>
<p>Set set = <strong>new</strong> HashSet&lt;&gt;();</p>
<p>set.add("Hello");</p>
<p>set.add("World");</p>
<p>set.add("foo");</p>
<p>set.add("bar");</p>
<p>set.add("42");</p>
<p>WORDS = Collections.unmodifiableSet(set);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 284</p>
<p><span id="_17" class="anchor"></span>}</p>
<p>Section 48.5: Basic Object Construction and Use</p>
<p>Objects come in their own class, so a simple example would be a car
(detailed explanations below):</p>
<p>public class <strong>Car {</strong></p>
<p>//Variables describing the characteristics of an individual car,
varies per object</p>
<p><strong>private int</strong> milesPerGallon;</p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> String color;</p>
<p><strong>public int</strong> numGallonsInTank;</p>
<p><strong>public</strong> Car(){</p>
<p>milesPerGallon = 0;</p>
<p>name = "";</p>
<p>color = "";</p>
<p>numGallonsInTank = 0;</p>
<p>}</p>
<p>//this is where an individual object is created</p>
<p><strong>public</strong> Car(<strong>int</strong> mpg,
<strong>int</strong>, gallonsInTank, String carName, String carColor){
milesPerGallon = mpg;</p>
<p>name = carName;</p>
<p>color = carColor;</p>
<p>numGallonsInTank = gallonsInTank;</p>
<p>}</p>
<p>//methods to make the object more usable</p>
<p>//Cars need to drive</p>
<p><strong>public void</strong> drive(<strong>int</strong>
distanceInMiles){</p>
<p>//get miles left in car</p>
<p><strong>int</strong> miles = numGallonsInTank * milesPerGallon;</p>
<p>//check that car has enough gas to drive distanceInMiles
<em><strong>if</strong> (miles &lt;= distanceInMiles){</em></p>
<p>numGallonsInTank = numGallonsInTank -(distanceInMiles /
milesPerGallon)</p>
<p>System.out.println("Drove " + numGallonsInTank + " miles!");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Could not drive!");</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> paintCar(String newColor){</p>
<p>color = newColor;</p>
<p>}</p>
<p>//set new Miles Per Gallon</p>
<p><strong>public void</strong> setMPG(<strong>int</strong> newMPG){</p>
<p>milesPerGallon = newMPG;</p>
<p>}</p>
<p>//set new number of Gallon In Tank</p>
<p><strong>public void</strong> setGallonsInTank(<strong>int</strong>
numGallons){</p>
<p>numGallonsInTank = numGallons;</p>
<p>}</p>
<p><strong>public void</strong> nameCar(String newName){</p>
<p>name = newName;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 285</p>
<p>//Get the Car color</p>
<p><strong>public</strong> String getColor(){</p>
<p><strong>return</strong> color;</p>
<p>}</p>
<p>//Get the Car name</p>
<p><strong>public</strong> String getName(){</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p>//Get the number of Gallons</p>
<p><strong>public</strong> String getGallons(){</p>
<p><strong>return</strong> numGallonsInTank;</p>
<p>}</p>
<p>}</p>
<p>Objects are <strong>instances of</strong> their class. So, the way
you would <strong>create an object</strong> would be by calling the Car
class in</p>
<p><strong>one of two ways</strong> in your main class (main method in
Java or onCreate in Android).</p>
<p>Option 1</p>
<p>`Car newCar = <strong>new</strong> Car(30, 10, "Ferrari", "Red");</p>
<p>Option 1 is where you essentially tell the program everything about
the Car upon creation of the object. Changing any property of the car
would require calling one of the methods such as the repaintCar method.
Example:</p>
<p>newCar.repaintCar("Blue");</p>
<p><strong>Note:</strong> Make sure you pass the correct data type to
the method. In the example above, you may also pass a variable</p>
<p><strong>to the repaintCar method</strong> as long as the data type is
correct`<strong>.</strong></p>
<p>That was an example of changing properties of an object, receiving
properties of an object would require using a method from the Car class
that has a return value (meaning a method that is not
<strong>void</strong>). Example:</p>
<p>String myCarName = newCar.getName(); <em>//returns string
"Ferrari"</em></p>
<p>Option 1 is the <strong>best</strong> option when you have
<strong>all the object's data</strong> at the time of creation.</p>
<p>Option 2</p>
<p>`Car newCar = <strong>new</strong> Car();</p>
<p>Option 2 gets the same effect but required more work to create an
object correctly. I want to recall this Constructor in the Car
class:</p>
<p>public void <strong>Car(){</strong></p>
<p>milesPerGallon = 0;</p>
<p>name = "";</p>
<p>color = "";</p>
<p>numGallonsInTank = 0;</p>
<p>}</p>
<p>Notice that you do not have to actually pass any parameters into the
object to create it. This is very useful for when you do not have all
the aspects of the object but you need to use the parts that you do
have. This sets generic data</p>
<p>into each of the instance variables of the object so that, if you
call for a piece of data that does not exist, no errors</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 286</p>
<p><span id="are_thrown" class="anchor"></span>are thrown.</p>
<p><strong>Note:</strong> Do not forget that you have to set the parts
of the object later that you did not initialize it with. For
example,</p>
<p>Car myCar = <strong>new</strong> Car();</p>
<p>String color = Car.getColor(); <em>//returns empty string</em></p>
<p>This is a common mistake amongst objects that are not initialized
with all their data. Errors were avoided because</p>
<p>there is a Constructor that allows an empty Car object to be created
with <strong>stand-in variables</strong> (<strong>public</strong>
Car(){}), but</p>
<p>no part of the myCar was actually customized. <strong>Correct example
of creating Car Object:</strong></p>
<p>Car myCar = <strong>new</strong> Car();</p>
<p>myCar.nameCar("Ferrari");</p>
<p>myCar.paintCar("Purple");</p>
<p>myCar.setGallonsInTank(10);</p>
<p>myCar.setMPG(30);</p>
<p>And, as a reminder, get an object's properties by calling a method in
your main class. Example:</p>
<p>String myCarName = myCar.getName(); <em>//returns string
"Ferrari"</em></p>
<p>Section 48.6: Simplest Possible Class</p>
<p><strong>class</strong> TrivialClass {}</p>
<p>A class consists at a minimum of the <strong>class</strong> keyword,
a name, and a body, which might be empty.</p>
<p>You instantiate a class with the <strong>new</strong> operator.</p>
<p>TrivialClass tc = <strong>new</strong> TrivialClass();</p>
<p>Section 48.7: Object Member vs Static Member</p>
<p>With this class:</p>
<p><strong>class</strong> ObjectMemberVsStaticMember {</p>
<p><strong>static int</strong> staticCounter = 0;</p>
<p><strong>int</strong> memberCounter = 0;</p>
<p><strong>void</strong> increment() {</p>
<p>staticCounter ++;</p>
<p>memberCounter++;</p>
<p>}</p>
<p>}</p>
<p>the following code snippet:</p>
<p><strong>final</strong> ObjectMemberVsStaticMember o1 =
<strong>new</strong> ObjectMemberVsStaticMember();
<strong>final</strong> ObjectMemberVsStaticMember o2 =
<strong>new</strong> ObjectMemberVsStaticMember();</p>
<p>o1.increment();</p>
<p>o2.increment();</p>
<p>o2.increment();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 287</p>
<p>System.out.println("o1 static counter " + o1.staticCounter);
System.out.println("o1 member counter " + o1.memberCounter);
System.out.println();</p>
<p>System.out.println("o2 static counter " + o2.staticCounter);
System.out.println("o2 member counter " + o2.memberCounter);
System.out.println();</p>
<p>System.out.println("ObjectMemberVsStaticMember.staticCounter = " +
ObjectMemberVsStaticMember.staticCounter);</p>
<p>// the following line does not compile. You need an object // to
access its members</p>
<p>//System.out.println("ObjectMemberVsStaticMember.staticCounter = " +
ObjectMemberVsStaticMember.memberCounter);</p>
<p>produces this output:</p>
<p>o1 static counter 3</p>
<p>o1 member counter 1</p>
<p>o2 static counter 3</p>
<p>o2 member counter 2</p>
<p>ObjectMemberVsStaticMember.staticCounter = 3</p>
<p><strong>Note:</strong> You should not call <strong>static</strong>
members on objects, but on classes. While it does not make a difference
for the</p>
<p>JVM, human readers will appreciate it.</p>
<p><strong>static</strong> members are part of the class and exists only
once per class. Non-<strong>static</strong> members exist on instances,
there</p>
<p>is an independent copy for each instance. This also means that you
need access to an object of that class to access its members.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 288</p>
<p><span id="Chapter_49__Local_Inner_Class_1"
class="anchor"></span>Chapter 49: Local Inner Class</p>
<p>A class i.e. created inside a method is called local inner class in
java. If you want to invoke the methods of local</p>
<p>inner class, you must instantiate this class inside the method.</p>
<p>Section 49.1: Local Inner Class</p>
<p><strong>public class</strong> localInner1{</p>
<p><em><strong>private int</strong> data=30;</em>//instance variable</p>
<p><strong>void</strong> display(){</p>
<p><strong>class</strong> Local{</p>
<p><strong>void</strong> msg(){System.out.println(data);}</p>
<p>}</p>
<p>Local l=<strong>new</strong> Local();</p>
<p>l.msg();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>localInner1 obj=<strong>new</strong> localInner1();</p>
<p>obj.display();</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 289</p>
<p><span id="Chapter_50__Nested_and_Inner_Cla_1"
class="anchor"></span>Chapter 50: Nested and Inner Classes</p>
<p>Using Java, developers have the ability to define a class within
another class. Such a class is called a <a
href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">Nested
Class</a>.</p>
<p>Nested Classes are called Inner Classes if they were declared as
non-static, if not, they are simply called Static Nested Classes. This
page is to document and provide details with examples on how to use Java
Nested and Inner</p>
<p>Classes.</p>
<p>Section 50.1: A Simple Stack Using a Nested Class</p>
<p>public class <strong>IntStack {</strong></p>
<p><strong>private</strong> IntStackNode head;</p>
<p>// IntStackNode is the inner class of the class IntStack // Each
instance of this inner class functions as one link in the // Overall
stack that it helps to represent</p>
<p>private static class <strong>IntStackNode {</strong></p>
<p>private int <strong>val;</strong></p>
<p><strong>private</strong> IntStackNode next;</p>
<p><strong>private</strong> IntStackNode(<strong>int</strong> v,
IntStackNode n) {</p>
<p>val = v;</p>
<p>next = n;</p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> IntStack push(<strong>int</strong> v) {</p>
<p>head = <strong>new</strong> IntStackNode(v, head);</p>
<p>return this<strong>;</strong></p>
<p>}</p>
<p>public int <strong>pop() {</strong></p>
<p><strong>int</strong> x = head.val;</p>
<p>head = head.next;</p>
<p>return <strong>x;</strong></p>
<p>}</p>
<p>}</p>
<p>And the use thereof, which (notably) does not at all acknowledge the
existence of the nested class.</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>IntStack s = <strong>new</strong> IntStack();</p>
<p>s.push(4).push(3).push(2).push(1).push(0);</p>
<p>//prints: 0, 1, 2, 3, 4,</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt; 5; i++) {</p>
<p>System.out.print(s.pop() + ", ");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 50.2: Static vs Non Static Nested Classes</p>
<p>When creating a nested class, you face a choice of having that nested
class static:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 290</p>
<p><strong>public class</strong> OuterClass1 {</p>
<p>private static class <strong>StaticNestedClass {</strong></p>
<p>}</p>
<p>}</p>
<p>Or non-static:</p>
<p><strong>public class</strong> OuterClass2 {</p>
<p><strong>private class</strong> NestedClass {</p>
<p>}</p>
<p>}</p>
<p>At its core, static nested classes <em>do not have a surrounding
<strong>instance</strong></em> of the outer class, whereas non-static
nested</p>
<p>classes do. This affects both where/when one is allowed to
instantiate a nested class, and what instances of those</p>
<p>nested classes are allowed to access. Adding to the above
example:</p>
<p><strong>public class</strong> OuterClass1 {</p>
<p>private int <strong>aField;</strong></p>
<p><strong>public void</strong> aMethod(){}</p>
<p>private static class <strong>StaticNestedClass {</strong></p>
<p><strong>private int</strong> innerField;</p>
<p><strong>private</strong> StaticNestedClass() {</p>
<p><em>innerField = aField;</em> //Illegal, can't access aField from
static context</p>
<p><em>aMethod();</em> //Illegal, can't call aMethod from static
context</p>
<p>}</p>
<p><strong>private</strong> StaticNestedClass(OuterClass1 instance)
{</p>
<p>innerField = instance.aField; <em>//Legal</em></p>
<p>}</p>
<p>}</p>
<p>public static void <strong>aStaticMethod() {</strong></p>
<p>StaticNestedClass s = <strong>new</strong> StaticNestedClass();
<em>//Legal, able to construct in static context</em></p>
<p>//Do stuff involving s...</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> OuterClass2 {</p>
<p>private int <strong>aField;</strong></p>
<p><strong>public void</strong> aMethod() {}</p>
<p><strong>private class</strong> NestedClass {</p>
<p><strong>private int</strong> innerField;</p>
<p><strong>private</strong> NestedClass() {</p>
<p>innerField = aField; <em>//Legal</em></p>
<p>aMethod(); <em>//Legal</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 291</p>
<p><span id="_18" class="anchor"></span>}</p>
<p>}</p>
<p><strong>public void</strong> aNonStaticMethod() {</p>
<p>NestedClass s = <strong>new</strong> NestedClass();
<em>//Legal</em></p>
<p>}</p>
<p>public static void <strong>aStaticMethod() {</strong></p>
<p><em>NestedClass s = <strong>new</strong> NestedClass();</em>
//Illegal. Can't construct without surrounding OuterClass2 instance.</p>
<p>//As this is a static context, there is no surrounding</p>
<p>OuterClass2 instance</p>
<p>}</p>
<p>}</p>
<p>Thus, your decision of static vs non-static mainly depends on whether
or not you need to be able to directly access fields and methods of the
outer class, though it also has consequences for when and where you can
construct the</p>
<p>nested class.</p>
<p>As a rule of thumb, make your nested classes static unless you need
to access fields and methods of the outer</p>
<p>class. Similar to making your fields private unless you need them
public, this decreases the visibility available to the nested class (by
not allowing access to an outer instance), reducing the likelihood of
error.</p>
<p>Section 50.3: Access Modifiers for Inner Classes</p>
<p>A full explanation of Access Modifiers in Java can be found here. But
how do they interact with Inner classes?</p>
<p><strong>public</strong> , as usual, gives unrestricted access to any
scope able to access the type.</p>
<p><strong>public class</strong> OuterClass {</p>
<p><strong>public class</strong> InnerClass {</p>
<p>public int <strong>x = 5;</strong></p>
<p>}</p>
<p><strong>public</strong> InnerClass createInner() {</p>
<p><strong>return new</strong> InnerClass();</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SomeOtherClass {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>int</strong> x = <strong>new</strong>
OuterClass().createInner().x; <em>//Direct field access is
legal</em></p>
<p>}</p>
<p>}</p>
<p>both <strong>protected</strong> and the default modifier (of nothing)
behave as expected as well, the same as they do for non-</p>
<p>nested classes.</p>
<p><strong>private</strong> , interestingly enough, does not restrict to
the class it belongs to. Rather, it restricts to the compilation unit
-</p>
<p>the .java file. This means that Outer classes have full access to
Inner class fields and methods, even if they are marked
<strong>private</strong>.</p>
<p><strong>public class</strong> OuterClass {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 292</p>
<p><span id="public_class_InnerClass"
class="anchor"></span><strong>public class</strong> InnerClass {</p>
<p>private int <strong>x;</strong></p>
<p><strong>private void</strong> anInnerMethod() {}</p>
<p>}</p>
<p><strong>public</strong> InnerClass aMethod() {</p>
<p>InnerClass a = <strong>new</strong> InnerClass();</p>
<p>a.x = 5; <em>//Legal</em></p>
<p>a.anInnerMethod(); <em>//Legal</em></p>
<p>return <strong>a;</strong></p>
<p>}</p>
<p>}</p>
<p>The Inner Class itself can have a visibility other than
<strong>public</strong>. By marking it <strong>private</strong> or
another restricted access</p>
<p>modifier, other (external) classes will not be allowed to import and
assign the type. They can still get references to</p>
<p>objects of that type, however.</p>
<p><strong>public class</strong> OuterClass {</p>
<p>private class <strong>InnerClass{}</strong></p>
<p><strong>public</strong> InnerClass makeInnerClass() {</p>
<p><strong>return new</strong> InnerClass();</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> AnotherClass {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>OuterClass o = <strong>new</strong> OuterClass();</p>
<p>InnerClass x = o.makeInnerClass(); <em>//Illegal, can't find
type</em></p>
<p>OuterClass.InnerClass x = o.makeInnerClass(); <em>//Illegal,
InnerClass has visibility private</em></p>
<p>Object x = o.makeInnerClass(); <em>//Legal</em></p>
<p>}</p>
<p>}</p>
<p>Section 50.4: Anonymous Inner Classes</p>
<p>An anonymous inner class is a form of inner class that is declared
and instantiated with a single statement. As a consequence, there is no
name for the class that can be used elsewhere in the program; i.e. it is
anonymous.</p>
<p>Anonymous classes are typically used in situations where you need to
be able to create a light-weight class to be passed as a parameter. This
is typically done with an interface. For example:</p>
<p><strong>public static</strong> Comparator CASE_INSENSITIVE =</p>
<p><strong>new</strong> Comparator() {</p>
<p>@Override</p>
<p><strong>public int</strong> compare(String string1, String string2)
{</p>
<p><strong>return</strong>
string1.toUpperCase().compareTo(string2.toUpperCase());</p>
<p>}</p>
<p>};</p>
<p>This anonymous class defines a Comparator object (CASE_INSENSITIVE)
that compares two strings ignoring</p>
<p>differences in case.</p>
<p>Other interfaces that are frequently implemented and instantiated
using anonymous classes are Runnable and</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 293</p>
<p><span id="Callable___For_example" class="anchor"></span>Callable .
For example:</p>
<p>// An anonymous Runnable class is used to provide an instance that
the Thread // will run when started.</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>System.out.println("Hello world");</p>
<p>}</p>
<p>});</p>
<p><em>t.start();</em> // Prints "Hello world"</p>
<p>Anonymous inner classes can also be based on classes. In this case,
the anonymous class implicitly <strong>extends</strong> the existing
class. If the class being extended is abstract, then the anonymous class
must implement all abstract</p>
<p>methods. It may also override non-abstract methods.</p>
<p>Constructors</p>
<p>An anonymous class cannot have an explicit constructor. Instead, an
implicit constructor is defined that uses</p>
<p><strong>super</strong>(...) to pass any parameters to a constructor
in the class that is being extended. For example:</p>
<p>SomeClass anon = <strong>new</strong> SomeClass(1, "happiness") {</p>
<p>@Override</p>
<p><strong>public int</strong> someMethod(<strong>int</strong> arg)
{</p>
<p>// do something</p>
<p>}</p>
<p>};</p>
<p>The implicit constructor for our anonymous subclass of SomeClass will
call a constructor of SomeClass that matches the call signature
SomeClass(<strong>int</strong>, String). If no constructor is available,
you will get a compilation error. Any</p>
<p>exceptions that are thrown by the matched constructor are also thrown
by the implicit constructor.</p>
<p>Naturally, this does not work when extending an interface. When you
create an anonymous class from an interface,</p>
<p>the classes superclass is java.lang.Object which only has a no-args
constructor.</p>
<p>Section 50.5: Create instance of non-static inner class from</p>
<p>outside</p>
<p>An inner class which is visible to any outside class can be created
from this class as well.</p>
<p>The inner class depends on the outside class and requires a reference
to an instance of it. To create an instance of the inner class, the
<strong>new</strong> operator only needs to be called on an instance of
the outer class.</p>
<p><strong>class</strong> OuterClass {</p>
<p><strong>class</strong> InnerClass {</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> OutsideClass {</p>
<p>OuterClass outer = <strong>new</strong> OuterClass();</p>
<p>OuterClass.InnerClass createInner() {</p>
<p><strong>return</strong> outer.<strong>new</strong> InnerClass();</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 294</p>
<p><span id="Note_the_usage_as_outer_new" class="anchor"></span>Note the
usage as outer.<strong>new</strong>.</p>
<p>Section 50.6: Method Local Inner Classes</p>
<p>A class written within a method called <strong>method local inner
class</strong>. In that case the scope of the inner class is</p>
<p>restricted within the method.</p>
<p>A method-local inner class can be instantiated only within the method
where the inner class is defined.</p>
<p>The example of using method local inner class:</p>
<p><strong>public class</strong> OuterClass {</p>
<p><strong>private void</strong> outerMethod() {</p>
<p><strong>final int</strong> outerInt = 1;</p>
<p>// Method Local Inner Class</p>
<p><strong>class</strong> MethodLocalInnerClass {</p>
<p>private void <strong>print() {</strong></p>
<p>System.out.println("Method local inner class " + outerInt);</p>
<p>}</p>
<p>}</p>
<p>// Accessing the inner class</p>
<p>MethodLocalInnerClass inner = <strong>new</strong>
MethodLocalInnerClass();</p>
<p>inner.print();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>OuterClass outer = <strong>new</strong> OuterClass();</p>
<p>outer.outerMethod();</p>
<p>}</p>
<p>}</p>
<p>Executing will give an output:</p>
<p>Method local inner class 1</p>
<p>.</p>
<p>Section 50.7: Accessing the outer class from a non-static</p>
<p>inner class</p>
<p>The reference to the outer class uses the class name and
<strong>this</strong></p>
<p><strong>public class</strong> OuterClass {</p>
<p><strong>public class</strong> InnerClass {</p>
<p>public void <strong>method() {</strong></p>
<p>System.out.println("I can access my enclosing class: " +
OuterClass.<strong>this</strong>);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>You can access fields and methods of the outer class directly.</p>
<p><strong>public class</strong> OuterClass {</p>
<p>private int <strong>counter;</strong></p>
<p><strong>public class</strong> InnerClass {</p>
<p>public void <strong>method() {</strong></p>
<p>System.out.println("I can access " + counter);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 295</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>But in case of name collision you can use the outer class
reference.</p>
<p><strong>public class</strong> OuterClass {</p>
<p>private int <strong>counter;</strong></p>
<p><strong>public class</strong> InnerClass {</p>
<p>private int <strong>counter;</strong></p>
<p>public void <strong>method() {</strong></p>
<p>System.out.println("My counter: " + counter);</p>
<p>System.out.println("Outer counter: " +
OuterClass.<strong>this</strong>.counter);</p>
<p>// updating my counter</p>
<p>counter = OuterClass.<strong>this</strong>.counter;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 296</p>
<p><span id="Chapter_51__The_java_util_Object_1"
class="anchor"></span>Chapter 51: The java.util.Objects Class</p>
<p>Section 51.1: Basic use for object null check</p>
<p>For null check in method</p>
<p>Object nullableObject = methodReturnObject();</p>
<p><strong>if</strong> (Objects.isNull(nullableObject)) {</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p>For not null check in method</p>
<p>Object nullableObject = methodReturnObject();</p>
<p><strong>if</strong> (Objects.nonNull(nullableObject)) {</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p>Section 51.2: Objects.nonNull() method reference use in</p>
<p>stream api</p>
<p>In the old fashion way for collection null check</p>
<p>List someObjects = methodGetList();</p>
<p><strong>for</strong> (Object obj : someObjects) {</p>
<p><strong>if</strong> (obj == <strong>null</strong>) {</p>
<p>continue<strong>;</strong></p>
<p>}</p>
<p>doSomething(obj);</p>
<p>}</p>
<p>With the Objects.nonNull method and Java8 Stream API, we can do the
above in this way:</p>
<p>List someObjects = methodGetList();</p>
<p>someObjects.stream()</p>
<p>.filter(Objects::nonNull)</p>
<p>.<strong>forEach</strong>(<strong>this</strong>::doSomething);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 297</p>
<p><span id="Chapter_52__Default_Methods_1"
class="anchor"></span>Chapter 52: Default Methods</p>
<p><strong>Default Method</strong> introduced in Java 8, allows
developers to add new methods to an interface without breaking the</p>
<p>existing implementations of this interface. It provides flexibility
to allow the interface to define an implementation</p>
<p>which will be used as default when a class which implements that
interface fails to provide an implementation of</p>
<p>that method.</p>
<p>Section 52.1: Basic usage of default methods</p>
<p>/**</p>
<p>* Interface with default method</p>
<p>*/</p>
<p>public interface <strong>Printable {</strong></p>
<p><strong>default void</strong> printString() {</p>
<p>System.out.println( "default implementation" );</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Class which falls back to default implementation of {@link
#printString()} */</p>
<p>public class <strong>WithDefault</strong></p>
<p>implements <strong>Printable</strong></p>
<p>{</p>
<p>}</p>
<p>/**</p>
<p>* Custom implementation of {@link #printString()}</p>
<p>*/</p>
<p><strong>public class</strong> OverrideDefault</p>
<p><strong>implements</strong> Printable {</p>
<p>@Override</p>
<p><strong>public void</strong> printString() {</p>
<p>System.out.println( "overridden implementation" );</p>
<p>}</p>
<p>}</p>
<p>The following statements</p>
<p><strong>new</strong> WithDefault().printString();</p>
<p><strong>new</strong> OverrideDefault().printString();</p>
<p>Will produce this output:</p>
<p>default implementation</p>
<p>overridden implementation</p>
<p>Section 52.2: Accessing overridden default methods from</p>
<p>implementing class</p>
<p>In classes, <strong>super</strong>.foo() will look in superclasses
only. If you want to call a default implementation from a
superinterface, you need to qualify <strong>super</strong> with the
interface name: Fooable.<strong>super</strong>.foo().</p>
<p>public interface <strong>Fooable {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 298</p>
<p><span id="default_int_foo____return_3" class="anchor"></span>default
int <strong>foo() {</strong>return <strong>3;}</strong></p>
<p>}</p>
<p>public class <strong>A</strong> extends <strong>Object</strong>
implements <strong>Fooable {</strong></p>
<p>@Override</p>
<p>public int <strong>foo() {</strong></p>
<p>//return super.foo() + 1; //error: no method foo() in
java.lang.Object <em><strong>return</strong>
Fooable.<strong>super</strong>.foo() + 1;</em> //okay, returns 4</p>
<p>}</p>
<p>}</p>
<p>Section 52.3: Why use Default Methods?</p>
<p>The simple answer is that it allows you to evolve an existing
interface without breaking existing implementations.</p>
<p>For example, you have Swim interface that you published 20 years
ago.</p>
<p>public interface <strong>Swim {</strong></p>
<p><strong>void</strong> backStroke();</p>
<p>}</p>
<p>We did a great job, our interface is very popular, there are many
implementation on that around the world and you</p>
<p>don't have control over their source code.</p>
<p>public class <strong>FooSwimmer</strong> implements <strong>Swim
{</strong></p>
<p><strong>public void</strong> backStroke() {</p>
<p>System.out.println("Do backstroke");</p>
<p>}</p>
<p>}</p>
<p>After 20 years, you've decided to add new functionality to the
interface, but it looks like our interface is frozen</p>
<p>because it will break existing implementations.</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Luckily
Java 8 introduces brand new feature called Default method.</a></p>
<p>We can now add new method to the Swim interface.</p>
<p>public interface <strong>Swim {</strong></p>
<p><strong>void</strong> backStroke();</p>
<p><strong>default void</strong> sideStroke() {</p>
<p>System.out.println("Default sidestroke implementation. Can be
overridden");</p>
<p>}</p>
<p>}</p>
<p>Now all existing implementations of our interface can still work. But
most importantly they can implement the</p>
<p>newly added method in their own time.</p>
<p>One of the biggest reasons for this change, and one of its biggest
uses, is in the Java Collections framework. Oracle could not add a
<strong>foreach</strong> method to the existing Iterable interface
without breaking all existing code which</p>
<p>implemented Iterable. By adding default methods, existing Iterable
implementation will inherit the default</p>
<p>implementation.</p>
<p>Section 52.4: Accessing other interface methods within</p>
<p>default method</p>
<p>You can as well access other interface methods from within your
default method.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 299</p>
<p><span id="public_interface_Summable" class="anchor"></span>public
interface <strong>Summable {</strong></p>
<p><strong>int</strong> getA();</p>
<p><strong>int</strong> getB();</p>
<p><strong>default int</strong> calculateSum() {</p>
<p><strong>return</strong> getA() + getB();</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Sum</strong> implements <strong>Summable
{</strong></p>
<p>@Override</p>
<p>public int <strong>getA() {</strong></p>
<p>return <strong>1;</strong></p>
<p>}</p>
<p>@Override</p>
<p>public int <strong>getB() {</strong></p>
<p>return <strong>2;</strong></p>
<p>}</p>
<p>}</p>
<p>The following statement will print <em>3</em>:</p>
<p>System.out.println(<strong>new</strong> Sum().calculateSum());</p>
<p>Default methods could be used along with interface static methods as
well:</p>
<p>public interface <strong>Summable {</strong></p>
<p>static int <strong>getA() {</strong></p>
<p>return <strong>1;</strong></p>
<p>}</p>
<p>static int <strong>getB() {</strong></p>
<p>return <strong>2;</strong></p>
<p>}</p>
<p><strong>default int</strong> calculateSum() {</p>
<p><strong>return</strong> getA() + getB();</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Sum</strong> implements <strong>Summable
{}</strong></p>
<p>The following statement will also print 3:</p>
<p>System.out.println(<strong>new</strong> Sum().calculateSum());</p>
<p>Section 52.5: Default method multiple inheritance collision</p>
<p>Consider next example:</p>
<p>public interface <strong>A {</strong></p>
<p><strong>default void</strong> foo() { System.out.println("A.foo");
}</p>
<p>}</p>
<p>public interface <strong>B {</strong></p>
<p><strong>default void</strong> foo() { System.out.println("B.foo");
}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 300</p>
<p><span id="_20" class="anchor"></span>}</p>
<p>Here are two interfaces declaring <strong>default</strong> method foo
with the same signature.</p>
<p>If you will try to extend these both interfaces in the new interface
you have to make choice of two, because Java</p>
<p>forces you to resolve this collision explicitly.</p>
<p><strong>First</strong>, you can declare method foo with the same
signature as <strong>abstract</strong>, which will override A and B
behaviour.</p>
<p><strong>public interface</strong> ABExtendsAbstract
<strong>extends</strong> A, B {</p>
<p>@Override</p>
<p><strong>void</strong> foo();</p>
<p>}</p>
<p>And when you will implement ABExtendsAbstract in the
<strong>class</strong> you will have to provide foo implementation:</p>
<p><strong>public class</strong> ABExtendsAbstractImpl
<strong>implements</strong> ABExtendsAbstract {</p>
<p>@Override</p>
<p><strong>public void</strong> foo() {
System.out.println("ABImpl.foo"); }</p>
<p>}</p>
<p>Or <strong>second</strong>, you can provide a completely new
<strong>default</strong> implementation. You also may reuse code of A
and B foo</p>
<p>methods by Accessing overridden default methods from implementing
class.</p>
<p>public interface <strong>ABExtends</strong> extends <strong>A, B
{</strong></p>
<p>@Override</p>
<p><strong>default void</strong> foo() {
System.out.println("ABExtends.foo"); }</p>
<p>}</p>
<p>And when you will implement ABExtends in the <strong>class</strong>
you will not have to provide foo implementation:</p>
<p><strong>public class</strong> ABExtendsImpl
<strong>implements</strong> ABExtends {}</p>
<p>Section 52.6: Class, Abstract class and Interface method</p>
<p>precedence</p>
<p>Implementations in classes, including abstract declarations, take
precedence over all interface defaults.</p>
<p>Abstract class method takes precedence over <a
href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Interface
Default Method</a>.</p>
<p>public interface <strong>Swim {</strong></p>
<p><strong>default void</strong> backStroke() {</p>
<p>System.out.println("Swim.backStroke");</p>
<p>}</p>
<p>}</p>
<p>public abstract class <strong>AbstractSwimmer</strong> implements
<strong>Swim {</strong></p>
<p><strong>public void</strong> backStroke() {</p>
<p>System.out.println("AbstractSwimmer.backStroke");</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> FooSwimmer <strong>extends</strong>
AbstractSwimmer {</p>
<p>}</p>
<p>The following statement</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 301</p>
<p><strong>new</strong> FooSwimmer().backStroke();</p>
<p>Will produce</p>
<p>AbstractSwimmer.backStroke</p>
<p>Class method takes precedence over <a
href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Interface
Default Method</a></p>
<p>public interface <strong>Swim {</strong></p>
<p><strong>default void</strong> backStroke() {</p>
<p>System.out.println("Swim.backStroke");</p>
<p>}</p>
<p>}</p>
<p>public abstract class <strong>AbstractSwimmer</strong> implements
<strong>Swim { }</strong></p>
<p><strong>public class</strong> FooSwimmer <strong>extends</strong>
AbstractSwimmer {</p>
<p><strong>public void</strong> backStroke() {</p>
<p>System.out.println("FooSwimmer.backStroke");</p>
<p>}</p>
<p>}</p>
<p>The following statement</p>
<p><strong>new</strong> FooSwimmer().backStroke();</p>
<p>Will produce</p>
<p>FooSwimmer.backStroke</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 302</p>
<p><span id="Chapter_53__Packages_1" class="anchor"></span>Chapter 53:
Packages</p>
<p>package in java is used to group class and interfaces. This helps
developer to avoid conflict when there are huge</p>
<p>numbers of classes. If we use this package the classes we can create
a class/interface with same name in different packages. By using
packages we can import the piece of again in another class. There many
<em>built in packages</em> in java</p>
<p>like &gt; 1.java.util &gt; 2.java.lang &gt; 3.java.io We can define
our own <em>user defined packages</em>.</p>
<p>Section 53.1: Using Packages to create classes with the same</p>
<p>name</p>
<p>First Test.class:</p>
<p><strong>package</strong> foo.bar</p>
<p>public class <strong>Test {</strong></p>
<p>}</p>
<p>Also Test.class in another package</p>
<p><strong>package</strong> foo.bar.baz</p>
<p>public class <strong>Test {</strong></p>
<p>}</p>
<p>The above is fine because the two classes exist in different
packages.</p>
<p>Section 53.2: Using Package Protected Scope</p>
<p>In Java if you don't provide an access modifier the default scope for
variables is package-protected level. This means</p>
<p>that classes can access the variables of other classes within the
same package as if those variables were publicly available.</p>
<p><strong>package</strong> foo.bar</p>
<p><strong>public class</strong> ExampleClass {</p>
<p><strong>double</strong> exampleNumber;</p>
<p>String exampleString;</p>
<p><strong>public</strong> ExampleClass() {</p>
<p>exampleNumber = 3;</p>
<p>exampleString = "Test String";</p>
<p>}</p>
<p>//No getters or setters</p>
<p>}</p>
<p><strong>package</strong> foo.bar</p>
<p><strong>public class</strong> AnotherClass {</p>
<p>ExampleClass clazz = <strong>new</strong> ExampleClass();</p>
<p>System.out.println("Example Number: " + clazz.exampleNumber);
<em>//Prints Example Number: 3</em></p>
<p>System.out.println("Example String: " + clazz.exampleString);
<em>//Prints Example String: Test String</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 303</p>
<p>}</p>
<p>This method will not work for a class in another package:</p>
<p><strong>package</strong> baz.foo</p>
<p><strong>public class</strong> ThisShouldNotWork {</p>
<p>ExampleClass clazz = <strong>new</strong> ExampleClass();</p>
<p>System.out.println("Example Number: " + clazz.exampleNumber);
<em>//Throws an exception</em></p>
<p>System.out.println("Example String: " + clazz.exampleString);
<em>//Throws an exception</em></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 304</p>
<p><span id="Chapter_54__Inheritance_1" class="anchor"></span>Chapter
54: Inheritance</p>
<p>Inheritance is a basic object oriented feature in which one class
acquires and extends upon the properties of</p>
<p>another class, using the keyword <strong>extends</strong>. For
Interfaces and the keyword <strong>implements</strong>, see
interfaces.</p>
<p>Section 54.1: Inheritance</p>
<p>With the use of the <strong>extends</strong> keyword among classes,
all the properties of the superclass (also known as the
<em>Parent</em></p>
<p><em>Class</em> or <em>Base Class</em>) are present in the subclass
(also known as the <em>Child Class</em> or <em>Derived Class</em>)</p>
<p>public class <strong>BaseClass {</strong></p>
<p><strong>public void</strong> baseMethod(){</p>
<p>System.out.println("Doing base class stuff");</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SubClass <strong>extends</strong>
BaseClass {</p>
<p>}</p>
<p>Instances of SubClass have <em>inherited</em> the method
baseMethod():</p>
<p>SubClass s = <strong>new</strong> SubClass();</p>
<p><em>s.baseMethod();</em> //Valid, prints "Doing base class stuff"</p>
<p>Additional content can be added to a subclass. Doing so allows for
additional functionality in the subclass without</p>
<p>any change to the base class or any other subclasses from that same
base class:</p>
<p><strong>public class</strong> Subclass2 <strong>extends</strong>
BaseClass {</p>
<p><strong>public void</strong> anotherMethod() {</p>
<p>System.out.println("Doing subclass2 stuff");</p>
<p>}</p>
<p>}</p>
<p>Subclass2 s2 = <strong>new</strong> Subclass2();</p>
<p><em>s2.baseMethod();</em> //Still valid , prints "Doing base class
stuff" <em>s2.anotherMethod();</em> //Also valid, prints "Doing
subclass2 stuff"</p>
<p>Fields are also inherited:</p>
<p><strong>public class</strong> BaseClassWithField {</p>
<p>public int <strong>x;</strong></p>
<p>}</p>
<p><strong>public class</strong> SubClassWithField
<strong>extends</strong> BaseClassWithField {</p>
<p><strong>public</strong> SubClassWithField(<strong>int</strong> x)
{</p>
<p><em><strong>this</strong>.x = x;</em> //Can access fields</p>
<p>}</p>
<p>}</p>
<p><strong>private</strong> fields and methods still exist within the
subclass, but are not accessible:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 305</p>
<p><span id="public_class_BaseClassWithPrivat"
class="anchor"></span><strong>public class</strong>
BaseClassWithPrivateField {</p>
<p>private int <strong>x = 5;</strong></p>
<p>public int <strong>getX() {</strong></p>
<p>return <strong>x;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SubClassInheritsPrivateField
<strong>extends</strong> BaseClassWithPrivateField {</p>
<p>public void <strong>printX() {</strong></p>
<p><em>System.out.println(x);</em> //Illegal, can't access private field
x <em>System.out.println(getX());</em> //Legal, prints 5</p>
<p>}</p>
<p>}</p>
<p>SubClassInheritsPrivateField s = <strong>new</strong>
SubClassInheritsPrivateField(); <strong>int</strong> x = s.getX();
<em>//x will have a value of 5.</em></p>
<p>In Java, each class may extend at most one other class.</p>
<p>public class <strong>A{}</strong></p>
<p>public class <strong>B{}</strong></p>
<p><strong>public class</strong> ExtendsTwoClasses
<strong>extends</strong> A, B {} <em>//Illegal</em></p>
<p>This is known as multiple inheritance, and while it is legal in some
languages, Java does not permit it with classes.</p>
<p>As a result of this, every class has an unbranching ancestral chain
of classes leading to Object, from which all</p>
<p>classes descend.</p>
<p>Section 54.2: Abstract Classes</p>
<p>An abstract class is a class marked with the
<strong>abstract</strong> keyword. It, contrary to non-abstract class,
may contain abstract - implementation-less - methods. It is, however,
valid to create an abstract class without abstract methods.</p>
<p>An abstract class cannot be instantiated. It can be sub-classed
(extended) as long as the sub-class is either also abstract, or
implements all methods marked as abstract by super classes.</p>
<p>An example of an abstract class:</p>
<p>public abstract class <strong>Component {</strong></p>
<p>private int <strong>x, y;</strong></p>
<p><strong>public</strong> setPosition(<strong>int</strong> x,
<strong>int</strong> y) {</p>
<p><strong>this</strong>.x = x;</p>
<p><strong>this</strong>.y = y;</p>
<p>}</p>
<p>public abstract void <strong>render();</strong></p>
<p>}</p>
<p>The class must be marked abstract, when it has at least one abstract
method. An abstract method is a method that has no implementation. Other
methods can be declared within an abstract class that have
implementation in order</p>
<p>to provide common code for any sub-classes.</p>
<p>Attempting to instantiate this class will provide a compile
error:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 306</p>
<p>//error: Component is abstract; cannot be instantiated <em>Component
myComponent = <strong>new</strong> Component();</em></p>
<p>However a class that extends Component, and provides an
implementation for all of its abstract methods and can be
instantiated.</p>
<p><strong>public class</strong> Button <strong>extends</strong>
Component {</p>
<p>@Override</p>
<p>public void <strong>render() {</strong></p>
<p>//render a button</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> TextBox <strong>extends</strong>
Component {</p>
<p>@Override</p>
<p>public void <strong>render() {</strong></p>
<p>//render a textbox</p>
<p>}</p>
<p>}</p>
<p>Instances of inheriting classes also can be cast as the parent class
(normal inheritance) and they provide a polymorphic effect when the
abstract method is called.</p>
<p>Component myButton = <strong>new</strong> Button();</p>
<p>Component myTextBox = <strong>new</strong> TextBox();</p>
<p>myButton.render(); <em>//renders a button</em></p>
<p>myTextBox.render(); <em>//renders a text box</em></p>
<p>Abstract classes vs Interfaces</p>
<p>Abstract classes and interfaces both provide a way to define method
signatures while requiring the</p>
<p>extending/implementing class to provide the implementation.</p>
<p>There are two key differences between abstract classes and
interfaces:</p>
<p>A class may only extend a single class, but may implement many
interfaces. An abstract class can contain instance
(non-<strong>static</strong>) fields, but interfaces may only contain
<strong>static</strong> fields.</p>
<p>Version &lt; Java SE 8</p>
<p>Methods declared in interfaces could not contain implementations, so
abstract classes were used when it was useful to provide additional
methods which implementations called the abstract methods.</p>
<p>Version ≥ Java SE 8</p>
<p>Java 8 allows interfaces to contain default methods, usually
implemented using the other methods of the interface,</p>
<p>making interfaces and abstract classes equally powerful in this
regard.</p>
<p>Anonymous subclasses of Abstract Classes</p>
<p>As a convenience java allows for instantiation of anonymous instances
of subclasses of abstract classes, which</p>
<p>provide implementations for the abstract methods upon creating the
new object. Using the above example this could look like this:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 307</p>
<p><span id="Component_myAnonymousComponent"
class="anchor"></span>Component myAnonymousComponent =
<strong>new</strong> Component() {</p>
<p>@Override</p>
<p>public void <strong>render() {</strong></p>
<p>// render a quick 1-time use component</p>
<p>}</p>
<p>}</p>
<p>Section 54.3: Using 'final' to restrict inheritance and</p>
<p>overriding</p>
<p>Final classes</p>
<p>When used in a <strong>class</strong> declaration, the
<strong>final</strong> modifier prevents other classes from being
declared that extend the</p>
<p>class. A <strong>final</strong> class is a "leaf" class in the
inheritance class hierarchy.</p>
<p>// This declares a final class</p>
<p><strong>final class</strong> MyFinalClass {</p>
<p>/* some code */</p>
<p>}</p>
<p>// Compilation error: cannot inherit from final MyFinalClass
<em><strong>class</strong> MySubClass <strong>extends</strong>
MyFinalClass {</em></p>
<p>/* more code */</p>
<p>}</p>
<p>Use-cases for final classes</p>
<p>Final classes can be combined with a <strong>private</strong>
constructor to control or prevent the instantiation of a class. This
can</p>
<p>be used to create a so-called "utility class" that only defines
static members; i.e. constants and static methods.</p>
<p>public final class <strong>UtilityClass {</strong></p>
<p>// Private constructor to replace the default visible constructor
<em><strong>private</strong> UtilityClass() {}</em></p>
<p>// Static members can still be used as usual</p>
<p><strong>public static int</strong> doSomethingCool() {</p>
<p>return <strong>123;</strong></p>
<p>}</p>
<p>}</p>
<p>Immutable classes should also be declared as <strong>final</strong>.
(An immutable class is one whose instances cannot be</p>
<p>changed after they have been created; see the Immutable Objects
topic. ) By doing this, you make it impossible to create a mutable
subclass of an immutable class. That would violate the Liskov
Substitution Principle which</p>
<p>requires that a subtype should obey the "behavioral contract" of its
supertypes.</p>
<p>From a practical perspective, declaring an immutable class to be
<strong>final</strong> makes it easier to reason about program</p>
<p>behavior. It also addresses security concerns in the scenario where
untrusted code is executed in a security sandbox. (For instance, since
String is declared as <strong>final</strong>, a trusted class does not
need to worry that it might be</p>
<p>tricked into accepting mutable subclass, which the untrusted caller
could then surreptitiously change.)</p>
<p>One disadvantage of <strong>final</strong> classes is that they do
not work with some mocking frameworks such as Mockito.</p>
<p>Update: Mockito version 2 now support mocking of final classes.</p>
<p>Final methods</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 308</p>
<p><span id="The_final_modifier_can_also_be_a" class="anchor"></span>The
<strong>final</strong> modifier can also be applied to methods to
prevent them being overridden in sub-classes:</p>
<p><strong>public class</strong> MyClassWithFinalMethod {</p>
<p>public final void <strong>someMethod() {</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> MySubClass <strong>extends</strong>
MyClassWithFinalMethod {</p>
<p>@Override</p>
<p><em><strong>public void</strong> someMethod() {</em> // Compiler
error (overridden method is final) <em>}</em></p>
<p>}</p>
<p>Final methods are typically used when you want to restrict what a
subclass can change in a class without forbidding subclasses
entirely.</p>
<p>The <strong>final</strong> modifier can also be applied to variables,
but the meaning of <strong>final</strong> for variables is unrelated to
inheritance.</p>
<p>Section 54.4: The Liskov Substitution Principle</p>
<p>Substitutability is a principle in object-oriented programming
introduced by Barbara Liskov in a 1987 conference keynote stating that,
if class B is a subclass of class A, then wherever A is expected, B can
be used instead:</p>
<p><strong>class</strong> A {...}</p>
<p>class <strong>B</strong> extends <strong>A {...}</strong></p>
<p><strong>public void</strong> method(A obj) {...}</p>
<p><em>A a = <strong>new</strong> B();</em> // Assignment OK</p>
<p><em>method(<strong>new</strong> B());</em> // Passing as parameter
OK</p>
<p>This also applies when the type is an interface, where there doesn't
need to any hierarchical relationship between</p>
<p>the objects:</p>
<p>interface <strong>Foo {</strong></p>
<p><strong>void</strong> bar();</p>
<p>}</p>
<p>class <strong>A</strong> implements <strong>Foo {</strong></p>
<p><strong>void</strong> bar() {...}</p>
<p>}</p>
<p>class <strong>B</strong> implements <strong>Foo {</strong></p>
<p><strong>void</strong> bar() {...}</p>
<p>}</p>
<p>List foos = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>foos.add(<strong>new</strong> A()); <em>// OK</em></p>
<p>foos.add(<strong>new</strong> B()); <em>// OK</em></p>
<p>Now the list contains objects that are not from the same class
hierarchy.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 309</p>
<p><span id="Section_54_5__Abstract_class_and"
class="anchor"></span>Section 54.5: Abstract class and Interface usage:
"Is-a"</p>
<p>relation vs "Has-a" capability</p>
<p>When to use abstract classes: To implement the same or different
behaviour among multiple related objects</p>
<p>When to use interfaces: to implement a contract by multiple unrelated
objects</p>
<p>Abstract classes create "is a" relations while interfaces provide
"has a" capability.</p>
<p>This can be seen in the code below:</p>
<p><strong>public class</strong> InterfaceAndAbstractClassDemo{</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>Dog dog = <strong>new</strong> Dog("Jack",16);</p>
<p>Cat cat = <strong>new</strong> Cat("Joe",20);</p>
<p>System.out.println("Dog:"+dog);</p>
<p>System.out.println("Cat:"+cat);</p>
<p>dog.remember();</p>
<p>dog.protectOwner();</p>
<p>Learn dl = dog;</p>
<p>dl.learn();</p>
<p>cat.remember();</p>
<p>cat.protectOwner();</p>
<p>Climb c = cat;</p>
<p>c.climb();</p>
<p>Man man = <strong>new</strong> Man("Ravindra",40);</p>
<p>System.out.println(man);</p>
<p>Climb cm = man;</p>
<p>cm.climb();</p>
<p>Think t = man;</p>
<p>t.think();</p>
<p>Learn l = man;</p>
<p>l.learn();</p>
<p>Apply a = man;</p>
<p>a.apply();</p>
<p>}</p>
<p>}</p>
<p>abstract class <strong>Animal{</strong></p>
<p>String name;</p>
<p><strong>int</strong> lifeExpentency;</p>
<p><strong>public</strong> Animal(String name,<strong>int</strong>
lifeExpentency ){</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.lifeExpentency=lifeExpentency;</p>
<p>}</p>
<p>public abstract void <strong>remember();</strong></p>
<p>public abstract void <strong>protectOwner();</strong></p>
<p><strong>public</strong> String toString(){</p>
<p><strong>return
this</strong>.getClass().getSimpleName()+":"+name+":"+lifeExpentency;</p>
<p>}</p>
<p>}</p>
<p>class <strong>Dog</strong> extends <strong>Animal</strong> implements
<strong>Learn{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 310</p>
<p><strong>public</strong> Dog(String name,<strong>int</strong>
age){</p>
<p><strong>super</strong>(name,age);</p>
<p>}</p>
<p><strong>public void</strong> remember(){</p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName()+"
can remember for 5 minutes");</p>
<p>}</p>
<p><strong>public void</strong> protectOwner(){</p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName()+
" will protect owner");</p>
<p>}</p>
<p>public void <strong>learn(){</strong></p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName()+
" can learn:");</p>
<p>}</p>
<p>}</p>
<p>class <strong>Cat</strong> extends <strong>Animal</strong> implements
<strong>Climb {</strong></p>
<p><strong>public</strong> Cat(String name,<strong>int</strong>
age){</p>
<p><strong>super</strong>(name,age);</p>
<p>}</p>
<p><strong>public void</strong> remember(){</p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName() +
" can remember for 16 hours");</p>
<p>}</p>
<p><strong>public void</strong> protectOwner(){</p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName()+
" won't protect owner");</p>
<p>}</p>
<p>public void <strong>climb(){</strong></p>
<p>System.out.println(<strong>this</strong>.getClass().getSimpleName()+
" can climb");</p>
<p>}</p>
<p>}</p>
<p>interface <strong>Climb{</strong></p>
<p><strong>void</strong> climb();</p>
<p>}</p>
<p>interface <strong>Think {</strong></p>
<p><strong>void</strong> think();</p>
<p>}</p>
<p>interface <strong>Learn {</strong></p>
<p><strong>void</strong> learn();</p>
<p>}</p>
<p>interface <strong>Apply{</strong></p>
<p><strong>void</strong> apply();</p>
<p>}</p>
<p><strong>class</strong> Man <strong>implements</strong>
Think,Learn,Apply,Climb{</p>
<p>String name;</p>
<p><strong>int</strong> age;</p>
<p><strong>public</strong> Man(String name,<strong>int</strong>
age){</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.age = age;</p>
<p>}</p>
<p>public void <strong>think(){</strong></p>
<p>System.out.println("I can
think:"+<strong>this</strong>.getClass().getSimpleName());</p>
<p>}</p>
<p>public void <strong>learn(){</strong></p>
<p>System.out.println("I can
learn:"+<strong>this</strong>.getClass().getSimpleName());</p>
<p>}</p>
<p>public void <strong>apply(){</strong></p>
<p>System.out.println("I can
apply:"+<strong>this</strong>.getClass().getSimpleName());</p>
<p>}</p>
<p>public void <strong>climb(){</strong></p>
<p>System.out.println("I can
climb:"+<strong>this</strong>.getClass().getSimpleName());</p>
<p>}</p>
<p><strong>public</strong> String toString(){</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 311</p>
<p><strong>return</strong> "Man :"+name+":Age:"+age;</p>
<p>}</p>
<p>}</p>
<p>output:</p>
<p>Dog:Dog:Jack:16</p>
<p>Cat:Cat:Joe:20</p>
<p>Dog can remember for 5 minutes</p>
<p>Dog will protect owner</p>
<p>Dog can learn:</p>
<p>Cat can remember for 16 hours</p>
<p>Cat won't protect owner</p>
<p>Cat can climb</p>
<p>Man :Ravindra:Age:40</p>
<p>I can climb:Man</p>
<p>I can think:Man</p>
<p>I can learn:Man</p>
<p>I can apply:Man</p>
<p>Key notes:</p>
<p>1. Animal is an abstract class with shared attributes: name and
lifeExpectancy and abstract methods:</p>
<p>remember() and protectOwner(). Dog and Cat are Animals that have
implemented the remember() and</p>
<p>protectOwner() methods.</p>
<p>2. Cat can climb() but Dog cannot. Dog can think() but Cat cannot.
These specific capabilities are added to Cat</p>
<p>and Dog by implementation.</p>
<p>3. Man is not an Animal but he can Think , Learn, Apply, and
Climb.</p>
<p>4. Cat is not a Man but it can Climb.</p>
<p>5. Dog is not a Man but it can Learn</p>
<p>6. Man is neither a Cat nor a Dog but can have some of the
capabilities of the latter two without extending</p>
<p>Animal , Cat, or Dog. This is done with Interfaces.</p>
<p>7. Even though Animal is an abstract class, it has a constructor,
unlike an interface.</p>
<p>TL;DR:</p>
<p>Unrelated classes can have capabilities through interfaces, but
related classes change the behaviour through extension of base
classes.</p>
<p>Refer to the Java documentation <a
href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">page</a>
to understand which one to use in a specific use case.</p>
<p>Consider using abstract classes <strong>if...</strong></p>
<p>1. You want to share code among several closely related classes.</p>
<p>2. You expect that classes that extend your abstract class have many
common methods or fields, or require</p>
<p>access modifiers other than public (such as protected and
private).</p>
<p>3. You want to declare non-static or non-final fields.</p>
<p>Consider using interfaces <strong>if...</strong></p>
<p>1. You expect that unrelated classes would implement your interface.
For example, many unrelated objects can</p>
<p>implement the Serializable interface.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 312</p>
<p><span id="2__You_want_to_specify_the_behav" class="anchor"></span>2.
You want to specify the behaviour of a particular data type but are not
concerned about who implements its</p>
<p>behaviour.</p>
<p>3. You want to take advantage of multiple inheritance of type.</p>
<p>Section 54.6: Static Inheritance</p>
<p>Static method can be inherited similar to normal methods, however
unlike normal methods it is impossible to</p>
<p>create "abstract" methods in order to force static method overriding.
Writing a method with the same signature as a static method in a super
class appears to be a form of overriding, but really this simply creates
a new function</p>
<p>hides the other.</p>
<p>public class <strong>BaseClass {</strong></p>
<p>public static int <strong>num = 5;</strong></p>
<p>public static void <strong>sayHello() {</strong></p>
<p>System.out.println("Hello");</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>BaseClass.sayHello();</p>
<p>System.out.println("BaseClass's num: " + BaseClass.num);</p>
<p>SubClass.sayHello();</p>
<p>//This will be different than the above statement's output, since it
runs //A different method</p>
<p>SubClass.sayHello(<strong>true</strong>);</p>
<p>StaticOverride.sayHello();</p>
<p>System.out.println("StaticOverride's num: " +
StaticOverride.num);</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> SubClass <strong>extends</strong>
BaseClass {</p>
<p>//Inherits the sayHello function, but does not override it
<em><strong>public static void</strong>
sayHello(<strong>boolean</strong> test) {</em></p>
<p>System.out.println("Hey");</p>
<p>}</p>
<p>}</p>
<p><strong>public static class</strong> StaticOverride
<strong>extends</strong> BaseClass {</p>
<p>//Hides the num field from BaseClass</p>
<p>//You can even change the type, since this doesn't affect the
signature <em><strong>public static</strong> String num =
"test";</em></p>
<p>//Cannot use @Override annotation, since this is static //This
overrides the sayHello method from BaseClass <em><strong>public static
void</strong> sayHello() {</em></p>
<p>System.out.println("Static says Hi");</p>
<p>}</p>
<p>}</p>
<p>Running any of these classes produces the output:</p>
<p>Hello</p>
<p>BaseClass's num: 5</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 313</p>
<p><span id="Hello" class="anchor"></span>Hello</p>
<p>Hey</p>
<p>Static says Hi</p>
<p>StaticOverride's num: test</p>
<p>Note that unlike normal inheritance, in static inheritance methods
are not hidden. You can always call the base</p>
<p>sayHello method by using BaseClass.sayHello(). But classes do inherit
static methods <em>if</em> no methods with the same signature are found
in the subclass. If two method's signatures vary, both methods can be
run from the</p>
<p>subclass, even if the name is the same.</p>
<p>Static fields hide each other in a similar way.</p>
<p>Section 54.7: Programming to an interface</p>
<p>The idea behind programming to an interface is to base the code
primarily on interfaces and only use concrete classes at the time of
instantiation. In this context, good code dealing with e.g. Java
collections will look something</p>
<p>like this (not that the method itself is of any use at all, just
illustration):</p>
<p><strong>public</strong> Set toSet(Collection collection) {</p>
<p><strong>return</strong> Sets.newHashSet(collection);</p>
<p>}</p>
<p>while bad code might look like this:</p>
<p><strong>public</strong> HashSet toSet(ArrayList collection) {</p>
<p><strong>return</strong> Sets.newHashSet(collection);</p>
<p>}</p>
<p>Not only the former can be applied to a wider choice of arguments,
its results will be more compatible with code</p>
<p>provided by other developers that generally adhere to the concept of
programming to an interface. However, the most important reasons to use
the former are:</p>
<p>most of the time the context, in which the result is used, does not
and should not need that many details as the concrete implementation
provides;</p>
<p>adhering to an interface forces cleaner code and less hacks such as
yet another public method gets added to a class serving some specific
scenario;</p>
<p>the code is more testable as interfaces are easily mockable;</p>
<p>finally, the concept helps even if only one implementation is
expected (at least for testability).</p>
<p>So how can one easily apply the concept of programming to an
interface when writing new code having in mind one particular
implementation? One option that we commonly use is a combination of the
following patterns:</p>
<p>programming to an interface</p>
<p>factory</p>
<p>builder</p>
<p>The following example based on these principles is a simplified and
truncated version of an RPC implementation</p>
<p>written for a number of different protocols:</p>
<p>public interface <strong>RemoteInvoker {</strong></p>
<p>CompletableFuture invoke(RQ request, Class responseClass);</p>
<p>}</p>
<p>The above interface is not supposed to be instantiated directly via a
factory, instead we derive further more</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 314</p>
<p>concrete interfaces, one for HTTP invocation and one for AMQP, each
then having a factory and a builder to construct instances, which in
turn are also instances of the above interface:</p>
<p><strong>public interface</strong> AmqpInvoker
<strong>extends</strong> RemoteInvoker {</p>
<p><strong>static</strong> AmqpInvokerBuilder with(String instanceId,
ConnectionFactory factory) {</p>
<p><strong>return new</strong> AmqpInvokerBuilder(instanceId,
factory);</p>
<p>}</p>
<p>}</p>
<p>Instances of RemoteInvoker for the use with AMQP can now be
constructed as easy as (or more involved depending</p>
<p>on the builder):</p>
<p>RemoteInvoker invoker = AmqpInvoker.with(instanceId, factory)
.requestRouter(router)</p>
<p>.build();</p>
<p>And an invocation of a request is as easy as:</p>
<p>Response res = invoker.invoke(<strong>new</strong> Request(data),
Response.<strong>class</strong>).get();</p>
<p>Due to Java 8 permitting placing of static methods directly into
interfaces, the intermediate factory has become</p>
<p>implicit in the above code replaced with AmqpInvoker.with(). In Java
prior to version 8, the same effect can be</p>
<p>achieved with an inner Factory class:</p>
<p><strong>public interface</strong> AmqpInvoker
<strong>extends</strong> RemoteInvoker {</p>
<p><strong>class</strong> Factory {</p>
<p><strong>public static</strong> AmqpInvokerBuilder with(String
instanceId, ConnectionFactory factory) {</p>
<p><strong>return new</strong> AmqpInvokerBuilder(instanceId,
factory);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The corresponding instantiation would then turn into:</p>
<p>RemoteInvoker invoker = AmqpInvoker.Factory.with(instanceId, factory)
.requestRouter(router)</p>
<p>.build();</p>
<p>The builder used above could look like this (although this is a
simplification as the actual one permits defining of up</p>
<p>to 15 parameters deviating from defaults). Note that the construct is
not public, so it is specifically usable only from the above AmqpInvoker
interface:</p>
<p><strong>public class</strong> AmqpInvokerBuilder {</p>
<p>...</p>
<p>AmqpInvokerBuilder(String instanceId, ConnectionFactory factory)
{</p>
<p><strong>this</strong>.instanceId = instanceId;</p>
<p><strong>this</strong>.factory = factory;</p>
<p>}</p>
<p><strong>public</strong> AmqpInvokerBuilder
requestRouter(RequestRouter requestRouter) {</p>
<p><strong>this</strong>.requestRouter = requestRouter;</p>
<p>return this<strong>;</strong></p>
<p>}</p>
<p><strong>public</strong> AmqpInvoker build() <strong>throws</strong>
TimeoutException, IOException {</p>
<p><strong>return new</strong> AmqpInvokerImpl(instanceId, factory,
requestRouter);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 315</p>
<p><span id="_22" class="anchor"></span>}</p>
<p>Generally, a builder can also be generated using a tool like
FreeBuilder.</p>
<p>Finally, the standard (and the only expected) implementation of this
interface is defined as a package-local class to</p>
<p>enforce the use of the interface, the factory and the builder:</p>
<p><strong>class</strong> AmqpInvokerImpl <strong>implements</strong>
AmqpInvoker {</p>
<p>AmqpInvokerImpl(String instanceId, ConnectionFactory factory,
RequestRouter requestRouter) {</p>
<p>...</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> CompletableFuture
invoke(<strong>final</strong> RQ request, <strong>final</strong> Class
respClass) { ...</p>
<p>}</p>
<p>}</p>
<p>Meanwhile, this pattern proved to be very efficient in developing all
our new code not matter how simple or complex the functionality is.</p>
<p>Section 54.8: Overriding in Inheritance</p>
<p>Overriding in Inheritance is used when you use a already defined
method from a super class in a sub class, but in a different way than
how the method was originally designed in the super class. Overriding
allows the user to reuse</p>
<p>code by using existing material and modifying it to suit the user's
needs better.</p>
<p>The following example demonstrates how ClassB overrides the
functionality of ClassA by changing what gets sent</p>
<p>out through the printing method:</p>
<p>Example:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ClassA a = <strong>new</strong> ClassA();</p>
<p>ClassA b = <strong>new</strong> ClassB();</p>
<p>a.printing();</p>
<p>b.printing();</p>
<p>}</p>
<p><strong>class</strong> ClassA {</p>
<p><strong>public void</strong> printing() {</p>
<p>System.out.println("A");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> ClassB <strong>extends</strong> ClassA {</p>
<p><strong>public void</strong> printing() {</p>
<p>System.out.println("B");</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>A</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 316</p>
<p><span id="B" class="anchor"></span>B</p>
<p>Section 54.9: Variable shadowing</p>
<p>Variables are SHADOWED and methods are OVERRIDDEN. Which variable
will be used depends on the class that the</p>
<p>variable is declared of. Which method will be used depends on the
actual class of the object that is referenced by the variable.</p>
<p><strong>class</strong> Car {</p>
<p><strong>public int</strong> gearRatio = 8;</p>
<p><strong>public</strong> String accelerate() {</p>
<p><strong>return</strong> "Accelerate : Car";</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> SportsCar <strong>extends</strong> Car {</p>
<p><strong>public int</strong> gearRatio = 9;</p>
<p><strong>public</strong> String accelerate() {</p>
<p><strong>return</strong> "Accelerate : SportsCar";</p>
<p>}</p>
<p>public void <strong>test() {</strong></p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Car car = <strong>new</strong> SportsCar();</p>
<p>System.out.println(car.gearRatio + " " + car.accelerate()); <em>//
will print out 8 Accelerate : SportsCar</em></p>
<p>}</p>
<p>}</p>
<p>Section 54.10: Narrowing and Widening of object references</p>
<p>Casting an instance of a base class to a subclass as in : b = (B) a;
is called <em>narrowing</em> (as you are trying to narrow</p>
<p>the base class object to a more specific class object) and needs an
explicit type-cast.</p>
<p>Casting an instance of a subclass to a base class as in: A a = b; is
called <em>widening</em> and does not need a type-cast.</p>
<p>To illustrate, consider the following class declarations, and test
code:</p>
<p><strong>class</strong> Vehicle {</p>
<p>}</p>
<p><strong>class</strong> Car <strong>extends</strong> Vehicle {</p>
<p>}</p>
<p><strong>class</strong> Truck <strong>extends</strong> Vehicle {</p>
<p>}</p>
<p><strong>class</strong> MotorCycle <strong>extends</strong> Vehicle
{</p>
<p>}</p>
<p><strong>class</strong> Test {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 317</p>
<p><span id="public_static_void_main_String_2"
class="anchor"></span><strong>public static void</strong> main(String[]
args) {</p>
<p>Vehicle vehicle = <strong>new</strong> Car();</p>
<p>Car car = <strong>new</strong> Car();</p>
<p><em>vehicle = car;</em> // is valid, no cast needed</p>
<p>Car c = vehicle <em>// not valid</em></p>
<p>Car c = (Car) vehicle; <em>//valid</em></p>
<p>}</p>
<p>}</p>
<p>The statement Vehicle vehicle = <strong>new</strong> Car(); is a
valid Java statement. Every instance of Car is also a Vehicle.</p>
<p>Therefore, the assignment is legal without the need for an explicit
type-cast.</p>
<p>On the other hand, Car c = vehicle; is not valid. The static type of
the vehicle variable is Vehicle which means</p>
<p>that it could refer to an instance of Car, Truck,MotorCycle, or any
other current or future subclass ofVehicle. (Or indeed, an instance
ofVehicleitself, since we did not declare it as
anabstract<strong>class</strong>.)</p>
<p>The assignment cannot be allowed, since that might lead to
carreferring to aTruck` instance.</p>
<p>To prevent this situation, we need to add an explicit type-cast:</p>
<p>Car c = (Car) vehicle;</p>
<p>The type-cast tells the compiler that we <em>expect</em> the value of
vehicle to be a Car or a subclass of Car. If necessary,</p>
<p>compiler will insert code to perform a run-time type check. If the
check fails, then a ClassCastException will be thrown when the code is
executed.</p>
<p>Note that not all type-casts are valid. For example:</p>
<p>String s = (String) vehicle; <em>// not valid</em></p>
<p>The Java compiler knows that an instance that is type compatible with
Vehicle <em>cannot ever be</em> type compatible with String . The
type-cast could never succeed, and the JLS mandates that this gives in a
compilation error.</p>
<p>Section 54.11: Inheritance and Static Methods</p>
<p>In Java, parent and child class both can have static methods with the
same name. But in such cases implementation</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8.2">of
static method in child is hiding parent class' implementation, it's not
method overriding. For example:</a></p>
<p><strong>class</strong> StaticMethodTest {</p>
<p>// static method and inheritance</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Parent p = <strong>new</strong> Child();</p>
<p><em>p.staticMethod();</em> // prints Inside Parent</p>
<p>((Child) p).staticMethod(); <em>// prints Inside Child</em></p>
<p>}</p>
<p>static class <strong>Parent {</strong></p>
<p>public static void <strong>staticMethod() {</strong></p>
<p>System.out.println("Inside Parent");</p>
<p>}</p>
<p>}</p>
<p>static class <strong>Child</strong> extends <strong>Parent
{</strong></p>
<p>public static void <strong>staticMethod() {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 318</p>
<p>System.out.println("Inside Child");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Static methods are bind to a class not to an instance and this method
binding happens at compile time. Since in the</p>
<p>first call to staticMethod(), parent class reference p was used,
Parent's version of staticMethod() is invoked. In second case, we did
cast p into Child class, Child's staticMethod() executed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 319</p>
<p><span id="Chapter_55__Reference_Types_1"
class="anchor"></span>Chapter 55: Reference Types</p>
<p>Section 55.1: Dierent Reference Types</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html">java.lang.ref
package provides reference-object classes, which support a limited
degree of interaction with the</a> garbage collector.</p>
<p>Java has four main different reference types. They are:</p>
<p>Strong Reference</p>
<p>Weak Reference</p>
<p>Soft Reference</p>
<p>Phantom Reference</p>
<p>1. Strong Reference</p>
<p>This is the usual form of creating objects.</p>
<p>MyObject myObject = <strong>new</strong> MyObject();</p>
<p>The variable holder is holding a strong reference to the object
created. As long as this variable is live and holds this value, the
MyObject instance will not be collected by the garbage collector.</p>
<p>2. Weak Reference</p>
<p>When you do not want to keep an object longer, and you need to
clear/free the memory allocated for an object as soon as possible, this
is the way to do so.</p>
<p>WeakReference myObjectRef = <strong>new</strong>
WeakReference(MyObject);</p>
<p>Simply, a weak reference is a reference that isn't strong enough to
force an object to remain in memory. Weak</p>
<p>references allow you to leverage the garbage collector's ability to
determine reachability for you, so you don't have to do it yourself.</p>
<p>When you need the object you created, just use .get() method:</p>
<p>myObjectRef.get();</p>
<p>Following code will exemplify this:</p>
<p>WeakReference myObjectRef = <strong>new</strong>
WeakReference(MyObject); System.out.println(myObjectRef.get()); <em>//
This will print the object reference address</em> System.gc();</p>
<p><em>System.out.println(myObjectRef.get());</em> // This will print
'null' if the GC cleaned up the object</p>
<p>3. Soft Reference</p>
<p>Soft references are slightly stronger than weak references. You can
create a soft referenced object as following:</p>
<p>SoftReference myObjectRef = <strong>new</strong>
SoftReference(MyObject);</p>
<p>They can hold onto the memory more strongly than the weak reference.
If you have enough memory supply/resources, garbage collector will not
clean the soft references as enthusiastically as weak references.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 320</p>
<p>Soft references are handy to use in caching. You can create soft
referenced objects as a cache, where they kept until your memory runs
out. When your memory can't supply enough resources, garbage collector
will remove soft</p>
<p>references.</p>
<p>SoftReference myObjectRef = <strong>new</strong>
SoftReference(MyObject); System.out.println(myObjectRef.get()); <em>//
This will print the reference address of the Object</em>
System.gc();</p>
<p><em>System.out.println(myObjectRef.get());</em> // This may or may
not print the reference address of the Object</p>
<p>4. Phantom Reference</p>
<p>This is the weakest referencing type. If you created an object
reference using Phantom Reference, the get() method will always return
null!</p>
<p>The use of this referencing is that "Phantom reference objects, which
are enqueued after the collector determines that their referents may
otherwise be reclaimed. Phantom references are most often used for
scheduling pre-</p>
<p>mortem cleanup actions in a more flexible way than is possible with
the Java finalization mechanism." - From</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html">Phantom
Reference Javadoc</a> from Oracle.</p>
<p>You can create an object of Phantom Reference as following:</p>
<p>PhantomReference myObjectRef = <strong>new</strong>
PhantomReference(MyObject);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 321</p>
<p><span id="Chapter_56__Console_I_O_1" class="anchor"></span>Chapter
56: Console I/O</p>
<p>Section 56.1: Reading user input from the console</p>
<p>Using BufferedReader:</p>
<p>System.out.println("Please type your name and press Enter.");</p>
<p>BufferedReader reader = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(System.in));
<strong>try</strong> {</p>
<p>String name = reader.readLine();</p>
<p>System.out.println("Hello, " + name + "!");</p>
<p>} <strong>catch</strong>(IOException e) {</p>
<p>System.out.println("An error occurred: " + e.getMessage());</p>
<p>}</p>
<p>The following imports are needed for this code:</p>
<p><strong>import</strong> java.io.BufferedReader;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.InputStreamReader;</p>
<p>Using Scanner:</p>
<p>Version ≥ Java SE 5</p>
<p>System.out.println("Please type your name and press Enter");</p>
<p>Scanner scanner = <strong>new</strong> Scanner(System.in);</p>
<p>String name = scanner.nextLine();</p>
<p>System.out.println("Hello, " + name + "!");</p>
<p>The following import is needed for this example:</p>
<p><strong>import</strong> java.util.Scanner;</p>
<p>To read more than one line, invoke scanner.nextLine() repeatedly:</p>
<p>System.out.println("Please enter your first and your last name, on
separate lines.");</p>
<p>Scanner scanner = <strong>new</strong> Scanner(System.in);</p>
<p>String firstName = scanner.nextLine();</p>
<p>String lastName = scanner.nextLine();</p>
<p>System.out.println("Hello, " + firstName + " " + lastName + "!");</p>
<p>There are two methods for obtaining Strings, next() and nextLine().
next() returns text up until the first space</p>
<p>(also known as a "token"), and nextLine() returns all text that the
user inputted until pressing enter.</p>
<p>Scanner also provides utility methods for reading data types other
than String. These include:</p>
<p>scanner.nextByte();</p>
<p>scanner.nextShort();</p>
<p>scanner.nextInt();</p>
<p>scanner.nextLong();</p>
<p>scanner.nextFloat();</p>
<p>scanner.nextDouble();</p>
<p>scanner.nextBigInteger();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 322</p>
<p><span id="scanner_nextBigDecimal"
class="anchor"></span>scanner.nextBigDecimal();</p>
<p>Prefixing any of these methods with has (as in hasNextLine(),
hasNextInt()) returns <strong>true</strong> if the stream has any more
of the request type. Note: These methods will crash the program if the
input is not of the requested type (for</p>
<p>example, typing "a" for nextInt() ). You can use a
<strong>try</strong> {} <strong>catch</strong>() {} to prevent this
(see: Exceptions)</p>
<p>Scanner scanner = <strong>new</strong> Scanner(System.in);
<em>//Create the scanner</em> scanner.useLocale(Locale.US); <em>//Set
number format excepted</em> System.out.println("Please input a float,
decimal separator is ."); <strong>if</strong> (scanner.hasNextFloat()){
<em>//Check if it is a float</em></p>
<p><strong>float</strong> fValue = scanner.nextFloat(); <em>//retrive
the value directly as float</em> System.out.println(fValue + " is a
float");</p>
<p><strong>}</strong>else<strong>{</strong></p>
<p>String sValue = scanner.next(); <em>//We can not retrive as
float</em> System.out.println(sValue + " is not a float");</p>
<p>}</p>
<p>Using System.console:</p>
<p>Version ≥ Java SE 6</p>
<p>String name = System.console().readLine("Please type your name and
press Enter%n");</p>
<p>System.out.printf("Hello, %s!", name);</p>
<p>//To read passwords (without echoing as in unix terminal)
<em><strong>char</strong>[] password =
System.console().readPassword();</em></p>
<p>Advantages<strong>:</strong></p>
<p>Reading methods are synchronized</p>
<p>Format string syntax can be used</p>
<p><strong>Note</strong>: This will only work if the program is run from
a real command line without redirecting the standard input and</p>
<p>output streams. It does not work when the program is run from within
certain IDEs, such as Eclipse. For code that</p>
<p>works within IDEs and with stream redirection, see the other
examples.</p>
<p>Section 56.2: Aligning strings in console</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#format-java.lang.String-java.lang.Object...-">The
method PrintWriter.format</a> (called through System.out.format) can be
used to print aligned strings in console. The method receives a String
with the format information and a series of objects to format:</p>
<p>String rowsStrings[] = <strong>new</strong> String[] {"1",</p>
<p>"1234",</p>
<p>"1234567",</p>
<p>"123456789"};</p>
<p>String column1Format = "%-3s"; <em>// min 3 characters, left
aligned</em> String column2Format = "%-5.8s"; <em>// min 5 and max 8
characters, left aligned</em> String column3Format = "%6.6s"; <em>//
fixed size 6 characters, right aligned</em> String formatInfo =
column1Format + " " + column2Format + " " + column3Format;</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt;
rowsStrings.length; i++) {</p>
<p>System.out.format(formatInfo, rowsStrings[i], rowsStrings[i],
rowsStrings[i]); System.out.println();</p>
<p>}</p>
<p>Output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 323</p>
<p><span id="1____1___________1" class="anchor"></span>1 1 1</p>
<p>1234 1234 1234</p>
<p>1234567 1234567 123456</p>
<p>123456789 12345678 123456</p>
<p>Using format strings with fixed size permits to print the strings in
a table-like appearance with fixed size columns:</p>
<p>String rowsStrings[] = <strong>new</strong> String[] {"1",</p>
<p>"1234",</p>
<p>"1234567",</p>
<p>"123456789"};</p>
<p>String column1Format = "%-3.3s"; <em>// fixed size 3 characters, left
aligned</em> String column2Format = "%-8.8s"; <em>// fixed size 8
characters, left aligned</em> String column3Format = "%6.6s"; <em>//
fixed size 6 characters, right aligned</em> String formatInfo =
column1Format + " " + column2Format + " " + column3Format;</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt;
rowsStrings.length; i++) {</p>
<p>System.out.format(formatInfo, rowsStrings[i], rowsStrings[i],
rowsStrings[i]); System.out.println();</p>
<p>}</p>
<p>Output:</p>
<p>1 1 1</p>
<p>123 1234 1234</p>
<p>123 1234567 123456</p>
<p>123 12345678 123456</p>
<p>Format strings examples</p>
<p>%s: just a string with no formatting</p>
<p>%5s: format the string with a <strong>minimum</strong> of 5
characters; if the string is shorter it will be <strong>padded</strong>
to 5</p>
<p>characters and <strong>right</strong> aligned</p>
<p>%-5s: format the string with a <strong>minimum</strong> of 5
characters; if the string is shorter it will be <strong>padded</strong>
to 5</p>
<p>characters and <strong>left</strong> aligned</p>
<p>%5.10s : format the string with a <strong>minimum</strong> of 5
characters and a <strong>maximum</strong> of 10 characters; if the
string is</p>
<p>shorter than 5 it will be <strong>padded</strong> to 5 characters and
<strong>right</strong> aligned; if the string is longer than 10 it will
be</p>
<p><strong>truncated</strong> to 10 characters and
<strong>right</strong> aligned</p>
<p>%-5.5s: format the string with a <strong>fixed</strong> size of 5
characters (minimum and maximum are equals); if the string</p>
<p>is shorter than 5 it will be <strong>padded</strong> to 5 characters
and <strong>left</strong> aligned; if the string is longer than 5 it
will be</p>
<p><strong>truncated</strong> to 5 characters and <strong>left</strong>
aligned</p>
<p>Section 56.3: Implementing Basic Command-Line Behavior</p>
<p>For basic prototypes or basic command-line behavior, the following
loop comes in handy.</p>
<p><strong>public class</strong> ExampleCli {</p>
<p><strong>private static final</strong> String CLI_LINE =
"example-cli&gt;"; <em>//console like string</em></p>
<p><em><strong>private static final</strong> String CMD_QUIT =
"quit";</em> //string for exiting the program <em><strong>private static
final</strong> String CMD_HELLO = "hello";</em> //string for printing
"Hello World!" on</p>
<p>the screen</p>
<p><em><strong>private static final</strong> String CMD_ANSWER =
"answer";</em> //string for printing 42 on the screen</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 324</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExampleCli claimCli = <strong>new</strong> ExampleCli(); <em>//
creates an object of this class</em></p>
<p>try <strong>{</strong></p>
<p><em>claimCli.start();</em> //calls the start function to do the work
like console</p>
<p>}</p>
<p><strong>catch</strong> (IOException e) {</p>
<p><em>e.printStackTrace();</em> //prints the exception log if it is
failed to do get the user</p>
<p>input or something like that</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> start() <strong>throws</strong>
IOException {</p>
<p>String cmd = "";</p>
<p>BufferedReader reader = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(System.in));
<strong>while</strong> (!cmd.equals(CMD_QUIT)) { <em>// terminates
console if user input is "quit"</em></p>
<p><em>System.out.print(CLI_LINE);</em> //prints the console-like
string</p>
<p><em>cmd = reader.readLine();</em> //takes input from user. user input
should be started with</p>
<p>"hello", "answer" or "quit"</p>
<p>String[] cmdArr = cmd.split(" ");</p>
<p><em><strong>if</strong> (cmdArr[0].equals(CMD_HELLO)) {</em>
//executes when user input starts with "hello"</p>
<p>hello(cmdArr);</p>
<p>}</p>
<p><em><strong>else if</strong> (cmdArr[0].equals(CMD_ANSWER)) {</em>
//executes when user input starts with</p>
<p>"answer"</p>
<p>answer(cmdArr);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// prints "Hello World!" on the screen if user input starts with
"hello" <em><strong>private void</strong> hello(String[] cmdArr)
{</em></p>
<p>System.out.println("Hello World!");</p>
<p>}</p>
<p>// prints "42" on the screen if user input starts with "answer"
<em><strong>private void</strong> answer(String[] cmdArr) {</em></p>
<p>System.out.println("42");</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 325</p>
<p><span id="Chapter_57__Streams_1" class="anchor"></span>Chapter 57:
Streams</p>
<p>A Stream represents a sequence of elements and supports different
kind of operations to perform computations</p>
<p>upon those elements. With Java 8, Collection interface has two
methods to generate a Stream: stream() and parallelStream(). Stream
operations are either intermediate or terminal. Intermediate operations
return a Stream</p>
<p>so multiple intermediate operations can be chained before the Stream
is closed. Terminal operations are either void or return a non-stream
result.</p>
<p>Section 57.1: Using Streams</p>
<p>A <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream
is a sequence of elements upon which sequential and parallel aggregate
operations can be performed.</a> Any given Stream can potentially have
an unlimited amount of data flowing through it. As a result, data
received</p>
<p>from a Stream is processed individually as it arrives, as opposed to
performing batch processing on the data altogether. When combined with
lambda expressions they provide a concise way to perform operations
on</p>
<p>sequences of data using a functional approach.</p>
<p><strong>Example:</strong> (<a href="https://ideone.com/IUWRdv">see it
work on Ideone</a>)</p>
<p>Stream fruitStream = Stream.of("apple", "banana", "pear", "kiwi",
"orange");</p>
<p>fruitStream.filter(s -&gt; s.contains("a"))</p>
<p>.map(String::toUpperCase)</p>
<p>.sorted()</p>
<p>.<strong>forEach</strong>(System.out::println);</p>
<p>Output:</p>
<p>APPLE</p>
<p>BANANA</p>
<p>ORANGE</p>
<p>PEAR</p>
<p>The operations performed by the above code can be summarized as
follows:</p>
<p>1. Create a Stream <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">containing
a sequenced ordered Stream of fruit</a> String elements using the
static</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#of-T...-">factory
method Stream.of(values).</a></p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-">The
filter()</a> operation retains only elements that match a given
predicate (the elements that when tested</p>
<p>by the predicate return true). In this case, it retains the elements
containing an "a". The predicate is given as</p>
<p>a lambda expression.</p>
<p>3. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-">The
map() operation transforms each element using a given function, called a
mapper. In this case, each fruit</a></p>
<p>String is mapped to its uppercase String version using the <a
href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">method-reference</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--">String::toUppercase.</a></p>
<p><strong>Note</strong> that the map() operation will return a stream
with a different generic type if the mapping</p>
<p>function returns a type different to its input parameter. For example
on a Stream calling .map(String::isEmpty) returns a Stream</p>
<p>4. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted--">The
sorted()</a> operation sorts the elements of the Stream according to
their natural ordering</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 326</p>
<p>(lexicographically, in the case of String).</p>
<p>5. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-">Finally,
the <strong>forEach</strong>(action) operation performs an action which
acts on each element of the</a> Stream,</p>
<p>passing it to a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-">Consumer.
In the example, each element is simply being printed to the console.
This operation</a></p>
<p>is a terminal operation, thus making it impossible to operate on it
again.</p>
<p><strong>Note</strong> that operations defined on the Stream are
performed <em>because</em> of the terminal operation.</p>
<p>Without a terminal operation, the stream is not processed. Streams
can not be reused. Once a terminal operation is called, the Stream
object becomes unusable.</p>
<p><img src="media/index-351_1.jpeg"
style="width:6.5in;height:1.27778in" alt="index-351_1.jpg" /></p>
<p>Operations (as seen above) are chained together to form what can be
seen as a query on the data.</p>
<p>Closing Streams</p>
<p>Note that a Stream generally does not have to be closed. <strong>It
is only required to close streams that</strong></p>
<p>operate on IO channels. Most Stream types don't operate on resources
and therefore don't require</p>
<p>closing.</p>
<p>The Stream interface extends <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html">AutoCloseable</a><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html#close--">.
Streams can be closed by calling the close method or by using
try-</a>with-resource statements.</p>
<p>An example use case where a Stream should be closed is when you
create a Stream of lines from a file:</p>
<p><strong>try</strong> (Stream lines =
Files.lines(Paths.get("somePath"))) {</p>
<p>lines.<strong>forEach</strong>(System.out::println);</p>
<p>}</p>
<p>The Stream <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#onClose-java.lang.Runnable-">interface
also declares the Stream.onClose() method which allows you to
register</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>
handlers which will be called when the stream is closed. An example use
case is where code which produces a stream needs</p>
<p>to know when it is consumed to perform some cleanup.</p>
<p><strong>public</strong> StreamstreamAndDelete(Path path)
<strong>throws</strong> IOException {</p>
<p><strong>return</strong> Files.lines(path).onClose(()-&gt;
someClass.deletePath(path));</p>
<p>}</p>
<p>The run handler will only execute if the close() method gets called,
either explicitly or implicitly by a try-with-</p>
<p>resources statement.</p>
<p>Processing Order</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 327</p>
<p><span id="A_Stream_object_s_processing_can" class="anchor"></span>A
Stream object's processing can be sequential or parallel.</p>
<p>In a <strong>sequential</strong> mode, the elements are processed in
the order of the source of the Stream. If the Stream is ordered</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">(such
as a SortedMap</a> implementation or a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>)
the processing is guaranteed to match the ordering of the source.</p>
<p><a href="http://stackoverflow.com/q/1882762/1667004">In other cases,
however, care should be taken not to depend on the ordering (see: is the
Java HashMap keySet()</a></p>
<p><a href="http://stackoverflow.com/q/1882762/1667004">iteration order
consistent?).</a></p>
<p>Example:</p>
<p>List integerList = Arrays.asList(0, 1, 2, 3, 42);</p>
<p>// sequential</p>
<p><strong>long</strong> howManyOddNumbers = integerList.stream()</p>
<p>.filter(e -&gt; (e % 2) == 1)</p>
<p>.count();</p>
<p>System.out.println(howManyOddNumbers); <em>// Output: 2</em></p>
<p><a href="https://ideone.com/FuMz1c">Live on Ideone</a></p>
<p><strong>Parallel</strong> mode allows the use of multiple threads on
multiple cores but there is no guarantee of the order in which</p>
<p>elements are processed.</p>
<p>If multiple methods are called on a sequential Stream, not every
method has to be invoked. For example, if a Stream is filtered and the
number of elements is reduced to one, a subsequent call to a method such
as sort will not occur.</p>
<p>This can increase the performance of a sequential Stream — an
optimization that is not possible with a parallel</p>
<p>Stream .</p>
<p>Example:</p>
<p>// parallel</p>
<p><strong>long</strong> howManyOddNumbersParallel =
integerList.parallelStream()</p>
<p>.filter(e -&gt; (e % 2) == 1)</p>
<p>.count();</p>
<p>System.out.println(howManyOddNumbersParallel); <em>// Output:
2</em></p>
<p><a href="https://ideone.com/FuMz1c">Live on Ideone</a></p>
<p>Differences from Containers (or Collections)</p>
<p>While some actions can be performed on both Containers and Streams,
they ultimately serve different purposes</p>
<p>and support different operations. Containers are more focused on how
the elements are stored and how those elements can be accessed
efficiently. A Stream, on the other hand, doesn't provide direct access
and manipulation</p>
<p>to its elements; it is more dedicated to the group of objects as a
collective entity and performing operations on that entity as a whole.
Stream and Collection are separate high-level abstractions for these
differing purposes.</p>
<p>Section 57.2: Consuming Streams</p>
<p>A <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream
will only be traversed when there is a</a> <em>terminal operation</em>,
like <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--">count()</a>,
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-">collect()
or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-"><strong>forEach</strong>().
Otherwise,</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">no
operation on the Stream will be performed.</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">In
the following example, no terminal operation is added to the Stream, so
the</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-">filter()</a>
operation will not be</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-">invoked
and no output will be produced because peek() is NOT a</a> <em>terminal
operation</em>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 328</p>
<p>IntStream.range(1, 10).filter(a -&gt; a % 2 ==
0).peek(System.out::println);</p>
<p><a href="https://ideone.com/YDijRj">Live on Ideone</a></p>
<p>This is a Stream sequence with a valid <em>terminal operation</em>,
thus an output is produced.</p>
<p>You could also use <strong>forEach</strong> instead of peek:</p>
<p>IntStream.range(1, 10).filter(a -&gt; a % 2 ==
0).<strong>forEach</strong>(System.out::println);</p>
<p><a href="https://ideone.com/LzUoM6">Live on Ideone</a></p>
<p>Output:</p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>After the terminal operation is performed, the Stream is consumed and
cannot be reused.</p>
<p>Although a given stream object cannot be reused, it's easy to create
a reusable Iterable that delegates to a stream pipeline. This can be
useful for returning a modified view of a live data set without having
to collect results into a</p>
<p>temporary structure.</p>
<p>List list = Arrays.asList("FOO", "BAR");</p>
<p>Iterable iterable = ()-&gt;
list.stream().map(String::toLowerCase).iterator();</p>
<p><strong>for</strong> (String str : iterable) {</p>
<p>System.out.println(str);</p>
<p>}</p>
<p><strong>for</strong> (String str : iterable) {</p>
<p>System.out.println(str);</p>
<p>}</p>
<p>Output:</p>
<p>foo</p>
<p>bar</p>
<p>foo</p>
<p>bar</p>
<p>This works because Iterable declares a single abstract method
Iterator iterator(). That makes it effectively</p>
<p>a functional interface, implemented by a lambda that creates a new
stream on each call.</p>
<p>In general, a Stream operates as shown in the following image:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 329</p>
<p><span id="page_354" class="anchor"></span><img
src="media/index-354_1.jpeg" style="width:4.06944in;height:1.31944in"
alt="index-354_1.jpg" /></p>
<p><strong>NOTE</strong>: Argument checks are always performed, even
without a <em>terminal operation</em>:</p>
<p>try <strong>{</strong></p>
<p>IntStream.range(1, 10).filter(<strong>null</strong>);</p>
<p>} <strong>catch</strong> (NullPointerException e) {</p>
<p>System.out.println("We got a NullPointerException as null was passed
as an argument to</p>
<p>filter()");</p>
<p>}</p>
<p><a href="https://ideone.com/zrkoRz">Live on Ideone</a></p>
<p>Output:</p>
<p>We got a NullPointerException as null was passed as an argument to
filter()</p>
<p>Section 57.3: Creating a Frequency Map</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-">The
groupingBy(classifier, downstream) collector allows the collection
of</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">elements
into a Map</a> by</p>
<p>classifying each element in a group and performing a downstream
operation on the elements classified in the same group.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">A
classic example of this principle is to use a Map</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">to
count the occurrences of elements in a Stream. In this example,</a> the
classifier is simply the identity function, which returns the element
as-is. The downstream operation counts the</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#counting--">number
of equal elements, using counting()</a>.</p>
<p>Stream.of("apple", "orange", "banana", "apple")</p>
<p>.collect(Collectors.groupingBy(Function.identity(),
Collectors.counting()))</p>
<p>.entrySet()</p>
<p>.<strong>forEach</strong>(System.out::println);</p>
<p>The downstream operation is itself a collector (<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#counting--">Collectors.counting())
that operates on elements of type String</a> and produces a result of
type Long. The result of the collect method call is a Map.</p>
<p>This would produce the following output:</p>
<p>banana=1</p>
<p>orange=1</p>
<p>apple=2</p>
<p>Section 57.4: Infinite Streams</p>
<p>It is possible to generate a Stream that does not end. Calling a
terminal method on an infinite Stream causes the</p>
<p>Stream <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#limit-long-">to
enter an infinite loop. The limit method of a</a> Stream can be used to
limit the number of terms of the Stream that Java processes.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 330</p>
<p><span id="This_example_generates_a_Stream" class="anchor"></span>This
example generates a Stream of all natural numbers, starting with the
number 1. Each successive term of the Stream is one higher than the
previous. By calling the limit method of this Stream, only the first
five terms of the</p>
<p>Stream are considered and printed.</p>
<p><em>// Generate infinite stream - 1, 2, 3, 4, 5, 6, 7, ...</em>
IntStream naturalNumbers = IntStream.iterate(1, x -&gt; x + 1);</p>
<p>// Print out only the first 5 terms</p>
<p>naturalNumbers.limit(5).<strong>forEach</strong>(System.out::println);</p>
<p>Output:</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#generate-java.util.function.Supplier-">Another
way of generating an infinite stream is using the Stream.generate
method. This method takes a lambda of</a></p>
<p>type <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier.</a></p>
<p>// Generate an infinite stream of random numbers</p>
<p>Stream infiniteRandomNumbers = Stream.generate(Math::random);</p>
<p>// Print out only the first 10 random numbers</p>
<p>infiniteRandomNumbers.limit(10).<strong>forEach</strong>(System.out::println);</p>
<p>Section 57.5: Collect Elements of a Stream into a Collection</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--">Collect
with toList() and</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toSet--">toSet()</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Elements
from a Stream can be easily collected into a container by using the</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-">Stream.collect</a>
operation:</p>
<p>System.out.println(Arrays</p>
<p>.asList("apple", "banana", "pear", "kiwi", "orange")</p>
<p>.stream()</p>
<p>.filter(s -&gt; s.contains("a"))</p>
<p>.collect(Collectors.toList())</p>
<p>);</p>
<p>// prints: [apple, banana, pear, orange]</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Other
collection instances, such as a Set, can be made by using other</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a>
built-in methods. For example,</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toSet--">Collectors.toSet()</a>
collects the elements of a Stream into a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set.</a></p>
<p>Explicit control over the implementation of <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">or
Set</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--">According
to documentation of Collectors#toList()</a> and <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toSet--">Collectors#toSet()</a>,
there are no guarantees on the</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">type,
mutability, serializability, or thread-safety of the List or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set
returned.</a></p>
<p>For explicit control over the implementation to be returned, <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toCollection-java.util.function.Supplier-">Collectors#toCollection(Supplier)</a>
can be used instead, where the given supplier returns a new and empty
collection.</p>
<p>// syntax with method reference</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 331</p>
<p>System.out.println(strings</p>
<p>.stream()</p>
<p>.filter(s -&gt; s != <strong>null</strong> &amp;&amp; s.length()
&lt;= 3)</p>
<p>.collect(Collectors.toCollection(ArrayList::<strong>new</strong>))
);</p>
<p>// syntax with lambda</p>
<p>System.out.println(strings</p>
<p>.stream()</p>
<p>.filter(s -&gt; s != <strong>null</strong> &amp;&amp; s.length()
&lt;= 3)</p>
<p>.collect(Collectors.toCollection(()-&gt; <strong>new</strong>
LinkedHashSet&lt;&gt;())) );</p>
<p>Collecting Elements using <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">toMap</a></p>
<p>Collector accumulates elements into a Map, Where key is the Student
Id and Value is Student Value.</p>
<p>List students = <strong>new</strong> ArrayList();</p>
<p>students.add(<strong>new</strong> Student(1,"test1"));</p>
<p>students.add(<strong>new</strong> Student(2,"test2"));</p>
<p>students.add(<strong>new</strong> Student(3,"test3"));</p>
<p>Map IdToName = students.stream()</p>
<p>.collect(Collectors.toMap(Student::getId, Student::getName));</p>
<p>System.out.println(IdToName);</p>
<p>Output :</p>
<p>{1=test1, 2=test2, 3=test3}</p>
<p>The Collectors.toMap has another implementation Collector&gt;
toMap(Functionsuper T, ? <strong>extends</strong> K&gt; keyMapper,
Functionsuper T, ? <strong>extends</strong> U&gt; valueMapper,
BinaryOperator</p>
<p>mergeFunction).The mergeFunction is mostly used to select either new
value or retain old value if the key is repeated when adding a new
member in the Map from a list.</p>
<p>The mergeFunction often looks like: (s1, s2)-&gt; s1 to retain value
corresponding to the repeated key, or (s1, s2)-&gt; s2 to put new value
for the repeated key.</p>
<p>Collecting Elements to Map of Collections</p>
<p>Example: from ArrayList to Map&gt;</p>
<p>Often it requires to make a map of list out of a primary list.
Example: From a student of list, we need to make a map</p>
<p>of list of subjects for each student.</p>
<p>List list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.MATH,
35.0));</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.SCIENCE,
12.9));</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.GEOGRAPHY,
37.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.ENGLISH,
85.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.MATH,
80.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.SCIENCE,
12.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.LITERATURE,
50.0));</p>
<p>list.add(<strong>new</strong> Student("Robert", SUBJECT.LITERATURE,
12.0));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 332</p>
<p>Map&gt; map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>list.stream().<strong>forEach</strong>(s -&gt; {</p>
<p>map.computeIfAbsent(s.getName(), x -&gt; <strong>new</strong>
ArrayList&lt;&gt;()).add(s.getSubject());</p>
<p>});</p>
<p>System.out.println(map);</p>
<p>Output:</p>
<p>{ Robert=[LITERATURE],</p>
<p>Sascha=[ENGLISH, MATH, SCIENCE, LITERATURE],</p>
<p>Davis=[MATH, SCIENCE, GEOGRAPHY] }</p>
<p>Example: from ArrayList to Map&gt;</p>
<p>List list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.MATH, 1,
35.0));</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.SCIENCE, 2,
12.9));</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.MATH, 3,
37.0));</p>
<p>list.add(<strong>new</strong> Student("Davis", SUBJECT.SCIENCE, 4,
37.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.ENGLISH, 5,
85.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.MATH, 1,
80.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.ENGLISH, 6,
12.0));</p>
<p>list.add(<strong>new</strong> Student("Sascha", SUBJECT.MATH, 3,
50.0));</p>
<p>list.add(<strong>new</strong> Student("Robert", SUBJECT.ENGLISH, 5,
12.0));</p>
<p>Map&gt;&gt; map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>list.stream().<strong>forEach</strong>(student -&gt; {</p>
<p>map.computeIfAbsent(student.getName(), s -&gt; <strong>new</strong>
HashMap&lt;&gt;())</p>
<p>.computeIfAbsent(student.getSubject(), s -&gt; <strong>new</strong>
ArrayList&lt;&gt;())</p>
<p>.add(student.getMarks());</p>
<p>});</p>
<p>System.out.println(map);</p>
<p>Output:</p>
<p>{ Robert={ENGLISH=[12.0]},</p>
<p>Sascha={MATH=[80.0, 50.0], ENGLISH=[85.0, 12.0]},</p>
<p>Davis={MATH=[35.0, 37.0], SCIENCE=[12.9, 37.0]} }</p>
<p>Cheat-Sheet</p>
<p>Goal Code</p>
<p>Collect to a List Collectors.toList()</p>
<p>Collect to an ArrayList with pre- Collectors.toCollection(()-&gt;
<strong>new</strong> ArrayList&lt;&gt;(size)) allocated size</p>
<p>Collect to a Set Collectors.toSet()</p>
<p>Collect to a Set with better iteration
Collectors.toCollection(()-&gt; <strong>new</strong>
LinkedHashSet&lt;&gt;()) performance</p>
<p>Collect to a case-insensitive Collectors.toCollection(()-&gt;
<strong>new</strong> Set
TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER))</p>
<p>Collect to an EnumSet (best Collectors.toCollection(()-&gt;
EnumSet.noneOf(AnEnum.<strong>class</strong>)) performance for
enums)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 333</p>
<p><span id="Collect_to_a_Map_with_unique_key"
class="anchor"></span>Collect to a Map with unique keys
Collectors.toMap(keyFunc,valFunc)</p>
<p>Map MyObject.getter() to unique Collectors.toMap(MyObject::getter,
Function.identity()) MyObject</p>
<p>Map MyObject.getter() to multiple
Collectors.groupingBy(MyObject::getter) MyObjects</p>
<p>Section 57.6: Using Streams to Implement Mathematical</p>
<p>Functions</p>
<p>Stream s, and especially IntStreams, are an elegant way of
implementing summation terms (∑). The ranges of the Stream can be used
as the bounds of the summation.</p>
<p>E.g., Madhava's approximation of Pi is given by the formula (Source:
<a
href="https://en.wikipedia.org/wiki/Approximations_of_%CF%80">wikipedia):</a></p>
<p><img src="media/index-358_1.png" style="width:6in;height:0.52778in"
alt="index-358_1.png" /></p>
<p>This can be calculated with an arbitrary precision. E.g., for 101
terms:</p>
<p><strong>double</strong> pi = Math.sqrt(12) *</p>
<p>IntStream.rangeClosed(0, 100)</p>
<p>.mapToDouble(k -&gt; Math.pow(-3, -1 * k) / (2 * k + 1))</p>
<p>.sum();</p>
<p><strong>Note:</strong> With <strong>double</strong>'s precision,
selecting an upper bound of 29 is sufficient to get a result that's
indistinguishable</p>
<p>from Math.Pi.</p>
<p>Section 57.7: Flatten Streams with flatMap()</p>
<p>A Stream of items that are in turn streamable can be flattened into a
single continuous Stream:</p>
<p>Array of List of Items can be converted into a single List.</p>
<p>List list1 = Arrays.asList("one", "two");</p>
<p>List list2 = Arrays.asList("three","four","five");</p>
<p>List list3 = Arrays.asList("six");</p>
<p>List finalList = Stream.of(list1, list2,
list3).flatMap(Collection::stream).collect(Collectors.toList());
System.out.println(finalList);</p>
<p>// [one, two, three, four, five, six]</p>
<p>Map containing List of Items as values can be Flattened to a Combined
List</p>
<p>Map&gt; map = <strong>new</strong> LinkedHashMap&lt;&gt;();
map.put("a", Arrays.asList(1, 2, 3));</p>
<p>map.put("b", Arrays.asList(4, 5, 6));</p>
<p><em>List allValues = map.values()</em> //
Collection&lt;List&lt;Integer&gt;&gt;</p>
<p><em>.stream()</em> // Stream&lt;List&lt;Integer&gt;&gt;</p>
<p>.flatMap(List::stream) <em>// Stream&lt;Integer&gt;</em></p>
<p>.collect(Collectors.toList());</p>
<p>System.out.println(allValues);</p>
<p>// [1, 2, 3, 4, 5, 6]</p>
<p>List of Map can be flattened into a single continuous Stream</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 334</p>
<p><span id="List__list___new_ArrayList" class="anchor"></span>List&gt;
list = <strong>new</strong> ArrayList&lt;&gt;(); Map map1 =
<strong>new</strong> HashMap();</p>
<p>map1.put("1", "one");</p>
<p>map1.put("2", "two");</p>
<p>Map map2 = <strong>new</strong> HashMap();</p>
<p>map2.put("3", "three");</p>
<p>map2.put("4", "four");</p>
<p>list.add(map1);</p>
<p>list.add(map2);</p>
<p><em>Set output= list.stream()</em> // Stream&lt;Map&lt;String,
String&gt;&gt;</p>
<p><em>.map(Map::values)</em> // Stream&lt;List&lt;String&gt;&gt;</p>
<p>.flatMap(Collection::stream) <em>// Stream&lt;String&gt;</em></p>
<p>.collect(Collectors.toSet()); <em>//Set&lt;String&gt;</em></p>
<p>// [one, two, three,four]</p>
<p>Section 57.8: Parallel Stream</p>
<p><strong>Note:</strong> Before deciding which Stream to use please
have a look at <a
href="http://stackoverflow.com/a/20375622/585398">ParallelStream vs
Sequential Stream behavior.</a></p>
<p>When you want to perform Stream operations concurrently, you could
use either of these ways.</p>
<p>List data = Arrays.asList("One", "Two", "Three", "Four", "Five");
Stream aParallelStream = data.stream().parallel();</p>
<p>Or:</p>
<p>Stream aParallelStream = data.parallelStream();</p>
<p>To execute the operations defined for the parallel stream, call a
terminal operator:</p>
<p>aParallelStream.<strong>forEach</strong>(System.out::println);</p>
<p>(A possible) output from the parallel Stream:</p>
<p>Three</p>
<p>Four</p>
<p>One</p>
<p>Two</p>
<p>Five</p>
<p>The order might change as all the elements are processed in parallel
(Which <em>may</em> make it faster). Use</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">parallelStream
when ordering does not matter.</a></p>
<p>Performance impact</p>
<p>In case networking is involved, parallel Streams may degrade the
overall performance of an application because all parallel Streams use a
common fork-join thread pool for the network.</p>
<p>On the other hand, parallel Streams may significantly improve
performance in many other cases, depending of the number of available
cores in the running CPU at the moment.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 335</p>
<p><span id="Section_57_9__Creating_a_Stream"
class="anchor"></span>Section 57.9: Creating a Stream</p>
<p>All java Collection<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--">s
have stream() and</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">parallelStream()</a>
methods from which a Stream can be</p>
<p>constructed:</p>
<p>Collection stringList = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>Stream stringStream = stringList.parallelStream();</p>
<p>A Stream can be created from an array using one of two methods:</p>
<p>String[] values = { "aaa", "bbbb", "ddd", "cccc" };</p>
<p>Stream stringStream = Arrays.stream(values); Stream
stringStreamAlternative = Stream.of(values);</p>
<p>The difference between <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-T:A-">Arrays.stream()</a>
and <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#of-T...-">Stream.of()
is that</a> Stream.of() has a varargs parameter, so it can</p>
<p>be used like:</p>
<p>Stream integerStream = Stream.of(1, 2, 3);</p>
<p>There are also primitive Streams that you can use. For example:</p>
<p>IntStream intStream = IntStream.of(1, 2, 3);</p>
<p>DoubleStream doubleStream = DoubleStream.of(1.0, 2.0, 3.0);</p>
<p>These primitive streams can also be constructed using the
Arrays.stream() method:</p>
<p>IntStream intStream = Arrays.stream(<strong>new int</strong>[]{ 1, 2,
3 });</p>
<p>It is possible to create a Stream from an array with a specified
range.</p>
<p><strong>int</strong>[] values= <strong>new int</strong>[]{1, 2, 3, 4,
5};</p>
<p>IntStream intStram = Arrays.stream(values, 1, 3);</p>
<p>Note that any primitive stream can be converted to boxed type stream
using the boxed method :</p>
<p>Stream integerStream = intStream.boxed();</p>
<p>This can be useful in some case if you want to collect the data since
primitive stream does not have any collect</p>
<p>method that takes a Collector as argument.</p>
<p>Reusing intermediate operations of a stream chain</p>
<p>Stream is closed when ever terminal operation is called. Reusing the
stream of intermediate operations, when only</p>
<p>terminal operation is only varying. we could create a stream supplier
to construct a new stream with all intermediate operations already set
up.</p>
<p>Supplier&gt; streamSupplier = ()-&gt; Stream.of("apple",
"banana","orange", "grapes", "melon","blueberry","blackberry")</p>
<p>.map(String::toUpperCase).sorted();</p>
<p>streamSupplier.get().filter(s -&gt;
s.startsWith("A")).<strong>forEach</strong>(System.out::println);</p>
<p>// APPLE</p>
<p>streamSupplier.get().filter(s -&gt;
s.startsWith("B")).<strong>forEach</strong>(System.out::println);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 336</p>
<p><span id="___BANANA" class="anchor"></span>// BANANA</p>
<p>// BLACKBERRY</p>
<p>// BLUEBERRY</p>
<p><strong>int</strong>[] arrays can be converted to List using
streams</p>
<p><strong>int</strong>[] ints = {1,2,3};</p>
<p>List list =
IntStream.of(ints).boxed().collect(Collectors.toList());</p>
<p>Section 57.10: Finding Statistics about Numerical Streams</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/IntSummaryStatistics.html">Java
8 provides classes called IntSummaryStatistics</a>, <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/DoubleSummaryStatistics.html">DoubleSummaryStatistics
and</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LongSummaryStatistics.html">LongSummaryStatistics</a></p>
<p>which give a state object for collecting statistics such as count,
min, max, sum, and average.</p>
<p>Version ≥ Java SE 8</p>
<p>List naturalNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
IntSummaryStatistics stats = naturalNumbers.stream()</p>
<p>.mapToInt((x)-&gt; x)</p>
<p>.summaryStatistics();</p>
<p>System.out.println(stats);</p>
<p>Which will result in:</p>
<p>Version ≥ Java SE 8</p>
<p>IntSummaryStatistics{count=10, sum=55, min=1, max=10,
average=5.500000}</p>
<p>Section 57.11: Converting an iterator to a stream</p>
<p>Use Spliterators.spliterator() or
Spliterators.spliteratorUnknownSize() to convert an iterator to a
stream:</p>
<p>Iterator iterator = Arrays.asList("A", "B", "C").iterator();
Spliterator spliterator = Spliterators.spliteratorUnknownSize(iterator,
0); Stream stream = StreamSupport.stream(spliterator,
<strong>false</strong>);</p>
<p>Section 57.12: Using IntStream to iterate over indexes</p>
<p>Stream s of elements usually do not allow access to the index value
of the current item. To iterate over an array or ArrayList while having
access to indexes, use IntStream.range(start, endExclusive).</p>
<p>String[] names = { "Jon", "Darin", "Bauke", "Hans", "Marc" };</p>
<p>IntStream.range(0, names.length)</p>
<p>.mapToObj(i -&gt; String.format("#%d %s", i + 1, names[i]))</p>
<p>.<strong>forEach</strong>(System.out::println);</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#range-int-int-">The
range(start, endExclusive) method returns another</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">ÌntStream</a>
and the <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#mapToObj-java.util.function.IntFunction-">mapToObj(mapper)</a>
returns a stream</p>
<p>of String.</p>
<p>Output:</p>
<p>#1 Jon</p>
<p>#2 Darin</p>
<p>#3 Bauke</p>
<p>#4 Hans</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 337</p>
<p><span id="_5_Marc" class="anchor"></span>#5 Marc</p>
<p>This is very similar to using a normal <strong>for</strong> loop with
a counter, but with the benefit of pipelining and parallelization:</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
names.length; i++) {</p>
<p>String newName = String.format("#%d %s", i + 1, names[i]);
System.out.println(newName);</p>
<p>}</p>
<p>Section 57.13: Concatenate Streams</p>
<p>Variable declaration for examples:</p>
<p>Collection abc = Arrays.asList("a", "b", "c"); Collection digits =
Arrays.asList("1", "2", "3"); Collection greekAbc =
Arrays.asList("alpha", "beta", "gamma");</p>
<p>Example 1 - Concatenate two Streams</p>
<p><strong>final</strong> Stream concat1 = Stream.concat(abc.stream(),
digits.stream());</p>
<p>concat1.<strong>forEach</strong>(System.out::print);</p>
<p>// prints: abc123</p>
<p>Example 2 - Concatenate more than two Streams</p>
<p><strong>final</strong> Stream concat2 = Stream.concat(</p>
<p>Stream.concat(abc.stream(), digits.stream()),</p>
<p>greekAbc.stream());</p>
<p>System.out.println(concat2.collect(Collectors.joining(", "))); <em>//
prints: a, b, c, 1, 2, 3, alpha, beta, gamma</em></p>
<p>Alternatively to simplify the nested concat() syntax the Streams can
also be concatenated with flatMap():</p>
<p><strong>final</strong> Stream concat3 = Stream.of(</p>
<p>abc.stream(), digits.stream(), greekAbc.stream())</p>
<p>.flatMap(s -&gt; s);</p>
<p>// or `.flatMap(Function.identity());`
(java.util.function.Function)</p>
<p>System.out.println(concat3.collect(Collectors.joining(", "))); <em>//
prints: a, b, c, 1, 2, 3, alpha, beta, gamma</em></p>
<p>Be careful when constructing Streams from repeated concatenation,
because accessing an element of a deeply concatenated Stream can result
in deep call chains or even a StackOverflowException.</p>
<p>Section 57.14: Reduction with Streams</p>
<p>Reduction is the process of applying a binary operator to every
element of a stream to result in one value.</p>
<p>The sum() method of an IntStream is an example of a reduction; it
applies addition to every term of the Stream,</p>
<p>resulting in one final value:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 338</p>
<p><img src="media/index-363_1.jpeg"
style="width:6.40278in;height:7.69444in" alt="index-363_1.jpg" /></p>
<p>This is equivalent to (((1+2)+3)+4)</p>
<p>The reduce method of a Stream allows one to create a custom
reduction. It is possible to use the reduce method to implement the
sum() method:</p>
<p>IntStream istr;</p>
<p>//Initialize istr</p>
<p>OptionalInt istr.reduce((a,b)-&gt;a+b);</p>
<p>The Optional version is returned so that empty Streams can be handled
appropriately.</p>
<p>Another example of reduction is combining a Stream&gt; into a single
LinkedList:</p>
<p>Stream&gt; listStream;</p>
<p>//Create a Stream&lt;LinkedList&lt;T&gt;&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 339</p>
<p>Optional&gt; bigList = listStream.reduce((LinkedList list1,
LinkedList list2)-&gt;{</p>
<p>LinkedList retList = <strong>new</strong> LinkedList();</p>
<p>retList.addAll(list1);</p>
<p>retList.addAll(list2);</p>
<p><strong>return</strong> retList;</p>
<p>});</p>
<p>You can also provide an <em>identity element</em>. For example, the
identity element for addition is 0, as x+0==x. For multiplication, the
identity element is 1, as x*1==x. In the case above, the identity
element is an empty</p>
<p>LinkedList, because if you add an empty list to another list, the
list that you are "adding" to doesn't change:</p>
<p>Stream&gt; listStream;</p>
<p>//Create a Stream&lt;LinkedList&lt;T&gt;&gt;</p>
<p>LinkedList bigList = listStream.reduce(<strong>new</strong>
LinkedList(), (LinkedList list1, LinkedList list2)-&gt;{</p>
<p>LinkedList retList = <strong>new</strong> LinkedList();</p>
<p>retList.addAll(list1);</p>
<p>retList.addAll(list2);</p>
<p><strong>return</strong> retList;</p>
<p>});</p>
<p>Note that when an identity element is provided, the return value is
not wrapped in an Optional—if called on an empty stream, reduce() will
return the identity element.</p>
<p>The binary operator must also be <em>associative</em>, meaning that
(a+b)+c==a+(b+c). This is because the elements may be reduced in any
order. For example, the above addition reduction could be performed like
this:</p>
<p><img src="media/index-364_1.jpeg"
style="width:6.5in;height:5.61111in" alt="index-364_1.jpg" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 340</p>
<p><span id="This_reduction_is_equivalent_to" class="anchor"></span>This
reduction is equivalent to writing ((1+2)+(3+4)). The property of
associativity also allows Java to reduce the</p>
<p>Stream in parallel—a portion of the Stream can be reduced by each
processor, with a reduction combining the result of each processor at
the end.</p>
<p>Section 57.15: Using Streams of Map.Entry to Preserve Initial</p>
<p>Values after Mapping</p>
<p>When you have a Stream you need to map but want to preserve the
initial values as well, you can map the Stream to</p>
<p>a Map.Entry using a utility method like the following:</p>
<p><strong>public static</strong> Function&gt; entryMapper(Function
mapper){</p>
<p><strong>return</strong> (k)-&gt;<strong>new</strong>
AbstractMap.SimpleEntry&lt;&gt;(k, mapper.apply(k));</p>
<p>}</p>
<p>Then you can use your converter to process Streams having access to
both the original and mapped values:</p>
<p>Set mySet;</p>
<p>Function transformer = SomeClass::transformerMethod; Stream&gt;
entryStream = mySet.stream()</p>
<p>.map(entryMapper(transformer));</p>
<p>You can then continue to process that Stream as normal. This avoids
the overhead of creating an intermediate collection.</p>
<p>Section 57.16: IntStream to String</p>
<p>Java does not have a <em>Char Stream</em>, so when working with
Strings and constructing a Stream of Characters, an</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">option
is to get a IntStream</a> of code points using String.codePoints()
method. So IntStream can be obtained as</p>
<p>below:</p>
<p><strong>public</strong> IntStream stringToIntStream(String in) {</p>
<p><strong>return</strong> in.codePoints();</p>
<p>}</p>
<p>It is a bit more involved to do the conversion other way around i.e.
IntStreamToString. That can be done as follows:</p>
<p><strong>public</strong> String intStreamToString(IntStream intStream)
{</p>
<p><strong>return</strong>
intStream.collect(StringBuilder::<strong>new</strong>,
StringBuilder::appendCodePoint,</p>
<p>StringBuilder::append).toString();</p>
<p>}</p>
<p>Section 57.17: Finding the First Element that Matches a</p>
<p>Predicate</p>
<p>It is possible to find the first element of a Stream that matches a
condition.</p>
<p>For this example, we will find the first Integer whose square is over
50000.</p>
<p><em>IntStream.iterate(1, i -&gt; i + 1)</em> // Generate an infinite
stream 1,2,3,4...</p>
<p><em>.filter(i -&gt; (i*i) &gt; 50000)</em> // Filter to find elements
where the square is &gt;50000</p>
<p><em>.findFirst();</em> // Find the first filtered element</p>
<p>This expression will return an OptionalInt with the result.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 341</p>
<p><span id="Note_that_with_an_infinite_Strea"
class="anchor"></span>Note that with an infinite Stream, Java will keep
checking each element until it finds a result. With a finite Stream, if
Java runs out of elements but still can't find a result, it returns an
empty OptionalInt.</p>
<p>Section 57.18: Using Streams and Method References to Write</p>
<p>Self-Documenting Processes</p>
<p>Method references make excellent self-documenting code, and using
method references with Streams makes</p>
<p>complicated processes simple to read and understand. Consider the
following code:</p>
<p>public interface <strong>Ordered {</strong></p>
<p><strong>default int</strong> getOrder(){</p>
<p>return <strong>0;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public interface</strong> Valuedextends Ordered&gt; {</p>
<p><strong>boolean</strong> hasPropertyTwo();</p>
<p>V getValue();</p>
<p>}</p>
<p><strong>public interface</strong> Thingextends Ordered&gt; {</p>
<p><strong>boolean</strong> hasPropertyOne();</p>
<p>Valued getValuedProperty();</p>
<p>}</p>
<p><strong>public</strong> extends Ordered&gt; List myMethod(List&gt;
things) {</p>
<p>List results = <strong>new</strong> ArrayList();</p>
<p><strong>for</strong> (Thing thing : things) {</p>
<p><strong>if</strong> (thing.hasPropertyOne()) {</p>
<p>Valued valued = thing.getValuedProperty();</p>
<p><strong>if</strong> (valued != <strong>null</strong> &amp;&amp;
valued.hasPropertyTwo()){</p>
<p>V value = valued.getValue();</p>
<p><strong>if</strong> (value != <strong>null</strong>){</p>
<p>results.add(value);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>results.sort((a, b)-&gt;{</p>
<p><strong>return</strong> Integer.compare(a.getOrder(),
b.getOrder());</p>
<p>});</p>
<p><strong>return</strong> results;</p>
<p>}</p>
<p>This last method rewritten using Streams and method references is
much more legible and each step of the process</p>
<p>is quickly and easily understood - it's not just shorter, it also
shows at a glance which interfaces and classes are responsible for the
code in each step:</p>
<p><strong>public</strong> extends Ordered&gt; List myMethod(List&gt;
things) {</p>
<p><strong>return</strong> things.stream()</p>
<p>.filter(Thing::hasPropertyOne)</p>
<p>.map(Thing::getValuedProperty)</p>
<p>.filter(Objects::nonNull)</p>
<p>.filter(Valued::hasPropertyTwo)</p>
<p>.map(Valued::getValue)</p>
<p>.filter(Objects::nonNull)</p>
<p>.sorted(Comparator.comparing(Ordered::getOrder))</p>
<p>.collect(Collectors.toList());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 342</p>
<p><span id="_23" class="anchor"></span>}</p>
<p>Section 57.19: Converting a Stream of Optional to a Stream of</p>
<p>Values</p>
<p>You may need to convert a Stream emitting Optional to a Stream of
values, emitting only values from existing</p>
<p>Optional . (ie: without <strong>null</strong> value and not dealing
with <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#empty--">Optional.empty()</a>).</p>
<p>Optional op1 = Optional.empty();</p>
<p>Optional op2 = Optional.of("Hello World");</p>
<p>List result = Stream.of(op1, op2)</p>
<p>.filter(Optional::isPresent)</p>
<p>.map(Optional::get)</p>
<p>.collect(Collectors.toList());</p>
<p>System.out.println(result); <em>//[Hello World]</em></p>
<p>Section 57.20: Get a Slice of a Stream</p>
<p><strong>Example:</strong> Get a Stream of 30 elements, containing
21st to 50th (inclusive) element of a collection.</p>
<p><em><strong>final long</strong> n = 20L;</em> // the number of
elements to skip <em><strong>final long</strong> maxSize = 30L;</em> //
the number of elements the stream should be limited to
<em><strong>final</strong> Stream slice =
collection.stream().skip(n).limit(maxSize);</em></p>
<p>Notes:</p>
<p>IllegalArgumentException is thrown if n is negative or maxSize is
negative both skip(<strong>long</strong>) and
limit(<strong>long</strong>) are intermediate operations</p>
<p>if a stream contains fewer than n elements then skip(n) returns an
empty stream</p>
<p>both skip(<strong>long</strong>) and limit(<strong>long</strong>) are
cheap operations on sequential stream pipelines, but can be quite
expensive on ordered parallel pipelines</p>
<p>Section 57.21: Create a Map based on a Stream</p>
<p>Simple case without duplicate keys</p>
<p>Stream characters = Stream.of("A", "B", "C");</p>
<p>Map map = characters</p>
<p>.collect(Collectors.toMap(element -&gt; element.hashCode(), element
-&gt; element)); <em>// map = {65=A, 66=B, 67=C}</em></p>
<p>To make things more declarative, we can use static method in Function
interface - <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#identity--">Function.identity().
We can</a></p>
<p>replace this lambda element -&gt; element with
Function.identity().</p>
<p>Case where there might be duplicate keys</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-">The
javadoc for</a> Collectors.toMap states:</p>
<p>If the mapped keys contains duplicates (according to
Object.equals(Object)), an</p>
<p>IllegalStateException is thrown when the collection operation is
performed. If the mapped keys may have duplicates, use toMap(Function,
Function, BinaryOperator) instead.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 343</p>
<p><span id="Stream_characters___Stream_of__A"
class="anchor"></span>Stream characters = Stream.of("A", "B", "B",
"C");</p>
<p>Map map = characters</p>
<p>.collect(Collectors.toMap(</p>
<p>element -&gt; element.hashCode(),</p>
<p>element -&gt; element,</p>
<p>(existingVal, newVal)-&gt; (existingVal + newVal)));</p>
<p>// map = {65=A, 66=BB, 67=C}</p>
<p>The BinaryOperator passed to Collectors.toMap(...) generates the
value to be stored in the case of a collision. It</p>
<p>can:</p>
<p>return the old value, so that the first value in the stream takes
precedence,</p>
<p>return the new value, so that the last value in the stream takes
precedence, or combine the old and new values</p>
<p>Grouping by value</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-">You
can use Collectors.groupingBy</a> when you need to perform the
equivalent of a database cascaded "group by" operation. To illustrate,
the following creates a map in which people's names are mapped to
surnames:</p>
<p>List people = Arrays.asList(</p>
<p><strong>new</strong> Person("Sam", "Rossi"),</p>
<p><strong>new</strong> Person("Sam", "Verdi"),</p>
<p><strong>new</strong> Person("John", "Bianchi"),</p>
<p><strong>new</strong> Person("John", "Rossi"),</p>
<p><strong>new</strong> Person("John", "Verdi")</p>
<p>);</p>
<p>Map&gt; map = people.stream()</p>
<p>.collect(</p>
<p>// function mapping input elements to keys</p>
<p>Collectors.groupingBy(Person::getName,</p>
<p>// function mapping input elements to values,</p>
<p>// how to store values</p>
<p>Collectors.mapping(Person::getSurname, Collectors.toList()))</p>
<p>);</p>
<p>// map = {John=[Bianchi, Rossi, Verdi], Sam=[Rossi, Verdi]}</p>
<p><a href="https://ideone.com/2Ar9IA">Live on Ideone</a></p>
<p>Section 57.22: Joining a stream to a single String</p>
<p>A use case that comes across frequently, is creating a String from a
stream, where the stream-items are separated</p>
<p>by a certain character. The Collectors.joining() method can be used
for this, like in the following example:</p>
<p>Stream fruitStream = Stream.of("apple", "banana", "pear", "kiwi",
"orange");</p>
<p>String result = fruitStream.filter(s -&gt; s.contains("a"))</p>
<p>.map(String::toUpperCase)</p>
<p>.sorted()</p>
<p>.collect(Collectors.joining(", "));</p>
<p>System.out.println(result);</p>
<p>Output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 344</p>
<p><span id="APPLE__BANANA__ORANGE__PEAR" class="anchor"></span>APPLE,
BANANA, ORANGE, PEAR</p>
<p>The Collectors.joining() method can also cater for pre- and
postfixes:</p>
<p>String result = fruitStream.filter(s -&gt; s.contains("e"))</p>
<p>.map(String::toUpperCase)</p>
<p>.sorted()</p>
<p>.collect(Collectors.joining(", ", "Fruits: ", "."));</p>
<p>System.out.println(result);</p>
<p>Output:</p>
<p>Fruits: APPLE, ORANGE, PEAR.</p>
<p><a href="http://ideone.com/e.js/MH4kmG">Live on Ideone</a></p>
<p>Section 57.23: Sort Using Stream</p>
<p>List data = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>data.add("Sydney");</p>
<p>data.add("London");</p>
<p>data.add("New York");</p>
<p>data.add("Amsterdam");</p>
<p>data.add("Mumbai");</p>
<p>data.add("California");</p>
<p>System.out.println(data);</p>
<p>List sortedData =
data.stream().sorted().collect(Collectors.toList());</p>
<p>System.out.println(sortedData);</p>
<p>Output:</p>
<p>[Sydney, London, New York, Amsterdam, Mumbai, California] [Amsterdam,
California, London, Mumbai, New York, Sydney]</p>
<p>It's also possible to use different comparison mechanism as there is
a overloaded <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-">sorted</a>
version which takes a comparator as its argument.</p>
<p>Also, you can use a lambda expression for sorting:</p>
<p>List sortedData2 = data.stream().sorted((s1,s2)-&gt;
s2.compareTo(s1)).collect(Collectors.toList());</p>
<p>This would output</p>
<p>[Sydney, New York, Mumbai, London, California, Amsterdam]</p>
<p>You can use Comparator.reverseOrder() to have a comparator that
imposes the reverse of the natural ordering.</p>
<p>List reverseSortedData =</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 345</p>
<p><span id="data_stream___sorted_Comparator"
class="anchor"></span>data.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</p>
<p>Section 57.24: Streams of Primitives</p>
<p>Java provides specialized Streams for three types of primitives
IntStream (for <strong>int</strong>s), LongStream (for
<strong>long</strong>s) and DoubleStream (for <strong>double</strong>s).
Besides being optimized implementations for their respective primitives,
they also</p>
<p>provide several specific terminal methods, typically for mathematical
operations. E.g.:</p>
<p>IntStream is = IntStream.of(10, 20, 30);</p>
<p><strong>double</strong> average = is.average().getAsDouble(); <em>//
average is 20.0</em></p>
<p>Section 57.25: Stream operations categories</p>
<p>Stream operations fall into two main categories, intermediate and
terminal operations, and two sub-categories,</p>
<p>stateless and stateful.</p>
<p>Intermediate Operations:</p>
<p>An intermediate operation is always <em>lazy</em>, such as a simple
Stream.map. It is not invoked until the stream is actually consumed.
This can be verified easily:</p>
<p>Arrays.asList(1, 2 ,3).stream().map(i -&gt; {</p>
<p><strong>throw new</strong> RuntimeException("not gonna happen");</p>
<p>return <strong>i;</strong></p>
<p>});</p>
<p>Intermediate operations are the common building blocks of a stream,
chained after the source and are usually followed by a terminal
operation triggering the stream chain.</p>
<p>Terminal Operations</p>
<p>Terminal operations are what triggers the consumption of a stream.
Some of the more common are</p>
<p>Stream.<strong>forEach</strong> or Stream.collect. They are usually
placed after a chain of intermediate operations and are almost always
<em>eager</em>.</p>
<p>Stateless Operations</p>
<p>Statelessness means that each item is processed without the context
of other items. Stateless operations allow for</p>
<p>memory-efficient processing of streams. Operations like Stream.map
and Stream.filter that do not require information on other items of the
stream are considered to be stateless.</p>
<p>Stateful operations</p>
<p>Statefulness means the operation on each item depends on (some) other
items of the stream. This requires a state</p>
<p>to be preserved. Statefulness operations may break with long, or
infinite, streams. Operations like Stream.sorted</p>
<p>require the entirety of the stream to be processed before any item is
emitted which will break in a long enough stream of items. This can be
demonstrated by a long stream (<strong>run at your own
risk</strong>):</p>
<p>// works - stateless stream</p>
<p><strong>long</strong> BIG_ENOUGH_NUMBER = 999999999;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 346</p>
<p><span id="IntStream_iterate_0__i____i___1"
class="anchor"></span>IntStream.iterate(0, i -&gt; i +
1).limit(BIG_ENOUGH_NUMBER).<strong>forEach</strong>(System.out::println);</p>
<p>This will cause an out-of-memory due to statefulness of
Stream.sorted:</p>
<p>// Out of memory - stateful stream</p>
<p>IntStream.iterate(0, i -&gt; i +
1).limit(BIG_ENOUGH_NUMBER).sorted().<strong>forEach</strong>(System.out::println);</p>
<p>Section 57.26: Collect Results of a Stream into an Array</p>
<p>Analog to get a collection for a Stream by collect() an array can be
obtained by the Stream.toArray() method:</p>
<p>List fruits = Arrays.asList("apple", "banana", "pear", "kiwi",
"orange");</p>
<p>String[] filteredFruits = fruits.stream()</p>
<p>.filter(s -&gt; s.contains("a"))</p>
<p>.toArray(String[]::<strong>new</strong>);</p>
<p>// prints: [apple, banana, pear, orange]</p>
<p>System.out.println(Arrays.toString(filteredFruits));</p>
<p>String[]::<strong>new</strong> is a special kind of method reference:
a constructor reference.</p>
<p>Section 57.27: Generating random Strings using Streams</p>
<p>It is sometimes useful to create random Strings, maybe as Session-ID
for a web-service or an initial password after registration for an
application. This can be easily achieved using Streams.</p>
<p>First we need to initialize a random number generator. To enhance
security for the generated Strings, it is a good idea to use
SecureRandom.</p>
<p><strong>Note</strong>: Creating a SecureRandom is quite expensive, so
it is best practice to only do this once and call one of its</p>
<p>setSeed() methods from time to time to reseed it.</p>
<p><em><strong>private static final</strong> SecureRandom rng =
<strong>new</strong> SecureRandom(SecureRandom.generateSeed(20));</em>
//20 Bytes as a seed is rather arbitrary, it is the number used in the
JavaDoc example</p>
<p>When creating random Strings, we usually want them to use only
certain characters (e.g. only letters and digits).</p>
<p>Therefore we can create a method returning a <strong>boolean</strong>
which can later be used to filter the Stream.</p>
<p>//returns true for all chars in 0-9, a-z and A-Z</p>
<p><strong>boolean</strong> useThisCharacter(<strong>char</strong>
c){</p>
<p>//check for range to avoid using all unicode Letter (e.g. some
chinese symbols) <em><strong>return</strong> c &gt;= '0' &amp;&amp; c
&lt;= 'z' &amp;&amp; Character.isLetterOrDigit(c);</em></p>
<p>}</p>
<p>Next we can utilize the RNG to generate a random String of specific
length containing the charset which pass our</p>
<p>useThisCharacter check.</p>
<p><strong>public</strong> String
generateRandomString(<strong>long</strong> length){</p>
<p>//Since there is no native CharStream, we use an IntStream instead
//and convert it to a Stream&lt;Character&gt; using mapToObj. //We need
to specify the boundaries for the int values to ensure they can safely
be cast to char</p>
<p>Stream randomCharStream = rng.ints(Character.MIN_CODE_POINT,
Character.MAX_CODE_POINT).mapToObj(i -&gt;
(<strong>char</strong>)i).filter(c -&gt;
<strong>this</strong>::useThisCharacter).limit(length);</p>
<p>//now we can use this Stream to build a String utilizing the collect
method.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 347</p>
<p>String randomString =
randomCharStream.collect(StringBuilder::<strong>new</strong>,
StringBuilder::append,</p>
<p>StringBuilder::append).toString();</p>
<p><strong>return</strong> randomString;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 348</p>
<p><span id="Chapter_58__InputStreams_and" class="anchor"></span>Chapter
58: InputStreams and</p>
<p>OutputStreams</p>
<p>Section 58.1: Closing Streams</p>
<p>Most streams must be closed when you are done with them, otherwise
you could introduce a memory leak or leave a file open. It is important
that streams are closed even if an exception is thrown.</p>
<p>Version ≥ Java SE 7</p>
<p><strong>try</strong>(FileWriter fw = <strong>new</strong>
FileWriter("outfilename");</p>
<p>BufferedWriter bw = <strong>new</strong> BufferedWriter(fw);</p>
<p>PrintWriter out = <strong>new</strong> PrintWriter(bw))</p>
<p>{</p>
<p>out.println("the text");</p>
<p>//more code</p>
<p>out.println("more text");</p>
<p>//more code</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>//handle this however you</p>
<p>}</p>
<p>Remember: try-with-resources guarantees, that the resources have been
closed when the block is exited, whether that happens with the usual
control flow or because of an exception.</p>
<p>Version ≤ Java SE 6</p>
<p>Sometimes, try-with-resources is not an option, or maybe you're
supporting older version of Java 6 or earlier. In this</p>
<p>case, proper handling is to use a <strong>finally</strong> block:</p>
<p>FileWriter fw = <strong>null</strong>;</p>
<p>BufferedWriter bw = <strong>null</strong>;</p>
<p>PrintWriter out = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>fw = <strong>new</strong> FileWriter("myfile.txt");</p>
<p>bw = <strong>new</strong> BufferedWriter(fw);</p>
<p>out = <strong>new</strong> PrintWriter(bw);</p>
<p>out.println("the text");</p>
<p>out.close();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>//handle this however you want</p>
<p>}</p>
<p>finally <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p><strong>if</strong>(out != <strong>null</strong>)</p>
<p>out.close();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>//typically not much you can do here...</p>
<p>}</p>
<p>}</p>
<p>Note that closing a wrapper stream will also close its underlying
stream. This means you cannot wrap a stream, close the wrapper and then
continue using the original stream.</p>
<p>Section 58.2: Reading InputStream into a String</p>
<p>Sometimes you may wish to read byte-input into a String. To do this
you will need to find something that converts</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 349</p>
<p><span id="between_byte_and_the__native_Jav"
class="anchor"></span>between <strong>byte</strong> and the "native
Java" UTF-16 Codepoints used as <strong>char</strong><a
href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html">.
That is done with a InputStreamReader</a>.</p>
<p>To speed the process up a bit, it's "usual" to allocate a buffer, so
that we don't have too much overhead when</p>
<p>reading from Input.</p>
<p>Version ≥ Java SE 7</p>
<p><strong>public</strong> String inputStreamToString(InputStream
inputStream) <strong>throws</strong> Exception {</p>
<p>StringWriter writer = <strong>new</strong> StringWriter();</p>
<p><strong>char</strong>[] buffer = <strong>new char</strong>[1024];</p>
<p><strong>try</strong> (Reader reader = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(inputStream,
"UTF-8"))) {</p>
<p>int <strong>n;</strong></p>
<p><strong>while</strong> ((n = reader.read(buffer)) !=-1) {</p>
<p>// all this code does is redirect the output of `reader` to `writer`
in // 1024 byte chunks</p>
<p>writer.write(buffer, 0, n);</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> writer.toString();</p>
<p>}</p>
<p>Transforming this example to Java SE 6 (and lower)-compatible code is
left out as an exercise for the reader.</p>
<p>Section 58.3: Wrapping Input/Output Streams</p>
<p>OutputStream and InputStream have many different classes, each of
them with a unique functionality. By wrapping</p>
<p>a stream around another, you gain the functionality of both
streams.</p>
<p>You can wrap a stream any number of times, just take note of the
ordering.</p>
<p>Useful combinations</p>
<p>Writing characters to a file while using a buffer</p>
<p>File myFile = <strong>new</strong> File("targetFile.txt");</p>
<p>PrintWriter writer = <strong>new</strong>
PrintWriter(<strong>new</strong>
BufferedOutputStream(<strong>new</strong>
FileOutputStream(myFile)));</p>
<p>Compressing and encrypting data before writing to a file while using
a buffer</p>
<p>Cipher cipher = ... <em>// Initialize cipher</em></p>
<p>File myFile = <strong>new</strong> File("targetFile.enc");</p>
<p>BufferedOutputStream outputStream = <strong>new</strong>
BufferedOutputStream(<strong>new</strong>
DeflaterOutputStream(<strong>new</strong>
CipherOutputStream(<strong>new</strong> FileOutputStream(myFile),
cipher)));</p>
<p>List of Input/Output Stream wrappers</p>
<p>Wrapper Description</p>
<p>BufferedOutputStream/ While OutputStream writes data one byte at a
time, BufferedOutputStream writes data in chunks. This reduces the
BufferedInputStream number of system calls, thus improving
performance.</p>
<p>DeflaterOutputStream/ Performs data compression.
DeflaterInputStream</p>
<p>InflaterOutputStream/ InflaterInputStream Performs data
decompression.</p>
<p>CipherOutputStream/ CipherInputStream Encrypts/Decrypts data.</p>
<p>DigestOutputStream/ DigestInputStream Generates Message Digest to
verify data integrity.</p>
<p>CheckedOutputStream/ Generates a CheckSum. CheckSum is a more trivial
version of CheckedInputStream Message Digest.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 350</p>
<p><span id="DataOutputStream__DataInputStrea"
class="anchor"></span>DataOutputStream/ DataInputStream Allows writing
of primitive data types and Strings. Meant for writing bytes. Platform
independent.</p>
<p>PrintStream Allows writing of primitive data types and Strings. Meant
for writing bytes. Platform dependent.</p>
<p>OutputStreamWriter Converts a OutputStream into a Writer. An
OutputStream deals with bytes while Writers deals with characters</p>
<p>Automatically calls OutputStreamWriter. Allows writing of
primitive</p>
<p>PrintWriter data types and Strings. Strictly for writing characters
and best for</p>
<p>writing characters</p>
<p>Section 58.4: DataInputStream Example</p>
<p><strong>package</strong> com.streams;</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>public class</strong> DataStreamDemo {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</p>
<p>InputStream input = <strong>new</strong>
FileInputStream("D:<strong>\\</strong>datastreamdemo.txt");
DataInputStream inst = <strong>new</strong> DataInputStream(input);</p>
<p><strong>int</strong> count = input.available();</p>
<p><strong>byte</strong>[] arr = <strong>new byte</strong>[count];</p>
<p>inst.read(arr);</p>
<p><strong>for</strong> (<strong>byte</strong> byt : arr) {</p>
<p><strong>char</strong> ki = (<strong>char</strong>) byt;</p>
<p>System.out.print(ki+"-");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 58.5: Writing bytes to an OutputStream</p>
<p>Writing bytes to an OutputStream one byte at a time</p>
<p>OutputStream stream = object.getOutputStream();</p>
<p><strong>byte</strong> b = 0x00;</p>
<p>stream.write( b );</p>
<p>Writing a byte array</p>
<p><strong>byte</strong>[] bytes = <strong>new byte</strong>[] { 0x00,
0x00 };</p>
<p>stream.write( bytes );</p>
<p>Writing a section of a byte array</p>
<p><strong>int</strong> offset = 1;</p>
<p><strong>int</strong> length = 2;</p>
<p><strong>byte</strong>[] bytes = <strong>new byte</strong>[] { 0xFF,
0x00, 0x00, 0xFF };</p>
<p>stream.write( bytes, offset, length );</p>
<p>Section 58.6: Copying Input Stream to Output Stream</p>
<p>This function copies data between two streams -</p>
<p><strong>void</strong> copy(InputStream in, OutputStream out)
<strong>throws</strong> IOException {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 351</p>
<p><strong>byte</strong>[] buffer = <strong>new byte</strong>[8192];</p>
<p><strong>while</strong> ((bytesRead = in.read(buffer)) &gt; 0) {</p>
<p>out.write(buffer, 0, bytesRead);</p>
<p>}</p>
<p>}</p>
<p>Example -</p>
<p>// reading from System.in and writing to System.out</p>
<p>copy(System.in, System.out);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 352</p>
<p><span id="Chapter_59__Readers_and_Writers_1"
class="anchor"></span>Chapter 59: Readers and Writers</p>
<p>Readers and Writers and their respective subclasses provide simple
I/O for text / character-based data.</p>
<p>Section 59.1: BueredReader</p>
<p>Introduction</p>
<p>The BufferedReader class is a wrapper for other Reader classes that
serves two main purposes:</p>
<p>1. A BufferedReader provides buffering for the wrapped Reader. This
allows an application to read characters</p>
<p>one at a time without undue I/O overheads.</p>
<p>2. A BufferedReader provides functionality for reading text a line at
a time.</p>
<p>Basics of using a BufferedReader</p>
<p>The normal pattern for using a BufferedReader is as follows. First,
you obtain the Reader that you want to read characters from. Next you
instantiate a BufferedReader that wraps the Reader. Then you read
character data.</p>
<p>Finally you close the BufferedReader which close the wrapped `Reader.
For example:</p>
<p>File someFile = <strong>new</strong> File(...);</p>
<p><strong>int</strong> aCount = 0;</p>
<p><strong>try</strong> (FileReader fr = <strong>new</strong>
FileReader(someFile);</p>
<p>BufferedReader br = <strong>new</strong> BufferedReader(fr)) {</p>
<p>// Count the number of 'a' characters.</p>
<p><strong>int</strong> ch;</p>
<p><strong>while</strong> ((ch = br.read()) !=-1) {</p>
<p><strong>if</strong> (ch == 'a') {</p>
<p>aCount++;</p>
<p>}</p>
<p>}</p>
<p>System.out.println("There are " + aCount + " 'a' characters in " +
someFile);</p>
<p>}</p>
<p>You can apply this pattern to any Reader</p>
<p>Notes:</p>
<p>1. We have used Java 7 (or later) <em>try-with-resources</em> to
ensure that the underlying reader is always closed. This</p>
<p>avoids a potential resource leak. In earlier versions of Java, you
would explicitly close the BufferedReader in a <strong>finally</strong>
block.</p>
<p>2. The code inside the <strong>try</strong> block is virtually
identical to what we would use if we read directly from the</p>
<p>FileReader. In fact, a BufferedReader functions exactly like the
Reader that it wraps would behave. The</p>
<p>difference is that <em>this</em> version is a lot more efficient.</p>
<p>The BufferedReader buffer size</p>
<p>The BufferedReader.readLine() method</p>
<p>Example: reading all lines of a File into a List</p>
<p>This is done by getting each line in a file, and adding it into a
List. The list is then returned:</p>
<p><strong>public</strong> List getAllLines(String filename)
<strong>throws</strong> IOException {</p>
<p>List lines = <strong>new</strong> ArrayList();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 353</p>
<p><span id="try__BufferedReader_br___new_Buf"
class="anchor"></span><strong>try</strong> (BufferedReader br =
<strong>new</strong> BufferedReader(<strong>new</strong>
FileReader(filename))) {</p>
<p>String line = <strong>null</strong>;</p>
<p><strong>while</strong> ((line = reader.readLine) !=
<strong>null</strong>) {</p>
<p>lines.add(line);</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> lines;</p>
<p>}</p>
<p>Java 8 provides a more concise way to do this using the lines()
method:</p>
<p><strong>public</strong> List getAllLines(String filename)
<strong>throws</strong> IOException {</p>
<p><strong>try</strong> (BufferedReader br = <strong>new</strong>
BufferedReader(<strong>new</strong> FileReader(filename))) {</p>
<p><strong>return</strong> br.lines().collect(Collectors.toList());</p>
<p>}</p>
<p><strong>return</strong> Collections.empty();</p>
<p>}</p>
<p>Section 59.2: StringWriter Example</p>
<p>Java StringWriter class is a character stream that collects output
from string buffer, which can be used to construct</p>
<p>a string.</p>
<p>The StringWriter class extends the Writer class.</p>
<p>In StringWriter class, system resources like network sockets and
files are not used, therefore closing the StringWriter is not
necessary.</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>public class</strong> StringWriterDemo {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</p>
<p><strong>char</strong>[] ary = <strong>new char</strong>[1024];</p>
<p>StringWriter writer = <strong>new</strong> StringWriter();</p>
<p>FileInputStream input = <strong>null</strong>;</p>
<p>BufferedReader buffer = <strong>null</strong>;</p>
<p>input = <strong>new</strong>
FileInputStream("c://stringwriter.txt");</p>
<p>buffer = <strong>new</strong> BufferedReader(<strong>new</strong>
InputStreamReader(input, "UTF-8"));</p>
<p>int <strong>x;</strong></p>
<p><strong>while</strong> ((x = buffer.read(ary)) !=-1) {</p>
<p>writer.write(ary, 0, x);</p>
<p>}</p>
<p>System.out.println(writer.toString());</p>
<p>writer.close();</p>
<p>buffer.close();</p>
<p>}</p>
<p>}</p>
<p>The above example helps us to know simple example of StringWriter
using BufferedReader to read file data from the stream.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 354</p>
<p><span id="Chapter_60__Preferences_1" class="anchor"></span>Chapter
60: Preferences</p>
<p>Section 60.1: Using preferences</p>
<p>Preferences can be used to store user settings that reflect a user's
personal application settings, e.g. their editor font, whether they
prefer the application to be started in full-screen mode, whether they
checked a "don't show this</p>
<p>again" checkbox and things like that.</p>
<p><strong>public class</strong> ExitConfirmer {</p>
<p>private static boolean <strong>confirmExit() {</strong></p>
<p>Preferences preferences =
Preferences.userNodeForPackage(ExitConfirmer.<strong>class</strong>);</p>
<p><strong>boolean</strong> doShowDialog =
preferences.getBoolean("showExitConfirmation", <strong>true</strong>);
<em>// true is</em></p>
<p>default value</p>
<p><strong>if</strong> (!doShowDialog) {</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p>//</p>
<p>// Show a dialog here...</p>
<p>//</p>
<p><em><strong>boolean</strong> exitWasConfirmed = ...;</em> // whether
the user clicked OK or Cancel <em><strong>boolean</strong>
doNotShowAgain = ...;</em> // get value from "Do not show again"
checkbox</p>
<p><strong>if</strong> (exitWasConfirmed &amp;&amp; doNotShowAgain)
{</p>
<p>// Exit was confirmed and the user chose that the dialog should not
be shown again // Save these settings to the Preferences object so the
dialog will not show again next</p>
<p>time</p>
<p>preferences.putBoolean("showExitConfirmation",
<strong>false</strong>);</p>
<p>}</p>
<p><strong>return</strong> exitWasConfirmed;</p>
<p>}</p>
<p>public static void <strong>exit() {</strong></p>
<p><strong>if</strong> (confirmExit()) {</p>
<p>System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 60.2: Adding event listeners</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/prefs/Preferences.html">There
are two types of events emitted by a Preferences</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/prefs/PreferenceChangeEvent.html">object:
PreferenceChangeEvent</a> and <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/prefs/NodeChangeEvent.html">NodeChangeEvent</a>.</p>
<p>PreferenceChangeEvent</p>
<p>A PreferenceChangeEvent gets emitted by a Properties object every
time one of the node's key-value-pairs</p>
<p>changes. PreferenceChangeEvents can be listened for with a <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/prefs/PreferenceChangeListener.html">PreferenceChangeListener</a>:</p>
<p>Version ≥ Java SE 8</p>
<p>preferences.addPreferenceChangeListener(evt -&gt; {</p>
<p>String newValue = evt.getNewValue();</p>
<p>String changedPreferenceKey = evt.getKey();</p>
<p>Preferences changedNode = evt.getNode();</p>
<p>});</p>
<p>Version &lt; Java SE 8</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 355</p>
<p><span id="preferences_addPreferenceChangeL"
class="anchor"></span>preferences.addPreferenceChangeListener(<strong>new</strong>
PreferenceChangeListener() {</p>
<p>@Override</p>
<p><strong>public void</strong> preferenceChange(PreferenceChangeEvent
evt) {</p>
<p>String newValue = evt.getNewValue();</p>
<p>String changedPreferenceKey = evt.getKey();</p>
<p>Preferences changedNode = evt.getNode();</p>
<p>}</p>
<p>});</p>
<p>This listener will not listen to changed key-value pairs of child
nodes.</p>
<p>NodeChangeEvent</p>
<p>This event will be fired whenever a child node of a Properties node
is added or removed.</p>
<p>preferences.addNodeChangeListener(<strong>new</strong>
NodeChangeListener() {</p>
<p>@Override</p>
<p><strong>public void</strong> childAdded(NodeChangeEvent evt) {</p>
<p>Preferences addedChild = evt.getChild();</p>
<p>Preferences parentOfAddedChild = evt.getParent();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> childRemoved(NodeChangeEvent evt) {</p>
<p>Preferences removedChild = evt.getChild();</p>
<p>Preferences parentOfRemovedChild = evt.getParent();</p>
<p>}</p>
<p>});</p>
<p>Section 60.3: Getting sub-nodes of Preferences</p>
<p>Preferences objects always represent a specific node in a whole
Preferences tree, kind of like this:</p>
<p>rRoot ├── <strong>com</strong> │ └── <strong>mycompany</strong> │ └──
<strong>myapp</strong> │ ├── darkApplicationMode=true │ ├──</p>
<p>showExitConfirmation=false │ └── windowMaximized=true └──
<strong>org</strong> └── <strong>myorganization</strong> └──
<strong>anotherapp</strong> ├──</p>
<p>defaultFont=Helvetica ├── defaultSavePath=/home/matt/Documents └──
<strong>exporting</strong> ├── defaultFormat=pdf └──</p>
<p>openInBrowserAfterExport=false</p>
<p>To select the /com/mycompany/myapp node:</p>
<p>1. By convention, based on the package of a class:</p>
<p><strong>package</strong> com.mycompany.myapp;</p>
<p>// ...</p>
<p>// Because this class is in the com.mycompany.myapp package, the node
// /com/mycompany/myapp will be returned.</p>
<p>Preferences myApp = Preferences.userNodeForPackage(getClass());</p>
<p>2. By relative path:</p>
<p>Preferences myApp =
Preferences.userRoot().node("com/mycompany/myapp");</p>
<p>Using a relative path (a path not starting with a /) will cause the
path to be resolved relative to the parent node it is resolved on. For
example, the following example will return the node of the path</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 356</p>
<p><span id="_one_two_three_com_mycompany_mya"
class="anchor"></span>/one/two/three/com/mycompany/myapp:</p>
<p>Preferences prefix = Preferences.userRoot().node("one/two/three");
Preferences myAppWithPrefix = prefix.node("com/mycompany/myapp"); <em>//
prefix is /one/two/three</em></p>
<p>// myAppWithPrefix is /one/two/three/com/mycompany/myapp</p>
<p>3. By absolute path:</p>
<p>Preferences myApp =
Preferences.userRoot().node("/com/mycompany/myapp");</p>
<p>Using an absolute path on the root node will not be different from
using a relative path. The difference is that, if called on a sub-node,
the path will be resolved relative to the root node.</p>
<p>Preferences prefix = Preferences.userRoot().node("one/two/three");
Preferences myAppWitoutPrefix = prefix.node("/com/mycompany/myapp");
<em>// prefix is /one/two/three</em></p>
<p>// myAppWitoutPrefix is /com/mycompany/myapp</p>
<p>Section 60.4: Coordinating preferences access across</p>
<p>multiple application instances</p>
<p>All instances of Preferences are always thread-safe across the
threads of a single Java Virtual Machine (JVM).</p>
<p>Because Preferences can be shared across multiple JVMs, there are
special methods that deal with synchronizing changes across virtual
machines.</p>
<p>If you have an application which is supposed to run in a
<strong>single instance</strong> only, then <strong>no external
synchronization</strong> is</p>
<p>required.</p>
<p>If you have an application which runs in <strong>multiple
instances</strong> on a single system and therefore Preferences
access</p>
<p>needs to be coordinated between the JVMs on the system, then the
<strong>sync() method</strong> of any Preferences node may</p>
<p>be used to ensure changes to the Preferences node are visible to
other JVMs on the system:</p>
<p>// Warning: don't use this if your application is intended // to only
run a single instance on a machine once</p>
<p>// (this is probably the case for most desktop applications)
<em><strong>try</strong> {</em></p>
<p>preferences.sync();</p>
<p>} <strong>catch</strong> (BackingStoreException e) {</p>
<p>// Deal with any errors while saving the preferences to the backing
storage</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 60.5: Exporting preferences</p>
<p>Preferences nodes can be exported into a XML document representing
that node. The resulting XML tree can be</p>
<p>imported again. The resulting XML document will remember whether it
was exported from the user or system</p>
<p>Preferences.</p>
<p>To export a single node, but <strong>not its child
nodes</strong>:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>try</strong> (OutputStream os = ...) {</p>
<p>preferences.exportNode(os);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 357</p>
<p><span id="___Exception_whilst_writing_data" class="anchor"></span>//
Exception whilst writing data to the OutputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (BackingStoreException bse) {</p>
<p>// Exception whilst reading from the backing preferences store</p>
<p>bse.printStackTrace();</p>
<p>}</p>
<p>Version &lt; Java SE 7</p>
<p>OutputStream os = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>os = ...;</p>
<p>preferences.exportSubtree(os);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Exception whilst writing data to the OutputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (BackingStoreException bse) {</p>
<p>// Exception whilst reading from the backing preferences store</p>
<p>bse.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (os != <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>os.close();</p>
<p>} <strong>catch</strong> (IOException ignored) {}</p>
<p>}</p>
<p>}</p>
<p>To export a single node <strong>with its child nodes</strong>:</p>
<p>Version ≥ Java SE 7</p>
<p><strong>try</strong> (OutputStream os = ...) {</p>
<p>preferences.exportNode(os);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Exception whilst writing data to the OutputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (BackingStoreException bse) {</p>
<p>// Exception whilst reading from the backing preferences store</p>
<p>bse.printStackTrace();</p>
<p>}</p>
<p>Version &lt; Java SE 7</p>
<p>OutputStream os = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>os = ...;</p>
<p>preferences.exportSubtree(os);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Exception whilst writing data to the OutputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (BackingStoreException bse) {</p>
<p>// Exception whilst reading from the backing preferences store</p>
<p>bse.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (os != <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>os.close();</p>
<p>} <strong>catch</strong> (IOException ignored) {}</p>
<p>}</p>
<p>}</p>
<p>Section 60.6: Importing preferences</p>
<p>Preferences nodes can be imported from a XML document. Importing is
meant to be used in conjunction with the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 358</p>
<p><span id="exporting_functionality_of_Prefe"
class="anchor"></span>exporting functionality of Preferences, since it
creates the correct corresponding XML documents.</p>
<p>The XML documents will remember whether they were exported from the
user or system Preferences. Therefore,</p>
<p>they can be imported into their respective Preferences trees again,
without you having to figure out or know where they came from. The
static function will automatically find out whether the XML document was
exported from the</p>
<p>user or system Preferences and will automatically import them into
the tree they were exported from.</p>
<p>Version ≥ Java SE 7</p>
<p><strong>try</strong> (InputStream is = ...) {</p>
<p>// This is a static call on the Preferences class</p>
<p>Preferences.importPreferences(is);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Exception whilst reading data from the InputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (InvalidPreferencesFormatException ipfe)
{</p>
<p>// Exception whilst parsing the XML document tree</p>
<p>ipfe.printStackTrace();</p>
<p>}</p>
<p>Version &lt; Java SE 7</p>
<p>InputStream is = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>is = ...;</p>
<p>// This is a static call on the Preferences class</p>
<p>Preferences.importPreferences(is);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Exception whilst reading data from the InputStream</p>
<p>ioe.printStackTrace();</p>
<p>} <strong>catch</strong> (InvalidPreferencesFormatException ipfe)
{</p>
<p>// Exception whilst parsing the XML document tree</p>
<p>ipfe.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (is != <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>is.close();</p>
<p>} <strong>catch</strong> (IOException ignored) {}</p>
<p>}</p>
<p>}</p>
<p>Section 60.7: Removing event listeners</p>
<p>Event listeners can be removed again from any Properties node, but
the instance of the listener has to be kept around for that.</p>
<p>Version ≥ Java SE 8</p>
<p>Preferences preferences =
Preferences.userNodeForPackage(getClass());</p>
<p>PreferenceChangeListener listener = evt -&gt; {</p>
<p>System.out.println(evt.getKey() + " got new value " +
evt.getNewValue());</p>
<p>};</p>
<p>preferences.addPreferenceChangeListener(listener);</p>
<p>//</p>
<p>// later...</p>
<p>//</p>
<p>preferences.removePreferenceChangeListener(listener);</p>
<p>Version &lt; Java SE 8</p>
<p>Preferences preferences =
Preferences.userNodeForPackage(getClass());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 359</p>
<p><span id="PreferenceChangeListener_listene"
class="anchor"></span>PreferenceChangeListener listener =
<strong>new</strong> PreferenceChangeListener() {</p>
<p>@Override</p>
<p><strong>public void</strong> preferenceChange(PreferenceChangeEvent
evt) {</p>
<p>System.out.println(evt.getKey() + " got new value " +
evt.getNewValue());</p>
<p>}</p>
<p>};</p>
<p>preferences.addPreferenceChangeListener(listener);</p>
<p>//</p>
<p>// later...</p>
<p>//</p>
<p>preferences.removePreferenceChangeListener(listener);</p>
<p>The same applies for NodeChangeListener.</p>
<p>Section 60.8: Getting preferences values</p>
<p>A value of a Preferences node can be of the type String,
<strong>boolean</strong>, <strong>byte</strong>[],
<strong>double</strong>, <strong>float</strong>, <strong>int</strong> or
<strong>long</strong>. All invocations must provide a default value, in
case the specified value is not present in the Preferences node.</p>
<p>Preferences preferences =
Preferences.userNodeForPackage(getClass());</p>
<p>String someString = preferences.get("someKey", "this is the default
value"); <strong>boolean</strong> someBoolean =
preferences.getBoolean("someKey", <strong>true</strong>);
<strong>byte</strong>[] someByteArray =
preferences.getByteArray("someKey", <strong>new byte</strong>[0]);
<strong>double</strong> someDouble = preferences.getDouble("someKey",
887284.4d); <strong>float</strong> someFloat =
preferences.getFloat("someKey", 38723.3f); <strong>int</strong> someInt
= preferences.getInt("someKey", 13232); <strong>long</strong> someLong =
preferences.getLong("someKey", 2827637868234L);</p>
<p>Section 60.9: Setting preferences values</p>
<p>To store a value into the Preferences node, one of the putXXX()
methods is used. A value of a Preferences node can be of the type
String, <strong>boolean</strong>, <strong>byte</strong>[],
<strong>double</strong>, <strong>float</strong>, <strong>int</strong> or
<strong>long</strong>.</p>
<p>Preferences preferences =
Preferences.userNodeForPackage(getClass());</p>
<p>preferences.put("someKey", "some String value");</p>
<p>preferences.putBoolean("someKey", <strong>false</strong>);</p>
<p>preferences.putByteArray("someKey", <strong>new
byte</strong>[0]);</p>
<p>preferences.putDouble("someKey", 187398123.4454d);
preferences.putFloat("someKey", 298321.445f);</p>
<p>preferences.putInt("someKey", 77637);</p>
<p>preferences.putLong("someKey", 2873984729834L);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 360</p>
<p><span id="Chapter_61__Collection_Factory_M_1"
class="anchor"></span>Chapter 61: Collection Factory Methods</p>
<p>Method w/ Parameter Description</p>
<p>List.of(E e) A generic type that can be a class or interface.</p>
<p>Set.of(E e) A generic type that can be a class or interface.</p>
<p>Map A key-value pair of generic types that can each be a class or .
of ( K k, V v ) interface.</p>
<p>Map.of(Map.Entryextends K, ? <strong>extends</strong> A Map.Entry
instance where its key can be K or one of its children, V&gt; entry) and
its value can be V or any of its children.</p>
<p>The arrival of Java 9 brings many new features to Java's Collections
API, one of which being collection factory</p>
<p>methods. These methods allow for easy initialization of
<strong>immutable</strong> collections, whether they be empty or</p>
<p>nonempty.</p>
<p>Note that these factory methods are only available for the following
interfaces: List, Set, and Map</p>
<p>Section 61.1: List&lt;E&gt; Factory Method Examples</p>
<p>List immutableEmptyList = List.of();</p>
<p>Initializes an empty, immutable List.</p>
<p>List immutableList = List.of(1, 2, 3, 4, 5);</p>
<p>Initializes an immutable List with five initial elements.</p>
<p>List mutableList = <strong>new</strong>
ArrayList&lt;&gt;(immutableList);</p>
<p>Initializes a mutable List from an immutable List.</p>
<p>Section 61.2: Set&lt;E&gt; Factory Method Examples</p>
<p>Set immutableEmptySet = Set.of();</p>
<p>Initializes an empty, immutable Set.</p>
<p>Set immutableSet = Set.of(1, 2, 3, 4, 5);</p>
<p>Initializes an immutable Set with five initial elements.</p>
<p>Set mutableSet = <strong>new</strong>
HashSet&lt;&gt;(immutableSet);</p>
<p>Initializes a mutable Set from an immutable Set.</p>
<p>Section 61.3: Map&lt;K, V&gt; Factory Method Examples</p>
<p>Map immutableEmptyMap = Map.of();</p>
<p>Initializes an empty, immutable Map.</p>
<p>Map immutableMap = Map.of(1, 2, 3, 4);</p>
<p>Initializes an immutable Map with two initial key-value entries.</p>
<p>Map immutableMap = Map.ofEntries(Map.entry(1, 2), Map.entry(3,
4));</p>
<p>Initializes an immutable Map with two initial key-value entries.</p>
<p>Map mutableMap = <strong>new</strong>
HashMap&lt;&gt;(immutableMap);</p>
<p>Initializes a mutable Map from an immutable Map.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 361</p>
<p><span id="Chapter_62__Alternative_Collecti_1"
class="anchor"></span>Chapter 62: Alternative Collections</p>
<p>Section 62.1: Multimap in Guava, Apache and Eclipse</p>
<p>Collections</p>
<p>This multimap allows duplicate key-value pairs. JDK analogs are
HashMap, HashMap and so on.</p>
<p>Key's order Value's order Duplicate Analog key Eclipse (GS) Analog
value Guava Apache JDK Collections</p>
<p>not defined HashMap&lt;K, Insertion-order yes <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>
<a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ArrayListMultimap.html">ArrayListMultimap</a>
MultiValueMap FastListMultimap ArrayList</p>
<p>&lt;V&gt;&gt;</p>
<p>MultiValueMap.</p>
<p>not defined multiValueMap( <strong>new</strong> HashMap&lt;K,
UnifiedSetMultimap not defined no <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a>
<a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/HashMultimap.html">HashMultimap</a>
HashMap &lt; K, Set &gt;() , HashSet &lt; V &gt;&gt;</p>
<p>HashSet.<strong>class</strong>);</p>
<p>not defined Multimaps. MultiValueMap.multiValueMap( newMultimap (
TreeSortedSet- HashMap&lt;K, sorted no <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">TreeSet</a>
<strong>new</strong> HashMap &lt; K, Set &gt;() , HashMap , Supplier
Multimap TreeSet &lt; V &gt;&gt; TreeSet . <strong>class</strong> ) &lt;
TreeSet &gt;)</p>
<p>MultiValueMap.</p>
<p>Insertion-order Insertion-order yes multiValueMap(new
LinkedHashMap&lt; <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>
<a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html">LinkedListMultimap</a>
LinkedHashMap(), K, ArrayList&gt;</p>
<p>ArrayList.class);</p>
<p>MultiValueMap.</p>
<p>Insertion-order Insertion-order no multiValueMap(<strong>new</strong>
LinkedHashMap&lt;K, <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html">LinkedHashSet</a>
<a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultimap.html">LinkedHashMultimap</a></p>
<p>LinkedHashMap&lt;K, Set&gt;(), LinkedHashSet&lt;V&gt;&gt;</p>
<p>LinkedHashSet.<strong>class</strong>)</p>
<p>MultiValueMap.</p>
<p>sorted multiValueMap( <strong>new</strong> TreeMap&lt;K, sorted no <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">TreeSet</a>
<a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeMultimap.html">TreeMultimap</a></p>
<p>TreeMap&lt;K, TreeSet&lt;V&gt;&gt;</p>
<p>Set&gt;(),TreeSet.<strong>class</strong>)</p>
<p>Examples using Multimap</p>
<p><strong>Task</strong>: Parse "Hello World! Hello All! Hi World!"
string to separate words and print all indexes of every word using</p>
<p>MultiMap (for example, Hello=[0, 2], World!=[1, 5] and so on)</p>
<p>1. MultiValueMap from Apache</p>
<p>String INPUT_TEXT = "Hello World! Hello All! Hi World!"; <em>// Parse
text to words and index</em></p>
<p>List words = Arrays.asList(INPUT_TEXT.split(" "));</p>
<p>// Create Multimap</p>
<p>MultiMap multiMap = <strong>new</strong> MultiValueMap();</p>
<p>// Fill Multimap</p>
<p><strong>int</strong> i = 0;</p>
<p><strong>for</strong>(String word: words) {</p>
<p>multiMap.put(word, i);</p>
<p>i++;</p>
<p>}</p>
<p>// Print all words</p>
<p><em>System.out.println(multiMap);</em> // print {Hi=[4], Hello=[0,
2], World!=[1, 5], All!=[3]} - in</p>
<p>random orders</p>
<p>// Print all unique words</p>
<p><em>System.out.println(multiMap.keySet());</em> // print [Hi, Hello,
World!, All!] - in random orders</p>
<p>// Print all indexes</p>
<p>System.out.println("Hello = " + multiMap.get("Hello")); <em>// print
[0, 2]</em> System.out.println("World = " + multiMap.get("World!"));
<em>// print [1, 5]</em> System.out.println("All = " +
multiMap.get("All!")); <em>// print [3]</em> System.out.println("Hi = "
+ multiMap.get("Hi")); <em>// print [4]</em> System.out.println("Empty =
" + multiMap.get("Empty")); <em>// print null</em></p>
<p>// Print count unique words</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 362</p>
<p>System.out.println(multiMap.keySet().size()); <em>//print 4</em></p>
<p>2. HashBiMap from GS / Eclipse Collection</p>
<p>String[] englishWords = {"one", "two", "three","ball","snow"};
String[] russianWords = {"jeden", "dwa", "trzy", "kula", "snieg"};</p>
<p>// Create Multiset</p>
<p>MutableBiMap biMap = <strong>new</strong>
HashBiMap(englishWords.length);</p>
<p>// Create English-Polish dictionary</p>
<p><strong>int</strong> i = 0;</p>
<p><strong>for</strong>(String englishWord: englishWords) {</p>
<p>biMap.put(englishWord, russianWords[i]);</p>
<p>i++;</p>
<p>}</p>
<p>// Print count words</p>
<p><em>System.out.println(biMap);</em> // print {two=dwa, ball=kula,
one=jeden, snow=snieg, three=trzy} - in</p>
<p>random orders</p>
<p>// Print all unique words</p>
<p><em>System.out.println(biMap.keySet());</em> // print [snow, two,
one, three, ball] - in random orders</p>
<p><em>System.out.println(biMap.values());</em> // print [dwa, kula,
jeden, snieg, trzy] - in random</p>
<p>orders</p>
<p>// Print translate by words</p>
<p>System.out.println("one = " + biMap.get("one")); <em>// print one =
jeden</em> System.out.println("two = " + biMap.get("two")); <em>// print
two = dwa</em> System.out.println("kula = " +
biMap.inverse().get("kula")); <em>// print kula = ball</em>
System.out.println("snieg = " + biMap.inverse().get("snieg")); <em>//
print snieg = snow</em> System.out.println("empty = " +
biMap.get("empty")); <em>// print empty = null</em></p>
<p>// Print count word's pair</p>
<p>System.out.println(biMap.size()); <em>//print 5</em></p>
<p>3. HashMultiMap from Guava</p>
<p>String INPUT_TEXT = "Hello World! Hello All! Hi World!"; <em>// Parse
text to words and index</em></p>
<p>List words = Arrays.asList(INPUT_TEXT.split(" "));</p>
<p>// Create Multimap</p>
<p>Multimap multiMap = HashMultimap.create();</p>
<p>// Fill Multimap</p>
<p><strong>int</strong> i = 0;</p>
<p><strong>for</strong>(String word: words) {</p>
<p>multiMap.put(word, i);</p>
<p>i++;</p>
<p>}</p>
<p>// Print all words</p>
<p><em>System.out.println(multiMap);</em> // print {Hi=[4], Hello=[0,
2], World!=[1, 5], All!=[3]} - keys</p>
<p>and values in random orders</p>
<p>// Print all unique words</p>
<p><em>System.out.println(multiMap.keySet());</em> // print [Hi, Hello,
World!, All!] - in random</p>
<p>orders</p>
<p>// Print all indexes</p>
<p>System.out.println("Hello = " + multiMap.get("Hello")); <em>// print
[0, 2]</em> System.out.println("World = " + multiMap.get("World!"));
<em>// print [1, 5]</em> System.out.println("All = " +
multiMap.get("All!")); <em>// print [3]</em> System.out.println("Hi = "
+ multiMap.get("Hi")); <em>// print [4]</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 363</p>
<p><span id="System_out_println__Empty"
class="anchor"></span>System.out.println("Empty = " +
multiMap.get("Empty")); <em>// print []</em></p>
<p>// Print count all words</p>
<p>System.out.println(multiMap.size()); <em>//print 6</em></p>
<p>// Print count unique words</p>
<p>System.out.println(multiMap.keySet().size()); <em>//print 4</em></p>
<p>Nore examples:</p>
<p>I. Apache Collection:</p>
<p>1. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheMultiValueMapTest.java">MultiValueMap</a></p>
<p>2. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheMultiValueMapLinkedTest.java">MultiValueMapLinked</a></p>
<p>3. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheMultiValueMapTreeTest.java">MultiValueMapTree</a></p>
<p>II. GS / Eclipse Collection</p>
<p>1. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsFastListMultimapTest.java">FastListMultimap</a></p>
<p>2. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsHashBiMapTest.java">HashBagMultimap</a></p>
<p>3. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsTreeSortedSetMultimapTest.java">TreeSortedSetMultimap</a></p>
<p>4. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsUnifiedSetMultimapTest.java">UnifiedSetMultimap</a></p>
<p>III. Guava</p>
<p>1. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/HashMultiMapTest.java">HashMultiMap</a></p>
<p>2. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/LinkedHashMultimapTest.java">LinkedHashMultimap</a></p>
<p>3. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/LinkedListMultimapTest.java">LinkedListMultimap</a></p>
<p>4. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/TreeMultimapTest.java">TreeMultimap</a></p>
<p>5. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/ArrayListMultimapTest.java">ArrayListMultimap</a></p>
<p>Section 62.2: Apache HashBag, Guava HashMultiset and</p>
<p>Eclipse HashBag</p>
<p>A Bag/ultiset stores each object in the collection together with a
count of occurrences. Extra methods on the</p>
<p>interface allow multiple copies of an object to be added or removed
at once. JDK analog is HashMap, when values is count of copies this
key.</p>
<p>Type Apache Commons Guava GS Collections JDK Collections</p>
<p>Order not <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/HashMultiset.html">HashMultiset</a>
<a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/bag/HashBag.html">HashBag</a>
<a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/mutable/HashBag.html">HashBag</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>
defined</p>
<p>Sorted <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeMultiset.html">TreeMultiset</a>
<a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/TreeBag.html">TreeBag</a>
<a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/sorted/mutable/TreeBag.html">TreeBag</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a></p>
<p>Insertion-order <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultiset.html">LinkedHashMultiset</a>
- - <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a></p>
<p>Concurrent Collections <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ConcurrentHashMultiset.html">ConcurrentHashMultiset</a>
<a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/bag/SynchronizedBag.html">SynchronizedBag</a>
<a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/mutable/SynchronizedBag.html">SynchronizedBag</a>.synchronizedMap(HashMap&lt;String,
Integer&gt;) variant</p>
<p>Concurrent - <a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/bag/SynchronizedSortedBag.html">SynchronizedSortedBag</a>
<a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/sorted/mutable/SynchronizedSortedBag.html">SynchronizedSortedBag</a>
Collections.synchronizedSortedMap(TreeMap&lt;String,Integer&gt;) and
sorted</p>
<p>Immutable Collections <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html">ImmutableMultiset</a>
<a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/bag/UnmodifiableBag.html">UnmodifiableBag</a>
<a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/mutable/UnmodifiableBag.html">UnmodifiableBag</a>.unmodifiableMap(HashMap&lt;String,
Integer)] collection</p>
<p>and sorted <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedMultiset.html">ImmutableSortedMultiset</a>
<a
href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/bag/UnmodifiableSortedBag.html">UnmodifiableSortedBag</a>
UnmodifiableSortedBag Immutable
Collections.unmodifiableSortedMap(TreeMap&lt;String, Integer&gt;)</p>
<p>Examples<strong>:</strong></p>
<p><a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/sorted/mutable/SynchronizedSortedBag.html">1.
Using SynchronizedSortedBag from Apache:</a></p>
<p>// Parse text to separate words</p>
<p>String INPUT_TEXT = "Hello World! Hello All! Hi World!";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 364</p>
<p>// Create Multiset</p>
<p>Bag bag = SynchronizedSortedBag.synchronizedBag(<strong>new</strong>
TreeBag(Arrays.asList(INPUT_TEXT.split("</p>
<p>"))));</p>
<p>// Print count words</p>
<p><em>System.out.println(bag);</em> // print
[1:All!,2:Hello,1:Hi,2:World!]- in natural (alphabet) order // Print all
unique words</p>
<p><em>System.out.println(bag.uniqueSet());</em> // print [All!, Hello,
Hi, World!]- in natural</p>
<p>(alphabet) order</p>
<p>// Print count occurrences of words</p>
<p>System.out.println("Hello = " + bag.getCount("Hello")); <em>// print
2</em> System.out.println("World = " + bag.getCount("World!")); <em>//
print 2</em> System.out.println("All = " + bag.getCount("All!")); <em>//
print 1</em> System.out.println("Hi = " + bag.getCount("Hi")); <em>//
print 1</em> System.out.println("Empty = " + bag.getCount("Empty"));
<em>// print 0</em></p>
<p>// Print count all words</p>
<p>System.out.println(bag.size()); <em>//print 6</em></p>
<p>// Print count unique words</p>
<p>System.out.println(bag.uniqueSet().size()); <em>//print 4</em></p>
<p><a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/sorted/mutable/TreeBag.html">2.
Using TreeBag from Eclipse(GC):</a></p>
<p>// Parse text to separate words</p>
<p>String INPUT_TEXT = "Hello World! Hello All! Hi World!"; <em>//
Create Multiset</em></p>
<p>MutableSortedBag bag =
TreeBag.newBag(Arrays.asList(INPUT_TEXT.split(" ")));</p>
<p>// Print count words</p>
<p><em>System.out.println(bag);</em> // print [All!, Hello, Hello, Hi,
World!, World!]- in natural order // Print all unique words</p>
<p><em>System.out.println(bag.toSortedSet());</em> // print [All!,
Hello, Hi, World!]- in natural order</p>
<p>// Print count occurrences of words</p>
<p>System.out.println("Hello = " + bag.occurrencesOf("Hello")); <em>//
print 2</em> System.out.println("World = " +
bag.occurrencesOf("World!")); <em>// print 2</em>
System.out.println("All = " + bag.occurrencesOf("All!")); <em>// print
1</em> System.out.println("Hi = " + bag.occurrencesOf("Hi")); <em>//
print 1</em> System.out.println("Empty = " +
bag.occurrencesOf("Empty")); <em>// print 0</em></p>
<p>// Print count all words</p>
<p>System.out.println(bag.size()); <em>//print 6</em></p>
<p>// Print count unique words</p>
<p>System.out.println(bag.toSet().size()); <em>//print 4</em></p>
<p><a
href="http://www.goldmansachs.com/gs-collections/javadoc/6.1.0/com/gs/collections/impl/bag/sorted/mutable/SynchronizedSortedBag.html">3.
Using LinkedHashMultiset from Guava:</a></p>
<p>// Parse text to separate words</p>
<p>String INPUT_TEXT = "Hello World! Hello All! Hi World!"; <em>//
Create Multiset</em></p>
<p>Multiset multiset =
LinkedHashMultiset.create(Arrays.asList(INPUT_TEXT.split(" ")));</p>
<p>// Print count words</p>
<p><em>System.out.println(multiset);</em> // print [Hello x 2, World! x
2, All!, Hi]- in predictable</p>
<p>iteration order</p>
<p>// Print all unique words</p>
<p>System.out.println(multiset.elementSet()); <em>// print [Hello,
World!, All!, Hi] - in</em></p>
<p>predictable iteration order</p>
<p>// Print count occurrences of words</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 365</p>
<p><span id="System_out_println__Hello"
class="anchor"></span>System.out.println("Hello = " +
multiset.count("Hello")); <em>// print 2</em> System.out.println("World
= " + multiset.count("World!")); <em>// print 2</em>
System.out.println("All = " + multiset.count("All!")); <em>// print
1</em> System.out.println("Hi = " + multiset.count("Hi")); <em>// print
1</em> System.out.println("Empty = " + multiset.count("Empty")); <em>//
print 0</em></p>
<p>// Print count all words</p>
<p>System.out.println(multiset.size()); <em>//print 6</em></p>
<p>// Print count unique words</p>
<p>System.out.println(multiset.elementSet().size()); <em>//print
4</em></p>
<p>More examples:</p>
<p>I. Apache Collection:</p>
<p>1. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheHashBagTest.java">HashBag
- order not defined</a></p>
<p>2. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheSynchronizedBagTest.java">SynchronizedBag
- concurrent and order not defined</a></p>
<p>3. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheSynchronizedSortedBagTest.java">SynchronizedSortedBag</a>
- - concurrent and sorted order</p>
<p>4. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/ApacheTreeBagTest.java">TreeBag</a>
- sorted order</p>
<p>II. GS / Eclipse Collection</p>
<p>5. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsMutableBagTest.java">MutableBag
- order not defined</a></p>
<p>6. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/GsMutableSortedBagTest.java">MutableSortedBag
- sorted order</a></p>
<p>III. Guava</p>
<p>7. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/guava/src/GuavaHashMultisetTest.java">HashMultiset
- order not defined</a></p>
<p>8. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/TreeMultisetTest.java">TreeMultiset</a>
- sorted order</p>
<p>9. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/LinkedHashMultisetTest.java">LinkedHashMultiset</a>
- insertion order</p>
<p>10. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections//src/ConcurrentHashMultisetTest.java">ConcurrentHashMultiset</a>
- concurrent and order not defined</p>
<p>Section 62.3: Compare operation with collections - Create</p>
<p>collections</p>
<p>Compare operation with collections - Create collections</p>
<p>1. Create List</p>
<p>Description JDK guava gs-collections</p>
<p>Create <strong>new</strong> ArrayList&lt;&gt;() Lists.newArrayList()
FastList.newList() empty list</p>
<p>Create list Arrays.asList("1", "2", FastList.newListWith("1", Lists.
newArrayList ( "1" , "2" , "3" ) from values "3" ) "2" , "3" )</p>
<p>Create list</p>
<p>with <strong>new</strong> ArrayList&lt;&gt;(100)
Lists.newArrayListWithCapacity(100) FastList.newList(100) capacity =
100</p>
<p>Create list <strong>new</strong> from any
Lists.newArrayList(collection) FastList.newList(collection) ArrayList
&lt;&gt;( collection ) collectin</p>
<p>Create list</p>
<p>from any - Lists.newArrayList(iterable) FastList.newList(iterable)
Iterable</p>
<p>Create list</p>
<p>from - Lists.newArrayList(iterator) -</p>
<p>Iterator</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 366</p>
<p>Create list Arrays.asList(array) Lists.newArrayList(array)
FastList.newListWith(array) from array</p>
<p>Create list FastList.newWithNValues(10, using--()-&gt; "1" )
factory</p>
<p>Examples:</p>
<p>System.out.println("createArrayList start");</p>
<p>// Create empty list</p>
<p>List emptyGuava = Lists.newArrayList(); <em>// using guava</em></p>
<p>List emptyJDK = <strong>new</strong> ArrayList&lt;&gt;(); <em>//
using JDK</em></p>
<p>MutableList emptyGS = FastList.newList(); <em>// using gs</em></p>
<p>// Create list with 100 element</p>
<p>List &lt; String &gt; exactly100 =
Lists.newArrayListWithCapacity(100); <em>// using guava</em></p>
<p>List exactly100JDK = <strong>new</strong> ArrayList&lt;&gt;(100);
<em>// using JDK</em></p>
<p>MutableList empty100GS = FastList.newList(100); <em>// using
gs</em></p>
<p>// Create list with about 100 element</p>
<p>List approx100 = Lists.newArrayListWithExpectedSize(100); <em>//
using guava</em></p>
<p>List approx100JDK = <strong>new</strong> ArrayList&lt;&gt;(115);
<em>// using JDK</em></p>
<p>MutableList approx100GS = FastList.newList(115); <em>// using
gs</em></p>
<p>// Create list with some elements</p>
<p>List withElements = Lists.newArrayList("alpha", "beta", "gamma");
<em>// using guava</em></p>
<p>List withElementsJDK = Arrays.asList("alpha", "beta", "gamma");
<em>// using JDK</em></p>
<p>MutableList withElementsGS = FastList.newListWith("alpha", "beta",
"gamma"); <em>// using gs</em></p>
<p>System.out.println(withElements);</p>
<p>System.out.println(withElementsJDK);</p>
<p>System.out.println(withElementsGS);</p>
<p>// Create list from any Iterable interface (any collection)</p>
<p>Collection collection = <strong>new</strong> HashSet&lt;&gt;(3);</p>
<p>collection.add("1");</p>
<p>collection.add("2");</p>
<p>collection.add("3");</p>
<p>List fromIterable = Lists.newArrayList(collection); <em>// using
guava</em></p>
<p>List fromIterableJDK = <strong>new</strong>
ArrayList&lt;&gt;(collection); <em>// using JDK</em></p>
<p>MutableList fromIterableGS = FastList.newList(collection); <em>//
using gs</em></p>
<p>System.out.println(fromIterable);</p>
<p>System.out.println(fromIterableJDK);</p>
<p>System.out.println(fromIterableGS);</p>
<p>/* Attention: JDK create list only from Collection, but guava and gs
can create list from</p>
<p>Iterable and Collection */</p>
<p>// Create list from any Iterator</p>
<p>Iterator iterator = collection.iterator();</p>
<p>List fromIterator = Lists.newArrayList(iterator); <em>// using
guava</em></p>
<p>System.out.println(fromIterator);</p>
<p>// Create list from any array</p>
<p>String[] array = {"4", "5", "6"};</p>
<p>List fromArray = Lists.newArrayList(array); <em>// using
guava</em></p>
<p>List fromArrayJDK = Arrays.asList(array); <em>// using JDK</em></p>
<p>MutableList fromArrayGS = FastList.newListWith(array); <em>// using
gs</em></p>
<p>System.out.println(fromArray);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 367</p>
<p>System.out.println(fromArrayJDK);</p>
<p>System.out.println(fromArrayGS);</p>
<p>// Create list using fabric</p>
<p>MutableList fromFabricGS = FastList.newWithNValues(10, ()-&gt;
String.valueOf(Math.random())); <em>// using gs</em></p>
<p>System.out.println(fromFabricGS);</p>
<p>System.out.println("createArrayList end");</p>
<p>2 Create Set</p>
<p>Description JDK guava gs-collections</p>
<p>Create <strong>new</strong> HashSet&lt;&gt;() Sets.newHashSet()
UnifiedSet.newSet() empty set</p>
<p>Creatre set <strong>new</strong> HashSet Sets.newHashSet("alpha",
UnifiedSet.newSetWith("alpha",</p>
<p>from values &lt;&gt;(Arrays.asList("alpha",</p>
<p>"beta", "gamma")) "beta", "gamma") "beta", "gamma")</p>
<p>Create set</p>
<p>from any <strong>new</strong> HashSet&lt;&gt;(collection)
Sets.newHashSet(collection) UnifiedSet.newSet(collection)
collections</p>
<p>Create set</p>
<p>from any - Sets.newHashSet(iterable) UnifiedSet.newSet(iterable)
Iterable</p>
<p>Create set</p>
<p>from any - Sets.newHashSet(iterator) -</p>
<p>Iterator</p>
<p>Create set <strong>new</strong> Sets.newHashSet(array)
UnifiedSet.newSetWith(array) from Array HashSet &lt;&gt;( Arrays .
asList ( array ))</p>
<p>Examples:</p>
<p>System.out.println("createHashSet start");</p>
<p>// Create empty set</p>
<p>Set emptyGuava = Sets.newHashSet(); <em>// using guava</em></p>
<p>Set emptyJDK = <strong>new</strong> HashSet&lt;&gt;(); <em>// using
JDK</em></p>
<p>Set emptyGS = UnifiedSet.newSet(); <em>// using gs</em></p>
<p>// Create set with 100 element</p>
<p>Set approx100 = Sets.newHashSetWithExpectedSize(100); <em>// using
guava</em></p>
<p>Set approx100JDK = <strong>new</strong> HashSet&lt;&gt;(130); <em>//
using JDK</em></p>
<p>Set approx100GS = UnifiedSet.newSet(130); <em>// using gs</em></p>
<p>// Create set from some elements</p>
<p>Set withElements = Sets.newHashSet("alpha", "beta", "gamma"); <em>//
using guava</em></p>
<p>Set withElementsJDK = <strong>new</strong>
HashSet&lt;&gt;(Arrays.asList("alpha", "beta", "gamma")); <em>// using
JDK</em></p>
<p>Set withElementsGS = UnifiedSet.newSetWith("alpha", "beta", "gamma");
<em>// using gs</em></p>
<p>System.out.println(withElements);</p>
<p>System.out.println(withElementsJDK);</p>
<p>System.out.println(withElementsGS);</p>
<p>// Create set from any Iterable interface (any collection)</p>
<p>Collection collection = <strong>new</strong>
ArrayList&lt;&gt;(3);</p>
<p>collection.add("1");</p>
<p>collection.add("2");</p>
<p>collection.add("3");</p>
<p>Set fromIterable = Sets.newHashSet(collection); <em>// using
guava</em></p>
<p>Set fromIterableJDK = <strong>new</strong>
HashSet&lt;&gt;(collection); <em>// using JDK</em></p>
<p>Set fromIterableGS = UnifiedSet.newSet(collection); <em>// using
gs</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 368</p>
<p>System.out.println(fromIterable);</p>
<p>System.out.println(fromIterableJDK);</p>
<p>System.out.println(fromIterableGS);</p>
<p>/* Attention: JDK create set only from Collection, but guava and gs
can create set from Iterable</p>
<p>and Collection */</p>
<p>// Create set from any Iterator</p>
<p>Iterator iterator = collection.iterator();</p>
<p>Set fromIterator = Sets.newHashSet(iterator); <em>// using
guava</em></p>
<p>System.out.println(fromIterator);</p>
<p>// Create set from any array</p>
<p>String[] array = {"4", "5", "6"};</p>
<p>Set fromArray = Sets.newHashSet(array); <em>// using guava</em></p>
<p>Set fromArrayJDK = <strong>new</strong>
HashSet&lt;&gt;(Arrays.asList(array)); <em>// using JDK</em></p>
<p>Set fromArrayGS = UnifiedSet.newSetWith(array); <em>// using
gs</em></p>
<p>System.out.println(fromArray);</p>
<p>System.out.println(fromArrayJDK);</p>
<p>System.out.println(fromArrayGS);</p>
<p>System.out.println("createHashSet end");</p>
<p>3 Create Map</p>
<p>Description JDK guava gs-collections</p>
<p>Create empty <strong>new</strong> Maps.newHashMap()
UnifiedMap.newMap() map HashMap &lt;&gt;()</p>
<p>Create map <strong>new</strong> with capacity
Maps.newHashMapWithExpectedSize(100) UnifiedMap.newMap(130) HashMap
&lt;&gt;( 130 ) = 130</p>
<p>Create map <strong>new</strong> from other Maps.newHashMap(map)
UnifiedMap.newMap(map) HashMap &lt;&gt;( map ) map</p>
<p>Create map UnifiedMap.newWithKeysValues("1",--from keys "a" , "2" ,
"b" )</p>
<p>Examples:</p>
<p>System.out.println("createHashMap start");</p>
<p>// Create empty map</p>
<p>Map emptyGuava = Maps.newHashMap(); <em>// using guava</em></p>
<p>Map emptyJDK = <strong>new</strong> HashMap&lt;&gt;(); <em>// using
JDK</em></p>
<p>Map emptyGS = UnifiedMap.newMap(); <em>// using gs</em></p>
<p>// Create map with about 100 element</p>
<p>Map approx100 = Maps.newHashMapWithExpectedSize(100); <em>// using
guava</em></p>
<p>Map approx100JDK = <strong>new</strong> HashMap&lt;&gt;(130); <em>//
using JDK</em></p>
<p>Map approx100GS = UnifiedMap.newMap(130); <em>// using gs</em></p>
<p>// Create map from another map</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;(3);</p>
<p>map.put("k1","v1");</p>
<p>map.put("k2","v2");</p>
<p>Map withMap = Maps.newHashMap(map); <em>// using guava</em></p>
<p>Map withMapJDK = <strong>new</strong> HashMap&lt;&gt;(map); <em>//
using JDK</em></p>
<p>Map withMapGS = UnifiedMap.newMap(map); <em>// using gs</em></p>
<p>System.out.println(withMap);</p>
<p>System.out.println(withMapJDK);</p>
<p>System.out.println(withMapGS);</p>
<p>// Create map from keys</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 369</p>
<p>Map withKeys = UnifiedMap.newWithKeysValues("1", "a", "2", "b");</p>
<p>System.out.println(withKeys);</p>
<p>System.out.println("createHashMap end");</p>
<p>More examples: <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/gs-eclipse/src/CreateCollectionTest.java">CreateCollectionTest</a></p>
<p>1. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/CollectionCompareTests.java">CollectionCompare</a></p>
<p>2. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/CollectionSearchTests.java">CollectionSearch</a></p>
<p>3. <a
href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/1.6-usefull-libraries/collections/apache-commons/src/JavaTransformTest.java">JavaTransform</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 370</p>
<p><span id="Chapter_63__Concurrent_Collectio_1"
class="anchor"></span>Chapter 63: Concurrent Collections</p>
<p>A <em>concurrent collection</em> is a [collection][1] which permits
access by more than one thread at the same time. Different</p>
<p>threads can typically iterate through the contents of the collection
and add or remove elements. The collection is responsible for ensuring
that the collection doesn't become corrupt. [1]:</p>
<p>http://stackoverflow.com/documentation/java/90/collections#t=201612221936497298484</p>
<p>Section 63.1: Thread-safe Collections</p>
<p>By default, the various Collection types are not thread-safe.</p>
<p>However, it's fairly easy to make a collection thread-safe.</p>
<p>List threadSafeList =
Collections.synchronizedList(<strong>new</strong> ArrayList()); Set
threadSafeSet = Collections.synchronizedSet(<strong>new</strong>
HashSet()); Map threadSafeMap =
Collections.synchronizedMap(<strong>new</strong> HashMap());</p>
<p>When you make a thread-safe collection, you should never access it
through the original collection, only through</p>
<p>the thread-safe wrapper.</p>
<p>Version ≥ Java SE 5</p>
<p>Starting in Java 5, java.util.collections has several new thread-safe
collections that don't need the various</p>
<p>Collections.<strong>synchronized</strong> methods.</p>
<p>List threadSafeList = <strong>new</strong> CopyOnWriteArrayList();
Set threadSafeSet = <strong>new</strong> ConcurrentHashSet(); Map
threadSafeMap = <strong>new</strong> ConcurrentHashMap();</p>
<p>Section 63.2: Insertion into ConcurrentHashMap</p>
<p><strong>public class</strong> InsertIntoConcurrentHashMap</p>
<p>{</p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>{</p>
<p>ConcurrentHashMap concurrentHashMap = <strong>new</strong>
ConcurrentHashMap&lt;&gt;();</p>
<p>SomeObject value = <strong>new</strong> SomeObject();</p>
<p>Integer key = 1;</p>
<p>SomeObject previousValue = concurrentHashMap.putIfAbsent(1,
value);</p>
<p><strong>if</strong> (previousValue != <strong>null</strong>)</p>
<p>{</p>
<p>//Then some other value was mapped to key = 1. 'value' that was
passed to //putIfAbsent method is NOT inserted, hence, any other thread
which calls //concurrentHashMap.get(1) would NOT receive a reference to
the 'value' //that your thread attempted to insert. Decide how you wish
to handle //this situation.</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>//'value' reference is mapped to key = 1.</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 371</p>
<p><span id="_24" class="anchor"></span>}</p>
<p>Section 63.3: Concurrent Collections</p>
<p>Concurrent collections are a generalization of thread-safe
collections, that allow for a broader usage in a concurrent
environment.</p>
<p>While thread-safe collections have safe element addition or removal
from multiple threads, they do not necessarily have safe iteration in
the same context (one may not be able to safely iterate through the
collection in one thread,</p>
<p>while another one modifies it by adding/removing elements).</p>
<p>This is where concurrent collections are used.</p>
<p>As iteration is often the base implementation of several bulk methods
in collections, like addAll, removeAll, or also collection copying
(through a constructor, or other means), sorting, ... the use case for
concurrent collections is</p>
<p>actually pretty large.</p>
<p>For example, the Java SE 5 java.util.concurrent.CopyOnWriteArrayList
is a thread safe and concurrent List</p>
<p>implementation, its <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArrayList.html">javadoc</a>
states :</p>
<p>The "snapshot" style iterator method uses a reference to the state of
the array at the point that the iterator was created. This array never
changes during the lifetime of the iterator, so interference is</p>
<p>impossible and the iterator is guaranteed not to throw
ConcurrentModificationException.</p>
<p>Therefore, the following code is safe :</p>
<p><strong>public class</strong> ThreadSafeAndConcurrent {</p>
<p><strong>public static final</strong> List LIST = <strong>new</strong>
CopyOnWriteArrayList&lt;&gt;();</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> InterruptedException {</p>
<p>Thread modifier = <strong>new</strong> Thread(<strong>new</strong>
ModifierRunnable()); Thread iterator = <strong>new</strong>
Thread(<strong>new</strong> IteratorRunnable());</p>
<p>modifier.start();</p>
<p>iterator.start();</p>
<p>modifier.join();</p>
<p>iterator.join();</p>
<p>}</p>
<p>public static final class <strong>ModifierRunnable</strong>
implements <strong>Runnable {</strong></p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 50000; i++)
{</p>
<p>LIST.add(i);</p>
<p>}</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static final class <strong>IteratorRunnable</strong>
implements <strong>Runnable {</strong></p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 372</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10000; i++)
{</p>
<p><strong>long</strong> total = 0;</p>
<p><strong>for</strong>(Integer inList : LIST) {</p>
<p>total += inList;</p>
<p>}</p>
<p>System.out.println(total);</p>
<p>}</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html">Another
concurrent collection regarding iteration is ConcurrentLinkedQueue</a>,
which states :</p>
<p>Iterators are weakly consistent, returning elements reflecting the
state of the queue at some point at or since the creation of the
iterator. They do not throw java.util.ConcurrentModificationException,
and may</p>
<p>proceed concurrently with other operations. Elements contained in the
queue since the creation of the iterator will be returned exactly
once.</p>
<p>One should check the javadocs to see if a collection is concurrent,
or not. The attributes of the iterator returned by</p>
<p>the iterator() method ("fail fast", "weakly consistent", ...) is the
most important attribute to look for.</p>
<p>Thread safe but non concurrent examples</p>
<p>In the above code, changing the LIST declaration to</p>
<p><strong>public static final</strong> List LIST =
Collections.synchronizedList(<strong>new</strong>
ArrayList&lt;&gt;());</p>
<p>Could (and statistically will on most modern, multi CPU/core
architectures) lead to exceptions.</p>
<p>Synchronized collections from the Collections utility methods are
thread safe for addition/removal of elements, but not iteration (unless
the underlying collection being passed to it already is).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 373</p>
<p><span id="Chapter_64__Choosing_Collections_1"
class="anchor"></span>Chapter 64: Choosing Collections</p>
<p>Java offers a wide variety of Collections. Choosing which Collection
to use can be tricky. See the Examples section</p>
<p>for an easy-to-follow flowchart to choose the right Collection for
the job.</p>
<p>Section 64.1: Java Collections Flowchart</p>
<p>Use the following flowchart to choose the right Collection for the
job.</p>
<p><img src="media/index-398_1.jpeg" style="width:6.5in;height:4in"
alt="index-398_1.jpg" /></p>
<p>This flowchart was based off [<a
href="https://i.stack.imgur.com/aSDsG.png)">http://i.stack.imgur.com/aSDsG.png).</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 374</p>
<p><span id="Chapter_65__super_keyword_1" class="anchor"></span>Chapter
65: super keyword</p>
<p>Section 65.1: Super keyword use with examples</p>
<p>super keyword performs important role in three places</p>
<p>1. Constructor Level</p>
<p>2. Method Level</p>
<p>3. Variable Level</p>
<p>Constructor Level</p>
<p><strong>super</strong> keyword is used to call parent class
constructor. This constructor can be default constructor or</p>
<p>parameterized constructor.</p>
<p>Default constructor : <strong>super</strong>();</p>
<p>Parameterized constructor :
<strong>super</strong>(<strong>int</strong> no, <strong>double</strong>
amount, String name);</p>
<p><strong>class</strong> Parentclass</p>
<p>{</p>
<p>Parentclass(){</p>
<p>System.out.println("Constructor of Superclass");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Subclass <strong>extends</strong>
Parentclass</p>
<p>{</p>
<p>Subclass(){</p>
<p>/* Compile adds super() here at the first line</p>
<p>* of this constructor implicitly</p>
<p>*/</p>
<p>System.out.println("Constructor of Subclass");</p>
<p>}</p>
<p>Subclass(<strong>int</strong> n1){</p>
<p>/* Compile adds super() here at the first line</p>
<p>* of this constructor implicitly</p>
<p>*/</p>
<p>System.out.println("Constructor with arg");</p>
<p>}</p>
<p><strong>void</strong> display(){</p>
<p>System.out.println("Hello");</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>// Creating object using default constructor</p>
<p>Subclass obj= <strong>new</strong> Subclass();</p>
<p>//Calling sub class method</p>
<p>obj.display();</p>
<p>//Creating object 2 using arg constructor</p>
<p>Subclass obj2= <strong>new</strong> Subclass(10);</p>
<p>obj2.display();</p>
<p>}</p>
<p>}</p>
<p><strong>Note</strong> : <strong>super</strong>() must be the first
statement in constructor otherwise we will get the compilation error
message.</p>
<p>Method Level</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 375</p>
<p><strong>super</strong> keyword can also be used in case of method
overriding. <strong>super</strong> keyword can be used to invoke or call
parent class method.</p>
<p><strong>class</strong> Parentclass</p>
<p>{</p>
<p>//Overridden method</p>
<p><strong>void</strong> display(){</p>
<p>System.out.println("Parent class method");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Subclass <strong>extends</strong>
Parentclass</p>
<p>{</p>
<p>//Overriding method</p>
<p><strong>void</strong> display(){</p>
<p>System.out.println("Child class method");</p>
<p>}</p>
<p><strong>void</strong> printMsg(){</p>
<p>//This would call Overriding method</p>
<p>display();</p>
<p>//This would call Overridden method</p>
<p><strong>super</strong>.display();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>Subclass obj= <strong>new</strong> Subclass();</p>
<p>obj.printMsg();</p>
<p>}</p>
<p>}</p>
<p><strong>Note</strong>:If there is not method overriding then we do
not need to use <strong>super</strong> keyword to call parent class
method.</p>
<p>Variable Level</p>
<p><strong>super</strong> is used to refer immediate parent class
instance variable. In case of inheritance, there may be possibility
of</p>
<p>base class and derived class may have similar data members.In order
to differentiate between the data member of base/parent class and
derived/child class, in the context of derived class the base class data
members must be</p>
<p>preceded by <strong>super</strong> keyword.</p>
<p>//Parent class or Superclass</p>
<p><strong>class</strong> Parentclass</p>
<p>{</p>
<p><strong>int</strong> num=100;</p>
<p>}</p>
<p>//Child class or subclass</p>
<p><strong>class</strong> Subclass <strong>extends</strong>
Parentclass</p>
<p>{</p>
<p>/* I am declaring the same variable</p>
<p>* num in child class too.</p>
<p>*/</p>
<p><strong>int</strong> num=110;</p>
<p><strong>void</strong> printNumber(){</p>
<p>System.out.println(num); <em>//It will print value 110</em></p>
<p>System.out.println(<strong>super</strong>.num); <em>//It will print
value 100</em></p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>Subclass obj= <strong>new</strong> Subclass();</p>
<p>obj.printNumber();</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 376</p>
<p><strong>Note</strong>: If we are not writing <strong>super</strong>
keyword before the base class data member name then it will be referred
as</p>
<p>current class data member and base class data member are hidden in
the context of derived class.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 377</p>
<p><span id="Chapter_66__Serialization_1" class="anchor"></span>Chapter
66: Serialization</p>
<p>Java provides a mechanism, called object serialization where an
object can be represented as a sequence of bytes</p>
<p>that includes the object's data as well as information about the
object's type and the types of data stored in the object.</p>
<p>After a serialized object has been written into a file, it can be
read from the file and deserialized that is, the type information and
bytes that represent the object and its data can be used to recreate the
object in memory.</p>
<p>Section 66.1: Basic Serialization in Java</p>
<p>What is Serialization</p>
<p>Serialization is the process of converting an object's state
(including its references) to a sequence of bytes, as well as the
process of rebuilding those bytes into a live object at some future
time. Serialization is used when you want</p>
<p>to persist the object. It is also used by Java RMI to pass objects
between JVMs, either as arguments in a method invocation from a client
to a server or as return values from a method invocation, or as
exceptions thrown by</p>
<p>remote methods. In general, serialization is used when we want the
object to exist beyond the lifetime of the JVM.</p>
<p>java.io.Serializable is a marker interface (has no body). It is just
used to "mark" Java classes as serializable.</p>
<p>The serialization runtime associates with each serializable class a
version number, called a serialVersionUID, which is used during
<em>de</em>-serialization to verify that the sender and receiver of a
serialized object have loaded classes</p>
<p>for that object that are compatible with respect to serialization. If
the receiver has loaded a class for the object that has a different
serialVersionUID than that of the corresponding sender's class, then
deserialization will result in</p>
<p>an InvalidClassException. A serializable class can declare its own
serialVersionUID explicitly by declaring a field named serialVersionUID
that must be <strong>static</strong>, <strong>final</strong>, and of
type <strong>long</strong>:</p>
<p>ANY-ACCESS-MODIFIER <strong>static final long</strong>
serialVersionUID = 1L;</p>
<p>How to make a class eligible for serialization</p>
<p>To persist an object the respective class must implement the
java.io.Serializable interface.</p>
<p><strong>import</strong> java.io.Serializable;</p>
<p><strong>public class</strong> SerialClass <strong>implements</strong>
Serializable {</p>
<p>private static final long <strong>serialVersionUID = 1L;</strong></p>
<p><strong>private</strong> Date currentTime;</p>
<p><strong>public</strong> SerialClass() {</p>
<p>currentTime = Calendar.getInstance().getTime();</p>
<p>}</p>
<p><strong>public</strong> Date getCurrentTime() {</p>
<p><strong>return</strong> currentTime;</p>
<p>}</p>
<p>}</p>
<p>How to write an object into a file</p>
<p>Now we need to write this object to a file system. We use
java.io.ObjectOutputStream for this purpose.</p>
<p><strong>import</strong> java.io.FileOutputStream;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 378</p>
<p><span id="import_java_io_ObjectOutputStrea"
class="anchor"></span><strong>import</strong>
java.io.ObjectOutputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>public class</strong> PersistSerialClass {</p>
<p><strong>public static void</strong> main(String [] args) {</p>
<p>String filename = "time.ser";</p>
<p><em>SerialClass time = <strong>new</strong> SerialClass();</em> //We
will write this object to file system.</p>
<p>try <strong>{</strong></p>
<p>ObjectOutputStream out = <strong>new</strong>
ObjectOutputStream(<strong>new</strong> FileOutputStream(filename));</p>
<p><em>out.writeObject(time);</em> //Write byte stream to file
system.</p>
<p>out.close();</p>
<p>} <strong>catch</strong>(IOException ex){</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>How to recreate an object from its serialized state</p>
<p>The stored object can be read from file system at later time using
java.io.ObjectInputStream as shown below:</p>
<p><strong>import</strong> java.io.FileInputStream;</p>
<p><strong>import</strong> java.io.ObjectInputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.java.lang.ClassNotFoundException;</p>
<p><strong>public class</strong> ReadSerialClass {</p>
<p><strong>public static void</strong> main(String [] args) {</p>
<p>String filename = "time.ser";</p>
<p>SerialClass time = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>ObjectInputStream in = <strong>new</strong>
ObjectInputStream(<strong>new</strong> FileInputStream(filename));</p>
<p>time = (SerialClass)in.readObject();</p>
<p>in.close();</p>
<p>} <strong>catch</strong>(IOException ex){</p>
<p>ex.printStackTrace();</p>
<p>} <strong>catch</strong>(ClassNotFoundException cnfe){</p>
<p>cnfe.printStackTrace();</p>
<p>}</p>
<p>// print out restored time</p>
<p>System.out.println("Restored time: " + time.getTime());</p>
<p>}</p>
<p>}</p>
<p>The serialized class is in binary form. The deserialization can be
problematic if the class definition changes: see the</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/version.html">Versioning
of Serialized Objects chapter of the Java Serialization
Specification</a> for details.</p>
<p>Serializing an object serializes the entire object graph of which it
is the root, and operates correctly in the presence of cyclic graphs. A
reset() method is provided to force the ObjectOutputStream to forget
about objects that have</p>
<p>already been serialized.</p>
<p><a
href="http://stackoverflow.com/questions/910374/why-does-java-have-transient-fields">Transient-fields
- Serialization</a></p>
<p>Section 66.2: Custom Serialization</p>
<p>In this example we want to create a class that will generate and
output to console, a random number between a</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 379</p>
<p>range of two integers which are passed as arguments during the
initialization.</p>
<p><strong>public class</strong> SimpleRangeRandom
<strong>implements</strong> Runnable {</p>
<p>private int <strong>min;</strong></p>
<p>private int <strong>max;</strong></p>
<p><strong>private</strong> Thread thread;</p>
<p><strong>public</strong> SimpleRangeRandom(<strong>int</strong> min,
<strong>int</strong> max){</p>
<p><strong>this</strong>.min = min;</p>
<p><strong>this</strong>.max = max;</p>
<p>thread = <strong>new</strong> Thread(<strong>this</strong>);</p>
<p>thread.start();</p>
<p>}</p>
<p>@Override</p>
<p><strong>private void</strong> WriteObject(ObjectOutputStreamout)
<strong>throws</strong> IO Exception;</p>
<p><strong>private void</strong> ReadObject(ObjectInputStream in)
<strong>throws</strong> IOException, ClassNotFoundException;
<strong>public void</strong> run() {</p>
<p>while<strong>(</strong>true<strong>) {</strong></p>
<p>Random rand = <strong>new</strong> Random();</p>
<p>System.out.println("Thread: " + thread.getId() + " Random:" +
rand.nextInt(max - min)); <strong>try</strong> {</p>
<p>Thread.sleep(10000);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now if we want to make this class Serializable there will be some
problems. The Thread is one of the certain</p>
<p>system-level classes that are not Serializable. So we need to declare
the thread as <strong>transient</strong>. By doing this we will</p>
<p>be able to serialize the objects of this class but we will still have
an issue. As you can see in the constructor we set</p>
<p>the min and the max values of our randomizer and after this we start
the thread which is responsible for</p>
<p>generating and printing the random value. Thus when restoring the
persisted object by calling the <em><strong>readObject()</strong></em>
the</p>
<p>constructor will not run again as there is no creation of a new
object. In that case we need to develop a <strong>Custom</strong></p>
<p><strong>Serialization</strong> by providing two methods inside the
class. Those methods are:</p>
<p><strong>private void</strong> writeObject(ObjectOutputStream out)
<strong>throws</strong> IOException; <strong>private void</strong>
readObject(ObjectInputStream in) <strong>throws</strong> IOException,
ClassNotFoundException;</p>
<p>Thus by adding our implementation in the
<em><strong>readObject()</strong></em> we can initiate and start our
thread:</p>
<p><strong>class</strong> RangeRandom <strong>implements</strong>
Serializable, Runnable {</p>
<p>private int <strong>min;</strong></p>
<p>private int <strong>max;</strong></p>
<p>private transient <strong>Thread thread;</strong></p>
<p>//transient should be any field that either cannot be serialized e.g
Thread or any field you do not want serialized</p>
<p><strong>public</strong> RangeRandom(<strong>int</strong> min,
<strong>int</strong> max){</p>
<p><strong>this</strong>.min = min;</p>
<p><strong>this</strong>.max = max;</p>
<p>thread = <strong>new</strong> Thread(<strong>this</strong>);</p>
<p>thread.start();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 380</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>while<strong>(</strong>true<strong>) {</strong></p>
<p>Random rand = <strong>new</strong> Random();</p>
<p>System.out.println("Thread: " + thread.getId() + " Random:" +
rand.nextInt(max - min)); <strong>try</strong> {</p>
<p>Thread.sleep(10000);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> writeObject(ObjectOutputStream oos)
<strong>throws</strong> IOException {</p>
<p>oos.defaultWriteObject();</p>
<p>}</p>
<p><strong>private void</strong> readObject(ObjectInputStream in)
<strong>throws</strong> IOException, ClassNotFoundException {</p>
<p>in.defaultReadObject();</p>
<p>thread = <strong>new</strong> Thread(<strong>this</strong>);</p>
<p>thread.start();</p>
<p>}</p>
<p>}</p>
<p>Here is the main for our example:</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println("Hello");</p>
<p>RangeRandom rangeRandom = <strong>new</strong> RangeRandom(1,10);</p>
<p>FileOutputStream fos = <strong>null</strong>;</p>
<p>ObjectOutputStream out = <strong>null</strong>;</p>
<p>try</p>
<p>{</p>
<p>fos = <strong>new</strong> FileOutputStream("test");</p>
<p>out = <strong>new</strong> ObjectOutputStream(fos);</p>
<p>out.writeObject(rangeRandom);</p>
<p>out.close();</p>
<p>}</p>
<p><strong>catch</strong>(IOException ex)</p>
<p>{</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>RangeRandom rangeRandom2 = <strong>null</strong>;</p>
<p>FileInputStream fis = <strong>null</strong>;</p>
<p>ObjectInputStream in = <strong>null</strong>;</p>
<p>try</p>
<p>{</p>
<p>fis = <strong>new</strong> FileInputStream("test");</p>
<p>in = <strong>new</strong> ObjectInputStream(fis);</p>
<p>rangeRandom2 = (RangeRandom)in.readObject();</p>
<p>in.close();</p>
<p>}</p>
<p><strong>catch</strong>(IOException ex)</p>
<p>{</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p><strong>catch</strong>(ClassNotFoundException ex)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 381</p>
<p><span id="_25" class="anchor"></span>{</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>If you run the main you will see that there are two threads running
for each RangeRandom instance and that is</p>
<p>because the <em><strong>Thread.start()</strong></em> method is now in
both the constructor and the <em><strong>readObject()</strong></em>.</p>
<p>Section 66.3: Versioning and serialVersionUID</p>
<p>When you implement java.io.Serializable interface to make a class
serializable, the compiler looks for a <strong>static</strong>
<strong>final</strong> field named serialVersionUID of type
<strong>long</strong>. If the class doesn't have this field declared
explicitly then the</p>
<p>compiler will create one such field and assign it with a value which
comes out of a implementation dependent computation of serialVersionUID.
This computation depends upon various aspects of the class and it
follows the</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html">Object
Serialization Specifications given by Sun. But, the value is not
guaranteed to be the same across all compiler</a></p>
<p>implementations.</p>
<p>This value is used for checking the compatibility of the classes with
respect to serialization and this is done while de-serializing a saved
object. The Serialization Runtime verifies that serialVersionUID read
from the de-serialized data</p>
<p>and the serialVersionUID declared in the class are exactly the same.
If that is not the case, it throws an</p>
<p>InvalidClassException.</p>
<p>It's highly recommended that you explicitly declare and initialize
the static, final field of type long and named 'serialVersionUID' in all
your classes you want to make Serializable instead of relying on the
default computation of</p>
<p>the value for this field even if you are not gonna use versioning.
<strong>'serialVersionUID' computation is extremely</strong></p>
<p>sensitive and may vary from one compiler implementation to another
and hence you may turn up getting</p>
<p>the InvalidClassException even for the same class just because you
used different compiler</p>
<p>implementations on the sender and the receiver ends of the
serialization process.</p>
<p><strong>public class</strong> Example <strong>implements</strong>
Serializable {</p>
<p><em><strong>static final long</strong> serialVersionUID = 1L</em>
/*or some other value*/<em>;</em> //...</p>
<p>}</p>
<p>As long as serialVersionUID is the same, Java Serialization can
handle different versions of a class. Compatible and incompatible
changes are;</p>
<p>Compatible Changes</p>
<p><strong>Adding fields :</strong> When the class being reconstituted
has a field that does not occur in the stream, that field in</p>
<p>the object will be initialized to the default value for its type. If
class-specific initialization is needed, the class may provide a
readObject method that can initialize the field to nondefault
values.</p>
<p><strong>Adding classes :</strong> The stream will contain the type
hierarchy of each object in the stream. Comparing this</p>
<p>hierarchy in the stream with the current class can detect additional
classes. Since there is no information in</p>
<p>the stream from which to initialize the object, the class's fields
will be initialized to the default values.</p>
<p><strong>Removing classes :</strong> Comparing the class hierarchy in
the stream with that of the current class can detect</p>
<p>that a class has been deleted. In this case, the fields and objects
corresponding to that class are read from the stream. Primitive fields
are discarded, but the objects referenced by the deleted class are
created, since</p>
<p>they may be referred to later in the stream. They will be
garbage-collected when the stream is garbage-collected or reset.</p>
<p><strong>Adding writeObject/readObject methods :</strong> If the
version reading the stream has these methods then</p>
<p>readObject is expected, as usual, to read the required data written
to the stream by the default serialization.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 382</p>
<p><span id="It_should_call_defaultReadObject" class="anchor"></span>It
should call defaultReadObject first before reading any optional data.
The writeObject method is expected as usual to call defaultWriteObject
to write the required data and then may write optional data.</p>
<p><strong>Adding java.io.Serializable :</strong> This is equivalent to
adding types. There will be no values in the stream for this</p>
<p>class so its fields will be initialized to default values. The
support for subclassing nonserializable classes</p>
<p>requires that the class's supertype have a no-arg constructor and the
class itself will be initialized to default values. If the no-arg
constructor is not available, the InvalidClassException is thrown.</p>
<p><strong>Changing the access to a field :</strong> The access
modifiers public, package, protected, and private have no effect</p>
<p>on the ability of serialization to assign values to the fields.</p>
<p>Changing a field from static to nonstatic or transient to
nontransient : <strong>When relying on default</strong></p>
<p>serialization to compute the serializable fields, this change is
equivalent to adding a field to the class. The</p>
<p>new field will be written to the stream but earlier classes will
ignore the value since serialization will not assign values to static or
transient fields.</p>
<p>Incompatible Changes</p>
<p><strong>Deleting fields :</strong> If a field is deleted in a class,
the stream written will not contain its value. When the stream</p>
<p>is read by an earlier class, the value of the field will be set to
the default value because no value is available in</p>
<p>the stream. However, this default value may adversely impair the
ability of the earlier version to fulfill its contract.</p>
<p><strong>Moving classes up or down the hierarchy :</strong> This
cannot be allowed since the data in the stream appears in</p>
<p>the wrong sequence.</p>
<p>Changing a nonstatic field to static or a nontransient field to
transient : <strong>When relying on default</strong></p>
<p>serialization, this change is equivalent to deleting a field from the
class. This version of the class will not write</p>
<p>that data to the stream, so it will not be available to be read by
earlier versions of the class. As when deleting a field, the field of
the earlier version will be initialized to the default value, which can
cause the class to fail in</p>
<p>unexpected ways.</p>
<p><strong>Changing the declared type of a primitive field :</strong>
Each version of the class writes the data with its declared</p>
<p>type. Earlier versions of the class attempting to read the field will
fail because the type of the data in the stream does not match the type
of the field.</p>
<p>Changing the writeObject or readObject method so that it no longer
writes or reads the default field data or changing it so that it
attempts to write it or read it when the previous version did not. The
default field data</p>
<p>must consistently either appear or not appear in the stream. Changing
a class from Serializable to Externalizable or vice versa is an
incompatible change since the stream</p>
<p>will contain data that is incompatible with the implementation of the
available class. Changing a class from a non-enum type to an enum type
or vice versa since the stream will contain data that</p>
<p>is incompatible with the implementation of the available class.</p>
<p>Removing either Serializable or Externalizable is an incompatible
change since when written it will no longer supply the fields needed by
older versions of the class.</p>
<p>Adding the writeReplace or readResolve method to a class is
incompatible if the behavior would produce an object that is
incompatible with any older version of the class.</p>
<p>Section 66.4: Serialization with Gson</p>
<p>Serialization with Gson is easy and will output correct JSON.</p>
<p>public class <strong>Employe {</strong></p>
<p><strong>private</strong> String firstName;</p>
<p><strong>private</strong> String lastName;</p>
<p>private int <strong>age;</strong></p>
<p><strong>private</strong> BigDecimal salary;</p>
<p><strong>private</strong> List skills;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 383</p>
<p><span id="__getters_and_setters" class="anchor"></span>//getters and
setters</p>
<p>}</p>
<p>(Serialization)</p>
<p>//Skills</p>
<p>List skills = <strong>new</strong> LinkedList();</p>
<p>skills.add("leadership");</p>
<p>skills.add("Java Experience");</p>
<p>//Employe</p>
<p>Employe obj = <strong>new</strong> Employe();</p>
<p>obj.setFirstName("Christian");</p>
<p>obj.setLastName("Lusardi");</p>
<p>obj.setAge(25);</p>
<p>obj.setSalary(<strong>new</strong> BigDecimal("10000"));</p>
<p>obj.setSkills(skills);</p>
<p>//Serialization process</p>
<p>Gson gson = <strong>new</strong> Gson();</p>
<p>String json = gson.toJson(obj);</p>
<p>//{"firstName":"Christian","lastName":"Lusardi","age":25,"salary":10000,"skills":["leadership","Java
Experience"]}</p>
<p>Note that you can not serialize objects with circular references
since that will result in infinite recursion.</p>
<p>(Deserialization)</p>
<p>//it's very simple...</p>
<p>//Assuming that json is the previous String object....</p>
<p>Employe obj2 = gson.fromJson(json, Employe.<strong>class</strong>);
<em>// obj2 is just like obj</em></p>
<p>Section 66.5: Custom JSON Deserialization with Jackson</p>
<p>We consume rest API as a JSON format and then unmarshal it to a POJO.
Jackson’s</p>
<p>org.codehaus.jackson.map.ObjectMapper “just works” out of the box and
we really don’t do anything in most cases.</p>
<p>But sometimes we need custom deserializer to fulfill our custom needs
and this tutorial will guide you through the process of creating your
own custom deserializer.</p>
<p>Let’s say we have following entities.</p>
<p>public class <strong>User {</strong></p>
<p><strong>private</strong> Long id;</p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> String email;</p>
<p>//getter setter are omitted for clarity</p>
<p>}</p>
<p>And</p>
<p>public class <strong>Program {</strong></p>
<p><strong>private</strong> Long id;</p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> User createdBy;</p>
<p><strong>private</strong> String contents;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 384</p>
<p>//getter setter are omitted for clarity</p>
<p>}</p>
<p>Let’s serialize/marshal an object first.</p>
<p>User user = <strong>new</strong> User();</p>
<p>user.setId(1L);</p>
<p>user.setEmail("example@example.com");</p>
<p>user.setName("Bazlur Rahman");</p>
<p>Program program = <strong>new</strong> Program();</p>
<p>program.setId(1L);</p>
<p>program.setName("Program @# 1");</p>
<p>program.setCreatedBy(user);</p>
<p>program.setContents("Some contents");</p>
<p>ObjectMapper objectMapper = <strong>new</strong> ObjectMapper();</p>
<p>final String json = objectMapper.writeValueAsString(program);
System.out.println(json);</p>
<p>The above code will produce following JSON-</p>
<p>{</p>
<p>"id": 1,</p>
<p>"name": "Program @# 1",</p>
<p>"createdBy": {</p>
<p>"id": 1,</p>
<p>"name": "Bazlur Rahman",</p>
<p>"email": "example@example.com"</p>
<p>},</p>
<p>"contents": "Some contents"</p>
<p>}</p>
<p>Now can do the opposite very easily. If we have this JSON, we can
unmarshal to a program object using</p>
<p>ObjectMapper as following –</p>
<p>Now let’s say, this is not the real case, we are going to have a
different JSON from an API which doesn’t match with our Program
class.</p>
<p>{</p>
<p>"id": 1,</p>
<p>"name": "Program @# 1",</p>
<p>"ownerId": 1</p>
<p>"contents": "Some contents"</p>
<p>}</p>
<p>Look at the JSON string, you can see, it has a different field that
is owenerId.</p>
<p>Now if you want to serialize this JSON as we did earlier, you will
have exceptions.</p>
<p>There are two ways to avoid exceptions and have this serialized –</p>
<p>Ignore the unknown fields</p>
<p>Ignore the onwerId. Add the following annotation in the Program
class</p>
<p>@JsonIgnoreProperties(ignoreUnknown = <strong>true</strong>)</p>
<p>public class <strong>Program {}</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 385</p>
<p>Write custom deserializer</p>
<p>But there are cases when you actually need this owerId field. Let's
say you want to relate it as an id of the User</p>
<p>class.</p>
<p>In such case, you need to write a custom deserializer-</p>
<p>As you can see, first you have to access the JsonNode from the
JonsParser. And then you can easily extract</p>
<p>information from a JsonNode using the get() method. and you have to
make sure about the field name. It should be the exact name, spelling
mistake will cause exceptions.</p>
<p>And finally, you have to register your ProgramDeserializer to the
ObjectMapper.</p>
<p>ObjectMapper mapper = <strong>new</strong> ObjectMapper();</p>
<p>SimpleModule module = <strong>new</strong> SimpleModule();</p>
<p>module.addDeserializer(Program.<strong>class</strong>,
<strong>new</strong> ProgramDeserializer());</p>
<p>mapper.registerModule(module);</p>
<p>String newJsonString =
"{<strong>\"</strong>id<strong>\"</strong>:1,<strong>\"</strong>name<strong>\"</strong>:<strong>\"</strong>Program
@#
1<strong>\"</strong>,<strong>\"</strong>ownerId<strong>\"</strong>:1,<strong>\"</strong>contents<strong>\"</strong>:<strong>\"</strong>Some
contents<strong>\"</strong>}";</p>
<p><strong>final</strong> Program program2 =
mapper.readValue(newJsonString, Program.<strong>class</strong>);</p>
<p>Alternatively, you can use annotation to register the deserializer
directly –</p>
<p>@JsonDeserialize(using = ProgramDeserializer.<strong>class</strong>)
<strong>public class</strong> Program {</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 386</p>
<p><span id="Chapter_67__Optional_1" class="anchor"></span>Chapter 67:
Optional</p>
<p>Optional is a container object which may or may not contain a
non-null value. If a value is present, isPresent() will</p>
<p>return <strong>true</strong> and get() will return the value.</p>
<p>Additional methods that depend on the presence of the contained value
are provided, such as <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElse-T-">orElse(),
which</a></p>
<p>returns a default value if value not present, and ifPresent() which
executes a block of code if the value is present.</p>
<p>Section 67.1: Map</p>
<p>Use the <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-">map()</a>
method of Optional to work with values that might be
<strong>null</strong> without doing explicit <strong>null</strong>
checks:</p>
<p>(Note that the <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-">map()</a>
and <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#filter-java.util.function.Predicate-">filter()
operations are evaluated immediately, unlike their Stream counterparts
which</a></p>
<p>are only evaluated upon a <em>terminal operation</em>.)</p>
<p>Syntax:</p>
<p><strong>public</strong> Optional map(Functionsuper T,?
<strong>extends</strong> U&gt; mapper)</p>
<p>Code examples:</p>
<p>String value = <strong>null</strong>;</p>
<p><strong>return</strong>
Optional.ofNullable(value).map(String::toUpperCase).orElse("NONE");
<em>// returns "NONE"</em></p>
<p>String value = "something";</p>
<p><strong>return</strong>
Optional.ofNullable(value).map(String::toUpperCase).orElse("NONE");
<em>// returns "SOMETHING"</em></p>
<p>Because <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-">Optional.map()
returns an empty optional when its mapping function returns null, you
can chain several</a></p>
<p>map() operations as a form of null-safe dereferencing. This is also
known as <strong>Null-safe chaining</strong>.</p>
<p>Consider the following example:</p>
<p>String value = foo.getBar().getBaz().toString();</p>
<p>Any of getBar, getBaz, and toString can potentially throw a
NullPointerException.</p>
<p>Here is an alternative way to get the value from toString() using
Optional:</p>
<p>String value = Optional.ofNullable(foo)</p>
<p>.map(Foo::getBar)</p>
<p>.map(Bar::getBaz)</p>
<p>.map(Baz::toString)</p>
<p>.orElse("");</p>
<p>This will return an empty string if any of the mapping functions
returned null.</p>
<p>Below is an another example, but slightly different. It will print
the value only if none of the mapping functions</p>
<p>returned null.</p>
<p>Optional.ofNullable(foo)</p>
<p>.map(Foo::getBar)</p>
<p>.map(Bar::getBaz)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 387</p>
<p><span id="_map_Baz__toString"
class="anchor"></span>.map(Baz::toString)</p>
<p>.ifPresent(System.out::println);</p>
<p>Section 67.2: Return default value if Optional is empty</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#get--">Don't
just use Optional.get() since that may throw</a>
NoSuchElementException<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElse-T-">.
The Optional.orElse(T) and</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-">Optional.orElseGet(Supplier&lt;?
<strong>extends</strong> T&gt;) methods provide a way to supply a
default value in case the</a> Optional is empty.</p>
<p>String value = "something";</p>
<p><strong>return</strong>
Optional.ofNullable(value).orElse("defaultValue"); <em>// returns
"something"</em></p>
<p><em><strong>return</strong>
Optional.ofNullable(value).orElseGet(()-&gt; getDefaultValue());</em> //
returns "something" (never calls the getDefaultValue() method)</p>
<p>String value = <strong>null</strong>;</p>
<p><strong>return</strong>
Optional.ofNullable(value).orElse("defaultValue"); <em>// returns
"defaultValue"</em></p>
<p><strong>return</strong> Optional.ofNullable(value).orElseGet(()-&gt;
getDefaultValue()); <em>// calls getDefaultValue() and returns its
results</em></p>
<p>The crucial difference between the orElse and orElseGet is that the
latter is only evaluated when the Optional is empty while the argument
supplied to the former one is evaluated even if the Optional is not
empty. The orElse</p>
<p>should therefore only be used for constants and never for supplying
value based on any sort of computation.</p>
<p>Section 67.3: Throw an exception, if there is no value</p>
<p>Use the <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseThrow-java.util.function.Supplier-">orElseThrow()</a>
method of Optional to get the contained value or throw an exception, if
it hasn't been set.</p>
<p>This is similar to calling get(), except that it allows for arbitrary
exception types. The method takes a supplier that must return the
exception to be thrown.</p>
<p>In the first example, the method simply returns the contained
value:</p>
<p>Optional optional = Optional.of("something");</p>
<p><strong>return</strong>
optional.orElseThrow(IllegalArgumentException::<strong>new</strong>);
<em>// returns "something" string</em></p>
<p>In the second example, the method throws an exception because a value
hasn't been set:</p>
<p>Optional optional = Optional.empty();</p>
<p><strong>return</strong>
optional.orElseThrow(IllegalArgumentException::<strong>new</strong>);
<em>// throws IllegalArgumentException</em></p>
<p>You can also use the lambda syntax if throwing an exception with
message is needed:</p>
<p>optional.orElseThrow(()-&gt; <strong>new</strong>
IllegalArgumentException("Illegal"));</p>
<p>Section 67.4: Lazily provide a default value using a Supplier</p>
<p>The <em>normal</em> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElse-T-">orElse</a>
method takes an Object, so you might wonder why there is an option to
provide a Supplier</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 388</p>
<p><span id="here__the_orElseGet_method" class="anchor"></span>here (the
orElseGet method).</p>
<p>Consider:</p>
<p>String value = "something";</p>
<p><strong>return</strong> Optional.ofNullable(value)</p>
<p>.orElse(getValueThatIsHardToCalculate()); <em>// returns
"something"</em></p>
<p>It would still call getValueThatIsHardToCalculate() even though it's
result is not used as the optional is not empty.</p>
<p>To avoid this penalty you supply a supplier:</p>
<p>String value = "something";</p>
<p><strong>return</strong> Optional.ofNullable(value)</p>
<p>.orElseGet(()-&gt; getValueThatIsHardToCalculate()); <em>// returns
"something"</em></p>
<p>This way getValueThatIsHardToCalculate() will only be called if the
Optional is empty.</p>
<p>Section 67.5: Filter</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#filter-java.util.function.Predicate-">filter()</a>
is used to indicate that you would like the value <em>only if</em> it
matches your predicate.</p>
<p>Think of it like <strong>if</strong> (!somePredicate(x)) { x =
<strong>null</strong>; }.</p>
<p>Code examples:</p>
<p>String value = <strong>null</strong>;</p>
<p>Optional.ofNullable(value) <em>// nothing</em></p>
<p><em>.filter(x -&gt; x.equals("cool string"))</em>// this is never run
since value is null</p>
<p>.isPresent(); <em>// false</em></p>
<p>String value = "cool string";</p>
<p>Optional.ofNullable(value) <em>// something</em></p>
<p>.filter(x -&gt; x.equals("cool string"))<em>// this is run and
passes</em></p>
<p>.isPresent(); <em>// true</em></p>
<p>String value = "hot string";</p>
<p>Optional.ofNullable(value) <em>// something</em></p>
<p>.filter(x -&gt; x.equals("cool string"))<em>// this is run and
fails</em></p>
<p>.isPresent(); <em>// false</em></p>
<p>Section 67.6: Using Optional containers for primitive number</p>
<p>types</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html">OptionalDouble,</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html">OptionalInt
and</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html">OptionalLong</a>
work like Optional, but are specifically designed to wrap primitive</p>
<p>types:</p>
<p>OptionalInt presentInt = OptionalInt.of(value);</p>
<p>OptionalInt absentInt = OptionalInt.empty();</p>
<p>Because numeric types do have a value, there is no special handling
for null. Empty containers can be checked with:</p>
<p>presentInt.isPresent(); <em>// Is true.</em></p>
<p>absentInt.isPresent(); <em>// Is false.</em></p>
<p>Similarly, shorthands exist to aid value management:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 389</p>
<p><span id="___Prints_the_value_since_it_is" class="anchor"></span>//
Prints the value since it is provided on creation.
<em>presentInt.ifPresent(System.out::println);</em></p>
<p>// Gives the other value as the original Optional is empty.
<em><strong>int</strong> finalValue =
absentInt.orElseGet(<strong>this</strong>::otherValue);</em></p>
<p>// Will throw a NoSuchElementException.</p>
<p><strong>int</strong> nonexistentValue = absentInt.getAsInt();</p>
<p>Section 67.7: Run code only if there is a value present</p>
<p>Optional optionalWithValue = Optional.of("foo");
optionalWithValue.ifPresent(System.out::println);<em>//Prints
"foo".</em></p>
<p>Optional emptyOptional = Optional.empty();
emptyOptional.ifPresent(System.out::println);<em>//Does
nothing.</em></p>
<p>Section 67.8: FlatMap</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-">flatMap</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-">is
similar to map</a>. The difference is described by the javadoc as
follows:</p>
<p>This method is similar to map(Function), but the provided mapper is
one whose result is already an</p>
<p>Optional , and if invoked, flatMap does not wrap it with an
additional Optional.</p>
<p>In other words, when you chain a method call that returns an
Optional, using Optional.flatMap avoids creating</p>
<p>nested Optionals.</p>
<p>For example, given the following classes:</p>
<p>public class <strong>Foo {</strong></p>
<p>Optional getBar(){</p>
<p><strong>return</strong> Optional.of(<strong>new</strong> Bar());</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Bar {</strong></p>
<p>}</p>
<p>If you use Optional.map, you will get a nested Optional; i.e.
Optional&gt;.</p>
<p>Optional&gt; nestedOptionalBar =</p>
<p>Optional.of(<strong>new</strong> Foo())</p>
<p>.map(Foo::getBar);</p>
<p>However, if you use Optional.flatMap, you will get a simple Optional;
i.e. Optional.</p>
<p>Optional optionalBar =</p>
<p>Optional.of(<strong>new</strong> Foo())</p>
<p>.flatMap(Foo::getBar);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 390</p>
<p><span id="Chapter_68__Object_References_1"
class="anchor"></span>Chapter 68: Object References</p>
<p>Section 68.1: Object References as method parameters</p>
<p>This topic explains the concept of an <em>object reference</em>; it
is targeted at people who are new to programming in Java. You should
already be familiar with some terms and meanings: class definition, main
method, object instance, and</p>
<p>the calling of methods "on" an object, and passing parameters to
methods.</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String name;</p>
<p><strong>public void</strong> setName(String name) {
<strong>this</strong>.name = name; }</p>
<p><strong>public</strong> String getName() { <strong>return</strong>
name; }</p>
<p><strong>public static void</strong> main(String [] arguments) {</p>
<p>Person person = <strong>new</strong> Person();</p>
<p>person.setName("Bob");</p>
<p><strong>int</strong> i = 5;</p>
<p>setPersonName(person, i);</p>
<p>System.out.println(person.getName() + " " + i);</p>
<p>}</p>
<p><strong>private static void</strong> setPersonName(Person person,
<strong>int</strong> num) { person.setName("Linda");</p>
<p>num = 99;</p>
<p>}</p>
<p>}</p>
<p>To be fully competent in Java programming, you should be able to
explain this example to someone else off the top</p>
<p>of your head. Its concepts are fundamental to understanding how Java
works.</p>
<p>As you can see, we have a main that instantiates an object to the
variable person, and calls a method to set the name field in that object
to "Bob". Then it calls another method, and passes person as one of two
parameters; the other</p>
<p>parameter is an integer variable, set to 5.</p>
<p>The method called sets the name value on the passed object to
"Linda', and sets the integer variable passed to 99,</p>
<p>then returns.</p>
<p>So what would get printed?</p>
<p>Linda 5</p>
<p>So why does the change made to person take effect in main, but the
change made to the integer does not?</p>
<p>When the call is made, the main method passes an <em>object
reference</em> for person to the setPersonName method; any</p>
<p>change that setAnotherName makes to that object is part of that
object, and so those changes are still part of that</p>
<p>object when the method returns.</p>
<p>Another way of saying the same thing: person points to an object
(stored on the heap, if you're interested). Any change the method makes
to that object are made "on that object", and are not affected by
whether the method</p>
<p>making the change is still active or has returned. When the method
returns, any changes made to the object are still</p>
<p>stored on that object.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 391</p>
<p>Contrast this with the integer that is passed. Since this is a
<em>primitive</em> int (and not an Integer object instance), it is
passed "by value", meaning its value is provided to the method, not a
pointer to the original integer passed in. The</p>
<p>method can change it for the method's own purposes, but that does not
affect the variable used when the method</p>
<p>call is made.</p>
<p>In Java, all primitives are passed by value. Objects are passed by
reference, which means that a pointer to the object is passed as the
parameter to any methods that take them.</p>
<p>One less-obvious thing this means: it is not possible for a called
method to create a <em>new</em> object and return it as one of the
parameters. The only way for a method to return an object that is
created, directly or indirectly, by the</p>
<p>method call, is as a return value from the method. Let's first see
how that would not work, and then how it would work.</p>
<p>Let's add another method to our little example here:</p>
<p><strong>private static void</strong> getAnotherObjectNot(Person
person) { person = <strong>new</strong> Person();</p>
<p>person.setName("George");</p>
<p>}</p>
<p>And, back in the main, below the call to setAnotherName, let's put a
call to this method and another println call:</p>
<p>getAnotherObjectNot(person);</p>
<p>System.out.println(person.getName());</p>
<p>Now the program would print out:</p>
<p>Linda 5</p>
<p>Linda</p>
<p>What happened to the object that had George? Well, the parameter that
was passed in was a pointer to Linda; when the getAnotherObjectNot
method created a new object, it replaced the reference to the Linda
object with a</p>
<p>reference to the George object. The Linda object still exists (on the
heap), the main method can still access it, but the getAnotherObjectNot
method wouldn't be able to do anything with it after that, because it
has no reference to it. It</p>
<p>would appear that the writer of the code intended for the method to
create a new object and pass it back, but if so,</p>
<p>it didn't work.</p>
<p>If that is what the writer wanted to do, he would need to return the
newly created object from the method, something like this:</p>
<p><strong>private static</strong> Person getAnotherObject() {</p>
<p>Person person = <strong>new</strong> Person();</p>
<p>person.setName("Mary");</p>
<p><strong>return</strong> person;</p>
<p>}</p>
<p>Then call it like this:</p>
<p>Person mary;</p>
<p>mary = getAnotherObject();</p>
<p>System.out.println(mary.getName());</p>
<p>And the entire program output would now be:</p>
<p>Linda 5</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 392</p>
<p>Linda</p>
<p>Mary</p>
<p>Here is the entire program, with both additions:</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String name;</p>
<p><strong>public void</strong> setName(String name) {
<strong>this</strong>.name = name; }</p>
<p><strong>public</strong> String getName() { <strong>return</strong>
name; }</p>
<p><strong>public static void</strong> main(String [] arguments) {</p>
<p>Person person = <strong>new</strong> Person();</p>
<p>person.setName("Bob");</p>
<p><strong>int</strong> i = 5;</p>
<p>setPersonName(person, i);</p>
<p>System.out.println(person.getName() + " " + i);</p>
<p>getAnotherObjectNot(person);</p>
<p>System.out.println(person.getName());</p>
<p>Person person;</p>
<p>person = getAnotherObject();</p>
<p>System.out.println(person.getName());</p>
<p>}</p>
<p><strong>private static void</strong> setPersonName(Person person,
<strong>int</strong> num) { person.setName("Linda");</p>
<p>num = 99;</p>
<p>}</p>
<p><strong>private static void</strong> getAnotherObjectNot(Person
person) { person = <strong>new</strong> Person();</p>
<p>person.setMyName("George");</p>
<p>}</p>
<p><strong>private static</strong> person getAnotherObject() {</p>
<p>Person person = <strong>new</strong> Person();</p>
<p>person.setMyName("Mary");</p>
<p><strong>return</strong> person;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 393</p>
<p><span id="Chapter_69__Exceptions_and_excep_1"
class="anchor"></span>Chapter 69: Exceptions and exception</p>
<p>handling</p>
<p>Objects of type Throwable and its subtypes can be sent up the stack
with the <strong>throw</strong> keyword and caught with</p>
<p><strong>try</strong>…<strong>catch</strong> statements.</p>
<p>Section 69.1: Catching an exception with try-catch</p>
<p>An exception can be caught and handled using the
<strong>try</strong>...<strong>catch</strong> statement. (In fact
<strong>try</strong> statements take other</p>
<p>forms, as described in other examples about
<strong>try</strong>...<strong>catch</strong>...<strong>finally</strong>
and try-with-resources.)</p>
<p>Try-catch with one catch block</p>
<p>The most simple form looks like this:</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p>} <strong>catch</strong> (SomeException e) {</p>
<p>handle(e);</p>
<p>}</p>
<p>// next statement</p>
<p>The behavior of a simple
<strong>try</strong>...<strong>catch</strong> is as follows:</p>
<p>The statements in the <strong>try</strong> block are executed.</p>
<p>If no exception is thrown by the statements in the
<strong>try</strong> block, then control passes to the next statement
after</p>
<p><strong>the</strong>
try<strong>...</strong>catch<strong>.</strong></p>
<p>If an exception is thrown within the <strong>try</strong> block.</p>
<p>The exception object is tested to see if it is an instance of
SomeException or a subtype. If it is, then the <strong>catch</strong>
block will <em>catch</em> the exception:</p>
<p>The variable e is bound to the exception object.</p>
<p>The code within the <strong>catch</strong> block is executed.</p>
<p>If that code throws an exception, then the newly thrown exception is
propagated in place of the</p>
<p>original one.</p>
<p>Otherwise, control passes to the next statement after the
<strong>try</strong>...<strong>catch</strong>.</p>
<p>If it is not, the original exception continues to propagate.</p>
<p>Try-catch with multiple catches</p>
<p>A <strong>try</strong>...<strong>catch</strong> can also have
multiple <strong>catch</strong> blocks. For example:</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p>} <strong>catch</strong> (SomeException e) {</p>
<p>handleOneWay(e)</p>
<p>} <strong>catch</strong> (SomeOtherException e) {</p>
<p>handleAnotherWay(e);</p>
<p>}</p>
<p>// next statement</p>
<p>If there are multiple <strong>catch</strong> blocks, they are tried
one at a time starting with the first one, until a match is found
for</p>
<p>the exception. The corresponding handler is executed (as above), and
then control is passed to the next statement after the
<strong>try</strong>...<strong>catch</strong> statement. The
<strong>catch</strong> blocks after the one that matches are always
skipped, <em>even if the</em></p>
<p>handler code throws an exception<em>.</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 394</p>
<p><span id="The__top_down__matching_strategy" class="anchor"></span>The
"top down" matching strategy has consequences for cases where the
exceptions in the <strong>catch</strong> blocks are not disjoint. For
example:</p>
<p>try <strong>{</strong></p>
<p><strong>throw new</strong> RuntimeException("test");</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.out.println("Exception");</p>
<p>} <strong>catch</strong> (RuntimeException e) {</p>
<p>System.out.println("RuntimeException");</p>
<p>}</p>
<p>This code snippet will output "Exception" rather than
"RuntimeException". Since RuntimeException is a subtype of</p>
<p>Exception , the first (more general) <strong>catch</strong> will be
matched. The second (more specific) <strong>catch</strong> will never be
executed.</p>
<p>The lesson to learn from this is that the most specific
<strong>catch</strong> blocks (in terms of the exception types) should
appear</p>
<p>first, and the most general ones should be last. (Some Java compilers
will warn you if a <strong>catch</strong> can never be executed, but
this is not a compilation error.)</p>
<p>Multi-exception catch blocks</p>
<p>Version ≥ Java SE 7</p>
<p>Starting with Java SE 7, a single <strong>catch</strong> block can
handle a list of unrelated exceptions. The exception type are listed,
separated with a vertical bar (|) symbol. For example:</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p>} <strong>catch</strong> (SomeException | SomeOtherException e) {</p>
<p>handleSomeException(e);</p>
<p>}</p>
<p>The behavior of a multi-exception catch is a simple extension for the
single-exception case. The <strong>catch</strong> matches if the thrown
exception matches (at least) one of the listed exceptions.</p>
<p>There is some additional subtlety in the specification. The type of e
is a synthetic <em>union</em> of the exception types in the list. When
the value of e is used, its static type is the least common supertype of
the type union. However, if e is</p>
<p>rethrown within the <strong>catch</strong> block, the exception types
that are thrown are the types in the union. For example:</p>
<p><strong>public void</strong> method() <strong>throws</strong>
IOException, SQLException</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p>} <strong>catch</strong> (IOException | SQLException e) {</p>
<p>report(e);</p>
<p>throw <strong>e;</strong></p>
<p>}</p>
<p>In the above, IOException and SQLException are checked exceptions
whose least common supertype is Exception. This means that the report
method must match report(Exception). However, the compiler knows that
the <strong>throw</strong></p>
<p>can throw only an IOException or an SQLException. Thus, method can be
declared as <strong>throws</strong> IOException, SQLException rather
than <strong>throws</strong> Exception. (Which is a good thing: see
Pitfall - Throwing Throwable, Exception,</p>
<p>Error or RuntimeException.)</p>
<p>Section 69.2: The try-with-resources statement</p>
<p>Version ≥ Java SE 7</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 395</p>
<p>As the try-catch-final statement example illustrates, resource
cleanup using a <strong>finally</strong> clause requires a significant
amount of "boiler-plate" code to implement the edge-cases correctly.
Java 7 provides a much simpler way to deal</p>
<p>with this problem in the form of the <em>try-with-resources</em>
statement.</p>
<p>What is a resource?</p>
<p>Java 7 introduced the java.lang.AutoCloseable interface to allow
classes to be managed using the <em>try-with-</em></p>
<p><em>resources</em> statement. Instances of classes that implement
AutoCloseable are referred to as <em>resources</em>. These</p>
<p>typically need to be disposed of in a timely fashion rather than
relying on the garbage collector to dispose of them.</p>
<p>The AutoCloseable interface defines a single method:</p>
<p><strong>public void</strong> close() <strong>throws</strong>
Exception</p>
<p>A close() method should dispose of the resource in an appropriate
fashion. The specification states that it should be safe to call the
method on a resource that has already been disposed of. In addition,
classes that implement</p>
<p>Autocloseable are <em>strongly encouraged</em> to declare the close()
method to throw a more specific exception than Exception , or no
exception at all.</p>
<p>A wide range of standard Java classes and interfaces implement
AutoCloseable. These include:</p>
<p>InputStream, OutputStream and their subclasses</p>
<p>Reader , Writer and their subclasses</p>
<p>Socket and ServerSocket and their subclasses</p>
<p>Channel and its subclasses, and</p>
<p>the JDBC interfaces Connection, Statement and ResultSet and their
subclasses.</p>
<p>Application and third party classes may do this as well.</p>
<p>The basic try-with-resource statement</p>
<p>The syntax of a <em>try-with-resources</em> is based on classical
<em>try-catch</em>, <em>try-finally</em> and <em>try-catch-finally</em>
forms. Here is an</p>
<p>example of a "basic" form; i.e. the form without a
<strong>catch</strong> or <strong>finally</strong>.</p>
<p><strong>try</strong> (PrintStream stream = <strong>new</strong>
PrintStream("hello.txt")) {</p>
<p>stream.println("Hello world!");</p>
<p>}</p>
<p>The resources to be manage are declared as variables in the (...)
section after the <strong>try</strong> clause. In the example above, we
declare a resource variable stream and initialize it to a newly created
PrintStream.</p>
<p>Once the resource variables have been initialized, the
<strong>try</strong> block is executed. When that completes,
stream.close()</p>
<p>will be called automatically to ensure that the resource does not
leak. Note that the close() call happens no matter</p>
<p>how the block completes.</p>
<p>The enhanced try-with-resource statements</p>
<p>The <em>try-with-resources</em> statement can be enhanced with
<strong>catch</strong> and <strong>finally</strong> blocks, as with the
pre-Java 7 <em>try-catch-</em></p>
<p><em>finally</em> syntax. The following code snippet adds a
<strong>catch</strong> block to our previous one to deal with the
FileNotFoundException that the PrintStream constructor can throw:</p>
<p><strong>try</strong> (PrintStream stream = <strong>new</strong>
PrintStream("hello.txt")) {</p>
<p>stream.println("Hello world!");</p>
<p>} <strong>catch</strong> (FileNotFoundException ex) {</p>
<p>System.err.println("Cannot open the file");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 396</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>System.err.println("All done");</p>
<p>}</p>
<p>If either the resource initialization or the try block throws the
exception, then the <strong>catch</strong> block will be executed. The
<strong>finally</strong> block will always be executed, as with a
conventional <em>try-catch-finally</em> statement.</p>
<p>There are a couple of things to note though:</p>
<p>The resource variable is <em>out of scope</em> in the
<strong>catch</strong> and <strong>finally</strong> blocks.</p>
<p>The resource cleanup will happen before the statement tries to match
the <strong>catch</strong> block. If the automatic resource cleanup
threw an exception, then that <em>could</em> be caught in one of the
<strong>catch</strong> blocks.</p>
<p>Managing multiple resources</p>
<p>The code snippets above show a single resource being managed. In
fact, <em>try-with-resources</em> can manage multiple</p>
<p>resources in one statement. For example:</p>
<p><strong>try</strong> (InputStream is = <strong>new</strong>
FileInputStream(file1);</p>
<p>OutputStream os = <strong>new</strong> FileOutputStream(file2)) {</p>
<p>// Copy 'is' to 'os'</p>
<p>}</p>
<p>This behaves as you would expect. Both is and os are closed
automatically at the end of the <strong>try</strong> block. There are
a</p>
<p>couple of points to note:</p>
<p>The initializations occur in the code order, and later resource
variable initializers can use of the values of the earlier ones.</p>
<p>All resource variables that were successfully initialized will be
cleaned up.</p>
<p>Resource variables are cleaned up in <em>reverse order</em> of their
declarations.</p>
<p>Thus, in the above example, is is initialized before os and cleaned
up after it, and is will be cleaned up if there is an</p>
<p>exception while initializing os.</p>
<p>Equivalence of try-with-resource and classical try-catch-finally</p>
<p>The Java Language Specification specifies the behavior of
<em>try-with-resource</em> forms in terms of the classical
<em>try-catch-</em></p>
<p><em>finally</em> statement. (Please refer to the JLS for the full
details.)</p>
<p>For example, this basic <em>try-with-resource</em> :</p>
<p><strong>try</strong> (PrintStream stream = <strong>new</strong>
PrintStream("hello.txt")) {</p>
<p>stream.println("Hello world!");</p>
<p>}</p>
<p>is defined to be equivalent to this <em>try-catch-finally</em>:</p>
<p>// Note that the constructor is not part of the try-catch statement
<em>PrintStream stream = <strong>new</strong>
PrintStream("hello.txt");</em></p>
<p>// This variable is used to keep track of the primary exception
thrown // in the try statement. If an exception is thrown in the try
block, // any exception thrown by AutoCloseable.close() will be
suppressed. <em>Throwable primaryException =
<strong>null</strong>;</em></p>
<p>// The actual try block</p>
<p>try <strong>{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 397</p>
<p><span id="stream_println__Hello_world"
class="anchor"></span>stream.println("Hello world!");</p>
<p>} <strong>catch</strong> (Throwable t) {</p>
<p>// If an exception is thrown, remember it for the finally block</p>
<p>primaryException = t;</p>
<p>throw <strong>t;</strong></p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (primaryException == <strong>null</strong>) {</p>
<p>// If no exception was thrown so far, exceptions thrown in close()
will // not be caught and therefore be passed on to the enclosing
code.</p>
<p>stream.close();</p>
<p>} <strong>else</strong> {</p>
<p>// If an exception has already been thrown, any exception thrown in
// close() will be suppressed as it is likely to be related to the //
previous exception. The suppressed exception can be retrieved // using
primaryException.getSuppressed().</p>
<p>try <strong>{</strong></p>
<p>stream.close();</p>
<p>} <strong>catch</strong> (Throwable suppressedException) {</p>
<p>primaryException.addSuppressed(suppressedException);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>(The JLS specifies that the actual t and primaryException variables
will be invisible to normal Java code.)</p>
<p>The enhanced form of <em>try-with-resources</em> is specified as an
equivalence with the basic form. For example:</p>
<p><strong>try</strong> (PrintStream stream = <strong>new</strong>
PrintStream(fileName)) {</p>
<p>stream.println("Hello world!");</p>
<p>} <strong>catch</strong> (NullPointerException ex) {</p>
<p>System.err.println("Null filename");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>System.err.println("All done");</p>
<p>}</p>
<p>is equivalent to:</p>
<p>try <strong>{</strong></p>
<p><strong>try</strong> (PrintStream stream = <strong>new</strong>
PrintStream(fileName)) { stream.println("Hello world!");</p>
<p>}</p>
<p>} <strong>catch</strong> (NullPointerException ex) {</p>
<p>System.err.println("Null filename");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>System.err.println("All done");</p>
<p>}</p>
<p>Section 69.3: Custom Exceptions</p>
<p>Under most circumstances, it is simpler from a code-design standpoint
to use existing generic <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html">Exception
classes</a></p>
<p>when throwing exceptions. This is especially true if you only need
the exception to carry a simple error message. In</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html">that
case, RuntimeException is usually preferred, since it is not a checked
Exception. Other exception classes exist</a></p>
<p>for common classes of errors:</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html">UnsupportedOperationException
- a certain operation is not supported</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</a>
- an invalid parameter value was passed to a method</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html">IllegalStateException
- your API has internally reached a condition that should never happen,
or which occurs</a></p>
<p>as a result of using your API in an invalid way</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 398</p>
<p>Cases where you <strong>do</strong> want to use a custom exception
class include the following:</p>
<p>You are writing an API or library for use by others, and you want to
allow users of your API to be able to</p>
<p><em>specifically catch and handle exceptions from your API, and</em>
be able to differentiate those exceptions from other, more generic
exceptions<em>.</em></p>
<p>You are throwing exceptions for a <strong>specific kind of
error</strong> in one part of your program, which you want to</p>
<p>catch and handle in another part of your program, and you want to be
able to differentiate these errors from</p>
<p>other, more generic errors.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html">You
can create your own custom exceptions by extending RuntimeException for
an unchecked exception, or</a></p>
<p><em><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html">checked
exception by extending any Exception</a></em> which is not also subclass
of RuntimeException<em>, because:</em></p>
<p>Subclasses of Exception that are not also subclasses of
RuntimeException are checked exceptions</p>
<p><strong>public class</strong> StringTooLongException
<strong>extends</strong> RuntimeException {</p>
<p>// Exceptions can have methods and fields like other classes // those
can be useful to communicate information to pieces of code catching //
such an exception</p>
<p><strong>public final</strong> String value;</p>
<p>public final int <strong>maximumLength;</strong></p>
<p><strong>public</strong> StringTooLongException(String value,
<strong>int</strong> maximumLength){</p>
<p><strong>super</strong>(String.format("String exceeds maximum Length
of %s: %s", maximumLength, value)); <strong>this</strong>.value =
value;</p>
<p><strong>this</strong>.maximumLength = maximumLength;</p>
<p>}</p>
<p>}</p>
<p>Those can be used just as predefined exceptions:</p>
<p><strong>void</strong> validateString(String value){</p>
<p><strong>if</strong> (value.length() &gt; 30){</p>
<p><strong>throw new</strong> StringTooLongException(value, 30);</p>
<p>}</p>
<p>}</p>
<p>And the fields can be used where the exception is caught and
handled:</p>
<p><strong>void</strong> anotherMethod(String value){</p>
<p>try <strong>{</strong></p>
<p>validateString(value);</p>
<p>} <strong>catch</strong>(StringTooLongException e){</p>
<p>System.out.println("The string '" + e.value +</p>
<p>"' was longer than the max of " + e.maximumLength );</p>
<p>}</p>
<p>}</p>
<p>Keep in mind that, according to <a
href="http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">Oracle's
Java Documentation:</a></p>
<p>[...] If a client can reasonably be expected to recover from an
exception, make it a checked exception. If a client cannot do anything
to recover from the exception, make it an unchecked exception.</p>
<p>More:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 399</p>
<p><span id="Why_does_RuntimeException_not_re" class="anchor"></span><a
href="http://stackoverflow.com/a/14995225/3502776">Why does
RuntimeException not require an explicit exception handling?</a></p>
<p>Section 69.4: Handling InterruptedException</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html">InterruptedException
is a confusing beast - it shows up in seemingly innocuous methods
like</a> <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#sleep(long)">Thread.sleep(),
but</a></p>
<p>handling it incorrectly leads to hard-to-manage code that behaves
poorly in concurrent environments.</p>
<p>At its most basic, if an InterruptedException is caught it means
someone, somewhere, called <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--">Thread.interrupt()</a></p>
<p>on the thread your code is currently running in. You might be
inclined to say "It's my code! I'll never interrupt it!" and therefore
do something like this:</p>
<p>// Bad. Don't do this.</p>
<p>try <strong>{</strong></p>
<p>Thread.sleep(1000);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// disregard</p>
<p>}</p>
<p>But this is exactly the wrong way to handle an "impossible" event
occurring. If you know your application will never</p>
<p>encounter an InterruptedException you should treat such an event as a
serious violation of your program's</p>
<p>assumptions and exit as quickly as possible.</p>
<p>The proper way to handle an "impossible" interrupt is like so:</p>
<p>// When nothing will interrupt your code</p>
<p>try <strong>{</strong></p>
<p>Thread.sleep(1000);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>Thread.currentThread().interrupt();</p>
<p><strong>throw new</strong> AssertionError(e);</p>
<p>}</p>
<p>This does two things; it first restores the interrupt status of the
thread (as if the InterruptedException had not been thrown in the first
place), and then it throws an AssertionError indicating the basic
invariants of your</p>
<p>application have been violated. If you know for certain that you'll
never interrupt the thread this code runs in this is safe since the
<strong>catch</strong> block should never be reached.</p>
<p><a
href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Uninterruptibles.html">Using
Guava's Uninterruptibles</a> class helps simplify this pattern;
calling</p>
<p><a
href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Uninterruptibles.html#sleepUninterruptibly(long,%20java.util.concurrent.TimeUnit)">Uninterruptibles.sleepUninterruptibly()</a>
disregards the interrupted state of a thread until the sleep
duration</p>
<p>has expired (at which point it's restored for later calls to inspect
and throw their own InterruptedException). If you know you'll never
interrupt such code this safely avoids needing to wrap your sleep calls
in a try-catch block.</p>
<p>More often, however, you cannot guarantee that your thread will never
be interrupted. In particular if you're writing</p>
<p>code that will be executed by an <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a>
or some other thread-management it's critical that your code
responds</p>
<p>promptly to interrupts, otherwise your application will stall or even
deadlock.</p>
<p>In such cases the best thing to do is generally to allow the
InterruptedException to propagate up the call stack,</p>
<p>adding a <strong>throws</strong> InterruptedException to each method
in turn. This may seem kludgy but it's actually a desirable property -
your method's signatures now indicates to callers that it will respond
promptly to interrupts.</p>
<p>// Let the caller determine how to handle the interrupt if you're
unsure <em><strong>public void</strong> myLongRunningMethod()
<strong>throws</strong> InterruptedException { ...</em></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 400</p>
<p><span id="In_limited_cases__e_g__while_ove" class="anchor"></span>In
limited cases (e.g. while overriding a method that doesn't
<strong>throw</strong> any checked exceptions) you can reset the
interrupted status without raising an exception, expecting whatever code
is executed next to handle the interrupt.</p>
<p>This delays handling the interruption but doesn't suppress it
entirely.</p>
<p>// Suppresses the exception but resets the interrupted state letting
later code // detect the interrupt and handle it properly.</p>
<p>try <strong>{</strong></p>
<p>Thread.sleep(1000);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>Thread.currentThread().interrupt();</p>
<p><em><strong>return</strong> ...;</em> // your expectations are still
broken at this point - try not to do more work.</p>
<p>}</p>
<p>Section 69.5: Return statements in try catch block</p>
<p>Although it's bad practice, it's possible to add multiple return
statements in a exception handling block:</p>
<p><strong>public static int</strong> returnTest(<strong>int</strong>
number){</p>
<p>try<strong>{</strong></p>
<p><strong>if</strong>(number%2 == 0) <strong>throw new</strong>
Exception("Exception thrown"); <strong>else return</strong> x;</p>
<p>}</p>
<p><strong>catch</strong>(Exception e){</p>
<p>return <strong>3;</strong></p>
<p>}</p>
<p>finally<strong>{</strong></p>
<p>return <strong>7;</strong></p>
<p>}</p>
<p>}</p>
<p>This method will always return 7 since the finally block associated
with the try/catch block is executed before</p>
<p>anything is returned. Now, as finally has <strong>return</strong> 7;,
this value supersedes the try/catch return values.</p>
<p>If the catch block returns a primitive value and that primitive value
is subsequently changed in the finally block, the</p>
<p>value returned in the catch block will be returned and the changes
from the finally block will be ignored.</p>
<p>The example below will print "0", not "1".</p>
<p><strong>public class</strong> FinallyExample {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>int</strong> n = returnTest(4);</p>
<p>System.out.println(n);</p>
<p>}</p>
<p><strong>public static int</strong> returnTest(<strong>int</strong>
number) {</p>
<p><strong>int</strong> returnNumber = 0;</p>
<p>try <strong>{</strong></p>
<p><strong>if</strong> (number % 2 == 0)</p>
<p><strong>throw new</strong> Exception("Exception thrown");</p>
<p>else</p>
<p><strong>return</strong> returnNumber;</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p><strong>return</strong> returnNumber;</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>returnNumber = 1;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 401</p>
<p><span id="_26" class="anchor"></span>}</p>
<p>}</p>
<p>}</p>
<p>Section 69.6: Introduction</p>
<p>Exceptions are errors which occur when a program is executing.
Consider the Java program below which divides two integers.</p>
<p><strong>class</strong> Division {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>int</strong> a, b, result;</p>
<p>Scanner input = <strong>new</strong> Scanner(System.in);</p>
<p>System.out.println("Input two integers");</p>
<p>a = input.nextInt();</p>
<p>b = input.nextInt();</p>
<p>result = a / b;</p>
<p>System.out.println("Result = " + result);</p>
<p>}</p>
<p>}</p>
<p>Now we compile and execute the above code, and see the output for an
attempted division by zero:</p>
<p>Input two integers</p>
<p>7 0</p>
<p>Exception in thread "main" java.lang.ArithmeticException: / by zero
at Division.main(Disivion.java:14)</p>
<p>Division by zero is an invalid operation that would produce a value
that cannot be represented as an integer. Java</p>
<p>deals with this by <em>throwing an <strong>exception</strong></em>.
In this case, the exception is an instance of the
<em>ArithmeticException</em> class.</p>
<p><strong>Note:</strong> The example on creating and reading stack
traces explains what the output after the two numbers means.</p>
<p>The utility of an <em>exception</em> is the flow control that it
allows. Without using exceptions, a typical solution to this</p>
<p>problem may be to first check if b == 0:</p>
<p><strong>class</strong> Division {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>int</strong> a, b, result;</p>
<p>Scanner input = <strong>new</strong> Scanner(System.in);</p>
<p>System.out.println("Input two integers");</p>
<p>a = input.nextInt();</p>
<p>b = input.nextInt();</p>
<p><strong>if</strong> (b == 0) {</p>
<p>System.out.println("You cannot divide by zero.");</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 402</p>
<p><span id="result___a___b" class="anchor"></span>result = a / b;</p>
<p>System.out.println("Result = " + result);</p>
<p>}</p>
<p>}</p>
<p>This prints the message You cannot divide by zero. to the console and
quits the program in a graceful way when the user tries to divide by
zero. An equivalent way of dealing with this problem via <em>exception
handling</em> would be to</p>
<p>replace the if flow control with a try-<strong>catch</strong>
block:</p>
<p>...</p>
<p>a = input.nextInt();</p>
<p>b = input.nextInt();</p>
<p>try <strong>{</strong></p>
<p>result = a / b;</p>
<p>}</p>
<p><strong>catch</strong> (ArithmeticException e) {</p>
<p>System.out.println("An ArithmeticException occurred. Perhaps you
tried to divide by zero."); <strong>return</strong>;</p>
<p>}</p>
<p>...</p>
<p>A try catch block is executed as follows:</p>
<p>1. Begin executing the code in the <strong>try</strong> block.</p>
<p>2. If an <em>exception</em> occurs in the try block, immediately
abort and check to see if this exception is <em>caught</em> by the</p>
<p><strong>catch</strong> block (in this case, when the Exception is an
instance of ArithmeticException).</p>
<p>3. If the exception is <em>caught</em>, it is assigned to the
variable e and the <strong>catch</strong> block is executed. 4. If
either the <strong>try</strong> or <strong>catch</strong> block is
completed (i.e. no uncaught exceptions occur during code execution)
then</p>
<p>continue to execute code below the try-<strong>catch</strong>
block.</p>
<p>It is generally considered good practice to use <em>exception
handling</em> as part of the normal flow control of an application</p>
<p>where behavior would otherwise be undefined or unexpected. For
instance, instead of returning <strong>null</strong> when a method
fails, it is usually better practice to <em>throw an exception</em> so
that the application making use of the method can</p>
<p>define its own flow control for the situation via <em>exception
handling</em> of the kind illustrated above. In some sense, this gets
around the problem of having to return a particular <em>type</em>, as
any one of multiple kinds of <em>exceptions</em> may be</p>
<p><em>thrown</em> to indicate the specific problem that occurred.</p>
<p>For more advice on how and how not to use exceptions, refer to Java
Pitfalls - Exception usage</p>
<p>Section 69.7: The Java Exception Hierarchy - Unchecked and</p>
<p>Checked Exceptions</p>
<p>All Java exceptions are instances of classes in the Exception class
hierarchy. This can be represented as follows:</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">java.lang.Throwable</a>
- This is the base class for all exception classes. Its methods and
constructors</p>
<p>implement a range of functionality common to all exceptions.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html">java.lang.Exception</a>
- This is the superclass of all normal exceptions.</p>
<p>various standard and custom exception classes.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html">java.lang.RuntimeException</a>
- This the superclass of all normal exceptions that are
<em>unchecked</em> <em>exceptions</em>.</p>
<p>various standard and custom runtime exception classes.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 403</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html">java.lang.Error</a>
- This is the superclass of all "fatal error" exceptions.</p>
<p>Notes:</p>
<p>1. The distinction between <em>checked</em> and <em>unchecked</em>
exceptions is described below. 2. The Throwable, Exception and
RuntimeException class should be treated as <strong>abstract</strong>;
see Pitfall - Throwing</p>
<p>Throwable, Exception, Error or RuntimeException.</p>
<p>3. The Error exceptions are thrown by the JVM in situations where it
would be unsafe or unwise for an</p>
<p>application to attempt to recover.</p>
<p>4. It would be unwise to declare custom subtypes of Throwable. Java
tools and libraries may assume that Error</p>
<p>and Exception are the only direct subtypes of Throwable, and
misbehave if that assumption is incorrect.</p>
<p>Checked versus Unchecked Exceptions</p>
<p>One of the criticisms of exception support in some programming
languages is that is difficult to know which</p>
<p>exceptions a given method or procedure might throw. Given that an
unhandled exception is liable to cause a program to crash, this can make
exceptions a source of fragility.</p>
<p>The Java language addresses this concern with the checked exception
mechanism. First, Java classifies exceptions into two categories:</p>
<p>Checked exceptions typically represent anticipated events that an
application should be able to deal with. For</p>
<p>instance, IOException and its subtypes represent error conditions
that can occur in I/O operations. Examples</p>
<p>include, file opens failing because a file or directory does not
exist, network reads and writes failing because a network connection has
been broken and so on.</p>
<p>Unchecked exceptions typically represent unanticipated events that an
application cannot deal with. These are typically the result of a bug in
the application.</p>
<p>(In the following, "thrown" refers to any exception thrown explicitly
(by a <strong>throw</strong> statement), or implicitly (in a failed</p>
<p>dereference, type cast and so on). Similarly, "propagated" refers to
an exception that was thrown in a nested call, and not caught within
that call. The sample code below will illustrate this.)</p>
<p>The second part of the checked exception mechanism is that there are
restrictions on methods where a checked exception may occur:</p>
<p>When a checked exception is thrown or propagated in a method, it
<em>must</em> either be caught by the method, or</p>
<p>listed in the method's <strong>throws</strong> clause. (The
significance of the <strong>throws</strong> clause is described in this
example.)</p>
<p>When a checked exception is thrown or propagated in an initializer
block, it must be caught the the block. A checked exception cannot be
propagated by a method call in a field initialization expression. (There
is no</p>
<p>way to catch such an exception.)</p>
<p>In short, a checked exception must be either handled, or
declared.</p>
<p>These restrictions do not apply to unchecked exceptions. This
includes all cases where an exception is thrown</p>
<p>implicitly, since all such cases throw unchecked exceptions.</p>
<p>Checked exception examples</p>
<p>These code snippets are intended to illustrate the checked exception
restrictions. In each case, we show a version</p>
<p>of the code with a compilation error, and a second version with the
error corrected.</p>
<p>// This declares a custom checked exception.</p>
<p><strong>public class</strong> MyException <strong>extends</strong>
Exception {</p>
<p>// constructors omitted.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 404</p>
<p>}</p>
<p>// This declares a custom unchecked exception.</p>
<p><strong>public class</strong> MyException2 <strong>extends</strong>
RuntimeException {</p>
<p>// constructors omitted.</p>
<p>}</p>
<p>The first example shows how explicitly thrown checked exceptions can
be declared as "thrown" if they should not</p>
<p>be handled in the method.</p>
<p>// INCORRECT</p>
<p><strong>public void</strong>
methodThrowingCheckedException(<strong>boolean</strong> flag) {</p>
<p><em><strong>int</strong> i = 1 / 0;</em> // Compiles OK, throws
ArithmeticException <em><strong>if</strong> (flag) {</em></p>
<p><em><strong>throw new</strong> MyException();</em> // Compilation
error</p>
<p>} <strong>else</strong> {</p>
<p><strong>throw new</strong> MyException2(); <em>// Compiles
OK</em></p>
<p>}</p>
<p>}</p>
<p>// CORRECTED</p>
<p><strong>public void</strong>
methodThrowingCheckedException(<strong>boolean</strong> flag)
<strong>throws</strong> MyException {</p>
<p><em><strong>int</strong> i = 1 / 0;</em> // Compiles OK, throws
ArithmeticException <em><strong>if</strong> (flag) {</em></p>
<p><em><strong>throw new</strong> MyException();</em> // Compilation
error</p>
<p>} <strong>else</strong> {</p>
<p><strong>throw new</strong> MyException2(); <em>// Compiles
OK</em></p>
<p>}</p>
<p>}</p>
<p>The second example shows how a propagated checked exception can be
dealt with.</p>
<p>// INCORRECT</p>
<p><strong>public void</strong> methodWithPropagatedCheckedException()
{</p>
<p><em>InputStream is = <strong>new</strong>
FileInputStream("someFile.txt");</em> // Compilation error //
FileInputStream throws IOException or a subclass if the file cannot //
be opened. IOException is a checked exception.</p>
<p>...</p>
<p>}</p>
<p>// CORRECTED (Version A)</p>
<p><strong>public void</strong> methodWithPropagatedCheckedException()
<strong>throws</strong> IOException {</p>
<p>InputStream is = <strong>new</strong>
FileInputStream("someFile.txt");</p>
<p>...</p>
<p>}</p>
<p>// CORRECTED (Version B)</p>
<p><strong>public void</strong> methodWithPropagatedCheckedException()
{</p>
<p>try <strong>{</strong></p>
<p>InputStream is = <strong>new</strong>
FileInputStream("someFile.txt");</p>
<p>...</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Cannot open file: " + ex.getMessage());</p>
<p>}</p>
<p>}</p>
<p>The final example shows how to deal with a checked exception in a
static field initializer.</p>
<p>// INCORRECT</p>
<p>public class <strong>Test {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 405</p>
<p><span id="private_static_final_InputStream"
class="anchor"></span>private static final <strong>InputStream is
=</strong></p>
<p><strong>new</strong> FileInputStream("someFile.txt"); <em>//
Compilation error</em></p>
<p>}</p>
<p>// CORRECTED</p>
<p>public class <strong>Test {</strong></p>
<p>private static final <strong>InputStream is;</strong></p>
<p>static <strong>{</strong></p>
<p>InputStream tmp = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>tmp = <strong>new</strong> FileInputStream("someFile.txt");</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Cannot open file: " + ex.getMessage());</p>
<p>}</p>
<p>is = tmp;</p>
<p>}</p>
<p>}</p>
<p>Note that in this last case, we also have to deal with the problems
that is cannot be assigned to more than once,</p>
<p>and yet also has to be assigned to, even in the case of an
exception.</p>
<p>Section 69.8: Creating and reading stacktraces</p>
<p>When an exception object is created (i.e. when you
<strong>new</strong> it), the Throwable constructor captures information
about</p>
<p>the context in which the exception was created. Later on, this
information can be output in the form of a stacktrace, which can be used
to help diagnose the problem that caused the exception in the first
place.</p>
<p>Printing a stacktrace</p>
<p>Printing a stacktrace is simply a matter of calling the
printStackTrace() method. For example:</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> a = 0;</p>
<p><strong>int</strong> b = 0;</p>
<p><strong>int</strong> c = a / b;</p>
<p>} <strong>catch</strong> (ArithmeticException ex) {</p>
<p>// This prints the stacktrace to standard output</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>The printStackTrace() method without arguments will print to the
application's standard output; i.e. the current System.out . There are
also printStackTrace(PrintStream) and printStackTrace(PrintWriter)
overloads that</p>
<p>print to a specified Stream or Writer.</p>
<p>Notes:</p>
<p>1. The stacktrace does not include the details of the exception
itself. You can use the toString() method to get</p>
<p>those details; e.g.</p>
<p>// Print exception and stacktrace</p>
<p>System.out.println(ex);</p>
<p>ex.printStackTrace();</p>
<p>2. Stacktrace printing should be used sparingly; see Pitfall -
Excessive or inappropriate stacktraces . It is often</p>
<p>better to use a logging framework, and pass the exception object to
be logged.</p>
<p>Understanding a stacktrace</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 406</p>
<p>Consider the following simple program consisting of two classes in
two files. (We have shown the filenames and added line numbers for
illustration purposes.)</p>
<p>File: "Main.java"</p>
<p><strong>1</strong> public class <strong>Main {</strong></p>
<p>2 <strong>public static void</strong> main(String[] args) {</p>
<p>3 <strong>new</strong> Test().foo();</p>
<p>4 }</p>
<p>5 }</p>
<p>File: "Test.java"</p>
<p>1 <strong>class</strong> Test {</p>
<p><strong>2</strong> public void <strong>foo() {</strong></p>
<p>3 bar();</p>
<p>4 }</p>
<p>5</p>
<p>6 <strong>public int</strong> bar() {</p>
<p>7 <strong>int</strong> a = 1;</p>
<p>8 <strong>int</strong> b = 0;</p>
<p>9 <strong>return</strong> a / b;</p>
<p>10 }</p>
<p>When these files are compiled and run, we will get the following
output.</p>
<p>Exception in thread "main" java.lang.ArithmeticException: / by zero
at Test.bar(Test.java:9)</p>
<p>at Test.foo(Test.java:3)</p>
<p>at Main.main(Main.java:3)</p>
<p>Let us read this one line at a time to figure out what it is telling
us.</p>
<p>Line #1 tells us that the thread called "main" has terminated due to
an uncaught exception. The full name of the</p>
<p>exception is java.lang.ArithmeticException, and the exception message
is "/ by zero".</p>
<p>If we look up the javadocs for this exception, it says:</p>
<p>Thrown when an exceptional arithmetic condition has occurred. For
example, an integer "divide by zero"</p>
<p>throws an instance of this class.</p>
<p>Indeed, the message "/ by zero" is a strong hint that the cause of
the exception is that some code has attempted to divide something by
zero. But what?</p>
<p>The remaining 3 lines are the stack trace. Each line represents a
method (or constructor) call on the call stack, and each one tells us
three things:</p>
<p>the name of the class and method that was being executed, the source
code filename,</p>
<p>the source code line number of the statement that was being
executed</p>
<p>These lines of a stacktrace are listed with the frame for the current
call at the top. The top frame in our example</p>
<p>above is in the Test.bar method, and at line 9 of the Test.java file.
That is the following line:</p>
<p><strong>return</strong> a / b;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 407</p>
<p>If we look a couple of lines earlier in the file to where b is
initialized, it is apparent that b will have the value zero. We can say
without any doubt that this is the cause of the exception.</p>
<p>If we needed to go further, we can see from the stacktrace that bar()
was called from foo() at line 3 of Test.java, and that foo() was in turn
called from Main.main().</p>
<p>Note: The class and method names in the stack frames are the internal
names for the classes and methods. You will need to recognize the
following unusual cases:</p>
<p>A nested or inner class will look like "OuterClass$InnerClass". An
anonymous inner class will look like "OuterClass$1", "OuterClass$2",
etcetera.</p>
<p>When code in a constructor, instance field initializer or an instance
initializer block is being executed, the method name will be "".</p>
<p>When code in a static field initializer or static initializer block
is being executed, the method name will be "".</p>
<p>(In some versions of Java, the stacktrace formatting code will detect
and elide repeated stackframe sequences, as</p>
<p>can occur when an application fails due to excessive recursion.)</p>
<p>Exception chaining and nested stacktraces</p>
<p>Version ≥ Java SE 1.4</p>
<p>Exception chaining happens when a piece of code catches an exception,
and then creates and throws a new one,</p>
<p>passing the first exception as the cause. Here is an example:</p>
<p>File: Test,java</p>
<p><strong>1</strong> public class <strong>Test {</strong></p>
<p>2 <strong>int</strong> foo() {</p>
<p>3 <strong>return</strong> 0 / 0;</p>
<p>4 }</p>
<p>5</p>
<p>6 <strong>public</strong> Test() {</p>
<p>7 <strong>try</strong> {</p>
<p>8 foo();</p>
<p>9 } <strong>catch</strong> (ArithmeticException ex) {</p>
<p>10 <strong>throw new</strong> RuntimeException("A bad thing
happened", ex); 11 }</p>
<p>12 }</p>
<p>13</p>
<p>14 <strong>public static void</strong> main(String[] args) {</p>
<p>15 <strong>new</strong> Test();</p>
<p>16 }</p>
<p>17 }</p>
<p>When the above class is compiled and run, we get the following
stacktrace:</p>
<p>Exception in thread "main" java.lang.RuntimeException: A bad thing
happened</p>
<p>at Test.(Test.java:10)</p>
<p>at Test.main(Test.java:15)</p>
<p>Caused by: java.lang.ArithmeticException: / by zero</p>
<p>at Test.foo(Test.java:3)</p>
<p>at Test.(Test.java:8)</p>
<p>... 1 more</p>
<p>The stacktrace starts with the class name, method and call stack for
the exception that (in this case) caused the</p>
<p>application to crash. This is followed by a "Caused by:" line that
reports the cause exception. The class name and message are reported,
followed by the cause exception's stack frames. The trace ends with an
"... N more" which</p>
<p>indicates that the last N frames are the same as for the previous
exception.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 408</p>
<p><span id="The__Caused_by___is_only_include" class="anchor"></span>The
"Caused by:" is only included in the output when the primary exception's
cause is not <strong>null</strong>). Exceptions can be chained
indefinitely, and in that case the stacktrace can have multiple "Caused
by:" traces.</p>
<p>Note: the cause mechanism was only exposed in the Throwable API in
Java 1.4.0. Prior to that, exception chaining needed to be implemented
by the application using a custom exception field to represent the
cause, and a custom</p>
<p>printStackTrace method.</p>
<p>Capturing a stacktrace as a String</p>
<p>Sometimes, an application needs to be able to capture a stacktrace as
a Java String, so that it can be used for other</p>
<p>purposes. The general approach for doing this is to create a
temporary OutputStream or Writer that writes to an in-memory buffer and
pass that to the printStackTrace(...).</p>
<p><a
href="http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/exception/ExceptionUtils.html#getStackTrace(java.lang.Throwable)">The
Apache Commons and</a> <a
href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Throwables.html#getStackTraceAsString(java.lang.Throwable)">Guava
libraries provide utility methods for capturing a stacktrace as a
String:</a></p>
<p>org.apache.commons.lang.exception.ExceptionUtils.getStackTrace(Throwable)</p>
<p>com.google.common.base.Throwables.getStackTraceAsString(Throwable)</p>
<p>If you cannot use third party libraries in your code base, then the
following method with do the task:</p>
<p>/**</p>
<p>* Returns the string representation of the stack trace.</p>
<p>*</p>
<p>* @param throwable the throwable</p>
<p>* @return the string.</p>
<p>*/</p>
<p><strong>public static</strong> String stackTraceToString(Throwable
throwable) {</p>
<p>StringWriter stringWriter = <strong>new</strong> StringWriter();</p>
<p>throwable.printStackTrace(<strong>new</strong>
PrintWriter(stringWriter));</p>
<p><strong>return</strong> stringWriter.toString();</p>
<p>}</p>
<p>Note that if your intention is to analyze the stacktrace, it is
simpler to use getStackTrace() and getCause() than to</p>
<p>attempt to parse a stacktrace.</p>
<p>Section 69.9: Throwing an exception</p>
<p>The following example shows the basics of throwing an exception:</p>
<p><strong>public void</strong> checkNumber(<strong>int</strong> number)
<strong>throws</strong> IllegalArgumentException {</p>
<p><strong>if</strong> (number &lt; 0) {</p>
<p><strong>throw new</strong> IllegalArgumentException("Number must be
positive: " + number);</p>
<p>}</p>
<p>}</p>
<p>The exception is thrown on the 3rd line. This statement can be broken
down into two parts:</p>
<p><strong>new</strong> IllegalArgumentException(...) is creating an
instance of the IllegalArgumentException class, with a</p>
<p>message that describes the error that exception is reporting.</p>
<p><strong>throw</strong> ... is then throwing the exception object.</p>
<p>When the exception is thrown, it causes the enclosing statements to
<em>terminate abnormally</em> until the exception is</p>
<p><em>handled</em>. This is described in other examples.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 409</p>
<p>It is good practice to both create and throw the exception object in
a single statement, as shown above. It is also good practice to include
a meaningful error message in the exception to help the programmer to
understand the</p>
<p>cause of the problem. However, this is not necessarily the message
that you should be showing to the end user.</p>
<p>(For a start, Java has no direct support for internationalizing
exception messages.)</p>
<p>There are a couple more points to be made:</p>
<p>We have declared the checkNumber as <strong>throws</strong>
IllegalArgumentException. This was not strictly necessary,</p>
<p>since IllegalArgumentException is a checked exception; see The Java
Exception Hierarchy - Unchecked and Checked Exceptions. However, it is
good practice to do this, and also to include the exceptions thrown
a</p>
<p>method's javadoc comments.</p>
<p>Code immediately after a <strong>throw</strong> statement is
<em>unreachable</em>. Hence if we wrote this:</p>
<p><strong>throw new</strong> IllegalArgumentException("it is bad");</p>
<p>return<strong>;</strong></p>
<p>the compiler would report a compilation error for the
<strong>return</strong> statement.</p>
<p>Exception chaining</p>
<p>Many standard exceptions have a constructor with a second cause
argument in addition to the conventional</p>
<p>message argument. The cause allows you to chain exceptions. Here is
an example.</p>
<p>First we define an unchecked exception that our application is going
throw when it encounters a non-recoverable</p>
<p>error. Note that we have included a constructor that accepts a cause
argument.</p>
<p><strong>public class</strong> AppErrorException
<strong>extends</strong> RuntimeException {</p>
<p><strong>public</strong> AppErrorException() {</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p><strong>public</strong> AppErrorException(String message) {</p>
<p><strong>super</strong>(message);</p>
<p>}</p>
<p><strong>public</strong> AppErrorException(String message, Throwable
cause) {</p>
<p><strong>super</strong>(message, cause);</p>
<p>}</p>
<p>}</p>
<p>Next, here is some code that illustrates exception chaining.</p>
<p><strong>public</strong> String readFirstLine(String file)
<strong>throws</strong> AppErrorException {</p>
<p><strong>try</strong> (Reader r = <strong>new</strong>
BufferedReader(<strong>new</strong> FileReader(file))) {</p>
<p>String line = r.readLine();</p>
<p><strong>if</strong> (line != <strong>null</strong>) {</p>
<p>return <strong>line;</strong></p>
<p>} <strong>else</strong> {</p>
<p><strong>throw new</strong> AppErrorException("File is empty: " +
file);</p>
<p>}</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p><strong>throw new</strong> AppErrorException("Cannot read file: " +
file, ex);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 410</p>
<p><span id="The_throw_within_the_try_block_d" class="anchor"></span>The
<strong>throw</strong> within the <strong>try</strong> block detects a
problem and reports it via an exception with a simple message. By
contrast, the <strong>throw</strong> within the <strong>catch</strong>
block is handling the IOException by wrapping it in a new (checked)
exception.</p>
<p>However, it is not throwing away the original exception. By passing
the IOException as the cause, we record it so</p>
<p>that it can be printed in the stacktrace, as explained in Creating
and reading stacktraces.</p>
<p>Section 69.10: Advanced features of Exceptions</p>
<p>This example covers some advanced features and use-cases for
Exceptions.</p>
<p>Examining the callstack programmatically</p>
<p>Version ≥ Java SE 1.4</p>
<p>The primary use of exception stacktraces is to provide information
about an application error and its context so</p>
<p>that the programmer can diagnose and fix the problem. Sometimes it
can be used for other things. For example, a SecurityManager class may
need to examine the call stack to decide whether the code that is making
a call should</p>
<p>be trusted.</p>
<p>You can use exceptions to examine the call stack programmatically as
follows:</p>
<p><em>Exception ex = <strong>new</strong> Exception();</em> // this
captures the call stack</p>
<p>StackTraceElement[] frames = ex.getStackTrace();</p>
<p>System.out.println("This method is " + frames[0].getMethodName());
System.out.println("Called from method " +
frames[1].getMethodName());</p>
<p>There are some important caveats on this:</p>
<p>1. The information available in a StackTraceElement is limited. There
is no more information available than is</p>
<p>displayed by printStackTrace. (The values of the local variables in
the frame are not available.)</p>
<p>2. The javadocs for getStackTrace() state that a JVM is permitted to
leave out frames:</p>
<p>Some virtual machines may, under some circumstances, omit one or more
stack frames from the stack trace. In the extreme case, a virtual
machine that has no stack trace information concerning</p>
<p>this throwable is permitted to return a zero-length array from this
method.</p>
<p>Optimizing exception construction</p>
<p>As mentioned elsewhere, constructing an exception is rather expensive
because it entails capturing and recording</p>
<p>information about all stack frames on the current thread. Sometimes,
we know that that information is never going to be used for a given
exception; e.g. the stacktrace will never be printed. In that case,
there is an implementation</p>
<p>trick that we can use in a custom exception to cause the information
to not be captured.</p>
<p>The stack frame information needed for stacktraces, is captured when
the Throwable constructors call the</p>
<p>Throwable.fillInStackTrace() method. This method is
<strong>public</strong>, which means that a subclass can override it.
The trick is to override the method inherited from Throwable with one
that does nothing; e.g.</p>
<p><strong>public class</strong> MyException <strong>extends</strong>
Exception {</p>
<p>// constructors</p>
<p>@Override</p>
<p><strong>public void</strong> fillInStackTrace() {</p>
<p>// do nothing</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 411</p>
<p><span id="_28" class="anchor"></span>}</p>
<p>The problem with this approach is that an exception that overrides
fillInStackTrace() can never capture the stacktrace, and is useless in
scenarios where you need one.</p>
<p>Erasing or replacing the stacktrace</p>
<p>Version ≥ Java SE 1.4</p>
<p>In some situations, the stacktrace for an exception created in the
normal way contains either incorrect information, or information that
the developer does not want to reveal to the user. For these scenarios,
the</p>
<p>Throwable.setStackTrace can be used to replace the array of
StackTraceElement objects that holds the information.</p>
<p>For example, the following can be used to discard an exception's
stack information:</p>
<p>exception.setStackTrace(<strong>new</strong>
StackTraceElement[0]);</p>
<p>Suppressed exceptions</p>
<p>Version ≥ Java SE 7</p>
<p>Java 7 introduced the <em>try-with-resources</em> construct, and the
associated concept of exception suppression. Consider the following
snippet:</p>
<p><strong>try</strong> (Writer w = <strong>new</strong>
BufferedWriter(<strong>new</strong> FileWriter(someFilename))) {</p>
<p>// do stuff</p>
<p><em><strong>int</strong> temp = 0 / 0;</em> // throws an
ArithmeticException</p>
<p>}</p>
<p>When the exception is thrown, the <strong>try</strong> will call
close() on the w which will flush any buffered output and then close the
FileWriter. But what happens if an IOException is thrown while flushing
the output?</p>
<p>What happens is that any exception that is thrown while cleaning up a
resource is <em>suppressed</em>. The exception is caught, and added to
the primary exception's suppressed exception list. Next the
<em>try-with-resources</em> will continue</p>
<p>with the cleanup of the other resources. Finally, primary exception
will be rethrown.</p>
<p>A similar pattern occurs if an exception it thrown during the
resource initialization, or if the <strong>try</strong> block
completes</p>
<p>normally. The first exception thrown becomes the primary exception,
and subsequent ones arising from cleanup are suppressed.</p>
<p>The suppressed exceptions can be retrieved from the primary exception
object by calling</p>
<p>getSuppressedExceptions.</p>
<p>Section 69.11: The try-finally and try-catch-finally statements</p>
<p>The
<strong>try</strong>...<strong>catch</strong>...<strong>finally</strong>
statement combines exception handling with clean-up code. The
<strong>finally</strong> block</p>
<p>contains code that will be executed in all circumstances. This makes
them suitable for resource management, and other kinds of cleanup.</p>
<p>Try-finally</p>
<p>Here is an example of the simpler
(<strong>try</strong>...<strong>finally</strong>) form:</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>cleanUp();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 412</p>
<p>}</p>
<p>The behavior of the <strong>try</strong>...<strong>finally</strong>
is as follows:</p>
<p>The code in the <strong>try</strong> block is executed.</p>
<p>If no exception was thrown in the <strong>try</strong> block:</p>
<p>The code in the <strong>finally</strong> block is executed.</p>
<p>If the <strong>finally</strong> block throws an exception, that
exception is propagated. Otherwise, control passes to the next statement
after the <strong>try</strong>...<strong>finally</strong>.</p>
<p>If an exception was thrown in the try block:</p>
<p>The code in the <strong>finally</strong> block is executed.</p>
<p>If the <strong>finally</strong> block throws an exception, that
exception is propagated.</p>
<p>Otherwise, the original exception continues to propagate.</p>
<p>The code within <strong>finally</strong> block will always be
executed. (The only exceptions are if System.exit(<strong>int</strong>)
is called, or if</p>
<p>the JVM panics.) Thus a <strong>finally</strong> block is the correct
place code that always needs to be executed; e.g. closing files and
other resources or releasing locks.</p>
<p>try-catch-finally</p>
<p>Our second example shows how <strong>catch</strong> and
<strong>finally</strong> can be used together. It also illustrates that
cleaning up resources is not straightforward.</p>
<p>// This code snippet writes the first line of a file to a string
<em>String result = <strong>null</strong>;</em></p>
<p>Reader reader = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>reader = <strong>new</strong> BufferedReader(<strong>new</strong>
FileReader(fileName));</p>
<p>result = reader.readLine();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger.warn("Unexpected IO error", ex); <em>// logging the
exception</em> } <strong>finally</strong> {</p>
<p><strong>if</strong> (reader != <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>reader.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>// ignore / discard this exception</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The complete set of (hypothetical) behaviors of
<strong>try</strong>...<strong>catch</strong>...<strong>finally</strong>
in this example are too complicated to</p>
<p>describe here. The simple version is that the code in the
<strong>finally</strong> block will always be executed.</p>
<p>Looking at this from the perspective of resource management:</p>
<p>We declare the "resource" (i.e. reader variable) before the
<strong>try</strong> block so that it will be in scope for the
<strong>finally</strong> block.</p>
<p>By putting the <strong>new</strong> FileReader(...), the
<strong>catch</strong> is able to handle any IOError exception from
thrown when opening the file.</p>
<p>We need a reader.close() in the <strong>finally</strong> block
because there are some exception paths that we cannot intercept either
in the <strong>try</strong> block or in <strong>catch</strong>
block.</p>
<p>However, since an exception <em>might</em> have been thrown before
reader was initialized, we also need an explicit</p>
<p><strong>null</strong> test.</p>
<p>Finally, the reader.close() call might (hypothetically) throw an
exception. We don't care about that, but if we</p>
<p>don't catch the exception at source, we would need to deal with it
further up the call stack.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 413</p>
<p><span id="Version_____Java_SE_7" class="anchor"></span>Version ≥ Java
SE 7</p>
<p>Java 7 and later provide an alternative try-with-resources syntax
which significantly simplifies resource clean-up.</p>
<p>Section 69.12: The 'throws' clause in a method declaration</p>
<p>Java's <em>checked exception</em> mechanism requires the programmer
to declare that certain methods <em>could</em> throw specifed checked
exceptions. This is done using the <strong>throws</strong> clause. For
example:</p>
<p><strong>public class</strong> OddNumberException
<strong>extends</strong> Exception { <em>// a checked exception</em>
}</p>
<p><strong>public void</strong> checkEven(<strong>int</strong> number)
<strong>throws</strong> OddNumberException {</p>
<p><strong>if</strong> (number % 2 != 0) {</p>
<p><strong>throw new</strong> OddNumberException();</p>
<p>}</p>
<p>}</p>
<p>The <strong>throws</strong> OddNumberException declares that a call
to checkEven <em>could</em> throw an exception that is of type</p>
<p>OddNumberException .</p>
<p>A <strong>throws</strong> clause can declare a list of types, and can
include unchecked exceptions as well as checked exceptions.</p>
<p><strong>public void</strong> checkEven(Double number)</p>
<p><strong>throws</strong> OddNumberException, ArithmeticException {</p>
<p><strong>if</strong> (!Double.isFinite(number)) {</p>
<p><strong>throw new</strong> ArithmeticException("INF or NaN");</p>
<p>} <strong>else if</strong> (number % 2 != 0) {</p>
<p><strong>throw new</strong> OddNumberException();</p>
<p>}</p>
<p>}</p>
<p>What is the point of declaring unchecked exceptions as thrown?</p>
<p>The <strong>throws</strong> clause in a method declaration serves two
purposes:</p>
<p>1. It tells the compiler which exceptions are thrown so that the
compiler can report uncaught (checked)</p>
<p>exceptions as errors.</p>
<p>2. It tells a programmer who is writing code that calls the method
what exceptions to expect. For this purpose,</p>
<p>it often makes to senses to include unchecked exceptions in a
<strong>throws</strong> list.</p>
<p>Note: that the <strong>throws</strong> list is also used by the
javadoc tool when generating API documentation, and by a typical
IDE's</p>
<p>"hover text" method tips.</p>
<p>Throws and method overriding</p>
<p>The <strong>throws</strong> clause forms part of a method's signature
for the purpose of method overriding. An override method</p>
<p>can be declared with the same set of checked exceptions as thrown by
the overridden method, or with a subset. However the override method
cannot add extra checked exceptions. For example:</p>
<p>@Override</p>
<p><em><strong>public void</strong> checkEven(<strong>int</strong>
number) <strong>throws</strong> NullPointerException</em> //
OK<em>—</em>NullPointerException is an unchecked exception</p>
<p>...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 414</p>
<p>@Override</p>
<p><strong>public void</strong> checkEven(Double number)
<strong>throws</strong> OddNumberException <em>// OK</em>—<em>identical
to the superclass</em></p>
<p>...</p>
<p><strong>class</strong> PrimeNumberException <strong>extends</strong>
OddNumberException {} <strong>class</strong> NonEvenNumberException
<strong>extends</strong> OddNumberException {}</p>
<p>@Override</p>
<p><strong>public void</strong> checkEven(<strong>int</strong> number)
<strong>throws</strong> PrimeNumberException, NonEvenNumberException
<em>// OK</em> —<em>these are both subclasses</em></p>
<p>@Override</p>
<p><strong>public void</strong> checkEven(Double number)
<strong>throws</strong> IOExcepion <em>// ERROR</em></p>
<p>The reason for this rule is that if an overridden method can throw a
checked exception that the overridden method could not throw, that would
break type substitutability.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 415</p>
<p><span id="Chapter_70__Calendar_and_its_Sub_1"
class="anchor"></span>Chapter 70: Calendar and its Subclasses</p>
<p>Section 70.1: Creating Calendar objects</p>
<p>Calendar objects can be created by using getInstance() or by using
the constructor GregorianCalendar.</p>
<p>It's important to notice that months in Calendar are zero based,
which means that JANUARY is represented by an</p>
<p><strong>int</strong> value 0. In order to provide a better code,
always use Calendar constants, such as Calendar.JANUARY to avoid
misunderstandings.</p>
<p>Calendar calendar = Calendar.getInstance();</p>
<p>Calendar gregorianCalendar = <strong>new</strong>
GregorianCalendar(); Calendar gregorianCalendarAtSpecificDay =
<strong>new</strong> GregorianCalendar(2016, Calendar.JANUARY, 1);
Calendar gregorianCalendarAtSpecificDayAndTime = <strong>new</strong>
GregorianCalendar(2016, Calendar.JANUARY, 1, 6, 55, 10);</p>
<p><strong>Note</strong><a
href="http://stackoverflow.com/questions/344380/why-is-january-month-0-in-java-calendar">:
Always use the month constants: The numeric representation is
misleading</a>, e.g. Calendar.JANUARY has the</p>
<p>value 0</p>
<p>Section 70.2: Increasing / Decreasing calendar fields</p>
<p>add() and roll() can be used to increase/decrease Calendar
fields.</p>
<p>Calendar calendar = <strong>new</strong> GregorianCalendar(2016,
Calendar.MARCH, 31); <em>// 31 March 2016</em></p>
<p>The add() method affects all fields, and behaves effectively if one
were to add or subtract actual dates from the</p>
<p>calendar</p>
<p>calendar.add(Calendar.MONTH, -6);</p>
<p>The above operation removes six months from the calendar, taking us
back to 30 September 2015.</p>
<p>To change a particular field without affecting the other fields, use
roll().</p>
<p>calendar.roll(Calendar.MONTH, -6);</p>
<p>The above operation removes six months from the current
<em>month</em>, so the month is identified as September. No</p>
<p>other fields have been adjusted; the year has not changed with this
operation.</p>
<p>Section 70.3: Subtracting calendars</p>
<p>To get a difference between two Calendars, use getTimeInMillis()
method:</p>
<p>Calendar c1 = Calendar.getInstance();</p>
<p>Calendar c2 = Calendar.getInstance();</p>
<p>c2.set(Calendar.DATE, c2.get(Calendar.DATE) + 1);</p>
<p>System.out.println(c2.getTimeInMillis()- c1.getTimeInMillis());
<em>//outputs 86400000 (24 * 60 * 60 * 1000)</em></p>
<p>Section 70.4: Finding AM/PM</p>
<p>With Calendar class it is easy to find AM or PM.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 416</p>
<p>Calendar cal = Calendar.getInstance();</p>
<p>cal.setTime(<strong>new</strong> Date());</p>
<p><strong>if</strong> (cal.get(Calendar.AM_PM) == Calendar.PM)</p>
<p>System.out.println("It is PM");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 417</p>
<p><span id="Chapter_71__Using_the_static_key_1"
class="anchor"></span>Chapter 71: Using the static keyword</p>
<p>Section 71.1: Reference to non-static member from static</p>
<p>context</p>
<p>Static variables and methods are not part of an instance, There will
always be a single copy of that variable no</p>
<p>matter how many objects you create of a particular class.</p>
<p>For example you might want to have an immutable list of constants, it
would be a good idea to keep it static and initialize it just once
inside a static method. This would give you a significant performance
gain if you are creating</p>
<p>several instances of a particular class on a regular basis.</p>
<p>Furthermore you can also have a static block in a class as well. You
can use it to assign a default value to a static</p>
<p>variable. They are executed only once when the class is loaded into
memory.</p>
<p>Instance variable as the name suggest are dependent on an instance of
a particular object, they live to serve the</p>
<p>whims of it. You can play around with them during a particular life
cycle of an object.</p>
<p>All the fields and methods of a class used inside a static method of
that class must be static or local. If you try to use</p>
<p>instance (non-static) variables or methods, your code will not
compile.</p>
<p>public class <strong>Week {</strong></p>
<p><strong>static int</strong> daysOfTheWeek = 7; <em>// static
variable</em></p>
<p><em><strong>int</strong> dayOfTheWeek;</em> // instance variable</p>
<p><strong>public static int</strong> getDaysLeftInWeek(){</p>
<p><strong>return</strong> Week.daysOfTheWeek-dayOfTheWeek; <em>// this
will cause errors</em></p>
<p>}</p>
<p><strong>public int</strong> getDaysLeftInWeek(){</p>
<p><strong>return</strong> Week.daysOfTheWeek-dayOfTheWeek; <em>// this
is valid</em></p>
<p>}</p>
<p><strong>public static int</strong>
getDaysLeftInTheWeek(<strong>int</strong> today){</p>
<p><strong>return</strong> Week.daysOfTheWeek-today; <em>// this is
valid</em></p>
<p>}</p>
<p>}</p>
<p>Section 71.2: Using static to declare constants</p>
<p>As the <strong>static</strong> keyword is used for accessing fields
and methods without an instantiated class, it can be used to</p>
<p>declare constants for use in other classes. These variables will
remain constant across every instantiation of the class. By convention,
<strong>static</strong> variables are always ALL_CAPS and use
underscores rather than camel case. ex:</p>
<p><strong>static</strong> E STATIC_VARIABLE_NAME</p>
<p>As constants cannot change, <strong>static</strong> can also be used
with the <strong>final</strong> modifier:</p>
<p>For example, to define the mathematical constant of pi:</p>
<p><strong>public class</strong> MathUtilities {</p>
<p>static final double <strong>PI = 3.14159265358</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 418</p>
<p>}</p>
<p>Which can be used in any class as a constant, for example:</p>
<p><strong>public class</strong> MathCalculations {</p>
<p>//Calculates the circumference of a circle</p>
<p><strong>public double</strong>
calculateCircumference(<strong>double</strong> radius) {</p>
<p><strong>return</strong> (2 * radius * MathUtilities.PI);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 419</p>
<p><span id="Chapter_72__Properties_Class_1"
class="anchor"></span>Chapter 72: Properties Class</p>
<p>The properties object contains key and value pair both as a string.
The java.util.Properties class is the subclass of</p>
<p>Hashtable.</p>
<p>It can be used to get property value based on the property key. The
Properties class provides methods to get data</p>
<p>from properties file and store data into properties file. Moreover,
it can be used to get properties of system.</p>
<p>Advantage of properties file</p>
<p>Recompilation is not required, if information is changed from
properties file: If any information is changed from</p>
<p>Section 72.1: Loading properties</p>
<p>To load a properties file bundled with your application:</p>
<p>public class <strong>Defaults {</strong></p>
<p><strong>public static</strong> Properties loadDefaults() {</p>
<p><strong>try</strong> (InputStream bundledResource =</p>
<p>Defaults.<strong>class</strong>.getResourceAsStream("defaults.properties"))
{</p>
<p>Properties defaults = <strong>new</strong> Properties();</p>
<p>defaults.load(bundledResource);</p>
<p><strong>return</strong> defaults;</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>// Since the resource is bundled with the application, // we should
never get here.</p>
<p><strong>throw new</strong> UncheckedIOException(</p>
<p>"defaults.properties not properly packaged"</p>
<p>+ " with application", e);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 72.2: Saving Properties as XML</p>
<p>Storing Properties in a XML File</p>
<p>The way you store properties files as XML files is very similar to
the way you would store them as .properties files.</p>
<p>Just instead of using the store() you would use storeToXML().</p>
<p><strong>public void</strong> saveProperties(String location)
<strong>throws</strong> IOException{</p>
<p>// make new instance of properties</p>
<p>Properties prop = <strong>new</strong> Properties();</p>
<p>// set the property values</p>
<p>prop.setProperty("name", "Steve");</p>
<p>prop.setProperty("color", "green");</p>
<p>prop.setProperty("age", "23");</p>
<p>// check to see if the file already exists</p>
<p>File file = <strong>new</strong> File(location);</p>
<p><strong>if</strong> (!file.exists()){</p>
<p>file.createNewFile();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 420</p>
<p><span id="___save_the_properties" class="anchor"></span>// save the
properties</p>
<p>prop.storeToXML(<strong>new</strong> FileOutputStream(file), "testing
properties with xml"); }</p>
<p>When you open the file it will look like this.</p>
<p><img src="media/index-445_1.jpeg"
style="width:6.5in;height:1.38889in" alt="index-445_1.jpg" /></p>
<p>Loading Properties from a XML File</p>
<p>Now to load this file as a properties you need to call the
loadFromXML() instead of the load() that you would use</p>
<p>with regular .properties files.</p>
<p><strong>public static void</strong> loadProperties(String location)
<strong>throws</strong> FileNotFoundException, IOException{</p>
<p>// make new properties instance to load the file into <em>Properties
prop = <strong>new</strong> Properties();</em></p>
<p>// check to make sure the file exists</p>
<p>File file = <strong>new</strong> File(location);</p>
<p><strong>if</strong> (file.exists()){</p>
<p>// load the file</p>
<p>prop.loadFromXML(<strong>new</strong> FileInputStream(file));</p>
<p>// print out all the properties</p>
<p><strong>for</strong> (String name : prop.stringPropertyNames()){</p>
<p>System.out.println(name + "=" + prop.getProperty(name));</p>
<p>}</p>
<p>} <strong>else</strong> {</p>
<p>System.err.println("Error: No file found at: " + location);</p>
<p>}</p>
<p>}</p>
<p>When you run this code you will get the following in the console:</p>
<p>age=23</p>
<p>color=green</p>
<p>name=Steve</p>
<p>Section 72.3: Property files caveat: trailing whitespace</p>
<p>Take a close look at these two property files which are seemingly
completely identical:</p>
<p><img src="media/index-445_2.png"
style="width:6.18056in;height:0.95833in" alt="index-445_2.png" /></p>
<p>except they are really not identical:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 421</p>
<p><img src="media/index-446_1.png"
style="width:6.18056in;height:0.95833in" alt="index-446_1.png" /></p>
<p>(screenshots are from Notepad++)</p>
<p>Since trailing whitespace is preserved the value of lastName would be
"Smith" in the first case and "Smith " in the second case.</p>
<p>Very rarely this is what users expect and one and can only speculate
why this is the default behavior of Properties class. It is however easy
to create an enhanced version of Properties that fixes this problem. The
following class,</p>
<p><strong>TrimmedProperties</strong>, does just that. It is a drop-in
replacement for standard Properties class.</p>
<p><strong>import</strong> java.io.FileInputStream;</p>
<p><strong>import</strong> java.io.FileReader;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.InputStream;</p>
<p><strong>import</strong> java.io.Reader;</p>
<p><strong>import</strong> java.util.Map.Entry;</p>
<p><strong>import</strong> java.util.Properties;</p>
<p>/**</p>
<p>* Properties class where values are trimmed for trailing whitespace
if the * properties are loaded from a file.</p>
<p>*</p>
<p>* &lt;p&gt;</p>
<p>* In the standard {@link java.util.Properties Properties} class
trailing * whitespace is always preserved. When loading properties from
a file such * trailing whitespace is almost always
&lt;i&gt;unintentional&lt;/i&gt;. This class fixes * this problem. The
trimming of trailing whitespace only takes place if the * source of
input is a file and only where the input is line oriented (meaning *
that for example loading from XML file is &lt;i&gt;not&lt;/i&gt; changed
by this class). * For this reason this class is almost in all cases a
safe drop-in replacement * for the standard
&lt;tt&gt;Properties&lt;/tt&gt;</p>
<p>* class.</p>
<p>*</p>
<p>* &lt;p&gt;</p>
<p>* Whitespace is defined here as any of space (U+0020) or tab
(U+0009). * *</p>
<p>*/</p>
<p><strong>public class</strong> TrimmedProperties
<strong>extends</strong> Properties {</p>
<p>/**</p>
<p>* Reads a property list (key and element pairs) from the input byte
stream.</p>
<p>*</p>
<p>* &lt;p&gt;Behaves exactly as {@link
java.util.Properties#load(java.io.InputStream) }</p>
<p>* with the exception that trailing whitespace is trimmed from
property values</p>
<p>* if &lt;tt&gt;inStream&lt;/tt&gt; is an instance of
&lt;tt&gt;FileInputStream&lt;/tt&gt;.</p>
<p>*</p>
<p>* @see java.util.Properties#load(java.io.InputStream)</p>
<p>* @param inStream the input stream.</p>
<p>* @throws IOException if an error occurred when reading from the
input stream.</p>
<p>*/</p>
<p>@Override</p>
<p><strong>public void</strong> load(InputStream inStream)
<strong>throws</strong> IOException {</p>
<p><strong>if</strong> (inStream <strong>instanceof</strong>
FileInputStream) {</p>
<p>// First read into temporary props using the standard way
<em>Properties tempProps = <strong>new</strong> Properties();</em></p>
<p>tempProps.load(inStream);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 422</p>
<p>// Now trim and put into target</p>
<p>trimAndLoad(tempProps);</p>
<p>} <strong>else</strong> {</p>
<p><strong>super</strong>.load(inStream);</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Reads a property list (key and element pairs) from the input
character stream in a simple line-oriented format.</p>
<p>*</p>
<p>* &lt;p&gt;Behaves exactly as {@link
java.util.Properties#load(java.io.Reader)}</p>
<p>* with the exception that trailing whitespace is trimmed on property
values</p>
<p>* if &lt;tt&gt;reader&lt;/tt&gt; is an instance of
&lt;tt&gt;FileReader&lt;/tt&gt;.</p>
<p>*</p>
<p>* @see java.util.Properties#load(java.io.Reader) }</p>
<p>* @param reader the input character stream.</p>
<p>* @throws IOException if an error occurred when reading from the
input stream.</p>
<p>*/</p>
<p>@Override</p>
<p><strong>public void</strong> load(Reader reader)
<strong>throws</strong> IOException {</p>
<p><strong>if</strong> (reader <strong>instanceof</strong> FileReader)
{</p>
<p>// First read into temporary props using the standard way
<em>Properties tempProps = <strong>new</strong> Properties();</em></p>
<p>tempProps.load(reader);</p>
<p>// Now trim and put into target</p>
<p>trimAndLoad(tempProps);</p>
<p>} <strong>else</strong> {</p>
<p><strong>super</strong>.load(reader);</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> trimAndLoad(Properties p) {</p>
<p><strong>for</strong> (Entry entry : p.entrySet()) {</p>
<p><strong>if</strong> (entry.getValue() <strong>instanceof</strong>
String) {</p>
<p>put(entry.getKey(), trimTrailing((String) entry.getValue()));</p>
<p>} <strong>else</strong> {</p>
<p>put(entry.getKey(), entry.getValue());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Trims trailing space or tabs from a string.</p>
<p>*</p>
<p>* @param str</p>
<p>* @return</p>
<p>*/</p>
<p><strong>public static</strong> String trimTrailing(String str) {</p>
<p><strong>if</strong> (str != <strong>null</strong>) {</p>
<p>// read str from tail until char is no longer whitespace
<em><strong>for</strong> (<strong>int</strong> i = str.length()-1; i
&gt;= 0; i--) {</em></p>
<p><strong>if</strong> ((str.charAt(i) != ' ') &amp;&amp; (str.charAt(i)
!= '<strong>\t</strong>')) {</p>
<p><strong>return</strong> str.substring(0, i + 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return <strong>str;</strong></p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 423</p>
<p><span id="Chapter_73__Lambda_Expressions_1"
class="anchor"></span>Chapter 73: Lambda Expressions</p>
<p>Lambda expressions provide a clear and concise way of implementing a
single-method interface using an</p>
<p>expression. They allow you to reduce the amount of code you have to
create and maintain. While similar to anonymous classes, they have no
type information by themselves. Type inference needs to happen.</p>
<p>Method references implement functional interfaces using existing
methods rather than expressions. They belong to the lambda family as
well.</p>
<p>Section 73.1: Introduction to Java lambdas</p>
<p>Functional Interfaces</p>
<p>Lambdas can only operate on a functional interface, which is an
interface with just one abstract method. Functional interfaces can have
any number of <strong>default</strong> or <strong>static</strong>
methods. (For this reason, they are sometimes referred to as</p>
<p>Single Abstract Method Interfaces, or SAM Interfaces).</p>
<p>interface <strong>Foo1 {</strong></p>
<p><strong>void</strong> bar();</p>
<p>}</p>
<p>interface <strong>Foo2 {</strong></p>
<p><strong>int</strong> bar(<strong>boolean</strong> baz);</p>
<p>}</p>
<p>interface <strong>Foo3 {</strong></p>
<p>String bar(Object baz, <strong>int</strong> mink);</p>
<p>}</p>
<p>interface <strong>Foo4 {</strong></p>
<p><em><strong>default</strong> String bar() {</em> // default so not
counted</p>
<p><strong>return</strong> "baz";</p>
<p>}</p>
<p><strong>void</strong> quux();</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">When
declaring a functional interface the @FunctionalInterface</a> annotation
can be added. This has no special effect, but a compiler error will be
generated if this annotation is applied to an interface which is not
functional,</p>
<p>thus acting as a reminder that the interface should not be
changed.</p>
<p>@FunctionalInterface</p>
<p>interface <strong>Foo5 {</strong></p>
<p><strong>void</strong> bar();</p>
<p>}</p>
<p>@FunctionalInterface</p>
<p><em><strong>interface</strong> BlankFoo1 <strong>extends</strong>
Foo3 {</em> // inherits abstract method from Foo3 <em>}</em></p>
<p>@FunctionalInterface</p>
<p>interface <strong>Foo6 {</strong></p>
<p><strong>void</strong> bar();</p>
<p><em><strong>boolean</strong> equals(Object obj);</em> // overrides
one of Object's method so not counted</p>
<p>}</p>
<p>Conversely, this is <strong>not</strong> a functional interface, as
it has more than <strong>one abstract</strong> method:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 424</p>
<p>interface <strong>BadFoo {</strong></p>
<p><strong>void</strong> bar();</p>
<p><em><strong>void</strong> quux();</em> // &lt;-- Second method
prevents lambda: which one should</p>
<p>// be considered as lambda?</p>
<p>}</p>
<p>This is <strong>also not</strong> a functional interface, as it does
not have any methods:</p>
<p><strong>interface</strong> BlankFoo2 { }</p>
<p>Take note of the following. Suppose you have</p>
<p><strong>interface</strong> Parent { <strong>public int</strong>
parentMethod(); }</p>
<p>and</p>
<p><strong>interface</strong> Child <strong>extends</strong> Parent {
<strong>public int</strong> ChildMethod(); }</p>
<p>Then Child <strong>cannot</strong> be a functional interface since it
has two specified methods.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html">Java
8 also provides a number of generic templated functional interfaces in
the package java.util.function. For</a></p>
<p>example, the built-in interface Predicate wraps a single method which
inputs a value of type T and returns a <strong>boolean</strong> .</p>
<p>Lambda Expressions</p>
<p>The basic structure of a Lambda expression is:</p>
<p><img src="media/index-449_1.jpeg" style="width:6.5in;height:1.75in"
alt="index-449_1.jpg" /></p>
<p>fi will then hold a singleton instance of a class, similar to an
anonymous class, which implements FunctionalInterface and where the one
method's definition is { System.out.println("Hello"); }. In other</p>
<p>words, the above is mostly equivalent to:</p>
<p>FunctionalInterface fi = <strong>new</strong> FunctionalInterface()
{</p>
<p>@Override</p>
<p><strong>public void</strong> theOneMethod() {</p>
<p>System.out.println("Hello");</p>
<p>}</p>
<p>};</p>
<p>The lambda is only "mostly equivalent" to the anonymous class because
in a lambda, the meaning of expressions</p>
<p>like <strong>this</strong>, <strong>super</strong> or toString()
reference the class within which the assignment takes place, not the
newly created object.</p>
<p>You cannot specify the name of the method when using a lambda—but you
shouldn't need to, because a functional interface must have only one
abstract method, so Java overrides that one.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 425</p>
<p>In cases where the type of the lambda is not certain, (e.g.
overloaded methods) you can add a cast to the lambda to tell the
compiler what its type should be, like so:</p>
<p>Object fooHolder = (Foo1) ()-&gt; System.out.println("Hello");
System.out.println(fooHolder <strong>instanceof</strong> Foo1); <em>//
returns true</em></p>
<p>If the functional interface's single method takes parameters, the
local formal names of these should appear between the brackets of the
lambda. There is no need to declare the type of the parameter or return
as these are</p>
<p>taken from the interface (although it is not an error to declare the
parameter types if you want to). Thus, these two examples are
equivalent:</p>
<p>Foo2 longFoo = <strong>new</strong> Foo2() {</p>
<p>@Override</p>
<p>public int <strong>bar(</strong>boolean <strong>baz) {</strong></p>
<p><strong>return</strong> baz ? 1 : 0;</p>
<p>}</p>
<p>};</p>
<p>Foo2 shortFoo = (x)-&gt; { <strong>return</strong> x ? 1 : 0; };</p>
<p>The parentheses around the argument can be omitted if the function
only has one argument:</p>
<p>Foo2 np = x -&gt; { <strong>return</strong> x ? 1 : 0; }; <em>//
okay</em></p>
<p>Foo3 np2 = x, y -&gt; x.toString() + y <em>// not okay</em></p>
<p>Implicit Returns</p>
<p>If the code placed inside a lambda is a Java <em>expression</em>
rather than a <em>statement</em>, it is treated as a method which</p>
<p>returns the value of the expression. Thus, the following two are
equivalent:</p>
<p>IntUnaryOperator addOneShort = (x)-&gt; (x + 1);</p>
<p>IntUnaryOperator addOneLong = (x)-&gt; { <strong>return</strong> (x +
1); };</p>
<p>Accessing Local Variables (value closures)</p>
<p>Since lambdas are syntactic shorthand for anonymous classes, they
follow the same rules for accessing local</p>
<p>variables in the enclosing scope; the variables must be treated as
<strong>final</strong> and not modified inside the lambda.</p>
<p>IntUnaryOperator makeAdder(<strong>int</strong> amount) {</p>
<p><em><strong>return</strong> (x)-&gt; (x + amount);</em> // Legal even
though amount will go out of scope</p>
<p>// because amount is not modified</p>
<p>}</p>
<p>IntUnaryOperator makeAccumulator(<strong>int</strong> value) {</p>
<p><strong>return</strong> (x)-&gt; { value += x;
<strong>return</strong> value; }; <em>// Will not compile</em></p>
<p>}</p>
<p>If it is necessary to wrap a changing variable in this way, a regular
object that keeps a copy of the variable should be used. Read more in
Java Closures with lambda expressions.</p>
<p>Accepting Lambdas</p>
<p>Because a lambda is an implementation of an interface, nothing
special needs to be done to make a method accept</p>
<p>a lambda: any function which takes a functional interface can also
accept a lambda.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 426</p>
<p><span id="public_void_passMeALambda_Foo1_f"
class="anchor"></span><strong>public void</strong> passMeALambda(Foo1 f)
{</p>
<p>f.bar();</p>
<p>}</p>
<p>passMeALambda(()-&gt; System.out.println("Lambda called"));</p>
<p>The Type of a Lambda Expression</p>
<p>A lambda expression, by itself, does not have a specific type. While
it is true that the types and number of</p>
<p>parameters, along with the type of a return value can convey some
type information, such information will only constrain what types it can
be assigned to. The lambda receives a type when it is assigned to a
functional interface</p>
<p>type in one of the following ways:</p>
<p>Direct assignment to a functional type, e.g. myPredicate = s -&gt;
s.isEmpty()</p>
<p>Passing it as a parameter that has a functional type, e.g.
stream.filter(s -&gt; s.isEmpty()) Returning it from a function that
returns a functional type, e.g. <strong>return</strong> s -&gt;
s.isEmpty()</p>
<p>Casting it to a functional type, e.g. (Predicate) s -&gt;
s.isEmpty()</p>
<p>Until any such assignment to a functional type is made, the lambda
does not have a definite type. To illustrate,</p>
<p>consider the lambda expression o -&gt; o.isEmpty(). The same lambda
expression can be assigned to many different functional types:</p>
<p>Predicate javaStringPred = o -&gt; o.isEmpty(); Function javaFunc = o
-&gt; o.isEmpty(); Predicate javaListPred = o -&gt; o.isEmpty();</p>
<p>Consumer javaStringConsumer = o -&gt; o.isEmpty(); <em>// return
value is ignored!</em> com.google.common.base.Predicate guavaPredicate =
o -&gt; o.isEmpty();</p>
<p>Now that they are assigned, the examples shown are of completely
different types even though the lambda</p>
<p>expressions looked the same, and they cannot be assigned to each
other.</p>
<p>Section 73.2: Using Lambda Expressions to Sort a Collection</p>
<p>Sorting lists</p>
<p>Prior to Java 8, it was necessary to implement the <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">java.util.Comparator
interface with an anonymous (or named)</a></p>
<p>class when sorting a list1:</p>
<p>Version ≥ Java SE 1.2</p>
<p>List people = ...</p>
<p>Collections.sort(</p>
<p>people,</p>
<p><strong>new</strong> Comparator() {</p>
<p><strong>public int</strong> compare(Person p1, Person p2){</p>
<p><strong>return</strong>
p1.getFirstName().compareTo(p2.getFirstName());</p>
<p>}</p>
<p>}</p>
<p>);</p>
<p>Starting with Java 8, the anonymous class can be replaced with a
lambda expression. Note that the types for the</p>
<p>parameters p1 and p2 can be left out, as the compiler will infer them
automatically:</p>
<p>Collections.sort(</p>
<p>people,</p>
<p>(p1, p2)-&gt; p1.getFirstName().compareTo(p2.getFirstName())</p>
<p>);</p>
<p>The example can be simplified by using <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-">Comparator.comparing
and method references expressed using the</a> ::</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 427</p>
<p><span id="_double_colon__symbol" class="anchor"></span>(double colon)
symbol.</p>
<p>Collections.sort(</p>
<p>people,</p>
<p>Comparator.comparing(Person::getFirstName)</p>
<p>);</p>
<p>A static import allows us to express this more concisely, but it is
debatable whether this improves overall</p>
<p>readability:</p>
<p><strong>import</strong> static java.util.Collections.sort;</p>
<p><strong>import</strong> static java.util.Comparator.comparing;</p>
<p>//...</p>
<p>sort(people, comparing(Person::getFirstName));</p>
<p>Comparators built this way can also be chained together. For example,
after comparing people by their first name,</p>
<p>if there are people with the same first name, the thenComparing
method with also compare by last name:</p>
<p>sort(people,
comparing(Person::getFirstName).thenComparing(Person::getLastName));</p>
<p>1 - Note that Collections.sort(...) only works on collections that
are subtypes of List. The Set and Collection APIs</p>
<p>do not imply any ordering of the elements.</p>
<p>Sorting maps</p>
<p>You can sort the entries of a HashMap by value in a similar fashion.
(Note that a LinkedHashMap must be used as the</p>
<p>target. The keys in an ordinary HashMap are unordered.)</p>
<p><em>Map map = <strong>new</strong> HashMap();</em> // ... or any
other Map class // populate the map</p>
<p>map = map.entrySet()</p>
<p>.stream()</p>
<p>.sorted(Map.Entry.comparingByValue())</p>
<p>.collect(Collectors.toMap(k -&gt; k.getKey(), v -&gt;
v.getValue(),</p>
<p>(k, v)-&gt; k, LinkedHashMap::<strong>new</strong>));</p>
<p>Section 73.3: Method References</p>
<p>Method references allow predefined static or instance methods that
adhere to a compatible functional interface to be passed as arguments
instead of an anonymous lambda expression.</p>
<p>Assume that we have a model:</p>
<p><strong>class</strong> Person {</p>
<p>private final <strong>String name;</strong></p>
<p><strong>private final</strong> String surname;</p>
<p><strong>public</strong> Person(String name, String surname){</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.surname = surname;</p>
<p>}</p>
<p><strong>public</strong> String getName(){ <strong>return</strong>
name; }</p>
<p><strong>public</strong> String getSurname(){ <strong>return</strong>
surname; }</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 428</p>
<p>List people = getSomePeople();</p>
<p>Instance method reference (to an arbitrary instance)</p>
<p>people.stream().map(Person::getName)</p>
<p>The equivalent lambda:</p>
<p>people.stream().map(person -&gt; person.getName())</p>
<p>In this example, a method reference to the instance method getName()
of type Person, is being passed. Since it's</p>
<p>known to be of the collection type, the method on the instance (known
later) will be invoked.</p>
<p>Instance method reference (to a specific instance)</p>
<p>people.<strong>forEach</strong>(System.out::println);</p>
<p>Since System.out is an instance of PrintStream, a method reference to
this specific instance is being passed as an argument.</p>
<p>The equivalent lambda:</p>
<p>people.<strong>forEach</strong>(person -&gt;
System.out.println(person));</p>
<p>Static method reference</p>
<p>Also for transforming streams we can apply references to static
methods:</p>
<p>List numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
numbers.stream().map(String::valueOf)</p>
<p>This example passes a reference to the static valueOf() method on the
String type. Therefore, the instance object</p>
<p>in the collection is passed as an argument to valueOf().</p>
<p>The equivalent lambda:</p>
<p>numbers.stream().map(num -&gt; String.valueOf(num))</p>
<p>Reference to a constructor</p>
<p>List strings = Arrays.asList("1", "2", "3");
strings.stream().map(Integer::<strong>new</strong>)</p>
<p>Read Collect Elements of a Stream into a Collection to see how to
collect elements to collection.</p>
<p>The single String argument constructor of the Integer type is being
used here, to construct an integer given the string provided as the
argument. In this case, as long as the string represents a number, the
stream will be mapped</p>
<p>to Integers. The equivalent lambda:</p>
<p>strings.stream().map(s -&gt; <strong>new</strong> Integer(s));</p>
<p>Cheat-Sheet</p>
<p>Method Reference Format Code Equivalent Lambda</p>
<p>Static method TypeName::method (args)-&gt; TypeName.method(args)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 429</p>
<p><span id="Non_static_method__on_instance"
class="anchor"></span>Non-static method (on instance*) instance::method
(args)-&gt; instance.method(args)</p>
<p>Non-static method (no instance) TypeName::method (instance,
args)-&gt; instance.method(args)</p>
<p>Constructor** TypeName::<strong>new</strong> (args)-&gt;
<strong>new</strong> TypeName(args)</p>
<p>Array constructor TypeName[]::<strong>new</strong>
(<strong>int</strong> size)-&gt; <strong>new</strong> TypeName[size]</p>
<p>* instance can be any expression that evaluates to a reference to an
instance, e.g. getInstance()::method, <strong>this</strong>::method</p>
<p>** If TypeName is a non-static inner class, constructor reference is
only valid within the scope of an outer class</p>
<p>instance</p>
<p>Section 73.4: Implementing multiple interfaces</p>
<p>Sometimes you may want to have a lambda expression implementing more
than one interface. This is mostly</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">useful
with marker interfaces (such as java.io.Serializable</a>) since they
don't add abstract methods.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html">For
example, you want to create a TreeSet with a custom</a> Comparator and
then serialize it and send it over the network. The trivial
approach:</p>
<p>TreeSet ts = <strong>new</strong> TreeSet&lt;&gt;((x, y)-&gt;
Long.compare(y, x));</p>
<p>doesn't work since the lambda for the comparator does not implement
Serializable. You can fix this by using</p>
<p>intersection types and explicitly specifying that this lambda needs
to be serializable:</p>
<p>TreeSet ts = <strong>new</strong> TreeSet&lt;&gt;(</p>
<p>(Comparator &amp; Serializable) (x, y)-&gt; Long.compare(y, x));</p>
<p><a href="http://spark.apache.org/">If you're frequently using
intersection types (for example, if you're using a framework such as
Apache Spark where</a></p>
<p>almost everything has to be serializable), you can create empty
interfaces and use them in your code instead:</p>
<p><strong>public interface</strong> SerializableComparator
<strong>extends</strong> Comparator, Serializable {}</p>
<p><strong>public class</strong> CustomTreeSet {</p>
<p><strong>public</strong> CustomTreeSet(SerializableComparator
comparator) {}</p>
<p>}</p>
<p>This way you're guaranteed that the passed comparator will be
serializable.</p>
<p>Section 73.5: Lambda - Listener Example</p>
<p>Anonymous class listener</p>
<p>Before Java 8, it’s very common that an anonymous class is used to
handle click event of a JButton, as shown in the</p>
<p>following code. This example shows how to implement an anonymous
listener within the scope of btn.addActionListener.</p>
<p>JButton btn = <strong>new</strong> JButton("My Button");</p>
<p>btn.addActionListener(<strong>new</strong> ActionListener() {</p>
<p>@Override</p>
<p><strong>public void</strong> actionPerformed(ActionEvent e) {</p>
<p>System.out.println("Button was pressed");</p>
<p>}</p>
<p>});</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 430</p>
<p><span id="Lambda_listener" class="anchor"></span>Lambda listener</p>
<p>Because the ActionListener interface defines only one method
actionPerformed(), it is a functional interface</p>
<p>which means there’s a place to use Lambda expressions to replace the
boilerplate code. The above example can be re-written using Lambda
expressions as follows:</p>
<p>JButton btn = <strong>new</strong> JButton("My Button");</p>
<p>btn.addActionListener(e -&gt; {</p>
<p>System.out.println("Button was pressed");</p>
<p>});</p>
<p>Section 73.6: Java Closures with lambda expressions</p>
<p>A lambda closure is created when a lambda expression references the
variables of an enclosing scope (global or local). The rules for doing
this are the same as those for inline methods and anonymous classes.</p>
<p><em>Local variables</em> from an enclosing scope that are used within
a lambda have to be <strong>final</strong>. With Java 8 (the earliest
version that supports lambdas), they don't need to be <em>declared</em>
<strong>final</strong> in the outside context, but must be treated</p>
<p>that way. For example:</p>
<p><em><strong>int</strong> n = 0;</em> // With Java 8 there is no need
to explicit final <em>Runnable r = ()-&gt; {</em> // Using lambda</p>
<p><strong>int</strong> i = n;</p>
<p>// do something</p>
<p>};</p>
<p>This is legal as long as the value of the n variable is not changed.
If you try to change the variable, inside or outside the lambda, you
will get the following compilation error:</p>
<p>"local variables referenced from a lambda expression must be
<em>final</em> or <em>effectively final</em>".</p>
<p>For example:</p>
<p><strong>int</strong> n = 0;</p>
<p>Runnable r = ()-&gt; { <em>// Using lambda</em></p>
<p><strong>int</strong> i = n;</p>
<p>// do something</p>
<p>};</p>
<p><em>n++;</em> // Will generate an error.</p>
<p>If it is necessary to use a changing variable within a lambda, the
normal approach is to declare a <strong>final</strong> copy of the
variable and use the copy. For example</p>
<p><strong>int</strong> n = 0;</p>
<p><em><strong>final int</strong> k = n;</em> // With Java 8 there is no
need to explicit final <em>Runnable r = ()-&gt; {</em> // Using
lambda</p>
<p><strong>int</strong> i = k;</p>
<p>// do something</p>
<p>};</p>
<p><em>n++;</em> // Now will not generate an error</p>
<p><em>r.run();</em> // Will run with i = 0 because k was 0 when the
lambda was created</p>
<p>Naturally, the body of the lambda does not see the changes to the
original variable.</p>
<p>Note that Java does not support true closures. A Java lambda cannot
be created in a way that allows it to see</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 431</p>
<p><span id="changes_in_the_environment_in_wh"
class="anchor"></span>changes in the environment in which it was
instantiated. If you want to implement a closure that observes or makes
changes to its environment, you should simulate it using a regular
class. For example:</p>
<p>// Does not compile ...</p>
<p><strong>public</strong> IntUnaryOperator createAccumulator() {</p>
<p><strong>int</strong> value = 0;</p>
<p>IntUnaryOperator accumulate = (x)-&gt; { value += x;
<strong>return</strong> value; };</p>
<p><strong>return</strong> accumulate;</p>
<p>}</p>
<p>The above example will not compile for reasons discussed previously.
We can work around the compilation error as follows:</p>
<p>// Compiles, but is incorrect ...</p>
<p><strong>public class</strong> AccumulatorGenerator {</p>
<p>private int <strong>value = 0;</strong></p>
<p><strong>public</strong> IntUnaryOperator createAccumulator() {</p>
<p>IntUnaryOperator accumulate = (x)-&gt; { value += x;
<strong>return</strong> value; };</p>
<p><strong>return</strong> accumulate;</p>
<p>}</p>
<p>}</p>
<p>The problem is that this breaks the design contract for the
IntUnaryOperator interface which states that instances should be
functional and stateless. If such a closure is passed to built-in
functions that accept functional objects, it</p>
<p>is liable to cause crashes or erroneous behavior. Closures that
encapsulate mutable state should be implemented</p>
<p>as regular classes. For example.</p>
<p>// Correct ...</p>
<p><strong>public class</strong> Accumulator {</p>
<p>private int <strong>value = 0;</strong></p>
<p><strong>public int</strong> accumulate(<strong>int</strong> x) {</p>
<p>value += x;</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p>}</p>
<p>Section 73.7: Lambdas and memory utilization</p>
<p>Since Java lambdas are closures, they can "capture" the values of
variables in the enclosing lexical scope. While not</p>
<p>all lambdas capture anything -- simple lambdas like s -&gt;
s.length() capture nothing and are called <em>stateless</em> --capturing
lambdas require a temporary object to hold the captured variables. In
this code snippet, the lambda ()</p>
<p>-&gt; j is a capturing lambda, and may cause an object to be
allocated when it is evaluated:</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 1000000000;
i++) {</p>
<p><strong>int</strong> j = i;</p>
<p>doSomethingWithLambda(()-&gt; j);</p>
<p>}</p>
<p>}</p>
<p>Although it might not be immediately obvious since the
<strong>new</strong> keyword doesn't appear anywhere in the snippet,
this</p>
<p>code is liable to create 1,000,000,000 separate objects to represent
the instances of the ()-&gt; j lambda expression. However, it should
also be noted that future versions of Java1 may be able to optimize this
so that <em>at</em></p>
<p><em>runtime</em> the lambda instances were reused, or were
represented in some other way.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 432</p>
<p><span id="1___For_instance__Java_9_introdu" class="anchor"></span>1 -
For instance, Java 9 introduces an optional "link" phase to the Java
build sequence which will provide the opportunity for doing global
optimizations like this.</p>
<p>Section 73.8: Using lambda expression with your own</p>
<p>functional interface</p>
<p>Lambdas are meant to provide inline implementation code for single
method interfaces and the ability to pass</p>
<p>them around as we have been doing with normal variables. We call them
Functional Interface.</p>
<p>For example, writing a Runnable in anonymous class and starting a
Thread looks like:</p>
<p>//Old way</p>
<p><strong>new</strong> Thread(</p>
<p><strong>new</strong> Runnable(){</p>
<p>public void <strong>run(){</strong></p>
<p>System.out.println("run logic...");</p>
<p>}</p>
<p>}</p>
<p>).start();</p>
<p>//lambdas, from Java 8</p>
<p><strong>new</strong> Thread(</p>
<p>()-&gt; System.out.println("run logic...")</p>
<p>).start();</p>
<p>Now, in line with above, lets say you have some custom interface:</p>
<p><strong>interface</strong> TwoArgInterface {</p>
<p><strong>int</strong> operate(<strong>int</strong> a,
<strong>int</strong> b);</p>
<p>}</p>
<p>How do you use lambda to give implementation of this interface in
your code? Same as Runnable example shown</p>
<p>above. See the driver program below:</p>
<p><strong>public class</strong> CustomLambda {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>TwoArgInterface plusOperation = (a, b)-&gt; a + b;</p>
<p>TwoArgInterface divideOperation = (a,b)-&gt;{</p>
<p><strong>if</strong> (b==0) <strong>throw new</strong>
IllegalArgumentException("Divisor can not be 0");
<strong>return</strong> a/b;</p>
<p>};</p>
<p>System.out.println("Plus operation of 3 and 5 is: " +
plusOperation.operate(3, 5)); System.out.println("Divide operation 50 by
25 is: " + divideOperation.operate(50, 25));</p>
<p>}</p>
<p>}</p>
<p>Section 73.9: Traditional style to Lambda style</p>
<p>Traditional way</p>
<p><strong>interface</strong> MathOperation{</p>
<p><strong>boolean</strong> unaryOperation(<strong>int</strong>
num);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 433</p>
<p><span id="public_class_LambdaTry" class="anchor"></span>public class
<strong>LambdaTry {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>MathOperation isEven = <strong>new</strong> MathOperation() {</p>
<p>@Override</p>
<p><strong>public boolean</strong> unaryOperation(<strong>int</strong>
num) {</p>
<p><strong>return</strong> num%2 == 0;</p>
<p>}</p>
<p>};</p>
<p>System.out.println(isEven.unaryOperation(25));</p>
<p>System.out.println(isEven.unaryOperation(20));</p>
<p>}</p>
<p>}</p>
<p>Lambda style</p>
<p>1. Remove class name and functional interface body.</p>
<p>public class <strong>LambdaTry {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>MathOperation isEven = (<strong>int</strong> num)-&gt; {</p>
<p><strong>return</strong> num%2 == 0;</p>
<p>};</p>
<p>System.out.println(isEven.unaryOperation(25));</p>
<p>System.out.println(isEven.unaryOperation(20));</p>
<p>}</p>
<p>}</p>
<p>2. Optional type declaration</p>
<p>MathOperation isEven = (num)-&gt; {</p>
<p><strong>return</strong> num%2 == 0;</p>
<p>};</p>
<p>3. Optional parenthesis around parameter, if it is single
parameter</p>
<p>MathOperation isEven = num -&gt; {</p>
<p><strong>return</strong> num%2 == 0;</p>
<p>};</p>
<p>4. Optional curly braces, if there is only one line in function
body</p>
<p>5. Optional return keyword, if there is only one line in function
body</p>
<p>MathOperation isEven = num -&gt; num%2 == 0;</p>
<p>Section 73.10: `return` only returns from the lambda, not the</p>
<p>outer method</p>
<p>The <strong>return</strong> method only returns from the lambda, not
the outer method.</p>
<p>Beware that this is <em>different</em> from Scala and Kotlin!</p>
<p><strong>void</strong> threeTimes(IntConsumer r) {</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 3; i++)
{</p>
<p>r.accept(i);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 434</p>
<p><strong>void</strong> demo() {</p>
<p>threeTimes(i -&gt; {</p>
<p>System.out.println(i);</p>
<p><em><strong>return</strong>;</em> // Return from lambda to threeTimes
only!</p>
<p>});</p>
<p>}</p>
<p>This can lead to unexpected behavior when attempting to write own
language constructs, as in builtin constructs</p>
<p>such as <strong>for</strong> loops <strong>return</strong> behaves
differently:</p>
<p><strong>void</strong> demo2() {</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 3; i++)
{</p>
<p>System.out.println(i);</p>
<p><em><strong>return</strong>;</em> // Return from 'demo2' entirely</p>
<p>}</p>
<p>}</p>
<p>In Scala and Kotlin, demo and demo2 would both only print 0. But this
is <em>not</em> more consistent. The Java approach is consistent with
refactoring and the use of classes - the <strong>return</strong> in the
code at the top, and the code below behaves</p>
<p>the same:</p>
<p><strong>void</strong> demo3() {</p>
<p>threeTimes(<strong>new</strong> MyIntConsumer());</p>
<p>}</p>
<p><strong>class</strong> MyIntConsumer <strong>implements</strong>
IntConsumer {</p>
<p>public void <strong>accept(</strong>int <strong>i) {</strong></p>
<p>System.out.println(i);</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>Therefore, the Java <strong>return</strong> is more consistent with
class methods and refactoring, but less with the <strong>for</strong>
and <strong>while</strong></p>
<p>builtins, these remain special.</p>
<p>Because of this, the following two are equivalent in Java:</p>
<p>IntStream.range(1, 4)</p>
<p>.map(x -&gt; x * x)</p>
<p>.<strong>forEach</strong>(System.out::println);</p>
<p>IntStream.range(1, 4)</p>
<p>.map(x -&gt; { <strong>return</strong> x * x; })</p>
<p>.<strong>forEach</strong>(System.out::println);</p>
<p>Furthermore, the use of try-with-resources is safe in Java:</p>
<p><strong>class</strong> Resource <strong>implements</strong>
AutoCloseable {</p>
<p><strong>public void</strong> close() { System.out.println("close()");
}</p>
<p>}</p>
<p><strong>void</strong> executeAround(Consumer f) {</p>
<p><strong>try</strong> (Resource r = <strong>new</strong> Resource())
{</p>
<p>System.out.print("before ");</p>
<p>f.accept(r);</p>
<p>System.out.print("after ");</p>
<p>}</p>
<p>}</p>
<p><strong>void</strong> demo4() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 435</p>
<p><span id="executeAround_r" class="anchor"></span>executeAround(r
-&gt; {</p>
<p>System.out.print("accept() ");</p>
<p><em><strong>return</strong>;</em> // Does not return from demo4, but
frees the resource.</p>
<p>});</p>
<p>}</p>
<p>will print before accept() after close(). In the Scala and Kotlin
semantics, the try-with-resources would not be closed, but it would
print before accept() only.</p>
<p>Section 73.11: Lambdas and Execute-around Pattern</p>
<p>There are several good examples of using lambdas as a
FunctionalInterface in simple scenarios. A fairly common use case that
can be improved by lambdas is what is called the Execute-Around pattern.
In this pattern, you have a</p>
<p>set of standard setup/teardown code that is needed for multiple
scenarios surrounding use case specific code. A few common example of
this are file io, database io, try/catch blocks.</p>
<p><strong>interface</strong> DataProcessor {</p>
<p><strong>void</strong> process( Connection connection )
<strong>throws</strong> SQLException;;</p>
<p>}</p>
<p><strong>public void</strong> doProcessing( DataProcessor processor )
<strong>throws</strong> SQLException{</p>
<p><strong>try</strong> (Connection connection =
DBUtil.getDatabaseConnection();) { processor.process(connection);</p>
<p>connection.commit();</p>
<p>}</p>
<p>}</p>
<p>Then to call this method with a lambda it might look like:</p>
<p><strong>public static void</strong> updateMyDAO(MyVO vo)
<strong>throws</strong> DatabaseException {</p>
<p>doProcessing((Connection conn)-&gt; MyDAO.update(conn,
ObjectMapper.map(vo))); }</p>
<p>This is not limited to I/O operations. It can apply to any scenario
where similar setup/tear down tasks are applicable</p>
<p>with minor variations. The main benefit of this Pattern is code
re-use and enforcing DRY (Don't Repeat Yourself).</p>
<p>Section 73.12: Using lambda expressions &amp; predicates to get a</p>
<p>certain value(s) from a list</p>
<p>Starting with Java 8, you can use lambda expressions &amp;
predicates.</p>
<p>Example: Use a lambda expressions &amp; a predicate to get a certain
value from a list. In this example every person will be printed out with
the fact if they are 18 and older or not.</p>
<p>Person Class:</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>age;</strong></p>
<p><strong>public</strong> Person(String name, <strong>int</strong> age)
{</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.age = age;</p>
<p>}</p>
<p><strong>public int</strong> getAge() { <strong>return</strong> age;
}</p>
<p><strong>public</strong> String getName() { <strong>return</strong>
name; }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 436</p>
<p>}</p>
<p>The built-in interface Predicate from the
java.util.function.Predicate packages is a functional interface with a
<strong>boolean</strong> test(T t) method.</p>
<p>Example Usage:</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.function.Predicate;</p>
<p><strong>public class</strong> LambdaExample {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List personList = <strong>new</strong> ArrayList();</p>
<p>personList.add(<strong>new</strong> Person("Jeroen", 20));</p>
<p>personList.add(<strong>new</strong> Person("Jack", 5));</p>
<p>personList.add(<strong>new</strong> Person("Lisa", 19));</p>
<p>print(personList, p -&gt; p.getAge() &gt;= 18);</p>
<p>}</p>
<p><strong>private static void</strong> print(List personList, Predicate
checker) {</p>
<p><strong>for</strong> (Person person : personList) {</p>
<p><strong>if</strong> (checker.test(person)) {</p>
<p>System.out.print(person + " matches your expression.");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println(person + " doesn't match your expression.");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The print(personList, p -&gt; p.getAge() &gt;= 18); method takes a
lambda expression (because the Predicate is</p>
<p>used a parameter) where you can define the expression that is needed.
The checker's test method checks if this expression is correct or not:
checker.test(person).</p>
<p>You can easily change this to something else, for example to
print(personList, p -&gt; p.getName().startsWith("J"));. This will check
if the person's name starts with a "J".</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 437</p>
<p><span id="Chapter_74__Basic_Control_Struct_1"
class="anchor"></span>Chapter 74: Basic Control Structures</p>
<p>Section 74.1: Switch statement</p>
<p>The <strong>switch</strong> statement is Java's multi-way branch
statement. It is used to take the place of long if-<strong>else
if</strong>-<strong>else</strong> chains, and make them more readable.
However, unlike if statements, one may not use inequalities; each
value</p>
<p>must be concretely defined.</p>
<p>There are three critical components to the <strong>switch</strong>
statement:</p>
<p><strong>case</strong>: This is the value that is evaluated for
equivalence with the argument to the <strong>switch</strong> statement.
<strong>default</strong> : This is an optional, catch-all expression,
should none of the <strong>case</strong> statements evaluate to
<strong>true</strong>.</p>
<p>Abrupt completion of the <strong>case</strong> statement; usually
<strong>break</strong>: This is required to prevent the undesired
evaluation of further <strong>case</strong> statements.</p>
<p>With the exception of <strong>continue</strong>, it is possible to
use any statement which would cause the <a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.1">abrupt
completion of a</a></p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.1">statement.
This includes:</a></p>
<p>break</p>
<p>return</p>
<p>throw</p>
<p>In the example below, a typical <strong>switch</strong> statement is
written with four possible cases, including
<strong>default</strong>.</p>
<p>Scanner scan = <strong>new</strong> Scanner(System.in);</p>
<p><strong>int</strong> i = scan.nextInt();</p>
<p>switch <strong>(i) {</strong></p>
<p>case <strong>0:</strong></p>
<p>System.out.println("i is zero");</p>
<p>break<strong>;</strong></p>
<p>case <strong>1:</strong></p>
<p>System.out.println("i is one");</p>
<p>break<strong>;</strong></p>
<p>case <strong>2:</strong></p>
<p>System.out.println("i is two");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p>System.out.println("i is less than zero or greater than two");</p>
<p>}</p>
<p>By omitting <strong>break</strong> or any statement which would an
abrupt completion, we can leverage what are known as "fall-</p>
<p>through" cases, which evaluate against several values. This can be
used to create ranges for a value to be successful against, but is still
not as flexible as inequalities.</p>
<p>Scanner scan = <strong>new</strong> Scanner(System.in);</p>
<p><strong>int</strong> foo = scan.nextInt();</p>
<p><strong>switch</strong>(foo) {</p>
<p>case <strong>1:</strong></p>
<p>System.out.println("I'm equal or greater than one");</p>
<p>case <strong>2:</strong></p>
<p>case <strong>3:</strong></p>
<p>System.out.println("I'm one, two, or three");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p>System.out.println("I'm not either one, two, or three");</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 438</p>
<p><span id="In_case_of_foo____1_the_output_w" class="anchor"></span>In
case of foo == 1 the output will be:</p>
<p>I'm equal or greater than one</p>
<p>I'm one, two, or three</p>
<p>In case of foo == 3 the output will be:</p>
<p>I'm one, two, or three</p>
<p>Version ≥ Java SE 5</p>
<p>The switch statement can also be used with
<strong>enum</strong>s.</p>
<p><strong>enum</strong> Option {</p>
<p>BLUE_PILL,</p>
<p>RED_PILL</p>
<p>}</p>
<p><strong>public void</strong> takeOne(Option option) {</p>
<p><strong>switch</strong>(option) {</p>
<p><strong>case</strong> BLUE_PILL:</p>
<p>System.out.println("Story ends, wake up, believe whatever you
want."); <strong>break</strong>;</p>
<p><strong>case</strong> RED_PILL:</p>
<p>System.out.println("I show you how deep the rabbit hole goes.");
<strong>break</strong>;</p>
<p>}</p>
<p>}</p>
<p>Version ≥ Java SE 7</p>
<p>The <strong>switch</strong> statement can also be used with
Strings.</p>
<p><strong>public void</strong> rhymingGame(String phrase) {</p>
<p><strong>switch</strong> (phrase) {</p>
<p><strong>case</strong> "apples and pears":</p>
<p>System.out.println("Stairs");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "lorry":</p>
<p>System.out.println("truck");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p>System.out.println("Don't know any more");</p>
<p>}</p>
<p>}</p>
<p>Section 74.2: do...while Loop</p>
<p>The <strong>do</strong>...<strong>while</strong> loop differs from
other loops in that it is guaranteed to execute <strong>at least
once</strong>. It is also called the</p>
<p>"post-test loop" structure because the conditional statement is
performed after the main loop body.</p>
<p><strong>int</strong> i = 0;</p>
<p>do <strong>{</strong></p>
<p>i++;</p>
<p>System.out.println(i);</p>
<p><em>} <strong>while</strong> (i &lt; 100);</em> // Condition gets
checked AFTER the content of the loop executes.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 439</p>
<p><span id="In_this_example__the_loop_will_r" class="anchor"></span>In
this example, the loop will run until the number 100 is printed (even
though the condition is i &lt; 100 and not i &lt;= 100), because the
loop condition is evaluated <em>after</em> the loop executes.</p>
<p>With the guarantee of at least one execution, it is possible to
declare variables outside of the loop and initialize them inside.</p>
<p>String theWord;</p>
<p>Scanner scan = <strong>new</strong> Scanner(System.in);</p>
<p>do <strong>{</strong></p>
<p>theWord = scan.nextLine();</p>
<p>} <strong>while</strong> (!theWord.equals("Bird"));</p>
<p>System.out.println(theWord);</p>
<p>In this context, theWord is defined outside of the loop, but since
it's guaranteed to have a value based on its natural</p>
<p>flow, theWord will be initialized.</p>
<p>Section 74.3: For Each</p>
<p>Version ≥ Java SE 5</p>
<p>With Java 5 and up, one can use for-each loops, also known as
enhanced for-loops:</p>
<p>List strings = <strong>new</strong> ArrayList();</p>
<p>strings.add("This");</p>
<p>strings.add("is");</p>
<p>strings.add("a for-each loop");</p>
<p>(String string : strings) { System.out.println(string); }</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html">For
each loops can be used to iterate over Arrays and implementations of the
Iterable</a> interface, the later includes</p>
<p>Collections classes, such as List or Set.</p>
<p>The loop variable can be of any type that is assignable from the
source type.</p>
<p>The loop variable for a enhanced for loop for Iterable or T[] can be
of type S, if</p>
<p><strong>T</strong> extends <strong>S</strong></p>
<p>both T and S are primitive types and assignable without a cast S is a
primitive type and T can be converted to a type assignable to S after
unboxing conversion.</p>
<p>T is a primitive type and can be converted to S by autoboxing
conversion.</p>
<p>Examples:</p>
<p>T elements = ...</p>
<p><strong>for</strong> (S s : elements) {</p>
<p>}</p>
<p>T S Compiles</p>
<p>int[] long yes</p>
<p>long[] int no</p>
<p>Iterable long yes</p>
<p>Iterable CharSequence yes</p>
<p>Iterable String no</p>
<p>int[] Long no</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 440</p>
<p><span id="int" class="anchor"></span>int[] Integer yes</p>
<p>Section 74.4: Continue Statement in Java</p>
<p>The continue statement is used to skip the remaining steps in the
current iteration and start with the next loop iteration. The control
goes from the <strong>continue</strong> statement to the step value
(increment or decrement), if any.</p>
<p>String[] programmers = {"Adrian", "Paul", "John", "Harry"};</p>
<p>//john is not printed out</p>
<p><strong>for</strong> (String name : programmers) {</p>
<p><strong>if</strong> (name.equals("John"))</p>
<p>continue<strong>;</strong></p>
<p>System.out.println(name);</p>
<p>}</p>
<p>The <strong>continue</strong> statement can also make the control of
the program shift to the step value (if any) of a named loop:</p>
<p><em>Outer:</em> // The name of the outermost loop is kept here as
'Outer' <em><strong>for</strong>(<strong>int</strong> i = 0; i &lt; 5;
)</em></p>
<p>{</p>
<p><strong>for</strong>(<strong>int</strong> j = 0; j &lt; 5; j++)</p>
<p>{</p>
<p>continue <strong>Outer;</strong></p>
<p>}</p>
<p>}</p>
<p>Section 74.5: If / Else If / Else Control</p>
<p><strong>if</strong> (i &lt; 2) {</p>
<p>System.out.println("i is less than 2");</p>
<p>} <strong>else if</strong> (i &gt; 2) {</p>
<p>System.out.println("i is more than 2");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("i is not less than 2, and not more than 2");</p>
<p>}</p>
<p>The if block will only run when i is 1 or less.</p>
<p>The <strong>else if</strong> condition is checked only if all the
conditions before it (in previous <strong>else if</strong> constructs,
and the parent</p>
<p>if constructs) have been tested to <strong>false</strong>. In this
example, the <strong>else if</strong> condition will only be checked if
i is greater than or equal to 2.</p>
<p>If its result is <strong>true</strong>, its block is run, and any
<strong>else if</strong> and <strong>else</strong> constructs after it
will be skipped.</p>
<p>If none of the if and <strong>else if</strong> conditions have been
tested to <strong>true</strong>, the <strong>else</strong> block at the
end will be run.</p>
<p>Section 74.6: For Loops</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100; i++)
{</p>
<p>System.out.println(i);</p>
<p>}</p>
<p>The three components of the <strong>for</strong> loop (separated by
;) are variable declaration/initialization (here <strong>int</strong> i
= 0), the</p>
<p>condition (here i &lt; 100), and the increment statement (here i++).
The variable declaration is done once as if placed just inside the { on
the first run. Then the condition is checked, if it is
<strong>true</strong> the body of the loop will execute, if it is</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 441</p>
<p><span id="false_the_loop_will_stop__Assumi"
class="anchor"></span><strong>false</strong> the loop will stop.
Assuming the loop continues, the body will execute and finally when the
} is reached the increment statement will execute just before the
condition is checked again.</p>
<p>The curly braces are optional (you can one line with a semicolon) if
the loop contains just one statement. But, it's always recommended to
use braces to avoid misunderstandings and bugs.</p>
<p>The <strong>for</strong> loop components are optional. If your
business logic contains one of these parts, you can omit the
corresponding component from your <strong>for</strong> loop.</p>
<p><em><strong>int</strong> i = obj.getLastestValue();</em> // i value
is fetched from a method</p>
<p><em><strong>for</strong> (; i &lt; 100; i++) {</em> // here
initialization is not done</p>
<p>System.out.println(i);</p>
<p>}</p>
<p>The <strong>for</strong> (;;) { function-body } structure is equal to
a <strong>while</strong> (<strong>true</strong>) loop.</p>
<p>Nested <strong>For</strong> Loops</p>
<p>Any looping statement having another loop statement inside called
nested loop. The same way for looping having more inner loop is called
'nested for loop'.</p>
<p><strong>for</strong>(;;){</p>
<p>//Outer Loop Statements</p>
<p><strong>for</strong>(;;){</p>
<p>//Inner Loop Statements</p>
<p>}</p>
<p>//Outer Loop Statements</p>
<p>}</p>
<p>Nested for loop can be demonstrated to print triangle shaped
numbers.</p>
<p><strong>for</strong>(<strong>int</strong> i=9;i&gt;0;i--){<em>//Outer
Loop</em></p>
<p>System.out.println();</p>
<p><strong>for</strong>(<strong>int</strong> k=i;k&gt;0;k--){<em>//Inner
Loop -1</em></p>
<p>System.out.print(" ");</p>
<p>}</p>
<p><strong>for</strong>(<strong>int</strong>
j=i;j&lt;=9;j++){<em>//Inner Loop -2</em></p>
<p>System.out.print(" "+j);</p>
<p>}</p>
<p>}</p>
<p>Section 74.7: Ternary Operator</p>
<p>Sometimes you have to check for a condition and set the value of a
variable.</p>
<p>For ex.</p>
<p>String name;</p>
<p><strong>if</strong> (A &gt; B) {</p>
<p>name = "Billy";</p>
<p>} <strong>else</strong> {</p>
<p>name = "Jimmy";</p>
<p>}</p>
<p>This can be easily written in one line as</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 442</p>
<p><span id="String_name___A___B____Billy" class="anchor"></span>String
name = A &gt; B ? "Billy" : "Jimmy";</p>
<p>The value of the variable is set to the value immediately after the
condition, if the condition is true. If the condition</p>
<p>is false, the second value will be given to the variable.</p>
<p>Section 74.8: Try ... Catch ... Finally</p>
<p>The <strong>try</strong> { ... } <strong>catch</strong> ( ... ) { ...
} control structure is used for handling Exceptions.</p>
<p>String age_input = "abc";</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> age = Integer.parseInt(age_input);</p>
<p><strong>if</strong> (age &gt;= 18) {</p>
<p>System.out.println("You can vote!");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Sorry, you can't vote yet.");</p>
<p>}</p>
<p>} <strong>catch</strong> (NumberFormatException ex) {</p>
<p>System.err.println("Invalid input. '" + age_input + "' is not a valid
integer.");</p>
<p>}</p>
<p>This would print:</p>
<p>Invalid input. 'abc' is not a valid integer.</p>
<p>A <strong>finally</strong> clause can be added after the
<strong>catch</strong>. The <strong>finally</strong> clause would always
be executed, regardless of</p>
<p>whether an exception was thrown.</p>
<p><strong>try</strong> { ... } <strong>catch</strong> ( ... ) { ... }
<strong>finally</strong> { ... }</p>
<p>String age_input = "abc";</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> age = Integer.parseInt(age_input);</p>
<p><strong>if</strong> (age &gt;= 18) {</p>
<p>System.out.println("You can vote!");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Sorry, you can't vote yet.");</p>
<p>}</p>
<p>} <strong>catch</strong> (NumberFormatException ex) {</p>
<p>System.err.println("Invalid input. '" + age_input + "' is not a valid
integer.");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>System.out.println("This code will always be run, even if an
exception is thrown");</p>
<p>}</p>
<p>This would print:</p>
<p>Invalid input. 'abc' is not a valid integer.</p>
<p>This code will always be run, even if an exception is thrown</p>
<p>Section 74.9: Break</p>
<p>The <strong>break</strong> statement ends a loop (like
<strong>for</strong>, <strong>while</strong>) or the evaluation of a
switch statement.</p>
<p>Loop:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 443</p>
<p><span id="while_true"
class="anchor"></span>while<strong>(</strong>true<strong>)
{</strong></p>
<p><strong>if</strong>(someCondition == 5) {</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>The loop in the example would run forever. But when someCondition
equals 5 at some point of execution, then the</p>
<p>loop ends.</p>
<p>If multiple loops are cascaded, only the most inner loop ends using
<strong>break</strong>.</p>
<p>Section 74.10: While Loops</p>
<p><strong>int</strong> i = 0;</p>
<p><em><strong>while</strong> (i &lt; 100) {</em> // condition gets
checked BEFORE the loop body executes</p>
<p>System.out.println(i);</p>
<p>i++;</p>
<p>}</p>
<p>A <strong>while</strong> loop runs as long as the condition inside
the parentheses is <strong>true</strong>. This is also called the
"pre-test loop"</p>
<p>structure because the conditional statement must be met before the
main loop body is performed every time.</p>
<p>The curly braces are optional if the loop contains just one
statement, but some coding style conventions prefers having the braces
regardless.</p>
<p>Section 74.11: If / Else</p>
<p><strong>int</strong> i = 2;</p>
<p><strong>if</strong> (i &lt; 2) {</p>
<p>System.out.println("i is less than 2");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("i is greater than 2");</p>
<p>}</p>
<p>An if statement executes code conditionally depending on the result
of the condition in parentheses. When condition in parentheses is true
it will enter to the block of if statement which is defined by curly
braces like { and }.</p>
<p>opening bracket till the closing bracket is the scope of the if
statement.</p>
<p>The <strong>else</strong> block is optional and can be omitted. It
runs if the if statement is <strong>false</strong> and does not run if
the if</p>
<p>statement is true Because in that case if statement executes.</p>
<p>See also: Ternary If</p>
<p>Section 74.12: Nested break / continue</p>
<p>It's possible to <strong>break</strong> / <strong>continue</strong>
to an outer loop by using label statements:</p>
<p>outerloop:</p>
<p><strong>for</strong>(...) {</p>
<p>innerloop:</p>
<p><strong>for</strong>(...) {</p>
<p><strong>if</strong>(condition1)</p>
<p><strong>break</strong> outerloop;</p>
<p><strong>if</strong>(condition2)</p>
<p><em><strong>continue</strong> innerloop;</em> // equivalent to:
continue;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 444</p>
<p>}</p>
<p>}</p>
<p>There is no other use for labels in Java.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 445</p>
<p><span id="Chapter_75__Bu_eredWriter_1" class="anchor"></span>Chapter
75: BueredWriter</p>
<p>Section 75.1: Write a line of text to File</p>
<p>This code writes the string to a file. It is important to close the
writer, so this is done in a <strong>finally</strong> block.</p>
<p><strong>public void</strong> writeLineToFile(String str)
<strong>throws</strong> IOException {</p>
<p>File file = <strong>new</strong> File("file.txt");</p>
<p>BufferedWriter bw = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>bw = <strong>new</strong> BufferedWriter(<strong>new</strong>
FileWriter(file));</p>
<p>bw.write(str);</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (bw != <strong>null</strong>) {</p>
<p>bw.close();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Also note that write(String s) does not place newline character after
string has been written. To put it use newLine() method.</p>
<p>Version ≥ Java SE 7</p>
<p>Java 7 adds the <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html">java.nio.file</a>
package, and try-with-resources:</p>
<p><strong>public void</strong> writeLineToFile(String str)
<strong>throws</strong> IOException {</p>
<p>Path path = Paths.get("file.txt");</p>
<p><strong>try</strong> (BufferedWriter bw =
Files.newBufferedWriter(path)) { bw.write(str);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 446</p>
<p><span id="Chapter_76__New_File_I_O_1" class="anchor"></span>Chapter
76: New File I/O</p>
<p>Section 76.1: Creating paths</p>
<p>The Path class is used to programmaticaly represent a path in the
file system (and can therefore point to files as well as directories,
even to non-existent ones)</p>
<p>A path can be obtained using the helper class Paths:</p>
<p>Path p1 = Paths.get("/var/www");</p>
<p>Path p2 = Paths.get(URI.create("file:///home/testuser/File.txt"));
Path p3 =
Paths.get("C:<strong>\\</strong>Users<strong>\\</strong>DentAr<strong>\\</strong>Documents<strong>\\</strong>HHGTDG.odt");
Path p4 = Paths.get("/home", "arthur", "files", "diary.tex");</p>
<p>Section 76.2: Manipulating paths</p>
<p>Joining Two Paths</p>
<p>Paths can be joined using the resolve() method. The path passed has
to be a partial path, which is a path that</p>
<p>doesn't include the root element.</p>
<p>Path p5 = Paths.get("/home/");</p>
<p>Path p6 = Paths.get("arthur/files");</p>
<p>Path joined = p5.resolve(p6);</p>
<p>Path otherJoined = p5.resolve("ford/files");</p>
<p>joined.toString() == "/home/arthur/files"</p>
<p>otherJoined.toString() == "/home/ford/files"</p>
<p>Normalizing a path</p>
<p>Paths may contain the elements . (which points to the directory
you're currently in) and ..(which points to the</p>
<p>parent directory).</p>
<p>When used in a path, . can be removed at any time without changing
the path's destination, and .. can be</p>
<p>removed together with the preceding element.</p>
<p>With the Paths API, this is done using the .normalize() method:</p>
<p>Path p7 = Paths.get("/home/./arthur/../ford/files"); Path p8 =
Paths.get("C:<strong>\\</strong>Users<strong>\\</strong>.<strong>\\</strong>..<strong>\\</strong>Program
Files");</p>
<p>p7.normalize().toString() == "/home/ford/files"</p>
<p>p8.normalize().toString() == "C:<strong>\\</strong>Program Files"</p>
<p>Section 76.3: Retrieving information about a path</p>
<p>Information about a path can be get using the methods of a Path
object:</p>
<p>toString() returns the string representation of the path</p>
<p><em>Path p1 = Paths.get("/var/www");</em> // p1.toString() returns
"/var/www"</p>
<p>getFileName() returns the file name (or, more specifically, the last
element of the path</p>
<p>Path p1 = Paths.get("/var/www"); <em>// p1.getFileName() returns
"www"</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 447</p>
<p><span id="Path_p3___Paths_get__C___Users" class="anchor"></span>Path
p3 =
Paths.get("C:<strong>\\</strong>Users<strong>\\</strong>DentAr<strong>\\</strong>Documents<strong>\\</strong>HHGTDG.odt");
<em>// p3.getFileName() returns "HHGTDG.odt"</em></p>
<p>getNameCount() returns the number of elements that form the path</p>
<p>Path p1 = Paths.get("/var/www"); <em>// p1.getNameCount() returns
2</em></p>
<p>getName(<strong>int</strong> index) returns the element at the given
index</p>
<p><em>Path p1 = Paths.get("/var/www");</em> // p1.getName(0) returns
"var", p1.getName(1) returns "www"</p>
<p>getParent() returns the path of the parent directory</p>
<p><em>Path p1 = Paths.get("/var/www");</em> //
p1.getParent().toString() returns "/var"</p>
<p>getRoot() returns the root of the path</p>
<p>Path p1 = Paths.get("/var/www"); <em>// p1.getRoot().toString()
returns "/"</em> Path p3 =
Paths.get("C:<strong>\\</strong>Users<strong>\\</strong>DentAr<strong>\\</strong>Documents<strong>\\</strong>HHGTDG.odt");
<em>// p3.getRoot().toString() returns "C:\\"</em></p>
<p>Section 76.4: Retrieving information using the filesystem</p>
<p>To interact with the filesystem you use the methods of the class
Files.</p>
<p>Checking existence</p>
<p>To check the existence of the file or directory a path points to, you
use the following methods:</p>
<p>Files.exists(Path path)</p>
<p>and</p>
<p>Files.notExists(Path path)</p>
<p>!Files.exists(path) does not neccesarily have to be equal to
Files.notExists(path), because there are three possible scenarios:</p>
<p>A file's or directory's existence is verified (exists returns
<strong>true</strong> and notExists returns <strong>false</strong> in
this case)</p>
<p>A file's or directory's nonexistence is verfied (exists returns
<strong>false</strong> and notExists returns <strong>true</strong>)</p>
<p>Neither the existence nor the nonexistence of a file or a directory
can be verified (for example due to access restrictions): Both exists
and nonExists return false.</p>
<p>Checking whether a path points to a file or a directory</p>
<p>This is done using Files.isDirectory(Path path) and
Files.isRegularFile(Path path)</p>
<p>Path p1 = Paths.get("/var/www");</p>
<p>Path p2 = Paths.get("/home/testuser/File.txt");</p>
<p>Files.isDirectory(p1) == <strong>true</strong></p>
<p>Files.isRegularFile(p1) == <strong>false</strong></p>
<p>Files.isDirectory(p2) == <strong>false</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 448</p>
<p><span id="Files_isRegularFile_p2_____true"
class="anchor"></span>Files.isRegularFile(p2) ==
<strong>true</strong></p>
<p>Getting properties</p>
<p>This can be done using the following methods:</p>
<p>Files.isReadable(Path path)</p>
<p>Files.isWritable(Path path)</p>
<p>Files.isExecutable(Path path)</p>
<p>Files.isHidden(Path path)</p>
<p>Files.isSymbolicLink(Path path)</p>
<p>Getting MIME type</p>
<p>Files.probeContentType(Path path)</p>
<p>This tries to get the MIME type of a file. It returns a MIME type
String, like this:</p>
<p>text/plain for text files</p>
<p>text/html for HTML pages</p>
<p>application/pdf for PDF files</p>
<p>image/png for PNG files</p>
<p>Section 76.5: Reading files</p>
<p>Files can be read byte- and line-wise using the Files class.</p>
<p>Path p2 = Paths.get(URI.create("file:///home/testuser/File.txt"));
<strong>byte</strong>[] content = Files.readAllBytes(p2);</p>
<p>List linesOfContent = Files.readAllLines(p2);</p>
<p>Files.readAllLines() optionally takes a charset as parameter (default
is StandardCharsets.UTF_8):</p>
<p>List linesOfContent = Files.readAllLines(p2,
StandardCharsets.ISO_8859_1);</p>
<p>Section 76.6: Writing files</p>
<p>Files can be written bite- and line-wise using the Files class</p>
<p>Path p2 = Paths.get("/home/testuser/File.txt");</p>
<p>List lines = Arrays.asList(</p>
<p><strong>new</strong> String[]{"First line", "Second line", "Third
line"});</p>
<p>Files.write(p2, lines);</p>
<p>Files.write(Path path, <strong>byte</strong>[] bytes)</p>
<p>Existing files wile be overridden, non-existing files will be
created.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 449</p>
<p><span id="Chapter_77__File_I_O_1" class="anchor"></span>Chapter 77:
File I/O</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html">Java
I/O (Input and Output) is used to process the input and produce the
output. Java uses the concept of stream to</a></p>
<p>make I/O operation fast. The java.io package contains all the classes
required for input and output operations.</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">Handling
files</a> is also done in java by Java I/O API.</p>
<p>Section 77.1: Migrating from java.io.File to Java 7 NIO</p>
<p>(java.nio.file.Path)</p>
<p>These examples assume that you already know what Java 7's NIO is in
general, and you are used to writing code using java.io.File. Use these
examples as a means to quickly find more NIO-centric documentation for
migrating.</p>
<p>There is much more to Java 7's NIO such as <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html">memory-mapped
files</a> <a
href="http://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html">or
opening a ZIP or JAR file using FileSystem.</a> These examples will only
cover a limited number of basic use cases.</p>
<p>As a basic rule, if you are used to perform a file system read/write
operation using a <a
href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html">java.io.File
instance</a></p>
<p>method, you will find it as a static method within <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html">java.nio.file.Files</a>.</p>
<p>Point to a path</p>
<p>// -&gt; IO</p>
<p>File file = <strong>new</strong> File("io.txt");</p>
<p>// -&gt; NIO</p>
<p>Path path = Paths.get("nio.txt");</p>
<p>Paths relative to another path</p>
<p>// Forward slashes can be used in place of backslashes even on a
Windows operating system // -&gt; IO</p>
<p>File folder = <strong>new</strong> File("C:/");</p>
<p>File fileInFolder = <strong>new</strong> File(folder, "io.txt");</p>
<p>// -&gt; NIO</p>
<p>Path directory = Paths.get("C:/");</p>
<p>Path pathInDirectory = directory.resolve("nio.txt");</p>
<p>Converting File from/to Path for use with libraries</p>
<p>// -&gt; IO to NIO</p>
<p>Path pathFromFile = <strong>new</strong> File("io.txt").toPath();</p>
<p>// -&gt; NIO to IO</p>
<p>File fileFromPath = Paths.get("nio.txt").toFile();</p>
<p>Check if the file exists and delete it if it does</p>
<p>// -&gt; IO</p>
<p><strong>if</strong> (file.exists()) {</p>
<p><strong>boolean</strong> deleted = file.delete();</p>
<p><strong>if</strong> (!deleted) {</p>
<p><strong>throw new</strong> IOException("Unable to delete file");</p>
<p>}</p>
<p>}</p>
<p>// -&gt; NIO</p>
<p>Files.deleteIfExists(path);</p>
<p>Write to a file via an OutputStream</p>
<p>There are several ways to write and read from a file using NIO for
different performance and memory constraints,</p>
<p><a
href="http://stackoverflow.com/questions/7366266/best-way-to-write-string-to-file-using-java-nio">readability
and use cases, such as FileChannel</a><a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#write(java.nio.file.Path,%20byte%5B%5D,%20java.nio.file.OpenOption...)">,
Files.write(Path path, <strong>byte</strong>\[\] bytes,
OpenOption...</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 450</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#write(java.nio.file.Path,%20byte%5B%5D,%20java.nio.file.OpenOption...)">options)</a>...
In this example, only OutputStream is covered, but you are strongly
encouraged to learn about memory-mapped files and the various static
methods available in java.nio.file.Files.</p>
<p>List lines = Arrays.asList(</p>
<p>String.valueOf(Calendar.getInstance().getTimeInMillis()), "line
one",</p>
<p>"line two");</p>
<p>// -&gt; IO</p>
<p><strong>if</strong> (file.exists()) {</p>
<p>// Note: Not atomic</p>
<p><strong>throw new</strong> IOException("File already exists");</p>
<p>}</p>
<p><strong>try</strong> (FileOutputStream outputStream =
<strong>new</strong> FileOutputStream(file)) {</p>
<p><strong>for</strong> (String line : lines) {</p>
<p>outputStream.write((line +
System.lineSeparator()).getBytes(StandardCharsets.UTF_8));</p>
<p>}</p>
<p>}</p>
<p>// -&gt; NIO</p>
<p><strong>try</strong> (OutputStream outputStream =
Files.newOutputStream(path, StandardOpenOption.CREATE_NEW)) {</p>
<p><strong>for</strong> (String line : lines) {</p>
<p>outputStream.write((line +
System.lineSeparator()).getBytes(StandardCharsets.UTF_8));</p>
<p>}</p>
<p>}</p>
<p>Iterating on each file within a folder</p>
<p>// -&gt; IO</p>
<p><strong>for</strong> (File selectedFile : folder.listFiles()) {</p>
<p>// Note: Depending on the number of files in the directory
folder.listFiles() may take a long</p>
<p>time to return</p>
<p>System.out.println((selectedFile.isDirectory() ? "d" : "f") + " "
+</p>
<p>selectedFile.getAbsolutePath());</p>
<p>}</p>
<p>// -&gt; NIO</p>
<p>Files.walkFileTree(directory,
EnumSet.noneOf(FileVisitOption.<strong>class</strong>), 1,
<strong>new</strong> SimpleFileVisitor() {</p>
<p>@Override</p>
<p><strong>public</strong> FileVisitResult preVisitDirectory(Path
selectedPath, BasicFileAttributes attrs) <strong>throws</strong></p>
<p>IOException {</p>
<p>System.out.println("d " + selectedPath.toAbsolutePath());
<strong>return</strong> FileVisitResult.<strong>CONTINUE</strong>;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> FileVisitResult visitFile(Path selectedPath,
BasicFileAttributes attrs) <strong>throws</strong></p>
<p>IOException {</p>
<p>System.out.println("f " + selectedPath.toAbsolutePath());
<strong>return</strong> FileVisitResult.<strong>CONTINUE</strong>;</p>
<p>}</p>
<p>});</p>
<p>Recursive folder iteration</p>
<p>// -&gt; IO</p>
<p>recurseFolder(folder);</p>
<p>// -&gt; NIO</p>
<p>// Note: Symbolic links are NOT followed unless explicitly passed as
an argument to Files.walkFileTree</p>
<p>Files.walkFileTree(directory, <strong>new</strong>
SimpleFileVisitor() {</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 451</p>
<p><span id="public_FileVisitResult_preVisitD"
class="anchor"></span><strong>public</strong> FileVisitResult
preVisitDirectory(Path dir, BasicFileAttributes attrs)
<strong>throws</strong></p>
<p>IOException {</p>
<p>System.out.println("d " + selectedPath.toAbsolutePath());
<strong>return</strong> FileVisitResult.<strong>CONTINUE</strong>;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> FileVisitResult visitFile(Path selectedPath,
BasicFileAttributes attrs) <strong>throws</strong></p>
<p>IOException {</p>
<p>System.out.println("f " + selectedPath.toAbsolutePath());
<strong>return</strong> FileVisitResult.<strong>CONTINUE</strong>;</p>
<p>}</p>
<p>});</p>
<p><strong>private static void</strong> recurseFolder(File folder) {</p>
<p><strong>for</strong> (File selectedFile : folder.listFiles()) {</p>
<p>System.out.println((selectedFile.isDirectory() ? "d" : "f") + " "
+</p>
<p>selectedFile.getAbsolutePath());</p>
<p><strong>if</strong> (selectedFile.isDirectory()) {</p>
<p>// Note: Symbolic links are followed</p>
<p>recurseFolder(selectedFile);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.2: Reading an image from a file</p>
<p><strong>import</strong> java.awt.Image;</p>
<p><strong>import</strong> javax.imageio.ImageIO;</p>
<p>...</p>
<p>try <strong>{</strong></p>
<p>Image img = ImageIO.read(<strong>new</strong>
File("~/Desktop/cat.png"));</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 77.3: File Read/Write Using</p>
<p>FileInputStream/FileOutputStream</p>
<p>Write to a file test.txt:</p>
<p>String filepath ="C:<strong>\\</strong>test.txt";</p>
<p>FileOutputStream fos = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>fos = <strong>new</strong> FileOutputStream(filepath);</p>
<p><strong>byte</strong>[] buffer = "This will be written in
test.txt".getBytes();</p>
<p>fos.write(buffer, 0, buffer.length);</p>
<p>fos.close();</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong> finally<strong>{</strong></p>
<p><strong>if</strong>(fos != <strong>null</strong>)</p>
<p>fos.close();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 452</p>
<p><span id="Read_from_file_test_txt" class="anchor"></span>Read from
file test.txt:</p>
<p>String filepath ="C:<strong>\\</strong>test.txt";</p>
<p>FileInputStream fis = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>fis = <strong>new</strong> FileInputStream(filepath);</p>
<p><strong>int</strong> length = (<strong>int</strong>)
<strong>new</strong> File(filepath).length();</p>
<p><strong>byte</strong>[] buffer = <strong>new
byte</strong>[length];</p>
<p>fis.read(buffer, 0, length);</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong> finally<strong>{</strong></p>
<p><strong>if</strong>(fis != <strong>null</strong>)</p>
<p>fis.close();</p>
<p>}</p>
<p>Note, that since Java 1.7 the try-with-resources statement was
introduced what made implementation of</p>
<p>reading\writing operation much simpler:</p>
<p>Write to a file test.txt:</p>
<p>String filepath ="C:<strong>\\</strong>test.txt";</p>
<p><strong>try</strong> (FileOutputStream fos = <strong>new</strong>
FileOutputStream(filepath)){</p>
<p><strong>byte</strong>[] buffer = "This will be written in
test.txt".getBytes();</p>
<p>fos.write(buffer, 0, buffer.length);</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Read from file test.txt:</p>
<p>String filepath ="C:<strong>\\</strong>test.txt";</p>
<p><strong>try</strong> (FileInputStream fis = <strong>new</strong>
FileInputStream(filepath)){</p>
<p><strong>int</strong> length = (<strong>int</strong>)
<strong>new</strong> File(filepath).length();</p>
<p><strong>byte</strong>[] buffer = <strong>new
byte</strong>[length];</p>
<p>fis.read(buffer, 0, length);</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 77.4: Reading all bytes to a byte[]</p>
<p>Java 7 introduced the very useful <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html">Files
class</a></p>
<p>Version ≥ Java SE 7</p>
<p><strong>import</strong> java.nio.file.Files;</p>
<p><strong>import</strong> java.nio.file.Paths;</p>
<p><strong>import</strong> java.nio.file.Path;</p>
<p>Path path = Paths.get("path/to/file");</p>
<p>try <strong>{</strong></p>
<p><strong>byte</strong>[] data = Files.readAllBytes(path);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 453</p>
<p><span id="__catch_IOException_e" class="anchor"></span>}
<strong>catch</strong>(IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 77.5: Copying a file using Channel</p>
<p>We can use Channel to copy file content faster. To do so, we can use
transferTo() method of FileChannel .</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> java.io.FileInputStream;</p>
<p><strong>import</strong> java.io.FileOutputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.nio.channels.FileChannel;</p>
<p><strong>public class</strong> FileCopier {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>File sourceFile = <strong>new</strong> File("hello.txt");</p>
<p>File sinkFile = <strong>new</strong> File("hello2.txt");</p>
<p>copy(sourceFile, sinkFile);</p>
<p>}</p>
<p><strong>public static void</strong> copy(File sourceFile, File
destFile) {</p>
<p><strong>if</strong> (!sourceFile.exists() || !destFile.exists())
{</p>
<p>System.out.println("Source or destination file doesn't exist");
<strong>return</strong>;</p>
<p>}</p>
<p><strong>try</strong> (FileChannel srcChannel = <strong>new</strong>
FileInputStream(sourceFile).getChannel();</p>
<p>FileChannel sinkChanel = <strong>new</strong>
FileOutputStream(destFile).getChannel()) {</p>
<p>srcChannel.transferTo(0, srcChannel.size(), sinkChanel);</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.6: Writing a byte[] to a file</p>
<p>Version ≥ Java SE 7</p>
<p><strong>byte</strong>[] bytes = { 0x48, 0x65, 0x6c, 0x6c, 0x6f };</p>
<p><strong>try</strong>(FileOutputStream stream = <strong>new</strong>
FileOutputStream("Hello world.txt")) {</p>
<p>stream.write(bytes);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Handle I/O Exception</p>
<p>ioe.printStackTrace();</p>
<p>}</p>
<p>Version &lt; Java SE 7</p>
<p><strong>byte</strong>[] bytes = { 0x48, 0x65, 0x6c, 0x6c, 0x6f };</p>
<p>FileOutputStream stream = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>stream = <strong>new</strong> FileOutputStream("Hello
world.txt");</p>
<p>stream.write(bytes);</p>
<p>} <strong>catch</strong> (IOException ioe) {</p>
<p>// Handle I/O Exception</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 454</p>
<p><span id="ioe_printStackTrace"
class="anchor"></span>ioe.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (stream != <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>stream.close();</p>
<p>} <strong>catch</strong> (IOException ignored) {}</p>
<p>}</p>
<p>}</p>
<p>Most java.io file APIs accept both Strings and Files as arguments, so
you could as well use</p>
<p>File file = <strong>new</strong> File("Hello world.txt");</p>
<p>FileOutputStream stream = <strong>new</strong>
FileOutputStream(file);</p>
<p>Section 77.7: Stream vs Writer/Reader API</p>
<p>Streams provide the most direct access to the binary content, so any
<a
href="https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html">InputStream</a>
<a
href="https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html">/
OutputStream implementations</a></p>
<p>always operate on <strong>int</strong>s and
<strong>byte</strong>s.</p>
<p>// Read a single byte from the stream</p>
<p><strong>int</strong> b = inputStream.read();</p>
<p><em><strong>if</strong> (b &gt;= 0) {</em> // A negative value
represents the end of the stream, normal values are in the range 0-
255</p>
<p>// Write the byte to another stream</p>
<p>outputStream.write(b);</p>
<p>}</p>
<p>// Read a chunk</p>
<p><strong>byte</strong>[] data = <strong>new byte</strong>[1024];</p>
<p><strong>int</strong> nBytesRead = inputStream.read(data);</p>
<p><em><strong>if</strong> (nBytesRead &gt;= 0) {</em> // A negative
value represents end of stream</p>
<p>// Write the chunk to another stream</p>
<p>outputStream.write(data, 0, nBytesRead);</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html">There
are some exceptions, probably most notably the PrintStream</a> which
adds the "ability to print representations</p>
<p>of various data values conveniently". This allows to use <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#out">System.out
both as a binary</a> InputStream and as a textual</p>
<p>output using methods such as System.out.println().</p>
<p>Also, some stream implementations work as an interface to
higher-level contents such as Java objects (see</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html">Serialization)
or native types, e.g. DataOutputStream /</a> <a
href="https://docs.oracle.com/javase/7/docs/api/java/io/DataInputStream.html">DataInputStream.</a></p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html">With
the Writer</a> and <a
href="https://docs.oracle.com/javase/7/docs/api/java/io/Reader.html">Reader</a>
classes, Java also provides an API for explicit character streams.
Although most applications will base these implementations on streams,
the character stream API does not expose any methods</p>
<p>for binary content.</p>
<p>// This example uses the platform's default charset, see below // for
a better implementation.</p>
<p>Writer writer = <strong>new</strong>
OutputStreamWriter(System.out);</p>
<p>writer.write("Hello world!");</p>
<p>Reader reader = <strong>new</strong>
InputStreamReader(System.in);</p>
<p><strong>char</strong> singleCharacter = reader.read();</p>
<p>Whenever it is necessary to encode characters into binary data (e.g.
when using the InputStreamWriter /</p>
<p>OutputStreamWriter classes), you should specify a charset if you do
not want to depend on the platform's default</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 455</p>
<p><span id="charset__When_in_doubt__use_a_Un"
class="anchor"></span>charset. When in doubt, use a Unicode-compatible
encoding, e.g. UTF-8 which is supported on all Java platforms.
Therefore, you should probably stay away from classes like FileWriter
and FileReader as those always use the</p>
<p>default platform charset. A better way to access files using
character streams is this:</p>
<p>Charset myCharset = StandardCharsets.UTF_8;</p>
<p>Writer writer = <strong>new</strong> OutputStreamWriter(
<strong>new</strong> FileOutputStream("test.txt"), myCharset );
writer.write(' Ä');</p>
<p>writer.flush();</p>
<p>writer.close();</p>
<p>Reader reader = <strong>new</strong> InputStreamReader(
<strong>new</strong> FileInputStream("test.txt"), myCharset );
<strong>char</strong> someUnicodeCharacter = reader.read();</p>
<p>reader.close();</p>
<p>One of the most commonly used Readers is BufferedReader which
provides a method to read whole lines of text</p>
<p>from another reader and is presumably the simplest way to read a
character stream line by line:</p>
<p>// Read from baseReader, one line at a time</p>
<p>BufferedReader reader = <strong>new</strong> BufferedReader(
baseReader ); String line;</p>
<p><strong>while</strong>((line = reader.readLine()) !=
<strong>null</strong>) {</p>
<p>// Remember: System.out is a stream, not a writer!</p>
<p>System.out.println(line);</p>
<p>}</p>
<p>Section 77.8: Reading a file with a Scanner</p>
<p>Reading a file line by line</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Scanner scanner = <strong>new</strong> Scanner(<strong>new</strong>
File("example.txt"));</p>
<p><strong>while</strong>(scanner.hasNextLine())</p>
<p>{</p>
<p>String line = scanner.nextLine();</p>
<p>//do stuff</p>
<p>}</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>word by word</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Scanner scanner = <strong>new</strong> Scanner(<strong>new</strong>
File("example.txt"));</p>
<p><strong>while</strong>(scanner.hasNext())</p>
<p>{</p>
<p>String line = scanner.next();</p>
<p>//do stuff</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 456</p>
<p><span id="__catch__FileNotFoundException_e" class="anchor"></span>}
<strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>and you can also change the delimeter by using scanner.useDelimeter()
method</p>
<p>Section 77.9: Copying a file using InputStream and</p>
<p>OutputStream</p>
<p>We can directly copy data from a source to a data sink using a loop.
In this example, we are reading data from an</p>
<p>InputStream and at the same time, writing to an OutputStream. Once we
are done reading and writing, we have to close the resource.</p>
<p><strong>public void</strong> copy(InputStream source, OutputStream
destination) <strong>throws</strong> IOException {</p>
<p>try <strong>{</strong></p>
<p>int <strong>c;</strong></p>
<p><strong>while</strong> ((c = source.read()) !=-1) {</p>
<p>destination.write(c);</p>
<p>}</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (source != <strong>null</strong>) {</p>
<p>source.close();</p>
<p>}</p>
<p><strong>if</strong> (destination != <strong>null</strong>) {</p>
<p>destination.close();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.10: Reading from a binary file</p>
<p>You can read an a binary file using this piece of code in all recent
versions of Java:</p>
<p>Version ≥ Java SE 1.4</p>
<p>File file = <strong>new</strong> File("path_to_the_file");</p>
<p><strong>byte</strong>[] data = <strong>new
byte</strong>[(<strong>int</strong>) file.length()];</p>
<p>DataInputStream stream = <strong>new</strong>
DataInputStream(<strong>new</strong> FileInputStream(file));
stream.readFully(data);</p>
<p>stream.close();</p>
<p>If you are using Java 7 or later, there is a simpler way using the
nio API:</p>
<p>Version ≥ Java SE 7</p>
<p>Path path = Paths.get("path_to_the_file");</p>
<p><strong>byte</strong> [] data = Files.readAllBytes(path);</p>
<p>Section 77.11: Reading a file using Channel and Buer</p>
<p>Channel uses a Buffer to read/write data. A buffer is a fixed sized
container where we can write a block of data at once. Channel is a quite
faster than stream-based I/O.</p>
<p>To read data from a file using Channel we need to have the following
steps-</p>
<p>1. We need an instance of FileInputStream. FileInputStreamhas a
method named getChannel() which</p>
<p>returns a Channel.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 457</p>
<p><span id="2__Call_the_getChannel___method" class="anchor"></span>2.
Call the getChannel() method of FileInputStream and acquire Channel. 3.
Create a ByteBuffer. ByteBuffer is a fixed size container of bytes.</p>
<p>4. Channel has a read method and we have to provide a ByteBuffer as
an argument to this read method.</p>
<p>ByteBuffer has two modes - read-only mood and write-only mood. We can
change the mode using flip() method call. Buffer has a position, limit,
and capacity. Once a buffer is created with a fixed size, its limit
and</p>
<p>capacity are the same as the size and the position starts from zero.
While a buffer is written with data, its position gradually increases.
Changing mode means, changing the position. To read data from the
beginning</p>
<p>of a buffer, we have to set the position to zero. flip() method
change the position</p>
<p>5. When we call the read method of the Channel, it fills up the
buffer using data.</p>
<p>6. If we need to read the data from the ByteBuffer, we need to flip
the buffer to change its mode to write-only</p>
<p>to read-only mode and then keep reading data from the buffer.</p>
<p>7. When there is no longer data to read, the read() method of channel
returns 0 or -1.</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> java.io.FileInputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.nio.ByteBuffer;</p>
<p><strong>import</strong> java.nio.channels.FileChannel;</p>
<p><strong>public class</strong> FileChannelRead {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>File inputFile = <strong>new</strong> File("hello.txt");</p>
<p><strong>if</strong> (!inputFile.exists()) {</p>
<p>System.out.println("The input file doesn't exit.");
<strong>return</strong>;</p>
<p>}</p>
<p>try <strong>{</strong></p>
<p>FileInputStream fis = <strong>new</strong>
FileInputStream(inputFile);</p>
<p>FileChannel fileChannel = fis.getChannel();</p>
<p>ByteBuffer buffer = ByteBuffer.allocate(1024);</p>
<p><strong>while</strong> (fileChannel.read(buffer) &gt; 0) {</p>
<p>buffer.flip();</p>
<p><strong>while</strong> (buffer.hasRemaining()) {</p>
<p><strong>byte</strong> b = buffer.get();</p>
<p>System.out.print((<strong>char</strong>) b);</p>
<p>}</p>
<p>buffer.clear();</p>
<p>}</p>
<p>fileChannel.close();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.12: Adding Directories</p>
<p>To make a new directory from a File instance you would need to use
one of two methods: mkdirs() or mkdir().</p>
<p>mkdir() <a
href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html#mkdir()">-
Creates the directory named by this abstract pathname. (source)</a>
mkdirs() - Creates the directory named by this abstract pathname,
including any necessary but nonexistent</p>
<p>parent directories. Note that if this operation fails it may have
succeeded in creating some of the necessary</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 458</p>
<p><span id="parent_directories___source" class="anchor"></span>parent
directories. (<a
href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html#mkdirs()">source)</a></p>
<p><strong>Note:</strong> createNewFile() will not create a new
directory only a file.</p>
<p>File singleDir = <strong>new</strong>
File("C:/Users/SomeUser/Desktop/A New Folder/");</p>
<p>File multiDir = <strong>new</strong>
File("C:/Users/SomeUser/Desktop/A New Folder 2/Another Folder/");</p>
<p>// assume that neither "A New Folder" or "A New Folder 2" exist</p>
<p><em>singleDir.createNewFile();</em> // will make a new file called "A
New Folder.file" <em>singleDir.mkdir();</em> // will make the
directory</p>
<p><em>singleDir.mkdirs();</em> // will make the directory</p>
<p>multiDir.createNewFile(); <em>// will throw a IOException</em>
multiDir.mkdir(); <em>// will not work</em></p>
<p><em>multiDir.mkdirs();</em> // will make the directory</p>
<p>Section 77.13: Blocking or redirecting standard output / error</p>
<p>Sometimes a poorly designed 3rd-party library will write unwanted
diagnostics to System.out or System.err</p>
<p>streams. The recommended solutions to this would be to either find a
better library or (in the case of open source)</p>
<p>fix the problem and contribute a patch to the developers.</p>
<p>If the above solutions are not feasible, then you should consider
redirecting the streams.</p>
<p>Redirection on the command line</p>
<p>On a UNIX, Linux or MacOSX system can be done from the shell using
&gt; redirection. For example:</p>
<p>$ java -jar app.jar arg1 arg2 &gt; /dev/<strong>null</strong>
2&gt;&amp;1</p>
<p>$ java -jar app.jar arg1 arg2 &gt; out.log 2&gt; error.log</p>
<p>The first one redirects standard output and standard error to
"/dev/null", which throws away anything written to those streams. The
second of redirects standard output to "out.log" and standard error to
"error.log".</p>
<p>(For more information on redirection, refer to the documentation of
the command shell you are using. Similar advice applies to Windows.)</p>
<p>Alternatively, you could implement the redirection in a wrapper
script or batch file that launches the Java application.</p>
<p>Redirection within a Java application</p>
<p>It is also possible to redired the streams <em>within</em> a Java
application using System.setOut() and System.setErr(). For example, the
following snippet redirects standard output and standard error to 2 log
files:</p>
<p>System.setOut(<strong>new</strong> PrintStream(<strong>new</strong>
FileOutputStream(<strong>new</strong> File("out.log"))));
System.setErr(<strong>new</strong> PrintStream(<strong>new</strong>
FileOutputStream(<strong>new</strong> File("err.log"))));</p>
<p>If you want to throw away the output entirely, you can create an
output stream that "writes" to an invalid file</p>
<p>descriptor. This is functionally equivalent to writing to "/dev/null"
on UNIX.</p>
<p>System.setOut(<strong>new</strong> PrintStream(<strong>new</strong>
FileOutputStream(<strong>new</strong> FileDescriptor())));
System.setErr(<strong>new</strong> PrintStream(<strong>new</strong>
FileOutputStream(<strong>new</strong> FileDescriptor())));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 459</p>
<p><span id="Caution__be_careful_how_you_use"
class="anchor"></span>Caution: be careful how you use setOut and
setErr:</p>
<p>1. The redirection will affect the entire JVM.</p>
<p>2. By doing this, you are taking away the user's ability to redirect
the streams from the command line.</p>
<p>Section 77.14: Reading a whole file at once</p>
<p>File f = <strong>new</strong> File(path);</p>
<p>String content = <strong>new</strong>
Scanner(f).useDelimiter("<strong>\\</strong>Z").next();</p>
<p>\Z is the EOF (End of File) Symbol. When set as delimiter the Scanner
will read the fill until the EOF Flag is reached.</p>
<p>Section 77.15: Locking</p>
<p>A file can be locked using the FileChannel API that can be acquired
from Input Output streams and readers</p>
<p>Example with streams</p>
<p>// Open a file stream</p>
<p>FileInputStream ios = <strong>new</strong> FileInputStream(filename);
<em>// get underlying channel</em></p>
<p>FileChannel channel = ios.getChannel();</p>
<p>/*</p>
<p>* try to lock the file. true means whether the lock is shared or not
i.e. multiple processes can acquire a</p>
<p>* shared lock (for reading only) Using false with readable channel
only will generate an exception. You should</p>
<p>* use a writable channel (taken from FileOutputStream) when using
false. tryLock will always return immediately</p>
<p>*/</p>
<p>FileLock lock = channel.tryLock(0, Long.MAX_VALUE,
<strong>true</strong>);</p>
<p><strong>if</strong> (lock == <strong>null</strong>) {</p>
<p>System.out.println("Unable to acquire lock");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Lock acquired successfully");</p>
<p>}</p>
<p>// you can also use blocking call which will block until a lock is
acquired.</p>
<p>channel.lock();</p>
<p>// Once you have completed desired operations of file. release the
lock <em><strong>if</strong> (lock != <strong>null</strong>) {</em></p>
<p>lock.release();</p>
<p>}</p>
<p>// close the file stream afterwards</p>
<p>// Example with reader</p>
<p>RandomAccessFile randomAccessFile = <strong>new</strong>
RandomAccessFile(filename, "rw");</p>
<p>FileChannel channel = randomAccessFile.getChannel();</p>
<p>//repeat the same steps as above but now you can use shared as true
or false as the channel is in</p>
<p>read write mode</p>
<p>Section 77.16: Reading a file using BueredInputStream</p>
<p>Reading file using a BufferedInputStream generally faster than
FileInputStream because it maintains an internal</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 460</p>
<p><span id="buffer_to_store_bytes_read_from"
class="anchor"></span>buffer to store bytes read from the underlying
input stream.</p>
<p><strong>import</strong> java.io.BufferedInputStream;</p>
<p><strong>import</strong> java.io.FileInputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>public class</strong> FileReadingDemo {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>String source = "hello.txt";</p>
<p><strong>try</strong> (BufferedInputStream bis = <strong>new</strong>
BufferedInputStream(<strong>new</strong> FileInputStream(source))) {</p>
<p><strong>byte</strong> data;</p>
<p><strong>while</strong> ((data = (<strong>byte</strong>) bis.read())
!=-1) {</p>
<p>System.out.println((<strong>char</strong>) data);</p>
<p>}</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.17: Iterate over a directory printing subdirectories</p>
<p>in it</p>
<p><strong>public void</strong> iterate(<strong>final</strong> String
dirPath) <strong>throws</strong> IOException {</p>
<p><strong>final</strong> DirectoryStream paths =
Files.newDirectoryStream(Paths.get(dirPath)); <strong>for</strong>
(<strong>final</strong> Path path : paths) {</p>
<p><strong>if</strong> (Files.isDirectory(path)) {</p>
<p>System.out.println(path.getFileName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.18: Writing a file using Channel and Buer</p>
<p>To write data to a file using Channel we need to have the following
steps:</p>
<p>1. First, we need to get an object of FileOutputStream</p>
<p>2. Acquire FileChannel calling the getChannel() method from the
FileOutputStream</p>
<p>3. Create a ByteBuffer and then fill it with data</p>
<p>4. Then we have to call the flip() method of the ByteBuffer and pass
it as an argument of the write()</p>
<p>method of the FileChannel</p>
<p>5. Once we are done writing, we have to close the resource</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>import</strong> java.nio.*;</p>
<p><strong>public class</strong> FileChannelWrite {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>File outputFile = <strong>new</strong> File("hello.txt");</p>
<p>String text = "I love Bangladesh.";</p>
<p>try <strong>{</strong></p>
<p>FileOutputStream fos = <strong>new</strong>
FileOutputStream(outputFile);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 461</p>
<p><span id="FileChannel_fileChannel___fos_ge"
class="anchor"></span>FileChannel fileChannel = fos.getChannel();</p>
<p><strong>byte</strong>[] bytes = text.getBytes();</p>
<p>ByteBuffer buffer = ByteBuffer.wrap(bytes);</p>
<p>fileChannel.write(buffer);</p>
<p>fileChannel.close();</p>
<p>} <strong>catch</strong> (java.io.IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.19: Writing a file using PrintStream</p>
<p>We can use PrintStream class to write a file. It has several methods
that let you print any data type values.</p>
<p>println() method appends a new line. Once we are done printing, we
have to flush the PrintStream.</p>
<p><strong>import</strong> java.io.FileNotFoundException;</p>
<p><strong>import</strong> java.io.PrintStream;</p>
<p><strong>import</strong> java.time.LocalDate;</p>
<p><strong>public class</strong> FileWritingDemo {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>String destination = "file1.txt";</p>
<p><strong>try</strong>(PrintStream ps = <strong>new</strong>
PrintStream(destination)){</p>
<p>ps.println("Stackoverflow documentation seems fun.");</p>
<p>ps.println();</p>
<p>ps.println("I love Java!");</p>
<p>ps.printf("Today is: %1$tm/%1$td/%1$tY", LocalDate.now());</p>
<p>ps.flush();</p>
<p>} <strong>catch</strong> (FileNotFoundException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 77.20: Iterating over a directory and filter by file</p>
<p>extension</p>
<p><strong>public void</strong> iterateAndFilter()
<strong>throws</strong> IOException {</p>
<p>Path dir = Paths.get("C:/foo/bar");</p>
<p>PathMatcher imageFileMatcher =</p>
<p>FileSystems.getDefault().getPathMatcher(</p>
<p>"regex:.*(?i:jpg|jpeg|png|gif|bmp|jpe|jfif)");</p>
<p><strong>try</strong> (DirectoryStream stream =
Files.newDirectoryStream(dir, entry -&gt;
imageFileMatcher.matches(entry.getFileName()))) {</p>
<p><strong>for</strong> (Path path : stream) {</p>
<p>System.out.println(path.getFileName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 462</p>
<p><span id="Section_77_21__Accessing_the_con"
class="anchor"></span>Section 77.21: Accessing the contents of a ZIP
file</p>
<p>The FileSystem API of Java 7 allows to read and add entries from or
to a Zip file using the Java NIO file API in the</p>
<p>same way as operating on any other filesystem.</p>
<p>The FileSystem is a resource that should be properly closed after
use, therefore the try-with-resources block should</p>
<p>be used.</p>
<p>Reading from an existing file</p>
<p>Path pathToZip = Paths.get("path/to/file.zip");</p>
<p><strong>try</strong>(FileSystem zipFs =
FileSystems.newFileSystem(pathToZip, <strong>null</strong>)) { Path root
= zipFs.getPath("/");</p>
<p><em>...</em> //access the content of the zip file same as ordinary
files <em>} <strong>catch</strong>(IOException ex) {</em></p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>Creating a new file</p>
<p>Map env = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>env.put("create", "true"); <em>//required for creating a new zip
file</em> env.put("encoding", "UTF-8"); <em>//optional: default is
UTF-8</em> URI uri = URI.create("jar:file:/path/to/file.zip");
<strong>try</strong> (FileSystem zipfs = FileSystems.newFileSystem(uri,
env)) { Path newFile = zipFs.getPath("/newFile.txt");</p>
<p>//writing to file</p>
<p>Files.write(newFile, "Hello world".getBytes());</p>
<p>} <strong>catch</strong>(IOException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 463</p>
<p><span id="Chapter_78__Scanner_1" class="anchor"></span>Chapter 78:
Scanner</p>
<p>Parameter Details</p>
<p>Source Source could be either one of String, File or any kind of
InputStream</p>
<p>Section 78.1: General Pattern that does most commonly</p>
<p>asked about tasks</p>
<p>The following is how to properly use the java.util.Scanner class to
interactively read user input from System.in</p>
<p>correctly( sometimes referred to as stdin, especially in C, C++ and
other languages as well as in Unix and Linux). It idiomatically
demonstrates the most common things that are requested to be done.</p>
<p><strong>package</strong> com.stackoverflow.scanner;</p>
<p><strong>import</strong> javax.annotation.Nonnull;</p>
<p><strong>import</strong> java.math.BigInteger;</p>
<p><strong>import</strong> java.net.MalformedURLException;</p>
<p><strong>import</strong> java.net.URL;</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>import</strong> java.util.regex.Pattern;</p>
<p><strong>import</strong> static java.lang.String.format;</p>
<p><strong>public class</strong> ScannerExample</p>
<p>{</p>
<p>private static final <strong>Set EXIT_COMMANDS;</strong></p>
<p>private static final <strong>Set HELP_COMMANDS;</strong></p>
<p><strong>private static final</strong> Pattern DATE_PATTERN;</p>
<p><strong>private static final</strong> String HELP_MESSAGE;</p>
<p>static</p>
<p>{</p>
<p><strong>final</strong> SortedSet ecmds = <strong>new</strong>
TreeSet(String.CASE_INSENSITIVE_ORDER);</p>
<p>ecmds.addAll(Arrays.asList("exit", "done", "quit", "end",
"fino"));</p>
<p>EXIT_COMMANDS = Collections.unmodifiableSortedSet(ecmds);</p>
<p><strong>final</strong> SortedSet hcmds = <strong>new</strong>
TreeSet(String.CASE_INSENSITIVE_ORDER);</p>
<p>hcmds.addAll(Arrays.asList("help", "helpi", "?"));</p>
<p>HELP_COMMANDS = Collections.unmodifiableSet(hcmds);</p>
<p>DATE_PATTERN =
Pattern.compile("<strong>\\</strong>d{4}([-<strong>\\</strong>/])<strong>\\</strong>d{2}<strong>\\</strong>1<strong>\\</strong>d{2}");
<em>// http://regex101.com/r/xB8dR3/1</em></p>
<p>HELP_MESSAGE = format("Please enter some data or enter one of the
following commands to exit %s", EXIT_COMMANDS);</p>
<p>}</p>
<p>/**</p>
<p>* Using exceptions to control execution flow is always bad.</p>
<p>* That is why this is encapsulated in a method, this is done this</p>
<p>* way specifically so as not to introduce any external libraries</p>
<p>* so that this is a completely self contained example.</p>
<p>* @param s possible url</p>
<p>* @return true if s represents a valid url, false otherwise</p>
<p>*/</p>
<p><strong>private static boolean</strong> isValidURL(@Nonnull
<strong>final</strong> String s) {</p>
<p>try <strong>{</strong> new <strong>URL(s);</strong> return
true<strong>; }</strong></p>
<p><strong>catch</strong> (<strong>final</strong> MalformedURLException
e) { <strong>return false</strong>; }</p>
<p>}</p>
<p><strong>private static void</strong> output(@Nonnull
<strong>final</strong> String format, @Nonnull <strong>final</strong>
Object... args)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 464</p>
<p>{</p>
<p>System.out.println(format(format, args));</p>
<p>}</p>
<p>public static void <strong>main(</strong>final <strong>String[]
args)</strong></p>
<p>{</p>
<p><strong>final</strong> Scanner sis = <strong>new</strong>
Scanner(System.in);</p>
<p>output(HELP_MESSAGE);</p>
<p><strong>while</strong> (sis.hasNext())</p>
<p>{</p>
<p><strong>if</strong> (sis.hasNextInt())</p>
<p>{</p>
<p><strong>final int</strong> next = sis.nextInt();</p>
<p>output("You entered an Integer = %d", next);</p>
<p>}</p>
<p><strong>else if</strong> (sis.hasNextLong())</p>
<p>{</p>
<p><strong>final long</strong> next = sis.nextLong();</p>
<p>output("You entered a Long = %d", next);</p>
<p>}</p>
<p><strong>else if</strong> (sis.hasNextDouble())</p>
<p>{</p>
<p><strong>final double</strong> next = sis.nextDouble();</p>
<p>output("You entered a Double = %f", next);</p>
<p>}</p>
<p><strong>else if</strong> (sis.hasNext("<strong>\\</strong>d+"))</p>
<p>{</p>
<p><strong>final</strong> BigInteger next = sis.nextBigInteger();</p>
<p>output("You entered a BigInteger = %s", next);</p>
<p>}</p>
<p><strong>else if</strong> (sis.hasNextBoolean())</p>
<p>{</p>
<p><strong>final boolean</strong> next = sis.nextBoolean();</p>
<p>output("You entered a Boolean representation = %s", next);</p>
<p>}</p>
<p><strong>else if</strong> (sis.hasNext(DATE_PATTERN))</p>
<p>{</p>
<p><strong>final</strong> String next = sis.next(DATE_PATTERN);</p>
<p>output("You entered a Date representation = %s", next);</p>
<p>}</p>
<p><em><strong>else</strong></em> // unclassified</p>
<p>{</p>
<p><strong>final</strong> String next = sis.next();</p>
<p><strong>if</strong> (isValidURL(next))</p>
<p>{</p>
<p>output("You entered a valid URL = %s", next);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p><strong>if</strong> (EXIT_COMMANDS.contains(next))</p>
<p>{</p>
<p>output("Exit command %s issued, exiting!", next);</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p><strong>else if</strong> (HELP_COMMANDS.contains(next)) {
output(HELP_MESSAGE); } <strong>else</strong> { output("You entered an
unclassified String = %s", next); }</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/*</p>
<p>This will close the underlying Readable, in this case System.in, and
free those resources.</p>
<p>You will not be to read from System.in anymore after this you call
.close().</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 465</p>
<p><span id="If_you_wanted_to_use_System_in_f" class="anchor"></span>If
you wanted to use System.in for something else, then don't close the
Scanner.</p>
<p>*/</p>
<p>sis.close();</p>
<p>System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>Section 78.2: Using custom delimiters</p>
<p>You can use custom delimiters (regular expressions) with Scanner,
with .useDelimiter(","), to determine how the</p>
<p>input is read. This works similarly to String.split(...). For
example, you can use Scanner to read from a list of comma separated
values in a String:</p>
<p>Scanner scanner = <strong>null</strong>;</p>
<p>try<strong>{</strong></p>
<p>scanner = <strong>new</strong>
Scanner("i,like,unicorns").useDelimiter(",");;</p>
<p><strong>while</strong>(scanner.hasNext()){</p>
<p>System.out.println(scanner.next());</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e){</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong>finally<strong>{</strong></p>
<p><strong>if</strong> (scanner != <strong>null</strong>)</p>
<p>scanner.close();</p>
<p>}</p>
<p>This will allow you to read every element in the input individually.
Note that you should <strong>not</strong> use this to parse CSV</p>
<p><a
href="http://stackoverflow.com/questions/101100/csv-api-for-java">data,
instead, use a proper CSV parser library, see CSV parser for Java</a>
for other possibilities.</p>
<p>Section 78.3: Reading system input using Scanner</p>
<p>Scanner scanner = <strong>new</strong> Scanner(System.in);
<em>//Scanner obj to read System input</em> String inputTaken =
<strong>new</strong> String();</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p><em>String input = scanner.nextLine();</em> // reading one line of
input <em><strong>if</strong>
(input.matches("<strong>\\</strong>s+"))</em> // if it matches
spaces/tabs, stop reading</p>
<p>break<strong>;</strong></p>
<p>inputTaken += input + " ";</p>
<p>}</p>
<p>System.out.println(inputTaken);</p>
<p>The scanner object is initialized to read input from keyboard. So for
the below input from keyboar, it'll produce the</p>
<p>output as Reading from keyboard</p>
<p>Reading</p>
<p>from</p>
<p>keyboard</p>
<p>//space</p>
<p>Section 78.4: Reading file input using Scanner</p>
<p>Scanner scanner = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>scanner = <strong>new</strong> Scanner(<strong>new</strong>
File("Names.txt"));</p>
<p><strong>while</strong> (scanner.hasNext()) {</p>
<p>System.out.println(scanner.nextLine());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 466</p>
<p><span id="_34" class="anchor"></span>}</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred!");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (scanner != <strong>null</strong>)</p>
<p>scanner.close();</p>
<p>}</p>
<p>Here a Scanner object is created by passing a File object containing
the name of a text file as input. This text file will be opened by the
File object and read in by the scanner object in the following lines.
scanner.hasNext() will</p>
<p>check to see if there is a next line of data in the text file.
Combining that with a <strong>while</strong> loop will allow you to
iterate through every line of data in the Names.txt file. To retrieve
the data itself, we can use methods such as</p>
<p>nextLine() ,nextInt(),nextBoolean(), etc. In the example above,
scanner.nextLine()is used. nextLine() refers to the following line in a
text file, and combining it with a scanner object allows you to print
the contents of the line.</p>
<p>To close a scanner object, you would use .close().</p>
<p>Using try with resources (from Java 7 onwards), the above mentioned
code can be written elegantly as below.</p>
<p><strong>try</strong> (Scanner scanner = <strong>new</strong>
Scanner(<strong>new</strong> File("Names.txt"))) {</p>
<p><strong>while</strong> (scanner.hasNext()) {</p>
<p>System.out.println(scanner.nextLine());</p>
<p>}</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred!");</p>
<p>}</p>
<p>Section 78.5: Read the entire input as a String using Scanner</p>
<p>You can use Scanner to read all of the text in the input as a String,
by using \Z (entire input) as the delimiter. For</p>
<p>example, this can be used to read all text in a text file in one
line:</p>
<p>String content = <strong>new</strong> Scanner(<strong>new</strong>
File("filename")).useDelimiter("<strong>\\</strong>Z").next();
System.out.println(content);</p>
<p>Remember that you'll have to close the Scanner, as well as catch the
IoException this may throw, as described in the example Reading file
input using Scanner.</p>
<p>Section 78.6: Carefully Closing a Scanner</p>
<p>it can happen that you use a scanner with the System.in as parameter
for the constructor, then you need to be aware that closing the scanner
will close the InputStream too giving as next that every try to read the
input on that</p>
<p>(Or any other scanner object) will throw an
java.util.NoSuchElementException or an
java.lang.IllegalStateException</p>
<p>example:</p>
<p>Scanner sc1 = <strong>new</strong> Scanner(System.in);</p>
<p>Scanner sc2 = <strong>new</strong> Scanner(System.in);</p>
<p><strong>int</strong> x1 = sc1.nextInt();</p>
<p>sc1.close();</p>
<p>// java.util.NoSuchElementException</p>
<p><strong>int</strong> x2 = sc2.nextInt();</p>
<p>// java.lang.IllegalStateException</p>
<p>x2 = sc1.nextInt();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 467</p>
<p><span id="Section_78_7__Read_an_int_from_t"
class="anchor"></span>Section 78.7: Read an int from the command
line</p>
<p><strong>import</strong> java.util.Scanner;</p>
<p>Scanner s = <strong>new</strong> Scanner(System.in);</p>
<p><strong>int</strong> number = s.nextInt();</p>
<p>If you want to read an int from the command line, just use this
snippet. First of all, you have to create a Scanner</p>
<p>object, that listens to System.in, which is by default the Command
Line, when you start the program from the command line. After that, with
the help of the Scanner object, you read the first int that the user
passes into the</p>
<p>command line and store it in the variable number. Now you can do
whatever you want with that stored int.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 468</p>
<p><span id="Chapter_79__Interfaces_1" class="anchor"></span>Chapter 79:
Interfaces</p>
<p>An <em>interface</em> is a reference type, similar to a class, which
can be declared by using <strong>interface</strong> keyword. Interfaces
can</p>
<p>contain only constants, method signatures, default methods, static
methods, and nested types. Method bodies</p>
<p>exist only for default methods and static methods. Like abstract
classes, Interfaces cannot be instantiated—they can only be implemented
by classes or extended by other interfaces. Interface is a common way to
achieve full</p>
<p>abstraction in Java.</p>
<p>Section 79.1: Implementing multiple interfaces</p>
<p>A Java class can implement multiple interfaces.</p>
<p>public interface <strong>NoiseMaker {</strong></p>
<p><em>String noise = "Making Noise";</em> // interface variables are
public static final by default</p>
<p><em>String makeNoise();</em> //interface methods are public abstract
by default</p>
<p>}</p>
<p>public interface <strong>FoodEater {</strong></p>
<p><strong>void</strong> eat(Food food);</p>
<p>}</p>
<p><strong>public class</strong> Cat <strong>implements</strong>
NoiseMaker, FoodEater {</p>
<p>@Override</p>
<p><strong>public</strong> String makeNoise() {</p>
<p><strong>return</strong> "meow";</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> eat(Food food) {</p>
<p>System.out.println("meows appreciatively");</p>
<p>}</p>
<p>}</p>
<p>Notice how the Cat class <strong>must</strong> implement the
inherited <strong>abstract</strong> methods in both the interfaces.
Furthermore,</p>
<p>notice how a class can practically implement as many interfaces as
needed (there is a limit of <strong>65,535</strong> due to <a
href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.11">JVM</a></p>
<p><a
href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.11">Limitation).</a></p>
<p>NoiseMaker noiseMaker = <strong>new</strong> Cat(); <em>//
Valid</em></p>
<p>FoodEater foodEater = <strong>new</strong> Cat(); <em>//
Valid</em></p>
<p>Cat cat = <strong>new</strong> Cat(); <em>// valid</em></p>
<p>Cat invalid1 = <strong>new</strong> NoiseMaker(); <em>//
Invalid</em></p>
<p>Cat invalid2 = <strong>new</strong> FoodEater(); <em>//
Invalid</em></p>
<p>Note:</p>
<p>1. All variables declared in an interface are <strong>public static
final</strong></p>
<p>2. All methods declared in an interface methods are <strong>public
abstract</strong> (This statement is valid only through Java</p>
<p>7. From Java 8, you are allowed to have methods in an interface,
which need not be abstract; such methods are known as default
methods)</p>
<p>3. Interfaces cannot be declared as <strong>final</strong></p>
<p>4. If more than one interface declares a method that has identical
signature, then effectively it is treated as only</p>
<p>one method and you cannot distinguish from which interface method is
implemented</p>
<p>5. A corresponding <strong>InterfaceName.class</strong> file would be
generated for each interface, upon compilation</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 469</p>
<p><span id="Section_79_2__Declaring_and_Impl"
class="anchor"></span>Section 79.2: Declaring and Implementing an
Interface</p>
<p>Declaration of an interface using the <strong>interface</strong>
keyword:</p>
<p>public interface <strong>Animal {</strong></p>
<p><em>String getSound();</em> // Interface methods are public by
default</p>
<p>}</p>
<p>Override Annotation</p>
<p>@Override</p>
<p><strong>public</strong> String getSound() {</p>
<p>// Code goes here...</p>
<p>}</p>
<p>This forces the compiler to check that we are overriding and prevents
the program from defining a new method or</p>
<p>messing up the method signature.</p>
<p>Interfaces are implemented using the implements keyword.</p>
<p>public class <strong>Cat</strong> implements <strong>Animal
{</strong></p>
<p>@Override</p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "meow";</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Dog</strong> implements <strong>Animal
{</strong></p>
<p>@Override</p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "woof";</p>
<p>}</p>
<p>}</p>
<p>In the example, classes Cat and Dog <strong>must</strong> define the
getSound() method as methods of an interface are inherently</p>
<p>abstract (with the exception of default methods).</p>
<p>Using the interfaces</p>
<p>Animal cat = <strong>new</strong> Cat();</p>
<p>Animal dog = <strong>new</strong> Dog();</p>
<p>System.out.println(cat.getSound()); <em>// prints "meow"</em>
System.out.println(dog.getSound()); <em>// prints "woof"</em></p>
<p>Section 79.3: Extending an interface</p>
<p>An interface can extend another interface via the
<strong>extends</strong> keyword.</p>
<p><strong>public interface</strong> BasicResourceService {</p>
<p>Resource getResource();</p>
<p>}</p>
<p><strong>public interface</strong> ExtendedResourceService
<strong>extends</strong> BasicResourceService {</p>
<p><strong>void</strong> updateResource(Resource resource);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 470</p>
<p><span id="_35" class="anchor"></span>}</p>
<p>Now a class implementing ExtendedResourceService will need to
implement both getResource() and updateResource().</p>
<p>Extending multiple interfaces</p>
<p>Unlike classes, the <strong>extends</strong> keyword can be used to
extend multiple interfaces (Separated by commas) allowing for
combinations of interfaces into a new interface</p>
<p><strong>public interface</strong> BasicResourceService {</p>
<p>Resource getResource();</p>
<p>}</p>
<p><strong>public interface</strong> AlternateResourceService {</p>
<p>Resource getAlternateResource();</p>
<p>}</p>
<p><strong>public interface</strong> ExtendedResourceService
<strong>extends</strong> BasicResourceService, AlternateResourceService
{</p>
<p>Resource updateResource(Resource resource);</p>
<p>}</p>
<p>In this case a class implementing ExtendedResourceService will need
to implement getResource(), getAlternateResource(), and
updateResource().</p>
<p>Section 79.4: Usefulness of interfaces</p>
<p>Interfaces can be extremely helpful in many cases. For example, say
you had a list of animals and you wanted to loop through the list, each
printing the sound they make.</p>
<p>{cat, dog, bird}</p>
<p>One way to do this would be to use interfaces. This would allow for
the same method to be called on all of the</p>
<p>classes</p>
<p>public interface <strong>Animal {</strong></p>
<p><strong>public</strong> String getSound();</p>
<p>}</p>
<p>Any class that <strong>implements</strong> Animal also must have a
getSound() method in them, yet they can all have different
implementations</p>
<p>public class <strong>Dog</strong> implements <strong>Animal
{</strong></p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "Woof";</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Cat</strong> implements <strong>Animal
{</strong></p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "Meow";</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Bird</strong> implements
<strong>Animal{</strong></p>
<p><strong>public</strong> String getSound() {</p>
<p><strong>return</strong> "Chirp";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 471</p>
<p>}</p>
<p>}</p>
<p>We now have three different classes, each of which has a getSound()
method. Because all of these classes</p>
<p>implement the Animal interface, which declares the getSound() method,
any instance of an Animal can have getSound() called on it</p>
<p>Animal dog = <strong>new</strong> Dog();</p>
<p>Animal cat = <strong>new</strong> Cat();</p>
<p>Animal bird = <strong>new</strong> Bird();</p>
<p>dog.getSound(); <em>// "Woof"</em></p>
<p>cat.getSound(); <em>// "Meow"</em></p>
<p>bird.getSound(); <em>// "Chirp"</em></p>
<p>Because each of these is an Animal, we could even put the animals in
a list, loop through them, and print out their</p>
<p>sounds</p>
<p>Animal[] animals = { <strong>new</strong> Dog(), <strong>new</strong>
Cat(), <strong>new</strong> Bird() }; <strong>for</strong> (Animal
animal : animals) {</p>
<p>System.out.println(animal.getSound());</p>
<p>}</p>
<p>Because the order of the array is Dog, Cat, and then Bird, <em>"Woof
Meow Chirp"</em> will be printed to the console.</p>
<p>Interfaces can also be used as the return value for functions. For
example, returning a Dog if the input is <em>"dog"</em>, Cat if</p>
<p>the input is <em>"cat"</em>, and Bird if it is <em>"bird"</em>, and
then printing the sound of that animal could be done using</p>
<p><strong>public</strong> Animal getAnimalByName(String name) {</p>
<p><strong>switch</strong>(name.toLowerCase()) {</p>
<p><strong>case</strong> "dog":</p>
<p>return new <strong>Dog();</strong></p>
<p><strong>case</strong> "cat":</p>
<p>return new <strong>Cat();</strong></p>
<p><strong>case</strong> "bird":</p>
<p>return new <strong>Bird();</strong></p>
<p>default<strong>:</strong></p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> String getAnimalSoundByName(String name){</p>
<p>Animal animal = getAnimalByName(name);</p>
<p><strong>if</strong> (animal == <strong>null</strong>) {</p>
<p>return null<strong>;</strong></p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong> animal.getSound();</p>
<p>}</p>
<p>}</p>
<p>String dogSound = getAnimalSoundByName("dog"); <em>// "Woof"</em>
String catSound = getAnimalSoundByName("cat"); <em>// "Meow"</em> String
birdSound = getAnimalSoundByName("bird"); <em>// "Chirp"</em> String
lightbulbSound = getAnimalSoundByName("lightbulb"); <em>// null</em></p>
<p>Interfaces are also useful for extensibility, because if you want to
add a new type of Animal, you wouldn't need to</p>
<p>change anything with the operations you perform on them.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 472</p>
<p><span id="Section_79_5__Default_methods"
class="anchor"></span>Section 79.5: Default methods</p>
<p>Introduced in Java 8, default methods are a way of specifying an
implementation inside an interface. This could be</p>
<p>used to avoid the typical "Base" or "Abstract" class by providing a
partial implementation of an interface, and</p>
<p>restricting the subclasses hierarchy.</p>
<p>Observer pattern implementation</p>
<p>For example, it's possible to implement the Observer-Listener pattern
directly into the interface, providing more</p>
<p>flexibility to the implementing classes.</p>
<p><strong>interface</strong> Observer {</p>
<p><strong>void</strong> onAction(String a);</p>
<p>}</p>
<p><strong>interface</strong> Observable{</p>
<p><strong>public abstract</strong> List getObservers();</p>
<p><strong>public default void</strong> addObserver(Observer o){</p>
<p>getObservers().add(o);</p>
<p>}</p>
<p><strong>public default void</strong> notify(String something ){</p>
<p><strong>for</strong>( Observer l : getObservers() ){</p>
<p>l.onAction(something);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now, any class can be made "Observable" just by implementing the
Observable interface, while being free to be part of a different class
hierarchy.</p>
<p>abstract class <strong>Worker{</strong></p>
<p>public abstract void <strong>work();</strong></p>
<p>}</p>
<p><strong>public class</strong> MyWorker <strong>extends</strong>
Worker <strong>implements</strong> Observable {</p>
<p><strong>private</strong> List myObservers = <strong>new</strong>
ArrayList();</p>
<p>@Override</p>
<p><strong>public</strong> List getObservers() {</p>
<p><strong>return</strong> myObservers;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>work(){</strong></p>
<p>notify("Started work");</p>
<p>// Code goes here...</p>
<p>notify("Completed work");</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>MyWorker w = <strong>new</strong> MyWorker();</p>
<p>w.addListener(<strong>new</strong> Observer() {</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 473</p>
<p><strong>public void</strong> onAction(String a) {</p>
<p>System.out.println(a + " (" + <strong>new</strong> Date() + ")");</p>
<p>}</p>
<p>});</p>
<p>w.work();</p>
<p>}</p>
<p>}</p>
<p>Diamond problem</p>
<p>The compiler in Java 8 is aware of the <a
href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">diamond
problem</a> which is caused when a class is implementing interfaces</p>
<p>containing a method with the same signature.</p>
<p>In order to solve it, an implementing class must override the shared
method and provide its own implementation.</p>
<p><strong>interface</strong> InterfaceA {</p>
<p><strong>public default</strong> String getName(){</p>
<p>return <strong>"a";</strong></p>
<p>}</p>
<p>}</p>
<p><strong>interface</strong> InterfaceB {</p>
<p><strong>public default</strong> String getName(){</p>
<p>return <strong>"b";</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> ImpClass <strong>implements</strong>
InterfaceA, InterfaceB {</p>
<p>@Override</p>
<p><strong>public</strong> String getName() {</p>
<p>//Must provide its own implementation</p>
<p><strong>return</strong> InterfaceA.<strong>super</strong>.getName() +
InterfaceB.<strong>super</strong>.getName();</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ImpClass c = <strong>new</strong> ImpClass();</p>
<p>System.out.println( c.getName() ); <em>// Prints "ab"</em></p>
<p>System.out.println( ((InterfaceA)c).getName() ); <em>// Prints
"ab"</em> System.out.println( ((InterfaceB)c).getName() ); <em>// Prints
"ab"</em></p>
<p>}</p>
<p>}</p>
<p>There's still the issue of having methods with the same name and
parameters with different return types, which will not compile.</p>
<p>Use default methods to resolve compatibility issues</p>
<p>The default method implementations come in very handy if a method is
added to an interface in an existing system where the interfaces is used
by several classes.</p>
<p>To avoid breaking up the entire system, you can provide a default
method implementation when you add a method to an interface. This way,
the system will still compile and the actual implementations can be done
step by step.</p>
<p>For more information, see the Default Methods topic.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 474</p>
<p><span id="Section_79_6__Modifiers_in_Inter"
class="anchor"></span>Section 79.6: Modifiers in Interfaces</p>
<p>The Oracle Java Style Guide states:</p>
<p>Modifiers should not be written out when they are implicit.</p>
<p>(See Modifiers in Oracle Official Code Standard for the context and a
link to the actual Oracle document.)</p>
<p>This style guidance applies particularly to interfaces. Let's
consider the following code snippet:</p>
<p>interface <strong>I {</strong></p>
<p>public static final int <strong>VARIABLE = 0;</strong></p>
<p>public abstract void <strong>method();</strong></p>
<p><strong>public static void</strong> staticMethod() { ... }</p>
<p><strong>public default void</strong> defaultMethod() { ... }</p>
<p>}</p>
<p>Variables</p>
<p>All interface variables are implicitly <em>constants</em> with
implicit <strong>public</strong> (accessible for all),
<strong>static</strong> (are accessible by</p>
<p>interface name) and <strong>final</strong> (must be initialized
during declaration) modifiers:</p>
<p>public static final int <strong>VARIABLE = 0;</strong></p>
<p>Methods</p>
<p>1. All methods which <em>don't provide implementation</em> are
implicitly <strong>public</strong> and <strong>abstract</strong>.</p>
<p>public abstract void <strong>method();</strong></p>
<p>Version ≥ Java SE 8</p>
<p>2. All methods with <strong>static</strong> or
<strong>default</strong> modifier <em>must provide implementation</em>
and are implicitly <strong>public</strong>.</p>
<p><strong>public static void</strong> staticMethod() { ... }</p>
<p>After all of the above changes have been applied, we will get the
following:</p>
<p>interface <strong>I {</strong></p>
<p><strong>int</strong> VARIABLE = 0;</p>
<p><strong>void</strong> method();</p>
<p><strong>static void</strong> staticMethod() { ... }</p>
<p><strong>default void</strong> defaultMethod() { ... }</p>
<p>}</p>
<p>Section 79.7: Using Interfaces with Generics</p>
<p>Let's say you want to define an interface that allows publishing /
consuming data to and from different types of channels (e.g. AMQP, JMS,
etc), but you want to be able to switch out the implementation details
...</p>
<p>Let's define a basic IO interface that can be re-used across multiple
implementations:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 475</p>
<p>public interface <strong>IO {</strong></p>
<p><strong>void</strong> publish(OutgoingType data);</p>
<p>IncomingType consume();</p>
<p>IncomingType RPCSubmit(OutgoingType data);</p>
<p>}</p>
<p>Now I can instantiate that interface, but since we don't have default
implementations for those methods, it'll need</p>
<p>an implementation when we instantiate it:</p>
<p>IO mockIO = <strong>new</strong> IO() {</p>
<p><strong>private</strong> String channel = "somechannel";</p>
<p>@Override</p>
<p><strong>public void</strong> publish(String data) {</p>
<p>System.out.println("Publishing " + data + " to " + channel);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String consume() {</p>
<p>System.out.println("Consuming from " + channel);</p>
<p><strong>return</strong> "some useful data";</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String RPCSubmit(String data) {</p>
<p><strong>return</strong> "received " + data + " just now ";</p>
<p>}</p>
<p>};</p>
<p><em>mockIO.consume();</em> // prints: Consuming from somechannel</p>
<p><em>mockIO.publish("TestData");</em> // Publishing TestData to
somechannel</p>
<p>System.out.println(mockIO.RPCSubmit("TestData")); <em>// received
TestData just now</em></p>
<p>We can also do something more useful with that interface, let's say
we want to use it to wrap some basic RabbitMQ functions:</p>
<p>public class <strong>RabbitMQ</strong> implements <strong>IO
{</strong></p>
<p><strong>private</strong> String exchange;</p>
<p><strong>private</strong> String queue;</p>
<p><strong>public</strong> RabbitMQ(String exchange, String queue){</p>
<p><strong>this</strong>.exchange = exchange;</p>
<p><strong>this</strong>.queue = queue;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> publish(String data) {</p>
<p>rabbit.basicPublish(exchange, queue, data.getBytes());</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String consume() {</p>
<p><strong>return</strong> rabbit.basicConsume(exchange, queue);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 476</p>
<p>@Override</p>
<p><strong>public</strong> String RPCSubmit(String data) {</p>
<p><strong>return</strong> rabbit.rpcPublish(exchange, queue, data);</p>
<p>}</p>
<p>}</p>
<p>Let's say I want to use this IO interface now as a way to count
visits to my website since my last system restart and</p>
<p>then be able to display the total number of visits - you can do
something like this:</p>
<p><strong>import</strong> java.util.concurrent.atomic.AtomicLong;</p>
<p>public class <strong>VisitCounter</strong> implements <strong>IO
{</strong></p>
<p><strong>private static</strong> AtomicLong websiteCounter =
<strong>new</strong> AtomicLong(0);</p>
<p>@Override</p>
<p><strong>public void</strong> publish(Integer count) {</p>
<p>websiteCounter.addAndGet(count);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Long consume() {</p>
<p><strong>return</strong> websiteCounter.get();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Long RPCSubmit(Integer count) {</p>
<p><strong>return</strong> websiteCounter.addAndGet(count);</p>
<p>}</p>
<p>}</p>
<p>Now let's use the VisitCounter:</p>
<p>VisitCounter counter = <strong>new</strong> VisitCounter();</p>
<p>// just had 4 visits, yay</p>
<p>counter.publish(4);</p>
<p>// just had another visit, yay</p>
<p>counter.publish(1);</p>
<p>// get data for stats counter</p>
<p>System.out.println(counter.consume()); <em>// prints 5</em></p>
<p>// show data for stats counter page, but include that as a page view
<em>System.out.println(counter.RPCSubmit(1));</em> // prints 6</p>
<p>When implementing multiple interfaces, you can't implement the same
interface twice. That also applies to generic</p>
<p>interfaces. Thus, the following code is invalid, and will result in a
compile error:</p>
<p>interface <strong>Printer {</strong></p>
<p><strong>void</strong> print(T value);</p>
<p>}</p>
<p>// Invalid!</p>
<p><strong>class</strong> SystemPrinter <strong>implements</strong>
Printer, Printer {</p>
<p>@Override <strong>public void</strong> print(Double d){
System.out.println("Decimal: " + d); }</p>
<p>@Override <strong>public void</strong> print(Integer i){
System.out.println("Discrete: " + i); }</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 477</p>
<p><span id="_37" class="anchor"></span>}</p>
<p>Section 79.8: Strengthen bounded type parameters</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/generics/bounded.html">Bounded
type parameters</a> allow you to set restrictions on generic type
arguments:</p>
<p><strong>class</strong> SomeClass {</p>
<p>}</p>
<p><strong>class</strong> Demoextends SomeClass&gt; {</p>
<p>}</p>
<p>But a type parameter can only bind to a single class type.</p>
<p>An interface type can be bound to a type that already had a binding.
This is achieved using the &amp; symbol:</p>
<p><strong>interface</strong> SomeInterface {</p>
<p>}</p>
<p><strong>class</strong> GenericClassextends SomeClass &amp;
SomeInterface&gt; {</p>
<p>}</p>
<p>This strengthens the bind, potentially requiring type arguments to
derive from multiple types.</p>
<p>Multiple interface types can be bound to a type parameter:</p>
<p><strong>class</strong> Demoextends SomeClass &amp; FirstInterface
&amp; SecondInterface&gt; {</p>
<p>}</p>
<p><a href="https://en.wikipedia.org/wiki/Code_smell">But should be used
with caution. Multiple interface bindings is usually a sign of a code
smell</a>, suggesting that a new type should be created which acts as an
adapter for the other types:</p>
<p><strong>interface</strong> NewInterface <strong>extends</strong>
FirstInterface, SecondInterface {</p>
<p>}</p>
<p><strong>class</strong> Demoextends SomeClass &amp; NewInterface&gt;
{</p>
<p>}</p>
<p>Section 79.9: Implementing interfaces in an abstract class</p>
<p>A method defined in an <strong>interface</strong> is by default
<strong>public abstract</strong>. When an <strong>abstract
class</strong> implements an <strong>interface</strong> , any methods
which are defined in the <strong>interface</strong> do not have to be
implemented by the <strong>abstract</strong></p>
<p><strong>class</strong>. This is because a <strong>class</strong> that
is declared <strong>abstract</strong> can contain abstract method
declarations. It is therefore</p>
<p>the responsibility of the first concrete sub-class to implement any
<strong>abstract</strong> methods inherited from any interfaces and/or
the <strong>abstract class</strong>.</p>
<p>public interface <strong>NoiseMaker {</strong></p>
<p><strong>void</strong> makeNoise();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 478</p>
<p>public abstract class <strong>Animal</strong> implements
<strong>NoiseMaker {</strong></p>
<p>//Does not need to declare or implement makeNoise()
<em><strong>public abstract void</strong> eat();</em></p>
<p>}</p>
<p>//Because Dog is concrete, it must define both makeNoise() and eat()
<em><strong>public class</strong> Dog <strong>extends</strong> Animal
{</em></p>
<p>@Override</p>
<p><strong>public void</strong> makeNoise() {</p>
<p>System.out.println("Borf borf");</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>eat() {</strong></p>
<p>System.out.println("Dog eats some kibble.");</p>
<p>}</p>
<p>}</p>
<p>From Java 8 onward it is possible for an <strong>interface</strong>
to declare <strong>default</strong> implementations of methods which
means</p>
<p>the method won't be <strong>abstract</strong>, therefore any concrete
sub-classes will not be forced to implement the method but will inherit
the <strong>default</strong> implementation unless overridden.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 479</p>
<p><span id="Chapter_80__Regular_Expressions_1"
class="anchor"></span>Chapter 80: Regular Expressions</p>
<p>A regular expression is a special sequence of characters that helps
in matching or finding other strings or sets of</p>
<p>strings, using a specialized syntax held in a pattern. Java has
support for regular expression usage through the</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">java.util.regex</a>
package. This topic is to introduce and help developers understand more
with examples on how</p>
<p>Regular Expressions must be used in Java.</p>
<p>Section 80.1: Using capture groups</p>
<p>If you need to extract a part of string from the input string, we can
use <strong>capture groups</strong> of regex.</p>
<p>For this example, we'll start with a simple phone number regex:</p>
<p>\d{3}-\d{3}-\d{4}</p>
<p>If parentheses are added to the regex, each set of parentheses is
considered a <em>capturing group</em>. In this case, we are</p>
<p>using what are called numbered capture groups:</p>
<p>(\d{3})-(\d{3})-(\d{4})</p>
<p>^-----^ ^-----^ ^-----^</p>
<p>Group 1 Group 2 Group 3</p>
<p>Before we can use it in Java, we must not forget to follow the rules
of Strings, escaping the backslashes, resulting in</p>
<p>the following pattern:</p>
<p>"(<strong>\\</strong>d{3})-(<strong>\\</strong>d{3})-(<strong>\\</strong>d{4})"</p>
<p>We first need to compile the regex pattern to make a Pattern and then
we need a Matcher to match our input string with the pattern:</p>
<p>Pattern phonePattern =
Pattern.compile("(<strong>\\</strong>d{3})-(<strong>\\</strong>d{3})-(<strong>\\</strong>d{4})");
Matcher phoneMatcher = phonePattern.matcher("abcd800-555-1234wxyz");</p>
<p>Next, the Matcher needs to find the first subsequence that matches
the regex:</p>
<p>phoneMatcher.find();</p>
<p>Now, using the group method, we can extract the data from the
string:</p>
<p>String number = phoneMatcher.group(0); <em>//"800-555-1234" (Group 0
is everything the regex matched)</em> String aCode =
phoneMatcher.group(1); <em>//"800"</em></p>
<p>String threeDigit = phoneMatcher.group(2); <em>//"555"</em></p>
<p>String fourDigit = phoneMatcher.group(3); <em>//"1234"</em></p>
<p><strong>Note:</strong> Matcher.group() can be used in place of
Matcher.group(0).</p>
<p>Version ≥ Java SE 7</p>
<p>Java 7 introduced named capture groups. Named capture groups function
the same as numbered capture groups (but with a name instead of a
number), although there are slight syntax changes. Using named capture
groups</p>
<p>improves readability.</p>
<p>We can alter the above code to use named groups:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 480</p>
<p><span id="___d_3_____d_3_____d_4"
class="anchor"></span>(?\d{3})-(\d{3})-(\d{4})</p>
<p>^----------------^ ^-----^ ^-----^</p>
<p>AreaCode Group 2 Group 3</p>
<p>To get the contents of "AreaCode", we can instead use:</p>
<p>String aCode = phoneMatcher.group("AreaCode"); <em>//"800"</em></p>
<p>Section 80.2: Using regex with custom behaviour by compiling</p>
<p>the Pattern with flags</p>
<p>A Pattern can be compiled with flags, if the regex is used as a
literal String, use inline modifiers:</p>
<p>Pattern pattern = Pattern.compile("foo.", Pattern.CASE_INSENSITIVE |
Pattern.DOTALL); pattern.matcher("FOO<strong>\n</strong>").matches();
<em>// Is true.</em></p>
<p>/* Had the regex not been compiled case insensitively and
singlelined, * it would fail because FOO does not match /foo/ and \n
(newline) * does not match /./.</p>
<p>*/</p>
<p>Pattern anotherPattern = Pattern.compile("(?si)foo");
anotherPattern.matcher("FOO<strong>\n</strong>").matches(); <em>// Is
true.</em></p>
<p>"foOt".replaceAll("(?si)foo", "ca"); <em>// Returns "cat".</em></p>
<p>Section 80.3: Escape Characters</p>
<p>Generally</p>
<p>To use regular expression specific characters (?+| etc.) in their
literal meaning they need to be escaped. In common</p>
<p>regular expression this is done by a backslash \. However, as it has
a special meaning in Java Strings, you have to</p>
<p>use a double backslash \\.</p>
<p>These two examples will not work:</p>
<p><em>"???".replaceAll ("?", "!");</em>
//java.util.regex.PatternSyntaxException <em>"???".replaceAll
("<strong>\?</strong>", "!");</em> //Invalid escape sequence</p>
<p>This example works</p>
<p>"???".replaceAll ("<strong>\\</strong>?", "!"); <em>//"!!!"</em></p>
<p>Splitting a Pipe Delimited String</p>
<p>This does not return the expected result:</p>
<p>"a|b".split ("|"); <em>// [a, |, b]</em></p>
<p>This returns the expected result:</p>
<p>"a|b".split ("<strong>\\</strong>|"); <em>// [a, b]</em></p>
<p>Escaping backslash \</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 481</p>
<p><span id="This_will_give_an_error" class="anchor"></span>This will
give an error:</p>
<p><em>"<strong>\\</strong>".matches("<strong>\\</strong>");</em> //
PatternSyntaxException</p>
<p>"<strong>\\</strong>".matches("<strong>\\\"</strong>); // Syntax
Error</p>
<p>This works:</p>
<p>"<strong>\\</strong>".matches("<strong>\\\\</strong>"); <em>//
true</em></p>
<p>Section 80.4: Not matching a given string</p>
<p>To match something that does <em>not</em> contain a given string, one
can use negative lookahead:</p>
<p>Regex syntax: (?!string-to-not-match)</p>
<p>Example:</p>
<p>//not matching "popcorn"</p>
<p>String regexString = "^(?!popcorn).*$";</p>
<p>System.out.println("[popcorn] " + ("popcorn".matches(regexString) ?
"matched!" : "nope!")); System.out.println("[unicorn] " +
("unicorn".matches(regexString) ? "matched!" : "nope!"));</p>
<p>Output:</p>
<p>[popcorn] nope!</p>
<p>[unicorn] matched!</p>
<p>Section 80.5: Matching with a regex literal</p>
<p>If you need to match characters that are a part of the regular
expression syntax you can mark all or part of the</p>
<p>pattern as a regex literal.</p>
<p>\Q marks the beginning of the regex literal. \E marks the end of the
regex literal.</p>
<p>// the following throws a PatternSyntaxException because of the
un-closed bracket <em>"[123".matches("[123");</em></p>
<p>// wrapping the bracket in \Q and \E allows the pattern to match as
you would expect.
<em>"[123".matches("<strong>\\</strong>Q[<strong>\\</strong>E123");</em>
// returns true</p>
<p>An easier way of doing it without having to remember the \Q and \E
escape sequences is to use Pattern.quote()</p>
<p>"[123".matches(Pattern.quote("[") + "123"); <em>// returns
true</em></p>
<p>Section 80.6: Matching a backslash</p>
<p>If you want to match a backslash in your regular expression, you'll
have to escape it.</p>
<p>Backslash is an escape character in regular expressions. You can use
'\\' to refer to a single backslash in a regular</p>
<p>expression.</p>
<p>However, backslash is <em>also</em> an escape character in Java
literal strings. To make a regular expression from a string</p>
<p>literal, you have to escape each of <em>its</em> backslashes. In a
string literal '\\\\' can be used to create a regular expression</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 482</p>
<p>with '\\', which in turn can match '\'.</p>
<p>For example, consider matching strings like "C:\dir\myfile.txt". A
regular expression ([A-Za-z]):\\(.*) will match,</p>
<p>and provide the drive letter as a capturing group. Note the doubled
backslash.</p>
<p>To express that pattern in a Java string literal, each of the
backslashes in the regular expression needs to be</p>
<p>escaped.</p>
<p>String path =
"C:<strong>\\</strong>dir<strong>\\</strong>myfile.txt";</p>
<p>System.out.println( "Local path: " + path ); <em>//
"C:\dir\myfile.txt"</em></p>
<p>String regex = "([A-Za-z]):<strong>\\\\</strong>.*"; <em>// Four to
match one</em> System.out.println("Regex: " + regex ); <em>//
"([A-Za-z]):\\(.*)"</em></p>
<p>Pattern pattern = Pattern.compile( regex );</p>
<p>Matcher matcher = pattern.matcher( path );</p>
<p><strong>if</strong> ( matcher.matches()) {</p>
<p>System.out.println( "This path is on drive " + matcher.group( 1 ) +
":."); <em>// This path is on drive C:.</em></p>
<p>}</p>
<p>If you want to match <em>two</em> backslashes, you'll find yourself
using eight in a literal string, to represent four in the regular
expression, to match two.</p>
<p>String path =
"<strong>\\\\</strong>myhost<strong>\\</strong>share<strong>\\</strong>myfile.txt";</p>
<p>System.out.println( "UNC path: " + path ); <em>//
\\myhost\share\myfile.txt"</em></p>
<p>String regex =
"<strong>\\\\\\\\</strong>(.+?)<strong>\\\\</strong>(.*)"; <em>// Eight
to match two</em> System.out.println("Regex: " + regex ); <em>//
\\\\(.+?)\\(.*)</em></p>
<p>Pattern pattern = Pattern.compile( regex );</p>
<p>Matcher matcher = pattern.matcher( path );</p>
<p><strong>if</strong> ( matcher.matches()) {</p>
<p>System.out.println( "This path is on host '" + matcher.group( 1 ) +
"'."); <em>// This path is on host 'myhost'.</em></p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 483</p>
<p><span id="Chapter_81__Comparable_and_Compa_1"
class="anchor"></span>Chapter 81: Comparable and Comparator</p>
<p>Section 81.1: Sorting a List using Comparable&lt;T&gt; or a</p>
<p>Comparator&lt;T&gt;</p>
<p>Say we are working on a class representing a Person by their first
and last names. We have created a basic class to</p>
<p>do this and implemented proper equals and hashCode methods.</p>
<p>public class <strong>Person {</strong></p>
<p><em><strong>private final</strong> String lastName;</em> //invariant
- nonnull</p>
<p><em><strong>private final</strong> String firstName;</em> //invariant
- nonnull</p>
<p><strong>public</strong> Person(String firstName, String
lastName){</p>
<p><strong>this</strong>.firstName = firstName != <strong>null</strong>
? firstName : "";</p>
<p><strong>this</strong>.lastName = lastName != <strong>null</strong> ?
lastName : "";</p>
<p>}</p>
<p><strong>public</strong> String getFirstName() {</p>
<p><strong>return</strong> firstName;</p>
<p>}</p>
<p><strong>public</strong> String getLastName() {</p>
<p><strong>return</strong> lastName;</p>
<p>}</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> lastName + ", " + firstName;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object o) {</p>
<p>if <strong>(! (o</strong> instanceof <strong>Person))</strong> return
false<strong>;</strong></p>
<p>Person p = (Person)o;</p>
<p><strong>return</strong> firstName.equals(p.firstName) &amp;&amp;
lastName.equals(p.lastName);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong> Objects.hash(firstName, lastName);</p>
<p>}</p>
<p>}</p>
<p>Now we would like to sort a list of Person objects by their name,
such as in the following scenario:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List people = Arrays.asList(<strong>new</strong> Person("John",
"Doe"),</p>
<p><strong>new</strong> Person("Bob", "Dole"),</p>
<p><strong>new</strong> Person("Ronald", "McDonald"),</p>
<p><strong>new</strong> Person("Alice", "McDonald"),</p>
<p><strong>new</strong> Person("Jill", "Doe"));</p>
<p><em>Collections.sort(people);</em> //This currently won't work.</p>
<p>}</p>
<p>Unfortunately, as marked, the above currently won't compile.
Collections.sort(..) only knows how to sort a list</p>
<p>if the elements in that list are comparable, or a custom method of
comparison is given.</p>
<p>If you were asked to sort the following list : 1,3,5,4,2, you'd have
no problem saying the answer is 1,2,3,4,5. This</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 484</p>
<p>is because Integers (both in Java and mathematically) have a
<em>natural ordering</em>, a standard, default comparison base ordering.
To give our Person class a natural ordering, we implement Comparable,
which requires</p>
<p>implementing the method compareTo(Person p):</p>
<p>public class <strong>Person</strong> implements <strong>Comparable
{</strong></p>
<p><em><strong>private final</strong> String lastName;</em> //invariant
- nonnull</p>
<p><em><strong>private final</strong> String firstName;</em> //invariant
- nonnull</p>
<p><strong>public</strong> Person(String firstName, String lastName)
{</p>
<p><strong>this</strong>.firstName = firstName != <strong>null</strong>
? firstName : "";</p>
<p><strong>this</strong>.lastName = lastName != <strong>null</strong> ?
lastName : "";</p>
<p>}</p>
<p><strong>public</strong> String getFirstName() {</p>
<p><strong>return</strong> firstName;</p>
<p>}</p>
<p><strong>public</strong> String getLastName() {</p>
<p><strong>return</strong> lastName;</p>
<p>}</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> lastName + ", " + firstName;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object o) {</p>
<p>if <strong>(! (o</strong> instanceof <strong>Person))</strong> return
false<strong>;</strong></p>
<p>Person p = (Person)o;</p>
<p><strong>return</strong> firstName.equals(p.firstName) &amp;&amp;
lastName.equals(p.lastName);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong> Objects.hash(firstName, lastName);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> compareTo(Person other) {</p>
<p>// If this' lastName and other's lastName are not comparably
equivalent, // Compare this to other by comparing their last names. //
Otherwise, compare this to other by comparing their first names
<em><strong>int</strong> lastNameCompare =
lastName.compareTo(other.lastName); <strong>if</strong> (lastNameCompare
!= 0) {</em></p>
<p><strong>return</strong> lastNameCompare;</p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong> firstName.compareTo(other.firstName);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now, the main method given will function correctly</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List people = Arrays.asList(<strong>new</strong> Person("John",
"Doe"),</p>
<p><strong>new</strong> Person("Bob", "Dole"),</p>
<p><strong>new</strong> Person("Ronald", "McDonald"),</p>
<p><strong>new</strong> Person("Alice", "McDonald"),</p>
<p><strong>new</strong> Person("Jill", "Doe"));</p>
<p>Collections.sort(people); <em>//Now functions correctly</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 485</p>
<p>//people is now sorted by last name, then first name: // --&gt; Jill
Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald</p>
<p>}</p>
<p>If, however, you either do not want or are unable to modify class
Person, you can provide a custom Comparator that handles the comparison
of any two Person objects. If you were asked to sort the following list:
circle,</p>
<p>square, rectangle, triangle, hexagon you could not, but if you were
asked to sort that list <em>based on the number</em> <em>of
corners</em>, you could. Just so, providing a comparator instructs Java
how to compare two normally not comparable</p>
<p>objects.</p>
<p><strong>public class</strong> PersonComparator
<strong>implements</strong> Comparator {</p>
<p><strong>public int</strong> compare(Person p1, Person p2) {</p>
<p>// If p1's lastName and p2's lastName are not comparably equivalent,
// Compare p1 to p2 by comparing their last names.</p>
<p>// Otherwise, compare p1 to p2 by comparing their first names
<em><strong>if</strong> (p1.getLastName().compareTo(p2.getLastName()) !=
0) {</em></p>
<p><strong>return</strong>
p1.getLastName().compareTo(p2.getLastName());</p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong>
p1.getFirstName().compareTo(p2.getFirstName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//Assume the first version of Person (that does not implement
Comparable) is used here <em><strong>public static void</strong>
main(String[] args) {</em></p>
<p>List people = Arrays.asList(<strong>new</strong> Person("John",
"Doe"),</p>
<p><strong>new</strong> Person("Bob", "Dole"),</p>
<p><strong>new</strong> Person("Ronald", "McDonald"),</p>
<p><strong>new</strong> Person("Alice", "McDonald"),</p>
<p><strong>new</strong> Person("Jill", "Doe"));</p>
<p>Collections.sort(people); <em>//Illegal, Person doesn't implement
Comparable.</em> Collections.sort(people, <strong>new</strong>
PersonComparator()); <em>//Legal</em></p>
<p>//people is now sorted by last name, then first name: // --&gt; Jill
Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald</p>
<p>}</p>
<p>Comparators can also be created/used as an anonymous inner class</p>
<p>//Assume the first version of Person (that does not implement
Comparable) is used here <em><strong>public static void</strong>
main(String[] args) {</em></p>
<p>List people = Arrays.asList(<strong>new</strong> Person("John",
"Doe"),</p>
<p><strong>new</strong> Person("Bob", "Dole"),</p>
<p><strong>new</strong> Person("Ronald", "McDonald"),</p>
<p><strong>new</strong> Person("Alice", "McDonald"),</p>
<p><strong>new</strong> Person("Jill", "Doe"));</p>
<p><em>Collections.sort(people);</em> //Illegal, Person doesn't
implement Comparable.</p>
<p>Collections.sort(people, <strong>new</strong> PersonComparator());
<em>//Legal</em></p>
<p>//people is now sorted by last name, then first name: // --&gt; Jill
Doe, John Doe, Bob Dole, Alice McDonald, Ronald McDonald</p>
<p>//Anonymous Class</p>
<p>Collections.sort(people, <strong>new</strong> Comparator() {
<em>//Legal</em></p>
<p><strong>public int</strong> compare(Person p1, Person p2) {</p>
<p>//Method code...</p>
<p>}</p>
<p>});</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 486</p>
<p><span id="_38" class="anchor"></span>}</p>
<p>Version ≥ Java SE 8</p>
<p>Lambda expression based comparators</p>
<p>As of Java 8, comparators can also be expressed as lambda
expressions</p>
<p>//Lambda</p>
<p>Collections.sort(people, (p1, p2)-&gt; { <em>//Legal</em></p>
<p>//Method code....</p>
<p>});</p>
<p>Comparator default methods</p>
<p>Furthermore, there are interesting default methods on the Comparator
interface for building comparators : the following builds a comparator
comparing by lastName and then firstName.</p>
<p>Collections.sort(people,
Comparator.comparing(Person::getLastName)</p>
<p>.thenComparing(Person::getFirstName));</p>
<p>Inversing the order of a comparator</p>
<p>Any comparator can also easily be reversed using the reversedMethod
which will change ascending order to descending.</p>
<p>Section 81.2: The compareTo and compare Methods</p>
<p>The Comparable interface requires one method:</p>
<p>public interface <strong>Comparable {</strong></p>
<p><strong>public int</strong> compareTo(T other);</p>
<p>}</p>
<p>And the Comparator interface requires one method:</p>
<p>public interface <strong>Comparator {</strong></p>
<p><strong>public int</strong> compare(T t1, T t2);</p>
<p>}</p>
<p>These two methods do essentially the same thing, with one minor
difference: compareTo compares <strong>this</strong> to other,</p>
<p>whereas compare compares t1 to t2, not caring at all about
<strong>this</strong>.</p>
<p>Aside from that difference, the two methods have similar
requirements. Specifically (for compareTo), <a
href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Comparable.java#Comparable">Compares
this</a></p>
<p><a
href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Comparable.java#Comparable">object
with the specified object for order. Returns a negative integer, zero,
or a positive integer as this object is less</a></p>
<p><a
href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Comparable.java#Comparable">than,
equal to, or greater than the specified object. Thus, for the comparison
of</a> a and b:</p>
<p>If a &lt; b, a.compareTo(b) and compare(a,b) should return a negative
integer, and b.compareTo(a) and</p>
<p>compare(b,a) should return a positive integer</p>
<p>If a &gt; b, a.compareTo(b) and compare(a,b) should return a positive
integer, and b.compareTo(a) and</p>
<p>compare(b,a) should return a negative integer</p>
<p>If a equals b for comparison, all comparisons should return 0.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 487</p>
<p><span id="Section_81_3__Natural__comparabl"
class="anchor"></span>Section 81.3: Natural (comparable) vs explicit
(comparator)</p>
<p>sorting</p>
<p>There are two Collections.sort() methods:</p>
<p>One that takes a List as a parameter where T must implement
Comparable and override the</p>
<p>compareTo() method that determines sort order.</p>
<p>One that takes a List and a Comparator as the arguments, where the
Comparator determines the sort order.</p>
<p>First, here is a Person class that implements Comparable:</p>
<p>public class <strong>Person</strong> implements <strong>Comparable
{</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>age;</strong></p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p><strong>public int</strong> getAge() {</p>
<p>return <strong>age;</strong></p>
<p>}</p>
<p><strong>public void</strong> setAge(<strong>int</strong> age) {</p>
<p><strong>this</strong>.age = age;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> compareTo(Person o) {</p>
<p><strong>return this</strong>.getAge()- o.getAge();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return
this</strong>.getAge()+"-"+<strong>this</strong>.getName();</p>
<p>}</p>
<p>}</p>
<p>Here is how you would use the above class to sort a List in the
natural ordering of its elements, defined by the compareTo() method
override:</p>
<p>//-- usage</p>
<p>List pList = <strong>new</strong> ArrayList();</p>
<p>Person p = <strong>new</strong> Person();</p>
<p>p.setName("A");</p>
<p>p.setAge(10);</p>
<p>pList.add(p);</p>
<p>p = <strong>new</strong> Person();</p>
<p>p.setName("Z");</p>
<p>p.setAge(20);</p>
<p>pList.add(p);</p>
<p>p = <strong>new</strong> Person();</p>
<p>p.setName("D");</p>
<p>p.setAge(30);</p>
<p>pList.add(p);</p>
<p>//-- natural sorting i.e comes with object implementation, by age
<em>Collections.sort(pList);</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 488</p>
<p><span id="System_out_println_pList"
class="anchor"></span>System.out.println(pList);</p>
<p>Here is how you would use an anonymous inline Comparator to sort a
List that does not implement Comparable, or in this case, to sort a List
in an order other than the natural ordering:</p>
<p>//-- explicit sorting, define sort on another property here goes with
name <em>Collections.sort(pList, <strong>new</strong> Comparator()
{</em></p>
<p>@Override</p>
<p><strong>public int</strong> compare(Person o1, Person o2) {</p>
<p><strong>return</strong> o1.getName().compareTo(o2.getName());</p>
<p>}</p>
<p>});</p>
<p>System.out.println(pList);</p>
<p>Section 81.4: Creating a Comparator using comparing method</p>
<p>Comparator.comparing(Person::getName)</p>
<p>This creates a comparator for the class Person that uses this person
name as the comparison source. Also it is</p>
<p>possible to use method version to compare long, int and double. For
example:</p>
<p>Comparator.comparingInt(Person::getAge)</p>
<p>Reversed order</p>
<p>To create a comparator that imposes the reverse ordering use
reversed() method:</p>
<p>Comparator.comparing(Person::getName).reversed()</p>
<p>Chain of comparators</p>
<p>Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName)</p>
<p>This will create a comparator that firs compares with last name then
compares with first name. You can chain as</p>
<p>many comparators as you want.</p>
<p>Section 81.5: Sorting Map entries</p>
<p>As of Java 8, there are default methods on the Map.Entry interface to
allow sorting of map iterations.</p>
<p>Version ≥ Java SE 8</p>
<p>Map numberOfEmployees = <strong>new</strong> HashMap&lt;&gt;();
numberOfEmployees.put("executives", 10);</p>
<p>numberOfEmployees.put("human ressources", 32);</p>
<p>numberOfEmployees.put("accounting", 12);</p>
<p>numberOfEmployees.put("IT", 100);</p>
<p>// Output the smallest departement in terms of number of employees
<em>numberOfEmployees.entrySet().stream()</em></p>
<p>.sorted(Map.Entry.comparingByValue())</p>
<p>.limit(1)</p>
<p><em>.<strong>forEach</strong>(System.out::println);</em> // outputs :
executives=10</p>
<p>Of course, these can also be used outside of the stream api :</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 489</p>
<p>Version ≥ Java SE 8</p>
<p>List&gt; entries = <strong>new</strong>
ArrayList&lt;&gt;(numberOfEmployees.entrySet());
Collections.sort(entries, Map.Entry.comparingByValue());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 490</p>
<p><span id="Chapter_82__Java_Floating_Point_1"
class="anchor"></span>Chapter 82: Java Floating Point</p>
<p>Operations</p>
<p>Floating-point numbers are numbers that have fractional parts
(usually expressed with a decimal point). In Java,</p>
<p>there is two primitive types for floating-point numbers which are
<strong>float</strong> (uses 4 bytes), and <strong>double</strong> (uses
8 bytes). This documentation page is for detailing with examples
operations that can be done on floating points in Java.</p>
<p>Section 82.1: Comparing floating point values</p>
<p>You should be careful when comparing floating-point values
(<strong>float</strong> or <strong>double</strong>) using relational
operators: ==, !=, &lt; and so on. These operators give results
according to the binary representations of the floating point values.
For</p>
<p>example:</p>
<p><strong>public class</strong> CompareTest {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>double</strong> oneThird = 1.0 / 3.0;</p>
<p><strong>double</strong> one = oneThird * 3;</p>
<p>System.out.println(one == 1.0); <em>// prints "false"</em></p>
<p>}</p>
<p>}</p>
<p>The calculation oneThird has introduced a tiny rounding error, and
when we multiply oneThird by 3 we get a result</p>
<p>that is slightly different to 1.0.</p>
<p>This problem of inexact representations is more stark when we attempt
to mix <strong>double</strong> and <strong>float</strong> in
calculations.</p>
<p>For example:</p>
<p><strong>public class</strong> CompareTest2 {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>float</strong> floatVal = 0.1f;</p>
<p><strong>double</strong> doubleVal = 0.1;</p>
<p><strong>double</strong> doubleValCopy = floatVal;</p>
<p>System.out.println(floatVal); <em>// 0.1</em></p>
<p>System.out.println(doubleVal); <em>// 0.1</em></p>
<p>System.out.println(doubleValCopy); <em>//
0.10000000149011612</em></p>
<p>System.out.println(floatVal == doubleVal); <em>// false</em>
System.out.println(doubleVal == doubleValCopy); <em>// false</em></p>
<p>}</p>
<p>}</p>
<p>The floating point representations used in Java for the
<strong>float</strong> and <strong>double</strong> types have limited
number of digits of precision. For the <strong>float</strong> type, the
precision is 23 binary digits or about 8 decimal digits. For the
<strong>double</strong> type, it is 52</p>
<p>bits or about 15 decimal digits. On top of that, some arithmetical
operations will introduce rounding errors.</p>
<p>Therefore, when a program compares floating point values, it standard
practice to define an <strong>acceptable delta</strong> for</p>
<p>the comparison. If the difference between the two numbers is less
than the delta, they are deemed to be equal. For example</p>
<p><strong>if</strong> (Math.abs(v1 - v2) &lt; delta)</p>
<p>Delta compare example:</p>
<p><strong>public class</strong> DeltaCompareExample {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 491</p>
<p>private static boolean <strong>deltaCompare(</strong>double
<strong>v1,</strong> double <strong>v2,</strong> double <strong>delta)
{</strong></p>
<p>// return true iff the difference between v1 and v2 is less than
delta <em><strong>return</strong> Math.abs(v1 - v2) &lt; delta;</em></p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>double</strong>[] doubles = {1.0, 1.0001, 1.0000001,
1.000000001, 1.0000000000001}; <strong>double</strong>[] deltas = {0.01,
0.00001, 0.0000001, 0.0000000001, 0};</p>
<p>// loop through all of deltas initialized above</p>
<p><strong>for</strong> (<strong>int</strong> j = 0; j &lt;
deltas.length; j++) {</p>
<p><strong>double</strong> delta = deltas[j];</p>
<p>System.out.println("delta: " + delta);</p>
<p>// loop through all of the doubles initialized above
<em><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
doubles.length-1; i++) {</em></p>
<p><strong>double</strong> d1 = doubles[i];</p>
<p><strong>double</strong> d2 = doubles[i + 1];</p>
<p><strong>boolean</strong> result = deltaCompare(d1, d2, delta);</p>
<p>System.out.println("" + d1 + " == " + d2 + " ? " + result);</p>
<p>}</p>
<p>System.out.println();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Result:</p>
<p>delta: 0.01</p>
<p>1.0 == 1.0001 ? <strong>true</strong></p>
<p>1.0001 == 1.0000001 ? <strong>true</strong></p>
<p>1.0000001 == 1.000000001 ? <strong>true</strong></p>
<p>1.000000001 == 1.0000000000001 ? <strong>true</strong></p>
<p>delta: 1.0E-5</p>
<p>1.0 == 1.0001 ? <strong>false</strong></p>
<p>1.0001 == 1.0000001 ? <strong>false</strong></p>
<p>1.0000001 == 1.000000001 ? <strong>true</strong></p>
<p>1.000000001 == 1.0000000000001 ? <strong>true</strong></p>
<p>delta: 1.0E-7</p>
<p>1.0 == 1.0001 ? <strong>false</strong></p>
<p>1.0001 == 1.0000001 ? <strong>false</strong></p>
<p>1.0000001 == 1.000000001 ? <strong>true</strong></p>
<p>1.000000001 == 1.0000000000001 ? <strong>true</strong></p>
<p>delta: 1.0E-10</p>
<p>1.0 == 1.0001 ? <strong>false</strong></p>
<p>1.0001 == 1.0000001 ? <strong>false</strong></p>
<p>1.0000001 == 1.000000001 ? <strong>false</strong></p>
<p>1.000000001 == 1.0000000000001 ? <strong>false</strong></p>
<p>delta: 0.0</p>
<p>1.0 == 1.0001 ? <strong>false</strong></p>
<p>1.0001 == 1.0000001 ? <strong>false</strong></p>
<p>1.0000001 == 1.000000001 ? <strong>false</strong></p>
<p>1.000000001 == 1.0000000000001 ? <strong>false</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 492</p>
<p><span id="Also_for_comparison_of_double_an"
class="anchor"></span>Also for comparison of <strong>double</strong> and
<strong>float</strong> primitive types static compare method of
corresponding boxing type can be used. For example:</p>
<p><strong>double</strong> a = 1.0;</p>
<p><strong>double</strong> b = 1.0001;</p>
<p>System.out.println(Double.compare(a, b));<em>//-1</em></p>
<p>System.out.println(Double.compare(b, a));<em>//1</em></p>
<p>Finally, determining what deltas are most appropriate for a
comparison can be tricky. A commonly used approach</p>
<p>is to pick delta values that are our intuition says are about right.
However, if you know scale and (true) accuracy of the input values, and
the calculations performed, it may be possible to come up with
mathematically sound bounds</p>
<p>on the accuracy of the results, and hence for the deltas. (There is a
formal branch of Mathematics known as Numerical Analysis that used to be
taught to computational scientists that covered this kind of
analysis.)</p>
<p>Section 82.2: OverFlow and UnderFlow</p>
<p><strong>Float</strong> data type</p>
<p>The float data type is a single-precision 32-bit IEEE 754 floating
point.</p>
<p>Float overflow</p>
<p>Maximum possible value is 3.4028235e+38 , When it exceeds this value
it produces Infinity</p>
<p><strong>float</strong> f = 3.4e38f;</p>
<p><strong>float</strong> result = f*2;</p>
<p>System.out.println(result); <em>//Infinity</em></p>
<p><strong>Float</strong> UnderFlow</p>
<p>Minimum value is 1.4e-45f, when is goes below this value it produces
0.0</p>
<p><strong>float</strong> f = 1e-45f;</p>
<p><strong>float</strong> result = f/1000;</p>
<p>System.out.println(result);</p>
<p><strong>double</strong> data type</p>
<p>The double data type is a double-precision 64-bit IEEE 754 floating
point.</p>
<p><strong>Double</strong> OverFlow</p>
<p>Maximum possible value is 1.7976931348623157e+308 , When it exceeds
this value it produces Infinity</p>
<p><strong>double</strong> d = 1e308;</p>
<p><strong>double</strong> result=d*2;</p>
<p>System.out.println(result); <em>//Infinity</em></p>
<p><strong>Double</strong> UnderFlow</p>
<p>Minimum value is 4.9e-324, when is goes below this value it produces
0.0</p>
<p><strong>double</strong> d = 4.8e-323;</p>
<p><strong>double</strong> result = d/1000;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 493</p>
<p><span id="System_out_println_result_____0"
class="anchor"></span>System.out.println(result); <em>//0.0</em></p>
<p>Section 82.3: Formatting the floating point values</p>
<p>Floating point Numbers can be formatted as a decimal number using
String.format with 'f' flag</p>
<p>//Two digits in fracttional part are rounded</p>
<p>String format1 = String.format("%.2f", 1.2399);</p>
<p>System.out.println(format1); <em>// "1.24"</em></p>
<p>// three digits in fractional part are rounded</p>
<p>String format2 = String.format("%.3f", 1.2399);</p>
<p>System.out.println(format2); <em>// "1.240"</em></p>
<p>//rounded to two digits, filled with zero</p>
<p>String format3 = String.format("%.2f", 1.2);</p>
<p>System.out.println(format3); <em>// returns "1.20"</em></p>
<p>//rounder to two digits</p>
<p>String format4 = String.format("%.2f", 3.19999);</p>
<p>System.out.println(format4); <em>// "3.20"</em></p>
<p>Floating point Numbers can be formatted as a decimal number using
DecimalFormat</p>
<p>// rounded with one digit fractional part</p>
<p>String format = <strong>new</strong>
DecimalFormat("0.#").format(4.3200); System.out.println(format); <em>//
4.3</em></p>
<p>// rounded with two digit fractional part</p>
<p>String format = <strong>new</strong>
DecimalFormat("0.##").format(1.2323000); System.out.println(format);
<em>//1.23</em></p>
<p>// formatting floating numbers to decimal number</p>
<p><strong>double</strong> dv = 123456789;</p>
<p>System.out.println(dv); <em>// 1.23456789E8</em></p>
<p>String format = <strong>new</strong>
DecimalFormat("0").format(dv);</p>
<p>System.out.println(format); <em>//123456789</em></p>
<p>Section 82.4: Strict Adherence to the IEEE Specification</p>
<p>By default, floating point operations on <strong>float</strong> and
<strong>double</strong> <em>do not</em> strictly adhere to the rules of
the IEEE 754 specification. An expression is allowed to use
implementation-specific extensions to the range of these values;</p>
<p>essentially allowing them to be <em>more</em> accurate than
required.</p>
<p><strong>strictfp</strong> disables this behavior. It is applied to a
class, interface, or method, and applies to everything contained in</p>
<p>it, such as classes, interfaces, methods, constructors, variable
initializers, etc. With <strong>strictfp</strong>, the intermediate
values of a floating-point expression <em>must</em> be within the float
value set or the double value set. This causes the</p>
<p>results of such expressions to be exactly those that the IEEE 754
specification predicts.</p>
<p>All constant expressions are implicitly strict, even if they aren't
inside a <strong>strictfp</strong> scope.</p>
<p>Therefore, <strong>strictfp</strong> has the net effect of sometimes
making certain corner case computations <em>less</em> accurate, and can
also make floating point operations <em>slower</em> (as the CPU is now
doing more work to ensure any native extra</p>
<p>precision does not affect the result). However, it also causes the
results to be exactly the same on all platforms. It is therefore useful
in things like scientific programs, where reproducibility is more
important than speed.</p>
<p><em><strong>public class StrictFP</strong> {</em> // No strictfp
-&gt; default lenient</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 494</p>
<p>public strictfp float <strong>strict(</strong>float <strong>input)
{</strong></p>
<p><em><strong>return</strong> input * input / 3.4f;</em> // Strictly
adheres to the spec.</p>
<p>// May be less accurate and may be slower.</p>
<p>}</p>
<p><strong>public float</strong> lenient(<strong>float</strong> input)
{</p>
<p><em><strong>return</strong> input * input / 3.4f;</em> // Can
sometimes be more accurate and faster,</p>
<p>// but results may not be reproducable.</p>
<p>}</p>
<p><em><strong>public static final strictfp class</strong> Ops {</em> //
strictfp affects all enclosed entities</p>
<p><strong>private</strong> StrictOps() {}</p>
<p><strong>public static</strong> div(<strong>double</strong> dividend,
<strong>double</strong> divisor) { <em>// implicitly strictfp</em></p>
<p><strong>return</strong> dividend / divisor;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 495</p>
<p><span id="Chapter_83__Currency_and_Money_1"
class="anchor"></span>Chapter 83: Currency and Money</p>
<p>Section 83.1: Add custom currency</p>
<p>Required JARs on classpath:</p>
<p>javax.money:money-api:1.0 (JSR354 money and currency api)</p>
<p>org.javamoney:moneta:1.0 (Reference implementation)</p>
<p>javax:annotation-api:1.2. (Common annotations used by reference
implementation)</p>
<p>// Let's create non-ISO currency, such as bitcoin</p>
<p><em>// At first, this will throw UnknownCurrencyException</em>
MonetaryAmount moneys = Money.of(<strong>new</strong> BigDecimal("0.1"),
"BTC");</p>
<p>// This happens because bitcoin is unknown to default currency //
providers</p>
<p>System.out.println(Monetary.isCurrencyAvailable("BTC")); <em>//
false</em></p>
<p>// We will build new currency using CurrencyUnitBuilder provided by
org.javamoney.moneta <em>CurrencyUnit bitcoin =
CurrencyUnitBuilder</em></p>
<p><em>.of("BTC", "BtcCurrencyProvider")</em> // Set currency code and
currency provider name</p>
<p><em>.setDefaultFractionDigits(2)</em> // Set default fraction
digits</p>
<p><em>.build(<strong>true</strong>);</em> // Build new currency unit.
Here 'true' means</p>
<p>// currency unit is to be registered and</p>
<p>// accessible within default monetary context</p>
<p>// Now BTC is available</p>
<p>System.out.println(Monetary.isCurrencyAvailable("BTC")); <em>//
True</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 496</p>
<p><span id="Chapter_84__Object_Cloning_1" class="anchor"></span>Chapter
84: Object Cloning</p>
<p>Section 84.1: Cloning performing a deep copy</p>
<p><a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy">To
copy nested objects, a deep copy</a> must be performed, as shown in this
example.</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p>public class <strong>Sheep</strong> implements <strong>Cloneable
{</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>weight;</strong></p>
<p><strong>private</strong> List children;</p>
<p><strong>public</strong> Sheep(String name, <strong>int</strong>
weight) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.weight = weight;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Object clone() <strong>throws</strong>
CloneNotSupportedException { Sheep clone = (Sheep)
<strong>super</strong>.clone();</p>
<p><strong>if</strong> (children != <strong>null</strong>) {</p>
<p>// make a deep copy of the children</p>
<p>List cloneChildren = <strong>new</strong>
ArrayList&lt;&gt;(children.size());</p>
<p><strong>for</strong> (Sheep child : children) {</p>
<p>cloneChildren.add((Sheep) child.clone());</p>
<p>}</p>
<p>clone.setChildren(cloneChildren);</p>
<p>}</p>
<p><strong>return</strong> clone;</p>
<p>}</p>
<p><strong>public</strong> List getChildren() {</p>
<p><strong>return</strong> children;</p>
<p>}</p>
<p><strong>public void</strong> setChildren(List children) {</p>
<p><strong>this</strong>.children = children;</p>
<p>}</p>
<p>}</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p><strong>import</strong> java.util.List;</p>
<p>// create a sheep</p>
<p>Sheep sheep = <strong>new</strong> Sheep("Dolly", 20);</p>
<p>// create children</p>
<p>Sheep child1 = <strong>new</strong> Sheep("Child1", 4);</p>
<p>Sheep child2 = <strong>new</strong> Sheep("Child2", 5);</p>
<p>sheep.setChildren(Arrays.asList(child1, child2));</p>
<p>// clone the sheep</p>
<p>Sheep dolly = (Sheep) sheep.clone();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 497</p>
<p><span id="List_sheepChildren___sheep_getCh"
class="anchor"></span>List sheepChildren = sheep.getChildren();</p>
<p>List dollysChildren = dolly.getChildren();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
sheepChildren.size(); i++) {</p>
<p><em>// prints false, both arrays contain copies of the objects
inside</em> System.out.println(sheepChildren.get(i) ==
dollysChildren.get(i));</p>
<p>}</p>
<p>Section 84.2: Cloning using a copy factory</p>
<p>public class <strong>Sheep {</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>weight;</strong></p>
<p><strong>public</strong> Sheep(String name, <strong>int</strong>
weight) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.weight = weight;</p>
<p>}</p>
<p><strong>public static</strong> Sheep newInstance(Sheep other);</p>
<p><strong>return new</strong> Sheep(other.name, other.weight)</p>
<p>}</p>
<p>}</p>
<p>Section 84.3: Cloning using a copy constructor</p>
<p>An easy way to clone an object is by implementing a copy
constructor.</p>
<p>public class <strong>Sheep {</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>weight;</strong></p>
<p><strong>public</strong> Sheep(String name, <strong>int</strong>
weight) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.weight = weight;</p>
<p>}</p>
<p>// copy constructor</p>
<p>// copies the fields of other into the new object</p>
<p><strong>public</strong> Sheep(Sheep other) {</p>
<p><strong>this</strong>.name = other.name;</p>
<p><strong>this</strong>.weight = other.weight;</p>
<p>}</p>
<p>}</p>
<p>// create a sheep</p>
<p>Sheep sheep = <strong>new</strong> Sheep("Dolly", 20);</p>
<p>// clone the sheep</p>
<p><em>Sheep dolly = <strong>new</strong> Sheep(sheep);</em> //
dolly.name is "Dolly" and dolly.weight is 20</p>
<p>Section 84.4: Cloning by implementing Clonable interface</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html">Cloning
an object by implementing the Cloneable interface.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 498</p>
<p><span id="public_class_Sheep_implements_Cl"
class="anchor"></span>public class <strong>Sheep</strong> implements
<strong>Cloneable {</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>weight;</strong></p>
<p><strong>public</strong> Sheep(String name, <strong>int</strong>
weight) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.weight = weight;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Object clone() <strong>throws</strong>
CloneNotSupportedException {</p>
<p>return super<strong>.clone();</strong></p>
<p>}</p>
<p>}</p>
<p>// create a sheep</p>
<p>Sheep sheep = <strong>new</strong> Sheep("Dolly", 20);</p>
<p>// clone the sheep</p>
<p><em>Sheep dolly = (Sheep) sheep.clone();</em> // dolly.name is
"Dolly" and dolly.weight is 20</p>
<p>Section 84.5: Cloning performing a shallow copy</p>
<p><a
href="https://en.wikipedia.org/wiki/Object_copying#Shallow_copy">Default
behavior when cloning an object is to perform a shallow copy</a> of the
object's fields. In that case, both the</p>
<p>original object and the cloned object, hold references to the same
objects.</p>
<p>This example shows that behavior.</p>
<p><strong>import</strong> java.util.List;</p>
<p>public class <strong>Sheep</strong> implements <strong>Cloneable
{</strong></p>
<p><strong>private</strong> String name;</p>
<p>private int <strong>weight;</strong></p>
<p><strong>private</strong> List children;</p>
<p><strong>public</strong> Sheep(String name, <strong>int</strong>
weight) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.weight = weight;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Object clone() <strong>throws</strong>
CloneNotSupportedException {</p>
<p>return super<strong>.clone();</strong></p>
<p>}</p>
<p><strong>public</strong> List getChildren() {</p>
<p><strong>return</strong> children;</p>
<p>}</p>
<p><strong>public void</strong> setChildren(List children) {</p>
<p><strong>this</strong>.children = children;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 499</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p><strong>import</strong> java.util.List;</p>
<p>// create a sheep</p>
<p>Sheep sheep = <strong>new</strong> Sheep("Dolly", 20);</p>
<p>// create children</p>
<p>Sheep child1 = <strong>new</strong> Sheep("Child1", 4);</p>
<p>Sheep child2 = <strong>new</strong> Sheep("Child2", 5);</p>
<p>sheep.setChildren(Arrays.asList(child1, child2));</p>
<p>// clone the sheep</p>
<p>Sheep dolly = (Sheep) sheep.clone();</p>
<p>List sheepChildren = sheep.getChildren();</p>
<p>List dollysChildren = dolly.getChildren();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
sheepChildren.size(); i++) {</p>
<p><em>// prints true, both arrays contain the same objects</em>
System.out.println(sheepChildren.get(i) == dollysChildren.get(i));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 500</p>
<p><span id="Chapter_85__Recursion_1" class="anchor"></span>Chapter 85:
Recursion</p>
<p>Recursion occurs when a method calls itself. Such a method is called
<strong>recursive</strong>. A recursive method may be more</p>
<p>concise than an equivalent non-recursive approach. However, for deep
recursion, sometimes an iterative solution</p>
<p>can consume less of a thread's finite stack space.</p>
<p>This topic includes examples of recursion in Java.</p>
<p>Section 85.1: The basic idea of recursion</p>
<p>What is recursion:</p>
<p>In general, recursion is when a function invokes itself, either
directly or indirectly. For example:</p>
<p>// This method calls itself "infinitely"</p>
<p><strong>public void</strong> useless() {</p>
<p><em>useless();</em> // method calls itself (directly)</p>
<p>}</p>
<p>Conditions for applying recursion to a problem:</p>
<p>There are two preconditions for using recursive functions to solving
a specific problem:</p>
<p>1. There must be a base condition for the problem, which will be the
endpoint for the recursion. When a</p>
<p>recursive function reaches the base condition, it makes no further
(deeper) recursive calls.</p>
<p>2. Each level of recursion should be attempting a smaller problem.
The recursive function thus divides the</p>
<p>problem into smaller and smaller parts. Assuming that the problem is
finite, this will ensure that the</p>
<p>recursion terminates.</p>
<p>In Java there is a third precondition: it should not be necessary to
recurse too deeply to solve the problem; see Deep recursion is
problematic in Java</p>
<p>Example</p>
<p>The following function calculates factorials using recursion. Notice
how the method factorial calls itself within the function. Each time it
calls itself, it reduces the parameter n by 1. When n reaches 1 (the
base condition) the</p>
<p>function will recurse no deeper.</p>
<p><strong>public int</strong> factorial(<strong>int</strong> n) {</p>
<p><em><strong>if</strong> (n &lt;= 1) {</em> // the base condition</p>
<p>return <strong>1;</strong></p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong> n * factorial(n -1);</p>
<p>}</p>
<p>}</p>
<p>This is not a practical way of computing factorials in Java, since it
does not take account of integer overflow, or call</p>
<p>stack overflow (i.e. StackOverflowError exceptions) for large values
of n.</p>
<p>Section 85.2: Deep recursion is problematic in Java</p>
<p>Consider the following naive method for adding two positive numbers
using recursion:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 501</p>
<p>public static int <strong>add(</strong>int <strong>a,</strong> int
<strong>b) {</strong></p>
<p><strong>if</strong> (a == 0) {</p>
<p>return <strong>b;</strong></p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong> add(a -1, b + 1); <em>// TAIL CALL</em></p>
<p>}</p>
<p>}</p>
<p>This is algorithmically correct, but it has a major problem. If you
call add with a large a, it will crash with a</p>
<p>StackOverflowError , on any version of Java up to (at least) Java
9.</p>
<p>In a typical functional programming language (and many other
languages) the compiler optimizes tail recursion.</p>
<p>The compiler would notice that the call to add (at the tagged line)
is a <a href="https://en.wikipedia.org/wiki/Tail_call">tail call, and
would effectively rewrite the</a> recursion as a loop. This
transformation is called tail-call elimination.</p>
<p>However, current generation Java compilers do not perform tail call
elimination. (This is not a simple oversight. There are substantial
technical reasons for this; see below.) Instead, each recursive call of
add causes a new frame</p>
<p>to be allocated on the thread's stack. For example, if you call
add(1000, 1), it will take 1000 recursive calls to arrive at the answer
1001.</p>
<p>The problem is that the size of Java thread stack is fixed when the
thread is created. (This includes the "main" thread in a single-threaded
program.) If too many stack frames are allocated the stack will
overflow. The JVM will</p>
<p>detect this and throw a StackOverflowError.</p>
<p>One approach to dealing with this is to simply use a bigger stack.
There are JVM options that control the default size</p>
<p>of a stack, and you can also specify the stack size as a Thread
constructor parameter. Unfortunately, this only "puts off" the stack
overflow. If you need to do a computation that requires an even larger
stack, then the</p>
<p>StackOverflowError comes back.</p>
<p>The real solution is to identify recursive algorithms where deep
recursion is likely, and <em>manually</em> perform the tail-call</p>
<p>optimization at the source code level. For example, our add method
can be rewritten as follows:</p>
<p>public static int <strong>add(</strong>int <strong>a,</strong> int
<strong>b) {</strong></p>
<p><strong>while</strong> (a != 0) {</p>
<p>a = a -1;</p>
<p>b = b + 1;</p>
<p>}</p>
<p>return <strong>b;</strong></p>
<p>}</p>
<p>(Obviously, there are better ways to add two integers. The above is
simply to illustrate the effect of manual tail-call</p>
<p>elimination.)</p>
<p>Why tail-call elimination is not implemented in Java (yet)</p>
<p>There are a number of reasons why adding tail call elimination to
Java is not easy. For example:</p>
<p>Some code could rely on StackOverflowError to (for example) place a
bound on the size of a computational problem.</p>
<p>Sandbox security managers often rely on analyzing the call stack when
deciding whether to allow non-privileged code to perform a privileged
action.</p>
<p>As John Rose explains in <a
href="https://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm">"Tail
calls in the VM"</a>:</p>
<p>"The effects of removing the caller<em>’</em>s stack frame are
visible to some APIs, notably access control checks and</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 502</p>
<p><span id="stack_tracing__It_is_as_if_the_c"
class="anchor"></span>stack tracing. It is as if the caller<em>’</em>s
caller had directly called the callee. Any privileges possessed by the
caller are</p>
<p>discarded after control is transferred to the callee. However, the
linkage and accessibility of the callee method are computed before the
transfer of control, and take into account the tail-calling caller."</p>
<p>In other words, tail-call elimination could cause an access control
method to mistakenly think that a security</p>
<p>sensitive API was was being called by trusted code.</p>
<p>Section 85.3: Types of Recursion</p>
<p>Recursion can be categorized as either <strong>Head
Recursion</strong> or <strong>Tail Recursion</strong>, depending on
where the recursive</p>
<p>method call is placed.</p>
<p>In <strong>head recursion</strong>, the recursive call, when it
happens, comes before other processing in the function (think of it</p>
<p>happening at the top, or head, of the function).</p>
<p>In <strong>tail recursion</strong>, it’s the opposite—the processing
occurs before the recursive call. Choosing between the two</p>
<p>recursive styles may seem arbitrary, but the choice can make all the
difference.</p>
<p>A function with a path with a single recursive call at the beginning
of the path uses what is called head recursion.</p>
<p>The factorial function of a previous exhibit uses head recursion. The
first thing it does once it determines that recursion is needed is to
call itself with the decremented parameter. A function with a single
recursive call at the</p>
<p>end of a path is using tail recursion.</p>
<p>public void <strong>tail(</strong>int <strong>n)</strong> public void
<strong>head(</strong>int <strong>n)</strong></p>
<p>{ {</p>
<p><strong>if</strong>(n == 1) <strong>if</strong>(n == 0)</p>
<p>return<strong>;</strong> return<strong>;</strong></p>
<p>else else</p>
<p>System.out.println(n); head(n-1);</p>
<p>tail(n-1); System.out.println(n);</p>
<p>} }</p>
<p>If the recursive call occurs at the end of a method, it is called a
tail recursion. The tail recursion is similar to a loop. The method
executes all the statements before jumping into the next recursive
call.</p>
<p>If the recursive call occurs at the beginning of a method, it is
called a head recursion. The method saves</p>
<p>the state before jumping into the next recursive call.</p>
<p><strong>Reference:</strong> <a
href="http://stackoverflow.com/questions/21426688/the-difference-between-head-tail-recursion">The
difference between head &amp; tail recursion</a></p>
<p>Section 85.4: Computing the Nth Fibonacci Number</p>
<p>The following method computes the Nth Fibonacci number using
recursion.</p>
<p>public int <strong>fib(</strong>final int <strong>n) {</strong></p>
<p><strong>if</strong> (n &gt; 2) {</p>
<p><strong>return</strong> fib(n -2) + fib(n -1);</p>
<p>}</p>
<p>return <strong>1;</strong></p>
<p>}</p>
<p>The method implements a base case (n &lt;= 2) and a recursive case
(n&gt;2). This illustrates the use of recursion to compute a recursive
relation.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 503</p>
<p><span id="However__while_this_example_is_i"
class="anchor"></span>However, while this example is illustrative, it is
also inefficient: each single instance of the method will call the
function itself twice, leading to an exponential growth in the number of
times the function is called as N increases.</p>
<p>The above function is O(2N), but an equivalent iterative solution has
complexity O(N). In addition, there is a "closed</p>
<p>form" expression that can be evaluated in O(N) floating-point
multiplications.</p>
<p>Section 85.5: StackOverflowError &amp; recursion to loop</p>
<p>If a recursive call goes "too deep", this results in a
StackOverflowError. Java allocates a new frame for every method call on
its thread's stack. However, the space of each thread's stack is
limited. Too many frames on the</p>
<p>stack leads to the Stack Overflow (SO).</p>
<p>Example</p>
<p>public static void <strong>recursion(</strong>int <strong>depth)
{</strong></p>
<p><strong>if</strong> (depth &gt; 0) {</p>
<p>recursion(depth-1);</p>
<p>}</p>
<p>}</p>
<p>Calling this method with large parameters (e.g. recursion(50000)
probably will result in a stack overflow. The exact</p>
<p>value depends on the thread stack size, which in turn depends on the
thread construction, command-line parameters such as -Xss, or the
default size for the JVM.</p>
<p>Workaround</p>
<p>A recursion can be converted to a loop by storing the data for each
recursive call in a data structure. This data structure can be stored on
the heap rather than on the thread stack.</p>
<p>In general the data required to restore the state of a method
invocation can be stored in a stack and a while loop can be used to
"simulate" the recursive calls. Data that may be required include:</p>
<p>the object the method was called for (instance methods only)</p>
<p>the method parameters</p>
<p>local variables</p>
<p>the current position in the execution or the method</p>
<p>Example</p>
<p>The following class allows recursive of a tree structure printing up
to a specified depth.</p>
<p>public class <strong>Node {</strong></p>
<p>public int <strong>data;</strong></p>
<p><strong>public</strong> Node left;</p>
<p><strong>public</strong> Node right;</p>
<p><strong>public</strong> Node(<strong>int</strong> data) {</p>
<p>this<strong>(data,</strong> null<strong>,</strong>
null<strong>);</strong></p>
<p>}</p>
<p><strong>public</strong> Node(<strong>int</strong> data, Node left,
Node right) {</p>
<p><strong>this</strong>.data = data;</p>
<p><strong>this</strong>.left = left;</p>
<p><strong>this</strong>.right = right;</p>
<p>}</p>
<p>public void <strong>print(</strong>final int <strong>maxDepth)
{</strong></p>
<p><strong>if</strong> (maxDepth &lt;= 0) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 504</p>
<p>System.out.print("(...)");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.print("(");</p>
<p><strong>if</strong> (left != <strong>null</strong>) {</p>
<p>left.print(maxDepth-1);</p>
<p>}</p>
<p>System.out.print(data);</p>
<p><strong>if</strong> (right != <strong>null</strong>) {</p>
<p>right.print(maxDepth-1);</p>
<p>}</p>
<p>System.out.print(")");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>e.g.</p>
<p>Node n = <strong>new</strong> Node(10, <strong>new</strong> Node(20,
<strong>new</strong> Node(50), <strong>new</strong> Node(1)),
<strong>new</strong> Node(30, <strong>new</strong> Node(42),
<strong>null</strong>)); n.print(2);</p>
<p>System.out.println();</p>
<p>Prints</p>
<p>(((...)20(...))10((...)30))</p>
<p>This could be converted to the following loop:</p>
<p>public class <strong>Frame {</strong></p>
<p>public final <strong>Node node;</strong></p>
<p>// 0: before printing anything</p>
<p>// 1: before printing data</p>
<p>// 2: before printing ")"</p>
<p><strong>public int</strong> state = 0;</p>
<p>public final int <strong>maxDepth;</strong></p>
<p><strong>public</strong> Frame(Node node, <strong>int</strong>
maxDepth) {</p>
<p><strong>this</strong>.node = node;</p>
<p><strong>this</strong>.maxDepth = maxDepth;</p>
<p>}</p>
<p>}</p>
<p>List stack = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><em>stack.add(<strong>new</strong> Frame(n, 2));</em> // first frame
= initial call</p>
<p><strong>while</strong> (!stack.isEmpty()) {</p>
<p>// get topmost stack element</p>
<p><strong>int</strong> index = stack.size()-1;</p>
<p>Frame frame = stack.get(index); <em>// get topmost frame</em>
<strong>if</strong> (frame.maxDepth &lt;= 0) {</p>
<p>// termial case (too deep)</p>
<p>System.out.print("(...)");</p>
<p>stack.remove(index); <em>// drop frame</em></p>
<p>} <strong>else</strong> {</p>
<p><strong>switch</strong> (frame.state) {</p>
<p>case <strong>0:</strong></p>
<p>frame.state++;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 505</p>
<p><span id="___do_everything_done_before_the" class="anchor"></span>//
do everything done before the first recursive call
<em>System.out.print("(");</em></p>
<p><strong>if</strong> (frame.node.left != <strong>null</strong>) {</p>
<p>// add new frame (recursive call to left and stop)</p>
<p>stack.add(<strong>new</strong> Frame(frame.node.left,
frame.maxDepth-1));</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>case <strong>1:</strong></p>
<p>frame.state++;</p>
<p>// do everything done before the second recursive call
<em>System.out.print(frame.node.data);</em></p>
<p><strong>if</strong> (frame.node.right != <strong>null</strong>) {</p>
<p>// add new frame (recursive call to right and stop)</p>
<p>stack.add(<strong>new</strong> Frame(frame.node.right,
frame.maxDepth-1));</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>case <strong>2:</strong></p>
<p>// do everything after the second recursive call &amp; drop frame
<em>System.out.print(")");</em></p>
<p>stack.remove(index);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>System.out.println();</p>
<p><strong>Note:</strong> This is just an example of the general
approach. Often you can come up with a much better way to represent</p>
<p>a frame and/or store the frame data.</p>
<p>Section 85.6: Computing the Nth power of a number</p>
<p>The following method computes the value of num raised to the power of
exp using recursion:</p>
<p>public long <strong>power(</strong>final int <strong>num,</strong>
final int <strong>exp) {</strong></p>
<p><strong>if</strong> (exp == 0) {</p>
<p>return <strong>1;</strong></p>
<p>}</p>
<p><strong>if</strong> (exp == 1) {</p>
<p>return <strong>num;</strong></p>
<p>}</p>
<p><strong>return</strong> num * power(num, exp -1);</p>
<p>}</p>
<p>This illustrates the principles mentioned above: the recursive method
implements a base case (two cases, n = 0 and</p>
<p>n = 1) that terminates the recursion, and a recursive case that calls
the method again. This method is O(N) and can be reduced to a simple
loop using tail-call optimization.</p>
<p>Section 85.7: Traversing a Tree data structure with recursion</p>
<p>Consider the Node class having 3 members data, left child pointer and
right child pointer like below.</p>
<p>public class <strong>Node {</strong></p>
<p>public int <strong>data;</strong></p>
<p><strong>public</strong> Node left;</p>
<p><strong>public</strong> Node right;</p>
<p><strong>public</strong> Node(<strong>int</strong> data){</p>
<p><strong>this</strong>.data = data;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 506</p>
<p><span id="_39" class="anchor"></span>}</p>
<p>We can traverse the tree constructed by connecting multiple Node
class's object like below, the traversal is called in-order traversal of
tree.</p>
<p><strong>public static void</strong> inOrderTraversal(Node root) {</p>
<p><strong>if</strong> (root != <strong>null</strong>) {</p>
<p>inOrderTraversal(root.left); <em>// traverse left sub tree</em></p>
<p>System.out.print(root.data + " "); <em>// traverse current
node</em></p>
<p>inOrderTraversal(root.right); <em>// traverse right sub tree</em></p>
<p>}</p>
<p>}</p>
<p>As demonstrated above, using <strong>recursion</strong> we can
traverse the <strong>tree data structure</strong> without using any
other data</p>
<p>structure which is not possible with the <strong>iterative</strong>
approach.</p>
<p>Section 85.8: Reverse a string using Recursion</p>
<p>Below is a recursive code to reverse a string</p>
<p>/**</p>
<p>* Just a snippet to explain the idea of recursion</p>
<p>*</p>
<p>**/</p>
<p>public class <strong>Reverse {</strong></p>
<p><strong>public static void</strong> main (String args[]) {</p>
<p>String string = "hello world";</p>
<p>System.out.println(reverse(string)); <em>//prints dlrow
olleh</em></p>
<p>}</p>
<p><strong>public static</strong> String reverse(String s) {</p>
<p><strong>if</strong> (s.length() == 1) {</p>
<p>return <strong>s;</strong></p>
<p>}</p>
<p><strong>return</strong> reverse(s.substring(1)) + s.charAt(0);</p>
<p>}</p>
<p>}</p>
<p>Section 85.9: Computing the sum of integers from 1 to N</p>
<p>The following method computes the sum of integers from 0 to N using
recursion.</p>
<p>public int <strong>sum(</strong>final int <strong>n) {</strong></p>
<p><strong>if</strong> (n &gt; 0) {</p>
<p><strong>return</strong> n + sum(n -1);</p>
<p>} <strong>else</strong> {</p>
<p>return <strong>n;</strong></p>
<p>}</p>
<p>}</p>
<p>This method is O(N) and can be reduced to a simple loop using
tail-call optimization. In fact there is a <em>closed form</em></p>
<p>expression that computes the sum in O(1) operations.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 507</p>
<p><span id="Chapter_86__Converting_to_and_fr_1"
class="anchor"></span>Chapter 86: Converting to and from</p>
<p>Strings</p>
<p>Section 86.1: Converting String to other datatypes</p>
<p>You can convert a <strong>numeric</strong> string to various Java
numeric types as follows:</p>
<p>String to int:</p>
<p>String number = "12";</p>
<p><strong>int</strong> num = Integer.parseInt(number);</p>
<p>String to float:</p>
<p>String number = "12.0";</p>
<p><strong>float</strong> num = Float.parseFloat(number);</p>
<p>String to double:</p>
<p>String <strong>double</strong> = "1.47";</p>
<p><strong>double</strong> num =
Double.parseDouble(<strong>double</strong>);</p>
<p>String to boolean:</p>
<p>String falseString = "False";</p>
<p><strong>boolean</strong> falseBool =
Boolean.parseBoolean(falseString); <em>// falseBool = false</em></p>
<p>String trueString = "True";</p>
<p><strong>boolean</strong> trueBool = Boolean.parseBoolean(trueString);
<em>// trueBool = true</em></p>
<p>String to long:</p>
<p>String number = "47";</p>
<p><strong>long</strong> num = Long.parseLong(number);</p>
<p>String to BigInteger:</p>
<p>String bigNumber = "21";</p>
<p>BigInteger reallyBig = <strong>new</strong>
BigInteger(bigNumber);</p>
<p>String to BigDecimal:</p>
<p>String bigFraction = "17.21455";</p>
<p>BigDecimal reallyBig = <strong>new</strong>
BigDecimal(bigFraction);</p>
<p>Conversion Exceptions:</p>
<p>The numeric conversions above will all throw an (unchecked)
NumberFormatException if you attempt to parse a string that is not a
suitably formatted number, or is out of range for the target type. The
Exceptions topic discusses</p>
<p>how to deal with such exceptions.</p>
<p>If you wanted to test that you can parse a string, you could
implement a tryParse... method like this:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 508</p>
<p><span id="boolean_tryParseInt__String_valu"
class="anchor"></span><strong>boolean</strong> tryParseInt (String
value) {</p>
<p>try <strong>{</strong></p>
<p>String somechar = Integer.parseInt(value);</p>
<p>return true<strong>;</strong></p>
<p>} <strong>catch</strong> (NumberFormatException e) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>However, calling this tryParse... method immediately before parsing
is (arguably) poor practice. It would be better to just call the
parse... method and deal with the exception.</p>
<p>Section 86.2: Conversion to / from bytes</p>
<p>To encode a string into a byte array, you can simply use the
String#getBytes() method, with one of the standard character sets
available on any Java runtime:</p>
<p><strong>byte</strong>[] bytes =
"test".getBytes(StandardCharsets.UTF_8);</p>
<p>and to decode:</p>
<p>String testString = <strong>new</strong> String(bytes,
StandardCharsets.UTF_8);</p>
<p>you can further simplify the call by using a static import:</p>
<p><strong>import</strong> static
java.nio.charset.StandardCharsets.UTF_8; ...</p>
<p><strong>byte</strong>[] bytes = "test".getBytes(UTF_8);</p>
<p>For less common character sets you can indicate the character set
with a string:</p>
<p><strong>byte</strong>[] bytes = "test".getBytes("UTF-8");</p>
<p>and the reverse:</p>
<p>String testString = <strong>new</strong> String (bytes, "UTF-8");</p>
<p>this does however mean that you have to handle the checked
UnsupportedCharsetException.</p>
<p>The following call will use the default character set. The default
character set is platform specific and generally differs between
Windows, Mac and Linux platforms.</p>
<p><strong>byte</strong>[] bytes = "test".getBytes();</p>
<p>and the reverse:</p>
<p>String testString = <strong>new</strong> String(bytes);</p>
<p>Note that invalid characters and bytes may be replaced or skipped by
these methods. For more control - for</p>
<p>instance for validating input - you're encouraged to use the
CharsetEncoder and CharsetDecoder classes.</p>
<p>Section 86.3: Base64 Encoding / Decoding</p>
<p>Occasionally you will find the need to encode binary data as a <a
href="https://it.wikipedia.org/wiki/Base64"><em>base64</em></a>-encoded
string.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 509</p>
<p><span id="For_this_we_can_use_the_Datatype" class="anchor"></span>For
this we can use the <a
href="https://docs.oracle.com/javase/7/docs/api/javax/xml/bind/DatatypeConverter.html">DatatypeConverter</a>
class from the <a
href="https://docs.oracle.com/javase/7/docs/api/javax/xml/bind/package-summary.html">javax.xml.bind</a>
package:</p>
<p><strong>import</strong> javax.xml.bind.DatatypeConverter;</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p>// arbitrary binary data specified as a byte array</p>
<p><strong>byte</strong>[] binaryData = "some arbitrary
data".getBytes("UTF-8");</p>
<p>// convert the binary data to the base64-encoded string <em>String
encodedData = DatatypeConverter.printBase64Binary(binaryData);</em> //
encodedData is now "c29tZSBhcmJpdHJhcnkgZGF0YQ=="</p>
<p><em>// convert the base64-encoded string back to a byte array</em>
<strong>byte</strong>[] decodedData =
DatatypeConverter.parseBase64Binary(encodedData);</p>
<p>// assert that the original data and the decoded data are equal
<em><strong>assert</strong> Arrays.equals(binaryData,
decodedData);</em></p>
<p>Apache commons-codec</p>
<p>Alternatively, we can use Base64 <a
href="http://commons.apache.org/proper/commons-codec/">from Apache
commons-codec</a>.</p>
<p><strong>import</strong> org.apache.commons.codec.binary.Base64;</p>
<p>// your blob of binary as a byte array</p>
<p><strong>byte</strong>[] blob = "someBinaryData".getBytes();</p>
<p>// use the Base64 class to encode</p>
<p>String binaryAsAString = Base64.encodeBase64String(blob);</p>
<p>// use the Base64 class to decode</p>
<p><strong>byte</strong>[] blob2 =
Base64.decodeBase64(binaryAsAString);</p>
<p>// assert that the two blobs are equal</p>
<p>System.out.println("Equal : " + Boolean.toString(Arrays.equals(blob,
blob2)));</p>
<p>If you inspect this program wile running, you will see that
someBinaryData encodes to c29tZUJpbmFyeURhdGE=, a very managable
<em>UTF-8</em> String object.</p>
<p>Version ≥ Java SE 8</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/Base64.html">Details
for the same can be found at Base64</a></p>
<p>// encode with padding</p>
<p>String encoded =
Base64.getEncoder().encodeToString(someByteArray);</p>
<p>// encode without padding</p>
<p>String encoded =
Base64.getEncoder().withoutPadding().encodeToString(someByteArray);</p>
<p>// decode a String</p>
<p><strong>byte</strong> [] barr =
Base64.getDecoder().decode(encoded);</p>
<p><a
href="http://stackoverflow.com/questions/19743851/base64-java-encode-and-decode-a-string">Reference</a></p>
<p>Section 86.4: Converting other datatypes to String</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 510</p>
<p><span id="You_can_get_the_value_of_other_p" class="anchor"></span>You
can get the value of other primitive data types as a String using one
the String class's valueOf methods.</p>
<p>For example:</p>
<p><strong>int</strong> i = 42;</p>
<p>String string = String.valueOf(i);</p>
<p>//string now equals "42<em>”</em>.</p>
<p>This method is also overloaded for other datatypes, such as
<strong>float</strong>, <strong>double</strong>,
<strong>boolean</strong>, and even Object.</p>
<p>You can also get any other Object (any instance of any class) as a
String by calling .toString on it. For this to</p>
<p>give useful output, the class must override toString(). Most of the
standard Java library classes do, such as Date and others.</p>
<p>For example:</p>
<p>Foo foo = <strong>new</strong> Foo(); <em>//Any class.</em></p>
<p>String stringifiedFoo = foo.toString().</p>
<p>Here stringifiedFoo contains a representation of foo as a String.</p>
<p>You can also convert any number type to String with short notation
like below.</p>
<p><strong>int</strong> i = 10;</p>
<p>String str = i + "";</p>
<p>Or just simple way is</p>
<p>String str = 10 + "";</p>
<p>Section 86.5: Getting a `String` from an `InputStream`</p>
<p>A String can be read from an InputStream using the byte array
constructor.</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>public</strong> String readString(InputStream input)
<strong>throws</strong> IOException {</p>
<p><em><strong>byte</strong>[] bytes = <strong>new
byte</strong>[50];</em> // supply the length of the string in bytes
here</p>
<p>input.read(bytes);</p>
<p><strong>return new</strong> String(bytes);</p>
<p>}</p>
<p>This uses the system default charset, although an alternate charset
may be specified:</p>
<p><strong>return new</strong> String(bytes,
Charset.forName("UTF-8"));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 511</p>
<p><span id="Chapter_87__Random_Number_Genera_1"
class="anchor"></span>Chapter 87: Random Number Generation</p>
<p>Section 87.1: Pseudo Random Numbers</p>
<p>Java provides, as part of the utils package, a basic pseudo-random
number generator, appropriately named Random . This object can be used
to generate a pseudo-random value as any of the built-in numerical
datatypes (<strong>int</strong>,</p>
<p><strong>float</strong>, etc). You can also use it to generate a
random Boolean value, or a random array of bytes. An example usage is as
follows:</p>
<p><strong>import</strong> java.util.Random;</p>
<p>...</p>
<p>Random random = <strong>new</strong> Random();</p>
<p><strong>int</strong> randInt = random.nextInt();</p>
<p><strong>long</strong> randLong = random.nextLong();</p>
<p><strong>double</strong> randDouble = random.nextDouble(); <em>//This
returns a value between 0.0 and 1.0</em> <strong>float</strong>
randFloat = random.nextFloat(); <em>//Same as nextDouble</em></p>
<p><strong>byte</strong>[] randBytes = <strong>new
byte</strong>[16];</p>
<p><em>random.nextBytes(randBytes);</em> //nextBytes takes a
user-supplied byte array, and fills it with random bytes. It returns
nothing.</p>
<p>NOTE: This class only produces fairly low-quality pseudo-random
numbers, and should never be used to generate</p>
<p>random numbers for cryptographic operations or other situations where
higher-quality randomness is critical (For that, you would want to use
the SecureRandom class, as noted below). An explanation for the
distinction between</p>
<p>"secure" and "insecure" randomness is beyond the scope of this
example.</p>
<p>Section 87.2: Pseudo Random Numbers in Specific Range</p>
<p>The method nextInt(<strong>int</strong> bound) of Random accepts an
upper exclusive boundary, i.e. a number that the returned</p>
<p>random value must be less than. However, only the nextInt method
accepts a bound; nextLong, nextDouble etc. do not.</p>
<p>Random random = <strong>new</strong> Random();</p>
<p>random.nextInt(1000); <em>// 0 - 999</em></p>
<p><em><strong>int</strong> number = 10 + random.nextInt(100);</em> //
number is in the range of 10 to 109</p>
<p>Starting in Java 1.7, you may also use ThreadLocalRandom <a
href="http://stackoverflow.com/questions/363681/generating-random-integers-in-a-specific-range">(source</a>).
This class provides a thread-safe PRNG (pseudo-random number generator).
Note that the nextInt method of this class accepts both an upper and
lower bound.</p>
<p><strong>import</strong> java.util.concurrent.ThreadLocalRandom;</p>
<p>// nextInt is normally exclusive of the top value,</p>
<p>// so add 1 to make it inclusive</p>
<p>ThreadLocalRandom.current().nextInt(min, max + 1);</p>
<p>Note that <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">the
official documentation states that</a> nextInt(<strong>int</strong>
bound) can do weird things when bound is near 230+1</p>
<p>(emphasis added):</p>
<p><strong>The algorithm is slightly tricky.</strong> It rejects values
that would result in an uneven distribution <strong>(due to</strong></p>
<p>the fact that 2^31 is not divisible by n). The probability of a value
being rejected depends on n. <strong>The worst</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 512</p>
<p><span id="case_is_n_2_30_1__for_which_the" class="anchor"></span>case
is n=2^30+1, for which the probability of a reject is 1/2, and the
expected number of iterations</p>
<p>before the loop terminates is 2.</p>
<p>In other words, specifying a bound will (slightly) decrease the
performance of the nextInt method, and this</p>
<p>performance decrease will become more pronounced as the bound
approaches half the max int value.</p>
<p>Section 87.3: Generating cryptographically secure</p>
<p>pseudorandom numbers</p>
<p>Random and ThreadLocalRandom are good enough for everyday use, but
they have a big problem: They are based on</p>
<p>a <a
href="https://en.wikipedia.org/wiki/Linear_congruential_generator">linear
congruential generator</a>, an algorithm whose output can be predicted
rather easily. Thus, these two classes</p>
<p>are <strong>not</strong> suitable for cryptographic uses (such as key
generation).</p>
<p>One can use java.security.SecureRandom in situations where a PRNG
with an output that is very hard to predict is</p>
<p>required. Predicting the random numbers created by instances of this
class is hard enough to label the class as</p>
<p>cryptographically secure<strong>.</strong></p>
<p><strong>import</strong> java.security.SecureRandom;</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p>public class <strong>Foo {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>SecureRandom rng = <strong>new</strong> SecureRandom();</p>
<p><strong>byte</strong>[] randomBytes = <strong>new
byte</strong>[64];</p>
<p><em>rng.nextBytes(randomBytes);</em> // Fills randomBytes with random
bytes (duh)</p>
<p>System.out.println(Arrays.toString(randomBytes));</p>
<p>}</p>
<p>}</p>
<p>Besides being cryptographically secure, SecureRandom has a gigantic
period of 2160, compared to Randoms period of</p>
<p>248. It has one drawback of being considerably slower than Random and
other linear PRNGs such as <a
href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne</a></p>
<p><a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Twister</a>
and <a href="https://en.wikipedia.org/wiki/Xorshift">Xorshift</a>,
however.</p>
<p>Note that SecureRandom implementation is both platform and provider
dependent. The default SecureRandom</p>
<p>(given by SUN provider in sun.security.provider.SecureRandom):</p>
<p>on Unix-like systems, seeded with data from /dev/random and/or
/dev/urandom.</p>
<p>on Windows, seeded with calls to CryptGenRandom() in <a
href="https://en.wikipedia.org/wiki/Microsoft_CryptoAPI">CryptoAPI.</a></p>
<p>Section 87.4: Generating Random Numbers with a Specified</p>
<p>Seed</p>
<p>//Creates a Random instance with a seed of 12345.</p>
<p>Random random = <strong>new</strong> Random(12345L);</p>
<p>//Gets a ThreadLocalRandom instance</p>
<p>ThreadLocalRandom tlr = ThreadLocalRandom.current();</p>
<p>//Set the instance's seed.</p>
<p>tlr.setSeed(12345L);</p>
<p>Using the same seed to generate random numbers will return the same
numbers every time, so setting a different</p>
<p>seed for every Random instance is a good idea if you don't want to
end up with duplicate numbers.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 513</p>
<p><span id="A_good_method_to_get_a_Long_that" class="anchor"></span>A
good method to get a Long <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#currentTimeMillis()">that
is different for every call is System.currentTimeMillis():</a></p>
<p>Random random = <strong>new</strong>
Random(System.currentTimeMillis());
ThreadLocalRandom.current().setSeed(System.currentTimeMillis());</p>
<p>Section 87.5: Select random numbers without duplicates</p>
<p>/**</p>
<p>* returns a array of random numbers with no duplicates * @param range
the range of possible numbers for ex. if 100 then it can be anywhere
from 1-100 * @param length the length of the array of random numbers *
@return array of random numbers with no duplicates. */</p>
<p><strong>public static int</strong>[]
getRandomNumbersWithNoDuplicates(<strong>int</strong> range,
<strong>int</strong> length){</p>
<p><strong>if</strong> (length</p>
<p>// this is where all the random numbers</p>
<p><strong>int</strong>[] randomNumbers = <strong>new
int</strong>[length];</p>
<p>// loop through all the random numbers to set them</p>
<p><strong>for</strong> (<strong>int</strong> q = 0; q &lt;
randomNumbers.length; q++){</p>
<p>// get the remaining possible numbers</p>
<p><strong>int</strong> remainingNumbers = range-q;</p>
<p>// get a new random number from the remainingNumbers
<em><strong>int</strong> newRandSpot = (<strong>int</strong>)
(Math.random()*remainingNumbers);</em></p>
<p>newRandSpot++;</p>
<p>// loop through all the possible numbers</p>
<p><strong>for</strong> (<strong>int</strong> t = 1; t &lt; range+1;
t++){</p>
<p>// check to see if this number has already been taken
<em><strong>boolean</strong> taken = <strong>false</strong>;</em></p>
<p><strong>for</strong> (<strong>int</strong> number :
randomNumbers){</p>
<p><strong>if</strong> (t==number){</p>
<p>taken = <strong>true</strong>;</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>// if it hasnt been taken then remove one from the spots
<em><strong>if</strong> (!taken){</em></p>
<p>newRandSpot--;</p>
<p>// if we have gone though all the spots then set the value
<em><strong>if</strong> (newRandSpot==0){</em></p>
<p>randomNumbers[q] = t;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> randomNumbers;</p>
<p>} <strong>else</strong> {</p>
<p>// invalid can't have a length larger then the range of possible
numbers</p>
<p>}</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>The method works by looping though an array that has the size of the
requested length and finds the remaining</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 514</p>
<p><span id="length_of_possible_numbers__It_s"
class="anchor"></span>length of possible numbers. It sets a random
number of those possible numbers newRandSpot and finds that number
within the non taken number left. It does this by looping through the
range and checking to see if that</p>
<p>number has already been taken.</p>
<p>For example if the range is 5 and the length is 3 and we have already
chosen the number 2. Then we have 4</p>
<p>remaining numbers so we get a random number between 1 and 4 and we
loop through the range(5) skipping over any numbers that we have already
used(2).</p>
<p>Now let's say the next number chosen between 1 &amp; 4 is 3. On the
first loop we get 1 which has not yet been taken so we can remove 1 from
3 making it 2. Now on the second loop we get 2 which has been taken so
we do nothing.</p>
<p>We follow this pattern until we get to 4 where once we remove 1 it
becomes 0 so we set the new randomNumber to 4.</p>
<p>Section 87.6: Generating Random number using apache-</p>
<p>common lang3</p>
<p>We can use org.apache.commons.lang3.RandomUtils to generate random
numbers using a single line.</p>
<p><strong>int</strong> x = RandomUtils.nextInt(1, 1000);</p>
<p>The method nextInt(<strong>int</strong> startInclusive,
<strong>int</strong> endExclusive) takes a range.</p>
<p>Apart from int, we can generate random <strong>long</strong>,
<strong>double</strong>, <strong>float</strong> and bytes using this
class.</p>
<p>RandomUtils class contains the following methods-</p>
<p><em><strong>static byte</strong>[] nextBytes(<strong>int</strong>
count)</em> //Creates an array of random bytes. <em><strong>static
double</strong> nextDouble()</em> //Returns a random double within 0 -
Double.MAX_VALUE <em><strong>static double</strong>
nextDouble(<strong>double</strong> startInclusive,
<strong>double</strong> endInclusive)</em> //Returns a random double
within the specified range.</p>
<p><em><strong>static float</strong> nextFloat()</em> //Returns a random
float within 0 - Float.MAX_VALUE <em><strong>static float</strong>
nextFloat(<strong>float</strong> startInclusive, <strong>float</strong>
endInclusive)</em> //Returns a random float within the specified
range.</p>
<p><em><strong>static int</strong> nextInt()</em> //Returns a random int
within 0 - Integer.MAX_VALUE <em><strong>static int</strong>
nextInt(<strong>int</strong> startInclusive, <strong>int</strong>
endExclusive)</em> //Returns a random integer within the specified
range.</p>
<p><em><strong>static long</strong> nextLong()</em> //Returns a random
long within 0 - Long.MAX_VALUE <em><strong>static long</strong>
nextLong(<strong>long</strong> startInclusive, <strong>long</strong>
endExclusive)</em> //Returns a random long within the specified
range.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 515</p>
<p><span id="Chapter_88__Singletons_1" class="anchor"></span>Chapter 88:
Singletons</p>
<p>A singleton is a class that only ever has one single instance. For
more information on the Singleton <em>design pattern</em>,</p>
<p>please refer to the Singleton topic in the Design Patterns tag.</p>
<p>Section 88.1: Enum Singleton</p>
<p>Version ≥ Java SE 5</p>
<p><strong>public enum</strong> Singleton {</p>
<p>INSTANCE;</p>
<p><strong>public void</strong> execute (String arg) {</p>
<p>// Perform operation here</p>
<p>}</p>
<p>}</p>
<p>Enums have private constructors, are final and provide proper
serialization machinery. They are also very concise</p>
<p>and lazily initialized in a thread safe manner.</p>
<p>The JVM provides a guarantee that enum values will not be
instantiated more than once each, which gives the enum</p>
<p>singleton pattern a very strong defense against reflection
attacks.</p>
<p>What the enum pattern <em>doesn't</em> protect against is other
developers physically adding more elements to the source</p>
<p>code. Consequently, if you choose this implementation style for your
singletons it is imperative that you very clearly document that no new
values should be added to those enums.</p>
<p>This is the recommended way of implementing the singleton pattern, as
<a
href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=3">explained</a>
by Joshua Bloch in Effective Java.</p>
<p>Section 88.2: Singleton without use of Enum (eager</p>
<p>initialization)</p>
<p>public class <strong>Singleton {</strong></p>
<p><strong>private static final</strong> Singleton INSTANCE =
<strong>new</strong> Singleton();</p>
<p><strong>private</strong> Singleton() {}</p>
<p><strong>public static</strong> Singleton getInstance() {</p>
<p><strong>return</strong> INSTANCE;</p>
<p>}</p>
<p>}</p>
<p>It can be argued that this example is <em>effectively</em> <a
href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.1">lazy
initialization. Section 12.4.1 of the Java Language Specification</a>
states:</p>
<p>A class or interface type T will be initialized immediately before
the first occurrence of any one of the</p>
<p>following:</p>
<p>T is a class and an instance of T is created</p>
<p>T is a class and a static method declared by T is invoked</p>
<p>A static field declared by T is assigned</p>
<p>A static field declared by T is used and the field is not a constant
variable</p>
<p>T is a top level class, and an assert statement lexically nested
within T is executed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 516</p>
<p><span id="Therefore__as_long_as_there_are"
class="anchor"></span>Therefore, as long as there are no other static
fields or static methods in the class, the Singleton instance will not
be initialized until the method getInstance() is invoked the first
time.</p>
<p>Section 88.3: Thread-safe lazy initialization using holder class</p>
<p>| Bill Pugh Singleton implementation</p>
<p>public class <strong>Singleton {</strong></p>
<p>private static class <strong>InstanceHolder {</strong></p>
<p><strong>static final</strong> Singleton INSTANCE =
<strong>new</strong> Singleton();</p>
<p>}</p>
<p><strong>public static</strong> Singleton getInstance() {</p>
<p><strong>return</strong> InstanceHolder.INSTANCE;</p>
<p>}</p>
<p><strong>private</strong> Singleton() {}</p>
<p>}</p>
<p>This initializes the INSTANCE variable on the first call to
Singleton.getInstance(), taking advantage of the</p>
<p>language's thread safety guarantees for static initialization without
requiring additional synchronization.</p>
<p><a
href="https://en.wikipedia.org/wiki/Singleton_pattern#Initialization-on-demand_holder_idiom">This
implementation is also known as Bill Pugh singleton pattern.
[Wiki]</a></p>
<p>Section 88.4: Thread safe Singleton with double checked</p>
<p>locking</p>
<p>This type of Singleton is thread safe, and prevents unnecessary
locking after the Singleton instance has been created.</p>
<p>Version ≥ Java SE 5</p>
<p><strong>public class</strong> MySingleton {</p>
<p>// instance of class</p>
<p>private static volatile <strong>MySingleton instance =</strong>
null<strong>;</strong></p>
<p>// Private constructor</p>
<p><strong>private</strong> MySingleton() {</p>
<p>// Some code for constructing object</p>
<p>}</p>
<p><strong>public static</strong> MySingleton getInstance() {</p>
<p>MySingleton result = instance;</p>
<p>//If the instance already exists, no locking is necessary
<em><strong>if</strong>(result == <strong>null</strong>) {</em></p>
<p>//The singleton instance doesn't exist, lock and check again
<em><strong>synchronized</strong>(MySingleton.<strong>class</strong>)
{</em></p>
<p>result = instance;</p>
<p><strong>if</strong>(result == <strong>null</strong>) {</p>
<p>instance = result = <strong>new</strong> MySingleton();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> result;</p>
<p>}</p>
<p>}</p>
<p><a
href="http://www.cs.umd.edu/%7Epugh/java/memoryModel/DoubleCheckedLocking.html">It
must be emphasized -- in versions prior to Java SE 5, the implementation
above is incorrect</a> and should be</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 517</p>
<p><span id="avoided__It_is_not_possible_to_i"
class="anchor"></span>avoided. It is not possible to implement
double-checked locking correctly in Java prior to Java 5.</p>
<p>Section 88.5: Extending singleton (singleton inheritance)</p>
<p>In this example, base class Singleton provides getMessage() method
that returns "Hello world!" message.</p>
<p>It's subclasses UppercaseSingleton and LowercaseSingleton override
getMessage() method to provide appropriate representation of the
message.</p>
<p>//Yeah, we'll need reflection to pull this off.</p>
<p><strong>import</strong> java.lang.reflect.*;</p>
<p>/*</p>
<p>Enumeration that represents possible classes of singleton instance.
If unknown, we'll go with base class - Singleton.</p>
<p>*/</p>
<p><strong>enum</strong> SingletonKind {</p>
<p>UNKNOWN,</p>
<p>LOWERCASE,</p>
<p>UPPERCASE</p>
<p>}</p>
<p>//Base class</p>
<p><strong>class</strong> Singleton{</p>
<p>/*</p>
<p>Extended classes has to be private inner classes, to prevent
extending them in</p>
<p>uncontrolled manner.</p>
<p>*/</p>
<p><strong>private class</strong> UppercaseSingleton
<strong>extends</strong> Singleton {</p>
<p><strong>private</strong> UppercaseSingleton(){</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String getMessage() {</p>
<p><strong>return super</strong>.getMessage().toUpperCase();</p>
<p>}</p>
<p>}</p>
<p>//Another extended class.</p>
<p><strong>private class</strong> LowercaseSingleton
<strong>extends</strong> Singleton</p>
<p>{</p>
<p><strong>private</strong> LowercaseSingleton(){</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String getMessage() {</p>
<p><strong>return super</strong>.getMessage().toLowerCase();</p>
<p>}</p>
<p>}</p>
<p>//Applying Singleton pattern</p>
<p><strong>private static</strong> SingletonKind kind =
SingletonKind.UNKNOWN;</p>
<p><strong>private static</strong> Singleton instance;</p>
<p>/*</p>
<p>By using this method prior to getInstance() method, you effectively
change the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 518</p>
<p>type of singleton instance to be created.</p>
<p>*/</p>
<p><strong>public static void</strong> setKind(SingletonKind kind) {</p>
<p>Singleton.kind = kind;</p>
<p>}</p>
<p>/*</p>
<p>If needed, getInstance() creates instance appropriate class, based on
value of</p>
<p>singletonKind field.</p>
<p>*/</p>
<p><strong>public static</strong> Singleton getInstance()</p>
<p><strong>throws</strong> NoSuchMethodException,</p>
<p>IllegalAccessException,</p>
<p>InvocationTargetException,</p>
<p>InstantiationException {</p>
<p><strong>if</strong>(instance==<strong>null</strong>){</p>
<p>synchronized <strong>(Singleton.</strong>class<strong>){</strong></p>
<p><strong>if</strong>(instance==<strong>null</strong>){</p>
<p>Singleton singleton = <strong>new</strong> Singleton();</p>
<p><strong>switch</strong> (kind){</p>
<p><strong>case</strong> UNKNOWN:</p>
<p>instance = singleton;</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> LOWERCASE:</p>
<p>/*</p>
<p>I can't use simple</p>
<p>instance = new LowercaseSingleton();</p>
<p>because java compiler won't allow me to use</p>
<p>constructor of inner class in static context,</p>
<p>so I use reflection API instead.</p>
<p>To be able to access inner class by reflection API,</p>
<p>I have to create instance of outer class first.</p>
<p>Therefore, in this implementation, Singleton cannot be</p>
<p>abstract class.</p>
<p>*/</p>
<p>//Get the constructor of inner class.</p>
<p>Constructor lcConstructor =</p>
<p>LowercaseSingleton.<strong>class</strong>.getDeclaredConstructor(Singleton.<strong>class</strong>);</p>
<p>//The constructor is private, so I have to make it accessible.</p>
<p>lcConstructor.setAccessible(<strong>true</strong>);</p>
<p>// Use the constructor to create instance.</p>
<p>instance = lcConstructor.newInstance(singleton);</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> UPPERCASE:</p>
<p>//Same goes here, just with different type</p>
<p>Constructor ucConstructor =</p>
<p>UppercaseSingleton.<strong>class</strong>.getDeclaredConstructor(Singleton.<strong>class</strong>);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 519</p>
<p>ucConstructor.setAccessible(<strong>true</strong>);</p>
<p>instance = ucConstructor.newInstance(singleton);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> instance;</p>
<p>}</p>
<p>//Singletons state that is to be used by subclasses
<em><strong>protected</strong> String message;</em></p>
<p>//Private constructor prevents external instantiation.
<em><strong>private</strong> Singleton()</em></p>
<p>{</p>
<p>message = "Hello world!";</p>
<p>}</p>
<p>//Singleton's API. Implementation can be overwritten by subclasses.
<em><strong>public</strong> String getMessage() {</em></p>
<p><strong>return</strong> message;</p>
<p>}</p>
<p>}</p>
<p>//Just a small test program</p>
<p><strong>public class</strong> ExtendingSingletonExample {</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>//just uncomment one of following lines to change singleton class</p>
<p>//Singleton.setKind(SingletonKind.UPPERCASE);</p>
<p>//Singleton.setKind(SingletonKind.LOWERCASE);</p>
<p>Singleton singleton = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>singleton = Singleton.getInstance();</p>
<p>} <strong>catch</strong> (NoSuchMethodException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IllegalAccessException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (InvocationTargetException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (InstantiationException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>System.out.println(singleton.getMessage());</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 520</p>
<p><span id="Chapter_89__Autoboxing_1" class="anchor"></span>Chapter 89:
Autoboxing</p>
<p><a
href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/autoboxing.html">Autoboxing
is the automatic conversion that Java compiler makes between primitive
types and their corresponding</a></p>
<p>object wrapper classes. Example, converting int -&gt; Integer, double
-&gt; Double... If the conversion goes the other way, this is called
unboxing. Typically, this is used in Collections that cannot hold other
than Objects, where boxing</p>
<p>primitive types is needed before setting them in the collection.</p>
<p>Section 89.1: Using int and Integer interchangeably</p>
<p>As you use generic types with utility classes, you may often find
that number types aren't very helpful when</p>
<p>specified as the object types, as they aren't equal to their
primitive counterparts.</p>
<p>List ints = <strong>new</strong> ArrayList();</p>
<p>Version ≥ Java SE 7</p>
<p>List ints = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>Fortunately, expressions that evaluate to <strong>int</strong> can be
used in place of an Integer when it is needed.</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)</p>
<p>ints.add(i);</p>
<p>The ints.add(i); statement is equivalent to:</p>
<p>ints.add(Integer.valueOf(i));</p>
<p>And retains properties from Integer#valueOf such as having the same
Integer objects cached by the JVM when it</p>
<p>is within the number caching range.</p>
<p>This also applies to:</p>
<p><strong>byte</strong> and Byte</p>
<p>short <strong>and Short</strong></p>
<p>float <strong>and Float</strong></p>
<p>double <strong>and Double</strong></p>
<p><strong>long</strong> and Long</p>
<p><strong>char</strong> and Character</p>
<p>boolean <strong>and Boolean</strong></p>
<p>Care must be taken, however, in ambiguous situations. Consider the
following code:</p>
<p>List ints = <strong>new</strong> ArrayList();</p>
<p>ints.add(1);</p>
<p>ints.add(2);</p>
<p>ints.add(3);</p>
<p><em>ints.remove(1);</em> // ints is now [1, 3]</p>
<p>The java.util.List interface contains both a
remove(<strong>int</strong> index) (List interface method) and a
remove(Object</p>
<p>o) (method inherited from java.util.Collection). In this case no
boxing takes place and remove(<strong>int</strong> index) is called.</p>
<p>One more example of strange Java code behavior caused by autoboxing
Integers with values in range from -128 to 127:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 521</p>
<p><span id="Integer_a___127" class="anchor"></span>Integer a = 127;</p>
<p>Integer b = 127;</p>
<p>Integer c = 128;</p>
<p>Integer d = 128;</p>
<p>System.out.println(a == b); <em>// true</em></p>
<p>System.out.println(c &lt;= d); <em>// true</em></p>
<p>System.out.println(c &gt;= d); <em>// true</em></p>
<p>System.out.println(c == d); <em>// false</em></p>
<p>This happens because &gt;= operator implicitly calls intValue() which
returns <strong>int</strong> while == compares
<strong>references</strong>, not</p>
<p>the <strong>int</strong> values.</p>
<p>By default, Java caches values in range [-128, 127], so the operator
== works because the Integers in this range</p>
<p>reference to the same objects if their values are same. Maximal value
of the cacheable range can be defined with -XX:AutoBoxCacheMax JVM
option. So, if you run the program with -XX:AutoBoxCacheMax=1000, the
following code</p>
<p>will print <strong>true</strong>:</p>
<p>Integer a = 1000;</p>
<p>Integer b = 1000;</p>
<p>System.out.println(a == b); <em>// true</em></p>
<p>Section 89.2: Auto-unboxing may lead to NullPointerException</p>
<p>This code compiles:</p>
<p>Integer arg = <strong>null</strong>;</p>
<p><strong>int</strong> x = arg;</p>
<p>But it will crash at runtime with a java.lang.NullPointerException on
the second line.</p>
<p>The problem is that a primitive <strong>int</strong> cannot have a
<strong>null</strong> value.</p>
<p>This is a minimalistic example, but in practice it often manifests in
more sophisticated forms. The NullPointerException is not very intuitive
and is often little help in locating such bugs.</p>
<p>Rely on autoboxing and auto-unboxing with care, make sure that
unboxed values will not have <strong>null</strong> values at
runtime.</p>
<p>Section 89.3: Using Boolean in if statement</p>
<p>Due to auto unboxing, one can use a Boolean in an if statement:</p>
<p>Boolean a = Boolean.<strong>TRUE</strong>;</p>
<p><em><strong>if</strong> (a) {</em> // a gets converted to boolean</p>
<p>System.out.println("It works!");</p>
<p>}</p>
<p>That works for <strong>while</strong>, <strong>do while</strong> and
the condition in the <strong>for</strong> statements as well.</p>
<p>Note that, if the Boolean is <strong>null</strong>, a
NullPointerException will be thrown in the conversion.</p>
<p>Section 89.4: Dierent Cases When Integer and int can be</p>
<p>used interchangeably</p>
<p><strong>Case 1:</strong> While using in the place of method
arguments.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 522</p>
<p>If a method requires an object of wrapper class as argument.Then
interchangeably the argument can be passed a variable of the respective
primitive type and vice versa.</p>
<p>Example:</p>
<p>int <strong>i;</strong></p>
<p>Integer j;</p>
<p><em><strong>void</strong> ex_method(Integer i)</em>//Is a valid
statement</p>
<p><em><strong>void</strong> ex_method1(<strong>int</strong> j)</em>//Is
a valid statement</p>
<p><strong>Case 2:</strong> While passing return values:</p>
<p>When a method returns a primitive type variable then an object of
corresponding wrapper class can be passed as</p>
<p>the return value interchangeably and vice versa.</p>
<p>Example:</p>
<p>int <strong>i;</strong></p>
<p>Integer j;</p>
<p><strong>int</strong> ex_method()</p>
<p>{...</p>
<p><em><strong>return</strong> j;}</em>//Is a valid statement</p>
<p>Integer ex_method1()</p>
<p>{...</p>
<p><em><strong>return</strong> i;</em>//Is a valid statement</p>
<p>}</p>
<p><strong>Case 3:</strong> While performing operations.</p>
<p>Whenever performing operations on numbers the primitive type variable
and object of respective wrapper class can be used interchangeably.</p>
<p><strong>int</strong> i=5;</p>
<p>Integer j=<strong>new</strong> Integer(7);</p>
<p><em><strong>int</strong> k=i+j;</em>//Is a valid statement</p>
<p><em>Integer m=i+j;</em>//Is also a valid statement</p>
<p><strong>Pitfall</strong>:Remember to initialize or assign a value to
an object of the wrapper class.</p>
<p>While using wrapper class object and primitive variable
interchangeably never forget or miss to initialize or assign a value to
the wrapper class object else it may lead to null pointer exception at
runtime.</p>
<p>Example:</p>
<p>public class <strong>Test{</strong></p>
<p>Integer i;</p>
<p>int <strong>j;</strong></p>
<p>public void <strong>met()</strong></p>
<p><em>{j=i;</em>//Null pointer exception</p>
<p>SOP(j);</p>
<p>SOP(i);}</p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>{Test t=<strong>new</strong> Test();</p>
<p><em>t.go();</em>//Null pointer exception</p>
<p>}</p>
<p>In the above example, the value of the object is unassigned and
uninitialized and thus at runtime the program will</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 523</p>
<p><span id="run_into_null_pointer_exception" class="anchor"></span>run
into null pointer exception.So as clear from the above example the value
of object should never be left uninitialized and unassigned.</p>
<p>Section 89.5: Memory and Computational Overhead of</p>
<p>Autoboxing</p>
<p>Autoboxing can come at a substantial memory overhead. For
example:</p>
<p>Map square = <strong>new</strong> HashMap();
<strong>for</strong>(<strong>int</strong> i = 256; i &lt; 1024; i++)
{</p>
<p><em>square.put(i, i * i);</em> // Autoboxing of large integers
<em>}</em></p>
<p>will typically consume substantial amount of memory (about 60kb for
6k of actual data).</p>
<p>Furthermore, boxed integers usually require additional round-trips in
the memory, and thus make CPU caches less effective. In above example,
the memory accessed is spread out to five different locations that may
be in entirely</p>
<p>different regions of the memory: 1. the HashMap object, 2. the map's
Entry[] table object, 3. the Entry object, 4. the entrys key object
(boxing the primitive key), 5. the entrys value object (boxing the
primitive value).</p>
<p><strong>class</strong> Example {</p>
<p><em><strong>int</strong> primitive;</em> // Stored directly in the
class `Example` <em>Integer boxed;</em> // Reference to another memory
location</p>
<p>}</p>
<p>Reading boxed requires two memory accesses, accessing primitive only
one.</p>
<p>When getting data from this map, the seemingly innocent code</p>
<p><strong>int</strong> sumOfSquares = 0;</p>
<p><strong>for</strong>(<strong>int</strong> i = 256; i &lt; 1024; i++)
{</p>
<p>sumOfSquares += square.get(i);</p>
<p>}</p>
<p>is equivalent to:</p>
<p><strong>int</strong> sumOfSquares = 0;</p>
<p><strong>for</strong>(<strong>int</strong> i = 256; i &lt; 1024; i++)
{</p>
<p>sumOfSquares += square.get(Integer.valueOf(i)).intValue(); }</p>
<p>Typically, the above code causes the <em>creation and garbage
collection</em> of an Integer object for every Map#get(Integer)
operation. (See Note below for more details.)</p>
<p>To reduce this overhead, several libraries offer optimized
collections for primitive types that do <em>not</em> require boxing. In
addition to avoiding the boxing overhead, these collection will require
about 4x less memory per entry. While</p>
<p>Java Hotspot <em>may</em> be able to optimize the autoboxing by
working with objects on the stack instead of the heap, it is not
possible to optimize the memory overhead and resulting memory
indirection.</p>
<p>Java 8 streams also have optimized interfaces for primitive data
types, such as IntStream that do not require boxing.</p>
<p>Note: a typical Java runtime maintains a simple cache of Integer and
other primitive wrapper object that is used by</p>
<p>the valueOf factory methods, and by autoboxing. For Integer, the
default range of this cache is -128 to +127. Some</p>
<p>JVMs provide a JVM command-line option for changing the cache size /
range.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 524</p>
<p><span id="Chapter_90__2D_Graphics_in_Java_1"
class="anchor"></span>Chapter 90: 2D Graphics in Java</p>
<p>Graphics are visual images or designs on some surface, such as a
wall, canvas, screen, paper, or stone to inform,</p>
<p>illustrate, or entertain. It includes: pictorial representation of
data, as in computer-aided design and manufacture, in typesetting and
the graphic arts, and in educational and recreational software. Images
that are generated by a</p>
<p>computer are called computer graphics.</p>
<p>The Java 2D API is powerful and complex. There are multiple ways to
do 2D graphics in Java.</p>
<p>Section 90.1: Example 1: Draw and Fill a Rectangle Using Java</p>
<p>This is an Example which print rectangle and fill color in the
rectangle. <a
href="https://i.stack.imgur.com/dlC5v.jpg">https://i.stack.imgur.com/dlC5v.jpg</a></p>
<p><img src="media/index-549_1.jpeg"
style="width:4.43056in;height:4.48611in" alt="index-549_1.jpg" /></p>
<p>Most methods of the Graphics class can be divided into two basic
groups:</p>
<p>1. Draw and fill methods, enabling you to render basic shapes, text,
and images</p>
<p>2. Attributes setting methods, which affect how that drawing and
filling appears</p>
<p>Code Example: Let us start this with a little example of drawing a
rectangle and filling color in it. There we declare</p>
<p>two classes, one class is MyPanel and other Class is Test. In class
MyPanel we use drawRect( ) &amp; fillRect( ) mathods to draw rectangle
and fill Color in it. We set the color by setColor(Color.blue) method.
In Second Class we Test our</p>
<p>graphic which is Test Class we make a Frame and put MyPanel with
p=new MyPanel() object in it.By running Test Class we see a Rectangle
and a Blue Color Filled Rectangle.</p>
<p>First Class: MyPanel</p>
<p><strong>import</strong> javax.swing.*;</p>
<p><strong>import</strong> java.awt.*;</p>
<p>// MyPanel extends JPanel, which will eventually be placed in a
JFrame <em><strong>public class</strong> MyPanel
<strong>extends</strong> JPanel {</em></p>
<p>// custom painting is performed by the paintComponent method</p>
<p>@Override</p>
<p><strong>public void</strong> paintComponent(Graphics g){</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 525</p>
<p>// clear the previous painting</p>
<p><strong>super</strong>.paintComponent(g);</p>
<p>// cast Graphics to Graphics2D</p>
<p>Graphics2D g2 = (Graphics2D) g;</p>
<p>g2.setColor(Color.red); <em>// sets Graphics2D color</em></p>
<p>// draw the rectangle</p>
<p><em>g2.drawRect(0,0,100,100);</em> // drawRect(x-position,
y-position, width, height)</p>
<p>g2.setColor(Color.blue);</p>
<p><em>g2.fillRect(200,0,100,100);</em> // fill new rectangle with color
blue</p>
<p>}</p>
<p>}</p>
<p>Second Class: Test</p>
<p><strong>import</strong> javax.swing.;</p>
<p><strong>import</strong> java.awt.;</p>
<p><em><strong>public class</strong> Test {</em> //the Class by which we
display our rectangle</p>
<p>JFrame f;</p>
<p>MyPanel p;</p>
<p><strong>public</strong> Test(){</p>
<p>f = <strong>new</strong> JFrame();</p>
<p>// get the content area of Panel.</p>
<p>Container c = f.getContentPane();</p>
<p>// set the LayoutManager</p>
<p>c.setLayout(<strong>new</strong> BorderLayout());</p>
<p>p = <strong>new</strong> MyPanel();</p>
<p>// add MyPanel object into container</p>
<p>c.add(p);</p>
<p>// set the size of the JFrame</p>
<p>f.setSize(400,400);</p>
<p>// make the JFrame visible</p>
<p>f.setVisible(<strong>true</strong>);</p>
<p>// sets close behavior; EXIT_ON_CLOSE invokes System.exit(0) on
closing the JFrame</p>
<p>f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[ ]){</p>
<p>Test t = <strong>new</strong> Test();</p>
<p>}</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/uiswing/layout/border.html">For
More Explanation about Border Layout:
https://docs.oracle.com/javase/tutorial/uiswing/layout/border.html</a></p>
<p>paintComponent( )</p>
<p>It is a main method for painting</p>
<p>By default, it first paints the background</p>
<p>After that, it performs custom painting (drawing circle, rectangles
etc.)</p>
<p>Graphic2D refers Graphic2D Class</p>
<p><strong>Note:</strong> The Java 2D API enables you to easily perform
the following tasks:</p>
<p>Draw lines, rectangles and any other geometric shape.</p>
<p>Fill those shapes with solid colors or gradients and textures. Draw
text with options for fine control over the font and rendering
process.</p>
<p>Draw images, optionally applying filtering operations.</p>
<p>Apply operations such as compositing and transforming during any of
the above rendering operations.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 526</p>
<p><span id="Section_90_2__Example_2__Drawing"
class="anchor"></span>Section 90.2: Example 2: Drawing and Filling
Oval</p>
<p><strong>import</strong> javax.swing.*;</p>
<p><strong>import</strong> java.awt.*;</p>
<p>public class <strong>MyPanel</strong> extends <strong>JPanel
{</strong></p>
<p>@Override</p>
<p><strong>public void</strong> paintComponent(Graphics g){</p>
<p>// clear the previous painting</p>
<p><strong>super</strong>.paintComponent(g);</p>
<p>Graphics2D g2 = (Graphics2D)g;</p>
<p>g2.setColor(Color.blue);</p>
<p>g2.drawOval(0, 0, 20,20);</p>
<p>g2.fillOval(50,50,20,20);</p>
<p>}</p>
<p>}</p>
<p>g2.drawOval(int x,int y,int height, int width);</p>
<p>This method will draw an oval at specified x and y position with
given height and width.</p>
<p><strong>g2.fillOval(int x,int y,int height, int width);</strong> This
method will fill an oval at specified x and y position with given</p>
<p>height and width.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 527</p>
<p><span id="Chapter_91__JAXB_1" class="anchor"></span>Chapter 91:
JAXB</p>
<p>Parameter Details</p>
<p>fileObjOfXML File object of an XML file</p>
<p>className Name of a class with .<strong>class</strong> extension</p>
<p><a
href="https://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">JAXB
or Java Architecture for XML Binding</a> (JAXB) is a software framework
that allows Java developers to map Java classes to XML representations.
This Page will introduce readers to JAXB using detailed examples about
its functions</p>
<p>provided mainly for marshaling and un-marshaling Java Objects into
xml format and vice-versa.</p>
<p>Section 91.1: Reading an XML file (unmarshalling)</p>
<p>To read an XML file named UserDetails.xml with the below content</p>
<p><strong>&lt;?xml</strong> version="1.0" encoding="UTF-8"
standalone="yes"<strong>?&gt; &lt;user&gt;</strong></p>
<p>&lt;name&gt;<strong>Jon Skeet</strong>&lt;/name&gt;</p>
<p>&lt;userID&gt;<strong>8884321</strong>&lt;/userID&gt;</p>
<p>&lt;/user&gt;</p>
<p>We need a POJO class named User.java as below</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlRootElement;</p>
<p>@XmlRootElement</p>
<p>public class <strong>User {</strong></p>
<p>private long <strong>userID;</strong></p>
<p><strong>private</strong> String name;</p>
<p>// getters and setters</p>
<p>}</p>
<p>Here we have created the variables and class name according to the
XML nodes. To map them, we use the annotation XmlRootElement on the
class.</p>
<p>public class <strong>XMLReader {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>User user = JAXB.unmarshal(<strong>new</strong>
File("UserDetails.xml"), User.<strong>class</strong>);</p>
<p>System.out.println(user.getName()); <em>// prints Jon Skeet</em>
System.out.println(user.getUserID()); <em>// prints 8884321</em></p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred while reading the XML!");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Here unmarshal() method is used to parse the XML file. It takes the
XML file name and the class type as two</p>
<p>arguments. Then we can use the getter methods of the object to print
the data.</p>
<p>Section 91.2: Writing an XML file (marshalling an object)</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlRootElement;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 528</p>
<p><span id="_XmlRootElement" class="anchor"></span>@XmlRootElement</p>
<p>public class <strong>User {</strong></p>
<p>private long <strong>userID;</strong></p>
<p><strong>private</strong> String name;</p>
<p>// getters and setters</p>
<p>}</p>
<p>By using the annotation XMLRootElement, we can mark a class as a root
element of an XML file.</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> javax.xml.bind.JAXB;</p>
<p><strong>public class</strong> XMLCreator {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>User user = <strong>new</strong> User();</p>
<p>user.setName("Jon Skeet");</p>
<p>user.setUserID(8884321);</p>
<p>try <strong>{</strong></p>
<p>JAXB.marshal(user, <strong>new</strong> File("UserDetails.xml"));</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred while writing in XML!");</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>System.out.println("XML created");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>marshal() is used to write the object's content into an XML file.
Here userobject and a new File object are passed as arguments to the
marshal().</p>
<p>On successful execution, this creates an XML file named
UserDetails.xml in the class-path with the below content.</p>
<p><strong>&lt;?xml</strong> version="1.0" encoding="UTF-8"
standalone="yes"<strong>?&gt; &lt;user&gt;</strong></p>
<p>&lt;name&gt;<strong>Jon Skeet</strong>&lt;/name&gt;</p>
<p>&lt;userID&gt;<strong>8884321</strong>&lt;/userID&gt;</p>
<p>&lt;/user&gt;</p>
<p>Section 91.3: Manual field/property XML mapping</p>
<p>configuration</p>
<p>Annotations <a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElement.html">@XmlElement,</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAttribute.html">@XmlAttribute
or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlTransient.html">@XmlTransient
and other in package</a> <a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/package-summary.html">javax.xml.bind.annotation</a>
allow the programmer to specify which and how marked fields or
properties should be serialized.</p>
<p>@XmlAccessorType(XmlAccessType.NONE) <em>// we want no automatic
field/property marshalling</em> <strong>public class</strong>
ManualXmlElementsExample {</p>
<p>@XmlElement</p>
<p><strong>private</strong> String field="field value";</p>
<p>@XmlAttribute</p>
<p><strong>private</strong> String attribute="attr value";</p>
<p>@XmlAttribute(name="differentAttribute")</p>
<p><strong>private</strong> String oneAttribute="other attr value";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 529</p>
<p><span id="_XmlElement_name__different_name"
class="anchor"></span>@XmlElement(name="different name")</p>
<p><strong>private</strong> String oneName="different name value";</p>
<p>@XmlTransient</p>
<p><strong>private</strong> String transientField = "will not get
serialized ever";</p>
<p>@XmlElement</p>
<p><strong>public</strong> String getModifiedTransientValue() {</p>
<p><strong>return</strong> transientField.replace(" ever", ", unless in
a getter");</p>
<p>}</p>
<p><strong>public void</strong> setModifiedTransientValue(String val) {}
<em>// empty on purpose</em></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>JAXB.marshal(<strong>new</strong> ManualXmlElementsExample(),
System.out);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred while writing in XML!");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 91.4: Binding an XML namespace to a serializable</p>
<p>Java class</p>
<p>This is an example of a package-info.java file that binds an XML
namespace to a serializable Java class. This</p>
<p>should be placed in the same package as the Java classes that should
be serialized using the namespace.</p>
<p>/**</p>
<p>* A package containing serializable classes.</p>
<p>*/</p>
<p>@XmlSchema</p>
<p>(</p>
<p>xmlns =</p>
<p>{</p>
<p>@XmlNs(prefix = MySerializableClass.NAMESPACE_PREFIX, namespaceURI =
MySerializableClass.NAMESPACE)</p>
<p>},</p>
<p>namespace = MySerializableClass.NAMESPACE,</p>
<p>elementFormDefault = XmlNsForm.QUALIFIED</p>
<p>)</p>
<p><strong>package</strong> com.test.jaxb;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlNs;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlNsForm;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlSchema;</p>
<p>Section 91.5: Using XmlAdapter to generate desired xml</p>
<p>format</p>
<p>When desired XML format differs from Java object model, an XmlAdapter
implementation can be used to transform</p>
<p>model object into xml-format object and vice versa. This example
demonstrates how to put a field's value into an attribute of an element
with field's name.</p>
<p><strong>public class</strong> XmlAdapterExample {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 530</p>
<p>@XmlAccessorType(XmlAccessType.FIELD)</p>
<p>public static class <strong>NodeValueElement {</strong></p>
<p>@XmlAttribute(name="attrValue")</p>
<p>String value;</p>
<p><strong>public</strong> NodeValueElement() {</p>
<p>}</p>
<p><strong>public</strong> NodeValueElement(String value) {</p>
<p>super<strong>();</strong></p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p><strong>public</strong> String getValue() {</p>
<p><strong>return</strong> value;</p>
<p>}</p>
<p><strong>public void</strong> setValue(String value) {</p>
<p><strong>this</strong>.value = value;</p>
<p>}</p>
<p>}</p>
<p><strong>public static class</strong> ValueAsAttrXmlAdapter
<strong>extends</strong> XmlAdapter {</p>
<p>@Override</p>
<p><strong>public</strong> NodeValueElement marshal(String v)
<strong>throws</strong> Exception {</p>
<p><strong>return new</strong> NodeValueElement(v);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String unmarshal(NodeValueElement v)
<strong>throws</strong> Exception {</p>
<p>if <strong>(v==</strong>null<strong>)</strong> return
<strong>"";</strong></p>
<p><strong>return</strong> v.getValue();</p>
<p>}</p>
<p>}</p>
<p>@XmlRootElement(name="DataObject")</p>
<p>@XmlAccessorType(XmlAccessType.FIELD)</p>
<p>public static class <strong>DataObject {</strong></p>
<p>String elementWithValue;</p>
<p>@XmlJavaTypeAdapter(value=ValueAsAttrXmlAdapter.<strong>class</strong>)</p>
<p>String elementWithAttribute;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>DataObject data = <strong>new</strong> DataObject();</p>
<p>data.elementWithValue="value1";</p>
<p>data.elementWithAttribute ="value2";</p>
<p>ByteArrayOutputStream baos = <strong>new</strong>
ByteArrayOutputStream();</p>
<p>JAXB.marshal(data, baos);</p>
<p>String xmlString = <strong>new</strong> String(baos.toByteArray(),
StandardCharsets.UTF_8);</p>
<p>System.out.println(xmlString);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 531</p>
<p><span id="Section_91_6__Using_XmlAdapter_t"
class="anchor"></span>Section 91.6: Using XmlAdapter to trim string</p>
<p><strong>package</strong> com.example.xml.adapters;</p>
<p><strong>import</strong>
javax.xml.bind.annotation.adapters.XmlAdapter;</p>
<p><strong>public class</strong> StringTrimAdapter
<strong>extends</strong> XmlAdapter {</p>
<p>@Override</p>
<p><strong>public</strong> String unmarshal(String v)
<strong>throws</strong> Exception {</p>
<p><strong>if</strong> (v == <strong>null</strong>)</p>
<p>return null<strong>;</strong></p>
<p><strong>return</strong> v.trim();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String marshal(String v)
<strong>throws</strong> Exception {</p>
<p><strong>if</strong> (v == <strong>null</strong>)</p>
<p>return null<strong>;</strong></p>
<p><strong>return</strong> v.trim();</p>
<p>}</p>
<p>}</p>
<p>And in package-info.java add following declaration.</p>
<p>@XmlJavaTypeAdapter(value =
com.example.xml.adapters.StringTrimAdapter.<strong>class</strong>, type
= String.<strong>class</strong>) <strong>package</strong>
com.example.xml.jaxb.bindings;<em>// Packge where you intend to apply
trimming filter</em></p>
<p><strong>import</strong>
javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;</p>
<p>Section 91.7: Automatic field/property XML mapping</p>
<p>configuration (@XmlAccessorType)</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAccessorType.html">Annotation
@XmlAccessorType determines whether fields/properties will be
automatically serialized to XML. Note,</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElement.html">that
field and method annotations @XmlElement</a>, <a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAttribute.html">@XmlAttribute</a>
<a
href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlTransient.html">or
@XmlTransient take precedence over the</a> default settings.</p>
<p><strong>public class</strong> XmlAccessTypeExample {</p>
<p>@XmlAccessorType(XmlAccessType.FIELD)</p>
<p><strong>static class</strong> AccessorExampleField {</p>
<p><strong>public</strong> String field="value1";</p>
<p><strong>public</strong> String getGetter() {</p>
<p><strong>return</strong> "getter";</p>
<p>}</p>
<p><strong>public void</strong> setGetter(String value) {}</p>
<p>}</p>
<p>@XmlAccessorType(XmlAccessType.NONE)</p>
<p><strong>static class</strong> AccessorExampleNone {</p>
<p><strong>public</strong> String field="value1";</p>
<p><strong>public</strong> String getGetter() {</p>
<p><strong>return</strong> "getter";</p>
<p>}</p>
<p><strong>public void</strong> setGetter(String value) {}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 532</p>
<p>@XmlAccessorType(XmlAccessType.PROPERTY)</p>
<p><strong>static class</strong> AccessorExampleProperty {</p>
<p><strong>public</strong> String field="value1";</p>
<p><strong>public</strong> String getGetter() {</p>
<p><strong>return</strong> "getter";</p>
<p>}</p>
<p><strong>public void</strong> setGetter(String value) {}</p>
<p>}</p>
<p>@XmlAccessorType(XmlAccessType.PUBLIC_MEMBER)</p>
<p><strong>static class</strong> AccessorExamplePublic {</p>
<p><strong>public</strong> String field="value1";</p>
<p><strong>public</strong> String getGetter() {</p>
<p><strong>return</strong> "getter";</p>
<p>}</p>
<p><strong>public void</strong> setGetter(String value) {}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>System.out.println("<strong>\n</strong>Field:");</p>
<p>JAXB.marshal(<strong>new</strong> AccessorExampleField(),
System.out);</p>
<p>System.out.println("<strong>\n</strong>None:");</p>
<p>JAXB.marshal(<strong>new</strong> AccessorExampleNone(),
System.out);</p>
<p>System.out.println("<strong>\n</strong>Property:");</p>
<p>JAXB.marshal(<strong>new</strong> AccessorExampleProperty(),
System.out);</p>
<p>System.out.println("<strong>\n</strong>Public:");</p>
<p>JAXB.marshal(<strong>new</strong> AccessorExamplePublic(),
System.out);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>System.err.println("Exception occurred while writing in XML!");</p>
<p>}</p>
<p>}</p>
<p><em>}</em> // outer class end</p>
<p>Output</p>
<p>Field:</p>
<p>value1</p>
<p>None:</p>
<p>Property:</p>
<p>getter</p>
<p>Public:</p>
<p>value1</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 533</p>
<p><span id="getter" class="anchor"></span>getter</p>
<p>Section 91.8: Specifying a XmlAdapter instance to (re)use</p>
<p>existing data</p>
<p>Sometimes specific instances of data should be used. Recreation is
not desired and referencing <strong>static</strong> data would have a
code smell.</p>
<p>It is possible to specify a XmlAdapter instance the Unmarshaller
should use, which allows the user to use XmlAdapters with no zero-arg
constructor and/or pass data to the adapter.</p>
<p>Example</p>
<p>User class</p>
<p>The following class contains a name and a user's image.</p>
<p><strong>import</strong> java.awt.image.BufferedImage;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlAttribute;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlRootElement;</p>
<p><strong>import</strong>
javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;</p>
<p>@XmlRootElement</p>
<p>public class <strong>User {</strong></p>
<p><strong>private</strong> String name;</p>
<p><strong>private</strong> BufferedImage image;</p>
<p>@XmlAttribute</p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public void</strong> setName(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>@XmlJavaTypeAdapter(value=ImageCacheAdapter.<strong>class</strong>)</p>
<p>@XmlAttribute</p>
<p><strong>public</strong> BufferedImage getImage() {</p>
<p><strong>return</strong> image;</p>
<p>}</p>
<p><strong>public void</strong> setImage(BufferedImage image) {</p>
<p><strong>this</strong>.image = image;</p>
<p>}</p>
<p><strong>public</strong> User(String name, BufferedImage image) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.image = image;</p>
<p>}</p>
<p><strong>public</strong> User() {</p>
<p>this<strong>("",</strong> null<strong>);</strong></p>
<p>}</p>
<p>}</p>
<p>Adapter</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 534</p>
<p>To avoid creating the same image in memory twice (as well as
downloading the data again), the adapter stores the images in a map.</p>
<p>Version ≤ Java SE 7</p>
<p>For valid Java 7 code replace the getImage method with</p>
<p><strong>public</strong> BufferedImage getImage(URL url) {</p>
<p>BufferedImage image = imageCache.get(url);</p>
<p><strong>if</strong> (image == <strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p>image = ImageIO.read(url);</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(ImageCacheAdapter.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>imageCache.put(url, image);</p>
<p>reverseIndex.put(image, url);</p>
<p>}</p>
<p><strong>return</strong> image;</p>
<p>}</p>
<p><strong>import</strong> java.awt.image.BufferedImage;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.net.URL;</p>
<p><strong>import</strong> java.util.HashMap;</p>
<p><strong>import</strong> java.util.Map;</p>
<p><strong>import</strong> java.util.logging.Level;</p>
<p><strong>import</strong> java.util.logging.Logger;</p>
<p><strong>import</strong> javax.imageio.ImageIO;</p>
<p><strong>import</strong>
javax.xml.bind.annotation.adapters.XmlAdapter;</p>
<p><strong>public class</strong> ImageCacheAdapter
<strong>extends</strong> XmlAdapter {</p>
<p><strong>private final</strong> Map imageCache = <strong>new</strong>
HashMap&lt;&gt;(); <strong>private final</strong> Map reverseIndex =
<strong>new</strong> HashMap&lt;&gt;();</p>
<p><strong>public</strong> BufferedImage getImage(URL url) {</p>
<p>// using a single lookup using Java 8 methods</p>
<p><strong>return</strong> imageCache.computeIfAbsent(url, s -&gt; {</p>
<p>try <strong>{</strong></p>
<p>BufferedImage img = ImageIO.read(s);</p>
<p>reverseIndex.put(img, s);</p>
<p>return <strong>img;</strong></p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(ImageCacheAdapter.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> BufferedImage unmarshal(String v)
<strong>throws</strong> Exception {</p>
<p><strong>return</strong> getImage(<strong>new</strong> URL(v));</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String marshal(BufferedImage v)
<strong>throws</strong> Exception {</p>
<p><strong>return</strong> reverseIndex.get(v).toExternalForm();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 535</p>
<p>}</p>
<p>Example XMLs</p>
<p>The following 2 xmls are for <em>Jon Skeet</em> and his earth 2
counterpart, which both look exactly the same and therefore</p>
<p>use the same avatar.</p>
<p><strong>&lt;?xml</strong> version="1.0"
encoding="UTF-8"<strong>?&gt;</strong></p>
<p><strong>&lt;user</strong> name="Jon Skeet"</p>
<p>image="https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=328&amp;d=identicon&amp;r
=PG"<strong>/&gt;</strong></p>
<p><strong>&lt;?xml</strong> version="1.0"
encoding="UTF-8"<strong>?&gt;</strong></p>
<p><strong>&lt;user</strong> name="Jon Skeet (Earth 2)"</p>
<p>image="https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=328&amp;d=identicon&amp;r
=PG"<strong>/&gt;</strong></p>
<p>Using the adapter</p>
<p>ImageCacheAdapter adapter = <strong>new</strong>
ImageCacheAdapter();</p>
<p>JAXBContext context =
JAXBContext.newInstance(User.<strong>class</strong>);</p>
<p>Unmarshaller unmarshaller = context.createUnmarshaller();</p>
<p>// specifiy the adapter instance to use for every</p>
<p><em>// @XmlJavaTypeAdapter(value=ImageCacheAdapter.class)</em>
unmarshaller.setAdapter(ImageCacheAdapter.<strong>class</strong>,
adapter);</p>
<p>User result1 = (User)
unmarshaller.unmarshal(Main.<strong>class</strong>.getResource("user.xml"));</p>
<p><em>// unmarshal second xml using the same adapter instance</em>
Unmarshaller unmarshaller2 = context.createUnmarshaller();
unmarshaller2.setAdapter(ImageCacheAdapter.<strong>class</strong>,
adapter); User result2 = (User)
unmarshaller2.unmarshal(Main.<strong>class</strong>.getResource("user2.xml"));</p>
<p>System.out.println(result1.getName());</p>
<p>System.out.println(result2.getName());</p>
<p>// yields true, since image is reused</p>
<p>System.out.println(result1.getImage() == result2.getImage());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 536</p>
<p><span id="Chapter_92__Class___Java_Reflect_1"
class="anchor"></span>Chapter 92: Class - Java Reflection</p>
<p>The java.lang.Class class provides many methods that can be used to
get metadata, examine and change the run</p>
<p>time behavior of a class.</p>
<p>The java.lang and java.lang.reflect packages provide classes for java
reflection.</p>
<p>Where it is used</p>
<p>The Reflection API is mainly used in:</p>
<p>IDE (Integrated Development Environment) e.g. Eclipse, MyEclipse,
NetBeans etc. Debugger Test Tools etc.</p>
<p>Section 92.1: getClass() method of Object class</p>
<p><strong>class</strong> Simple { }</p>
<p><strong>class</strong> Test {</p>
<p><strong>void</strong> printName(Object obj){</p>
<p><strong>Class</strong> c = obj.getClass();</p>
<p>System.out.println(c.getName());</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>Simple s = <strong>new</strong> Simple();</p>
<p>Test t = <strong>new</strong> Test();</p>
<p>t.printName(s);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 537</p>
<p><span id="Chapter_93__Networking_1" class="anchor"></span>Chapter 93:
Networking</p>
<p>Section 93.1: Basic Client and Server Communication using a</p>
<p>Socket</p>
<p>Server: Start, and wait for incoming connections</p>
<p>//Open a listening "ServerSocket" on port 1234.</p>
<p>ServerSocket serverSocket = <strong>new</strong>
ServerSocket(1234);</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>// Wait for a client connection.</p>
<p>// Once a client connected, we get a "Socket" object // that can be
used to send and receive messages to/from the newly // connected
client</p>
<p>Socket clientSocket = serverSocket.accept();</p>
<p>// Here we'll add the code to handle one specific client.</p>
<p>}</p>
<p>Server: Handling clients</p>
<p>We'll handle each client in a separate thread so multiple clients
could interact with the server at the same time. This technique works
fine as long as the number of clients is low (&lt;&lt; 1000 clients,
depending on the OS architecture and</p>
<p>the expected load of each thread).</p>
<p><strong>new</strong> Thread(()-&gt; {</p>
<p>// Get the socket's InputStream, to read bytes from the socket
<em>InputStream in = clientSocket.getInputStream();</em></p>
<p>// wrap the InputStream in a reader so you can read a String instead
of bytes <em>BufferedReader reader = <strong>new</strong>
BufferedReader(</em></p>
<p><strong>new</strong> InputStreamReader(in,
StandardCharsets.UTF_8));</p>
<p>// Read text from the socket and print line by line <em>String
line;</em></p>
<p><strong>while</strong> ((line = reader.readLine()) !=
<strong>null</strong>) {</p>
<p>System.out.println(line);</p>
<p>}</p>
<p>}).start();</p>
<p>Client: Connect to the server and send a message</p>
<p>// 127.0.0.1 is the address of the server (this is the localhost
address; i.e. // the address of our own machine)</p>
<p>// 1234 is the port that the server will be listening on <em>Socket
socket = <strong>new</strong> Socket("127.0.0.1", 1234);</em></p>
<p><em>// Write a string into the socket, and flush the buffer</em>
OutputStream outStream = socket.getOutputStream(); PrintWriter writer =
<strong>new</strong> PrintWriter(</p>
<p><strong>new</strong> OutputStreamWriter(outStream,
StandardCharsets.UTF_8));</p>
<p>writer.println("Hello world!");</p>
<p>writer.flush();</p>
<p>Closing Sockets and Handling Exceptions</p>
<p>The above examples left out some things to make them easier to
read.</p>
<p>1. Just like files and other external resources, it's important we
tell the OS when we're done with them. When</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 538</p>
<p>we're done with a socket, call socket.close() to properly close
it.</p>
<p>2. Sockets handle I/O (Input/Output) operations that depend on a
variety of external factors. For example what</p>
<p>if the other side suddenly disconnects? What if there are network
error? These things are beyond our control.</p>
<p>This is why many socket operations might throw exceptions, especially
IOException.</p>
<p>A more complete code for the client would therefore be something like
this:</p>
<p>// "try-with-resources" will close the socket once we leave its scope
<em><strong>try</strong> (Socket socket = <strong>new</strong>
Socket("127.0.0.1", 1234)) {</em></p>
<p>OutputStream outStream = socket.getOutputStream(); PrintWriter writer
= <strong>new</strong> PrintWriter(</p>
<p><strong>new</strong> OutputStreamWriter(outStream,
StandardCharsets.UTF_8));</p>
<p>writer.println("Hello world!");</p>
<p>writer.flush();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>//Handle the error</p>
<p>}</p>
<p>Basic Server and Client - complete examples</p>
<p>Server:</p>
<p><strong>import</strong> java.io.BufferedReader;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.InputStream;</p>
<p><strong>import</strong> java.io.InputStreamReader;</p>
<p><strong>import</strong> java.net.ServerSocket;</p>
<p><strong>import</strong> java.net.Socket;</p>
<p><strong>import</strong> java.nio.charset.StandardCharsets;</p>
<p>public class <strong>Server {</strong></p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p><strong>try</strong> (ServerSocket serverSocket =
<strong>new</strong> ServerSocket(1234)) {</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>// Wait for a client connection.</p>
<p>Socket clientSocket = serverSocket.accept();</p>
<p>// Create and start a thread to handle the new client
<em><strong>new</strong> Thread(()-&gt; {</em></p>
<p>try <strong>{</strong></p>
<p>// Get the socket's InputStream, to read bytes</p>
<p>// from the socket</p>
<p>InputStream in = clientSocket.getInputStream();</p>
<p>// wrap the InputStream in a reader so you can</p>
<p>// read a String instead of bytes</p>
<p>BufferedReader reader = <strong>new</strong> BufferedReader(</p>
<p><strong>new</strong> InputStreamReader(in,
StandardCharsets.UTF_8));</p>
<p>// Read from the socket and print line by line</p>
<p>String line;</p>
<p><strong>while</strong> ((line = reader.readLine()) !=
<strong>null</strong>) {</p>
<p>System.out.println(line);</p>
<p>}</p>
<p>}</p>
<p><strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>// This finally block ensures the socket is closed. // A
try-with-resources block cannot be used because // the socket is passed
into a thread, so it isn't</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 539</p>
<p><span id="___created_and_closed_in_the_sam" class="anchor"></span>//
created and closed in the same block</p>
<p>try <strong>{</strong></p>
<p>clientSocket.close();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}).start();</p>
<p>}</p>
<p>}</p>
<p><strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Client:</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.OutputStream;</p>
<p><strong>import</strong> java.io.OutputStreamWriter;</p>
<p><strong>import</strong> java.io.PrintWriter;</p>
<p><strong>import</strong> java.net.Socket;</p>
<p><strong>import</strong> java.nio.charset.StandardCharsets;</p>
<p>public class <strong>Client {</strong></p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p><strong>try</strong> (Socket socket = <strong>new</strong>
Socket("127.0.0.1", 1234)) {</p>
<p>// We'll reach this code once we've connected to the server</p>
<p><em>// Write a string into the socket, and flush the buffer</em>
OutputStream outStream = socket.getOutputStream(); PrintWriter writer =
<strong>new</strong> PrintWriter(</p>
<p><strong>new</strong> OutputStreamWriter(outStream,
StandardCharsets.UTF_8));</p>
<p>writer.println("Hello world!");</p>
<p>writer.flush();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>// Exception should be handled.</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 93.2: Basic Client/Server Communication using UDP</p>
<p>(Datagram)</p>
<p>Client.java</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>import</strong> java.net.*;</p>
<p>public class <strong>Client{</strong></p>
<p><strong>public static void</strong> main(String [] args)
<strong>throws</strong> IOException{</p>
<p>DatagramSocket clientSocket = <strong>new</strong>
DatagramSocket();</p>
<p>InetAddress address = InetAddress.getByName(args[0]);</p>
<p>String ex = "Hello, World!";</p>
<p><strong>byte</strong>[] buf = ex.getBytes();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 540</p>
<p><span id="DatagramPacket_packet___new_Data"
class="anchor"></span>DatagramPacket packet = <strong>new</strong>
DatagramPacket(buf,buf.length, address, 4160);</p>
<p>clientSocket.send(packet);</p>
<p>}</p>
<p>}</p>
<p>In this case, we pass in the address of the server, via an argument
(args[0]). The port we are using is 4160.</p>
<p>Server.java</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>import</strong> java.net.*;</p>
<p>public class <strong>Server{</strong></p>
<p><strong>public static void</strong> main(String [] args)
<strong>throws</strong> IOException{</p>
<p>DatagramSocket serverSocket = <strong>new</strong>
DatagramSocket(4160);</p>
<p><strong>byte</strong>[] rbuf = <strong>new byte</strong>[256];</p>
<p>DatagramPacket packet = <strong>new</strong> DatagramPacket(rbuf,
rbuf.length);</p>
<p>serverSocket.receive(packet);</p>
<p>String response = <strong>new</strong> String(packet.getData());</p>
<p>System.out.println("Response: " + response);</p>
<p>}</p>
<p>}</p>
<p>On the server-side, declare a DatagramSocket on the same port which
we sent our message to (4160) and wait for a response.</p>
<p>Section 93.3: Loading TrustStore and KeyStore from</p>
<p>InputStream</p>
<p><strong>public class</strong> TrustLoader {</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>try <strong>{</strong></p>
<p>//Gets the inputstream of a a trust store file under
ssl/rpgrenadesClient.jks //This path refers to the ssl folder in the jar
file, in a jar file in the same</p>
<p>directory</p>
<p>//as this jar file, or a different directory in the same directory as
the jar file <em>InputStream stream =</em></p>
<p>TrustLoader.<strong>class</strong>.getResourceAsStream("/ssl/rpgrenadesClient.jks");</p>
<p>//Both trustStores and keyStores are represented by the KeyStore
object <em>KeyStore trustStore =
KeyStore.getInstance(KeyStore.getDefaultType());</em> //The password for
the trustStore</p>
<p><strong>char</strong>[] trustStorePassword =
"password".toCharArray(); <em>//This loads the trust store into the
object</em></p>
<p>trustStore.load(stream, trustStorePassword);</p>
<p>//This is defining the SSLContext so the trust store will be used
//Getting default SSLContext to edit.</p>
<p>SSLContext context = SSLContext.getInstance("SSL");</p>
<p>//TrustMangers hold trust stores, more than one can be added</p>
<p>TrustManagerFactory factory =</p>
<p>TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</p>
<p>//Adds the truststore to the factory</p>
<p>factory.init(trustStore);</p>
<p>//This is passed to the SSLContext init method</p>
<p>TrustManager[] managers = factory.getTrustManagers();</p>
<p>context.init(<strong>null</strong>, managers,
<strong>null</strong>);</p>
<p>//Sets our new SSLContext to be used.</p>
<p>SSLContext.setDefault(context);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 541</p>
<p><span id="__catch__KeyStoreException___IOE" class="anchor"></span>}
<strong>catch</strong> (KeyStoreException | IOException |
NoSuchAlgorithmException</p>
<p>| CertificateException | KeyManagementException ex) {</p>
<p>//Handle error</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Intiating a KeyStore works the same, except replace any word Trust in
a object name with Key. Additionally, the</p>
<p>KeyManager[] array must be passed to the the first argument of
SSLContext.init. That is SSLContext.init(keyMangers, trustMangers,
<strong>null</strong>)</p>
<p>Section 93.4: Socket example - reading a web page using a</p>
<p>simple socket</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>import</strong> java.net.Socket;</p>
<p>public class <strong>Main {</strong></p>
<p><em><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</em>//We don't handle Exceptions
in this</p>
<p>example</p>
<p>//Open a socket to stackoverflow.com, port 80</p>
<p>Socket socket = <strong>new</strong>
Socket("stackoverflow.com",80);</p>
<p><em>//Prepare input, output stream before sending request</em>
OutputStream outStream = socket.getOutputStream(); InputStream inStream
= socket.getInputStream();</p>
<p>BufferedReader reader = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(inStream));
PrintWriter writer = <strong>new</strong>
PrintWriter(<strong>new</strong> BufferedOutputStream(outStream));</p>
<p>//Send a basic HTTP header</p>
<p>writer.print("GET /
HTTP/1.1<strong>\n</strong>Host:stackoverflow.com<strong>\n\n</strong>");</p>
<p>writer.flush();</p>
<p>//Read the response</p>
<p>System.out.println(readFully(reader));</p>
<p>//Close the socket</p>
<p>socket.close();</p>
<p>}</p>
<p><strong>private static</strong> String readFully(Reader in) {</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder();</p>
<p><strong>int</strong> BUFFER_SIZE=1024;</p>
<p><strong>char</strong>[] buffer = <strong>new
char</strong>[BUFFER_SIZE]; <em>// or some other size,</em>
<strong>int</strong> charsRead = 0;</p>
<p><strong>while</strong> ( (charsRead = rd.read(buffer, 0,
BUFFER_SIZE)) !=-1) {</p>
<p>sb.append(buffer, 0, charsRead);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>You should get a response that starts with HTTP/1.1 200 OK, which
indicates a normal HTTP response, followed by</p>
<p>the rest of the HTTP header, followed by the raw web page in HTML
form.</p>
<p>Note the readFully() method is important to prevent a premature EOF
exception. The last line of the web page</p>
<p>may be missing a return, to signal the end of line, then readLine()
will complain, so one must read it by hand or</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 542</p>
<p><span id="use_utility_methods_from_Apache" class="anchor"></span><a
href="https://github.com/apache/commons-io/blob/2.5/src/main/java/org/apache/commons/io/IOUtils.java">use
utility methods from Apache commons-io IOUtils</a></p>
<p>This example is meant as a simple demonstration of connecting to an
existing resource using a socket, it's not a</p>
<p>practical way of accessing web pages. If you need to access a web
page using Java, it's best to use an existing HTTP</p>
<p>client library such as <a
href="https://hc.apache.org/httpcomponents-client-ga/">Apache's HTTP
Client or</a> <a
href="https://developers.google.com/api-client-library/java/google-http-java-client/">Google's
HTTP Client</a></p>
<p>Section 93.5: Temporarily disable SSL verification (for testing</p>
<p>purposes)</p>
<p>Sometimes in a development or testing environment, the SSL
certificate chain might not have been fully established</p>
<p>(yet).</p>
<p>To continue developing and testing, you can turn off SSL verification
programmatically by installing an "all-trusting" trust manager:</p>
<p>try <strong>{</strong></p>
<p>// Create a trust manager that does not validate certificate
chains</p>
<p>TrustManager[] trustAllCerts = <strong>new</strong> TrustManager[]
{</p>
<p><strong>new</strong> X509TrustManager() {</p>
<p><strong>public</strong> X509Certificate[] getAcceptedIssuers() {</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p><strong>public void</strong> checkClientTrusted(X509Certificate[]
certs, String authType) { }</p>
<p><strong>public void</strong> checkServerTrusted(X509Certificate[]
certs, String authType) { }</p>
<p>}</p>
<p>};</p>
<p>// Install the all-trusting trust manager</p>
<p>SSLContext sc = SSLContext.getInstance("SSL");</p>
<p>sc.init(<strong>null</strong>, trustAllCerts, <strong>new</strong>
java.security.SecureRandom());</p>
<p>HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</p>
<p>// Create all-trusting host name verifier</p>
<p>HostnameVerifier allHostsValid = <strong>new</strong>
HostnameVerifier() {</p>
<p><strong>public boolean</strong> verify(String hostname, SSLSession
session) {</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p>};</p>
<p>// Install the all-trusting host verifier</p>
<p>HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid); }
<strong>catch</strong> (NoSuchAlgorithmException |
KeyManagementException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 93.6: Downloading a file using Channel</p>
<p>If the file already exists, it will be overwritten!</p>
<p>String fileName = "file.zip"; <em>// name of the file</em> String
urlToGetFrom = "http://www.mywebsite.com/"; <em>// URL to get it
from</em> String pathToSaveTo =
"C:<strong>\\</strong>Users<strong>\\</strong>user<strong>\\</strong>";
<em>// where to put it</em></p>
<p>//If the file already exists, it will be overwritten!</p>
<p>//Opening OutputStream to the destination file</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 543</p>
<p><span id="try__ReadableByteChannel_rbc"
class="anchor"></span><strong>try</strong> (ReadableByteChannel rbc
=</p>
<p>Channels.newChannel(<strong>new</strong> URL(urlToGetFrom +
fileName).openStream()) ) {</p>
<p><strong>try</strong> ( FileChannel channel =</p>
<p><strong>new</strong> FileOutputStream(pathToSaveTo +
fileName).getChannel(); ) {</p>
<p>channel.transferFrom(rbc, 0, Long.MAX_VALUE);</p>
<p>}</p>
<p><strong>catch</strong> (FileNotFoundException e) { <em>/* Output
directory not found */</em> } <strong>catch</strong> (IOException e) {
<em>/* File IO error */</em> }</p>
<p>}</p>
<p><em><strong>catch</strong> (MalformedURLException e) {</em> /* URL is
malformed */ <em>} <strong>catch</strong> (IOException e) {</em> /* IO
error connecting to website */ <em>}</em></p>
<p>Notes</p>
<p>Don't leave the catch blocks empty!</p>
<p>In case of error, check if the remote file exists</p>
<p>This is a blocking operation, can take long time with large files</p>
<p>Section 93.7: Multicasting</p>
<p>Multicasting is a type of Datagram Socket. Unlike regular Datagrams,
Multicasting doesn't handle each client</p>
<p>individually instead it sends it out to one IP Address and all
subscribed clients will get the message.</p>
<p><img src="media/index-568_1.jpeg"
style="width:5.09722in;height:2.97222in" alt="index-568_1.jpg" /></p>
<p>Example code for a server side:</p>
<p>public class <strong>Server {</strong></p>
<p><strong>private</strong> DatagramSocket serverSocket;</p>
<p><strong>private</strong> String ip;</p>
<p>private int <strong>port;</strong></p>
<p><strong>public</strong> Server(String ip, <strong>int</strong> port)
<strong>throws</strong> SocketException, IOException{</p>
<p><strong>this</strong>.ip = ip;</p>
<p><strong>this</strong>.port = port;</p>
<p>// socket used to send</p>
<p>serverSocket = <strong>new</strong> DatagramSocket();</p>
<p>}</p>
<p><strong>public void</strong> send() <strong>throws</strong>
IOException{</p>
<p>// make datagram packet</p>
<p><strong>byte</strong>[] message = ("Multicasting...").getBytes();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 544</p>
<p>DatagramPacket packet = <strong>new</strong> DatagramPacket(message,
message.length,</p>
<p>InetAddress.getByName(ip), port);</p>
<p>// send packet</p>
<p>serverSocket.send(packet);</p>
<p>}</p>
<p>public void <strong>close(){</strong></p>
<p>serverSocket.close();</p>
<p>}</p>
<p>}</p>
<p>Example code for a client side:</p>
<p>public class <strong>Client {</strong></p>
<p><strong>private</strong> MulticastSocket socket;</p>
<p><strong>public</strong> Client(String ip, <strong>int</strong> port)
<strong>throws</strong> IOException {</p>
<p>// important that this is a multicast socket</p>
<p>socket = <strong>new</strong> MulticastSocket(port);</p>
<p>// join by ip</p>
<p>socket.joinGroup(InetAddress.getByName(ip));</p>
<p>}</p>
<p><strong>public void</strong> printMessage() <strong>throws</strong>
IOException{</p>
<p>// make datagram packet to recieve</p>
<p><strong>byte</strong>[] message = <strong>new byte</strong>[256];</p>
<p>DatagramPacket packet = <strong>new</strong> DatagramPacket(message,
message.length);</p>
<p>// recieve the packet</p>
<p>socket.receive(packet);</p>
<p>System.out.println(<strong>new</strong>
String(packet.getData()));</p>
<p>}</p>
<p>public void <strong>close(){</strong></p>
<p>socket.close();</p>
<p>}</p>
<p>}</p>
<p>Code for running the Server:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p><strong>final</strong> String ip = args[0];</p>
<p><strong>final int</strong> port = Integer.parseInt(args[1]);</p>
<p>Server server = <strong>new</strong> Server(ip, port);</p>
<p>server.send();</p>
<p>server.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>Code for running a Client:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p><strong>final</strong> String ip = args[0];</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 545</p>
<p><strong>final int</strong> port = Integer.parseInt(args[1]);</p>
<p>Client client = <strong>new</strong> Client(ip, port);</p>
<p>client.printMessage();</p>
<p>client.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>Run the Client First:</strong> The Client must subscribe to
the IP before it can start receiving any packets. If you start the</p>
<p>server and call the send() method, and then make a client (&amp; call
printMessage()). Nothing will happen because</p>
<p>the client connected after the message was sent.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 546</p>
<p><span id="Chapter_94__NIO___Networking_1"
class="anchor"></span>Chapter 94: NIO - Networking</p>
<p>Section 94.1: Using Selector to wait for events (example with</p>
<p>OP_CONNECT)</p>
<p>NIO appeared in Java 1.4 and introduced the concept of "Channels",
which are supposed to be faster than regular</p>
<p>I/O. Network-wise, the <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/channels/SelectableChannel.html">SelectableChannel</a>
is the most interesting as it allows to monitor different states of the
Channel. It works in a similar manner as the C <strong>SELECT</strong>()
system call: we get woken-up when certain types of events</p>
<p>occur:</p>
<p>connection received (OP_ACCEPT)</p>
<p>connection realized (OP_CONNECT)</p>
<p>data available in read FIFO (OP_READ)</p>
<p>data can be pushed to write FIFO (OP_WRITE)</p>
<p>It allows for separation between <em>detecting</em> socket I/O
(something can be read/written/...) and <em>performing</em> the I/O</p>
<p>(read/write/...). Especially, all I/O detection can be done in a
single thread for multiple sockets (clients), while performing I/O can
be handled in a thread pool or anywhere else. That allows for an
application to scale easily to</p>
<p>the number of connected clients.</p>
<p>The following example shows the basics:</p>
<p>1. Create a <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html">Selector</a></p>
<p>2. Create a <a
href="https://docs.oracle.com/javase/7/docs/api/java/nio/channels/SocketChannel.html">SocketChannel</a></p>
<p>3. Register the SocketChannelto the Selector</p>
<p>4. Loop with the Selector to detect events</p>
<p>Selector sel = Selector.open(); // <strong>CREATE</strong> the
Selector SocketChannel sc = SocketChannel.open(); //
<strong>CREATE</strong> a SocketChannel
sc.configureBlocking(<strong>FALSE</strong>); // ... non blocking</p>
<p>sc.setOption(StandardSocketOptions.SO_KEEPALIVE,
<strong>TRUE</strong>); // ... <strong>SET SOME</strong> options</p>
<p>// Register the Channel <strong>TO</strong> the Selector
<strong>FOR</strong> wake-up <strong>ON CONNECT</strong> event
<strong>AND USE SOME</strong> description <strong>AS</strong> an
attachement</p>
<p>sc.register(sel, SelectionKey.OP_CONNECT, "Connection to
google.com"); // <strong>RETURNS</strong> a SelectionKey: the
association <strong>BETWEEN</strong> the SocketChannel
<strong>AND</strong> the Selector System.out.println("Initiating
connection");</p>
<p><strong>IF</strong> (sc.connect(<strong>NEW</strong>
InetSocketAddress("www.google.com", 80)))</p>
<p>System.out.println("Connected"); // Connected right-away: nothing
<strong>ELSE TO</strong> do <strong>ELSE</strong> {</p>
<p>BOOLEAN <strong>exit =</strong> FALSE<strong>;</strong></p>
<p>while (!exit) {</p>
<p><strong>IF</strong> (sel.select(100) == 0) // Did something happen
<strong>ON SOME</strong> registered Channels during the</p>
<p><strong>LAST</strong> 100ms?</p>
<p>continue; // No, wait <strong>SOME</strong> more</p>
<p>// Something happened...</p>
<p>Set <strong>KEYS</strong> = sel.selectedKeys(); // List
<strong>OF</strong> SelectionKeys <strong>ON</strong> which
<strong>SOME</strong> registered operation was triggered</p>
<p><strong>FOR</strong> (SelectionKey k : <strong>KEYS</strong>) {</p>
<p>System.out.println("Checking "+k.attachment());</p>
<p><strong>IF</strong> (k.isConnectable()) { // <strong>CONNECT</strong>
event</p>
<p>System.out.print("Connected through select() on "+k.channel()+" -&gt;
");</p>
<p><strong>IF</strong> (sc.finishConnect()) { // Finish connection
process</p>
<p>System.out.println("done!");</p>
<p>k.interestOps(k.interestOps() &amp; ~SelectionKey.OP_CONNECT); // We
are already connected: remove interest <strong>IN CONNECT</strong>
event</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 547</p>
<p>exit = <strong>TRUE</strong>;</p>
<p><strong>}</strong> ELSE</p>
<p>System.out.println("unfinished...");</p>
<p>}</p>
<p>// TODO: <strong>ELSE IF</strong> (k.isReadable()) { ...</p>
<p>}</p>
<p><strong>KEYS</strong>.clear(); // Have <strong>TO</strong> clear the
selected <strong>KEYS SET</strong> once processed!</p>
<p>}</p>
<p>}</p>
<p>System.out.print("Disconnecting ... ");</p>
<p>sc.shutdownOutput(); // Initiate graceful disconnection // TODO:
empty receive buffer</p>
<p>sc.close();</p>
<p>System.out.println("done");</p>
<p>Would give the following output:</p>
<p>Initiating connection</p>
<p>Checking Connection to google.com</p>
<p>Connected through 'select()' on
java.nio.channels.SocketChannel[connection-pending
remote=www.google.com/216.58.208.228:80] -&gt; done!</p>
<p>Disconnecting ... done</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 548</p>
<p><span id="Chapter_95__HttpURLConnection_1"
class="anchor"></span>Chapter 95: HttpURLConnection</p>
<p>Section 95.1: Get response body from a URL as a String</p>
<p>String getText(String url) <strong>throws</strong> IOException {</p>
<p>HttpURLConnection connection = (HttpURLConnection)
<strong>new</strong> URL(url).openConnection(); <em>//add headers to the
connection, or check the status if desired..</em></p>
<p>// handle error response code it occurs</p>
<p><strong>int</strong> responseCode = conn.getResponseCode();</p>
<p>InputStream inputStream;</p>
<p><strong>if</strong> (200 &lt;= responseCode &amp;&amp; responseCode
&lt;= 299) {</p>
<p>inputStream = connection.getInputStream();</p>
<p>} <strong>else</strong> {</p>
<p>inputStream = connection.getErrorStream();</p>
<p>}</p>
<p>BufferedReader in = <strong>new</strong> BufferedReader(</p>
<p><strong>new</strong> InputStreamReader(</p>
<p>inputStream));</p>
<p>StringBuilder response = <strong>new</strong> StringBuilder();</p>
<p>String currentLine;</p>
<p><strong>while</strong> ((currentLine = in.readLine()) !=
<strong>null</strong>)</p>
<p>response.append(currentLine);</p>
<p>in.close();</p>
<p><strong>return</strong> response.toString();</p>
<p>}</p>
<p>This will download text data from the specified URL, and return it as
a String.</p>
<p>How this works:</p>
<p>First, we create a HttpUrlConnection from our URL, with
<strong>new</strong> URL(url).openConnection(). We cast the
UrlConnection this returns to a HttpUrlConnection, so we have access to
things like adding headers (such as</p>
<p>User Agent), or checking the response code. (This example does not do
that, but it's easy to add.)</p>
<p>Then, create InputStream basing on the response code (for error
handling)</p>
<p>Then, create a BufferedReader which allows us to read text from
InputStream we get from the connection.</p>
<p>Now, we append the text to a StringBuilder, line by line.</p>
<p>Close the InputStream, and return the String we now have.</p>
<p>Notes:</p>
<p>This method will throw an IoException in case of failure (such as a
network error, or no internet connection), and it will also throw an
<em>unchecked</em> MalformedUrlException if the given URL is not
valid.</p>
<p>It can be used for reading from any URL which returns text, such as
webpages (HTML), REST APIs which</p>
<p>return JSON or XML, etc.</p>
<p>See also: <a
href="http://stackoverflow.com/questions/4328711/read-url-to-string-in-few-lines-of-java-code">Read
URL to String in few lines of Java code.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 549</p>
<p><span id="Usage" class="anchor"></span>Usage:</p>
<p>Is very simple:</p>
<p>String text = getText(”http:<em>//example.com");</em></p>
<p>//Do something with the text from example.com, in this case the
HTML.</p>
<p>Section 95.2: POST data</p>
<p><strong>public static void</strong> post(String url,
<strong>byte</strong> [] data, String contentType)
<strong>throws</strong> IOException {</p>
<p>HttpURLConnection connection = <strong>null</strong>;</p>
<p>OutputStream out = <strong>null</strong>;</p>
<p>InputStream in = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>connection = (HttpURLConnection) <strong>new</strong>
URL(url).openConnection();</p>
<p>connection.setRequestProperty("Content-Type", contentType);</p>
<p>connection.setDoOutput(<strong>true</strong>);</p>
<p>out = connection.getOutputStream();</p>
<p>out.write(data);</p>
<p>out.close();</p>
<p>in = connection.getInputStream();</p>
<p>BufferedReader reader = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(in)); String line
= <strong>null</strong>;</p>
<p><strong>while</strong> ((line = reader.readLine()) !=
<strong>null</strong>) {</p>
<p>System.out.println(line);</p>
<p>}</p>
<p>in.close();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (connection != <strong>null</strong>)
connection.disconnect();</p>
<p><strong>if</strong> (out != <strong>null</strong>) out.close();</p>
<p><strong>if</strong> (in != <strong>null</strong>) in.close();</p>
<p>}</p>
<p>}</p>
<p>This will POST data to the specified URL, then read the response
line-by-line.</p>
<p>How it works</p>
<p>As usual we obtain the HttpURLConnection from a URL.</p>
<p>Set the content type using setRequestProperty, by default it's
application/x-www-form-urlencoded setDoOutput(<strong>true</strong>)
tells the connection that we will send data.</p>
<p>Then we obtain the OutputStream by calling getOutputStream() and
write data to it. Don't forget to close it after you are done.</p>
<p>At last we read the server response.</p>
<p>Section 95.3: Delete resource</p>
<p><strong>public static void</strong> delete (String urlString, String
contentType) <strong>throws</strong> IOException {</p>
<p>HttpURLConnection connection = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>URL url = <strong>new</strong> URL(urlString);</p>
<p>connection = (HttpURLConnection) url.openConnection();</p>
<p>connection.setDoInput(<strong>true</strong>);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 550</p>
<p><span id="connection_setRequestMethod__DEL"
class="anchor"></span>connection.setRequestMethod("DELETE");</p>
<p>connection.setRequestProperty("Content-Type", contentType);</p>
<p>Map&gt; map = connection.getHeaderFields();</p>
<p>StringBuilder sb = <strong>new</strong> StringBuilder();</p>
<p>Iterator&gt; iterator = responseHeader.entrySet().iterator();</p>
<p><strong>while</strong>(iterator.hasNext())</p>
<p>{</p>
<p>Map.Entry entry = iterator.next();</p>
<p>sb.append(entry.getKey());</p>
<p>sb.append('=').append('"');</p>
<p>sb.append(entry.getValue());</p>
<p>sb.append('"');</p>
<p><strong>if</strong>(iterator.hasNext())</p>
<p>{</p>
<p>sb.append(',').append(' ');</p>
<p>}</p>
<p>}</p>
<p>System.out.println(sb.toString());</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (connection != <strong>null</strong>)
connection.disconnect();</p>
<p>}</p>
<p>}</p>
<p>This will DELETE the resource in the specified URL, then print the
response header.</p>
<p>How it works</p>
<p>we obtain the HttpURLConnection from a URL.</p>
<p>Set the content type using setRequestProperty, by default it's
application/x-www-form-urlencoded</p>
<p>setDoInput(<strong>true</strong>) tells the connection that we intend
to use the URL connection for input. setRequestMethod("DELETE") to
perform HTTP DELETE</p>
<p>At last we print the server response header.</p>
<p>Section 95.4: Check if resource exists</p>
<p>/**</p>
<p>* Checks if a resource exists by sending a HEAD-Request. * @param url
The url of a resource which has to be checked. * @return true if the
response code is 200 OK.</p>
<p>*/</p>
<p><strong>public static final boolean</strong>
checkIfResourceExists(URL url) <strong>throws</strong> IOException {</p>
<p>HttpURLConnection conn = (HttpURLConnection)
url.openConnection();</p>
<p>conn.setRequestMethod("HEAD");</p>
<p><strong>int</strong> code = conn.getResponseCode();</p>
<p>conn.disconnect();</p>
<p><strong>return</strong> code == 200;</p>
<p>}</p>
<p>Explanation:</p>
<p>If you are just checking if a resource exists, it better to use a
HEAD request than a GET. This avoids the overhead of transferring the
resource.</p>
<p>Note that the method only returns <strong>true</strong> if the
response code is 200. If you anticipate redirect (i.e. 3XX) responses,
then the method may need to be enhanced to honor them.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 551</p>
<p>Example:</p>
<p>checkIfResourceExists(<strong>new</strong>
URL("http://images.google.com/")); <em>// true</em>
checkIfResourceExists(<strong>new</strong>
URL("http://pictures.google.com/")); <em>// false</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 552</p>
<p><span id="Chapter_96__JAX_WS_1" class="anchor"></span>Chapter 96:
JAX-WS</p>
<p>Section 96.1: Basic Authentication</p>
<p>The way to do a JAX-WS call with basic authentication is a little
unobvious.</p>
<p>Here is an example where Service is the service class representation
and Port is the service port you want to</p>
<p>access.</p>
<p>Service s = <strong>new</strong> Service();</p>
<p>Port port = s.getPort();</p>
<p>BindingProvider prov = (BindingProvider)port;</p>
<p>prov.getRequestContext().put(BindingProvider.USERNAME_PROPERTY,
"myusername");
prov.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY,
"mypassword");</p>
<p>port.call();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 553</p>
<p><span id="Chapter_97__Nashorn_JavaScript_e_1"
class="anchor"></span>Chapter 97: Nashorn JavaScript engine</p>
<p><a
href="https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)">Nashorn
is a JavaScript engine developed in Java by Oracle, and has been
released with Java 8. Nashorn allows</a></p>
<p>embedding Javascript in Java applications via JSR-223 and allows to
develop standalone Javascript applications, and</p>
<p><a
href="http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html">it
provides better runtime performance and better compliance with the ECMA
normalized Javascript specification.</a></p>
<p>Section 97.1: Execute JavaScript file</p>
<p>// Required imports</p>
<p><strong>import</strong> javax.script.ScriptEngineManager;</p>
<p><strong>import</strong> javax.script.ScriptEngine;</p>
<p><strong>import</strong> javax.script.ScriptException;</p>
<p><strong>import</strong> java.io.FileReader;</p>
<p><strong>import</strong> java.io.FileNotFoundException;</p>
<p>// Obtain an instance of the JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("nashorn");</p>
<p>// Load and execute a script from the file 'demo.js'
<em><strong>try</strong> {</em></p>
<p>engine.eval(<strong>new</strong> FileReader("demo.js"));</p>
<p>} <strong>catch</strong> (FileNotFoundException ex) {</p>
<p>ex.printStackTrace();</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>// This is the generic Exception subclass for the Scripting API</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// 'Script from file!' printed on standard output</p>
<p>demo.js<em>:</em></p>
<p>print('Script from file!');</p>
<p>Section 97.2: Intercept script output</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("nashorn");</p>
<p>// Setup a custom writer</p>
<p>StringWriter stringWriter = <strong>new</strong> StringWriter();</p>
<p>// Modify the engine context so that the custom writer is now the
default // output writer of the engine</p>
<p>engine.getContext().setWriter(stringWriter);</p>
<p>// Execute some script</p>
<p>try <strong>{</strong></p>
<p>engine.eval("print('Redirected text!');");</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// Nothing printed on standard output, but</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 554</p>
<p><span id="___stringWriter_toString___conta" class="anchor"></span>//
stringWriter.toString() contains 'Redirected text!'</p>
<p>Section 97.3: Hello Nashorn</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("nashorn");</p>
<p>// Execute an hardcoded script</p>
<p>try <strong>{</strong></p>
<p>engine.eval("print('Hello Nashorn!');");</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>// This is the generic Exception subclass for the Scripting API</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// 'Hello Nashorn!' printed on standard output</p>
<p>Section 97.4: Evaluate Arithmetic Strings</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("JavaScript");</p>
<p>//String to be evaluated</p>
<p>String str = "3+2*4+5";</p>
<p>//Value after doing Arithmetic operation with operator precedence
will be 16</p>
<p>//Printing the value</p>
<p>try <strong>{</strong></p>
<p>System.out.println(engine.eval(str));</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>//Outcome:</p>
<p>//Value of the string after arithmetic evaluation is printed on
standard output. //In this case '16.0' will be printed on standard
output.</p>
<p>Section 97.5: Set global variables</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("nashorn");</p>
<p>// Define a global variable</p>
<p>engine.put("textToPrint", "Data defined in Java.");</p>
<p>// Print the global variable</p>
<p>try <strong>{</strong></p>
<p>engine.eval("print(textToPrint);");</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// 'Data defined in Java.' printed on standard output</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 555</p>
<p><span id="Section_97_6__Set_and_get_global"
class="anchor"></span>Section 97.6: Set and get global variables</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager(); ScriptEngine engine =
manager.getEngineByName("nashorn");</p>
<p>try <strong>{</strong></p>
<p>// Set value in the global name space of the engine</p>
<p>engine.put("name","Nashorn");</p>
<p>// Execute an hardcoded script</p>
<p>engine.eval("var value='Hello '+name+'!';");</p>
<p>// Get value</p>
<p>String value=(String)engine.get("value");</p>
<p>System.out.println(value);</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>// This is the generic Exception subclass for the Scripting API</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// 'Hello Nashorn!' printed on standard output</p>
<p>Section 97.7: Usage of Java objects in JavaScript in Nashorn</p>
<p>It's possible to pass Java objects to Nashorn engine to be processed
in Java code. At the same time, there are some</p>
<p>JavaScript (and Nashorn) specific constructions, and it's not always
clear how they work with java objects.</p>
<p>Below there is a table which describes behaviour of native Java
objects inside JavaScript constructions.</p>
<p>Tested constructions:</p>
<p>1. Expression in if clause. In JS expression in if clause doesn't
have to be boolean unlike Java. It's evaluated as</p>
<p>false for so called falsy values (null, undefined, 0, empty strings
etc)</p>
<p>2. for each statement Nashorn has a special kind of loop - for each -
which can iterate over different JS and Java</p>
<p>object.</p>
<p>3. Getting object size. In JS objects have a property length, which
returns size of an array or a string.</p>
<p>Results:</p>
<p>Type If for each .length</p>
<p>Java null false No iterations <strong>Exception</strong></p>
<p>Java empty string false No iterations 0</p>
<p>Java string true Iterates over string characters Length of the
string</p>
<p>Java Integer/Long value != 0 No iterations undefined</p>
<p>Java ArrayList true Iterates over elements Length of the list</p>
<p>Java HashMap true Iterates over values null</p>
<p>Java HashSet true Iterates over items undefined</p>
<p>Recommendatons:</p>
<p>It's advisable to use <strong>if</strong> (some_string) to check if a
string is not null and not empty <strong>for</strong> each can be safely
used to iterate over any collection, and it doesn't raise exceptions if
the collection is</p>
<p>not iterable, null or undefined</p>
<p>Before getting length of an object it must be checked for null or
undefined (the same is true for any attempt</p>
<p>of calling a method or getting a property of Java object)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 556</p>
<p><span id="Section_97_8__Implementing_an_in"
class="anchor"></span>Section 97.8: Implementing an interface from
script</p>
<p><strong>import</strong> java.io.FileReader;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> javax.script.ScriptEngine;</p>
<p><strong>import</strong> javax.script.ScriptEngineManager;</p>
<p><strong>import</strong> javax.script.ScriptException;</p>
<p><strong>public class</strong> InterfaceImplementationExample {</p>
<p>public static interface <strong>Pet {</strong></p>
<p>public void <strong>eat();</strong></p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</p>
<p>// Obtain an instance of JavaScript engine</p>
<p>ScriptEngineManager manager = <strong>new</strong>
ScriptEngineManager();</p>
<p>ScriptEngine engine = manager.getEngineByName("nashorn");</p>
<p>try <strong>{</strong></p>
<p>//evaluate a script</p>
<p>/* pet.js */</p>
<p>/*</p>
<p>var Pet = Java.type("InterfaceImplementationExample.Pet");</p>
<p>new Pet() {</p>
<p>eat: function() { print("eat"); }</p>
<p>}</p>
<p>*/</p>
<p>Pet pet = (Pet) engine.eval(<strong>new</strong>
FileReader("pet.js"));</p>
<p>pet.eat();</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>// Outcome:</p>
<p>// 'eat' printed on standard output</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 557</p>
<p><span id="Chapter_98__Java_Native_Interfac_1"
class="anchor"></span>Chapter 98: Java Native Interface</p>
<p>Parameter Details</p>
<p>JNIEnv Pointer to the JNI environment</p>
<p>jobject The object which invoked the non-<strong>static
native</strong> method</p>
<p>jclass The class which invoked the <strong>static native</strong>
method</p>
<p>Section 98.1: Calling C++ methods from Java</p>
<p>Static and member methods in Java can be marked as <em>native</em> to
indicate that their implementation is to be found in a shared library
file. Upon execution of a native method, the JVM looks for a
corresponding function in loaded</p>
<p>libraries (see Loading native libraries), using a simple name
mangling scheme, performs argument conversion and stack setup, then
hands over control to native code.</p>
<p>Java code</p>
<p>/*** com/example/jni/JNIJava.java **/</p>
<p><strong>package</strong> com.example.jni;</p>
<p>public class <strong>JNIJava {</strong></p>
<p>static <strong>{</strong></p>
<p>System.loadLibrary("libJNI_CPP");</p>
<p>}</p>
<p>// Obviously, native methods may not have a body defined in Java
<em><strong>public native void</strong> printString(String
name);</em></p>
<p>public static native double <strong>average(</strong>int<strong>[]
nums);</strong></p>
<p>public static void <strong>main(</strong>final <strong>String[] args)
{</strong></p>
<p>JNIJava jniJava = <strong>new</strong> JNIJava();</p>
<p>jniJava.printString("Invoked C++ 'printString' from Java");</p>
<p><strong>double</strong> d = average(<strong>new int</strong>[]{1, 2,
3, 4, 7});</p>
<p>System.out.println("Got result from C++ 'average': " + d);</p>
<p>}</p>
<p>}</p>
<p>C++ code</p>
<p>Header files containing native function declarations should be
generated using the javah tool on target classes. Running the following
command at the build directory :</p>
<p>javah -o com_example_jni_JNIJava.hpp com.example.jni.JNIJava</p>
<p>... produces the following header file (<em>comments stripped for
brevity</em>) :</p>
<p>// com_example_jni_JNIJava.hpp</p>
<p>/* DO NOT EDIT THIS FILE - it is machine generated */ <em>#include //
The JNI API declarations</em></p>
<p>#ifndef _Included_com_example_jni_JNIJava</p>
<p>#define _Included_com_example_jni_JNIJava</p>
<p>#ifdef __cplusplus</p>
<p>extern "C" { // This is absolutely required if using a C++ compiler
#endif</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 558</p>
<p><span id="JNIEXPORT_void_JNICALL_Java_com"
class="anchor"></span>JNIEXPORT void JNICALL
Java_com_example_jni_JNIJava_printString</p>
<p>(JNIEnv *, jobject, jstring);</p>
<p>JNIEXPORT jdouble JNICALL Java_com_example_jni_JNIJava_average</p>
<p>(JNIEnv *, jclass, jintArray);</p>
<p>#ifdef __cplusplus</p>
<p>}</p>
<p>#endif</p>
<p>#endif</p>
<p>Here is an example implementation :</p>
<p>// com_example_jni_JNIJava.cpp</p>
<p>#include</p>
<p>#include "com_example_jni_JNIJava.hpp"</p>
<p>using namespace std;</p>
<p>JNIEXPORT void JNICALL
Java_com_example_jni_JNIJava_printString(JNIEnv *env, jobject jthis,
jstring string) {</p>
<p>const char *stringInC = env-&gt;GetStringUTFChars(string, NULL); if
(NULL == stringInC)</p>
<p>return;</p>
<p>cout &lt;&lt; stringInC &lt;&lt; endl;</p>
<p>env-&gt;ReleaseStringUTFChars(string, stringInC);</p>
<p>}</p>
<p>JNIEXPORT jdouble JNICALL Java_com_example_jni_JNIJava_average(JNIEnv
*env, jclass jthis, jintArray intArray) {</p>
<p>jint *intArrayInC = env-&gt;GetIntArrayElements(intArray, NULL);</p>
<p>if (NULL == intArrayInC)</p>
<p>return-1;</p>
<p>jsize length = env-&gt;GetArrayLength(intArray);</p>
<p>int sum = 0;</p>
<p>for (int i = 0; i &lt; length; i++) {</p>
<p>sum += intArrayInC[i];</p>
<p>}</p>
<p>env-&gt;ReleaseIntArrayElements(intArray, intArrayInC, 0);</p>
<p>return (double) sum / length;</p>
<p>}</p>
<p>Output</p>
<p>Running the example class above yields the following output :</p>
<p>Invoked C++ 'printString' from Java</p>
<p>Got result from C++ 'average': 3.4</p>
<p>Section 98.2: Calling Java methods from C++ (callback)</p>
<p>Calling a Java method from native code is a two-step process :</p>
<p>1. obtain a method pointer with the GetMethodID JNI function, using
the method name and descriptor ;</p>
<p>2. call one of the Call*Method functions listed <a
href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp16656">here.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 559</p>
<p>Java code</p>
<p>/*** com.example.jni.JNIJavaCallback.java ***/</p>
<p><strong>package</strong> com.example.jni;</p>
<p><strong>public class</strong> JNIJavaCallback {</p>
<p>static <strong>{</strong></p>
<p>System.loadLibrary("libJNI_CPP");</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>new</strong> JNIJavaCallback().callback();</p>
<p>}</p>
<p>public native void <strong>callback();</strong></p>
<p>public static void <strong>printNum(</strong>int <strong>i)
{</strong></p>
<p>System.out.println("Got int from C++: " + i);</p>
<p>}</p>
<p><strong>public void</strong> printFloat(<strong>float</strong> i)
{</p>
<p>System.out.println("Got float from C++: " + i);</p>
<p>}</p>
<p>}</p>
<p>C++ code</p>
<p>// com_example_jni_JNICppCallback.cpp</p>
<p>#include</p>
<p>#include "com_example_jni_JNIJavaCallback.h"</p>
<p>using namespace std;</p>
<p>JNIEXPORT void JNICALL
Java_com_example_jni_JNIJavaCallback_callback(JNIEnv *env, jobject
jthis) {</p>
<p>jclass thisClass = env-&gt;GetObjectClass(jthis);</p>
<p>jmethodID printFloat = env-&gt;GetMethodID(thisClass, "printFloat",
"(F)V");</p>
<p>if (NULL == printFloat)</p>
<p>return;</p>
<p>env-&gt;CallVoidMethod(jthis, printFloat, 5.221);</p>
<p>jmethodID staticPrintInt = env-&gt;GetStaticMethodID(thisClass,
"printNum", "(I)V");</p>
<p>if (NULL == staticPrintInt)</p>
<p>return;</p>
<p>env-&gt;CallVoidMethod(jthis, staticPrintInt, 17);</p>
<p>}</p>
<p>Output</p>
<p>Got float from C++: 5.221</p>
<p>Got int from C++: 17</p>
<p>Getting the descriptor</p>
<p>Descriptors (or <em>internal type signatures</em>) are obtained using
the <strong>javap</strong> program on the compiled
.<strong>class</strong> file. Here is</p>
<p>the output of javap -p -s com.example.jni.JNIJavaCallback :</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 560</p>
<p><span id="Compiled_from__JNIJavaCallback_j"
class="anchor"></span>Compiled from "JNIJavaCallback.java"</p>
<p><strong>public class</strong> com.example.jni.JNIJavaCallback {</p>
<p>static <strong>{};</strong></p>
<p>descriptor: ()V</p>
<p><strong>public</strong> com.example.jni.JNIJavaCallback();</p>
<p>descriptor: ()V</p>
<p><strong>public static void</strong> main(java.lang.String[]);</p>
<p>descriptor: ([Ljava/lang/String;)V</p>
<p>public native void <strong>callback();</strong></p>
<p>descriptor: ()V</p>
<p>public static void
<strong>printNum(</strong>int<strong>);</strong></p>
<p>descriptor: (I)V <em>// &lt;---- Needed</em></p>
<p>public void <strong>printFloat(</strong>float<strong>);</strong></p>
<p>descriptor: (F)V <em>// &lt;---- Needed</em></p>
<p>}</p>
<p>Section 98.3: Loading native libraries</p>
<p>The common idiom for loading shared library files in Java is the
following :</p>
<p><strong>public class</strong> ClassWithNativeMethods {</p>
<p>static <strong>{</strong></p>
<p>System.loadLibrary("Example");</p>
<p>}</p>
<p><strong>public native void</strong> someNativeMethod(String arg);</p>
<p>...</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#loadLibrary(java.lang.String)">Calls
to System.loadLibrary</a> are almost always static so as to occur during
class loading, ensuring that no native</p>
<p>method can execute before the shared library has been loaded. However
the following is possible :</p>
<p><strong>public class</strong> ClassWithNativeMethods {</p>
<p>// Call this before using any native method</p>
<p><strong>public static void</strong> prepareNativeMethods() {</p>
<p>System.loadLibrary("Example");</p>
<p>}</p>
<p>...</p>
<p>This allows to defer shared library loading until necessary, but
requires extra care to avoid</p>
<p>java.lang.UnsatisfiedLinkErrors.</p>
<p>Target file lookup</p>
<p>Shared library files are searched for in the paths defined by the
java.library.path system property, which can be</p>
<p>overridden using the -Djava.library.path= JVM argument at runtime
:</p>
<p>java -Djava.library.path=path/to/lib/:path/to/other/lib
MainClassWithNativeMethods</p>
<p>Watch out for system path separators : for example, Windows uses ;
instead of :.</p>
<p>Note that System.loadLibrary resolves library filenames in a
platform-dependent manner : the code snippet above</p>
<p>expects a file named libExample.so on Linux, and Example.dll on
Windows.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 561</p>
<p>An alternative to System.loadLibrary <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#load(java.lang.String)">is
System.load(String)</a>, which takes the full path to a shared library
file, circumventing the java.library.path lookup :</p>
<p><strong>public class</strong> ClassWithNativeMethods {</p>
<p>static <strong>{</strong></p>
<p>System.load("/path/to/lib/libExample.so");</p>
<p>}</p>
<p>...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 562</p>
<p><span id="Chapter_99__Functional_Interface_1"
class="anchor"></span>Chapter 99: Functional Interfaces</p>
<p>In Java 8+, a <em>functional interface</em> is an interface that has
just one abstract method (aside from the methods of</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.8">Object).
See JLS §9.8. Functional Interfaces.</a></p>
<p>Section 99.1: List of standard Java Runtime Library functional</p>
<p>interfaces by signature</p>
<p>Parameter Types Return Type Interface</p>
<p>() void <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a></p>
<p>() T <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier</a></p>
<p>() boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BooleanSupplier.html">BooleanSupplier</a></p>
<p>() int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntSupplier.html">IntSupplier</a></p>
<p>() long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongSupplier.html">LongSupplier</a></p>
<p>() double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleSupplier.html">DoubleSupplier</a></p>
<p>(T) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">Consumer&lt;T&gt;</a></p>
<p>(T) T <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html">UnaryOperator&lt;T&gt;</a></p>
<p>(T) R <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function&lt;T,R&gt;</a></p>
<p>(T) boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Predicate&lt;T&gt;</a></p>
<p>(T) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToIntFunction.html">ToIntFunction&lt;T&gt;</a></p>
<p>(T) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToLongFunction.html">ToLongFunction&lt;T&gt;</a></p>
<p>(T) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToDoubleFunction.html">ToDoubleFunction&lt;T&gt;</a></p>
<p>(T, T) T <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html">BinaryOperator&lt;T&gt;</a></p>
<p>(T, U) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html">BiConsumer&lt;T,U&gt;</a></p>
<p>(T, U) R <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html">BiFunction&lt;T,U,R&gt;</a></p>
<p>(T, U) boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiPredicate.html">BiPredicate&lt;T,U&gt;</a></p>
<p>(T, U) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToIntBiFunction.html">ToIntBiFunction&lt;T,U&gt;</a></p>
<p>(T, U) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToLongBiFunction.html">ToLongBiFunction&lt;T,U&gt;</a></p>
<p>(T, U) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ToDoubleBiFunction.html">ToDoubleBiFunction&lt;T,U&gt;</a></p>
<p>(T, int) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ObjIntConsumer.html">ObjIntConsumer&lt;T&gt;</a></p>
<p>(T, long) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ObjLongConsumer.html">ObjLongConsumer&lt;T&gt;</a></p>
<p>(T, double) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/ObjDoubleConsumer.html">ObjDoubleConsumer&lt;T&gt;</a></p>
<p>(int) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntConsumer.html">IntConsumer</a></p>
<p>(int) R <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntFunction.html">IntFunction&lt;R&gt;</a></p>
<p>(int) boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntPredicate.html">IntPredicate</a></p>
<p>(int) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntUnaryOperator.html">IntUnaryOperator</a></p>
<p>(int) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntToLongFunction.html">IntToLongFunction</a></p>
<p>(int) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntToDoubleFunction.html">IntToDoubleFunction</a></p>
<p>(int, int) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/IntBinaryOperator.html">IntBinaryOperator</a></p>
<p>(long) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongConsumer.html">LongConsumer</a></p>
<p>(long) R <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongFunction.html">LongFunction&lt;R&gt;</a></p>
<p>(long) boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongPredicate.html">LongPredicate</a></p>
<p>(long) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongToIntFunction.html">LongToIntFunction</a></p>
<p>(long) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongUnaryOperator.html">LongUnaryOperator</a></p>
<p>(long) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongToDoubleFunction.html">LongToDoubleFunction</a></p>
<p>(long, long) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/LongBinaryOperator.html">LongBinaryOperator</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 563</p>
<p>(double) void <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleConsumer.html">DoubleConsumer</a></p>
<p>(double) R <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleFunction.html">DoubleFunction&lt;R&gt;</a></p>
<p>(double) boolean <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoublePredicate.html">DoublePredicate</a></p>
<p>(double) int <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleToIntFunction.html">DoubleToIntFunction</a></p>
<p>(double) long <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleToLongFunction.html">DoubleToLongFunction</a></p>
<p>(double) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleUnaryOperator.html">DoubleUnaryOperator</a></p>
<p>(double, double) double <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/function/DoubleBinaryOperator.html">DoubleBinaryOperator</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 564</p>
<p><span id="Chapter_100__Fluent_Interface_1"
class="anchor"></span>Chapter 100: Fluent Interface</p>
<p>Section 100.1: Fluent programming style</p>
<p>In fluent programming style you return <strong>this</strong> from
fluent (setter) methods that would return nothing in non-fluent
programming style.</p>
<p>This allows you to chain the different method calls which makes your
code shorter and easier to handle for the developers.</p>
<p>Consider this non-fluent code:</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String firstName;</p>
<p><strong>private</strong> String lastName;</p>
<p><strong>public</strong> String getFirstName() {</p>
<p><strong>return</strong> firstName;</p>
<p>}</p>
<p><strong>public void</strong> setFirstName(String firstName) {</p>
<p><strong>this</strong>.firstName = firstName;</p>
<p>}</p>
<p><strong>public</strong> String getLastName() {</p>
<p><strong>return</strong> lastName;</p>
<p>}</p>
<p><strong>public void</strong> setLastName(String lastName) {</p>
<p><strong>this</strong>.lastName = lastName;</p>
<p>}</p>
<p><strong>public</strong> String whoAreYou() {</p>
<p><strong>return</strong> "I am " + firstName + " " + lastName;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Person person = <strong>new</strong> Person();</p>
<p>person.setFirstName("John");</p>
<p>person.setLastName("Doe");</p>
<p>System.out.println(person.whoAreYou());</p>
<p>}</p>
<p>}</p>
<p>As the setter methods don't return anything, we need 4 instructions
in the mainmethod to instantiate a Person with</p>
<p>some data and print it. With a fluent style this code can be changed
to:</p>
<p>public class <strong>Person {</strong></p>
<p><strong>private</strong> String firstName;</p>
<p><strong>private</strong> String lastName;</p>
<p><strong>public</strong> String getFirstName() {</p>
<p><strong>return</strong> firstName;</p>
<p>}</p>
<p><strong>public</strong> Person withFirstName(String firstName) {</p>
<p><strong>this</strong>.firstName = firstName;</p>
<p>return this<strong>;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 565</p>
<p><span id="_41" class="anchor"></span>}</p>
<p><strong>public</strong> String getLastName() {</p>
<p><strong>return</strong> lastName;</p>
<p>}</p>
<p><strong>public</strong> Person withLastName(String lastName) {</p>
<p><strong>this</strong>.lastName = lastName;</p>
<p>return this<strong>;</strong></p>
<p>}</p>
<p><strong>public</strong> String whoAreYou() {</p>
<p><strong>return</strong> "I am " + firstName + " " + lastName;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println(<strong>new</strong>
Person().withFirstName("John")</p>
<p>.withLastName("Doe").whoAreYou());</p>
<p>}</p>
<p>}</p>
<p>The idea is to always return some object to enable building of a
method call chain and to use method names which reflect natural
speaking. This fluent style makes the code more readable.</p>
<p>Section 100.2: Truth - Fluent Testing Framework</p>
<p>From "How to use Truth" <a
href="http://google.github.io/truth/">http://google.github.io/truth/</a></p>
<p>String string = "awesome";</p>
<p>assertThat(string).startsWith("awe");</p>
<p>assertWithMessage("Without me, it's just
aweso").that(string).contains("me");</p>
<p>Iterable googleColors = googleLogo.getColors();
assertThat(googleColors)</p>
<p>.containsExactly(BLUE, RED, YELLOW, BLUE, GREEN, RED)</p>
<p>.inOrder();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 566</p>
<p><span id="Chapter_101__Remote_Method_Invoc_1"
class="anchor"></span>Chapter 101: Remote Method Invocation</p>
<p>(RMI)</p>
<p>Section 101.1: Callback: invoking methods on a "client"</p>
<p>Overview</p>
<p>In this example 2 clients send information to each other through a
server. One client sends the server a number which is relayed to the
second client. The second client halves the number and sends it back to
the first client</p>
<p>through the server. The first client does the same. The server stops
the communication when the number returned</p>
<p>to it by any of the clients is less than 10. The return value from
the server to the clients (the number it got converted to string
representation) then backtracks the process.</p>
<p>1. A login server binds itself to a registry.</p>
<p>2. A client looks up the login server and calls the login method with
its information. Then:</p>
<p>The login server stores the client information. It includes the
client's stub with the callback methods. The login server creates and
returns a server stub ("connection" or "session") to the client to
store. It</p>
<p>includes the server's stub with its methods including a logout method
(unused in this example).</p>
<p>3. A client calls the server's passInt with the name of the recipient
client and an <strong>int</strong>.</p>
<p>4. The server calls the half on the recipient client with that
<strong>int</strong>. This initiates a back-and-forth (calls and</p>
<p>callbacks) communication until stopped by the server.</p>
<p>The shared remote interfaces</p>
<p>The login server:</p>
<p><strong>package</strong> callbackRemote;</p>
<p><strong>import</strong> java.rmi.Remote;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p>public interface <strong>RemoteLogin</strong> extends <strong>Remote
{</strong></p>
<p>RemoteConnection login(String name, RemoteClient client)
<strong>throws</strong> RemoteException; }</p>
<p>The server:</p>
<p><strong>package</strong> callbackRemote;</p>
<p><strong>import</strong> java.rmi.Remote;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>public interface</strong> RemoteConnection
<strong>extends</strong> Remote {</p>
<p><strong>void</strong> logout() <strong>throws</strong>
RemoteException;</p>
<p>String passInt(String name, <strong>int</strong> i)
<strong>throws</strong> RemoteException;</p>
<p>}</p>
<p>The client:</p>
<p><strong>package</strong> callbackRemote;</p>
<p><strong>import</strong> java.rmi.Remote;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 567</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p>public interface <strong>RemoteClient</strong> extends <strong>Remote
{</strong></p>
<p><strong>void</strong> half(<strong>int</strong> i)
<strong>throws</strong> RemoteException;</p>
<p>}</p>
<p>The implementations</p>
<p>The login server:</p>
<p><strong>package</strong> callbackServer;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong> java.rmi.registry.Registry;</p>
<p><strong>import</strong> java.rmi.server.UnicastRemoteObject;</p>
<p><strong>import</strong> java.util.HashMap;</p>
<p><strong>import</strong> java.util.Map;</p>
<p><strong>import</strong> callbackRemote.RemoteClient;</p>
<p><strong>import</strong> callbackRemote.RemoteConnection;</p>
<p><strong>import</strong> callbackRemote.RemoteLogin;</p>
<p><strong>public class</strong> LoginServer <strong>implements</strong>
RemoteLogin {</p>
<p><strong>static</strong> Map clients = <strong>new</strong>
HashMap&lt;&gt;();</p>
<p>@Override</p>
<p><strong>public</strong> RemoteConnection login(String name,
RemoteClient client) {</p>
<p>Connection connection = <strong>new</strong> Connection(name,
client);</p>
<p>clients.put(name, client);</p>
<p>System.out.println(name + " logged in");</p>
<p><strong>return</strong> connection;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Registry reg =
LocateRegistry.createRegistry(Registry.REGISTRY_PORT);</p>
<p>LoginServer server = <strong>new</strong> LoginServer();</p>
<p>UnicastRemoteObject.exportObject(server, Registry.REGISTRY_PORT);</p>
<p>reg.rebind("LoginServerName", server);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The server:</p>
<p><strong>package</strong> callbackServer;</p>
<p><strong>import</strong> java.rmi.NoSuchObjectException;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.Registry;</p>
<p><strong>import</strong> java.rmi.server.UnicastRemoteObject;</p>
<p><strong>import</strong> java.rmi.server.Unreferenced;</p>
<p><strong>import</strong> callbackRemote.RemoteClient;</p>
<p><strong>import</strong> callbackRemote.RemoteConnection;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 568</p>
<p><strong>public class</strong> Connection <strong>implements</strong>
RemoteConnection, Unreferenced {</p>
<p>RemoteClient client;</p>
<p>String name;</p>
<p><strong>public</strong> Connection(String name, RemoteClient client)
{</p>
<p><strong>this</strong>.client = client;</p>
<p><strong>this</strong>.name = name;</p>
<p>try <strong>{</strong></p>
<p>UnicastRemoteObject.exportObject(<strong>this</strong>,
Registry.REGISTRY_PORT);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> unreferenced() {</p>
<p>try <strong>{</strong></p>
<p>UnicastRemoteObject.unexportObject(<strong>this</strong>,
<strong>true</strong>);</p>
<p>} <strong>catch</strong> (NoSuchObjectException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>logout() {</strong></p>
<p>try <strong>{</strong></p>
<p>UnicastRemoteObject.unexportObject(<strong>this</strong>,
<strong>true</strong>);</p>
<p>} <strong>catch</strong> (NoSuchObjectException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String passInt(String recipient,
<strong>int</strong> i) {</p>
<p>System.out.println("Server received from " + name + ":" + i);
<strong>if</strong> (i &lt; 10)</p>
<p><strong>return</strong> String.valueOf(i);</p>
<p>RemoteClient client = LoginServer.clients.get(recipient);</p>
<p>try <strong>{</strong></p>
<p>client.half(i);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p><strong>return</strong> String.valueOf(i);</p>
<p>}</p>
<p>}</p>
<p>The client:</p>
<p><strong>package</strong> callbackClient;</p>
<p><strong>import</strong> java.rmi.NotBoundException;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong> java.rmi.registry.Registry;</p>
<p><strong>import</strong> java.rmi.server.UnicastRemoteObject;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 569</p>
<p><strong>import</strong> callbackRemote.RemoteClient;</p>
<p><strong>import</strong> callbackRemote.RemoteConnection;</p>
<p><strong>import</strong> callbackRemote.RemoteLogin;</p>
<p><strong>public class</strong> Client <strong>implements</strong>
RemoteClient {</p>
<p>RemoteConnection connection;</p>
<p>String name, target;</p>
<p>Client(String name, String target) {</p>
<p><strong>this</strong>.name = name;</p>
<p><strong>this</strong>.target = target;</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Client client = <strong>new</strong> Client(args[0], args[1]);</p>
<p>try <strong>{</strong></p>
<p>Registry reg = LocateRegistry.getRegistry();</p>
<p>RemoteLogin login = (RemoteLogin) reg.lookup("LoginServerName");</p>
<p>UnicastRemoteObject.exportObject(client,
Integer.parseInt(args[2]));</p>
<p>client.connection = login.login(client.name, client);</p>
<p>} <strong>catch</strong> (RemoteException | NotBoundException e)
{</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p><strong>if</strong> ("Client1".equals(client.name)) {</p>
<p>try <strong>{</strong></p>
<p>client.connection.passInt(client.target, 120);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> half(<strong>int</strong> i)
<strong>throws</strong> RemoteException {</p>
<p>String result = connection.passInt(target, i / 2);</p>
<p>System.out.println(name + " received: <strong>\"</strong>" + result +
"<strong>\"</strong>");</p>
<p>}</p>
<p>}</p>
<p>Running the example:</p>
<p>1. Run the login server.</p>
<p>2. Run a client with the arguments Client2 Client1 1097.</p>
<p>3. Run a client with the arguments Client1 Client2 1098.</p>
<p>The outputs will appear in 3 consoles since there are 3 JVMs. here
they are lumped together:</p>
<p>Client2 logged in</p>
<p>Client1 logged in</p>
<p>Server received from Client1:120</p>
<p>Server received from Client2:60</p>
<p>Server received from Client1:30</p>
<p>Server received from Client2:15</p>
<p>Server received from Client1:7</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 570</p>
<p><span id="Client1_received___7" class="anchor"></span>Client1
received: "7"</p>
<p>Client2 received: "15"</p>
<p>Client1 received: "30"</p>
<p>Client2 received: "60"</p>
<p>Section 101.2: Simple RMI example with Client and Server</p>
<p>implementation</p>
<p>This is a simple RMI example with five Java classes and two packages,
<em>server</em> and <em>client</em>.</p>
<p>Server Package</p>
<p>PersonListInterface.java</p>
<p><strong>public interface</strong> PersonListInterface
<strong>extends</strong> Remote</p>
<p>{</p>
<p>/**</p>
<p>* This interface is used by both client and server</p>
<p>* @return List of Persons</p>
<p>* @throws RemoteException</p>
<p>*/</p>
<p>ArrayList getPersonList() <strong>throws</strong> RemoteException;
}</p>
<p>PersonListImplementation.java</p>
<p><strong>public class</strong> PersonListImplementation</p>
<p><strong>extends</strong> UnicastRemoteObject</p>
<p><strong>implements</strong> PersonListInterface</p>
<p>{</p>
<p>private static final long <strong>serialVersionUID = 1L;</strong></p>
<p>// standard constructor needs to be available</p>
<p><strong>public</strong> PersonListImplementation()
<strong>throws</strong> RemoteException {}</p>
<p>/**</p>
<p>* Implementation of "PersonListInterface"</p>
<p>* @throws RemoteException</p>
<p>*/</p>
<p>@Override</p>
<p><strong>public</strong> ArrayList getPersonList()
<strong>throws</strong> RemoteException {</p>
<p>ArrayList personList = <strong>new</strong> ArrayList();</p>
<p>personList.add("Peter Pan");</p>
<p>personList.add("Pippi Langstrumpf");</p>
<p>// add your name here :)</p>
<p><strong>return</strong> personList;</p>
<p>}</p>
<p>}</p>
<p>Server.java</p>
<p>public class <strong>Server {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 571</p>
<p>/**</p>
<p>* Register servicer to the known public methods</p>
<p>*/</p>
<p>private static void <strong>createServer() {</strong></p>
<p>try <strong>{</strong></p>
<p>// Register registry with standard port 1099</p>
<p>LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
System.out.println("Server : Registry created.");</p>
<p>// Register PersonList to registry</p>
<p>Naming.rebind("PersonList", <strong>new</strong>
PersonListImplementation()); System.out.println("Server : PersonList
registered");</p>
<p>} <strong>catch</strong> (<strong>final</strong> IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>public static void <strong>main(</strong>final <strong>String[] args)
{</strong></p>
<p>createServer();</p>
<p>}</p>
<p>}</p>
<p>Client package</p>
<p>PersonListLocal.java</p>
<p><strong>public class</strong> PersonListLocal {</p>
<p><strong>private static</strong> PersonListLocal instance;</p>
<p><strong>private</strong> PersonListInterface personList;</p>
<p>/**</p>
<p>* Create a singleton instance</p>
<p>*/</p>
<p><strong>private</strong> PersonListLocal() {</p>
<p>try <strong>{</strong></p>
<p><em>// Lookup to the local running server with port 1099</em>
<strong>final</strong> Registry registry =
LocateRegistry.getRegistry("localhost",</p>
<p>Registry.REGISTRY_PORT);</p>
<p>// Lookup to the registered "PersonList"</p>
<p>personList = (PersonListInterface) registry.lookup("PersonList");</p>
<p>} <strong>catch</strong> (<strong>final</strong> RemoteException e)
{</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (<strong>final</strong> NotBoundException e)
{</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>public static</strong> PersonListLocal getInstance() {</p>
<p><strong>if</strong> (instance == <strong>null</strong>) {</p>
<p>instance = <strong>new</strong> PersonListLocal();</p>
<p>}</p>
<p><strong>return</strong> instance;</p>
<p>}</p>
<p>/**</p>
<p>* Returns the servers PersonList</p>
<p>*/</p>
<p><strong>public</strong> ArrayList getPersonList() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 572</p>
<p><span id="if__instance____null"
class="anchor"></span><strong>if</strong> (instance !=
<strong>null</strong>) {</p>
<p>try <strong>{</strong></p>
<p><strong>return</strong> personList.getPersonList();</p>
<p>} <strong>catch</strong> (<strong>final</strong> RemoteException e)
{</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>return new</strong> ArrayList&lt;&gt;();</p>
<p>}</p>
<p>}</p>
<p>PersonTest.java</p>
<p>public class <strong>PersonTest</strong></p>
<p>{</p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>{</p>
<p>// get (local) PersonList</p>
<p>ArrayList personList =
PersonListLocal.getInstance().getPersonList();</p>
<p>// print all persons</p>
<p><strong>for</strong>(String person : personList)</p>
<p>{</p>
<p>System.out.println(person);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Test your application</p>
<p>Start main method of Server.java. Output:</p>
<p>Server : Registry created.</p>
<p>Server : PersonList registered</p>
<p>Start main method of PersonTest.java. Output:</p>
<p>Peter Pan</p>
<p>Pippi Langstrumpf</p>
<p>Section 101.3: Client-Server: invoking methods in one JVM</p>
<p>from another</p>
<p>The shared remote interface:</p>
<p><strong>package</strong> remote;</p>
<p><strong>import</strong> java.rmi.Remote;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p>public interface <strong>RemoteServer</strong> extends <strong>Remote
{</strong></p>
<p><strong>int</strong> stringToInt(String string)
<strong>throws</strong> RemoteException;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 573</p>
<p>The server implementing the shared remote interface:</p>
<p><strong>package</strong> server;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong> java.rmi.registry.Registry;</p>
<p><strong>import</strong> java.rmi.server.UnicastRemoteObject;</p>
<p><strong>import</strong> remote.RemoteServer;</p>
<p><strong>public class</strong> Server <strong>implements</strong>
RemoteServer {</p>
<p>@Override</p>
<p><strong>public int</strong> stringToInt(String string)
<strong>throws</strong> RemoteException {</p>
<p>System.out.println("Server received: <strong>\"</strong>" + string +
"<strong>\"</strong>"); <strong>return</strong>
Integer.parseInt(string);</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Registry reg =
LocateRegistry.createRegistry(Registry.REGISTRY_PORT);</p>
<p>Server server = <strong>new</strong> Server();</p>
<p>UnicastRemoteObject.exportObject(server, Registry.REGISTRY_PORT);</p>
<p>reg.rebind("ServerName", server);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The client invoking a method on the server (remotely):</p>
<p><strong>package</strong> client;</p>
<p><strong>import</strong> java.rmi.NotBoundException;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong> java.rmi.registry.Registry;</p>
<p><strong>import</strong> remote.RemoteServer;</p>
<p>public class <strong>Client {</strong></p>
<p><strong>static</strong> RemoteServer server;</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Registry reg = LocateRegistry.getRegistry();</p>
<p>server = (RemoteServer) reg.lookup("ServerName");</p>
<p>} <strong>catch</strong> (RemoteException | NotBoundException e)
{</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Client client = <strong>new</strong> Client();</p>
<p>client.callServer();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 574</p>
<p><strong>void</strong> callServer() {</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> i = server.stringToInt("120");</p>
<p>System.out.println("Client received: " + i);</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Server received: "120"</p>
<p>Client received: 120</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 575</p>
<p><span id="Chapter_102__Iterator_and_Iterab_1"
class="anchor"></span>Chapter 102: Iterator and Iterable</p>
<p>The java.util.Iterator is the standard Java SE interface for object
that implement the Iterator design pattern.</p>
<p>The java.lang.Iterable interface is for objects that can
<em>provide</em> an iterator.</p>
<p>Section 102.1: Removing elements using an iterator</p>
<p>The Iterator.remove() method is an optional method that removes the
element returned by the previous call to</p>
<p>Iterator.next(). For example, the following code populates a list of
strings and then removes all of the empty strings.</p>
<p>List names = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>names.add("name 1");</p>
<p>names.add("name 2");</p>
<p>names.add("");</p>
<p>names.add("name 3");</p>
<p>names.add("");</p>
<p>System.out.println("Old Size : " + names.size());</p>
<p>Iterator it = names.iterator();</p>
<p><strong>while</strong> (it.hasNext()) {</p>
<p>String el = it.next();</p>
<p><strong>if</strong> (el.equals("")) {</p>
<p>it.remove();</p>
<p>}</p>
<p>}</p>
<p>System.out.println("New Size : " + names.size());</p>
<p>Output :</p>
<p>Old Size : 5</p>
<p>New Size : 3</p>
<p>Note that is the code above is the safe way to remove elements while
iterating a typical collection. If instead, you</p>
<p>attempt to do remove elements from a collection like this:</p>
<p><strong>for</strong> (String el: names) {</p>
<p><strong>if</strong> (el.equals("")) {</p>
<p>names.remove(el); <em>// WRONG!</em></p>
<p>}</p>
<p>}</p>
<p>a typical collection (such as ArrayList) which provides iterators
with <em>fail fast</em> iterator semantics will throw a
ConcurrentModificationException.</p>
<p>The remove() method can only called (once) following a next() call.
If it is called before calling next() or if it is</p>
<p>called twice following a next() call, then the remove() call will
throw an IllegalStateException.</p>
<p>The remove operation is described as an <em>optional</em> operation;
i.e. not all iterators will allow it. Examples where it is not</p>
<p>supported include iterators for immutable collections, read-only
views of collections, or fixed sized collections. If remove() is called
when the iterator does not support removal, it will throw an
UnsupportedOperationException.</p>
<p>Section 102.2: Creating your own Iterable</p>
<p>To create your own Iterable as with any interface you just implement
the abstract methods in the interface. For</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 576</p>
<p><span id="Iterable_there_is_only_one_which"
class="anchor"></span>Iterable there is only one which is called
iterator(). But its return type Iterator is itself an interface with
three abstract methods. You can return an iterator associated with some
collection or create your own custom</p>
<p>implementation:</p>
<p>public static class <strong>Alphabet</strong> implements
<strong>Iterable {</strong></p>
<p>@Override</p>
<p><strong>public</strong> Iterator iterator() {</p>
<p>return new <strong>Iterator() {</strong></p>
<p><strong>char</strong> letter = 'a';</p>
<p>@Override</p>
<p>public boolean <strong>hasNext() {</strong></p>
<p><strong>return</strong> letter &lt;= 'z';</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Character next() {</p>
<p><strong>return</strong> letter++;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>remove() {</strong></p>
<p><strong>throw new</strong> UnsupportedOperationException("Doesn't
make sense to remove a letter");</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>To use:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>for</strong>(<strong>char</strong> c : <strong>new</strong>
Alphabet()) {</p>
<p>System.out.println("c = " + c);</p>
<p>}</p>
<p>}</p>
<p>The new Iterator should come with a state pointing to the first item,
each call to next updates its state to point to</p>
<p>the next one. The hasNext() checks to see if the iterator is at the
end. If the iterator were connected to a modifiable</p>
<p>collection then the iterator's optional remove() method might be
implemented to remove the item currently pointed to from the underlying
collection.</p>
<p>Section 102.3: Using Iterable in for loop</p>
<p>Classes implementing Iterable&lt;&gt; interface can be used in
<strong>for</strong> loops. This is actually only <a
href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar for
getting</a></p>
<p>an iterator from the object and using it to get all elements
sequentially; it makes code clearer, faster to write end</p>
<p>less error-prone.</p>
<p><strong>public class</strong> UsingIterable {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List intList = Arrays.asList(1,2,3,4,5,6,7);</p>
<p>// List extends Collection, Collection extends Iterable</p>
<p>Iterable iterable = intList;</p>
<p>// foreach-like loop</p>
<p><strong>for</strong> (Integer i: iterable) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 577</p>
<p><span id="System_out_println_i"
class="anchor"></span>System.out.println(i);</p>
<p>}</p>
<p>// pre java 5 way of iterating loops</p>
<p><strong>for</strong>(Iterator i = iterable.iterator(); i.hasNext(); )
{</p>
<p>Integer item = i.next();</p>
<p>System.out.println(item);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 102.4: Using the raw iterator</p>
<p>While using the foreach loop (or "extended for loop") is simple, it's
sometimes beneficial to use the iterator directly.</p>
<p>For example, if you want to output a bunch of comma-separated values,
but don't want the last item to have a comma:</p>
<p>List yourData = <em>//...</em></p>
<p>Iterator iterator = yourData.iterator();</p>
<p><strong>while</strong> (iterator.hasNext()){</p>
<p>// next() "moves" the iterator to the next entry and returns it's
value. <em>String entry = iterator.next();</em></p>
<p>System.out.print(entry);</p>
<p><strong>if</strong> (iterator.hasNext()){</p>
<p>// If the iterator has another element after the current one:
<em>System.out.print(",");</em></p>
<p>}</p>
<p>}</p>
<p>This is much easier and clearer than having a isLastEntry variable or
doing calculations with the loop index.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 578</p>
<p><span id="Chapter_103__Reflection_API_1"
class="anchor"></span>Chapter 103: Reflection API</p>
<p>Reflection is commonly used by programs which require the ability to
examine or modify the runtime behavior of</p>
<p>applications running in the JVM. <a
href="https://docs.oracle.com/javase/tutorial/reflect/">Java Reflection
API is used for that purpose where it makes it possible to inspect</a>
classes, interfaces, fields and methods at runtime, without knowing
their names at compile time. And It also makes</p>
<p>it possible to instantiate new objects, and to invoke methods using
reflection.</p>
<p>Section 103.1: Dynamic Proxies</p>
<p>Dynamic Proxies do not really have much to do with Reflection but
they are part of the API. It's basically a way to</p>
<p>create a dynamic implementation of an interface. This could be
helpful when creating mockup services. A Dynamic Proxy is an instance of
an interface that is created with a so-called invocation handler that
intercepts all</p>
<p>method calls and allows the handling of their invocation
manually.</p>
<p><strong>public class</strong> DynamicProxyTest {</p>
<p>public interface <strong>MyInterface1{</strong></p>
<p><strong>public void</strong> someMethod1();</p>
<p><strong>public int</strong> someMethod2(String s);</p>
<p>}</p>
<p>public interface <strong>MyInterface2{</strong></p>
<p><strong>public void</strong> anotherMethod();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[])
<strong>throws</strong> Exception {</p>
<p>// the dynamic proxy class</p>
<p>Class proxyClass = Proxy.getProxyClass(</p>
<p>ClassLoader.getSystemClassLoader(),</p>
<p><strong>new Class</strong>[] {MyInterface1.<strong>class</strong>,
MyInterface2.<strong>class</strong>});</p>
<p>// the dynamic proxy class constructor</p>
<p>Constructor proxyConstructor =</p>
<p>proxyClass.getConstructor(InvocationHandler.<strong>class</strong>);</p>
<p>// the invocation handler</p>
<p>InvocationHandler handler = <strong>new</strong>
InvocationHandler(){</p>
<p>// this method is invoked for every proxy method call // method is
the invoked method, args holds the method parameters // it must return
the method result</p>
<p>@Override</p>
<p><strong>public</strong> Object invoke(Object proxy, Method method,
Object[] args) <strong>throws</strong> Throwable {</p>
<p>String methodName = method.getName();</p>
<p><strong>if</strong>(methodName.equals("someMethod1")){</p>
<p>System.out.println("someMethod1 was invoked!");</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p><strong>if</strong>(methodName.equals("someMethod2")){</p>
<p>System.out.println("someMethod2 was invoked!");</p>
<p>System.out.println("Parameter: " + args[0]);</p>
<p>return <strong>42;</strong></p>
<p>}</p>
<p><strong>if</strong>(methodName.equals("anotherMethod")){</p>
<p>System.out.println("anotherMethod was invoked!");</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>System.out.println("Unkown method!");</p>
<p>return null<strong>;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 579</p>
<p><span id="_43" class="anchor"></span>}</p>
<p>};</p>
<p>// create the dynamic proxy instances</p>
<p>MyInterface1 i1 = (MyInterface1)
proxyConstructor.newInstance(handler);</p>
<p>MyInterface2 i2 = (MyInterface2)
proxyConstructor.newInstance(handler);</p>
<p>// and invoke some methods</p>
<p>i1.someMethod1();</p>
<p>i1.someMethod2("stackoverflow");</p>
<p>i2.anotherMethod();</p>
<p>}</p>
<p>}</p>
<p>The result of this code is this:</p>
<p>someMethod1 was invoked!</p>
<p>someMethod2 was invoked!</p>
<p>Parameter: stackoverflow</p>
<p>anotherMethod was invoked!</p>
<p>Section 103.2: Introduction</p>
<p>Basics</p>
<p>The Reflection API allows one to check the class structure of the
code at runtime and invoke code dynamically. This is very powerful, but
it is also dangerous since the compiler is not able to statically
determine whether dynamic</p>
<p>invocations are valid.</p>
<p>A simple example would be to get the public constructors and methods
of a given class:</p>
<p><strong>import</strong> java.lang.reflect.Constructor;</p>
<p><strong>import</strong> java.lang.reflect.Method;</p>
<p>// This is a object representing the String class (not an instance of
String!) <em>Class clazz = String.<strong>class</strong>;</em></p>
<p>Constructor[] constructors = clazz.getConstructors(); <em>// returns
all public constructors of String</em></p>
<p><em>Method[] methods = clazz.getMethods();</em> // returns all public
methods from String and parents</p>
<p>With this information it is possible to instance the object and call
different methods dynamically.</p>
<p>Reflection and Generic Types</p>
<p>Generic type information is available for:</p>
<p>method parameters, using getGenericParameterTypes(). method return
types, using getGenericReturnType().</p>
<p><strong>public</strong> fields, using getGenericType.</p>
<p>The following example shows how to extract the generic type
information in all three cases:</p>
<p><strong>import</strong> java.lang.reflect.Field;</p>
<p><strong>import</strong> java.lang.reflect.Method;</p>
<p><strong>import</strong> java.lang.reflect.ParameterizedType;</p>
<p><strong>import</strong> java.lang.reflect.Type;</p>
<p><strong>import</strong> java.util.List;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 580</p>
<p><span id="import_java_util_Map"
class="anchor"></span><strong>import</strong> java.util.Map;</p>
<p><strong>public class</strong> GenericTest {</p>
<p><strong>public static void</strong> main(<strong>final</strong>
String[] args) <strong>throws</strong> Exception {</p>
<p><strong>final</strong> Method method =
GenericTest.<strong>class</strong>.getMethod("testMethod",
Map.<strong>class</strong>); <strong>final</strong> Field field =
GenericTest.<strong>class</strong>.getField("testField");</p>
<p>System.out.println("Method parameter:");</p>
<p><strong>final</strong> Type parameterType =
method.getGenericParameterTypes()[0];</p>
<p>displayGenericType(parameterType, "<strong>\t</strong>");</p>
<p>System.out.println("Method return type:");</p>
<p><strong>final</strong> Type returnType =
method.getGenericReturnType();</p>
<p>displayGenericType(returnType, "<strong>\t</strong>");</p>
<p>System.out.println("Field type:");</p>
<p><strong>final</strong> Type fieldType = field.getGenericType();</p>
<p>displayGenericType(fieldType, "<strong>\t</strong>");</p>
<p>}</p>
<p><strong>private static void</strong>
displayGenericType(<strong>final</strong> Type type,
<strong>final</strong> String prefix) {</p>
<p>System.out.println(prefix + type.getTypeName());</p>
<p><strong>if</strong> (type <strong>instanceof</strong>
ParameterizedType) {</p>
<p><strong>for</strong> (<strong>final</strong> Type subtype :
((ParameterizedType) type).getActualTypeArguments()) {</p>
<p>displayGenericType(subtype, prefix + "<strong>\t</strong>");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> Map&gt;&gt; testField;</p>
<p><strong>public</strong> List testMethod(<strong>final</strong> Map
arg) {</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>This results in the following output:</p>
<p>Method parameter:</p>
<p>java.util.Map</p>
<p>java.lang.String</p>
<p>java.lang.Double</p>
<p>Method return type:</p>
<p>java.util.List</p>
<p>java.lang.Number</p>
<p>Field type:</p>
<p>java.util.Map</p>
<p>java.lang.String</p>
<p>java.util.Map</p>
<p>java.lang.Integer</p>
<p>java.util.List</p>
<p>java.lang.String</p>
<p>Section 103.3: Evil Java hacks with Reflection</p>
<p>The Reflection API could be used to change values of private and
final fields even in the JDK default library. This</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 581</p>
<p>could be used to manipulate the behaviour of some well known classes
as we will see.</p>
<p>What is not possible</p>
<p>Lets start first with the only limitation means the only field we
can't change with Reflection. That is the Java</p>
<p>SecurityManager . It is declared in <a
href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/System.java">java.lang.System
as</a></p>
<p><strong>private static volatile</strong> SecurityManager security =
<strong>null</strong>;</p>
<p>But it won't be listed in the System class if we run this code</p>
<p><strong>for</strong>(Field f :
System.<strong>class</strong>.getDeclaredFields())</p>
<p>System.out.println(f);</p>
<p>Thats because of the fieldFilterMap in <a
href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/reflect/Reflection.java">sun.reflect.Reflection
that holds the map itself and the security field in</a></p>
<p>the System.<strong>class</strong> and protects them against any
access with Reflection. So we could not deactivate the SecurityManager
.</p>
<p>Crazy Strings</p>
<p>Each Java String is represented by the JVM as an instance of the
String class. However, in some situations the JVM saves heap space by
using the same instance for Strings that are. This happens for string
literals, and also for</p>
<p>strings that have been "interned" by calling String.intern(). So if
you have "hello" in your code multiple times it is always the same
object instance.</p>
<p>Strings are supposed to be immutable, but it is possible to use
"evil" reflection to change them. The example below show how we can
change the characters in a String by replacing its value field.</p>
<p><strong>public class</strong> CrazyStrings {</p>
<p>static <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p>Field f =
String.<strong>class</strong>.getDeclaredField("value");</p>
<p>f.setAccessible(<strong>true</strong>);</p>
<p>f.set("hello", "you stink!".toCharArray());</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>System.out.println("hello");</p>
<p>}</p>
<p>}</p>
<p>So this code will print "you stink!"</p>
<p>1 = 42</p>
<p>The same idea could be used with the Integer Class</p>
<p>public class <strong>CrazyMath {</strong></p>
<p>static <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p>Field value =
Integer.<strong>class</strong>.getDeclaredField("value");</p>
<p>value.setAccessible(<strong>true</strong>);</p>
<p>value.setInt(Integer.valueOf(1), 42);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 582</p>
<p><span id="public_static_void_main_String_a"
class="anchor"></span><strong>public static void</strong> main(String
args[]) {</p>
<p>System.out.println(Integer.valueOf(1));</p>
<p>}</p>
<p>}</p>
<p>Everything is true</p>
<p>And according to <a
href="http://stackoverflow.com/questions/3301635/change-private-static-final-field-using-java-reflection">this
stackoverflow post</a> we can use reflection to do something really
evil.</p>
<p>public class <strong>Evil {</strong></p>
<p>static <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p>Field field = Boolean.<strong>class</strong>.getField("FALSE");</p>
<p>field.setAccessible(<strong>true</strong>);</p>
<p>Field modifiersField =
Field.<strong>class</strong>.getDeclaredField("modifiers");</p>
<p>modifiersField.setAccessible(<strong>true</strong>);</p>
<p>modifiersField.setInt(field, field.getModifiers() &amp;
~Modifier.<strong>FINAL</strong>);</p>
<p>field.set(<strong>null</strong>, <strong>true</strong>);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>System.out.format("Everything is %s", <strong>false</strong>);</p>
<p>}</p>
<p>}</p>
<p>Note that what we are doing here is going to cause the JVM to behave
in inexplicable ways. This is very dangerous.</p>
<p>Section 103.4: Misuse of Reflection API to change private and</p>
<p>final variables</p>
<p>Reflection is useful when it is properly used for right purpose. By
using reflection, you can access private variables and re-initialize
final variables.</p>
<p>Below is the code snippet, which is <strong>not</strong>
recommended.</p>
<p><strong>import</strong> java.lang.reflect.*;</p>
<p><strong>public class</strong> ReflectionDemo{</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>try<strong>{</strong></p>
<p>Field[] fields = A.<strong>class</strong>.getDeclaredFields();</p>
<p>A a = <strong>new</strong> A();</p>
<p><strong>for</strong> ( Field field:fields ) {</p>
<p><strong>if</strong>(field.getName().equalsIgnoreCase("name")){</p>
<p>field.setAccessible(<strong>true</strong>);</p>
<p>field.set(a, "StackOverFlow");</p>
<p>System.out.println("A.name="+field.get(a));</p>
<p>}</p>
<p><strong>if</strong>(field.getName().equalsIgnoreCase("age")){</p>
<p>field.set(a, 20);</p>
<p>System.out.println("A.age="+field.get(a));</p>
<p>}</p>
<p><strong>if</strong>(field.getName().equalsIgnoreCase("rep")){</p>
<p>field.setAccessible(<strong>true</strong>);</p>
<p>field.set(a,"New Reputation");</p>
<p>System.out.println("A.rep="+field.get(a));</p>
<p>}</p>
<p><strong>if</strong>(field.getName().equalsIgnoreCase("count")){</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 583</p>
<p><span id="field_set_a_25" class="anchor"></span>field.set(a,25);</p>
<p>System.out.println("A.count="+field.get(a));</p>
<p>}</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception err){</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>class <strong>A {</strong></p>
<p><strong>private</strong> String name;</p>
<p>public int <strong>age;</strong></p>
<p>public final <strong>String rep;</strong></p>
<p>public static int <strong>count=0;</strong></p>
<p>public <strong>A(){</strong></p>
<p>name = "Unset";</p>
<p>age = 0;</p>
<p>rep = "Reputation";</p>
<p>count++;</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>A.name=StackOverFlow</p>
<p>A.age=20</p>
<p>A.rep=New Reputation</p>
<p>A.count=25</p>
<p>Explanation:</p>
<p>In normal scenario, <strong>private</strong> variables can't be
accessed outside of declared class ( without getter and setter methods).
<strong>final</strong> variables can't be re-assigned after
initialization.</p>
<p>Reflection breaks both barriers can be abused to change both private
and final variables as explained above.</p>
<p>field.setAccessible(<strong>true</strong>) is the key to achieve
desired functionality.</p>
<p>Section 103.5: Getting and Setting fields</p>
<p>Using the Reflection API, it is possible to change or get the value
of a field at runtime. For example, you could use it in an API to
retrieve different fields based on a factor, like the OS. You can also
remove modifiers like <strong>final</strong> to allow</p>
<p>modifing fields that are final.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getField-java.lang.String-">To
do so, you will need to use the method Class#getField() in a way such as
the one shown below:</a></p>
<p>// Get the field in class SomeClass "NAME".</p>
<p>Field nameField =
SomeClass.<strong>class</strong>.getDeclaredField("NAME");</p>
<p>// Get the field in class Field "modifiers". Note that it does not //
need to be static</p>
<p>Field modifiersField =
Field.<strong>class</strong>.getDeclaredField("modifiers");</p>
<p>// Allow access from anyone even if it's declared private
<em>modifiersField.setAccessible(<strong>true</strong>);</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 584</p>
<p><span id="___Get_the_modifiers_on_the__NAM"
class="anchor"></span><em>// Get the modifiers on the "NAME" field as an
int.</em> <strong>int</strong> existingModifiersOnNameField =
nameField.getModifiers();</p>
<p>// Bitwise AND NOT Modifier.FINAL (16) on the existing modifiers //
Readup here https://en.wikipedia.org/wiki/Bitwise_operations_in_C // if
you're unsure what bitwise operations are.</p>
<p><strong>int</strong> newModifiersOnNameField =
existingModifiersOnNameField &amp; ~Modifier.<strong>FINAL</strong>;</p>
<p>// Set the value of the modifiers field under an object for
non-static fields <em>modifiersField.setInt(nameField,
newModifiersOnNameField);</em></p>
<p>// Set it to be accessible. This overrides normal Java //
private/protected/package/etc access control checks.
<em>nameField.setAccessible(<strong>true</strong>);</em></p>
<p>// Set the value of "NAME" here. Note the null argument. // Pass null
when modifying static fields, as there is no instance object</p>
<p>nameField.set(<strong>null</strong>, "Hacked by reflection...");</p>
<p>// Here I can directly access it. If needed, use reflection to get
it. (Below) <em>System.out.println(SomeClass.NAME);</em></p>
<p>Getting fields is much easier. We can use <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html#get-java.lang.Object-">Field#get()</a>
and its variants to get its value:</p>
<p>// Get the field in class SomeClass "NAME".</p>
<p>Field nameField =
SomeClass.<strong>class</strong>.getDeclaredField("NAME");</p>
<p>// Set accessible for private fields</p>
<p>nameField.setAccessible(<strong>true</strong>);</p>
<p>// Pass null as there is no instance, remember?</p>
<p>String name = (String) nameField.get(<strong>null</strong>);</p>
<p>Do note this:</p>
<p>When using <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredField-java.lang.String-">Class#getDeclaredField</a>,
use it to get a field in the class itself:</p>
<p><strong>class</strong> HackMe <strong>extends</strong> Hacked {</p>
<p><strong>public</strong> String iAmDeclared;</p>
<p>}</p>
<p><strong>class</strong> Hacked {</p>
<p><strong>public</strong> String someState;</p>
<p>}</p>
<p>Here, HackMe#iAmDeclared is declared field. However, HackMe#someState
is not a declared field as it is inherited</p>
<p>from its superclass, Hacked.</p>
<p>Section 103.6: Call constructor</p>
<p>Getting the Constructor Object</p>
<p>You can obtain Constructor class from the <strong>Class</strong>
object like this:</p>
<p><em><strong>Class</strong> myClass = ...</em> // get a class
object</p>
<p>Constructor[] constructors = myClass.getConstructors();</p>
<p>Where the constructors variable will have one Constructor instance
for each public constructor declared in the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 585</p>
<p><span id="class" class="anchor"></span>class.</p>
<p>If you know the precise parameter types of the constructor you want
to access, you can filter the specific</p>
<p>constructor. The next example returns the public constructor of the
given class which takes a Integer as parameter:</p>
<p><em><strong>Class</strong> myClass = ...</em> // get a class
object</p>
<p>Constructor constructor = myClass.getConstructor(<strong>new
Class</strong>[]{Integer.<strong>class</strong>});</p>
<p>If no constructor matches the given constructor arguments a
NoSuchMethodException is thrown.</p>
<p>New Instance using Constructor Object</p>
<p><em><strong>Class</strong> myClass =
MyObj.<strong>class</strong></em> // get a class object</p>
<p>Constructor constructor =
myClass.getConstructor(Integer.<strong>class</strong>); MyObj myObj =
(MyObj) constructor.newInstance(Integer.valueOf(123));</p>
<p>Section 103.7: Call constructor of nested class</p>
<p>If you want to create an instance of an inner nested class you need
to provide a class object of the enclosing class</p>
<p><a
href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredConstructor%28java.lang.Class...%29">as
an extra parameter with Class#getDeclaredConstructor</a>.</p>
<p>public class <strong>Enclosing{</strong></p>
<p>public class <strong>Nested{</strong></p>
<p><strong>public</strong> Nested(String a){</p>
<p>System.out.println("Constructor :String =&gt; "+a);</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[])
<strong>throws</strong> Exception { Class clazzEnclosing =
<strong>Class</strong>.forName("Enclosing"); Class clazzNested =
<strong>Class</strong>.forName("Enclosing$Nested"); Enclosing
objEnclosing = (Enclosing)clazzEnclosing.newInstance(); Constructor
constructor =
clazzNested.getDeclaredConstructor(<strong>new</strong></p>
<p><strong>Class</strong>[]{Enclosing.<strong>class</strong>,
String.<strong>class</strong>});</p>
<p>Nested objInner =
(Nested)constructor.newInstance(<strong>new</strong>
Object[]{objEnclosing, "StackOverFlow"});</p>
<p>}</p>
<p>}</p>
<p>If the nested class is static you will not need this enclosing
instance.</p>
<p>Section 103.8: Invoking a method</p>
<p>Using reflection, a method of an object can be invoked during
runtime.</p>
<p>The example shows how to invoke the methods of a String object.</p>
<p><strong>import</strong> java.lang.reflect.InvocationTargetException;
<strong>import</strong> java.lang.reflect.Method;</p>
<p>String s = "Hello World!";</p>
<p>// method without parameters</p>
<p>// invoke s.length()</p>
<p>Method method1 =
String.<strong>class</strong>.getMethod("length");</p>
<p><strong>int</strong> length = (<strong>int</strong>)
method1.invoke(s); <em>// variable length contains "12"</em></p>
<p>// method with parameters</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 586</p>
<p><span id="___invoke_s_substring_6" class="anchor"></span>// invoke
s.substring(6)</p>
<p>Method method2 = String.<strong>class</strong>.getMethod("substring",
<strong>int</strong>.<strong>class</strong>); String substring =
(String) method2.invoke(s, 6); <em>// variable substring contains
"World!"</em></p>
<p>Section 103.9: Get Class given its (fully qualified) name</p>
<p>Given a String containing the name of a class, it's
<strong>Class</strong> object can be accessed using
<strong>Class</strong>.forName:</p>
<p><strong>Class</strong> clazz = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>clazz = <strong>Class</strong>.forName("java.lang.Integer");</p>
<p>} <strong>catch</strong> (ClassNotFoundException ex) {</p>
<p><strong>throw new</strong> IllegalStateException(ex);</p>
<p>}</p>
<p>Version ≥ Java SE 1.2</p>
<p>It can be specified, if the class should be initialized (second
parameter of forName) and which ClassLoader should be used (third
parameter):</p>
<p>ClassLoader classLoader = ...</p>
<p><strong>boolean</strong> initialize = ...</p>
<p><strong>Class</strong> clazz = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>clazz = <strong>Class</strong>.forName("java.lang.Integer",
initialize, classLoader); } <strong>catch</strong>
(ClassNotFoundException ex) {</p>
<p><strong>throw new</strong> IllegalStateException(ex);</p>
<p>}</p>
<p>Section 103.10: Getting the Constants of an Enumeration</p>
<p>Giving this enumeration as Example:</p>
<p><strong>enum</strong> Compass {</p>
<p>NORTH(0),</p>
<p>EAST(90),</p>
<p>SOUTH(180),</p>
<p>WEST(270);</p>
<p>private int <strong>degree;</strong></p>
<p>Compass(<strong>int</strong> deg){</p>
<p>degree = deg;</p>
<p>}</p>
<p><strong>public int</strong> getDegree(){</p>
<p><strong>return</strong> degree;</p>
<p>}</p>
<p>}</p>
<p>In Java an enum class is like any other class but has some definied
constants for the enum values. Additionally it has</p>
<p>a field that is an array that holds all the values and two static
methods with name values() and valueOf(String). We can see this if we
use Reflection to print all fields in this class</p>
<p><strong>for</strong>(Field f :
Compass.<strong>class</strong>.getDeclaredFields())</p>
<p>System.out.println(f.getName());</p>
<p>the output will be:</p>
<p>NORTH</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 587</p>
<p><span id="EAST" class="anchor"></span>EAST</p>
<p>SOUTH</p>
<p>WEST</p>
<p>degree</p>
<p>ENUM$VALUES</p>
<p>So we could examine enum classes with Reflection like any other
class. But the Reflection API offers three enum-</p>
<p>specific methods.</p>
<p>enum check</p>
<p>Compass.<strong>class</strong>.isEnum();</p>
<p>Returns true for classes that represents an enum type.</p>
<p>retrieving values</p>
<p>Object[] values =
Compass.<strong>class</strong>.getEnumConstants();</p>
<p>Returns an array of all enum values like Compass.values() but without
the need of an instance.</p>
<p>enum constant check</p>
<p><strong>for</strong>(Field f :
Compass.<strong>class</strong>.getDeclaredFields()){</p>
<p><strong>if</strong>(f.isEnumConstant())</p>
<p>System.out.println(f.getName());</p>
<p>}</p>
<p>Lists all the class fields that are enum values.</p>
<p>Section 103.11: Call overloaded constructors using reflection</p>
<p>Example: Invoke different constructors by passing relevant
parameters</p>
<p><strong>import</strong> java.lang.reflect.*;</p>
<p><strong>class</strong> NewInstanceWithReflection{</p>
<p><strong>public</strong> NewInstanceWithReflection(){</p>
<p>System.out.println("Default constructor");</p>
<p>}</p>
<p><strong>public</strong> NewInstanceWithReflection( String a){</p>
<p>System.out.println("Constructor :String =&gt; "+a);</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[])
<strong>throws</strong> Exception {</p>
<p>NewInstanceWithReflection object =</p>
<p>(NewInstanceWithReflection)<strong>Class</strong>.forName("NewInstanceWithReflection").newInstance();</p>
<p>Constructor constructor =
NewInstanceWithReflection.<strong>class</strong>.getDeclaredConstructor(
<strong>new</strong></p>
<p><strong>Class</strong>[] {String.<strong>class</strong>});</p>
<p>NewInstanceWithReflection object1 =
(NewInstanceWithReflection)constructor.newInstance(<strong>new</strong>
Object[]{"StackOverFlow"});</p>
<p>}</p>
<p>}</p>
<p>output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 588</p>
<p>Default constructor</p>
<p>Constructor :String =&gt; StackOverFlow</p>
<p>Explanation:</p>
<p>1. Create instance of class using <strong>Class</strong>.forName : It
calls default constructor 2. Invoke getDeclaredConstructor of the class
by passing type of parameters as <strong>Class</strong> array</p>
<p>3. After getting the constructor, create newInstance by passing
parameter value as Object array</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 589</p>
<p><span id="Chapter_104__ByteBu_er_1" class="anchor"></span>Chapter
104: ByteBuer</p>
<p>The ByteBuffer class was introduced in java 1.4 to ease working on
binary data. It's especially suited to use with</p>
<p>primitive type data. It allows the creation, but also subsequent
manipulation of a <strong>byte</strong>[]s on a higher abstraction
level</p>
<p>Section 104.1: Basic Usage - Using DirectByteBuer</p>
<p>DirectByteBuffer is special implementation of ByteBuffer that has no
<strong>byte</strong>[] laying underneath.</p>
<p>We can allocate such ByteBuffer by calling:</p>
<p>ByteBuffer directBuffer = ByteBuffer.allocateDirect(16);</p>
<p>This operation will allocate 16 bytes of memory. The contents of
direct buffers <em>may</em> reside outside of the normal
garbage-collected heap.</p>
<p>We can verify whether ByteBuffer is direct by calling:</p>
<p>directBuffer.isDirect(); <em>// true</em></p>
<p>The main characteristics of DirectByteBuffer is that JVM will try to
natively work on allocated memory without any additional buffering so
operations performed on it may be faster then those performed on
ByteBuffers with arrays</p>
<p>lying underneath.</p>
<p>It is recomended to use DirectByteBuffer with heavy IO operations
that rely on speed of execution, like real time</p>
<p>communication.</p>
<p>We have to be aware that if we try using array() method we will get
UnsupportedOperationException. So it is a</p>
<p>good practice to chech whether our ByteBuffer has it (byte array)
before we try to access it:</p>
<p><strong>byte</strong>[] arrayOfBytes;</p>
<p><strong>if</strong>(buffer.hasArray()) {</p>
<p>arrayOfBytes = buffer.array();</p>
<p>}</p>
<p>Another use of direct byte buffer is interop through JNI. Since a
direct byte buffer does not use a <strong>byte</strong>[], but an actual
block of memory, it is possible to access that memory directly through a
pointer in native code. This can save</p>
<p>a bit of trouble and overhead on marshalling between the Java and
native representation of data.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#nio_support">The
JNI interface defines several functions to handle direct byte buffers:
NIO Support</a>.</p>
<p>Section 104.2: Basic Usage - Creating a ByteBuer</p>
<p>There's two ways to create a ByteBuffer, where one can be subdivided
again.</p>
<p>If you have an already existing <strong>byte</strong>[], you can
<em>"wrap"</em> it into a ByteBuffer to simplify processing:</p>
<p><strong>byte</strong>[] reqBuffer = <strong>new
byte</strong>[BUFFER_SIZE];</p>
<p><strong>int</strong> readBytes = socketInputStream.read(reqBuffer);
<strong>final</strong> ByteBuffer reqBufferWrapper =
ByteBuffer.wrap(reqBuffer);</p>
<p>This would be a possibility for code that handles low-level
networking interactions</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 590</p>
<p><span id="If_you_do_not_have_an_already_ex" class="anchor"></span>If
you do not have an already existing <strong>byte</strong>[], you can
create a ByteBuffer over an array that's specifically allocated for the
buffer like this:</p>
<p><strong>final</strong> ByteBuffer respBuffer =
ByteBuffer.allocate(RESPONSE_BUFFER_SIZE);
putResponseData(respBuffer);</p>
<p>socketOutputStream.write(respBuffer.array());</p>
<p>If the code-path is extremely performance critical and you need
<strong>direct system memory access</strong>, the ByteBuffer</p>
<p>can even allocate <em>direct</em> buffers using #allocateDirect()</p>
<p>Section 104.3: Basic Usage - Write Data to the Buer</p>
<p>Given a ByteBuffer instance one can write primitive-type data to it
using <em>relative</em> and <em>absolute</em> put. The striking
difference is that putting data using the <em>relative</em> method keeps
track of the index the data is inserted at for you,</p>
<p>while the absolute method always requires giving an index to put the
data at.</p>
<p>Both methods allow <em>"chaining"</em> calls. Given a sufficiently
sized buffer one can accordingly do the following:</p>
<p>buffer.putInt(0xCAFEBABE).putChar('c').putFloat(0.25).putLong(0xDEADBEEFCAFEBABE);</p>
<p>which is equivalent to:</p>
<p>buffer.putInt(0xCAFEBABE);</p>
<p>buffer.putChar('c');</p>
<p>buffer.putFloat(0.25);</p>
<p>buffer.putLong(0xDEADBEEFCAFEBABE);</p>
<p>Do note that the method operating on <strong>byte</strong>s is not
named specially. Additionally note that it's also valid to pass both a
ByteBuffer and a <strong>byte</strong>[] to put. Other than that, all
primitive types have specialized put-methods.</p>
<p>An additional note: The index given when using absolute put* is
always counted in <strong>byte</strong>s.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 591</p>
<p><span id="Chapter_105__Applets_1" class="anchor"></span>Chapter 105:
Applets</p>
<p>Applets have been part of Java since its official release and have
been used to teach Java and programming for a</p>
<p>number of years.</p>
<p>Recent years have seen an active push to move away from Applets and
other browser plugins, with some browsers</p>
<p>blocking them or actively not supporting them.</p>
<p>In 2016, Oracle announced their plans to deprecate the plugin, <a
href="https://blogs.oracle.com/java-platform-group/entry/moving_to_a_plugin_free">Moving
to a Plugin-Free Web</a></p>
<p>Newer and better APIs are now available</p>
<p>Section 105.1: Minimal Applet</p>
<p>A very simple applet draws a rectangle and prints a string something
on the screen.</p>
<p>public class <strong>MyApplet</strong> extends
<strong>JApplet{</strong></p>
<p><strong>private</strong> String str = "StackOverflow";</p>
<p>@Override</p>
<p>public void <strong>init() {</strong></p>
<p>setBackground(Color.gray);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> destroy() {}</p>
<p>@Override</p>
<p>public void <strong>start() {}</strong></p>
<p>@Override</p>
<p>public void <strong>stop() {}</strong></p>
<p>@Override</p>
<p><strong>public void</strong> paint(Graphics g) {</p>
<p>g.setColor(Color.yellow);</p>
<p>g.fillRect(1,1,300,150);</p>
<p>g.setColor(Color.red);</p>
<p>g.setFont(<strong>new</strong> Font("TimesRoman", Font.PLAIN,
48));</p>
<p>g.drawString(str, 10, 80);</p>
<p>}</p>
<p>}</p>
<p>The main class of an applet extends from javax.swing.JApplet.</p>
<p>Version ≤ Java SE 1.2</p>
<p>Before Java 1.2 and the introduction of the swing API applets had
extended from java.applet.Applet.</p>
<p>Applets don't require a main method. The entry point is controlled by
the life cycle. To use them, they need to be</p>
<p>embedded in a HTML document. This is also the point where their size
is defined.</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p><strong>&lt;applet</strong> code="MyApplet.class" width="400"
height="200"<strong>&gt;&lt;/applet&gt;</strong></p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 592</p>
<p><span id="Section_105_2__Creating_a_GUI"
class="anchor"></span>Section 105.2: Creating a GUI</p>
<p>Applets could easily be used to create a GUI. They act like a
Container and have an add() method that takes any</p>
<p>awt or swing component.</p>
<p><strong>public class</strong> MyGUIApplet <strong>extends</strong>
JApplet{</p>
<p><strong>private</strong> JPanel panel;</p>
<p><strong>private</strong> JButton button;</p>
<p><strong>private</strong> JComboBox cmbBox;</p>
<p><strong>private</strong> JTextField textField;</p>
<p>@Override</p>
<p>public void <strong>init(){</strong></p>
<p>panel = <strong>new</strong> JPanel();</p>
<p>button = <strong>new</strong> JButton("ClickMe!");</p>
<p>button.addActionListener(<strong>new</strong> ActionListener(){</p>
<p>@Override</p>
<p><strong>public void</strong> actionPerformed(ActionEvent ae) {</p>
<p><strong>if</strong>(((String)cmbBox.getSelectedItem()).equals("greet"))
{</p>
<p>JOptionPane.showMessageDialog(<strong>null</strong>,"Hello " +
textField.getText());</p>
<p>} <strong>else</strong> {</p>
<p>JOptionPane.showMessageDialog(<strong>null</strong>,textField.getText()
+ " stinks!");</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>cmbBox = <strong>new</strong> JComboBox&lt;&gt;(<strong>new</strong>
String[]{"greet", "offend"});</p>
<p>textField = <strong>new</strong> JTextField("John Doe");</p>
<p>panel.add(cmbBox);</p>
<p>panel.add(textField);</p>
<p>panel.add(button);</p>
<p>add(panel);</p>
<p>}</p>
<p>}</p>
<p>Section 105.3: Open links from within the applet</p>
<p>You can use the method getAppletContext() to get an AppletContext
object that allows you to request the</p>
<p>browser to open a link. For this you use the method showDocument().
Its second parameter tells the browser to use a new window _blank or the
one that shows the applet _self.</p>
<p><strong>public class</strong> MyLinkApplet <strong>extends</strong>
JApplet{</p>
<p>@Override</p>
<p>public void <strong>init(){</strong></p>
<p>JButton button = <strong>new</strong> JButton("ClickMe!");</p>
<p>button.addActionListener(<strong>new</strong> ActionListener(){</p>
<p>@Override</p>
<p><strong>public void</strong> actionPerformed(ActionEvent ae) {</p>
<p>AppletContext a = getAppletContext();</p>
<p>try <strong>{</strong></p>
<p>URL url = <strong>new</strong> URL("http://stackoverflow.com/");</p>
<p>a.showDocument(url,"_blank");</p>
<p><em>} <strong>catch</strong> (Exception e) {</em> /* omitted for
brevity */ <em>}</em></p>
<p>}</p>
<p>});</p>
<p>add(button);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 593</p>
<p><span id="Section_105_4__Loading_images__a"
class="anchor"></span>Section 105.4: Loading images, audio and other
resources</p>
<p>Java applets are able to load different resources. But since they are
running in the web browser of the client you</p>
<p>need to make sure that these resources are accessible. Applets are
not able to access client resources as the local</p>
<p>file system.</p>
<p>If you want to load resources from the same URL the Applet is stored
you can use the method getCodeBase() to retrieve the base URL. To load
resources, applets offer the methods getImage() and getAudioClip() to
load</p>
<p>images or audio files.</p>
<p>Load and show an image</p>
<p><strong>public class</strong> MyImgApplet <strong>extends</strong>
JApplet{</p>
<p><strong>private</strong> Image img;</p>
<p>@Override</p>
<p>public void <strong>init(){</strong></p>
<p>try <strong>{</strong></p>
<p>img = getImage(<strong>new</strong>
URL("http://cdn.sstatic.net/stackexchange/img/logos/so/so-logo.png"));</p>
<p>} <strong>catch</strong> (MalformedURLException e) { <em>/* omitted
for brevity */</em> }</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> paint(Graphics g) {</p>
<p>g.drawImage(img, 0, 0, <strong>this</strong>);</p>
<p>}</p>
<p>}</p>
<p>Load and play an audio file</p>
<p><strong>public class</strong> MyAudioApplet <strong>extends</strong>
JApplet{</p>
<p><strong>private</strong> AudioClip audioClip;</p>
<p>@Override</p>
<p>public void <strong>init(){</strong></p>
<p>try <strong>{</strong></p>
<p>audioClip = getAudioClip(<strong>new</strong>
URL("URL/TO/AN/AUDIO/FILE.WAV"));</p>
<p>} <strong>catch</strong> (MalformedURLException e) { <em>/* omitted
for brevity */</em> }</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>start() {</strong></p>
<p>audioClip.play();</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>stop(){</strong></p>
<p>audioClip.stop();</p>
<p>}</p>
<p>}</p>
<p>Load and display a text file</p>
<p><strong>public class</strong> MyTextApplet <strong>extends</strong>
JApplet{</p>
<p>@Override</p>
<p>public void <strong>init(){</strong></p>
<p>JTextArea textArea = <strong>new</strong> JTextArea();</p>
<p>JScrollPane sp = <strong>new</strong> JScrollPane(textArea);</p>
<p>add(sp);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 594</p>
<p>// load text</p>
<p>try <strong>{</strong></p>
<p>URL url = <strong>new</strong>
URL("http://www.textfiles.com/fun/quotes.txt"); InputStream in =
url.openStream();</p>
<p>BufferedReader bf = <strong>new</strong>
BufferedReader(<strong>new</strong> InputStreamReader(in)); String line
= "";</p>
<p><strong>while</strong>((line = bf.readLine()) !=
<strong>null</strong>) {</p>
<p>textArea.append(line + "<strong>\n</strong>");</p>
<p>}</p>
<p><em>} <strong>catch</strong>(Exception e) {</em> /* omitted for
brevity */ <em>}</em></p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 595</p>
<p><span id="Chapter_106__Expressions_1" class="anchor"></span>Chapter
106: Expressions</p>
<p>Expressions in Java are the primary construct for doing
calculations.</p>
<p>Section 106.1: Operator Precedence</p>
<p>When an expression contains multiple operators, it can potentially be
read in different ways. For example, the</p>
<p>mathematical expression 1 + 2 x 3 could be read in two ways:</p>
<p>1. Add 1 and 2 and multiply the result by 3. This gives the answer 9.
If we added parentheses, this would look</p>
<p>like ( 1 + 2 ) x 3.</p>
<p>2. Add 1 to the result of multiplying 2 and 3. This gives the answer
7. If we added parentheses, this would look</p>
<p>like 1 + ( 2 x 3 ).</p>
<p>In mathematics, the convention is to read the expression the second
way. The general rule is that multiplication and</p>
<p>division are done before addition and subtraction. When more advanced
mathematical notation is used, either the</p>
<p>meaning is either "self-evident" (to a trained mathematician!), or
parentheses are added to disambiguate. In either case, the effectiveness
of the notation to convey meaning depends on the intelligence and shared
knowledge of the</p>
<p>mathematicians.</p>
<p>Java has the same clear rules on how to read an expression, based on
the <em>precedence</em> of the operators that are</p>
<p>used.</p>
<p>In general, each operator is ascribed a <em>precedence</em> value;
see the table below.</p>
<p>For example:</p>
<p>1 + 2 * 3</p>
<p>The precedence of + is lower than the precedence of *, so the result
of the expression is 7, not 9.</p>
<p>Description Operators / constructs (primary) Precedence
Associativity</p>
<p>Qualifier name.name</p>
<p>Parentheses (expr)</p>
<p>Instance creation <strong>new</strong></p>
<p>Field access primary.name 15 Left to right</p>
<p>Array access primary[expr]</p>
<p>Method invocation primary(expr, ...)</p>
<p>Method reference primary::name</p>
<p>Post increment expr++, expr-- 14 -</p>
<p>Pre increment ++expr, --expr, -</p>
<p>Unary +expr, -expr, ~expr, !expr, 13 Right to left</p>
<p>Cast1 (type)expr Right to left</p>
<p>Multiplicative * / % 12 Left to right</p>
<p>Additive + - 11 Left to right</p>
<p>Shift &lt;&lt; &gt;&gt; &gt;&gt;&gt; 10 Left to right</p>
<p>Relational &lt; &gt; &lt;= &gt;= <strong>instanceof</strong> 9 Left
to right</p>
<p>Equality == != 8 Left to right</p>
<p>Bitwise AND &amp; 7 Left to right</p>
<p>Bitwise exclusive OR ^ 6 Left to right</p>
<p>Bitwise inclusive OR | 5 Left to right</p>
<p>Logical AND &amp;&amp; 4 Left to right</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 596</p>
<p><span id="Logical_OR" class="anchor"></span>Logical OR || 3 Left to
right</p>
<p>Conditional1 ? : 2 Right to left</p>
<p>Assignment = *= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;=
^= |= 1 Right to left Lambda1-&gt;</p>
<p>1 Lambda expression precedence is complex, as it can also occur after
a cast, or as the third part of the conditional</p>
<p>ternary operator.</p>
<p>Section 106.2: Expression Basics</p>
<p>Expressions in Java are the primary construct for doing calculations.
Here are some examples:</p>
<p><em>1</em> // A simple literal is an expression</p>
<p><em>1 + 2</em> // A simple expression that adds two numbers</p>
<p><em>(i + j) / k</em> // An expression with multiple operations
<em>(flag) ? c : d</em> // An expression using the "conditional"
operator <em>(String) s</em> // A type-cast is an expression</p>
<p><em>obj.test()</em> // A method call is an expression</p>
<p><em><strong>new</strong> Object()</em> // Creation of an object is an
expression <em><strong>new int</strong>[]</em> // Creation of an object
is an expression</p>
<p>In general, an expression consists of the following forms:</p>
<p>Expression names which consist of:</p>
<p>Simple identifiers; e.g. someIdentifier</p>
<p>Qualified identifiers; e.g. MyClass.someField</p>
<p>Primaries which consist of:</p>
<p>Literals; e.g. 1, 1.0, 'X', "hello", <strong>false</strong> and
<strong>null</strong></p>
<p>Class literal expressions; e.g. MyClass.<strong>class</strong></p>
<p>this <strong>and</strong> &lt;TypeName&gt; <strong>.
this</strong></p>
<p>Parenthesized expressions; e.g. ( a + b )</p>
<p>Class instance creation expressions; e.g. <strong>new</strong>
MyClass(1, 2, 3) Array instance creation expressions; e.g. <strong>new
int</strong>[3]</p>
<p>Field access expressions; e.g. obj.someField or
<strong>this</strong>.someField</p>
<p>Array access expressions; e.g. vector[21]</p>
<p>Method invocations; e.g. obj.doIt(1, 2, 3)</p>
<p>Method references (Java 8 and later); e.g. MyClass::doIt</p>
<p>Unary operator expressions; e.g. !a or i++</p>
<p>Binary operator expressions; e.g. a + b or obj ==
<strong>null</strong></p>
<p>Ternary operator expressions; e.g. (obj == <strong>null</strong>) ? 1
: obj.getCount()</p>
<p>Lambda expressions (Java 8 and later); e.g. obj -&gt;
obj.getCount()</p>
<p>The details of the different forms of expressions may be found in
other Topics.</p>
<p>The Operators topic covers unary, binary and ternary operator
expressions. The Lambda expressions topic covers lambda expressions and
method reference expressions.</p>
<p>The Classes and Objects topic covers class instance creation
expressions. The Arrays topic covers array access expressions and array
instance creation expressions.</p>
<p>The Literals topic covers the different kinds of literals
expressions.</p>
<p>The Type of an Expression</p>
<p>In most cases, an expression has a static type that can be determined
at compile time by examining and its</p>
<p>subexpressions. These are referred to as <em>stand-alone</em>
expressions.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 597</p>
<p><span id="However___in_Java_8_and_later__t"
class="anchor"></span>However, (in Java 8 and later) the following kinds
of expressions may be <em>poly expressions</em>:</p>
<p>Parenthesized expressions</p>
<p>Class instance creation expressions</p>
<p>Method invocation expressions</p>
<p>Method reference expressions</p>
<p>Conditional expressions</p>
<p>Lambda expressions</p>
<p>When an expression is a poly expression, its type may be influenced
by the expression's <em>target type</em>; i.e. what it is</p>
<p>being used for.</p>
<p>The value of an Expression</p>
<p>The value of an expression is assignment compatible with its type.
The exception to this is when <em>heap pollution</em> has</p>
<p>occurred; e.g. because "unsafe conversion" warnings have been
(inappropriately) suppressed or ignored.</p>
<p>Expression Statements</p>
<p>Unlike many other languages, Java does not generally allow
expressions to be used as statements. For example:</p>
<p><strong>public void</strong> compute(<strong>int</strong> i,
<strong>int</strong> j) {</p>
<p><em>i + j;</em> // ERROR</p>
<p>}</p>
<p>Since the result of evaluating an expression like cannot be use, and
since it cannot affect the execution of the</p>
<p>program in any other way, the Java designers took the position that
such usage is either a mistake, or misguided.</p>
<p>However, this does not apply to all expressions. A subset of
expressions are (in fact) legal as statements. The set</p>
<p>comprises:</p>
<p>Assignment expression, including <em>operation-and-becomes</em>
assignments.</p>
<p>Pre and post increment and decrement expressions.</p>
<p>Method calls (<strong>void</strong> or
non-<strong>void</strong>).</p>
<p>Class instance creation expressions.</p>
<p>Section 106.3: Expression evaluation order</p>
<p>Java expressions are evaluated following the following rules:</p>
<p>Operands are evaluated from left to right.</p>
<p>The operands of an operator are evaluated before the operator.</p>
<p>Operators are evaluated according to operator precedence Argument
lists are evaluated from left to right.</p>
<p>Simple Example</p>
<p>In the following example:</p>
<p><strong>int</strong> i = method1() + method2();</p>
<p>the order of evaluation is:</p>
<p>1. The left operand of = operator is evaluated to the address of
i.</p>
<p>2. The left operand of the + operator (method1()) is evaluated.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 598</p>
<p><span id="3__The_right_operand_of_the___op" class="anchor"></span>3.
The right operand of the + operator (method2()) is evaluated. 4. The +
operation is evaluated.</p>
<p>5. The = operation is evaluated, assigning the result of the addition
to i.</p>
<p>Note that if the effects of the calls are observable, you will be
able to observe that the call to method1 occurs before</p>
<p>the call to method2.</p>
<p>Example with an operator which has a side-effect</p>
<p>In the following example:</p>
<p><strong>int</strong> i = 1;</p>
<p>intArray[i] = ++i + 1;</p>
<p>the order of evaluation is:</p>
<p>1. The left operand of = operator is evaluated. This gives the
address of intArray[1].</p>
<p>2. The pre-increment is evaluated. This adds 1 to i, and evaluates to
2. 3. The right hand operand of the + is evaluated.</p>
<p>4. The + operation is evaluated to: 2 + 1 -&gt; 3.</p>
<p>5. The = operation is evaluated, assigning 3 to intArray[1].</p>
<p>Note that since the left-hand operand of the = is evaluated first, it
is not influenced by the side-effect of the ++i subexpression.</p>
<p>Reference:</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.7">JLS
15.7 - Evaluation Order</a></p>
<p>Section 106.4: Constant Expressions</p>
<p>A constant expression is an expression that yields a primitive type
or a String, and whose value can be evaluated at</p>
<p>compile time to a literal. The expression must evaluate without
throwing an exception, and it must be composed of only the
following:</p>
<p>Primitive and String literals.</p>
<p>Type casts to primitive types or String.</p>
<p>The following unary operators: +, -, ~ and !.</p>
<p>The following binary operators: *, /, %, +, -, &lt;&lt;, &gt;&gt;,
&gt;&gt;&gt;, &lt;, &lt;=, &gt;, &gt;=, ==, !=, &amp;, ^, |, &amp;&amp;
and ||.</p>
<p>The ternary conditional operator ? :.</p>
<p>Parenthesized constant expressions.</p>
<p>Simple names that refer to constant variables. (A constant variable
is a variable declared as <strong>final</strong> where the initializer
expression is itself a constant expression.)</p>
<p>Qualified names of the form <strong>&lt;TypeName&gt;</strong> .
<strong>&lt;Identifier&gt;</strong> that refer to constant
variables.</p>
<p>Note that the above list <em>excludes</em> ++ and --, the assignment
operators, <strong>class</strong> and <strong>instanceof</strong>,
method calls and references to general variables or fields.</p>
<p>Constant expressions of type String result in an "interned" String,
and floating point operations in constant</p>
<p>expressions are evaluated with FP-strict semantics.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 599</p>
<p>Uses for Constant Expressions</p>
<p>Constant expressions can be used (just about) anywhere that a normal
expression can be used. However, they have</p>
<p>a special significance in the following contexts.</p>
<p>Constant expressions are required for case labels in switch
statements. For example:</p>
<p><strong>switch</strong> (someValue) {</p>
<p><strong>case</strong> 1 + 1: <em>// OK</em></p>
<p><em><strong>case</strong> Math.min(2, 3):</em> // Error - not a
constant expression</p>
<p>doSomething();</p>
<p>}</p>
<p>When the expression on the right hand side of an assignment is a
constant expression, then the assignment can perform a primitive
narrowing conversion. This is allowed provided that the value of the
constant expression is</p>
<p>within the range of the type on the left hand side. (See <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3">JLS
5.1.3</a> <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.2">and
5.2</a>) For example:</p>
<p><em><strong>byte</strong> b1 = 1 + 1;</em> // OK - primitive
narrowing conversion. <em><strong>byte</strong> b2 = 127 + 1;</em> //
Error - out of range</p>
<p><em><strong>byte</strong> b3 = b1 + 1;</em> // Error - not a constant
expession <em><strong>byte</strong> b4 = (<strong>byte</strong>) (b1 +
1);</em> // OK</p>
<p>When a constant expression is used as the condition in a do,
<strong>while</strong> or <strong>for</strong>, then it affects the
readability analysis.</p>
<p>For example:</p>
<p>while <strong>(</strong>false<strong>) {</strong></p>
<p><em>doSomething();</em> // Error - statenent not reachable</p>
<p>}</p>
<p>boolean <strong>flag =</strong> false<strong>;</strong></p>
<p><strong>while</strong> (flag) {</p>
<p>doSomething(); <em>// OK</em></p>
<p>}</p>
<p>(Note that this does not apply if statements. The Java compiler
allows the then or <strong>else</strong> block of an if statement to</p>
<p>be unreachable. This is the Java analog of conditional compilation in
C and C++.)</p>
<p>Finally, <strong>static final</strong> fields in an class or
interface with constant expression initializers are initialized eagerly.
Thus,</p>
<p>it is guaranteed that these constants will be observed in the
initialized state, even when there is a cycle in the class
initialization dependency graph.</p>
<p>For more information, refer to <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3">JLS
15.28. Constant Expressions</a>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 600</p>
<p><span id="Chapter_107__JSON_in_Java_1" class="anchor"></span>Chapter
107: JSON in Java</p>
<p>JSON (JavaScript Object Notation) is a lightweight, text-based,
language-independent data exchange format that is</p>
<p>easy for humans and machines to read and write. JSON can represent
two structured types: objects and arrays.</p>
<p><a
href="http://www.oracle.com/technetwork/articles/java/json-1973242.html">JSON
is often used in Ajax applications, configurations, databases, and
RESTful web services. The Java API for JSON</a></p>
<p><a
href="http://www.oracle.com/technetwork/articles/java/json-1973242.html">Processing
provides portable APIs to parse, generate, transform, and query
JSON.</a></p>
<p>Section 107.1: Using Jackson Object Mapper</p>
<p>Pojo Model</p>
<p>public class <strong>Model {</strong></p>
<p><strong>private</strong> String firstName;</p>
<p><strong>private</strong> String lastName;</p>
<p>private int <strong>age;</strong></p>
<p>/* Getters and setters not shown for brevity */</p>
<p>}</p>
<p>Example: String to Object</p>
<p>Model outputObject = objectMapper.readValue(</p>
<p>"{<strong>\"</strong>firstName<strong>\"</strong>:<strong>\"</strong>John<strong>\"</strong>,<strong>\"</strong>lastName<strong>\"</strong>:<strong>\"</strong>Doe<strong>\"</strong>,<strong>\"</strong>age<strong>\"</strong>:23}",</p>
<p>Model.<strong>class</strong>);</p>
<p>System.out.println(outputObject.getFirstName());</p>
<p>//result: John</p>
<p>Example: Object to String</p>
<p>String jsonString = objectMapper.writeValueAsString(inputObject));
<em>//result: {"firstName":"John","lastName":"Doe","age":23}</em></p>
<p>Details</p>
<p>Import statement needed:</p>
<p><strong>import</strong>
com.fasterxml.jackson.databind.ObjectMapper;</p>
<p><a
href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind">Maven
dependency: jackson-databind</a></p>
<p>ObjectMapper instance</p>
<p>//creating one</p>
<p>ObjectMapper objectMapper = <strong>new</strong> ObjectMapper();</p>
<p>ObjectMapper is threadsafe</p>
<p>recommended: have a shared, static instance</p>
<p>Deserialization:</p>
<p><strong>&lt;T&gt;</strong> T readValue(String content,
Class<strong>&lt;T&gt;</strong> valueType)</p>
<p>valueType needs to be specified -- the return will be of this type
Throws</p>
<p>IOException - in case of a low-level I/O problem</p>
<p>JsonParseException - if underlying input contains invalid content
JsonMappingException - if the input JSON structure does not match object
structure</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 601</p>
<p><span id="Usage_example__jsonString_is_the"
class="anchor"></span>Usage example (jsonString is the input
string):</p>
<p>Model fromJson = objectMapper.readValue(jsonString,
Model.<strong>class</strong>);</p>
<p>Method for serialization:</p>
<p>String writeValueAsString(Object value)</p>
<p>Throws</p>
<p>JsonProcessingException in case of an error</p>
<p>Note: prior to version 2.1, throws clause included IOException; 2.1
removed it.</p>
<p>Section 107.2: JSON To Object (Gson Library)</p>
<p>Lets assume you have a class called Person with just name</p>
<p>private class <strong>Person {</strong></p>
<p><strong>public</strong> String name;</p>
<p><strong>public</strong> Person(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p>Code:</p>
<p>Gson gson = <strong>new</strong> Gson();</p>
<p>String json = "{<strong>\"</strong>name<strong>\"</strong>:
<strong>\"</strong>John<strong>\"</strong>}";</p>
<p>Person person = gson.fromJson(json, Person.<strong>class</strong>);
System.out.println(person.name); <em>//John</em></p>
<p>You must have <a
href="https://mvnrepository.com/artifact/com.google.code.gson/gson">gson
library</a> in your classpath.</p>
<p>Section 107.3: JSONObject.NULL</p>
<p>If you need to add a property with a <strong>null</strong> value, you
should use the predefined static final JSONObject.<strong>NULL</strong>
and not</p>
<p>the standard Java <strong>null</strong> reference.</p>
<p>JSONObject.<strong>NULL</strong> is a sentinel value used to
explicitly define a property with an empty value.</p>
<p>JSONObject obj = <strong>new</strong> JSONObject();</p>
<p>obj.put("some", JSONObject.<strong>NULL</strong>); <em>//Creates:
{"some":null}</em> System.out.println(obj.get("some"));<em>//prints:
null</em></p>
<p>Note</p>
<p>JSONObject.<strong>NULL</strong>.equals(<strong>null</strong>);
<em>//returns true</em></p>
<p>Which is a <strong>clear violation</strong> of <a
href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)">Java.equals()</a>
contract:</p>
<p>For any non-null reference value x, x.equals(null) should return
false</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 602</p>
<p><span id="Section_107_4__JSON_Builder___ch"
class="anchor"></span>Section 107.4: JSON Builder - chaining methods</p>
<p><a href="https://en.wikipedia.org/wiki/Method_chaining">You can use
method chaining</a> while working with JSONObject and JSONArray.</p>
<p>JSONObject example</p>
<p><em>JSONObject obj = <strong>new</strong>
JSONObject();</em>//Initialize an empty JSON object //Before: {}</p>
<p>obj.put("name","Nikita").put("age","30").put("isMarried","true");
<em>//After: {"name":"Nikita","age":30,"isMarried":true}</em></p>
<p>JSONArray</p>
<p><em>JSONArray arr = <strong>new</strong>
JSONArray();</em>//Initialize an empty array //Before: []</p>
<p>arr.put("Stack").put("Over").put("Flow");</p>
<p>//After: ["Stack","Over","Flow"]</p>
<p>Section 107.5: Object To JSON (Gson Library)</p>
<p>Lets assume you have a class called Person with just name</p>
<p>private class <strong>Person {</strong></p>
<p><strong>public</strong> String name;</p>
<p><strong>public</strong> Person(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>}</p>
<p>Code:</p>
<p>Gson g = <strong>new</strong> Gson();</p>
<p>Person person = <strong>new</strong> Person("John");</p>
<p>System.out.println(g.toJson(person)); <em>// {"name":"John"}</em></p>
<p><a
href="http://central.maven.org/maven2/com/google/code/gson/gson/2.3.1/gson-2.3.1.jar">Of
course the Gson</a> jar must be on the classpath.</p>
<p>Section 107.6: JSON Iteration</p>
<p>Iterate over JSONObject properties</p>
<p>JSONObject obj = <strong>new</strong>
JSONObject("{<strong>\"</strong>isMarried<strong>\"</strong>:<strong>\"</strong>true<strong>\"</strong>,
<strong>\"</strong>name<strong>\"</strong>:<strong>\"</strong>Nikita<strong>\"</strong>,
<strong>\"</strong>age<strong>\"</strong>:<strong>\"</strong>30<strong>\"</strong>}");
Iterator keys = obj.keys();<em>//all keys: isMarried, name &amp;
age</em> <strong>while</strong> (keys.hasNext()) { <em>//as long as
there is another key</em></p>
<p>String key = keys.next(); <em>//get next key</em></p>
<p>Object value = obj.get(key); <em>//get next value by key</em>
System.out.println(key + " : " + value);<em>//print key : value</em></p>
<p>}</p>
<p>Iterate over JSONArray values</p>
<p><em>JSONArray arr = <strong>new</strong> JSONArray();</em>
//Initialize an empty array //push (append) some values in:</p>
<p>arr.put("Stack");</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 603</p>
<p><span id="arr_put__Over" class="anchor"></span>arr.put("Over");</p>
<p>arr.put("Flow");</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
arr.length(); i++) {<em>//iterate over all values</em></p>
<p>Object value = arr.get(i); <em>//get value</em></p>
<p>System.out.println(value); <em>//print each value</em></p>
<p>}</p>
<p>Section 107.7: optXXX vs getXXX methods</p>
<p>JSONObject and JSONArray have a few methods that are very useful
while dealing with a possibility that a value</p>
<p>your are trying to get does not exist or is of another type.</p>
<p>JSONObject obj = <strong>new</strong> JSONObject();</p>
<p>obj.putString("foo", "bar");</p>
<p>// For existing properties of the correct type, there is no
difference <em>obj.getString("foo");</em> // returns "bar"</p>
<p>obj.optString("foo"); <em>// returns "bar"</em></p>
<p>obj.optString("foo", "tux"); <em>// returns "bar"</em></p>
<p>// However, if a value cannot be coerced to the required type, the
behavior differs <em>obj.getInt("foo");</em> // throws JSONException</p>
<p>obj.optInt("foo"); <em>// returns 0</em></p>
<p>obj.optInt("foo", 123); <em>// returns 123</em></p>
<p>// Same if a property does not exist</p>
<p>obj.getString("undefined"); <em>// throws JSONException</em></p>
<p>obj.optString("undefined"); <em>// returns ""</em></p>
<p>obj.optString("undefined", "tux"); <em>// returns "tux"</em></p>
<p>The same rules apply to the getXXX / optXXX methods of JSONArray.</p>
<p>Section 107.8: Extract single element from JSON</p>
<p>String json = "{<strong>\"</strong>name<strong>\"</strong>:
<strong>\"</strong>John<strong>\"</strong>,
<strong>\"</strong>age<strong>\"</strong>:21}";</p>
<p>JsonObject jsonObject = <strong>new</strong>
JsonParser().parse(json).getAsJsonObject();</p>
<p>System.out.println(jsonObject.get("name").getAsString());
<em>//John</em> System.out.println(jsonObject.get("age").getAsInt());
<em>//21</em></p>
<p>Section 107.9: JsonArray to Java List (Gson Library)</p>
<p>Here is a simple JsonArray which you would like to convert to a Java
ArrayList:</p>
<p>{</p>
<p>"list": [</p>
<p>"Test_String_1",</p>
<p>"Test_String_2"</p>
<p>]</p>
<p>}</p>
<p>Now pass the JsonArray 'list' to the following method which returns a
corresponding Java ArrayList:</p>
<p><strong>public</strong> ArrayList getListString(String jsonList){</p>
<p>Type listType = <strong>new</strong> TypeToken&gt;()
{}.getType();</p>
<p>//make sure the name 'list' matches the name of 'JsonArray' in your
'Json'.</p>
<p>ArrayList list = <strong>new</strong> Gson().fromJson(jsonList,
listType);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 604</p>
<p><span id="return_list" class="anchor"></span>return
<strong>list;</strong></p>
<p>}</p>
<p>You should add the following maven dependency to your POM.xml
file:</p>
<p>&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson
--&gt; <em><strong>&lt;dependency&gt;</strong></em></p>
<p><strong>&lt;groupId&gt;</strong>com.google.code.gson<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>gson</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>2.7</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>Or you should have the jar com.google.code.gson:gson:jar: in your
classpath.</p>
<p>Section 107.10: Encoding data as JSON</p>
<p>If you need to create a JSONObject and put data in it, consider the
following example:</p>
<p>// Create a new javax.json.JSONObject instance.</p>
<p>JSONObject first = <strong>new</strong> JSONObject();</p>
<p>first.put("foo", "bar");</p>
<p>first.put("temperature", 21.5);</p>
<p>first.put("year", 2016);</p>
<p>// Add a second object.</p>
<p>JSONObject second = <strong>new</strong> JSONObject();</p>
<p>second.put("Hello", "world");</p>
<p>first.put("message", second);</p>
<p>// Create a new JSONArray with some values</p>
<p>JSONArray someMonths = <strong>new</strong>
JSONArray(<strong>new</strong> String[] { "January", "February" });
someMonths.put("March");</p>
<p>// Add another month as the fifth element, leaving the 4th element
unset. <em>someMonths.put(4, "May");</em></p>
<p>// Add the array to our object</p>
<p>object.put("months", someMonths);</p>
<p>// Encode</p>
<p>String json = object.toString();</p>
<p>// An exercise for the reader: Add pretty-printing! /* {</p>
<p>"foo":"bar",</p>
<p>"temperature":21.5,</p>
<p>"year":2016,</p>
<p>"message":{"Hello":"world"},</p>
<p>"months":["January","February","March",null,"May"]</p>
<p>}</p>
<p>*/</p>
<p>Section 107.11: Decoding JSON data</p>
<p>If you need to get data from a JSONObject, consider the following
example:</p>
<p>String json =</p>
<p>"{<strong>\"</strong>foo<strong>\"</strong>:<strong>\"</strong>bar<strong>\"</strong>,<strong>\"</strong>temperature<strong>\"</strong>:21.5,<strong>\"</strong>year<strong>\"</strong>:2016,<strong>\"</strong>message<strong>\"</strong>:{<strong>\"</strong>Hello<strong>\"</strong>:<strong>\"</strong>world<strong>\"</strong>},<strong>\"</strong>months<strong>\"</strong>:[
<strong>\"</strong>January<strong>\"</strong>,<strong>\"</strong>February<strong>\"</strong>,<strong>\"</strong>March<strong>\"</strong>,null,<strong>\"</strong>May<strong>\"</strong>]}";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 605</p>
<p>// Decode the JSON-encoded string</p>
<p>JSONObject object = <strong>new</strong> JSONObject(json);</p>
<p>// Retrieve some values</p>
<p>String foo = object.getString("foo");</p>
<p><strong>double</strong> temperature =
object.getDouble("temperature"); <strong>int</strong> year =
object.getInt("year");</p>
<p>// Retrieve another object</p>
<p>JSONObject secondary = object.getJSONObject("message"); String world
= secondary.getString("Hello");</p>
<p>// Retrieve an array</p>
<p>JSONArray someMonths = object.getJSONArray("months"); <em>// Get some
values from the array</em></p>
<p><strong>int</strong> nMonths = someMonths.length();</p>
<p>String february = someMonths.getString(1);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 606</p>
<p><span id="Chapter_108__XML_Parsing_using_t_1"
class="anchor"></span>Chapter 108: XML Parsing using the JAXP</p>
<p>APIs</p>
<p>Section 108.1: Parsing a document using the StAX API</p>
<p>Considering the following document :</p>
<p><strong>&lt;?xml</strong> version='1.0' encoding='UTF-8'
<strong>?&gt;</strong></p>
<p>&lt;library&gt;</p>
<p><strong>&lt;book</strong> id='1'<strong>&gt;</strong>Effective
Java<strong>&lt;/book&gt;</strong></p>
<p><strong>&lt;book</strong> id='2'<strong>&gt;</strong>Java Concurrency
In Practice<strong>&lt;/book&gt;</strong></p>
<p><strong>&lt;notABook</strong> id='3'<strong>&gt;</strong>This is not
a book element<strong>&lt;/notABook&gt;</strong></p>
<p>&lt;/library&gt;</p>
<p>One can use the following code to parse it and build a map of book
titles by book id.</p>
<p><strong>import</strong> javax.xml.stream.XMLInputFactory;</p>
<p><strong>import</strong> javax.xml.stream.XMLStreamConstants;</p>
<p><strong>import</strong> javax.xml.stream.XMLStreamReader;</p>
<p><strong>import</strong> java.io.StringReader;</p>
<p><strong>import</strong> java.util.HashMap;</p>
<p><strong>import</strong> java.util.Map;</p>
<p>public class <strong>StaxDemo {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>String xmlDocument = ""</p>
<p>+ ""</p>
<p>+ "Effective Java"</p>
<p>+ "Java Concurrency In Practice" + "This is not a book element "</p>
<p>+ "";</p>
<p>XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</p>
<p>// Various flavors are possible, e.g. from an InputStream, a Source,
...</p>
<p>XMLStreamReader xmlStreamReader =
xmlInputFactory.createXMLStreamReader(<strong>new</strong>
StringReader(xmlDocument));</p>
<p>Map bookTitlesById = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>// We go through each event using a loop</p>
<p><strong>while</strong> (xmlStreamReader.hasNext()) {</p>
<p><strong>switch</strong> (xmlStreamReader.getEventType()) {</p>
<p><strong>case</strong> XMLStreamConstants.START_ELEMENT:</p>
<p>System.out.println("Found start of element: " +
xmlStreamReader.getLocalName()); <em>// Check if we are at the start of
a &lt;book&gt; element</em> <strong>if</strong>
("book".equals(xmlStreamReader.getLocalName())) {</p>
<p><strong>int</strong> bookId =
Integer.parseInt(xmlStreamReader.getAttributeValue("", "id")); String
bookTitle = xmlStreamReader.getElementText();</p>
<p>bookTitlesById.put(bookId, bookTitle);</p>
<p>}</p>
<p>break<strong>;</strong></p>
<p>// A bunch of other things are possible : comments, processing
instructions,</p>
<p>Whitespace...</p>
<p>default<strong>:</strong></p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>xmlStreamReader.next();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 607</p>
<p><span id="_44" class="anchor"></span>}</p>
<p>System.out.println(bookTitlesById);</p>
<p>}</p>
<p>This outputs :</p>
<p>Found start of element: library</p>
<p>Found start of element: book</p>
<p>Found start of element: book</p>
<p>Found start of element: notABook</p>
<p>{1=Effective Java, 2=Java Concurrency In Practice}</p>
<p>In this sample, one must be carreful of a few things :</p>
<p>1. The use of xmlStreamReader.getAttributeValue works because we have
checked first that the parser is in</p>
<p>the START_ELEMENT state. In evey other states (except ATTRIBUTES),
the parser is mandated to throw</p>
<p>IllegalStateException, because attributes can only appear at the
beginning of elements.</p>
<p>2. same goes for xmlStreamReader.getTextContent(), it works because
we are at a START_ELEMENT and we</p>
<p>know in this document that the <strong>&lt;book&gt;</strong> element
has no non-text child nodes.</p>
<p>For more complex documents parsing (deeper, nested elements, ...), it
is a good practice to "delegate" the parser to</p>
<p>sub-methods or other objets, e.g. have a BookParser class or method,
and have it deal with every element from the START_ELEMENT to the
END_ELEMENT of the book XML tag.</p>
<p>One can also use a Stack object to keep around important datas up and
down the tree.</p>
<p>Section 108.2: Parsing and navigating a document using the</p>
<p>DOM API</p>
<p>Considering the following document :</p>
<p><strong>&lt;?xml</strong> version='1.0' encoding='UTF-8'
<strong>?&gt;</strong></p>
<p>&lt;library&gt;</p>
<p><strong>&lt;book</strong> id='1'<strong>&gt;</strong>Effective
Java<strong>&lt;/book&gt;</strong></p>
<p><strong>&lt;book</strong> id='2'<strong>&gt;</strong>Java Concurrency
In Practice<strong>&lt;/book&gt;</strong></p>
<p>&lt;/library&gt;</p>
<p>One can use the following code to build a DOM tree out of a String
:</p>
<p><strong>import</strong> org.w3c.dom.Document;</p>
<p><strong>import</strong> org.w3c.dom.Node;</p>
<p><strong>import</strong> org.w3c.dom.NodeList;</p>
<p><strong>import</strong> org.xml.sax.InputSource;</p>
<p><strong>import</strong> javax.xml.parsers.DocumentBuilder;</p>
<p><strong>import</strong> javax.xml.parsers.DocumentBuilderFactory;</p>
<p><strong>import</strong> java.io.StringReader;</p>
<p>public class <strong>DOMDemo {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>String xmlDocument = ""</p>
<p>+ ""</p>
<p>+ "Effective Java"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 608</p>
<p>+ "Java Concurrency In Practice" + "";</p>
<p>DocumentBuilderFactory documentBuilderFactory =
DocumentBuilderFactory.newInstance();</p>
<p>// This is useless here, because the XML does not have namespaces,
but this option is usefull to</p>
<p>know in cas</p>
<p>documentBuilderFactory.setNamespaceAware(<strong>true</strong>);</p>
<p>DocumentBuilder documentBuilder =
documentBuilderFactory.newDocumentBuilder();</p>
<p><em>// There are various options here, to read from an InputStream,
from a file, ...</em> Document document =
documentBuilder.parse(<strong>new</strong>
InputSource(<strong>new</strong> StringReader(xmlDocument)));</p>
<p>// Root of the document</p>
<p>System.out.println("Root of the XML Document: " +</p>
<p>document.getDocumentElement().getLocalName());</p>
<p>// Iterate the contents</p>
<p>NodeList firstLevelChildren =
document.getDocumentElement().getChildNodes();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt;
firstLevelChildren.getLength(); i++) { Node item =
firstLevelChildren.item(i);</p>
<p>System.out.println("First level child found, XML tag name is: " +
item.getLocalName()); System.out.println("<strong>\t</strong>id
attribute of this tag is : " +</p>
<p>item.getAttributes().getNamedItem("id").getTextContent());</p>
<p>}</p>
<p>// Another way would have been</p>
<p>NodeList allBooks =
document.getDocumentElement().getElementsByTagName("book"); }</p>
<p>}</p>
<p>The code yields the following :</p>
<p>Root of the XML Document: library</p>
<p>First level child found, XML tag name is: book</p>
<p>id attribute of <strong>this</strong> tag is : 1</p>
<p>First level child found, XML tag name is: book</p>
<p>id attribute of <strong>this</strong> tag is : 2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 609</p>
<p><span id="Chapter_109__XML_XPath_Evaluatio_1"
class="anchor"></span>Chapter 109: XML XPath Evaluation</p>
<p>Section 109.1: Parsing multiple XPath Expressions in a single</p>
<p>XML</p>
<p>Using the same example as <strong>Evaluating a NodeList in an XML
document</strong>, here is how you would make multiple</p>
<p>XPath calls efficiently:</p>
<p>Given the following XML document:</p>
<p>&lt;documentation&gt;</p>
<p>&lt;tags&gt;</p>
<p><strong>&lt;tag</strong> name="Java"<strong>&gt;</strong></p>
<p><strong>&lt;topic</strong> name="Regular
expressions"<strong>&gt;</strong></p>
<p>&lt;example&gt;<strong>Matching groups</strong>&lt;/example&gt;</p>
<p><strong>&lt;example&gt;</strong>Escaping
metacharacters<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p><strong>&lt;topic</strong> name="Arrays"<strong>&gt;</strong></p>
<p>&lt;example&gt;<strong>Looping over
arrays</strong>&lt;/example&gt;</p>
<p><strong>&lt;example&gt;</strong>Converting an array to a
list<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p>&lt;/tag&gt;</p>
<p><strong>&lt;tag</strong> name="Android"<strong>&gt;</strong></p>
<p><strong>&lt;topic</strong> name="Building Android
projects"<strong>&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Building an Android application using
Gradle<strong>&lt;/example&gt; &lt;example&gt;</strong>Building an
Android application using Maven<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p><strong>&lt;topic</strong> name="Layout
resources"<strong>&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Including layout
resources<strong>&lt;/example&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Supporting multiple device
screens<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p>&lt;/tag&gt;</p>
<p>&lt;/tags&gt;</p>
<p>&lt;/documentation&gt;</p>
<p>This is how you would use XPath to evaluate multiple expressions in
one document:</p>
<p>XPath xPath = XPathFactory.newInstance().newXPath(); <em>//Make new
XPath</em> DocumentBuilder builder =
DocumentBuilderFactory.newInstance(); Document doc =
builder.parse(<strong>new</strong> File("path/to/xml.xml"));
<em>//Specify XML file path</em></p>
<p>NodeList javaExampleNodes = (NodeList)</p>
<p>xPath.evaluate("/documentation/tags/tag[@name='Java']//example", doc,
XPathConstants.NODESET); <em>//Evaluate the XPath</em></p>
<p>xPath.reset(); <em>//Resets the xPath so it can be used again</em>
NodeList androidExampleNodes = (NodeList)</p>
<p>xPath.evaluate("/documentation/tags/tag[@name='Android']//example",
doc, XPathConstants.NODESET); <em>//Evaluate the XPath</em></p>
<p>...</p>
<p>Section 109.2: Parsing single XPath Expression multiple times</p>
<p>in an XML</p>
<p>In this case, you want to have the expression compiled before the
evaluations, so that each call to evaluate does</p>
<p>not compile the same expression. The simple syntax would be:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 610</p>
<p><span id="XPath_xPath___XPathFactory_newIn"
class="anchor"></span>XPath xPath =
XPathFactory.newInstance().newXPath(); <em>//Make new XPath</em>
XPathExpression exp =
xPath.compile("/documentation/tags/tag[@name='Java']//example");
DocumentBuilder builder = DocumentBuilderFactory.newInstance(); Document
doc = builder.parse(<strong>new</strong> File("path/to/xml.xml"));
<em>//Specify XML file path</em></p>
<p>NodeList javaExampleNodes = (NodeList) exp.evaluate(doc,
XPathConstants.NODESET); <em>//Evaluate the XPath from the
already-compiled expression</em></p>
<p>NodeList javaExampleNodes2 = (NodeList) exp.evaluate(doc,
XPathConstants.NODESET); <em>//Do it again</em></p>
<p>Overall, two calls to XPathExpression.evaluate() will be much more
efficient than two calls to XPath.evaluate().</p>
<p>Section 109.3: Evaluating a NodeList in an XML document</p>
<p>Given the following XML document:</p>
<p>&lt;documentation&gt;</p>
<p>&lt;tags&gt;</p>
<p><strong>&lt;tag</strong> name="Java"<strong>&gt;</strong></p>
<p><strong>&lt;topic</strong> name="Regular
expressions"<strong>&gt;</strong></p>
<p>&lt;example&gt;<strong>Matching groups</strong>&lt;/example&gt;</p>
<p><strong>&lt;example&gt;</strong>Escaping
metacharacters<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p><strong>&lt;topic</strong> name="Arrays"<strong>&gt;</strong></p>
<p>&lt;example&gt;<strong>Looping over
arrays</strong>&lt;/example&gt;</p>
<p><strong>&lt;example&gt;</strong>Converting an array to a
list<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p>&lt;/tag&gt;</p>
<p><strong>&lt;tag</strong> name="Android"<strong>&gt;</strong></p>
<p><strong>&lt;topic</strong> name="Building Android
projects"<strong>&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Building an Android application using
Gradle<strong>&lt;/example&gt; &lt;example&gt;</strong>Building an
Android application using Maven<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p><strong>&lt;topic</strong> name="Layout
resources"<strong>&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Including layout
resources<strong>&lt;/example&gt;</strong></p>
<p><strong>&lt;example&gt;</strong>Supporting multiple device
screens<strong>&lt;/example&gt;</strong></p>
<p>&lt;/topic&gt;</p>
<p>&lt;/tag&gt;</p>
<p>&lt;/tags&gt;</p>
<p>&lt;/documentation&gt;</p>
<p>The following retrieves all example nodes for the Java tag (Use this
method if only evaluating XPath in the XML once.</p>
<p>See other example for when multiple XPath calls are evaluated in the
same XML file.):</p>
<p>XPathFactory xPathFactory = XPathFactory.newInstance(); XPath xPath =
xPathFactory.newXPath(); <em>//Make new XPath</em> InputSource
inputSource = <strong>new</strong> InputSource("path/to/xml.xml");
<em>//Specify XML file path</em></p>
<p>NodeList javaExampleNodes = (NodeList)</p>
<p>xPath.evaluate("/documentation/tags/tag[@name='Java']//example",
inputSource, XPathConstants.NODESET); <em>//Evaluate the XPath</em></p>
<p>...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 611</p>
<p><span id="Chapter_110__XOM___XML_Object_Mo_1"
class="anchor"></span>Chapter 110: XOM - XML Object Model</p>
<p>Section 110.1: Reading a XML file</p>
<p>In order to load the XML data with <a href="http://www.xom.nu/">XOM
you will need to make a</a> Builder from which you can build it into a
Document .</p>
<p>Builder builder = <strong>new</strong> Builder();</p>
<p>Document doc = builder.build(file);</p>
<p>To get the root element, the highest parent in the xml file, you need
to use the getRootElement() on the Document instance.</p>
<p>Element root = doc.getRootElement();</p>
<p>Now the Element class has a lot of handy methods that make reading
xml really easy. Some of the most useful are</p>
<p>listed below:</p>
<p>getChildElements(String name) - returns an Elements instance that
acts as an array of elements getFirstChildElement(String name) - returns
the first child element with that tag.</p>
<p>getValue() - returns the value inside the element.</p>
<p>getAttributeValue(String name) - returns the value of an attribute
with the specified name.</p>
<p>When you call the getChildElements() you get a Elements instance.
From this you can loop through and call the get(<strong>int</strong>
index) method on it to retrieve all the elements inside.</p>
<p>Elements colors = root.getChildElements("color");</p>
<p><strong>for</strong> (<strong>int</strong> q = 0; q &lt;
colors.size(); q++){</p>
<p>Element color = colors.get(q);</p>
<p>}</p>
<p><strong>Example:</strong> Here is an example of reading an XML
File:</p>
<p>XML File:</p>
<p><img src="media/index-636_1.jpeg" style="width:6.5in;height:2.75in"
alt="index-636_1.jpg" /></p>
<p>Code for reading and printing it:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 612</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> nu.xom.Builder;</p>
<p><strong>import</strong> nu.xom.Document;</p>
<p><strong>import</strong> nu.xom.Element;</p>
<p><strong>import</strong> nu.xom.Elements;</p>
<p><strong>import</strong> nu.xom.ParsingException;</p>
<p>public class <strong>XMLReader {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> ParsingException, IOException{</p>
<p>File file = <strong>new</strong> File("insert path here");</p>
<p>// builder builds xml data</p>
<p>Builder builder = <strong>new</strong> Builder();</p>
<p>Document doc = builder.build(file);</p>
<p>// get the root element &lt;example&gt;</p>
<p>Element root = doc.getRootElement();</p>
<p>// gets all element with tag &lt;person&gt;</p>
<p>Elements people = root.getChildElements("person");</p>
<p><strong>for</strong> (<strong>int</strong> q = 0; q &lt;
people.size(); q++){</p>
<p>// get the current person element</p>
<p>Element person = people.get(q);</p>
<p><em>// get the name element and its children: first and last</em>
Element nameElement = person.getFirstChildElement("name"); Element
firstNameElement = nameElement.getFirstChildElement("first"); Element
lastNameElement = nameElement.getFirstChildElement("last");</p>
<p>// get the age element</p>
<p>Element ageElement = person.getFirstChildElement("age");</p>
<p>// get the favorite color element</p>
<p>Element favColorElement =
person.getFirstChildElement("fav_color");</p>
<p>String fName, lName, ageUnit, favColor;</p>
<p><strong>int</strong> age;</p>
<p>try <strong>{</strong></p>
<p>fName = firstNameElement.getValue();</p>
<p>lName = lastNameElement.getValue();</p>
<p>age = Integer.parseInt(ageElement.getValue());</p>
<p>ageUnit = ageElement.getAttributeValue("unit");</p>
<p>favColor = favColorElement.getValue();</p>
<p>System.out.println("Name: " + lName + ", " + fName);</p>
<p>System.out.println("Age: " + age + " (" + ageUnit + ")");
System.out.println("Favorite Color: " + favColor);</p>
<p>System.out.println("----------------");</p>
<p>} <strong>catch</strong> (NullPointerException ex){</p>
<p>ex.printStackTrace();</p>
<p>} <strong>catch</strong> (NumberFormatException ex){</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 613</p>
<p><span id="This_will_print_out_in_the_conso"
class="anchor"></span>This will print out in the console:</p>
<p>Name: Smith, Dan</p>
<p>Age: 23 (years)</p>
<p>Favorite Color: green</p>
<p>----------------</p>
<p>Name: Autry, Bob</p>
<p>Age: 3 (months)</p>
<p>Favorite Color: N/A</p>
<p>----------------</p>
<p>Section 110.2: Writing to a XML File</p>
<p><a href="http://www.xom.nu/">Writing to a XML File using XOM</a> is
very similar to reading it except in this case we are making the
instances instead</p>
<p>of retrieving them off the root.</p>
<p>To make a new Element use the constructor Element(String name). You
will want to make a root element so that</p>
<p>you can easily add it to a Document.</p>
<p>Element root = <strong>new</strong> Element("root");</p>
<p>The Element class has some handy methods for editing elements. They
are listed below:</p>
<p>appendChild(String name) - this will basically set the value of the
element to name. appendChild(Node node) - this will make node the
elements parent. (Elements are nodes so you can parse</p>
<p>elements).</p>
<p>addAttribute(Attribute attribute) - will add an attribute to the
element.</p>
<p>The Attribute class has a couple of different constructors. The
simplest one is Attribute(String name, String value).</p>
<p>Once you have all of your elements add to your root element you can
turn it into a Document. Document will take a Element as an argument in
it's constructor.</p>
<p>You can use a Serializer to write your XML to a file. You will need
to make a new output stream to parse in the constructor of
Serializer.</p>
<p>FileOutputStream fileOutputStream = <strong>new</strong>
FileOutputStream(file); Serializer serializer = <strong>new</strong>
Serializer(fileOutputStream, "UTF-8"); serializer.setIndent(4);</p>
<p>serializer.write(doc);</p>
<p>Example</p>
<p>Code:</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> java.io.FileOutputStream;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.UnsupportedEncodingException;</p>
<p><strong>import</strong> nu.xom.Attribute;</p>
<p><strong>import</strong> nu.xom.Builder;</p>
<p><strong>import</strong> nu.xom.Document;</p>
<p><strong>import</strong> nu.xom.Element;</p>
<p><strong>import</strong> nu.xom.Elements;</p>
<p><strong>import</strong> nu.xom.ParsingException;</p>
<p><strong>import</strong> nu.xom.Serializer;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 614</p>
<p>public class <strong>XMLWriter{</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> UnsupportedEncodingException,</p>
<p>IOException{</p>
<p>// root element &lt;example&gt;</p>
<p>Element root = <strong>new</strong> Element("example");</p>
<p>// make a array of people to store</p>
<p>Person[] people = {<strong>new</strong> Person("Smith", "Dan",
"years", "green", 23),</p>
<p><strong>new</strong> Person("Autry", "Bob", "months", "N/A", 3)};</p>
<p>// add all the people</p>
<p><strong>for</strong> (Person person : people){</p>
<p>// make the main person element &lt;person&gt;</p>
<p>Element personElement = <strong>new</strong> Element("person");</p>
<p>// make the name element and it's children: first and last
<em>Element nameElement = <strong>new</strong> Element("name");</em></p>
<p>Element firstNameElement = <strong>new</strong> Element("first");</p>
<p>Element lastNameElement = <strong>new</strong> Element("last");</p>
<p>// make age element</p>
<p>Element ageElement = <strong>new</strong> Element("age");</p>
<p>// make favorite color element</p>
<p>Element favColorElement = <strong>new</strong>
Element("fav_color");</p>
<p>// add value to names</p>
<p>firstNameElement.appendChild(person.getFirstName());</p>
<p>lastNameElement.appendChild(person.getLastName());</p>
<p>// add names to name</p>
<p>nameElement.appendChild(firstNameElement);</p>
<p>nameElement.appendChild(lastNameElement);</p>
<p>// add value to age</p>
<p>ageElement.appendChild(String.valueOf(person.getAge()));</p>
<p>// add unit attribute to age</p>
<p>ageElement.addAttribute(<strong>new</strong> Attribute("unit",
person.getAgeUnit()));</p>
<p>// add value to favColor</p>
<p>favColorElement.appendChild(person.getFavoriteColor());</p>
<p>// add all contents to person</p>
<p>personElement.appendChild(nameElement);</p>
<p>personElement.appendChild(ageElement);</p>
<p>personElement.appendChild(favColorElement);</p>
<p>// add person to root</p>
<p>root.appendChild(personElement);</p>
<p>}</p>
<p>// create doc off of root</p>
<p>Document doc = <strong>new</strong> Document(root);</p>
<p>// the file it will be stored in</p>
<p>File file = <strong>new</strong> File("out.xml");</p>
<p><strong>if</strong> (!file.exists()){</p>
<p>file.createNewFile();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 615</p>
<p>// get a file output stream ready</p>
<p>FileOutputStream fileOutputStream = <strong>new</strong>
FileOutputStream(file);</p>
<p>// use the serializer class to write it all</p>
<p>Serializer serializer = <strong>new</strong>
Serializer(fileOutputStream, "UTF-8");</p>
<p>serializer.setIndent(4);</p>
<p>serializer.write(doc);</p>
<p>}</p>
<p>private static class <strong>Person {</strong></p>
<p><strong>private</strong> String lName, fName, ageUnit, favColor;</p>
<p>private int <strong>age;</strong></p>
<p><strong>public</strong> Person(String lName, String fName, String
ageUnit, String favColor, <strong>int</strong> age){</p>
<p><strong>this</strong>.lName = lName;</p>
<p><strong>this</strong>.fName = fName;</p>
<p><strong>this</strong>.age = age;</p>
<p><strong>this</strong>.ageUnit = ageUnit;</p>
<p><strong>this</strong>.favColor = favColor;</p>
<p>}</p>
<p><strong>public</strong> String getLastName() {
<strong>return</strong> lName; }</p>
<p><strong>public</strong> String getFirstName() {
<strong>return</strong> fName; }</p>
<p><strong>public</strong> String getAgeUnit() { <strong>return</strong>
ageUnit; }</p>
<p><strong>public</strong> String getFavoriteColor() {
<strong>return</strong> favColor; }</p>
<p><strong>public int</strong> getAge() { <strong>return</strong> age;
}</p>
<p>}</p>
<p>}</p>
<p>This will be the contents of "out.xml":</p>
<p><img src="media/index-640_1.jpeg"
style="width:6.5in;height:2.76389in" alt="index-640_1.jpg" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 616</p>
<p><span id="Chapter_111__Polymorphism_1" class="anchor"></span>Chapter
111: Polymorphism</p>
<p>Polymorphism is one of main OOP(object oriented programming)
concepts. Polymorphism word was derived from</p>
<p>the greek words "poly" and "morphs". Poly means "many" and morphs
means "forms" (many forms).</p>
<p>There are two ways to perform polymorphism. <strong>Method
Overloading</strong> and <strong>Method Overriding</strong>.</p>
<p>Section 111.1: Method Overriding</p>
<p>Method overriding is the ability of subtypes to redefine (override)
the behavior of their supertypes.</p>
<p>In Java, this translates to subclasses overriding the methods defined
in the super class. In Java, all non-primitive</p>
<p>variables are actually references, which are akin to pointers to the
location of the actual object in memory. The</p>
<p>references only have one type, which is the type they were declared
with. However, they can point to an object of either their declared type
or any of its subtypes.</p>
<p>When a method is called on a reference, the corresponding
<strong>method of the actual object being pointed to is</strong></p>
<p>invoked<strong>.</strong></p>
<p><strong>class</strong> SuperType {</p>
<p><strong>public void</strong> sayHello(){</p>
<p>System.out.println("Hello from SuperType");</p>
<p>}</p>
<p>public void <strong>sayBye(){</strong></p>
<p>System.out.println("Bye from SuperType");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> SubType <strong>extends</strong> SuperType
{</p>
<p>// override the superclass method</p>
<p><strong>public void</strong> sayHello(){</p>
<p>System.out.println("Hello from SubType");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Test {</p>
<p><strong>public static void</strong> main(String... args){</p>
<p>SuperType superType = <strong>new</strong> SuperType();</p>
<p><em>superType.sayHello();</em> // -&gt; Hello from SuperType</p>
<p>// make the reference point to an object of the subclass</p>
<p>superType = <strong>new</strong> SubType();</p>
<p>// behaviour is governed by the object, not by the reference</p>
<p><em>superType.sayHello();</em> // -&gt; Hello from SubType</p>
<p>// non-overridden method is simply inherited</p>
<p><em>superType.sayBye();</em> // -&gt; Bye from SuperType</p>
<p>}</p>
<p>}</p>
<p>Rules to keep in mind</p>
<p>To override a method in the subclass, the overriding method (i.e. the
one in the subclass) <strong>MUST HAVE</strong>:</p>
<p>same name</p>
<p>same return type in case of primitives (a subclass is allowed for
classes, this is also known as covariant return</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 617</p>
<p><span id="types" class="anchor"></span>types).</p>
<p>same type and order of parameters</p>
<p>it may throw only those exceptions that are declared in the throws
clause of the superclass's method or</p>
<p>exceptions that are subclasses of the declared exceptions. It may
also choose NOT to throw any exception. The names of the parameter types
do not matter. For example, void methodX(int i) is same as void</p>
<p>methodX(int k)</p>
<p>We are unable to Override final or Static methods. Only thing that we
can do change only method body.</p>
<p>Section 111.2: Method Overloading</p>
<p><strong>Method overloading</strong>, also known as <strong>function
overloading</strong>, is the ability of a class to have multiple methods
with</p>
<p>the same name, granted that they differ in either number or type of
arguments.</p>
<p>Compiler checks <em><strong>method signature</strong></em> for method
overloading.</p>
<p>Method signature consists of three things -</p>
<p>1. Method name</p>
<p>2. Number of parameters</p>
<p>3. Types of parameters</p>
<p>If these three are same for any two methods in a class, then compiler
throws <strong>duplicate method error</strong>.</p>
<p>This type of polymorphism is called <em>static</em> or <em>compile
time</em> polymorphism because the appropriate method to be</p>
<p>called is decided by the compiler during the compile time based on
the argument list.</p>
<p><strong>class</strong> Polymorph {</p>
<p>public int <strong>add(</strong>int <strong>a,</strong> int
<strong>b){</strong></p>
<p><strong>return</strong> a + b;</p>
<p>}</p>
<p>public int <strong>add(</strong>int <strong>a,</strong> int
<strong>b,</strong> int <strong>c){</strong></p>
<p><strong>return</strong> a + b + c;</p>
<p>}</p>
<p>public float <strong>add(</strong>float <strong>a,</strong> float
<strong>b){</strong></p>
<p><strong>return</strong> a + b;</p>
<p>}</p>
<p><strong>public static void</strong> main(String... args){</p>
<p>Polymorph poly = <strong>new</strong> Polymorph();</p>
<p><strong>int</strong> a = 1, b = 2, c = 3;</p>
<p><strong>float</strong> d = 1.5, e = 2.5;</p>
<p>System.out.println(poly.add(a, b));</p>
<p>System.out.println(poly.add(a, b, c));</p>
<p>System.out.println(poly.add(d, e));</p>
<p>}</p>
<p>}</p>
<p>This will result in:</p>
<p>2</p>
<p>6</p>
<p>4.000000</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 618</p>
<p><span id="Overloaded_methods_may_be_static"
class="anchor"></span>Overloaded methods may be static or non-static.
This also does not effect method overloading.</p>
<p>public class <strong>Polymorph {</strong></p>
<p>private static void <strong>methodOverloaded()</strong></p>
<p>{</p>
<p>//No argument, private static method</p>
<p>}</p>
<p><strong>private int</strong> methodOverloaded(<strong>int</strong>
i)</p>
<p>{</p>
<p>//One argument private non-static method</p>
<p>return <strong>i;</strong></p>
<p>}</p>
<p><strong>static int</strong> methodOverloaded(<strong>double</strong>
d)</p>
<p>{</p>
<p>//static Method</p>
<p>return <strong>0;</strong></p>
<p>}</p>
<p><strong>public void</strong> methodOverloaded(<strong>int</strong> i,
<strong>double</strong> d)</p>
<p>{</p>
<p>//Public non-static Method</p>
<p>}</p>
<p>}</p>
<p>Also if you change the return type of method, we are unable to get it
as method overloading.</p>
<p>public class <strong>Polymorph {</strong></p>
<p><strong>void</strong> methodOverloaded(){</p>
<p>//No argument and No return type</p>
<p>}</p>
<p><strong>int</strong> methodOverloaded(){</p>
<p>//No argument and int return type</p>
<p>return <strong>0;</strong></p>
<p>}</p>
<p>Section 111.3: Polymorphism and dierent types of overriding</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html">From
java tutorial</a></p>
<p>The dictionary definition of polymorphism refers to a principle in
biology in which an organism or species can have many different forms or
stages. This principle can also be applied to object-oriented</p>
<p>programming and languages like the Java language.
<em><strong>Subclasses of a class can define their own
unique</strong></em></p>
<p>behaviors and yet share some of the same functionality of the parent
class.</p>
<p>Have a look at this example to understand different types of
overriding.</p>
<p>1. Base class provides no implementation and sub-class has to
override complete method - (abstract)</p>
<p>2. Base class provides default implementation and sub-class can
change the behaviour</p>
<p>3. Sub-class adds extension to base class implementation by calling
<strong>super</strong>.methodName() as first statement 4. Base class
defines structure of the algorithm (Template method) and sub-class will
override a part of</p>
<p>algorithm</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 619</p>
<p>code snippet:</p>
<p><strong>import</strong> java.util.HashMap;</p>
<p>abstract class <strong>Game</strong> implements
<strong>Runnable{</strong></p>
<p>protected boolean <strong>runGame =</strong>
true<strong>;</strong></p>
<p><strong>protected</strong> Player player1 =
<strong>null</strong>;</p>
<p><strong>protected</strong> Player player2 =
<strong>null</strong>;</p>
<p><strong>protected</strong> Player currentPlayer =
<strong>null</strong>;</p>
<p><strong>public</strong> Game(){</p>
<p>player1 = <strong>new</strong> Player("Player 1");</p>
<p>player2 = <strong>new</strong> Player("Player 2");</p>
<p>currentPlayer = player1;</p>
<p>initializeGame();</p>
<p>}</p>
<p>/* Type 1: Let subclass define own implementation. Base class defines
abstract method to force sub-classes to define implementation</p>
<p>*/</p>
<p>protected abstract void <strong>initializeGame();</strong></p>
<p>/* Type 2: Sub-class can change the behaviour. If not, base class
behaviour is applicable */ <em><strong>protected void</strong>
logTimeBetweenMoves(Player player){</em></p>
<p>System.out.println("Base class: Move Duration: player.PlayerActTime
-</p>
<p>player.MoveShownTime");</p>
<p>}</p>
<p>/* Type 3: Base class provides implementation. Sub-class can enhance
base class implementation by</p>
<p>calling</p>
<p>super.methodName() in first line of the child class method and
specific implementation later */</p>
<p><strong>protected void</strong> logGameStatistics(){</p>
<p>System.out.println("Base class: logGameStatistics:");</p>
<p>}</p>
<p>/* Type 4: Template method: Structure of base class can't be changed
but sub-class can some part</p>
<p>of behaviour */</p>
<p><strong>protected void</strong> runGame() <strong>throws</strong>
Exception{</p>
<p>System.out.println("Base class: Defining the flow for Game:");
<strong>while</strong> (runGame) {</p>
<p>/*</p>
<p>1. Set current player</p>
<p>2. Get Player Move</p>
<p>*/</p>
<p>validatePlayerMove(currentPlayer);</p>
<p>logTimeBetweenMoves(currentPlayer);</p>
<p>Thread.sleep(500);</p>
<p>setNextPlayer();</p>
<p>}</p>
<p>logGameStatistics();</p>
<p>}</p>
<p>/* sub-part of the template method, which define child class
behaviour */ <em><strong>protected abstract void</strong>
validatePlayerMove(Player p);</em></p>
<p>protected void <strong>setRunGame(</strong>boolean
<strong>status){</strong></p>
<p><strong>this</strong>.runGame = status;</p>
<p>}</p>
<p><strong>public void</strong> setCurrentPlayer(Player p){</p>
<p><strong>this</strong>.currentPlayer = p;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 620</p>
<p><strong>public void</strong> setNextPlayer(){</p>
<p><strong>if</strong> (currentPlayer == player1) {</p>
<p>currentPlayer = player2;</p>
<p><strong>}</strong>else<strong>{</strong></p>
<p>currentPlayer = player1;</p>
<p>}</p>
<p>}</p>
<p>public void <strong>run(){</strong></p>
<p>try<strong>{</strong></p>
<p>runGame();</p>
<p>}<strong>catch</strong>(Exception err){</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Player{</p>
<p>String name;</p>
<p>Player(String name){</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p><strong>public</strong> String getName(){</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p>}</p>
<p>/* Concrete Game implementation */</p>
<p><strong>class</strong> Chess <strong>extends</strong> Game{</p>
<p><strong>public</strong> Chess(){</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p><strong>public void</strong> initializeGame(){</p>
<p>System.out.println("Child class: Initialized Chess game");</p>
<p>}</p>
<p><strong>protected void</strong> validatePlayerMove(Player p){</p>
<p>System.out.println("Child class: Validate Chess move:" +
p.getName());</p>
<p>}</p>
<p><strong>protected void</strong> logGameStatistics(){</p>
<p><strong>super</strong>.logGameStatistics();</p>
<p>System.out.println("Child class: Add Chess specific
logGameStatistics:");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> TicTacToe <strong>extends</strong> Game{</p>
<p><strong>public</strong> TicTacToe(){</p>
<p>super<strong>();</strong></p>
<p>}</p>
<p><strong>public void</strong> initializeGame(){</p>
<p>System.out.println("Child class: Initialized TicTacToe game");</p>
<p>}</p>
<p><strong>protected void</strong> validatePlayerMove(Player p){</p>
<p>System.out.println("Child class: Validate TicTacToe move:" +
p.getName());</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> Polymorphism{</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>try<strong>{</strong></p>
<p>Game game = <strong>new</strong> Chess();</p>
<p>Thread t1 = <strong>new</strong> Thread(game);</p>
<p>t1.start();</p>
<p>Thread.sleep(1000);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 621</p>
<p><span id="game_setRunGame_false"
class="anchor"></span>game.setRunGame(<strong>false</strong>);</p>
<p>Thread.sleep(1000);</p>
<p>game = <strong>new</strong> TicTacToe();</p>
<p>Thread t2 = <strong>new</strong> Thread(game);</p>
<p>t2.start();</p>
<p>Thread.sleep(1000);</p>
<p>game.setRunGame(<strong>false</strong>);</p>
<p>}<strong>catch</strong>(Exception err){</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Child class: Initialized Chess game</p>
<p>Base class: Defining the flow for Game:</p>
<p>Child class: Validate Chess move:Player 1</p>
<p>Base class: Move Duration: player.PlayerActTime -
player.MoveShownTime Child class: Validate Chess move:Player 2</p>
<p>Base class: Move Duration: player.PlayerActTime -
player.MoveShownTime Base class: logGameStatistics:</p>
<p>Child class: Add Chess specific logGameStatistics:</p>
<p>Child class: Initialized TicTacToe game</p>
<p>Base class: Defining the flow for Game:</p>
<p>Child class: Validate TicTacToe move:Player 1</p>
<p>Base class: Move Duration: player.PlayerActTime -
player.MoveShownTime Child class: Validate TicTacToe move:Player 2</p>
<p>Base class: Move Duration: player.PlayerActTime -
player.MoveShownTime Base class: logGameStatistics:</p>
<p>Section 111.4: Virtual functions</p>
<p>Virtual Methods are methods in Java that are non-static and without
the keyword Final in front. All methods by</p>
<p>default are virtual in Java. Virtual Methods play important roles in
Polymorphism because children classes in Java can override their parent
classes' methods if the function being overridden is non-static and has
the same method</p>
<p>signature.</p>
<p>There are, however, some methods that are not virtual. For example,
if the method is declared private or with the</p>
<p>keyword final, then the method is not Virtual.</p>
<p>Consider the following modified example of inheritance with Virtual
Methods from this StackOverflow post <a
href="http://stackoverflow.com/questions/460446/how-do-virtual-functions-work-in-c-sharp-and-java)">How
do</a></p>
<p><a
href="http://stackoverflow.com/questions/460446/how-do-virtual-functions-work-in-c-sharp-and-java)">virtual
functions work in C# and Java?</a> :</p>
<p>public class <strong>A{</strong></p>
<p>public void <strong>hello(){</strong></p>
<p>System.out.println("Hello");</p>
<p>}</p>
<p>public void <strong>boo(){</strong></p>
<p>System.out.println("Say boo");</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 622</p>
<p><span id="public_class_B_extends_A" class="anchor"></span>public
class <strong>B</strong> extends <strong>A{</strong></p>
<p>public void <strong>hello(){</strong></p>
<p>System.out.println("No");</p>
<p>}</p>
<p>public void <strong>boo(){</strong></p>
<p>System.out.println("Say haha");</p>
<p>}</p>
<p>}</p>
<p>If we invoke class B and call hello() and boo(), we would get "No"
and "Say haha" as the resulting output because B</p>
<p>overrides the same methods from A. Even though the example above is
almost exactly the same as method overriding, it is important to
understand that the methods in class A are all, by default, Virtual.</p>
<p>Additionally, we can implement Virtual methods using the abstract
keyword. Methods declared with the keyword</p>
<p>"abstract" does not have a method definition, meaning the method's
body is not yet implemented. Consider the</p>
<p>example from above again, except the boo() method is declared
abstract:</p>
<p>public class <strong>A{</strong></p>
<p>public void <strong>hello(){</strong></p>
<p>System.out.println("Hello");</p>
<p>}</p>
<p>abstract void <strong>boo();</strong></p>
<p>}</p>
<p>public class <strong>B</strong> extends <strong>A{</strong></p>
<p>public void <strong>hello(){</strong></p>
<p>System.out.println("No");</p>
<p>}</p>
<p>public void <strong>boo(){</strong></p>
<p>System.out.println("Say haha");</p>
<p>}</p>
<p>}</p>
<p>If we invoke boo() from B, the output will still be "Say haha" since
B inherits the abstract method boo() and makes</p>
<p>boo () output "Say haha".</p>
<p>Sources used and further readings:</p>
<p><a
href="http://stackoverflow.com/questions/460446/how-do-virtual-functions-work-in-c-sharp-and-java">How
do virtual functions work in C# and Java?</a></p>
<p>Check out this great answer that gives a much more complete
information about Virtual functions:</p>
<p><a
href="http://stackoverflow.com/questions/4547453/can-you-write-virtual-functions-methods-in-java">Can
you write virtual functions / methods in Java?</a></p>
<p>Section 111.5: Adding behaviour by adding classes without</p>
<p>touching existing code</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> static java.lang.System.out;</p>
<p><strong>public class</strong> PolymorphismDemo {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 623</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>List machines = <strong>new</strong> ArrayList();</p>
<p>machines.add(<strong>new</strong> FlyingMachine());</p>
<p>machines.add(<strong>new</strong> Jet());</p>
<p>machines.add(<strong>new</strong> Helicopter());</p>
<p>machines.add(<strong>new</strong> Jet());</p>
<p><strong>new</strong> MakeThingsFly().letTheMachinesFly(machines);</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> MakeThingsFly {</p>
<p><strong>public void</strong> letTheMachinesFly(List flyingMachines)
{</p>
<p><strong>for</strong> (FlyingMachine flyingMachine : flyingMachines)
{</p>
<p>flyingMachine.fly();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> FlyingMachine {</p>
<p>public void <strong>fly() {</strong></p>
<p>out.println("No implementation");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Jet <strong>extends</strong> FlyingMachine
{</p>
<p>@Override</p>
<p>public void <strong>fly() {</strong></p>
<p>out.println("Start, taxi, fly");</p>
<p>}</p>
<p><strong>public void</strong> bombardment() {</p>
<p>out.println("Fire missile");</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> Helicopter <strong>extends</strong>
FlyingMachine {</p>
<p>@Override</p>
<p>public void <strong>fly() {</strong></p>
<p>out.println("Start vertically, hover, fly");</p>
<p>}</p>
<p>}</p>
<p>Explanation</p>
<p>a) The MakeThingsFly class can work with everything that is of type
FlyingMachine.</p>
<p>b) The method letTheMachinesFly also works without any change (!)
when you add a new class, for example</p>
<p>PropellerPlane:</p>
<p><strong>public void</strong> letTheMachinesFly(List flyingMachines)
{</p>
<p><strong>for</strong> (FlyingMachine flyingMachine : flyingMachines)
{</p>
<p>flyingMachine.fly();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a
href="https://en.wikipedia.org/wiki/Open/closed_principle#Polymorphic_open.2Fclosed_principle">That's
the power of polymorphism. You can implement the
open-closed-principle</a> with it.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 624</p>
<p><span id="Chapter_112__Encapsulation_1" class="anchor"></span>Chapter
112: Encapsulation</p>
<p>Imagine you had a class with some pretty important variables and they
were set (by other programmers from their</p>
<p>code) to unacceptable values.Their code brought errors in your code.
As a solution, In OOP, you allow the state of an object (stored in its
variables) to be modified only through methods. Hiding the state of an
object and providing</p>
<p>all interaction through an objects methods is known as Data
Encapsulation.</p>
<p>Section 112.1: Encapsulation to maintain invariants</p>
<p>There are two parts of a class: the interface and the
implementation.</p>
<p>The interface is the exposed functionality of the class. Its public
methods and variables are part of the interface.</p>
<p>The implementation is the internal workings of a class. Other classes
shouldn't need to know about the implementation of a class.</p>
<p>Encapsulation refers to the practice of hiding the implementation of
a class from any users of that class. This allows the class to make
assumptions about its internal state.</p>
<p>For example, take this class representing an Angle:</p>
<p>public class <strong>Angle {</strong></p>
<p><strong>private double</strong> angleInDegrees;</p>
<p><strong>private double</strong> angleInRadians;</p>
<p><strong>public static</strong> Angle
angleFromDegrees(<strong>double</strong> degrees){ Angle a =
<strong>new</strong> Angle();</p>
<p>a.angleInDegrees = degrees;</p>
<p>a.angleInRadians = Math.PI*degrees/180;</p>
<p>return <strong>a;</strong></p>
<p>}</p>
<p><strong>public static</strong> Angle
angleFromRadians(<strong>double</strong> radians){ Angle a =
<strong>new</strong> Angle();</p>
<p>a.angleInRadians = radians;</p>
<p>a.angleInDegrees = radians*180/Math.PI;</p>
<p>return <strong>a;</strong></p>
<p>}</p>
<p><strong>public double</strong> getDegrees(){</p>
<p><strong>return</strong> angleInDegrees;</p>
<p>}</p>
<p><strong>public double</strong> getRadians(){</p>
<p><strong>return</strong> angleInRadians;</p>
<p>}</p>
<p><strong>public void</strong> setDegrees(<strong>double</strong>
degrees){</p>
<p><strong>this</strong>.angleInDegrees = degrees;</p>
<p><strong>this</strong>.angleInRadians = Math.PI*degrees/180;</p>
<p>}</p>
<p><strong>public void</strong> setRadians(<strong>double</strong>
radians){</p>
<p><strong>this</strong>.angleInRadians = radians;</p>
<p><strong>this</strong>.angleInDegrees = radians*180/Math.PI;</p>
<p>}</p>
<p><strong>private</strong> Angle(){}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 625</p>
<p><span id="_45" class="anchor"></span>}</p>
<p><strong>This class relies on a basic assumption (or
<em>invariant</em>):</strong> angleInDegrees and angleInRadians are
always in sync<strong>. If</strong></p>
<p>the class members were public, there would be no guarantees that the
two representations of angles are</p>
<p>correlated.</p>
<p>Section 112.2: Encapsulation to reduce coupling</p>
<p>Encapsulation allows you to make internal changes to a class without
affecting any code that calls the class. This</p>
<p>reduces <em>coupling</em>, or how much any given class relies on the
implementation of another class.</p>
<p>For example, let's change the implementation of the Angle class from
the previous example:</p>
<p>public class <strong>Angle {</strong></p>
<p><strong>private double</strong> angleInDegrees;</p>
<p><strong>public static</strong> Angle
angleFromDegrees(<strong>double</strong> degrees){ Angle a =
<strong>new</strong> Angle();</p>
<p>a.angleInDegrees = degrees;</p>
<p>return <strong>a;</strong></p>
<p>}</p>
<p><strong>public static</strong> Angle
angleFromRadians(<strong>double</strong> radians){ Angle a =
<strong>new</strong> Angle();</p>
<p>a.angleInDegrees = radians*180/Math.PI;</p>
<p>return <strong>a;</strong></p>
<p>}</p>
<p><strong>public double</strong> getDegrees(){</p>
<p><strong>return</strong> angleInDegrees;</p>
<p>}</p>
<p><strong>public double</strong> getRadians(){</p>
<p><strong>return</strong> angleInDegrees*Math.PI / 180;</p>
<p>}</p>
<p><strong>public void</strong> setDegrees(<strong>double</strong>
degrees){</p>
<p><strong>this</strong>.angleInDegrees = degrees;</p>
<p>}</p>
<p><strong>public void</strong> setRadians(<strong>double</strong>
radians){</p>
<p><strong>this</strong>.angleInDegrees = radians*180/Math.PI;</p>
<p>}</p>
<p><strong>private</strong> Angle(){}</p>
<p>}</p>
<p>The implementation of this class has changed so that it only stores
one representation of the angle and calculates</p>
<p>the other angle when needed.</p>
<p>However, <strong>the implementation changed, but the interface
didn't</strong>. If a calling class relied on accessing the</p>
<p>angleInRadians method, it would need to be changed to use the new
version of Angle. Calling classes shouldn't care</p>
<p>about the internal representation of a class.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 626</p>
<p><span id="Chapter_113__Java_Agents_1" class="anchor"></span>Chapter
113: Java Agents</p>
<p>Section 113.1: Modifying classes with agents</p>
<p>Firstly, make sure that the agent being used has the following
attributes in the Manifest.mf:</p>
<p>Can-Redefine-Classes: <strong>true</strong></p>
<p>Can-Retransform-Classes: <strong>true</strong></p>
<p>Starting a java agent will let the agent access the class
Instrumentation. With Instrumentation you can call</p>
<p><em>addTransformer(ClassFileTransformer transformer)</em>.
ClassFileTransformers will let you rewrite the bytes of classes. The
class has only a single method which supplies the ClassLoader that loads
the class, the class's name, a</p>
<p>java.lang.Class instance of it, it's ProtectionDomain, and lastly the
bytes of the class itself.</p>
<p>It looks like this:</p>
<p><strong>byte</strong>[] transform(ClassLoader loader, String
className, Class classBeingRedefined,</p>
<p>ProtectionDomain protectionDomain, <strong>byte</strong>[]
classfileBuffer)</p>
<p>Modifying a class purely from bytes can take ages. To remedy this
there are libraries that can be used to convert</p>
<p>the class bytes into something more usable.</p>
<p>In this example I'll be using ASM, but other alternatives like
Javassist and BCEL have similar features.</p>
<p>ClassNode getNode(<strong>byte</strong>[] bytes) {</p>
<p>// Create a ClassReader that will parse the byte array into a
ClassNode</p>
<p>ClassReader cr = <strong>new</strong> ClassReader(bytes);</p>
<p>ClassNode cn = <strong>new</strong> ClassNode();</p>
<p>try <strong>{</strong></p>
<p>// This populates the ClassNode</p>
<p>cr.accept(cn, ClassReader.EXPAND_FRAMES);</p>
<p>cr = <strong>null</strong>;</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>return <strong>cn;</strong></p>
<p>}</p>
<p>From here changes can be made to the ClassNode object. This makes
changing field/method access incredibly easy. Plus with ASM's Tree API
modifying the bytecode of methods is a breeze.</p>
<p>Once the edits are finished you can convert the ClassNode back into
bytes with the following method and return them in the
<em>transform</em> method:</p>
<p><strong>public static byte</strong>[] getNodeBytes(ClassNode cn,
<strong>boolean</strong> useMaxs) {</p>
<p>ClassWriter cw = <strong>new</strong> ClassWriter(useMaxs ?
ClassWriter.COMPUTE_MAXS : ClassWriter.COMPUTE_FRAMES);</p>
<p>cn.accept(cw);</p>
<p><strong>byte</strong>[] b = cw.toByteArray();</p>
<p>return <strong>b;</strong></p>
<p>}</p>
<p>Section 113.2: Adding an agent at runtime</p>
<p>Agents can be added to a JVM at runtime. To load an agent you will
need to use the Attach API's</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 627</p>
<p><span id="VirtualMachine_attatch_String_id"
class="anchor"></span><em>VirtualMachine.attatch(String id)</em>. You
can then load a compiled agent jar with the following method:</p>
<p><strong>public static void</strong> loadAgent(String agentPath) {</p>
<p>String vmName = ManagementFactory.getRuntimeMXBean().getName();
<strong>int</strong> index = vmName.indexOf('@');</p>
<p>String pid = vmName.substring(0, index);</p>
<p>try <strong>{</strong></p>
<p>File agentFile = <strong>new</strong> File(agentPath);</p>
<p>VirtualMachine vm = VirtualMachine.attach(pid);</p>
<p>vm.loadAgent(agentFile.getAbsolutePath(), "");</p>
<p>VirtualMachine.attach(vm.id());</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p><strong>throw new</strong> RuntimeException(e);</p>
<p>}</p>
<p>}</p>
<p>This will not call <em>premain((String agentArgs, Instrumentation
inst)</em> in the loaded agent, but instead will call</p>
<p>agentmain(String agentArgs, Instrumentation inst)<em>. This
requires</em> Agent-Class <em>to be set in the agent
Manifest.mf.</em></p>
<p>Section 113.3: Setting up a basic agent</p>
<p><em>The Premain class will contain the method</em> "premain(String
agentArgs Instrumentation inst)"</p>
<p>Here is an example:</p>
<p><strong>import</strong> java.lang.instrument.Instrumentation;</p>
<p><strong>public class</strong> PremainExample {</p>
<p><strong>public static void</strong> premain(String agentArgs,
Instrumentation inst) {</p>
<p>System.out.println(agentArgs);</p>
<p>}</p>
<p>}</p>
<p>When compiled into a jar file open the Manifest and ensure that it
has the Premain-Class attribute.</p>
<p>Here is an example:</p>
<p>Premain-<strong>Class</strong>: PremainExample</p>
<p>To use the agent with another java program "myProgram" you must
define the agent in the JVM arguments:</p>
<p>java -javaagent:PremainAgent.jar-jar myProgram.jar</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 628</p>
<p><span id="Chapter_114__Varargs__Variable_A_1"
class="anchor"></span>Chapter 114: Varargs (Variable Argument)</p>
<p>Section 114.1: Working with Varargs parameters</p>
<p>Using varargs as a parameter for a method definition, it is possible
to pass either an array or a sequence of arguments. If a sequence of
arguments are passed, they are converted into an array
automatically.</p>
<p>This example shows both an array and a sequence of arguments being
passed into the printVarArgArray() method, and how they are treated
identically in the code inside the method:</p>
<p>public class <strong>VarArgs {</strong></p>
<p>// this method will print the entire contents of the parameter passed
in</p>
<p><strong>void</strong> printVarArgArray(<strong>int</strong>... x)
{</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; x.length;
i++) {</p>
<p>System.out.print(x[i] + ",");</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>VarArgs obj = <strong>new</strong> VarArgs();</p>
<p>//Using an array:</p>
<p><strong>int</strong>[] testArray = <strong>new int</strong>[]{10,
20};</p>
<p>obj.printVarArgArray(testArray);</p>
<p>System.out.println(" ");</p>
<p>//Using a sequence of arguments</p>
<p>obj.printVarArgArray(5, 6, 5, 8, 6, 31);</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>10,20,</p>
<p>5,6,5,8,6,31</p>
<p>If you define the method like this, it will give compile-time
errors.</p>
<p><em><strong>void</strong> method(String... a, <strong>int</strong>...
b , <strong>int</strong> c){}</em> //Compile time error (multiple
varargs )</p>
<p><em><strong>void</strong> method(<strong>int</strong>... a, String
b){}</em> //Compile time error (varargs must be the last argument</p>
<p>Section 114.2: Specifying a varargs parameter</p>
<p><strong>void</strong> doSomething(String... strings) {</p>
<p><strong>for</strong> (String s : strings) {</p>
<p>System.out.println(s);</p>
<p>}</p>
<p>}</p>
<p>The three periods after the final parameter's type indicate that the
final argument may be passed as an array or as a sequence of arguments.
Varargs can be used only in the final argument position.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 629</p>
<p><span id="Chapter_115__Logging__java_util_1"
class="anchor"></span>Chapter 115: Logging (java.util.logging)</p>
<p>Section 115.1: Logging complex messages (eciently)</p>
<p>Let's look at a sample of logging which you can see in many
programs:</p>
<p><strong>public class</strong> LoggingComplex {</p>
<p>private static final <strong>Logger logger =</strong></p>
<p>Logger.getLogger(LoggingComplex.<strong>class</strong>.getName());</p>
<p><strong>private int</strong> total = 50, orders = 20;</p>
<p><strong>private</strong> String username = "Bob";</p>
<p><strong>public void</strong> takeOrder() {</p>
<p>// (...) making some stuff</p>
<p>logger.fine(String.format("User %s ordered %d things (%d in
total)",</p>
<p>username, orders, total));</p>
<p>// (...) some other stuff</p>
<p>}</p>
<p>// some other methods and calculations</p>
<p>}</p>
<p>The above example looks perfectly fine, but many programmers forgets
that Java VM is stack machine. This means</p>
<p>that all method's parameters are calculated <strong>before</strong>
executing the method.</p>
<p>This fact is crucial for logging in Java, especially for logging
something in low levels like FINE, FINER, FINEST which are disabled by
default. Let's look at Java bytecode for the takeOrder() method.</p>
<p>The result for javap -c LoggingComplex.<strong>class</strong> is
something like this:</p>
<p><strong>public void</strong> takeOrder();</p>
<p>Code:</p>
<p><em>0: getstatic #27</em> // Field logger:Ljava/util/logging/Logger;
<em>3: ldc #45</em> // String User %s ordered %d things (%d in total)
<em>5: iconst_3</em></p>
<p><em>6: anewarray #3</em> // class java/lang/Object</p>
<p>9: dup</p>
<p>10: iconst_0</p>
<p>11: aload_0</p>
<p><em>12: getfield #40</em> // Field username:Ljava/lang/String;
<em>15: aastore</em></p>
<p>16: dup</p>
<p>17: iconst_1</p>
<p>18: aload_0</p>
<p>19: getfield #36 <em>// Field orders:I</em></p>
<p><em>22: invokestatic #47</em> // Method
java/lang/Integer.valueOf:(I)Ljava/lang/Integer; <em>25:
aastore</em></p>
<p>26: dup</p>
<p>27: iconst_2</p>
<p>28: aload_0</p>
<p>29: getfield #34 <em>// Field total:I</em></p>
<p><em>32: invokestatic #47</em> // Method
java/lang/Integer.valueOf:(I)Ljava/lang/Integer; <em>35:
aastore</em></p>
<p>36: invokestatic #53 <em>// Method</em></p>
<p>java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</p>
<p><em>39: invokevirtual #59</em> // Method
java/util/logging/Logger.fine:(Ljava/lang/String;)V</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 630</p>
<p><span id="42__return" class="anchor"></span><strong>42:</strong>
return</p>
<p>Line 39 runs the actual logging. All of the previous work (loading
variables, creating new objects, concatenating Strings in format method)
can be for nothing if logging level is set higher then FINE (and by
default it is). Such</p>
<p>logging can be very inefficient, consuming unnecessary memory and
processor resources.</p>
<p>That's why you should ask if the level you want to use is
enabled.</p>
<p>The right way should be:</p>
<p><strong>public void</strong> takeOrder() {</p>
<p>// making some stuff</p>
<p><strong>if</strong> (logger.isLoggable(Level.FINE)) {</p>
<p>// no action taken when there's no need for it</p>
<p>logger.fine(String.format("User %s ordered %d things (%d in
total)",</p>
<p>username, orders, total));</p>
<p>}</p>
<p>// some other stuff</p>
<p>}</p>
<p>Since Java 8:</p>
<p>The Logger class has additional methods that take a Supplier as
parameter, which can simply be provided</p>
<p>by a lambda:</p>
<p><strong>public void</strong> takeOrder() {</p>
<p>// making some stuff</p>
<p>logger.fine(()-&gt; String.format("User %s ordered %d things (%d in
total)",</p>
<p>username, orders, total));</p>
<p>// some other stuff</p>
<p>}</p>
<p>The Suppliers get()method - in this case the lambda - is only called
when the corresponding level is enabled and so</p>
<p>the ifconstruction is not needed anymore.</p>
<p>Section 115.2: Using the default logger</p>
<p>This example shows how to use the default logging api.</p>
<p><strong>import</strong> java.util.logging.Level;</p>
<p><strong>import</strong> java.util.logging.Logger;</p>
<p>public class <strong>MyClass {</strong></p>
<p>// retrieve the logger for the current class</p>
<p><strong>private static final</strong> Logger LOG =
Logger.getLogger(MyClass.<strong>class</strong>.getName());</p>
<p>public void <strong>foo() {</strong></p>
<p>LOG.info("A log message");</p>
<p>LOG.log(Level.INFO, "Another log message");</p>
<p>LOG.fine("A fine message");</p>
<p>// logging an exception</p>
<p>try <strong>{</strong></p>
<p>// code might throw an exception</p>
<p>} <strong>catch</strong> (SomeException ex) {</p>
<p>// log a warning printing "Something went wrong"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 631</p>
<p><span id="___together_with_the_exception_m" class="anchor"></span>//
together with the exception message and stacktrace</p>
<p>LOG.log(Level.WARNING, "Something went wrong", ex);</p>
<p>}</p>
<p>String s = "Hello World!";</p>
<p>// logging an object</p>
<p>LOG.log(Level.FINER, "String s: {0}", s);</p>
<p>// logging several objects</p>
<p>LOG.log(Level.FINEST, "String s: {0} has length {1}",
<strong>new</strong> Object[]{s, s.length()});</p>
<p>}</p>
<p>}</p>
<p>Section 115.3: Logging levels</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/Level.html">Java
Logging Api has 7 levels. The levels in descending order are:</a></p>
<p>SEVERE (highest value)</p>
<p>WARNING</p>
<p>INFO</p>
<p>CONFIG</p>
<p>FINE</p>
<p>FINER</p>
<p>FINEST (lowest value)</p>
<p>The default level is INFO (but this depends on the system and used a
virtual machine).</p>
<p><strong>Note</strong>: There are also levels OFF (can be used to turn
logging off) and ALL (the opposite of OFF).</p>
<p>Code example for this:</p>
<p><strong>import</strong> java.util.logging.Logger;</p>
<p>public class <strong>Levels {</strong></p>
<p><strong>private static final</strong> Logger logger =
Logger.getLogger(Levels.<strong>class</strong>.getName());</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>logger.severe("Message logged by SEVERE");</p>
<p>logger.warning("Message logged by WARNING");</p>
<p>logger.info("Message logged by INFO");</p>
<p>logger.config("Message logged by CONFIG");</p>
<p>logger.fine("Message logged by FINE");</p>
<p>logger.finer("Message logged by FINER");</p>
<p>logger.finest("Message logged by FINEST");</p>
<p>// All of above methods are really just shortcut for // public void
log(Level level, String msg):</p>
<p>logger.log(Level.FINEST, "Message logged by FINEST");</p>
<p>}</p>
<p>}</p>
<p>By default running this class will output only messages with level
higher then CONFIG:</p>
<p>Jul 23, 2016 9:16:11 PM LevelsExample main</p>
<p>SEVERE: Message logged by SEVERE</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 632</p>
<p>Jul 23, 2016 9:16:11 PM LevelsExample main</p>
<p>WARNING: Message logged by WARNING</p>
<p>Jul 23, 2016 9:16:11 PM LevelsExample main</p>
<p>INFO: Message logged by INFO</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 633</p>
<p><span id="Chapter_116__log4j___log4j2_1"
class="anchor"></span>Chapter 116: log4j / log4j2</p>
<p><a href="https://en.wikipedia.org/wiki/Log4j">Apache Log4j is a
Java-based logging utility, it is one of several Java logging
frameworks. This topic is to show how to</a></p>
<p>setup and configure Log4j in Java with detailed examples on all of
its possible aspects of usage.</p>
<p>Section 116.1: Properties-File to log to DB</p>
<p>For this example to work you'll need a JDBC driver compatible to the
system the database is running on. An</p>
<p>opensource one that allows you to connect to DB2 databases on an IBM
System i can be found here: <a
href="http://jt400.sourceforge.net/">JT400</a></p>
<p>Even though this example is DB2 specific, it works for almost every
other system if you exchange the driver and</p>
<p>adapt the JDBC URL.</p>
<p># Root logger option</p>
<p>log4j.rootLogger= ERROR, DB</p>
<p># Redirect log messages to a DB2</p>
<p># Define the DB appender</p>
<p>log4j.appender.DB=org.apache.log4j.jdbc.JDBCAppender</p>
<p># Set JDBC URL (!!! adapt to your target system !!!)
log4j.appender.DB.URL=jdbc:as400:<em>//10.10.10.1:446/DATABASENAME;naming=system;errors=full;</em></p>
<p># Set Database Driver (!!! adapt to your target system !!!)
log4j.appender.DB.driver=com.ibm.as400.access.AS400JDBCDriver</p>
<p># Set database user name and password</p>
<p>log4j.appender.DB.user=USER</p>
<p>log4j.appender.DB.password=PASSWORD</p>
<p># Set the SQL statement to be executed.</p>
<p>log4j.appender.DB.sql=INSERT INTO DB.TABLENAME
VALUES('%d{yyyy-MM-dd}','%d{HH:mm:ss}','%C','%p','%m')</p>
<p># Define the layout <strong>for</strong> file appender</p>
<p>log4j.appender.DB.layout=org.apache.log4j.PatternLayout</p>
<p>Section 116.2: How to get Log4j</p>
<p>Current version (log4j2)</p>
<p>Using Maven:</p>
<p>Add the following dependency to your POM.xml file:</p>
<p>&lt;dependencies&gt;</p>
<p>&lt;dependency&gt;</p>
<p><strong>&lt;groupId&gt;</strong>org.apache.logging.log4j<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>log4j-api</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>2.6.2</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;dependency&gt;</p>
<p><strong>&lt;groupId&gt;</strong>org.apache.logging.log4j<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>log4j-core</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>2.6.2</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;/dependencies&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 634</p>
<p><span id="Using_Ivy" class="anchor"></span>Using Ivy:</p>
<p>&lt;dependencies&gt;</p>
<p><strong>&lt;dependency</strong> org="org.apache.logging.log4j"
name="log4j-api" rev="2.6.2" <strong>/&gt; &lt;dependency</strong>
org="org.apache.logging.log4j" name="log4j-core" rev="2.6.2"
<strong>/&gt;</strong></p>
<p>&lt;/dependencies&gt;</p>
<p>Using Gradle:</p>
<p>dependencies {</p>
<p>compile group: 'org.apache.logging.log4j', name: 'log4j-api',
version: '2.6.2' compile group: 'org.apache.logging.log4j', name:
'log4j-core', version: '2.6.2' }</p>
<p>Getting log4j 1.x</p>
<p><strong>Note:</strong> Log4j 1.x has reached End-of-Life (EOL) (see
Remarks).</p>
<p>Using Maven:</p>
<p>Declare this dependency in the POM.xml file:</p>
<p>&lt;dependency&gt;</p>
<p>&lt;groupId&gt;<strong>log4j</strong>&lt;/groupId&gt;</p>
<p>&lt;artifactId&gt;<strong>log4j</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>1.2.17</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>Using Ivy:</p>
<p><strong>&lt;dependency</strong> org="log4j" name="log4j"
rev="1.2.17"<strong>/&gt;</strong></p>
<p>Usign Gradle:</p>
<p>compile group: 'log4j', name: 'log4j', version: '1.2.17'</p>
<p>Using Buildr:</p>
<p>'log4j:log4j:jar:1.2.17'</p>
<p>Adding manually in path build:</p>
<p><a href="http://logging.apache.org/log4j/1.2/download.html">Download
from Log4j website project</a></p>
<p>Section 116.3: Setting up property file</p>
<p>Log4j gives you posibility to log data into console and file at same
time. Create a log4j.properties file and put</p>
<p>inside this basic configuration:</p>
<p># Root logger option</p>
<p>log4j.rootLogger=DEBUG, stdout, file</p>
<p># Redirect log messages to console</p>
<p>log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out</p>
<p>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 635</p>
<p><span id="log4j_appender_stdout_layout_Con"
class="anchor"></span>log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd
HH:mm:ss} %-5p %c{1}:%L -%m%n</p>
<p># Redirect log messages to a log file, support file rolling.
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=C:\\log4j-application.log
log4j.appender.file.MaxFileSize=5MB</p>
<p>log4j.appender.file.MaxBackupIndex=10</p>
<p>log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss}
%-5p %c{1}:%L -%m%n</p>
<p>If you are using maven, put this propertie file in path:</p>
<p>/ProjectFolder/src/java/resources</p>
<p>Section 116.4: Basic log4j2.xml configuration file</p>
<p><strong>&lt;?xml</strong> version="1.0"
encoding="UTF-8"<strong>?&gt;</strong></p>
<p>&lt;Configuration&gt;</p>
<p>&lt;Appenders&gt;</p>
<p><strong>&lt;Console</strong> name="STDOUT"
target="SYSTEM_OUT"<strong>&gt;</strong></p>
<p><strong>&lt;PatternLayout</strong> pattern="%d %-5p [%t] %C{2}
%m%n"<strong>/&gt;</strong></p>
<p>&lt;/Console&gt;</p>
<p>&lt;/Appenders&gt;</p>
<p>&lt;Loggers&gt;</p>
<p><strong>&lt;Root</strong> level="debug"<strong>&gt;</strong></p>
<p>&lt;AppenderRef <strong>ref="STDOUT"</strong>/&gt;</p>
<p>&lt;/Root&gt;</p>
<p>&lt;/Loggers&gt;</p>
<p>&lt;/Configuration&gt;</p>
<p>This is a basic log4j2.xml configuration which has a console appender
and a root logger. The pattern layout specifies which pattern should be
used for logging the statements.</p>
<p>In order to debug the loading of log4j2.xml you can add the attribute
status = in the configuration tag of your log4j2.xml.</p>
<p>You can also add a monitor interval so that it loads the
configuration again after the specified interval period. The monitor
interval can be added to the configuration tag as follows:
monitorInterval = 30. It means that the config</p>
<p>will be loaded every 30 seconds.</p>
<p>Section 116.5: How to use Log4j in Java code</p>
<p>First need to create a <strong>final static</strong> logger
object:</p>
<p><strong>final static</strong> Logger logger =
Logger.getLogger(classname.<strong>class</strong>);</p>
<p>Then, call logging methods:</p>
<p>//logs an error message</p>
<p>logger.info("Information about some param: " + parameter); <em>//
Note that this line could throw a NullPointerException!</em></p>
<p>//in order to improve performance, it is advised to use the
`isXXXEnabled()` Methods <em><strong>if</strong>( logger.isInfoEnabled()
){</em></p>
<p>logger.info("Information about some param: " + parameter); }</p>
<p>// In log4j2 parameter substitution is preferable due to readability
and performance // The parameter substitution only takes place if info
level is active which obsoletes the use of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 636</p>
<p><span id="isXXXEnabled" class="anchor"></span>isXXXEnabled().</p>
<p>logger.info("Information about some param: {}" , parameter);</p>
<p>//logs an exception</p>
<p>logger.error("Information about some error: ", exception);</p>
<p>Section 116.6: Migrating from log4j 1.x to 2.x</p>
<p>If you want to migrate from existing log4j 1.x in your project to
log4j 2.x then remove all existing log4j 1.x dependencies and add the
following dependency:</p>
<p>Log4j 1.x API Bridge</p>
<p>Maven Build</p>
<p>&lt;dependencies&gt;</p>
<p>&lt;dependency&gt;</p>
<p><strong>&lt;groupId&gt;</strong>org.apache.logging.log4j<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>log4j-1.2-api</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>2.6.2</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;/dependencies&gt;</p>
<p>Ivy Build</p>
<p>&lt;dependencies&gt;</p>
<p><strong>&lt;dependency</strong> org="org.apache.logging.log4j"
name="log4j-1.2-api" rev="2.6.2" <strong>/&gt;</strong></p>
<p>&lt;/dependencies&gt;</p>
<p>Gradle Build</p>
<p>dependencies {</p>
<p>compile group: 'org.apache.logging.log4j', name: 'log4j-1.2-api',
version: '2.6.2' }</p>
<p><strong>Apache Commons Logging Bridge</strong> If your project is
using Apache Commons Logging which use log4j 1.x and you want to migrate
it to log4j 2.x then add the following dependencies:</p>
<p>Maven Build</p>
<p>&lt;dependencies&gt;</p>
<p>&lt;dependency&gt;</p>
<p><strong>&lt;groupId&gt;</strong>org.apache.logging.log4j<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>log4j-jcl</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>2.6.2</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;/dependencies&gt;</p>
<p>Ivy Build</p>
<p>&lt;dependencies&gt;</p>
<p><strong>&lt;dependency</strong> org="org.apache.logging.log4j"
name="log4j-jcl" rev="2.6.2" <strong>/&gt;</strong></p>
<p>&lt;/dependencies&gt;</p>
<p>Gradle Build</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 637</p>
<p><span id="dependencies" class="anchor"></span>dependencies {</p>
<p>compile group: 'org.apache.logging.log4j', name: 'log4j-jcl',
version: '2.6.2' }</p>
<p>Note: Do not remove any existing dependencies of Apache commons
logging</p>
<p>Reference: <a
href="https://logging.apache.org/log4j/2.x/maven-artifacts.html">https://logging.apache.org/log4j/2.x/maven-artifacts.html</a></p>
<p>Section 116.7: Filter Logoutput by level (log4j 1.x)</p>
<p>You can use a filter to log only messages "lower" than e.g. ERROR
level. <strong>But the filter is not supported by</strong></p>
<p>PropertyConfigurator. So you must change to XML config to use
it<strong><a
href="http://wiki.apache.org/logging-log4j/LogToAppenderByLevel?highlight=%28filter%29">.
See log4j-Wiki about filters</a>.</strong></p>
<p>Example "specific level"</p>
<p><strong>&lt;appender</strong> name="info-out"
class="org.apache.log4j.FileAppender"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="File"
value="info.log"<strong>/&gt;</strong></p>
<p><strong>&lt;layout</strong>
class="org.apache.log4j.PatternLayout"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="ConversionPattern"
value="%m%n"<strong>/&gt;</strong></p>
<p>&lt;/layout&gt;</p>
<p><strong>&lt;filter</strong>
class="org.apache.log4j.varia.LevelMatchFilter"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="LevelToMatch" value="info"
<strong>/&gt;</strong></p>
<p><strong>&lt;param</strong> name="AcceptOnMatch"
value="true"<strong>/&gt;</strong></p>
<p>&lt;/filter&gt;</p>
<p><strong>&lt;filter</strong>
class="org.apache.log4j.varia.DenyAllFilter" <strong>/&gt;</strong></p>
<p>&lt;/appender&gt;</p>
<p>Or "Level range"</p>
<p><strong>&lt;appender</strong> name="info-out"
class="org.apache.log4j.FileAppender"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="File"
value="info.log"<strong>/&gt;</strong></p>
<p><strong>&lt;layout</strong>
class="org.apache.log4j.PatternLayout"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="ConversionPattern"
value="%m%n"<strong>/&gt;</strong></p>
<p>&lt;/layout&gt;</p>
<p><strong>&lt;filter</strong>
class="org.apache.log4j.varia.LevelRangeFilter"<strong>&gt;</strong></p>
<p><strong>&lt;param</strong> name="LevelMax"
value="info"<strong>/&gt;</strong></p>
<p><strong>&lt;param</strong> name="LevelMin"
value="info"<strong>/&gt;</strong></p>
<p><strong>&lt;param</strong> name="AcceptOnMatch"
value="true"<strong>/&gt;</strong></p>
<p>&lt;/filter&gt;</p>
<p>&lt;/appender&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 638</p>
<p><span id="Chapter_117__Oracle_O_cial_Code_1"
class="anchor"></span>Chapter 117: Oracle Ocial Code Standard</p>
<p><a href="http://cr.openjdk.java.net/%7Ealundblad/styleguide">Oracle
official style guide for the Java Programming Language is a standard
followed by developers at Oracle and</a></p>
<p>recommended to be followed by any other Java developer. It covers
filenames, file organization, indentation, comments, declarations,
statements, white space, naming conventions, programming practices and
includes a code</p>
<p>example.</p>
<p>Section 117.1: Naming Conventions</p>
<p>Package names</p>
<p>Package names should be all lower case without underscores or other
special characters. Package names begin with the reversed authority part
of the web address of the company of the developer.</p>
<p>This part can be followed a by project/program structure dependent
package substructure.</p>
<p>Don’t use plural form. Follow the convention of the standard API
which uses for instance java.lang.annotation and not
java.lang.annotations.</p>
<p><strong>Examples:</strong> com.yourcompany.widget.button,
com.yourcompany.core.api</p>
<p>Class, Interface and Enum Names</p>
<p>Class and enum names should typically be nouns.</p>
<p>Interface names should typically be nouns or adjectives ending with
…able.</p>
<p>Use mixed case with the first letter in each word in upper case (i.e.
<a href="https://en.wikipedia.org/wiki/CamelCase">CamelCase).</a></p>
<p>Match the regular expression ^[A-Z][a-zA-Z0-9]*$.</p>
<p>Use whole words and avoid using abbreviations unless the abbreviation
is more widely used than the long</p>
<p>form.</p>
<p>Format an abbreviation as a word if the it is part of a longer class
name.</p>
<p><strong>Examples:</strong> ArrayList, BigInteger,
ArrayIndexOutOfBoundsException, Iterable.</p>
<p>Method Names</p>
<p>Method names should typically be verbs or other descriptions of
actions</p>
<p>They should match the regular expression ^[a-z][a-zA-Z0-9]*$. Use
mixed case with the first letter in lower case.</p>
<p><strong>Examples:</strong> toString, hashCode</p>
<p>Variables</p>
<p>Variable names should be in mixed case with the first letter in lower
case</p>
<p>Match the regular expression ^[a-z][a-zA-Z0-9]*$</p>
<p>Further recommendation: <a
href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">Variables</a></p>
<p><strong>Examples:</strong> elements, currentIndex</p>
<p>Type Variables</p>
<p>For simple cases where there are few type variables involved use a
single upper case letter.</p>
<p>Match the regular expression ^[A-Z][0-9]?$</p>
<p>If one letter is more descriptive than another (such as K and V for
keys and values in maps or R for a function</p>
<p>return type) use that, otherwise use T.</p>
<p>For complex cases where single letter type variables become
confusing, use longer names written in all</p>
<p>capital letters and use underscore (_) to separate words.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 639</p>
<p><span id="Examples__T__V__SRC_VERTEX"
class="anchor"></span><strong>Examples:</strong> T, V, SRC_VERTEX</p>
<p>Constants</p>
<p>Constants (<strong>static final</strong> fields whose content is
immutable, by language rules or by convention) should be named with all
capital letters and underscore (_) to separate words.</p>
<p>Match the regular expression ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</p>
<p><strong>Examples:</strong> BUFFER_SIZE, MAX_LEVEL</p>
<p>Other guidelines on naming</p>
<p>Avoid hiding/shadowing methods, variables and type variables in outer
scopes. Let the verbosity of the name correlate to the size of the
scope. (For instance, use descriptive names for</p>
<p>fields of large classes and brief names for local short-lived
variables.) When naming public static members, let the identifier be
self descriptive if you believe they will be statically</p>
<p>imported.</p>
<p>Further reading: <a
href="http://cr.openjdk.java.net/%7Ealundblad/styleguide/index-v6.html#toc-naming">Naming
Section (in the official Java Style Guide)</a></p>
<p>Source: <a
href="http://cr.openjdk.java.net/%7Ealundblad/styleguide/index-v6.html">Java
Style Guidelines from Oracle</a></p>
<p>Section 117.2: Class Structure</p>
<p>Order of class members</p>
<p>Class members should be ordered as follows:</p>
<p>1. Fields (in order of public, protected and private)</p>
<p>2. Constructors</p>
<p>3. Factory methods</p>
<p>4. Other Methods (in order of public, protected and private)</p>
<p>Ordering fields and methods primarily by their access modifiers or
identifier is not required.</p>
<p>Here is an example of this order:</p>
<p><strong>class</strong> Example {</p>
<p>private int <strong>i;</strong></p>
<p>Example(<strong>int</strong> i) {</p>
<p><strong>this</strong>.i = i;</p>
<p>}</p>
<p><strong>static</strong> Example getExample(<strong>int</strong> i)
{</p>
<p><strong>return new</strong> Example(i);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong> "An example [" + i + "]";</p>
<p>}</p>
<p>}</p>
<p>Grouping of class members</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 640</p>
<p><span id="Related_fields_should_be_grouped"
class="anchor"></span>Related fields should be grouped together.</p>
<p>A nested type may be declared right before its first use; otherwise
it should be declared before the fields.</p>
<p>Constructors and overloaded methods should be grouped together by
functionality and ordered with</p>
<p>increasing arity. This implies that delegation among these constructs
flow downward in the code. Constructors should be grouped together
without other members between.</p>
<p>Overloaded variants of a method should be grouped together without
other members between.</p>
<p>Section 117.3: Annotations</p>
<p>Declaration annotations should be put on a separate line from the
declaration being annotated.</p>
<p>@SuppressWarnings("unchecked")</p>
<p><strong>public</strong> T[] toArray(T[] typeHolder) {</p>
<p>...</p>
<p>}</p>
<p>However, few or short annotations annotating a single-line method may
be put on the same line as the method if it</p>
<p>improves readability. For example, one may write:</p>
<p>@Nullable String getName() { <strong>return</strong> name; }</p>
<p>For a matter of consistency and readability, either all annotations
should be put on the same line or each annotation should be put on a
separate line.</p>
<p>// Bad.</p>
<p>@Deprecated @SafeVarargs</p>
<p>@CustomAnnotation</p>
<p><strong>public final</strong> Tuple extend(T... elements) {</p>
<p>...</p>
<p>}</p>
<p>// Even worse.</p>
<p>@Deprecated @SafeVarargs</p>
<p>@CustomAnnotation <strong>public final</strong> Tuple extend(T...
elements) {</p>
<p>...</p>
<p>}</p>
<p>// Good.</p>
<p>@Deprecated</p>
<p>@SafeVarargs</p>
<p>@CustomAnnotation</p>
<p><strong>public final</strong> Tuple extend(T... elements) {</p>
<p>...</p>
<p>}</p>
<p>// Good.</p>
<p>@Deprecated @SafeVarargs @CustomAnnotation</p>
<p><strong>public final</strong> Tuple extend(T... elements) {</p>
<p>...</p>
<p>}</p>
<p>Section 117.4: Import statements</p>
<p>// First java/javax packages</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> javax.tools.JavaCompiler;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 641</p>
<p><span id="___Then_third_party_libraries" class="anchor"></span>//
Then third party libraries</p>
<p><strong>import</strong>
com.fasterxml.jackson.annotation.JsonProperty;</p>
<p>// Then project imports</p>
<p><strong>import</strong> com.example.my.package.ClassA;</p>
<p><strong>import</strong> com.example.my.package.ClassB;</p>
<p>// Then static imports (in the same order as above)
<em><strong>import</strong> static
java.util.stream.Collectors.toList;</em></p>
<p>Import statements should be sorted…</p>
<p>…primarily by non-static / static with non-static imports first.</p>
<p>…secondarily by package origin according to the following order</p>
<p>java packages</p>
<p>javax packages</p>
<p>external packages (e.g. org.xml)</p>
<p>internal packages (e.g. com.sun)</p>
<p>…tertiary by package and class identifier in lexicographical
order</p>
<p>Import statements should not be line wrapped, regardless of whether
it exceeds the recommended</p>
<p>maximum length of a line.</p>
<p>No unused imports should be present.</p>
<p>Wildcard imports</p>
<p>Wildcard imports should in general not be used.</p>
<p>When importing a large number of closely-related classes (such as
implementing a visitor over a tree with</p>
<p>dozens of distinct “node” classes), a wildcard import may be
used.</p>
<p>In any case, no more than one wildcard import per file should be
used.</p>
<p>Section 117.5: Braces</p>
<p><strong>class</strong> Example {</p>
<p><strong>void</strong> method(<strong>boolean</strong> error) {</p>
<p><strong>if</strong> (error) {</p>
<p>Log.error("Error occurred!");</p>
<p>System.out.println("Error!");</p>
<p><em>} <strong>else</strong> {</em> // Use braces since the other
block uses braces.</p>
<p>System.out.println("No error");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Opening braces should be put on the end of the current line rather
than on a line by its own.</p>
<p>There should be a new line in front of a closing brace unless the
block is empty (see Short Forms below)</p>
<p>Braces are recommended even where the language makes them optional,
such as single-line if and loop bodies.</p>
<p>If a block spans more than one line (including comments) it must have
braces. If one of the blocks in a if / <strong>else</strong> statement
has braces, the other block must too.</p>
<p>If the block comes last in an enclosing block, it must have
braces.</p>
<p>The <strong>else</strong>, <strong>catch</strong> and the
<strong>while</strong> keyword in
<strong>do</strong>…<strong>while</strong> loops go on the same line as
the closing brace of the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 642</p>
<p><span id="preceding_block" class="anchor"></span>preceding block.</p>
<p>Short forms</p>
<p><strong>enum</strong> Response { YES, NO, MAYBE }</p>
<p>public boolean <strong>isReference() {</strong> return true<strong>;
}</strong></p>
<p>The above recommendations are intended to improve uniformity (and
thus increase familiarity / readability). In</p>
<p>some cases “short forms” that deviate from the above guidelines are
just as readable and may be used instead.</p>
<p>These cases include for instance simple enum declarations and trivial
methods and lambda expressions.</p>
<p>Section 117.6: Redundant Parentheses</p>
<p><strong>return</strong> flag ? "yes" : "no";</p>
<p>String cmp = (flag1 != flag2) ? "not equal" : "equal";</p>
<p>// Don't do this</p>
<p><strong>return</strong> (flag ? "yes" : "no");</p>
<p>Redundant grouping parentheses (i.e. parentheses that does not affect
evaluation) may be used if they improve readability.</p>
<p>Redundant grouping parentheses should typically be left out in
shorter expressions involving common operators but included in longer
expressions or expressions involving operators whose precedence and</p>
<p>associativity is unclear without parentheses. Ternary expressions
with non-trivial conditions belong to the</p>
<p>latter.</p>
<p>The entire expression following a <strong>return</strong> keyword
must not be surrounded by parentheses.</p>
<p>Section 117.7: Modifiers</p>
<p><strong>class</strong> ExampleClass {</p>
<p>// Access modifiers first (don't do for instance "static public")
<em><strong>public static void</strong> main(String[] args) {</em></p>
<p>System.out.println("Hello World");</p>
<p>}</p>
<p>}</p>
<p><strong>interface</strong> ExampleInterface {</p>
<p>// Avoid 'public' and 'abstract' since they are implicit
<em><strong>void</strong> sayHello();</em></p>
<p>}</p>
<p>Modifiers should go in the following order</p>
<p>Access modifier (<strong>public</strong> / <strong>private</strong> /
<strong>protected</strong>)</p>
<p>abstract</p>
<p>static</p>
<p>final</p>
<p>transient</p>
<p>volatile</p>
<p>default</p>
<p>synchronized</p>
<p>native</p>
<p>strictfp</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 643</p>
<p><span id="Modifiers_should_not_be_written"
class="anchor"></span>Modifiers should not be written out when they are
implicit. For example, interface methods should neither be declared
<strong>public</strong> nor <strong>abstract</strong>, and nested enums
and interfaces should not be declared static.</p>
<p>Method parameters and local variables should not be declared
<strong>final</strong> unless it improves readability or</p>
<p>documents an actual design decision.</p>
<p>Fields should be declared <strong>final</strong> unless there is a
compelling reason to make them mutable.</p>
<p>Section 117.8: Indentation</p>
<p>Indentation level is <strong>four spaces</strong>.</p>
<p>Only space characters may be used for indentation. <strong>No
tabs.</strong></p>
<p>Empty lines must not be indented. (This is implied by the no trailing
white space rule.) <strong>case</strong> lines should be indented with
four spaces, and statements within the case should be indented with</p>
<p>another four spaces.</p>
<p><strong>switch</strong> (var) {</p>
<p><strong>case</strong> TWO:</p>
<p>setChoice("two");</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> THREE:</p>
<p>setChoice("three");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p><strong>throw new</strong> IllegalArgumentException();</p>
<p>}</p>
<p>Refer to Wrapping statements for guidelines on how to indent
continuation lines.</p>
<p>Section 117.9: Literals</p>
<p><strong>long</strong> l = 5432L;</p>
<p><strong>int</strong> i = 0x123 + 0xABC;</p>
<p><strong>byte</strong> b = 0b1010;</p>
<p><strong>float</strong> f1 = 1 / 5432f;</p>
<p><strong>float</strong> f2 = 0.123e4f;</p>
<p><strong>double</strong> d1 = 1 / 5432d; <em>// or 1 / 5432.0</em></p>
<p><strong>double</strong> d2 = 0x1.3p2;</p>
<p><strong>long</strong> literals should use the upper case letter L
suffix.</p>
<p>Hexadecimal literals should use upper case letters A-F.</p>
<p>All other numerical prefixes, infixes, and suffixes should use
lowercase letters.</p>
<p>Section 117.10: Package declaration</p>
<p><strong>package</strong> com.example.my.package;</p>
<p>The package declaration should not be line wrapped, regardless of
whether it exceeds the recommended</p>
<p>maximum length of a line.</p>
<p>Section 117.11: Lambda Expressions</p>
<p>Runnable r = ()-&gt; System.out.println("Hello World");</p>
<p>Supplier c = ()-&gt; "Hello World";</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 644</p>
<p><span id="___Collection__contains_is_a_sim" class="anchor"></span>//
Collection::contains is a simple unary method and its behavior is //
clear from the context. A method reference is preferred here.
<em>appendFilter(goodStrings::contains);</em></p>
<p>// A lambda expression is easier to understand than just tempMap::put
in this case <em>trackTemperature((time, temp)-&gt; tempMap.put(time,
temp));</em></p>
<p>Expression lambdas are preferred over single-line block lambdas.
Method references should generally be preferred over lambda
expressions.</p>
<p>For bound instance method references, or methods with arity greater
than one, a lambda expression may be easier to understand and therefore
preferred. Especially if the behavior of the method is not clear from
the</p>
<p>context.</p>
<p>The parameter types should be omitted unless they improve
readability. If a lambda expression stretches over more than a few
lines, consider creating a method.</p>
<p>Section 117.12: Java Source Files</p>
<p>All lines must be terminated with a line feed character (LF, ASCII
value 10) and not for instance CR or CR+LF.</p>
<p>There may be no trailing white space at the end of a line.</p>
<p>The name of a source file must equal the name of the class it
contains followed by the .java extension, even</p>
<p>for files that only contain a package private class. This does not
apply to files that do not contain any class declarations, such as
package-info.java.</p>
<p>Section 117.13: Wrapping statements</p>
<p>Source code and comments should generally not exceed 80 characters
per line and rarely if ever exceed 100 characters per line, including
indentation.</p>
<p>The character limit must be judged on a case by case basis. What
really matters is the semantical “density”</p>
<p>and readability of the line. Making lines gratuitously long makes
them hard to read; similarly, making “heroic</p>
<p>attempts” to fit them into 80 columns can also make them hard to
read. The flexibility outlined here aims to</p>
<p>enable developers to avoid these extremes, not to maximize use of
monitor real-estate.</p>
<p>URLs or example commands should not be wrapped.</p>
<p>// Ok even though it might exceed max line width when indented.
<em>Error e = isTypeParam</em></p>
<p>?
Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
:
Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));</p>
<p>// Wrapping preferable</p>
<p>String pretty = Stream.of(args)</p>
<p>.map(Argument::prettyPrint)</p>
<p>.collectors(joining(", "));</p>
<p>// Too strict interpretation of max line width. Readability suffers.
<em>Error e = isTypeParam</em></p>
<p>? Errors.InvalidRepeatableAnnotationNotApplicable(
targetContainerType, on)</p>
<p>: Errors.InvalidRepeatableAnnotationNotApplicableInContext(
targetContainerType);</p>
<p>// Should be wrapped even though it fits within the character
limit</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 645</p>
<p><span id="String_pretty___Stream_of_args"
class="anchor"></span>String pretty =
Stream.of(args).map(Argument::prettyPrint).collectors(joining(",
"));</p>
<p>Wrapping at a higher syntactical level is preferred over wrapping at
a lower syntactical level.</p>
<p>There should be at most 1 statement per line.</p>
<p>A continuation line should be indented in one of the following four
ways</p>
<p><strong>Variant 1</strong>: With 8 extra spaces relative to the
indentation of the previous line.</p>
<p><strong>Variant 2</strong>: With 8 extra spaces relative to the
starting column of the wrapped expression.</p>
<p><strong>Variant 3</strong>: Aligned with previous sibling expression
(as long as it is clear that it’s a continuation line)</p>
<p><strong>Variant 4</strong>: Aligned with previous method call in a
chained expression.</p>
<p>Section 117.14: Wrapping Method Declarations</p>
<p><strong>int</strong> someMethod(String aString,</p>
<p>List aList,</p>
<p>Map aMap,</p>
<p><strong>int</strong> anInt,</p>
<p><strong>long</strong> aLong,</p>
<p>Set aSet,</p>
<p><strong>double</strong> aDouble) {</p>
<p>…</p>
<p>}</p>
<p><strong>int</strong> someMethod(String aString, List aList,</p>
<p>Map aMap, <strong>int</strong> anInt, <strong>long</strong>
aLong,</p>
<p><strong>double</strong> aDouble, <strong>long</strong> aLong) {</p>
<p>…</p>
<p>}</p>
<p><strong>int</strong> someMethod(String aString,</p>
<p>List&gt; aListOfMaps,</p>
<p>Map aMap)</p>
<p><strong>throws</strong> IllegalArgumentException {</p>
<p>…</p>
<p>}</p>
<p><strong>int</strong> someMethod(String aString, List aList,</p>
<p>Map aMap, <strong>int</strong> anInt)</p>
<p><strong>throws</strong> IllegalArgumentException {</p>
<p>…</p>
<p>}</p>
<p>Method declarations can be formatted by listing the arguments
vertically, or by a new line and +8 extra</p>
<p>spaces</p>
<p>If a throws clause needs to be wrapped, put the line break in front
of the throws clause and make sure it</p>
<p>stands out from the argument list, either by indenting +8 relative to
the function declaration, or +8 relative to the previous line.</p>
<p>Section 117.15: Wrapping Expressions</p>
<p>If a line approaches the maximum character limit, always consider
breaking it down into multiple statements / expressions instead of
wrapping the line.</p>
<p>Break before operators.</p>
<p>Break before the . in chained method calls.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 646</p>
<p><span id="popupMsg__Inbox_notification__Yo"
class="anchor"></span>popupMsg("Inbox notification: You have "</p>
<p>+ newMsgs + " new messages");</p>
<p>// Don't! Looks like two arguments</p>
<p>popupMsg("Inbox notification: You have " +</p>
<p>newMsgs + " new messages");</p>
<p>Section 117.16: Whitespace</p>
<p>Vertical Whitespace</p>
<p>A single blank line should be used to separate…</p>
<p>Package declaration</p>
<p>Class declarations</p>
<p>Constructors</p>
<p>Methods</p>
<p>Static initializers</p>
<p>Instance initializers</p>
<p>…and may be used to separate logical groups of</p>
<p>import statements</p>
<p>fields</p>
<p>statements</p>
<p>Multiple consecutive blank lines should only be used to separate
groups of related members and not as the standard inter-member
spacing.</p>
<p>Horizontal Whitespace</p>
<p>A single space should be used…</p>
<p>To separate keywords from neighboring opening or closing brackets and
braces Before and after all binary operators and operator like symbols
such as arrows in lambda expressions</p>
<p>and the colon in enhanced for loops (but not before the colon of a
label) After // that starts a comment.</p>
<p>After commas separating arguments and semicolons separating the parts
of a for loop.</p>
<p>After the closing parenthesis of a cast.</p>
<p>In variable declarations it is not recommended to align types and
variables.</p>
<p>Section 117.17: Special Characters</p>
<p>Apart from LF the only allowed white space character is Space (ASCII
value 32). Note that this implies that</p>
<p>other white space characters (in, for instance, string and character
literals) must be written in escaped form.</p>
<p>\', \", \\, \t, \b, \r, \f, and \n should be preferred over
corresponding octal (e.g. \047) or Unicode (e.g. \u0027 ) escaped
characters.</p>
<p>Should there be a need to go against the above rules for the sake of
testing, the test should <em>generate</em> the required input
programmatically.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 647</p>
<p><span id="Section_117_18__Variable_Declara"
class="anchor"></span>Section 117.18: Variable Declarations</p>
<p>One variable per declaration (and at most one declaration per
line)</p>
<p>Square brackets of arrays should be at the type (String[] args) and
not on the variable (String args[]).</p>
<p>Declare a local variable right before it is first used, and
initialize it as close to the declaration as possible.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 648</p>
<p><span id="Chapter_118__Character_encoding_1"
class="anchor"></span>Chapter 118: Character encoding</p>
<p>Section 118.1: Reading text from a file encoded in UTF-8</p>
<p><strong>import</strong> java.io.BufferedReader;</p>
<p><strong>import</strong> java.io.BufferedWriter;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.nio.charset.StandardCharsets;</p>
<p><strong>import</strong> java.nio.file.Files;</p>
<p><strong>import</strong> java.nio.file.Paths;</p>
<p><strong>public class</strong> ReadingUTF8TextFile {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</p>
<p>//StandardCharsets is available since Java 1.7</p>
<p>//for ealier version use Charset.forName("UTF-8");</p>
<p><strong>try</strong> (BufferedWriter wr =
Files.newBufferedWriter(Paths.get("test.txt"),</p>
<p>StandardCharsets.UTF_8)) {</p>
<p>wr.write("Strange cyrillic symbol Ы");</p>
<p>}</p>
<p>/* First Way. For big files */</p>
<p><strong>try</strong> (BufferedReader reader =
Files.newBufferedReader(Paths.get("test.txt"),</p>
<p>StandardCharsets.UTF_8)) {</p>
<p>String line;</p>
<p><strong>while</strong> ((line = reader.readLine()) !=
<strong>null</strong>) {</p>
<p>System.out.print(line);</p>
<p>}</p>
<p>}</p>
<p><em>System.out.println();</em> //just separating output</p>
<p>/* Second way. For small files */</p>
<p>String s = <strong>new</strong>
String(Files.readAllBytes(Paths.get("test.txt")),
StandardCharsets.UTF_8); System.out.print(s);</p>
<p>}</p>
<p>}</p>
<p>Section 118.2: Writing text to a file in UTF-8</p>
<p><strong>import</strong> java.io.BufferedWriter;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.nio.charset.StandardCharsets;</p>
<p><strong>import</strong> java.nio.file.Files;</p>
<p><strong>import</strong> java.nio.file.Paths;</p>
<p><strong>public class</strong> WritingUTF8TextFile {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> IOException {</p>
<p>//StandardCharsets is available since Java 1.7</p>
<p>//for ealier version use Charset.forName("UTF-8");</p>
<p><strong>try</strong> (BufferedWriter wr =
Files.newBufferedWriter(Paths.get("test2.txt"),</p>
<p>StandardCharsets.UTF_8)) {</p>
<p>wr.write("Cyrillic symbol Ы");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 649</p>
<p><span id="Section_118_3__Getting_byte_repr"
class="anchor"></span>Section 118.3: Getting byte representation of a
string in UTF-8</p>
<p><strong>import</strong> java.nio.charset.StandardCharsets;</p>
<p><strong>import</strong> java.util.Arrays;</p>
<p><strong>public class</strong> GetUtf8BytesFromString {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>String str = "Cyrillic symbol Ы";</p>
<p>//StandardCharsets is available since Java 1.7</p>
<p>//for ealier version use Charset.forName("UTF-8");</p>
<p><strong>byte</strong>[] textInUtf8 =
str.getBytes(StandardCharsets.UTF_8);</p>
<p>System.out.println(Arrays.toString(textInUtf8));</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 650</p>
<p><span id="Chapter_119__Apache_Commons_Lang_1"
class="anchor"></span>Chapter 119: Apache Commons Lang</p>
<p>Section 119.1: Implement equals() method</p>
<p>To implement the equals method of an object easily you could use the
EqualsBuilder class.</p>
<p>Selecting the fields:</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>if</strong>(!(obj <strong>instanceof</strong> MyClass)) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>MyClass theOther = (MyClass) obj;</p>
<p>EqualsBuilder builder = <strong>new</strong> EqualsBuilder();</p>
<p>builder.append(field1, theOther.field1);</p>
<p>builder.append(field2, theOther.field2);</p>
<p>builder.append(field3, theOther.field3);</p>
<p><strong>return</strong> builder.isEquals();</p>
<p>}</p>
<p>Using reflection:</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>return</strong>
EqualsBuilder.reflectionEquals(<strong>this</strong>, obj,
<strong>false</strong>);</p>
<p>}</p>
<p>the boolean parameter is to indicates if the equals should check
transient fields.</p>
<p>Using reflection avoiding some fields:</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(Object obj) {</p>
<p><strong>return</strong>
EqualsBuilder.reflectionEquals(<strong>this</strong>, obj, "field1",
"field2");</p>
<p>}</p>
<p>Section 119.2: Implement hashCode() method</p>
<p>To implement the hashCode method of an object easily you could use
the HashCodeBuilder class.</p>
<p>Selecting the fields:</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p>HashCodeBuilder builder = <strong>new</strong> HashCodeBuilder();</p>
<p>builder.append(field1);</p>
<p>builder.append(field2);</p>
<p>builder.append(field3);</p>
<p><strong>return</strong> builder.hashCode();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 651</p>
<p><span id="Using_reflection" class="anchor"></span>Using
reflection:</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong>
HashCodeBuilder.reflectionHashCode(<strong>this</strong>,
<strong>false</strong>);</p>
<p>}</p>
<p>the boolean parameter indicates if it should use transient
fields.</p>
<p>Using reflection avoiding some fields:</p>
<p>@Override</p>
<p><strong>public int</strong> hashCode() {</p>
<p><strong>return</strong>
HashCodeBuilder.reflectionHashCode(<strong>this</strong>, "field1",
"field2");</p>
<p>}</p>
<p>Section 119.3: Implement toString() method</p>
<p>To implement the toString method of an object easily you could use
the ToStringBuilder class.</p>
<p>Selecting the fields:</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p>ToStringBuilder builder = <strong>new</strong>
ToStringBuilder(<strong>this</strong>);</p>
<p>builder.append(field1);</p>
<p>builder.append(field2);</p>
<p>builder.append(field3);</p>
<p><strong>return</strong> builder.toString();</p>
<p>}</p>
<p>Example result:</p>
<p>ar.com.jonat.lang.MyClass@dd7123[,0,<strong>false</strong>]</p>
<p>Explicitly giving names to the fields:</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p>ToStringBuilder builder = <strong>new</strong>
ToStringBuilder(<strong>this</strong>);</p>
<p>builder.append("field1",field1);</p>
<p>builder.append("field2",field2);</p>
<p>builder.append("field3",field3);</p>
<p><strong>return</strong> builder.toString();</p>
<p>}</p>
<p>Example result:</p>
<p>ar.com.jonat.lang.MyClass@dd7404[field1=,field2=0,field3=<strong>false</strong>]</p>
<p>You could change the style via parameter:</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 652</p>
<p><strong>public</strong> String toString() {</p>
<p>ToStringBuilder builder = <strong>new</strong>
ToStringBuilder(<strong>this</strong>,</p>
<p>ToStringStyle.MULTI_LINE_STYLE);</p>
<p>builder.append("field1", field1);</p>
<p>builder.append("field2", field2);</p>
<p>builder.append("field3", field3);</p>
<p><strong>return</strong> builder.toString();</p>
<p>}</p>
<p>Example result:</p>
<p>ar.com.bna.lang.MyClass@ebbf5c[</p>
<p>field1=</p>
<p>field2=0</p>
<p>field3=<strong>false</strong></p>
<p>]</p>
<p>There are some styles, for example JSON, no Classname, short, etc
...</p>
<p>Via reflection:</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong>
ToStringBuilder.reflectionToString(<strong>this</strong>);</p>
<p>}</p>
<p>You could also indicate the style:</p>
<p>@Override</p>
<p><strong>public</strong> String toString() {</p>
<p><strong>return</strong>
ToStringBuilder.reflectionToString(<strong>this</strong>,
ToStringStyle.JSON_STYLE);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 653</p>
<p><span id="Chapter_120__Localization_and"
class="anchor"></span>Chapter 120: Localization and</p>
<p>Internationalization</p>
<p>Section 120.1: Locale</p>
<p>The java.util.Locale class is used to represent a "geographical,
political or cultural" region to localize a given text, number, date or
operation to. A Locale object may thus contain a country, region,
language, and also a variant of a</p>
<p>language, for instance a dialect spoken in a certain region of a
country, or spoken in a different country than the country from which
the language originates.</p>
<p>The Locale instance is handed to components that need to localize
their actions, whether it is converting the input, output, or just need
it for internal operations. The Locale class cannot do any
internationalization or localization by</p>
<p>itself</p>
<p>Language</p>
<p>The language must be an ISO 639 2 or 3 character language code, or a
registered language subtag of up to 8</p>
<p>characters. In case a language has both a 2 and 3 character language
code, use the 2 character code. A full list of language codes can be
found in the IANA Language Subtag Registry.</p>
<p>Language codes are case insensitive, but the Locale class always use
lowercase versions of the language codes</p>
<p>Creating a Locale</p>
<p>Creating a java.util.Locale instance can be done in four different
ways:</p>
<p>Locale constants</p>
<p>Locale constructors</p>
<p>Locale.Builder <strong>class</strong></p>
<p>Locale.forLanguageTag factory method</p>
<p>Java ResourceBundle</p>
<p>You create a ResourceBundle instance like this:</p>
<p>Locale locale = <strong>new</strong> Locale("en", "US");</p>
<p>ResourceBundle labels = ResourceBundle.getBundle("i18n.properties");
System.out.println(labels.getString("message"));</p>
<p>Consider I have a property file i18n.properties:</p>
<p>message=<strong>This</strong> is locale</p>
<p>Output:</p>
<p>This is locale</p>
<p>Setting Locale</p>
<p>If you want to reproduce the state using other languages, you can use
<strong>setDefault()</strong> method. Its usage:</p>
<p>setDefault(Locale.JAPANESE); <em>//Set Japanese</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 654</p>
<p><span id="Section_120_2__Automatically_for"
class="anchor"></span>Section 120.2: Automatically formatted Dates using
"locale"</p>
<p>SimpleDateFormatter is great in a pinch, but like the name suggests
it doesn't scale well.</p>
<p>If you hard-code "MM/dd/yyyy" all over your application your
international users won't be happy.</p>
<p>Let Java do the work for you</p>
<p>Use the <strong>static</strong> <a
href="https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html">methods
in DateFormat</a> to retrieve the right formatting for your user. For a
desktop application</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#getDefault--">(where
you'll rely on the default locale), simply call:</a></p>
<p>String localizedDate =
DateFormat.getDateInstance(style).format(date);</p>
<p>Where style is one of the formatting constants (FULL, LONG, MEDIUM,
SHORT, etc.) specified in DateFormat.</p>
<p>For a server-side application where the user specifies their locale
as part of the request, you should pass it explicitly</p>
<p>to getDateInstance() instead:</p>
<p>String localizedDate =</p>
<p>DateFormat.getDateInstance(style,
request.getLocale()).format(date);</p>
<p>Section 120.3: String Comparison</p>
<p>Compare two Strings ignoring case:</p>
<p>"School".equalsIgnoreCase("school"); <em>// true</em></p>
<p>Don't use</p>
<p>text1.toLowerCase().equals(text2.toLowerCase());</p>
<p>Languages have different rules for converting upper and lower case. A
'I' would be converted to 'i' in English. But in</p>
<p>Turkish a 'I' becomes a 'ı'. If you have to use toLowerCase() use the
overload which expects a Locale: String.toLowerCase(Locale).</p>
<p>Comparing two Strings ignoring minor differences:</p>
<p>Collator collator = Collator.getInstance(Locale.GERMAN);
collator.setStrength(Collator.PRIMARY);</p>
<p>collator.equals("Gärten", "gaerten"); <em>// returns true</em></p>
<p>Sort Strings respecting natural language order, ignoring case (use
collation key to:</p>
<p>String[] texts = <strong>new</strong> String[] {"Birne", "äther",
"Apfel"}; Collator collator = Collator.getInstance(Locale.GERMAN);
collator.setStrength(Collator.SECONDARY); <em>// ignore case</em>
Arrays.sort(texts, collator::compare); <em>// will return {"Apfel",
"</em>ä<em>ther", "Birne"}</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 655</p>
<p><span id="Chapter_121__Parallel_programmin_1"
class="anchor"></span>Chapter 121: Parallel programming with</p>
<p>Fork/Join framework</p>
<p>Section 121.1: Fork/Join Tasks in Java</p>
<p>The fork/join framework in Java is ideal for a problem that can be
divided into smaller pieces and solved in parallel. The fundamental
steps of a fork/join problem are:</p>
<p>Divide the problem into multiple pieces</p>
<p>Solve each of the pieces in parallel to each other</p>
<p>Combine each of the sub-solutions into one overall solution</p>
<p>A <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a>
is the interface that defines such a problem. It is generally expected
that you will subclass one of its</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html">abstract
implementations (usually the RecursiveTask) rather than implement the
interface directly.</a></p>
<p>In this example, we are going to sum a collection of integers,
dividing until we get to batch sizes of no more than</p>
<p>ten.</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.concurrent.RecursiveTask;</p>
<p><strong>public class</strong> SummingTask <strong>extends</strong>
RecursiveTask {</p>
<p>private static final int <strong>MAX_BATCH_SIZE = 10;</strong></p>
<p>private final <strong>List numbers;</strong></p>
<p><strong>private final int</strong> minInclusive, maxExclusive;</p>
<p><strong>public</strong> SummingTask(List numbers) {</p>
<p><strong>this</strong>(numbers, 0, numbers.size());</p>
<p>}</p>
<p>// This constructor is only used internally as part of the dividing
process <em><strong>private</strong> SummingTask(List numbers,
<strong>int</strong> minInclusive, <strong>int</strong> maxExclusive)
{</em></p>
<p><strong>this</strong>.numbers = numbers;</p>
<p><strong>this</strong>.minInclusive = minInclusive;</p>
<p><strong>this</strong>.maxExclusive = maxExclusive;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Integer compute() {</p>
<p><strong>if</strong> (maxExclusive - minInclusive &gt; MAX_BATCH_SIZE)
{</p>
<p>// This is too big for a single batch, so we shall divide into two
tasks <em><strong>int</strong> mid = (minInclusive + maxExclusive) /
2;</em></p>
<p>SummingTask leftTask = <strong>new</strong> SummingTask(numbers,
minInclusive, mid);</p>
<p>SummingTask rightTask = <strong>new</strong> SummingTask(numbers,
mid, maxExclusive);</p>
<p>// Submit the left hand task as a new task to the same
ForkJoinPool</p>
<p>leftTask.fork();</p>
<p>// Run the right hand task on the same thread and get the result
<em><strong>int</strong> rightResult = rightTask.compute();</em></p>
<p>// Wait for the left hand task to complete and get its result
<em><strong>int</strong> leftResult = leftTask.join();</em></p>
<p>// And combine the result</p>
<p><strong>return</strong> leftResult + rightResult;</p>
<p>} <strong>else</strong> {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 656</p>
<p>// This is fine for a single batch, so we will run it here and now
<em><strong>int</strong> sum = 0;</em></p>
<p><strong>for</strong> (<strong>int</strong> i = minInclusive; i &lt;
maxExclusive; i++) {</p>
<p>sum += numbers.get(i);</p>
<p>}</p>
<p>return <strong>sum;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">An
instance of this task can now be passed to an instance of
ForkJoinPool.</a></p>
<p>// Because I am not specifying the number of threads // it will
create a thread for each available processor <em>ForkJoinPool pool =
<strong>new</strong> ForkJoinPool();</em></p>
<p>// Submit the task to the pool, and get what is effectively the
Future <em>ForkJoinTask task = pool.submit(<strong>new</strong>
SummingTask(numbers));</em></p>
<p>// Wait for the result</p>
<p><strong>int</strong> result = task.join();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 657</p>
<p><span id="Chapter_122__Non_Access_Modifier_1"
class="anchor"></span>Chapter 122: Non-Access Modifiers</p>
<p>Non-Access Modifiers <em><strong>do not change the accessibility of
variables</strong></em> and methods, but they do provide them
<em><strong>special</strong></em></p>
<p>properties<em><strong>.</strong></em></p>
<p>Section 122.1: final</p>
<p><strong>final</strong> in Java can refer to variables, methods and
classes. There are three simple rules:</p>
<p>final variable cannot be reassigned</p>
<p>final method cannot be overridden</p>
<p>final class cannot be extended</p>
<p>Usages</p>
<p>Good Programming Practice</p>
<p>Some developer consider it good practice to mark a variable final
when you can. If you have a variable that should not be changed, you
should mark it final.</p>
<p>An important use of <strong>final</strong> keyword if for method
parameters. If you want to emphasize that a method doesn't</p>
<p>change its input parameters, mark the properties as final.</p>
<p>public int <strong>sumup(</strong>final <strong>List
ints);</strong></p>
<p>This emphasizes that the sumup method is not going to change the
ints.</p>
<p>Inner class Access</p>
<p>If your anonymous inner class wants to access a variable, the
variable should be marked <strong>final</strong></p>
<p><strong>public</strong> IPrintName printName(){</p>
<p>String name;</p>
<p><strong>return new</strong> IPrintName(){</p>
<p>@Override</p>
<p><strong>public void</strong> printName(){</p>
<p>System.out.println(name);</p>
<p>}</p>
<p>};</p>
<p>}</p>
<p>This class doesn't compile, as the variable name, is not final.</p>
<p>Version ≥ Java SE 8</p>
<p>Effectively final variables are an exception. These are local
variables that are written to only once and could</p>
<p>therefore be made final. Effectively final variables can be accessed
from anonymus classes too.</p>
<p>final static variable</p>
<p>Even though the code below is completely legal when
<strong>final</strong> variable foo is not <strong>static</strong>, in
case of <strong>static</strong> it will not compile:</p>
<p><strong>class</strong> TestFinal {</p>
<p>private final static <strong>List foo;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 658</p>
<p><span id="public_Test" class="anchor"></span><strong>public</strong>
Test() {</p>
<p>foo = <strong>new</strong> ArrayList();</p>
<p>}</p>
<p>}</p>
<p>The reason is, let's repeat again, <em>final variable cannot be
reassigned</em>. Since foo is static, it is shared among all</p>
<p>instances of class TestFinal. When a new instance of a class
TestFinal is created, its constructor is invoked and therefore foo gets
reassigned which compiler does not allow. A correct way to initialize
variable foo in this case is</p>
<p>either:</p>
<p><strong>class</strong> TestFinal {</p>
<p><strong>private static final</strong> List foo = <strong>new</strong>
ArrayList();</p>
<p>//..</p>
<p>}</p>
<p>or by using a static initializer:</p>
<p><strong>class</strong> TestFinal {</p>
<p>private static final <strong>List foo;</strong></p>
<p>static <strong>{</strong></p>
<p>foo = <strong>new</strong> ArrayList();</p>
<p>}</p>
<p>//..</p>
<p>}</p>
<p><strong>final</strong> methods are useful when base class implements
some important functionality that derived class is not supposed to
change it. They are also faster than non-final methods, because there is
no concept of virtual table</p>
<p>involved.</p>
<p>All wrapper classes in Java are final, such as Integer, Long etc.
Creators of these classes didn't want that anyone</p>
<p>can e.g. extend Integer into his own class and change the basic
behavior of Integer class. One of the requirements to make a class
immutable is that subclasses may not override methods. The simplest way
to do this is to declare</p>
<p>the class as <strong>final</strong>.</p>
<p>Section 122.2: static</p>
<p>The <strong>static</strong> keyword is used on a class, method, or
field to make them work independently of any instance of the</p>
<p>class.</p>
<p>Static fields are common to all instances of a class. They do not
need an instance to access them.</p>
<p>Static methods can be run without an instance of the class they are
in. However, they can only access static fields of that class.</p>
<p>Static classes can be declared inside of other classes. They do not
need an instance of the class they are in to be instantiated.</p>
<p>public class <strong>TestStatic</strong></p>
<p>{</p>
<p><strong>static int</strong> staticVariable;</p>
<p>static <strong>{</strong></p>
<p>// This block of code is run when the class first loads</p>
<p>staticVariable = 11;</p>
<p>}</p>
<p><strong>int</strong> nonStaticVariable = 5;</p>
<p><strong>static void</strong> doSomething() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 659</p>
<p><span id="___We_can_access_static_variable" class="anchor"></span>//
We can access static variables from static methods</p>
<p>staticVariable = 10;</p>
<p>}</p>
<p><strong>void</strong> add() {</p>
<p>// We can access both static and non-static variables from non-static
methods</p>
<p>nonStaticVariable += staticVariable;</p>
<p>}</p>
<p><strong>static class</strong> StaticInnerClass {</p>
<p><strong>int</strong> number;</p>
<p><strong>public</strong> StaticInnerClass(<strong>int</strong>
_number) {</p>
<p>number = _number;</p>
<p>}</p>
<p><strong>void</strong> doSomething() {</p>
<p>// We can access number and staticVariable, but not
nonStaticVariable</p>
<p>number += staticVariable;</p>
<p>}</p>
<p><strong>int</strong> getNumber() {</p>
<p><strong>return</strong> number;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Static fields and methods</p>
<p>TestStatic object1 = <strong>new</strong> TestStatic();</p>
<p>System.out.println(object1.staticVariable); <em>// 11</em></p>
<p>System.out.println(TestStatic.staticVariable); <em>// 11</em></p>
<p>TestStatic.doSomething();</p>
<p>TestStatic object2 = <strong>new</strong> TestStatic();</p>
<p>System.out.println(object1.staticVariable); <em>// 10</em></p>
<p>System.out.println(object2.staticVariable); <em>// 10</em></p>
<p>System.out.println(TestStatic.staticVariable); <em>// 10</em></p>
<p>object1.add();</p>
<p>System.out.println(object1.nonStaticVariable); <em>// 15</em>
System.out.println(object2.nonStaticVariable); <em>// 10</em></p>
<p>// Static inner classes</p>
<p>StaticInnerClass object3 = <strong>new</strong>
TestStatic.StaticInnerClass(100); StaticInnerClass object4 =
<strong>new</strong> TestStatic.StaticInnerClass(200);</p>
<p>System.out.println(object3.getNumber()); <em>// 100</em></p>
<p>System.out.println(object4.getNumber()); <em>// 200</em></p>
<p>object3.doSomething();</p>
<p>System.out.println(object3.getNumber()); <em>// 110</em></p>
<p>System.out.println(object4.getNumber()); <em>// 200</em></p>
<p>Section 122.3: abstract</p>
<p>Abstraction is a process of hiding the implementation details and
showing only functionality to the user. An abstract</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 660</p>
<p><span id="class_can_never_be_instantiated"
class="anchor"></span>class can never be instantiated. If a class is
declared as abstract then the sole purpose is for the class to be
extended.</p>
<p>abstract class <strong>Car</strong></p>
<p>{</p>
<p>abstract void <strong>tagLine();</strong></p>
<p>}</p>
<p>class <strong>Honda</strong> extends <strong>Car</strong></p>
<p>{</p>
<p><strong>void</strong> tagLine()</p>
<p>{</p>
<p>System.out.println("Start Something Special");</p>
<p>}</p>
<p>}</p>
<p>class <strong>Toyota</strong> extends <strong>Car</strong></p>
<p>{</p>
<p><strong>void</strong> tagLine()</p>
<p>{</p>
<p>System.out.println("Drive Your Dreams");</p>
<p>}</p>
<p>}</p>
<p>Section 122.4: strictfp</p>
<p>Version ≥ Java SE 1.2</p>
<p>strictfp modifier is used for floating-point calculations. This
modifier makes floating point variable more consistent</p>
<p>across multiple platforms and ensure all the floating point
calculations are done according to IEEE 754 standards to avoid errors of
calculation (round-off errors), overflows and underflows on both 32bit
and 64bit architecture. This</p>
<p>cannot be applied on abstract methods, variables or constructors.</p>
<p>// strictfp keyword can be applied on methods, classes and
interfaces.</p>
<p>strictfp class <strong>A{}</strong></p>
<p>strictfp interface <strong>M{}</strong></p>
<p>class <strong>A{</strong></p>
<p>strictfp void <strong>m(){}</strong></p>
<p>}</p>
<p>Section 122.5: volatile</p>
<p>The <strong>volatile</strong> modifier is used in multi threaded
programming. If you declare a field as <strong>volatile</strong> it is a
signal to</p>
<p>threads that they must read the most recent value, not a locally
cached one. Furthermore, <strong>volatile</strong> reads and writes are
guaranteed to be atomic (access to a non-<strong>volatile long</strong>
or <strong>double</strong> is not atomic), thus avoiding certain</p>
<p>read/write errors between multiple threads.</p>
<p>public class <strong>MyRunnable</strong> implements
<strong>Runnable</strong></p>
<p>{</p>
<p>private volatile boolean <strong>active;</strong></p>
<p><em><strong>public void</strong> run(){</em> // run is called in one
thread</p>
<p>active = <strong>true</strong>;</p>
<p><strong>while</strong> (active){</p>
<p>// some code here</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 661</p>
<p><span id="_46" class="anchor"></span>}</p>
<p>}</p>
<p><em><strong>public void</strong> stop(){</em> // stop() is called
from another thread <em>active = <strong>false</strong>;</em></p>
<p>}</p>
<p>}</p>
<p>Section 122.6: synchronized</p>
<p>Synchronized modifier is used to control the access of a particular
method or a block by multiple threads. Only one thread can enter into a
method or a block which is declared as synchronized. synchronized
keyword works on</p>
<p>intrinsic lock of an object, in case of a synchronized method current
objects lock and static method uses class object. Any thread trying to
execute a synchronized block must acquire the object lock first.</p>
<p><strong>class</strong> Shared</p>
<p>{</p>
<p>int <strong>i;</strong></p>
<p>synchronized void <strong>SharedMethod()</strong></p>
<p>{</p>
<p>Thread t = Thread.currentThread();</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt;= 1000;
i++)</p>
<p>{</p>
<p>System.out.println(t.getName()+" : "+i);</p>
<p>}</p>
<p>}</p>
<p><strong>void</strong> SharedMethod2()</p>
<p>{</p>
<p>synchronized <strong>(</strong>this<strong>)</strong></p>
<p>{</p>
<p>System.out.println("Thais access to currect object is synchronize
"+<strong>this</strong>);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> ThreadsInJava</p>
<p>{</p>
<p><strong>public static void</strong> main(String[] args)</p>
<p>{</p>
<p><strong>final</strong> Shared s1 = <strong>new</strong> Shared();</p>
<p>Thread t1 = <strong>new</strong> Thread("Thread - 1")</p>
<p>{</p>
<p>@Override</p>
<p>public void <strong>run()</strong></p>
<p>{</p>
<p>s1.SharedMethod();</p>
<p>}</p>
<p>};</p>
<p>Thread t2 = <strong>new</strong> Thread("Thread - 2")</p>
<p>{</p>
<p>@Override</p>
<p>public void <strong>run()</strong></p>
<p>{</p>
<p>s1.SharedMethod();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 662</p>
<p><span id="_47" class="anchor"></span>};</p>
<p>t1.start();</p>
<p>t2.start();</p>
<p>}</p>
<p>}</p>
<p>Section 122.7: transient</p>
<p>A variable which is declared as transient will not be serialized
during object serialization.</p>
<p>public transient int <strong>limit = 55; <em>// will not
persist</em></strong></p>
<p><em><strong>public int</strong> b;</em> // will persist</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 663</p>
<p><span id="Chapter_123__Process_1" class="anchor"></span>Chapter 123:
Process</p>
<p>Section 123.1: Pitfall: Runtime.exec, Process and</p>
<p>ProcessBuilder don't understand shell syntax</p>
<p>The Runtime.exec(String ...) and Runtime.exec(String) methods allow
you to execute a command as an</p>
<p>external process1. In the first version, you supply the command name
and the command arguments as separate elements of the string array, and
the Java runtime requests the OS runtime system to start the external
command.</p>
<p>The second version is deceptively easy to use, but it has some
pitfalls.</p>
<p>First of all, here is an example of using exec(String) being used
safely:</p>
<p>Process p = Runtime.exec("mkdir /tmp/testDir");</p>
<p>p.waitFor();</p>
<p><strong>if</strong> (p.exitValue() == 0) {</p>
<p>System.out.println("created the directory");</p>
<p>}</p>
<p>Spaces in pathnames</p>
<p>Suppose that we generalize the example above so that we can create an
arbitrary directory:</p>
<p>Process p = Runtime.exec("mkdir " + dirPath);</p>
<p>// ...</p>
<p>This will typically work, but it will fail if dirPath is (for
example) "/home/user/My Documents". The problem is that exec(String)
splits the string into a command and arguments by simply looking for
whitespace. The command</p>
<p>string:</p>
<p>"mkdir /home/user/My Documents"</p>
<p>will be split into:</p>
<p>"mkdir", "/home/user/My", "Documents"</p>
<p>and this will cause the "mkdir" command to fail because it expects
one argument, not two.</p>
<p>Faced with this, some programmers try to add quotes around the
pathname. This doesn't work either:</p>
<p>"mkdir <strong>\"</strong>/home/user/My
Documents<strong>\"</strong>"</p>
<p>will be split into:</p>
<p>"mkdir", "<strong>\"</strong>/home/user/My",
"Documents<strong>\"</strong>"</p>
<p>The extra double-quote characters that were added in attempt to
"quote" the spaces are treated like any other non-whitespace characters.
Indeed, anything we do quote or escape the spaces is going to fail.</p>
<p>The way to deal with this particular problems is to use the
exec(String ...) overload.</p>
<p>Process p = Runtime.exec("mkdir", dirPath);</p>
<p>// ...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 664</p>
<p>This will work if dirpath includes whitespace characters because this
overload of exec does not attempt to split the arguments. The strings
are passed through to the OS exec system call as-is.</p>
<p>Redirection, pipelines and other shell syntax</p>
<p>Suppose that we want to redirect an external command's input or
output, or run a pipeline. For example:</p>
<p>Process p = Runtime.exec("find / -name *.java -print
2&gt;/dev/null");</p>
<p>or</p>
<p>Process p = Runtime.exec("find source -name *.java | xargs grep
package");</p>
<p>(The first example lists the names of all Java files in the file
system, and the second one prints the <strong>package</strong>
statements2 in the Java files in the "source" tree.)</p>
<p>These are not going to work as expected. In the first case, the
"find" command will be run with "2&gt;/dev/null" as a command argument.
It will not be interpreted as a redirection. In the second example, the
pipe character ("|") and</p>
<p>the works following it will be given to the "find" command.</p>
<p>The problem here is that the exec methods and ProcessBuilder do not
understand any shell syntax. This includes</p>
<p>redirections, pipelines, variable expansion, globbing, and so on.</p>
<p>In a few cases (for example, simple redirection) you can easily
achieve the desired effect using ProcessBuilder. However, this is not
true in general. An alternative approach is to run the command line in a
shell; for example:</p>
<p>Process p = Runtime.exec("bash", "-c",</p>
<p>"find / -name *.java -print 2&gt;/dev/null");</p>
<p>or</p>
<p>Process p = Runtime.exec("bash", "-c",</p>
<p>"find source -name <strong>\\</strong>*.java | xargs grep
package");</p>
<p>But note that in the second example, we needed to escape the wildcard
character ("*") because we want the</p>
<p>wildcard to be interpreted by "find" rather than the shell.</p>
<p>Shell builtin commands don't work</p>
<p>Suppose the following examples won't work on a system with a
UNIX-like shell:</p>
<p>Process p = Runtime.exec("cd", "/tmp"); <em>// Change java app's home
directory</em></p>
<p>or</p>
<p>Process p = Runtime.exec("export", "NAME=value"); <em>// Export NAME
to the java app's environment</em></p>
<p>There are a couple of reasons why this won't work:</p>
<p>1. On "cd" and "export" commands are shell builtin commands. They
don't exist as distinct executables.</p>
<p>2. For shell builtins to do what they are supposed to do (e.g. change
the working directory, update the</p>
<p>environment), they need to change the place where that state resides.
For a normal application (including a Java application) the state is
associated with the application process. So for example, the child
process that</p>
<p>would run the "cd" command could not change the working directory of
its parent "java" process. Similarly,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 665</p>
<p><span id="one_exec_d_process_cannot_change" class="anchor"></span>one
exec'd process cannot change the working directory for a process that
follows it.</p>
<p>This reasoning applies to all shell builtin commands.</p>
<p>1 - You can use ProcessBuilder as well, but that is not relevant to
the point of this example.</p>
<p>2 - This is a bit rough and ready ... but once again, the failings of
this approach are not relevant to the example.</p>
<p>Section 123.2: Simple example (Java version &lt; 1.5)</p>
<p>This example will call the windows calculator. It's important to
notice that the exit code will vary accordingly to the program/script
that is being called.</p>
<p><strong>package</strong> process.example;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p>public class <strong>App {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>// Executes windows calculator</p>
<p>Process p = Runtime.getRuntime().exec("calc.exe");</p>
<p>// Wait for process until it terminates</p>
<p><strong>int</strong> exitCode = p.waitFor();</p>
<p>System.out.println(exitCode);</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 666</p>
<p><span id="Chapter_124__Java_Native_Access_1"
class="anchor"></span>Chapter 124: Java Native Access</p>
<p>Section 124.1: Introduction to JNA</p>
<p>What is JNA?</p>
<p>Java Native Access (JNA) is a community-developed library providing
Java programs an easy access to native shared libraries (.dll files on
windows, .so files on Unix ...)</p>
<p>How can I use it?</p>
<p>Firstly, download the <a
href="https://mvnrepository.com/artifact/net.java.dev.jna/jna">latest
release of JNA</a> and reference its jna.jar in your project's
CLASSPATH.</p>
<p>Secondly, copy, compile and run the Java code below</p>
<p>For the purpose of this introduction, we suppose the native platform
in use is Windows. If you're running on another platform simply replace
the string "msvcrt" with the string "c" in the code below.</p>
<p>The small Java program below will print a message on the console by
calling the C printf function.</p>
<p>CRuntimeLibrary.java</p>
<p><strong>package</strong> jna.introduction;</p>
<p><strong>import</strong> com.sun.jna.Library;</p>
<p><strong>import</strong> com.sun.jna.Native;</p>
<p>// We declare the printf function we need and the library containing
it (msvcrt)... <em><strong>public interface</strong> CRuntimeLibrary
<strong>extends</strong> Library {</em></p>
<p>CRuntimeLibrary INSTANCE =</p>
<p>(CRuntimeLibrary) <strong>Native</strong>.loadLibrary("msvcrt",
CRuntimeLibrary.<strong>class</strong>);</p>
<p><strong>void</strong> printf(String format, Object... args);</p>
<p>}</p>
<p>MyFirstJNAProgram.java</p>
<p><strong>package</strong> jna.introduction;</p>
<p>// Now we call the printf function...</p>
<p><strong>public class</strong> MyFirstJNAProgram {</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>CRuntimeLibrary.INSTANCE.printf("Hello World from JNA !");</p>
<p>}</p>
<p>}</p>
<p>Where to go now?</p>
<p><a href="https://github.com/java-native-access/jna">Jump into another
topic here or jump to the official site.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 667</p>
<p><span id="Chapter_125__Modules_1" class="anchor"></span>Chapter 125:
Modules</p>
<p>Section 125.1: Defining a basic module</p>
<p>Modules are defined in a file named module-info.java, named a module
descriptor. It should be placed in the source-code root:</p>
<p>|-- module-info.java</p>
<p>|-- com</p>
<p>|-- example</p>
<p>|-- foo</p>
<p>|-- Foo.java</p>
<p>|-- bar</p>
<p>|-- Bar.java</p>
<p>Here is a simple module descriptor:</p>
<p>module com.example {</p>
<p>requires java.httpclient;</p>
<p>exports com.example.foo;</p>
<p>}</p>
<p><a
href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">The
module name should be unique and it is recommended that you use the same
Reverse-DNS naming notation</a></p>
<p>as used by packages to help ensure this.</p>
<p>The module java.base, which contains Java's basic classes, is
implicitly visible to any module and does not need to</p>
<p>be included.</p>
<p>The requires declaration allows us to use other modules, in the
example the module java.httpclient is imported.</p>
<p>A module can also specify which packages it exports and therefore
makes it visible to other modules.</p>
<p>The package com.example.foo declared in the exports clause will be
visible to other modules. Any sub-packages of com.example.foo will not
be exported, they need their own export declarations.</p>
<p>Conversely, com.example.bar which is not listed in exports clauses
will not be visible to other modules.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 668</p>
<p><span id="Chapter_126__Concurrent_Programm_1"
class="anchor"></span>Chapter 126: Concurrent Programming</p>
<p>(Threads)</p>
<p>Concurrent computing is a form of computing in which several
computations are executed concurrently instead of</p>
<p><a
href="https://en.wikipedia.org/wiki/Java_concurrency">sequentially. Java
language is designed to support concurrent programming</a> through the
usage of threads. Objects and resources can be accessed by multiple
threads; each thread can potentially access any object in the
program</p>
<p>and the programmer must ensure read and write access to objects is
properly synchronized between threads.</p>
<p>Section 126.1: Callable and Future</p>
<p>While Runnable provides a means to wrap code to be executed in a
different thread, it has a limitation in that it</p>
<p>cannot return a result from the execution. The only way to get some
return value from the execution of a Runnable is to assign the result to
a variable accessible in a scope outside of the Runnable.</p>
<p>Callable was introduced in Java 5 as a peer to Runnable. Callable is
essentially the same except it has a call method instead of run. The
call method has the additional capability to return a result and is also
allowed to throw</p>
<p>checked exceptions.</p>
<p>The result from a <em>Callable task submission</em> is available to
be tapped via a Future</p>
<p>Future can be considered a container of sorts that houses the result
of the Callable computation. Computation of</p>
<p>the callable can carry on in another thread, and any attempt to tap
the result of a Future will block and will only return the result once
it is available.</p>
<p>Callable Interface</p>
<p>public interface <strong>Callable {</strong></p>
<p>V call() <strong>throws</strong> Exception;</p>
<p>}</p>
<p>Future</p>
<p>interface <strong>Future {</strong></p>
<p>V get();</p>
<p>V get(<strong>long</strong> timeout, TimeUnit unit);</p>
<p><strong>boolean</strong> cancel(<strong>boolean</strong>
mayInterruptIfRunning);</p>
<p><strong>boolean</strong> isCancelled();</p>
<p><strong>boolean</strong> isDone();</p>
<p>}</p>
<p>Using Callable and Future example:</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>ExecutorService es = Executors.newSingleThreadExecutor();</p>
<p>System.out.println("Time At Task Submission : " +
<strong>new</strong> Date());</p>
<p>Future result = es.submit(<strong>new</strong>
ComplexCalculator());</p>
<p>// the call to Future.get() blocks until the result is available.So
we are in for about a 10 sec</p>
<p>wait now</p>
<p>System.out.println("Result of Complex Calculation is : " +
result.get()); System.out.println("Time At the Point of Printing the
Result : " + <strong>new</strong> Date());</p>
<p>}</p>
<p>Our Callable that does a lengthy computation</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 669</p>
<p><span id="public_class_ComplexCalculator_i"
class="anchor"></span><strong>public class</strong> ComplexCalculator
<strong>implements</strong> Callable {</p>
<p>@Override</p>
<p><strong>public</strong> String call() <strong>throws</strong>
Exception {</p>
<p>// just sleep for 10 secs to simulate a lengthy computation
<em>Thread.sleep(10000);</em></p>
<p>System.out.println("Result after a lengthy 10sec calculation");
<strong>return</strong> "Complex Result"; <em>// the result</em></p>
<p>}</p>
<p>}</p>
<p>Output</p>
<p>Time At Task Submission : Thu Aug 04 15:05:15 EDT 2016 Result after a
lengthy 10sec calculation</p>
<p>Result of Complex Calculation is : Complex Result</p>
<p>Time At the Point of Printing the Result : Thu Aug 04 15:05:25 EDT
2016</p>
<p>Other operations permitted on Future</p>
<p>While get() is the method to extract the actual result Future has
provision</p>
<p>get(<strong>long</strong> timeout, TimeUnit unit) defines maximum
time period during current thread will wait for a</p>
<p>result;</p>
<p>To cancel the task call cancel(mayInterruptIfRunning). The flag
mayInterrupt indicates that task should be</p>
<p>interrupted if it was started and is running right now;</p>
<p>To check if task is completed/finished by calling isDone(); To check
if the lengthy task were cancelled isCancelled().</p>
<p>Section 126.2: CountDownLatch</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a></p>
<p>A synchronization aid that allows one or more threads to wait until a
set of operations being performed in other threads completes.</p>
<p>1. A CountDownLatch is initialized with a given count.</p>
<p>2. The await methods block until the current count reaches zero due
to invocations of the countDown() method,</p>
<p>after which all waiting threads are released and any subsequent
invocations of await return immediately.</p>
<p>3. This is a one-shot phenomenon—the count cannot be reset. If you
need a version that resets the count,</p>
<p>consider using a CyclicBarrier.</p>
<p>Key Methods:</p>
<p><strong>public void</strong> await() <strong>throws</strong>
InterruptedException</p>
<p>Causes the current thread to wait until the latch has counted down to
zero, unless the thread is interrupted.</p>
<p><strong>public void</strong> countDown()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 670</p>
<p>Decrements the count of the latch, releasing all waiting threads if
the count reaches zero.</p>
<p>Example:</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p><strong>class</strong> DoSomethingInAThread
<strong>implements</strong> Runnable {</p>
<p>CountDownLatch latch;</p>
<p><strong>public</strong> DoSomethingInAThread(CountDownLatch latch)
{</p>
<p><strong>this</strong>.latch = latch;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p>System.out.println("Do some thing");</p>
<p>latch.countDown();</p>
<p>} <strong>catch</strong>(Exception err) {</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> CountDownLatchDemo {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> numberOfThreads = 5;</p>
<p><strong>if</strong> (args.length &lt; 1) {</p>
<p>System.out.println("Usage: java CountDownLatchDemo numberOfThreads");
<strong>return</strong>;</p>
<p>}</p>
<p>try <strong>{</strong></p>
<p>numberOfThreads = Integer.parseInt(args[0]);</p>
<p>} <strong>catch</strong>(NumberFormatException ne) {</p>
<p>}</p>
<p>CountDownLatch latch = <strong>new</strong>
CountDownLatch(numberOfThreads);</p>
<p><strong>for</strong> (<strong>int</strong> n = 0; n &lt;
numberOfThreads; n++) {</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
DoSomethingInAThread(latch));</p>
<p>t.start();</p>
<p>}</p>
<p>latch.await();</p>
<p>System.out.println("In Main thread after completion of " +
numberOfThreads + "</p>
<p>threads");</p>
<p>} <strong>catch</strong>(Exception err) {</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>output:</p>
<p>java CountDownLatchDemo 5</p>
<p>Do some thing</p>
<p>Do some thing</p>
<p>Do some thing</p>
<p>Do some thing</p>
<p>Do some thing</p>
<p>In Main thread after completion of 5 threads</p>
<p>Explanation:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 671</p>
<p><span id="1__CountDownLatch_is_initialized" class="anchor"></span>1.
CountDownLatch is initialized with a counter of 5 in Main thread 2. Main
thread is waiting by using await() method.</p>
<p>3. Five instances of DoSomethingInAThread have been created. Each
instance decremented the counter with</p>
<p>countDown() method.</p>
<p>4. Once the counter becomes zero, Main thread will resume</p>
<p>Section 126.3: Basic Multithreading</p>
<p>If you have many tasks to execute, and all these tasks are not
dependent of the result of the precedent ones, you</p>
<p>can use <strong>Multithreading</strong> for your computer to do all
this tasks at the same time using more processors if your</p>
<p>computer can. This can make your program execution
<strong>faster</strong> if you have some big independent tasks.</p>
<p><strong>class</strong> CountAndPrint <strong>implements</strong>
Runnable {</p>
<p>private final <strong>String name;</strong></p>
<p>CountAndPrint(String name) {</p>
<p><strong>this</strong>.name = name;</p>
<p>}</p>
<p>/** This is what a CountAndPrint will do */</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10000; i++)
{</p>
<p>System.out.println(<strong>this</strong>.name + ": " + i);</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// Launching 4 parallel threads</p>
<p><strong>for</strong> (<strong>int</strong> i = 1; i &lt;= 4; i++)
{</p>
<p>// `start` method will call the `run` method</p>
<p>// of CountAndPrint in another thread</p>
<p><strong>new</strong> Thread(<strong>new</strong>
CountAndPrint("Instance " + i)).start();</p>
<p>}</p>
<p>// Doing some others tasks in the main Thread</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10000; i++)
{</p>
<p>System.out.println("Main: " + i);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The code of the run method of the various CountAndPrint instances
will execute in non predictable order. A snippet of a sample execution
might look like this:</p>
<p>Instance 4: 1</p>
<p>Instance 2: 1</p>
<p>Instance 4: 2</p>
<p>Instance 1: 1</p>
<p>Instance 1: 2</p>
<p>Main: 1</p>
<p>Instance 4: 3</p>
<p>Main: 2</p>
<p>Instance 3: 1</p>
<p>Instance 4: 4</p>
<p>...</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 672</p>
<p><span id="Section_126_4__Locks_as_Synchron"
class="anchor"></span>Section 126.4: Locks as Synchronisation aids</p>
<p>Prior to Java 5's concurrent package introduction threading was more
low level.The introduction of this package</p>
<p>provided several higher level concurrent programming
aids/constructs.</p>
<p>Locks are thread synchronisation mechanisms that essentially serve
the same purpose as synchronized blocks or</p>
<p>key words.</p>
<p>Intrinsic Locking</p>
<p><em><strong>int</strong> count = 0;</em> // shared among multiple
threads</p>
<p><strong>public void</strong> doSomething() {</p>
<p>synchronized<strong>(</strong>this<strong>) {</strong></p>
<p><em>++count;</em> // a non-atomic operation</p>
<p>}</p>
<p>}</p>
<p>Synchronisation using Locks</p>
<p><em><strong>int</strong> count = 0;</em> // shared among multiple
threads</p>
<p>Lock lockObj = <strong>new</strong> ReentrantLock();</p>
<p><strong>public void</strong> doSomething() {</p>
<p>try <strong>{</strong></p>
<p>lockObj.lock();</p>
<p><em>++count;</em> // a non-atomic operation</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><em>lockObj.unlock();</em> // sure to release the lock without
fail</p>
<p>}</p>
<p>}</p>
<p>Locks also have functionality available that intrinsic locking does
not offer, such as locking but remaining responsive</p>
<p>to interruption, or trying to lock, and not block when unable to.</p>
<p>Locking, responsive to interruption</p>
<p><strong>class</strong> Locky {</p>
<p><em><strong>int</strong> count = 0;</em> // shared among multiple
threads</p>
<p>Lock lockObj = <strong>new</strong> ReentrantLock();</p>
<p><strong>public void</strong> doSomething() {</p>
<p>try <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p>lockObj.lockInterruptibly();</p>
<p><em>++count;</em> // a non-atomic operation</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>Thread.currentThread().interrupt(); <em>// stopping</em></p>
<p>}</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (!Thread.currentThread().isInterrupted()) {</p>
<p><em>lockObj.unlock();</em> // sure to release the lock without
fail</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 673</p>
<p><span id="Only_do_something_when_able_to_l"
class="anchor"></span>Only do something when able to lock</p>
<p>public class <strong>Locky2 {</strong></p>
<p><em><strong>int</strong> count = 0;</em> // shared among multiple
threads</p>
<p>Lock lockObj = <strong>new</strong> ReentrantLock();</p>
<p><strong>public void</strong> doSomething() {</p>
<p><strong>boolean</strong> locked = lockObj.tryLock(); <em>// returns
true upon successful lock</em> <strong>if</strong> (locked) {</p>
<p>try <strong>{</strong></p>
<p><em>++count;</em> // a non-atomic operation</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><em>lockObj.unlock();</em> // sure to release the lock without
fail</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/package-summary.html">There
are several variants of lock available.For more details refer the api
docs here</a></p>
<p>Section 126.5: Semaphore</p>
<p>A Semaphore is a high-level synchronizer that maintains a set of
<em>permits</em> that can be acquired and released by threads. A
Semaphore can be imagined as a counter of <em>permits</em> that will be
decremented when a thread acquires,</p>
<p>and incremented when a thread releases. If the amount of
<em>permits</em> is 0 when a thread attempts to acquire, then the</p>
<p>thread will block until a permit is made available (or until the
thread is interrupted).</p>
<p>A semaphore is initialized as:</p>
<p><em>Semaphore semaphore = <strong>new</strong> Semaphore(1);</em> //
The int value being the number of permits</p>
<p>The Semaphore constructor accepts an additional boolean parameter for
fairness. When set false, this class makes no guarantees about the order
in which threads acquire permits. When fairness is set true, the
semaphore</p>
<p>guarantees that threads invoking any of the acquire methods are
selected to obtain permits in the order in which their invocation of
those methods was processed. It is declared in the following manner:</p>
<p>Semaphore semaphore = <strong>new</strong> Semaphore(1,
<strong>true</strong>);</p>
<p>Now let's look at an example from javadocs, where Semaphore is used
to control access to a pool of items. A Semaphore is used in this
example to provide blocking functionality in order to ensure that there
are always items</p>
<p>to be obtained when getItem() is called.</p>
<p><strong>class</strong> Pool {</p>
<p>/*</p>
<p>* Note that this DOES NOT bound the amount that may be released!</p>
<p>* This is only a starting value for the Semaphore and has no
other</p>
<p>* significant meaning UNLESS you enforce this inside of the</p>
<p>* getNextAvailableItem() and markAsUnused() methods</p>
<p>*/</p>
<p>private static final int <strong>MAX_AVAILABLE = 100;</strong></p>
<p><strong>private final</strong> Semaphore available =
<strong>new</strong> Semaphore(MAX_AVAILABLE,
<strong>true</strong>);</p>
<p>/**</p>
<p>* Obtains the next available item and reduces the permit count by
1.</p>
<p>* If there are no items available, block.</p>
<p>*/</p>
<p><strong>public</strong> Object getItem() <strong>throws</strong>
InterruptedException {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 674</p>
<p><span id="available_acquire"
class="anchor"></span>available.acquire();</p>
<p><strong>return</strong> getNextAvailableItem();</p>
<p>}</p>
<p>/**</p>
<p>* Puts the item into the pool and add 1 permit.</p>
<p>*/</p>
<p><strong>public void</strong> putItem(Object x) {</p>
<p><strong>if</strong> (markAsUnused(x))</p>
<p>available.release();</p>
<p>}</p>
<p><strong>private</strong> Object getNextAvailableItem() {</p>
<p>// Implementation</p>
<p>}</p>
<p><strong>private boolean</strong> markAsUnused(Object o) {</p>
<p>// Implementation</p>
<p>}</p>
<p>}</p>
<p>Section 126.6: Synchronization</p>
<p>In Java, there is a built-in language-level locking mechanism: the
<strong>synchronized</strong> block, which can use any Java object as an
intrinsic lock (i.e. every Java object may have a monitor associated
with it).</p>
<p>Intrinsic locks provide atomicity to groups of statements. To
understand what that means for us, let's have a look at an example where
<strong>synchronized</strong> is useful:</p>
<p>private static int <strong>t = 0;</strong></p>
<p><strong>private static</strong> Object mutex = <strong>new</strong>
Object();</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExecutorService executorService = Executors.newFixedThreadPool(400);
<em>// The high thread count is for demonstration purposes.</em></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100; i++)
{</p>
<p>executorService.execute(()-&gt; {</p>
<p>synchronized <strong>(mutex) {</strong></p>
<p>t++;</p>
<p>System.out.println(MessageFormat.format("t: {0}", t));</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>executorService.shutdown();</p>
<p>}</p>
<p>In this case, if it weren't for the <strong>synchronized</strong>
block, there would have been multiple concurrency issues involved.</p>
<p>The first one would be with the post increment operator (it isn't
atomic in itself), and the second would be that we would be observing
the value of t after an arbitrary amount of other threads has had the
chance to modify it.</p>
<p>However, since we acquired an intrinsic lock, there will be no race
conditions here and the output will contain numbers from 1 to 100 in
their normal order.</p>
<p>Intrinsic locks in Java are <em>mutexes</em> (i.e. mutual execution
locks). Mutual execution means that if one thread has acquired the lock,
the second will be forced to wait for the first one to release it before
it can acquire the lock for</p>
<p>itself. Note: An operation that may put the thread into the wait
(sleep) state is called a <em>blocking operation</em>. Thus, acquiring a
lock is a blocking operation.</p>
<p>Intrinsic locks in Java are <em>reentrant</em>. This means that if a
thread attempts to acquire a lock it already owns, it will not</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 675</p>
<p><span id="block_and_it_will_successfully_a"
class="anchor"></span>block and it will successfully acquire it. For
instance, the following code will <em>not</em> block when called:</p>
<p>public void <strong>bar(){</strong></p>
<p>synchronized<strong>(</strong>this<strong>){</strong></p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>public void <strong>foo(){</strong></p>
<p>synchronized<strong>(</strong>this<strong>){</strong></p>
<p>bar();</p>
<p>}</p>
<p>}</p>
<p>Beside <strong>synchronized</strong> blocks, there are also
<strong>synchronized</strong> methods.</p>
<p>The following blocks of code are practically equivalent (even though
the bytecode seems to be different):</p>
<p><strong>1.</strong> synchronized <strong>block on</strong>
this<strong>:</strong></p>
<p>public void <strong>foo() {</strong></p>
<p>synchronized<strong>(</strong>this<strong>) {</strong></p>
<p>doStuff();</p>
<p>}</p>
<p>}</p>
<p><strong>2.</strong> synchronized <strong>method:</strong></p>
<p>public synchronized void <strong>foo() {</strong></p>
<p>doStuff();</p>
<p>}</p>
<p>Likewise for <strong>static</strong> methods, this:</p>
<p><strong>class</strong> MyClass {</p>
<p>...</p>
<p>public static void <strong>bar() {</strong></p>
<p>synchronized<strong>(MyClass.</strong>class<strong>) {</strong></p>
<p>doSomeOtherStuff();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>has the same effect as this:</p>
<p><strong>class</strong> MyClass {</p>
<p>...</p>
<p>public static synchronized void <strong>bar() {</strong></p>
<p>doSomeOtherStuff();</p>
<p>}</p>
<p>}</p>
<p>Section 126.7: Runnable Object</p>
<p>The Runnable interface defines a single method, run(), meant to
contain the code executed in the thread.</p>
<p>The Runnable object is passed to the Thread constructor. And Thread's
start() method is called.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 676</p>
<p><span id="Example_1" class="anchor"></span>Example</p>
<p><strong>public class</strong> HelloRunnable
<strong>implements</strong> Runnable {</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>System.out.println("Hello from a thread");</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>new</strong> Thread(<strong>new</strong>
HelloRunnable()).start();</p>
<p>}</p>
<p>}</p>
<p>Example in Java8:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Runnable r = ()-&gt; System.out.println("Hello world");
<strong>new</strong> Thread(r).start();</p>
<p>}</p>
<p>Runnable vs Thread subclass</p>
<p>A Runnable object employment is more general, because the Runnable
object can subclass a class other than</p>
<p>Thread .</p>
<p>Thread subclassing is easier to use in simple applications, but is
limited by the fact that your task class must be a</p>
<p>descendant of Thread.</p>
<p>A Runnable object is applicable to the high-level thread management
APIs.</p>
<p>Section 126.8: Creating basic deadlocked system</p>
<p>A deadlock occurs when two competing actions wait for the other to
finish, and thus neither ever does. In java there</p>
<p>is one lock associated with each object. To avoid concurrent
modification done by multiple threads on single object</p>
<p>we can use <strong>synchronized</strong> keyword, but everything
comes at a cost. Using <strong>synchronized</strong> keyword wrongly can
lead to stuck systems called as deadlocked system.</p>
<p>Consider there are 2 threads working on 1 instance, Lets call threads
as First and Second, and lets say we have 2</p>
<p>resources R1 and R2. First acquires R1 and also needs R2 for its
completion while Second acquires R2 and needs R1</p>
<p>for completion.</p>
<p>so say at time t=0,</p>
<p>First has R1 and Second has R2. now First is waiting for R2 while
Second is waiting for R1. this wait is indefinite and</p>
<p>this leads to deadlock.</p>
<p>public class <strong>Example2 {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> InterruptedException {</p>
<p><strong>final</strong> DeadLock dl = <strong>new</strong>
DeadLock();</p>
<p>Thread t1 = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>// TODO Auto-generated method stub</p>
<p>dl.methodA();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 677</p>
<p>}</p>
<p>});</p>
<p>Thread t2 = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>// TODO Auto-generated method stub</p>
<p>try <strong>{</strong></p>
<p>dl.method2();</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>});</p>
<p>t1.setName("First");</p>
<p>t2.setName("Second");</p>
<p>t1.start();</p>
<p>t2.start();</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> DeadLock {</p>
<p>Object mLock1 = <strong>new</strong> Object();</p>
<p>Object mLock2 = <strong>new</strong> Object();</p>
<p><strong>public void</strong> methodA() {</p>
<p>System.out.println("methodA wait for mLock1 " +
Thread.currentThread().getName()); <strong>synchronized</strong>
(mLock1) {</p>
<p>System.out.println("methodA mLock1 acquired " +
Thread.currentThread().getName()); <strong>try</strong> {</p>
<p>Thread.sleep(100);</p>
<p>method2();</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// TODO Auto-generated catch block</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> method2() <strong>throws</strong>
InterruptedException {</p>
<p>System.out.println("method2 wait for mLock2 " +
Thread.currentThread().getName()); <strong>synchronized</strong>
(mLock2) {</p>
<p>System.out.println("method2 mLock2 acquired " +
Thread.currentThread().getName()); Thread.sleep(100);</p>
<p>method3();</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> method3() <strong>throws</strong>
InterruptedException {</p>
<p>System.out.println("method3 mLock1 "+
Thread.currentThread().getName()); <strong>synchronized</strong>
(mLock1) {</p>
<p>System.out.println("method3 mLock1 acquired " +
Thread.currentThread().getName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output of this program:</p>
<p>methodA wait for mLock1 First</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 678</p>
<p><span id="method2_wait_for_mLock2__Second"
class="anchor"></span>method2 wait for mLock2 Second</p>
<p>method2 mLock2 acquired Second</p>
<p>methodA mLock1 acquired First</p>
<p>method3 mLock1 Second</p>
<p>method2 wait for mLock2 First</p>
<p>Section 126.9: Creating a java.lang.Thread instance</p>
<p>There are two main approaches to creating a thread in Java. In
essence, creating a thread is as easy as writing the</p>
<p>code that will be executed in it. The two approaches differ in where
you define that code.</p>
<p>In Java, a thread is represented by an object - an instance of <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">java.lang.Thread
or its subclass. So the first approach is</a></p>
<p>to create that subclass and override the <em>run()</em> method.</p>
<p><strong>Note</strong>: I'll use <em>Thread</em> to refer to the <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">java.lang.Thread
class and</a> <em>thread</em> to refer to the logical concept of
threads.</p>
<p><strong>class</strong> MyThread <strong>extends</strong> Thread {</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)
{</p>
<p>System.out.println("Thread running!");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now since we've already defined the code to be executed, the thread
can be created simply as:</p>
<p>MyThread t = <strong>new</strong> MyThread();</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">The
Thread class also contains a constructor accepting a string, which will
be used as the thread's name. This can</a> be particulary useful when
debugging a multi thread program.</p>
<p><strong>class</strong> MyThread <strong>extends</strong> Thread {</p>
<p><strong>public</strong> MyThread(String name) {</p>
<p><strong>super</strong>(name);</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)
{</p>
<p>System.out.println("Thread running! ");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>MyThread t = <strong>new</strong> MyThread("Greeting Producer");</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">The
second approach is to define the code using java.lang.Runnable</a> and
its only method <em>run()</em>. The <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread
class</a></p>
<p>then allows you to execute that method in a separated thread. To
achieve this, create the thread using a</p>
<p>constructor accepting an instance of the <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>
interface.</p>
<p>Thread t = <strong>new</strong> Thread(aRunnable);</p>
<p>This can be very powerful when combined with lambdas or methods
references (Java 8 only):</p>
<p>Thread t = <strong>new</strong> Thread(operator::hardWork);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 679</p>
<p><span id="You_can_specify_the_thread_s_nam" class="anchor"></span>You
can specify the thread's name, too.</p>
<p>Thread t = <strong>new</strong> Thread(operator::hardWork, "Pi
operator");</p>
<p><a
href="http://stackoverflow.com/questions/541487/implements-runnable-vs-extends-thread">Practicaly
speaking, you can use both approaches without worries. However the
general wisdom</a> says to use the latter.</p>
<p>For every of the four mentioned constructors, there is also an
alternative accepting an instance of</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadGroup.html">java.lang.ThreadGroup</a>
as the first parameter.</p>
<p>ThreadGroup tg = <strong>new</strong> ThreadGroup("Operators");</p>
<p>Thread t = <strong>new</strong> Thread(tg, operator::hardWork, "PI
operator");</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadGroup.html">The
ThreadGroup</a> represents a set of threads. You can only add a <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread
to a ThreadGroup using a Thread</a>'s</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadGroup.html">constructor.
The ThreadGroup</a> can then be used to manage all its <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Threads
together, as well as the Thread can gain</a></p>
<p>information from its <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadGroup.html">ThreadGroup.</a></p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">So
to sumarize, the Thread can be created with one of these public
constructors:</a></p>
<p>Thread()</p>
<p>Thread(String name)</p>
<p>Thread(Runnable target)</p>
<p>Thread(Runnable target, String name)</p>
<p>Thread(ThreadGroup group, String name)</p>
<p>Thread(ThreadGroup group, Runnable target)</p>
<p>Thread(ThreadGroup group, Runnable target, String name)
Thread(ThreadGroup group, Runnable target, String name,
<strong>long</strong> stackSize)</p>
<p>The last one allows us to define desired stack size for the new
thread.</p>
<p>Often the code readability suffers when creating and configuring many
Threads with same properties or from the</p>
<p>same pattern. That's when <a
href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadFactory.html">java.util.concurrent.ThreadFactory
can be used. This interface allows you to encapsulate</a></p>
<p>the procedure of creating the thread through the factory pattern and
its only method <em>newThread(Runnable)</em>.</p>
<p><strong>class</strong> WorkerFactory <strong>implements</strong>
ThreadFactory {</p>
<p>private int <strong>id = 0;</strong></p>
<p>@Override</p>
<p><strong>public</strong> Thread newThread(Runnable r) {</p>
<p><strong>return new</strong> Thread(r, "Worker " + id++);</p>
<p>}</p>
<p>}</p>
<p>Section 126.10: Atomic operations</p>
<p>An atomic operation is an operation that is executed "all at once",
without any chance of other threads observing or modifying state during
the atomic operation's execution.</p>
<p>Lets consider a <strong>BAD EXAMPLE</strong>.</p>
<p>private static int <strong>t = 0;</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExecutorService executorService = Executors.newFixedThreadPool(400);
<em>// The high thread count is for demonstration purposes.</em></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100; i++)
{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 680</p>
<p><span id="executorService_execute"
class="anchor"></span>executorService.execute(()-&gt; {</p>
<p>t++;</p>
<p>System.out.println(MessageFormat.format("t: {0}", t));</p>
<p>});</p>
<p>}</p>
<p>executorService.shutdown();</p>
<p>}</p>
<p>In this case, there are two issues. The first issue is that the post
increment operator is <em>not</em> atomic. It is comprised of multiple
operations: get the value, add 1 to the value, set the value. That's why
if we run the example, it is likely that</p>
<p>we won't see t: 100 in the output - two threads may concurrently get
the value, increment it, and set it: let's say the value of t is 10, and
two threads are incrementing t. Both threads will set the value of t to
11, since the second</p>
<p>thread observes the value of t before the first thread had finished
incrementing it.</p>
<p>The second issue is with how we are observing t. When we are printing
the value of t, the value may have already</p>
<p>been changed by a different thread after this thread's increment
operation.</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">To
fix those issues, we'll use the
java.util.concurrent.atomic.AtomicInteger</a>, which has many atomic</p>
<p>operations for us to use.</p>
<p><strong>private static</strong> AtomicInteger t =
<strong>new</strong> AtomicInteger(0);</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExecutorService executorService = Executors.newFixedThreadPool(400);
<em>// The high thread count is for demonstration purposes.</em></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100; i++)
{</p>
<p>executorService.execute(()-&gt; {</p>
<p><strong>int</strong> currentT = t.incrementAndGet();</p>
<p>System.out.println(MessageFormat.format("t: {0}", currentT));</p>
<p>});</p>
<p>}</p>
<p>executorService.shutdown();</p>
<p>}</p>
<p>The incrementAndGet method of <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">AtomicInteger</a>
atomically increments and returns the new value, thus eliminating</p>
<p>the previous race condition. Please note that in this example the
lines will still be out of order because we make no effort to sequence
the println calls and that this falls outside the scope of this example,
since it would require</p>
<p>synchronization and the goal of this example is to show how to use
AtomicInteger to eliminate race conditions concerning state.</p>
<p>Section 126.11: Exclusive write / Concurrent read access</p>
<p>It is sometimes required for a process to concurrently write and read
the same "data".</p>
<p>The ReadWriteLock interface, and its ReentrantReadWriteLock
implementation allows for an access pattern that</p>
<p>can be described as follow :</p>
<p>1. There can be any number of concurrent readers of the data. If
there is at least one reader access granted,</p>
<p>then no writer access is possible.</p>
<p>2. There can be at most one single writer to the data. If there is a
writer access granted, then no reader can</p>
<p>access the data.</p>
<p>An implementation could look like :</p>
<p><strong>import</strong> java.util.concurrent.locks.ReadWriteLock;</p>
<p><strong>import</strong>
java.util.concurrent.locks.ReentrantReadWriteLock;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 681</p>
<p><span id="public_class_Sample" class="anchor"></span>public class
<strong>Sample {</strong></p>
<p>// Our lock. The constructor allows a "fairness" setting, which
guarantees the chronology of lock attributions.</p>
<p><strong>protected static final</strong> ReadWriteLock RW_LOCK =
<strong>new</strong> ReentrantReadWriteLock();</p>
<p>// This is a typical data that needs to be protected for concurrent
access <em><strong>protected static int</strong> data = 0;</em></p>
<p>/** This will write to the data, in an exclusive access */ <em>public
static void <strong>writeToData() {</strong></em></p>
<p>RW_LOCK.writeLock().lock();</p>
<p>try <strong>{</strong></p>
<p>data++;</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>RW_LOCK.writeLock().unlock();</p>
<p>}</p>
<p>}</p>
<p>public static int <strong>readData() {</strong></p>
<p>RW_LOCK.readLock().lock();</p>
<p>try <strong>{</strong></p>
<p>return <strong>data;</strong></p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>RW_LOCK.readLock().unlock();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>NOTE 1</strong> : This precise use case has a cleaner
solution using AtomicInteger, but what is described here is an
access</p>
<p>pattern, that works regardless of the fact that data here is an
integer that as an Atomic variant.</p>
<p><strong>NOTE 2</strong> : The lock on the reading part is really
needed, although it might not look so to the casual reader. Indeed,
if</p>
<p>you do not lock on the reader side, any number of things can go
wrong, amongst which :</p>
<p>1. The writes of primitive values are not guaranteed to be atomic on
all JVMs, so the reader could see e.g. only</p>
<p>32bits of a 64bits write if data were a 64bits long type</p>
<p>2. The visibility of the write from a thread that did not perform it
is guaranteed by the JVM only if we establish</p>
<p><em>Happen Before relationship</em> between the writes and the reads.
This relationship is established when both readers and writers use their
respective locks, but not otherwise</p>
<p>Version ≥ Java SE 8</p>
<p>In case higher performance is required, an under certain types of
usage, there is a faster lock type available, called</p>
<p>the StampedLock, that amongst other things implements an optimistic
lock mode. This lock works very differently from the ReadWriteLock, and
this sample is not transposable.</p>
<p>Section 126.12: Producer-Consumer</p>
<p>A simple example of producer-consumer problem solution. Notice that
JDK classes (AtomicBoolean and</p>
<p>BlockingQueue) are used for synchronization, which reduces the chance
of creating an invalid solution. Consult</p>
<p>Javadoc for various types of <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue;
choosing different implementation may drastically change the</a></p>
<p>behavior of this example (like <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html">DelayQueue
or</a> <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html">Priority
Queue</a>).</p>
<p>public class <strong>Producer</strong> implements <strong>Runnable
{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 682</p>
<p><strong>private final</strong> BlockingQueue queue;</p>
<p><strong>public</strong> Producer(BlockingQueue queue) {</p>
<p><strong>this</strong>.queue = queue;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p><strong>int</strong> producedCount = 0;</p>
<p>try <strong>{</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>producedCount++;</p>
<p>//put throws an InterruptedException when the thread is
interrupted</p>
<p>queue.put(<strong>new</strong> ProducedData());</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// the thread has been interrupted: cleanup and exit</p>
<p>producedCount--;</p>
<p>//re-interrupt the thread in case the interrupt flag is needeed
higher up <em>Thread.currentThread().interrupt();</em></p>
<p>}</p>
<p>System.out.println("Produced " + producedCount + " objects");</p>
<p>}</p>
<p>}</p>
<p>public class <strong>Consumer</strong> implements <strong>Runnable
{</strong></p>
<p><strong>private final</strong> BlockingQueue queue;</p>
<p><strong>public</strong> Consumer(BlockingQueue queue) {</p>
<p><strong>this</strong>.queue = queue;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p><strong>int</strong> consumedCount = 0;</p>
<p>try <strong>{</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>//put throws an InterruptedException when the thread is
interrupted</p>
<p>ProducedData data = queue.poll(10, TimeUnit.MILLISECONDS);</p>
<p>// process data</p>
<p>consumedCount++;</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// the thread has been interrupted: cleanup and exit</p>
<p>consumedCount--;</p>
<p>//re-interrupt the thread in case the interrupt flag is needeed
higher up <em>Thread.currentThread().interrupt();</em></p>
<p>}</p>
<p>System.out.println("Consumed " + consumedCount + " objects");</p>
<p>}</p>
<p>}</p>
<p><strong>public class</strong> ProducerConsumerExample {</p>
<p><strong>static class</strong> ProducedData {</p>
<p>// empty data object</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> InterruptedException { BlockingQueue queue =
<strong>new</strong> ArrayBlockingQueue(1000);</p>
<p>// choice of queue determines the actual behavior: see various
BlockingQueue implementations</p>
<p>Thread producer = <strong>new</strong> Thread(<strong>new</strong>
Producer(queue));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 683</p>
<p><span id="Thread_consumer___new_Thread_new"
class="anchor"></span>Thread consumer = <strong>new</strong>
Thread(<strong>new</strong> Consumer(queue));</p>
<p>producer.start();</p>
<p>consumer.start();</p>
<p>Thread.sleep(1000);</p>
<p>producer.interrupt();</p>
<p>Thread.sleep(10);</p>
<p>consumer.interrupt();</p>
<p>}</p>
<p>}</p>
<p>Section 126.13: Visualizing read/write barriers while using</p>
<p>synchronized / volatile</p>
<p>As we know that we should use <strong>synchronized</strong> keyword
to make execution of a method or block exclusive. But few of us may not
be aware of one more important aspect of using
<strong>synchronized</strong> and <strong>volatile</strong> keyword:
<em>apart from</em></p>
<p><em>making a unit of code atomic, it also provides read / write
barrier</em>. What is this read / write barrier? Let's discuss this
using an example:</p>
<p><strong>class</strong> Counter {</p>
<p><strong>private</strong> Integer count = 10;</p>
<p>public synchronized void <strong>incrementCount() {</strong></p>
<p>count++;</p>
<p>}</p>
<p><strong>public</strong> Integer getCount() {</p>
<p><strong>return</strong> count;</p>
<p>}</p>
<p>}</p>
<p>Let's suppose a thread <em>A</em> calls incrementCount() first then
another thread <em>B</em> calls getCount(). In this scenario there</p>
<p>is no guarantee that B will see updated value of count. It may still
see count as 10, even it is also possible that it</p>
<p>never sees updated value of count ever.</p>
<p>To understand this behavior we need to understand how Java memory
model integrates with hardware architecture. In Java, each thread has
it's own thread stack. This stack contains: method call stack and local
variable</p>
<p>created in that thread. In a multi core system, it is quite possible
that two threads are running concurrently in</p>
<p>separate cores. In such scenario it is possible that part of a
thread's stack lies inside register / cache of a core. If inside a
thread, an object is accessed using <strong>synchronized</strong> (or
<strong>volatile</strong>) keyword, after <strong>synchronized</strong>
block that</p>
<p>thread syncs it's local copy of that variable with the main memory.
This creates a read / write barrier and makes sure that the thread is
seeing the latest value of that object.</p>
<p>But in our case, since thread B has not used synchronized access to
count, it might be refering value of count stored in register and may
never see updates from thread A. To make sure that B sees latest value
of count we</p>
<p>need to make getCount() synchronized as well.</p>
<p><strong>public synchronized</strong> Integer getCount() {</p>
<p><strong>return</strong> count;</p>
<p>}</p>
<p>Now when thread A is done with updating count it unlocks Counter
instance, at the same time creates write barrier and flushes all changes
done inside that block to the main memory. Similarly when thread B
acquires lock on the</p>
<p>same instance of Counter, it enters into read barrier and reads value
of count from main memory and sees all</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 684</p>
<p><span id="updates" class="anchor"></span>updates.</p>
<p><img src="media/index-709_1.jpeg" style="width:6.5in;height:3.5in"
alt="index-709_1.jpg" /></p>
<p>Same visibility effect goes for <strong>volatile</strong> read /
writes as well. All variables updated prior to write to
<strong>volatile</strong> will be</p>
<p>flushed to main memory and all reads after <strong>volatile</strong>
variable read will be from main memory.</p>
<p>Section 126.14: Get status of all threads started by your</p>
<p>program excluding system threads</p>
<p>Code snippet:</p>
<p><strong>import</strong> java.util.Set;</p>
<p><strong>public class</strong> ThreadStatus {</p>
<p><strong>public static void</strong> main(String args[])
<strong>throws</strong> Exception {</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 5; i++){</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
MyThread());</p>
<p>t.setName("MyThread:" + i);</p>
<p>t.start();</p>
<p>}</p>
<p><strong>int</strong> threadCount = 0;</p>
<p>Set threadSet = Thread.getAllStackTraces().keySet();</p>
<p><strong>for</strong> (Thread t : threadSet) {</p>
<p><strong>if</strong> (t.getThreadGroup() ==
Thread.currentThread().getThreadGroup()) {</p>
<p>System.out.println("Thread :" + t + ":" + "state:" + t.getState());
++threadCount;</p>
<p>}</p>
<p>}</p>
<p>System.out.println("Thread count started by Main thread:" +
threadCount);</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> MyThread <strong>implements</strong> Runnable
{</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p>Thread.sleep(2000);</p>
<p>} <strong>catch</strong>(Exception err) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 685</p>
<p><span id="err_printStackTrace"
class="anchor"></span>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Thread :Thread[MyThread:1,5,main]:state:TIMED_WAITING Thread
:Thread[MyThread:3,5,main]:state:TIMED_WAITING Thread
:Thread[main,5,main]:state:RUNNABLE</p>
<p>Thread :Thread[MyThread:4,5,main]:state:TIMED_WAITING Thread
:Thread[MyThread:0,5,main]:state:TIMED_WAITING Thread
:Thread[MyThread:2,5,main]:state:TIMED_WAITING Thread count started by
Main thread:6</p>
<p>Explanation:</p>
<p>Thread.getAllStackTraces().keySet() returns all Threads including
application threads and system threads. If you are interested only in
status of Threads, started by your application, iterate the Thread set
by checking Thread</p>
<p>Group of a particular thread against your main program thread.</p>
<p>In absence of above ThreadGroup condition, the program returns status
of below System Threads:</p>
<p>Reference Handler</p>
<p>Signal Dispatcher</p>
<p>Attach Listener</p>
<p>Finalizer</p>
<p>Section 126.15: Using ThreadLocal</p>
<p>A useful tool in Java Concurrency is ThreadLocal – this allows you to
have a variable that will be unique to a given thread. Thus, if the same
code runs in different threads, these executions will not share the
value, but instead each</p>
<p>thread has its own variable that is <em>local to the thread</em>.</p>
<p>For example, this is frequently used to establish the context (such
as authorization information) of handling a</p>
<p>request in a servlet. You might do something like this:</p>
<p><strong>private static final</strong> ThreadLocal contexts =
<strong>new</strong> ThreadLocal&lt;&gt;();</p>
<p><strong>public static</strong> MyUserContext getContext() {</p>
<p><em><strong>return</strong> contexts.get();</em> // get returns the
variable unique to this thread</p>
<p>}</p>
<p><strong>public void</strong> doGet(...) {</p>
<p>MyUserContext context = magicGetContextFromRequest(request);</p>
<p><em>contexts.put(context);</em> // save that context to our
thread-local - other threads</p>
<p>// making this call don't overwrite ours</p>
<p>try <strong>{</strong></p>
<p>// business logic</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><em>contexts.remove();</em> // 'ensure' removal of thread-local
variable</p>
<p>}</p>
<p>}</p>
<p>Now, instead of passing MyUserContext into every single method, you
can instead use MyServlet.getContext()</p>
<p>where you need it. Now of course, this does introduce a variable that
needs to be documented, but it’s thread-safe,</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 686</p>
<p><span id="which_eliminates_a_lot_of_the_do"
class="anchor"></span>which eliminates a lot of the downsides to using
such a highly scoped variable.</p>
<p>The key advantage here is that every thread has its own thread local
variable in that contexts container. As long as</p>
<p>you use it from a defined entry point (like demanding that each
servlet maintains its context, or perhaps by adding a servlet filter)
you can rely on this context being there when you need it.</p>
<p>Section 126.16: Multiple producer/consumer example with</p>
<p>shared global queue</p>
<p>Below code showcases multiple Producer/Consumer program. Both
Producer and Consumer threads share same</p>
<p>global queue.</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p><strong>import</strong> java.util.Random;</p>
<p><strong>public class</strong> ProducerConsumerWithES {</p>
<p><strong>public static void</strong> main(String args[]) {</p>
<p>BlockingQueue sharedQueue = <strong>new</strong>
LinkedBlockingQueue();</p>
<p>ExecutorService pes = Executors.newFixedThreadPool(2);</p>
<p>ExecutorService ces = Executors.newFixedThreadPool(2);</p>
<p>pes.submit(<strong>new</strong> Producer(sharedQueue, 1));</p>
<p>pes.submit(<strong>new</strong> Producer(sharedQueue, 2));</p>
<p>ces.submit(<strong>new</strong> Consumer(sharedQueue, 1));</p>
<p>ces.submit(<strong>new</strong> Consumer(sharedQueue, 2));</p>
<p>pes.shutdown();</p>
<p>ces.shutdown();</p>
<p>}</p>
<p>}</p>
<p>/* Different producers produces a stream of integers continuously to
a shared queue, which is shared between all Producers and consumers
*/</p>
<p><strong>class</strong> Producer <strong>implements</strong> Runnable
{</p>
<p><strong>private final</strong> BlockingQueue sharedQueue;</p>
<p>private int <strong>threadNo;</strong></p>
<p><strong>private</strong> Random random = <strong>new</strong>
Random();</p>
<p><strong>public</strong> Producer(BlockingQueue
sharedQueue,<strong>int</strong> threadNo) {</p>
<p><strong>this</strong>.threadNo = threadNo;</p>
<p><strong>this</strong>.sharedQueue = sharedQueue;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>// Producer produces a continuous stream of numbers for every 200
milli seconds <em><strong>while</strong> (<strong>true</strong>)
{</em></p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> number = random.nextInt(1000);</p>
<p>System.out.println("Produced:" + number + ":by thread:"+
threadNo);</p>
<p>sharedQueue.put(number);</p>
<p>Thread.sleep(200);</p>
<p>} <strong>catch</strong> (Exception err) {</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/* Different consumers consume data from shared queue, which is
shared by both producer and consumer threads */</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 687</p>
<p><span id="class_Consumer_implements_Runnab"
class="anchor"></span><strong>class</strong> Consumer
<strong>implements</strong> Runnable {</p>
<p><strong>private final</strong> BlockingQueue sharedQueue;</p>
<p>private int <strong>threadNo;</strong></p>
<p><strong>public</strong> Consumer (BlockingQueue
sharedQueue,<strong>int</strong> threadNo) {</p>
<p><strong>this</strong>.sharedQueue = sharedQueue;</p>
<p><strong>this</strong>.threadNo = threadNo;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>// Consumer consumes numbers generated from Producer threads
continuously <em><strong>while</strong>(<strong>true</strong>){</em></p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> num = sharedQueue.take();</p>
<p>System.out.println("Consumed: "+ num + ":by thread:"+threadNo);</p>
<p>} <strong>catch</strong> (Exception err) {</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>output:</p>
<p>Produced:69:by thread:2</p>
<p>Produced:553:by thread:1</p>
<p>Consumed: 69:by thread:1</p>
<p>Consumed: 553:by thread:2</p>
<p>Produced:41:by thread:2</p>
<p>Produced:796:by thread:1</p>
<p>Consumed: 41:by thread:1</p>
<p>Consumed: 796:by thread:2</p>
<p>Produced:728:by thread:2</p>
<p>Consumed: 728:by thread:1</p>
<p>and so on ................</p>
<p>Explanation:</p>
<p>1. sharedQueue, which is a LinkedBlockingQueue is shared among all
Producer and Consumer threads.</p>
<p>2. Producer threads produces one integer for every 200 milli seconds
continuously and append it to</p>
<p>sharedQueue</p>
<p>3. Consumer thread consumes integer from sharedQueue
continuously.</p>
<p>4. This program is implemented with-out explicit
<strong>synchronized</strong> or Lock constructs. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue
is the key to</a></p>
<p>achieve it.</p>
<p>BlockingQueue implementations are designed to be used primarily for
producer-consumer queues.</p>
<p>BlockingQueue implementations are thread-safe. All queuing methods
achieve their effects atomically</p>
<p>using internal locks or other forms of concurrency control.</p>
<p>Section 126.17: Add two `int` arrays using a Threadpool</p>
<p>A Threadpool has a Queue of tasks, of which each will be executed on
one these Threads.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 688</p>
<p><span id="The_following_example_shows_how" class="anchor"></span>The
following example shows how to add two <strong>int</strong> arrays using
a Threadpool.</p>
<p>Version ≥ Java SE 8</p>
<p><strong>int</strong>[] firstArray = { 2, 4, 6, 8 };</p>
<p><strong>int</strong>[] secondArray = { 1, 3, 5, 7 };</p>
<p><strong>int</strong>[] result = { 0, 0, 0, 0 };</p>
<p>ExecutorService pool = Executors.newCachedThreadPool();</p>
<p>// Setup the ThreadPool:</p>
<p>// for each element in the array, submit a worker to the pool that
adds elements <em><strong>for</strong> (<strong>int</strong> i = 0; i
&lt; result.length; i++) {</em></p>
<p><strong>final int</strong> worker = i;</p>
<p>pool.submit(()-&gt; result[worker] = firstArray[worker] +
secondArray[worker] ); }</p>
<p>// Wait for all Workers to finish:</p>
<p>try <strong>{</strong></p>
<p>// execute all submitted tasks</p>
<p>pool.shutdown();</p>
<p>// waits until all workers finish, or the timeout ends</p>
<p>pool.awaitTermination(12, TimeUnit.SECONDS);</p>
<p>}</p>
<p><strong>catch</strong> (InterruptedException e) {</p>
<p>pool.shutdownNow(); <em>//kill thread</em></p>
<p>}</p>
<p>System.out.println(Arrays.toString(result));</p>
<p>Notes:</p>
<p>1. This example is purely illustrative. In practice, there won't be
any speedup by using threads for a task this</p>
<p>small. A slowdown is likely, since the overheads of task creation and
scheduling will swamp the time taken to run a task.</p>
<p>2. If you were using Java 7 and earlier, you would use anonymous
classes instead of lambdas to implement the</p>
<p>tasks.</p>
<p>Section 126.18: Pausing Execution</p>
<p>Thread.sleep causes the current thread to suspend execution for a
specified period. This is an efficient means of</p>
<p>making processor time available to the other threads of an
application or other applications that might be running on a computer
system. There are two overloaded sleep methods in the Thread class.</p>
<p>One that specifies the sleep time to the millisecond</p>
<p><strong>public static void</strong> sleep(<strong>long</strong>
millis) <strong>throws</strong> InterruptedException</p>
<p>One that specifies the sleep time to the nanosecond</p>
<p>public static void <strong>sleep(</strong>long
<strong>millis,</strong> int <strong>nanos)</strong></p>
<p>Pausing Execution for 1 second</p>
<p>Thread.sleep(1000);</p>
<p>It is important to note that this is a hint to the operating system's
kernel's scheduler. This may not necessarily be</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 689</p>
<p><span id="precise__and_some_implementation"
class="anchor"></span>precise, and some implementations do not even
consider the nanosecond parameter (possibly rounding to the nearest
millisecond).</p>
<p>It is recommended to enclose a call to Thread.sleep in try/catch and
catch InterruptedException.</p>
<p>Section 126.19: Thread Interruption / Stopping Threads</p>
<p>Each Java Thread has an interrupt flag, which is initially false.
Interrupting a thread, is essentially nothing more than</p>
<p>setting that flag to true. The code running on that thread can check
the flag on occasion and act upon it. The code can also ignore it
completely. But why would each Thread have such a flag? After all,
having a boolean flag on a</p>
<p>thread is something we can just organize ourselves, if and when we
need it. Well, there are methods that behave in a special way when the
thread they're running on is interrupted. These methods are called
blocking methods.</p>
<p>These are methods that put the thread in the WAITING or TIMED_WAITING
state. When a thread is in this state, interrupting it, will cause an
InterruptedException to be thrown on the interrupted thread, rather than
the interrupt</p>
<p>flag being set to true, and the thread becomes RUNNABLE again. Code
that invokes a blocking method is forced to</p>
<p>deal with the InterruptedException, since it is a checked exception.
So, and hence its name, an interrupt can have the effect of interrupting
a WAIT, effectively ending it. Note that not all methods that are
somehow waiting (e.g.</p>
<p>blocking IO) respond to interruption in that way, as they don't put
the thread in a waiting state. Lastly a thread that has its interrupt
flag set, that enters a blocking method (i.e. tries to get into a
waiting state), will immediately throw</p>
<p>an InterruptedException and the interrupt flag will be cleared.</p>
<p>Other than these mechanics, Java does not assign any special semantic
meaning to interruption. Code is free to</p>
<p>interpret an interrupt any way it likes. But most often interruption
is used to signal to a thread it should stop running at its earliest
convenience. But, as should be clear from the above, it is up to the
code on that thread to</p>
<p>react to that interruption appropriately in order to stop running.
Stopping a thread is a collaboration. When a thread is interrupted its
running code can be several levels deep into the stacktrace. Most code
doesn't call a</p>
<p>blocking method, and finishes timely enough to not delay the stopping
of the thread unduly. The code that should</p>
<p>mostly be concerned with being responsive to interruption, is code
that is in a loop handling tasks until there are none left, or until a
flag is set signalling it to stop that loop. Loops that handle possibly
infinite tasks (i.e. they keep</p>
<p>running in principle) should check the interrupt flag in order to
exit the loop. For finite loops the semantics may dictate that all tasks
must be finished before ending, or it may be appropriate to leave some
tasks unhandled. Code</p>
<p>that calls blocking methods will be forced to deal with the
InterruptedException. If at all semantically possible, it can simply
propagate the InterruptedException and declare to throw it. As such it
becomes a blocking method itself in</p>
<p>regard to its callers. If it cannot propagate the exception, it
should at the very least set the interrupted flag, so callers higher up
the stack also know the thread was interrupted. In some cases the method
needs to continue</p>
<p>waiting regardless of the InterruptedException, in which case it must
delay setting the interrupted flag until after it</p>
<p>is done waiting, this may involve setting a local variable, which is
to be checked prior to exiting the method to then interrupt its
thread.</p>
<p>Examples :</p>
<p>Example of code that stops handling tasks upon interruption</p>
<p><strong>class</strong> TaskHandler <strong>implements</strong>
Runnable {</p>
<p><strong>private final</strong> BlockingQueue queue;</p>
<p>TaskHandler(BlockingQueue queue) {</p>
<p><strong>this</strong>.queue = queue;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>while</strong> (!Thread.currentThread().isInterrupted()) {
<em>// check for interrupt flag, exit loop</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 690</p>
<p>when interrupted</p>
<p>try <strong>{</strong></p>
<p><em>Task task = queue.take();</em> // blocking call, responsive to
interruption</p>
<p>handle(task);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p><em>Thread.currentThread().interrupt();</em> // cannot throw
InterruptedException (due to</p>
<p>Runnable interface restriction) so indicating interruption by setting
the flag</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> handle(Task task) {</p>
<p>// actual handling</p>
<p>}</p>
<p>}</p>
<p>Example of code that delays setting the interrupt flag until
completely done :</p>
<p><strong>class</strong> MustFinishHandler <strong>implements</strong>
Runnable {</p>
<p><strong>private final</strong> BlockingQueue queue;</p>
<p>MustFinishHandler(BlockingQueue queue) {</p>
<p><strong>this</strong>.queue = queue;</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>boolean</strong> shouldInterrupt =
<strong>false</strong>;</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>try <strong>{</strong></p>
<p>Task task = queue.take();</p>
<p><strong>if</strong> (task.isEndOfTasks()) {</p>
<p><strong>if</strong> (shouldInterrupt) {</p>
<p>Thread.currentThread().interrupt();</p>
<p>}</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p>handle(task);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p><em>shouldInterrupt = <strong>true</strong>;</em> // must finish,
remember to set interrupt flag when we're done</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> handle(Task task) {</p>
<p>// actual handling</p>
<p>}</p>
<p>}</p>
<p>Example of code that has a fixed list of tasks but may quit early
when interrupted</p>
<p><strong>class</strong> GetAsFarAsPossible <strong>implements</strong>
Runnable {</p>
<p><strong>private final</strong> List tasks = <strong>new</strong>
ArrayList&lt;&gt;();</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>for</strong> (Task task : tasks) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 691</p>
<p><strong>if</strong> (Thread.currentThread().isInterrupted()) {</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p>handle(task);</p>
<p>}</p>
<p>}</p>
<p><strong>private void</strong> handle(Task task) {</p>
<p>// actual handling</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 692</p>
<p><span id="Chapter_127__Executor__ExecutorS_1"
class="anchor"></span>Chapter 127: Executor, ExecutorService</p>
<p>and Thread pools</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html">The
Executor interface in Java provides a way of decoupling task submission
from the mechanics of how each task</a></p>
<p>will be run, including details of thread use, scheduling, etc. An
Executor is normally used instead of explicitly creating threads. With
Executors, developers won't have to significantly rewrite their code to
be able to easily tune</p>
<p>their program's task-execution policy.</p>
<p>Section 127.1: ThreadPoolExecutor</p>
<p>A common Executor used is the ThreadPoolExecutor, which takes care of
Thread handling. You can configure the</p>
<p>minimal amount of Threads the executor always has to maintain when
there's not much to do (it's called core size) and a maximal Thread size
to which the Pool can grow, if there is more work to do. Once the
workload declines, the</p>
<p>Pool slowly reduces the Thread count again until it reaches min
size.</p>
<p>ThreadPoolExecutor pool = <strong>new</strong>
ThreadPoolExecutor(</p>
<p><em>1,</em> // keep at least one thread ready,</p>
<p>// even if no Runnables are executed</p>
<p><em>5,</em> // at most five Runnables/Threads</p>
<p>// executed in parallel</p>
<p><em>1, TimeUnit.MINUTES,</em> // idle Threads terminated after
one</p>
<p>// minute, when min Pool size exceeded</p>
<p><em><strong>new</strong> ArrayBlockingQueue(10));</em> // outstanding
Runnables are kept here</p>
<p>pool.execute(<strong>new</strong> Runnable() {</p>
<p>@Override <strong>public void</strong> run() {</p>
<p>//code to run</p>
<p>}</p>
<p>});</p>
<p><strong>Note</strong> If you configure the ThreadPoolExecutor with an
<em>unbounded</em> queue, then the thread count will not exceed</p>
<p>corePoolSize since new threads are only created if the queue is
full:</p>
<p>ThreadPoolExecutor with all parameters:</p>
<p>ThreadPoolExecutor(<strong>int</strong> corePoolSize,
<strong>int</strong> maximumPoolSize, <strong>long</strong>
keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory
threadFactory, RejectedExecutionHandler handler)</p>
<p>from <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">JavaDoc</a></p>
<p>If there are more than corePoolSize but less than maximumPoolSize
threads running, a new thread will</p>
<p>be created only if the queue is full.</p>
<p>Advantages:</p>
<p>1. BlockingQueue size can be controlled and out-of-memory scenarios
can be avoided. Application</p>
<p>performance won't be degraded with limited bounded queue size.</p>
<p>2. You can use existing or create new Rejection Handler policies.</p>
<p>1. In the default ThreadPoolExecutor.AbortPolicy, the handler throws
a runtime</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 693</p>
<p><span id="RejectedExecutionException_upon"
class="anchor"></span>RejectedExecutionException upon rejection.</p>
<p>2. In ThreadPoolExecutor.CallerRunsPolicy, the thread that invokes
execute itself runs the task. This</p>
<p>provides a simple feedback control mechanism that will slow down the
rate that new tasks are</p>
<p>submitted.</p>
<p>3. In ThreadPoolExecutor.DiscardPolicy, a task that cannot be
executed is simply dropped.</p>
<p>4. In ThreadPoolExecutor.DiscardOldestPolicy, if the executor is not
shut down, the task at the head</p>
<p>of the work queue is dropped, and then execution is retried (which
can fail again, causing this to be</p>
<p>repeated.)</p>
<p>3. Custom ThreadFactory can be configured, which is useful :</p>
<p>1. To set a more descriptive thread name</p>
<p>2. To set thread daemon status</p>
<p>3. To set thread priority</p>
<p><a
href="https://github.com/manjunathshetty/java-samples/tree/master/java-threadpool-executor-sample">Here
is a example of how to use ThreadPoolExecutor</a></p>
<p>Section 127.2: Retrieving value from computation - Callable</p>
<p>If your computation produces some return value which later is
required, a simple Runnable task isn't sufficient. For</p>
<p>such cases you can use
ExecutorService.submit(Callable<strong>&lt;T&gt;</strong>) which returns
a value after execution completes.</p>
<p>The Service will return a Future which you can use to retrieve the
result of the task execution.</p>
<p>// Submit a callable for execution</p>
<p>ExecutorService pool = anExecutorService;</p>
<p>Future future = pool.submit(<strong>new</strong> Callable() {</p>
<p>@Override <strong>public</strong> Integer call() {</p>
<p>//do some computation</p>
<p><strong>return new</strong> Random().nextInt();</p>
<p>}</p>
<p>});</p>
<p>// ... perform other tasks while future is executed in a different
thread</p>
<p>When you need to get the result of the future, call future.get()</p>
<p>Wait indefinitely for future to finish with a result.</p>
<p>try <strong>{</strong></p>
<p>// Blocks current thread until future is completed</p>
<p>Integer result = future.get();</p>
<p><strong>catch</strong> (InterruptedException || ExecutionException e)
{</p>
<p>// handle appropriately</p>
<p>}</p>
<p>Wait for future to finish, but no longer than specified time.</p>
<p>try <strong>{</strong></p>
<p>// Blocks current thread for a maximum of 500 milliseconds. // If the
future finishes before that, result is returned, // otherwise
TimeoutException is thrown.</p>
<p>Integer result = future.get(500, TimeUnit.MILLISECONDS);</p>
<p><strong>catch</strong> (InterruptedException || ExecutionException ||
TimeoutException e) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 694</p>
<p><span id="___handle_appropriately" class="anchor"></span>// handle
appropriately</p>
<p>}</p>
<p>If the result of a scheduled or running task is no longer required,
you can call Future.cancel(<strong>boolean</strong>) to cancel it.</p>
<p>Calling cancel(<strong>false</strong>) will just remove the task from
the queue of tasks to be run.</p>
<p>Calling cancel(<strong>true</strong>) will <em>also</em> interrupt
the task if it is currently running.</p>
<p>Section 127.3: submit() vs execute() exception handling</p>
<p>dierences</p>
<p>Generally execute() command is used for fire and forget calls
(without need of analyzing the result) and submit()</p>
<p>command is used for analyzing the result of Future object.</p>
<p>We should be aware of key difference of Exception Handling mechanisms
between these two commands.</p>
<p>Exceptions from submit() are swallowed by framework if you did not
catch them.</p>
<p>Code example to understand the difference:</p>
<p>Case 1: submit the Runnable with execute() command, which reports the
Exception.</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>public class</strong> ExecuteSubmitDemo {</p>
<p><strong>public</strong> ExecuteSubmitDemo() {</p>
<p>System.out.println("creating service");</p>
<p>ExecutorService service = Executors.newFixedThreadPool(2);</p>
<p>//ExtendedExecutor service = new ExtendedExecutor();
<em><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 2;
i++){</em></p>
<p>service.execute(<strong>new</strong> Runnable(){</p>
<p>public void <strong>run(){</strong></p>
<p><strong>int</strong> a = 4, b = 0;</p>
<p>System.out.println("a and b=" + a + ":" + b);</p>
<p>System.out.println("a/b:" + (a / b));</p>
<p>System.out.println("Thread Name in Runnable after divide by</p>
<p>zero:"+Thread.currentThread().getName());</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>service.shutdown();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>ExecuteSubmitDemo demo = <strong>new</strong>
ExecuteSubmitDemo();</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> ExtendedExecutor <strong>extends</strong>
ThreadPoolExecutor {</p>
<p><strong>public</strong> ExtendedExecutor() {</p>
<p><strong>super</strong>(1, 1, 60, TimeUnit.SECONDS,
<strong>new</strong> ArrayBlockingQueue(100));</p>
<p>}</p>
<p>// ...</p>
<p><strong>protected void</strong> afterExecute(Runnable r, Throwable t)
{</p>
<p><strong>super</strong>.afterExecute(r, t);</p>
<p><strong>if</strong> (t == <strong>null</strong> &amp;&amp; r
<strong>instanceof</strong> Future) {</p>
<p>try <strong>{</strong></p>
<p>Object result = ((Future) r).get();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 695</p>
<p>} <strong>catch</strong> (CancellationException ce) {</p>
<p>t = ce;</p>
<p>} <strong>catch</strong> (ExecutionException ee) {</p>
<p>t = ee.getCause();</p>
<p>} <strong>catch</strong> (InterruptedException ie) {</p>
<p>Thread.currentThread().interrupt(); <em>// ignore/reset</em></p>
<p>}</p>
<p>}</p>
<p><strong>if</strong> (t != <strong>null</strong>)</p>
<p>System.out.println(t);</p>
<p>}</p>
<p>}</p>
<p>output:</p>
<p>creating service</p>
<p>a and b=4:0</p>
<p>a and b=4:0</p>
<p>Exception in thread "pool-1-thread-1" Exception in thread
"pool-1-thread-2" java.lang.ArithmeticException: / by zero</p>
<p>at ExecuteSubmitDemo$1.run(ExecuteSubmitDemo.java:15) at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at java.lang.Thread.run(Thread.java:744)</p>
<p>java.lang.ArithmeticException: / by zero</p>
<p>at ExecuteSubmitDemo$1.run(ExecuteSubmitDemo.java:15) at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at java.lang.Thread.run(Thread.java:744)</p>
<p>Case 2: Replace execute() with submit() :
<strong>service.submit(</strong>new <strong>Runnable(){ In this case,
Exceptions are</strong></p>
<p>swallowed by framework since run() method did not catch them
explicitly.</p>
<p>output:</p>
<p>creating service</p>
<p>a and b=4:0</p>
<p>a and b=4:0</p>
<p>Case 3: Change the newFixedThreadPool to ExtendedExecutor</p>
<p>//ExecutorService service = Executors.newFixedThreadPool(2);
<em>ExtendedExecutor service = <strong>new</strong>
ExtendedExecutor();</em></p>
<p>output:</p>
<p>creating service</p>
<p>a and b=4:0</p>
<p>java.lang.ArithmeticException: / by zero</p>
<p>a and b=4:0</p>
<p>java.lang.ArithmeticException: / by zero</p>
<p>I have demonstrated this example to cover two topics : Use your
custom ThreadPoolExecutor and handle Exectpion</p>
<p>with custom ThreadPoolExecutor.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 696</p>
<p><span id="Other_simple_solution_to_above_p"
class="anchor"></span><strong>Other simple solution to above problem
:</strong> When you are using normal ExecutorService &amp; submit
command, get</p>
<p>the Future object from submit() command call get() API on Future.
Catch the three exceptions, which have been</p>
<p>quoted in afterExecute method implementation. Advantage of custom
ThreadPoolExecutor over this approach : You have to handle Exception
handling mechanism in only one place - Custom ThreadPoolExecutor.</p>
<p>Section 127.4: Handle Rejected Execution</p>
<p>If</p>
<p>1. you try to submit tasks to a shutdown Executor or</p>
<p>2. the queue is saturated (only possible with bounded ones) and
maximum number of Threads has been</p>
<p>reached,</p>
<p>RejectedExecutionHandler.rejectedExecution(Runnable,
ThreadPoolExecutor) will be called.</p>
<p>The default behavior is that you'll get a RejectedExecutionException
thrown at the caller. But there are more predefined behaviors
available:</p>
<p>ThreadPoolExecutor.AbortPolicy <strong>(default, will throw
REE)</strong></p>
<p><strong>ThreadPoolExecutor.CallerRunsPolicy</strong> (executes task
on caller's thread - <em>blocking it</em>)</p>
<p>ThreadPoolExecutor.DiscardPolicy <strong>(silently discard
task)</strong></p>
<p><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong> (silently
discard <strong>oldest</strong> task in queue and retry execution of
the</p>
<p>new task)</p>
<p>You can set them using one of the ThreadPool <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor-int-int-long-java.util.concurrent.TimeUnit-java.util.concurrent.BlockingQueue-java.util.concurrent.RejectedExecutionHandler-">constructors:</a></p>
<p><strong>public</strong> ThreadPoolExecutor(<strong>int</strong>
corePoolSize,</p>
<p><strong>int</strong> maximumPoolSize,</p>
<p><strong>long</strong> keepAliveTime,</p>
<p>TimeUnit unit,</p>
<p>BlockingQueue workQueue,</p>
<p>RejectedExecutionHandler handler) <em>// &lt;--</em></p>
<p><strong>public</strong> ThreadPoolExecutor(<strong>int</strong>
corePoolSize,</p>
<p><strong>int</strong> maximumPoolSize,</p>
<p><strong>long</strong> keepAliveTime,</p>
<p>TimeUnit unit,</p>
<p>BlockingQueue workQueue,</p>
<p>ThreadFactory threadFactory,</p>
<p>RejectedExecutionHandler handler) <em>// &lt;--</em></p>
<p>You can as well implement your own behavior by extending <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution-java.lang.Runnable-java.util.concurrent.ThreadPoolExecutor-">RejectedExecutionHandler</a>
interface:</p>
<p><strong>void</strong> rejectedExecution(Runnable r,
ThreadPoolExecutor executor)</p>
<p>Section 127.5: Fire and Forget - Runnable Tasks</p>
<p>Executors accept a java.lang.Runnable which contains (potentially
computationally or otherwise long-running or</p>
<p>heavy) code to be run in another Thread.</p>
<p>Usage would be:</p>
<p>Executor exec = anExecutor;</p>
<p>exec.execute(<strong>new</strong> Runnable() {</p>
<p>@Override <strong>public void</strong> run() {</p>
<p>//offloaded work, no need to get result back</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 697</p>
<p><span id="_49" class="anchor"></span>}</p>
<p>});</p>
<p>Note that with this executor, you have no means to get any computed
value back.</p>
<p>With Java 8, one can utilize lambdas to shorten the code example.</p>
<p>Version ≥ Java SE 8</p>
<p>Executor exec = anExecutor;</p>
<p>exec.execute(()-&gt; {</p>
<p>//offloaded work, no need to get result back</p>
<p>});</p>
<p>Section 127.6: Use cases for dierent types of concurrency</p>
<p>constructs</p>
<p>1. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a></p>
<p>ExecutorService executor = Executors.newFixedThreadPool(50);</p>
<p>It is simple and easy to use. It hides low level details of
ThreadPoolExecutor.</p>
<p>I prefer this one when number of Callable/Runnable tasks are small in
number and piling of tasks in unbounded queue does not increase memory
&amp; degrade the performance of the system. If you have</p>
<p>CPU/Memory constraints, I prefer to use ThreadPoolExecutor with
capacity constraints &amp; RejectedExecutionHandler to handle rejection
of tasks.</p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a></p>
<p>CountDownLatch will be initialized with a given count. This count is
decremented by calls to the countDown() method. Threads waiting for this
count to reach zero can call one of the await() methods. Calling
await()</p>
<p><em>blocks the thread until the count reaches zero.</em> This class
enables a java thread to wait until other set of threads completes their
tasks.</p>
<p>Use cases:</p>
<p>1. Achieving Maximum Parallelism: Sometimes we want to start a number
of threads at the same time to</p>
<p>achieve maximum parallelism</p>
<p>2. Wait N threads to completes before start execution</p>
<p>3. Deadlock detection.</p>
<p>3. <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>
: It provides more control. If application is constrained by number of
pending</p>
<p>Runnable/Callable tasks, you can use bounded queue by setting the max
capacity. Once the queue reaches</p>
<p>maximum capacity, you can define RejectionHandler. Java provides four
types of RejectedExecutionHandler</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">policies.</a></p>
<p>1. ThreadPoolExecutor.AbortPolicy, the handler throws a runtime
RejectedExecutionException upon</p>
<p>rejection.</p>
<p>2. ThreadPoolExecutor.CallerRunsPolicy`, the thread that invokes
execute itself runs the task. This</p>
<p>provides a simple feedback control mechanism that will slow down the
rate that new tasks are submitted.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 698</p>
<p><span id="3__In_ThreadPoolExecutor_Discard" class="anchor"></span>3.
In ThreadPoolExecutor.DiscardPolicy, a task that cannot be executed is
simply dropped.</p>
<p>4. ThreadPoolExecutor.DiscardOldestPolicy, if the executor is not
shut down, the task at the head of</p>
<p>the work queue is dropped, and then execution is retried (which can
fail again, causing this to be</p>
<p>repeated.)</p>
<p>If you want to simulate CountDownLatch behaviour, you can use
invokeAll() method.</p>
<p>4. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">One
more mechanism you did not quote is ForkJoinPool</a></p>
<p>The ForkJoinPool was added to Java in Java 7. The ForkJoinPool is
similar to the Java ExecutorService but with one difference. The
ForkJoinPool makes it easy for tasks to split their work up into smaller
tasks which</p>
<p>are then submitted to the ForkJoinPool too. Task stealing happens in
ForkJoinPool when free worker threads steal tasks from busy worker
thread queue.</p>
<p>Java 8 has introduced one more API in <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService
to create work stealing pool. You don't have to create</a> RecursiveTask
and RecursiveAction but still can use ForkJoinPool.</p>
<p><strong>public static</strong> ExecutorService
newWorkStealingPool()</p>
<p>Creates a work-stealing thread pool using all available processors as
its target parallelism level.</p>
<p>By default, it will take number of CPU cores as parameter.</p>
<p>All these four mechanism are complimentary to each other. Depending
on level of granularity you want to control, you have to chose right
ones.</p>
<p>Section 127.7: Wait for completion of all tasks in</p>
<p>ExecutorService</p>
<p>Let's have a look at various options to wait for completion of tasks
submitted to <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a></p>
<p>1. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>
invokeAll()</p>
<p>Executes the given tasks, returning a list of Futures holding their
status and results when everything is completed.</p>
<p>Example:</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p><strong>import</strong> java.util.*;</p>
<p><strong>public class</strong> InvokeAllDemo{</p>
<p><strong>public</strong> InvokeAllDemo(){</p>
<p>System.out.println("creating service");</p>
<p>ExecutorService service =</p>
<p>Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</p>
<p>List futureList = <strong>new</strong> ArrayList();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 699</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10;
i++){</p>
<p>MyCallable myCallable = <strong>new</strong>
MyCallable((<strong>long</strong>)i);</p>
<p>futureList.add(myCallable);</p>
<p>}</p>
<p>System.out.println("Start");</p>
<p>try<strong>{</strong></p>
<p>List&gt; futures = service.invokeAll(futureList);</p>
<p>} <strong>catch</strong>(Exception err){</p>
<p>err.printStackTrace();</p>
<p>}</p>
<p>System.out.println("Completed");</p>
<p>service.shutdown();</p>
<p>}</p>
<p><strong>public static void</strong> main(String args[]){</p>
<p>InvokeAllDemo demo = <strong>new</strong> InvokeAllDemo();</p>
<p>}</p>
<p><strong>class</strong> MyCallable <strong>implements</strong>
Callable{</p>
<p>Long id = 0L;</p>
<p><strong>public</strong> MyCallable(Long val){</p>
<p><strong>this</strong>.id = val;</p>
<p>}</p>
<p><strong>public</strong> Long call(){</p>
<p>// Add your business logic</p>
<p>return <strong>id;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>2. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a></p>
<p>A synchronization aid that allows one or more threads to wait until a
set of operations being</p>
<p>performed in other threads completes.</p>
<p>A <strong>CountDownLatch</strong> is initialized with a given count.
The await methods block until the current</p>
<p>count reaches zero due to invocations of the countDown() method,
after which all waiting threads are released and any subsequent
invocations of await return immediately. This is a one-shot</p>
<p>phenomenon -- the count cannot be reset. If you need a version that
resets the count, consider</p>
<p><strong>using a</strong> CyclicBarrier<strong>.</strong></p>
<p>3. <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>
or newWorkStealingPool() <a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html">in
Executors</a></p>
<p>4. Iterate through all Future objects created after submitting to
ExecutorService</p>
<p>5. <a
href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">Recommended
way of shutdown from oracle documentation page of
ExecutorService</a>:</p>
<p><strong>void</strong> shutdownAndAwaitTermination(ExecutorService
pool) {</p>
<p><em>pool.shutdown();</em> // Disable new tasks from being
submitted</p>
<p>try <strong>{</strong></p>
<p>// Wait a while for existing tasks to terminate</p>
<p><strong>if</strong> (!pool.awaitTermination(60, TimeUnit.SECONDS))
{</p>
<p><em>pool.shutdownNow();</em> // Cancel currently executing tasks</p>
<p>// Wait a while for tasks to respond to being cancelled
<em><strong>if</strong> (!pool.awaitTermination(60,
TimeUnit.SECONDS))</em></p>
<p>System.err.println("Pool did not terminate");</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 700</p>
<p><span id="__catch__InterruptedException_ie" class="anchor"></span>}
<strong>catch</strong> (InterruptedException ie) {</p>
<p>// (Re-)Cancel if current thread also interrupted</p>
<p>pool.shutdownNow();</p>
<p>// Preserve interrupt status</p>
<p>Thread.currentThread().interrupt();</p>
<p>}</p>
<p>shutdown(): Initiates an orderly shutdown in which previously
submitted tasks are executed, but no new</p>
<p>tasks will be accepted.</p>
<p>shutdownNow():Attempts to stop all actively executing tasks, halts
the processing of waiting tasks, and</p>
<p>returns a list of the tasks that were awaiting execution.</p>
<p>In above example, if your tasks are taking more time to complete, you
can change if condition to while</p>
<p>condition</p>
<p>Replace</p>
<p><strong>if</strong> (!pool.awaitTermination(60,
TimeUnit.SECONDS))</p>
<p>with</p>
<p><strong>while</strong>(!pool.awaitTermination(60, TimeUnit.SECONDS))
{</p>
<p>Thread.sleep(60000);</p>
<p>}</p>
<p>Section 127.8: Use cases for dierent types of</p>
<p>ExecutorService</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html">Executors</a>
returns different type of ThreadPools catering to specific need.</p>
<p>1. <strong>public static</strong> ExecutorService
newSingleThreadExecutor()</p>
<p>Creates an Executor that uses a single worker thread operating off an
unbounded queue</p>
<p>There is a difference between newFixedThreadPool(1) and
newSingleThreadExecutor() as the java doc says for the latter:</p>
<p>Unlike the otherwise equivalent newFixedThreadPool(1) the returned
executor is guaranteed not to be reconfigurable to use additional
threads.</p>
<p>Which means that a newFixedThreadPool can be reconfigured later in
the program by:</p>
<p>((ThreadPoolExecutor) fixedThreadPool).setMaximumPoolSize(10) This is
not possible for newSingleThreadExecutor</p>
<p>Use cases:</p>
<p>1. You want to execute the submitted tasks in a sequence.</p>
<p>2. You need only one Thread to handle all your request</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 701</p>
<p>Cons:</p>
<p>1. Unbounded queue is harmful</p>
<p>2. <strong>public static</strong> ExecutorService
newFixedThreadPool(<strong>int</strong> nThreads)</p>
<p>Creates a thread pool that reuses a fixed number of threads operating
off a shared unbounded queue. At any point, at most nThreads threads
will be active processing tasks. If additional tasks</p>
<p>are submitted when all threads are active, they will wait in the
queue until a thread is available</p>
<p>Use cases:</p>
<p>1. Effective use of available cores. Configure nThreads as</p>
<p>Runtime.getRuntime().availableProcessors()</p>
<p>2. When you decide that number of thread should not exceed a number
in the thread pool</p>
<p>Cons:</p>
<p>1. Unbounded queue is harmful.</p>
<p>3. <strong>public static</strong> ExecutorService
newCachedThreadPool()</p>
<p>Creates a thread pool that creates new threads as needed, but will
reuse previously constructed</p>
<p>threads when they are available</p>
<p>Use cases:</p>
<p>1. For short-lived asynchronous tasks</p>
<p>Cons:</p>
<p>1. Unbounded queue is harmful.</p>
<p>2. Each new task will create a new thread if all existing threads are
busy. If the task is taking long</p>
<p>duration, more number of threads will be created,which will degrade
the performance of the system.</p>
<p>Alternative in this case: newFixedThreadPool</p>
<p>4. <strong>public static</strong> ScheduledExecutorService
newScheduledThreadPool(<strong>int</strong> corePoolSize)</p>
<p>Creates a thread pool that can schedule commands to run after a given
delay, or to execute periodically.</p>
<p>Use cases:</p>
<p>1. Handling recurring events with delays, which will happen in future
at certain interval of times</p>
<p>Cons:</p>
<p>1. Unbounded queue is harmful.</p>
<p>5.<strong>public static</strong> ExecutorService
newWorkStealingPool()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 702</p>
<p><span id="Creates_a_work_stealing_thread_p"
class="anchor"></span>Creates a work-stealing thread pool using all
available processors as its target parallelism level</p>
<p>Use cases:</p>
<p>1. For divide and conquer type of problems.</p>
<p>2. Effective use of idle threads. Idle threads steals tasks from busy
threads.</p>
<p>Cons:</p>
<p>1. Unbounded queue size is harmful.</p>
<p>You can see one common drawbacks in all these ExecutorService :
unbounded queue. This will be addressed with</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html#execute-java.lang.Runnable-">ThreadPoolExecutor</a></p>
<p>ThreadPoolExecutor(<strong>int</strong> corePoolSize,
<strong>int</strong> maximumPoolSize, <strong>long</strong>
keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory
threadFactory, RejectedExecutionHandler handler)</p>
<p>With ThreadPoolExecutor, you can</p>
<p>1. Control Thread pool size dynamically</p>
<p>2. Set the capacity for BlockingQueue</p>
<p>3. Define RejectionExecutionHander when queue is full</p>
<p>4. CustomThreadFactory to add some additional functionality during
Thread creation (<strong>public</strong> Thread</p>
<p>newThread(Runnable r)</p>
<p>Section 127.9: Scheduling tasks to run at a fixed time, after a</p>
<p>delay or repeatedly</p>
<p>The ScheduledExecutorService class provides a methods for scheduling
single or repeated tasks in a number of</p>
<p>ways. The following code sample assume that pool has been declared
and initialized as follows:</p>
<p>ScheduledExecutorService pool =
Executors.newScheduledThreadPool(2);</p>
<p>In addition to the normal ExecutorService methods, the
ScheduledExecutorService API adds 4 methods that</p>
<p>schedule tasks and return ScheduledFuture objects. The latter can be
used to retrieve results (in some cases) and</p>
<p>cancel tasks.</p>
<p>Starting a task after a fixed delay</p>
<p>The following example schedules a task to start after ten
minutes.</p>
<p>ScheduledFuture future = pool.schedule(<strong>new</strong>
Callable&lt;&gt;() {</p>
<p>@Override <strong>public</strong> Integer call() {</p>
<p>// do something</p>
<p>return <strong>42;</strong></p>
<p>}</p>
<p>},</p>
<p>10, TimeUnit.MINUTES);</p>
<p>Starting tasks at a fixed rate</p>
<p>The following example schedules a task to start after ten minutes,
and then repeatedly at a rate of once every one</p>
<p>minute.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 703</p>
<p><span id="ScheduledFuturenew_Runnable"
class="anchor"></span>ScheduledFuture future =
pool.scheduleAtFixedRate(<strong>new</strong> Runnable() {</p>
<p>@Override <strong>public void</strong> run() {</p>
<p>// do something</p>
<p>}</p>
<p>},</p>
<p>10, 1, TimeUnit.MINUTES);</p>
<p>Task execution will continue according to the schedule until the pool
is shut down, the future is canceled, or one of the tasks encounters an
exception.</p>
<p>It is guaranteed that the tasks scheduled by a given
scheduledAtFixedRate call will not overlap in time. If a task takes
longer than the prescribed period, then the next and subsequent task
executions may start late.</p>
<p>Starting tasks with a fixed delay</p>
<p>The following example schedules a task to start after ten minutes,
and then repeatedly with a delay of one minute between one task ending
and the next one starting.</p>
<p>ScheduledFuture future =
pool.scheduleWithFixedDelay(<strong>new</strong> Runnable() {</p>
<p>@Override <strong>public void</strong> run() {</p>
<p>// do something</p>
<p>}</p>
<p>},</p>
<p>10, 1, TimeUnit.MINUTES);</p>
<p>Task execution will continue according to the schedule until the pool
is shut down, the future is canceled, or one of</p>
<p>the tasks encounters an exception.</p>
<p>Section 127.10: Using Thread Pools</p>
<p>Thread Pools are used mostly calling methods in ExecutorService.</p>
<p>The following methods can be used to submit work for execution:</p>
<p>Method Description</p>
<p>submit Executes a the submitted work and return a future which can be
used to get the result</p>
<p>execute Execute the task sometime in the future without getting any
return value</p>
<p>invokeAll Execute a list of tasks and return a list of Futures</p>
<p>invokeAny Executes all the but return only the result of one that has
been successful (without exceptions)</p>
<p>Once you are done with the Thread Pool you can call shutdown() to
terminate the Thread Pool. This executes all</p>
<p>pending tasks. To wait for all tasks to execute you can can loop
around awaitTermination or isShutdown().</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 704</p>
<p><span id="Chapter_128__ThreadLocal_1" class="anchor"></span>Chapter
128: ThreadLocal</p>
<p>Section 128.1: Basic ThreadLocal usage</p>
<p>Java ThreadLocal is used to create thread local variables. It is
known that threads of an Object share it’s variables,</p>
<p>so the variable is not thread safe. We can use synchronization for
thread safety but if we want to avoid synchronization,ThreadLocal allows
us to create variables which are local to the thread, i.e. only that
thread can</p>
<p>read or write to those variables, so the other threads executing the
same piece of code will not be able to access each others ThreadLocal
variables.</p>
<p>This can be usedwe can use ThreadLocal variables. in situations where
you have a thread pool like for example in a web service. For example,
Creating a SimpleDateFormat object every time for every request is time
consuming and</p>
<p>a Static one cannot be created as SimpleDateFormat is not thread
safe, so we can create a ThreadLocal so that we can perform thread safe
operations without the overhead of creating SimpleDateFormat every
time.</p>
<p>The below piece of code shows how it can be used:</p>
<p>Every thread has it’s own ThreadLocal variable and they can use it’s
get() and set() methods to get the default</p>
<p>value or change it’s value local to Thread.</p>
<p>ThreadLocal instances are typically private static fields in classes
that wish to associate state with a thread.</p>
<p>Here is a small example showing use of ThreadLocal in java program
and proving that every thread has it’s own</p>
<p>copy of ThreadLocal variable.</p>
<p><strong>package</strong> com.examples.threads;</p>
<p><strong>import</strong> java.text.SimpleDateFormat;</p>
<p><strong>import</strong> java.util.Random;</p>
<p><strong>public class</strong> ThreadLocalExample
<strong>implements</strong> Runnable{</p>
<p>// SimpleDateFormat is not thread-safe, so give one to each
thread</p>
<p>// SimpleDateFormat is not thread-safe, so give one to each
thread</p>
<p>private static final <strong>ThreadLocal formatter =</strong> new</p>
<p>ThreadLocal(){</p>
<p>@Override</p>
<p><strong>protected</strong> SimpleDateFormat initialValue()</p>
<p>{</p>
<p><strong>return new</strong> SimpleDateFormat("yyyyMMdd HHmm");</p>
<p>}</p>
<p>};</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> InterruptedException { ThreadLocalExample obj =
<strong>new</strong> ThreadLocalExample();</p>
<p><strong>for</strong>(<strong>int</strong> i=0 ; i&lt;10; i++){</p>
<p>Thread t = <strong>new</strong> Thread(obj, ""+i);</p>
<p>Thread.sleep(<strong>new</strong> Random().nextInt(1000));</p>
<p>t.start();</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p>System.out.println("Thread Name= "+Thread.currentThread().getName()+"
default Formatter =</p>
<p>"+formatter.get().toPattern());</p>
<p>try <strong>{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 705</p>
<p><span id="Thread_sleep_new_Random___nextIn"
class="anchor"></span>Thread.sleep(<strong>new</strong>
Random().nextInt(1000));</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>formatter.set(<strong>new</strong> SimpleDateFormat());</p>
<p>System.out.println("Thread Name= "+Thread.currentThread().getName()+"
formatter =</p>
<p>"+formatter.get().toPattern());</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>Thread Name= 0 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 1 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 0 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 2 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 1 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 3 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 4 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 4 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 5 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 2 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 3 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 6 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 5 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 6 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 7 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 8 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 8 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 7 formatter = M/d/yy h:mm a</p>
<p>Thread Name= 9 <strong>default</strong> Formatter = yyyyMMdd HHmm</p>
<p>Thread Name= 9 formatter = M/d/yy h:mm a</p>
<p>As we can see from the output that Thread-0 has changed the value of
formatter but still thread-2 default formatter</p>
<p>is same as the initialized value.</p>
<p>Section 128.2: ThreadLocal Java 8 functional initialization</p>
<p>public static class <strong>ThreadLocalExample</strong></p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 706</p>
<p><span id="private_static_final_ThreadLocal"
class="anchor"></span>private static final <strong>ThreadLocal format
=</strong></p>
<p>ThreadLocal.withInitial(()-&gt; <strong>new</strong>
SimpleDateFormat("yyyyMMdd_HHmm"));</p>
<p><strong>public</strong> String formatDate(Date date)</p>
<p>{</p>
<p><strong>return</strong> format.get().format(date);</p>
<p>}</p>
<p>}</p>
<p>Section 128.3: Multiple threads with one shared object</p>
<p>In this example we have only one object but it is shared
between/executed on different threads. Ordinary usage of</p>
<p>fields to save state would not be possible because the other thread
would see that too (or probably not see).</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Foo foo = <strong>new</strong> Foo();</p>
<p><strong>new</strong> Thread(foo, "Thread 1").start();</p>
<p><strong>new</strong> Thread(foo, "Thread 2").start();</p>
<p>}</p>
<p>}</p>
<p>In Foo we count starting from zero. Instead of saving the state to a
field we store our current number in the</p>
<p>ThreadLocal object which is statically accessible. Note that the
synchronization in this example is not related to the usage of
ThreadLocal but rather ensures a better console output.</p>
<p>public class <strong>Foo</strong> implements <strong>Runnable
{</strong></p>
<p>private static final int <strong>ITERATIONS = 10;</strong></p>
<p><strong>private static final</strong> ThreadLocal threadLocal =
<strong>new</strong> ThreadLocal() { @Override</p>
<p><strong>protected</strong> Integer initialValue() {</p>
<p>return <strong>0;</strong></p>
<p>}</p>
<p>};</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; ITERATIONS;
i++) {</p>
<p><strong>synchronized</strong> (threadLocal) {</p>
<p>//Although accessing a static field, we get our own (previously
saved) value. <em><strong>int</strong> value =
threadLocal.get();</em></p>
<p>System.out.println(Thread.currentThread().getName() + ": " +
value);</p>
<p>//Update our own variable</p>
<p>threadLocal.set(value + 1);</p>
<p>try <strong>{</strong></p>
<p>threadLocal.notifyAll();</p>
<p><strong>if</strong> (i &lt; ITERATIONS -1) {</p>
<p>threadLocal.wait();</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException ex) {</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>From the output we can see that each thread counts for itself and
does not use the value of the other one:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 707</p>
<p>Thread 1: 0</p>
<p>Thread 2: 0</p>
<p>Thread 1: 1</p>
<p>Thread 2: 1</p>
<p>Thread 1: 2</p>
<p>Thread 2: 2</p>
<p>Thread 1: 3</p>
<p>Thread 2: 3</p>
<p>Thread 1: 4</p>
<p>Thread 2: 4</p>
<p>Thread 1: 5</p>
<p>Thread 2: 5</p>
<p>Thread 1: 6</p>
<p>Thread 2: 6</p>
<p>Thread 1: 7</p>
<p>Thread 2: 7</p>
<p>Thread 1: 8</p>
<p>Thread 2: 8</p>
<p>Thread 1: 9</p>
<p>Thread 2: 9</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 708</p>
<p><span id="Chapter_129__Using_ThreadPoolExe_1"
class="anchor"></span>Chapter 129: Using ThreadPoolExecutor in</p>
<p>MultiThreaded applications.</p>
<p>When creating a performant and data-driven application, it can be
very helpful to complete time-intensive tasks in</p>
<p>an asynchronous manner and to have multiple tasks running
concurrently. This topic will introduce the concept of using
ThreadPoolExecutors to complete multiple ansynchronous tasks
concurrently.</p>
<p>Section 129.1: Performing Asynchronous Tasks Where No</p>
<p>Return Value Is Needed Using a Runnable Class Instance</p>
<p>Some applications may want to create so-called "Fire &amp; Forget"
tasks which can be periodically triggered and do not</p>
<p>need to return any type of value returned upon completion of the
assigned task (for example, purging old temp files, rotating logs,
autosaving state).</p>
<p>In this example, we will create two classes: One which implements the
Runnable interface, and one which contains</p>
<p>a main() method.</p>
<p>AsyncMaintenanceTaskCompleter.java</p>
<p><strong>import</strong> lombok.extern.java.Log;</p>
<p><strong>import</strong> java.util.concurrent.ThreadLocalRandom;</p>
<p><strong>import</strong> java.util.concurrent.TimeUnit;</p>
<p>@Log</p>
<p><strong>public class</strong> AsyncMaintenanceTaskCompleter
<strong>implements</strong> Runnable {</p>
<p><strong>private int</strong> taskNumber;</p>
<p><strong>public</strong>
AsyncMaintenanceTaskCompleter(<strong>int</strong> taskNumber) {</p>
<p><strong>this</strong>.taskNumber = taskNumber;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p><strong>int</strong> timeout = ThreadLocalRandom.current().nextInt(1,
20); <strong>try</strong> {</p>
<p>log.info(String.format("Task %d is sleeping for %d seconds",
taskNumber, timeout));</p>
<p>TimeUnit.SECONDS.sleep(timeout);</p>
<p>log.info(String.format("Task %d is done sleeping", taskNumber));</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>AsyncExample1</p>
<p><strong>import</strong> java.util.concurrent.ExecutorService;</p>
<p><strong>import</strong> java.util.concurrent.Executors;</p>
<p><strong>public class</strong> AsyncExample1 {</p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>ExecutorService executorService =
Executors.newCachedThreadPool();</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt; 10; i++){</p>
<p>executorService.execute(<strong>new</strong>
AsyncMaintenanceTaskCompleter(i));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 709</p>
<p><span id="executorService_shutdown"
class="anchor"></span>executorService.shutdown();</p>
<p>}</p>
<p>}</p>
<p>Running AsyncExample1.main() resulted in the following output:</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
8 is sleeping for 18 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
6 is sleeping for 4 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
2 is sleeping for 6 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
3 is sleeping for 4 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
9 is sleeping for 14 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
4 is sleeping for 9 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
5 is sleeping for 10 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
0 is sleeping for 7 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
1 is sleeping for 9 seconds</p>
<p>Dec 28, 2016 2:21:03 PM AsyncMaintenanceTaskCompleter run INFO: Task
7 is sleeping for 8 seconds</p>
<p>Dec 28, 2016 2:21:07 PM AsyncMaintenanceTaskCompleter run INFO: Task
6 is done sleeping</p>
<p>Dec 28, 2016 2:21:07 PM AsyncMaintenanceTaskCompleter run INFO: Task
3 is done sleeping</p>
<p>Dec 28, 2016 2:21:09 PM AsyncMaintenanceTaskCompleter run INFO: Task
2 is done sleeping</p>
<p>Dec 28, 2016 2:21:10 PM AsyncMaintenanceTaskCompleter run INFO: Task
0 is done sleeping</p>
<p>Dec 28, 2016 2:21:11 PM AsyncMaintenanceTaskCompleter run INFO: Task
7 is done sleeping</p>
<p>Dec 28, 2016 2:21:12 PM AsyncMaintenanceTaskCompleter run INFO: Task
4 is done sleeping</p>
<p>Dec 28, 2016 2:21:12 PM AsyncMaintenanceTaskCompleter run INFO: Task
1 is done sleeping</p>
<p>Dec 28, 2016 2:21:13 PM AsyncMaintenanceTaskCompleter run INFO: Task
5 is done sleeping</p>
<p>Dec 28, 2016 2:21:17 PM AsyncMaintenanceTaskCompleter run INFO: Task
9 is done sleeping</p>
<p>Dec 28, 2016 2:21:21 PM AsyncMaintenanceTaskCompleter run INFO: Task
8 is done sleeping</p>
<p>Process finished with exit code 0</p>
<p><strong>Observations of Note:</strong> There are several things to
note in the output above,</p>
<p>1. The tasks did not execute in a predictable order.</p>
<p>2. Since each task was sleeping for a (pseudo)random amount of time,
they did not necessarily complete in the</p>
<p>order in which they were invoked.</p>
<p>Section 129.2: Performing Asynchronous Tasks Where a</p>
<p>Return Value Is Needed Using a Callable Class Instance</p>
<p>It is often necessary to execute a long-running task and use the
result of that task once it has completed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 710</p>
<p>In this example, we will create two classes: One which implements the
Callable interface (where T is the type we wish to return), and one
which contains a main() method.</p>
<p>AsyncValueTypeTaskCompleter.java</p>
<p><strong>import</strong> lombok.extern.java.Log;</p>
<p><strong>import</strong> java.util.concurrent.Callable;</p>
<p><strong>import</strong> java.util.concurrent.ThreadLocalRandom;</p>
<p><strong>import</strong> java.util.concurrent.TimeUnit;</p>
<p>@Log</p>
<p><strong>public class</strong> AsyncValueTypeTaskCompleter
<strong>implements</strong> Callable {</p>
<p><strong>private int</strong> taskNumber;</p>
<p><strong>public</strong>
AsyncValueTypeTaskCompleter(<strong>int</strong> taskNumber) {</p>
<p><strong>this</strong>.taskNumber = taskNumber;</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Integer call() <strong>throws</strong>
Exception {</p>
<p><strong>int</strong> timeout = ThreadLocalRandom.current().nextInt(1,
20); <strong>try</strong> {</p>
<p>log.info(String.format("Task %d is sleeping", taskNumber));</p>
<p>TimeUnit.SECONDS.sleep(timeout);</p>
<p>log.info(String.format("Task %d is done sleeping", taskNumber));</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p><strong>return</strong> timeout;</p>
<p>}</p>
<p>}</p>
<p>AsyncExample2.java</p>
<p><strong>import</strong> lombok.extern.java.Log;</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.concurrent.ExecutionException;</p>
<p><strong>import</strong> java.util.concurrent.ExecutorService;</p>
<p><strong>import</strong> java.util.concurrent.Executors;</p>
<p><strong>import</strong> java.util.concurrent.Future;</p>
<p>@Log</p>
<p><strong>public class</strong> AsyncExample2 {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExecutorService executorService =
Executors.newCachedThreadPool();</p>
<p>List&gt; futures = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10;
i++){</p>
<p>Future submittedFuture = executorService.submit(<strong>new</strong>
AsyncValueTypeTaskCompleter(i));</p>
<p>futures.add(submittedFuture);</p>
<p>}</p>
<p>executorService.shutdown();</p>
<p><strong>while</strong>(!futures.isEmpty()){</p>
<p><strong>for</strong>(<strong>int</strong> j = 0; j &lt;
futures.size(); j++){</p>
<p>Future f = futures.get(j);</p>
<p><strong>if</strong>(f.isDone()){</p>
<p>try <strong>{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 711</p>
<p><strong>int</strong> timeout = f.get();</p>
<p>log.info(String.format("A task just completed after sleeping for %d
seconds", timeout));</p>
<p>futures.remove(f);</p>
<p>} <strong>catch</strong> (InterruptedException | ExecutionException
e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Running AsyncExample2.main() resulted in the following output:</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 7
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 8
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 2
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 1
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 4
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 9
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 0
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 6
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 5
is sleeping</p>
<p>Dec 28, 2016 3:07:15 PM AsyncValueTypeTaskCompleter call INFO: Task 3
is sleeping</p>
<p>Dec 28, 2016 3:07:16 PM AsyncValueTypeTaskCompleter call INFO: Task 8
is done sleeping</p>
<p>Dec 28, 2016 3:07:16 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 1 seconds Dec 28, 2016
3:07:17 PM AsyncValueTypeTaskCompleter call INFO: Task 2 is done
sleeping</p>
<p>Dec 28, 2016 3:07:17 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 2 seconds Dec 28, 2016
3:07:17 PM AsyncValueTypeTaskCompleter call INFO: Task 9 is done
sleeping</p>
<p>Dec 28, 2016 3:07:17 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 2 seconds Dec 28, 2016
3:07:19 PM AsyncValueTypeTaskCompleter call INFO: Task 3 is done
sleeping</p>
<p>Dec 28, 2016 3:07:19 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 4 seconds Dec 28, 2016
3:07:20 PM AsyncValueTypeTaskCompleter call INFO: Task 0 is done
sleeping</p>
<p>Dec 28, 2016 3:07:20 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 5 seconds Dec 28, 2016
3:07:21 PM AsyncValueTypeTaskCompleter call INFO: Task 5 is done
sleeping</p>
<p>Dec 28, 2016 3:07:21 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 6 seconds Dec 28, 2016
3:07:25 PM AsyncValueTypeTaskCompleter call INFO: Task 1 is done
sleeping</p>
<p>Dec 28, 2016 3:07:25 PM AsyncExample2 main</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 712</p>
<p><span id="INFO__A_task_just_completed_afte"
class="anchor"></span>INFO: A task just completed after sleeping for 10
seconds Dec 28, 2016 3:07:27 PM AsyncValueTypeTaskCompleter call INFO:
Task 6 is done sleeping</p>
<p>Dec 28, 2016 3:07:27 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 12 seconds Dec 28,
2016 3:07:29 PM AsyncValueTypeTaskCompleter call INFO: Task 7 is done
sleeping</p>
<p>Dec 28, 2016 3:07:29 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 14 seconds Dec 28,
2016 3:07:31 PM AsyncValueTypeTaskCompleter call INFO: Task 4 is done
sleeping</p>
<p>Dec 28, 2016 3:07:31 PM AsyncExample2 main</p>
<p>INFO: A task just completed after sleeping for 16 seconds</p>
<p>Observations of Note:</p>
<p>There are several things to note in the output above,</p>
<p>1. Each call to ExecutorService.submit() returned an instance of
Future, which was stored in a list for later use 2. Future contains a
method called isDone() which can be used to check whether our task has
been completed</p>
<p>before attempting to check it's return value. Calling the
Future.get() method on a Future that is not yet done</p>
<p>will block the current thread until the task is complete, potentially
negating many benefits gained from performing the task
Asynchronously.</p>
<p>3. The executorService.shutdown() method was called prior to checking
the return values of the Future objects.</p>
<p>This is not required, but was done in this way to show that it is
possible. The executorService.shutdown()</p>
<p>method does not prevent the completion of tasks which have already
been submitted to the ExecutorService, but rather prevents new tasks
from being added to the Queue.</p>
<p>Section 129.3: Defining Asynchronous Tasks Inline using</p>
<p>Lambdas</p>
<p>While good software design often maximizes code reusability,
sometimes it can be useful to define asynchronous</p>
<p>tasks inline in your code via Lambda expressions to maximize code
readability.</p>
<p>In this example, we will create a single class which contains a
main() method. Inside this method, we will use Lambda expressions to
create and execute instances of Callable and Runnable.</p>
<p>AsyncExample3.java</p>
<p><strong>import</strong> lombok.extern.java.Log;</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p>@Log</p>
<p><strong>public class</strong> AsyncExample3 {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ExecutorService executorService =
Executors.newCachedThreadPool();</p>
<p>List&gt; futures = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><strong>for</strong>(<strong>int</strong> i = 0; i &lt; 5; i++){</p>
<p><strong>final int</strong> index = i;</p>
<p>executorService.execute(()-&gt; {</p>
<p><strong>int</strong> timeout = getTimeout();</p>
<p>log.info(String.format("Runnable %d has been submitted and will sleep
for %d seconds", index, timeout));</p>
<p>try <strong>{</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 713</p>
<p>TimeUnit.SECONDS.sleep(timeout);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p>log.info(String.format("Runnable %d has finished sleeping",
index));</p>
<p>});</p>
<p>Future submittedFuture = executorService.submit(()-&gt; {</p>
<p><strong>int</strong> timeout = getTimeout();</p>
<p>log.info(String.format("Callable %d will begin sleeping",
index));</p>
<p>try <strong>{</strong></p>
<p>TimeUnit.SECONDS.sleep(timeout);</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p>log.info(String.format("Callable %d is done sleeping", index));</p>
<p><strong>return</strong> timeout;</p>
<p>});</p>
<p>futures.add(submittedFuture);</p>
<p>}</p>
<p>executorService.shutdown();</p>
<p><strong>while</strong>(!futures.isEmpty()){</p>
<p><strong>for</strong>(<strong>int</strong> j = 0; j &lt;
futures.size(); j++){</p>
<p>Future f = futures.get(j);</p>
<p><strong>if</strong>(f.isDone()){</p>
<p>try <strong>{</strong></p>
<p><strong>int</strong> timeout = f.get();</p>
<p>log.info(String.format("A task just completed after sleeping for %d
seconds", timeout));</p>
<p>futures.remove(f);</p>
<p>} <strong>catch</strong> (InterruptedException | ExecutionException
e) {</p>
<p>log.warning(e.getMessage());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public static int <strong>getTimeout(){</strong></p>
<p><strong>return</strong> ThreadLocalRandom.current().nextInt(1,
20);</p>
<p>}</p>
<p>}</p>
<p>Observations of Note:</p>
<p>There are several things to note in the output above,</p>
<p>1. Lambda expressions have access to variables and methods which are
available to the scope in which they are</p>
<p>defined, but all variables must be final (or effectively final) for
use inside a lambda expression.</p>
<p>2. We do not have to specify whether our Lambda expression is a
Callable or a Runnable explicitly, the</p>
<p>return type is inferred automatically by the return type.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 714</p>
<p><span id="Chapter_130__Common_Java_Pitfall_1"
class="anchor"></span>Chapter 130: Common Java Pitfalls</p>
<p>This topic outlines some of the common mistakes made by beginners in
Java.</p>
<p>This includes any common mistakes in use of the Java language or
understanding of the run-time environment.</p>
<p>Mistakes associated with specific APIs can be described in topics
specific to those APIs. Strings are a special case; they're covered in
the Java Language Specification. Details other than common mistakes can
be described in this</p>
<p>topic on Strings.</p>
<p>Section 130.1: Pitfall: using == to compare primitive wrappers</p>
<p>objects such as Integer</p>
<p>(This pitfall applies equally to all primitive wrapper types, but we
will illustrate it for Integer and <strong>int</strong>.)</p>
<p>When working with Integer objects, it is tempting to use == to
compare values, because that is what you would do</p>
<p>with <strong>int</strong> values. And in some cases this will seem to
work:</p>
<p>Integer int1_1 = Integer.valueOf("1");</p>
<p>Integer int1_2 = Integer.valueOf(1);</p>
<p>System.out.println("int1_1 == int1_2: " + (int1_1 == int1_2)); <em>//
true</em> System.out.println("int1_1 equals int1_2: " +
int1_1.equals(int1_2)); <em>// true</em></p>
<p>Here we created two Integer objects with the value 1 and compare them
(In this case we created one from a</p>
<p>String and one from an <strong>int</strong> literal. There are other
alternatives). Also, we observe that the two comparison methods (== and
equals) both yield <strong>true</strong>.</p>
<p>This behavior changes when we choose different values:</p>
<p>Integer int2_1 = Integer.valueOf("1000");</p>
<p>Integer int2_2 = Integer.valueOf(1000);</p>
<p>System.out.println("int2_1 == int2_2: " + (int2_1 == int2_2)); <em>//
false</em> System.out.println("int2_1 equals int2_2: " +
int2_1.equals(int2_2)); <em>// true</em></p>
<p>In this case, only the equals comparison yields the correct
result.</p>
<p>The reason for this difference in behavior is, that the JVM maintains
a cache of Integer objects for the range -128 to 127. (The upper value
can be overridden with the system property
"java.lang.Integer.IntegerCache.high" or the JVM</p>
<p>argument "-XX:AutoBoxCacheMax=size"). For values in this range, the
Integer.valueOf() will return the cached value rather than creating a
new one.</p>
<p>Thus, in the first example the Integer.valueOf(1) and
Integer.valueOf("1") calls returned the same cached Integer instance. By
contrast, in the second example the Integer.valueOf(1000) and
Integer.valueOf("1000")</p>
<p>both created and returned new Integer objects.</p>
<p>The == operator for reference types tests for reference equality
(i.e. the same object). Therefore, in the first</p>
<p>example int1_1 == int1_2 is <strong>true</strong> because the
references are the same. In the second example int2_1 == int2_2 is false
because the references are different.</p>
<p>Section 130.2: Pitfall: using == to compare strings</p>
<p>A common mistake for Java beginners is to use the == operator to test
if two strings are equal. For example:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 715</p>
<p>public class <strong>Hello {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>if</strong> (args.length &gt; 0) {</p>
<p><strong>if</strong> (args[0] == "hello") {</p>
<p>System.out.println("Hello back to you");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Are you feeling grumpy today?");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The above program is supposed to test the first command line argument
and print different messages when it and</p>
<p>isn't the word "hello". But the problem is that it won't work. That
program will output "Are you feeling grumpy today?" no matter what the
first command line argument is.</p>
<p>In this particular case the String "hello" is put in the string pool
while the String args[0] resides on the heap. This means there are two
objects representing the same literal, each with its reference. Since ==
tests for references, not</p>
<p>actual equality, the comparison will yield a false most of the times.
This doesn't mean that it will always do so.</p>
<p>When you use == to test strings, what you are actually testing is if
two String objects are the same Java object.</p>
<p>Unfortunately, that is not what string equality means in Java. In
fact, the correct way to test strings is to use the equals(Object)
method. For a pair of strings, we usually want to test if they consist
of the same characters in the</p>
<p>same order.</p>
<p>public class <strong>Hello2 {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>if</strong> (args.length &gt; 0) {</p>
<p><strong>if</strong> (args[0].equals("hello")) {</p>
<p>System.out.println("Hello back to you");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Are you feeling grumpy today?");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>But it actually gets worse. The problem is that == <em>will</em> give
the expected answer in some circumstances. For example</p>
<p>public class <strong>Test1 {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>String s1 = "hello";</p>
<p>String s2 = "hello";</p>
<p><strong>if</strong> (s1 == s2) {</p>
<p>System.out.println("same");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("different");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Interestingly, this will print "same", even though we are testing the
strings the wrong way. Why is that? Because the</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">Java
Language Specification (Section 3.10.5: String Literals)</a> stipulates
that any two string &gt;&gt;literals&lt;&lt; consisting of</p>
<p>the same characters will actually be represented by the same Java
object. Hence, the == test will give true for equal literals. (The
string literals are "interned" and added to a shared "string pool" when
your code is loaded, but that is</p>
<p>actually an implementation detail.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 716</p>
<p><span id="To_add_to_the_confusion__the_Jav" class="anchor"></span>To
add to the confusion, the Java Language Specification also stipulates
that when you have a compile-time constant expression that concatenates
two string literals, that is equivalent to a single literal. Thus:</p>
<p>public class <strong>Test1 {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>String s1 = "hello";</p>
<p>String s2 = "hel" + "lo";</p>
<p>String s3 = " mum";</p>
<p><strong>if</strong> (s1 == s2) {</p>
<p>System.out.println("1. same");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("1. different");</p>
<p>}</p>
<p><strong>if</strong> (s1 + s3 == "hello mum") {</p>
<p>System.out.println("2. same");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("2. different");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>This will output "1. same" and "2. different". In the first case, the
+ expression is evaluated at compile time and we compare one String
object with itself. In the second case, it is evaluated at run time and
we compare two different</p>
<p>String objects</p>
<p>In summary, using == to test strings in Java is almost always
incorrect, but it is not guaranteed to give the wrong</p>
<p>answer.</p>
<p>Section 130.3: Pitfall: forgetting to free resources</p>
<p>Every time a program opens a resource, such as a file or network
connection, it is important to free the resource</p>
<p>once you are done using it. Similar caution should be taken if any
exception were to be thrown during operations</p>
<p>on such resources. One could argue that the <a
href="https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html">FileInputStream</a>
has a <a href="https://en.wikipedia.org/wiki/Finalizer">finalizer</a>
that invokes the close() method on a</p>
<p>garbage collection event; however, since we can’t be sure when a
garbage collection cycle will start, the input</p>
<p>stream can consume computer resources for an indefinite period of
time. The resource must be closed in a <strong>finally</strong> section
of a try-catch block:</p>
<p>Version &lt; Java SE 7</p>
<p><strong>private static void</strong> printFileJava6()
<strong>throws</strong> IOException {</p>
<p>FileInputStream input;</p>
<p>try <strong>{</strong></p>
<p>input = <strong>new</strong> FileInputStream("file.txt");</p>
<p><strong>int</strong> data = input.read();</p>
<p><strong>while</strong> (data !=-1){</p>
<p>System.out.print((<strong>char</strong>) data);</p>
<p>data = input.read();</p>
<p>}</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (input != <strong>null</strong>) {</p>
<p>input.close();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Since Java 7 there is a really useful and neat statement introduced
in Java 7 particularly for this case, called try-with-resources:</p>
<p>Version ≥ Java SE 7</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 717</p>
<p><span id="private_static_void_printFileJav"
class="anchor"></span><strong>private static void</strong>
printFileJava7() <strong>throws</strong> IOException {</p>
<p><strong>try</strong> (FileInputStream input = <strong>new</strong>
FileInputStream("file.txt")) {</p>
<p><strong>int</strong> data = input.read();</p>
<p><strong>while</strong> (data !=-1){</p>
<p>System.out.print((<strong>char</strong>) data);</p>
<p>data = input.read();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The <em>try-with-resources</em> statement can be used with any object
that implements the Closeable or AutoCloseable</p>
<p>interface. It ensures that each resource is closed by the end of the
statement. The difference between the two interfaces is, that the
close() method of Closeable throws an IOException which has to be
handled in some way.</p>
<p>In cases where the resource has already been opened but should be
safely closed after use, one can assign it to a local variable inside
the try-with-resources</p>
<p>Version ≥ Java SE 7</p>
<p><strong>private static void</strong> printFileJava7(InputStream
extResource) <strong>throws</strong> IOException {</p>
<p><strong>try</strong> (InputStream input = extResource) {</p>
<p><em>...</em> //access resource</p>
<p>}</p>
<p>}</p>
<p>The local resource variable created in the try-with-resources
constructor is effectively final.</p>
<p>Section 130.4: Pitfall: testing a file before attempting to open</p>
<p>it</p>
<p>Some people recommend that you should apply various tests to a file
before attempting to open it either to provide better diagnostics or
avoid dealing with exceptions. For example, this method attempts to
check if path</p>
<p>corresponds to a readable file:</p>
<p><strong>public static</strong> File getValidatedFile(String path)
<strong>throws</strong> IOException {</p>
<p>File f = <strong>new</strong> File(path);</p>
<p><strong>if</strong> (!f.exists()) <strong>throw new</strong>
IOException("Error: not found: " + path); <strong>if</strong>
(!f.isFile()) <strong>throw new</strong> IOException("Error: Is a
directory: " + path); <strong>if</strong> (!f.canRead()) <strong>throw
new</strong> IOException("Error: cannot read file: " + path);
<strong>return</strong> f;</p>
<p>}</p>
<p>You might use the above method like this:</p>
<p>File f = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>f = getValidatedFile("somefile");</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.err.println(ex.getMessage());</p>
<p>return<strong>;</strong></p>
<p>}</p>
<p><strong>try</strong> (InputStream is = <strong>new</strong>
FileInputStream(file)) {</p>
<p>// Read data etc.</p>
<p>}</p>
<p>The first problem is in the signature for FileInputStream(File)
because the compiler will still insist we catch</p>
<p>IOException here, or further up the stack.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 718</p>
<p><span id="The_second_problem_is_that_check" class="anchor"></span>The
second problem is that checks performed by getValidatedFile do not
guarantee that the FileInputStream will succeed.</p>
<p>Race conditions: another thread or a separate process could rename
the file, delete the file, or remove read access after the
getValidatedFile returns. That would lead to a "plain" IOException
without the custom</p>
<p>message.</p>
<p>There are edge cases not covered by those tests. For example, on a
system with SELinux in "enforcing" mode, an attempt to read a file can
fail despite canRead() returning <strong>true</strong>.</p>
<p>The third problem is that the tests are inefficient. For example, the
exists, isFile and canRead calls will each make</p>
<p>a <a href="https://en.wikipedia.org/wiki/System_call">syscall to
perform the required check. Another syscall is then made to open the
file, which repeats the same</a></p>
<p>checks behind the scenes.</p>
<p>In short, methods like getValidatedFile are misguided. It is better
to simply attempt to open the file and handle</p>
<p>the exception:</p>
<p><strong>try</strong> (InputStream is = <strong>new</strong>
FileInputStream("somefile")) {</p>
<p>// Read data etc.</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.err.println("IO Error processing 'somefile': " +
ex.getMessage()); <strong>return</strong>;</p>
<p>}</p>
<p>If you wanted to distinguish IO errors thrown while opening and
reading, you could use a nested try / catch. If you</p>
<p>wanted to produce better diagnostics for open failures, you could
perform the exists, isFile and canRead checks in the handler.</p>
<p>Section 130.5: Pitfall: thinking of variables as objects</p>
<p>No Java variable represents an object.</p>
<p><em>String foo;</em> // NOT AN OBJECT</p>
<p>Neither does any Java array contain objects.</p>
<p>String bar[] = <strong>new</strong> String[100]; <em>// No member is
an object.</em></p>
<p>If you mistakenly think of variables as objects, the actual behavior
of the Java language will surprise you.</p>
<p>For Java variables which have a primitive type (such as
<strong>int</strong> or <strong>float</strong>) the variable holds a
copy of the value. All copies of a primitive value are
indistinguishable; i.e. there is only one <strong>int</strong> value for
the number one. Primitive</p>
<p>values are not objects and they do not behave like objects.</p>
<p>For Java variables which have a reference type (either a class or an
array type) the variable holds a reference. All copies of a reference
are indistinguishable. References may point to objects, or they may be
<strong>null</strong> which</p>
<p>means that they point to no object. However, they are not objects and
they don't behave like objects.</p>
<p>Variables are not objects in either case, and they don't contain
objects in either case. They may contain <em>references to</em></p>
<p><em>objects</em>, but that is saying something different.</p>
<p>Example class</p>
<p>The examples that follow use this class, which represents a point in
2D space.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 719</p>
<p>public final class <strong>MutableLocation {</strong></p>
<p>public int <strong>x;</strong></p>
<p>public int <strong>y;</strong></p>
<p><strong>public</strong> MutableLocation(<strong>int</strong> x,
<strong>int</strong> y) {</p>
<p><strong>this</strong>.x = x;</p>
<p><strong>this</strong>.y = y;</p>
<p>}</p>
<p><strong>public boolean</strong> equals(Object other) {</p>
<p><strong>if</strong> (!(other <strong>instanceof</strong>
MutableLocation) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>MutableLocation that = (MutableLocation) other;</p>
<p><strong>return this</strong>.x == that.x &amp;&amp;
<strong>this</strong>.y == that.y;</p>
<p>}</p>
<p>}</p>
<p>An instance of this class is an object that has two fields x and y
which have the type <strong>int</strong>.</p>
<p>We can have many instances of the MutableLocation class. Some will
represent the same locations in 2D space; i.e.</p>
<p>the respective values of x and y will match. Others will represent
different locations.</p>
<p>Multiple variables can point to the same object</p>
<p>MutableLocation here = <strong>new</strong> MutableLocation(1,
2);</p>
<p>MutableLocation there = here;</p>
<p>MutableLocation elsewhere = <strong>new</strong> MutableLocation(1,
2);</p>
<p>In the above, we have declared three variables here, there and
elsewhere that can hold references to MutableLocation objects.</p>
<p>If you (incorrectly) think of these variables as being objects, then
you are likely to misread the statements as saying:</p>
<p>1. Copy the location "[1, 2]" to here</p>
<p>2. Copy the location "[1, 2]" to there</p>
<p>3. Copy the location "[1, 2]" to elsewhere</p>
<p>From that, you are likely to infer we have three independent objects
in the three variables. In fact there are <em>only two</em> <em>objects
created</em> by the above. The variables here and there actually refer
to the same object.</p>
<p>We can demonstrate this. Assuming the variable declarations as
above:</p>
<p>System.out.println("BEFORE: here.x is " + here.x + ", there.x is " +
there.x +</p>
<p>"elsewhere.x is " + elsewhere.x);</p>
<p>here.x = 42;</p>
<p>System.out.println("AFTER: here.x is " + here.x + ", there.x is " +
there.x +</p>
<p>"elsewhere.x is " + elsewhere.x);</p>
<p>This will output the following:</p>
<p>BEFORE: here.x is 1, there.x is 1, elsewhere.x is 1 AFTER: here.x is
42, there.x is 42, elsewhere.x is 1</p>
<p>We assigned a new value to here.x and it changed the value that we
see via there.x. They are referring to the same object. But the value
that we see via elsewhere.x has not changed, so elsewhere must refer to
a different</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 720</p>
<p>object.</p>
<p>If a variable was an object, then the assignment here.x = 42 would
not change there.x.</p>
<p>The equality operator does NOT test that two objects are equal</p>
<p>Applying the equality (==) operator to reference values tests if the
values refer to the same object. It does <em>not</em> test whether two
(different) objects are "equal" in the intuitive sense.</p>
<p>MutableLocation here = <strong>new</strong> MutableLocation(1,
2);</p>
<p>MutableLocation there = here;</p>
<p>MutableLocation elsewhere = <strong>new</strong> MutableLocation(1,
2);</p>
<p><strong>if</strong> (here == there) {</p>
<p>System.out.println("here is there");</p>
<p>}</p>
<p><strong>if</strong> (here == elsewhere) {</p>
<p>System.out.println("here is elsewhere");</p>
<p>}</p>
<p>This will print "here is there", but it won't print "here is
elsewhere". (The references in here and elsewhere are for</p>
<p>two distinct objects.)</p>
<p>By contrast, if we call the equals(Object) method that we implemented
above, we are going to test if two</p>
<p>MutableLocation instances have an equal location.</p>
<p><strong>if</strong> (here.equals(there)) {</p>
<p>System.out.println("here equals there");</p>
<p>}</p>
<p><strong>if</strong> (here.equals(elsewhere)) {</p>
<p>System.out.println("here equals elsewhere");</p>
<p>}</p>
<p>This will print both messages. In particular, here.equals(elsewhere)
returns <strong>true</strong> because the semantic criteria we</p>
<p>chose for equality of two MutableLocation objects has been
satisfied.</p>
<p>Method calls do NOT pass objects at all</p>
<p>Java method calls use <em>pass by value</em>1 to pass arguments and
return a result.</p>
<p>When you pass a reference value to a method, you're actually passing
a reference to an object <em>by value</em>, which</p>
<p>means that it is creating a copy of the object reference.</p>
<p>As long as both object references are still pointing to the same
object, you can modify that object from either</p>
<p>reference, and this is what causes confusion for some.</p>
<p>However, you are <em>not</em> passing an object by reference2. The
distinction is that if the object reference copy is modified</p>
<p>to point to another object, the original object reference will still
point to the original object.</p>
<p><strong>void</strong> f(MutableLocation foo) {</p>
<p><em>foo = <strong>new</strong> MutableLocation(3, 4);</em> // Point
local foo at a different object. <em>}</em></p>
<p><strong>void</strong> g() {</p>
<p>MutableLocation foo = MutableLocation(1, 2);</p>
<p>f(foo);</p>
<p>System.out.println("foo.x is " + foo.x); <em>// Prints "foo.x is
1".</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 721</p>
<p><span id="_50" class="anchor"></span>}</p>
<p>Neither are you passing a copy of the object.</p>
<p><strong>void</strong> f(MutableLocation foo) {</p>
<p>foo.x = 42;</p>
<p>}</p>
<p><strong>void</strong> g() {</p>
<p>MutableLocation foo = <strong>new</strong> MutableLocation(0, 0);</p>
<p>f(foo);</p>
<p>System.out.println("foo.x is " + foo.x); <em>// Prints "foo.x is
42"</em></p>
<p>}</p>
<p>1 - In languages like Python and Ruby, the term "pass by sharing" is
preferred for "pass by value" of an object /</p>
<p>reference.</p>
<p>2 - The term "pass by reference" or "call by reference" has a very
specific meaning in programming language</p>
<p>terminology. In effect, it means that you pass the address <em>of a
variable or an array element</em>, so that when the called method
assigns a new value to the formal argument, it changes the value in the
original variable. Java does not</p>
<p>support this. For a more fulsome description of different mechanisms
for passing parameters, please refer to</p>
<p><a
href="https://en.wikipedia.org/wiki/Evaluation_strategy">https://en.wikipedia.org/wiki/Evaluation_strategy.</a></p>
<p>Section 130.6: Pitfall: memory leaks</p>
<p>Java manages memory automatically. You are not required to free
memory manually. An object's memory on the heap may be freed by a
garbage collector when the object is no longer <em>reachable</em> by a
live thread.</p>
<p>However, you can prevent memory from being freed, by allowing objects
to be reachable that are no longer needed. Whether you call this a
memory leak or memory packratting, the result is the same -- an
unnecessary</p>
<p>increase in allocated memory.</p>
<p>Memory leaks in Java can happen in various ways, but the most common
reason is everlasting object references,</p>
<p>because the garbage collector can’t remove objects from the heap
while there are still references to them.</p>
<p>Static fields</p>
<p>One can create such a reference by defining class with a
<strong>static</strong> field containing some collection of objects, and
forgetting to set that <strong>static</strong> field to
<strong>null</strong> after the collection is no longer needed.
<strong>static</strong> fields are considered GC</p>
<p>roots and are never collected. Another issue is leaks in non-heap
memory when <a
href="https://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a> is
used.</p>
<p>Classloader leak</p>
<p><a href="https://zeroturnaround.com/rebellabs/rjc201/">By far,
though, the most insidious type of memory leak is the classloader
leak</a>. A classloader holds a reference to</p>
<p>every class it has loaded, and every class holds a reference to its
classloader. Every object holds a reference to its class as well.
Therefore, if even a <em>single</em> object of a class loaded by a
classloader is not garbage, not a single class</p>
<p>that that classloader has loaded can be collected. Since each class
also refers to its static fields, they cannot be collected either.</p>
<p><strong>Accumulation leak</strong> The accumulation leak example
could look like the following:</p>
<p><strong>final</strong> ScheduledExecutorService
scheduledExecutorService = Executors.newScheduledThreadPool(1);
<strong>final</strong> Deque numbers = <strong>new</strong>
LinkedBlockingDeque&lt;&gt;(); <strong>final</strong> BigDecimal divisor
= <strong>new</strong> BigDecimal(51);</p>
<p>scheduledExecutorService.scheduleAtFixedRate(()-&gt; {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 722</p>
<p><span id="BigDecimal_number___numbers_peek"
class="anchor"></span>BigDecimal number = numbers.peekLast();</p>
<p><strong>if</strong> (number != <strong>null</strong> &amp;&amp;
number.remainder(divisor).byteValue() == 0) {</p>
<p>System.out.println("Number: " + number);</p>
<p>System.out.println("Deque size: " + numbers.size());</p>
<p>}</p>
<p>}, 10, 10, TimeUnit.MILLISECONDS);</p>
<p>scheduledExecutorService.scheduleAtFixedRate(()-&gt; {</p>
<p>numbers.add(<strong>new</strong>
BigDecimal(System.currentTimeMillis())); }, 10, 10,
TimeUnit.MILLISECONDS);</p>
<p>try <strong>{</strong></p>
<p>scheduledExecutorService.awaitTermination(1, TimeUnit.DAYS); }
<strong>catch</strong> (InterruptedException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>This example creates two scheduled tasks. The first task takes the
last number from a deque called numbers, and, if the number is divisible
by 51, it prints the number and the deque's size. The second task puts
numbers into the</p>
<p>deque. Both tasks are scheduled at a fixed rate, and they run every
10 ms.</p>
<p>If the code is executed, you’ll see that the size of the deque is
permanently increasing. This will eventually cause the deque to be
filled with objects that consume all available heap memory.</p>
<p>To prevent this while preserving the semantics of this program, we
can use a different method for taking numbers from the deque: pollLast.
Contrary to the method peekLast, pollLast returns the element and
removes it from</p>
<p>the deque while peekLast only returns the last element.</p>
<p>Section 130.7: Pitfall: Not understanding that String is an</p>
<p>immutable class</p>
<p>New Java programmers often forget, or fail to fully comprehend, that
the Java String class is immutable. This leads</p>
<p>to problems like the one in the following example:</p>
<p>public class <strong>Shout {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>for</strong> (String s : args) {</p>
<p>s.toUpperCase();</p>
<p>System.out.print(s);</p>
<p>System.out.print(" ");</p>
<p>}</p>
<p>System.out.println();</p>
<p>}</p>
<p>}</p>
<p>The above code is supposed to print command line arguments in upper
case. Unfortunately, it does not work, the</p>
<p>case of the arguments is not changed. The problem is this
statement:</p>
<p>s.toUpperCase();</p>
<p>You might think that calling toUpperCase() is going to change s to an
uppercase string. It doesn't. It can't! String</p>
<p>objects are immutable. They cannot be changed.</p>
<p>In reality, the toUpperCase() method <em>returns</em> a String object
which is an uppercase version of the String that you</p>
<p>call it on. This will probably be a new String object, but if s was
already all uppercase, the result could be the existing string.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 723</p>
<p><span id="So_in_order_to_use_this_method_e" class="anchor"></span>So
in order to use this method effectively, you need to use the object
returned by the method call; for example:</p>
<p>s = s.toUpperCase();</p>
<p>In fact, the "strings never change" rule applies to all String
methods. If you remember that, then you can avoid a whole category of
beginner's mistakes.</p>
<p>Section 130.8: Pitfall: combining assignment and side-eects</p>
<p>Occasionally we see StackOverflow Java questions (and C or C++
questions) that ask what something like this:</p>
<p>i += a[i++] + b[i--];</p>
<p>evaluates to ... for some known initial states of i, a and b.</p>
<p>Generally speaking:</p>
<p>for Java the answer is always specified1, but non-obvious, and often
difficult to figure out</p>
<p>for C and C++ the answer is often unspecified.</p>
<p>Such examples are often used in exams or job interviews as an attempt
to see if the student or interviewee</p>
<p>understands how expression evaluation really works in the Java
programming language. This is arguably legitimate as a "test of
knowledge", but that does not mean that you should ever do this in a
real program.</p>
<p>To illustrate, the following seemingly simple example has appeared a
few times in StackOverflow questions (like <a
href="http://stackoverflow.com/questions/7911776">this</a></p>
<p><a href="http://stackoverflow.com/questions/7911776">one</a>). In
some cases, it appears as a genuine mistake in someone's code.</p>
<p><strong>int</strong> a = 1;</p>
<p>a = a++;</p>
<p><em>System.out.println(a);</em> // What does this print.</p>
<p>Most programmers (including Java experts) reading those statements
<em>quickly</em> would say that it outputs 2. In fact, it</p>
<p>outputs 1. For a detailed explanation of why, please read <a
href="http://stackoverflow.com/a/12033710/139985">this Answer</a>.</p>
<p>However the real takeaway from this and similar examples is that
<em>any</em> Java statement that <em>both</em> assigns to <em>and</em>
side-effects the same variable is going to be <em>at best</em> hard to
understand, and <em>at worst</em> downright misleading. You should</p>
<p>avoid writing code like this.</p>
<p>1 - modulo potential issues with the Java Memory Model if the
variables or objects are visible to other threads.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 724</p>
<p><span id="Chapter_131__Java_Pitfalls___Exc_1"
class="anchor"></span>Chapter 131: Java Pitfalls - Exception usage</p>
<p>Several Java programming language misusage might conduct a program to
generate incorrect results despite being</p>
<p>compiled correctly. This topic main purpose is to list common
<strong>pitfalls</strong> related to <strong>exception
handling</strong>, and to</p>
<p>propose the correct way to avoid having such pitfalls.</p>
<p>Section 131.1: Pitfall - Catching Throwable, Exception, Error or</p>
<p>RuntimeException</p>
<p>A common thought pattern for inexperienced Java programmers is that
exceptions are "a problem" or "a burden" and the best way to deal with
this is catch them all1 as soon as possible. This leads to code like
this:</p>
<p>....</p>
<p>try <strong>{</strong></p>
<p>InputStream is = <strong>new</strong> FileInputStream(fileName);</p>
<p>// process the input</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>System.out.println("Could not open file " + fileName);</p>
<p>}</p>
<p>The above code has a significant flaw. The <strong>catch</strong> is
actually going to catch more exceptions than the programmer is
expecting. Suppose that the value of the fileName is
<strong>null</strong>, due to a bug elsewhere in the application. This
will cause</p>
<p>the FileInputStream constructor to throw a NullPointerException. The
handler will catch this, and report to the</p>
<p>user:</p>
<p>Could not open file <strong>null</strong></p>
<p>which is unhelpful and confusing. Worse still, suppose that the it
was the "process the input" code that threw the</p>
<p>unexpected exception (checked or unchecked!). Now the user will get
the misleading message for a problem that</p>
<p>didn't occur while opening the file, and may not be related to I/O at
all.</p>
<p>The root of the problem is that the programmer has coded a handler
for Exception. This is almost always a mistake:</p>
<p>Catching Exception will catch all checked exceptions, and most
unchecked exceptions as well. Catching RuntimeException will catch most
unchecked exceptions.</p>
<p>Catching Error will catch unchecked exceptions that signal JVM
internal errors. These errors are generally not recoverable, and should
not be caught.</p>
<p>Catching Throwable will catch all possible exceptions.</p>
<p>The problem with catching too broad a set of exceptions is that the
handler typically cannot handle all of them</p>
<p>appropriately. In the case of the Exception and so on, it is
difficult for the programmer to predict what <em>could</em> be caught;
i.e. what to expect.</p>
<p>In general, the correct solution is to deal with the exceptions that
<em>are</em> thrown. For example, you can catch them and handle them in
situ:</p>
<p>try <strong>{</strong></p>
<p>InputStream is = <strong>new</strong> FileInputStream(fileName);</p>
<p>// process the input</p>
<p>} <strong>catch</strong> (FileNotFoundException ex) {</p>
<p>System.out.println("Could not open file " + fileName);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 725</p>
<p><span id="or_you_can_declare_them_as_throw" class="anchor"></span>or
you can declare them as thrown by the enclosing method.</p>
<p>There are very few situations where catching Exception is
appropriate. The only one that arises commonly is</p>
<p>something like this:</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>// do stuff</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>System.err.println("Unfortunately an error has occurred. " +</p>
<p>"Please report this to X Y Z");</p>
<p>// Write stacktrace to a log file.</p>
<p>System.exit(1);</p>
<p>}</p>
<p>}</p>
<p>Here we genuinely want to deal with all exceptions, so catching
Exception (or even Throwable) is correct.</p>
<p><a href="http://c2.com/cgi/wiki?PokemonExceptionHandling">1 - Also
known as Pokemon Exception Handling.</a></p>
<p>Section 131.2: Pitfall - Ignoring or squashing exceptions</p>
<p>This example is about deliberately ignoring or "squashing"
exceptions. Or to be more precise, it is about how to catch and handle
an exception in a way that ignores it. However, before we describe how
to do this, we should first</p>
<p>point out that squashing exceptions is generally not the correct way
to deal with them.</p>
<p>Exceptions are usually thrown (by something) to notify other parts of
the program that some significant (i.e.</p>
<p>"exceptional") event has occurred. Generally (though not always) an
exception means that something has gone wrong. If you code your program
to squash the exception, there is a fair chance that the problem will
reappear in</p>
<p>another form. To make things worse, when you squash the exception,
you are throwing away the information in the exception object and its
associated stack trace. That is likely to make it harder to figure out
what the original source</p>
<p>of the problem was.</p>
<p>In practice, exception squashing frequently happens when you use an
IDE's auto-correction feature to "fix" a</p>
<p>compilation error caused by an unhandled exception. For example, you
might see code like this:</p>
<p>try <strong>{</strong></p>
<p>inputStream = <strong>new</strong> FileInputStream("someFile");</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>/* add exception handling code here */</p>
<p>}</p>
<p>Clearly, the programmer has accepted the IDE's suggestion to make the
compilation error go away, but the suggestion was inappropriate. (If the
file open has failed, the program should most likely do something about
it.</p>
<p>With the above "correction", the program is liable to fail later;
e.g. with a NullPointerException because inputStream is now
<strong>null</strong>.)</p>
<p>Having said that, here is an example of deliberately squashing an
exception. (For the purposes of argument, assume that we have determined
that an interrupt while showing the selfie is harmless.) The comment
tells the</p>
<p>reader that we squashed the exception deliberately, and why we did
that.</p>
<p>try <strong>{</strong></p>
<p>selfie.show();</p>
<p>} <strong>catch</strong> (InterruptedException e) {</p>
<p>// It doesn't matter if showing the selfie is interrupted.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 726</p>
<p><span id="_51" class="anchor"></span>}</p>
<p>Another conventional way to highlight that we are
<em>deliberately</em> squashing an exception without saying why is to
indicate this with the exception variable's name, like this:</p>
<p>try <strong>{</strong></p>
<p>selfie.show();</p>
<p>} <strong>catch</strong> (InterruptedException ignored) { }</p>
<p>Some IDEs (like IntelliJ IDEA) won't display a warning about the
empty catch block if the variable name is set to</p>
<p>ignored .</p>
<p>Section 131.3: Pitfall - Throwing Throwable, Exception, Error or</p>
<p>RuntimeException</p>
<p>While catching the Throwable, Exception, Error and RuntimeException
exceptions is bad, throwing them is even</p>
<p>worse.</p>
<p>The basic problem is that when your application needs to handle
exceptions, the presence of the top level</p>
<p>exceptions make it hard to discriminate between different error
conditions. For example</p>
<p>try <strong>{</strong></p>
<p>InputStream is = <strong>new</strong> FileInputStream(someFile);
<em>// could throw IOException</em></p>
<p>...</p>
<p><strong>if</strong> (somethingBad) {</p>
<p><strong>throw new</strong> Exception(); <em>// WRONG</em></p>
<p>}</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.err.println("cannot open ...");</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>System.err.println("something bad happened"); <em>// WRONG</em></p>
<p>}</p>
<p>The problem is that because we threw an Exception instance, we are
forced to catch it. However as described in</p>
<p>another example, catching Exception is bad. In this situation, it
becomes difficult to discriminate between the "expected" case of an
Exception that gets thrown if somethingBad is <strong>true</strong>, and
the unexpected case where we</p>
<p>actually catch an unchecked exception such as
NullPointerException.</p>
<p>If the top-level exception is allowed to propagate, we run into other
problems:</p>
<p>We now have to remember all of the different reasons that we threw
the top-level, and discriminate / handle them.</p>
<p>In the case of Exception and Throwable we also need to add these
exceptions to the <strong>throws</strong> clause of methods if we want
the exception to propagate. This is problematic, as described below.</p>
<p>In short, don't throw these exceptions. Throw a more specific
exception that more closely describes the "exceptional event" that has
happened. If you need to, define and use a custom exception class.</p>
<p>Declaring Throwable or Exception in a method's "throws" is
problematic.</p>
<p>It is tempting to replace a long list of thrown exceptions in a
method's <strong>throws</strong> clause with Exception or even
`Throwable. This is a bad idea:</p>
<p>1. It forces the caller to handle (or propagate) Exception.</p>
<p>2. We can no longer rely on the compiler to tell us about specific
checked exceptions that need to be handled.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 727</p>
<p><span id="3__Handling_Exception_properly_i" class="anchor"></span>3.
Handling Exception properly is difficult. It is hard to know what actual
exceptions may be caught, and if you</p>
<p>don't know what could be caught, it is hard to know what recovery
strategy is appropriate.</p>
<p>4. Handling Throwable is even harder, since now you also have to cope
with potential failures that should never</p>
<p>be recovered from.</p>
<p>This advice means that certain other patterns should be avoided. For
example:</p>
<p>try <strong>{</strong></p>
<p>doSomething();</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>report(ex);</p>
<p>throw <strong>ex;</strong></p>
<p>}</p>
<p>The above attempts to log all exceptions as they pass, without
definitively handling them. Unfortunately, prior to</p>
<p>Java 7, the <strong>throw</strong> ex; statement caused the compiler
to think that any Exception could be thrown. That could force you to
declare the enclosing method as <strong>throws</strong> Exception. From
Java 7 onwards, the compiler knows that the set</p>
<p>of exceptions that could be (re-thrown) there is smaller.</p>
<p>Section 131.4: Pitfall - Using exceptions for normal flowcontrol</p>
<p>There is a mantra that some Java experts are won't to recite:</p>
<p>"Exceptions should only be used for exceptional cases."</p>
<p>(For example: <a
href="http://programmers.stackexchange.com/questions/184654">http://programmers.stackexchange.com/questions/184654</a>
)</p>
<p>The essence of this is that is it is a bad idea (in Java) to use
exceptions and exception handling to implement normal flow control. For
example, compare these two ways of dealing with a parameter that could
be null.</p>
<p><strong>public</strong> String truncateWordOrNull(String word,
<strong>int</strong> maxLength) {</p>
<p><strong>if</strong> (word == <strong>null</strong>) {</p>
<p>return <strong>"";</strong></p>
<p>} <strong>else</strong> {</p>
<p><strong>return</strong> word.substring(0, Math.min(word.length(),
maxLength));</p>
<p>}</p>
<p>}</p>
<p><strong>public</strong> String truncateWordOrNull(String word,
<strong>int</strong> maxLength) {</p>
<p>try <strong>{</strong></p>
<p><strong>return</strong> word.substring(0, Math.min(word.length(),
maxLength));</p>
<p>} <strong>catch</strong> (NullPointerException ex) {</p>
<p>return <strong>"";</strong></p>
<p>}</p>
<p>}</p>
<p>In this example, we are (by design) treating the case where word is
<strong>null</strong> as if it is an empty word. The two versions deal
with <strong>null</strong> either using conventional <em>if ...
else</em> and or <em>try ... catch</em>. How should we decide which
version is better?</p>
<p>The first criterion is readability. While readability is hard to
quantify objectively, most programmers would agree that the essential
meaning of the first version is easier to discern. Indeed, in order to
truly understand the second</p>
<p>form, you need to understand that a NullPointerException cannot be
thrown by the Math.min or String.substring methods.</p>
<p>The second criterion is efficiency. In releases of Java prior to Java
8, the second version is significantly (orders of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 728</p>
<p><span id="magnitude__slower_than_the_first"
class="anchor"></span>magnitude) slower than the first version. In
particular, the construction of an exception object entails capturing
and recording the stackframes, just in case the stacktrace is
required.</p>
<p>On the other hand, there are many situations where using exceptions
is more readable, more efficient and (sometimes) more correct than using
conditional code to deal with "exceptional" events. Indeed, there are
rare</p>
<p>situations where it is necessary to use them for "non-exceptional"
events; i.e. events that occur relatively frequently. For the latter, it
is worth looking at ways to reduce the overheads of creating exception
objects.</p>
<p>Section 131.5: Pitfall - Directly subclassing `Throwable`</p>
<p>Throwable has two direct subclasses, Exception and Error. While it's
possible to create a new class that extends Throwable directly, this is
inadvisable as many applications assume only Exception and Error
exist.</p>
<p>More to the point there is no practical benefit to directly
subclassing Throwable, as the resulting class is, in effect, simply a
checked exception. Subclassing Exception instead will result in the same
behavior, but will more clearly</p>
<p>convey your intent.</p>
<p>Section 131.6: Pitfall - Catching InterruptedException</p>
<p>As already pointed out in other pitfalls, catching all exceptions by
using</p>
<p>try <strong>{</strong></p>
<p>// Some code</p>
<p>} <strong>catch</strong> (Exception) {</p>
<p>// Some error handling</p>
<p>}</p>
<p>Comes with a lot of different problems. But one perticular problem is
that it can lead to deadlocks as it breaks the</p>
<p>interrupt system when writing multi-threaded applications.</p>
<p>If you start a thread you usually also need to be able to stop it
abruptly for various reasons.</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>//Do something indefinetely</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>t.start();</p>
<p>//Do something else</p>
<p>// The thread should be canceld if it is still active. // A Better
way to solve this is with a shared variable that is tested // regularily
by the thread for a clean exit, but for this example we try to //
forcibly interrupt this thread.</p>
<p><strong>if</strong> (t.isAlive()) {</p>
<p>t.interrupt();</p>
<p>t.join();</p>
<p>}</p>
<p>//Continue with program</p>
<p>The t.interrupt() will raise an InterruptedException in that thread,
than is intended to shut down the thread. But what if the Thread needs
to clean up some resources before its completely stopped? For this it
can catch the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 729</p>
<p>InterruptedException and do some cleanup.</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>//Do something indefinetely</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException ex) {</p>
<p>//Do some quick cleanup</p>
<p>// In this case a simple return would do.</p>
<p>// But if you are not 100% sure that the thread ends after //
catching the InterruptedException you will need to raise another // one
for the layers surrounding this code.
<em>Thread.currentThread().interrupt();</em></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>But if you have a catch-all expression in your code, the
InterruptedException will be caught by it as well and the</p>
<p>interruption will not continue. Which in this case could lead to a
deadlock as the parent thread waits indefinitely for this thead to stop
with t.join().</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>try <strong>{</strong></p>
<p>//Do something indefinetely</p>
<p>}</p>
<p><strong>catch</strong> (Exception ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException ex) {</p>
<p>// Dead code as the interrupt exception was already caught in // the
inner try-catch</p>
<p>Thread.currentThread().interrupt();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>So it is better to catch Exceptions individually, but if you insist
on using a catch-all, at least catch the</p>
<p>InterruptedException individually beforehand.</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>try <strong>{</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>try <strong>{</strong></p>
<p>//Do something indefinetely</p>
<p>} <strong>catch</strong> (InterruptedException ex) {</p>
<p><em><strong>throw</strong> ex;</em> //Send it up in the chain</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>} <strong>catch</strong> (InterruptedException ex) {</p>
<p>// Some quick cleanup code</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 730</p>
<p><span id="Thread_currentThread___interrupt"
class="anchor"></span>Thread.currentThread().interrupt();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 131.7: Pitfall - Excessive or inappropriate stacktraces</p>
<p>One of the more annoying things that programmers can do is to scatter
calls to printStackTrace() throughout their code.</p>
<p>The problem is that the printStackTrace() is going to write the
stacktrace to standard output.</p>
<p>For an application that is intended for end-users who are not Java
programmers, a stacktrace is uninformative at best, and alarming at
worst.</p>
<p>For a server-side application, the chances are that nobody will look
at the standard output.</p>
<p>A better idea is to not call printStackTrace directly, or if you do
call it, do it in a way that the stack trace is written to a log file or
error file rather than to the end-user's console.</p>
<p>One way to do this is to use a logging framework, and pass the
exception object as a parameter of the log event. However, even logging
the exception can be harmful if done injudiciously. Consider the
following:</p>
<p><strong>public void</strong> method1() <strong>throws</strong>
SomeException {</p>
<p>try <strong>{</strong></p>
<p>method2();</p>
<p>// Do something</p>
<p>} <strong>catch</strong> (SomeException ex) {</p>
<p>Logger.getLogger().warn("Something bad in method1", ex);</p>
<p>throw <strong>ex;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> method2() <strong>throws</strong>
SomeException {</p>
<p>try <strong>{</strong></p>
<p>// Do something else</p>
<p>} <strong>catch</strong> (SomeException ex) {</p>
<p>Logger.getLogger().warn("Something bad in method2", ex);</p>
<p>throw <strong>ex;</strong></p>
<p>}</p>
<p>}</p>
<p>If the exception is thrown in method2, you are likely to see two
copies of the same stacktrace in the logfile,</p>
<p>corresponding to the same failure.</p>
<p>In short, either log the exception or re-throw it further (possibly
wrapped with another exception). Don't do both.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 731</p>
<p><span id="Chapter_132__Java_Pitfalls___Lan_1"
class="anchor"></span>Chapter 132: Java Pitfalls - Language</p>
<p>syntax</p>
<p>Several Java programming language misusage might conduct a program to
generate incorrect results despite being</p>
<p>compiled correctly. This topic main purpose is to list common
pitfalls with their causes, and to propose the correct way to avoid
falling in such problems.</p>
<p>Section 132.1: Pitfall - Missing a ‘break’ in a 'switch' case</p>
<p>These Java issues can be very embarrassing, and sometimes remain
undiscovered until run in production.</p>
<p>Fallthrough behavior in switch statements is often useful; however,
missing a “break” keyword when such behavior</p>
<p>is not desired can lead to disastrous results. If you have forgotten
to put a “break” in “case 0” in the code example below, the program will
write “Zero” followed by “One”, since the control flow inside here will
go through the entire</p>
<p>“switch” statement until it reaches a “break”. For example:</p>
<p><strong>public static void</strong> switchCasePrimer() {</p>
<p><strong>int</strong> caseIndex = 0;</p>
<p><strong>switch</strong> (caseIndex) {</p>
<p>case <strong>0:</strong></p>
<p>System.out.println("Zero");</p>
<p>case <strong>1:</strong></p>
<p>System.out.println("One");</p>
<p>break<strong>;</strong></p>
<p>case <strong>2:</strong></p>
<p>System.out.println("Two");</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p>System.out.println("Default");</p>
<p>}</p>
<p>}</p>
<p>In most cases, the cleaner solution would be to use interfaces and
move code with specific behaviour into separate implementations
(<em>composition over inheritance</em>)</p>
<p>If a switch-statement is unavoidable it is recommended to document
"expected" fallthroughs if they occur. That way you show fellow
developers that you are aware of the missing break, and that this is
expected behaviour.</p>
<p><strong>switch</strong>(caseIndex) {</p>
<p>[...]</p>
<p>case <strong>2:</strong></p>
<p>System.out.println("Two");</p>
<p>// fallthrough</p>
<p>default<strong>:</strong></p>
<p>System.out.println("Default");</p>
<p>Section 132.2: Pitfall - Declaring classes with the same names</p>
<p>as standard classes</p>
<p>Sometimes, programmers who are new to Java make the mistake of
defining a class with a name that is the same</p>
<p>as a widely used class. For example:</p>
<p><strong>package</strong> com.example;</p>
<p>/**</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 732</p>
<p><span id="__My_string_utilities" class="anchor"></span> * My string
utilities</p>
<p>*/</p>
<p>public class <strong>String {</strong></p>
<p>....</p>
<p>}</p>
<p>Then they wonder why they get unexpected errors. For example:</p>
<p><strong>package</strong> com.example;</p>
<p>public class <strong>Test {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>System.out.println("Hello world!");</p>
<p>}</p>
<p>}</p>
<p>If you compile and then attempt to run the above classes you will get
an error:</p>
<p>$ javac com/example<em>/*.java</em></p>
<p>$ java com.example.Test</p>
<p>Error: Main method not found in class test.Test, please define the
main method as:</p>
<p>public static void main(String[] args)</p>
<p>or a JavaFX application class must extend
javafx.application.Application</p>
<p>Someone looking at the code for the Test class would see the
declaration of main and look at its signature and</p>
<p>wonder what the java command is complaining about. But in fact, the
java command is telling the truth.</p>
<p>When we declare a version of String in the same package as Test, this
version takes precedence over the</p>
<p>automatic import of java.lang.String. Thus, the signature of the
Test.main method is actually</p>
<p><strong>void</strong> main(com.example.String[] args)</p>
<p>instead of</p>
<p><strong>void</strong> main(java.lang.String[] args)</p>
<p>and the java command will not recognize <em>that</em> as an
entrypoint method.</p>
<p>Lesson: Do not define classes that have the same name as existing
classes in java.lang, or other commonly used classes in the Java SE
library. If you do that, you are setting yourself open for all sorts of
obscure errors.</p>
<p>Section 132.3: Pitfall - Leaving out braces: the "dangling if"</p>
<p>and "dangling else" problems</p>
<p>The latest version of the Oracle Java style guide mandates that the
"then" and "else" statements in an if statement should always be
enclosed in "braces" or "curly brackets". Similar rules apply to the
bodies of various loop</p>
<p>statements.</p>
<p><em><strong>if</strong> (a) {</em> // &lt;- open brace</p>
<p>doSomething();</p>
<p>doSomeMore();</p>
<p><em>}</em> // &lt;- close brace</p>
<p>This is not actually required by Java language syntax. Indeed, if the
"then" part of an if statement is a single</p>
<p>statement, it is legal to leave out the braces</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 733</p>
<p><strong>if</strong> (a)</p>
<p>doSomething();</p>
<p>or even</p>
<p><strong>if</strong> (a) doSomething();</p>
<p>However there are dangers in ignoring Java style rules and leaving
out the braces. Specifically, you significantly increase the risk that
code with faulty indentation will be misread.</p>
<p>The "dangling if" problem:</p>
<p>Consider the example code from above, rewritten without braces.</p>
<p><strong>if</strong> (a)</p>
<p>doSomething();</p>
<p>doSomeMore();</p>
<p>This code <em>seems to say</em> that the calls to doSomething and
doSomeMore will both occur <em>if and only if</em> a is
<strong>true</strong>. In fact, the code is incorrectly indented. The
Java Language Specification that the doSomeMore() call is a separate
statement</p>
<p>following the if statement. The correct indentation is as
follows:</p>
<p><strong>if</strong> (a)</p>
<p>doSomething();</p>
<p>doSomeMore();</p>
<p>The "dangling else" problem</p>
<p>A second problem appears when we add <strong>else</strong> to the
mix. Consider the following example with missing braces.</p>
<p><strong>if</strong> (a)</p>
<p><strong>if</strong> (b)</p>
<p>doX();</p>
<p>else if <strong>(c)</strong></p>
<p>doY();</p>
<p>else</p>
<p>doZ();</p>
<p>The code above <em>seems to say</em> that doZ will be called when a
is <strong>false</strong>. In fact, the indentation is incorrect once
again.</p>
<p>The correct indentation for the code is:</p>
<p><strong>if</strong> (a)</p>
<p><strong>if</strong> (b)</p>
<p>doX();</p>
<p>else if <strong>(c)</strong></p>
<p>doY();</p>
<p>else</p>
<p>doZ();</p>
<p>If the code was written according to the Java style rules, it would
actually look like this:</p>
<p><strong>if</strong> (a) {</p>
<p><strong>if</strong> (b) {</p>
<p>doX();</p>
<p>} <strong>else if</strong> (c) {</p>
<p>doY();</p>
<p>} <strong>else</strong> {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 734</p>
<p><span id="doZ" class="anchor"></span>doZ();</p>
<p>}</p>
<p>}</p>
<p>To illustrate why that is better, suppose that you had accidentally
mis-indented the code. You might end up with something like this:</p>
<p><strong>if</strong> (a) { <strong>if</strong> (a) {</p>
<p><strong>if</strong> (b) { <strong>if</strong> (b) {</p>
<p>doX(); doX();</p>
<p>} <strong>else if</strong> (c) { } <strong>else if</strong> (c) {</p>
<p>doY(); doY();</p>
<p>} <strong>else</strong> { } <strong>else</strong> {</p>
<p>doZ(); doZ();</p>
<p>} }</p>
<p>} }</p>
<p>But in both cases, the mis-indented code "looks wrong" to the eye of
an experienced Java programmer.</p>
<p>Section 132.4: Pitfall - Octal literals</p>
<p>Consider the following code snippet:</p>
<p>// Print the sum of the numbers 1 to 10</p>
<p><strong>int</strong> count = 0;</p>
<p><strong>for</strong> (<strong>int</strong> i = 1; i &lt; 010; i++) {
<em>// Mistake here ....</em></p>
<p>count = count + i;</p>
<p>}</p>
<p>System.out.println("The sum of 1 to 10 is " + count);</p>
<p>A Java beginner might be surprised to know that the above program
prints the wrong answer. It actually prints the</p>
<p>sum of the numbers 1 to 8.</p>
<p>The reason is that an integer literal that starts with the digit zero
('0') is interpreted by the Java compiler as an octal</p>
<p>literal, not a decimal literal as you might expect. Thus, 010 is the
octal number 10, which is 8 in decimal.</p>
<p>Section 132.5: Pitfall - Using '==' to test a boolean</p>
<p>Sometimes a new Java programmer will write code like this:</p>
<p>public void <strong>check(</strong>boolean <strong>ok) {</strong></p>
<p><em><strong>if</strong> (ok == <strong>true</strong>) {</em> // Note
'ok == true'</p>
<p>System.out.println("It is OK");</p>
<p>}</p>
<p>}</p>
<p>An experienced programmer would spot that as being clumsy and want to
rewrite it as:</p>
<p>public void <strong>check(</strong>boolean <strong>ok) {</strong></p>
<p><strong>if</strong> (ok) {</p>
<p>System.out.println("It is OK");</p>
<p>}</p>
<p>}</p>
<p>However, there is more wrong with ok == <strong>true</strong> than
simple clumsiness. Consider this variation:</p>
<p>public void <strong>check(</strong>boolean <strong>ok) {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 735</p>
<p><span id="if__ok___true__________________O"
class="anchor"></span><strong>if</strong> (ok = <strong>true</strong>) {
<em>// Oooops!</em></p>
<p>System.out.println("It is OK");</p>
<p>}</p>
<p>}</p>
<p>Here the programmer has mistyped == as = ... and now the code has a
subtle bug. The expression x = <strong>true</strong></p>
<p>unconditionally assigns <strong>true</strong> to x and then evaluates
to <strong>true</strong>. In other words, the check method will now
print "It is OK" no matter what the parameter was.</p>
<p>The lesson here is to get out of the habit of using ==
<strong>false</strong> and == <strong>true</strong>. In addition to
being verbose, they make your coding more error prone.</p>
<p>Note: A possible alternative to ok == <strong>true</strong> that
avoids the pitfall is to use <a
href="https://en.wikipedia.org/wiki/Yoda_conditions">Yoda conditions;
i.e. put the literal on the</a> left side of the relational operator, as
in <strong>true</strong> == ok. This works, but most programmers would
probably agree that</p>
<p>Yoda conditions look odd. Certainly ok (or !ok) is more concise and
more natural.</p>
<p>Section 132.6: Pitfall - Ignoring method visibility</p>
<p>Even experienced Java developers tend to think that Java has only
three protection modifiers. The language actually</p>
<p>has four! The <strong>package private</strong> (a.k.a. default) level
of visibility is often forgotten.</p>
<p>You should pay attention to what methods you make public. The public
methods in an application are the</p>
<p>application’s visible API. This should be as small and compact as
possible, especially if you are writing a reusable</p>
<p>library (see also the <a
href="https://en.wikipedia.org/wiki/Open/closed_principle">SOLID
principle). It is important to similarly consider the visibility of all
methods, and to only</a></p>
<p>use protected or package private access where appropriate.</p>
<p>When you declare methods that should be <strong>private</strong> as
public, you expose the internal implementation details of the</p>
<p>class.</p>
<p>A corollary to this is that you only <a
href="http://www.tutorialspoint.com/junit/junit_test_framework.htm">unit
test</a> the public methods of your class - in fact you can
<strong>only</strong> test public</p>
<p>methods. It is bad practice to increase the visibility of private
methods just to be able to run unit tests against those</p>
<p>methods. Testing public methods that call the methods with more
restrictive visibility should be sufficient to test an entire API. You
should <strong>never</strong> expand your API with more public methods
only to allow unit testing.</p>
<p>Section 132.7: Pitfall: Using 'assert' for argument or user input</p>
<p>validation</p>
<p>A question that occasionally on StackOverflow is whether it is
appropriate to use <strong>assert</strong> to validate arguments
supplied to a method, or even inputs provided by the user.</p>
<p>The simple answer is that it is not appropriate.</p>
<p>Better alternatives include:</p>
<p>Throwing an IllegalArgumentException using custom code.</p>
<p>Using the Preconditions methods available in Google Guava library.
Using the Validate methods available in Apache Commons Lang3
library.</p>
<p>This is what the <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.10">Java
Language Specification (JLS 14.10, for Java 8) advises on this
matter:</a></p>
<p>Typically, assertion checking is enabled during program development
and testing, and disabled for deployment, to improve performance.</p>
<p>Because assertions may be disabled, programs must not assume that the
expressions contained in</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 736</p>
<p><span id="assertions_will_be_evaluated__Th"
class="anchor"></span>assertions will be evaluated. Thus, these boolean
expressions should generally be free of side effects. Evaluating such a
boolean expression should not affect any state that is visible after the
evaluation is</p>
<p>complete. It is not illegal for a boolean expression contained in an
assertion to have a side effect, but it is</p>
<p>generally inappropriate, as it could cause program behavior to vary
depending on whether assertions were enabled or disabled.</p>
<p>In light of this, assertions should not be used for argument checking
in public methods. Argument</p>
<p>checking is typically part of the contract of a method, and this
contract must be upheld whether</p>
<p>assertions are enabled or disabled.</p>
<p>A secondary problem with using assertions for argument checking is
that erroneous arguments should result in an appropriate run-time
exception (such as IllegalArgumentException,</p>
<p>ArrayIndexOutOfBoundsException, or NullPointerException). An
assertion failure will not throw an</p>
<p>appropriate exception. Again, it is not illegal to use assertions for
argument checking on public methods, but it is generally inappropriate.
It is intended that AssertionError never be caught, but it is possible
to</p>
<p>do so, thus the rules for try statements should treat assertions
appearing in a try block similarly to the current treatment of throw
statements.</p>
<p>Section 132.8: Pitfall - Wildcard imports can make your code</p>
<p>fragile</p>
<p>Consider the following partial example:</p>
<p><strong>import</strong> com.example.somelib.*;</p>
<p><strong>import</strong> com.acme.otherlib.*;</p>
<p>public class <strong>Test {</strong></p>
<p><em><strong>private</strong> Context x = <strong>new</strong>
Context();</em> // from com.example.somelib</p>
<p>...</p>
<p>}</p>
<p>Suppose that when when you first developed the code against version
1.0 of somelib and version 1.0 of otherlib.</p>
<p>Then at some later point, you need to upgrade your dependencies to a
later versions, and you decide to use</p>
<p>otherlib version 2.0. Also suppose that one of the changes that they
made to otherlib between 1.0 and 2.0 was to add a Context class.</p>
<p>Now when you recompile Test, you will get a compilation error telling
you that Context is an ambiguous import.</p>
<p>If you are familiar with the codebase, this probably is just a minor
inconvenience. If not, then you have some work to do to address this
problem, here and potentially elsewhere.</p>
<p>The problem here is the wildcard imports. On the one hand, using
wildcards can make your classes a few lines shorter. On the other
hand:</p>
<p>Upwards compatible changes to other parts of your codebase, to Java
standard libraries or to 3rd party libraries can lead to compilation
errors.</p>
<p>Readability suffers. Unless you are using an IDE, figuring out which
of the wildcard imports is pulling in a</p>
<p>named class can be difficult.</p>
<p>The lesson is that it is a bad idea to use wildcard imports in code
that needs to be long lived. Specific (non-wildcard)</p>
<p>imports are not much effort to maintain if you use an IDE, and the
effort is worthwhile.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 737</p>
<p><span id="Section_132_9__Pitfall___Misplac"
class="anchor"></span>Section 132.9: Pitfall - Misplaced semicolons and
missing</p>
<p>braces</p>
<p>This is a mistake that causes real confusion for Java beginners, at
least the first time that they do it. Instead of writing this:</p>
<p><strong>if</strong> (feeling == HAPPY)</p>
<p>System.out.println("Smile");</p>
<p>else</p>
<p>System.out.println("Frown");</p>
<p>they accidentally write this:</p>
<p><strong>if</strong> (feeling == HAPPY);</p>
<p>System.out.println("Smile");</p>
<p>else</p>
<p>System.out.println("Frown");</p>
<p>and are puzzled when the Java compiler tells them that the
<strong>else</strong> is misplaced. The Java compiler with interpret the
above as follows:</p>
<p><strong>if</strong> (feeling == HAPPY)</p>
<p>/*empty statement*/ <em>;</em></p>
<p><em>System.out.println("Smile");</em> // This is unconditional
<em><strong>else</strong></em> // This is misplaced. A statement
cannot</p>
<p>// start with 'else'</p>
<p>System.out.println("Frown");</p>
<p>In other cases, there will be no be compilation errors, but the code
won't do what the programmer intends. For example:</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 5; i++);</p>
<p>System.out.println("Hello");</p>
<p>only prints "Hello" once. Once again, the spurious semicolon means
that the body of the <strong>for</strong> loop is an empty statement.
That means that the println call that follows is unconditional.</p>
<p>Another variation:</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 5; i++);</p>
<p>System.out.println("The number is " + i);</p>
<p>This will give a "Cannot find symbol" error for i. The presence of
the spurious semicolon means that the println call is attempting to use
i outside of its scope.</p>
<p>In those examples, there is a straight-forward solution: simply
delete the spurious semicolon. However, there are some deeper lessons to
be drawn from these examples:</p>
<p>1. The semicolon in Java is not "syntactic noise". The presence or
absence of a semicolon can change the</p>
<p>meaning of your program. Don't just add them at the end of every
line.</p>
<p>2. Don't trust your code's indentation. In the Java language, extra
whitespace at the beginning of a line is</p>
<p>ignored by the compiler.</p>
<p>3. Use an automatic indenter. All IDEs and many simple text editors
understand how to correctly indent Java</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 738</p>
<p><span id="code" class="anchor"></span>code.</p>
<p>4. This is the most important lesson. Follow the latest Java style
guidelines, and put braces around the "then"</p>
<p>and "else" statements and the body statement of a loop. The open
brace ({) should not be on a new line.</p>
<p>If the programmer followed the style rules then the if example with a
misplaced semicolons would look like this:</p>
<p><strong>if</strong> (feeling == HAPPY); {</p>
<p>System.out.println("Smile");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Frown");</p>
<p>}</p>
<p>That looks odd to an experienced eye. If you auto-indented that code,
it would probably look like this:</p>
<p><strong>if</strong> (feeling == HAPPY); {</p>
<p>System.out.println("Smile");</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("Frown");</p>
<p>}</p>
<p>which should stand out as wrong to even a beginner.</p>
<p>Section 132.10: Pitfall - Overloading instead of overriding</p>
<p>Consider the following example:</p>
<p>public final class <strong>Person {</strong></p>
<p><strong>private final</strong> String firstName;</p>
<p><strong>private final</strong> String lastName;</p>
<p><strong>public</strong> Person(String firstName, String lastName)
{</p>
<p><strong>this</strong>.firstName = (firstName ==
<strong>null</strong>) ? "" : firstName;</p>
<p><strong>this</strong>.lastName = (lastName == <strong>null</strong>)
? "" : lastName;</p>
<p>}</p>
<p><strong>public boolean</strong> equals(String other) {</p>
<p><strong>if</strong> (!(other <strong>instanceof</strong> Person))
{</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>Person p = (Person) other;</p>
<p><strong>return</strong> firstName.equals(p.firstName) &amp;&amp;</p>
<p>lastName.equals(p.lastName);</p>
<p>}</p>
<p><strong>public int</strong> hashcode() {</p>
<p><strong>return</strong> firstName.hashCode() + 31 *
lastName.hashCode();</p>
<p>}</p>
<p>}</p>
<p>This code is not going to behave as expected. The problem is that the
equals and hashcode methods for Person do</p>
<p>not override the standard methods defined by Object.</p>
<p>The equals method has the wrong signature. It should be declared as
equals(Object) not equals(String).</p>
<p>The hashcode method has the wrong name. It should be hashCode() (note
the capital <strong>C</strong>).</p>
<p>These mistakes mean that we have declared accidental overloads, and
these won't be used if Person is used in a</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 739</p>
<p><span id="polymorphic_context" class="anchor"></span>polymorphic
context.</p>
<p>However, there is a simple way to deal with this (from Java 5
onwards). Use the @Override annotation whenever</p>
<p>you <em>intend</em> your method to be an override:</p>
<p>Version ≥ Java SE 5</p>
<p>public final class <strong>Person {</strong></p>
<p>...</p>
<p>@Override</p>
<p><strong>public boolean</strong> equals(String other) {</p>
<p>....</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> hashcode() {</p>
<p>....</p>
<p>}</p>
<p>}</p>
<p>When we add an @Override annotation to a method declaration, the
compiler will check that the method <em>does</em></p>
<p>override (or implement) a method declared in a superclass or
interface. So in the example above, the compiler will give us two
compilation errors, which should be enough to alert us to the
mistake.</p>
<p>Section 132.11: Pitfall of Auto-Unboxing Null Objects into</p>
<p>Primitives</p>
<p>public class <strong>Foobar {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// example:</p>
<p>Boolean ignore = <strong>null</strong>;</p>
<p><strong>if</strong> (ignore == <strong>false</strong>) {</p>
<p>System.out.println("Do not ignore!");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The pitfall here is that <strong>null</strong> is compared to
<strong>false</strong>. Since we're comparing a primitive
<strong>boolean</strong> against a Boolean, Java attempts to
<em>unbox</em> the the Boolean Object into a primitive equivalent, ready
for comparison. However, since</p>
<p>that value is <strong>null</strong>, a NullPointerException is
thrown.</p>
<p>Java is incapable of comparing primitive types against
<strong>null</strong> values, which causes a NullPointerException at</p>
<p>runtime. Consider the primitive case of the condition
<strong>false</strong> == <strong>null</strong>; this would generate a
<em>compile time</em> error incomparable types: <strong>int</strong> and
.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 740</p>
<p><span id="Chapter_133__Java_Pitfalls___Thr_1"
class="anchor"></span>Chapter 133: Java Pitfalls - Threads and</p>
<p>Concurrency</p>
<p>Section 133.1: Pitfall - Extending 'java.lang.Thread'</p>
<p>The javadoc for the Thread class shows two ways to define and use a
thread:</p>
<p>Using a custom thread class:</p>
<p><strong>class</strong> PrimeThread <strong>extends</strong> Thread
{</p>
<p><strong>long</strong> minPrime;</p>
<p>PrimeThread(<strong>long</strong> minPrime) {</p>
<p><strong>this</strong>.minPrime = minPrime;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p>// compute primes larger than minPrime</p>
<p>. . .</p>
<p>}</p>
<p>}</p>
<p>PrimeThread p = <strong>new</strong> PrimeThread(143);</p>
<p>p.start();</p>
<p>Using a Runnable:</p>
<p><strong>class</strong> PrimeRun <strong>implements</strong> Runnable
{</p>
<p><strong>long</strong> minPrime;</p>
<p>PrimeRun(<strong>long</strong> minPrime) {</p>
<p><strong>this</strong>.minPrime = minPrime;</p>
<p>}</p>
<p>public void <strong>run() {</strong></p>
<p>// compute primes larger than minPrime</p>
<p>. . .</p>
<p>}</p>
<p>}</p>
<p>PrimeRun p = <strong>new</strong> PrimeRun(143);</p>
<p><strong>new</strong> Thread(p).start();</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">(Source:
java.lang.Thread javadoc.)</a></p>
<p>The custom thread class approach works, but it has a few
problems:</p>
<p>1. It is awkward to use PrimeThread in a context that uses a classic
thread pool, an executor, or the ForkJoin</p>
<p>framework. (It is not impossible, because PrimeThread indirectly
implements Runnable, but using a custom</p>
<p>Thread class as a Runnable is certainly clumsy, and may not be viable
... depending on other aspects of the class.)</p>
<p>2. There is more opportunity for mistakes in other methods. For
example, if you declared a</p>
<p>PrimeThread.start() without delegating to Thread.start(), you would
end up with a "thread" that ran on the current thread.</p>
<p>The approach of putting the thread logic into a Runnable avoids these
problems. Indeed, if you use an anonymous</p>
<p>class (Java 1.1 onwards) to implement the Runnable the result is more
succinct, and more readable than the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 741</p>
<p><span id="examples_above" class="anchor"></span>examples above.</p>
<p><strong>final long</strong> minPrime = ...</p>
<p><strong>new</strong> Thread(<strong>new</strong> Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>// compute primes larger than minPrime</p>
<p>. . .</p>
<p>}</p>
<p>}.start();</p>
<p>With a lambda expression (Java 8 onwards), the above example would
become even more elegant:</p>
<p><strong>final long</strong> minPrime = ...</p>
<p><strong>new</strong> Thread(()-&gt; {</p>
<p>// compute primes larger than minPrime</p>
<p>. . .</p>
<p>}).start();</p>
<p>Section 133.2: Pitfall - Too many threads makes an application</p>
<p>slower</p>
<p>A lot of people who are new to multi-threading think that using
threads automatically make an application go faster. In fact, it is a
lot more complicated than that. But one thing that we can state with
certainty is that for any</p>
<p>computer there is a limit on the number of threads that can be run at
the same time:</p>
<p>A computer has a fixed number of <em>cores</em> (or
<em>hyperthreads</em>).</p>
<p>A Java thread has to be <em>scheduled</em> to a core or hyperthread
in order to run. If there are more runnable Java threads than
(available) cores / hyperthreads, some of them must wait.</p>
<p>This tells us that simply creating more and more Java threads
<em>cannot</em> make the application go faster and faster. But there are
other considerations as well:</p>
<p>Each thread requires an off-heap memory region for its thread stack.
The typical (default) thread stack size is</p>
<p>512Kbytes or 1Mbytes. If you have a significant number of threads,
the memory usage can be significant.</p>
<p>Each active thread will refer to a number of objects in the heap.
That increases the working set of <em>reachable</em> objects, which
impacts on garbage collection and on physical memory usage.</p>
<p>The overheads of switching between threads is non-trivial. It
typically entails a switch into the OS kernel</p>
<p>space to make a thread scheduling decision.</p>
<p>The overheads of thread synchronization and inter-thread signaling
(e.g. wait(), notify() / notifyAll) <em>can be</em> significant.</p>
<p>Depending on the details of your application, these factors generally
mean that there is a "sweet spot" for the number of threads. Beyond
that, adding more threads gives minimal performance improvement, and can
make</p>
<p>performance worse.</p>
<p>If your application create for each new task, then an unexpected
increase in the workload (e.g. a high request rate)</p>
<p>can lead to catastrophic behavior.</p>
<p>A better way to deal with this is to use bounded thread pool whose
size you can control (statically or dynamically).</p>
<p>When there is too much work to do, the application needs to queue the
requests. If you use an ExecutorService, it will take care of the thread
pool management and task queuing.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 742</p>
<p><span id="Section_133_3__Pitfall__incorrec"
class="anchor"></span>Section 133.3: Pitfall: incorrect use of wait() /
notify()</p>
<p>The methods object.wait(), object.notify() and object.notifyAll() are
meant to be used in a very specific</p>
<p>way. (see
http://stackoverflow.com/documentation/java/5409/wait-notify#t=20160811161648303307
)</p>
<p>The "Lost Notification" problem</p>
<p>One common beginner mistake is to unconditionally call
object.wait()</p>
<p><strong>private final</strong> Object lock = <strong>new</strong>
Object();</p>
<p><strong>public void</strong> myConsumer() {</p>
<p>synchronized <strong>(lock) {</strong></p>
<p><em>lock.wait();</em> // DON'T DO THIS!!</p>
<p>}</p>
<p>doSomething();</p>
<p>}</p>
<p>The reason this is wrong is that it depends on some other thread to
call lock.notify() or lock.notifyAll(), but nothing guarantees that the
other thread did not make that call <em>before</em> the consumer thread
called lock.wait().</p>
<p>lock.notify() and lock.notifyAll() do not do anything at all if some
other thread is not <em>already</em> waiting for the notification. The
thread that calls myConsumer() in this example will hang forever if it
is too late to catch the</p>
<p>notification.</p>
<p>The "Illegal Monitor State" bug</p>
<p>If you call wait() or notify() on an object without holding the lock,
then the JVM will throw</p>
<p>IllegalMonitorStateException .</p>
<p><strong>public void</strong> myConsumer() {</p>
<p><em>lock.wait();</em> // throws exception</p>
<p>consume();</p>
<p>}</p>
<p><strong>public void</strong> myProducer() {</p>
<p>produce();</p>
<p><em>lock.notify();</em> // throws exception</p>
<p>}</p>
<p>(The design for wait() / notify() requires that the lock is held
because this is necessary to avoid systemic race</p>
<p>conditions. If it was possible to call wait() or notify() without
locking, then it would be impossible to implement the primary use-case
for these primitives: waiting for a condition to occur.)</p>
<p>Wait / notify is too low-level</p>
<p>The <em>best</em> way to avoid problems with wait() and notify() is
to not use them. Most synchronization problems can be solved by using
the higher-level synchronization objects (queues, barriers, semaphores,
etc.) that are available in</p>
<p>the java.utils.concurrent package.</p>
<p>Section 133.4: Pitfall: Shared variables require proper</p>
<p>synchronization</p>
<p>Consider this example:</p>
<p><strong>public class</strong> ThreadTest <strong>implements</strong>
Runnable {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 743</p>
<p>private boolean <strong>stop =</strong> false<strong>;</strong></p>
<p>public void <strong>run() {</strong></p>
<p><strong>long</strong> counter = 0;</p>
<p><strong>while</strong> (!stop) {</p>
<p>counter = counter + 1;</p>
<p>}</p>
<p>System.out.println("Counted " + counter);</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ThreadTest tt = <strong>new</strong> ThreadTest();</p>
<p><strong>new</strong> Thread(tt).start(); <em>// Create and start
child thread</em> Thread.sleep(1000);</p>
<p><em>tt.stop = <strong>true</strong>;</em> // Tell child thread to
stop.</p>
<p>}</p>
<p>}</p>
<p>The intent of this program is intended to start a thread, let it run
for 1000 milliseconds, and then cause it to stop by setting the stop
flag.</p>
<p>Will it work as intended?</p>
<p>Maybe yes, may be no.</p>
<p>An application does not necessarily stop when the main method
returns. If another thread has been created, and</p>
<p>that thread has not been marked as a daemon thread, then the
application will continue to run after the main thread has ended. In
this example, that means that the application will keep running until
child thread ends. That</p>
<p>should happens when tt.stop is set to <strong>true</strong>.</p>
<p>But that is actually not strictly true. In fact, the child thread
will stop after it has <em>observed</em> stop with the value
<strong>true</strong>.</p>
<p>Will that happen? Maybe yes, maybe no.</p>
<p>The Java Language Specification <em>guarantees</em> that memory reads
and writes made in a thread are visible to that</p>
<p>thread, as per the order of the statements in the source code.
However, in general, this is NOT guaranteed when one thread writes and
another thread (subsequently) reads. To get guaranteed visibility, there
needs to be a chain</p>
<p>of <em>happens-before</em> relations between a write and a subsequent
read. In the example above, there is no such chain for the update to the
stop flag, and therefore it is not guaranteed that the child thread will
see stop change to <strong>true</strong>.</p>
<p>(Note to authors: There should be a separate Topic on the Java Memory
Model to go into the deep technical details.)</p>
<p>How do we fix the problem?</p>
<p>In this case, there are two simple ways to ensure that the stop
update is visible:</p>
<p>1. Declare stop to be <strong>volatile</strong>; i.e.</p>
<p>private volatile boolean <strong>stop =</strong>
false<strong>;</strong></p>
<p>For a <strong>volatile</strong> variable, the JLS specifies that
there is a <em>happens-before</em> relation between a write by one</p>
<p>thread and a later read by a second thread.</p>
<p>2. Use a mutex to synchronize as follows:</p>
<p><strong>public class</strong> ThreadTest <strong>implements</strong>
Runnable {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 744</p>
<p>private boolean <strong>stop =</strong> false<strong>;</strong></p>
<p>public void <strong>run() {</strong></p>
<p><strong>long</strong> counter = 0;</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>synchronize (<strong>this</strong>) {</p>
<p><strong>if</strong> (stop) {</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>counter = counter + 1;</p>
<p>}</p>
<p>System.out.println("Counted " + counter);</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>ThreadTest tt = <strong>new</strong> ThreadTest();</p>
<p><strong>new</strong> Thread(tt).start(); <em>// Create and start
child thread</em> Thread.sleep(1000);</p>
<p>synchronize (tt) {</p>
<p><em>tt.stop = <strong>true</strong>;</em> // Tell child thread to
stop.</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>In addition to ensuring that there is mutual exclusion, the JLS
specifies that there is a <em>happens-before</em> relation</p>
<p>between the releasing a mutex in one thread and gaining the same
mutex in a second thread.</p>
<p>But isn't assignment atomic?</p>
<p>Yes it is!</p>
<p>However, that fact does not mean that the effects of update will be
visible simultaneously to all threads. Only a</p>
<p>proper chain of <em>happens-before</em> relations will guarantee
that.</p>
<p>Why did they do this?</p>
<p>Programmers doing multi-threaded programming in Java for the first
time find the Memory Model is challenging.</p>
<p>Programs behave in an unintuitive way because the natural expectation
is that writes are visible uniformly. So why the Java designers design
the Memory Model this way.</p>
<p>It actually comes down to a compromise between performance and ease
of use (for the programmer).</p>
<p>A modern computer architecture consists of multiple processors
(cores) with individual register sets. Main memory</p>
<p>is accessible either to all processors or to groups of processors.
Another property of modern computer hardware is that access to registers
is typically orders of magnitude faster to access than access to main
memory. As the</p>
<p>number of cores scales up, it is easy to see that reading and writing
to main memory can become a system's main performance bottleneck.</p>
<p>This mismatch is addressed by implementing one or more levels of
memory caching between the processor cores and main memory. Each core
access memory cells via its cache. Normally, a main memory read only
happens when</p>
<p>there is a cache miss, and a main memory write only happens when a
cache line needs to be flushed. For an application where each core's
working set of memory locations will fit into its cache, the core speed
is no longer</p>
<p>limited by main memory speed / bandwidth.</p>
<p>But that gives us a new problem when multiple cores are reading and
writing shared variables. The latest version of</p>
<p>a variable may sit in one core's cache. Unless the that core flushes
the cache line to main memory, AND other cores</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 745</p>
<p><span id="invalidate_their_cached_copy_of"
class="anchor"></span>invalidate their cached copy of older versions,
some of them are liable to see stale versions of the variable. But if
the caches were flushed to memory each time there is a cache write
("just in case" there was a read by another</p>
<p>core) that would consume main memory bandwidth unnecessarily.</p>
<p>The standard solution used at the hardware instruction set level is
to provide instructions for cache invalidation and</p>
<p>a cache write-through, and leave it to the compiler to decide when to
use them.</p>
<p>Returning to Java. the Memory Model is designed so that the Java
compilers are not required to issue cache</p>
<p>invalidation and write-through instructions where they are not really
needed. The assumption is that the programmer will use an appropriate
synchronization mechanism (e.g. primitive mutexes,
<strong>volatile</strong>, higher-level</p>
<p>concurrency classes and so on) to indicate that it needs memory
visibility. In the absence of a <em>happens-before</em> relation, the
Java compilers are free to <em>assume</em> that no cache operations (or
similar) are required.</p>
<p>This has significant performance advantages for multi-threaded
applications, but the downside is that writing correct multi-threaded
applications is not a simple matter. The programmer <em>does</em> have
to understand what he or</p>
<p>she is doing.</p>
<p>Why can't I reproduce this?</p>
<p>There are a number of reasons why problems like this are difficult to
reproduce:</p>
<p>1. As explained above, the consequence of not dealing with memory
visibility issues problems properly is</p>
<p><em>typically</em> that your compiled application does not handle the
memory caches correctly. However, as we</p>
<p>alluded to above, memory caches often get flushed anyway.</p>
<p>2. When you change the hardware platform, the characteristics of the
memory caches may change. This can</p>
<p>lead to different behavior if your application does not synchronize
correctly.</p>
<p>3. You may be observing the effects of <em>serendipitous</em>
synchronization. For example, if you add traceprints, their</p>
<p>is typically some synchronization happening behind the scenes in the
I/O streams that causes cache flushes. So adding traceprints
<em>often</em> causes the application to behave differently.</p>
<p>4. Running an application under a debugger causes it to be compiled
differently by the JIT compiler.</p>
<p>Breakpoints and single stepping exacerbate this. These effects will
often change the way an application behaves.</p>
<p>These things make bugs that are due to inadequate synchronization
particularly difficult to solve.</p>
<p>Section 133.5: Pitfall - Thread creation is relatively expensive</p>
<p>Consider these two micro-benchmarks:</p>
<p>The first benchmark simply creates, starts and joins threads. The
thread's Runnable does no work.</p>
<p><strong>public class</strong> ThreadTest {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p><strong>long</strong> start = System.nanoTime();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100_000;
i++) {</p>
<p>Thread t = <strong>new</strong> Thread(<strong>new</strong>
Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>}});</p>
<p>t.start();</p>
<p>t.join();</p>
<p>}</p>
<p><strong>long</strong> end = System.nanoTime();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 746</p>
<p>System.out.println((end - start) / 100_000.0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>$ java ThreadTest</p>
<p>34627.91355</p>
<p>33596.66021</p>
<p>33661.19084</p>
<p>33699.44895</p>
<p>33603.097</p>
<p>33759.3928</p>
<p>33671.5719</p>
<p>33619.46809</p>
<p>33679.92508</p>
<p>33500.32862</p>
<p>33409.70188</p>
<p>33475.70541</p>
<p>33925.87848</p>
<p>33672.89529</p>
<p>^C</p>
<p>On a typical modern PC running Linux with 64bit Java 8 u101, this
benchmark shows an average time taken to</p>
<p>create, start and join thread of between 33.6 and 33.9
microseconds.</p>
<p>The second benchmark does the equivalent to the first but using an
ExecutorService to submit tasks and a Future</p>
<p>to rendezvous with the end of the task.</p>
<p><strong>import</strong> java.util.concurrent.*;</p>
<p><strong>public class</strong> ExecutorTest {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception { ExecutorService exec =
Executors.newCachedThreadPool();</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p><strong>long</strong> start = System.nanoTime();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 100_000;
i++) {</p>
<p>Future future = exec.submit(<strong>new</strong> Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>}</p>
<p>});</p>
<p>future.get();</p>
<p>}</p>
<p><strong>long</strong> end = System.nanoTime();</p>
<p>System.out.println((end - start) / 100_000.0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>$ java ExecutorTest</p>
<p>6714.66053</p>
<p>5418.24901</p>
<p>5571.65213</p>
<p>5307.83651</p>
<p>5294.44132</p>
<p>5370.69978</p>
<p>5291.83493</p>
<p>5386.23932</p>
<p>5384.06842</p>
<p>5293.14126</p>
<p>5445.17405</p>
<p>5389.70685</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 747</p>
<p>^C</p>
<p>As you can see, the averages are between 5.3 and 5.6
microseconds.</p>
<p>While the actual times will depend on a variety of factors, the
difference between these two results is significant. It</p>
<p>is clearly faster to use a thread pool to recycle threads than it is
to create new threads.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 748</p>
<p><span id="Chapter_134__Java_Pitfalls___Nul_1"
class="anchor"></span>Chapter 134: Java Pitfalls - Nulls and</p>
<p>NullPointerException</p>
<p>Section 134.1: Pitfall - "Making good" unexpected nulls</p>
<p>On StackOverflow, we often see code like this in Answers:</p>
<p><strong>public</strong> String joinStrings(String a, String b) {</p>
<p><strong>if</strong> (a == <strong>null</strong>) {</p>
<p>a = "";</p>
<p>}</p>
<p><strong>if</strong> (b == <strong>null</strong>) {</p>
<p>b = "";</p>
<p>}</p>
<p><strong>return</strong> a + ": " + b;</p>
<p>}</p>
<p>Often, this is accompanied with an assertion that is "best practice"
to test for <strong>null</strong> like this to avoid</p>
<p>NullPointerException.</p>
<p>Is it best practice? In short: No.</p>
<p>There are some underlying assumptions that need to be questioned
before we can say if it is a good idea to do this in our
joinStrings:</p>
<p>What does it mean for "a" or "b" to be null?</p>
<p>A String value can be zero or more characters, so we already have a
way of representing an empty string. Does <strong>null</strong> mean
something different to ""? If no, then it is problematic to have two
ways to represent an empty string.</p>
<p>Did the null come from an uninitialized variable?</p>
<p>A <strong>null</strong> can come from an uninitialized field, or an
uninitialized array element. The value could be uninitialized by design,
or by accident. If it was by accident then this is a bug.</p>
<p>Does the null represent a "don't know" or "missing value"?</p>
<p>Sometimes a <strong>null</strong> can have a genuine meaning; e.g.
that the real value of a variable is unknown or unavailable or
"optional". In Java 8, the Optional class provides a better way of
expressing that.</p>
<p>If this is a bug (or a design error) should we "make good"?</p>
<p>One interpretation of the code is that we are "making good" an
unexpected <strong>null</strong> by using an empty string in its place.
Is the correct strategy? Would it be better to let the
NullPointerException happen, and then catch the</p>
<p>exception further up the stack and log it as a bug?</p>
<p>The problem with "making good" is that it is liable to either hide
the problem, or make it harder to diagnose.</p>
<p>Is this efficient / good for code quality?</p>
<p>If the "make good" approach is used consistently, your code is going
to contain a lot of "defensive" null tests. This is going to make it
longer and harder to read. Furthermore, all of this testing and "making
good" is liable to impact on</p>
<p>the performance of your application.</p>
<p>In summary</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 749</p>
<p><span id="If_null_is_a_meaningful_value__t" class="anchor"></span>If
<strong>null</strong> is a meaningful value, then testing for the
<strong>null</strong> case is the correct approach. The corollary is
that if a <strong>null</strong> value is meaningful, then this should be
clearly documented in the javadocs of any methods that accept the
<strong>null</strong></p>
<p>value or return it.</p>
<p>Otherwise, it is a better idea to treat an unexpected
<strong>null</strong> as a programming error, and let the</p>
<p>NullPointerException happen so that the developer gets to know there
is a problem in the code.</p>
<p>Section 134.2: Pitfall - Using null to represent an empty array</p>
<p>or collection</p>
<p>Some programmers think that it is a good idea to save space by using
a <strong>null</strong> to represent an empty array or collection. While
it is true that you can save a small amount of space, the flipside is
that it makes your code more</p>
<p>complicated, and more fragile. Compare these two versions of a method
for summing an array:</p>
<p>The first version is how you would normally code the method:</p>
<p>/**</p>
<p>* Sum the values in an array of integers.</p>
<p>* @arg values the array to be summed</p>
<p>* @return the sum</p>
<p>**/</p>
<p><strong>public int</strong> sum(<strong>int</strong>[] values) {</p>
<p><strong>int</strong> sum = 0;</p>
<p><strong>for</strong> (<strong>int</strong> value : values) {</p>
<p>sum += value;</p>
<p>}</p>
<p>return <strong>sum;</strong></p>
<p>}</p>
<p>The second version is how you need to code the method if you are in
the habit of using <strong>null</strong> to represent an empty</p>
<p>array.</p>
<p>/**</p>
<p>* Sum the values in an array of integers.</p>
<p>* @arg values the array to be summed, or null.</p>
<p>* @return the sum, or zero if the array is null.</p>
<p>**/</p>
<p><strong>public int</strong> sum(<strong>int</strong>[] values) {</p>
<p><strong>int</strong> sum = 0;</p>
<p><strong>if</strong> (values != <strong>null</strong>) {</p>
<p><strong>for</strong> (<strong>int</strong> value : values) {</p>
<p>sum += value;</p>
<p>}</p>
<p>}</p>
<p>return <strong>sum;</strong></p>
<p>}</p>
<p>As you can see, the code is a bit more complicated. This is directly
attributable to the decision to use <strong>null</strong> in this
way.</p>
<p>Now consider if this array that might be a <strong>null</strong> is
used in lots of places. At each place where you use it, you need to</p>
<p>consider whether you need to test for <strong>null</strong>. If you
miss a <strong>null</strong> test that needs to be there, you risk a</p>
<p>NullPointerException. Hence, the strategy of using
<strong>null</strong> in this way leads to your application being more
fragile; i.e. more vulnerable to the consequences of programmer
errors.</p>
<p>The lesson here is to use empty arrays and empty lists when that is
what you mean.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 750</p>
<p><span id="int___values___new_int_0"
class="anchor"></span><strong>int</strong>[] values = <strong>new
int</strong>[0]; <em>// always empty</em></p>
<p>List list = <strong>new</strong> ArrayList(); <em>// initially
empty</em> List list = Collections.emptyList(); <em>// always
empty</em></p>
<p>The space overhead is small, and there are other ways to minimize it
if this this is a worthwhile thing to do.</p>
<p>Section 134.3: Pitfall - Not checking if an I/O stream isn't even</p>
<p>initialized when closing it</p>
<p>To prevent memory leaks, one should not forget to close an input
stream or an output stream whose job is done.</p>
<p>This is usually done with a
<strong>try</strong>-<strong>catch</strong>-<strong>finally</strong>
statement without the <strong>catch</strong> part:</p>
<p><strong>void</strong> writeNullBytesToAFile(<strong>int</strong>
count, String filename) <strong>throws</strong> IOException {</p>
<p>FileOutputStream out = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>out = <strong>new</strong> FileOutputStream(filename);</p>
<p><strong>for</strong>(; count &gt; 0; count--)</p>
<p>out.write(0);</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>out.close();</p>
<p>}</p>
<p>}</p>
<p>While the above code might look innocent, it has a flaw that can make
debugging impossible. If the line where out is initialized (out =
<strong>new</strong> FileOutputStream(filename)) throws an exception,
then out will be <strong>null</strong> when out.close()</p>
<p>is executed, resulting in a nasty NullPointerException!</p>
<p>To prevent this, simply make sure the stream isn't
<strong>null</strong> before trying to close it.</p>
<p><strong>void</strong> writeNullBytesToAFile(<strong>int</strong>
count, String filename) <strong>throws</strong> IOException {</p>
<p>FileOutputStream out = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>out = <strong>new</strong> FileOutputStream(filename);</p>
<p><strong>for</strong>(; count &gt; 0; count--)</p>
<p>out.write(0);</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p><strong>if</strong> (out != <strong>null</strong>)</p>
<p>out.close();</p>
<p>}</p>
<p>}</p>
<p>An even better approach is to <strong>try</strong>-with-resources,
since it'll automatically close the stream with a probability of 0 to
throw an NPE without the need of a <strong>finally</strong> block.</p>
<p><strong>void</strong> writeNullBytesToAFile(<strong>int</strong>
count, String filename) <strong>throws</strong> IOException {</p>
<p><strong>try</strong> (FileOutputStream out = <strong>new</strong>
FileOutputStream(filename)) {</p>
<p><strong>for</strong>(; count &gt; 0; count--)</p>
<p>out.write(0);</p>
<p>}</p>
<p>}</p>
<p>Section 134.4: Pitfall - Returning null instead of throwing an</p>
<p>exception</p>
<p>Some Java programmers have a general aversion to throwing or
propagating exceptions. This leads to code like the following:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 751</p>
<p><span id="public_Reader_getReader_String_p"
class="anchor"></span><strong>public</strong> Reader getReader(String
pathname) {</p>
<p>try <strong>{</strong></p>
<p><strong>return new</strong> BufferedReader(FileReader(pathname));</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Open failed: " + ex.getMessage()); <strong>return
null</strong>;</p>
<p>}</p>
<p>}</p>
<p>So what is the problem with that?</p>
<p>The problem is that the getReader is returning a
<strong>null</strong> as a special value to indicate that the Reader
could not be opened. Now the returned value needs to be tested to see if
it is <strong>null</strong> before it is used. If the test is left out,
the</p>
<p>result will be a NullPointerException.</p>
<p>There are actually three problems here:</p>
<p>1. The IOException was caught too soon.</p>
<p>2. The structure of this code means that there is a risk of leaking a
resource.</p>
<p>3. A <strong>null</strong> was used then returned because no "real"
Reader was available to return.</p>
<p>In fact, assuming that the exception did need to be caught early like
this, there were a couple of alternatives to</p>
<p>returning <strong>null</strong>:</p>
<p>1. It would be possible to implement a NullReader class; e.g. one
where API's operations behaves as if the</p>
<p>reader was already at the "end of file" position.</p>
<p>2. With Java 8, it would be possible to declare getReader as
returning an Optional.</p>
<p>Section 134.5: Pitfall - Unnecessary use of Primitive Wrappers</p>
<p>can lead to NullPointerExceptions</p>
<p>Sometimes, programmers who are new Java will use primitive types and
wrappers interchangeably. This can lead to problems. Consider this
example:</p>
<p>public class <strong>MyRecord {</strong></p>
<p>public int <strong>a, b;</strong></p>
<p><strong>public</strong> Integer c, d;</p>
<p>}</p>
<p>...</p>
<p>MyRecord record = <strong>new</strong> MyRecord();</p>
<p>record.a = 1; <em>// OK</em></p>
<p>record.b = record.b + 1; <em>// OK</em></p>
<p>record.c = 1; <em>// OK</em></p>
<p><em>record.d = record.d + 1;</em> // throws a
NullPointerException</p>
<p>Our MyRecord class1 relies on default initialization to initialize
the values on its fields. Thus, when we <strong>new</strong> a
record,</p>
<p>the a and b fields will be set to zero, and the c and d fields will
be set to <strong>null</strong>.</p>
<p>When we try to use the default initialized fields, we see that the
<strong>int</strong> fields works all of the time, but the Integer
fields work in some cases and not others. Specifically, in the case that
fails (with d), what happens is that the</p>
<p>expression on the right-hand side attempts to unbox a
<strong>null</strong> reference, and that is what causes the</p>
<p>NullPointerException to be thrown.</p>
<p>There are a couple of ways to look at this:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 752</p>
<p><span id="If_the_fields_c_and_d_need_to_be" class="anchor"></span>If
the fields c and d need to be primitive wrappers, then either we should
not be relying on default initialization, or we should be testing for
<strong>null</strong>. For former is the correct approach
<em>unless</em> there is a definite</p>
<p>meaning for the fields in the <strong>null</strong> state.</p>
<p>If the fields don't need to be primitive wrappers, then it is a
mistake to make them primitive wrappers. In addition to this problem,
the primitive wrappers have extra overheads relative to primitive
types.</p>
<p>The lesson here is to not use primitive wrapper types unless you
really need to.</p>
<p>1 - This class is not an example of good coding practice. For
instance, a well-designed class would not have public</p>
<p>fields. However, that is not the point of this example.</p>
<p>Section 134.6: Pitfall - Using "Yoda notation" to avoid</p>
<p>NullPointerException</p>
<p>A lot of example code posted on StackOverflow includes snippets like
this:</p>
<p><strong>if</strong> ("A".equals(someString)) {</p>
<p>// do something</p>
<p>}</p>
<p>This does "prevent" or "avoid" a possible NullPointerException in the
case that someString is <strong>null</strong>. Furthermore,</p>
<p>it is arguable that</p>
<p>"A".equals(someString)</p>
<p>is better than:</p>
<p>someString != <strong>null</strong> &amp;&amp;
someString.equals("A")</p>
<p>(It is more concise, and in some circumstances it might be more
efficient. However, as we argue below, conciseness could be a
negative.)</p>
<p>However, the real pitfall is using the Yoda test <strong>to avoid
NullPointerExceptions</strong> as a matter of habit.</p>
<p>When you write "A".equals(someString) you are actually "making good"
the case where someString happens to be <strong>null</strong>. But as
another example (Pitfall - "Making good" unexpected nulls ) explains,
"making good" <strong>null</strong> values</p>
<p>can be harmful for a variety of reasons.</p>
<p>This means that Yoda conditions are not "best practice"1. Unless the
<strong>null</strong> is expected, it is better to let the</p>
<p>NullPointerException happen so that you can get a unit test failure
(or a bug report). That allows you to find and fix the bug that caused
the unexpected / unwanted <strong>null</strong> to appear.</p>
<p>Yoda conditions should only be used in cases where the
<strong>null</strong> is <em>expected</em> because the object you are
testing has come from an API that is <em>documented</em> as returning a
<strong>null</strong>. And arguably, it could be better to use one of
the less</p>
<p>pretty ways expressing the test because that helps to highlight the
<strong>null</strong> test to someone who is reviewing your code.</p>
<p><a href="https://en.wikipedia.org/wiki/Best_coding_practices"><em>1 -
According to Wikipedia:</em></a> "Best coding practices are a set of
informal rules that the software development community has learned over
time which can help improve the quality of software."<em>. Using Yoda
notation does not achieve this. In a</em></p>
<p>lot of situations, it makes the code worse.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 753</p>
<p><span id="Chapter_135__Java_Pitfalls___Per_1"
class="anchor"></span>Chapter 135: Java Pitfalls - Performance</p>
<p>Issues</p>
<p>This topic describes a number of "pitfalls" (i.e. mistakes that
novice java programmers make) that relate to Java</p>
<p>application performance.</p>
<p>Section 135.1: Pitfall - String concatenation in a loop does not</p>
<p>scale</p>
<p>Consider the following code as an illustration:</p>
<p><strong>public</strong> String joinWords(List words) {</p>
<p>String message = "";</p>
<p><strong>for</strong> (String word : words) {</p>
<p>message = message + " " + word;</p>
<p>}</p>
<p><strong>return</strong> message;</p>
<p>}</p>
<p>Unfortunate this code is inefficient if the words list is long. The
root of the problem is this statement:</p>
<p>message = message + " " + word;</p>
<p>For each loop iteration, this statement creates a new message string
containing a copy of all characters in the</p>
<p>original message string with extra characters appended to it. This
generates a lot of temporary strings, and does a lot of copying.</p>
<p>When we analyse joinWords, assuming that there are N words with an
average length of M, we find that O(N)</p>
<p>temporary strings are created and O(M.N2) characters will be copied
in the process. The N2 component is</p>
<p>particularly troubling.</p>
<p>The recommended approach for this kind of problem1 is to use a
StringBuilder instead of string concatenation as follows:</p>
<p><strong>public</strong> String joinWords2(List words) {</p>
<p>StringBuilder message = <strong>new</strong> StringBuilder();</p>
<p><strong>for</strong> (String word : words) {</p>
<p>message.append(" ").append(word);</p>
<p>}</p>
<p><strong>return</strong> message.toString();</p>
<p>}</p>
<p>The analysis of joinWords2 needs to take account of the overheads of
"growing" the StringBuilder backing array</p>
<p>that holds the builder's characters. However, it turns out that the
number of new objects created is O(logN) and that the number of
characters copied is O(M.N) characters. The latter includes characters
copied in the final</p>
<p>toString() call.</p>
<p>(It may be possible to tune this further, by creating the
StringBuilder with the correct capacity to start with.</p>
<p>However, the overall complexity remains the same.)</p>
<p>Returning to the original joinWords method, it turns out that the
critical statement will be optimized by a typical</p>
<p>Java compiler to something like this:</p>
<p>StringBuilder tmp = <strong>new</strong> StringBuilder();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 754</p>
<p><span id="tmp_append_message__append"
class="anchor"></span>tmp.append(message).append(" ").append(word);</p>
<p>message = tmp.toString();</p>
<p>However, the Java compiler will not "hoist" the StringBuilder out of
the loop, as we did by hand in the code for</p>
<p>joinWords2.</p>
<p>Reference:</p>
<p><a
href="http://outoffactserror.blogspot.com/2017/03/is-javas-string-operator-in-loop-slow.html">"Is
Java's String '+' operator in a loop slow?"</a></p>
<p>1 - In Java 8 and later, the Joiner class can be used to solve this
particular problem. However, that is not what this example is <em>really
supposed to be about</em>.</p>
<p>Section 135.2: Pitfall - Using size() to test if a collection is</p>
<p>empty is inecient</p>
<p>The Java Collections Framework provides two related methods for all
Collection objects:</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#size--">size()</a>
returns the number of entries in a Collection, and</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#isEmpty--">isEmpty()</a>
method returns true if (and only if) the Collection is empty.</p>
<p>Both methods can be used to test for collection emptiness. For
example:</p>
<p>Collection strings = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p><strong>boolean</strong> isEmpty_wrong = strings.size() == 0; <em>//
Avoid this</em> <strong>boolean</strong> isEmpty = strings.isEmpty();
<em>// Best</em></p>
<p>While these approaches look the same, some collection implementations
do not store the size. For such a</p>
<p>collection, the implementation of size() needs to calculate the size
each time it is called. For instance:</p>
<p>A simple linked list class (but not the java.util.LinkedList) might
need to traverse the list to count the</p>
<p>elements.</p>
<p>The ConcurrentHashMap class needs to sum the entries in all of the
map's "segments".</p>
<p>A lazy implementation of a collection might need to realize the
entire collection in memory in order to count the elements.</p>
<p>By contrast, an isEmpty() method only needs to test if there is
<em>at least one</em> element in the collection. This does not entail
counting the elements.</p>
<p>While size() == 0 is not always less efficient that isEmpty(), it is
inconceivable for a properly implemented isEmpty() to be less efficient
than size() == 0. Hence isEmpty() is preferred.</p>
<p>Section 135.3: Pitfall - Interning strings so that you can use ==</p>
<p>is a bad idea</p>
<p>When some programmers see this advice:</p>
<p>"Testing strings using == is incorrect (unless the strings are
interned)"</p>
<p>their initial reaction is to intern strings so that they can use ==.
(After all == is faster than calling</p>
<p>String.equals(...), isn't it.)</p>
<p>This is the wrong approach, from a number of perspectives:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 755</p>
<p>Fragility</p>
<p>First of all, you can only safely use == if you know that
<em>all</em> of the String objects you are testing have been
interned.</p>
<p>The JLS guarantees that String literals in your source code will have
been interned. However, none of the standard Java SE APIs guarantee to
return interned strings, apart from String.intern(String) itself. If you
miss just one</p>
<p>source of String objects that haven't been interned, your application
will be unreliable. That unreliability will manifest itself as false
negatives rather than exceptions which is liable to make it harder to
detect.</p>
<p>Costs of using 'intern()'</p>
<p>Under the hood, interning works by maintaining a hash table that
contains previously interned String objects. Some kind of weak reference
mechanism is used so that the interning hash table does not become a
storage leak.</p>
<p>While the hash table is implemented in native code (unlike HashMap,
HashTable and so on), the intern calls are still relatively costly in
terms of CPU and memory used.</p>
<p>This cost has to be compared with the saving of we are going to get
by using == instead of equals. In fact, we are not going to break even
unless each interned string is compared with other strings "a few"
times.</p>
<p>(Aside: the few situations where interning is worthwhile tend to be
about reducing the memory foot print of an application where the same
strings recur many times, <em>and</em> those strings have a long
lifetime.)</p>
<p>The impact on garbage collection</p>
<p>In addition to the direct CPU and memory costs described above,
interned Strings impact on the garbage collector performance.</p>
<p>For versions of Java prior to Java 7, interned strings are held in
the "PermGen" space which is collected infrequently.</p>
<p>If PermGen needs to be collected, this (typically) triggers a full
garbage collection. If the PermGen space fills</p>
<p>completely, the JVM crashes, even if there was free space in the
regular heap spaces.</p>
<p>In Java 7, the string pool was moved out of "PermGen" into the normal
heap. However, the hash table is still going</p>
<p>to be a long-lived data structure, which is going to cause any
interned strings to be long-lived. (Even if the interned string objects
were allocated in Eden space they would most likely be promoted before
they were collected.)</p>
<p>Thus in all cases, interning a string is going to prolong its
lifetime relative to an ordinary string. That will increase the</p>
<p>garbage collection overheads over the lifetime of the JVM.</p>
<p>The second issue is that the hash table needs to use a weak reference
mechanism of some kind to prevent string</p>
<p>interning leaking memory. But such a mechanism is more work for the
garbage collector.</p>
<p>These garbage collection overheads are difficult to quantify, but
there is little doubt that they do exist. If you use</p>
<p>intern extensively, they could be significant.</p>
<p>The string pool hashtable size</p>
<p><a
href="http://java-performance.info/string-intern-in-java-6-7-8/">According
to this source, from Java 6 onwards, the string pool is implemented as
fixed sized hash table with chains</a></p>
<p>to deal with strings that hash to the same bucket. In early releases
of Java 6, the hash table had a (hard-wired) constant size. A tuning
parameter (-XX:StringTableSize) was added as a mid-life update to Java
6. Then in a mid-</p>
<p>life update to Java 7, the default size of the pool was changed from
1009 to 60013.</p>
<p>The bottom line is that if you do intend to use intern intensively in
your code, it is <em>advisable</em> to pick a version of Java</p>
<p>where the hashtable size is tunable and make sure that you tune the
size it appropriately. Otherwise, the performance of intern is liable to
degrade as the pool gets larger.</p>
<p>Interning as a potential denial of service vector</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 756</p>
<p><span id="The_hashcode_algorithm_for_strin" class="anchor"></span>The
hashcode algorithm for strings is well-known. If you intern strings
supplied by malicious users or applications, this could be used as part
of a denial of service (DoS) attack. If the malicious agent arranges
that all of the strings it</p>
<p>provides have the same hash code, this could lead to an unbalanced
hash table and O(N) performance for intern ...</p>
<p>where N is the number of collided strings.</p>
<p>(There are simpler / more effective ways to launch a DoS attack
against a service. However, this vector could be used if the goal of the
DoS attack is to break security, or to evade first-line DoS
defences.)</p>
<p>Section 135.4: Pitfall - Using 'new' to create primitive wrapper</p>
<p>instances is inecient</p>
<p>The Java language allows you to use <strong>new</strong> to create
instances Integer, Boolean and so on, but it is generally a bad</p>
<p>idea. It is better to either use autoboxing (Java 5 and later) or the
valueOf method.</p>
<p>Integer i1 = <strong>new</strong> Integer(1); <em>// BAD</em></p>
<p><em>Integer i2 = 2;</em> // BEST (autoboxing)</p>
<p>Integer i3 = Integer.valueOf(3); <em>// OK</em></p>
<p>The reason that using <strong>new</strong>
Integer(<strong>int</strong>) explicitly is a bad idea is that it
creates a new object (unless optimized out</p>
<p>by JIT compiler). By contrast, when autoboxing or an explicit valueOf
call are used, the Java runtime will try to reuse</p>
<p>an Integer object from a cache of pre-existing objects. Each time the
runtime has a cache "hit", it avoids creating an object. This also saves
heap memory and reduces GC overheads caused by object churn.</p>
<p>Notes:</p>
<p>1. In recent Java implementations, autoboxing is implemented by
calling valueOf, and there are caches for</p>
<p>Boolean , Byte, Short, Integer, Long and Character.</p>
<p>2. The caching behavior for the integral types is mandated by the
Java Language Specification.</p>
<p>Section 135.5: Pitfall - Eciency concerns with regular</p>
<p>expressions</p>
<p>Regular expression matching is a powerful tool (in Java, and in other
contexts) but it does have some drawbacks. One of these that regular
expressions tends to be rather expensive.</p>
<p>Pattern and Matcher instances should be reused</p>
<p>Consider the following example:</p>
<p>/**</p>
<p>* Test if all strings in a list consist of English letters and
numbers. * @param strings the list to be checked</p>
<p>* @return 'true' if an only if all strings satisfy the criteria *
@throws NullPointerException if 'strings' is 'null' or a 'null' element.
*/</p>
<p><strong>public boolean</strong> allAlphanumeric(List strings) {</p>
<p><strong>for</strong> (String s : strings) {</p>
<p><strong>if</strong> (!s.matches("[A-Za-z0-9]*")) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p>This code is correct, but it is inefficient. The problem is in the
matches(...) call. Under the hood, s.matches("[A-</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 757</p>
<p>Za-z0-9]*") is equivalent to this:</p>
<p>Pattern.matches(s, "[A-Za-z0-9]*")</p>
<p>which is in turn equivalent to</p>
<p>Pattern.compile("[A-Za-z0-9]*").matcher(s).matches()</p>
<p>The Pattern.compile("[A-Za-z0-9]*") call parses the regular
expression, analyze it, and construct a Pattern object that holds the
data structure that will be used by the regex engine. This is a
non-trivial computation. Then a</p>
<p>Matcher object is created to wrap the s argument. Finally we call
match() to do the actual pattern matching.</p>
<p>The problem is that this work is all repeated for each loop
iteration. The solution is to restructure the code as</p>
<p>follows:</p>
<p><strong>private static</strong> Pattern ALPHA_NUMERIC =
Pattern.compile("[A-Za-z0-9]*");</p>
<p><strong>public boolean</strong> allAlphanumeric(List strings) {</p>
<p>Matcher matcher = ALPHA_NUMERIC.matcher("");</p>
<p><strong>for</strong> (String s : strings) {</p>
<p>matcher.reset(s);</p>
<p><strong>if</strong> (!matcher.matches()) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Note
that the javadoc for</a> Pattern states:</p>
<p>Instances of this class are immutable and are safe for use by
multiple concurrent threads. Instances of the Matcher class are not safe
for such use.</p>
<p>Don't use match() when you should use find()</p>
<p>Suppose you want to test if a string s contains three or more digits
in a row. You cn express this in various ways including:</p>
<p><strong>if</strong> (s.matches(".*[0-9]{3}.*")) {</p>
<p>System.out.println("matches");</p>
<p>}</p>
<p>or</p>
<p><strong>if</strong> (Pattern.compile("[0-9]{3}").matcher(s).find())
{</p>
<p>System.out.println("matches");</p>
<p>}</p>
<p>The first one is more concise, but it is also likely to be less
efficient. On the face of it, the first version is going to try to match
the entire string against the pattern. Furthermore, since ".*" is a
"greedy" pattern, the pattern matcher is</p>
<p>likely to advance "eagerly" try to the end of the string, and
backtrack until it finds a match.</p>
<p>By contrast, the second version will search from left to right and
will stop searching as soon as it finds the 3 digits in</p>
<p>a row.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 758</p>
<p>Use more efficient alternatives to regular expressions</p>
<p>Regular expressions are a powerful tool, but they should not be your
only tool. A lot of tasks can be done more</p>
<p>efficiently in other ways. For example:</p>
<p>Pattern.compile("ABC").matcher(s).find()</p>
<p>does the same thing as:</p>
<p>s.contains("ABC")</p>
<p>except that the latter is a lot more efficient. (Even if you can
amortize the cost of compiling the regular expression.)</p>
<p>Often, the non-regex form is more complicated. For example, the test
performed by the matches() call the earlier allAlplanumeric method can
be rewritten as:</p>
<p><strong>public boolean</strong> matches(String s) {</p>
<p><strong>for</strong> (<strong>char</strong> c : s) {</p>
<p><strong>if</strong> ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||</p>
<p>(c &gt;= 'a' &amp;&amp; c &lt;= 'z') ||</p>
<p>(c &gt;= '0' &amp;&amp; c &lt;= '9')) {</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p>Now that is more code than using a Matcher, but it is also going to
be significantly faster.</p>
<p>Catastrophic Backtracking</p>
<p>(This is potentially a problem with all implementations of regular
expressions, but we will mention it here because it is a pitfall for
Pattern usage.)</p>
<p>Consider this (contrived) example:</p>
<p>Pattern pat = Pattern.compile("(A+)+B");</p>
<p>System.out.println(pat.matcher("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB").matches());
System.out.println(pat.matcher("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC").matches());</p>
<p>The first println call will quickly print <strong>true</strong>. The
second one will print <strong>false</strong>. Eventually. Indeed, if you
experiment</p>
<p>with the code above, you will see that each time you add an A before
the C, the time take will double.</p>
<p>This is behavior is an example of <em>catastrophic backtracking</em>.
The pattern matching engine that implements the regex</p>
<p>matching is fruitlessly trying all of the <em>possible</em> ways that
the pattern <em>might</em> match.</p>
<p>Let us look at what (A+)+B actually means. Superficially, it seems to
say "one or more A characters followed by a B</p>
<p>value", but in reality it says one or more groups, each of which
consists of one or more A characters. So, for example:</p>
<p>'AB' matches one way only: '(A)B'</p>
<p>'AAB' matches two ways: '(AA)B' or '(A)(A)B`</p>
<p>'AAAB' matches four ways: '(AAA)B' or '(AA)(A)Bor '(A)(AA)B or
'(A)(A)(A)B` and so on</p>
<p>In other words, the number of possible matches is 2N where N is the
number of A characters.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 759</p>
<p><span id="The_above_example_is_clearly_con" class="anchor"></span>The
above example is clearly contrived, but patterns that exhibit this kind
of performance characteristics (i.e. O(2^N) or O(N^K) for a large K)
arise frequently when ill-considered regular expressions are used. There
are some</p>
<p>standard remedies:</p>
<p>Avoid nesting repeating patterns within other repeating patterns.</p>
<p>Avoid using too many repeating patterns.</p>
<p>Use non-backtracking repetition as appropriate.</p>
<p>Don't use regexes for complicated parsing tasks. (Write a proper
parser instead.)</p>
<p>Finally, beware of situations where a user or an API client can
supply a regex string with pathological characteristics.</p>
<p>That can lead to accidental or deliberate "denial of service".</p>
<p>References:</p>
<p>The Regular Expressions tag, particularly</p>
<p>http://stackoverflow.com/documentation/regex/977/backtracking#t=201610010339131361163
and</p>
<p>http://stackoverflow.com/documentation/regex/4527/when-you-should-not-use-regular-expressions#t=2016
10010339593564913</p>
<p><a href="https://blog.codinghorror.com/regex-performance/">"Regex
Performance" by Jeff Atwood.</a></p>
<p><a
href="http://andreas.haufler.info/2013/09/how-to-kill-java-with-regular-expression.html">"How
to kill Java with a Regular Expression"</a> by Andreas Haufler.</p>
<p>Section 135.6: Pitfall - Small reads / writes on unbuered</p>
<p>streams are inecient</p>
<p>Consider the following code to copy one file to another:</p>
<p><strong>import</strong> java.io.*;</p>
<p>public class <strong>FileCopy {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p><strong>try</strong> (InputStream is = <strong>new</strong>
FileInputStream(args[0]);</p>
<p>OutputStream os = <strong>new</strong> FileOutputStream(args[1]))
{</p>
<p><strong>int</strong> octet;</p>
<p><strong>while</strong> ((octet = is.read()) !=-1) {</p>
<p>os.write(octet);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>(We have deliberated omitted normal argument checking, error
reporting and so on because they are not relevant</p>
<p>to <em>point</em> of this example.)</p>
<p>If you compile the above code and use it to copy a huge file, you
will notice that it is very slow. In fact, it will be at</p>
<p>least a couple of orders of magnitude slower than the standard OS
file copy utilities.</p>
<p><em>(</em>Add actual performance measurements here!<em>)</em></p>
<p>The primary reason that the example above is slow (in the large file
case) is that it is performing one-byte reads and</p>
<p>one-byte writes on unbuffered byte streams. The simple way to improve
performance is to wrap the streams with buffered streams. For
example:</p>
<p><strong>import</strong> java.io.*;</p>
<p>public class <strong>FileCopy {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 760</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p><strong>try</strong> (InputStream is = <strong>new</strong>
BufferedInputStream(</p>
<p><strong>new</strong> FileInputStream(args[0]));</p>
<p>OutputStream os = <strong>new</strong> BufferedOutputStream(</p>
<p><strong>new</strong> FileOutputStream(args[1]))) {</p>
<p><strong>int</strong> octet;</p>
<p><strong>while</strong> ((octet = is.read()) !=-1) {</p>
<p>os.write(octet);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>These small changes will improve data copy rate by <em>at least</em>
a couple of orders of magnitude, depending on various</p>
<p>platform-related factors. The buffered stream wrappers cause the data
to be read and written in larger chunks. The instances both have buffers
implemented as byte arrays.</p>
<p>With is, data is read from the file into the buffer a few kilobytes
at a time. When read() is called, the</p>
<p>implementation will typically return a byte from the buffer. It will
only read from the underlying input stream</p>
<p>if the buffer has been emptied.</p>
<p>The behavior for os is analogous. Calls to
os.write(<strong>int</strong>) write single bytes into the buffer. Data
is only</p>
<p>written to the output stream when the buffer is full, or when os is
flushed or closed.</p>
<p>What about character-based streams?</p>
<p>As you should be aware, Java I/O provides different APIs for reading
and writing binary and text data.</p>
<p>InputStream and OutputStream are the base APIs for stream-based
binary I/O Reader and Writer are the base APIs for stream-based text
I/O.</p>
<p>For text I/O, BufferedReader and BufferedWriter are the equivalents
for BufferedInputStream and</p>
<p>BufferedOutputStream.</p>
<p>Why do buffered streams make this much difference?</p>
<p>The real reason that buffered streams help performance is to do with
the way that an application talks to the</p>
<p>operating system:</p>
<p>Java method in a Java application, or native procedure calls in the
JVM's native runtime libraries are fast. They</p>
<p>typically take a couple of machine instructions and have minimal
performance impact.</p>
<p>By contrast, JVM runtime calls to the operating system are not fast.
They involve something known as a "syscall". The typical pattern for a
syscall is as follows:</p>
<p>1. Put the syscall arguments into registers.</p>
<p>2. Execute a SYSENTER trap instruction.</p>
<p>3. The trap handler switched to privileged state and changes the
virtual memory mappings. Then it</p>
<p>dispatches to the code to handle the specific syscall.</p>
<p>4. The syscall handler checks the arguments, taking care that it
isn't being told to access memory that the</p>
<p>user process should not see.</p>
<p>5. The syscall specific work is performed. In the case of a read
syscall, this may involve:</p>
<p>1. checking that there is data to be read at the file descriptor's
current position</p>
<p>2. calling the file system handler to fetch the required data from
disk (or wherever it is stored) into</p>
<p>the buffer cache,</p>
<p>3. copying data from the buffer cache to the JVM-supplied address</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 761</p>
<p><span id="4__adjusting_thstream_pointerse" class="anchor"></span>4.
adjusting thstream pointerse file descriptor position</p>
<p>6. Return from the syscall. This entails changing VM mappings again
and switching out of privileged state.</p>
<p>As you can imagine, performing a single syscall can thousands of
machine instructions. Conservatively, <em>at least</em> two</p>
<p>orders of magnitude longer than a regular method call. (Probably
three or more.)</p>
<p>Given this, the reason that buffered streams make a big difference is
that they drastically reduce the number of</p>
<p>syscalls. Instead of doing a syscall for each read() call, the
buffered input stream reads a large amount of data into a buffer as
required. Most read() calls on the buffered stream do some simple bounds
checking and return a <strong>byte</strong></p>
<p>that was read previously. Similar reasoning applies in the output
stream case, and also the character stream cases.</p>
<p>(Some people think that buffered I/O performance comes from the
mismatch between the read request size and</p>
<p>the size of a disk block, disk rotational latency and things like
that. In fact, a modern OS uses a number of strategies to ensure that
the application <em>typically</em> doesn't need to wait for the disk.
This is not the real explanation.)</p>
<p>Are buffered streams always a win?</p>
<p>Not always. Buffered streams are definitely a win if your application
is going to do lots of "small" reads or writes. However, if your
application only needs to perform large reads or writes to / from a
large <strong>byte</strong>[] or <strong>char</strong>[], then</p>
<p>buffered streams will give you no real benefits. Indeed there might
even be a (tiny) performance penalty.</p>
<p>Is this the fastest way to copy a file in Java?</p>
<p>No it isn't. When you use Java's stream-based APIs to copy a file,
you incur the cost of at least one extra memory-to-</p>
<p>memory copy of the data. It is possible to avoid this if your use the
NIO ByteBuffer and Channel APIs. (<em>Add a link to</em> <em>a separate
example here.</em>)</p>
<p>Section 135.7: Pitfall - Over-use of primitive wrapper types is</p>
<p>inecient</p>
<p>Consider these two pieces of code:</p>
<p><strong>int</strong> a = 1000;</p>
<p><strong>int</strong> b = a + 1;</p>
<p>and</p>
<p>Integer a = 1000;</p>
<p>Integer b = a + 1;</p>
<p>Question: Which version is more efficient?</p>
<p>Answer: The two versions look almost the identical, but the first
version is a lot more efficient than the second one.</p>
<p>The second version is using a representation for the numbers that
uses more space, and is relying on auto-boxing</p>
<p>and auto-unboxing behind the scenes. In fact the second version is
directly equivalent to the following code:</p>
<p>Integer a = Integer.valueOf(1000); <em>// box 1000</em></p>
<p>Integer b = Integer.valueOf(a.intValue() + 1); <em>// unbox 1000, add
1, box 1001</em></p>
<p>Comparing this to the other version that uses <strong>int</strong>,
there are clearly three extra method calls when Integer is used.</p>
<p>In the case of valueOf, the calls are each going to create and
initialize a new Integer object. All of this extra boxing and unboxing
work is likely to make the second version an order of magnitude slower
than the first one.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 762</p>
<p><span id="In_addition_to_that__the_second" class="anchor"></span>In
addition to that, the second version is allocating objects on the heap
in each valueOf call. While the space utilization is platform specific,
it is likely to be in the region of 16 bytes for each Integer object. By
contrast, the <strong>int</strong></p>
<p>version needs zero extra heap space, assuming that a and b are local
variables.</p>
<p>Another big reason why primitives are faster then their boxed
equivalent is how their respective array types are laid</p>
<p>out in memory.</p>
<p>If you take <strong>int</strong>[] and Integer[] as an example, in
the case of an <strong>int</strong>[] the <strong>int</strong>
<em>values</em> are contiguously laid out in</p>
<p>memory. But in the case of an Integer[] it's not the values that are
laid out, but references (pointers) to Integer objects, which in turn
contain the actual <strong>int</strong> values.</p>
<p>Besides being an extra level of indirection, this can be a big tank
when it comes to cache locality when iterating over the values. In the
case of an <strong>int</strong>[] the CPU could fetch all the values in
the array, into it's cache at once, because</p>
<p>they are contiguous in memory. But in the case of an Integer[] the
CPU potentially has to do an additional memory fetch for each element,
since the array only contains references to the actual values.</p>
<p>In short, using primitive wrapper types is relatively expensive in
both CPU and memory resources. Using them unnecessarily is in
efficient.</p>
<p>Section 135.8: Pitfall - The overheads of creating log</p>
<p>messages</p>
<p>TRACE and DEBUG log levels are there to be able to convey high detail
about the operation of the given code at</p>
<p>runtime. Setting the log level above these is usually recommended,
however some care must be taken for these statements to not affect
performance even when seemingly "turned off".</p>
<p>Consider this log statement:</p>
<p>// Processing a request of some kind, logging the parameters
<em>LOG.debug("Request coming from " + myInetAddress.toString()</em></p>
<p>+ " parameters: " + Arrays.toString(veryLongParamArray));</p>
<p>Even when the log level is set to INFO, arguments passed to debug()
will be evaluated on each execution of the line.</p>
<p>This makes it unnecessarily consuming on several counts:</p>
<p>String concatenation: multiple String instances will be created</p>
<p>InetAddress might even do a DNS lookup.</p>
<p>the veryLongParamArray might be very long - creating a String out of
it consumes memory, takes time</p>
<p>Solution</p>
<p>Most logging framework provide means to create log messages using fix
strings and object references. The log</p>
<p>message will be evaluated only if the message is actually logged.
Example:</p>
<p><em>// No toString() evaluation, no string concatenation if debug is
disabled</em> LOG.debug("Request coming from {} parameters: {}",
myInetAddress, parameters));</p>
<p>This works very well as long as all parameters can be converted to
strings using <a
href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#valueOf-java.lang.Object-">String.valueOf(Object)</a>.
If the log</p>
<p>message compuation is more complex, the log level can be checked
before logging:</p>
<p><strong>if</strong> (LOG.isDebugEnabled()) {</p>
<p>// Argument expression evaluated only when DEBUG is enabled</p>
<p>LOG.debug("Request coming from {}, parameters: {}",
myInetAddress,</p>
<p>Arrays.toString(veryLongParamArray);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 763</p>
<p><span id="_52" class="anchor"></span>}</p>
<p>Here, LOG.debug() with the costly Arrays.toString(Obect[])
computation is processed only when DEBUG is actually enabled.</p>
<p>Section 135.9: Pitfall - Iterating a Map's keys can be inecient</p>
<p>The following example code is slower than it needs to be :</p>
<p>Map map = <strong>new</strong> HashMap&lt;&gt;();</p>
<p><strong>for</strong> (String key : map.keySet()) {</p>
<p>String value = map.get(key);</p>
<p>// Do something with key and value</p>
<p>}</p>
<p>That is because it requires a map lookup (the get() method) for each
key in the map. This lookup may not be</p>
<p>efficient (in a HashMap, it entails calling hashCode on the key, then
looking up the correct bucket in internal data</p>
<p>structures, and sometimes even calling equals). On a large map, this
may not be a trivial overhead.</p>
<p>The correct way of avoiding this is to iterate on the map's entries,
which is detailed in the Collections topic</p>
<p>Section 135.10: Pitfall - Calling System.gc() is inecient</p>
<p>It is (almost always) a bad idea to call System.gc().</p>
<p>The javadoc for the gc() method specifies the following:</p>
<p>"Calling the gc method suggests that the Java Virtual Machine expend
effort toward recycling unused objects in order to make the memory they
currently occupy available for quick reuse. When control</p>
<p>returns from the method call, the Java Virtual Machine has made a
best effort to reclaim space from all discarded objects."</p>
<p>There are a couple of important points that can be drawn from
this:</p>
<p>1. The use of the word "suggests" rather than (say) "tells" means
that the JVM is free to ignore the suggestion.</p>
<p>The default JVM behavior (recent releases) is to follow the
suggestion, but this can be overridden by setting -XX:+DisableExplicitGC
when when launching the JVM.</p>
<p>2. The phrase "a best effort to reclaim space from all discarded
objects" implies that calling gc will trigger a</p>
<p>"full" garbage collection.</p>
<p>So why is calling System.gc() a bad idea?</p>
<p>First, running a full garbage collection is expensive. A full GC
involves visiting and "marking" every object that is still</p>
<p>reachable; i.e. every object that is not garbage. If you trigger this
when there isn't much garbage to be collected, then the GC does a lot of
work for relatively little benefit.</p>
<p>Second, a full garbage collection is liable to disturb the "locality"
properties of the objects that are not collected. Objects that are
allocated by the same thread at roughly the same time tend to be
allocated close together in</p>
<p>memory. This is good. Objects that are allocated at the same time are
likely to be related; i.e. reference each other.</p>
<p>If your application uses those references, then the chances are that
memory access will be faster because of various memory and page caching
effects. Unfortunately, a full garbage collection tend to move objects
around so</p>
<p>that objects that were once close are now further apart.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 764</p>
<p><span id="Third__running_a_full_garbage_co"
class="anchor"></span>Third, running a full garbage collection is liable
to make your application pause until the collection is complete. While
this is happening, your application will be non-responsive.</p>
<p>In fact, the best strategy is to let the JVM decide when to run the
GC, and what kind of collection to run. If you don't interfere, the JVM
will choose a time and collection type that optimizes throughput or
minimizes GC pause times.</p>
<p>At the beginning we said "... (almost always) a bad idea ...". In
fact there are a couple of scenarios where it <em>might</em> be a good
idea:</p>
<p>1. If you are implementing a unit test for some code that is garbage
collection sensitive (e.g. something</p>
<p>involving finalizers or weak / soft / phantom references) then
calling System.gc() may be necessary.</p>
<p>2. In some interactive applications, there can be particular points
in time where the user won't care if there is a</p>
<p>garbage collection pause. One example is a game where there are
natural pauses in the "play"; e.g. when loading a new level.</p>
<p>Section 135.11: Pitfall - Calling 'new String(String)' is
inecient</p>
<p>Using <strong>new</strong> String(String) to duplicate a string is
inefficient and almost always unnecessary.</p>
<p>String objects are immutable, so there is no need to copy them to
protect against changes.</p>
<p>In some older versions of Java, String objects can share backing
arrays with other String objects. In those versions, it is possible to
leak memory by creating a (small) substring of a (large) string and
retaining it.</p>
<p>However, from Java 7 onwards, String backing arrays are not
shared.</p>
<p>In the absence of any tangible benefit, calling <strong>new</strong>
String(String) is simply wasteful:</p>
<p>Making the copy takes CPU time.</p>
<p>The copy uses more memory which increases the application's memoru
footprint and / or increases GC</p>
<p>overheads.</p>
<p>Operations like equals(Object) and hashCode() can be slower if String
objects are copied.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 765</p>
<p><span id="Chapter_136__ServiceLoader_1" class="anchor"></span>Chapter
136: ServiceLoader</p>
<p>Section 136.1: Simple ServiceLoader Example</p>
<p>The ServiceLoader is a simple and easy to use built-in mechanism for
dynamic loading of interface implementations. With the service loader -
providing means for instantation (but not the wiring) - a simple</p>
<p>dependency injection mechanism can be built in Java SE. With the
ServiceLoader interface and implementation separation becomes natural
and programs can be conveniently extended. Actually a lot of Java API
are implented</p>
<p>based on the ServiceLoader</p>
<p>The basic concepts are</p>
<p>Operating on <em>interfaces</em> of services</p>
<p>Obtaining implementation(s) of the service via ServiceLoader</p>
<p>Providing implementation of servics</p>
<p>Lets start with the interface and put it in a jar, named for example
accounting-api.jar</p>
<p><strong>package</strong> example;</p>
<p><strong>public interface</strong> AccountingService {</p>
<p><strong>long</strong> getBalance();</p>
<p>}</p>
<p>Now we provide an implementation of that service in a jar named
accounting-impl.jar, containing an</p>
<p>implementation of the service</p>
<p><strong>package</strong> example.impl;</p>
<p><strong>import</strong> example.AccountingService;</p>
<p><strong>public interface</strong> DefaultAccountingService
<strong>implements</strong> AccouningService {</p>
<p><strong>public long</strong> getBalance() {</p>
<p><strong>return</strong> balanceFromDB();</p>
<p>}</p>
<p><strong>private long</strong> balanceFromDB(){</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>further, the accounting-impl.jar contains a file declaring that this
jar provides an implementation of</p>
<p>AccountingService . The file has to have a path starting with
META-INF/services/ and must have the same name as the
<em>fully-qualified</em> name of the interface:</p>
<p>META-INF/services/example.AccountingService</p>
<p>The content of the file is the <em>fully-qualfified</em> name of the
implementation:</p>
<p>example.impl.DefaultAccountingService</p>
<p>Given both jars are in the classpath of the program, that consumes
the AccountingService, an instance of the</p>
<p>Service can be obtained by using the ServiceLauncher</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 766</p>
<p><span id="ServiceLoader_loader___ServiceLo"
class="anchor"></span>ServiceLoader loader =
ServiceLoader.load(AccountingService.<strong>class</strong>)
AccountingService service = loader.next();</p>
<p><strong>long</strong> balance = service.getBalance();</p>
<p>As the ServiceLoader is an Iterable, it supports multiple
implementation providers, where the program may</p>
<p>choose from:</p>
<p>ServiceLoader loader =
ServiceLoader.load(AccountingService.<strong>class</strong>)
<strong>for</strong>(AccountingService service : loader) {</p>
<p>//...</p>
<p>}</p>
<p>Note that when invoking next() a new instance will allways be
created. If you want to re-use an instance, you have</p>
<p>to use the iterator() method of the ServiceLoader or the for-each
loop as shown above.</p>
<p>Section 136.2: Logger Service</p>
<p>The following example shows how to instantiate a class for logging
via the ServiceLoader.</p>
<p>Service</p>
<p><strong>package</strong> servicetest;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>public interface</strong> Logger <strong>extends</strong>
AutoCloseable {</p>
<p><strong>void</strong> log(String message) <strong>throws</strong>
IOException;</p>
<p>}</p>
<p>Implementations of the service</p>
<p>The following implementation simply writes the message to
System.err</p>
<p><strong>package</strong> servicetest.logger;</p>
<p><strong>import</strong> servicetest.Logger;</p>
<p><strong>public class</strong> ConsoleLogger
<strong>implements</strong> Logger {</p>
<p>@Override</p>
<p><strong>public void</strong> log(String message) {</p>
<p>System.err.println(message);</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>close() {</strong></p>
<p>}</p>
<p>}</p>
<p>The following implementation writes the messages to a text file:</p>
<p><strong>package</strong> servicetest.logger;</p>
<p><strong>import</strong> java.io.BufferedWriter;</p>
<p><strong>import</strong> java.io.FileWriter;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 767</p>
<p><strong>import</strong> servicetest.Logger;</p>
<p>public class <strong>FileLogger</strong> implements <strong>Logger
{</strong></p>
<p><strong>private final</strong> BufferedWriter writer;</p>
<p><strong>public</strong> FileLogger() <strong>throws</strong>
IOException {</p>
<p>writer = <strong>new</strong> BufferedWriter(<strong>new</strong>
FileWriter("log.txt"));</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> log(String message)
<strong>throws</strong> IOException {</p>
<p>writer.append(message);</p>
<p>writer.newLine();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> close() <strong>throws</strong>
IOException {</p>
<p>writer.close();</p>
<p>}</p>
<p>}</p>
<p>META-INF/services/servicetest.Logger</p>
<p>The META-INF/services/servicetest.Logger file lists the names of the
Logger implementations.</p>
<p>servicetest.logger.ConsoleLogger</p>
<p>servicetest.logger.FileLogger</p>
<p>Usage</p>
<p>The following main method writes a message to all available loggers.
The loggers are instantiated using ServiceLoader.</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p><strong>final</strong> String message = "Hello World!";</p>
<p>// get ServiceLoader for Logger</p>
<p>ServiceLoader loader =
ServiceLoader.load(servicetest.Logger.<strong>class</strong>);</p>
<p>// iterate through instances of available loggers, writing the
message to each one</p>
<p>Iterator iterator = loader.iterator();</p>
<p><strong>while</strong> (iterator.hasNext()) {</p>
<p><strong>try</strong> (Logger logger = iterator.next()) {</p>
<p>logger.log(message);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 768</p>
<p><span id="Chapter_137__Classloaders_1" class="anchor"></span>Chapter
137: Classloaders</p>
<p>Section 137.1: Implementing a custom classLoader</p>
<p>Every custom loader must directly or indirectly extend the
java.lang.ClassLoader class. The main <em>extension points</em> are the
following methods:</p>
<p>findClass(String) - overload this method if your classloader follows
the standard delegation model for class loading.</p>
<p>loadClass(String, <strong>boolean</strong>) - overload this method to
implement an alternative delegation model. findResource and
findResources - overload these methods to customize resource
loading.</p>
<p>The defineClass methods which are responsible for actually loading
the class from a byte array are <strong>final</strong> to prevent
overloading. Any custom behavior needs to be performed prior to calling
defineClass.</p>
<p>Here is a simple that loads a specific class from a byte array:</p>
<p><strong>public class</strong> ByteArrayClassLoader
<strong>extends</strong> ClassLoader {</p>
<p><strong>private</strong> String classname;</p>
<p><strong>private byte</strong>[] classfile;</p>
<p><strong>public</strong> ByteArrayClassLoader(String classname,
<strong>byte</strong>[] classfile) {</p>
<p><strong>this</strong>.classname = classname;</p>
<p><strong>this</strong>.classfile = classfile.clone();</p>
<p>}</p>
<p>@Override</p>
<p><strong>protected Class</strong> findClass(String classname)
<strong>throws</strong> ClassNotFoundException {</p>
<p><strong>if</strong>
(classname.equals(<strong>this</strong>.classname)) {</p>
<p><strong>return</strong> defineClass(classname, classfile, 0,
classfile.length);</p>
<p>} <strong>else</strong> {</p>
<p><strong>throw new</strong> ClassNotFoundException(classname);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Since we have only overridden the findClass method, this custom class
loader is going to behave as follows when</p>
<p>loadClass is called.</p>
<p>1. The classloader's loadClass method calls findLoadedClass to see if
a class with this name has already been</p>
<p>loaded by this classloader. If that succeeds, the resulting
<strong>Class</strong> object is returned to the requestor.</p>
<p>2. The loadClass method then delegates to the parent classloader by
calling its loadClass call. If the parent can</p>
<p>deal with the request, it will return a <strong>Class</strong> object
which is then returned to the requestor.</p>
<p>3. If the parent classloader cannot load the class, findClass then
calls our override findClass method, passing</p>
<p>the name of the class to be loaded.</p>
<p>4. If the requested name matches <strong>this</strong>.classname, we
call defineClass to load the actual class from the</p>
<p><strong>this</strong>.classfile byte array. The resulting
<strong>Class</strong> object is then returned.</p>
<p>5. If the name did not match, we throw ClassNotFoundException.</p>
<p>Section 137.2: Loading an external .class file</p>
<p>To load a class we first need to define it. The class is defined by
the ClassLoader. There's just one problem, Oracle</p>
<p>didn't write the ClassLoader's code with this feature available. To
define the class we will need to access a method named defineClass()
which is a private method of the ClassLoader.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 769</p>
<p><span id="To_access_it__what_we_will_do_is" class="anchor"></span>To
access it, what we will do is create a new class, ByteClassLoader, and
extend it to ClassLoader. Now that we have extended our class to
ClassLoader, we can access the ClassLoader's private methods. To
make</p>
<p>defineClass() available, we will create a new method that will act
like a mirror for the private defineClass()</p>
<p>method. To call the private method we will need the class name, name,
the class bytes, classBytes, the first byte's offset, which will be 0
because classBytes' data starts at classBytes[0], and the last byte's
offset, which will be</p>
<p>classBytes.lenght because it represents the size of the data, which
will be the last offset.</p>
<p><strong>public class</strong> ByteClassLoader
<strong>extends</strong> ClassLoader {</p>
<p><strong>public</strong> Class defineClass(String name,
<strong>byte</strong>[] classBytes) {</p>
<p><strong>return</strong> defineClass(name, classBytes, 0,
classBytes.length);</p>
<p>}</p>
<p>}</p>
<p>Now, we have a public defineClass() method. It can be called by
passing the name of the class and the class bytes</p>
<p>as arguments.</p>
<p>Let's say we have class named MyClass in the package
stackoverflow...</p>
<p>To call the method we need the class bytes so we create a Path object
representing our class' path by using the Paths.get() method and passing
the path of the binary class as an argument. Now, we can get the class
bytes with</p>
<p>Files.readAllBytes(path). So we create a ByteClassLoader instance and
use the method we created, defineClass(). We already have the class
bytes but to call our method we also need the class name which is
given</p>
<p>by the package name (dot) the class canonical name, in this case
stackoverflow.MyClass.</p>
<p>Path path = Paths.get("MyClass.class");</p>
<p>ByteClassLoader loader = <strong>new</strong> ByteClassLoader();</p>
<p>loader.defineClass("stackoverflow.MyClass",
Files.readAllBytes(path);</p>
<p><strong>Note</strong>: The defineClass() method returns a Class
object. You can save it if you want.</p>
<p>To load the class, we just call loadClass() and pass the class name.
This method can throw an</p>
<p>ClassNotFoundException so we need to use a try cath block</p>
<p>try<strong>{</strong></p>
<p>loader.loadClass("stackoverflow.MyClass");</p>
<p>} <strong>catch</strong>(ClassNotFoundException e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>Section 137.3: Instantiating and using a classloader</p>
<p>This basic example shows how an application can instantiate a
classloader and use it to dynamically load a class.</p>
<p>URL[] urls = <strong>new</strong> URL[] {<strong>new</strong>
URL("file:/home/me/extras.jar")}; Classloader loader =
<strong>new</strong> URLClassLoader(urls);</p>
<p>Class myObjectClass = loader.findClass("com.example.MyObject");</p>
<p>The classloader created in this example will have the default
classloader as its parent, and will first try to find any</p>
<p>class in the parent classloader before looking in "extra.jar". If the
requested class has already been loaded, the findClass call will return
the reference to the previously loaded class.</p>
<p>The findClass call can fail in a variety of ways. The most common
are:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 770</p>
<p>If the named class cannot be found, the call with throw
ClassNotFoundException. If the named class depends on some other class
that cannot be found, the call will throw</p>
<p>NoClassDefFoundError.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 771</p>
<p><span id="Chapter_138__Creating_Images" class="anchor"></span>Chapter
138: Creating Images</p>
<p>Programmatically</p>
<p>Section 138.1: Creating a simple image programmatically and</p>
<p>displaying it</p>
<p><strong>class</strong> ImageCreationExample {</p>
<p><strong>static</strong> Image createSampleImage() {</p>
<p><em>// instantiate a new BufferedImage (subclass of Image)
instance</em> BufferedImage img = <strong>new</strong>
BufferedImage(640, 480, BufferedImage.TYPE_INT_ARGB);</p>
<p>//draw something on the image</p>
<p>paintOnImage(img);</p>
<p>return <strong>img;</strong></p>
<p>}</p>
<p><strong>static void</strong> paintOnImage(BufferedImage img) {</p>
<p>// get a drawable Graphics2D (subclass of Graphics) object
<em>Graphics2D g2d = (Graphics2D) img.getGraphics();</em></p>
<p>// some sample drawing</p>
<p>g2d.setColor(Color.BLACK);</p>
<p>g2d.fillRect(0, 0, 640, 480);</p>
<p>g2d.setColor(Color.WHITE);</p>
<p>g2d.drawLine(0, 0, 640, 480);</p>
<p>g2d.drawLine(0, 480, 640, 0);</p>
<p>g2d.setColor(Color.YELLOW);</p>
<p>g2d.drawOval(200, 100, 240, 280);</p>
<p>g2d.setColor(Color.RED);</p>
<p>g2d.drawRect(150, 70, 340, 340);</p>
<p>// drawing on images can be very memory-consuming</p>
<p>// so it's better to free resources early</p>
<p>// it's not necessary, though</p>
<p>g2d.dispose();</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>JFrame frame = <strong>new</strong> JFrame();</p>
<p>frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>Image img = createSampleImage();</p>
<p>ImageIcon icon = <strong>new</strong> ImageIcon(img);</p>
<p>frame.add(<strong>new</strong> JLabel(icon));</p>
<p>frame.pack();</p>
<p>frame.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 772</p>
<p><span id="page_797" class="anchor"></span><img
src="media/index-797_1.png" style="width:6.5in;height:5.25in"
alt="index-797_1.png" /></p>
<p>Section 138.2: Save an Image to disk</p>
<p><strong>public static void</strong> saveImage(String destination)
<strong>throws</strong> IOException {</p>
<p>// method implemented in "Creating a simple image Programmatically
and displaying it" example <em>BufferedImage img =
createSampleImage();</em></p>
<p>// ImageIO provides several write methods with different outputs</p>
<p>ImageIO.write(img, "png", <strong>new</strong> File(destination));
}</p>
<p>Section 138.3: Setting individual pixel's color in BueredImage</p>
<p>BufferedImage image = <strong>new</strong> BufferedImage(256, 256,
BufferedImage.TYPE_INT_ARGB);</p>
<p>//you don't have to use the Graphics object, you can read and set
pixel color individually <em><strong>for</strong> (<strong>int</strong>
i = 0; i &lt; 256; i++) {</em></p>
<p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; 256; j++)
{</p>
<p><em><strong>int</strong> alpha = 255;</em> //don't forget this, or
use BufferedImage.TYPE_INT_RGB instead <em><strong>int</strong> red =
i;</em> //or any formula you like</p>
<p><em><strong>int</strong> green = j;</em> //or any formula you
like</p>
<p><em><strong>int</strong> blue = 50;</em> //or any formula you
like</p>
<p><strong>int</strong> color = (alpha &lt;&lt; 24) | (red &lt;&lt; 16)
| (green &lt;&lt; 8) | blue;</p>
<p>image.setRGB(i, j, color);</p>
<p>}</p>
<p>}</p>
<p>ImageIO.write(image, "png", <strong>new</strong>
File("computed.png"));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 773</p>
<p><span id="Output" class="anchor"></span>Output:</p>
<p><img src="media/index-798_1.png" style="width:2.875in;height:2.875in"
alt="index-798_1.png" /></p>
<p>Section 138.4: Specifying image rendering quality</p>
<p><strong>static void</strong> setupQualityHigh(Graphics2D g2d) {</p>
<p>g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_ON);</p>
<p>g2d.setRenderingHint(RenderingHints.KEY_RENDERING,
RenderingHints.VALUE_RENDER_QUALITY);</p>
<p>// many other RenderingHints KEY/VALUE pairs to specify</p>
<p>}</p>
<p><strong>static void</strong> setupQualityLow(Graphics2D g2d) {</p>
<p>g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_OFF);</p>
<p>g2d.setRenderingHint(RenderingHints.KEY_RENDERING,
RenderingHints.VALUE_RENDER_SPEED); }</p>
<p>A comparison of QUALITY and SPEED rendering of the sample image:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 774</p>
<p><img src="media/index-799_1.png" style="width:6.5in;height:5.25in"
alt="index-799_1.png" /></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 775</p>
<p><span id="page_800" class="anchor"></span><img
src="media/index-800_1.jpeg" style="width:6.5in;height:5.25in"
alt="index-800_1.jpg" /></p>
<p>Section 138.5: Creating an image with BueredImage class</p>
<p><strong>int</strong> width = 256; <em>//in pixels</em></p>
<p><strong>int</strong> height = 256; <em>//in pixels</em></p>
<p><em>BufferedImage image = <strong>new</strong> BufferedImage(width,
height, BufferedImage.TYPE_4BYTE_ABGR);</em>
//BufferedImage.TYPE_4BYTE_ABGR - store RGB color and visibility
(alpha), see javadoc for more info</p>
<p>Graphics g = image.createGraphics();</p>
<p>//draw whatever you like, like you would in a drawComponent(Graphics
g) method in an UI application <em>g.setColor(Color.RED);</em></p>
<p>g.fillRect(20, 30, 50, 50);</p>
<p>g.setColor(Color.BLUE);</p>
<p>g.drawOval(120, 120, 80, 40);</p>
<p><em>g.dispose();</em> //dispose graphics objects when they are no
longer needed</p>
<p>//now image has programmatically generated content, you can use it in
graphics.drawImage() to draw it somewhere else</p>
<p>//or just simply save it to a file</p>
<p>ImageIO.write(image, "png", <strong>new</strong>
File("myimage.png"));</p>
<p>Output:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 776</p>
<p><span id="page_801" class="anchor"></span><img
src="media/index-801_1.png" style="width:2.875in;height:2.875in"
alt="index-801_1.png" /></p>
<p>Section 138.6: Editing and re-using image with BueredImage</p>
<p>BufferedImage cat = ImageIO.read(<strong>new</strong>
File("cat.jpg")); <em>//read existing file</em></p>
<p>//modify it</p>
<p>Graphics g = cat.createGraphics();</p>
<p>g.setColor(Color.RED);</p>
<p>g.drawString("Cat", 10, 10);</p>
<p>g.dispose();</p>
<p>//now create a new image</p>
<p>BufferedImage cats = <strong>new</strong> BufferedImage(256, 256,
BufferedImage.TYPE_4BYTE_ABGR);</p>
<p>//and draw the old one on it, 16 times</p>
<p>g = cats.createGraphics();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; 4; i++)
{</p>
<p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; 4; j++)
{</p>
<p>g.drawImage(cat, i * 64, j * 64, <strong>null</strong>);</p>
<p>}</p>
<p>}</p>
<p>g.setColor(Color.BLUE);</p>
<p>g.drawRect(0, 0, 255, 255); <em>//add some nice border</em></p>
<p>g.dispose(); <em>//and done</em></p>
<p>ImageIO.write(cats, "png", <strong>new</strong>
File("cats.png"));</p>
<p>Original cat file:</p>
<p><img src="media/index-801_2.jpeg"
style="width:0.70833in;height:0.70833in" alt="index-801_2.jpg" /></p>
<p>Produced file:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 777</p>
<p><span id="page_802" class="anchor"></span><img
src="media/index-802_1.jpeg" style="width:2.875in;height:2.875in"
alt="index-802_1.jpg" /></p>
<p>Section 138.7: How to scale a BueredImage</p>
<p>/**</p>
<p>* Resizes an image using a Graphics2D object backed by a
BufferedImage. * @param srcImg - source image to scale</p>
<p>* @param w - desired width</p>
<p>* @param h - desired height</p>
<p>* @return - the new resized image</p>
<p>*/</p>
<p><strong>private</strong> BufferedImage getScaledImage(Image srcImg,
<strong>int</strong> w, <strong>int</strong> h){</p>
<p>//Create a new image with good size that contains or might contain
arbitrary alpha values between</p>
<p>and including 0.0 and 1.0.</p>
<p>BufferedImage resizedImg = <strong>new</strong> BufferedImage(w, h,
BufferedImage.TRANSLUCENT);</p>
<p>//Create a device-independant object to draw the resized image
<em>Graphics2D g2 = resizedImg.createGraphics();</em></p>
<p>//This could be changed, Cf.</p>
<p>http://stackoverflow.com/documentation/java/5482/creating-images-programmatically/19498/specifying-im
age-rendering-quality</p>
<p>g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
RenderingHints.VALUE_INTERPOLATION_BILINEAR);</p>
<p>//Finally draw the source image in the Graphics2D with the desired
size.</p>
<p>g2.drawImage(srcImg, 0, 0, w, h, <strong>null</strong>);</p>
<p>//Disposes of this graphics context and releases any system resources
that it is using</p>
<p>g2.dispose();</p>
<p>//Return the image used to create the Graphics2D</p>
<p><strong>return</strong> resizedImg;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 778</p>
<p><span id="Chapter_139__Atomic_Types_1" class="anchor"></span>Chapter
139: Atomic Types</p>
<p>Parameter Description</p>
<p>set Volatile set of the field</p>
<p>get Volatile read of the field</p>
<p>lazySet This is a store ordered operation of the field</p>
<p>compareAndSet If the value is the expeed value then sent it to the
new value</p>
<p>getAndSet get the current value and update</p>
<p>Java Atomic Types are simple mutable types that provide basic
operations that are thread-safe and atomic without resorting to locking.
They are intended for use in cases where locking would be a concurrency
bottleneck, or where</p>
<p>there is risk of deadlock or livelock.</p>
<p>Section 139.1: Creating Atomic Types</p>
<p>For simple multi-threaded code, using synchronization is acceptable.
However, using synchronization does have a</p>
<p>liveness impact, and as a codebase becomes more complex, the
likelihood goes up that you will end up with</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html">Deadlock</a>,
<a
href="https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html">Starvation,
or Livelock</a>.</p>
<p>In cases of more complex concurrency, using Atomic Variables is often
a better alternative, as it allows an individual</p>
<p>variable to be accessed in a thread-safe manner without the overhead
of using synchronized methods or code</p>
<p>blocks.</p>
<p>Creating an AtomicInteger type:</p>
<p>AtomicInteger aInt = <strong>new</strong> AtomicInteger() <em>//
Create with default value 0</em></p>
<p>AtomicInteger aInt = <strong>new</strong> AtomicInteger(1) <em>//
Create with initial value 1</em></p>
<p>Similarly for other instance types.</p>
<p>AtomicIntegerArray aIntArray = <strong>new</strong>
AtomicIntegerArray(10) <em>// Create array of specific length</em>
AtomicIntegerArray aIntArray = <strong>new</strong>
AtomicIntegerArray(<strong>new int</strong>[] {1, 2, 3}) <em>//
Initialize array with another array</em></p>
<p>Similarly for other atomic types.</p>
<p>There is a notable exception that there is no <strong>float</strong>
and <strong>double</strong> types. These can be simulated through the
use of Float.floatToIntBits(<strong>float</strong>) and
Float.intBitsToFloat(<strong>int</strong>) for <strong>float</strong> as
well as</p>
<p>Double.doubleToLongBits(<strong>double</strong>) and
Double.longBitsToDouble(<strong>long</strong>) for doubles.</p>
<p>If you are willing to use sun.misc.Unsafe you can use any primitive
variable as atomic by using the atomic</p>
<p>operation in sun.misc.Unsafe. All primitive types should be converted
or encoded in int or longs to so use it in this</p>
<p>way. For more on this see: sun.misc.Unsafe.</p>
<p>Section 139.2: Motivation for Atomic Types</p>
<p>The simple way to implement multi-threaded applications is to use
Java's built-in synchronization and locking primitives; e.g. the
<strong>synchronized</strong> keyword. The following example shows how
we might use <strong>synchronized</strong> to</p>
<p>accumulate counts.</p>
<p>public class <strong>Counters {</strong></p>
<p>private final int<strong>[] counters;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 779</p>
<p><strong>public</strong> Counters(<strong>int</strong> nosCounters)
{</p>
<p>counters = <strong>new int</strong>[nosCounters];</p>
<p>}</p>
<p>/**</p>
<p>* Increments the integer at the given index</p>
<p>*/</p>
<p>public synchronized void <strong>count(</strong>int <strong>number)
{</strong></p>
<p><strong>if</strong> (number &gt;= 0 &amp;&amp; number &lt;
counters.length) {</p>
<p>counters[number]++;</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Obtains the current count of the number at the given index,</p>
<p>* or if there is no number at that index, returns 0.</p>
<p>*/</p>
<p>public synchronized int <strong>getCount(</strong>int <strong>number)
{</strong></p>
<p><strong>return</strong> (number &gt;= 0 &amp;&amp; number &lt;
counters.length) ? counters[number] : 0;</p>
<p>}</p>
<p>}</p>
<p>This implementation will work correctly. However, if you have a large
number of threads making lots of</p>
<p>simultaneous calls on the same Counters object, the synchronization
is liable to be a bottleneck. Specifically:</p>
<p>1. Each <strong>synchronized</strong> method call will start with the
current thread acquiring the lock for the Counters</p>
<p>instance.</p>
<p>2. The thread will hold the lock while it checks number value and
updates the counter.</p>
<p>3. Finally, the it will release the lock, allowing other threads
access.</p>
<p>If one thread attempts to acquire the lock while another one holds
it, the attempting thread will be blocked</p>
<p>(stopped) at step 1 until the lock is released. If multiple threads
are waiting, one of them will get it, and the others will continue to be
blocked.</p>
<p>This can lead to a couple of problems:</p>
<p>If there is a lot of <em>contention</em> for the lock (i.e. lots of
thread try to acquire it), then some threads can be blocked for a long
time.</p>
<p>When a thread is blocked waiting for the lock, the operating system
will typically try switch execution to a</p>
<p>different thread. This <em>context switching</em> incurs a relatively
large performance impact on the processor.</p>
<p>When there are multiple threads blocked on the same lock, there are
no guarantees that any one of them will be treated "fairly" (i.e. each
thread is guaranteed to be scheduled to run). This can lead to
<em>thread</em></p>
<p>starvation<em>.</em></p>
<p>How does one implement Atomic Types?</p>
<p>Let us start by rewriting the example above using AtomicInteger
counters:</p>
<p>public class <strong>Counters {</strong></p>
<p><strong>private final</strong> AtomicInteger[] counters;</p>
<p><strong>public</strong> Counters(<strong>int</strong> nosCounters)
{</p>
<p>counters = <strong>new</strong> AtomicInteger[nosCounters];</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; nosCounters;
i++) {</p>
<p>counters[i] = <strong>new</strong> AtomicInteger();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 780</p>
<p>}</p>
<p>/**</p>
<p>* Increments the integer at the given index</p>
<p>*/</p>
<p><strong>public void</strong> count(<strong>int</strong> number) {</p>
<p><strong>if</strong> (number &gt;= 0 &amp;&amp; number &lt;
counters.length) {</p>
<p>counters[number].incrementAndGet();</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Obtains the current count of the object at the given index,</p>
<p>* or if there is no number at that index, returns 0.</p>
<p>*/</p>
<p><strong>public int</strong> getCount(<strong>int</strong> number)
{</p>
<p><strong>return</strong> (number &gt;= 0 &amp;&amp; number &lt;
counters.length) ?</p>
<p>counters[number].get() : 0;</p>
<p>}</p>
<p>}</p>
<p>We have replaced the <strong>int</strong>[] with an AtomicInteger[],
and initialized it with an instance in each element. We have also added
calls to incrementAndGet() and get() in place of operations on
<strong>int</strong> values.</p>
<p>But the most important thing is that we can remove the
<strong>synchronized</strong> keyword because locking is no longer
required. This works because the incrementAndGet() and get() operations
are <em>atomic</em> and <em>thread-safe</em>. In this</p>
<p>context, it means that:</p>
<p>Each counter in the array will only be <em>observable</em> in the
either the "before" state for an operation (like an</p>
<p>"increment") or in the "after" state.</p>
<p>Assuming that the operation occurs at time T, no thread will be able
to see the "before" state after time T.</p>
<p>Furthermore, while two threads might actually attempt to update the
same AtomicInteger instance at the same</p>
<p>time, the implementations of the operations ensure that only one
increment happens at a time on the given instance. This is done without
locking, often resulting in better performance.</p>
<p>How do Atomic Types work?</p>
<p>Atomic types typically rely on specialized hardware instructions in
the instruction set of the target machine. For</p>
<p>example, Intel-based instruction sets provide a CAS <a
href="https://en.wikipedia.org/wiki/Compare-and-swap">(Compare and Swap)
instruction that will perform a specific</a></p>
<p>sequence of memory operations atomically.</p>
<p>These low-level instructions are are used to implement higher-level
operations in the APIs of the respective</p>
<p>AtomicXxx classes. For example, (again, in C-like pseudocode):</p>
<p>private volatile <strong>num;</strong></p>
<p><strong>int</strong> increment() {</p>
<p>while <strong>(</strong>TRUE<strong>) {</strong></p>
<p><strong>int</strong> old = num;</p>
<p><strong>int new</strong> = old + 1;</p>
<p><strong>if</strong> (old == compare_and_swap(&amp;num, old,
<strong>new</strong>)) {</p>
<p>return new<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 781</p>
<p>If there is no contention on the AtomicXxxx, the if test will succeed
and the loop will end immediately. If there is contention, then the if
will fail for all but one of the threads, and they will "spin" in the
loop for a small number of</p>
<p>cycles of the loop. In practice, the spinning is orders of magnitude
faster (except at <em>unrealistically high</em> levels of</p>
<p>contention, where synchronized performs better than atomic classes
because when the CAS operation fails, then the retry will only add more
contention) than suspending the thread and switching to another one.</p>
<p>Incidentally, CAS instructions are typically used by the JVM to
implement <em>uncontended locking</em>. If the JVM can see that</p>
<p>a lock is not currently locked, it will attempt to use a CAS to
acquire the lock. If the CAS succeeds, then there is no</p>
<p>need to do the expensive thread scheduling, context switching and so
on. For more information on the techniques</p>
<p>used, see <a
href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">Biased
Locking in HotSpot.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 782</p>
<p><span id="Chapter_140__RSA_Encryption_1"
class="anchor"></span>Chapter 140: RSA Encryption</p>
<p>Section 140.1: An example using a hybrid cryptosystem</p>
<p>consisting of OAEP and GCM</p>
<p><a href="https://en.wikipedia.org/wiki/Hybrid_cryptosystem">The
following example encrypts data by using a hybrid cryptosystem</a>
consisting of AES GCM and OAEP, using their</p>
<p>default parameter sizes and an AES key size of 128 bits.</p>
<p>OAEP is less vulnerable to padding oracle attacks than PKCS#1 v1.5
padding. GCM is also protected against padding oracle attacks.</p>
<p>Decryption can be performed by first retrieving the length of the
encapsulated key and then by retrieving the encapsulated key. The
encapsulated key can then be decrypted using the RSA private key that
forms a key pair with</p>
<p>the public key. After that the AES/GCM encrypted ciphertext can be
decrypted to the original plaintext.</p>
<p>The protocol consists of:</p>
<p>1. a length field for the wrapped key (RSAPrivateKey misses a
getKeySize() method); 2. the wrapped/encapsulated key, of the same size
as the RSA key size in bytes;</p>
<p>3. the GCM ciphertext and 128 bit authentication tag (automatically
added by Java).</p>
<p>Notes:</p>
<p>To correctly use this code you should supply an RSA key of at least
2048 bits, bigger is better (but slower,</p>
<p>especially during decryption);</p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">To
use AES-256 you should install the unlimited cryptography policy files
first;</a> Instead creating your own protocol you might want to use a
container format such as the Cryptographic</p>
<p>Message Syntax (CMS / PKCS#7) or PGP instead.</p>
<p>So here's the example:</p>
<p>/**</p>
<p>* Encrypts the data using a hybrid crypto-system which uses GCM to
encrypt the data and OAEP to encrypt the AES key.</p>
<p>* The key size of the AES encryption will be 128 bit. * All the
default parameter choices are used for OAEP and GCM. *</p>
<p>* @param publicKey the RSA public key used to wrap the AES key *
@param plaintext the plaintext to be encrypted, not altered * @return
the ciphertext</p>
<p>* @throws InvalidKeyException if the key is not an RSA public key *
@throws NullPointerException if the plaintext is null */</p>
<p><strong>public static byte</strong>[] encryptData(PublicKey
publicKey, <strong>byte</strong>[] plaintext)</p>
<p><strong>throws</strong> InvalidKeyException, NullPointerException
{</p>
<p>// --- create the RSA OAEP cipher ---</p>
<p>Cipher oaep;</p>
<p>try <strong>{</strong></p>
<p>// SHA-1 is the default and not vulnerable in this setting // use
OAEPParameterSpec to configure more than just the hash</p>
<p>oaep = Cipher.getInstance("RSA/ECB/OAEPwithSHA1andMGF1Padding");</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for RSA cipher (mandatory algorithm for
runtimes)",</p>
<p>e);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 783</p>
<p>} <strong>catch</strong> (NoSuchPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for OAEP padding (present in the
standard Java</p>
<p>runtime sinze XX)", e);</p>
<p>}</p>
<p>oaep.init(Cipher.WRAP_MODE, publicKey);</p>
<p>// --- wrap the plaintext in a buffer</p>
<p>// will throw NullPointerException if plaintext is null</p>
<p>ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);</p>
<p>// --- generate a new AES secret key ---</p>
<p>KeyGenerator aesKeyGenerator;</p>
<p>try <strong>{</strong></p>
<p>aesKeyGenerator = KeyGenerator.getInstance("AES");</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for AES key generator (mandatory
algorithm for</p>
<p>runtimes)", e);</p>
<p>}</p>
<p>// for AES-192 and 256 make sure you've got the rights (install the
// Unlimited Crypto Policy files)</p>
<p>aesKeyGenerator.init(128);</p>
<p>SecretKey aesKey = aesKeyGenerator.generateKey();</p>
<p>// --- wrap the new AES secret key ---</p>
<p><strong>byte</strong>[] wrappedKey;</p>
<p>try <strong>{</strong></p>
<p>wrappedKey = oaep.wrap(aesKey);</p>
<p>} <strong>catch</strong> (IllegalBlockSizeException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"AES key should always fit OAEP with normal sized RSA key", e);</p>
<p>}</p>
<p>// --- setup the AES GCM cipher mode ---</p>
<p>Cipher aesGCM;</p>
<p>try <strong>{</strong></p>
<p>aesGCM = Cipher.getInstance("AES/GCM/Nopadding");</p>
<p>// we can get away with a zero nonce since the key is randomly
generated // 128 bits is the recommended (maximum) value for the tag
size // 12 bytes (96 bits) is the default nonce size for GCM mode
encryption</p>
<p>GCMParameterSpec staticParameterSpec = <strong>new</strong>
GCMParameterSpec(128, <strong>new byte</strong>[12]);</p>
<p>aesGCM.init(Cipher.ENCRYPT_MODE, aesKey, staticParameterSpec);</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for AES cipher (mandatory algorithm for
runtimes)",</p>
<p>e);</p>
<p>} <strong>catch</strong> (NoSuchPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for GCM (present in the standard Java
runtime sinze</p>
<p>XX)", e);</p>
<p>} <strong>catch</strong> (InvalidAlgorithmParameterException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"IvParameterSpec not accepted by this implementation of GCM", e);</p>
<p>}</p>
<p>// --- create a buffer of the right size for our own protocol ---</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 784</p>
<p>ByteBuffer ciphertextBuffer = ByteBuffer.allocate(</p>
<p>Short.BYTES</p>
<p>+ oaep.getOutputSize(128 / Byte.SIZE)</p>
<p>+ aesGCM.getOutputSize(plaintext.length));</p>
<p>// - element 1: make sure that we know the size of the wrapped
key</p>
<p>ciphertextBuffer.putShort((<strong>short</strong>)
wrappedKey.length);</p>
<p>// - element 2: put in the wrapped key</p>
<p>ciphertextBuffer.put(wrappedKey);</p>
<p>// - element 3: GCM encrypt into buffer</p>
<p>try <strong>{</strong></p>
<p>aesGCM.doFinal(plaintextBuffer, ciphertextBuffer);</p>
<p>} <strong>catch</strong> (ShortBufferException |
IllegalBlockSizeException | BadPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException("Cryptographic exception,
AES/GCM encryption should not fail</p>
<p>here", e);</p>
<p>}</p>
<p><strong>return</strong> ciphertextBuffer.array();</p>
<p>}</p>
<p>Of course, encryption is not very useful without decryption. Note
that this will return minimal information if</p>
<p>decryption fails.</p>
<p>/**</p>
<p>* Decrypts the data using a hybrid crypto-system which uses GCM to
encrypt * the data and OAEP to encrypt the AES key. All the default
parameter * choices are used for OAEP and GCM.</p>
<p>*</p>
<p>* @param privateKey</p>
<p>* the RSA private key used to unwrap the AES key * @param
ciphertext</p>
<p>* the ciphertext to be encrypted, not altered * @return the
plaintext</p>
<p>* @throws InvalidKeyException</p>
<p>* if the key is not an RSA private key * @throws
NullPointerException</p>
<p>* if the ciphertext is null</p>
<p>* @throws IllegalArgumentException</p>
<p>* with the message "Invalid ciphertext" if the ciphertext is invalid
(minimize information leakage)</p>
<p>*/</p>
<p><strong>public static byte</strong>[] decryptData(PrivateKey
privateKey, <strong>byte</strong>[] ciphertext)</p>
<p><strong>throws</strong> InvalidKeyException, NullPointerException
{</p>
<p>// --- create the RSA OAEP cipher ---</p>
<p>Cipher oaep;</p>
<p>try <strong>{</strong></p>
<p>// SHA-1 is the default and not vulnerable in this setting // use
OAEPParameterSpec to configure more than just the hash</p>
<p>oaep = Cipher.getInstance("RSA/ECB/OAEPwithSHA1andMGF1Padding");</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for RSA cipher (mandatory algorithm for
runtimes)",</p>
<p>e);</p>
<p>} <strong>catch</strong> (NoSuchPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for OAEP padding (present in the
standard Java</p>
<p>runtime sinze XX)",</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 785</p>
<p>e);</p>
<p>}</p>
<p>oaep.init(Cipher.UNWRAP_MODE, privateKey);</p>
<p>// --- wrap the ciphertext in a buffer</p>
<p>// will throw NullPointerException if ciphertext is null</p>
<p>ByteBuffer ciphertextBuffer = ByteBuffer.wrap(ciphertext);</p>
<p>// sanity check #1</p>
<p><strong>if</strong> (ciphertextBuffer.remaining() &lt; 2) {</p>
<p><strong>throw new</strong> IllegalArgumentException("Invalid
ciphertext");</p>
<p>}</p>
<p>// - element 1: the length of the encapsulated key</p>
<p><strong>int</strong> wrappedKeySize = ciphertextBuffer.getShort()
&amp; 0xFFFF; <em>// sanity check #2</em></p>
<p><strong>if</strong> (ciphertextBuffer.remaining() &lt; wrappedKeySize
+ 128 / Byte.SIZE) {</p>
<p><strong>throw new</strong> IllegalArgumentException("Invalid
ciphertext");</p>
<p>}</p>
<p>// --- unwrap the AES secret key ---</p>
<p><strong>byte</strong>[] wrappedKey = <strong>new
byte</strong>[wrappedKeySize];</p>
<p>// - element 2: the encapsulated key</p>
<p>ciphertextBuffer.get(wrappedKey);</p>
<p>SecretKey aesKey;</p>
<p>try <strong>{</strong></p>
<p>aesKey = (SecretKey) oaep.unwrap(wrappedKey, "AES",</p>
<p>Cipher.SECRET_KEY);</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for AES cipher (mandatory algorithm for
runtimes)",</p>
<p>e);</p>
<p>} <strong>catch</strong> (InvalidKeyException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Invalid ciphertext");</p>
<p>}</p>
<p>// --- setup the AES GCM cipher mode ---</p>
<p>Cipher aesGCM;</p>
<p>try <strong>{</strong></p>
<p>aesGCM = Cipher.getInstance("AES/GCM/Nopadding");</p>
<p>// we can get away with a zero nonce since the key is randomly //
generated</p>
<p>// 128 bits is the recommended (maximum) value for the tag size // 12
bytes (96 bits) is the default nonce size for GCM mode // encryption</p>
<p>GCMParameterSpec staticParameterSpec = <strong>new</strong>
GCMParameterSpec(128,</p>
<p>new byte<strong>[12]);</strong></p>
<p>aesGCM.init(Cipher.DECRYPT_MODE, aesKey, staticParameterSpec);</p>
<p>} <strong>catch</strong> (NoSuchAlgorithmException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for AES cipher (mandatory algorithm for
runtimes)",</p>
<p>e);</p>
<p>} <strong>catch</strong> (NoSuchPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Runtime doesn't have support for GCM (present in the standard Java
runtime sinze</p>
<p>XX)",</p>
<p>e);</p>
<p>} <strong>catch</strong> (InvalidAlgorithmParameterException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 786</p>
<p>"IvParameterSpec not accepted by this implementation of GCM",</p>
<p>e);</p>
<p>}</p>
<p>// --- create a buffer of the right size for our own protocol ---</p>
<p>ByteBuffer plaintextBuffer = ByteBuffer.allocate(aesGCM</p>
<p>.getOutputSize(ciphertextBuffer.remaining()));</p>
<p>// - element 3: GCM ciphertext</p>
<p>try <strong>{</strong></p>
<p>aesGCM.doFinal(ciphertextBuffer, plaintextBuffer);</p>
<p>} <strong>catch</strong> (ShortBufferException |
IllegalBlockSizeException</p>
<p>| BadPaddingException e) {</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Invalid ciphertext");</p>
<p>}</p>
<p><strong>return</strong> plaintextBuffer.array();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 787</p>
<p><span id="Chapter_141__Secure_objects_1"
class="anchor"></span>Chapter 141: Secure objects</p>
<p>Section 141.1: SealedObject (javax.crypto.SealedObject)</p>
<p>This class enables a programmer to create an object and protect its
confidentiality with a cryptographic algorithm.</p>
<p>Given any Serializable object, one can create a
<strong>SealedObject</strong> that encapsulates the original object, in
serialized</p>
<p>format (i.e., a "deep copy"), and seals (encrypts) its serialized
contents, using a cryptographic algorithm such as AES,</p>
<p>DES, to protect its confidentiality. The encrypted content can later
be decrypted (with the corresponding algorithm using the correct
decryption key) and de-serialized, yielding the original object.</p>
<p><img src="media/index-812_1.png" style="width:6.5in;height:2.66667in"
alt="index-812_1.png" /></p>
<p>Serializable obj = <strong>new</strong> String("John");</p>
<p>// Generate key</p>
<p>KeyGenerator kgen = KeyGenerator.getInstance("AES");
kgen.init(128);</p>
<p>SecretKey aesKey = kgen.generateKey();</p>
<p>Cipher cipher = Cipher.getInstance("AES");</p>
<p>cipher.init(Cipher.ENCRYPT_MODE, aesKey);</p>
<p>SealedObject sealedObject = <strong>new</strong> SealedObject(obj,
cipher); System.out.println("sealedObject-" + sealedObject);
System.out.println("sealedObject Data-" +
sealedObject.getObject(aesKey));</p>
<p>Section 141.2: SignedObject (java.security.SignedObject)</p>
<p>SignedObject is a class for the purpose of creating authentic runtime
objects whose integrity cannot be</p>
<p>compromised without being detected.</p>
<p>More specifically, a SignedObject contains another Serializable
object, the (to-be-)signed object and its signature.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 788</p>
<p><img src="media/index-813_1.png" style="width:6.5in;height:2.66667in"
alt="index-813_1.png" /></p>
<p>//Create a key</p>
<p>KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA", "SUN");
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
keyGen.initialize(1024, random);</p>
<p>// create a private key</p>
<p>PrivateKey signingKey = keyGen.generateKeyPair().getPrivate(); <em>//
create a Signature</em></p>
<p>Signature signingEngine = Signature.getInstance("DSA");
signingEngine.initSign(signingKey);</p>
<p>// create a simple object</p>
<p>Serializable obj = <strong>new</strong> String("John");</p>
<p>// sign our object</p>
<p>SignedObject signedObject = <strong>new</strong> SignedObject(obj,
signingKey, signingEngine);</p>
<p>System.out.println("signedObject-" + signedObject);
System.out.println("signedObject Data-" + signedObject.getObject());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 789</p>
<p><span id="Chapter_142__Security___Cryptogr_1"
class="anchor"></span>Chapter 142: Security &amp; Cryptography</p>
<p>Section 142.1: Compute Cryptographic Hashes</p>
<p>To compute the hashes of relatively small blocks of data using
different algorithms:</p>
<p><strong>final</strong> MessageDigest md5 =
MessageDigest.getInstance("MD5"); <strong>final</strong> MessageDigest
sha1 = MessageDigest.getInstance("SHA-1"); <strong>final</strong>
MessageDigest sha256 = MessageDigest.getInstance("SHA-256");</p>
<p><strong>final byte</strong>[] data = "FOO BAR".getBytes();</p>
<p>System.out.println("MD5 hash: " +
DatatypeConverter.printHexBinary(md5.digest(data)));
System.out.println("SHA1 hash: " +
DatatypeConverter.printHexBinary(sha1.digest(data)));
System.out.println("SHA256 hash: " +
DatatypeConverter.printHexBinary(sha256.digest(data)));</p>
<p>Produces this output:</p>
<p>MD5 hash: E99E768582F6DD5A3BA2D9C849DF736E</p>
<p>SHA1 hash: 0135FAA6323685BA8A8FF8D3F955F0C36949D8FB SHA256 hash:
8D35C97BCD902B96D1B551741BBE8A7F50BB5A690B4D0225482EAA63DBFB9DED</p>
<p>Additional algorithms may be available depending on your
implementation of the Java platform.</p>
<p>Section 142.2: Encrypt and Decrypt Data with Public / Private</p>
<p>Keys</p>
<p>To encrypt data with a public key:</p>
<p><strong>final</strong> Cipher rsa = Cipher.getInstance("RSA");</p>
<p>rsa.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
rsa.update(message.getBytes());</p>
<p><strong>final byte</strong>[] result = rsa.doFinal();</p>
<p>System.out.println("Message: " + message);</p>
<p>System.out.println("Encrypted: " +
DatatypeConverter.printHexBinary(result));</p>
<p>Produces output similar to:</p>
<p>Message: Hello</p>
<p>Encrypted: 5641FBB9558ECFA9ED...</p>
<p>Note that when creating the Cipher object, you have to specify a
transformation that is compatible with the type of</p>
<p><a
href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher">key
being used. (See JCA Standard Algorithm Names for a list of supported
transformations.). For RSA encryption</a></p>
<p>data message.getBytes() length must be smaller than the key size. See
this <a href="http://stackoverflow.com/a/5868456/669265">SO Answer for
detail.</a></p>
<p>To decrypt the data:</p>
<p><strong>final</strong> Cipher rsa = Cipher.getInstance("RSA");</p>
<p>rsa.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
rsa.update(cipherText);</p>
<p><strong>final</strong> String result = <strong>new</strong>
String(rsa.doFinal());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 790</p>
<p><span id="System_out_println__Decrypted"
class="anchor"></span>System.out.println("Decrypted: " + result);</p>
<p>Produces the following output:</p>
<p>Decrypted: Hello</p>
<p>Section 142.3: Generate Cryptographically Random Data</p>
<p>To generate samples of cryptographically random data:</p>
<p>final byte<strong>[] sample =</strong> new
byte<strong>[16];</strong></p>
<p><strong>new</strong> SecureRandom().nextBytes(sample);</p>
<p>System.out.println("Sample: " +
DatatypeConverter.printHexBinary(sample));</p>
<p>Produces output similar to:</p>
<p>Sample: E4F14CEA2384F70B706B53A6DF8C5EFE</p>
<p>Note that the call to nextBytes() may block while entropy is gathered
depending on the algorithm being used.</p>
<p>To specify the algorithm and provider:</p>
<p>final byte<strong>[] sample =</strong> new
byte<strong>[16];</strong></p>
<p><strong>final</strong> SecureRandom randomness =
SecureRandom.getInstance("SHA1PRNG", "SUN");</p>
<p>randomness.nextBytes(sample);</p>
<p>System.out.println("Provider: " + randomness.getProvider());
System.out.println("Algorithm: " + randomness.getAlgorithm());
System.out.println("Sample: " +
DatatypeConverter.printHexBinary(sample));</p>
<p>Produces output similar to:</p>
<p>Provider: SUN version 1.8</p>
<p>Algorithm: SHA1PRNG</p>
<p>Sample: C80C44BAEB352FD29FBBE20489E4C0B9</p>
<p>Section 142.4: Generate Public / Private Key Pairs</p>
<p>To generate key pairs using different algorithms and key sizes:</p>
<p><strong>final</strong> KeyPairGenerator dhGenerator =
KeyPairGenerator.getInstance("DiffieHellman"); <strong>final</strong>
KeyPairGenerator dsaGenerator = KeyPairGenerator.getInstance("DSA");
<strong>final</strong> KeyPairGenerator rsaGenerator =
KeyPairGenerator.getInstance("RSA");</p>
<p>dhGenerator.initialize(1024);</p>
<p>dsaGenerator.initialize(1024);</p>
<p>rsaGenerator.initialize(2048);</p>
<p><strong>final</strong> KeyPair dhPair =
dhGenerator.generateKeyPair(); <strong>final</strong> KeyPair dsaPair =
dsaGenerator.generateKeyPair(); <strong>final</strong> KeyPair rsaPair =
rsaGenerator.generateKeyPair();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 791</p>
<p><span id="Additional_algorithms_and_key_si"
class="anchor"></span>Additional algorithms and key sizes may be
available on your implementation of the Java platform.</p>
<p>To specify a source of randomness to use when generating the
keys:</p>
<p><strong>final</strong> KeyPairGenerator generator =
KeyPairGenerator.getInstance("RSA");</p>
<p>generator.initialize(2048, SecureRandom.getInstance("SHA1PRNG",
"SUN"));</p>
<p><strong>final</strong> KeyPair pair =
generator.generateKeyPair();</p>
<p>Section 142.5: Compute and Verify Digital Signatures</p>
<p>To compute a signature:</p>
<p><strong>final</strong> PrivateKey privateKey = keyPair.getPrivate();
<strong>final byte</strong>[] data = "FOO BAR".getBytes();</p>
<p><strong>final</strong> Signature signer =
Signature.getInstance("SHA1withRSA");</p>
<p>signer.initSign(privateKey);</p>
<p>signer.update(data);</p>
<p><strong>final byte</strong>[] signature = signer.sign();</p>
<p>Note that the signature algorithm must be compatible with the
algorithm used to generate the key pair.</p>
<p>To verify a signature:</p>
<p><strong>final</strong> PublicKey publicKey = keyPair.getPublic();</p>
<p><strong>final</strong> Signature verifier =
Signature.getInstance("SHA1withRSA");</p>
<p>verifier.initVerify(publicKey);</p>
<p>verifier.update(data);</p>
<p>System.out.println("Signature: " + verifier.verify(signature));</p>
<p>Produces this output:</p>
<p>Signature: true</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 792</p>
<p><span id="Chapter_143__Security___Cryptogr_1"
class="anchor"></span>Chapter 143: Security &amp; Cryptography</p>
<p>Security practices in Java can be separated into two broad, vaguely
defined categories; Java platform security, and</p>
<p>secure Java programming.</p>
<p>Java platform security practices deal with managing the security and
integrity of the JVM. It includes such topics as</p>
<p>managing JCE providers and security policies.</p>
<p>Secure Java programming practices concern the best ways to write
secure Java programs. It includes such topics as</p>
<p>using random numbers and cryptography, and preventing
vulnerabilities.</p>
<p>Section 143.1: The JCE</p>
<p>The Java Cryptography Extension (JCE) is a framework built into the
JVM to allow developers to easily and securely use cryptography in their
programs. It does this by providing a simple, portable interface to
programmers, while</p>
<p>using a system of JCE Providers to securely implement the underlying
cryptographic operations.</p>
<p>Section 143.2: Keys and Key Management</p>
<p>While the JCE secures cryptographic operations and key generation, it
is up to the developer to actually manage</p>
<p>their keys. More information needs to be provided here.</p>
<p>One commonly-accepted best practice for handling keys at runtime is
to store them only as <strong>byte</strong> arrays, and never</p>
<p>as strings. This is because Java strings are immutable, and cannot be
manually "cleared" or "zeroed out" in memory; while a reference to a
string can be removed, the exact string will remain in memory until its
segment of memory is</p>
<p>garbage-collected and reused. An attacker would have a large window
in which they could dump the program's memory and easily find the key.
Contrarily, <strong>byte</strong> arrays are mutable, and can have their
contents overwritten in</p>
<p>place; it is a good idea to 'zero-out' your keys as soon as you no
longer need them.</p>
<p>Section 143.3: Common Java vulnerabilities</p>
<p>Section 143.4: Networking Concerns</p>
<p>Section 143.5: Randomness and You</p>
<p>For most applications, the java.utils.Random class is a perfectly
fine source of "random" data. If you need to</p>
<p>choose a random element from an array, or generate a random string,
or create a temporary "unique" identifier,</p>
<p>you should probably use Random.</p>
<p>However, many cryptographic systems rely on randomness for their
security, and the randomness provided by Random simply isn't of high
enough quality. For any cryptographic operation that requires a random
input, you</p>
<p>should use SecureRandom instead.</p>
<p>Section 143.6: Hashing and Validation</p>
<p>A cryptographic hash function is a member of a class of functions
with three vital properties; consistency,</p>
<p>uniqueness, and irreversibility.</p>
<p><strong>Consistency:</strong> Given the same data, a hash function
will always return the same value. That is, if X = Y, f(x) will
always</p>
<p>equal f(y) for hash function f.</p>
<p><strong>Uniqueness:</strong> No two inputs to a hash function will
ever result in the same output. That is, if X != Y, f(x) != f(y), for
any</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 793</p>
<p>values of X and Y.</p>
<p><strong>Irreversibility:</strong> It is impractically difficult, if
not impossible, to "reverse" a hash function. That is, given only
f(X),</p>
<p>there should be no way of finding the original X short of putting
every possible value of X through the function f (brute-force). There
should be no function f1 such that f1(f(X)) = X.</p>
<p>Many functions lack at least one of these attributes. For example,
MD5 and SHA1 are known to have collisions, i.e.</p>
<p>two inputs that have the same output, so they lack uniqueness. Some
functions that are currently believed to be</p>
<p>secure are SHA-256 and SHA-512.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 794</p>
<p><span id="Chapter_144__SecurityManager_1"
class="anchor"></span>Chapter 144: SecurityManager</p>
<p>Section 144.1: Sandboxing classes loaded by a ClassLoader</p>
<p>The ClassLoader needs to provide a ProtectionDomain identifying the
source of the code:</p>
<p><strong>public class</strong> PluginClassLoader
<strong>extends</strong> ClassLoader {</p>
<p><strong>private final</strong> ClassProvider provider;</p>
<p><strong>private final</strong> ProtectionDomain pd;</p>
<p><strong>public</strong> PluginClassLoader(ClassProvider provider)
{</p>
<p><strong>this</strong>.provider = provider;</p>
<p>Permissions permissions = <strong>new</strong> Permissions();</p>
<p><strong>this</strong>.pd = <strong>new</strong>
ProtectionDomain(provider.getCodeSource(), permissions,
<strong>this</strong>, <strong>null</strong>);</p>
<p>}</p>
<p>@Override</p>
<p><strong>protected</strong> Class findClass(String name)
<strong>throws</strong> ClassNotFoundException {</p>
<p><strong>byte</strong>[] classDef = provider.getClass(name);</p>
<p>Class clazz = defineClass(name, classDef, 0, classDef.length,
pd);</p>
<p><strong>return</strong> clazz;</p>
<p>}</p>
<p>}</p>
<p>By overriding findClass rather than loadClass the delegational model
is preserved, and the PluginClassLoader will first query the system and
parent classloader for class definitions.</p>
<p>Create a Policy:</p>
<p><strong>public class</strong> PluginSecurityPolicy
<strong>extends</strong> Policy {</p>
<p><strong>private final</strong> Permissions appPermissions =
<strong>new</strong> Permissions(); <strong>private final</strong>
Permissions pluginPermissions = <strong>new</strong> Permissions();</p>
<p><strong>public</strong> PluginSecurityPolicy() {</p>
<p>// amend this as appropriate</p>
<p>appPermissions.add(<strong>new</strong> AllPermission());</p>
<p>// add any permissions plugins should have to pluginPermissions</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Provider getProvider() {</p>
<p><strong>return super</strong>.getProvider();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> String getType() {</p>
<p>return super<strong>.getType();</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> Parameters getParameters() {</p>
<p><strong>return super</strong>.getParameters();</p>
<p>}</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 795</p>
<p><span id="public_PermissionCollection_getP"
class="anchor"></span><strong>public</strong> PermissionCollection
getPermissions(CodeSource codesource) {</p>
<p><strong>return new</strong> Permissions();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> PermissionCollection
getPermissions(ProtectionDomain domain) {</p>
<p><strong>return</strong>
isPlugin(domain)?pluginPermissions:appPermissions;</p>
<p>}</p>
<p><strong>private boolean</strong> isPlugin(ProtectionDomain pd){</p>
<p><strong>return</strong> pd.getClassLoader()
<strong>instanceof</strong> PluginClassLoader;</p>
<p>}</p>
<p>}</p>
<p>Finally, set the policy and a SecurityManager (default implementation
is fine):</p>
<p>Policy.setPolicy(<strong>new</strong> PluginSecurityPolicy());</p>
<p>System.setSecurityManager(<strong>new</strong>
SecurityManager());</p>
<p>Section 144.2: Enabling the SecurityManager</p>
<p>Java Virtual Machines (JVMs) can be run with a SecurityManager
installed. The SecurityManager governs what the</p>
<p>code running in the JVM is allowed to do, based on factors such as
where the code was loaded from and what certificates were used to sign
the code.</p>
<p>The SecurityManager can be installed by setting the
java.security.manager system property on the command line when starting
the JVM:</p>
<p>java -Djava.security.manager</p>
<p>class name&gt;</p>
<p>or programmatically from within Java code:</p>
<p>System.setSecurityManager(<strong>new</strong> SecurityManager())</p>
<p>The standard Java SecurityManager grants permissions on the basis of
a Policy, which is defined in a policy file. If no</p>
<p>policy file is specified, the default policy file under
$JAVA_HOME/lib/security/java.policy will be used.</p>
<p>Section 144.3: Implementing policy deny rules</p>
<p>It is occasionally desirable to <em>deny</em> a certain Permission to
some ProtectionDomain, <em>regardless</em> of any other</p>
<p>permissions that domain accrues. This example demonstrates just one
of all the possible approaches for satisfying</p>
<p>this kind of requirement. It introduces a "negative" permission
class, along with a wrapper that enables the default Policy to be reused
as a repository of such permissions.</p>
<p>Notes:</p>
<p>The standard policy file syntax and mechanism for permission
assignment in general remain unaffected. This means that <em>deny</em>
rules within policy files are still expressed as <em>grants</em>.</p>
<p>The policy wrapper is meant to specifically encapsulate the default
file-backed Policy (assumed to be
com.sun.security.provider.PolicyFile).</p>
<p>Denied permissions are only processed as such at the policy level. If
statically assigned to a domain, they will</p>
<p>by default be treated by that domain as ordinary "positive"
permissions.</p>
<p>The DeniedPermission class</p>
<p><strong>package</strong> com.example;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 796</p>
<p><strong>import</strong> java.lang.reflect.Constructor;</p>
<p><strong>import</strong> java.lang.reflect.InvocationTargetException;
<strong>import</strong> java.lang.reflect.Modifier;</p>
<p><strong>import</strong> java.security.BasicPermission;</p>
<p><strong>import</strong> java.security.Permission;</p>
<p><strong>import</strong> java.security.UnresolvedPermission;</p>
<p><strong>import</strong> java.text.MessageFormat;</p>
<p>/**</p>
<p>* A representation of a "negative" privilege.</p>
<p>* &lt;p&gt;</p>
<p>* A &lt;code&gt;DeniedPermission&lt;/code&gt;, when "granted" (to
some &lt;code&gt;ProtectionDomain&lt;/code&gt; and/or *
&lt;code&gt;Principal&lt;/code&gt;), represents a privilege which
&lt;em&gt;cannot&lt;/em&gt; be exercised, regardless of * any positive
permissions (&lt;code&gt;AllPermission&lt;/code&gt; included) possessed.
In other words, if a * set of granted permissions,
&lt;em&gt;P&lt;/em&gt;, contains a permission of this class,
&lt;em&gt;D&lt;/em&gt;, then the * set of effectively granted
permissions is&lt;br/&gt;</p>
<p>* &lt;br/&gt;</p>
<p>* &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;{
P&lt;sub&gt;implied&lt;/sub&gt; - D&lt;sub&gt;implied&lt;/sub&gt;
}&lt;/em&gt;. * &lt;/p&gt;</p>
<p>* &lt;p&gt;</p>
<p>* Each instance of this class encapsulates a &lt;em&gt;target
permission&lt;/em&gt;, representing the * "positive" permission being
denied.</p>
<p>* &lt;/p&gt;</p>
<p>* Denied permissions employ the following naming scheme:&lt;br/&gt; *
&lt;br/&gt;</p>
<p>*</p>
<p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;&amp;lt;target_class_name&amp;gt;:&amp;lt;target_name&amp;gt;(:&amp;lt;target_actions&amp;gt;)&lt;/e
m&gt;&lt;br/&gt;</p>
<p>* &lt;br/&gt;</p>
<p>* where:</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;&lt;em&gt;target_class_name&lt;/em&gt; is the name of the
target permission's class,&lt;/li&gt; *
&lt;li&gt;&lt;em&gt;target_name&lt;/em&gt; is the name of the target
permission, and&lt;/li&gt; *
&lt;li&gt;&lt;em&gt;target_actions&lt;/em&gt; is, optionally, the
actions string of the target permission.&lt;/li&gt; * &lt;/ul&gt;</p>
<p>* A denied permission, having a target permission
&lt;em&gt;t&lt;/em&gt;, is said to &lt;em&gt;imply&lt;/em&gt; another *
permission &lt;em&gt;p&lt;/em&gt;, if:</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;p &lt;em&gt;is not&lt;/em&gt; itself a denied permission,
and &lt;code&gt;(t.implies(p) == true)&lt;/code&gt;, * or&lt;/li&gt;</p>
<p>* &lt;li&gt;p &lt;em&gt;is&lt;/em&gt; a denied permission, with a
target &lt;em&gt;t1&lt;/em&gt;, and * &lt;code&gt;(t.implies(t1) ==
true)&lt;/code&gt;.</p>
<p>* &lt;/ul&gt;</p>
<p>* &lt;p&gt;</p>
<p>* It is the responsibility of the policy decision point (e.g., the
&lt;code&gt;Policy&lt;/code&gt; provider) to * take denied permission
semantics into account when issuing authorization statements. *
&lt;/p&gt;</p>
<p>*/</p>
<p><strong>public final class</strong> DeniedPermission
<strong>extends</strong> BasicPermission {</p>
<p><strong>private final</strong> Permission target;</p>
<p><strong>private static final long</strong> serialVersionUID =
473625163869800679L;</p>
<p>/**</p>
<p>* Instantiates a &lt;code&gt;DeniedPermission&lt;/code&gt; that
encapsulates a target permission of the</p>
<p>* indicated class, specified name and, optionally, actions.</p>
<p>*</p>
<p>* @throws IllegalArgumentException</p>
<p>* if:</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;targetClassName&lt;/code&gt; is
&lt;code&gt;null&lt;/code&gt;, the empty string, does not</p>
<p>* refer to a concrete &lt;code&gt;Permission&lt;/code&gt; descendant,
or refers to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 797</p>
<p> * &lt;code&gt;DeniedPermission.class&lt;/code&gt; or
&lt;code&gt;UnresolvedPermission.class&lt;/code&gt;.&lt;/li&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;targetName&lt;/code&gt; is
&lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;targetClassName&lt;/code&gt; cannot be
instantiated, and it's the caller's fault;</p>
<p>* e.g., because &lt;code&gt;targetName&lt;/code&gt; and/or
&lt;code&gt;targetActions&lt;/code&gt; do not adhere</p>
<p>* to the naming constraints of the target class; or due to the target
class not</p>
<p>* exposing a &lt;code&gt;(String name)&lt;/code&gt;, or
&lt;code&gt;(String name, String actions)&lt;/code&gt;</p>
<p>* constructor, depending on whether
&lt;code&gt;targetActions&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
or</p>
<p>* not.&lt;/li&gt;</p>
<p>* &lt;/ul&gt;</p>
<p>*/</p>
<p><strong>public static</strong> DeniedPermission
newDeniedPermission(String targetClassName, String targetName,</p>
<p>String targetActions) {</p>
<p><strong>if</strong> (targetClassName == <strong>null</strong> ||
targetClassName.trim().isEmpty() || targetName == <strong>null</strong>)
{</p>
<p><strong>throw new</strong> IllegalArgumentException(</p>
<p>"Null or empty [targetClassName], or null [targetName] argument
was</p>
<p>supplied.");</p>
<p>}</p>
<p>StringBuilder sb = <strong>new</strong>
StringBuilder(targetClassName).append(":").append(targetName);</p>
<p><strong>if</strong> (targetName != <strong>null</strong>) {</p>
<p>sb.append(":").append(targetName);</p>
<p>}</p>
<p><strong>return new</strong> DeniedPermission(sb.toString());</p>
<p>}</p>
<p>/**</p>
<p>* Instantiates a &lt;code&gt;DeniedPermission&lt;/code&gt; that
encapsulates a target permission of the class,</p>
<p>* name and, optionally, actions, collectively provided as the
&lt;code&gt;name&lt;/code&gt; argument.</p>
<p>*</p>
<p>* @throws IllegalArgumentException</p>
<p>* if:</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;name&lt;/code&gt;'s target permission class
name component is empty, does not</p>
<p>* refer to a concrete &lt;code&gt;Permission&lt;/code&gt; descendant,
or refers to</p>
<p>* &lt;code&gt;DeniedPermission.class&lt;/code&gt; or
&lt;code&gt;UnresolvedPermission.class&lt;/code&gt;.&lt;/li&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;name&lt;/code&gt;'s target name component is
&lt;code&gt;empty&lt;/code&gt;&lt;/li&gt;</p>
<p>* &lt;li&gt;the target permission class cannot be instantiated, and
it's the caller's fault;</p>
<p>* e.g., because &lt;code&gt;name&lt;/code&gt;'s target name and/or
target actions component(s) do</p>
<p>* not adhere to the naming constraints of the target class; or due to
the target class</p>
<p>* not exposing a &lt;code&gt;(String name)&lt;/code&gt;, or</p>
<p>* &lt;code&gt;(String name, String actions)&lt;/code&gt; constructor,
depending on whether the</p>
<p>* target actions component is empty or not.&lt;/li&gt;</p>
<p>* &lt;/ul&gt;</p>
<p>*/</p>
<p><strong>public</strong> DeniedPermission(String name) {</p>
<p><strong>super</strong>(name);</p>
<p>String[] comps = name.split(":");</p>
<p><strong>if</strong> (comps.length &lt; 2) {</p>
<p><strong>throw new</strong>
IllegalArgumentException(MessageFormat.format("Malformed name [{0}]</p>
<p>argument.", name));</p>
<p>}</p>
<p><strong>this</strong>.target = initTarget(comps[0], comps[1],
((comps.length &lt; 3) ? <strong>null</strong> : comps[2]));</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 798</p>
<p>/**</p>
<p>* Instantiates a &lt;code&gt;DeniedPermission&lt;/code&gt; that
encapsulates the given target permission.</p>
<p>*</p>
<p>* @throws IllegalArgumentException</p>
<p>* if &lt;code&gt;target&lt;/code&gt; is
&lt;code&gt;null&lt;/code&gt;, a
&lt;code&gt;DeniedPermission&lt;/code&gt;, or an</p>
<p>* &lt;code&gt;UnresolvedPermission&lt;/code&gt;.</p>
<p>*/</p>
<p><strong>public static</strong> DeniedPermission
newDeniedPermission(Permission target) {</p>
<p><strong>if</strong> (target == <strong>null</strong>) {</p>
<p><strong>throw new</strong> IllegalArgumentException("Null [target]
argument.");</p>
<p>}</p>
<p><strong>if</strong> (target <strong>instanceof</strong>
DeniedPermission || target <strong>instanceof</strong>
UnresolvedPermission) {</p>
<p><strong>throw new</strong> IllegalArgumentException("[target] must
not be a DeniedPermission or an</p>
<p>UnresolvedPermission.");</p>
<p>}</p>
<p>StringBuilder sb = <strong>new</strong></p>
<p>StringBuilder(target.getClass().getName()).append(":").append(target.getName());</p>
<p>String targetActions = target.getActions();</p>
<p><strong>if</strong> (targetActions != <strong>null</strong>) {</p>
<p>sb.append(":").append(targetActions);</p>
<p>}</p>
<p><strong>return new</strong> DeniedPermission(sb.toString(),
target);</p>
<p>}</p>
<p><strong>private</strong> DeniedPermission(String name, Permission
target) {</p>
<p><strong>super</strong>(name);</p>
<p><strong>this</strong>.target = target;</p>
<p>}</p>
<p><strong>private</strong> Permission initTarget(String
targetClassName, String targetName, String targetActions)</p>
<p>{</p>
<p>Class targetClass;</p>
<p>try <strong>{</strong></p>
<p>targetClass = <strong>Class</strong>.forName(targetClassName);</p>
<p>}</p>
<p><strong>catch</strong> (ClassNotFoundException cnfe) {</p>
<p><strong>if</strong> (targetClassName.trim().isEmpty()) {</p>
<p>targetClassName = "";</p>
<p>}</p>
<p><strong>throw new</strong> IllegalArgumentException(</p>
<p>MessageFormat.format("Target Permission class [{0}] not found.",</p>
<p>targetClassName));</p>
<p>}</p>
<p><strong>if</strong>
(!Permission.<strong>class</strong>.isAssignableFrom(targetClass) ||</p>
<p>Modifier.isAbstract(targetClass.getModifiers())) {</p>
<p><strong>throw new</strong> IllegalArgumentException(MessageFormat</p>
<p>.format("Target Permission class [{0}] is not a (concrete)
Permission.", targetClassName));</p>
<p>}</p>
<p><strong>if</strong> (targetClass ==
DeniedPermission.<strong>class</strong> || targetClass ==
UnresolvedPermission.<strong>class</strong>) {</p>
<p><strong>throw new</strong> IllegalArgumentException("Target
Permission class cannot be a</p>
<p>DeniedPermission itself.");</p>
<p>}</p>
<p>Constructor targetCtor;</p>
<p>try <strong>{</strong></p>
<p><strong>if</strong> (targetActions == <strong>null</strong>) {</p>
<p>targetCtor =
targetClass.getConstructor(String.<strong>class</strong>);</p>
<p>}</p>
<p>else <strong>{</strong></p>
<p>targetCtor =
targetClass.getConstructor(String.<strong>class</strong>,
String.<strong>class</strong>);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 799</p>
<p>}</p>
<p><strong>catch</strong> (NoSuchMethodException nsme) {</p>
<p><strong>throw new</strong>
IllegalArgumentException(MessageFormat.format(</p>
<p>"Target Permission class [{0}] does not provide or expose a (String
name) or</p>
<p>(String name, String actions) constructor.",</p>
<p>targetClassName));</p>
<p>}</p>
<p>try <strong>{</strong></p>
<p><strong>return</strong> (Permission) targetCtor</p>
<p>.newInstance(((targetCtor.getParameterCount() == 1) ?
<strong>new</strong> Object[] { targetName }</p>
<p>: <strong>new</strong> Object[] { targetName, targetActions }));</p>
<p>}</p>
<p><strong>catch</strong> (ReflectiveOperationException roe) {</p>
<p><strong>if</strong> (roe <strong>instanceof</strong>
InvocationTargetException) {</p>
<p><strong>if</strong> (targetName == <strong>null</strong>) {</p>
<p>targetName = "";</p>
<p>}</p>
<p><strong>else if</strong> (targetName.trim().isEmpty()) {</p>
<p>targetName = "";</p>
<p>}</p>
<p><strong>if</strong> (targetActions == <strong>null</strong>) {</p>
<p>targetActions = "";</p>
<p>}</p>
<p><strong>else if</strong> (targetActions.trim().isEmpty()) {</p>
<p>targetActions = "";</p>
<p>}</p>
<p><strong>throw new</strong>
IllegalArgumentException(MessageFormat.format(</p>
<p>"Could not instantiate target Permission class [{0}]; provided target
name</p>
<p>[{1}] and/or target actions [{2}] potentially erroneous.",</p>
<p>targetClassName, targetName, targetActions), roe);</p>
<p>}</p>
<p><strong>throw new</strong> RuntimeException(</p>
<p>"Could not instantiate target Permission class [{0}]; an unforeseen
error</p>
<p>occurred - see attached cause for details",</p>
<p>roe);</p>
<p>}</p>
<p>}</p>
<p>/**</p>
<p>* Checks whether the given permission is implied by this one, as per
the {@link DeniedPermission</p>
<p>* overview}.</p>
<p>*/</p>
<p>@Override</p>
<p><strong>public boolean</strong> implies(Permission p) {</p>
<p><strong>if</strong> (p <strong>instanceof</strong> DeniedPermission)
{</p>
<p><strong>return</strong> target.implies(((DeniedPermission)
p).target);</p>
<p>}</p>
<p><strong>return</strong> target.implies(p);</p>
<p>}</p>
<p>/**</p>
<p>* Returns this denied permission's target permission (the actual
positive permission which is not</p>
<p>* to be granted).</p>
<p>*/</p>
<p><strong>public</strong> Permission getTargetPermission() {</p>
<p><strong>return</strong> target;</p>
<p>}</p>
<p>}</p>
<p>The DenyingPolicy class</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 800</p>
<p><strong>package</strong> com.example;</p>
<p><strong>import</strong> java.security.CodeSource;</p>
<p><strong>import</strong> java.security.NoSuchAlgorithmException;</p>
<p><strong>import</strong> java.security.Permission;</p>
<p><strong>import</strong> java.security.PermissionCollection;</p>
<p><strong>import</strong> java.security.Policy;</p>
<p><strong>import</strong> java.security.ProtectionDomain;</p>
<p><strong>import</strong> java.security.UnresolvedPermission;</p>
<p><strong>import</strong> java.util.Enumeration;</p>
<p>/**</p>
<p>* Wrapper that adds rudimentary {@link DeniedPermission} processing
capabilities to the standard * file-backed
&lt;code&gt;Policy&lt;/code&gt;.</p>
<p>*/</p>
<p>public final class <strong>DenyingPolicy</strong> extends
<strong>Policy {</strong></p>
<p>{</p>
<p>try <strong>{</strong></p>
<p>defaultPolicy = Policy.getInstance("javaPolicy",
<strong>null</strong>);</p>
<p>}</p>
<p><strong>catch</strong> (NoSuchAlgorithmException nsae) {</p>
<p><strong>throw new</strong> RuntimeException("Could not acquire
default Policy.", nsae);</p>
<p>}</p>
<p>}</p>
<p><strong>private final</strong> Policy defaultPolicy;</p>
<p>@Override</p>
<p><strong>public</strong> PermissionCollection
getPermissions(CodeSource codesource) {</p>
<p><strong>return</strong> defaultPolicy.getPermissions(codesource);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public</strong> PermissionCollection
getPermissions(ProtectionDomain domain) {</p>
<p><strong>return</strong> defaultPolicy.getPermissions(domain);</p>
<p>}</p>
<p>/**</p>
<p>* @return</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;true&lt;/code&gt; if:&lt;/li&gt;</p>
<p>* &lt;ul&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;permission&lt;/code&gt; &lt;em&gt;is
not&lt;/em&gt; an instance of</p>
<p>* &lt;code&gt;DeniedPermission&lt;/code&gt;,&lt;/li&gt;</p>
<p>* &lt;li&gt;an &lt;code&gt;implies(domain, permission)&lt;/code&gt;
invocation on the system-default</p>
<p>* &lt;code&gt;Policy&lt;/code&gt; yields
&lt;code&gt;true&lt;/code&gt;, and&lt;/li&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;permission&lt;/code&gt; &lt;em&gt;is
not&lt;/em&gt; implied by any
&lt;code&gt;DeniedPermission&lt;/code&gt;s</p>
<p>* having potentially been assigned to
&lt;code&gt;domain&lt;/code&gt;.&lt;/li&gt;</p>
<p>* &lt;/ul&gt;</p>
<p>* &lt;li&gt;&lt;code&gt;false&lt;/code&gt;, otherwise.</p>
<p>* &lt;/ul&gt;</p>
<p>*/</p>
<p>@Override</p>
<p><strong>public boolean</strong> implies(ProtectionDomain domain,
Permission permission) {</p>
<p><strong>if</strong> (permission <strong>instanceof</strong>
DeniedPermission) {</p>
<p>/*</p>
<p>* At the policy decision level, DeniedPermissions can only themselves
imply, not be implied (as</p>
<p>* they take away, rather than grant, privileges). Furthermore,
clients aren't supposed to use this</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 801</p>
<p>* method for checking whether some domain _does not_ have a
permission (which is what</p>
<p>* DeniedPermissions express after all).</p>
<p>*/</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p><strong>if</strong> (!defaultPolicy.implies(domain, permission))
{</p>
<p>// permission not granted, so no need to check whether denied
<em><strong>return false</strong>;</em></p>
<p>}</p>
<p>/*</p>
<p>* Permission granted--now check whether there's an overriding
DeniedPermission. The following</p>
<p>* assumes that previousPolicy is a sun.security.provider.PolicyFile
(different implementations</p>
<p>* might not support #getPermissions(ProtectionDomain) and/or handle
UnresolvedPermissions</p>
<p>* differently).</p>
<p>*/</p>
<p>Enumeration perms =
defaultPolicy.getPermissions(domain).elements();</p>
<p><strong>while</strong> (perms.hasMoreElements()) {</p>
<p>Permission p = perms.nextElement();</p>
<p>/*</p>
<p>* DeniedPermissions will generally remain unresolved, as no code is
expected to check whether other</p>
<p>* code has been "granted" such a permission.</p>
<p>*/</p>
<p><strong>if</strong> (p <strong>instanceof</strong>
UnresolvedPermission) {</p>
<p>UnresolvedPermission up = (UnresolvedPermission) p;
<strong>if</strong>
(up.getUnresolvedType().equals(DeniedPermission.<strong>class</strong>.getName()))
{</p>
<p>// force resolution</p>
<p>defaultPolicy.implies(domain, up);</p>
<p>// evaluate right away, to avoid reiterating over the collection</p>
<p>p = <strong>new</strong>
DeniedPermission(up.getUnresolvedName());</p>
<p>}</p>
<p>}</p>
<p><strong>if</strong> (p <strong>instanceof</strong> DeniedPermission
&amp;&amp; p.implies(permission)) {</p>
<p>// permission denied</p>
<p>return false<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>// permission granted</p>
<p>return true<strong>;</strong></p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> refresh() {</p>
<p>defaultPolicy.refresh();</p>
<p>}</p>
<p>}</p>
<p>Demo</p>
<p><strong>package</strong> com.example;</p>
<p><strong>import</strong> java.security.Policy;</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String... args) {</p>
<p>Policy.setPolicy(<strong>new</strong> DenyingPolicy());</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 802</p>
<p>System.setSecurityManager(<strong>new</strong>
SecurityManager());</p>
<p>// should fail</p>
<p>System.getProperty("foo.bar");</p>
<p>}</p>
<p>}</p>
<p>Assign some permissions:</p>
<p>grant codeBase "file:///path/to/classes/bin/-"</p>
<p>permission java.util.PropertyPermission "*", "read,write";</p>
<p>permission com.example.DeniedPermission
"java.util.PropertyPermission:foo.bar:read"; };</p>
<p>Lastly, run the Main and watch it fail, due to the "deny" rule (the
DeniedPermission) overriding the grant (its</p>
<p>PropertyPermission ). Note that a setProperty("foo.baz", "xyz")
invocation would instead have succeeded,</p>
<p>since the denied permission only covers the "read" action, and solely
for the "foo.bar" property.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 803</p>
<p><span id="Chapter_145__JNDI_1" class="anchor"></span>Chapter 145:
JNDI</p>
<p>Section 145.1: RMI through JNDI</p>
<p>This example shows how JNDI works in RMI. It has two roles:</p>
<p>to provide the server with a bind/unbind/rebind API to the RMI
Registry</p>
<p>to provide the client with a lookup/list API to the RMI Registry.</p>
<p>The RMI Registry is part of RMI, not JNDI.</p>
<p>To make this simple, we will use java.rmi.registry.CreateRegistry()
to create the RMI Registry.</p>
<p>1. Server.java(the JNDI server)</p>
<p><strong>package</strong> com.neohope.jndi.test;</p>
<p><strong>import</strong> javax.naming.Context;</p>
<p><strong>import</strong> javax.naming.InitialContext;</p>
<p><strong>import</strong> javax.naming.NamingException;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.rmi.RemoteException;</p>
<p><strong>import</strong> java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong> java.util.Hashtable;</p>
<p>/**</p>
<p>* JNDI Server</p>
<p>* 1.create a registry on port 1234</p>
<p>* 2.bind JNDI</p>
<p>* 3.wait for connection</p>
<p>* 4.clean up and end</p>
<p>*/</p>
<p>public class <strong>Server {</strong></p>
<p><strong>private static</strong> Registry registry;</p>
<p><strong>private static</strong> InitialContext ctx;</p>
<p>public static void <strong>initJNDI() {</strong></p>
<p>try <strong>{</strong></p>
<p>registry = LocateRegistry.createRegistry(1234);</p>
<p><strong>final</strong> Hashtable jndiProperties =
<strong>new</strong> Hashtable();</p>
<p>jndiProperties.put(Context.INITIAL_CONTEXT_FACTORY,</p>
<p>"com.sun.jndi.rmi.registry.RegistryContextFactory");</p>
<p>jndiProperties.put(Context.PROVIDER_URL, "rmi://localhost:1234");</p>
<p>ctx = <strong>new</strong> InitialContext(jndiProperties);</p>
<p>} <strong>catch</strong> (NamingException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (RemoteException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> bindJNDI(String name, Object obj)
<strong>throws</strong> NamingException { ctx.bind(name, obj);</p>
<p>}</p>
<p><strong>public static void</strong> unbindJNDI(String name)
<strong>throws</strong> NamingException { ctx.unbind(name);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 804</p>
<p><strong>public static void</strong> unInitJNDI()
<strong>throws</strong> NamingException { ctx.close();</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> NamingException, IOException { initJNDI();</p>
<p>NMessage msg = <strong>new</strong> NMessage("Just A Message");</p>
<p>bindJNDI("/neohope/jndi/test01", msg);</p>
<p>System.in.read();</p>
<p>unbindJNDI("/neohope/jndi/test01");</p>
<p>unInitJNDI();</p>
<p>}</p>
<p>}</p>
<p>2. Client.java(the JNDI client)</p>
<p><strong>package</strong> com.neohope.jndi.test;</p>
<p><strong>import</strong> javax.naming.Context;</p>
<p><strong>import</strong> javax.naming.InitialContext;</p>
<p><strong>import</strong> javax.naming.NamingException;</p>
<p><strong>import</strong> java.util.Hashtable;</p>
<p>/**</p>
<p>* 1.init context</p>
<p>* 2.lookup registry for the service</p>
<p>* 3.use the service</p>
<p>* 4.end</p>
<p>*/</p>
<p>public class <strong>Client {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> NamingException {</p>
<p><strong>final</strong> Hashtable jndiProperties =
<strong>new</strong> Hashtable();</p>
<p>jndiProperties.put(Context.INITIAL_CONTEXT_FACTORY,</p>
<p>"com.sun.jndi.rmi.registry.RegistryContextFactory");</p>
<p>jndiProperties.put(Context.PROVIDER_URL, "rmi://localhost:1234");</p>
<p>InitialContext ctx = <strong>new</strong>
InitialContext(jndiProperties);</p>
<p>NMessage msg = (NeoMessage) ctx.lookup("/neohope/jndi/test01");</p>
<p>System.out.println(msg.message);</p>
<p>ctx.close();</p>
<p>}</p>
<p>}</p>
<p>3. NMessage.java (RMI server class)</p>
<p><strong>package</strong> com.neohope.jndi.test;</p>
<p><strong>import</strong> java.io.Serializable;</p>
<p><strong>import</strong> java.rmi.Remote;</p>
<p>/**</p>
<p>* NMessage</p>
<p>* RMI server class</p>
<p>* must implements Remote and Serializable</p>
<p>*/</p>
<p><strong>public class</strong> NMessage <strong>implements</strong>
Remote, Serializable {</p>
<p><strong>public</strong> String message = "";</p>
<p><strong>public</strong> NMessage(String message)</p>
<p>{</p>
<p><strong>this</strong>.message = message;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 805</p>
<p>}</p>
<p>}</p>
<p>How to run the eaxmple:</p>
<p>1. build and start the server</p>
<p>2. build and start the client</p>
<p>Introduce</p>
<p><img src="media/index-830_1.jpeg"
style="width:6.45833in;height:4.02778in" alt="index-830_1.jpg" /></p>
<p>The <strong>Java Naming and Directory Interface (JNDI)</strong> is a
Java API for a directory service that allows Java software</p>
<p>clients to discover and look up data and objects via a name. It is
designed to be independent of any specific naming</p>
<p>or directory service implementation.</p>
<p>The JNDI architecture consists of an <strong>API</strong>
(Application Programming Interface) and an <strong>SPI</strong> (Service
Provider</p>
<p>Interface). Java applications use this API to access a variety of
naming and directory services. The SPI enables a</p>
<p>variety of naming and directory services to be plugged in
transparently, allowing the Java application using the API of the JNDI
technology to access their services.</p>
<p>As you can see form the picture above, JNDI supports LDAP, DNS, NIS,
NDS, RMI and CORBA. Of course, you can extend it.</p>
<p>How it works</p>
<p>In this example, the Java RMI use the JNDI API to look up objects in
a network. If you want to look up a object, you need at least two pieces
of information:</p>
<p>Where to find the object</p>
<p>The RMI Registry manages the name bindings, it tells you where to
find the object.</p>
<p>The name of the object</p>
<p>What is a object's name? It is usually a string, it can also be a
object that implements the Name interface.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 806</p>
<p>Step by step</p>
<p>1. First you need a registry, which manage the name binding. In this
example, we use</p>
<p>java.rmi.registry.LocateRegistry .</p>
<p>//This will start a registry on localhost, port 1234 <em>registry =
LocateRegistry.createRegistry(1234);</em></p>
<p>2. Both client and server need a Context. Server use the Context to
bind the name and object. Client use the</p>
<p>Context to lookup the name and get the object.</p>
<p>//We use com.sun.jndi.rmi.registry.RegistryContextFactory as the
InitialContextFactory <em><strong>final</strong> Hashtable
jndiProperties = <strong>new</strong> Hashtable();</em></p>
<p>jndiProperties.put(Context.INITIAL_CONTEXT_FACTORY,
"com.sun.jndi.rmi.registry.RegistryContextFactory"); <em>//the registry
usrl is "rmi://localhost:1234"</em></p>
<p>jndiProperties.put(Context.PROVIDER_URL, "rmi://localhost:1234");
InitialContext ctx = <strong>new</strong>
InitialContext(jndiProperties);</p>
<p>3. The server bind the name and object</p>
<p>//The jndi name is "/neohope/jndi/test01"</p>
<p>bindJNDI("/neohope/jndi/test01", msg);</p>
<p>4. The client look up the object by the name
"/neohope/jndi/test01"</p>
<p><em>//look up the object by name "java:com/neohope/jndi/test01"</em>
NeoMessage msg = (NeoMessage) ctx.lookup("/neohope/jndi/test01");</p>
<p>5. Now the client can use the object</p>
<p>6. When the server is ending, need to clean up.</p>
<p>ctx.unbind("/neohope/jndi/test01");</p>
<p>ctx.close();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 807</p>
<p><span id="Chapter_146__sun_misc_Unsafe_1"
class="anchor"></span>Chapter 146: sun.misc.Unsafe</p>
<p>Section 146.1: Instantiating sun.misc.Unsafe via reflection</p>
<p><strong>public static</strong> Unsafe getUnsafe() {</p>
<p>try <strong>{</strong></p>
<p>Field unsafe =
Unsafe.<strong>class</strong>.getDeclaredField("theUnsafe");</p>
<p>unsafe.setAccessible(<strong>true</strong>);</p>
<p><strong>return</strong> (Unsafe)
unsafe.get(<strong>null</strong>);</p>
<p>} <strong>catch</strong> (IllegalAccessException e) {</p>
<p>// Handle</p>
<p>} <strong>catch</strong> (IllegalArgumentException e) {</p>
<p>// Handle</p>
<p>} <strong>catch</strong> (NoSuchFieldException e) {</p>
<p>// Handle</p>
<p>} <strong>catch</strong> (SecurityException e) {</p>
<p>// Handle</p>
<p>}</p>
<p>}</p>
<p>sun.misc.Unsafe has a Private constructor, and the static getUnsafe()
method is guarded with a check of the classloader to ensure that the
code was loaded with the primary classloader. Therefore, one method of
loading the</p>
<p>instance is to use reflection to get the static field.</p>
<p>Section 146.2: Instantiating sun.misc.Unsafe via bootclasspath</p>
<p><strong>public class</strong> UnsafeLoader {</p>
<p><strong>public static</strong> Unsafe loadUnsafe() {</p>
<p><strong>return</strong> Unsafe.getUnsafe();</p>
<p>}</p>
<p>}</p>
<p>While this example will compile, it is likely to fail at runtime
unless the Unsafe class was loaded with the primary classloader. To
ensure that happens the JVM should be loaded with the appropriate
arguments, like:</p>
<p>java -Xbootclasspath:$JAVA_HOME/jre/lib/rt.jar:./UnsafeLoader.jar
foo.bar.MyApp</p>
<p>The foo.bar.MyApp class can then use UnsafeLoader.loadUnsafe().</p>
<p>Section 146.3: Getting Instance of Unsafe</p>
<p>Unsafe is stored as a private field that cannot be accessed directly.
The constructor is private and the only method</p>
<p>to access <strong>public static</strong> Unsafe getUnsafe() has
privileged access. By use of reflection, there is a work-around to</p>
<p>make private fields accessible:</p>
<p>public static final <strong>Unsafe UNSAFE;</strong></p>
<p>static <strong>{</strong></p>
<p>Unsafe unsafe = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p><strong>final</strong> PrivilegedExceptionAction action = ()-&gt;
{</p>
<p><strong>final</strong> Field f =
Unsafe.<strong>class</strong>.getDeclaredField("theUnsafe");</p>
<p>f.setAccessible(<strong>true</strong>);</p>
<p><strong>return</strong> (Unsafe) f.get(<strong>null</strong>);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 808</p>
<p><span id="_57" class="anchor"></span>};</p>
<p>unsafe = AccessController.doPrivileged(action);</p>
<p>} <strong>catch</strong> (<strong>final</strong> Throwable t) {</p>
<p><strong>throw new</strong> RuntimeException("Exception accessing
Unsafe", t);</p>
<p>}</p>
<p>UNSAFE = unsafe;</p>
<p>}</p>
<p>Section 146.4: Uses of Unsafe</p>
<p>Some uses of unsafe is s follows:</p>
<p>Use API</p>
<p>Off heap / direct memory allocation, allocateMemory(bytes),
reallocateMemory(address, bytes) and reallocation and deallocation
freeMemory(address)</p>
<p>Memory fences loadFence(), storeFence(), fullFence()</p>
<p>Parking current thread park(isAbsolute, time), unpark(thread)</p>
<p>Direct field and or memory access get* and put* family of methods</p>
<p>Throwing unchecked exceptions throwException(e)</p>
<p>CAS and Atomic Operations compareAndSwap* family of methods</p>
<p>Setting out memory setMemory</p>
<p>Volatile or concurrent operations get*<strong>Volatile</strong>,
put*<strong>Volatile</strong>, putOrdered*</p>
<p>The get and put family of methods are relative to a given object. If
the object is null then it is treated as an absolute address.</p>
<p>// Putting a value to a field</p>
<p><strong>protected static long</strong> fieldOffset =
UNSAFE.objectFieldOffset(getClass().getField("theField"));
UNSAFE.putLong(<strong>this</strong>, fieldOffset , newValue);</p>
<p>// Puting an absolute value</p>
<p>UNSAFE.putLong(<strong>null</strong>, address, newValue);</p>
<p>UNSAFE.putLong(address, newValue);</p>
<p>Some methods are only defined for int and longs. You can use these
methods on floats and doubles using floatToRawIntBits ,
intBitsToFloat,doubleToRawLongBits,longBitsToDouble`</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 809</p>
<p><span id="Chapter_147__Java_Memory_Model_1"
class="anchor"></span>Chapter 147: Java Memory Model</p>
<p>Section 147.1: Motivation for the Memory Model</p>
<p>Consider the following example:</p>
<p>public class <strong>Example {</strong></p>
<p><strong>public int</strong> a, b, c, d;</p>
<p>public void <strong>doIt() {</strong></p>
<p>a = b + 1;</p>
<p>c = d + 1;</p>
<p>}</p>
<p>}</p>
<p>If this class is used is a single-threaded application, then the
observable behavior will be exactly as you would expect. For
instance:</p>
<p><strong>public class</strong> SingleThreaded {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>Example eg = <strong>new</strong> Example();</p>
<p>System.out.println(eg.a + ", " + eg.c);</p>
<p>eg.doIt();</p>
<p>System.out.println(eg.a + ", " + eg.c);</p>
<p>}</p>
<p>}</p>
<p>will output:</p>
<p>0, 0</p>
<p>1, 1</p>
<p><em>As far as the "main" thread can tell</em>, the statements in the
main() method and the doIt() method will be executed in</p>
<p>the order that they are written in the source code. This is a clear
requirement of the Java Language Specification (JLS).</p>
<p>Now consider the same class used in a multi-threaded application.</p>
<p><strong>public class</strong> MultiThreaded {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>final</strong> Example eg = <strong>new</strong>
Example();</p>
<p><strong>new</strong> Thread(<strong>new</strong> Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>eg.doIt();</p>
<p>}</p>
<p>}</p>
<p>}).start();</p>
<p>while <strong>(</strong>true<strong>) {</strong></p>
<p>System.out.println(eg.a + ", " + eg.c);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>What will this print?</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 810</p>
<p>In fact, according to the JLS it is not possible to predict that this
will print:</p>
<p>You will probably see a few lines of 0, 0 to start with.</p>
<p>Then you probably see lines like N, N or N, N + 1.</p>
<p>You might see lines like N + 1, N.</p>
<p>In theory, you might even see that the 0, 0 lines continue
forever1.</p>
<p>1 - In practice the presence of the println statements is liable to
cause some serendipitous synchronization and</p>
<p>memory cache flushing. That is likely to hide some of the effects
that would cause the above behavior.</p>
<p>So how can we explain these?</p>
<p>Reordering of assignments</p>
<p>One possible explanation for unexpected results is that the JIT
compiler has changed the order of the assignments in the doIt() method.
The JLS requires that statements <em>appear to</em> execute in order
<em>from the perspective of the current</em></p>
<p>thread. In this case, nothing in the code of the doIt() method can
observe the effect of a (hypothetical) reordering of those two
statement. This means that the JIT compiler would be permitted to do
that.</p>
<p>Why would it do that?</p>
<p>On typical modern hardware, machine instructions are executed using a
instruction pipeline which allows a</p>
<p>sequence of instructions to be in different stages. Some phases of
instruction execution take longer than others, and memory operations
tend to take a longer time. A smart compiler can optimize the
instruction throughput of</p>
<p>the pipeline by ordering the instructions to maximize the amount of
overlap. This may lead to executing parts of statements out of order.
The JLS permits this provided that not affect the result of the
computation <em>from the</em></p>
<p>perspective of the current thread<em>.</em></p>
<p>Effects of memory caches</p>
<p>A second possible explanation is effect of memory caching. In a
classical computer architecture, each processor has</p>
<p>a small set of registers, and a larger amount of memory. Access to
registers is much faster than access to main memory. In modern
architectures, there are memory caches that are slower than registers,
but faster than main</p>
<p>memory.</p>
<p>A compiler will exploit this by trying to keep copies of variables in
registers, or in the memory caches. If a variable</p>
<p>does not <em>need</em> to be flushed to main memory, or does not
<em>need</em> to be read from memory, there are significant performance
benefits in not doing this. In cases where the JLS does not require
memory operations to be visible to</p>
<p>another thread, the Java JIT compiler is likely to not add the "read
barrier" and "write barrier" instructions that will force main memory
reads and writes. Once again, the performance benefits of doing this are
significant.</p>
<p>Proper synchronization</p>
<p>So far, we have seen that the JLS allows the JIT compiler to generate
code that makes single-threaded code faster by reordering or avoiding
memory operations. But what happens when other threads can observe the
state of the</p>
<p>(shared) variables in main memory?</p>
<p>The answer is, that the other threads are liable to observe variable
states which would appear to be impossible ...</p>
<p>based on the code order of the Java statements. The solution to this
is to use appropriate synchronization. The three main approaches
are:</p>
<p>Using primitive mutexes and the <strong>synchronized</strong>
constructs. Using <strong>volatile</strong> variables.</p>
<p>Using higher level concurrency support; e.g. classes in the
java.util.concurrent packages.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 811</p>
<p><span id="But_even_with_this__it_is_import" class="anchor"></span>But
even with this, it is important to understand where synchronization is
needed, and what effects that you can rely on. This is where the Java
Memory Model comes in.</p>
<p>The Memory Model</p>
<p>The Java Memory Model is the section of the JLS that specifies the
conditions under which one thread is guaranteed to see the effects of
memory writes made by another thread. The Memory Model is specified with
a fair degree of</p>
<p><em>formal rigor</em>, and (as a result) requires detailed and
careful reading to understand. But the basic principle is that</p>
<p>certain constructs create a "happens-before" relation between write
of a variable by one thread, and a subsequent read of the same variable
by another thread. If the "happens before" relation exists, the JIT
compiler is <em>obliged</em> to</p>
<p>generate code that will ensure that the read operation sees the value
written by the write.</p>
<p>Armed with this, it is possible to reason about memory coherency in a
Java program, and decide whether this will</p>
<p>be predictable and consistent for <em>all</em> execution
platforms.</p>
<p>Section 147.2: Happens-before relationships</p>
<p>(The following is a simplified version of what the Java Language
Specification says. For a deeper understanding, you need to read the
specification itself.)</p>
<p>Happens-before relationships are the part of the Memory Model that
allow us to understand and reason about</p>
<p>memory visibility. As the JLS says (<a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5">JLS
17.4.5</a>):</p>
<p>"Two <em>actions</em> can be ordered by a <em>happens-before</em>
relationship. If one action <em>happens-before</em> another, then the
first is visible to and ordered before the second."</p>
<p>What does this mean?</p>
<p>Actions</p>
<p>The actions that the above quote refers to are specified in <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.2">JLS
17.4.2</a>. There are 5 kinds of action listed defined by the spec:</p>
<p>Read: Reading a non-volatile variable.</p>
<p>Write: Writing a non-volatile variable.</p>
<p>Synchronization actions:</p>
<p>Volatile read: Reading a volatile variable.</p>
<p>Volatile write: Writing a volatile variable.</p>
<p>Lock. Locking a monitor</p>
<p>Unlock. Unlocking a monitor.</p>
<p>The (synthetic) first and last actions of a thread.</p>
<p>Actions that start a thread or detect that a thread has
terminated.</p>
<p>External Actions. An action that has a result that depends on the
environment in which the program.</p>
<p>Thread divergence actions. These model the behavior of certain kinds
of infinite loop.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 812</p>
<p><span id="Program_Order_and_Synchronizatio"
class="anchor"></span>Program Order and Synchronization Order</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.3">These
two orderings ( JLS 17.4.3 and</a> <a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.4">JLS
17.4.4</a> ) govern the execution of statements in a Java</p>
<p>Program order describes the order of statement execution within a
single thread.</p>
<p>Synchronization order describes the order of statement execution for
two statements connected by a synchronization:</p>
<p>An unlock action on monitor <em>synchronizes-with</em> all subsequent
lock actions on that monitor.</p>
<p>A write to a volatile variable <em>synchronizes-with</em> all
subsequent reads of the same variable by any thread.</p>
<p>An action that starts a thread (i.e. the call to Thread.start())
<em>synchronizes-with</em> the first action in the thread it</p>
<p>starts (i.e. the call to the thread's run() method).</p>
<p>The default initialization of fields <em>synchronizes-with</em> the
first action in every thread. (See the JLS for an explanation of
this.)</p>
<p>The final action in a thread <em>synchronizes-with</em> any action in
another thread that detects the termination; e.g. the return of a join()
call or isTerminated() call that returns <strong>true</strong>.</p>
<p>If one thread interrupts another thread, the interrupt call in the
first thread <em>synchronizes-with</em> the point where</p>
<p>another thread detects that the thread was interrupted.</p>
<p>Happens-before Order</p>
<p><a
href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5">This
ordering ( JLS 17.4.5</a> ) is what determines whether a memory write is
guaranteed to be visible to a subsequent</p>
<p>memory read.</p>
<p>More specifically, a read of a variable v is guaranteed to observe a
write to v if and only if write(v) <em>happens-before</em></p>
<p>read(v) AND there is no intervening write to v. If there are
intervening writes, then the read(v) may see the results of them rather
than the earlier one.</p>
<p>The rules that define the <em>happens-before</em> ordering are as
follows:</p>
<p><strong>Happens-Before Rule #1</strong> - If x and y are actions of
the same thread and x comes before y in <em>program order</em>,</p>
<p><em>then x</em> happens-before <em>y.</em></p>
<p><strong>Happens-Before Rule #2</strong> - There is a happens-before
edge from the end of a constructor of an object to the</p>
<p>start of a finalizer for that object.</p>
<p><strong>Happens-Before Rule #3</strong> - If an action x
<em>synchronizes-with</em> a subsequent action y, then x
<em>happens-before</em> y.</p>
<p><em><strong>Happens-Before Rule #4</strong> - If x</em>
happens-before <em>y and y</em> happens-before <em>z then x</em>
happens-before <em>z.</em></p>
<p>In addition, various classes in the Java standard libraries are
specified as defining <em>happens-before</em> relationships. You</p>
<p>can interpret this as meaning that it happens <em>somehow</em>,
without needing to know exactly how the guarantee is going to be
met.</p>
<p>Section 147.3: How to avoid needing to understand the</p>
<p>Memory Model</p>
<p>The Memory Model is difficult to understand, and difficult to apply.
It is useful if you need to reason about the correctness of
multi-threaded code, but you do not want to have to do this reasoning
for every multi-threaded</p>
<p>application that you write.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 813</p>
<p><span id="If_you_adopt_the_following_princ" class="anchor"></span>If
you adopt the following principals when writing concurrent code in Java,
you can <em>largely</em> avoid the need to resort to
<em>happens-before</em> reasoning.</p>
<p>Use immutable data structures where possible. A properly implemented
immutable class will be thread-safe, and will not introduce
thread-safety issues when you use it with other classes.</p>
<p>Understand and avoid "unsafe publication".</p>
<p>Use primitive mutexes or Lock objects to synchronize access to state
in mutable objects that need to be</p>
<p>thread-safe1.</p>
<p>Use Executor / ExecutorService or the fork join framework rather than
attempting to create manage</p>
<p>threads directly.</p>
<p>Use the `java.util.concurrent classes that provide advanced locks,
semaphores, latches and barriers, instead of using wait/notify/notifyAll
directly.</p>
<p>Use the java.util.concurrent versions of maps, sets, lists, queues
and deques rather than external</p>
<p>synchonization of non-concurrent collections.</p>
<p>The general principle is to try to use Java's built-in concurrency
libraries rather than "rolling your own" concurrency.</p>
<p>You can rely on them working, if you use them properly.</p>
<p>1 - Not all objects need to be thread safe. For example, if an object
or objects is <em>thread-confined</em> (i.e. it is only</p>
<p>accessible to one thread), then its thread-safety is not
relevant.</p>
<p>Section 147.4: Happens-before reasoning applied to some</p>
<p>examples</p>
<p>We will present some examples to show how to apply
<em>happens-before</em> reasoning to check that writes are visible
to</p>
<p>subsequent reads.</p>
<p>Single-threaded code</p>
<p>As you would expect, writes are always visible to subsequent reads in
a single-threaded program.</p>
<p><strong>public class</strong> SingleThreadExample {</p>
<p>public int <strong>a, b;</strong></p>
<p>public int <strong>add() {</strong></p>
<p><em>a = 1;</em> // write(a)</p>
<p><em>b = 2;</em> // write(b)</p>
<p><em><strong>return</strong> a + b;</em> // read(a) followed by
read(b)</p>
<p>}</p>
<p>}</p>
<p>By Happens-Before Rule #1:</p>
<p>1. The write(a) action <em>happens-before</em> the write(b)
action.</p>
<p>2. The write(b) action <em>happens-before</em> the read(a)
action.</p>
<p>3. The read(a) action <em>happens-before</em> the read(a) action.</p>
<p>By Happens-Before Rule #4:</p>
<p>4. write(a) <em>happens-before</em> write(b) AND write(b)
<em>happens-before</em> read(a) IMPLIES write(a)
<em>happens-before</em></p>
<p>read(a).</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 814</p>
<p>5. write(b) <em>happens-before</em> read(a) AND read(a)
<em>happens-before</em> read(b) IMPLIES write(b)
<em>happens-before</em></p>
<p>read(b).</p>
<p>Summing up:</p>
<p>6. The write(a) <em>happens-before</em> read(a) relation means that
the a + b statement is guaranteed to see the</p>
<p>correct value of a.</p>
<p>7. The write(b) <em>happens-before</em> read(b) relation means that
the a + b statement is guaranteed to see the</p>
<p>correct value of b.</p>
<p>Behavior of 'volatile' in an example with 2 threads</p>
<p>We will use the following example code to explore some implications
of the Memory Model for `volatile.</p>
<p><strong>public class</strong> VolatileExample {</p>
<p>private volatile int <strong>a;</strong></p>
<p><em><strong>private int</strong> b;</em> // NOT volatile</p>
<p><strong>public void</strong> update(<strong>int</strong> first,
<strong>int</strong> second) {</p>
<p>b = first; <em>// write(b)</em></p>
<p><em>a = second;</em> // write-volatile(a)</p>
<p>}</p>
<p><strong>public int</strong> observe() {</p>
<p><em><strong>return</strong> a + b;</em> // read-volatile(a) followed
by read(b)</p>
<p>}</p>
<p>}</p>
<p>First, consider the following sequence of statements involving 2
threads:</p>
<p>1. A single instance of VolatileExample is created; call it ve, 2.
ve.update(1, 2) is called in one thread, and</p>
<p>3. ve.observe() is called in another thread.</p>
<p>By Happens-Before Rule #1:</p>
<p>1. The write(a) action <em>happens-before</em> the volatile-write(a)
action. 2. The volatile-read(a) action <em>happens-before</em> the
read(b) action.</p>
<p>By Happens-Before Rule #2:</p>
<p>3. The volatile-write(a) action in the first thread
<em>happens-before</em> the volatile-read(a) action in the second</p>
<p>thread.</p>
<p>By Happens-Before Rule #4:</p>
<p>4. The write(b) action in the first thread <em>happens-before</em>
the read(b) action in the second thread.</p>
<p>In other words, for this particular sequence, we are guaranteed that
the 2nd thread will see the update to the non-</p>
<p>volatile variable b made by the first thread. However, it is should
also be clear that if the assignments in the update</p>
<p>method were the other way around, or the observe() method read the
variable b before a, then the <em>happens-before</em> chain would be
broken. The chain would also be broken if volatile-read(a) in the second
thread was not</p>
<p>subsequent to the volatile-write(a) in the first thread.</p>
<p>When the chain is broken, there is no <em>guarantee</em> that
observe() will see the correct value of b.</p>
<p>Volatile with three threads</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 815</p>
<p>Suppose we to add a third thread into the previous example:</p>
<p>1. A single instance of VolatileExample is created; call it ve,</p>
<p>2. Two threads call update:</p>
<p>ve.update(1, 2) is called in one thread,</p>
<p>ve.update(3, 4) is called in the second thread,</p>
<p>3. ve.observe() is subsequently called in a third thread.</p>
<p>To analyse this completely, we need to consider all of the possible
interleavings of the statements in thread one and thread two. Instead,
we will consider just two of them.</p>
<p>Scenario #1 - suppose that update(1, 2) precedes update(3,4) we get
this sequence:</p>
<p>write(b, 1), write-<strong>volatile</strong>(a, 2) <em>// first
thread</em></p>
<p>write(b, 3), write-<strong>volatile</strong>(a, 4) <em>// second
thread</em></p>
<p>read-<strong>volatile</strong>(a), read(b) <em>// third
thread</em></p>
<p>In this case, it is easy to see that there is an unbroken
<em>happens-before</em> chain from write(b, 3) to read(b). Furthermore
there is no intervening write to b. So, for this scenario, the third
thread is guaranteed to see b as</p>
<p>having value 3.</p>
<p>Scenario #2 - suppose that update(1, 2) and update(3,4) overlap and
the ations are interleaved as follows:</p>
<p><em>write(b, 3)</em> // second thread</p>
<p><em>write(b, 1)</em> // first thread</p>
<p><em>write-<strong>volatile</strong>(a, 2)</em> // first thread</p>
<p><em>write-<strong>volatile</strong>(a, 4)</em> // second thread</p>
<p>read-<strong>volatile</strong>(a), read(b) <em>// third
thread</em></p>
<p>Now, while there is a <em>happens-before</em> chain from write(b, 3)
to read(b), there is an intervening write(b, 1) action performed by the
other thread. This means we cannot be certain which value read(b) will
see.</p>
<p>(Aside: This demonstrates that we cannot rely on
<strong>volatile</strong> for ensuring visibility of non-volatile
variables, except in very limited situations.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 816</p>
<p><span id="Chapter_148__Java_deployment_1"
class="anchor"></span>Chapter 148: Java deployment</p>
<p>There are a variety of technologies for "packaging" Java
applications, webapps and so forth, for deployment to the</p>
<p>platform on which they will run. They range from simple library or
executable JAR files, WAR and EAR files, through to installers and
self-contained executables.</p>
<p>Section 148.1: Making an executable JAR from the command</p>
<p>line</p>
<p>To make a jar, you need one or more class files. This should have a
main method if it is to be run by a double click.</p>
<p>For this example, we will use:</p>
<p><strong>import</strong> javax.swing.*;</p>
<p><strong>import</strong> java.awt.Container;</p>
<p><strong>public class</strong> HelloWorld {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>JFrame f = <strong>new</strong> JFrame("Hello, World");</p>
<p>JLabel label = <strong>new</strong> JLabel("Hello, World");</p>
<p>Container cont = f.getContentPane();</p>
<p>cont.add(label);</p>
<p>f.setSize(400,100);</p>
<p>f.setVisible(<strong>true</strong>);</p>
<p>f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</p>
<p>}</p>
<p>}</p>
<p>It has been named HelloWorld.java</p>
<p>Next, we want to compile this program.</p>
<p>You may use any program you want to do this. To run from the command
line, see the documentation on compiling and running your first java
program.</p>
<p>Once you have HelloWorld.class, make a new folder and call it
whatever you want.</p>
<p>Make another file called manifest.txt and paste into it</p>
<p>Main-<strong>Class</strong>: HelloWorld</p>
<p>Class-Path: HelloWorld.jar</p>
<p>Put it in the same folder with HelloWorld.class</p>
<p>Use the command line to make your current directory
(<strong>cd</strong> C:\Your\Folder\Path\Here on windows) your
folder.</p>
<p>Use Terminal and change directory to the directory (<strong>cd
/</strong>Users<strong>/</strong>user<strong>/</strong>Documents<strong>/</strong>Java<strong>/</strong>jarfolder
on Mac) your</p>
<p>folder</p>
<p>When that is done, type in jar -cvfm HelloWorld.jar manifest.txt
HelloWorld.<strong>class</strong> and press enter. This</p>
<p>makes a jar file (in the folder with your manifest and
HelloWorld.class) using the .class files specified and named
HelloWorld.jar. See the Syntax section for information about the options
(like -m and -v).</p>
<p>After these steps, go to your directory with the manifest file and
you should find HelloWorld.jar</p>
<p>Clicking on it should display Hello, World in a text box.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 817</p>
<p><span id="Section_148_2__Creating_an_UberJ"
class="anchor"></span>Section 148.2: Creating an UberJAR for an
application and its</p>
<p>dependencies</p>
<p>A common requirement for a Java application is that can be deployed
by copying a single file. For simple applications that depend only on
the standard Java SE class libraries, this requirement is satisfied by
creating a JAR</p>
<p>file containing all of the (compiled) application classes.</p>
<p>Things are not so straightforward if the application depends on
third-party libraries. If you simply put dependency</p>
<p>JAR files inside an application JAR, the standard Java class loader
will not be able to find the library classes, and your application will
not start. Instead, you need to create a single JAR file that contains
the application classes and</p>
<p>associated resources together with the dependency classes and
resources. These need to be organized as a single namespace for the
classloader to search.</p>
<p>The such a JAR file is often referred to as an UberJAR.</p>
<p>Creating an UberJAR using the "jar" command</p>
<p>The procedure for creating an UberJAR is straight-forward. (I will
use Linux commands for simplicity. The commands</p>
<p>should be identical for Mac OS, and similar for Windows.)</p>
<p>1. Create a temporary directory, and change directory to it.</p>
<p>$ <strong>mkdir</strong> tempDir</p>
<p>$ <strong>cd</strong> tempDir</p>
<p>2. For each dependent JAR file, <em>in the reverse order</em> that
they need to appear on the application's classpath, used</p>
<p>the jar command to unpack the JAR into the temporary directory.</p>
<p>$ jar -xf</p>
<p>Doing this for multiple JAR files will <em>overlay</em> contents of
the JARs.</p>
<p>3. Copy the application classes from the build tree into the
temporary directory</p>
<p>$ cp -r path/to/classes .</p>
<p>4. Create the UberJAR from the contents of the temporary
directory:</p>
<p>$ jar -cf ../myApplication.jar</p>
<p>If you are creating an executable JAR file, include an appropriate
MANIFEST.MF as described here.</p>
<p>Creating an UberJAR using Maven</p>
<p>If your project is built using Maven, you can get it to create an
UberJAR using either the "maven-assembly" or "maven-shade" plugins. See
the Maven Assembly topic (in the Maven documentation) for details.</p>
<p>The advantages and drawbacks of UberJARs</p>
<p>Some of advantages of UberJARs are self-evident:</p>
<p>An UberJAR is easy to distribute.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 818</p>
<p><span id="You_cannot_break_the_library_dep" class="anchor"></span>You
cannot break the library dependencies for an UberJAR, since the
libraries are self-contained.</p>
<p>In addition, if you use an appropriate tooling to create the UberJAR,
you will have the option of excluding library</p>
<p>classes that are not used from the JAR file. However, that this is
typically done by static analysis of the classes. If your application
uses reflection, annotation processing and similar techniques, you need
to be careful that classes</p>
<p>are not excluded incorrectly.</p>
<p>UberJARs also have some disadvantages:</p>
<p>If you have lots of UberJARs with the same dependencies, then each
one will contain a copy of the dependencies.</p>
<p>Some open source libraries have licenses which <em>may</em> preclude
1 their use in an UberJAR.</p>
<p>1 - Some open source library licenses allow you to use the library
only of the end-user is able to replace one version</p>
<p>of the library with another. UberJARs can make replacement of version
dependencies difficult.</p>
<p>Section 148.3: Creating JAR, WAR and EAR files</p>
<p>The JAR, WAR and EAR files types are fundamentally ZIP files with a
"manifest" file and (for WAR and EAR files) a</p>
<p>particular internal directory / file structure.</p>
<p>The recommended way to create these files is to use a Java-specific
build tool which "understands" the requirements for the respective file
types. If you don't use a build tool, then IDE "export" is the next
option to try.</p>
<p><em>(</em>Editorial note: the descriptions of how to create these
files are best placed in the documentation for the respective tools. Put
them there. Please show some self-restraint and DON'T shoe-horn them
into this example!<em>)</em></p>
<p>Creating JAR and WAR files using Maven</p>
<p>Creating a JAR or WAR using Maven is simply a matter of putting the
correct <strong>&lt;packaging&gt;</strong> element into the POM file;
e,g,</p>
<p>&lt;packaging&gt;<strong>jar</strong>&lt;/packaging&gt;</p>
<p>or</p>
<p>&lt;packaging&gt;<strong>war</strong>&lt;/packaging&gt;</p>
<p>For more details. Maven can be configured to create "executable" JAR
files by adding the requisite information</p>
<p>about the entry-point class and external dependencies as plugin
properties for the maven jar plugin. There is even a plugin for creating
"uberJAR" files that combine an application and its dependencies into a
single JAR file.</p>
<p>Please refer to the Maven documentation (
http://stackoverflow.com/documentation/maven/topics )for more
information.</p>
<p>Creating JAR, WAR and EAR files using Ant</p>
<p>The Ant build tool has separate "tasks" for building JAR, WAR and
EAR. Please refer to the Ant documentation (
http://stackoverflow.com/documentation/ant/topics ) for more
information.</p>
<p>Creating JAR, WAR and EAR files using an IDE</p>
<p>The three most popular Java IDEs all have built-in support for
creating deployment files. The functionality is often described as
"exporting".</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 819</p>
<p><span id="Eclipse___http___stackoverflow_c"
class="anchor"></span>Eclipse -
http://stackoverflow.com/documentation/eclipse/topics NetBeans -
http://stackoverflow.com/documentation/netbeans/topics</p>
<p>Intellij-IDEA - Exporting</p>
<p>Creating JAR, WAR and EAR files using the jar command.</p>
<p>It is also possible to create these files "by hand" using the jar
command. It is simply a matter of assembling a file</p>
<p>tree with the correct component files in the correct place, creating
a manifest file, and running jar to create the JAR file.</p>
<p>Please refer to the jar command Topic ( Creating and modifying JAR
files ) for more information</p>
<p>Section 148.4: Introduction to Java Web Start</p>
<p>The Oracle Java Tutorials summarize <a
href="https://docs.oracle.com/javase/tutorial/deployment/webstart/">Web
Start</a> as follows:</p>
<p>Java Web Start software provides the power to launch full-featured
applications with a single click. Users</p>
<p>can download and launch applications, such as a complete spreadsheet
program or an Internet chat client, without going through lengthy
installation procedures.</p>
<p>Other advantages of Java Web Start are support for signed code and
explicit declaration of platform dependencies,</p>
<p>and support for code caching and deployment of application
updates.</p>
<p>Java Web Start is also referred to as JavaWS and JAWS. The primary
sources of information are:</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/deployment/webstart/">The
Java Tutorials - Lesson: Java Web Start</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">Java
Web Start Guide</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">Java
Web Start FAQ</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">JNLP
Specification</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">javax.jnlp
API Documentation</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/javawebstart/index.html">Java
Web Start Developers Site</a></p>
<p>Prerequisites</p>
<p>At a high level, Web Start works by distributing Java applications
packed as JAR files from a remote webserver. The</p>
<p>prerequisites are:</p>
<p>A pre-existing Java installation (JRE or JDK) on the target machine
where the application is to run. Java 1.2.2 or</p>
<p>higher is required:</p>
<p>From Java 5.0 onwards, Web Start support is included in the JRE /
JDK.</p>
<p>For earlier releases, Web Start support is installed separately. The
Web Start infrastructure includes some Javascript that can be included
in a web page to assist the</p>
<p>user to install the necessary software.</p>
<p>The webserver that hosts the software must be accessible to the
target machine.</p>
<p>If the user is going to launch a Web Start application using a link
in a web page, then:</p>
<p>they need a compatible web browser, and</p>
<p>for modern (secure) browsers, they need to be told how to tell the
browser to allow Java to run ...</p>
<p>without compromising web browser security.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 820</p>
<p>An example JNLP file</p>
<p>The following example is intended to illustrate the basic
functionality of JNLP.</p>
<p><strong>&lt;?xml</strong> version="1.0"
encoding="UTF-8"<strong>?&gt;</strong></p>
<p><strong>&lt;jnlp</strong> spec="1.0+"
codebase="https://www.example.com/demo"</p>
<p>href="demo_webstart.jnlp"<strong>&gt;</strong></p>
<p>&lt;information&gt;</p>
<p>&lt;title&gt;<strong>Demo</strong>&lt;/title&gt;</p>
<p><strong>&lt;vendor&gt;</strong>The Example.com
Team<strong>&lt;/vendor&gt;</strong></p>
<p>&lt;/information&gt;</p>
<p>&lt;resources&gt;</p>
<p>&lt;!-- Application Resources --&gt;</p>
<p><strong>&lt;j2se</strong> version="1.7+"
href="http://java.sun.com/products/autodl/j2se"<strong>/&gt;</strong></p>
<p><strong>&lt;jar</strong> href="Demo.jar"
main="true"<strong>/&gt;</strong></p>
<p>&lt;/resources&gt;</p>
<p>&lt;application-desc</p>
<p>name="Demo Application"</p>
<p>main-class="com.example.jwsdemo.Main"</p>
<p>width="300"</p>
<p>height="300"<strong>&gt;</strong></p>
<p>&lt;/application-desc&gt;</p>
<p><strong>&lt;update</strong>
check="background"<strong>/&gt;</strong></p>
<p>&lt;/jnlp&gt;</p>
<p>As you can see, a JNLP file XML-based, and the information is all
contained in the <strong>&lt;jnlp&gt;</strong> element.</p>
<p>The spec attribute gives the version of the JNPL spec that this file
conforms to.</p>
<p>The codebase attribute gives the base URL for resolving relative href
URLs in the rest of the file. The href attribute gives the definitive
URL for this JNLP file.</p>
<p>The <strong>&lt;information&gt;</strong> element contains metadata
the application including its title, authors, description and help
website.</p>
<p>The <strong>&lt;resources&gt;</strong> element describes the
dependencies for the application including the required Java version, OS
platform and JAR files.</p>
<p>The <strong>&lt;application-desc&gt;</strong> (or
<strong>&lt;applet-desc&gt;</strong>) element provides information
needed to launch the</p>
<p>application.</p>
<p>Setting up the web server</p>
<p>The webserver must be configured to use application/x-java-jnlp-file
as the MIMEtype for .jnlp files.</p>
<p>The JNLP file and the application's JAR files must be installed on
the webserver so that they are available using the</p>
<p>URLs indicated by the JNLP file.</p>
<p>Enabling launch via a web page</p>
<p>If the application is to be launched via a web link, the page that
contains the link must be created on the webserver.</p>
<p>If you can assume that Java Web Start is already installed on the
user's machine, then the web page simply</p>
<p>needs to contain a link for launching the application. For
example.</p>
<p><strong>&lt;a</strong>
href="https://www.example.com/demo_webstart.jnlp"<strong>&gt;</strong>Launch
the application<strong>&lt;/a&gt;</strong></p>
<p>Otherwise, the page should also include some scripting to detect the
kind of browser the user is using and</p>
<p>request to download and install the required version of Java.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 821</p>
<p><strong>NOTE:</strong> It is a bad idea to encourage users to
encourage to install Java this way, or even to enable Java in their
web</p>
<p>browsers so that JNLP web page launch will work.</p>
<p>Launching Web Start applications from the command line</p>
<p>The instructions for launching an Web Start application from the
command line are simple. Assuming that the user has a Java 5.0 JRE or
JDK installed, the simply need to run this:</p>
<p>$ javaws</p>
<p>where <strong>&lt;url&gt;</strong> is the URL for the JNLP file on
the remote server.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 822</p>
<p><span id="Chapter_149__Java_plugin_system_1"
class="anchor"></span>Chapter 149: Java plugin system</p>
<p>implementations</p>
<p>Section 149.1: Using URLClassLoader</p>
<p>There are several ways to implement a plugin system for a Java
application. One of the simplest is to use <em>URLClassLoader</em>. The
following example will involve a bit of JavaFX code.</p>
<p>Suppose we have a module of a main application. This module is
supposed to load plugins in form of Jars from 'plugins' folder. Initial
code:</p>
<p>package <strong>main;</strong></p>
<p><strong>public class</strong> MainApplication
<strong>extends</strong> Application</p>
<p>{</p>
<p>@Override</p>
<p><strong>public void</strong> start(Stage primaryStage)
<strong>throws</strong> Exception {</p>
<p>File pluginDirectory=<strong>new</strong> File("plugins");
<em>//arbitrary directory</em>
<strong>if</strong>(!pluginDirectory.exists())pluginDirectory.mkdir();</p>
<p><em>VBox loadedPlugins=<strong>new</strong> VBox(6);</em> //a
container to show the visual info later</p>
<p>Rectangle2D screenbounds=Screen.getPrimary().getVisualBounds();</p>
<p>Scene scene=<strong>new</strong>
Scene(loadedPlugins,screenbounds.getWidth()/2,screenbounds.getHeight()/2);</p>
<p>primaryStage.setScene(scene);</p>
<p>primaryStage.show();</p>
<p>}</p>
<p>public static void <strong>main(String[] a)</strong></p>
<p>{</p>
<p>launch(a);</p>
<p>}</p>
<p>}</p>
<p>Then, we create an interface which will represent a plugin.</p>
<p>package <strong>main;</strong></p>
<p>public interface <strong>Plugin</strong></p>
<p>{</p>
<p><strong>default void</strong> initialize()</p>
<p>{</p>
<p>System.out.println("Initialized
"+<strong>this</strong>.getClass().getName());</p>
<p>}</p>
<p><strong>default</strong> String name(){<strong>return</strong>
getClass().getSimpleName();}</p>
<p>}</p>
<p>We want to load classes which implement this interface, so first we
need to filter files which have a '.jar' extension:</p>
<p>File[] files=pluginDirectory.listFiles((dir, name)-&gt;
name.endsWith(".jar"));</p>
<p>If there are any files, we need to create collections of URLs and
class names:</p>
<p><strong>if</strong>(files!=<strong>null</strong> &amp;&amp;
files.length&gt;0)</p>
<p>{</p>
<p>ArrayList classes=<strong>new</strong> ArrayList&lt;&gt;();</p>
<p>ArrayList urls=<strong>new</strong>
ArrayList&lt;&gt;(files.length);</p>
<p><strong>for</strong>(File file:files)</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 823</p>
<p>JarFile jar=<strong>new</strong> JarFile(file);</p>
<p>jar.stream().<strong>forEach</strong>(jarEntry -&gt; {</p>
<p><strong>if</strong>(jarEntry.getName().endsWith(".class"))</p>
<p>{</p>
<p>classes.add(jarEntry.getName());</p>
<p>}</p>
<p>});</p>
<p>URL url=file.toURI().toURL();</p>
<p>urls.add(url);</p>
<p>}</p>
<p>}</p>
<p>Let's add a static HashSet to <em>MainApplication</em> which will
hold loaded plugins:</p>
<p><strong>static</strong> HashSet plugins=<strong>new</strong>
HashSet&lt;&gt;();</p>
<p>Next, we instantiate a <em>URLClassLoader</em>, and iterate over
class names, instantiating classes which implement <em>Plugin</em>
interface:</p>
<p>URLClassLoader urlClassLoader=<strong>new</strong>
URLClassLoader(urls.toArray(<strong>new</strong> URL[urls.size()]));
classes.<strong>forEach</strong>(className-&gt;{</p>
<p>try</p>
<p>{</p>
<p><strong>Class</strong>
cls=urlClassLoader.loadClass(className.replaceAll("/",".").replace(".class",""));</p>
<p>//transforming to binary name</p>
<p><strong>Class</strong>[] interfaces=cls.getInterfaces();</p>
<p><strong>for</strong>(<strong>Class</strong> intface:interfaces)</p>
<p>{</p>
<p><em><strong>if</strong>(intface.equals(Plugin.<strong>class</strong>))</em>
//checking presence of Plugin interface <em>{</em></p>
<p>Plugin plugin=(Plugin) cls.newInstance(); <em>//instantiating the
Plugin</em></p>
<p>plugins.add(plugin);</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>catch</strong> (Exception e){e.printStackTrace();}</p>
<p>});</p>
<p>Then, we can call plugin's methods, for example, to initialize
them:</p>
<p><strong>if</strong>(!plugins.isEmpty())loadedPlugins.getChildren().add(<strong>new</strong>
Label("Loaded plugins:"));</p>
<p>plugins.<strong>forEach</strong>(plugin -&gt; {</p>
<p>plugin.initialize();</p>
<p>loadedPlugins.getChildren().add(<strong>new</strong>
Label(plugin.name())); });</p>
<p>The final code of <em>MainApplication</em>:</p>
<p>package <strong>main;</strong></p>
<p><strong>public class</strong> MainApplication
<strong>extends</strong> Application</p>
<p>{</p>
<p><strong>static</strong> HashSet plugins=<strong>new</strong>
HashSet&lt;&gt;();</p>
<p>@Override</p>
<p><strong>public void</strong> start(Stage primaryStage)
<strong>throws</strong> Exception {</p>
<p>File pluginDirectory=<strong>new</strong> File("plugins");</p>
<p><strong>if</strong>(!pluginDirectory.exists())pluginDirectory.mkdir();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 824</p>
<p>File[] files=pluginDirectory.listFiles((dir, name)-&gt;
name.endsWith(".jar"));</p>
<p>VBox loadedPlugins=<strong>new</strong> VBox(6);</p>
<p>loadedPlugins.setAlignment(Pos.CENTER);</p>
<p><strong>if</strong>(files!=<strong>null</strong> &amp;&amp;
files.length&gt;0)</p>
<p>{</p>
<p>ArrayList classes=<strong>new</strong> ArrayList&lt;&gt;();</p>
<p>ArrayList urls=<strong>new</strong>
ArrayList&lt;&gt;(files.length);</p>
<p><strong>for</strong>(File file:files)</p>
<p>{</p>
<p>JarFile jar=<strong>new</strong> JarFile(file);</p>
<p>jar.stream().<strong>forEach</strong>(jarEntry -&gt; {</p>
<p><strong>if</strong>(jarEntry.getName().endsWith(".class"))</p>
<p>{</p>
<p>classes.add(jarEntry.getName());</p>
<p>}</p>
<p>});</p>
<p>URL url=file.toURI().toURL();</p>
<p>urls.add(url);</p>
<p>}</p>
<p>URLClassLoader urlClassLoader=<strong>new</strong>
URLClassLoader(urls.toArray(<strong>new</strong> URL[urls.size()]));</p>
<p>classes.<strong>forEach</strong>(className-&gt;{</p>
<p>try</p>
<p>{</p>
<p>Class</p>
<p>cls=urlClassLoader.loadClass(className.replaceAll("/",".").replace(".class",""));</p>
<p><strong>Class</strong>[] interfaces=cls.getInterfaces();</p>
<p><strong>for</strong>(<strong>Class</strong> intface:interfaces)</p>
<p>{</p>
<p><strong>if</strong>(intface.equals(Plugin.<strong>class</strong>))</p>
<p>{</p>
<p>Plugin plugin=(Plugin) cls.newInstance();</p>
<p>plugins.add(plugin);</p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>catch</strong> (Exception e){e.printStackTrace();}</p>
<p>});</p>
<p><strong>if</strong>(!plugins.isEmpty())loadedPlugins.getChildren().add(<strong>new</strong>
Label("Loaded plugins:"));</p>
<p>plugins.<strong>forEach</strong>(plugin -&gt; {</p>
<p>plugin.initialize();</p>
<p>loadedPlugins.getChildren().add(<strong>new</strong>
Label(plugin.name()));</p>
<p>});</p>
<p>}</p>
<p>Rectangle2D screenbounds=Screen.getPrimary().getVisualBounds();</p>
<p>Scene scene=<strong>new</strong>
Scene(loadedPlugins,screenbounds.getWidth()/2,screenbounds.getHeight()/2);</p>
<p>primaryStage.setScene(scene);</p>
<p>primaryStage.show();</p>
<p>}</p>
<p>public static void <strong>main(String[] a)</strong></p>
<p>{</p>
<p>launch(a);</p>
<p>}</p>
<p>}</p>
<p>Let's create two plugins. Obviously, the plugin's source should be in
a separate module.</p>
<p><strong>package</strong> plugins;</p>
<p><strong>import</strong> main.Plugin;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 825</p>
<p>public class <strong>FirstPlugin</strong> implements
<strong>Plugin</strong></p>
<p>{</p>
<p>//this plugin has default behaviour</p>
<p>}</p>
<p>Second plugin:</p>
<p><strong>package</strong> plugins;</p>
<p><strong>import</strong> main.Plugin;</p>
<p>public class <strong>AnotherPlugin</strong> implements
<strong>Plugin</strong></p>
<p>{</p>
<p>@Override</p>
<p><em><strong>public void</strong> initialize()</em> //overrided to
show user's home directory <em>{</em></p>
<p>System.out.println("User home directory:
"+System.getProperty("user.home"));</p>
<p>}</p>
<p>}</p>
<p>These plugins have to be packaged into standard Jars - this process
depends on your IDE or other tools.</p>
<p>When Jars will be put into 'plugins' directly,
<em>MainApplication</em> will detect them and instantiate appropriate
classes.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 826</p>
<p><span id="Chapter_150__JavaBean_1" class="anchor"></span>Chapter 150:
JavaBean</p>
<p>JavaBeans (TM) is a pattern for designing Java class APIs that allows
instances (beans) to be used in various contexts</p>
<p>and using various tools <em>without</em> explicitly writing Java
code. The patterns consists of conventions for defining getters and
setters for <em>properties</em>, for defining constructors, and for
defining event listener APIs.</p>
<p>Section 150.1: Basic Java Bean</p>
<p><strong>public class</strong> BasicJavaBean
<strong>implements</strong> java.io.Serializable{</p>
<p>private int <strong>value1;</strong></p>
<p><strong>private</strong> String value2;</p>
<p>private boolean <strong>value3;</strong></p>
<p><strong>public</strong> BasicJavaBean(){}</p>
<p><strong>public void</strong> setValue1(<strong>int</strong>
value1){</p>
<p><strong>this</strong>.value1 = value1;</p>
<p>}</p>
<p><strong>public int</strong> getValue1(){</p>
<p><strong>return</strong> value1;</p>
<p>}</p>
<p><strong>public void</strong> setValue2(String value2){</p>
<p><strong>this</strong>.value2 = value2;</p>
<p>}</p>
<p><strong>public</strong> String getValue2(){</p>
<p><strong>return</strong> value2;</p>
<p>}</p>
<p><strong>public void</strong> setValue3(<strong>boolean</strong>
value3){</p>
<p><strong>this</strong>.value3 = value3;</p>
<p>}</p>
<p>public boolean <strong>isValue3(){</strong></p>
<p><strong>return</strong> value3;</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 827</p>
<p><span id="Chapter_151__Java_SE_7_Features_1"
class="anchor"></span>Chapter 151: Java SE 7 Features</p>
<p>In this topic you'll find a summary of the new features added to the
Java programming language in Java SE 7. There</p>
<p>are many other new features in other fields such as JDBC and Java
Virtual Machine (JVM) that are not going to be covered in this
topic.</p>
<p>Section 151.1: New Java SE 7 programming language features</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/binary-literals.html">Binary
Literals: The integral types (byte, short, int, and long) can also be
expressed using the binary number</a> system. To specify a binary
literal, add the prefix 0b or 0B to the number.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/strings-switch.html">Strings
in switch Statements</a>: You can use a String object in the expression
of a switch statement</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html">The
try-with-resources Statement</a>: The try-with-resources statement is a
try statement that declares one or</p>
<p>more resources. A resource is as an object that must be closed after
the program is finished with it. The try-with-resources statement
ensures that each resource is closed at the end of the statement. Any
object that</p>
<p>implements java.lang.AutoCloseable, which includes all objects which
implement java.io.Closeable, can be used as a resource.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/catch-multiple.html">Catching
Multiple Exception Types and Rethrowing Exceptions with Improved Type
Checking</a>: a single catch</p>
<p>block can handle more than one type of exception. This feature can
reduce code duplication and lessen the temptation to catch an overly
broad exception.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/underscores-literals.html">Underscores
in Numeric Literals: Any number of underscore characters (_) can appear
anywhere between</a> digits in a numerical literal. This feature enables
you, for example, to separate groups of digits in numeric</p>
<p>literals, which can improve the readability of your code.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/type-inference-generic-instance-creation.html">Type
Inference for Generic Instance Creation: You can replace the type
arguments required to invoke the</a></p>
<p>constructor of a generic class with an empty set of type parameters
(&lt;&gt;) as long as the compiler can infer the type arguments from the
context. This pair of angle brackets is informally called the
diamond.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/non-reifiable-varargs.html">Improved
Compiler Warnings and Errors When Using Non-Reifiable Formal Parameters
with Varargs</a></p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/non-reifiable-varargs.html">Methods</a></p>
<p>Section 151.2: Binary Literals</p>
<p>// An 8-bit 'byte' value:</p>
<p><strong>byte</strong> aByte = (<strong>byte</strong>)0b00100001;</p>
<p>// A 16-bit 'short' value:</p>
<p><strong>short</strong> aShort =
(<strong>short</strong>)0b1010000101000101;</p>
<p>// Some 32-bit 'int' values:</p>
<p><strong>int</strong> anInt1 = 0b10100001010001011010000101000101;</p>
<p><strong>int</strong> anInt2 = 0b101;</p>
<p><em><strong>int</strong> anInt3 = 0B101;</em> // The B can be upper
or lower case.</p>
<p>// A 64-bit 'long' value. Note the "L" suffix:</p>
<p><strong>long</strong> aLong =
0b1010000101000101101000010100010110100001010001011010000101000101L;</p>
<p>Section 151.3: The try-with-resources statement</p>
<p>The example reads the first line from a file. It uses an instance of
BufferedReader to read data from the file.</p>
<p>BufferedReader is a resource that must be closed after the program is
finished with it:</p>
<p><strong>static</strong> String readFirstLineFromFile(String path)
<strong>throws</strong> IOException {</p>
<p><strong>try</strong> (BufferedReader br = <strong>new</strong>
BufferedReader(<strong>new</strong> FileReader(path))) {</p>
<p><strong>return</strong> br.readLine();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 828</p>
<p><span id="_58" class="anchor"></span>}</p>
<p>In this example, the resource declared in the try-with-resources
statement is a BufferedReader. The declaration statement appears within
parentheses immediately after the try keyword. The class BufferedReader,
in Java SE 7</p>
<p>and later, implements the interface java.lang.AutoCloseable. Because
the BufferedReader instance is declared in a try-with-resource
statement, it will be closed regardless of whether the try statement
completes normally or</p>
<p>abruptly (as a result of the method BufferedReader.readLine throwing
an IOException).</p>
<p>Section 151.4: Underscores in Numeric Literals</p>
<p>The following example shows other ways you can use the underscore in
numeric literals:</p>
<p><strong>long</strong> creditCardNumber = 1234_5678_9012_3456L;</p>
<p><strong>long</strong> socialSecurityNumber = 999_99_9999L;</p>
<p><strong>float</strong> pi = 3.14_15F;</p>
<p><strong>long</strong> hexBytes = 0xFF_EC_DE_5E;</p>
<p><strong>long</strong> hexWords = 0xCAFE_BABE;</p>
<p><strong>long</strong> maxLong = 0x7fff_ffff_ffff_ffffL;</p>
<p><strong>byte</strong> nybbles = 0b0010_0101;</p>
<p><strong>long</strong> bytes =
0b11010010_01101001_10010100_10010010;</p>
<p>You can place underscores only between digits; you cannot place
underscores in the following places:</p>
<p>At the beginning or end of a number</p>
<p>Adjacent to a decimal point in a floating point literal</p>
<p>Prior to an F or L suffix</p>
<p>In positions where a string of digits is expected</p>
<p>Section 151.5: Type Inference for Generic Instance Creation</p>
<p>You can use</p>
<p>Map&gt; myMap = <strong>new</strong> HashMap&lt;&gt;();</p>
<p>instead of</p>
<p>Map&gt; myMap = <strong>new</strong> HashMap&gt;();</p>
<p>However, you can't use</p>
<p>List list = <strong>new</strong> ArrayList&lt;&gt;();</p>
<p>list.add("A");</p>
<p>// The following statement should fail since addAll expects //
Collection&lt;? extends String&gt;</p>
<p>list.addAll(<strong>new</strong> ArrayList&lt;&gt;());</p>
<p>because it can't compile. Note that the diamond often works in method
calls; however, it is suggested that you use</p>
<p>the diamond primarily for variable declarations.</p>
<p>Section 151.6: Strings in switch Statements</p>
<p><strong>public</strong> String getTypeOfDayWithSwitchStatement(String
dayOfWeekArg) {</p>
<p>String typeOfDay;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 829</p>
<p><strong>switch</strong> (dayOfWeekArg) {</p>
<p><strong>case</strong> "Monday":</p>
<p>typeOfDay = "Start of work week";</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "Tuesday":</p>
<p><strong>case</strong> "Wednesday":</p>
<p><strong>case</strong> "Thursday":</p>
<p>typeOfDay = "Midweek";</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "Friday":</p>
<p>typeOfDay = "End of work week";</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "Saturday":</p>
<p><strong>case</strong> "Sunday":</p>
<p>typeOfDay = "Weekend";</p>
<p>break<strong>;</strong></p>
<p>default<strong>:</strong></p>
<p><strong>throw new</strong> IllegalArgumentException("Invalid day of
the week: " + dayOfWeekArg);</p>
<p>}</p>
<p><strong>return</strong> typeOfDay;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 830</p>
<p><span id="Chapter_152__Java_SE_8_Features_1"
class="anchor"></span>Chapter 152: Java SE 8 Features</p>
<p>In this topic you'll find a summary of the new features added to the
Java programming language in Java SE 8. There</p>
<p>are many other new features in other fields such as JDBC and Java
Virtual Machine (JVM) that are not going to be covered in this
topic.</p>
<p>Section 152.1: New Java SE 8 programming language features</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda
Expressions, a new language feature, has been introduced in this
release. They enable you to treat</a> functionality as a method
argument, or code as data. Lambda expressions let you express instances
of</p>
<p>single-method interfaces (referred to as functional interfaces) more
compactly.</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">Method
references provide easy-to-read lambda expressions for methods that
already have a name.</a></p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Default
methods enable new functionality to be added to the interfaces of
libraries and ensure binary</a> compatibility with code written for
older versions of those interfaces.</p>
<p><a
href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/lambda_api_jdk8.html">New
and Enhanced APIs That Take Advantage of Lambda Expressions and
Streams</a> in Java SE 8 describe new and enhanced classes that take
advantage of lambda expressions and streams.</p>
<p>Improved Type Inference - The Java compiler takes advantage of target
typing to infer the type parameters of</p>
<p>a generic method invocation. The target type of an expression is the
data type that the Java compiler expects depending on where the
expression appears. For example, you can use an assignment statement's
target</p>
<p>type for type inference in Java SE 7. However, in Java SE 8, you can
use the target type for type inference in more contexts.</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing">Target
Typing</a> <a
href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">in
Lambda Expressions</a></p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html">Type
Inference</a></p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">Repeating
Annotations provide the ability to apply the same annotation type more
than once to the same</a> declaration or type use.</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html">Type
Annotations</a> provide the ability to apply an annotation anywhere a
type is used, not just on a</p>
<p>declaration. Used with a pluggable type system, this feature enables
improved type checking of your code.</p>
<p><a
href="http://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html">Method
parameter reflection - You can obtain the names of the formal parameters
of any method or</a></p>
<p>constructor with the method
java.lang.reflect.Executable.getParameters. (The classes Method and
Constructor extend the class Executable and therefore inherit the method
Executable.getParameters)</p>
<p>However, .<strong>class</strong> files do not store formal parameter
names by default. To store formal parameter names in a particular
.<strong>class</strong> file, and thus enable the Reflection API to
retrieve formal parameter names, compile the</p>
<p>source file with the -parameters option of the javac compiler.
Date-time-api - Added new time api in java.time. If used this, you don't
need to designate timezone.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 831</p>
<p><span id="Chapter_153__Dynamic_Method_Disp_1"
class="anchor"></span>Chapter 153: Dynamic Method Dispatch</p>
<p>What is Dynamic Method Dispatch?</p>
<p>Dynamic Method Dispatch is a process in which the call to an
overridden method is resolved at runtime rather than</p>
<p>at compile-time. When an overridden method is called by a reference,
Java determines which version of that method to execute based on the
type of object it refer to. This is also know as runtime
polymorphism.</p>
<p>We will see this through an example.</p>
<p>Section 153.1: Dynamic Method Dispatch - Example Code</p>
<p>Abstract Class :</p>
<p>package <strong>base;</strong></p>
<p>/*</p>
<p>Abstract classes cannot be instantiated, but they can be subclassed
*/</p>
<p>public abstract class <strong>ClsVirusScanner {</strong></p>
<p>//With One Abstract method</p>
<p>public abstract void <strong>fnStartScan();</strong></p>
<p><strong>protected void</strong> fnCheckForUpdateVersion(){</p>
<p>System.out.println("Perform Virus Scanner Version Check");</p>
<p>}</p>
<p><strong>protected void</strong> fnBootTimeScan(){</p>
<p>System.out.println("Perform BootTime Scan");</p>
<p>}</p>
<p><strong>protected void</strong> fnInternetSecutiry(){</p>
<p>System.out.println("Scan for Internet Security");</p>
<p>}</p>
<p><strong>protected void</strong> fnRealTimeScan(){</p>
<p>System.out.println("Perform RealTime Scan");</p>
<p>}</p>
<p><strong>protected void</strong> fnVirusMalwareScan(){</p>
<p>System.out.println("Detect Virus &amp; Malware");</p>
<p>}</p>
<p>}</p>
<p>Overriding Abstract Method in Child Class :</p>
<p><strong>import</strong> base.ClsVirusScanner;</p>
<p>//All the 3 child classes inherits the base class ClsVirusScanner
//Child Class 1</p>
<p><strong>class</strong> ClsPaidVersion <strong>extends</strong>
ClsVirusScanner{</p>
<p>@Override</p>
<p><strong>public void</strong> fnStartScan() {</p>
<p><strong>super</strong>.fnCheckForUpdateVersion();</p>
<p><strong>super</strong>.fnBootTimeScan();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 832</p>
<p><strong>super</strong>.fnInternetSecutiry();</p>
<p><strong>super</strong>.fnRealTimeScan();</p>
<p><strong>super</strong>.fnVirusMalwareScan();</p>
<p>}</p>
<p><em>};</em> //ClsPaidVersion IS-A ClsVirusScanner</p>
<p>//Child Class 2</p>
<p><strong>class</strong> ClsTrialVersion <strong>extends</strong>
ClsVirusScanner{</p>
<p>@Override</p>
<p><strong>public void</strong> fnStartScan() {</p>
<p><strong>super</strong>.fnInternetSecutiry();</p>
<p><strong>super</strong>.fnVirusMalwareScan();</p>
<p>}</p>
<p><em>};</em> //ClsTrialVersion IS-A ClsVirusScanner</p>
<p>//Child Class 3</p>
<p><strong>class</strong> ClsFreeVersion <strong>extends</strong>
ClsVirusScanner{</p>
<p>@Override</p>
<p><strong>public void</strong> fnStartScan() {</p>
<p><strong>super</strong>.fnVirusMalwareScan();</p>
<p>}</p>
<p><em>};</em> //ClsTrialVersion IS-A ClsVirusScanner</p>
<p>Dynamic/Late Binding leads to Dynamic method dispatch :</p>
<p>//Calling Class</p>
<p><strong>public class</strong> ClsRunTheApplication {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>final</strong> String VIRUS_SCANNER_VERSION =
"TRIAL_VERSION";</p>
<p>//Parent Refers Null</p>
<p>ClsVirusScanner objVS=<strong>null</strong>;</p>
<p>//String Cases Supported from Java SE 7</p>
<p><strong>switch</strong> (VIRUS_SCANNER_VERSION){</p>
<p><strong>case</strong> "FREE_VERSION":</p>
<p>//Parent Refers Child Object 3</p>
<p>//ClsFreeVersion IS-A ClsVirusScanner</p>
<p><em>objVS = <strong>new</strong> ClsFreeVersion();</em> //Dynamic or
Runtime Binding</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "PAID_VERSION":</p>
<p>//Parent Refers Child Object 1</p>
<p>//ClsPaidVersion IS-A ClsVirusScanner</p>
<p><em>objVS = <strong>new</strong> ClsPaidVersion();</em> //Dynamic or
Runtime Binding</p>
<p>break<strong>;</strong></p>
<p><strong>case</strong> "TRIAL_VERSION":</p>
<p>//Parent Refers Child Object 2</p>
<p>objVS = <strong>new</strong> ClsTrialVersion(); <em>//Dynamic or
Runtime Binding</em></p>
<p>break<strong>;</strong></p>
<p>}</p>
<p>//Method fnStartScan() is the Version of ClsTrialVersion()</p>
<p>objVS.fnStartScan();</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 833</p>
<p>}</p>
<p>Result :</p>
<p>Scan <strong>for</strong> Internet Security</p>
<p>Detect Virus &amp; Malware</p>
<p>Upcasting :</p>
<p>objVS = <strong>new</strong> ClsFreeVersion();</p>
<p>objVS = <strong>new</strong> ClsPaidVersion();</p>
<p>objVS = <strong>new</strong> ClsTrialVersion()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 834</p>
<p><span id="Chapter_154__Generating_Java_Cod_1"
class="anchor"></span>Chapter 154: Generating Java Code</p>
<p>Section 154.1: Generate POJO From JSON</p>
<p><a
href="https://plugins.jetbrains.com/plugin/8062-json-model-generator">Install
JSON Model Genrator plugin</a> of Intellij by searching in Intellij
setting.</p>
<p>Start the plugin from 'Tools'</p>
<p>Input the field of UI as following shows ('Path'、'Source'、'Package'
is required):</p>
<p><img src="media/index-859_1.jpeg"
style="width:6.23611in;height:3.95833in" alt="index-859_1.jpg" /></p>
<p>Click 'Generate' button and your are done.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 835</p>
<p><span id="Chapter_155__JShell_1" class="anchor"></span>Chapter 155:
JShell</p>
<p>JShell is an interactive REPL for Java added in JDK 9. It allows
developers to instantly evaluate expressions, test</p>
<p><a href="http://jdk.java.net/9/">classes, and experiment with the
Java language. Early access for jdk 9 can be obtained from:
http://jdk.java.net/9/</a></p>
<p>Section 155.1: Editting Snippets</p>
<p>The basic unit of code used by JShell is the
<strong>snippet</strong>, or <strong>source entry</strong>. Every time
you declare a local variable or</p>
<p>define a local method or class, you create a snippet whose name is
the identifier of the variable/method/class. At</p>
<p>any time, you can edit a snippet you have created with the /edit
command. For example, let's say I have created the class Foo with a
single, method, bar:</p>
<p>jshell&gt; <strong>class</strong> Foo {</p>
<p>...&gt; <strong>void</strong> bar() {</p>
<p>...&gt; }</p>
<p>...&gt; }</p>
<p>Now, I want to fill in the body of my method. Rather than rewrite the
entire class, I can edit it:</p>
<p>jshell&gt; /edit Foo</p>
<p>By default, a swing editor will pop up with the most basic features
possible. However you can change the editor that JShell uses:</p>
<p>jshell&gt; /set editor emacs</p>
<p>jshell&gt; /set editor vi</p>
<p>jshell&gt; /set editor nano</p>
<p>jshell&gt; /set editor -<strong>default</strong></p>
<p><strong>Note that if</strong> the new version of the snippet contains
any syntax errors, it may not be saved. <strong>Likewise, a</strong></p>
<p>snippet is only created if the original declaration/definition is
syntactically correct; the following does not work:</p>
<p>jshell&gt; String st = String 3</p>
<p>//error omitted</p>
<p>jshell&gt; /edit st</p>
<p>| No such snippet: st</p>
<p>However, snippets may be compiled and hence editable despite certain
compile-time errors, such as mismatched</p>
<p>types—the following works:</p>
<p>jshell&gt; <strong>int</strong> i = "hello"</p>
<p>//error omitted</p>
<p>jshell&gt; /edit i</p>
<p>Finally, snippets may be deleted using the /drop command:</p>
<p>jshell&gt; <strong>int</strong> i = 13</p>
<p>jshell&gt; /drop i</p>
<p>jshell&gt; System.out.println(i)</p>
<p>| Error:</p>
<p>| cannot find symbol</p>
<p>| symbol: variable i</p>
<p>| System.out.println(i)</p>
<p>|</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 836</p>
<p><span id="To_delete_all_snippets__thereby" class="anchor"></span>To
delete all snippets, thereby reseting the state of the JVM, use
\reset:</p>
<p>jshell&gt; <strong>int</strong> i = 2</p>
<p>jshell&gt; String s = "hi"</p>
<p>jshell&gt; /reset</p>
<p>| Resetting state.</p>
<p>jshell&gt; i</p>
<p>| Error:</p>
<p>| cannot find symbol</p>
<p>| symbol: variable i</p>
<p>| i</p>
<p>| ^</p>
<p>jshell&gt; s</p>
<p>| Error:</p>
<p>| cannot find symbol</p>
<p>| symbol: variable s</p>
<p>| s</p>
<p>| ^</p>
<p>Section 155.2: Entering and Exiting JShell</p>
<p>Starting JShell</p>
<p>Before trying to start JShell, make sure your JAVA_HOME environment
variable points to a JDK 9 installation. To start JShell, run the
following command:</p>
<p>$ jshell</p>
<p>If all goes well, you should see a jshell&gt; prompt.</p>
<p>Exiting JShell</p>
<p>To exit JShell, run the following command from the JShell prompt:</p>
<p>jshell&gt; /exit</p>
<p>Section 155.3: Expressions</p>
<p>Within JShell, you can evaluate Java expressions, with or without
semicolons. These can range from basic expressions and statements to
more complex ones:</p>
<p>jshell&gt; 4+2</p>
<p>jshell&gt; System.out.printf("I am %d years old.<strong>\n</strong>",
421)</p>
<p>Loops and conditionals are fine, too:</p>
<p>jshell&gt; <strong>for</strong> (<strong>int</strong> i = 0; i&lt;3;
i++) {</p>
<p>...&gt; System.out.println(i);</p>
<p>...&gt; }</p>
<p><strong>It is important to note that</strong> expressions within
blocks must have semicolons!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 837</p>
<p><span id="Section_155_4__Methods_and_Class"
class="anchor"></span>Section 155.4: Methods and Classes</p>
<p>You can define methods and classes within JShell:</p>
<p>jshell&gt; <strong>void</strong> speak() {</p>
<p>...&gt; System.out.println("hello");</p>
<p>...&gt; }</p>
<p>jshell&gt; <strong>class</strong> MyClass {</p>
<p>...&gt; <strong>void</strong> doNothing() {}</p>
<p>...&gt; }</p>
<p>No access modifiers are necessary. As with other blocks, semicolons
are required inside of method bodies. Keep in</p>
<p>mind that, as with variables, it is possible to redefine methods and
classes. To see a list of methods or classes, enter /methods or /types
at the JShell prompt, respectively.</p>
<p>Section 155.5: Variables</p>
<p>You can declare local variables within JShell:</p>
<p>jshell&gt; String s = "hi"</p>
<p>jshell&gt; <strong>int</strong> i = s.length</p>
<p>Keep in mind that variables can be redeclared with different types;
this is perfectly valid in JShell:</p>
<p>jshell&gt; String var = "hi"</p>
<p>jshell&gt; <strong>int</strong> var = 3</p>
<p>To see a list of variables, enter /vars at the JShell prompt.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 838</p>
<p><span id="Chapter_156__Stack_Walking_API_1"
class="anchor"></span>Chapter 156: Stack-Walking API</p>
<p>Prior to Java 9, access to the thread stack frames was limited to an
internal class sun.reflect.Reflection.</p>
<p>Specifically the method sun.reflect.Reflection::getCallerClass. Some
libraries relies on this method which is deprecated.</p>
<p>An alternative standard API is now provided in JDK 9 via the
java.lang.StackWalker class, and is designed to be efficient by allowing
lazy access to the stack frames. Some applications may use this API to
traverse the execution</p>
<p>stack and filter on classes.</p>
<p>Section 156.1: Print all stack frames of the current thread</p>
<p>The following prints all stack frames of the current thread:</p>
<p>1 <strong>package</strong> test;</p>
<p>2</p>
<p>3 <strong>import</strong> java.lang.StackWalker.StackFrame;</p>
<p>4 <strong>import</strong>
java.lang.reflect.InvocationTargetException; 5 <strong>import</strong>
java.lang.reflect.Method;</p>
<p>6 <strong>import</strong> java.util.List;</p>
<p>7 <strong>import</strong> java.util.stream.Collectors;</p>
<p>8</p>
<p>9 <strong>public class</strong> StackWalkerExample {</p>
<p>10</p>
<p>11 <strong>public static void</strong> main(String[] args)
<strong>throws</strong> NoSuchMethodException, SecurityException,
IllegalAccessException, IllegalArgumentException,
InvocationTargetException { 12 Method fooMethod =
FooHelper.<strong>class</strong>.getDeclaredMethod("foo",
(Class[])<strong>null</strong>); 13
fooMethod.invoke(<strong>null</strong>, (Object[])
<strong>null</strong>);</p>
<p>14 }</p>
<p>15 }</p>
<p>16</p>
<p>17 <strong>class</strong> FooHelper {</p>
<p><strong>18</strong> protected static void <strong>foo()
{</strong></p>
<p>19 BarHelper.bar();</p>
<p>20 }</p>
<p>21 }</p>
<p>22</p>
<p>23 <strong>class</strong> BarHelper {</p>
<p><strong>24</strong> protected static void <strong>bar()
{</strong></p>
<p>25 List stack = StackWalker.getInstance() 26 .walk((s)-&gt;
s.collect(Collectors.toList())); 27 <strong>for</strong>(StackFrame
frame : stack) {</p>
<p>28 System.out.println(frame.getClassName() + " " +
frame.getLineNumber() + " " + frame.getMethodName());</p>
<p>29 }</p>
<p>30 }</p>
<p>31 }</p>
<p>Output:</p>
<p>test.BarHelper 26 bar</p>
<p>test.FooHelper 19 foo</p>
<p>test.StackWalkerExample 13 main</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 839</p>
<p><span id="Section_156_2__Print_current_cal"
class="anchor"></span>Section 156.2: Print current caller class</p>
<p>The following prints the current caller class. Note that in this
case, the <a
href="http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.html">StackWalker
needs to be created with the</a></p>
<p><a
href="http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.Option.html#RETAIN_CLASS_REFERENCE">option
RETAIN_CLASS_REFERENCE</a>, so that <strong>Class</strong> <a
href="http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.StackFrame.html">instances
are retained in the StackFrame</a> objects. Otherwise an</p>
<p>exception would occur.</p>
<p><strong>public class</strong> StackWalkerExample {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>FooHelper.foo();</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> FooHelper {</p>
<p>protected static void <strong>foo() {</strong></p>
<p>BarHelper.bar();</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> BarHelper {</p>
<p>protected static void <strong>bar() {</strong></p>
<p>System.out.println(StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE).getCallerClass());</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>class test.FooHelper</p>
<p>Section 156.3: Showing reflection and other hidden frames</p>
<p>A couple of other options allow stack traces to include
implementation and/or reflection frames. This may be useful</p>
<p>for debugging purposes. For instance, we can add the <a
href="http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.Option.html#SHOW_REFLECT_FRAMES">SHOW_REFLECT_FRAMES
option to the</a> <a
href="http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.html">StackWalker</a>
instance</p>
<p>upon creation, so that the frames for the reflective methods are
printed as well:</p>
<p>package <strong>test;</strong></p>
<p><strong>import</strong> java.lang.StackWalker.Option;</p>
<p><strong>import</strong> java.lang.StackWalker.StackFrame;</p>
<p><strong>import</strong> java.lang.reflect.InvocationTargetException;
<strong>import</strong> java.lang.reflect.Method;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> java.util.stream.Collectors;</p>
<p><strong>public class</strong> StackWalkerExample {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> NoSuchMethodException, SecurityException,</p>
<p>IllegalAccessException, IllegalArgumentException,
InvocationTargetException {</p>
<p>Method fooMethod =
FooHelper.<strong>class</strong>.getDeclaredMethod("foo",
(Class[])<strong>null</strong>);</p>
<p>fooMethod.invoke(<strong>null</strong>, (Object[])
<strong>null</strong>);</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> FooHelper {</p>
<p>protected static void <strong>foo() {</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 840</p>
<p>BarHelper.bar();</p>
<p>}</p>
<p>}</p>
<p><strong>class</strong> BarHelper {</p>
<p>protected static void <strong>bar() {</strong></p>
<p>// show reflection methods</p>
<p>List stack = StackWalker.getInstance(Option.SHOW_REFLECT_FRAMES)</p>
<p>.walk((s)-&gt; s.collect(Collectors.toList()));</p>
<p><strong>for</strong>(StackFrame frame : stack) {</p>
<p>System.out.println(frame.getClassName() + " " + frame.getLineNumber()
+ " " +</p>
<p>frame.getMethodName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Output:</p>
<p>test.BarHelper 27 bar</p>
<p>test.FooHelper 20 foo</p>
<p>jdk.internal.reflect.NativeMethodAccessorImpl -2 invoke0
jdk.internal.reflect.NativeMethodAccessorImpl 62 invoke
jdk.internal.reflect.DelegatingMethodAccessorImpl 43 invoke
java.lang.reflect.Method 563 invoke</p>
<p>test.StackWalkerExample 14 main</p>
<p>Note that line numbers for some reflection methods may not be
available so StackFrame.getLineNumber() may</p>
<p>return negative values.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 841</p>
<p><span id="Chapter_157__Sockets_1" class="anchor"></span>Chapter 157:
Sockets</p>
<p>A socket is one end-point of a two-way communication link between two
programs running on the network.</p>
<p>Section 157.1: Read from socket</p>
<p>String hostName = args[0];</p>
<p><strong>int</strong> portNumber = Integer.parseInt(args[1]);</p>
<p>try <strong>(</strong></p>
<p>Socket echoSocket = <strong>new</strong> Socket(hostName,
portNumber); PrintWriter out =</p>
<p><strong>new</strong> PrintWriter(echoSocket.getOutputStream(),
<strong>true</strong>);</p>
<p>BufferedReader in =</p>
<p><strong>new</strong> BufferedReader(</p>
<p><strong>new</strong>
InputStreamReader(echoSocket.getInputStream()));</p>
<p>BufferedReader stdIn =</p>
<p><strong>new</strong> BufferedReader(</p>
<p><strong>new</strong> InputStreamReader(System.in))</p>
<p>) {</p>
<p>//Use the socket</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 842</p>
<p><span id="Chapter_158__Java_Sockets_1" class="anchor"></span>Chapter
158: Java Sockets</p>
<p>Sockets are a low-level network interface that helps in creating a
connection between two program mainly clients</p>
<p>which may or may not be running on the same machine.</p>
<p>Socket Programming is one of the most widely used networking
concepts.</p>
<p>Section 158.1: A simple TCP echo back server</p>
<p>Our TCP echo back server will be a separate thread. It's simple as
its a start. It will just echo back whatever you send</p>
<p>it but in capitalised form.</p>
<p><strong>public class</strong> CAPECHOServer <strong>extends</strong>
Thread{</p>
<p>// This class implements server sockets. A server socket waits for
requests to come // in over the network only when it is allowed through
the local firewall <em>ServerSocket serverSocket;</em></p>
<p><strong>public</strong> CAPECHOServer(<strong>int</strong> port,
<strong>int</strong> timeout){</p>
<p>try <strong>{</strong></p>
<p>// Create a new Server on specified port.</p>
<p>serverSocket = <strong>new</strong> ServerSocket(port);</p>
<p>// SoTimeout is basiacally the socket timeout.</p>
<p>// timeout is the time until socket timeout in milliseconds</p>
<p>serverSocket.setSoTimeout(timeout);</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOServer.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run(){</strong></p>
<p>try <strong>{</strong></p>
<p>// We want the server to continuously accept connections
<em><strong>while</strong>(!Thread.interrupted()){</em></p>
<p>}</p>
<p>// Close the server once done.</p>
<p>serverSocket.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOServer.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now to accept connections. Let's update the run method.</p>
<p>@Override</p>
<p>public void <strong>run(){</strong></p>
<p><strong>while</strong>(!Thread.interrupted()){</p>
<p>try <strong>{</strong></p>
<p>// Log with the port number and machine ip</p>
<p>Logger.getLogger((<strong>this</strong>.getClass().getName())).log(Level.INFO,
"Listening for Clients at {0} on {1}", <strong>new</strong>
Object[]{serverSocket.getLocalPort(),
InetAddress.getLocalHost().getHostAddress()});</p>
<p><em>Socket client = serverSocket.accept();</em> // Accept client
conncetion // Now get DataInputStream and DataOutputStreams</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 843</p>
<p>DataInputStream istream = <strong>new</strong>
DataInputStream(client.getInputStream()); <em>// From</em></p>
<p>client's input stream</p>
<p>DataOutputStream ostream = <strong>new</strong>
DataOutputStream(client.getOutputStream()); <em>// Important
Note</em></p>
<p>/*</p>
<p>The server's input is the client's output</p>
<p>The client's input is the server's output</p>
<p>*/</p>
<p>// Send a welcome message</p>
<p>ostream.writeUTF("Welcome!");</p>
<p>// Close the connection</p>
<p>istream.close();</p>
<p>ostream.close();</p>
<p>client.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOServer.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>// Close the server once done</p>
<p>try <strong>{</strong></p>
<p>serverSocket.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOServer.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>Now if you can open telnet and try connecting You'll see a Welcome
message.</p>
<p>You must connect with the port you specified and IP Adress.</p>
<p>You should see a result similar to this:</p>
<p>Welcome!</p>
<p>Connection to host lost.</p>
<p>Well, the connection was lost because we terminated it. Sometimes we
would have to program our own TCP client.</p>
<p>In this case, we need a client to request input from the user and
send it across the network, receive the capitalised input.</p>
<p>If the server sends data first, then the client must read the data
first.</p>
<p><strong>public class</strong> CAPECHOClient <strong>extends</strong>
Thread{</p>
<p>Socket server;</p>
<p><em>Scanner key;</em> // Scanner for input</p>
<p><strong>public</strong> CAPECHOClient(String ip, <strong>int</strong>
port){</p>
<p>try <strong>{</strong></p>
<p>server = <strong>new</strong> Socket(ip, port);</p>
<p>key = <strong>new</strong> Scanner(System.in);</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOClient.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>@Override</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 844</p>
<p>public void <strong>run(){</strong></p>
<p>DataInputStream istream = <strong>null</strong>;</p>
<p>DataOutputStream ostream = <strong>null</strong>;</p>
<p>try <strong>{</strong></p>
<p>istream = <strong>new</strong>
DataInputStream(server.getInputStream()); <em>// Familiar lines</em></p>
<p>ostream = <strong>new</strong>
DataOutputStream(server.getOutputStream());</p>
<p>System.out.println(istream.readUTF()); <em>// Print what the server
sends</em> System.out.print("&gt;");</p>
<p>String tosend = key.nextLine();</p>
<p><em>ostream.writeUTF(tosend);</em> // Send whatever the user typed to
the server</p>
<p><em>System.out.println(istream.readUTF());</em> // Finally read what
the server sends before</p>
<p>exiting.</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOClient.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>try <strong>{</strong></p>
<p>istream.close();</p>
<p>ostream.close();</p>
<p>server.close();</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>Logger.getLogger(CAPECHOClient.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now update the server</p>
<p>ostream.writeUTF("Welcome!");</p>
<p>String inString = istream.readUTF(); <em>// Read what the user
sent</em> String outString = inString.toUpperCase(); <em>// Change it to
caps</em> ostream.writeUTF(outString);</p>
<p>// Close the connection</p>
<p>istream.close();</p>
<p>And now run the server and client, You should have an output similar
to this</p>
<p>Welcome!</p>
<p>&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 845</p>
<p><span id="Chapter_159__FTP__File_Transfer_1"
class="anchor"></span>Chapter 159: FTP (File Transfer Protocol)</p>
<p>Parameters Details</p>
<p>host Either the host name or IP address of the FTP server</p>
<p>port The FTP server port</p>
<p>username The FTP server username</p>
<p>password The FTP server password</p>
<p>Section 159.1: Connecting and Logging Into a FTP Server</p>
<p>To start using FTP with Java, you will need to create a new FTPClient
and then connect and login to the server using</p>
<p>.connect(String server, <strong>int</strong> port) and .login(String
username, String password).</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPClient;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPReply;</p>
<p>//Import all the required resource for this project.</p>
<p><strong>public class</strong> FTPConnectAndLogin {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// SET THESE TO MATCH YOUR FTP SERVER //</p>
<p><em>String server = "www.server.com";</em> //Server can be either
host name or IP address. <em><strong>int</strong> port = 21;</em></p>
<p>String user = "Username";</p>
<p>String pass = "Password";</p>
<p>FTPClient ftp = <strong>new</strong> FTPClient;</p>
<p>ftp.connect(server, port);</p>
<p>ftp.login(user, pass);</p>
<p>}</p>
<p>}</p>
<p>Now we have the basics done. But what if we have an error connecting
to the server? We'll want to know when something goes wrong and get the
error message. Let's add some code to catch errors while connecting.</p>
<p>try <strong>{</strong></p>
<p>ftp.connect(server, port);</p>
<p>showServerReply(ftp);</p>
<p><strong>int</strong> replyCode = ftp.getReplyCode();</p>
<p><strong>if</strong> (!FTPReply.isPositiveCompletion(replyCode)) {</p>
<p>System.out.printIn("Operation failed. Server reply code: " +
replyCode) <strong>return</strong>;</p>
<p>}</p>
<p>ftp.login(user, pass);</p>
<p><strong>}</strong> catch <strong>{</strong></p>
<p>}</p>
<p>Let's break down what we just did, step by step.</p>
<p>showServerReply(ftp);</p>
<p>This refers to a function we will be making in a later step.</p>
<p><strong>int</strong> replyCode = ftp.getReplyCode();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 846</p>
<p>This grabs the reply/error code from the server and stores it as an
integer.</p>
<p><strong>if</strong> (!FTPReply.isPositiveCompletion(replyCode)) {</p>
<p>System.out.printIn("Operation failed. Server reply code: " +
replyCode) <strong>return</strong>;</p>
<p>}</p>
<p>This checks the reply code to see if there was an error. If there was
an error, it will simply print "Operation failed.</p>
<p>Server reply code: " followed by the error code. We also added a
try/catch block which we will add to in the next step. Next, let's also
create a function that checks ftp.login() for errors.</p>
<p><strong>boolean</strong> success = ftp.login(user, pass);</p>
<p>showServerReply(ftp);</p>
<p><strong>if</strong> (!success) {</p>
<p>System.out.println("Failed to log into the server");</p>
<p>return<strong>;</strong></p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("LOGGED IN SERVER");</p>
<p>}</p>
<p>Let's break this block down too.</p>
<p><strong>boolean</strong> success = ftp.login(user, pass);</p>
<p>This will not just attempt to login to the FTP server, it will also
store the result as a boolean.</p>
<p>showServerReply(ftp);</p>
<p>This will check if the server sent us any messages, but we will first
need to create the function in the next step.</p>
<p><strong>if</strong> (!success) {</p>
<p>System.out.println("Failed to log into the server");</p>
<p>return<strong>;</strong></p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("LOGGED IN SERVER");</p>
<p>}</p>
<p>This statement will check if we logged in successfully; if so, it
will print "LOGGED IN SERVER", otherwise it will print</p>
<p>"Failed to log into the server". This is our script so far:</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPClient;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPReply;</p>
<p><strong>public class</strong> FTPConnectAndLogin {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// SET THESE TO MATCH YOUR FTP SERVER //</p>
<p>String server = "www.server.com";</p>
<p><strong>int</strong> port = 21;</p>
<p>String user = "username"</p>
<p>String pass = "password"</p>
<p>FTPClient ftp = <strong>new</strong> FTPClient</p>
<p>try <strong>{</strong></p>
<p>ftp.connect(server, port)</p>
<p>showServerReply(ftp);</p>
<p><strong>int</strong> replyCode = ftpClient.getReplyCode();</p>
<p><strong>if</strong> (!FTPReply.isPositiveCompletion(replyCode)) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 847</p>
<p>System.out.println("Operation failed. Server reply code: " +
replyCode); <strong>return</strong>;</p>
<p>}</p>
<p><strong>boolean</strong> success = ftp.login(user, pass);</p>
<p>showServerReply(ftp);</p>
<p><strong>if</strong> (!success) {</p>
<p>System.out.println("Failed to log into the server");
<strong>return</strong>;</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("LOGGED IN SERVER");</p>
<p>}</p>
<p><strong>}</strong> catch <strong>{</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now next let's create complete the Catch block in case we run into
any errors with the whole process.</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Oops! Something went wrong.");</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>The completed catch block will now print "Oops! Something went
wrong." and the stacktrace if there is an error.</p>
<p>Now our final step is to create the showServerReply() we have been
using for a while now.</p>
<p><strong>private static void</strong> showServerReply(FTPClient ftp)
{</p>
<p>String[] replies = ftp.getReplyStrings();</p>
<p><strong>if</strong> (replies != <strong>null</strong> &amp;&amp;
replies.length &gt; 0) {</p>
<p><strong>for</strong> (String aReply : replies) {</p>
<p>System.out.println("SERVER: " + aReply);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>This function takes an FTPClient as a variable, and calls it "ftp".
After that it stores any server replies from the server in a string
array. Next it checks if any messages were stored. If there is any, it
prints each of them as</p>
<p>"SERVER: [reply]". Now that we have that function done, this is the
completed script:</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPClient;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPReply;</p>
<p><strong>public class</strong> FTPConnectAndLogin {</p>
<p><strong>private static void</strong> showServerReply(FTPClient ftp)
{</p>
<p>String[] replies = ftp.getReplyStrings();</p>
<p><strong>if</strong> (replies != <strong>null</strong> &amp;&amp;
replies.length &gt; 0) {</p>
<p><strong>for</strong> (String aReply : replies) {</p>
<p>System.out.println("SERVER: " + aReply);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// SET THESE TO MATCH YOUR FTP SERVER //</p>
<p>String server = "www.server.com";</p>
<p><strong>int</strong> port = 21;</p>
<p>String user = "username"</p>
<p>String pass = "password"</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 848</p>
<p>FTPClient ftp = <strong>new</strong> FTPClient</p>
<p>try <strong>{</strong></p>
<p>ftp.connect(server, port)</p>
<p>showServerReply(ftp);</p>
<p><strong>int</strong> replyCode = ftpClient.getReplyCode();</p>
<p><strong>if</strong> (!FTPReply.isPositiveCompletion(replyCode)) {</p>
<p>System.out.println("Operation failed. Server reply code: " +
replyCode); <strong>return</strong>;</p>
<p>}</p>
<p><strong>boolean</strong> success = ftp.login(user, pass);</p>
<p>showServerReply(ftp);</p>
<p><strong>if</strong> (!success) {</p>
<p>System.out.println("Failed to log into the server");
<strong>return</strong>;</p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("LOGGED IN SERVER");</p>
<p>}</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Oops! Something went wrong.");</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>We first need to create a new FTPClient and try connecting to the
server it and logging into it using</p>
<p>.connect(String server, <strong>int</strong> port) and .login(String
username, String password). It is important to connect and login using a
try/catch block in case our code fails to connect with the server. We
will also need to</p>
<p>create a function that checks and displays any messages we may
receive from the server as we try connecting and logging in. We will
call this function "showServerReply(FTPClient ftp)".</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPClient;</p>
<p><strong>import</strong> org.apache.commons.net.ftp.FTPReply;</p>
<p><strong>public class</strong> FTPConnectAndLogin {</p>
<p><strong>private static void</strong> showServerReply(FTPClient ftp)
{</p>
<p><strong>if</strong> (replies != <strong>null</strong> &amp;&amp;
replies.length &gt; 0) {</p>
<p><strong>for</strong> (String aReply : replies) {</p>
<p>System.out.println("SERVER: " + aReply);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>// SET THESE TO MATCH YOUR FTP SERVER //</p>
<p>String server = "www.server.com";</p>
<p><strong>int</strong> port = 21;</p>
<p>String user = "username"</p>
<p>String pass = "password"</p>
<p>FTPClient ftp = <strong>new</strong> FTPClient</p>
<p>try <strong>{</strong></p>
<p>ftp.connect(server, port)</p>
<p>showServerReply(ftp);</p>
<p><strong>int</strong> replyCode = ftpClient.getReplyCode();</p>
<p><strong>if</strong> (!FTPReply.isPositiveCompletion(replyCode)) {</p>
<p>System.out.println("Operation failed. Server reply code: " +
replyCode); <strong>return</strong>;</p>
<p>}</p>
<p><strong>boolean</strong> success = ftp.login(user, pass);</p>
<p>showServerReply(ftp);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 849</p>
<p><strong>if</strong> (!success) {</p>
<p>System.out.println("Failed to log into the server");</p>
<p>return<strong>;</strong></p>
<p>} <strong>else</strong> {</p>
<p>System.out.println("LOGGED IN SERVER");</p>
<p>}</p>
<p>} <strong>catch</strong> (IOException ex) {</p>
<p>System.out.println("Oops! Something went wrong.");</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>After this, you should now have your FTP server connected to you Java
script.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 850</p>
<p><span id="Chapter_160__Using_Other_Scripti_1"
class="anchor"></span>Chapter 160: Using Other Scripting</p>
<p>Languages in Java</p>
<p>Java in itself is an extremely powerful language, but its power can
further be extended Thanks to JSR223 (Java</p>
<p>Specification Request 223) introducing a script engine</p>
<p>Section 160.1: Evaluating A JavaScript file in -scripting mode</p>
<p>of nashorn</p>
<p>public class <strong>JSEngine {</strong></p>
<p>/*</p>
<p>* Note Nashorn is only available for Java-8 onwards</p>
<p>* You can use rhino from
ScriptEngineManager.getEngineByName("js");</p>
<p>*/</p>
<p>ScriptEngine engine;</p>
<p>ScriptContext context;</p>
<p><strong>public</strong> Bindings scope;</p>
<p>// Initialize the Engine from its factory in scripting mode
<em><strong>public</strong> JSEngine(){</em></p>
<p>engine = <strong>new</strong>
NashornScriptEngineFactory().getScriptEngine("-scripting");</p>
<p>// Script context is an interface so we need an implementation of
it</p>
<p>context = <strong>new</strong> SimpleScriptContext();</p>
<p>// Create bindings to expose variables into</p>
<p>scope = engine.createBindings();</p>
<p>}</p>
<p>// Clear the bindings to remove the previous variables
<em><strong>public void</strong> newBatch(){</em></p>
<p>scope.clear();</p>
<p>}</p>
<p><strong>public void</strong> execute(String file){</p>
<p>try <strong>{</strong></p>
<p>// Get a buffered reader for input</p>
<p>BufferedReader br = <strong>new</strong>
BufferedReader(<strong>new</strong> FileReader(file)); <em>// Evaluate
code, with input as bufferdReader</em></p>
<p>engine.eval(br);</p>
<p>} <strong>catch</strong> (FileNotFoundException ex) {</p>
<p>Logger.getLogger(JSEngine.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>// Script Exception is basically when there is an error in script</p>
<p>Logger.getLogger(JSEngine.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p><strong>public void</strong> eval(String code){</p>
<p>try <strong>{</strong></p>
<p>// Engine.eval basically treats any string as a line of code and
evaluates it, executes</p>
<p>it</p>
<p>engine.eval(code);</p>
<p>} <strong>catch</strong> (ScriptException ex) {</p>
<p>// Script Exception is basically when there is an error in script</p>
<p>Logger.getLogger(JSEngine.<strong>class</strong>.getName()).log(Level.SEVERE,
<strong>null</strong>, ex);</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 851</p>
<p>// Apply the bindings to the context and set the engine's default
context <em><strong>public void</strong> startBatch(<strong>int</strong>
SCP){</em></p>
<p>context.setBindings(scope, SCP);</p>
<p>engine.setContext(context);</p>
<p>}</p>
<p>// We use the invocable interface to access methods from the script
// Invocable is an optional interface, please check if your engine
implements it <em><strong>public</strong> Invocable
invocable(){</em></p>
<p><strong>return</strong> (Invocable)engine;</p>
<p>}</p>
<p>}</p>
<p>Now the main method</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>JSEngine jse = <strong>new</strong> JSEngine();</p>
<p>// Create a new batch probably unecessary</p>
<p>jse.newBatch();</p>
<p>// Expose variable x into script with value of hello world</p>
<p>jse.scope.put("x", "hello world");</p>
<p>// Apply the bindings and start the batch</p>
<p>jse.startBatch(ScriptContext.ENGINE_SCOPE);</p>
<p>// Evaluate the code</p>
<p>jse.eval("print(x);");</p>
<p>}</p>
<p>Your output should be similar to this</p>
<p>hello world</p>
<p>As you can see the exposed variable x has been printed. Now testing
with a file.</p>
<p>Here we have test.js</p>
<p>print(x);</p>
<p>function test(){</p>
<p>print("hello test.js:test");</p>
<p>}</p>
<p>test();</p>
<p>And the updated main method</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>JSEngine jse = <strong>new</strong> JSEngine();</p>
<p>// Create a new batch probably unecessary</p>
<p>jse.newBatch();</p>
<p>// Expose variable x into script with value of hello world</p>
<p>jse.scope.put("x", "hello world");</p>
<p>// Apply the bindings and start the batch</p>
<p>jse.startBatch(ScriptContext.ENGINE_SCOPE);</p>
<p>// Evaluate the code</p>
<p>jse.execute("./test.js");</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 852</p>
<p>Assuming that test.js is in the same directory as your application
You should have output similar to this</p>
<p>hello world</p>
<p>hello test.js:test</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 853</p>
<p><span id="Chapter_161__C___Comparison_1"
class="anchor"></span>Chapter 161: C++ Comparison</p>
<p>Java and C++ are similar languages. This topic serves as a quick
reference guide for Java and C++ Engineers.</p>
<p>Section 161.1: Static Class Members</p>
<p>Static members have class scope as opposed to object scope</p>
<p><a href="http://www.bogotobogo.com/cplusplus/statics.php">C++
Example</a></p>
<p>// define in header</p>
<p><strong>class</strong> Singleton {</p>
<p>public<strong>:</strong></p>
<p><strong>static</strong> Singleton *getInstance();</p>
<p>private<strong>:</strong></p>
<p>Singleton() {}</p>
<p><strong>static</strong> Singleton *instance;</p>
<p>};</p>
<p>// initialize in .cpp</p>
<p>Singleton* Singleton::instance = 0;</p>
<p><a
href="http://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">Java
Example</a></p>
<p>public class <strong>Singleton {</strong></p>
<p><strong>private static</strong> Singleton instance;</p>
<p><strong>private</strong> Singleton() {}</p>
<p><strong>public static</strong> Singleton getInstance() {</p>
<p><strong>if</strong>(instance == <strong>null</strong>) {</p>
<p>instance = <strong>new</strong> Singleton();</p>
<p>}</p>
<p><strong>return</strong> instance;</p>
<p>}</p>
<p>}</p>
<p>Section 161.2: Classes Defined within Other Constructs</p>
<p>Defined within Another Class</p>
<p>C++</p>
<p><a
href="https://stackoverflow.com/questions/2687544/question-about-c-inner-class">Nested
Class[ref] (needs a reference to enclosing class)</a></p>
<p><strong>class</strong> Outer {</p>
<p><strong>class</strong> Inner {</p>
<p>public<strong>:</strong></p>
<p>Inner(Outer* o) :outer(o) {}</p>
<p>private<strong>:</strong></p>
<p>Outer* outer;</p>
<p>};</p>
<p>};</p>
<p>Java</p>
<p>[non-static] Nested Class (aka Inner Class or Member Class)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 854</p>
<p><strong>class</strong> OuterClass {</p>
<p>...</p>
<p><strong>class</strong> InnerClass {</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>Statically Defined within Another Class</p>
<p>C++</p>
<p>Static Nested Class</p>
<p><strong>class</strong> Outer {</p>
<p><strong>class</strong> Inner {</p>
<p>...</p>
<p>};</p>
<p>};</p>
<p>Java</p>
<p>Static Nested Class (aka Static Member Class)<a
href="https://www.javatpoint.com/static-nested-class">[ref]</a></p>
<p><strong>class</strong> OuterClass {</p>
<p>...</p>
<p><strong>static class</strong> StaticNestedClass {</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>Defined within a Method</p>
<p>(e.g. event handling)</p>
<p>C++</p>
<p><a href="http://www.geeksforgeeks.org/local-class-in-c/">Local
Class[ref]</a></p>
<p><strong>void</strong> fun() {</p>
<p><strong>class</strong> Test {</p>
<p>/* members of Test class */</p>
<p>};</p>
<p>}</p>
<p>Java</p>
<p><a
href="https://stackoverflow.com/questions/1183453/whats-the-use-of-a-method-local-inner-class">Local
Class[ref]</a></p>
<p><strong>class</strong> Test {</p>
<p><strong>void</strong> f() {</p>
<p><strong>new</strong> Thread(<strong>new</strong> Runnable() {</p>
<p>public void <strong>run() {</strong></p>
<p>doSomethingBackgroundish();</p>
<p>}</p>
<p>}).start();</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 855</p>
<p><span id="Section_161_3__Pass_by_value___P"
class="anchor"></span>Section 161.3: Pass-by-value &amp;
Pass-by-reference</p>
<p>Many argue that Java is ONLY pass-by-value, but it's more nuanced
than that. Compare the following C++ and Java</p>
<p>examples to see the many flavors of pass-by-value (aka copy) and
pass-by-reference (aka alias).</p>
<p>C++ Example <a
href="https://gitlab.com/johndifini/java-algos/blob/master/PassIt.cpp">(complete
code)</a></p>
<p>// passes a COPY of the object</p>
<p><strong>static void</strong> passByCopy(PassIt obj) {</p>
<p><em>obj.i = 22;</em> // only a "local" change</p>
<p>}</p>
<p>// passes a pointer</p>
<p><strong>static void</strong> passByPointer(PassIt* ptr) {</p>
<p>ptr-&gt;i = 33;</p>
<p><em>ptr = 0;</em> // better to use nullptr instead if '0'</p>
<p>}</p>
<p>// passes an alias (aka reference)</p>
<p><strong>static void</strong> passByAlias(PassIt&amp; ref) {</p>
<p>ref.i = 44;</p>
<p>}</p>
<p>// This is an old-school way of doing it.</p>
<p>// Check out std::swap for the best way to do this</p>
<p><strong>static void</strong> swap(PassIt** pptr1, PassIt** pptr2)
{</p>
<p>PassIt* tmp = *pptr1;</p>
<p>*pptr1 = *pptr2;</p>
<p>*pptr2 = tmp;</p>
<p>}</p>
<p>Java Example <a
href="https://gitlab.com/johndifini/java-algos/blob/master/PassIt.java">(complete
code)</a></p>
<p>// passes a copy of the variable</p>
<p>// NOTE: in java only primitives are pass-by-copy</p>
<p>public static void <strong>passByCopy(</strong>int <strong>copy)
{</strong></p>
<p><em>copy = 33;</em> // only a "local" change</p>
<p>}</p>
<p>// No such thing as pointers in Java</p>
<p>/*</p>
<p>public static void passByPointer(PassIt *ptr) {</p>
<p>ptr-&gt;i = 33;</p>
<p>ptr = 0; // better to use nullptr instead if '0'</p>
<p>}</p>
<p>*/</p>
<p>// passes an alias (aka reference)</p>
<p><strong>public static void</strong> passByAlias(PassIt ref) {</p>
<p>ref.i = 44;</p>
<p>}</p>
<p>// passes aliases (aka references),</p>
<p>// but need to do "manual", potentially expensive copies
<em><strong>public static void</strong> swap(PassIt ref1, PassIt ref2)
{</em></p>
<p>PassIt tmp = <strong>new</strong> PassIt(ref1);</p>
<p>ref1.copy(ref2);</p>
<p>ref2.copy(tmp);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 856</p>
<p><span id="Section_161_4__Inheritance_vs_Co"
class="anchor"></span>Section 161.4: Inheritance vs Composition</p>
<p>C++ &amp; Java are both object-oriented languages, thus the following
diagram applies to both.</p>
<p><img src="media/index-881_1.jpeg"
style="width:6.5in;height:3.20833in" alt="index-881_1.jpg" /></p>
<p>Section 161.5: Outcast Downcasting</p>
<p>Beware of using "downcasting" - Downcasting is casting down the
inheritance hierarchy from a base class to a subclass (i.e. opposite of
polymorphism). In general, use polymorphism &amp; overriding instead of
instanceof &amp;</p>
<p>downcasting.</p>
<p>C++ Example</p>
<p>// explicit type case required</p>
<p>Child *pChild = (Child *) &amp;parent;</p>
<p>Java Example</p>
<p><strong>if</strong>(mySubClass <strong>instanceof</strong> SubClass)
{</p>
<p>SubClass mySubClass = (SubClass)someBaseClass;</p>
<p>mySubClass.nonInheritedMethod();</p>
<p>}</p>
<p>Section 161.6: Abstract Methods &amp; Classes</p>
<p>Abstract Method</p>
<p>declared without an implementation</p>
<p>C++</p>
<p>pure virtual method</p>
<p>virtual <strong>void</strong> eat(<strong>void</strong>) = 0;</p>
<p>Java</p>
<p>abstract method</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 857</p>
<p>abstract void <strong>draw();</strong></p>
<p>Abstract Class</p>
<p>cannot be instantiated</p>
<p>C++</p>
<p>cannot be instantiated; has at least 1 pure virtual method</p>
<p><strong>class</strong> AB {<strong>public</strong>: virtual
<strong>void</strong> f() = 0;};</p>
<p>Java</p>
<p>cannot be instantiated; can have non-abstract methods</p>
<p><strong>abstract class</strong> GraphicObject {}</p>
<p>Interface</p>
<p>no instance fields</p>
<p>C++</p>
<p>nothing comparable to Java</p>
<p>Java</p>
<p>very similar to abstract class, but 1) supports multiple inheritance;
2) no instance fields</p>
<p><strong>interface</strong> TestInterface {}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 858</p>
<p><span id="Chapter_162__Audio_1" class="anchor"></span>Chapter 162:
Audio</p>
<p>Section 162.1: Play a MIDI file</p>
<p>MIDI files can be played by using several classes from the
javax.sound.midi package. A Sequencer performs playback of the MIDI
file, and many of its methods can be used to set playback controls such
as loop count, tempo,</p>
<p>track muting, and others.</p>
<p>General playback of MIDI data can be done in this way:</p>
<p><strong>import</strong> java.io.File;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong>
javax.sound.midi.InvalidMidiDataException;</p>
<p><strong>import</strong> javax.sound.midi.MidiSystem;</p>
<p><strong>import</strong>
javax.sound.midi.MidiUnavailableException;</p>
<p><strong>import</strong> javax.sound.midi.Sequence;</p>
<p><strong>import</strong> javax.sound.midi.Sequencer;</p>
<p><strong>public class</strong> MidiPlayback {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>try <strong>{</strong></p>
<p>Sequencer sequencer = MidiSystem.getSequencer(); <em>// Get the
default Sequencer</em> <strong>if</strong>
(sequencer==<strong>null</strong>) {</p>
<p>System.err.println("Sequencer device not supported");
<strong>return</strong>;</p>
<p>}</p>
<p>sequencer.open(); <em>// Open device</em></p>
<p><em>// Create sequence, the File must contain MIDI file data.</em>
Sequence sequence = MidiSystem.getSequence(<strong>new</strong>
File(args[0]));</p>
<p>sequencer.setSequence(sequence); <em>// load it into
sequencer</em></p>
<p><em>sequencer.start();</em> // start the playback</p>
<p>} <strong>catch</strong> (MidiUnavailableException |
InvalidMidiDataException | IOException ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>To stop the playback use:</p>
<p><em>sequencer.stop();</em> // Stop the playback</p>
<p>A sequencer can be set to mute one or more of the sequence's tracks
during playback so none of the instruments in those specified play. The
following example sets the first track in the sequence to be muted:</p>
<p><strong>import</strong> javax.sound.midi.Track;</p>
<p>// ...</p>
<p>Track[] track = sequence.getTracks();</p>
<p>sequencer.setTrackMute(track[0]);</p>
<p>A sequencer can play a sequence repeatedly if the loop count is
given. The following sets the sequencer to play a sequence four times
and indefinitely:</p>
<p>sequencer.setLoopCount(3);</p>
<p>sequencer.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);</p>
<p>The sequencer does not always have to play the sequence from the
beginning, nor does it have to play the</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 859</p>
<p><span id="sequence_until_the_end__It_can_s"
class="anchor"></span>sequence until the end. It can start and end at
any point by specifying the <em>tick</em> in the sequence to start and
end at. It is also possible to specify manually which tick in the
sequence the sequencer should play from:</p>
<p>sequencer.setLoopStartPoint(512);</p>
<p>sequencer.setLoopEndPoint(32768);</p>
<p>sequencer.setTickPosition(8192);</p>
<p>Sequencers can also play a MIDI file at a certain tempo, which can be
controlled by specifying the tempo in beats</p>
<p>per minute (BPM) or microseconds per quarter note (MPQ). The factor
at which the sequence is played can be adjusted as well.</p>
<p>sequencer.setTempoInBPM(1250f);</p>
<p>sequencer.setTempoInMPQ(4750f);</p>
<p>sequencer.setTempoFactor(1.5f);</p>
<p>When you finished using the Sequencer, remeber to close it</p>
<p>sequencer.close();</p>
<p>Section 162.2: Play an Audio file Looped</p>
<p>Needed imports:</p>
<p><strong>import</strong> javax.sound.sampled.AudioSystem;</p>
<p><strong>import</strong> javax.sound.sampled.Clip;</p>
<p>This code will create a clip and play it continuously once
started:</p>
<p>Clip clip = AudioSystem.getClip();</p>
<p>clip.open(AudioSystem.getAudioInputStream(<strong>new</strong>
URL(filename))); clip.start();</p>
<p>clip.loop(Clip.LOOP_CONTINUOUSLY);</p>
<p>Get an Array with all supported file types:</p>
<p>AudioFileFormat.Type [] audioFileTypes =
AudioSystem.getAudioFileTypes();</p>
<p>Section 162.3: Basic audio output</p>
<p>The Hello Audio! of Java that plays a sound file from local or
internet storage looks as follows. It works for uncompressed .wav files
and should not be used for playing mp3 or compressed files.</p>
<p><strong>import</strong> java.io.*;</p>
<p><strong>import</strong> java.net.URL;</p>
<p><strong>import</strong> javax.sound.sampled.*;</p>
<p><strong>public class</strong> SoundClipTest {</p>
<p>// Constructor</p>
<p><strong>public</strong> SoundClipTest() {</p>
<p>try <strong>{</strong></p>
<p>// Open an audio input stream.</p>
<p>File soundFile = <strong>new</strong>
File("/usr/share/sounds/alsa/Front_Center.wav"); <em>//you could
also</em></p>
<p>get the sound file with an URL</p>
<p>AudioInputStream audioIn =
AudioSystem.getAudioInputStream(soundFile); AudioFormat format =
audioIn.getFormat();</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 860</p>
<p><span id="___Get_a_sound_clip_resource" class="anchor"></span>// Get
a sound clip resource.</p>
<p>DataLine.Info info = <strong>new</strong>
DataLine.Info(Clip.<strong>class</strong>, format); Clip clip =
(Clip)AudioSystem.getLine(info);</p>
<p>// Open audio clip and load samples from the audio input stream.</p>
<p>clip.open(audioIn);</p>
<p>clip.start();</p>
<p>} <strong>catch</strong> (UnsupportedAudioFileException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>} <strong>catch</strong> (LineUnavailableException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><strong>new</strong> SoundClipTest();</p>
<p>}</p>
<p>}</p>
<p>Section 162.4: Bare metal sound</p>
<p>You can also go almost bare-metal when producing sound with java.
This code will write raw binary data into the OS</p>
<p>audio buffer to generate sound. It's extremely important to
understand the limitations and necessary calculations to generating
sound like this. Since playback is basically instantaneous, calculations
need to be performed at almost</p>
<p>real-time.</p>
<p>As such this method is unusable for more complicated sound-sampling.
For such purposes using specialized tools is</p>
<p>the better approach.</p>
<p>The following method generates and directly outputs a rectangle-wave
of a given frequency in a given volume for a</p>
<p>given duration.</p>
<p><strong>public void</strong> rectangleWave(<strong>byte</strong>
volume, <strong>int</strong> hertz, <strong>int</strong> msecs) {</p>
<p><strong>final</strong> SourceDataLine dataLine;</p>
<p>// 24 kHz x 8bit, single-channel, signed little endian AudioFormat
<em>AudioFormat af = <strong>new</strong> AudioFormat(24_000, 8, 1,
<strong>true</strong>, <strong>false</strong>); <strong>try</strong>
{</em></p>
<p>dataLine = AudioSystem.getSourceDataLine(af);</p>
<p><em>dataLine.open(af, 10_000);</em> // audio buffer size: 10k
samples</p>
<p>} <strong>catch</strong> (LineUnavailableException e) {</p>
<p><strong>throw new</strong> RuntimeException(e);</p>
<p>}</p>
<p><strong>int</strong> waveHalf = 24_000 / hertz; <em>// samples for
half a period</em> <strong>byte</strong>[] buffer = <strong>new
byte</strong>[waveHalf * 20];</p>
<p><em><strong>int</strong> samples = msecs * (24_000 / 1000);</em> //
24k (samples / sec) / 1000 (ms/sec) * time(ms)</p>
<p>dataLine.start(); <em>// starts playback</em></p>
<p><strong>int</strong> sign = 1;</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; samples; i
+= buffer.length) {</p>
<p><em><strong>for</strong> (<strong>int</strong> j = 0; j &lt; 20; j++)
{</em> // generate 10 waves into buffer</p>
<p>sign *=-1;</p>
<p><em>// fill from the jth wave-half to the j+1th wave-half with
volume</em> Arrays.fill(buffer, waveHalf * j, waveHalf * (j+1),
(<strong>byte</strong>) (volume * sign));</p>
<p>}</p>
<p>dataLine.write(buffer, 0, buffer.length); <em>//</em></p>
<p>}</p>
<p><em>dataLine.drain();</em> // forces buffer drain to hardware</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 861</p>
<p>dataLine.stop(); <em>// ends playback</em></p>
<p>}</p>
<p>For a more differentiated way to generate different soundwaves sinus
calculations and possibly larger sample sizes</p>
<p>are necessary. This results in significantly more complex code and is
accordingly omitted here.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 862</p>
<p><span id="Chapter_163__Java_Print_Service_1"
class="anchor"></span>Chapter 163: Java Print Service</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/jps/spec/JPSTOC.fm.html">The
Java Print Service API</a> provides functionalities to discover print
services and send print requests for them.</p>
<p><a href="https://en.wikipedia.org/wiki/Internet_Printing_Protocol">It
includes extensible print attributes based on the standard attributes
specified in the Internet Printing Protocol</a></p>
<p><a
href="https://en.wikipedia.org/wiki/Internet_Printing_Protocol">(IPP)
1.1 from the IETF Specification,</a> <a
href="https://tools.ietf.org/html/rfc2911">RFC 2911.</a></p>
<p>Section 163.1: Building the Doc that will be printed</p>
<p>Doc is an interface and the Java Print Service API provide a simple
implementation called SimpleDoc.</p>
<p>Every Doc instance is basically made of two aspects:</p>
<p>the print data content itself (an E-mail, an image, a document
etc)</p>
<p>the print data format, called DocFlavor (MIME type + Representation
class).</p>
<p>Before creating the Doc object, we need to load our document from
somewhere. In the example, we will load an</p>
<p>specific file from the disk:</p>
<p>FileInputStream pdfFileInputStream = <strong>new</strong>
FileInputStream("something.pdf");</p>
<p>So now, we have to choose a DocFlavor that matches our content. The
DocFlavor class has a bunch of constants to</p>
<p>represent the most usual types of data. Let's pick the
INPUT_STREAM.PDF one:</p>
<p>DocFlavor pdfDocFlavor = DocFlavor.INPUT_STREAM.PDF;</p>
<p>Now, we can create a new instance of SimpleDoc:</p>
<p>Doc doc = <strong>new</strong> SimpleDoc(pdfFileInputStream,
pdfDocFlavor , <strong>null</strong>);</p>
<p>The doc object now can be sent to the print job request (see Creating
a print job from a print service).</p>
<p>Section 163.2: Discovering the available print services</p>
<p>To discovery all the available print services, we can use the
PrintServiceLookup class. Let's see how:</p>
<p><strong>import</strong> javax.print.PrintService;</p>
<p><strong>import</strong> javax.print.PrintServiceLookup;</p>
<p><strong>public class</strong> DiscoveringAvailablePrintServices {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>discoverPrintServices();</p>
<p>}</p>
<p><strong>public static void</strong> discoverPrintServices() {</p>
<p>PrintService[] allPrintServices =
PrintServiceLookup.lookupPrintServices(<strong>null</strong>,
<strong>null</strong>);</p>
<p><strong>for</strong> (Printservice printService : allPrintServices)
{</p>
<p>System.out.println("Print service name: " +
printService.getName());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 863</p>
<p><span id="This_program__when_executed_on_a"
class="anchor"></span>This program, when executed on a Windows
environment, will print something like this:</p>
<p>Print service name: Fax</p>
<p>Print service name: Microsoft Print to PDF</p>
<p>Print service name: Microsoft XPS Document Viewer</p>
<p>Section 163.3: Defining print request attributes</p>
<p>Sometimes we need to determine some aspects of the print request. We
will call them <em>attribute</em>.</p>
<p>Are examples of print request attributes:</p>
<p>amount of copies (1, 2 etc),</p>
<p>orientation (portrait or landscape)</p>
<p>chromacity (monochrome, color)</p>
<p>quality (draft, normal, high)</p>
<p>sides (one-sided, two-sided etc)</p>
<p>and so on...</p>
<p>Before choosing one of them and which value each one will have, first
we need to build a set of attributes:</p>
<p>PrintRequestAttributeSet pras = <strong>new</strong>
HashPrintRequestAttributeSet();</p>
<p>Now we can add them. Some examples are:</p>
<p>pras.add(<strong>new</strong> Copies(5));</p>
<p>pras.add(MediaSize.ISO_A4);</p>
<p>pras.add(OrientationRequested.PORTRAIT);</p>
<p>pras.add(PrintQuality.NORMAL);</p>
<p>The pras object now can be sent to the print job request (see
Creating a print job from a print service).</p>
<p>Section 163.4: Listening print job request status change</p>
<p>For the most printing clients, is extremely useful to know if a print
job has finished or failed.</p>
<p>The Java Print Service API provide some functionalities to get
informed about these scenarios. All we have to do is:</p>
<p>provide an implementation for PrintJobListener interface and register
this implementation at the print job.</p>
<p>When the print job state changes, we will be notified. We can do
anything is needed, for example:</p>
<p>update a user interface,</p>
<p>start another business process,</p>
<p>record something in the database,</p>
<p>or simply log it.</p>
<p>In the example bellow, we will log every print job status change:</p>
<p><strong>import</strong> javax.print.event.PrintJobEvent;</p>
<p><strong>import</strong> javax.print.event.PrintJobListener;</p>
<p><strong>public class</strong> LoggerPrintJobListener
<strong>implements</strong> PrintJobListener {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 864</p>
<p>// Your favorite Logger class goes here!</p>
<p><strong>private static final</strong> Logger LOG =
Logger.getLogger(LoggerPrintJobListener.<strong>class</strong>);</p>
<p><strong>public void</strong> printDataTransferCompleted(PrintJobEvent
pje) { LOG.info("Print data transfer completed ;) "); }</p>
<p><strong>public void</strong> printJobCompleted(PrintJobEvent pje)
{</p>
<p>LOG.info("Print job completed =) ");</p>
<p>}</p>
<p><strong>public void</strong> printJobFailed(PrintJobEvent pje) {</p>
<p>LOG.info("Print job failed =( ");</p>
<p>}</p>
<p><strong>public void</strong> printJobCanceled(PrintJobEvent pje)
{</p>
<p>LOG.info("Print job canceled :| ");</p>
<p>}</p>
<p><strong>public void</strong> printJobNoMoreEvents(PrintJobEvent pje)
{ LOG.info("No more events to the job ");</p>
<p>}</p>
<p><strong>public void</strong> printJobRequiresAttention(PrintJobEvent
pje) { LOG.info("Print job requires attention :O ");</p>
<p>}</p>
<p>}</p>
<p>Finally, we can add our print job listener implementation on the
print job before the print request itself, as follows:</p>
<p>DocPrintJob printJob = printService.createPrintJob();</p>
<p>printJob.addPrintJobListener(<strong>new</strong>
LoggerPrintJobListener());</p>
<p>printJob.print(doc, pras);</p>
<p><em>The</em> PrintJobEvent pje <em>argument</em></p>
<p>Notice that every method has a PrintJobEvent pje argument. We don't
use it in this example for simplicity</p>
<p>purposes, but you can use it to explore the status. For example:</p>
<p>pje.getPrintJob().getAttributes();</p>
<p>Will return a PrintJobAttributeSet object instance and you can run
them in a for-each way.</p>
<p>Another way to achieve the same goal</p>
<p>Another option to achieve the same goal is extending the
PrintJobAdapter class, as the name says, is an adapter</p>
<p>for PrintJobListener. Implementing the interface we compulsorily have
to implement all of them. The advantage</p>
<p>of this way it's we need to override only the methods we want. Let's
see how it works:</p>
<p><strong>import</strong> javax.print.event.PrintJobEvent;</p>
<p><strong>import</strong> javax.print.event.PrintJobAdapter;</p>
<p><strong>public class</strong> LoggerPrintJobAdapter
<strong>extends</strong> PrintJobAdapter {</p>
<p>// Your favorite Logger class goes here!</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 865</p>
<p><span id="private_static_final_Logger_LOG"
class="anchor"></span><strong>private static final</strong> Logger LOG =
Logger.getLogger(LoggerPrintJobAdapter.<strong>class</strong>);</p>
<p><strong>public void</strong> printJobCompleted(PrintJobEvent pje)
{</p>
<p>LOG.info("Print job completed =) ");</p>
<p>}</p>
<p><strong>public void</strong> printJobFailed(PrintJobEvent pje) {</p>
<p>LOG.info("Print job failed =( ");</p>
<p>}</p>
<p>}</p>
<p>Notice that we override only some specific methods.</p>
<p>As the same way in the example implementing the interface
PrintJobListener, we add the listener to the print job</p>
<p>before sending it to print:</p>
<p>printJob.addPrintJobListener(<strong>new</strong>
LoggerPrintJobAdapter());</p>
<p>printJob.print(doc, pras);</p>
<p>Section 163.5: Discovering the default print service</p>
<p>To discovery the default print service, we can use the
PrintServiceLookup class. Let's see how::</p>
<p><strong>import</strong> javax.print.PrintService;</p>
<p><strong>import</strong> javax.print.PrintServiceLookup;</p>
<p><strong>public class</strong> DiscoveringDefaultPrintService {</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>discoverDefaultPrintService();</p>
<p>}</p>
<p><strong>public static void</strong> discoverDefaultPrintService()
{</p>
<p>PrintService defaultPrintService =
PrintServiceLookup.lookupDefaultPrintService();</p>
<p>System.out.println("Default print service name: " +
defaultPrintService.getName());</p>
<p>}</p>
<p>}</p>
<p>Section 163.6: Creating a print job from a print service</p>
<p>A print job is a request of printing something in a specific print
service. It consists, basically, by:</p>
<p>the data that will be printed (see Building the Doc that will be
printed) a set of attributes</p>
<p>After picking-up the right print service instance, we can request the
creation of a print job:</p>
<p>DocPrintJob printJob = printService.createPrintJob();</p>
<p>The DocPrintJob interface provide us the print method:</p>
<p>printJob.print(doc, pras);</p>
<p>The doc argument is a Doc: the data that will be printed.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 866</p>
<p>And the pras argument is a PrintRequestAttributeSet interface: a set
of PrintRequestAttribute. Are examples of print request attributes:</p>
<p>amount of copies (1, 2 etc),</p>
<p>orientation (portrait or landscape)</p>
<p>chromacity (monochrome, color)</p>
<p>quality (draft, normal, high)</p>
<p>sides (one-sided, two-sided etc)</p>
<p>and so on...</p>
<p>The print method may throw a PrintException.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 867</p>
<p><span id="Chapter_164__CompletableFuture_1"
class="anchor"></span>Chapter 164: CompletableFuture</p>
<p>CompletableFuture is a class added to Java SE 8 which implements the
Future interface from Java SE 5. In addition</p>
<p>to supporting the Future interface it adds many methods that allow
asynchronous callback when the future is completed.</p>
<p>Section 164.1: Simple Example of CompletableFuture</p>
<p>In the example below, the calculateShippingPrice method calculates
shipping cost, which takes some processing time. In a real world
example, this would e.g. be contacting another server which returns the
price based on the</p>
<p>weight of the product and the shipping method.</p>
<p>By modeling this in an async way via CompletableFuture, we can
continue different work in the method (i.e.</p>
<p>calculating packaging costs).</p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p><em><strong>int</strong> price = 15;</em> // Let's keep it simple and
work with whole number prices here <em><strong>int</strong>
weightInGrams = 900;</em></p>
<p>calculateShippingPrice(weightInGrams) <em>// Here, we get the
future</em></p>
<p><em>.thenAccept(shippingPrice -&gt; {</em> // And then immediately
work on it!</p>
<p><em>// This fluent style is very useful for keeping it concise</em>
System.out.println("Your total price is: " + (price +
shippingPrice));</p>
<p>});</p>
<p>System.out.println("Please stand by. We are calculating your total
price.");</p>
<p>}</p>
<p><strong>public static</strong> CompletableFuture
calculateShippingPrice(<strong>int</strong> weightInGrams) {</p>
<p><strong>return</strong> CompletableFuture.supplyAsync(()-&gt; {</p>
<p>// supplyAsync is a factory method that turns a given //
Supplier&lt;U&gt; into a CompletableFuture&lt;U&gt;</p>
<p>// Let's just say each 200 grams is a new dollar on your shipping
costs <em><strong>int</strong> shippingCosts = weightInGrams /
200;</em></p>
<p>try <strong>{</strong></p>
<p><em>Thread.sleep(2000L);</em> // Now let's simulate some waiting
time...</p>
<p>} <strong>catch</strong>(InterruptedException e) { <em>/* We can
safely ignore that */</em> }</p>
<p><em><strong>return</strong> shippingCosts;</em> // And send the costs
back!</p>
<p>});</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 868</p>
<p><span id="Chapter_165__Runtime_Commands_1"
class="anchor"></span>Chapter 165: Runtime Commands</p>
<p>Section 165.1: Adding shutdown hooks</p>
<p>Sometimes you need a piece of code to execute when the program stops,
such as releasing system resources that you open. You can make a thread
run when the program stops with the addShutdownHook method:</p>
<p>Runtime.getRuntime().addShutdownHook(<strong>new</strong>
Thread(()-&gt; {</p>
<p>ImportantStuff.someImportantIOStream.close();</p>
<p>}));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 869</p>
<p><span id="Chapter_166__Unit_Testing_1" class="anchor"></span>Chapter
166: Unit Testing</p>
<p>Unit testing is an integral part of test-driven development, and an
important feature for building any robust</p>
<p>application. In Java, Unit testing is almost exclusively performed
using external libraries and frameworks, most of which have their own
documentation tag. This stub serves as a means of introducing the reader
to the tools</p>
<p>available, and their respective documentation.</p>
<p>Section 166.1: What is Unit Testing?</p>
<p>This is a bit of a primer. It's mostly put it in because
documentation is forced to have an example, even if it's</p>
<p>intended as a stub article. If you already know unit-testing basics,
feel free to skip forward to the remarks, where specific frameworks are
mentioned.</p>
<p>Unit testing is ensuring that a given module behaves as expected. In
large-scale applications, ensuring the appropriate execution of modules
in a vacuum is an integral part of ensuring application fidelity.</p>
<p>Consider the following (trivial) pseudo-example:</p>
<p>public class <strong>Example {</strong></p>
<p><strong>public static void</strong> main (String args[]) {</p>
<p><strong>new</strong> Example();</p>
<p>}</p>
<p>// Application-level test.</p>
<p><strong>public</strong> Example() {</p>
<p>Consumer c = <strong>new</strong> Consumer();</p>
<p>System.out.println("VALUE = " + c.getVal());</p>
<p>}</p>
<p>// Your Module.</p>
<p><strong>class</strong> Consumer {</p>
<p><strong>private</strong> Capitalizer c;</p>
<p><strong>public</strong> Consumer() {</p>
<p>c = <strong>new</strong> Capitalizer();</p>
<p>}</p>
<p><strong>public</strong> String getVal() {</p>
<p><strong>return</strong> c.getVal();</p>
<p>}</p>
<p>}</p>
<p>// Another team's module.</p>
<p><strong>class</strong> Capitalizer {</p>
<p><strong>private</strong> DataReader dr;</p>
<p><strong>public</strong> Capitalizer() {</p>
<p>dr = <strong>new</strong> DataReader();</p>
<p>}</p>
<p><strong>public</strong> String getVal() {</p>
<p><strong>return</strong> dr.readVal().toUpperCase();</p>
<p>}</p>
<p>}</p>
<p>// Another team's module.</p>
<p><strong>class</strong> DataReader {</p>
<p><strong>public</strong> String readVal() {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 870</p>
<p>// Refers to a file somewhere in your application deployment, or //
perhaps retrieved over a deployment-specific network. <em>File
f;</em></p>
<p>String s = "data";</p>
<p>// ... Read data from f into s ...</p>
<p>return <strong>s;</strong></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>So this example is trivial; DataReader gets the data from a file,
passes it to the Capitalizer, which converts all the characters to
upper-case, which then gets passed to the Consumer. But the DataReader
is heavily-linked to our</p>
<p>application environment, so we defer testing of this chain until we
are ready to deploy a test release.</p>
<p>Now, assume, somewhere along the way in a release, for reasons
unknown, the getVal() method in Capitalizer</p>
<p>changed from returning a toUpperCase() String to a toLowerCase()
String:</p>
<p>// Another team's module.</p>
<p><strong>class</strong> Capitalizer {</p>
<p>...</p>
<p><strong>public</strong> String getVal() {</p>
<p><strong>return</strong> dr.readVal().toLowerCase();</p>
<p>}</p>
<p>}</p>
<p>Clearly, this breaks expected behavior. But, because of the arduous
processes involved with execution of the DataReader, we won't notice
this until our next test deployment. So days/weeks/months go by with
this bug sitting</p>
<p>in our system, and then the product manager sees this, and instantly
turns to you, the team leader associated with the Consumer. "Why is this
happening? What did you guys change?" Obviously, you're clueless. You
have no idea</p>
<p>what's going on. You didn't change any code that should be touching
this; why is it suddenly broken?</p>
<p>Eventually, after discussion between the teams and collaboration, the
issue is traced, and the problem solved. But,</p>
<p>it begs the question; how could this have been prevented?</p>
<p>There are two obvious things:</p>
<p>Tests need to be automated</p>
<p>Our reliance upon manual testing let this bug go by unnoticed far too
long. We need a way to automate the process</p>
<p>under which bugs are introduced <strong>instantly</strong>. Not 5
weeks from now. Not 5 days from now. Not 5 minutes from now. Right
now.</p>
<p>You have to appreciate that, in this example, I've expressed one
<strong>very trivial</strong> bug that was introduced and</p>
<p>unnoticed. In an industrial application, with dozens of modules
constantly being updated, these can creep in all</p>
<p>over the place. You fix something with one module, only to realize
that the very behavior you "fixed" was relied upon in some manner
elsewhere (either internally or externally).</p>
<p>Without rigorous validation, things will creep into the system. It's
possible that, if neglected far enough, this will result in so much
extra work trying to fix changes (and then fixing those fixes, etc.),
that a product will actually</p>
<p><strong>increase</strong> in remaining work as effort is put into it.
You do not want to be in this situation.</p>
<p>Tests need to be fine-grained</p>
<p>The second problem noted in our above example is the amount of time
it took to trace the bug. The product manager pinged you when the
testers noticed it, you investigated and found that the Capitalizer was
returning</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 871</p>
<p>seemingly bad data, you pinged the Capitalizer team with your
findings, they investigated, etc. etc. etc.</p>
<p>The same point I made above about the quantity and difficulty of this
trivial example hold here. Obviously anyone</p>
<p>reasonably well-versed with Java could find the introduced problem
quickly. But it's often much, much more difficult to trace and
communicate issues. Maybe the Capitalizer team provided you a JAR with
no source. Maybe</p>
<p>they're located on the other side of the world, and communication
hours are very limited (perhaps to e-mails that get sent once daily). It
can result in bugs taking weeks or longer to trace (and, again, there
could be several of these</p>
<p>for a given release).</p>
<p>In order to mitigate against this, we want rigorous testing on as
<strong>fine</strong> a level as possible (you also want coarse-</p>
<p>grained testing to ensure modules interact properly, but that's not
our focal point here). We want to rigorously specify how all
outward-facing functionality (at minimum) operates, and tests for that
functionality.</p>
<p>Enter unit-testing</p>
<p>Imagine if we had a test, specifically ensuring that the getVal()
method of Capitalizer returned a capitalized string for a given input
string. Furthermore, imagine that test was run before we even committed
any code. The bug</p>
<p>introduced into the system (that is, toUpperCase() being replaced
with toLowerCase()) would cause no issues</p>
<p>because the bug would never <strong>be</strong> introduced into the
system. We would catch it in a test, the developer would</p>
<p>(hopefully) realize their mistake, and an alternative solution would
be reached as to how to introduce their intended effect.</p>
<p>There's some omissions made here as to <strong>how</strong> to
implement these tests, but those are covered in the framework-</p>
<p>specific documentation (linked in the remarks). Hopefully, this
serves as an example of <strong>why</strong> unit testing is</p>
<p>important.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 872</p>
<p><span id="Chapter_167__Asserting_1" class="anchor"></span>Chapter
167: Asserting</p>
<p>Parameter Details</p>
<p>expression1 The assertion statement throws an AssertionError if this
expression evaluates to <strong>false</strong>.</p>
<p>expression2 Optional. When used, AssertionErrors thrown by the assert
statement have this message.</p>
<p>Section 167.1: Checking arithmetic with assert</p>
<p>a = 1-Math.abs(1- a % 2);</p>
<p><em>// This will throw an error if my arithmetic above is wrong.</em>
<strong>assert</strong> a &gt;= 0 &amp;&amp; a &lt;= 1 : "Calculated
value of " + a + " is outside of expected bounds";</p>
<p>return <strong>a;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 873</p>
<p><span id="Chapter_168__Multi_Release_JAR_F_1"
class="anchor"></span>Chapter 168: Multi-Release JAR Files</p>
<p>One of the features introduced in Java 9 is the multi-release Jar
(MRJAR) which allows bundling code targeting</p>
<p>multiple Java releases within the same Jar file. The feature is
specified in <a href="http://openjdk.java.net/jeps/238">JEP 238.</a></p>
<p>Section 168.1: Example of a multi-release Jar file's contents</p>
<p>By setting <a
href="http://download.java.net/java/jdk9/docs/api/java/util/jar/Attributes.Name.html#MULTI_RELEASE">Multi-Release:
<strong>true</strong> in the MANIFEST.MF file, the Jar file becomes a
multi-release Jar and the Java</a></p>
<p>runtime (as long as it supports the MRJAR format) will pick the
appropriate versions of classes depending on the current major
version.</p>
<p>The structure of such a Jar is the following:</p>
<p>jar root</p>
<p><strong>- A.</strong>class</p>
<p><strong>- B.</strong>class</p>
<p><strong>- C.</strong>class</p>
<p><strong>- D.</strong>class</p>
<p>- META-INF</p>
<p>- versions</p>
<p>-9</p>
<p><strong>- A.</strong>class</p>
<p><strong>- B.</strong>class</p>
<p>-10</p>
<p><strong>- A.</strong>class</p>
<p>On JDKs &lt; 9, only the classes in the root entry are visible to the
Java runtime.</p>
<p>On a JDK 9, the classes A and B will be loaded from the directory
root/META-INF/versions/9, while C and D will be loaded from the base
entry.</p>
<p>On a JDK 10, class A would be loaded from the directory
root/META-INF/versions/10.</p>
<p>Section 168.2: Creating a multi-release Jar using the jar tool</p>
<p>The jar command can be used to create a multi-release Jar containing
two versions of the same class compiled for</p>
<p>both Java 8 and Java 9, albeit with a warning telling that the
classes are identical:</p>
<p>C:\Users\manouti&gt;jar --create --file MR.jar-C sampleproject-base
demo --release 9-C sampleproject-9 demo</p>
<p>Warning: entry
META-INF/versions/9/demo/SampleClass.<strong>class</strong> contains a
<strong>class</strong> that is identical to an entry already in the
jar</p>
<p>The --release 9 option tells jar to include everything that follows
(the demo package inside the sampleproject-9</p>
<p>directory) inside a versioned entry in the MRJAR, namely under
root/META-INF/versions/9. The result is the following contents:</p>
<p>jar root</p>
<p>- demo</p>
<p>- SampleClass.<strong>class</strong></p>
<p>- META-INF</p>
<p>- versions</p>
<p>-9</p>
<p>- demo</p>
<p>- SampleClass.<strong>class</strong></p>
<p>Let us now create a class called Main that prints the URL of the
SampleClass, and add it for the Java 9 version:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 874</p>
<p><span id="package_demo" class="anchor"></span>package
<strong>demo;</strong></p>
<p><strong>import</strong> java.net.URL;</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>URL url =
Main.<strong>class</strong>.getClassLoader().getResource("demo/SampleClass.class");
System.out.println(url);</p>
<p>}</p>
<p>}</p>
<p>If we compile this class and re-run the jar command, we get an
error:</p>
<p>C:\Users\manouti&gt;jar --create --file MR.jar-C sampleproject-base
demo --release 9-C sampleproject-9 demoentry:
META-INF/versions/9/demo/Main.<strong>class</strong>, contains a
<strong>new public class</strong> not found in base entries</p>
<p>Warning: entry META-INF/versions/9/demo/Main.java, multiple resources
with same name Warning: entry
META-INF/versions/9/demo/SampleClass.<strong>class</strong> contains a
<strong>class</strong> that is identical to an entry already in the
jar</p>
<p>invalid multi-release jar file MR.jar deleted</p>
<p>The reason is that the jar tool prevents adding public classes to
versioned entries if they are not added to the base entries as well.
This is done so that the MRJAR exposes the same public API for the
different Java versions. Note that</p>
<p>at runtime, this rule is not required. It may be only applied by
tools like jar. In this particular case, the purpose of Main is to run
sample code, so we can simply add a copy in the base entry. If the class
were part of a newer</p>
<p>implementation that we only need for Java 9, it could be made
non-public.</p>
<p>To add Main to the root entry, we first need to compile it to target
a pre-Java 9 release. This can be done using the</p>
<p>new --release option of javac:</p>
<p>C:\Users\manouti\sampleproject-base\demo<strong>&gt;javac</strong>--release
8 Main.java
C:\Users\manouti\sampleproject-base\demo<strong>&gt;cd</strong>
..<strong>/</strong>..</p>
<p>C:\Users\manouti<strong>&gt;jar</strong>--create--file MR.jar -C
sampleproject-base demo --release 9 -C sampleproject-9 demo</p>
<p>Running the Main class shows that the SampleClass gets loaded from
the versioned directory:</p>
<p>C:\Users\manouti&gt;java --class-path MR.jar demo.Main
jar:file:/C:/Users/manouti/MR.jar!/META-INF/versions/9/demo/SampleClass.<strong>class</strong></p>
<p>Section 168.3: URL of a loaded class inside a multi-release Jar</p>
<p>Given the following multi-release Jar:</p>
<p>jar root</p>
<p>- demo</p>
<p>- SampleClass.<strong>class</strong></p>
<p>- META-INF</p>
<p>- versions</p>
<p>-9</p>
<p>- demo</p>
<p>- SampleClass.<strong>class</strong></p>
<p>The following class prints the URL of the SampleClass:</p>
<p>package <strong>demo;</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 875</p>
<p><strong>import</strong> java.net.URL;</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>URL url =
Main.<strong>class</strong>.getClassLoader().getResource("demo/SampleClass.class");
System.out.println(url);</p>
<p>}</p>
<p>}</p>
<p>If the class is compiled and added on the versioned entry for Java 9
in the MRJAR, running it would result in:</p>
<p>C:\Users\manouti&gt;java --class-path MR.jar demo.Main
jar:file:/C:/Users/manouti/MR.jar!/META-INF/versions/9/demo/SampleClass.<strong>class</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 876</p>
<p><span id="Chapter_169__Just_in_Time__JIT_1"
class="anchor"></span>Chapter 169: Just in Time (JIT) compiler</p>
<p>Section 169.1: Overview</p>
<p><img src="media/index-901_1.jpeg"
style="width:6.26389in;height:6.93056in" alt="index-901_1.jpg" /></p>
<p>The Just-In-Time (JIT) compiler is a component of the Java™ Runtime
Environment that improves the performance</p>
<p>of Java applications at run time.</p>
<p>Java programs consists of classes, which contain platform-neutral
bytecodes that can be interpreted by a JVM on many different computer
architectures.</p>
<p>At run time, the JVM loads the class files, determines the semantics
of each individual bytecode, and</p>
<p>performs the appropriate computation.</p>
<p>The additional processor and memory usage during interpretation means
that a Java application performs more slowly than a native
application.</p>
<p>The JIT compiler helps improve the performance of Java programs by
compiling bytecodes into native</p>
<p>machine code at run time.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 877</p>
<p>The JIT compiler is enabled by default, and is activated when a Java
method is called. The JIT compiler compiles the bytecodes of that method
into native machine code, compiling it "just in time" to run.</p>
<p>When a method has been compiled, the JVM calls the compiled code of
that method directly instead of interpreting it. Theoretically, if
compilation did not require processor time and memory usage, compiling
every method could</p>
<p>allow the speed of the Java program to approach that of a native
application.</p>
<p>JIT compilation does require processor time and memory usage. When
the JVM first starts up, thousands of</p>
<p>methods are called. Compiling all of these methods can significantly
affect startup time, even if the program eventually achieves very good
peak performance.</p>
<p>In practice, methods are not compiled the first time they are called.
For each method, the JVM maintains a call count which is incremented
every time the method is called.</p>
<p>The JVM interprets a method until its call count exceeds a JIT
compilation threshold. Therefore, often-used methods are compiled soon
after the JVM has started, and less-used methods are</p>
<p>compiled much later, or not at all.</p>
<p>The JIT compilation threshold helps the JVM start quickly and still
have improved performance. The threshold has been carefully selected to
obtain an optimal balance between startup times and long term</p>
<p>performance.</p>
<p>After a method is compiled, its call count is reset to zero and
subsequent calls to the method continue to</p>
<p>increment its count.</p>
<p>When the call count of a method reaches a JIT recompilation
threshold, the JIT compiler compiles it a second</p>
<p>time, applying a larger selection of optimizations than on the
previous compilation. This process is repeated until the maximum
optimization level is reached.</p>
<p>The busiest methods of a Java program are always optimized most
aggressively, maximizing the performance benefits of using the JIT
compiler.</p>
<p>The JIT compiler can also measure operational data at run time, and
use that data to improve the quality of</p>
<p>further recompilations.</p>
<p>The JIT compiler can be disabled, in which case the entire Java
program will be interpreted. Disabling the</p>
<p>JIT compiler is not recommended except to diagnose or work around JIT
compilation problems.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 878</p>
<p><span id="Chapter_170__Bytecode_Modificati_1"
class="anchor"></span>Chapter 170: Bytecode Modification</p>
<p>Section 170.1: What is Bytecode?</p>
<p>Bytecode is the set of instructions used by the JVM. To illustrate
this let's take this Hello World program.</p>
<p><strong>public static void</strong> main(String[] args){</p>
<p>System.out.println("Hello World");</p>
<p>}</p>
<p>This is what it turns into when compiled into bytecode.</p>
<p><strong>public static</strong> main([Ljava/lang/String; args)V</p>
<p>getstatic java/lang/System out Ljava/io/PrintStream;</p>
<p>ldc "Hello World"</p>
<p>invokevirtual java/io/PrintStream print(Ljava/lang/String;)V</p>
<p>What's the logic behind this?</p>
<p><strong>getstatic</strong> - Retrieves the value of a static field of
a class. In this case, the <em>PrintStream "Out"</em> of
<em>System</em>.</p>
<p><strong>ldc</strong> - Push a constant onto the stack. In this case,
the String "Hello World"</p>
<p><strong>invokevirtual</strong> - Invokes a method on a loaded
reference on the stack and puts the result on the stack. Parameters</p>
<p>of the method are also taken from the stack.</p>
<p>Well, there has to be more right?</p>
<p>There are 255 opcodes, but not all of them are implemented yet. A
table with all of the current opcodes can be</p>
<p><a
href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">found
here: Java bytecode instruction listings</a>.</p>
<p>How can I write / edit bytecode?</p>
<p>There's multiple ways to write and edit bytecode. You can use a
compiler, use a library, or use a program.</p>
<p>For writing:</p>
<p><a href="http://jasmin.sourceforge.net/">Jasmin</a></p>
<p><a href="https://github.com/Storyyeller/Krakatau">Krakatau</a></p>
<p>For editing:</p>
<p>Libraries</p>
<p><a href="http://asm.ow2.org/">ASM</a></p>
<p><a
href="http://jboss-javassist.github.io/javassist/">Javassist</a></p>
<p><a href="https://commons.apache.org/proper/commons-bcel/"><em>BCEL
-</em></a> Doesn't support Java 8+</p>
<p>Tools</p>
<p><a
href="https://github.com/Konloch/bytecode-viewer">Bytecode-Viewer</a></p>
<p><a href="https://github.com/QMatt/JBytedit">JBytedit</a></p>
<p><em><a href="http://rejava.sourceforge.net/features.html">reJ</a>
-</em> Doesn't support Java 8+</p>
<p><a href="http://www.cs.ioc.ee/%7Eando/jbe/"><em>JBE -</em></a>
Doesn't support Java 8+</p>
<p>I'd like to learn more about bytecode!</p>
<p>There's probably a specific documentation page specificially for
bytecode. This page focuses on the modification of</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 879</p>
<p><span id="bytecode_using_different_librari"
class="anchor"></span>bytecode using different libraries and tools.</p>
<p>Section 170.2: How to edit jar files with ASM</p>
<p>Firstly the classes from the jar need to be loaded. We'll use three
methods for this process:</p>
<p>loadClasses(File)</p>
<p>readJar(JarFile, JarEntry, Map)</p>
<p>getNode(byte[])</p>
<p>Map loadClasses(File jarFile) <strong>throws</strong> IOException
{</p>
<p>Map classes = <strong>new</strong> HashMap();</p>
<p>JarFile jar = <strong>new</strong> JarFile(jarFile);</p>
<p>Stream str = jar.stream();</p>
<p>str.<strong>forEach</strong>(z -&gt; readJar(jar, z, classes));</p>
<p>jar.close();</p>
<p><strong>return</strong> classes;</p>
<p>}</p>
<p>Map readJar(JarFile jar, JarEntry entry, Map classes) {</p>
<p>String name = entry.getName();</p>
<p><strong>try</strong> (InputStream jis =
jar.getInputStream(entry)){</p>
<p><strong>if</strong> (name.endsWith(".class")) {</p>
<p><strong>byte</strong>[] bytes = IOUtils.toByteArray(jis);</p>
<p>String cafebabe = String.format("%02X%02X%02X%02X", bytes[0],
bytes[1], bytes[2],</p>
<p>bytes[3]);</p>
<p><strong>if</strong> (!cafebabe.toLowerCase().equals("cafebabe"))
{</p>
<p>// This class doesn't have a valid magic</p>
<p><strong>return</strong> classes;</p>
<p>}</p>
<p>try <strong>{</strong></p>
<p>ClassNode cn = getNode(bytes);</p>
<p>classes.put(cn.name, cn);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p><strong>return</strong> classes;</p>
<p>}</p>
<p>ClassNode getNode(<strong>byte</strong>[] bytes) {</p>
<p>ClassReader cr = <strong>new</strong> ClassReader(bytes);</p>
<p>ClassNode cn = <strong>new</strong> ClassNode();</p>
<p>try <strong>{</strong></p>
<p>cr.accept(cn, ClassReader.EXPAND_FRAMES);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>cr = <strong>null</strong>;</p>
<p>return <strong>cn;</strong></p>
<p>}</p>
<p>With these methods loading and changing a jar file becomes a simple
matter of changing ClassNodes in a map. In</p>
<p>this example we will replace all Strings in the jar with capitalized
ones using the Tree API.</p>
<p>File jarFile = <strong>new</strong> File("sample.jar");</p>
<p>Map nodes = loadClasses(jarFile);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 880</p>
<p>// Iterate ClassNodes</p>
<p><strong>for</strong> (ClassNode cn : nodes.values()){</p>
<p>// Iterate methods in class</p>
<p><strong>for</strong> (MethodNode mn : cn.methods){</p>
<p>// Iterate instructions in method</p>
<p><strong>for</strong> (AbstractInsnNode ain :
mn.instructions.toArray()){</p>
<p>// If the instruction is loading a constant value</p>
<p><strong>if</strong> (ain.getOpcode() == Opcodes.LDC){</p>
<p>// Cast current instruction to Ldc</p>
<p>// If the constant is a string then capitalize it.</p>
<p>LdcInsnNode ldc = (LdcInsnNode) ain;</p>
<p><strong>if</strong> (ldc.cst <strong>instanceof</strong> String){</p>
<p>ldc.cst = ldc.cst.toString().toUpperCase();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Now that all of the ClassNode's strings have been modified we need to
save the changes. In order to save the changes and have a working output
a few things have to be done:</p>
<p>Export ClassNodes to bytes</p>
<p><em>Load non-class jar entries</em> (Ex: Manifest.mf / other binary
resources in jar) <em>as bytes</em></p>
<p>Save all bytes to a new jar</p>
<p>From the last portion above, we'll create three methods.</p>
<p>processNodes(Map nodes)</p>
<p>loadNonClasses(File jarFile)</p>
<p>saveAsJar(Map outBytes, String fileName)</p>
<p>Usage:</p>
<p>Mapbyte[]&gt; out = process(nodes, <strong>new</strong> HashMap());
out.putAll(loadNonClassEntries(jarFile));</p>
<p>saveAsJar(out, "sample-edit.jar");</p>
<p>The methods used:</p>
<p><strong>static</strong> Mapbyte[]&gt; processNodes(Map nodes, Map
mappings) {</p>
<p>Mapbyte[]&gt; out = <strong>new</strong> HashMapbyte[]&gt;();</p>
<p>// Iterate nodes and add them to the map of &lt;Class names , Class
bytes&gt; // Using Compute_Frames ensures that stack-frames will be
re-calculated automatically <em><strong>for</strong> (ClassNode cn :
nodes.values()) {</em></p>
<p>ClassWriter cw = <strong>new</strong>
ClassWriter(ClassWriter.COMPUTE_FRAMES);</p>
<p>out.put(mappings.containsKey(cn.name) ?
mappings.get(cn.name).getNewName() : cn.name, cw.toByteArray());</p>
<p>}</p>
<p>return <strong>out;</strong></p>
<p>}</p>
<p><strong>static</strong> Mapbyte[]&gt; loadNonClasses(File jarFile)
<strong>throws</strong> IOException {</p>
<p>Mapbyte[]&gt; entries = <strong>new</strong> HashMapbyte[]&gt;();</p>
<p>ZipInputStream jis = <strong>new</strong>
ZipInputStream(<strong>new</strong> FileInputStream(jarFile)); ZipEntry
entry;</p>
<p>// Iterate all entries</p>
<p><strong>while</strong> ((entry = jis.getNextEntry()) !=
<strong>null</strong>) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 881</p>
<p><span id="try" class="anchor"></span>try <strong>{</strong></p>
<p>String name = entry.getName();</p>
<p><strong>if</strong> (!name.endsWith(".class") &amp;&amp;
!entry.isDirectory()) {</p>
<p>// Apache Commons - byte[] toByteArray(InputStream input) //</p>
<p>// Add each entry to the map &lt;Entry name , Entry bytes&gt;
<em><strong>byte</strong>[] bytes = IOUtils.toByteArray(jis);</em></p>
<p>entries.put(name, bytes);</p>
<p>}</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>e.printStackTrace();</p>
<p><strong>}</strong> finally <strong>{</strong></p>
<p>jis.closeEntry();</p>
<p>}</p>
<p>}</p>
<p>jis.close();</p>
<p><strong>return</strong> entries;</p>
<p>}</p>
<p><strong>static void</strong> saveAsJar(Mapbyte[]&gt; outBytes, String
fileName) {</p>
<p>try <strong>{</strong></p>
<p>// Create jar output stream</p>
<p>JarOutputStream out = <strong>new</strong>
JarOutputStream(<strong>new</strong> FileOutputStream(fileName)); <em>//
For each entry in the map, save the bytes</em></p>
<p><strong>for</strong> (String entry : outBytes.keySet()) {</p>
<p>// Appent class names to class entries</p>
<p>String ext = entry.contains(".") ? "" : ".class";</p>
<p>out.putNextEntry(<strong>new</strong> ZipEntry(entry + ext));</p>
<p>out.write(outBytes.get(entry));</p>
<p>out.closeEntry();</p>
<p>}</p>
<p>out.close();</p>
<p>} <strong>catch</strong> (IOException e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>That's it. All the changes will be saved to "sample-edit.jar".</p>
<p>Section 170.3: How to load a ClassNode as a Class</p>
<p>/**</p>
<p>* Load a class by from a ClassNode</p>
<p>*</p>
<p>* @param cn</p>
<p>* ClassNode to load</p>
<p>* @return</p>
<p>*/</p>
<p><strong>public static</strong> Class load(ClassNode cn) {</p>
<p>ClassWriter cw = <strong>new</strong>
ClassWriter(ClassWriter.COMPUTE_FRAMES);</p>
<p><strong>return new</strong>
ClassDefiner(ClassLoader.getSystemClassLoader()).get(cn.name.replace("/",
"."),</p>
<p>cw.toByteArray());</p>
<p>}</p>
<p>/**</p>
<p>* Classloader that loads a class from bytes.</p>
<p>*/</p>
<p><strong>static class</strong> ClassDefiner <strong>extends</strong>
ClassLoader {</p>
<p><strong>public</strong> ClassDefiner(ClassLoader parent) {</p>
<p><strong>super</strong>(parent);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 882</p>
<p><span id="public_Classbyte___bytes"
class="anchor"></span><strong>public</strong> Class get(String name,
<strong>byte</strong>[] bytes) {</p>
<p>Class c = defineClass(name, bytes, 0, bytes.length);</p>
<p>resolveClass(c);</p>
<p>return <strong>c;</strong></p>
<p>}</p>
<p>}</p>
<p>Section 170.4: How to rename classes in a jar file</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> Exception {</p>
<p>File jarFile = <strong>new</strong> File("Input.jar");</p>
<p>Map nodes = JarUtils.loadClasses(jarFile);</p>
<p>Mapbyte[]&gt; out = JarUtils.loadNonClassEntries(jarFile);</p>
<p>Map mappings = <strong>new</strong> HashMap();</p>
<p>mappings.put("me/example/ExampleClass",
"me/example/ExampleRenamed");</p>
<p>out.putAll(process(nodes, mappings));</p>
<p>JarUtils.saveAsJar(out, "Input-new.jar");</p>
<p>}</p>
<p><strong>static</strong> Mapbyte[]&gt; process(Map nodes, Map
mappings) {</p>
<p>Mapbyte[]&gt; out = <strong>new</strong> HashMapbyte[]&gt;();</p>
<p>Remapper mapper = <strong>new</strong> SimpleRemapper(mappings);</p>
<p><strong>for</strong> (ClassNode cn : nodes.values()) {</p>
<p>ClassWriter cw = <strong>new</strong>
ClassWriter(ClassWriter.COMPUTE_FRAMES);</p>
<p>ClassVisitor remapper = <strong>new</strong> ClassRemapper(cw,
mapper);</p>
<p>cn.accept(remapper);</p>
<p>out.put(mappings.containsKey(cn.name) ? mappings.get(cn.name) :
cn.name, cw.toByteArray());</p>
<p>}</p>
<p>return <strong>out;</strong></p>
<p>}</p>
<p>SimpleRemapper is an existing class in the ASM library. However it
only allows for class names to be changed. If you</p>
<p>wish to rename fields and methods you should create your own
implemenation of the Remapper class.</p>
<p>Section 170.5: Javassist Basic</p>
<p>Javassist is a bytecode instrumentation library that allows you to
modify bytecode injecting Java code that will be</p>
<p>converted to bytecode by Javassist and added to the instrumented
class/method at runtime.</p>
<p>Lets write the first transformer that actually take an hypothetical
class "com.my.to.be.instrumented.MyClass" and</p>
<p>add to the instructions of each method a log call.</p>
<p><strong>import</strong>
java.lang.instrument.ClassFileTransformer;</p>
<p><strong>import</strong>
java.lang.instrument.IllegalClassFormatException;
<strong>import</strong> java.security.ProtectionDomain;</p>
<p><strong>import</strong> javassist.ClassPool;</p>
<p><strong>import</strong> javassist.CtClass;</p>
<p><strong>import</strong> javassist.CtMethod;</p>
<p><strong>public class</strong> DynamicTransformer
<strong>implements</strong> ClassFileTransformer {</p>
<p><strong>public byte</strong>[] transform(ClassLoader loader, String
className, <strong>Class</strong> classBeingRedefined,</p>
<p>ProtectionDomain protectionDomain, <strong>byte</strong>[]
classfileBuffer) <strong>throws</strong></p>
<p>IllegalClassFormatException {</p>
<p><strong>byte</strong>[] byteCode = classfileBuffer;</p>
<p>// into the transformer will arrive every class loaded so we
filter</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 883</p>
<p>// to match only what we need</p>
<p><strong>if</strong>
(className.equals("com/my/to/be/instrumented/MyClass")) {</p>
<p>try <strong>{</strong></p>
<p>// retrive default Javassist class pool</p>
<p>ClassPool cp = ClassPool.getDefault();</p>
<p>// get from the class pool our class with this qualified name</p>
<p>CtClass cc = cp.get("com.my.to.be.instrumented.MyClass");</p>
<p>// get all the methods of the retrieved class</p>
<p>CtMethod[] methods = cc.getDeclaredMethods()</p>
<p><strong>for</strong>(CtMethod meth : methods) {</p>
<p>// The instrumentation code to be returned and injected
<em><strong>final</strong> StringBuffer buffer = <strong>new</strong>
StringBuffer();</em></p>
<p>String name = meth.getName();</p>
<p>// just print into the buffer a log for example</p>
<p>buffer.append("System.out.println(<strong>\"</strong>Method " + name
+ " executed<strong>\"</strong> );");</p>
<p>meth.insertBefore(buffer.toString())</p>
<p>}</p>
<p>// create the byteclode of the class</p>
<p>byteCode = cc.toBytecode();</p>
<p>// remove the CtClass from the ClassPool</p>
<p>cc.detach();</p>
<p>} <strong>catch</strong> (Exception ex) {</p>
<p>ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><strong>return</strong> byteCode;</p>
<p>}</p>
<p>}</p>
<p>Now in order to use this transformer (so that our JVM will call the
method transform on each class at load time) we</p>
<p>need to add this instrumentor this with an agent:</p>
<p><strong>import</strong> java.lang.instrument.Instrumentation;</p>
<p>public class <strong>EasyAgent {</strong></p>
<p><strong>public static void</strong> premain(String agentArgs,
Instrumentation inst) {</p>
<p>// registers the transformer</p>
<p>inst.addTransformer(<strong>new</strong> DynamicTransformer());</p>
<p>}</p>
<p>}</p>
<p>Last step to start our first instrumentor experiment is to actually
register this agent class to the JVM machine</p>
<p>execution. The easiest way to actually do it is to register it with
an option into the shell command:</p>
<p>java -javaagent:myAgent.jar MyJavaApplication</p>
<p>As we can see the agent/transformer project is added as a jar to the
execution of any application named</p>
<p>MyJavaApplication that is supposed to contain a class named
"com.my.to.be.instrumented.MyClass" to actually</p>
<p>execute our injected code.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 884</p>
<p><span id="Chapter_171__Disassembling_and"
class="anchor"></span>Chapter 171: Disassembling and</p>
<p>Decompiling</p>
<p>Name Description</p>
<p><strong>&lt;classes&gt;</strong> List of classes to disassemble. Can
be in either package1.package2.Classname format, <em>or</em></p>
<p>package1/package2/Classname format. Do <strong>not</strong> include
the .<strong>class</strong> extension.</p>
<p>-help , --help, -? Print this usage message</p>
<p>-version Version information</p>
<p>-v, -verbose Print additional information</p>
<p>-l Print line number and local variable tables</p>
<p>-<strong>public</strong> Show only public classes and members</p>
<p>-<strong>protected</strong> Show protected/public classes and
members</p>
<p>-<strong>package</strong> Show package/protected/public classes and
members (default)</p>
<p>-p, -<strong>private</strong> Show all classes and members</p>
<p>-c Disassemble the code</p>
<p>-s Print internal type signatures</p>
<p>-sysinfo Show system info (path, size, date, MD5 hash) of class being
processed</p>
<p>-constants Show final constants</p>
<p>-classpath Specify where to find user class files</p>
<p>-cp Specify where to find user class files</p>
<p>-bootclasspath Override location of bootstrap class files</p>
<p>Section 171.1: Viewing bytecode with javap</p>
<p>If you want to see the generated bytecode for a Java program, you can
use the provided javap command to view it.</p>
<p>Assuming that we have the following Java source file:</p>
<p><strong>package</strong> com.stackoverflow.documentation;</p>
<p><strong>import</strong> org.springframework.stereotype.Service;</p>
<p><strong>import</strong> java.io.IOException;</p>
<p><strong>import</strong> java.io.InputStream;</p>
<p><strong>import</strong> java.util.List;</p>
<p>@Service</p>
<p><strong>public class</strong> HelloWorldService {</p>
<p><strong>public void</strong> sayHello() {</p>
<p>System.out.println("Hello, World!");</p>
<p>}</p>
<p><strong>private</strong> Object[] pvtMethod(List strings) {</p>
<p><strong>return new</strong> Object[]{strings};</p>
<p>}</p>
<p><strong>protected</strong> String tryCatchResources(String filename)
<strong>throws</strong> IOException {</p>
<p><strong>try</strong> (InputStream inputStream =
getClass().getResourceAsStream(filename)) {</p>
<p><strong>byte</strong>[] bytes = <strong>new byte</strong>[8192];</p>
<p><strong>int</strong> read = inputStream.read(bytes);</p>
<p><strong>return new</strong> String(bytes, 0, read);</p>
<p>} <strong>catch</strong> (IOException | RuntimeException e) {</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 885</p>
<p>e.printStackTrace();</p>
<p>throw <strong>e;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>void</strong> stuff() {</p>
<p>System.out.println("stuff");</p>
<p>}</p>
<p>}</p>
<p>After compiling the source file, the most simple usage is:</p>
<p><strong>cd &lt;</strong>directory containing classes<strong>&gt;
(</strong>e.g. target<strong>/</strong>classes<strong>)</strong> javap
com<strong>/</strong>stackoverflow<strong>/</strong>documentation<strong>/</strong>SpringExample</p>
<p>Which produces the output</p>
<p>Compiled from "HelloWorldService.java"</p>
<p>public class com.stackoverflow.documentation.HelloWorldService {
public com.stackoverflow.documentation.HelloWorldService(); public void
sayHello();</p>
<p>protected java.lang.String tryCatchResources(java.lang.String) throws
java.io.IOException; void stuff();</p>
<p>}</p>
<p>This lists all non-private methods in the class, but that is not
particularly useful for most purposes. The following</p>
<p>command is a lot more useful:</p>
<p>javap -p -c -s -constants -l -v
com/stackoverflow/documentation/HelloWorldService</p>
<p>Which produces the output:</p>
<p>Classfile
/Users/pivotal/IdeaProjects/stackoverflow-spring-docs/target/classes/com/stackoverflow/documentation/HelloWorldService.class
Last modified Jul 22, 2016; size 2167 bytes</p>
<p>MD5 checksum 6e33b5c292ead21701906353b7f06330</p>
<p>Compiled from "HelloWorldService.java"</p>
<p>public class com.stackoverflow.documentation.HelloWorldService minor
version: 0</p>
<p>major version: 51</p>
<p>flags: ACC_PUBLIC, ACC_SUPER</p>
<p>Constant pool:</p>
<p>#1 = Methodref #5.#60 // java/lang/Object."":()V #2 = Fieldref
#61.#62 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #63 //
Hello, World! #4 = Methodref #64.#65 //
java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #66 //
java/lang/Object #6 = Methodref #5.#67 //
java/lang/Object.getClass:()Ljava/lang/Class; #7 = Methodref #68.#69
//</p>
<p>java/lang/Class.getResourceAsStream:(Ljava/lang/String;)Ljava/io/InputStream;
#8 = Methodref #70.#71 // java/io/InputStream.read:([B)I #9 = Class #72
// java/lang/String #10 = Methodref #9.#73 //
java/lang/String."":([BII)V #11 = Methodref #70.#74 //
java/io/InputStream.close:()V #12 = Class #75 // java/lang/Throwable #13
= Methodref #12.#76 //</p>
<p>java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V #14 =
Class #77 // java/io/IOException #15 = Class #78 //
java/lang/RuntimeException</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 886</p>
<p>#16 = Methodref #79.#80 // java/lang/Exception.printStackTrace:()V
#17 = String #55 // stuff</p>
<p>#18 = Class #81 // com/stackoverflow/documentation/HelloWorldService
#19 = Utf8</p>
<p>#20 = Utf8 ()V</p>
<p>#21 = Utf8 Code</p>
<p>#22 = Utf8 LineNumberTable</p>
<p>#23 = Utf8 LocalVariableTable</p>
<p>#24 = Utf8 this</p>
<p>#25 = Utf8 Lcom/stackoverflow/documentation/HelloWorldService; #26 =
Utf8 sayHello</p>
<p>#27 = Utf8 pvtMethod</p>
<p>#28 = Utf8 (Ljava/util/List;)[Ljava/lang/Object; #29 = Utf8
strings</p>
<p>#30 = Utf8 Ljava/util/List;</p>
<p>#31 = Utf8 LocalVariableTypeTable</p>
<p>#32 = Utf8 Ljava/util/List;</p>
<p>#33 = Utf8 Signature</p>
<p>#34 = Utf8 (Ljava/util/List;)[Ljava/lang/Object; #35 = Utf8
tryCatchResources</p>
<p>#36 = Utf8 (Ljava/lang/String;)Ljava/lang/String; #37 = Utf8
bytes</p>
<p>#38 = Utf8 [B</p>
<p>#39 = Utf8 read</p>
<p>#40 = Utf8 I</p>
<p>#41 = Utf8 inputStream</p>
<p>#42 = Utf8 Ljava/io/InputStream;</p>
<p>#43 = Utf8 e</p>
<p>#44 = Utf8 Ljava/lang/Exception;</p>
<p>#45 = Utf8 filename</p>
<p>#46 = Utf8 Ljava/lang/String;</p>
<p>#47 = Utf8 StackMapTable</p>
<p>#48 = Class #81 // com/stackoverflow/documentation/HelloWorldService
#49 = Class #72 // java/lang/String #50 = Class #82 //
java/io/InputStream #51 = Class #75 // java/lang/Throwable #52 = Class
#38 // "[B"</p>
<p>#53 = Class #83 // java/lang/Exception #54 = Utf8 Exceptions</p>
<p>#55 = Utf8 stuff</p>
<p>#56 = Utf8 SourceFile</p>
<p>#57 = Utf8 HelloWorldService.java</p>
<p>#58 = Utf8 RuntimeVisibleAnnotations #59 = Utf8
Lorg/springframework/stereotype/Service; #60 = NameAndType #19:#20 //
"":()V</p>
<p>#61 = Class #84 // java/lang/System #62 = NameAndType #85:#86 //
out:Ljava/io/PrintStream; #63 = Utf8 Hello, World!</p>
<p>#64 = Class #87 // java/io/PrintStream #65 = NameAndType #88:#89 //
println:(Ljava/lang/String;)V #66 = Utf8 java/lang/Object</p>
<p>#67 = NameAndType #90:#91 // getClass:()Ljava/lang/Class; #68 = Class
#92 // java/lang/Class #69 = NameAndType #93:#94 //</p>
<p>getResourceAsStream:(Ljava/lang/String;)Ljava/io/InputStream; #70 =
Class #82 // java/io/InputStream #71 = NameAndType #39:#95 // read:([B)I
#72 = Utf8 java/lang/String</p>
<p>#73 = NameAndType #19:#96 // "":([BII)V #74 = NameAndType #97:#20 //
close:()V #75 = Utf8 java/lang/Throwable</p>
<p>#76 = NameAndType #98:#99 // addSuppressed:(Ljava/lang/Throwable;)V
#77 = Utf8 java/io/IOException</p>
<p>#78 = Utf8 java/lang/RuntimeException</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 887</p>
<p>#79 = Class #83 // java/lang/Exception #80 = NameAndType #100:#20 //
printStackTrace:()V #81 = Utf8
com/stackoverflow/documentation/HelloWorldService #82 = Utf8
java/io/InputStream</p>
<p>#83 = Utf8 java/lang/Exception</p>
<p>#84 = Utf8 java/lang/System</p>
<p>#85 = Utf8 out</p>
<p>#86 = Utf8 Ljava/io/PrintStream;</p>
<p>#87 = Utf8 java/io/PrintStream</p>
<p>#88 = Utf8 println</p>
<p>#89 = Utf8 (Ljava/lang/String;)V</p>
<p>#90 = Utf8 getClass</p>
<p>#91 = Utf8 ()Ljava/lang/Class;</p>
<p>#92 = Utf8 java/lang/Class</p>
<p>#93 = Utf8 getResourceAsStream</p>
<p>#94 = Utf8 (Ljava/lang/String;)Ljava/io/InputStream; #95 = Utf8
([B)I</p>
<p>#96 = Utf8 ([BII)V</p>
<p>#97 = Utf8 close</p>
<p>#98 = Utf8 addSuppressed</p>
<p>#99 = Utf8 (Ljava/lang/Throwable;)V</p>
<p>#100 = Utf8 printStackTrace</p>
<p>{</p>
<p>public com.stackoverflow.documentation.HelloWorldService();
descriptor: ()V</p>
<p>flags: ACC_PUBLIC</p>
<p>Code:</p>
<p>stack=1, locals=1, args_size=1</p>
<p>0: aload_0</p>
<p>1: invokespecial #1 // Method java/lang/Object."":()V 4: return</p>
<p>LineNumberTable:</p>
<p>line 10: 0</p>
<p>LocalVariableTable:</p>
<p>Start Length Slot Name Signature</p>
<p>0 5 0 this Lcom/stackoverflow/documentation/HelloWorldService;</p>
<p>public void sayHello();</p>
<p>descriptor: ()V</p>
<p>flags: ACC_PUBLIC</p>
<p>Code:</p>
<p>stack=2, locals=1, args_size=1</p>
<p>0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc #3 // String Hello, World! 5: invokevirtual #4 // Method
java/io/PrintStream.println:(Ljava/lang/String;)V 8: return</p>
<p>LineNumberTable:</p>
<p>line 13: 0</p>
<p>line 14: 8</p>
<p>LocalVariableTable:</p>
<p>Start Length Slot Name Signature</p>
<p>0 9 0 this Lcom/stackoverflow/documentation/HelloWorldService;</p>
<p>private java.lang.Object[] pvtMethod(java.util.List); descriptor:
(Ljava/util/List;)[Ljava/lang/Object;</p>
<p>flags: ACC_PRIVATE</p>
<p>Code:</p>
<p>stack=4, locals=2, args_size=2</p>
<p>0: iconst_1</p>
<p>1: anewarray #5 // class java/lang/Object 4: dup</p>
<p>5: iconst_0</p>
<p>6: aload_1</p>
<p>7: aastore</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 888</p>
<p>8: areturn</p>
<p>LineNumberTable:</p>
<p>line 17: 0</p>
<p>LocalVariableTable:</p>
<p>Start Length Slot Name Signature</p>
<p>0 9 0 this Lcom/stackoverflow/documentation/HelloWorldService; 0 9 1
strings Ljava/util/List;</p>
<p>LocalVariableTypeTable:</p>
<p>Start Length Slot Name Signature</p>
<p>0 9 1 strings Ljava/util/List;</p>
<p>Signature: #34 // (Ljava/util/List;)[Ljava/lang/Object;</p>
<p>protected java.lang.String tryCatchResources(java.lang.String) throws
java.io.IOException; descriptor: (Ljava/lang/String;)Ljava/lang/String;
flags: ACC_PROTECTED</p>
<p>Code:</p>
<p>stack=5, locals=10, args_size=2</p>
<p>0: aload_0</p>
<p>1: invokevirtual #6 // Method
java/lang/Object.getClass:()Ljava/lang/Class; 4: aload_1</p>
<p>5: invokevirtual #7 // Method</p>
<p>java/lang/Class.getResourceAsStream:(Ljava/lang/String;)Ljava/io/InputStream;
8: astore_2</p>
<p>9: aconst_null</p>
<p>10: astore_3</p>
<p>11: sipush 8192</p>
<p>14: newarray byte</p>
<p>16: astore 4</p>
<p>18: aload_2</p>
<p>19: aload 4</p>
<p>21: invokevirtual #8 // Method java/io/InputStream.read:([B)I 24:
istore 5</p>
<p>26: new #9 // class java/lang/String 29: dup</p>
<p>30: aload 4</p>
<p>32: iconst_0</p>
<p>33: iload 5</p>
<p>35: invokespecial #10 // Method java/lang/String."":([BII)V 38:
astore 6</p>
<p>40: aload_2</p>
<p>41: ifnull 70</p>
<p>44: aload_3</p>
<p>45: ifnull 66</p>
<p>48: aload_2</p>
<p>49: invokevirtual #11 // Method java/io/InputStream.close:()V 52:
goto 70</p>
<p>55: astore 7</p>
<p>57: aload_3</p>
<p>58: aload 7</p>
<p>60: invokevirtual #13 // Method</p>
<p>java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V 63: goto
70</p>
<p>66: aload_2</p>
<p>67: invokevirtual #11 // Method java/io/InputStream.close:()V 70:
aload 6</p>
<p>72: areturn</p>
<p>73: astore 4</p>
<p>75: aload 4</p>
<p>77: astore_3</p>
<p>78: aload 4</p>
<p>80: athrow</p>
<p>81: astore 8</p>
<p>83: aload_2</p>
<p>84: ifnull 113</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 889</p>
<p>87: aload_3</p>
<p>88: ifnull 109</p>
<p>91: aload_2</p>
<p>92: invokevirtual #11 // Method java/io/InputStream.close:()V 95:
goto 113</p>
<p>98: astore 9</p>
<p>100: aload_3</p>
<p>101: aload 9</p>
<p>103: invokevirtual #13 // Method</p>
<p>java/lang/Throwable.addSuppressed:(Ljava/lang/Throwable;)V 106: goto
113</p>
<p>109: aload_2</p>
<p>110: invokevirtual #11 // Method java/io/InputStream.close:()V 113:
aload 8</p>
<p>115: athrow</p>
<p>116: astore_2</p>
<p>117: aload_2</p>
<p>118: invokevirtual #16 // Method
java/lang/Exception.printStackTrace:()V 121: aload_2</p>
<p>122: athrow</p>
<p>Exception table:</p>
<p>from to target type</p>
<p>48 52 55 Class java/lang/Throwable</p>
<p>11 40 73 Class java/lang/Throwable</p>
<p>11 40 81 any</p>
<p>91 95 98 Class java/lang/Throwable</p>
<p>73 83 81 any</p>
<p>0 70 116 Class java/io/IOException</p>
<p>0 70 116 Class java/lang/RuntimeException</p>
<p>73 116 116 Class java/io/IOException</p>
<p>73 116 116 Class java/lang/RuntimeException</p>
<p>LineNumberTable:</p>
<p>line 21: 0</p>
<p>line 22: 11</p>
<p>line 23: 18</p>
<p>line 24: 26</p>
<p>line 25: 40</p>
<p>line 21: 73</p>
<p>line 25: 81</p>
<p>line 26: 117</p>
<p>line 27: 121</p>
<p>LocalVariableTable:</p>
<p>Start Length Slot Name Signature</p>
<p>18 55 4 bytes [B</p>
<p>26 47 5 read I</p>
<p>9 107 2 inputStream Ljava/io/InputStream; 117 6 2 e
Ljava/lang/Exception;</p>
<p>0 123 0 this Lcom/stackoverflow/documentation/HelloWorldService; 0
123 1 filename Ljava/lang/String;</p>
<p>StackMapTable: number_of_entries = 9</p>
<p>frame_type = 255 /* full_frame */</p>
<p>offset_delta = 55</p>
<p>locals = [ class com/stackoverflow/documentation/HelloWorldService,
class java/lang/String, class java/io/InputStream, class
java/lang/Throwable, class "[B", int, class java/lang/String ] stack = [
class java/lang/Throwable ]</p>
<p>frame_type = 10 /* same */</p>
<p>frame_type = 3 /* same */</p>
<p>frame_type = 255 /* full_frame */</p>
<p>offset_delta = 2</p>
<p>locals = [ class com/stackoverflow/documentation/HelloWorldService,
class java/lang/String, class java/io/InputStream, class
java/lang/Throwable ]</p>
<p>stack = [ class java/lang/Throwable ]</p>
<p>frame_type = 71 /* same_locals_1_stack_item */</p>
<p>stack = [ class java/lang/Throwable ]</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 890</p>
<p>frame_type = 255 /* full_frame */</p>
<p>offset_delta = 16</p>
<p>locals = [ class com/stackoverflow/documentation/HelloWorldService,
class java/lang/String, class java/io/InputStream, class
java/lang/Throwable, top, top, top, top, class java/lang/Throwable ]
stack = [ class java/lang/Throwable ]</p>
<p>frame_type = 10 /* same */</p>
<p>frame_type = 3 /* same */</p>
<p>frame_type = 255 /* full_frame */</p>
<p>offset_delta = 2</p>
<p>locals = [ class com/stackoverflow/documentation/HelloWorldService,
class java/lang/String ] stack = [ class java/lang/Exception ]</p>
<p>Exceptions:</p>
<p>throws java.io.IOException</p>
<p>void stuff();</p>
<p>descriptor: ()V</p>
<p>flags:</p>
<p>Code:</p>
<p>stack=2, locals=1, args_size=1</p>
<p>0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;
3: ldc #17 // String stuff 5: invokevirtual #4 // Method
java/io/PrintStream.println:(Ljava/lang/String;)V 8: return</p>
<p>LineNumberTable:</p>
<p>line 32: 0</p>
<p>line 33: 8</p>
<p>LocalVariableTable:</p>
<p>Start Length Slot Name Signature</p>
<p>0 9 0 this Lcom/stackoverflow/documentation/HelloWorldService; }</p>
<p>SourceFile: "HelloWorldService.java"</p>
<p>RuntimeVisibleAnnotations:</p>
<p>0: #59()</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 891</p>
<p><span id="Chapter_172__JMX_1" class="anchor"></span>Chapter 172:
JMX</p>
<p>The JMX technology provides the tools for building distributed,
Web-based, modular and dynamic solutions for</p>
<p>managing and monitoring devices, applications, and service-driven
networks. By design, this standard is suitable for adapting legacy
systems, implementing new management and monitoring solutions, and
plugging into those of the</p>
<p>future.</p>
<p>Section 172.1: Simple example with Platform MBean Server</p>
<p>Let's say we have some server that registers new users and greets
them with some message. And we want to</p>
<p>monitor this server and change some of it's parameters.</p>
<p>First, we need an interface with our monitoring and control
methods</p>
<p><strong>public interface</strong> UserCounterMBean {</p>
<p><strong>long</strong> getSleepTime();</p>
<p><strong>void</strong> setSleepTime(<strong>long</strong>
sleepTime);</p>
<p><strong>int</strong> getUserCount();</p>
<p><strong>void</strong> setUserCount(<strong>int</strong>
userCount);</p>
<p>String getGreetingString();</p>
<p><strong>void</strong> setGreetingString(String greetingString);</p>
<p><strong>void</strong> stop();</p>
<p>}</p>
<p>And some simple implementation that will let us see how it's working
and how we affect it</p>
<p><strong>public class</strong> UserCounter <strong>implements</strong>
UserCounterMBean, Runnable {</p>
<p><strong>private</strong> AtomicLong sleepTime = <strong>new</strong>
AtomicLong(10000); <strong>private</strong> AtomicInteger userCount =
<strong>new</strong> AtomicInteger(0); <strong>private</strong>
AtomicReference greetingString = <strong>new</strong>
AtomicReference&lt;&gt;("welcome"); <strong>private</strong>
AtomicBoolean interrupted = <strong>new</strong>
AtomicBoolean(<strong>false</strong>);</p>
<p>@Override</p>
<p><strong>public long</strong> getSleepTime() {</p>
<p><strong>return</strong> sleepTime.get();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> setSleepTime(<strong>long</strong>
sleepTime) {</p>
<p><strong>this</strong>.sleepTime.set(sleepTime);</p>
<p>}</p>
<p>@Override</p>
<p><strong>public int</strong> getUserCount() {</p>
<p><strong>return</strong> userCount.get();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> setUserCount(<strong>int</strong>
userCount) {</p>
<p><strong>this</strong>.userCount.set(userCount);</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 892</p>
<p>@Override</p>
<p><strong>public</strong> String getGreetingString() {</p>
<p><strong>return</strong> greetingString.get();</p>
<p>}</p>
<p>@Override</p>
<p><strong>public void</strong> setGreetingString(String greetingString)
{</p>
<p><strong>this</strong>.greetingString.set(greetingString);</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>stop() {</strong></p>
<p><strong>this</strong>.interrupted.set(<strong>true</strong>);</p>
<p>}</p>
<p>@Override</p>
<p>public void <strong>run() {</strong></p>
<p><strong>while</strong> (!interrupted.get()) {</p>
<p>try <strong>{</strong></p>
<p>System.out.printf("User %d, %s%n", userCount.incrementAndGet(),</p>
<p>greetingString.get());</p>
<p>Thread.sleep(sleepTime.get());</p>
<p>} <strong>catch</strong> (InterruptedException ignored) {</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>For simple example with local or remote management, we need to
register our MBean:</p>
<p><strong>import</strong>
javax.management.InstanceAlreadyExistsException; <strong>import</strong>
javax.management.MBeanRegistrationException; <strong>import</strong>
javax.management.MBeanServer;</p>
<p><strong>import</strong>
javax.management.MalformedObjectNameException; <strong>import</strong>
javax.management.NotCompliantMBeanException; <strong>import</strong>
javax.management.ObjectName;</p>
<p><strong>import</strong> java.lang.management.ManagementFactory;</p>
<p>public class <strong>Main {</strong></p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> MalformedObjectNameException,</p>
<p>NotCompliantMBeanException, InstanceAlreadyExistsException,
MBeanRegistrationException, InterruptedException {</p>
<p><strong>final</strong> UserCounter userCounter = <strong>new</strong>
UserCounter();</p>
<p><strong>final</strong> MBeanServer mBeanServer =
ManagementFactory.getPlatformMBeanServer(); <strong>final</strong>
ObjectName objectName = <strong>new</strong>
ObjectName("ServerManager:type=UserCounter");</p>
<p>mBeanServer.registerMBean(userCounter, objectName);</p>
<p><strong>final</strong> Thread thread = <strong>new</strong>
Thread(userCounter);</p>
<p>thread.start();</p>
<p>thread.join();</p>
<p>}</p>
<p>}</p>
<p>After that we can run our application and connect to it via jConsole,
which can be found in your $JAVA_HOME/bin directory. First, we need to
find our local java process with our application</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 893</p>
<p><img src="media/index-918_1.jpeg"
style="width:4.91667in;height:5.01389in" alt="index-918_1.jpg" /></p>
<p>then switch to MBeans tab and find that MBean that we used in our
Main class as an ObjectName (in the example</p>
<p>above it's ServerManager). In Attributes section we can see out
attributes. If you specified get method only,</p>
<p>attribute will be readable but not writeable. If you specified both
get and set methods, attribute would be readable and writeable.</p>
<p><img src="media/index-918_2.jpeg"
style="width:6.5in;height:3.45833in" alt="index-918_2.jpg" /></p>
<p>Specified methods can be invoked in Operations section.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 894</p>
<p><img src="media/index-919_1.jpeg"
style="width:6.5in;height:3.41667in" alt="index-919_1.jpg" /></p>
<p>If you want to be able to use remote management, you will need
additional JVM parameters, like:</p>
<p>-Dcom.sun.management.jmxremote=<strong>true</strong> <em>//true by
default</em>-Dcom.sun.management.jmxremote.port=36006</p>
<p>-Dcom.sun.management.jmxremote.authenticate=<strong>false</strong></p>
<p>-Dcom.sun.management.jmxremote.ssl=<strong>false</strong></p>
<p>These parameters can be found in <a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html">Chapter
2 of JMX guides</a>. After that you will be able to connect to your</p>
<p>application via jConsole remotely with jconsole host:port or with
specifying host:port or
service:jmx:rmi:<em>///jndi/rmi://hostName:portNum/jmxrmi</em> in
jConsole GUI.</p>
<p>Useful links:</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/overview.html">JMX
guides</a></p>
<p><a
href="http://www.oracle.com/us/technologies/java/best-practices-jsp-136021.html">JMX
Best practices</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 895</p>
<p><span id="Chapter_173__Java_Virtual_Machin_1"
class="anchor"></span>Chapter 173: Java Virtual Machine (JVM)</p>
<p>Section 173.1: These are the basics</p>
<p>JVM is an <strong>abstract computing machine</strong> or
<strong>Virtual machine</strong> that resides in your RAM. It has a
platform-</p>
<p>independent execution environment that interprets Java bytecode into
native machine code. (Javac is Java Compiler</p>
<p>which compiles your Java code into Bytecode)</p>
<p>Java program will be running inside the JVM which is then mapped onto
the underlying physical machine. It is one of programming tool in
JDK.</p>
<p>(<em>Byte code</em> is platform-independent code which is run on
every platform and <em>Machine code</em> is platform-specific code which
is run in only specific platform such as windows or linux; it depend on
execution.)</p>
<p>Some of the components:</p>
<p>Class Loder - load the .class file into RAM.</p>
<p>Bytecode verifier - check whether there are any access restriction
violations in your code. Execution engine - convert the byte code into
executable machine code.</p>
<p>JIT(just in time) - JIT is part of JVM which used to improves the
performance of JVM.It will dynamically compile or translate java
bytecode into native machine code during execution time.</p>
<p>(Edited)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 896</p>
<p><span id="Chapter_174__XJC_1" class="anchor"></span>Chapter 174:
XJC</p>
<p>Parameter Details</p>
<p>schema file The xsd schema file to convert to java</p>
<p><a
href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/xjc.html">XJC
is a Java SE tool that compiles an XML schema file into fully annotated
Java classes.</a></p>
<p>It is distributed within the JDK package and is located at /bin/xjc
path.</p>
<p>Section 174.1: Generating Java code from simple XSD file</p>
<p>XSD schema (schema.xsd)</p>
<p>The following xml schema (xsd) defines a list of users with
attributes name and reputation.</p>
<p><strong>&lt;?xml</strong> version="1.0"<strong>?&gt;</strong></p>
<p><strong>&lt;xs:schema</strong> version="1.0"</p>
<p>xmlns:xs="http://www.w3.org/2001/XMLSchema"</p>
<p>xmlns:ns="http://www.stackoverflow.com/users"</p>
<p>elementFormDefault="qualified"</p>
<p>targetNamespace="http://www.stackoverflow.com/users"<strong>&gt;</strong></p>
<p><strong>&lt;xs:element</strong> name="users"
type="ns:Users"<strong>/&gt;</strong></p>
<p>&lt;xs:complexType <strong>name="Users"</strong>&gt;</p>
<p>&lt;xs:sequence&gt;</p>
<p><strong>&lt;xs:element</strong> type="ns:User" name="user"
minOccurs="0" maxOccurs="unbounded"<strong>/&gt;</strong></p>
<p>&lt;/xs:sequence&gt;</p>
<p>&lt;/xs:complexType&gt;</p>
<p>&lt;xs:complexType <strong>name="User"</strong>&gt;</p>
<p><strong>&lt;xs:attribute</strong> name="name" use="required"
type="xs:string"<strong>/&gt; &lt;xs:attribute</strong>
name="reputation" use="required"<strong>&gt;</strong></p>
<p>&lt;xs:simpleType&gt;</p>
<p>&lt;xs:restriction <strong>base="xs:int"</strong>&gt;</p>
<p>&lt;xs:minInclusive <strong>value="1"</strong>/&gt;</p>
<p>&lt;/xs:restriction&gt;</p>
<p>&lt;/xs:simpleType&gt;</p>
<p>&lt;/xs:attribute&gt;</p>
<p>&lt;/xs:complexType&gt;</p>
<p>&lt;/xs:schema&gt;</p>
<p>Using xjc</p>
<p>This requires the path to the xjc tool (JDK binaries) to be in the OS
path variable.</p>
<p>The code generation can be started using</p>
<p>xjc schema.xsd</p>
<p>This will generate java files in the working directory.</p>
<p>Result files</p>
<p>There will be some additional comments, but basically the java files
generated look like this:</p>
<p><strong>package</strong> com.stackoverflow.users;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 897</p>
<p><strong>import</strong> java.util.ArrayList;</p>
<p><strong>import</strong> java.util.List;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlAccessType;</p>
<p><strong>import</strong>
javax.xml.bind.annotation.XmlAccessorType;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlType;</p>
<p>@XmlAccessorType(XmlAccessType.FIELD)</p>
<p>@XmlType(name = "Users", propOrder = {</p>
<p>"user"</p>
<p>})</p>
<p>public class <strong>Users {</strong></p>
<p><strong>protected</strong> List user;</p>
<p><strong>public</strong> List getUser() {</p>
<p><strong>if</strong> (user == <strong>null</strong>) {</p>
<p>user = <strong>new</strong> ArrayList();</p>
<p>}</p>
<p>return this<strong>.user;</strong></p>
<p>}</p>
<p>}</p>
<p><strong>package</strong> com.stackoverflow.users;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlAccessType;</p>
<p><strong>import</strong>
javax.xml.bind.annotation.XmlAccessorType;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlAttribute;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlType;</p>
<p>@XmlAccessorType(XmlAccessType.FIELD)</p>
<p>@XmlType(name = "User")</p>
<p>public class <strong>User {</strong></p>
<p>@XmlAttribute(name = "name", required = <strong>true</strong>)</p>
<p><strong>protected</strong> String name;</p>
<p>@XmlAttribute(name = "reputation", required =
<strong>true</strong>)</p>
<p>protected int <strong>reputation;</strong></p>
<p><strong>public</strong> String getName() {</p>
<p>return <strong>name;</strong></p>
<p>}</p>
<p><strong>public void</strong> setName(String value) {</p>
<p><strong>this</strong>.name = value;</p>
<p>}</p>
<p><strong>public int</strong> getReputation() {</p>
<p><strong>return</strong> reputation;</p>
<p>}</p>
<p><strong>public void</strong> setReputation(<strong>int</strong>
value) {</p>
<p><strong>this</strong>.reputation = value;</p>
<p>}</p>
<p>}</p>
<p><strong>package</strong> com.stackoverflow.users;</p>
<p><strong>import</strong> javax.xml.bind.JAXBElement;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlElementDecl;</p>
<p><strong>import</strong> javax.xml.bind.annotation.XmlRegistry;</p>
<p><strong>import</strong> javax.xml.namespace.QName;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 898</p>
<p>@XmlRegistry</p>
<p><strong>public class</strong> ObjectFactory {</p>
<p><strong>private final static</strong> QName _Users_QNAME =
<strong>new</strong> QName("http://www.stackoverflow.com/users",</p>
<p>"users");</p>
<p><strong>public</strong> ObjectFactory() {</p>
<p>}</p>
<p><strong>public</strong> Users createUsers() {</p>
<p>return new <strong>Users();</strong></p>
<p>}</p>
<p><strong>public</strong> User createUser() {</p>
<p>return new <strong>User();</strong></p>
<p>}</p>
<p>@XmlElementDecl(namespace = "http://www.stackoverflow.com/users",
name = "users")</p>
<p><strong>public</strong> JAXBElement createUsers(Users value) {</p>
<p><strong>return new</strong> JAXBElement(_Users_QNAME,
Users.<strong>class</strong>, <strong>null</strong>, value);</p>
<p>}</p>
<p>}</p>
<p>package-info.java</p>
<p>@javax.xml.bind.annotation.XmlSchema(namespace =
"http://www.stackoverflow.com/users", elementFormDefault =
javax.xml.bind.annotation.XmlNsForm.QUALIFIED) <strong>package</strong>
com.stackoverflow.users;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 899</p>
<p><span id="Chapter_175__JVM_Flags_1" class="anchor"></span>Chapter
175: JVM Flags</p>
<p>Section 175.1: -XXaggressive</p>
<p>-XXaggressive is a collection of configurations that make the JVM
perform at a high speed and reach a stable state as soon as possible. To
achieve this goal, the JVM uses more internal resources at startup;
however, it requires less</p>
<p>adaptive optimization once the goal is reached. We recommend that you
use this option for long-running, memory-intensive applications that
work alone.</p>
<p>Usage:</p>
<p>-XXaggressive:</p>
<p>&lt;param&gt; Description</p>
<p>opt Schedules adaptive optimizations earlier and enables new
optimizations, which are expected to be the</p>
<p>default in future releases.</p>
<p>Configures the memory system for memory-intensive workloads and sets
an expectation to enable large</p>
<p>memory amounts of memory resources to ensure high throughput. JRockit
JVM will also use large pages, if</p>
<p>available.</p>
<p>Section 175.2: -XXallocClearChunks</p>
<p>This option allows you to clear a TLA for references and values at
TLA allocation time and pre-fetch the next chunk. When an integer, a
reference, or anything else is declared, it has a default value of 0 or
null (depending upon type).</p>
<p>At the appropriate time, you will need to clear these references and
values to free the memory on the heap so Java can use- or reuse- it. You
can do either when the object is allocated or, by using this option,
when you request a</p>
<p>new TLA.</p>
<p>Usage:</p>
<p>-XXallocClearChunks</p>
<p>-XXallocClearChunks=&lt;<strong>true</strong> | false&gt;</p>
<p>The above is a boolean option and is generally recommended on IA64
systems; ultimately, its use depends upon</p>
<p>the application. If you want to set the size of chunks cleared,
combine this option with -XXallocClearChunkSize. If you use this flag
but do not specify a boolean value, the default is
<strong>true</strong>.</p>
<p>Section 175.3: -XXallocClearChunkSize</p>
<p>When used with -XXallocClearChunkSize, this option sets the size of
the chunks to be cleared. If this flag is used</p>
<p>but no value is specified, the default is 512 bytes.</p>
<p>Usage:</p>
<p>-XXallocClearChunks -XXallocClearChunkSize=[k|K][m|M][g|G]</p>
<p>Section 175.4: -XXcallProfiling</p>
<p>This option enables the use of call profiling for code optimizations.
Profiling records useful runtime statistics</p>
<p>specific to the application and can—in many cases—increase
performance because JVM can then act on those</p>
<p>statistics.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 900</p>
<p><span id="Note__This_option_is_supported_w"
class="anchor"></span>Note: This option is supported with the JRockit
JVM R27.3.0 and later version. It may become default in future
versions.</p>
<p>Usage:</p>
<p>java -XXcallProfiling myApp</p>
<p>This option is disabled by default. You must enable it to use it.</p>
<p>Section 175.5: -XXdisableFatSpin</p>
<p>This option disables the fat lock spin code in Java, allowing threads
that block trying to acquire a fat lock go to sleep directly.</p>
<p>Objects in Java become a lock as soon as any thread enters a
synchronized block on that object. All locks are held (that is, stayed
locked) until released by the locking thread. If the lock is not going
to be released very fast, it can be</p>
<p>inflated to a “fat lock.” “Spinning” occurs when a thread that wants
a specific lock continuously checks that lock to</p>
<p>see if it is still taken, spinning in a tight loop as it makes the
check. Spinning against a fat lock is generally beneficial although, in
some instances, it can be expensive and might affect performance.
-XXdisableFatSpin allows you to</p>
<p>turn off spinning against a fat lock and eliminate the potential
performance hit.</p>
<p>Usage:</p>
<p>-XXdisableFatSpin</p>
<p>Section 175.6: -XXdisableGCHeuristics</p>
<p>This option disables the garbage collector strategy changes.
Compaction heuristics and nursery size heuristics are</p>
<p>not affected by this option. By default, the garbage collection
heuristics are enabled.</p>
<p>Usage:</p>
<p>-XXdisableFatSpin</p>
<p>Section 175.7: -XXdumpSize</p>
<p>This option causes a dump file to be generated and allows you to
specify the relative size of that file (that is, small, medium, or
large).</p>
<p>Usage:</p>
<p>-XXdumpsize:</p>
<p>&lt;size&gt; Description</p>
<p>none Does not generate a dump file.</p>
<p>On Windows, a small dump file is generated (on Linux a full core dump
is generated). A small dump only</p>
<p>small include the thread stacks including their traces and very
little else. This was the default in the JRockit JVM</p>
<p>8.1 with service packs 1 and 2, as well as 7.0 with service pack 3
and higher).</p>
<p>normal Causes a normal dump to be generated on all platforms. This
dump file includes all memory except the</p>
<p>java heap. This is the default value for the JRockit JVM 1.4.2 and
later.</p>
<p>large Includes everything that is in memory, including the Java heap.
This option makes -XXdumpSize equivalent</p>
<p>to -XXdumpFullState.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 901</p>
<p><span id="Section_175_8___XXexitOnOutOfMem"
class="anchor"></span>Section 175.8: -XXexitOnOutOfMemory</p>
<p>This option makes JRockit JVM exit on the first occurrence of an out
of memory error. It can be used if you prefer</p>
<p>restarting an instance of JRockit JVM rather than handling out of
memory errors. Enter this command at startup to</p>
<p>force JRockit JVM to exit on the first occurrence of an out of memory
error.</p>
<p>Usage:</p>
<p>-XXexitOnOutOfMemory</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 902</p>
<p><span id="Chapter_176__JVM_Tool_Interface_1"
class="anchor"></span>Chapter 176: JVM Tool Interface</p>
<p>Section 176.1: Iterate over objects reachable from object</p>
<p>(Heap 1.0)</p>
<p>#include</p>
<p>#include</p>
<p>#include "agent_util.hpp"</p>
<p>//this file can be found in Java SE Development Kit 8u101 Demos and
Samples //see
http://download.oracle.com/otn-pub/java/jdk/8u101-b13-demos/jdk-8u101-windows-x64-demos.zip
//jdk1.8.0_101.zip!\demo\jvmti\versionCheck\src\agent_util.h</p>
<p>/*</p>
<p>* Struct used for jvmti-&gt;SetTag(object, &lt;pointer to tag&gt;); *
http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#SetTag
*</p>
<p>*/</p>
<p>typedef struct Tag</p>
<p>{</p>
<p>jlong referrer_tag;</p>
<p>jlong size;</p>
<p>char* classSignature;</p>
<p>jint hashCode;</p>
<p>} Tag;</p>
<p>/*</p>
<p>* Utility function: jlong -&gt; Tag*</p>
<p>*/</p>
<p>static Tag* pointerToTag(jlong tag_ptr)</p>
<p>{</p>
<p>if (tag_ptr == 0)</p>
<p>{</p>
<p>return new Tag();</p>
<p>}</p>
<p>return (Tag*)(ptrdiff_t)(void*)tag_ptr;</p>
<p>}</p>
<p>/*</p>
<p>* Utility function: Tag* -&gt; jlong</p>
<p>*/</p>
<p>static jlong tagToPointer(Tag* tag)</p>
<p>{</p>
<p>return (jlong)(ptrdiff_t)(void*)tag;</p>
<p>}</p>
<p>/*</p>
<p>* Heap 1.0 Callback</p>
<p>*
http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#jvmtiObjectReferenceCallback
*/</p>
<p>static jvmtiIterationControl JNICALL
heabObjectReferencesCallback(</p>
<p>jvmtiObjectReferenceKind reference_kind,</p>
<p>jlong class_tag,</p>
<p>jlong size,</p>
<p>jlong* tag_ptr,</p>
<p>jlong referrer_tag,</p>
<p>jint referrer_index,</p>
<p>void* user_data)</p>
<p>{</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 903</p>
<p>//iterate only over reference field</p>
<p>if (reference_kind != JVMTI_HEAP_REFERENCE_FIELD)</p>
<p>{</p>
<p>return JVMTI_ITERATION_IGNORE;</p>
<p>}</p>
<p>auto tag_ptr_list = (std::vector*)(ptrdiff_t)(void*)user_data;
//create and assign tag</p>
<p>auto t = pointerToTag(*tag_ptr);</p>
<p>t-&gt;referrer_tag = referrer_tag;</p>
<p>t-&gt;size = size;</p>
<p>*tag_ptr = tagToPointer(t);</p>
<p>//collect tag</p>
<p>(*tag_ptr_list).push_back(*tag_ptr);</p>
<p>return JVMTI_ITERATION_CONTINUE;</p>
<p>}</p>
<p>/*</p>
<p>* Main function for demonstration of Iterate Over Objects Reachable
From Object *</p>
<p>http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#IterateOverObjectsReachableFromObject
*</p>
<p>*/</p>
<p>void iterateOverObjectHeapReferences(jvmtiEnv* jvmti, JNIEnv* env,
jobject object) {</p>
<p>std::vector tag_ptr_list;</p>
<p>auto t = new Tag();</p>
<p>jvmti-&gt;SetTag(object, tagToPointer(t));</p>
<p>tag_ptr_list.push_back(tagToPointer(t));</p>
<p>stdout_message("tag list size before call callback:
%d<strong>\n</strong>", tag_ptr_list.size());</p>
<p>/*</p>
<p>* Call Callback for every reachable object reference</p>
<p>* see</p>
<p>http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#IterateOverObjectsReachableFromObject</p>
<p>*/</p>
<p>jvmti-&gt;IterateOverObjectsReachableFromObject(object,
&amp;heabObjectReferencesCallback, (void*)&amp;tag_ptr_list);</p>
<p>stdout_message("tag list size after call callback:
%d<strong>\n</strong>", tag_ptr_list.size());</p>
<p>if (tag_ptr_list.size() &gt; 0)</p>
<p>{</p>
<p>jint found_count = 0;</p>
<p>jlong* tags = &amp;tag_ptr_list[0];</p>
<p>jobject* found_objects;</p>
<p>jlong* found_tags;</p>
<p>/*</p>
<p>* collect all tagged object (via *tag_ptr = pointer to tag )</p>
<p>* see
http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#GetObjectsWithTags</p>
<p>*/</p>
<p>jvmti-&gt;GetObjectsWithTags(tag_ptr_list.size(), tags,
&amp;found_count, &amp;found_objects, &amp;found_tags);</p>
<p>stdout_message("found %d objects<strong>\n</strong>",
found_count);</p>
<p>for (auto i = 0; i &lt; found_count; ++i)</p>
<p>{</p>
<p>jobject found_object = found_objects[i];</p>
<p>char* classSignature;</p>
<p>jclass found_object_class = env-&gt;GetObjectClass(found_object);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 904</p>
<p><span id="_60" class="anchor"></span>/*</p>
<p>* Get string representation of found_object_class</p>
<p>* see
http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#GetClassSignature</p>
<p>*/</p>
<p>jvmti-&gt;GetClassSignature(found_object_class, &amp;classSignature,
nullptr);</p>
<p>jint hashCode;</p>
<p>/*</p>
<p>* Getting hash code for found_object</p>
<p>* see
http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#GetObjectHashCode</p>
<p>*/</p>
<p>jvmti-&gt;GetObjectHashCode(found_object, &amp;hashCode);</p>
<p>//save all it in Tag</p>
<p>Tag* t = pointerToTag(found_tags[i]);</p>
<p>t-&gt;classSignature = classSignature;</p>
<p>t-&gt;hashCode = hashCode;</p>
<p>}</p>
<p>//print all saved information</p>
<p>for (auto i = 0; i &lt; found_count; ++i)</p>
<p>{</p>
<p>auto t = pointerToTag(found_tags[i]);</p>
<p>auto rt = pointerToTag(t-&gt;referrer_tag);</p>
<p>if (t-&gt;referrer_tag != 0)</p>
<p>{</p>
<p>stdout_message("referrer object %s#%d --&gt; object %s#%d (size:
%2d)<strong>\n</strong>",</p>
<p>rt-&gt;classSignature, rt-&gt;hashCode, t-&gt;classSignature,
t-&gt;hashCode, t-&gt;size);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Section 176.2: Get JVMTI environment</p>
<p>Inside Agent_OnLoad method:</p>
<p>jvmtiEnv* jvmti;</p>
<p>/* Get JVMTI environment */</p>
<p>vm-&gt;GetEnv(reinterpret_cast&lt;<strong>void</strong>
**&gt;(&amp;jvmti), JVMTI_VERSION);</p>
<p>Section 176.3: Example of initialization inside of</p>
<p>Agent_OnLoad method</p>
<p>/* Callback for JVMTI_EVENT_VM_INIT */</p>
<p><strong>static void</strong> JNICALL vm_init(jvmtiEnv* jvmti, JNIEnv*
env, jthread thread) {</p>
<p>jint runtime_version;</p>
<p>jvmti-&gt;GetVersionNumber(&amp;runtime_version);</p>
<p>stdout_message("JVMTI Version: %d<strong>\n</strong>",
runtime_verision); }</p>
<p>/* Agent_OnLoad() is called first, we prepare for a VM_INIT event
here. */ <em>JNIEXPORT jint JNICALL</em></p>
<p>Agent_OnLoad(JavaVM* vm, <strong>char</strong>* options,
<strong>void</strong>* reserved) {</p>
<p>jint rc;</p>
<p>jvmtiEventCallbacks callbacks;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 905</p>
<p>jvmtiCapabilities capabilities;</p>
<p>jvmtiEnv* jvmti;</p>
<p>/* Get JVMTI environment */</p>
<p>rc = vm-&gt;GetEnv(reinterpret_cast&lt;<strong>void</strong>
**&gt;(&amp;jvmti), JVMTI_VERSION);</p>
<p><strong>if</strong> (rc != JNI_OK)</p>
<p>{</p>
<p>return<strong>-1;</strong></p>
<p>}</p>
<p>/* Immediately after getting the jvmtiEnv* we need to ask for the</p>
<p>* capabilities this agent will need.</p>
<p>*/</p>
<p>jvmti-&gt;GetCapabilities(&amp;capabilities);</p>
<p>capabilities.can_tag_objects = 1;</p>
<p>jvmti-&gt;AddCapabilities(&amp;capabilities);</p>
<p>/* Set callbacks and enable event notifications */</p>
<p>memset(&amp;callbacks, 0, sizeof(callbacks));</p>
<p>callbacks.VMInit = &amp;vm_init;</p>
<p>jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));</p>
<p>jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT,
nullptr);</p>
<p><strong>return</strong> JNI_OK;</p>
<p>}</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 906</p>
<p><span id="Chapter_177__Java_Memory_Managem_1"
class="anchor"></span>Chapter 177: Java Memory Management</p>
<p>Section 177.1: Setting the Heap, PermGen and Stack sizes</p>
<p>When a Java virtual machine starts, it needs to know how big to make
the Heap, and the default size for thread stacks. These can be specified
using command-line options on the java command. For versions of Java
prior to Java</p>
<p>8, you can also specify the size of the PermGen region of the
Heap.</p>
<p>Note that PermGen was removed in Java 8, and if you attempt to set
the PermGen size the option will be ignored</p>
<p>(with a warning message).</p>
<p>If you don't specify Heap and Stack sizes explicitly, the JVM will
use defaults that are calculated in a version and</p>
<p>platform specific way. This may result in your application using too
little or too much memory. This is typically OK for thread stacks, but
it can be problematic for a program that uses a lot of memory.</p>
<p>Setting the Heap, PermGen and default Stack sizes:</p>
<p>The following JVM options set the heap size:</p>
<p>-Xms - sets the initial heap size</p>
<p>-Xmx - sets the maximum heap size</p>
<p>-XX:PermSize - sets the initial PermGen size</p>
<p>-XX:MaxPermSize - sets the maximum PermGen size-Xss - sets the
default thread stack size</p>
<p>The <strong>&lt;size&gt;</strong> parameter can be a number of bytes,
or can have a suffix of k, m or g. The latter specify the size in
kilobytes, megabytes and gigabytes respectively.</p>
<p>Examples:</p>
<p>$ java -Xms512m -Xmx1024m JavaApp</p>
<p>$ java -XX:PermSize=64m -XX:MaxPermSize=128m JavaApp $ java -Xss512k
JavaApp</p>
<p>Finding the default sizes:</p>
<p>The -XX:+printFlagsFinal option can be used to print the values of
all flags before starting the JVM. This can be</p>
<p>used to print the defaults for the heap and stack size settings as
follows:</p>
<p>For Linux, Unix, Solaris and Mac OSX</p>
<p>$ java -XX:+PrintFlagsFinal -version | grep -iE
'HeapSize|PermSize|ThreadStackSize'</p>
<p>For Windows:</p>
<p>java -XX:+PrintFlagsFinal -version | findstr /i "HeapSize PermSize
ThreadStackSize"</p>
<p>The output of the above commands will resemble the following:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 907</p>
<p><span id="uintx_InitialHeapSize" class="anchor"></span>uintx
InitialHeapSize := 20655360 {product} uintx MaxHeapSize := 331350016
{product} uintx PermSize = 21757952 {pd product} uintx MaxPermSize =
85983232 {pd product} intx ThreadStackSize = 1024 {pd product}</p>
<p>The sizes are given in bytes.</p>
<p>Section 177.2: Garbage collection</p>
<p>The C++ approach - new and delete</p>
<p>In a language like C++, the application program is responsible for
managing the memory used by dynamically allocated memory. When an object
is created in the C++ heap using the <strong>new</strong> operator,
there needs to be a</p>
<p>corresponding use of the delete operator to dispose of the
object:</p>
<p>If program forgets to delete an object and just "forgets" about it,
the associated memory is lost to the</p>
<p>application. The term for this situation is a <em>memory leak</em>,
and it too much memory leaks an application is liable to use more and
more memory, and eventually crash.</p>
<p>On the other hand, if an application attempts to delete the same
object twice, or use an object after it has been deleted, then the
application is liable to crash due to problems with memory
corruption</p>
<p>In a complicated C++ program, implementing memory management using
<strong>new</strong> and delete can be time consuming.</p>
<p>Indeed, memory management is a common source of bugs.</p>
<p>The Java approach - garbage collection</p>
<p>Java takes a different approach. Instead of an explicit delete
operator, Java provides an automatic mechanism</p>
<p>known as garbage collection to reclaim the memory used by objects
that are no longer needed. The Java runtime system takes responsibility
for finding the objects to be disposed of. This task is performed by a
component called a</p>
<p><em>garbage collector</em>, or GC for short.</p>
<p>At any time during the execution of a Java program, we can divide the
set of all existing objects into two distinct</p>
<p>subsets1:</p>
<p>Reachable objects are defined by the JLS as follows:</p>
<p>A reachable object is any object that can be accessed in any
potential continuing computation from</p>
<p>any live thread.</p>
<p>In practice, this means that there is a chain of references starting
from an in-scope local variable or a <strong>static</strong></p>
<p>variable by which some code might be able to reach the object.</p>
<p>Unreachable objects are objects that <em>cannot possibly</em> be
reached as above.</p>
<p>Any objects that are unreachable are <em>eligible</em> for garbage
collection. This does not mean that they <em>will</em> be garbage</p>
<p>collected. In fact:</p>
<p>An unreachable object <em>does not</em> get collected immediately on
becoming unreachable1.</p>
<p>An unreachable object <em>may not ever</em> be garbage collected.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 908</p>
<p>The Java language Specification gives a lot of latitude to a JVM
implementation to decide when to collect unreachable objects. It also
(in practice) gives permission for a JVM implementation to be
conservative in how it</p>
<p>detects unreachable objects.</p>
<p>The one thing that the JLS guarantees is that no <em>reachable</em>
objects will ever be garbage collected.</p>
<p>What happens when an object becomes unreachable</p>
<p>First of all, nothing specifically happens when an object
<em>becomes</em> unreachable. Things only happen when the garbage
collector runs <em>and</em> it detects that the object is unreachable.
Furthermore, it is common for a GC run to not</p>
<p>detect all unreachable objects.</p>
<p>When the GC detects an unreachable object, the following events can
occur.</p>
<p>1. If there are any Reference objects that refer to the object, those
references will be cleared before the object</p>
<p>is deleted.</p>
<p>2. If the object is <em>finalizable</em>, then it will be finalized.
This happens before the object is deleted.</p>
<p>3. The object can be deleted, and the memory it occupies can be
reclaimed.</p>
<p>Note that there is a clear sequence in which the above events
<em>can</em> occur, but nothing requires the garbage collector</p>
<p>to perform the final deletion of any specific object in any specific
time-frame.</p>
<p>Examples of reachable and unreachable objects</p>
<p>Consider the following example classes:</p>
<p>// A node in simple "open" linked-list.</p>
<p>public class <strong>Node {</strong></p>
<p>private static int <strong>counter = 0;</strong></p>
<p><strong>public int</strong> nodeNumber = ++counter;</p>
<p><strong>public</strong> Node next;</p>
<p>}</p>
<p>public class <strong>ListTest {</strong></p>
<p><strong>public static void</strong> main(String[] args) {</p>
<p>test(); <em>// M1</em></p>
<p>System.out.prinln("Done"); <em>// M2</em></p>
<p>}</p>
<p>private static void <strong>test() {</strong></p>
<p>Node n1 = <strong>new</strong> Node(); <em>// T1</em></p>
<p>Node n2 = <strong>new</strong> Node(); <em>// T2</em></p>
<p>Node n3 = <strong>new</strong> Node(); <em>// T3</em></p>
<p>n1.next = n2; <em>// T4</em></p>
<p>n2 = <strong>null</strong>; <em>// T5</em></p>
<p>n3 = <strong>null</strong>; <em>// T6</em></p>
<p>}</p>
<p>}</p>
<p>Let us examine what happens when test() is called. Statements T1, T2
and T3 create Node objects, and the objects are all reachable via the
n1, n2 and n3 variables respectively. Statement T4 assigns the reference
to the 2nd Node</p>
<p>object to the next field of the first one. When that is done, the 2nd
Node is reachable via two paths:</p>
<p>n2 -&gt; Node2</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 909</p>
<p><span id="n1____Node1__Node1_next___Node2" class="anchor"></span>n1
-&gt; Node1, Node1.next-&gt; Node2</p>
<p>In statement T5, we assign <strong>null</strong> to n2. This breaks
the first of the reachability chains for Node2, but the second one
remains unbroken, so Node2 is still reachable.</p>
<p>In statement T6, we assign <strong>null</strong> to n3. This breaks
the only reachability chain for Node3, which makes Node3 unreachable.
However, Node1 and Node2 are both still reachable via the n1
variable.</p>
<p>Finally, when the test() method returns, its local variables n1, n2
and n3 go out of scope, and therefore cannot be accessed by anything.
This breaks the remaining reachability chains for Node1 and Node2, and
all of the Node objects</p>
<p>are nor unreachable and <em>eligible</em> for garbage collection.</p>
<p>1 - This is a simplification that ignores finalization, and Reference
classes. 2 - Hypothetically, a Java implementation</p>
<p>could do this, but the performance cost of doing this makes it
impractical.</p>
<p>Section 177.3: Memory leaks in Java</p>
<p>In the Garbage collection example, we implied that Java solves the
problem of memory leaks. This is not actually</p>
<p>true. A Java program can leak memory, though the causes of the leaks
are rather different.</p>
<p>Reachable objects can leak</p>
<p>Consider the following naive stack implementation.</p>
<p><strong>public class</strong> NaiveStack {</p>
<p><strong>private</strong> Object[] stack = <strong>new</strong>
Object[100];</p>
<p>private int <strong>top = 0;</strong></p>
<p><strong>public void</strong> push(Object obj) {</p>
<p><strong>if</strong> (top &gt;= stack.length) {</p>
<p><strong>throw new</strong> StackException("stack overflow");</p>
<p>}</p>
<p>stack[top++] = obj;</p>
<p>}</p>
<p><strong>public</strong> Object pop() {</p>
<p><strong>if</strong> (top &lt;= 0) {</p>
<p><strong>throw new</strong> StackException("stack underflow");</p>
<p>}</p>
<p><strong>return</strong> stack[--top];</p>
<p>}</p>
<p>public boolean <strong>isEmpty() {</strong></p>
<p><strong>return</strong> top == 0;</p>
<p>}</p>
<p>}</p>
<p>When you push an object and then immediately pop it, there will still
be a reference to the object in the stack array.</p>
<p>The logic of the stack implementation means that that reference
cannot be returned to a client of the API. If an</p>
<p>object has been popped then we can prove that it cannot <em>"be
accessed in any potential continuing computation from</em> <em>any live
thread"</em>. The problem is that a current generation JVM cannot prove
this. Current generation JVMs do not</p>
<p>consider the logic of the program in determining whether references
are reachable. (For a start, it is not practical.)</p>
<p>But setting aside the issue of what <em>reachability</em> really
means, we clearly have a situation here where the NaiveStack</p>
<p>implementation is "hanging onto" objects that ought to be reclaimed.
That is a memory leak.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 910</p>
<p><span id="In_this_case__the_solution_is_st" class="anchor"></span>In
this case, the solution is straightforward:</p>
<p><strong>public</strong> Object pop() {</p>
<p><strong>if</strong> (top &lt;= 0) {</p>
<p><strong>throw new</strong> StackException("stack underflow");</p>
<p>}</p>
<p>Object popped = stack[--top];</p>
<p><em>stack[top] = <strong>null</strong>;</em> // Overwrite popped
reference with null.</p>
<p><strong>return</strong> popped;</p>
<p>}</p>
<p>Caches can be memory leaks</p>
<p>A common strategy for improving service performance is to cache
results. The idea is that you keep a record of common requests and their
results in an in-memory data structure known as a cache. Then, each time
a request is</p>
<p>made, you lookup the request in the cache. If the lookup succeeds,
you return the corresponding saved results.</p>
<p>This strategy can be very effective if implemented properly. However,
if implemented incorrectly, a cache can be a</p>
<p>memory leak. Consider the following example:</p>
<p><strong>public class</strong> RequestHandler {</p>
<p><strong>private</strong> Map cache = <strong>new</strong>
HashMap&lt;&gt;();</p>
<p><strong>public</strong> Result doRequest(Task task) {</p>
<p>Result result = cache.get(task);</p>
<p><strong>if</strong> (result == <strong>null</strong>) {</p>
<p>result == doRequestProcessing(task);</p>
<p>cache.put(task, result);</p>
<p>}</p>
<p><strong>return</strong> result;</p>
<p>}</p>
<p>}</p>
<p>The problem with this code is that while any call to doRequest could
add a new entry to the cache, there is nothing to remove them. If the
service is continually getting different tasks, then the cache will
eventually consume all</p>
<p>available memory. This is a form of memory leak.</p>
<p>One approach to solving this is to use a cache with a maximum size,
and throw out old entries when the cache</p>
<p>exceeds the maximum. (Throwing out the least recently used entry is a
good strategy.) Another approach is to build</p>
<p>the cache using WeakHashMap so that the JVM can evict cache entries
if the heap starts getting too full.</p>
<p>Section 177.4: Finalization</p>
<p>A Java object may declare a finalize method. This method is called
just before Java releases the memory for the object. It will typically
look like this:</p>
<p>public class <strong>MyClass {</strong></p>
<p>//Methods for the class</p>
<p>@Override</p>
<p><strong>protected void</strong> finalize() <strong>throws</strong>
Throwable {</p>
<p>// Cleanup code</p>
<p>}</p>
<p>}</p>
<p>However, there some important caveats on the behavior of Java
finalization.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 911</p>
<p><span id="Java_makes_no_guarantees_about_w"
class="anchor"></span>Java makes no guarantees about when a finalize()
method will called. Java does not even guarantee that a finalize()
method will be called some time during the running</p>
<p>application's lifetime.</p>
<p>The only thing that is guaranteed is that the method will be called
before the object is deleted ... if the object is deleted.</p>
<p>The caveats above mean that it is a bad idea to rely on the finalize
method to perform cleanup (or other) actions</p>
<p>that must be performed in a timely fashion. Over reliance on
finalization can lead to storage leaks, memory leaks</p>
<p>and other problems.</p>
<p>In short, there are very few situation where finalization is actually
a good solution.</p>
<p>Finalizers only run once</p>
<p>Normally, an object is deleted after it has been finalized. However,
this doesn't happen all of the time. Consider the</p>
<p>following example1:</p>
<p><strong>public class</strong> CaptainJack {</p>
<p><strong>public static</strong> CaptainJack notDeadYet =
<strong>null</strong>;</p>
<p>protected void <strong>finalize() {</strong></p>
<p>// Resurrection!</p>
<p>notDeadYet = <strong>this</strong>;</p>
<p>}</p>
<p>}</p>
<p>When an instance of CaptainJack becomes unreachable and the garbage
collector attempts to reclaim it, the</p>
<p>finalize() method will assign a reference to the instance to the
notDeadYet variable. That will make the instance reachable once more,
and the garbage collector won't delete it.</p>
<p>Question: Is Captain Jack immortal?</p>
<p>Answer: No.</p>
<p>The catch is the JVM will only run a finalizer on an object once in
its lifetime. If you assign <strong>null</strong> to notDeadYet</p>
<p>causing a resurected instance to be unreachable once more, the
garbage collector won't call finalize() on the object.</p>
<p>1 - See <a
href="https://en.wikipedia.org/wiki/Jack_Harkness">https://en.wikipedia.org/wiki/Jack_Harkness</a>.</p>
<p>Section 177.5: Manually triggering GC</p>
<p>You can manually trigger the Garbage Collector by calling</p>
<p>System.gc();</p>
<p>However, Java does not guarantee that the Garbage Collector has run
when the call returns. This method simply</p>
<p>"suggests" to the JVM (Java Virtual Machine) that you want it to run
the garbage collector, but does not force it to do so.</p>
<p>It is generally considered a bad practice to attempt to manually
trigger garbage collection. The JVM can be run with</p>
<p>the -XX:+DisableExplicitGC option to disable calls to System.gc().
Triggering garbage collection by calling</p>
<p>System.gc() can disrupt normal garbage management / object promotion
activities of the specific garbage collector implementation in use by
the JVM.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 912</p>
<p><span id="Chapter_178__Java_Performance_Tu_1"
class="anchor"></span>Chapter 178: Java Performance Tuning</p>
<p>Section 178.1: An evidence-based approach to Java</p>
<p>performance tuning</p>
<p>Donald Knuth is often quoted as saying this:</p>
<p>"Programmers waste enormous amounts of time thinking about, or
worrying about, the speed of</p>
<p>noncritical parts of their programs, and these attempts at efficiency
actually have a strong negative impact when debugging and maintenance
are considered. <em>We should forget about small efficiencies,
say</em></p>
<p><em>about 97% of the time</em>: premature optimization is the root of
all evil. Yet we should not pass up our opportunities in that critical
3%."</p>
<p><a
href="https://en.wikiquote.org/wiki/Donald_Knuth#Computer_Programming_as_an_Art_.281974.29">source</a></p>
<p>Bearing that sage advice in mind, here is the recommended procedure
for optimizing programs:</p>
<p>1. First of all, design and code your program or library with a focus
on simplicity and correctness. To start with,</p>
<p>don't spend much effort on performance.</p>
<p>2. Get it to a working state, and (ideally) develop unit tests for
the key parts of the codebase.</p>
<p>3. Develop an application level performance benchmark. The benchmark
should cover the performance critical</p>
<p>aspects of your application, and should perform a range of tasks that
are typical of how the application will be used in production.</p>
<p>4. Measure the performance.</p>
<p>5. Compare the measured performance against your criteria for how
fast the application needs to be. (Avoid</p>
<p>unrealistic, unattainable or unquantifiable criteria such as "as fast
as possible".)</p>
<p>6. If you have met the criteria, STOP. You job is done. (Any further
effort is probably a waste of time.)</p>
<p>7. Profile the application while it is running your performance
benchmark.</p>
<p>8. Examine the profiling results and pick the biggest (unoptimized)
"performance hotspots"; i.e. sections of the</p>
<p>code where the application seems to be spending the most time.</p>
<p>9. Analyse the hotspot code section to try to understand why it is a
bottleneck, and think of a way to make it</p>
<p>faster.</p>
<p>10. Implement that as a proposed code change, test and debug.</p>
<p>11. Rerun the benchmark to see if the code change has improved the
performance:</p>
<p>If Yes, then return to step 4.</p>
<p>If No, then abandon the change and return to step 9. If you are
making no progress, pick a different</p>
<p>hotspot for your attention.</p>
<p>Eventually you will get to a point where the application is either
fast enough, or you have considered all of the significant hotspots. At
this point you need to stop this approach. If a section of code is
consuming (say) 1% of the</p>
<p>overall time, then even a 50% improvement is only going to make the
application 0.5% faster overall.</p>
<p>Clearly, there is a point beyond which hotspot optimization is a
waste of effort. If you get to that point, you need to</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 913</p>
<p><span id="take_a_more_radical_approach__Fo"
class="anchor"></span>take a more radical approach. For example:</p>
<p>Look at the algorithmic complexity of your core algorithms.</p>
<p>If the application is spending a lot of time garbage collection, look
for ways to reduce the rate of object creation.</p>
<p>If key parts of the application are CPU intensive and
single-threaded, look for opportunities for parallelism. If the
application is already multi-threaded, look for concurrency
bottlenecks.</p>
<p>But wherever possible, rely on tools and measurement rather than
instinct to direct your optimization effort.</p>
<p>Section 178.2: Reducing amount of Strings</p>
<p>In Java, it's too "easy" to create many String instances which are
not needed. That and other reasons might cause</p>
<p>your program to have lots of Strings that the GC is busy cleaning
up.</p>
<p>Some ways you might be creating String instances:</p>
<p>myString += "foo";</p>
<p>Or worse, in a loop or recursion:</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; N; i++)
{</p>
<p>myString += "foo" + i;</p>
<p>}</p>
<p>The problem is that each + creates a new String (usually, since new
compilers optimize some cases). A possible optimization can be made
using StringBuilder or StringBuffer:</p>
<p>StringBuffer sb = <strong>new</strong> StringBuffer(myString);</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; N; i++)
{</p>
<p>sb.append("foo").append(i);</p>
<p>}</p>
<p>myString = sb.toString();</p>
<p>If you build long Strings often (SQLs for example), use a String
building API.</p>
<p>Other things to consider:</p>
<p>Reduce usage of replace, substring etc.</p>
<p>Avoid String.toArray(), especially in frequently accessed code.</p>
<p>Log prints which are destined to be filtered (due to log level for
example) should not be generated (log level should be checked in
advance).</p>
<p><a href="https://commons.apache.org/proper/commons-lang/">Use
libraries like this if necessary.</a></p>
<p>StringBuilder is better if the variable is used in a non-shared
manner (across threads).</p>
<p>Section 178.3: General approach</p>
<p>The internet is packed with tips for performance improvement of Java
programs. Perhaps the number one tip is awareness. That means:</p>
<p>Identify possible performance problems and bottlenecks.</p>
<p>Use analyzing and testing tools.</p>
<p>Know good practices and bad practices.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 914</p>
<p>The first point should be done during the design stage if speaking
about a new system or module. If speaking about legacy code, analyzing
and testing tools come into the picture. The most basic tool for
analyzing your JVM</p>
<p>performance is JVisualVM, which is included in the JDK.</p>
<p>The third point is mostly about experience and extensive research,
and of course raw tips that will show up on this</p>
<p>page and others, like <a
href="http://javaperformancetuning.com/tips/rawtips.shtml">this</a>.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 915</p>
<p><span id="Chapter_179__Benchmarks_1" class="anchor"></span>Chapter
179: Benchmarks</p>
<p>Writing performance benchmarks in java is not as simple as getting
System.currentTimeMillis() in the beginning</p>
<p>and in the end and calculating the difference. To write valid
performance benchmarks, one should use proper tools.</p>
<p>Section 179.1: Simple JMH example</p>
<p><a href="http://openjdk.java.net/projects/code-tools/jmh/">One of the
tools for writing proper benchmark tests is JMH</a>. Let's say we want
to compare performance of searching</p>
<p>an element in HashSet vs TreeSet.</p>
<p><a href="https://maven.apache.org/plugins/maven-shade-plugin/">The
easiest way to get JHM into your project - is to use maven and shade
plugin. Also you can see</a> pom.xml <a
href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-archetypes/jmh-java-benchmark-archetype/src/main/resources/archetype-resources/pom.xml">from
JHM</a></p>
<p><a
href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-archetypes/jmh-java-benchmark-archetype/src/main/resources/archetype-resources/pom.xml">examples.</a></p>
<p>&lt;build&gt;</p>
<p>&lt;plugins&gt;</p>
<p>&lt;plugin&gt;</p>
<p><strong>&lt;groupId&gt;</strong>org.apache.maven.plugins<strong>&lt;/groupId&gt;</strong></p>
<p>&lt;artifactId&gt;<strong>maven-shade-plugin</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>3.0.0</strong>&lt;/version&gt;</p>
<p>&lt;executions&gt;</p>
<p>&lt;execution&gt;</p>
<p>&lt;phase&gt;<strong>package</strong>&lt;/phase&gt;</p>
<p>&lt;goals&gt;</p>
<p>&lt;goal&gt;<strong>shade</strong>&lt;/goal&gt;</p>
<p>&lt;/goals&gt;</p>
<p>&lt;configuration&gt;</p>
<p>&lt;finalName&gt;<strong>/benchmarks</strong>&lt;/finalName&gt;</p>
<p>&lt;transformers&gt;</p>
<p>&lt;transformer</p>
<p>implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"<strong>&gt;</strong></p>
<p>&lt;mainClass&gt;<strong>org.openjdk.jmh.Main</strong>&lt;/mainClass&gt;</p>
<p>&lt;/transformer&gt;</p>
<p>&lt;/transformers&gt;</p>
<p>&lt;filters&gt;</p>
<p>&lt;filter&gt;</p>
<p>&lt;artifact&gt;<strong>*:*</strong>&lt;/artifact&gt;</p>
<p>&lt;excludes&gt;</p>
<p>&lt;exclude&gt;<strong>META-INF/*.SF</strong>&lt;/exclude&gt;</p>
<p>&lt;exclude&gt;<strong>META-INF/*.DSA</strong>&lt;/exclude&gt;</p>
<p>&lt;exclude&gt;<strong>META-INF/*.RSA</strong>&lt;/exclude&gt;</p>
<p>&lt;/excludes&gt;</p>
<p>&lt;/filter&gt;</p>
<p>&lt;/filters&gt;</p>
<p>&lt;/configuration&gt;</p>
<p>&lt;/execution&gt;</p>
<p>&lt;/executions&gt;</p>
<p>&lt;/plugin&gt;</p>
<p>&lt;/plugins&gt;</p>
<p>&lt;/build&gt;</p>
<p>&lt;dependencies&gt;</p>
<p>&lt;dependency&gt;</p>
<p>&lt;groupId&gt;<strong>org.openjdk.jmh</strong>&lt;/groupId&gt;</p>
<p>&lt;artifactId&gt;<strong>jmh-core</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>1.18</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;dependency&gt;</p>
<p>&lt;groupId&gt;<strong>org.openjdk.jmh</strong>&lt;/groupId&gt;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 916</p>
<p>&lt;artifactId&gt;<strong>jmh-generator-annprocess</strong>&lt;/artifactId&gt;</p>
<p>&lt;version&gt;<strong>1.18</strong>&lt;/version&gt;</p>
<p>&lt;/dependency&gt;</p>
<p>&lt;/dependencies&gt;</p>
<p>After this you need to write benchmark class itself:</p>
<p><strong>package</strong> benchmark;</p>
<p><strong>import</strong> org.openjdk.jmh.annotations.*;</p>
<p><strong>import</strong> org.openjdk.jmh.infra.Blackhole;</p>
<p><strong>import</strong> java.util.HashSet;</p>
<p><strong>import</strong> java.util.Random;</p>
<p><strong>import</strong> java.util.Set;</p>
<p><strong>import</strong> java.util.TreeSet;</p>
<p><strong>import</strong> java.util.concurrent.TimeUnit;</p>
<p>@State(Scope.Thread)</p>
<p><strong>public class</strong> CollectionFinderBenchmarkTest {</p>
<p>private static final int <strong>SET_SIZE = 10000;</strong></p>
<p><strong>private</strong> Set hashSet;</p>
<p><strong>private</strong> Set treeSet;</p>
<p><strong>private</strong> String stringToFind = "8888";</p>
<p>@Setup</p>
<p><strong>public void</strong> setupCollections() {</p>
<p>hashSet = <strong>new</strong> HashSet&lt;&gt;(SET_SIZE);</p>
<p>treeSet = <strong>new</strong> TreeSet&lt;&gt;();</p>
<p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; SET_SIZE;
i++) {</p>
<p><strong>final</strong> String value = String.valueOf(i);</p>
<p>hashSet.add(value);</p>
<p>treeSet.add(value);</p>
<p>}</p>
<p>stringToFind = String.valueOf(<strong>new</strong>
Random().nextInt(SET_SIZE));</p>
<p>}</p>
<p>@Benchmark</p>
<p>@BenchmarkMode(Mode.AverageTime)</p>
<p>@OutputTimeUnit(TimeUnit.NANOSECONDS)</p>
<p><strong>public void</strong> testHashSet(Blackhole blackhole) {</p>
<p>blackhole.consume(hashSet.contains(stringToFind));</p>
<p>}</p>
<p>@Benchmark</p>
<p>@BenchmarkMode(Mode.AverageTime)</p>
<p>@OutputTimeUnit(TimeUnit.NANOSECONDS)</p>
<p><strong>public void</strong> testTreeSet(Blackhole blackhole) {</p>
<p>blackhole.consume(treeSet.contains(stringToFind));</p>
<p>}</p>
<p>}</p>
<p>Please keep in mind this blackhole.consume(), we'll get back to it
later. Also we need main class for running</p>
<p>benchmark:</p>
<p><strong>package</strong> benchmark;</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 917</p>
<p><strong>import</strong> org.openjdk.jmh.runner.Runner;</p>
<p><strong>import</strong> org.openjdk.jmh.runner.RunnerException;</p>
<p><strong>import</strong> org.openjdk.jmh.runner.options.Options;</p>
<p><strong>import</strong>
org.openjdk.jmh.runner.options.OptionsBuilder;</p>
<p><strong>public class</strong> BenchmarkMain {</p>
<p><strong>public static void</strong> main(String[] args)
<strong>throws</strong> RunnerException {</p>
<p><strong>final</strong> Options options = <strong>new</strong>
OptionsBuilder()</p>
<p>.include(CollectionFinderBenchmarkTest.<strong>class</strong>.getSimpleName())</p>
<p>.forks(1)</p>
<p>.build();</p>
<p><strong>new</strong> Runner(options).run();</p>
<p>}</p>
<p>}</p>
<p>And we're all set. We just need to run mvn <strong>package</strong>
(it will create benchmarks.jar in your /target folder) and run</p>
<p>our benchmark test:</p>
<p>java -cp target/benchmarks.jar benchmark.BenchmarkMain</p>
<p>And after some warmup and calculation iterations, we will have our
results:</p>
<p># Run complete. Total time: 00:01:21</p>
<p>Benchmark Mode Cnt Score Error Units
CollectionFinderBenchmarkTest.testHashSet avgt 20 9.940 ± 0.270 ns/op
CollectionFinderBenchmarkTest.testTreeSet avgt 20 98.858 ± 13.743
ns/op</p>
<p>About that blackhole.consume(). If your calculations do not change
the state of your application, java will most likely just ignore it. So,
in order to avoid it, you can either make your benchmark methods return
some value, or use</p>
<p>Blackhole object to consume it.</p>
<p>You can find more information about writing proper benchmarks in <a
href="https://shipilev.net/blog/2014/nanotrusting-nanotime/">Aleksey
Shipilëv's blog, in</a> <a
href="http://tutorials.jenkov.com/java-performance/jmh.html">Jacob
Jenkov's blog</a></p>
<p>and in java-performance blog: <a
href="http://java-performance.info/jmh/">1,</a> <a
href="http://java-performance.info/introduction-jmh-profilers/">2.</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 918</p>
<p><span id="Chapter_180__FileUpload_to_AWS_1"
class="anchor"></span>Chapter 180: FileUpload to AWS</p>
<p>Upload File to AWS s3 bucket using spring rest API.</p>
<p>Section 180.1: Upload file to s3 bucket</p>
<p>Here we will create a rest API which will take file object as a
multipart parameter from front end and upload it to S3</p>
<p>bucket using java rest API.</p>
<p><strong>Requirement</strong>: secrete key and Access key for s3
bucket where you wanna upload your file.</p>
<p>code: DocumentController.java</p>
<p>@RestController</p>
<p>@RequestMapping("/api/v2")</p>
<p><strong>public class</strong> DocumentController {</p>
<p><strong>private static</strong> String bucketName =
"pharmerz-chat";</p>
<p>// private static String keyName = "Pharmerz"+ UUID.randomUUID();</p>
<p>@RequestMapping(value = "/upload", method = RequestMethod.POST,
consumes = MediaType.MULTIPART_FORM_DATA)</p>
<p><strong>public</strong> URL uploadFileHandler(@RequestParam("name")
String name,</p>
<p>@RequestParam("file") MultipartFile file) <strong>throws</strong>
IOException {</p>
<p>/******* Printing all the possible parameter from @RequestParam
*************/</p>
<p>System.out.println("*****************************");</p>
<p>System.out.println("file.getOriginalFilename() " +
file.getOriginalFilename()); System.out.println("file.getContentType()"
+ file.getContentType()); System.out.println("file.getInputStream() " +
file.getInputStream()); System.out.println("file.toString() " +
file.toString()); System.out.println("file.getSize() " +
file.getSize()); System.out.println("name " + name);</p>
<p>System.out.println("file.getBytes() " + file.getBytes());
System.out.println("file.hashCode() " + file.hashCode());
System.out.println("file.getClass() " + file.getClass());
System.out.println("file.isEmpty() " + file.isEmpty());</p>
<p>/*************Parameters to b pass to s3 bucket put Object
**************/ <em>InputStream is = file.getInputStream();</em></p>
<p>String keyName = file.getOriginalFilename();</p>
<p>// Credentials for Aws</p>
<p>AWSCredentials credentials = <strong>new</strong>
BasicAWSCredentials("AKIA*************",
"zr**********************");</p>
<p>/****************** DocumentController.uploadfile(credentials);
***************************/</p>
<p>AmazonS3 s3client = <strong>new</strong>
AmazonS3Client(credentials);</p>
<p>try <strong>{</strong></p>
<p>System.out.println("Uploading a new object to S3 from a
file<strong>\n</strong>"); <em>//File file = new
File(awsuploadfile);</em></p>
<p>s3client.putObject(<strong>new</strong> PutObjectRequest(</p>
<p>bucketName, keyName, is, <strong>new</strong> ObjectMetadata()));</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 919</p>
<p>URL url = s3client.generatePresignedUrl(bucketName, keyName,</p>
<p>Date.from(Instant.now().plus(5, ChronoUnit.MINUTES)));</p>
<p>// URL url=s3client.generatePresignedUrl(bucketName,keyName,</p>
<p>Date.from(Instant.now().plus(5, ChronoUnit.)));</p>
<p>System.out.println("************************************");
System.out.println(url);</p>
<p>return <strong>url;</strong></p>
<p>} <strong>catch</strong> (AmazonServiceException ase) {</p>
<p>System.out.println("Caught an AmazonServiceException, which " +</p>
<p>"means your request made it " +</p>
<p>"to Amazon S3, but was rejected with an error response" + " for some
reason.");</p>
<p>System.out.println("Error Message: " + ase.getMessage());
System.out.println("HTTP Status Code: " + ase.getStatusCode());
System.out.println("AWS Error Code: " + ase.getErrorCode());
System.out.println("Error Type: " + ase.getErrorType());
System.out.println("Request ID: " + ase.getRequestId());</p>
<p>} <strong>catch</strong> (AmazonClientException ace) {</p>
<p>System.out.println("Caught an AmazonClientException, which " +</p>
<p>"means the client encountered " +</p>
<p>"an internal error while trying to " +</p>
<p>"communicate with S3, " +</p>
<p>"such as not being able to access the network.");</p>
<p>System.out.println("Error Message: " + ace.getMessage());</p>
<p>}</p>
<p>return null<strong>;</strong></p>
<p>}</p>
<p>}</p>
<p>Front end Function</p>
<p>var form = <strong>new</strong> FormData();</p>
<p>form.append("file", "image.jpeg");</p>
<p>var settings = {</p>
<p>"async": <strong>true</strong>,</p>
<p>"crossDomain": <strong>true</strong>,</p>
<p>"url": "http://url/",</p>
<p>"method": "POST",</p>
<p>"headers": {</p>
<p>"cache-control": "no-cache"</p>
<p>},</p>
<p>"processData": <strong>false</strong>,</p>
<p>"contentType": <strong>false</strong>,</p>
<p>"mimeType": "multipart/form-data",</p>
<p>"data": form</p>
<p>}</p>
<p>$.ajax(settings).done(function (response) {</p>
<p>console.log(response);</p>
<p>});</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 920</p>
<p><span id="Chapter_181__AppDynamics_and_TIB_1"
class="anchor"></span>Chapter 181: AppDynamics and TIBCO</p>
<p>BusinessWorks Instrumentation for Easy</p>
<p>Integration</p>
<p>As AppDynamics aims to provide a way to measure application
performance, speed of development, delivery</p>
<p>(deployment) of applications is an essential factor in making DevOps
efforts a true success. Monitoring a TIBCO BW application with AppD is
generally simple and not time consuming but when deploying large sets of
applications</p>
<p>rapid instrumentation is key. This guide shows how to instrument all
of your BW applications in a single step</p>
<p>without modifying each application before deploying.</p>
<p>Section 181.1: Example of Instrumentation of all BW</p>
<p>Applications in a Single Step for Appdynamics</p>
<p>1. Locate and open your TIBCO BW bwengine.tra file typlically under
TIBCO_HOME/bw/5.12/bin/bwengine.tra</p>
<p>(Linux environment)</p>
<p>2. Look for the line that states:</p>
<p>*** Common variables. Modify these only. ***</p>
<p>3. Add the following line right after that section
tibco.deployment=%tibco.deployment%</p>
<p>4. Go to the end of the file and add (replace ? with your own values
as needed or remove the flag that does not</p>
<p>apply):
java.extended.properties=-javaagent:/opt/appd/current/appagent/javaagent.jar
-</p>
<p>Dappdynamics.http.proxyHost=? -Dappdynamics.http.proxyPort=?
-Dappdynamics.agent.applicationName=?-Dappdynamics.agent.tierName=?
-Dappdynamics.agent.nodeName=%tibco.deployment% -</p>
<p>Dappdynamics.controller.ssl.enabled=?
-Dappdynamics.controller.sslPort=? -Dappdynamics.agent.logs.dir=?
-Dappdynamics.agent.runtime.dir=? -Dappdynamics.controller.hostName=?
-Dappdynamics.controller.port=?</p>
<p>-Dappdynamics.agent.accountName=?
-Dappdynamics.agent.accountAccessKey=?</p>
<p>5. Save file and redeploy. All your applications should now be
instrumented automatically at deployment time.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 921</p>
<p><span id="Appendix_A__Installing_Java__Sta"
class="anchor"></span>Appendix A: Installing Java (Standard</p>
<p>Edition)</p>
<p>This documentation page gives access to instructions for installing
java standard edition on Windows, Linux, and</p>
<p>macOS computers.</p>
<p>Section A.1: Setting %PATH% and %JAVA_HOME% after</p>
<p>installing on Windows</p>
<p>Assumptions:</p>
<p>An Oracle JDK has been installed.</p>
<p>The JDK was installed to the default directory.</p>
<p>Setup steps</p>
<p>1. Open Windows Explorer.</p>
<p>2. In the navigation pane on the left right click on <em>This PC</em>
(or <em>Computer</em> for older Windows versions). There is a</p>
<p>shorter way without using the explorer in actual Windows versions:
Just press Win + Pause</p>
<p>3. In the newly opened Control Panel window, left click <em>Advanced
System Settings</em> which should be in the top left</p>
<p>corner. This will open the <em>System Properties</em> window.</p>
<p><img src="media/index-946_1.jpeg"
style="width:3.02778in;height:2.52778in" alt="index-946_1.jpg" /></p>
<p>Alternatively, type SystemPropertiesAdvanced (case insensitive) in
the <em>Run</em> ( Win + R ), and hit Enter .</p>
<p>4. In the <em>Advanced</em> tab of <em>System Properties</em> select
the Environment Variables... button in the lower right</p>
<p>corner of the window.</p>
<p>5. Add a <strong>New System Variable</strong> by clicking the New...
button in <em>System Variables</em> with the name JAVA_HOME</p>
<p>and whose value is the path to the directory where the JDK was
installed. After entering these values, press OK .</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 922</p>
<p><span id="page_947" class="anchor"></span><img
src="media/index-947_1.png" style="width:4in;height:1.77778in"
alt="index-947_1.png" /></p>
<p>6. Scroll down the list of <em>System Variables</em> and select the
Path variable.</p>
<p>7. <strong>CAUTION:</strong> Windows relies on Path to find important
programs. If any or all of it is removed,</p>
<p>Windows may not be able to function properly. It must be modified to
allow Windows to run the JDK. With this in mind ,click the "Edit..."
button with the Path variable selected. Add</p>
<p>%JAVA_HOME%\bin; to the beginning of the Path variable.</p>
<p>It is better to append at the beginning of the line because Oracle's
software used to register their own version of Java in Path - This will
cause your version to be ignored if it occurs after Oracle's
declaration.</p>
<p>Check your work</p>
<p>1. Open the command prompt by clicking Start then typing cmd and
pressing Enter. 2. Enter javac -version into the prompt. If it was
successful, then the version of the JDK will be printed to the</p>
<p>screen.</p>
<p>Note: If you have to try again, close the prompt before checking your
work. This will force windows to get the new</p>
<p>version of Path.</p>
<p>Section A.2: Installing a Java JDK on Linux</p>
<p>Using the Package Manager</p>
<p>JDK and/or JRE releases for OpenJDK or Oracle can be installed using
the package manager on most mainstream</p>
<p>Linux distribution. (The choices that are available to you will
depend on the distro.)</p>
<p>As a general rule, the procedure is to open terminal window and run
the commands shown below. (It is assumed</p>
<p>that you have sufficient access to run commands as the "root" user
... which is what the sudo command does. If you do not, then please talk
to your system's administrators.)</p>
<p>Using the package manager is recommended because it (generally) makes
it easier to keep your Java installation up to date.</p>
<p>apt-get, Debian based Linux distributions (Ubuntu, etc)</p>
<p>The following instructions will install Oracle Java 8:</p>
<p>$ <strong>sudo</strong> add-apt-repository
ppa:webupd8team<strong>/java</strong></p>
<p><strong>$</strong> sudo apt-get update</p>
<p>$ <strong>sudo apt-get install</strong> oracle-java8-installer</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 923</p>
<p>Note: To automatically set up the Java 8 environment variables, you
can install the following package:</p>
<p>$ <strong>sudo apt-get install</strong> oracle-java8-set-default</p>
<p>Creating a .deb file</p>
<p>If you prefer to create the .deb file yourself from the .tar.gz file
downloaded from Oracle, do the following (assuming you've downloaded the
.tar.gz to ./.tar.gz):</p>
<p><em>$ <strong>sudo apt-get install</strong> java-package</em> # might
not be available in default repos <em>$ make-jpkg
.<strong>/&lt;</strong>jdk<strong>&gt;</strong>.tar.gz</em> # should not
be run as root <em>$ <strong>sudo dpkg</strong>-i
<strong>*</strong>j2sdk<strong>*</strong>.deb</em></p>
<p><em>Note</em>: This expects the input to be provided as a ".tar.gz"
file.</p>
<p>slackpkg , Slackware based Linux distributions</p>
<p><strong>sudo</strong> slapt-get <strong>install</strong>
default-jdk</p>
<p>yum, RedHat, CentOS, etc</p>
<p><strong>sudo yum install</strong> java-1.8.0-openjdk-devel.x86_64</p>
<p>dnf, Fedora</p>
<p>On recent Fedora releases, yum has been superseded by dnf.</p>
<p><strong>sudo</strong> dnf <strong>install</strong>
java-1.8.0-openjdk-devel.x86_64</p>
<p>In recent Fedora releases, there are no packages for installing Java
7 and earlier.</p>
<p>pacman , Arch based Linux distributions</p>
<p><strong>sudo pacman</strong>-S jdk8-openjdk</p>
<p>Using sudo is not required if you're running as the root user.</p>
<p>Gentoo Linux</p>
<p><a href="https://wiki.gentoo.org/wiki/Java">The Gentoo Java guide</a>
is maintained by the Gentoo Java team and keeps an updated wiki page
including the correct</p>
<p>portage packages and USE flags needed.</p>
<p>Installing Oracle JDKs on Redhat, CentOS, Fedora</p>
<p>Installing JDK from an Oracle JDK or JRE tar.gz file.</p>
<p>1. Download the appropriate Oracle archive ("tar.gz") file for the
desired release from the <a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle
Java</a></p>
<p><a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">downloads
site.</a></p>
<p>2. Change directory to the place where you want to put the
installation;</p>
<p>3. Decompress the archive file; e.g.</p>
<p>tar xzvf jdk-8u67-linux-x64.tar.gz</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 924</p>
<p><span id="Installing_from_an_Oracle_Java_R"
class="anchor"></span>Installing from an Oracle Java RPM file.</p>
<p>1. <a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Retrieve
the required RPM file for the desired release from the Oracle Java
downloads site.</a></p>
<p>2. Install using the rpm command. For example:</p>
<p>$ <strong>sudo</strong> rpm -ivh jdk-8u67-linux-x644.rpm</p>
<p>Section A.3: Installing a Java JDK on macOS</p>
<p>Oracle Java 7 and Java 8</p>
<p>Java 7 and Java 8 for macOS are available from Oracle. This Oracle
page answers a lot of questions about Java for Mac. Note that Java 7
prior to 7u25 have been disabled by Apple for security reasons.</p>
<p>In general, Oracle Java (Version 7 and later) requires an Intel-based
Mac running macOS 10.7.3 or later.</p>
<p>Installation of Oracle Java</p>
<p>Java 7 &amp; 8 JDK and JRE installers for macOS can be downloaded
from Oracle’s website:</p>
<p>Java 8 - <a
href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Java
SE Downloads</a></p>
<p>Java 7 - <a
href="http://www.oracle.com/technetwork/java/javase/archive-139210.html">Oracle
Java Archive.</a></p>
<p>After downloading the relevant package, double click on the package
and go through the normal installation process. A JDK should get
installed here:</p>
<p>/Library/Java/JavaVirtualMachines/.jdk/Contents/Home</p>
<p>where corresponds to the installed version.</p>
<p>Command-Line Switching</p>
<p>When Java is installed, the installed version is automatically set as
the default. To switch between different, use:</p>
<p>export JAVA_HOME=/usr/libexec/java_home -v 1.6 #Or 1.7 or 1.8</p>
<p>The following functions can be added to the ~/.bash_profile (If you
use the default Bash shell) for ease of use:</p>
<p>function java_version {</p>
<p>echo 'java -version';</p>
<p>}</p>
<p>function java_set {</p>
<p><strong>if</strong> [[ $1 == "6" ]]</p>
<p>then</p>
<p>export JAVA_HOME='/usr/libexec/java_home -v 1.6';</p>
<p>echo "Setting Java to version 6..."</p>
<p>echo "$JAVA_HOME"</p>
<p>elif [[ $1 == "7" ]]</p>
<p>then</p>
<p>export JAVA_HOME='/usr/libexec/java_home -v 1.7';</p>
<p>echo "Setting Java to version 7..."</p>
<p>echo "$JAVA_HOME"</p>
<p>elif [[ $1 == "8" ]]</p>
<p>then</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 925</p>
<p><span id="export_JAVA_HOME___usr_libexec_j"
class="anchor"></span>export JAVA_HOME='/usr/libexec/java_home -v
1.8';</p>
<p>echo "Setting Java to version 8..."</p>
<p>echo "$JAVA_HOME"</p>
<p>fi</p>
<p>}</p>
<p>Apple Java 6 on macOS</p>
<p>On older versions of macOS (10.11 El Capitan and earlier), Apple's
release of Java 6 comes pre-installed. If installed, it can be be found
at this location:</p>
<p>/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</p>
<p>Note that Java 6 passed its end-of-life long ago, so upgrading to a
newer version is recommended. There is more</p>
<p>information on reinstalling Apple Java 6 on the Oracle website.</p>
<p>Section A.4: Installing a Java JDK or JRE on Windows</p>
<p>Only Oracle JDKs and JREs are available for Windows platforms. The
installation procedure is straight-forward:</p>
<p>1. Visit the Oracle Java <a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Downloads
page</a>:</p>
<p>2. Click on either the JDK button, the JRE button or the Server JRE
button. Note that to develop using Java you</p>
<p>need JDK. To know the difference between JDK and JRE, see <a
href="http://stackoverflow.com/a/1906455/3375713">here</a></p>
<p>3. Scroll down to the version you want to download. (Generally
speaking, the most recent one is</p>
<p>recommended.)</p>
<p>4. Select the "Accept License Agreement" radio button.</p>
<p>5. Download the Windows x86 (32 bit) or Windows x64 (64 bit)
installer. 6. Run the installer ... in the normal way for your version
of Windows.</p>
<p>An alternate way to install Java on Windows using the command prompt
is to use Chocolately:</p>
<p>1. <a href="https://chocolatey.org/">Install Chocolately from
https://chocolatey.org/</a></p>
<p>2. Open a cmd instance, for example hit Win + R and then type "cmd"
in the "Run" window followed by an</p>
<p>enter.</p>
<p>3. In your cmd instance, run the following command to download and
install a Java 8 JDK:</p>
<p>C:\&gt; choco install jdk8</p>
<p>Getting up and running with portable versions</p>
<p>There are instances where you might want to install JDK/JRE on a
system with limited privileges like a VM or you might want to install
and use multiple versions or architectures (x64/x86) of JDK/JRE. The
steps remain same till the</p>
<p>point you download the installer (.EXE). The steps after that are as
follows (The steps are applicable for JDK/JRE 7 and above, for older
versions they are slightly different in the names of folders and
files):</p>
<p>1. Move the file to an appropriate location where you would want your
Java binaries to reside permanently.</p>
<p>2. Install 7-Zip or its portable version if you have limited
privileges.</p>
<p>3. With 7-Zip, extract the files from the Java installer EXE to the
location.</p>
<p>4. Open up command prompt there by holding Shift and Right-Clicking
in the folder in explorer or navigate</p>
<p>to that location from anywhere.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 926</p>
<p><span id="5__Navigate_to_the_newly_created" class="anchor"></span>5.
Navigate to the newly created folder. Let's say the folder name is
jdk-7u25-windows-x64. So type <strong>cd</strong></p>
<p>jdk-7u25-windows-x64. Then type the following commands in order :</p>
<p><strong>cd</strong> .rsrc\JAVA_CAB10</p>
<p>extrac32 111</p>
<p>6. This will create a tools.zip file in that location. Extract the
tools.zip with 7-Zip so that the files inside it are</p>
<p>now created under tools in the same directory.</p>
<p>7. Now execute these commands on the already opened command prompt
:</p>
<p><strong>cd</strong> tools</p>
<p><strong>for</strong> /r %x in (*.pack) <strong>do</strong>
.\bin\unpack200 -r "%x" "%~dx%~px%~nx.jar"</p>
<p>8. Wait for the command to complete. Copy the contents of tools to
the location where you want your binaries</p>
<p>to be.</p>
<p>This way, you can install any versions of JDK/JRE you need to be
installed simultaneously.</p>
<p>Original post : <a
href="http://stackoverflow.com/a/6571736/1448252">http://stackoverflow.com/a/6571736/1448252</a></p>
<p>Section A.5: Configuring and switching Java versions on Linux</p>
<p>using alternatives</p>
<p>Using Alternatives</p>
<p>Many Linux distributions use the alternatives command for switching
between different versions of a command. You can use this for switching
between different versions of Java installed on a machine.</p>
<p>1. In a command shell, set $JDK to the pathname of a newly installed
JDK; e.g.</p>
<p>$ JDK=/Data/jdk1.8.0_67</p>
<p>2. Use alternatives --install to add the commands in the Java SDK to
alternatives:</p>
<p>$ <strong>sudo</strong> alternatives --install
<strong>/</strong>usr<strong>/</strong>bin<strong>/java java</strong>
$JDK<strong>/</strong>bin<strong>/java</strong> 2 $
<strong>sudo</strong> alternatives --install
<strong>/</strong>usr<strong>/</strong>bin<strong>/javac javac</strong>
$JDK<strong>/</strong>bin<strong>/javac</strong> 2 $
<strong>sudo</strong> alternatives --install
<strong>/</strong>usr<strong>/</strong>bin<strong>/jar jar</strong>
$JDK<strong>/</strong>bin<strong>/jar</strong> 2</p>
<p>And so on.</p>
<p>Now you can switch between different versions of a Java command as
follows:</p>
<p>$ <strong>sudo</strong> alternatives --config
<strong>javac</strong></p>
<p>There is 1 program that provides 'javac'.</p>
<p>Selection Command</p>
<p>-----------------------------------------------</p>
<p><strong>*</strong>+ 1
<strong>/</strong>usr<strong>/</strong>lib<strong>/</strong>jvm<strong>/</strong>java-1.8.0-openjdk-1.8.0.101-1.b14.fc23.x86_64<strong>/</strong>bin<strong>/javac</strong></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 927</p>
<p><span id="2____________Data_jdk1_8_0_67_bi" class="anchor"></span>2
<strong>/</strong>Data<strong>/</strong>jdk1.8.0_67<strong>/</strong>bin<strong>/javac</strong></p>
<p>Enter to keep the current
selection<strong>[</strong>+<strong>]</strong>, or <strong>type</strong>
selection number: 2 $</p>
<p>For more information on using alternatives<a
href="http://linux.die.net/man/8/alternatives">, refer to the
alternatives(8)</a> manual entry.</p>
<p>Arch based installs</p>
<p>Arch Linux based installs come with the command archlinux-java to
switch java versions.</p>
<p>Listing installed environments</p>
<p>$ archlinux-java status</p>
<p>Available Java environments:</p>
<p>java-7-openjdk (<strong>default</strong>)</p>
<p>java-8-openjdk/jre</p>
<p>Switching current environment</p>
<p># archlinux-java set</p>
<p>Eg:</p>
<p># archlinux-java set java-8-openjdk/jre</p>
<p><a
href="https://wiki.archlinux.org/index.php/java#Switching_between_JVM">More
information can be found on the Arch Linux Wiki</a></p>
<p>Section A.6: What do I need for Java Development</p>
<p>A JDK installation and a text editor are the bare minimum for Java
development. (It is nice to have a text editor that</p>
<p>can do Java syntax highlighting, but you can do without.)</p>
<p>However for serious development work it is recommended that you also
use the following:</p>
<p>A Java IDE such as Eclipse, Intellij IDEA or NetBeans</p>
<p>A Java build tool such as Ant, Gradle or Maven</p>
<p>A version control system for managing your code base (with
appropriate backups, and off-site replication)</p>
<p>Test tools and CI (continuous integration) tools</p>
<p>Section A.7: Selecting an appropriate Java SE release</p>
<p>There have been many releases of Java since the original Java 1.0
release in 1995. (Refer to <a
href="https://en.wikipedia.org/wiki/Java_version_history">Java version
history</a> for a</p>
<p>summary.) However most releases have passed their official End Of
Life dates. This means that the vendor (typically Oracle now) has ceased
new development for the release, and no longer provides public / free
patches for any bugs</p>
<p>or security issues. (Private patch releases are typically available
for people / organizations with a support contract;</p>
<p>contact your vendor's sales office.)</p>
<p>In general, the recommended Java SE release for use will be the
latest update for the latest public version. Currently, this means the
latest available Java 8 release. Java 9 is due for public release in
2017. (Java 7 has passed</p>
<p>its End Of Life and the last public release was in April 2015. Java 7
and earlier releases are not recommended.)</p>
<p>This recommendation applies for all new Java development, and anyone
learning Java. It also applies to people who</p>
<p>just want to run Java software provided by a third-party. Generally
speaking, well-written Java code will work on a newer release of Java.
(But check the software's release notes, and contact the author /
supplier / vendor if you</p>
<p>have doubts.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 928</p>
<p><span id="If_you_are_working_on_an_older_J" class="anchor"></span>If
you are working on an older Java codebase, you would be advised to
ensure that your code runs on the latest release of Java. Deciding when
to start using the features of newer Java releases is more difficult, as
this will impact</p>
<p>your ability to support customers who are unable or unwilling their
Java installation.</p>
<p>Section A.8: Java release and version naming</p>
<p>Java release naming is a little confusing. There are actually two
systems of naming and numbering, as shown in this</p>
<p>table:</p>
<p>JDK version Marketing name</p>
<p>jdk-1.0 JDK 1.0</p>
<p>jdk-1.1 JDK 1.1</p>
<p>jdk-1.2 J2SE 1.2</p>
<p>... ...</p>
<p>jdk-1.5 J2SE 1.5 rebranded Java SE 5</p>
<p>jdk-1.6 Java SE 6</p>
<p>jdk-1.7 Java SE 7</p>
<p>jdk-1.8 Java SE 8</p>
<p>jdk-91 Java SE 9 (not released yet)</p>
<p>1 - It appears that Oracle intends to break from their previous
practice of using a "semantic version number"</p>
<p>scheme in the Java version strings. It remains to be seen if they
will follow through with this.</p>
<p>The "SE" in the marketing names refers to Standard Edition. This is
the base release for running Java on most</p>
<p>laptops, PCs and servers (apart from Android).</p>
<p>There are two other official editions of Java: "Java ME" is the Micro
Edition, and "Java EE" is the Enterprise Edition.</p>
<p>The Android flavor of Java is also significantly different from Java
SE. Java ME, Java EE and Android Java are outside of the scope of this
Topic.</p>
<p>The full version number for a Java release looks like this:</p>
<p>1.8.0_101-b13</p>
<p>This says JDK 1.8.0, Update 101, Build #13. Oracle refers to this in
the release notes as:</p>
<p>Java ™ SE Development Kit 8, Update 101 (JDK 8u101)</p>
<p>The update number is important -- Oracle regularly issue updates to a
major release with security patches, bug</p>
<p>fixes and (in some cases) new features. The build number is usually
irrelevant. Note that Java 8 and Java 1.8 <em>refer to</em> <em>the same
thing</em>; Java 8 is just the "marketing" name for Java 1.8.</p>
<p>Section A.9: Installing Oracle Java on Linux with latest tar file</p>
<p>Follow the below steps to install Oracle JDK from the latest tar
file:</p>
<p>1. <a
href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Download
the latest tar file from here - Current latest is Java SE Development
Kit 8u112.</a></p>
<p>2. You need sudo privilages:</p>
<p>sudo su</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 929</p>
<p><span id="3__Create_a_dir_for_jdk_install" class="anchor"></span>3.
Create a dir for jdk install:</p>
<p>mkdir /opt/jdk</p>
<p>4. Extract downloaded tar into it:</p>
<p>tar -zxf jdk-8u5-linux-x64.tar.gz-C /opt/jdk</p>
<p>5. Verify if the files are extracted:</p>
<p>ls /opt/jdk</p>
<p>6. Setting Oracle JDK as the default JVM:</p>
<p>update-alternatives --install /usr/bin/java java
/opt/jdk/jdk1.8.0_05/bin/java 100</p>
<p>and</p>
<p>update-alternatives --install /usr/bin/javac javac
/opt/jdk/jdk1.8.0_05/bin/javac 100</p>
<p>7. Check Java version:</p>
<p>java -version</p>
<p>Expected output:</p>
<p>java version "1.8.0_111"</p>
<p>Java(TM) SE Runtime Environment (build 1.8.0_111-b14) Java
HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</p>
<p>Section A.10: Post-installation checking and configuration on</p>
<p>Linux</p>
<p>After installing a Java SDK, it is advisable to check that it is
ready to use. You can do this by running these two</p>
<p>commands, using your normal user account:</p>
<p>$ java -version</p>
<p>$ javac -version</p>
<p>These commands print out the version information for the JRE and JDK
(respectively) that are on your shell's</p>
<p>command search path. Look for the JDK / JRE version string.</p>
<p>If either of the above commands fails, saying "command not found",
then the JRE or JDK is not on the search</p>
<p>path at all; go to <strong>Configuring PATH directly</strong>
below.</p>
<p>If either of the above commands displays a different version string
to what you were expecting, then either</p>
<p>your search path or the "alternatives" system needs adjusting; go to
<strong>Checking Alternatives</strong></p>
<p>If the correct version strings are displayed, you are nearly done;
skip to <strong>Checking JAVA_HOME</strong></p>
<p>Configuring PATH directly</p>
<p>If there is no java or javac on the search path at the moment, then
the simple solution is to add it to your search</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 930</p>
<p>path.</p>
<p>First, find where you installed Java; see <strong>Where was Java
installed?</strong> below if you have doubts.</p>
<p>Next, assuming that bash is your command shell, use a text editor to
add the following lines to the end of either</p>
<p>~/.bash_profile or ~/.bashrc (If you use Bash as your shell).</p>
<p>JAVA_HOME=</p>
<p>PATH=$JAVA_HOME/bin:$PATH</p>
<p>export JAVA_HOME</p>
<p>export PATH</p>
<p>... replacing <strong>&lt;installation</strong>
directory<strong>&gt;</strong> with the pathname for your Java
installation directory. Note that the above assumes that the
installation directory contains a bin directory, and the bin directory
contains the java and javac</p>
<p>commands that you are trying to use.</p>
<p>Next, source the file that you just edited, so that the environment
variables for your current shell are updated.</p>
<p>$ source ~/.bash_profile</p>
<p>Next, repeat the java and javac version checks. If there are still
problems, use which java and which javac to</p>
<p>verify that you have updates the environment variables correctly.</p>
<p>Finally, logout and login again so that the updated environment
variables ptopagate to all of your shells. You should now be done.</p>
<p>Checking Alternatives</p>
<p>If java -version or javac -version worked but gave an unexpected
version number, you need to check where the commands are coming from.
Use which and ls -l to find this out as follows:</p>
<p>$ ls -l `which java`</p>
<p>If the output looks like this, :</p>
<p>lrwxrwxrwx. 1 root root 22 Jul 30 22:18 /usr/bin/java -&gt;
/etc/alternatives/java</p>
<p>then the alternatives version switching is being used. You needs to
decide whether to continue using it, or simply</p>
<p>override it by setting the PATH directly.</p>
<p>Configuring and Switching Java versions on Linux using
alternatives</p>
<p>See "Configuring PATH directly" above.</p>
<p>Where was Java installed?</p>
<p>Java can be installed in a variety of places, depending on the
installation method.</p>
<p>The Oracle RPMs put the Java installation in "/usr/java".</p>
<p>On Fedora, the default location is "/usr/lib/jvm".</p>
<p>If Java was installed by hand from ZIP or JAR files, the installation
could be anywhere.</p>
<p>If you are having difficultly finding the installation directory, We
suggest that you use find (or slocate) to find the command. For
example:</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 931</p>
<p>$ find /-name java -type f 2&gt; /dev/<strong>null</strong></p>
<p>This gives you the pathnames for all files called java on your
system. (The redirection of standard error to</p>
<p>"/dev/null" suppresses messages about files and directories that you
can't access.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 932</p>
<p><span id="Appendix_B__Java_Editions__Versi"
class="anchor"></span>Appendix B: Java Editions, Versions,</p>
<p>Releases and Distributions</p>
<p>Section B.1: Dierences between Java SE JRE or Java SE JDK</p>
<p>distributions</p>
<p>Sun / Oracle releases of Java SE come in two forms: JRE and JDK. In
simple terms, JREs support running Java</p>
<p>applications, and JDKs also support Java development.</p>
<p>Java Runtime Environment</p>
<p>Java Runtime Environment or JRE distributions consist of the set of
libraries and tools needed to run and manage</p>
<p>Java applications. The tools in a typical modern JRE include:</p>
<p>The java command for running a Java program in a JVM (Java Virtual
Machine)</p>
<p>The jjs command for running the Nashorn Javascript engine. The
keytool command for manipulating Java keystores.</p>
<p>The policytool command for editing security sandbox security
policies. The pack200 and unpack200 tools for packing and unpacking
"pack200" file for web deployment.</p>
<p>The orbd, rmid, rmiregistry and tnameserv commands that support Java
CORBA and RMI applications.</p>
<p>"Desktop JRE" installers include a Java plugin suitable for some web
browser. This is deliberately left out of "Server</p>
<p>JRE" installers.linux syscall read benchmarku</p>
<p>From Java 7 update 6 onwards, JRE installers have included JavaFX
(version 2.2 or later).</p>
<p>Java Development Kit</p>
<p>A Java Development Kit or JDK distribution includes the JRE tools,
and additional tools for developing Java software.</p>
<p>The additional tools typically include:</p>
<p>The javac command, which compiles Java source code (".java") to
bytecode files (".class").</p>
<p>The tools for creating JAR files such as jar and jarsigner</p>
<p>Development tools such as:</p>
<p>appletviewer for running applets</p>
<p>idlj the CORBA IDL to Java compiler</p>
<p>javah the JNI stub generator</p>
<p>native2ascii for character set conversion of Java source code
schemagen the Java to XML schema generator (part of JAXB)</p>
<p>serialver generate Java Object Serialization version string. the
wsgen and wsimport support tools for JAX-WS</p>
<p>Diagnostic tools such as:</p>
<p>jdb the basic Java debugger</p>
<p>jmap and jhat for dumping and analysing a Java heap.</p>
<p>jstack for getting a thread stack dump.</p>
<p>javap for examining ".class" files.</p>
<p>Application management and monitoring tools such as:</p>
<p>jconsole a management console,</p>
<p>jstat , jstatd, jinfo and jps for application monitoring</p>
<p>A typical Sun / Oracle JDK installation also includes a ZIP file with
the source code of the Java libraries. Prior to Java</p>
<p>6, this was the only publicly available Java source code.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 933</p>
<p><span id="From_Java_6_onwards__the_complet"
class="anchor"></span>From Java 6 onwards, the complete source code for
OpenJDK is available for download from the OpenJDK site. It is typically
not included in (Linux) JDK packages, but is available as a separate
package.</p>
<p>Section B.2: Java SE Versions</p>
<p>Java SE Version History</p>
<p>The following table provides the timeline for the significant major
versions of the Java SE platform.</p>
<p>Java SE Version1 Code Name End-of-life (free2) Release Date</p>
<p><a
href="https://docs.oracle.com/javase/10/docs/api/overview-summary.html">Java
SE 10 (Early Access)</a> <em>None</em> future 2018-03-20 (estimated)</p>
<p><a href="http://download.java.net/java/jdk9/docs/api/">Java SE 9</a>
<em>None</em> future 2017-07-27)</p>
<p><a href="http://docs.oracle.com/javase/8/docs/api/">Java SE 8</a>
<em>None</em> future 2014-03-18</p>
<p><a href="http://docs.oracle.com/javase/7/docs/api/">Java SE 7</a>
Dolphin 2015-04-14 2011-07-28</p>
<p><a href="http://docs.oracle.com/javase/6/docs/api/">Java SE 6</a>
Mustang 2013-04-16 2006-12-23</p>
<p><a href="http://docs.oracle.com/javase/1.5.0/docs/api/">Java SE 5</a>
Tiger 2009-11-04 2004-10-04</p>
<p><a href="http://docs.oracle.com/javase/1.4.2/docs/api/">Java SE
1.4.2</a> Mantis prior to 2009-11-04 2003-06-26</p>
<p>Java SE 1.4.1 Hopper / Grasshopper prior to 2009-11-04 2002-09-16</p>
<p>Java SE 1.4 Merlin prior to 2009-11-04 2002-02-06</p>
<p>Java SE 1.3.1 Ladybird prior to 2009-11-04 2001-05-17</p>
<p><a href="http://docs.oracle.com/javase/1.3/docs/api/">Java SE 1.3</a>
Kestrel prior to 2009-11-04 2000-05-08</p>
<p>Java SE 1.2 Playground prior to 2009-11-04 1998-12-08</p>
<p>Java SE 1.1 Sparkler prior to 2009-11-04 1997-02-19</p>
<p>Java SE 1.0 Oak prior to 2009-11-04 1996-01-21</p>
<p>Footnotes:</p>
<p>1. The links are to online copies of the respective releases
documentation on Oracle's website. The</p>
<p>documentation for many older releases no longer online, though it
typically can be downloaded from the Oracle Java Archives.</p>
<p>2. Most historical versions of Java SE have passed their official
"end of life" dates. When a Java version passes</p>
<p>this milestone, Oracle stop providing free updates for it. Updates
are still available to customers with support contracts.</p>
<p>Source:</p>
<p><a href="http://mindprod.com/jgloss/jdkreleasedates.html">JDK release
dates by Roedy Green of Canadian Mind Products</a></p>
<p>Java SE Version Highlights</p>
<p>Version Java SE Highlights</p>
<p>Lambda expressions and MapReduce-inspired Streams. The Nashorn
Javascript engine. Annotations</p>
<p>Java SE 8 on types and repeating annotations. Unsigned arithmetic
extensions. New Date and Time APIs.</p>
<p>Statically linked JNI libraries. JavaFX launcher. Removal of
PermGen.</p>
<p>String switches, <em>try-with-resource</em>, the diamond
(&lt;<strong>&gt;</strong>), numeric literal enhancements and
exception</p>
<p>Java SE 7 handling / rethrowing improvements. Concurrency library
enhancements. Enhanced support for native file systems. Timsort. ECC
crypto algorithms. Improved 2D graphics (GPU) support. Pluggable</p>
<p>annotations.</p>
<p>Java SE 6 Significant performance enhancements to JVM platform and
Swing. Scripting language API and Mozilla Rhino Javascript engine. JDBC
4.0. Compiler API. JAXB 2.0. Web Services support (JAX-WS)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 934</p>
<p><span id="Generics__annotations__auto_boxi"
class="anchor"></span>Generics, annotations, auto-boxing,
<strong>enum</strong> classes, varargs, enhanced <strong>for</strong>
loops and static imports.</p>
<p>Java SE 5 Specification of the Java Memory Model. Swing and RMI
enhancements. Addition of</p>
<p>java.util.concurrent.* package and Scanner.</p>
<p>The <strong>assert</strong> keyword. Regular expression classes.
Exception chaining. NIO APIs - non-blocking I/O,</p>
<p>Java SE 1.4 Buffer and Channel. java.util.logging.* API. Image I/O
API. Integrated XML and XSLT (JAXP).</p>
<p>Integrated security and cryptography (JCE, JSSE, JAAS). Integrated
Java Web Start. Preferences API.</p>
<p>Java SE 1.3 HotSpot JVM included. CORBA / RMI integration. Java
Naming and Directory Interface (JNDI). Debugger framework (JPDA).
JavaSound API. Proxy API.</p>
<p>Java SE 1.2 The <strong>strictfp</strong> keyword. Swing APIs. The
Java plugin (for web browsers). CORBA interoperability. Collections
framework.</p>
<p>Java SE 1.1 Inner classes. Reflection. JDBC. RMI. Unicode / character
streams. Internationalization support. Overhaul of AWT event model.
JavaBeans.</p>
<p>Source:</p>
<p>Wikipedia: <a
href="https://en.wikipedia.org/wiki/Java_version_history">Java version
history</a></p>
<p>Section B.3: Dierences between Java EE, Java SE, Java ME</p>
<p>and JavaFX</p>
<p>Java technology is both a programming language and a platform. The
Java programming language is a high-level</p>
<p>object-oriented language that has a particular syntax and style. A
Java platform is a particular environment in which Java programming
language applications run.</p>
<p>There are several Java platforms. Many developers, even long-time
Java programming language developers, do not understand how the
different platforms relate to each other.</p>
<p>The Java Programming Language Platforms</p>
<p>There are four platforms of the Java programming language:</p>
<p>Java Platform, Standard Edition (Java SE)</p>
<p>Java Platform, Enterprise Edition (Java EE)</p>
<p>Java Platform, Micro Edition (Java ME)</p>
<p>Java FX</p>
<p>All Java platforms consist of a Java Virtual Machine (VM) and an
application programming interface (API). The Java</p>
<p>Virtual Machine is a program, for a particular hardware and software
platform, that runs Java technology applications. An API is a collection
of software components that you can use to create other software
components</p>
<p>or applications. Each Java platform provides a virtual machine and an
API, and this allows applications written for that platform to run on
any compatible system with all the advantages of the Java programming
language:</p>
<p>platform-independence, power, stability, ease-of-development, and
security.</p>
<p>Java SE</p>
<p>When most people think of the Java programming language, they think
of the Java SE API. Java SE's API provides the</p>
<p>core functionality of the Java programming language. It defines
everything from the basic types and objects of the</p>
<p>Java programming language to high-level classes that are used for
networking, security, database access, graphical user interface (GUI)
development, and XML parsing.</p>
<p>In addition to the core API, the Java SE platform consists of a
virtual machine, development tools, deployment</p>
<p>technologies, and other class libraries and toolkits commonly used in
Java technology applications.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 935</p>
<p>Java EE</p>
<p>The Java EE platform is built on top of the Java SE platform. The
Java EE platform provides an API and runtime</p>
<p>environment for developing and running large-scale, multi-tiered,
scalable, reliable, and secure network applications.</p>
<p>Java ME</p>
<p>The Java ME platform provides an API and a small-footprint virtual
machine for running Java programming language applications on small
devices, like mobile phones. The API is a subset of the Java SE API,
along with special class</p>
<p>libraries useful for small device application development. Java ME
applications are often clients of Java EE platform services.</p>
<p>Java FX</p>
<p>Java FX technology is a platform for creating rich internet
applications written in Java FX ScriptTM. Java FX Script is a
statically-typed declarative language that is compiled to Java
technology bytecode, which can then be run on a Java</p>
<p>VM. Applications written for the Java FX platform can include and
link to Java programming language classes, and may be clients of Java EE
platform services.</p>
<p><a
href="http://docs.oracle.com/javaee/6/firstcup/doc/gkhoy.html">Taken
from the Oracle documentation</a></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 936</p>
<p><span id="Appendix_C__The_Classpath" class="anchor"></span>Appendix
C: The Classpath</p>
<p>The classpath lists places where the Java runtime should look for
classes and resources. The classpath is also used</p>
<p>by the Java compiler to find previously compiled and external
dependencies.</p>
<p>Section C.1: Dierent ways to specify the classpath</p>
<p>There are three ways to set the classpath.</p>
<p>1. It can be set using the CLASSPATH environment variable :</p>
<p>set CLASSPATH=... # Windows and csh</p>
<p>export CLASSPATH=... # Unix ksh/bash</p>
<p>2. It can be set on the command line as follows</p>
<p>java -classpath ...</p>
<p>javac-classpath ...</p>
<p>Note that the -classpath (or -cp) option takes precedence over the
CLASSPATH environment variable.</p>
<p>3. The classpath for an executable JAR file is specified using the
Class-Path element in MANIFEST.MF:</p>
<p>Class-Path: jar1-name jar2-name directory-name/jar3-name</p>
<p>Note that this only applies when the JAR file is executed like
this:</p>
<p>java -jar some.jar ...</p>
<p>In this mode of execution, the -classpath option and the CLASSPATH
environment variable will be ignored,</p>
<p>even if the JAR file has no Class-Path element.</p>
<p>If no classpath is specified, then the default classpath is the
selected JAR file when using java -jar, or the current</p>
<p>directory otherwise.</p>
<p>Related:</p>
<p><a
href="https://docs.oracle.com/javase/tutorial/deployment/jar/downman.html">https://docs.oracle.com/javase/tutorial/deployment/jar/downman.html</a></p>
<p><a
href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/classpath.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/classpath.html</a></p>
<p>Section C.2: Adding all JARs in a directory to the classpath</p>
<p>If you want to add all the JARs in directory to the classpath, you
can do this concisely using classpath wildcard</p>
<p>syntax; for example:</p>
<p>someFolder<em>/*</em></p>
<p>This tells the JVM to add all JAR and ZIP files in the someFolder
directory to the classpath. This syntax can be used in a -cp argument, a
CLASSPATH environment variable, or a Class-Path attribute in an
executable JAR file's manifest</p>
<p><em>file.See</em> <a
href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html#A1100762">Setting
the Class Path: Class Path Wild Cards</a> <em>for examples and
caveats.</em></p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 937</p>
<p><span id="Notes" class="anchor"></span>Notes:</p>
<p>1. Classpath wildcards were first introduced in Java 6. Earlier
versions of Java do not treat "*" as a wildcard.</p>
<p>2. You cannot put other characters before or after the "<em>"; e.g.
"someFolder/</em>.jar" is not a wildcard. 3. A wildcard matches only
files with the suffix ".jar" or ".JAR". ZIP files are ignored, as are
JAR files with a</p>
<p>different suffixes.</p>
<p>4. A wildcard matches only JAR files in the directory itself, not in
its subdirectories.</p>
<p>5. When a group of JAR files is matched by a wildcard entry, their
relative order on the classpath is not specified.</p>
<p>Section C.3: Load a resource from the classpath</p>
<p>It can be useful to load a resource (image, text file, properties,
KeyStore, ...) that is packaged inside a JAR. For this</p>
<p>purpose, we can use the <strong>Class</strong> and ClassLoaders.</p>
<p>Suppose we have the following project structure:</p>
<p>program.jar</p>
<p>|</p>
<p>\-com</p>
<p>\-project</p>
<p>|</p>
<p>|-file.txt</p>
<p>\-Test.class</p>
<p>And we want to access the contents of file.txt from the Test class.
We can do so by asking the classloader:</p>
<p>InputStream is =
Test.<strong>class</strong>.getClassLoader().getResourceAsStream("com/project/file.txt");</p>
<p>By using the classloader, we need to specify the fully qualified path
of our resource (each package).</p>
<p>Or alternatively, we can ask the Test class object directly</p>
<p>InputStream is =
Test.<strong>class</strong>.getResourceAsStream("file.txt");</p>
<p>Using the class object, the path is relative to the class itself. Our
Test.<strong>class</strong> being in the com.project package, the same
as file.txt, we do not need to specify any path at all.</p>
<p>We can, however, use absolute paths from the class object, like
so:</p>
<p>is =
Test.<strong>class</strong>.getResourceAsStream("/com/project/file.txt");</p>
<p>Section C.4: Classpath path syntax</p>
<p>The classpath is a sequence of entries which are directory pathnames,
JAR or ZIP file pathnames, or JAR / ZIP</p>
<p>wildcard specifications.</p>
<p>For a classpath specified on the command line (e.g. -classpath) or as
an environment variable, the entries</p>
<p>must be separated with ; (semicolon) characters on Windows, or :
(colon) characters on other platforms (Linux, UNIX, MacOSX and so
on).</p>
<p>For the Class-Path element in a JAR file's MANIFEST.MF, use a single
space to separate the entries.</p>
<p>Sometimes it is necessary to embed a space in a classpath entry</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 938</p>
<p><span id="When_the_classpath_is_specified" class="anchor"></span>When
the classpath is specified on the command line, it is simply a matter of
using the appropriate shell quoting. For example:</p>
<p>export CLASSPATH="/home/user/My JAR Files/foo.jar:second.jar"</p>
<p>(The details may depend on the command shell that you use.)</p>
<p>When the classpath is specified in a JAR file's a "MANIFEST.MF" file,
URL encoding must be used.</p>
<p>Class-Path: /home/user/My%20JAR%20Files/foo.jar second.jar</p>
<p>Section C.5: Dynamic Classpath</p>
<p>Sometimes, just adding all the JARs from a folder isn't enough, for
example when you have native code and need to</p>
<p>select a subset of JARs. In this case, you need two main() methods.
The first one builds a classloader and then uses this classloader to
call the second main().</p>
<p>Here is an example which selects the correct SWT native JAR for your
platform, adds all your application's JARs and</p>
<p>then invokes the real main() <a
href="http://stackoverflow.com/questions/2706222/create-cross-platform-java-swt-application/3204032#3204032">method:
Create cross platform Java SWT Application</a></p>
<p>Section C.6: Mapping classnames to pathnames</p>
<p>The standard Java toolchain (and 3rd-party tools designed to
interoperate with them) have specific rules for mapping the names of
classes to the pathnames of files and other resources that represent
them.</p>
<p>The mappings are as follows</p>
<p>For classes in the default package, the pathnames are simple
filenames. For classes in a named package, the package name components
map to directories.</p>
<p>For named nested and inner classes, the filename component is formed
by joining the class names with a $</p>
<p>character.</p>
<p>For anonymous inner classes, numbers are used in place of names.</p>
<p>This is illustrated in the following table:</p>
<p>Classname Source pathname Classfile pathname</p>
<p>SomeClass SomeClass.java SomeClass.<strong>class</strong></p>
<p>com.example.SomeClass com/example/SomeClass.java
com/example/SomeClass.<strong>class</strong></p>
<p>SomeClass.Inner (in SomeClass.java )
SomeClass$Inner.<strong>class</strong></p>
<p>SomeClass anon inner classes (in SomeClass.java )
SomeClass$1.<strong>class</strong>, SomeClass$2.<strong>class</strong>,
etc</p>
<p>Section C.7: The bootstrap classpath</p>
<p>The normal Java classloaders look for classes first in the bootstrap
classpath, before checking for extensions and the application classpath.
By default, the bootstrap classpath consists of the "rt.jar" file and
some other important</p>
<p>JAR files that are supplied by the JRE installation. These provide
all of the classes in the standard Java SE class</p>
<p>library, along with various "internal" implementation classes.</p>
<p>Under normal circumstances, you don't need to concern yourself with
this. By default, commands like java, javac</p>
<p>and so on will use the appropriate versions of the runtime
libraries.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 939</p>
<p><span id="Very_occasionally__it_is_necessa"
class="anchor"></span>Very occasionally, it is necessary to override the
normal behavior of the Java runtime by using an alternative version of a
class in the standard libraries. For example, you might encounter a
"show stopper" bug in the runtime libraries</p>
<p>that you cannot work around by normal means. In such a situation, it
is possible to create a JAR file containing the</p>
<p>altered class and then add it to the bootstrap classpath which
launching the JVM.</p>
<p>The java command provides the following -X options for modifying the
bootstrap classpath:</p>
<p>-Xbootclasspath: replaces the current boot classpath with the path
provided.</p>
<p>-Xbootclasspath/a: appends the provided path to the current boot
classpath.-Xbootclasspath/p: prepends the provided path to the current
boot classpath.</p>
<p>Note that when use the bootclasspath options to replace or override a
Java class (etcetera), you are technically modifying Java. There <em>may
be</em> licensing implications if you then distribute your code. (Refer
to the terms and</p>
<p>conditions of the Java Binary License ... and consult a lawyer.)</p>
<p>Section C.8: What the classpath means: how searches work</p>
<p>The purpose of the classpath is to tell a JVM where to find classes
and other resources. The meaning of the</p>
<p>classpath and the search process are intertwined.</p>
<p>The classpath is a form of search path which specifies a sequence of
<em>locations</em> to look for resources. In a standard</p>
<p>classpath, these places are either, a directory in the host file
system, a JAR file or a ZIP file. In each cases, the location is the
root of a <em>namespace</em> that will be searched.</p>
<p>The standard procedure for searching for a class on the classpath is
as follows:</p>
<p>1. Map the class name to a relative classfile pathname RP. The
mapping for class names to class filenames is</p>
<p>described elsewhere.</p>
<p>2. For each entry E in the classpath:</p>
<p>If the entry is a filesystem directory:</p>
<p>Resolve RP relative to E to give an absolute pathname AP.</p>
<p>Test if AP is a path for an existing file.</p>
<p>If yes, load the class from that file</p>
<p>If the entry is a JAR or ZIP file:</p>
<p>Lookup RP in the JAR / ZIP file index.</p>
<p>If the corresponding JAR / ZIP file entry exists, load the class from
that entry.</p>
<p>The procedure for searching for a resource on the classpath depends
on whether the resource path is absolute or relative. For an absolute
resource path, the procedure is as above. For a relative resource path
resolved using</p>
<p><strong>Class</strong>.getResource or
<strong>Class</strong>.getResourceAsStream, the path for the classes
package is prepended prior to searching.</p>
<p>(Note these are the procedures implemented by the standard Java
classloaders. A custom classloader might perform the search
differently.)</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 940</p>
<p><span id="Appendix_D__Resources__on_classp"
class="anchor"></span>Appendix D: Resources (on classpath)</p>
<p>Java allows the retrieval of file-based resources stored inside of a
JAR alongside compiled classes. This topic focuses</p>
<p>on loading those resources and making them available to your
code.</p>
<p>Section D.1: Loading default configuration</p>
<p>To read default configuration properties:</p>
<p><strong>package</strong> com.example;</p>
<p><strong>public class</strong> ExampleApplication {</p>
<p><strong>private</strong> Properties getDefaults()
<strong>throws</strong> IOException {</p>
<p>Properties defaults = <strong>new</strong> Properties();</p>
<p><strong>try</strong> (InputStream defaultsStream =</p>
<p>ExampleApplication.<strong>class</strong>.getResourceAsStream("config.properties"))
{</p>
<p>defaults.load(defaultsStream);</p>
<p>}</p>
<p><strong>return</strong> defaults;</p>
<p>}</p>
<p>}</p>
<p>Section D.2: Loading an image from a resource</p>
<p>To load a bundled image:</p>
<p><strong>package</strong> com.example;</p>
<p><strong>public class</strong> ExampleApplication {</p>
<p><strong>private</strong> Image getIcon() <strong>throws</strong>
IOException {</p>
<p>URL imageURL =
ExampleApplication.<strong>class</strong>.getResource("icon.png");
<strong>return</strong> ImageIO.read(imageURL);</p>
<p>}</p>
<p>}</p>
<p>Section D.3: Finding and reading resources using a</p>
<p>classloader</p>
<p>Resource loading in Java comprises the following steps:</p>
<p>1. Finding the <strong>Class</strong> or ClassLoader that will find
the resource.</p>
<p>2. Finding the resource.</p>
<p>3. Obtaining the byte stream for the resource.</p>
<p>4. Reading and processing the byte stream.</p>
<p>5. Closing the byte stream.</p>
<p>The last three steps are typically accomplished by passing the URL to
a library method or constructor to load the resource. You will typically
use a getResource method in this case. It is also possible to read the
resource data in</p>
<p>application code. You will typically use getResourceAsStream in this
case.</p>
<p>Absolute and relative resource paths</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 941</p>
<p>Resources that can be loaded from the classpath are denoted by a
<em>path</em>. The syntax of the path is similar to a UNIX / Linux file
path. It consists of simple names separated by forward slash (/)
characters. A <em>relative path</em> starts with a</p>
<p>name, and an <em>absolute path</em> starts with a separator.</p>
<p>As the Classpath examples describe, a JVM's classpath defines a
namespace by overlaying the namespaces of the</p>
<p>directories and JAR or ZIP files in the classpath. When an absolute
path is resolved, it the classloaders interpret the initial / as meaning
the root of the namespace. By contrast, a relative path <em>may be</em>
resolved relative to any "folder"</p>
<p>in the namespace. The folder used will depend on the object that you
use to resolve the path.</p>
<p>Obtaining a Class or Classloader</p>
<p>A resource can be located using either a <strong>Class</strong>
object or a ClassLoader object. A <strong>Class</strong> object can
resolve relative</p>
<p>paths, so you will typically use one of these if you have a (class)
relative resource. There are a variety of ways to</p>
<p>obtain a <strong>Class</strong> object. For example:</p>
<p>A <em>class literal</em> will give you the <strong>Class</strong>
object for any class that you can name in Java source code; e.g.
String.<strong>class</strong> gives you the <strong>Class</strong>
object for the String type.</p>
<p>The Object.getClass() will give you the <strong>Class</strong> object
for the type od any object; e.g. "hello".getClass() is</p>
<p>another way to get <strong>Class</strong> of the String type.</p>
<p>The <strong>Class</strong>.forName(String) method will (if necessary)
dynamically load a class and return its <strong>Class</strong> object;
e.g. <strong>Class</strong>.forName("java.lang.String").</p>
<p>A ClassLoader object is typically obtained by calling
getClassLoader() on a <strong>Class</strong> object. It is also possible
to get hold of the JVM's default classloader using the static
ClassLoader.getSystemClassLoader() method.</p>
<p>The get methods</p>
<p>Once you have a <strong>Class</strong> or ClassLoader instance, you
can find a resource, using one of the following methods:</p>
<p>Methods Description</p>
<p>ClassLoader.getResource(path) Returns a URL which represents the
location of the resource with the</p>
<p>ClassLoader.getResources(path) given path.</p>
<p>ClassLoader.getResources(path) Returns an Enumeration giving the URLs
which can be used to <strong>Class</strong>.getResources(path) locate
the foo.bar resource; see below.</p>
<p>ClassLoader.getResourceAsStream(path) Returns an InputStream from
which you can read the contents of the
<strong>Class</strong>.getResourceStream(path) foo.bar resource as a
sequence of bytes.</p>
<p>Notes:</p>
<p>The main difference between the ClassLoader and
<strong>Class</strong> versions of the methods is in the way that
relative paths are interpreted.</p>
<p>The <strong>Class</strong> methods resolve a relative path in the
"folder" that corresponds to the classes package.</p>
<p>The ClassLoader methods treat relative paths as if they were
absolute; i.e. the resolve them in the "root folder" of the classpath
namespace.</p>
<p>If the requested resource (or resources) cannot be found, the
getResource and</p>
<p>getResourceAsStreammethods <strong>return</strong>null, and
thegetResourcesmethods <strong>return</strong> an emptyEnumeration`.</p>
<p>The URLs returned will be resolvable using URL.toStream(). They could
be file: URLs or other conventional URLs, but if the resource resides in
a JAR file, they will be jar: URLs that identify the JAR file and a
specific</p>
<p>resource within it.</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 942</p>
<p><span id="If_your_code_uses_a_getResourceA" class="anchor"></span>If
your code uses a getResourceAsStream method (or URL.toStream()) to
obtain an InputStream, it is responsible for closing the stream object.
Failure to close the stream could lead to a resource leak.</p>
<p>Section D.4: Loading same-name resource from multiple</p>
<p>JARs</p>
<p>Resource with same path and name may exist in more than one JAR file
on the classpath. Common cases are</p>
<p>resources following a convention or that are part of a packaging
specification. Examples for such resources are</p>
<p>META-INF/MANIFEST.MF</p>
<p>META-INF/beans.xml (CDI Spec)</p>
<p>ServiceLoader properties containing implementation providers</p>
<p>To get access to <em>all</em> of these resources in different jars,
one has to use a ClassLoader, which has a method for this. The returned
Enumeration can be conveniently converted to a List using a Collections
function.</p>
<p>Enumeration resEnum =
MyClass.<strong>class</strong>.getClassLoader().getResources("META-INF/MANIFEST.MF");
ArrayList resources = Collections.list(resEnum);</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 943</p>
<p><span id="Credits" class="anchor"></span>Credits</p>
<p>Thank you greatly to all the people from Stack Overflow Documentation
who helped provide this content,</p>
<p>more changes can be sent to web@petercv.com for new content to be
published or updated</p>
<p><a href="https://stackoverflow.com/users/5381656/">100rabh</a>
Chapters 18 and 79</p>
<p><a href="https://stackoverflow.com/users/3927528/">17slim</a>
Chapters 28, 40, 72 and 109</p>
<p><a href="https://stackoverflow.com/users/4089359/">1d0m3n30</a>
Chapters 9, 35, 45, 47 and 106</p>
<p><a href="https://stackoverflow.com/users/5249858/">3442</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/2547495/">3751_Creator</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/5743988/">4castle</a>
Chapters 2 and 57</p>
<p><a href="https://stackoverflow.com/users/3230218/">A Boschman</a>
Chapters 42 and 67</p>
<p><a href="https://stackoverflow.com/users/264016/">A.J. Brown</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/34088/">Aaron Digulla</a>
Chapters 47 and 184</p>
<p><a href="https://stackoverflow.com/users/4441547/">Aaron Franke</a>
Chapter 56</p>
<p><a href="https://stackoverflow.com/users/626853/">Aasmund
Eldhuset</a> Chapter 46</p>
<p><a href="https://stackoverflow.com/users/7775489/">ABDUL KHALIQ</a>
Chapter 90</p>
<p><a href="https://stackoverflow.com/users/5790498/">Abhijeet</a>
Chapter 65</p>
<p><a href="https://stackoverflow.com/users/3857465/">Abhishek Jain</a>
Chapters 11, 23 and 79</p>
<p><a href="https://stackoverflow.com/users/1151456/">Abubakkar</a>
Chapters 11, 23, 57, 67 and 102</p>
<p><a href="https://stackoverflow.com/users/1850609/">acdcjunior</a>
Chapters 23 and 57</p>
<p><a href="https://stackoverflow.com/users/6451425/">Ad Infinitum</a>
Chapters 23, 24, 33, 43 and 73</p>
<p><a href="https://stackoverflow.com/users/6620312/">Adam Ratzman</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/42769/">Adeel Ansari</a>
Chapter 182</p>
<p><a href="https://stackoverflow.com/users/5236247/">Adowrath</a>
Chapters 79 and 164</p>
<p><a href="https://stackoverflow.com/users/4304038/">Adrian Krebs</a>
Chapters 11, 23, 54, 69, 74 and 111</p>
<p><a href="https://stackoverflow.com/users/3626698/">afzalex</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/1238944/">agilob</a>
Chapters 11, 23 and 69</p>
<p><a href="https://stackoverflow.com/users/1439946/">agoeb</a> Chapter
54</p>
<p><a href="https://stackoverflow.com/users/5322470/">Aiden Deom</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/2809449/">Aimee Borda</a>
Chapters 22 and 57</p>
<p><a href="https://stackoverflow.com/users/276052/">aioobe</a> Chapters
35 and 117</p>
<p><a href="https://stackoverflow.com/users/1736792/">ajablonski</a>
Chapter 182</p>
<p><a href="https://stackoverflow.com/users/3690024/">AJNeufeld</a>
Chapter 74</p>
<p><a href="https://stackoverflow.com/users/6943913/">akgren_soar</a>
Chapter 58</p>
<p><a href="https://stackoverflow.com/users/3869736/">Akhil S K</a>
Chapters 1, 66, 69, 117 and 182</p>
<p><a href="https://stackoverflow.com/users/1140748/">alain.janinm</a>
Chapters 16, 19 and 138</p>
<p><a href="https://stackoverflow.com/users/2669025/">Alek
Mieczkowski</a> Chapters 20, 33 and 78</p>
<p><a href="https://stackoverflow.com/users/6452488/">Alex A</a> Chapter
182</p>
<p><a href="https://stackoverflow.com/users/569046/">Alex Meiburg</a>
Chapters 11 and 47</p>
<p><a href="https://stackoverflow.com/users/2170192/">Alex Shesterov</a>
Chapters 11 and 20</p>
<p><a href="https://stackoverflow.com/users/1701465/">Alex T.</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/8195498/">Alexandre
Grimaud</a> Chapter 181</p>
<p><a href="https://stackoverflow.com/users/4590852/">Alexey Lagunov</a>
Chapter 83</p>
<p><a href="https://stackoverflow.com/users/2650960/">alexey
semenyuk</a> Chapters 47 and 117</p>
<p><a href="https://stackoverflow.com/users/2723001/">Alexiy</a> Chapter
149</p>
<p><a href="https://stackoverflow.com/users/6007933/">Alon .G.</a>
Chapter 43</p>
<p><a href="https://stackoverflow.com/users/3188061/">Alper Fırat
Kaya</a> Chapter 77</p>
<p><a href="https://stackoverflow.com/users/352315/">alphaloop</a>
Chapter 144</p>
<p><a href="https://stackoverflow.com/users/1130812/">altomnr</a>
Chapters 24 and 182</p>
<p><a href="https://stackoverflow.com/users/4957418/">Amani
Kilumanga</a> Chapters 10, 11, 35, 40, 80 and 111</p>
<p><a href="https://stackoverflow.com/users/6477936/">Amit Gujarathi</a>
Chapters 12, 29, 30, 31 and 180</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 944</p>
<p><a href="https://stackoverflow.com/users/453767/">Amit Gupta</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/5632321/">Anatoly
Yakimchuk</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/5221149/">Andreas</a>
Chapters 40, 99 and 106</p>
<p><a href="https://stackoverflow.com/users/1611055/">Andreas Fester</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/4922375/">Andrew</a>
Chapters 23, 40, 73 and 79</p>
<p><a href="https://stackoverflow.com/users/6619917/">Andrew Antipov</a>
Chapter 88</p>
<p><a href="https://stackoverflow.com/users/2278598/">Andrew Brooke</a>
Chapter 74</p>
<p><a href="https://stackoverflow.com/users/894973/">Andrew
Sklyarevsky</a> Chapter 35</p>
<p><a href="https://stackoverflow.com/users/5091346/">Andrii Abramov</a>
Chapters 41, 57, 73, 75, 81, 117 and 134</p>
<p><a href="https://stackoverflow.com/users/4969370/">Androbin</a>
Chapter 33</p>
<p><a href="https://stackoverflow.com/users/202009/">Andy Thomas</a>
Chapters 11, 80, 85 and 130</p>
<p><a href="https://stackoverflow.com/users/2142994/">Ani Menon</a>
Chapters 1, 42, 56 and 182</p>
<p><a href="https://stackoverflow.com/users/711308/">Anil</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/5850195/">ankidaemon</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/3373597/">Ankit Katiyar</a>
Chapters 73, 122 and 141</p>
<p><a href="https://stackoverflow.com/users/3027001/">Ankur Anand</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1060350/">Anony</a> Chapters
10, 11, 24, 35, 47, 73 and 89</p>
<p><a href="https://stackoverflow.com/users/7369809/">anotherGatsby</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/2275818/">Anthony
Raymond</a> Chapter 182</p>
<p><a href="https://stackoverflow.com/users/6544942/">Anton Hlinisty</a>
Chapter 130</p>
<p><a href="https://stackoverflow.com/users/4558709/">antonio</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/1448252/">anuvab1911</a>
Chapters 42 and 182</p>
<p><a href="https://stackoverflow.com/users/1981450/">ar4ers</a> Chapter
52</p>
<p><a href="https://stackoverflow.com/users/617157/">Arash</a> Chapter
122</p>
<p><a href="https://stackoverflow.com/users/3812201/">ArcticLord</a>
Chapters 103 and 105</p>
<p><a href="https://stackoverflow.com/users/3893496/">arcy</a> Chapters
16 and 68</p>
<p><a href="https://stackoverflow.com/users/3458/">Arkadiy</a> Chapters
1 and 54</p>
<p><a href="https://stackoverflow.com/users/4906610/">arpit pandey</a>
Chapter 21</p>
<p><a href="https://stackoverflow.com/users/3809164/">ArsenArsen</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/6395535/">Arthur</a>
Chapters 23, 71, 72, 77, 87, 93 and 110</p>
<p><a href="https://stackoverflow.com/users/166339/">Asaph</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/6462678/">AshanPerera</a>
Chapter 74</p>
<p><a href="https://stackoverflow.com/users/2515719/">Asiat</a> Chapter
41</p>
<p><a href="https://stackoverflow.com/users/829571/">assylias</a>
Chapters 73 and 126</p>
<p><a href="https://stackoverflow.com/users/3366929/">AstroCB</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/150830/">ata</a> Chapters 28
and 77</p>
<p><a href="https://stackoverflow.com/users/293099/">Athari</a> Chapters
23 and 57</p>
<p><a href="https://stackoverflow.com/users/2540669/">augray</a> Chapter
42</p>
<p><a href="https://stackoverflow.com/users/4921205/">Aurasphere</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/668540/">Austin</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/4539472/">Austin Day</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/5050431/">A_Arnold</a>
Chapters 11, 16, 18 and 26</p>
<p><a href="https://stackoverflow.com/users/872814/">Bart Kummel</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/2761035/">Batty</a> Chapter
66</p>
<p><a href="https://stackoverflow.com/users/283143/">bcosynot</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/1818045/">ben75</a> Chapter
97</p>
<p><a href="https://stackoverflow.com/users/2003642/">Bhavik Patel</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/1486762/">Bilbo Baggins</a>
Chapter 17</p>
<p><a href="https://stackoverflow.com/users/6042824/">Bilesh Ganguly</a>
Chapters 10 and 66</p>
<p><a href="https://stackoverflow.com/users/256376/">Binary Nerd</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/3842050/">Blubberguy22</a>
Chapters 25 and 40</p>
<p><a href="https://stackoverflow.com/users/89339/">bn.</a> Chapter
100</p>
<p><a href="https://stackoverflow.com/users/51754/">Bob Rivers</a>
Chapters 10, 16, 18, 24, 35, 70 and 123</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 945</p>
<p><a href="https://stackoverflow.com/users/5999533/">Bobas_Pett</a>
Chapter 85</p>
<p><a href="https://stackoverflow.com/users/5651359/">Bohdan
Korinnyi</a> Chapter 107</p>
<p><a href="https://stackoverflow.com/users/256196/">Bohemian</a>
Chapters 15, 45 and 54</p>
<p><a href="https://stackoverflow.com/users/1886012/">bowmore</a>
Chapters 17, 67 and 126</p>
<p><a href="https://stackoverflow.com/users/4936137/">Božo Stojković</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/2039482/">bpoiss</a>
Chapters 23 and 57</p>
<p><a href="https://stackoverflow.com/users/873043/">Brendon Dugan</a>
Chapter 129</p>
<p><a href="https://stackoverflow.com/users/142446/">Brett Kail</a>
Chapter 42</p>
<p><a href="https://stackoverflow.com/users/3553087/">Brian Goetz</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/3385651/">BrunoDM</a>
Chapter 41</p>
<p><a href="https://stackoverflow.com/users/1715829/">Buddy</a> Chapter
74</p>
<p><a href="https://stackoverflow.com/users/12860/">Burkhard</a>
Chapters 1, 6, 7, 11, 23, 54, 66, 69, 77 and 107</p>
<p><a href="https://stackoverflow.com/users/745750/">bwegs</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/4565682/">c.uent</a> Chapter
40</p>
<p><a href="https://stackoverflow.com/users/2047504/">c1phr</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/4816518/">Cache Staheli</a>
Chapters 11, 13, 23, 47 and 107</p>
<p><a href="https://stackoverflow.com/users/4005742/">CaffeineToCode</a>
Chapter 42</p>
<p><a href="https://stackoverflow.com/users/2489497/">Caleb Brinkman</a>
Chapters 6 and 74</p>
<p><a href="https://stackoverflow.com/users/1107607/">Caner Balım</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/1916721/">carloabelli</a>
Chapters 11 and 74</p>
<p><a href="https://stackoverflow.com/users/3940445/">Carlton</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/7563898/">CarManuel</a>
Chapter 71</p>
<p><a href="https://stackoverflow.com/users/6781533/">Carter
Brainerd</a> Chapter 6</p>
<p><a href="https://stackoverflow.com/users/2525319/">Cas Eliëns</a>
Chapter 74</p>
<p><a href="https://stackoverflow.com/users/261156/">Catalina Island</a>
Chapter 46</p>
<p><a href="https://stackoverflow.com/users/4663542/">cdm</a> Chapter
70</p>
<p><a href="https://stackoverflow.com/users/2649570/">ced</a> Chapters
24, 25, 26, 41 and 80</p>
<p><a href="https://stackoverflow.com/users/463213/">charlesreid1</a>
Chapter 85</p>
<p><a href="https://stackoverflow.com/users/4185234/">Charlie H</a>
Chapters 1, 23 and 67</p>
<p><a href="https://stackoverflow.com/users/1171622/">Chetya</a> Chapter
126</p>
<p><a href="https://stackoverflow.com/users/5456160/">Chirag Parmar</a>
Chapters 24, 26, 78 and 86</p>
<p><a href="https://stackoverflow.com/users/2591803/">Chris Midgley</a>
Chapter 40</p>
<p><a href="https://stackoverflow.com/users/2497492/">Christian</a>
Chapter 19</p>
<p><a href="https://stackoverflow.com/users/657205/">Christian
Wilkie</a> Chapter 16</p>
<p><a href="https://stackoverflow.com/users/4173303/">Christophe
Weis</a> Chapters 84, 103 and 115</p>
<p><a href="https://stackoverflow.com/users/3059385/">Christopher
Schneider</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/7167257/">Claudia</a>
Chapter 40</p>
<p><a href="https://stackoverflow.com/users/1117751/">Claudio</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/3179169/">clinomaniac</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/1456253/">code11</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/2775450/">Codebender</a>
Chapters 24, 41 and 47</p>
<p><a href="https://stackoverflow.com/users/1997093/">coder</a> Chapters
11, 23 and 35</p>
<p><a href="https://stackoverflow.com/users/1529061/">Coffee Ninja</a>
Chapter 98</p>
<p><a href="https://stackoverflow.com/users/8089674/">Coffeehouse
Coder</a> Chapters 1 and 74</p>
<p><a href="https://stackoverflow.com/users/5148907/">Cold Fire</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/4871061/">compuhosny</a>
Chapters 151 and 152</p>
<p><a href="https://stackoverflow.com/users/903291/">Confiqure</a>
Chapters 1, 23, 48, 85, 175 and 182</p>
<p><a href="https://stackoverflow.com/users/2267100/">Constantine</a>
Chapters 35 and 57</p>
<p><a href="https://stackoverflow.com/users/330057/">corsiKa</a> Chapter
126</p>
<p><a href="https://stackoverflow.com/users/5495287/">CraftedCart</a>
Chapters 5, 74 and 182</p>
<p><a href="https://stackoverflow.com/users/2308683/">cricket_007</a>
Chapter 42</p>
<p><a href="https://stackoverflow.com/users/825957/">cyberscientist</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/4909087/">c ʟ s</a> Chapter
1</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 946</p>
<p><a href="https://stackoverflow.com/users/1951909/">D D</a> Chapter
22</p>
<p><a href="https://stackoverflow.com/users/3858162/">Daniel</a> Chapter
10</p>
<p><a href="https://stackoverflow.com/users/1079174/">Daniel Käfer</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/4434245/">Daniel LIn</a>
Chapters 48 and 111</p>
<p><a href="https://stackoverflow.com/users/4508007/">Daniel M.</a>
Chapters 35, 46, 57, 73, 80, 112 and 177</p>
<p><a href="https://stackoverflow.com/users/4409409/">Daniel Nugent</a>
Chapters 81, 114, 130 and 139</p>
<p><a href="https://stackoverflow.com/users/5449709/">Daniel
Stradowski</a> Chapters 11, 23, 24, 26 and 57</p>
<p><a href="https://stackoverflow.com/users/5283746/">Daniel Wild</a>
Chapter 116</p>
<p><a href="https://stackoverflow.com/users/4566490/">Danilo
Guimaraes</a> Chapters 35 and 163</p>
<p><a href="https://stackoverflow.com/users/1961634/">Dariusz</a>
Chapters 23, 43, 54, 57, 82, 91, 102, 126, 128 and 138</p>
<p><a href="https://stackoverflow.com/users/6275934/">DarkV1</a>
Chapters 1, 11, 23 and 86</p>
<p><a href="https://stackoverflow.com/users/5409369/">Datagrammar</a>
Chapter 95</p>
<p><a href="https://stackoverflow.com/users/4161024/">Dave Ranjan</a>
Chapter 48</p>
<p><a href="https://stackoverflow.com/users/1305516/">David Grinberg</a>
Chapter 54</p>
<p><a href="https://stackoverflow.com/users/239101/">David Soroko</a>
Chapter 87</p>
<p><a href="https://stackoverflow.com/users/6639835/">DeepCoder</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/6228266/">Demon Coldmist</a>
Chapter 43</p>
<p><a href="https://stackoverflow.com/users/236247/">demongolem</a>
Chapter 26</p>
<p><a href="https://stackoverflow.com/users/2688050/">desilijic</a>
Chapter 176</p>
<p><a href="https://stackoverflow.com/users/6623910/">devguy</a> Chapter
79</p>
<p><a href="https://stackoverflow.com/users/1030974/">devnull69</a>
Chapter 93</p>
<p><a href="https://stackoverflow.com/users/4390212/">DimaSan</a>
Chapters 26, 33, 50 and 126</p>
<p><a href="https://stackoverflow.com/users/113632/">dimo414</a>
Chapters 69, 120 and 131</p>
<p><a href="https://stackoverflow.com/users/5620200/">Display Name</a>
Chapters 113 and 170</p>
<p><a href="https://stackoverflow.com/users/3439135/">Dmitriy Kotov</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/3745636/">dnup1092</a>
Chapters 10 and 11</p>
<p><a href="https://stackoverflow.com/users/3728901/">Do Nhu Vy</a>
Chapters 6 and 10</p>
<p><a href="https://stackoverflow.com/users/2719960/">DonyorM</a>
Chapters 54, 57 and 93</p>
<p><a href="https://stackoverflow.com/users/6304349/">dorukayhan</a>
Chapters 11, 20, 76, 87, 133 and 134</p>
<p><a href="https://stackoverflow.com/users/833070/">Draken</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/570291/">Drizzt321</a>
Chapters 43 and 103</p>
<p><a href="https://stackoverflow.com/users/4356188/">Duh</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/1759015/">Durgpal Singh</a>
Chapters 23 and 28</p>
<p><a href="https://stackoverflow.com/users/1458909/">Dushko
Jovanovski</a> Chapters 43, 57 and 130</p>
<p><a href="https://stackoverflow.com/users/4155961/">Dushman</a>
Chapters 111, 114 and 173</p>
<p><a href="https://stackoverflow.com/users/5966775/">DVarga</a>
Chapters 11, 23, 47, 54, 57 and 79</p>
<p><a href="https://stackoverflow.com/users/476690/">dwursteisen</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/4819996/">Dylan</a> Chapter
41</p>
<p><a href="https://stackoverflow.com/users/13226/">ebo</a> Chapter
74</p>
<p><a href="https://stackoverflow.com/users/17428/">Eduard Wirch</a>
Chapter 120</p>
<p><a href="https://stackoverflow.com/users/2948683/">Eilit</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/207421/">EJP</a> Chapters 66
and 145</p>
<p><a href="https://stackoverflow.com/users/2660039/">ekaerovets</a>
Chapter 97</p>
<p><a href="https://stackoverflow.com/users/2289509/">Elazar</a> Chapter
42</p>
<p><a href="https://stackoverflow.com/users/1411160/">Emil Sierżęga</a>
Chapters 23, 42, 115 and 182</p>
<p><a href="https://stackoverflow.com/users/2446574/">Emily Mabrey</a>
Chapters 28 and 185</p>
<p><a
href="https://stackoverflow.com/users/4029174/">emotionlessbananas</a>
Chapters 66 and 120</p>
<p><a href="https://stackoverflow.com/users/6382007/">Emre Bolat</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/3555000/">Enamul Hassan</a>
Chapter 56</p>
<p><a href="https://stackoverflow.com/users/597657/">Eng.Fouad</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/3554071/">engineercoding</a>
Chapter 33</p>
<p><a href="https://stackoverflow.com/users/5151575/">Enigo</a> Chapters
13, 24, 28, 42 and 77</p>
<p><a href="https://stackoverflow.com/users/1003123/">enrico.bacis</a>
Chapters 1, 11, 23 and 57</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 947</p>
<p><a href="https://stackoverflow.com/users/1442870/">Enwired</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/1221571/">Eran</a> Chapters
1, 23 and 24</p>
<p><a href="https://stackoverflow.com/users/3474/">erickson</a> Chapter
117</p>
<p><a href="https://stackoverflow.com/users/6093353/">Erik Minarini</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/178753/">Erkan Haspulat</a>
Chapter 56</p>
<p><a href="https://stackoverflow.com/users/1553934/">esin88</a>
Chapters 22, 172 and 179</p>
<p><a href="https://stackoverflow.com/users/2908793/">Etki</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/6391367/">explv</a> Chapters
16, 23, 54 and 57</p>
<p><a href="https://stackoverflow.com/users/5019769/">F. Stephen Q</a>
Chapters 87 and 143</p>
<p><a href="https://stackoverflow.com/users/2991525/">fabian</a>
Chapters 10, 13, 40, 43, 48, 74, 80, 85, 91, 103, 117, 122, 136 and
174</p>
<p><a href="https://stackoverflow.com/users/3431964/">faraa</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/5269673/">FFY00</a> Chapter
137</p>
<p><a href="https://stackoverflow.com/users/298029/">fgb</a> Chapter
13</p>
<p><a href="https://stackoverflow.com/users/219584/">fikovnik</a>
Chapter 67</p>
<p><a href="https://stackoverflow.com/users/982149/">Fildor</a> Chapters
3, 116, 126 and 127</p>
<p><a href="https://stackoverflow.com/users/6544665/">Filip Smola</a>
Chapter 2</p>
<p><a
href="https://stackoverflow.com/users/4250629/">FlyingPiMonster</a>
Chapters 40, 77 and 122</p>
<p><a href="https://stackoverflow.com/users/4174188/">FMC</a> Chapter
69</p>
<p><a href="https://stackoverflow.com/users/3517923/">foxt7ot</a>
Chapter 150</p>
<p><a href="https://stackoverflow.com/users/3453226/">Francesco
Menzani</a> Chapters 1, 10 and 97</p>
<p><a href="https://stackoverflow.com/users/3297820/">Freddie
Coleman</a> Chapter 126</p>
<p><a href="https://stackoverflow.com/users/2291955/">Friederike</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/3601420/">Functino</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/69783/">futureelite7</a>
Chapter 40</p>
<p><a href="https://stackoverflow.com/users/1606632/">f_puras</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/3580365/">Gal Dreiman</a>
Chapters 23, 35, 57, 69, 73, 130, 131, 132 and 183</p>
<p><a href="https://stackoverflow.com/users/485695/">gar</a> Chapters 10
and 73</p>
<p><a href="https://stackoverflow.com/users/3151415/">garg10may</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1964623/">Garreth
Golding</a> Chapter 19</p>
<p><a href="https://stackoverflow.com/users/4921429/">Gautam Jose</a>
Chapter 182</p>
<p><a href="https://stackoverflow.com/users/432378/">Gene Marin</a>
Chapters 23, 35 and 178</p>
<p><a href="https://stackoverflow.com/users/871270/">geniushkg</a>
Chapter 54</p>
<p><a href="https://stackoverflow.com/users/463304/">George Bailey</a>
Chapters 6 and 41</p>
<p><a href="https://stackoverflow.com/users/3985482/">Gerald Mücke</a>
Chapters 6, 22, 77, 130, 136 and 185</p>
<p><a href="https://stackoverflow.com/users/1531124/">GhostCat</a>
Chapter 43</p>
<p><a href="https://stackoverflow.com/users/5213194/">Gihan
Chathuranga</a> Chapter 86</p>
<p><a href="https://stackoverflow.com/users/1358722/">GingerHead</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/4047785/">giucal</a> Chapter
117</p>
<p><a href="https://stackoverflow.com/users/5818889/">glee8e</a> Chapter
93</p>
<p><a href="https://stackoverflow.com/users/1594933/">gontard</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/2131074/">GPI</a> Chapters
24, 28, 63, 73, 81, 108, 126, 135 and 184</p>
<p><a href="https://stackoverflow.com/users/2830342/">GradAsso</a>
Chapter 66</p>
<p><a href="https://stackoverflow.com/users/4532326/">granmirupa</a>
Chapters 23 and 25</p>
<p><a href="https://stackoverflow.com/users/179850/">Gray</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/539048/">GreenGiant</a>
Chapters 11, 69 and 88</p>
<p><a href="https://stackoverflow.com/users/845567/">Grexis</a> Chapters
35 and 146</p>
<p><a href="https://stackoverflow.com/users/118587/">Grzegorz
Oledzki</a> Chapter 57</p>
<p><a href="https://stackoverflow.com/users/415304/">Gubbel</a> Chapter
58</p>
<p><a href="https://stackoverflow.com/users/1107651/">Guilherme Torres
Castro</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/736244/">Gustavo Coelho</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/1125346/">gwintrob</a>
Chapter 67</p>
<p><a href="https://stackoverflow.com/users/3884852/">Gytis
Tenovimas</a> Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/1368690/">hamena314</a>
Chapters 11 and 85</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 948</p>
<p><a href="https://stackoverflow.com/users/3487617/">Hank D</a>
Chapters 57 and 73</p>
<p><a href="https://stackoverflow.com/users/4506528/">Hay</a> Chapter
77</p>
<p><a href="https://stackoverflow.com/users/740012/">Hazem Farahat</a>
Chapter 81</p>
<p><a href="https://stackoverflow.com/users/1768737/">HCarrasko</a>
Chapter 116</p>
<p><a href="https://stackoverflow.com/users/4923905/">hellrocker</a>
Chapter 126</p>
<p><a href="https://stackoverflow.com/users/1424875/">hexafraction</a>
Chapters 47, 69, 73, 126 and 144</p>
<p><a href="https://stackoverflow.com/users/1529983/">hirosht</a>
Chapter 54</p>
<p><a href="https://stackoverflow.com/users/2711488/">Holger</a> Chapter
137</p>
<p><a href="https://stackoverflow.com/users/1709946/">HON95</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/5684257/">HTNW</a> Chapters
82 and 130</p>
<p><a href="https://stackoverflow.com/users/2513200/">Hulk</a> Chapter
102</p>
<p><a href="https://stackoverflow.com/users/3790806/">hzpz</a> Chapter
67</p>
<p><a href="https://stackoverflow.com/users/464457/">Idcmp</a> Chapter
45</p>
<p><a href="https://stackoverflow.com/users/3739391/">iliketocode</a>
Chapters 1, 11, 23 and 57</p>
<p><a href="https://stackoverflow.com/users/1458740/">Ilya</a> Chapters
11, 23, 82, 93, 97, 118 and 126</p>
<p><a href="https://stackoverflow.com/users/4184530/">Infuzion</a>
Chapter 11</p>
<p><a
href="https://stackoverflow.com/users/6147266/">InitializeSahib</a>
Chapter 97</p>
<p><a href="https://stackoverflow.com/users/574351/">inovaovao</a>
Chapter 79</p>
<p><a href="https://stackoverflow.com/users/4490559/">intboolstring</a>
Chapters 23, 46, 74 and 79</p>
<p><a href="https://stackoverflow.com/users/5055401/">Inzimam Tariq
IT</a> Chapter 74</p>
<p><a href="https://stackoverflow.com/users/415877/">ipsi</a> Chapters
1, 10, 35, 171 and 182</p>
<p><a href="https://stackoverflow.com/users/6254077/">iqbal_cs</a>
Chapter 140</p>
<p><a href="https://stackoverflow.com/users/1601729/">Ironcache</a>
Chapters 3 and 166</p>
<p><a href="https://stackoverflow.com/users/596167/">Ivan Vergiliev</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/4683264/">J Atkin</a>
Chapters 10, 28, 43, 57, 58, 67, 73 and 89</p>
<p><a href="https://stackoverflow.com/users/4735402/">Jérémie Bolduc</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/4952551/">J. Pichardo</a>
Chapter 150</p>
<p><a href="https://stackoverflow.com/users/6451307/">J.D. Sandifer</a>
Chapter 117</p>
<p><a href="https://stackoverflow.com/users/2106815/">Jabir</a> Chapters
11, 16, 24, 28, 69, 72, 86 and 91</p>
<p><a href="https://stackoverflow.com/users/7294647/">Jacob G.</a>
Chapter 61</p>
<p><a href="https://stackoverflow.com/users/6655092/">JakeD</a> Chapter
10</p>
<p><a href="https://stackoverflow.com/users/1984357/">James Jensen</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/801894/">james large</a>
Chapters 42, 126 and 133</p>
<p><a href="https://stackoverflow.com/users/6342516/">James Oswald</a>
Chapter 79</p>
<p><a href="https://stackoverflow.com/users/1944335/">James Taylor</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/2357233/">JamesENL</a>
Chapters 42 and 53</p>
<p><a href="https://stackoverflow.com/users/527533/">Jan Vladimir
Mostert</a> Chapters 25, 47 and 79</p>
<p><a href="https://stackoverflow.com/users/641955/">janos</a> Chapters
25 and 89</p>
<p><a href="https://stackoverflow.com/users/3872894/">Jared Hooper</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/959/">jatanp</a> Chapter
178</p>
<p><a href="https://stackoverflow.com/users/5739389/">Jatin Balodhi</a>
Chapter 5</p>
<p><a href="https://stackoverflow.com/users/4521040/">javac</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/198166/">JAVAC</a> Chapter
81</p>
<p><a href="https://stackoverflow.com/users/3059893/">JavaHopper</a>
Chapters 1, 23, 40, 57, 69, 79 and 85</p>
<p><a href="https://stackoverflow.com/users/6523710/">Javant</a>
Chapters 23 and 85</p>
<p><a href="https://stackoverflow.com/users/1766828/">Javier Diaz</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/1056133/">jayantS</a>
Chapter 56</p>
<p><a href="https://stackoverflow.com/users/4741655/">JD9999</a>
Chapters 25 and 59</p>
<p><a href="https://stackoverflow.com/users/719263/">Jean</a> Chapter
16</p>
<p><a href="https://stackoverflow.com/users/5318192/">Jean Vitor</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4416792/">Jeet</a> Chapter
153</p>
<p><a href="https://stackoverflow.com/users/5893681/">Jeff Coleman</a>
Chapter 182</p>
<p><a href="https://stackoverflow.com/users/3614835/">Jeffrey
Bosboom</a> Chapters 23, 28, 52 and 54</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 949</p>
<p><a href="https://stackoverflow.com/users/1440897/">Jeffrey Lin</a>
Chapters 1 and 11</p>
<p><a href="https://stackoverflow.com/users/66686/">Jens Schauder</a>
Chapters 1, 23, 47, 48, 58, 69, 74, 88, 126 and 127</p>
<p><a href="https://stackoverflow.com/users/4347628/">Jeroen
Vandevelde</a> Chapter 73</p>
<p><a href="https://stackoverflow.com/users/4602283/">Jeutnarg</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/18157/">Jim Garrison</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6402939/">jitendra
varshney</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/4244993/">jmattheis</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6815131/">Joe C</a> Chapter
121</p>
<p><a href="https://stackoverflow.com/users/5223579/">Johannes</a>
Chapters 23, 35, 79 and 126</p>
<p><a href="https://stackoverflow.com/users/6230654/">John DiFini</a>
Chapters 64 and 161</p>
<p><a href="https://stackoverflow.com/users/5284011/">John Fergus</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/6280993/">John Nash</a>
Chapters 19, 21, 58 and 142</p>
<p><a href="https://stackoverflow.com/users/1946501/">John Slegers</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/1530494/">John Starich</a>
Chapter 135</p>
<p><a href="https://stackoverflow.com/users/2696779/">johnnyaug</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/2767207/">Jojodmo</a>
Chapters 10, 11, 23, 40 and 79</p>
<p><a href="https://stackoverflow.com/users/1950/">Jon Erickson</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/4428462/">JonasCz</a>
Chapters 11, 69, 74, 78, 86 and 95</p>
<p><a href="https://stackoverflow.com/users/69875/">Jonathan</a>
Chapters 1, 23, 28, 46, 57, 79, 84, 88 and 125</p>
<p><a href="https://stackoverflow.com/users/14811/">Jonathan Barbero</a>
Chapters 96 and 119</p>
<p><a href="https://stackoverflow.com/users/2397327/">Jonathan Lam</a>
Chapters 23 and 182</p>
<p><a href="https://stackoverflow.com/users/3419894/">JonK</a> Chapter
88</p>
<p><a href="https://stackoverflow.com/users/470341/">jopasserat</a>
Chapter 25</p>
<p><a href="https://stackoverflow.com/users/3850595/">Jordi Castilla</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/4793100/">Jordy Baylac</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/4779071/">Jorel Ali</a>
Chapter 71</p>
<p><a href="https://stackoverflow.com/users/3699139/">Jorn Vernee</a>
Chapters 4, 11, 42, 43, 47, 54, 57, 75, 79, 104, 126 and 135</p>
<p><a href="https://stackoverflow.com/users/8409/">Joshua Carmody</a>
Chapter 2</p>
<p><a href="https://stackoverflow.com/users/5986817/">JStef</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/4506140/">Jude Niroshan</a>
Chapters 11, 57, 67 and 73</p>
<p><a
href="https://stackoverflow.com/users/6357392/">JudgingNotJudging</a>
Chapters 13 and 73</p>
<p><a href="https://stackoverflow.com/users/575376/">juergen d</a>
Chapter 74</p>
<p><a href="https://stackoverflow.com/users/1124740/">jwd630</a> Chapter
177</p>
<p><a href="https://stackoverflow.com/users/856696/">K''</a> Chapter
184</p>
<p><a href="https://stackoverflow.com/users/519334/">k3b</a> Chapter
35</p>
<p><a href="https://stackoverflow.com/users/5614968/">kaartic</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/714965/">Kai</a> Chapters
52, 54, 69 and 79</p>
<p><a href="https://stackoverflow.com/users/1003886/">kajacx</a> Chapter
138</p>
<p><a href="https://stackoverflow.com/users/919158/">kann</a> Chapter
70</p>
<p><a href="https://stackoverflow.com/users/577123/">kaotikmynd</a>
Chapter 80</p>
<p><a href="https://stackoverflow.com/users/897024/">Kapep</a> Chapters
11, 43 and 57</p>
<p><a href="https://stackoverflow.com/users/3001733/">KartikKannapur</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/34240/">kasperjj</a> Chapter
97</p>
<p><a href="https://stackoverflow.com/users/5353128/">Kaushal28</a>
Chapters 20, 26 and 86</p>
<p><a href="https://stackoverflow.com/users/7550472/">Kaushik NP</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/321697/">kcoppock</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/80907/">KdgDev</a> Chapter
10</p>
<p><a href="https://stackoverflow.com/users/6670001/">Kelvin Kellner</a>
Chapter 159</p>
<p><a href="https://stackoverflow.com/users/1270789/">Ken Y</a> Chapter
122</p>
<p><a href="https://stackoverflow.com/users/13317/">Kenster</a> Chapters
11, 25, 28 and 63</p>
<p><a href="https://stackoverflow.com/users/1316346/">Kevin
DiTraglia</a> Chapter 54</p>
<p><a href="https://stackoverflow.com/users/1379329/">Kevin Raoofi</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/3502776/">Kevin Thorne</a>
Chapters 6, 23, 40 and 69</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 950</p>
<p><a href="https://stackoverflow.com/users/6387668/">Kichiin</a>
Chapter 87</p>
<p><a href="https://stackoverflow.com/users/3886961/">kiedysktos</a>
Chapter 95</p>
<p><a href="https://stackoverflow.com/users/3252477/">Kineolyan</a>
Chapter 22</p>
<p><a href="https://stackoverflow.com/users/18511/">Kip</a> Chapter
58</p>
<p><a href="https://stackoverflow.com/users/1940824/">KIRAN KUMAR
MATAM</a> Chapters 27, 30, 36, 37, 39, 49, 53, 58, 59 and 92</p>
<p><a href="https://stackoverflow.com/users/6625678/">Kirill Sokolov</a>
Chapter 89</p>
<p><a href="https://stackoverflow.com/users/4386547/">Kishore
Tulsiani</a> Chapter 164</p>
<p><a href="https://stackoverflow.com/users/3808179/">kristyna</a>
Chapter 45</p>
<p><a href="https://stackoverflow.com/users/48382/">Krzysztof Krasoń</a>
Chapter 25</p>
<p><a href="https://stackoverflow.com/users/2702815/">kstandell</a>
Chapters 11, 42 and 79</p>
<p><a href="https://stackoverflow.com/users/5230401/">KudzieChase</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/2287101/">Kuroda</a> Chapter
18</p>
<p><a href="https://stackoverflow.com/users/1369198/">Lachlan
Dowding</a> Chapter 86</p>
<p><a href="https://stackoverflow.com/users/692942/">Lankymart</a>
Chapter 56</p>
<p><a href="https://stackoverflow.com/users/6083675/">Laurel</a>
Chapters 79, 80 and 86</p>
<p><a href="https://stackoverflow.com/users/4000655/">leaqui</a> Chapter
77</p>
<p><a href="https://stackoverflow.com/users/33311/">Lernkurve</a>
Chapter 111</p>
<p><a href="https://stackoverflow.com/users/5647260/">Li357</a> Chapter
106</p>
<p><a href="https://stackoverflow.com/users/4714914/">Liju Thomas</a>
Chapters 23, 128 and 169</p>
<p><a href="https://stackoverflow.com/users/2036090/">llamositopia</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6245535/">Loris Securo</a>
Chapters 19, 23 and 56</p>
<p><a href="https://stackoverflow.com/users/1217989/">Luan Nico</a>
Chapters 23, 54, 89 and 103</p>
<p><a href="https://stackoverflow.com/users/717341/">Lukas Knuth</a>
Chapter 102</p>
<p><a href="https://stackoverflow.com/users/5227589/">M M</a> Chapter
14</p>
<p><a href="https://stackoverflow.com/users/589259/">Maarten Bodewes</a>
Chapters 20, 35, 86 and 140</p>
<p><a href="https://stackoverflow.com/users/2352462/">Mac70</a> Chapter
40</p>
<p><a href="https://stackoverflow.com/users/3138238/">madx</a> Chapters
1, 35 and 103</p>
<p><a href="https://stackoverflow.com/users/1079354/">Makoto</a>
Chapters 23, 70 and 74</p>
<p><a href="https://stackoverflow.com/users/3773011/">Makyen</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/3572733/">Malav</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/3199595/">Malt</a> Chapters
23, 32, 73, 88, 93 and 126</p>
<p><a href="https://stackoverflow.com/users/2736638/">Manish Kothari</a>
Chapters 19 and 128</p>
<p><a href="https://stackoverflow.com/users/1064245/">manouti</a>
Chapters 109, 156 and 168</p>
<p><a href="https://stackoverflow.com/users/3309466/">Manuel
Spigolon</a> Chapter 11</p>
<p><a href="https://stackoverflow.com/users/2420517/">Manuel Vieda</a>
Chapter 18</p>
<p><a href="https://stackoverflow.com/users/4382892/">Marc</a> Chapters
1 and 47</p>
<p><a href="https://stackoverflow.com/users/2890451/">Mark Green</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/4178262/">Mark Stewart</a>
Chapter 5</p>
<p><a href="https://stackoverflow.com/users/6754053/">Mark Yisri</a>
Chapters 46 and 71</p>
<p><a href="https://stackoverflow.com/users/1735406/">Maroun</a> Chapter
24</p>
<p><a href="https://stackoverflow.com/users/2910751/">Martin Frank</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/4616087/">Marvin</a>
Chapters 11 and 23</p>
<p><a href="https://stackoverflow.com/users/4475997/">MasterBlaster</a>
Chapters 48, 57 and 87</p>
<p><a href="https://stackoverflow.com/users/1509764/">Matas
Vaitkevicius</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/5502426/">Matěj Kripner</a>
Chapter 126</p>
<p><a href="https://stackoverflow.com/users/461958/">mateuscb</a>
Chapter 77</p>
<p><a href="https://stackoverflow.com/users/923847/">Matsemann</a>
Chapter 88</p>
<p><a href="https://stackoverflow.com/users/5024726/">Matt</a> Chapters
1, 23 and 47</p>
<p><a href="https://stackoverflow.com/users/1790644/">Matt Clark</a>
Chapters 11, 16, 58 and 86</p>
<p><a href="https://stackoverflow.com/users/1168884/">matt freake</a>
Chapters 20, 43 and 52</p>
<p><a href="https://stackoverflow.com/users/2261980/">Matthew Trout</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/775954/">Matthias Braun</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/1098603/">Matthieu</a>
Chapter 94</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 951</p>
<p><a href="https://stackoverflow.com/users/4336080/">Maxim
Kreschishin</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/5343328/">Maxim Plevako</a>
Chapters 11 and 23</p>
<p><a href="https://stackoverflow.com/users/2234742/">Maximillian
Laumeister</a> Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6579771/">mayha</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/997537/">mayojava</a>
Chapters 10 and 85</p>
<p><a href="https://stackoverflow.com/users/1447381/">MBorsch</a>
Chapter 10</p>
<p><a href="https://stackoverflow.com/users/4663552/">Md. Nasir Uddin
Bhuiyan</a> Chapters 20 and 126</p>
<p><a href="https://stackoverflow.com/users/13379/">Michael</a> Chapters
11 and 58</p>
<p><a href="https://stackoverflow.com/users/13531/">Michael Myers</a>
Chapters 35 and 103</p>
<p><a href="https://stackoverflow.com/users/2621917/">Michael Piefel</a>
Chapters 23, 45 and 126</p>
<p><a href="https://stackoverflow.com/users/6679991/">Michael von
Wenckstern</a> Chapter 7</p>
<p><a href="https://stackoverflow.com/users/117839/">Michael Wiles</a>
Chapter 67</p>
<p><a href="https://stackoverflow.com/users/1309035/">michaelbahr</a>
Chapters 28, 69 and 87</p>
<p><a href="https://stackoverflow.com/users/1995170/">Michał Rybak</a>
Chapter 135</p>
<p><a href="https://stackoverflow.com/users/905488/">Mick Mnemonic</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/4555785/">MikeW</a> Chapter
79</p>
<p><a href="https://stackoverflow.com/users/34746/">Miles</a> Chapters
11, 16 and 17</p>
<p><a href="https://stackoverflow.com/users/1460628/">Miljen Mikic</a>
Chapters 23, 42, 69 and 122</p>
<p><a href="https://stackoverflow.com/users/2822643/">Mimouni</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/413537/">Mimyck</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/6557067/">Mine_Stone</a>
Chapter 93</p>
<p><a href="https://stackoverflow.com/users/4684058/">Minhas Kamal</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/8353029/">Miroslav
Bradic</a> Chapter 88</p>
<p><a href="https://stackoverflow.com/users/2364405/">Mitch Talmadge</a>
Chapters 1 and 23</p>
<p><a href="https://stackoverflow.com/users/2608433/">mnoronha</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/2456732/">Mo.Ashfaq</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/5817706/">Mohamed Fadhl</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/5387134/">Mrunal Pagnis</a>
Chapters 107 and 116</p>
<p><a href="https://stackoverflow.com/users/3267497/">Mshnik</a>
Chapters 47, 50, 54 and 81</p>
<p><a href="https://stackoverflow.com/users/5339966/">mszymborski</a>
Chapter 19</p>
<p><a href="https://stackoverflow.com/users/1638739/">Muhammed
Refaat</a> Chapters 23 and 54</p>
<p><a href="https://stackoverflow.com/users/7087617/">Mukund</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/4467208/">Murat K.</a>
Chapter 126</p>
<p><a href="https://stackoverflow.com/users/2422776/">Mureinik</a>
Chapters 57 and 59</p>
<p><a href="https://stackoverflow.com/users/6479160/">Muto</a> Chapter
57</p>
<p><a href="https://stackoverflow.com/users/5207023/">Mykola
Yashchenko</a> Chapter 44</p>
<p><a href="https://stackoverflow.com/users/1351182/">Myridium</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/3282002/">NageN</a> Chapters
23, 35, 40, 42, 46, 55, 95, 111 and 122</p>
<p><a href="https://stackoverflow.com/users/4848127/">Nagesh
Lakinepally</a> Chapter 6</p>
<p><a href="https://stackoverflow.com/users/95725/">NamshubWriter</a>
Chapters 16 and 88</p>
<p><a href="https://stackoverflow.com/users/5917671/">Naresh Kumar</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/442945/">Nathaniel Ford</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/6532640/">NatNgs</a>
Chapters 47 and 126</p>
<p><a href="https://stackoverflow.com/users/839689/">Nayuki</a> Chapters
22, 23, 42 and 89</p>
<p><a href="https://stackoverflow.com/users/467379/">ncmathsadist</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/3386893/">Nef10</a> Chapter
35</p>
<p><a href="https://stackoverflow.com/users/1369532/">neohope</a>
Chapter 145</p>
<p><a href="https://stackoverflow.com/users/1400768/">nhahtdh</a>
Chapter 80</p>
<p><a href="https://stackoverflow.com/users/2963652/">nicael</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/4760390/">Nicholas J
Panella</a> Chapter 107</p>
<p><a href="https://stackoverflow.com/users/1320066/">Nick Donnelly</a>
Chapter 2</p>
<p><a href="https://stackoverflow.com/users/704104/">nickguletskii</a>
Chapter 126</p>
<p><a href="https://stackoverflow.com/users/682559/">Nicktar</a>
Chapters 16, 42 and 85</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 952</p>
<p><a href="https://stackoverflow.com/users/7980731/">Nikhil R</a>
Chapters 158 and 160</p>
<p><a href="https://stackoverflow.com/users/3219049/">Nikita Kurtin</a>
Chapters 69 and 107</p>
<p><a href="https://stackoverflow.com/users/108207/">Niklas
Rosencrantz</a> Chapter 162</p>
<p><a href="https://stackoverflow.com/users/2119041/">NikolaB</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/4331291/">Nishant123</a>
Chapter 16</p>
<p><a href="https://stackoverflow.com/users/7280124/">nishizawa23</a>
Chapter 148</p>
<p><a href="https://stackoverflow.com/users/2060704/">Nithanim</a>
Chapters 1, 128 and 182</p>
<p><a href="https://stackoverflow.com/users/1520248/">niyasc</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/248082/">nobeh</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/7643517/">Nolequen</a>
Chapters 35, 43 and 81</p>
<p><a href="https://stackoverflow.com/users/1989695/">noscreenname</a>
Chapters 66 and 127</p>
<p><a href="https://stackoverflow.com/users/923179/">Nufail</a> Chapter
20</p>
<p><a href="https://stackoverflow.com/users/1519458/">Nuri Tasdemir</a>
Chapters 1, 11, 23, 40 and 57</p>
<p><a href="https://stackoverflow.com/users/3490881/">nyarasha</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1132499/">Ocracoke</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/823393/">OldCurmudgeon</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/6049263/">OldMcDonald</a>
Chapter 54</p>
<p><a href="https://stackoverflow.com/users/3165602/">Oleg Sklyar</a>
Chapters 24, 25, 47 and 54</p>
<p><a href="https://stackoverflow.com/users/5487099/">OliPro007</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/2345592/">Omar Ayala</a>
Chapter 114</p>
<p><a href="https://stackoverflow.com/users/3133545/">Onur</a> Chapters
11, 23, 47, 66 and 122</p>
<p><a href="https://stackoverflow.com/users/3524867/">orccrusher99</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/865910/">Ordiel</a> Chapter
157</p>
<p><a href="https://stackoverflow.com/users/1807667/">Ortomala Lokni</a>
Chapters 40, 43, 47 and 57</p>
<p><a href="https://stackoverflow.com/users/5792507/">ostrichofevil</a>
Chapter 155</p>
<p><a href="https://stackoverflow.com/users/2164304/">OverCoder</a>
Chapters 35 and 177</p>
<p><a href="https://stackoverflow.com/users/4393565/">P.J.Meisch</a>
Chapters 11, 13, 35, 69, 100, 115 and 130</p>
<p><a href="https://stackoverflow.com/users/1796236/">Pablo</a> Chapter
24</p>
<p><a href="https://stackoverflow.com/users/202694/">Pace</a> Chapter
42</p>
<p><a href="https://stackoverflow.com/users/4199385/">padippist</a>
Chapter 177</p>
<p><a href="https://stackoverflow.com/users/3697273/">paisanco</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/5022249/">Panda</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/5514765/">ParkerHalo</a>
Chapters 9, 10, 40 and 46</p>
<p><a href="https://stackoverflow.com/users/697449/">Paul Bellora</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/4936904/">Pavneet_Singh</a>
Chapter 1</p>
<p><a href="https://stackoverflow.com/users/1691530/">Pawan</a> Chapters
57 and 111</p>
<p><a href="https://stackoverflow.com/users/6057220/">Paweł Albecki</a>
Chapters 23, 24, 35 and 47</p>
<p><a href="https://stackoverflow.com/users/4932834/">PcAF</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/843943/">Peter Rader</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/1504556/">peterh</a> Chapter
72</p>
<p><a href="https://stackoverflow.com/users/5292302/">Petter Friberg</a>
Chapters 3, 11, 24, 35, 42, 47, 56, 57, 69, 73, 82, 103, 117 and 162</p>
<p><a href="https://stackoverflow.com/users/383124/">phant0m</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/1031887/">phatfingers</a>
Chapter 28</p>
<p><a href="https://stackoverflow.com/users/1377224/">philnate</a>
Chapters 47, 52, 73, 74 and 127</p>
<p><a href="https://stackoverflow.com/users/1817722/">Pirate_Jack</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/6849461/">Piyush Baderia</a>
Chapters 11, 89 and 132</p>
<p><a href="https://stackoverflow.com/users/4756763/">PizzaFrog</a>
Chapter 6</p>
<p><a href="https://stackoverflow.com/users/4745695/">Polostor</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/122607/">Pops</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/15880/">Powerlord</a>
Chapters 24 and 63</p>
<p><a href="https://stackoverflow.com/users/1667004/">ppeterka</a>
Chapters 11, 16, 23, 33, 57, 69, 70, 80, 91, 105, 107, 122 and 135</p>
<p><a href="https://stackoverflow.com/users/3048005/">Prasad Reddy</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/1089149/">Prem Singh
Bist</a> Chapter 107</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 953</p>
<p><a href="https://stackoverflow.com/users/2976142/">Přemysl
Šťastný</a> Chapter 11</p>
<p><a href="https://stackoverflow.com/users/5526401/">Pseudonym
Patel</a> Chapter 148</p>
<p><a href="https://stackoverflow.com/users/4161385/">PSN</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/5771658/">PSo</a> Chapters
11 and 86</p>
<p><a href="https://stackoverflow.com/users/349710/">Pujan
Srivastava</a> Chapter 73</p>
<p><a href="https://stackoverflow.com/users/4484822/">QoP</a> Chapters
11 and 23</p>
<p><a href="https://stackoverflow.com/users/1848578/">qxz</a> Chapter
40</p>
<p><a href="https://stackoverflow.com/users/4800355/">Radek
Postołowicz</a> Chapters 10 and 69</p>
<p><a href="https://stackoverflow.com/users/2891664/">Radiodef</a>
Chapters 23 and 24</p>
<p><a href="https://stackoverflow.com/users/5131937/">Radouane
ROUFID</a> Chapters 1, 11, 23, 35, 47, 57, 69, 73 and 182</p>
<p><a href="https://stackoverflow.com/users/3613766/">Rafael Pacheco</a>
Chapter 114</p>
<p><a href="https://stackoverflow.com/users/4156508/">rahul tyagi</a>
Chapter 40</p>
<p><a href="https://stackoverflow.com/users/5557885/">rajadilipkolli</a>
Chapter 24</p>
<p><a href="https://stackoverflow.com/users/3702862/">Rajesh</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/6290553/">Rakitić</a>
Chapters 57 and 182</p>
<p><a href="https://stackoverflow.com/users/5226835/">rakwaht</a>
Chapter 170</p>
<p><a href="https://stackoverflow.com/users/8207228/">Ralf
Kleberhoff</a> Chapters 16 and 41</p>
<p><a href="https://stackoverflow.com/users/2270563/">Ram</a> Chapters
1, 16, 23, 28, 42, 43, 48, 70, 74, 78, 80 and 91</p>
<p><a href="https://stackoverflow.com/users/6392939/">RamenChef</a>
Chapters 1, 11, 23, 33, 40, 69, 73, 79, 86, 106, 126, 151 and 165</p>
<p><a href="https://stackoverflow.com/users/4464702/">RAnders00</a>
Chapters 10, 11, 60 and 77</p>
<p><a href="https://stackoverflow.com/users/4999394/">Ravindra babu</a>
Chapters 54, 103, 111, 126 and 127</p>
<p><a href="https://stackoverflow.com/users/2862341/">Ravindra HV</a>
Chapters 52 and 132</p>
<p><a href="https://stackoverflow.com/users/5416718/">Raviteja</a>
Chapter 85</p>
<p><a href="https://stackoverflow.com/users/737936/">ravthiru</a>
Chapters 28, 57 and 82</p>
<p><a href="https://stackoverflow.com/users/1515111/">rd22</a> Chapters
24, 33, 35, 47 and 126</p>
<p><a href="https://stackoverflow.com/users/971067/">rdonuk</a> Chapters
24 and 69</p>
<p><a href="https://stackoverflow.com/users/7564323/">Rednivrug</a>
Chapter 22</p>
<p><a href="https://stackoverflow.com/users/3599225/">Redterd</a>
Chapter 78</p>
<p><a href="https://stackoverflow.com/users/4787916/">Rens van der
Heijden</a> Chapter 116</p>
<p><a href="https://stackoverflow.com/users/133645/">reto</a> Chapter
57</p>
<p><a href="https://stackoverflow.com/users/948550/">Reut Sharabani</a>
Chapters 1, 23, 40 and 57</p>
<p><a href="https://stackoverflow.com/users/3448799/">richersoon</a>
Chapter 52</p>
<p><a href="https://stackoverflow.com/users/461499/">RobAu</a> Chapters
57, 69 and 77</p>
<p><a href="https://stackoverflow.com/users/6471538/">Robert
Columbia</a> Chapters 10, 23 and 42</p>
<p><a href="https://stackoverflow.com/users/1076463/">Robin</a> Chapter
75</p>
<p><a href="https://stackoverflow.com/users/2935333/">Rocherlee</a>
Chapter 11</p>
<p><a href="https://stackoverflow.com/users/2326914/">Rogério</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/893197/">rokonoid</a>
Chapters 66, 77 and 87</p>
<p><a href="https://stackoverflow.com/users/1374678/">rolve</a> Chapters
23, 47, 56 and 73</p>
<p><a href="https://stackoverflow.com/users/204968/">ronnyfm</a> Chapter
182</p>
<p><a href="https://stackoverflow.com/users/2629460/">Ronon Dex</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/2111876/">RudolphEst</a>
Chapter 132</p>
<p><a href="https://stackoverflow.com/users/1483663/">Ruslan Bes</a>
Chapter 20</p>
<p><a href="https://stackoverflow.com/users/2103383/">RutledgePaulV</a>
Chapter 47</p>
<p><a href="https://stackoverflow.com/users/6127225/">Ryan Cocuzzo</a>
Chapter 48</p>
<p><a href="https://stackoverflow.com/users/2884225/">Ryan Hilbert</a>
Chapter 22</p>
<p><a href="https://stackoverflow.com/users/5230900/">saagarjha</a>
Chapters 56 and 89</p>
<p><a href="https://stackoverflow.com/users/2663579/">SachinSarawgi</a>
Chapters 1 and 131</p>
<p><a href="https://stackoverflow.com/users/6919927/">Saclyr
Barlonium</a> Chapter 73</p>
<p><a href="https://stackoverflow.com/users/6364956/">Sadiq Ali</a>
Chapter 71</p>
<p><a href="https://stackoverflow.com/users/1354334/">Saif</a> Chapter
80</p>
<p><a href="https://stackoverflow.com/users/6837911/">Samk</a> Chapters
33 and 35</p>
<p><a href="https://stackoverflow.com/users/1073786/">Sanandrea</a>
Chapter 182</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 954</p>
<p><a href="https://stackoverflow.com/users/2058368/">Sandeep
Chatterjee</a> Chapter 182</p>
<p><a href="https://stackoverflow.com/users/3782992/">sanjaykumar81</a>
Chapter 117</p>
<p><a href="https://stackoverflow.com/users/6589979/">Santhosh
Ramanan</a> Chapters 74 and 117</p>
<p><a href="https://stackoverflow.com/users/518992/">sargue</a> Chapters
6 and 50</p>
<p><a href="https://stackoverflow.com/users/257501/">Saša Šijak</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/3619691/">Saurabh</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/1203728/">SaWo</a> Chapter
150</p>
<p><a href="https://stackoverflow.com/users/679052/">scorpp</a> Chapter
131</p>
<p><a href="https://stackoverflow.com/users/6702288/">screab</a>
Chapters 130 and 183</p>
<p><a href="https://stackoverflow.com/users/5604676/">Sergii Bishyr</a>
Chapters 23, 57 and 73</p>
<p><a href="https://stackoverflow.com/users/1091453/">sevenforce</a>
Chapters 11, 23, 57 and 74</p>
<p><a href="https://stackoverflow.com/users/6263070/">Shaan</a> Chapter
86</p>
<p><a href="https://stackoverflow.com/users/4909445/">Shettyh</a>
Chapter 127</p>
<p><a href="https://stackoverflow.com/users/669265/">shibli049</a>
Chapter 142</p>
<p><a href="https://stackoverflow.com/users/1654631/">ShivBuyya</a>
Chapters 11, 40 and 77</p>
<p><a href="https://stackoverflow.com/users/1553851/">shmosel</a>
Chapters 23, 35, 43, 57, 67, 88 and 106</p>
<p><a href="https://stackoverflow.com/users/493122/">Shoe</a> Chapters
11, 23 and 57</p>
<p><a href="https://stackoverflow.com/users/2302862/">Siguza</a>
Chapters 1 and 47</p>
<p><a href="https://stackoverflow.com/users/473181/">Simon</a> Chapter
17</p>
<p><a href="https://stackoverflow.com/users/1515052/">Simulant</a>
Chapters 10 and 79</p>
<p><a href="https://stackoverflow.com/users/8009045/">Siva Sainath Reddy
Bandi</a> Chapter 66</p>
<p><a href="https://stackoverflow.com/users/140934/">SjB</a> Chapter
24</p>
<p><a href="https://stackoverflow.com/users/1678392/">skia.heliou</a>
Chapter 16</p>
<p><a href="https://stackoverflow.com/users/7808133/">Sky</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/215166/">Skylar Sutton</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/7089830/">smichel</a>
Chapter 101</p>
<p><a href="https://stackoverflow.com/users/5809504/">Smit</a> Chapter
148</p>
<p><a href="https://stackoverflow.com/users/343299/">solidcell</a>
Chapters 11 and 23</p>
<p><a href="https://stackoverflow.com/users/1919297/">someoneigna</a>
Chapter 79</p>
<p><a href="https://stackoverflow.com/users/2051126/">Somnath Musib</a>
Chapters 26 and 85</p>
<p><a href="https://stackoverflow.com/users/170587/">Spina</a> Chapters
35 and 57</p>
<p><a href="https://stackoverflow.com/users/585398/">SRJ</a> Chapter
57</p>
<p><a href="https://stackoverflow.com/users/2469027/">stackptr</a>
Chapters 1, 23 and 57</p>
<p><a href="https://stackoverflow.com/users/3888450/">Stefan Dollase</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/3314107/">stefanobaghino</a>
Chapter 88</p>
<p><a href="https://stackoverflow.com/users/845034/">steffen</a> Chapter
135</p>
<p><a href="https://stackoverflow.com/users/363573/">Stephan</a> Chapter
124</p>
<p>Chapters 1, 5, 7, 8, 9, 10, 11, 13, 23, 25, 28, 33, 40, 42, 43, 45,
47, 50, 51, 54,</p>
<p><a href="https://stackoverflow.com/users/139985/">Stephen C</a> 57,
59, 67, 69, 73, 77, 79, 81, 82, 85, 86, 88, 89, 95, 102, 103, 106, 126,
127, 130, 131, 132, 133, 134, 135, 137, 139, 146, 147, 148, 169, 177,
178, 182, 183,</p>
<p>184 and 185</p>
<p><a href="https://stackoverflow.com/users/6388243/">Stephen Leppik</a>
Chapters 1, 23, 47, 69 and 73</p>
<p><a href="https://stackoverflow.com/users/2020820/">Steve K</a>
Chapter 57</p>
<p><a href="https://stackoverflow.com/users/2948765/">still_learning</a>
Chapters 54, 69, 77, 86 and 107</p>
<p><a href="https://stackoverflow.com/users/5020253/">Stoyan Dekov</a>
Chapter 107</p>
<p><a href="https://stackoverflow.com/users/4274119/">Sudhir Singh</a>
Chapters 54 and 126</p>
<p><a href="https://stackoverflow.com/users/5829396/">Sugan</a> Chapters
38 and 57</p>
<p><a href="https://stackoverflow.com/users/4804264/">Sujith
Niraikulathan</a> Chapter 3</p>
<p><a href="https://stackoverflow.com/users/6606123/">Suketu Patel</a>
Chapter 34</p>
<p><a href="https://stackoverflow.com/users/676644/">Suminda Sirinath
S.</a> Chapters 127, 139, 146 and 147 <a
href="https://stackoverflow.com/users/676644/">Dharmasena</a></p>
<p><a href="https://stackoverflow.com/users/2637998/">sumit</a> Chapter
85</p>
<p><a href="https://stackoverflow.com/users/1136610/">svsav</a> Chapter
93</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 955</p>
<p><a href="https://stackoverflow.com/users/3375713/">Sнаđошƒа</a>
Chapters 1, 5 and 182</p>
<p><a href="https://stackoverflow.com/users/358688/">taer</a> Chapter
128</p>
<p><a href="https://stackoverflow.com/users/3141068/">tainy</a> Chapter
47</p>
<p><a href="https://stackoverflow.com/users/4669984/">Tarun Maganti</a>
Chapters 17 and 35</p>
<p><a href="https://stackoverflow.com/users/3426328/">TDG</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/6181599/">thatguy</a>
Chapter 22</p>
<p><a href="https://stackoverflow.com/users/2846923/">The Guy with The
Hat</a> Chapter 167</p>
<p><a href="https://stackoverflow.com/users/2193767/">TheLostMind</a>
Chapter 11</p>
<p><a
href="https://stackoverflow.com/users/3807967/">ThePhantomGamer</a>
Chapters 9 and 11</p>
<p><a href="https://stackoverflow.com/users/3615862/">Thisaru Guruge</a>
Chapters 3, 25 and 55</p>
<p><a href="https://stackoverflow.com/users/637853/">Thomas</a> Chapters
23 and 47</p>
<p><a href="https://stackoverflow.com/users/7248342/">Thomas Fritsch</a>
Chapter 91</p>
<p><a href="https://stackoverflow.com/users/7343856/">Thomas Gerot</a>
Chapters 1 and 79</p>
<p><a href="https://stackoverflow.com/users/3551916/">ThunderStruct</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/6342442/">Tim</a> Chapter
107</p>
<p><a href="https://stackoverflow.com/users/69471/">TMN</a> Chapter
10</p>
<p><a href="https://stackoverflow.com/users/3386144/">TNT</a> Chapters
42 and 162</p>
<p><a href="https://stackoverflow.com/users/6579112/">Tobias
Friedinger</a> Chapter 77</p>
<p><a href="https://stackoverflow.com/users/5904368/">Tomasz Bawor</a>
Chapter 104</p>
<p><a href="https://stackoverflow.com/users/4519426/">tonirush</a>
Chapters 40, 130, 162 and 182</p>
<p><a href="https://stackoverflow.com/users/2870532/">Tony</a> Chapter
154</p>
<p><a href="https://stackoverflow.com/users/80075/">Tony BenBrahim</a>
Chapters 11 and 103</p>
<p><a href="https://stackoverflow.com/users/1691457/">Torsten</a>
Chapter 35</p>
<p><a href="https://stackoverflow.com/users/4660897/">Tot Zam</a>
Chapters 80, 93 and 162</p>
<p><a href="https://stackoverflow.com/users/4530326/">tpunt</a> Chapters
23 and 57</p>
<p><a href="https://stackoverflow.com/users/230513/">trashgod</a>
Chapter 184</p>
<p><a href="https://stackoverflow.com/users/1026459/">Travis J</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/4695645/">Tripta Kiroula</a>
Chapter 69</p>
<p><a href="https://stackoverflow.com/users/1743880/">Tunaki</a>
Chapters 23, 57 and 73</p>
<p><a href="https://stackoverflow.com/users/6377268/">TuringTux</a>
Chapters 76 and 100</p>
<p><a href="https://stackoverflow.com/users/1086315/">Tyler Zika</a>
Chapter 48</p>
<p><a href="https://stackoverflow.com/users/3385212/">tynn</a> Chapters
41 and 50</p>
<p><a href="https://stackoverflow.com/users/3067217/">Un3qual</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/3622940/">Unihedron</a>
Chapters 23, 57, 67, 73, 74, 80 and 89</p>
<p><a href="https://stackoverflow.com/users/3278662/">Universal
Electricity</a> Chapters 6 and 103</p>
<p><a href="https://stackoverflow.com/users/1120015/">Uri Agassi</a>
Chapters 74 and 167</p>
<p><a href="https://stackoverflow.com/users/1121883/">user1121883</a>
Chapter 102</p>
<p><a href="https://stackoverflow.com/users/1133275/">user1133275</a>
Chapters 1 and 57</p>
<p><a href="https://stackoverflow.com/users/4945535/">user140547</a>
Chapters 67 and 125</p>
<p><a href="https://stackoverflow.com/users/1803551/">user1803551</a>
Chapters 10, 98 and 101</p>
<p><a href="https://stackoverflow.com/users/5247502/">user187470</a>
Chapter 79</p>
<p><a href="https://stackoverflow.com/users/2296600/">user2296600</a>
Chapter 63</p>
<p><a href="https://stackoverflow.com/users/2314737/">user2314737</a>
Chapter 10</p>
<p><a href="https://stackoverflow.com/users/2683146/">user2683146</a>
Chapters 57 and 67</p>
<p><a href="https://stackoverflow.com/users/3105453/">user3105453</a>
Chapters 88, 131 and 132</p>
<p><a href="https://stackoverflow.com/users/6653173/">user6653173</a>
Chapter 23</p>
<p><a href="https://stackoverflow.com/users/3986374/">Uux</a> Chapter
144</p>
<p><a href="https://stackoverflow.com/users/3786332/">uzaif</a> Chapters
1 and 23</p>
<p><a href="https://stackoverflow.com/users/2074605/">vallismortis</a>
Chapter 91</p>
<p><a href="https://stackoverflow.com/users/6350636/">Vasilis
Vasilatos</a> Chapters 25 and 66</p>
<p><a href="https://stackoverflow.com/users/4563745/">Vasiliy Vlasov</a>
Chapters 24, 52 and 68</p>
<p><a href="https://stackoverflow.com/users/6239674/">VatsalSura</a>
Chapters 75 and 97</p>
<p><a href="https://stackoverflow.com/users/1763356/">Veedrac</a>
Chapter 10</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 956</p>
<p><a href="https://stackoverflow.com/users/1737909/">Ven</a> Chapter
23</p>
<p><a href="https://stackoverflow.com/users/1831987/">VGR</a> Chapters
11, 72, 114 and 185</p>
<p><a href="https://stackoverflow.com/users/4318868/">Viacheslav
Vedenin</a> Chapters 28 and 62</p>
<p><a href="https://stackoverflow.com/users/6854434/">Victor G.</a>
Chapters 23 and 35</p>
<p><a href="https://stackoverflow.com/users/2109492/">victorantunes</a>
Chapter 104</p>
<p><a href="https://stackoverflow.com/users/5888265/">Vin</a> Chapter
1</p>
<p><a href="https://stackoverflow.com/users/2398375/">Vince Emigh</a>
Chapter 79</p>
<p><a href="https://stackoverflow.com/users/466023/">vincentvanjoe</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/1416620/">Vinod Kumar
Kashyap</a> Chapter 16</p>
<p><a href="https://stackoverflow.com/users/4622192/">Vivek Anoop</a>
Chapter 18</p>
<p><a href="https://stackoverflow.com/users/3009130/">Vlad</a> Chapters
47 and 126</p>
<p><a href="https://stackoverflow.com/users/2753863/">Vladimir
Vagaytsev</a> Chapter 89</p>
<p><a href="https://stackoverflow.com/users/1803692/">Vogel612</a>
Chapters 8, 20, 23, 28, 41, 43, 58, 80, 104, 127 and 162</p>
<p><a href="https://stackoverflow.com/users/421602/">vorburger</a>
Chapter 123</p>
<p><a href="https://stackoverflow.com/users/3239417/">vsminkov</a>
Chapter 107</p>
<p><a href="https://stackoverflow.com/users/2063026/">vsnyc</a> Chapter
57</p>
<p><a href="https://stackoverflow.com/users/5647037/">Vucko</a> Chapter
54</p>
<p><a href="https://stackoverflow.com/users/5638612/">vvtx</a> Chapter
11</p>
<p><a href="https://stackoverflow.com/users/1096905/">webo80</a>
Chapters 24 and 73</p>
<p><a
href="https://stackoverflow.com/users/5171540/">WillShackleford</a>
Chapters 102 and 164</p>
<p><a href="https://stackoverflow.com/users/6511967/">Wilson</a>
Chapters 1, 11, 23, 47, 57 and 69</p>
<p><a href="https://stackoverflow.com/users/1979340/">Wolfgang</a>
Chapter 73</p>
<p><a href="https://stackoverflow.com/users/1841181/">xploreraj</a>
Chapters 24, 73 and 88</p>
<p><a href="https://stackoverflow.com/users/3308999/">xTrollxDudex</a>
Chapters 126 and 139</p>
<p><a href="https://stackoverflow.com/users/2615437/">xwoker</a>
Chapters 19 and 74</p>
<p><a href="https://stackoverflow.com/users/3452803/">yitzih</a> Chapter
123</p>
<p><a href="https://stackoverflow.com/users/1470257/">yiwei</a> Chapter
69</p>
<p><a href="https://stackoverflow.com/users/1484017/">Yogesh</a> Chapter
73</p>
<p><a href="https://stackoverflow.com/users/500452/">Yohanes Khosiawan
许先</a> Chapter 4 <a
href="https://stackoverflow.com/users/500452/">汉</a></p>
<p><a href="https://stackoverflow.com/users/11238/">yuku</a> Chapters 11
and 23</p>
<p><a href="https://stackoverflow.com/users/4378400/">Yury Fedorov</a>
Chapters 23 and 107</p>
<p><a href="https://stackoverflow.com/users/7015351/">Zachary David
Saunders</a> Chapter 1</p>
<p><a href="https://stackoverflow.com/users/4232386/">Ze Rubeus</a>
Chapters 57 and 182</p>
<p><a href="https://stackoverflow.com/users/4793951/">Zircon</a>
Chapters 79 and 134</p>
<p><a href="https://stackoverflow.com/users/6366398/">Ħěƀ ё</a> Chapters
78, 120 and 152</p>
<p><a href="https://stackoverflow.com/users/6825151/">Łukasz
Piaszczyk</a> Chapter 19</p>
<p><a href="https://stackoverflow.com/users/982161/">ΦXocę 웃 Пepeúpa
ツ</a> Chapters 11, 17, 21, 23, 25, 43, 78 and 103</p>
<p><a href="https://stackoverflow.com/users/6714194/">ʀ ɴ</a> Chapters 1
and 25</p>
<p><a href="https://goalkicker.com/">GoalKicker.com – Java® Notes for
Professionals</a> 957</p>
<p><span id="You_may_also_like" class="anchor"></span>You may also
like</p>
<p><img src="media/index-982_1.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_1.jpg" /></p>
<p><img src="media/index-982_2.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_2.jpg" /></p>
<p><img src="media/index-982_3.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_3.jpg" /></p>
<p><img src="media/index-982_4.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_4.jpg" /></p>
<p><img src="media/index-982_5.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_5.jpg" /></p>
<p><img src="media/index-982_6.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_6.jpg" /></p>
<p><img src="media/index-982_7.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_7.jpg" /></p>
<p><img src="media/index-982_8.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_8.jpg" /></p>
<p><img src="media/index-982_9.jpeg"
style="width:2.52778in;height:3.5in" alt="index-982_9.jpg" /></p>
</body>
</html>
